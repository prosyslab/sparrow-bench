/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 186 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 216 "/home/khheo/.linuxbrew/Cellar/gcc/5.3.0/lib/gcc/x86_64-unknown-linux-gnu/5.3.0/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 267 "/usr/include/unistd.h"
typedef __intptr_t intptr_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 80 "/usr/include/glob.h"
struct stat;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 122 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 78 "src/core/ngx_config.h"
typedef intptr_t ngx_int_t;
#line 79 "src/core/ngx_config.h"
typedef uintptr_t ngx_uint_t;
#line 15 "src/core/ngx_core.h"
struct ngx_module_s;
#line 15 "src/core/ngx_core.h"
typedef struct ngx_module_s ngx_module_t;
#line 16
struct ngx_conf_s;
#line 16 "src/core/ngx_core.h"
typedef struct ngx_conf_s ngx_conf_t;
#line 17
struct ngx_cycle_s;
#line 17 "src/core/ngx_core.h"
typedef struct ngx_cycle_s ngx_cycle_t;
#line 18
struct ngx_pool_s;
#line 18 "src/core/ngx_core.h"
typedef struct ngx_pool_s ngx_pool_t;
#line 19
struct ngx_chain_s;
#line 19 "src/core/ngx_core.h"
typedef struct ngx_chain_s ngx_chain_t;
#line 20
struct ngx_log_s;
#line 20 "src/core/ngx_core.h"
typedef struct ngx_log_s ngx_log_t;
#line 21
struct ngx_open_file_s;
#line 21 "src/core/ngx_core.h"
typedef struct ngx_open_file_s ngx_open_file_t;
#line 22
struct ngx_command_s;
#line 22 "src/core/ngx_core.h"
typedef struct ngx_command_s ngx_command_t;
#line 23
struct ngx_file_s;
#line 23 "src/core/ngx_core.h"
typedef struct ngx_file_s ngx_file_t;
#line 24
struct ngx_event_s;
#line 24 "src/core/ngx_core.h"
typedef struct ngx_event_s ngx_event_t;
#line 26
struct ngx_connection_s;
#line 26 "src/core/ngx_core.h"
typedef struct ngx_connection_s ngx_connection_t;
#line 98 "src/os/unix/ngx_atomic.h"
typedef unsigned long ngx_atomic_uint_t;
#line 16 "src/core/ngx_rbtree.h"
typedef ngx_uint_t ngx_rbtree_key_t;
#line 20
struct ngx_rbtree_node_s;
#line 20 "src/core/ngx_rbtree.h"
typedef struct ngx_rbtree_node_s ngx_rbtree_node_t;
#line 22 "src/core/ngx_rbtree.h"
struct ngx_rbtree_node_s {
   ngx_rbtree_key_t key ;
   ngx_rbtree_node_t *left ;
   ngx_rbtree_node_t *right ;
   ngx_rbtree_node_t *parent ;
   u_char color ;
   u_char data ;
};
#line 32
struct ngx_rbtree_s;
#line 32 "src/core/ngx_rbtree.h"
typedef struct ngx_rbtree_s ngx_rbtree_t;
#line 37 "src/core/ngx_rbtree.h"
struct ngx_rbtree_s {
   ngx_rbtree_node_t *root ;
   ngx_rbtree_node_t *sentinel ;
   void (*insert)(ngx_rbtree_node_t *root , ngx_rbtree_node_t *node , ngx_rbtree_node_t *sentinel ) ;
};
#line 16 "src/os/unix/ngx_time.h"
typedef ngx_rbtree_key_t ngx_msec_t;
#line 17 "src/os/unix/ngx_socket.h"
typedef int ngx_socket_t;
#line 16 "src/core/ngx_string.h"
struct __anonstruct_ngx_str_t_99 {
   size_t len ;
   u_char *data ;
};
#line 16 "src/core/ngx_string.h"
typedef struct __anonstruct_ngx_str_t_99 ngx_str_t;
#line 16 "src/os/unix/ngx_files.h"
typedef int ngx_fd_t;
#line 17 "src/os/unix/ngx_files.h"
typedef struct stat ngx_file_info_t;
#line 50 "src/core/ngx_log.h"
struct ngx_log_s {
   ngx_uint_t log_level ;
   ngx_open_file_t *file ;
   ngx_atomic_uint_t connection ;
   time_t disk_full_time ;
   u_char *(*handler)(ngx_log_t *log , u_char *buf , size_t len ) ;
   void *data ;
   void (*writer)(ngx_log_t *log , ngx_uint_t level , u_char *buf , size_t len ) ;
   void *wdata ;
   char *action ;
   ngx_log_t *next ;
};
#line 32 "src/core/ngx_palloc.h"
struct ngx_pool_cleanup_s;
#line 32 "src/core/ngx_palloc.h"
typedef struct ngx_pool_cleanup_s ngx_pool_cleanup_t;
#line 34 "src/core/ngx_palloc.h"
struct ngx_pool_cleanup_s {
   void (*handler)(void *data ) ;
   void *data ;
   ngx_pool_cleanup_t *next ;
};
#line 41
struct ngx_pool_large_s;
#line 41 "src/core/ngx_palloc.h"
typedef struct ngx_pool_large_s ngx_pool_large_t;
#line 43 "src/core/ngx_palloc.h"
struct ngx_pool_large_s {
   ngx_pool_large_t *next ;
   void *alloc ;
};
#line 49 "src/core/ngx_palloc.h"
struct __anonstruct_ngx_pool_data_t_109 {
   u_char *last ;
   u_char *end ;
   ngx_pool_t *next ;
   ngx_uint_t failed ;
};
#line 49 "src/core/ngx_palloc.h"
typedef struct __anonstruct_ngx_pool_data_t_109 ngx_pool_data_t;
#line 57 "src/core/ngx_palloc.h"
struct ngx_pool_s {
   ngx_pool_data_t d ;
   size_t max ;
   ngx_pool_t *current ;
   ngx_chain_t *chain ;
   ngx_pool_large_t *large ;
   ngx_pool_cleanup_t *cleanup ;
   ngx_log_t *log ;
};
#line 16 "src/core/ngx_buf.h"
typedef void *ngx_buf_tag_t;
#line 18
struct ngx_buf_s;
#line 18 "src/core/ngx_buf.h"
typedef struct ngx_buf_s ngx_buf_t;
#line 20 "src/core/ngx_buf.h"
struct ngx_buf_s {
   u_char *pos ;
   u_char *last ;
   off_t file_pos ;
   off_t file_last ;
   u_char *start ;
   u_char *end ;
   ngx_buf_tag_t tag ;
   ngx_file_t *file ;
   ngx_buf_t *shadow ;
   unsigned int temporary : 1 ;
   unsigned int memory : 1 ;
   unsigned int mmap : 1 ;
   unsigned int recycled : 1 ;
   unsigned int in_file : 1 ;
   unsigned int flush : 1 ;
   unsigned int sync : 1 ;
   unsigned int last_buf : 1 ;
   unsigned int last_in_chain : 1 ;
   unsigned int last_shadow : 1 ;
   unsigned int temp_file : 1 ;
   int num ;
};
#line 59 "src/core/ngx_buf.h"
struct ngx_chain_s {
   ngx_buf_t *buf ;
   ngx_chain_t *next ;
};
#line 16 "src/core/ngx_queue.h"
struct ngx_queue_s;
#line 16 "src/core/ngx_queue.h"
typedef struct ngx_queue_s ngx_queue_t;
#line 18 "src/core/ngx_queue.h"
struct ngx_queue_s {
   ngx_queue_t *prev ;
   ngx_queue_t *next ;
};
#line 16 "src/core/ngx_array.h"
struct __anonstruct_ngx_array_t_113 {
   void *elts ;
   ngx_uint_t nelts ;
   size_t size ;
   ngx_uint_t nalloc ;
   ngx_pool_t *pool ;
};
#line 16 "src/core/ngx_array.h"
typedef struct __anonstruct_ngx_array_t_113 ngx_array_t;
#line 16 "src/core/ngx_list.h"
struct ngx_list_part_s;
#line 16 "src/core/ngx_list.h"
typedef struct ngx_list_part_s ngx_list_part_t;
#line 18 "src/core/ngx_list.h"
struct ngx_list_part_s {
   void *elts ;
   ngx_uint_t nelts ;
   ngx_list_part_t *next ;
};
#line 25 "src/core/ngx_list.h"
struct __anonstruct_ngx_list_t_114 {
   ngx_list_part_t *last ;
   ngx_list_part_t part ;
   size_t size ;
   ngx_uint_t nalloc ;
   ngx_pool_t *pool ;
};
#line 25 "src/core/ngx_list.h"
typedef struct __anonstruct_ngx_list_t_114 ngx_list_t;
#line 16 "src/core/ngx_file.h"
struct ngx_file_s {
   ngx_fd_t fd ;
   ngx_str_t name ;
   ngx_file_info_t info ;
   off_t offset ;
   off_t sys_offset ;
   ngx_log_t *log ;
   unsigned int valid_info : 1 ;
   unsigned int directio : 1 ;
};
#line 38 "src/core/ngx_cycle.h"
struct ngx_cycle_s {
   void ****conf_ctx ;
   ngx_pool_t *pool ;
   ngx_log_t *log ;
   ngx_log_t new_log ;
   ngx_uint_t log_use_stderr ;
   ngx_connection_t **files ;
   ngx_connection_t *free_connections ;
   ngx_uint_t free_connection_n ;
   ngx_module_t **modules ;
   ngx_uint_t modules_n ;
   ngx_uint_t modules_used ;
   ngx_queue_t reusable_connections_queue ;
   ngx_uint_t reusable_connections_n ;
   ngx_array_t listening ;
   ngx_array_t paths ;
   ngx_array_t config_dump ;
   ngx_rbtree_t config_dump_rbtree ;
   ngx_rbtree_node_t config_dump_sentinel ;
   ngx_list_t open_files ;
   ngx_list_t shared_memory ;
   ngx_uint_t connection_n ;
   ngx_uint_t files_n ;
   ngx_connection_t *connections ;
   ngx_event_t *read_events ;
   ngx_event_t *write_events ;
   ngx_cycle_t *old_cycle ;
   ngx_str_t conf_file ;
   ngx_str_t conf_param ;
   ngx_str_t conf_prefix ;
   ngx_str_t prefix ;
   ngx_str_t lock_file ;
   ngx_str_t hostname ;
};
#line 77 "src/core/ngx_conf_file.h"
struct ngx_command_s {
   ngx_str_t name ;
   ngx_uint_t type ;
   char *(*set)(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
   ngx_uint_t conf ;
   ngx_uint_t offset ;
   void *post ;
};
#line 89 "src/core/ngx_conf_file.h"
struct ngx_open_file_s {
   ngx_fd_t fd ;
   ngx_str_t name ;
   void (*flush)(ngx_open_file_t *file , ngx_log_t *log ) ;
   void *data ;
};
#line 98 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_file_t_153 {
   ngx_file_t file ;
   ngx_buf_t *buffer ;
   ngx_buf_t *dump ;
   ngx_uint_t line ;
};
#line 98 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_file_t_153 ngx_conf_file_t;
#line 116 "src/core/ngx_conf_file.h"
struct ngx_conf_s {
   char *name ;
   ngx_array_t *args ;
   ngx_cycle_t *cycle ;
   ngx_pool_t *pool ;
   ngx_pool_t *temp_pool ;
   ngx_conf_file_t *conf_file ;
   ngx_log_t *log ;
   void *ctx ;
   ngx_uint_t module_type ;
   ngx_uint_t cmd_type ;
   char *(*handler)(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
   void *handler_conf ;
};
#line 222 "src/core/ngx_module.h"
struct ngx_module_s {
   ngx_uint_t ctx_index ;
   ngx_uint_t index ;
   char *name ;
   ngx_uint_t spare0 ;
   ngx_uint_t spare1 ;
   ngx_uint_t version ;
   char const   *signature ;
   void *ctx ;
   ngx_command_t *commands ;
   ngx_uint_t type ;
   ngx_int_t (*init_master)(ngx_log_t *log ) ;
   ngx_int_t (*init_module)(ngx_cycle_t *cycle ) ;
   ngx_int_t (*init_process)(ngx_cycle_t *cycle ) ;
   ngx_int_t (*init_thread)(ngx_cycle_t *cycle ) ;
   void (*exit_thread)(ngx_cycle_t *cycle ) ;
   void (*exit_process)(ngx_cycle_t *cycle ) ;
   void (*exit_master)(ngx_cycle_t *cycle ) ;
   uintptr_t spare_hook0 ;
   uintptr_t spare_hook1 ;
   uintptr_t spare_hook2 ;
   uintptr_t spare_hook3 ;
   uintptr_t spare_hook4 ;
   uintptr_t spare_hook5 ;
   uintptr_t spare_hook6 ;
   uintptr_t spare_hook7 ;
};
#line 16 "src/core/ngx_connection.h"
struct ngx_listening_s;
#line 16 "src/core/ngx_connection.h"
typedef struct ngx_listening_s ngx_listening_t;
#line 18 "src/core/ngx_connection.h"
struct ngx_listening_s {
   ngx_socket_t fd ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   size_t addr_text_max_len ;
   ngx_str_t addr_text ;
   int type ;
   int backlog ;
   int rcvbuf ;
   int sndbuf ;
   int keepidle ;
   int keepintvl ;
   int keepcnt ;
   void (*handler)(ngx_connection_t *c ) ;
   void *servers ;
   ngx_log_t log ;
   ngx_log_t *logp ;
   size_t pool_size ;
   size_t post_accept_buffer_size ;
   ngx_msec_t post_accept_timeout ;
   ngx_listening_t *previous ;
   ngx_connection_t *connection ;
   ngx_uint_t worker ;
   unsigned int open : 1 ;
   unsigned int remain : 1 ;
   unsigned int ignore : 1 ;
   unsigned int bound : 1 ;
   unsigned int inherited : 1 ;
   unsigned int nonblocking_accept : 1 ;
   unsigned int listen : 1 ;
   unsigned int nonblocking : 1 ;
   unsigned int shared : 1 ;
   unsigned int addr_ntop : 1 ;
   unsigned int wildcard : 1 ;
   unsigned int ipv6only : 1 ;
   unsigned int reuseport : 1 ;
   unsigned int add_reuseport : 1 ;
   unsigned int keepalive : 2 ;
   unsigned int deferred_accept : 1 ;
   unsigned int delete_deferred : 1 ;
   unsigned int add_deferred : 1 ;
   int fastopen ;
};
#line 121 "src/core/ngx_connection.h"
struct ngx_connection_s {
   void *data ;
   ngx_event_t *read ;
   ngx_event_t *write ;
   ngx_socket_t fd ;
   ssize_t (*recv)(ngx_connection_t *c , u_char *buf , size_t size ) ;
   ssize_t (*send)(ngx_connection_t *c , u_char *buf , size_t size ) ;
   ssize_t (*recv_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ngx_chain_t *(*send_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ngx_listening_t *listening ;
   off_t sent ;
   ngx_log_t *log ;
   ngx_pool_t *pool ;
   int type ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t addr_text ;
   ngx_str_t proxy_protocol_addr ;
   in_port_t proxy_protocol_port ;
   struct sockaddr *local_sockaddr ;
   socklen_t local_socklen ;
   ngx_buf_t *buffer ;
   ngx_queue_t queue ;
   ngx_atomic_uint_t number ;
   ngx_uint_t requests ;
   unsigned int buffered : 8 ;
   unsigned int log_error : 3 ;
   unsigned int timedout : 1 ;
   unsigned int error : 1 ;
   unsigned int destroyed : 1 ;
   unsigned int idle : 1 ;
   unsigned int reusable : 1 ;
   unsigned int close : 1 ;
   unsigned int shared : 1 ;
   unsigned int sendfile : 1 ;
   unsigned int sndlowat : 1 ;
   unsigned int tcp_nodelay : 2 ;
   unsigned int tcp_nopush : 2 ;
   unsigned int need_last_buf : 1 ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 128 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino64_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 50 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino64_t ino_t;
#line 90 "/usr/include/x86_64-linux-gnu/sys/socket.h"
struct sockaddr_in;
#line 90
struct sockaddr_in6;
#line 90
struct sockaddr_un;
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_82 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_82 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/semaphore.h"
union __anonunion_sem_t_93 {
   char __size[32] ;
   long __align ;
};
#line 36 "/usr/include/x86_64-linux-gnu/bits/semaphore.h"
typedef union __anonunion_sem_t_93 sem_t;
#line 80 "src/core/ngx_config.h"
typedef intptr_t ngx_flag_t;
#line 16 "src/os/unix/ngx_errno.h"
typedef int ngx_err_t;
#line 106 "src/os/unix/ngx_atomic.h"
typedef ngx_atomic_uint_t volatile   ngx_atomic_t;
#line 28 "src/core/ngx_string.h"
struct __anonstruct_ngx_variable_value_t_101 {
   unsigned int len : 28 ;
   unsigned int valid : 1 ;
   unsigned int no_cacheable : 1 ;
   unsigned int not_found : 1 ;
   unsigned int escape : 1 ;
   u_char *data ;
};
#line 28 "src/core/ngx_string.h"
typedef struct __anonstruct_ngx_variable_value_t_101 ngx_variable_value_t;
#line 18 "src/os/unix/ngx_files.h"
typedef ino_t ngx_file_uniq_t;
#line 16 "src/os/unix/ngx_shmem.h"
struct __anonstruct_ngx_shm_t_106 {
   u_char *addr ;
   size_t size ;
   ngx_str_t name ;
   ngx_log_t *log ;
   ngx_uint_t exists ;
};
#line 16 "src/os/unix/ngx_shmem.h"
typedef struct __anonstruct_ngx_shm_t_106 ngx_shm_t;
#line 65 "src/core/ngx_buf.h"
struct __anonstruct_ngx_bufs_t_111 {
   ngx_int_t num ;
   size_t size ;
};
#line 65 "src/core/ngx_buf.h"
typedef struct __anonstruct_ngx_bufs_t_111 ngx_bufs_t;
#line 71
struct ngx_output_chain_ctx_s;
#line 71 "src/core/ngx_buf.h"
typedef struct ngx_output_chain_ctx_s ngx_output_chain_ctx_t;
#line 78 "src/core/ngx_buf.h"
struct ngx_output_chain_ctx_s {
   ngx_buf_t *buf ;
   ngx_chain_t *in ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   unsigned int sendfile : 1 ;
   unsigned int directio : 1 ;
   unsigned int unaligned : 1 ;
   unsigned int need_in_memory : 1 ;
   unsigned int need_in_temp : 1 ;
   unsigned int aio : 1 ;
   off_t alignment ;
   ngx_pool_t *pool ;
   ngx_int_t allocated ;
   ngx_bufs_t bufs ;
   ngx_buf_tag_t tag ;
   ngx_int_t (*output_filter)(void *ctx , ngx_chain_t *in ) ;
   void *filter_ctx ;
};
#line 116 "src/core/ngx_buf.h"
struct __anonstruct_ngx_chain_writer_ctx_t_112 {
   ngx_chain_t *out ;
   ngx_chain_t **last ;
   ngx_connection_t *connection ;
   ngx_pool_t *pool ;
   off_t limit ;
};
#line 116 "src/core/ngx_buf.h"
typedef struct __anonstruct_ngx_chain_writer_ctx_t_112 ngx_chain_writer_ctx_t;
#line 16 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_elt_t_115 {
   void *value ;
   u_short len ;
   u_char name[1] ;
};
#line 16 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_elt_t_115 ngx_hash_elt_t;
#line 23 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_t_116 {
   ngx_hash_elt_t **buckets ;
   ngx_uint_t size ;
};
#line 23 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_t_116 ngx_hash_t;
#line 29 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_wildcard_t_117 {
   ngx_hash_t hash ;
   void *value ;
};
#line 29 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_wildcard_t_117 ngx_hash_wildcard_t;
#line 45 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_combined_t_119 {
   ngx_hash_t hash ;
   ngx_hash_wildcard_t *wc_head ;
   ngx_hash_wildcard_t *wc_tail ;
};
#line 45 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_combined_t_119 ngx_hash_combined_t;
#line 92 "src/core/ngx_hash.h"
struct __anonstruct_ngx_table_elt_t_122 {
   ngx_uint_t hash ;
   ngx_str_t key ;
   ngx_str_t value ;
   u_char *lowcase_key ;
};
#line 92 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_table_elt_t_122 ngx_table_elt_t;
#line 50 "src/core/ngx_file.h"
struct __anonstruct_ngx_path_t_123 {
   ngx_str_t name ;
   size_t len ;
   size_t level[3] ;
   ngx_msec_t (*manager)(void *data ) ;
   ngx_msec_t (*purger)(void *data ) ;
   void (*loader)(void *data ) ;
   void *data ;
   u_char *conf_file ;
   ngx_uint_t line ;
};
#line 50 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_path_t_123 ngx_path_t;
#line 71 "src/core/ngx_file.h"
struct __anonstruct_ngx_temp_file_t_125 {
   ngx_file_t file ;
   off_t offset ;
   ngx_path_t *path ;
   ngx_pool_t *pool ;
   char *warn ;
   ngx_uint_t access ;
   unsigned int log_level : 8 ;
   unsigned int persistent : 1 ;
   unsigned int clean : 1 ;
   unsigned int thread_write : 1 ;
};
#line 71 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_temp_file_t_125 ngx_temp_file_t;
#line 324 "/home/khheo/.linuxbrew/include/pcre.h"
struct real_pcre;
#line 325 "/home/khheo/.linuxbrew/include/pcre.h"
typedef struct real_pcre pcre;
#line 376 "/home/khheo/.linuxbrew/include/pcre.h"
struct pcre_extra {
   unsigned long flags ;
   void *study_data ;
   unsigned long match_limit ;
   void *callout_data ;
   unsigned char const   *tables ;
   unsigned long match_limit_recursion ;
   unsigned char **mark ;
   void *executable_jit ;
};
#line 376 "/home/khheo/.linuxbrew/include/pcre.h"
typedef struct pcre_extra pcre_extra;
#line 23 "src/core/ngx_regex.h"
struct __anonstruct_ngx_regex_t_128 {
   pcre *code ;
   pcre_extra *extra ;
};
#line 23 "src/core/ngx_regex.h"
typedef struct __anonstruct_ngx_regex_t_128 ngx_regex_t;
#line 16 "src/core/ngx_shmtx.h"
struct __anonstruct_ngx_shmtx_sh_t_133 {
   ngx_atomic_t lock ;
   ngx_atomic_t wait ;
};
#line 16 "src/core/ngx_shmtx.h"
typedef struct __anonstruct_ngx_shmtx_sh_t_133 ngx_shmtx_sh_t;
#line 24 "src/core/ngx_shmtx.h"
struct __anonstruct_ngx_shmtx_t_134 {
   ngx_atomic_t *lock ;
   ngx_atomic_t *wait ;
   ngx_uint_t semaphore ;
   sem_t sem ;
   ngx_uint_t spin ;
};
#line 24 "src/core/ngx_shmtx.h"
typedef struct __anonstruct_ngx_shmtx_t_134 ngx_shmtx_t;
#line 16 "src/core/ngx_slab.h"
struct ngx_slab_page_s;
#line 16 "src/core/ngx_slab.h"
typedef struct ngx_slab_page_s ngx_slab_page_t;
#line 18 "src/core/ngx_slab.h"
struct ngx_slab_page_s {
   uintptr_t slab ;
   ngx_slab_page_t *next ;
   uintptr_t prev ;
};
#line 25 "src/core/ngx_slab.h"
struct __anonstruct_ngx_slab_stat_t_135 {
   ngx_uint_t total ;
   ngx_uint_t used ;
   ngx_uint_t reqs ;
   ngx_uint_t fails ;
};
#line 25 "src/core/ngx_slab.h"
typedef struct __anonstruct_ngx_slab_stat_t_135 ngx_slab_stat_t;
#line 34 "src/core/ngx_slab.h"
struct __anonstruct_ngx_slab_pool_t_136 {
   ngx_shmtx_sh_t lock ;
   size_t min_size ;
   size_t min_shift ;
   ngx_slab_page_t *pages ;
   ngx_slab_page_t *last ;
   ngx_slab_page_t free ;
   ngx_slab_stat_t *stats ;
   ngx_uint_t pfree ;
   u_char *start ;
   u_char *end ;
   ngx_shmtx_t mutex ;
   u_char *log_ctx ;
   u_char zero ;
   unsigned int log_nomem : 1 ;
   void *data ;
   void *addr ;
};
#line 34 "src/core/ngx_slab.h"
typedef struct __anonstruct_ngx_slab_pool_t_136 ngx_slab_pool_t;
#line 35 "src/core/ngx_inet.h"
union __anonunion_ngx_sockaddr_t_137 {
   struct sockaddr sockaddr ;
   struct sockaddr_in sockaddr_in ;
   struct sockaddr_in6 sockaddr_in6 ;
   struct sockaddr_un sockaddr_un ;
};
#line 35 "src/core/ngx_inet.h"
typedef union __anonunion_ngx_sockaddr_t_137 ngx_sockaddr_t;
#line 74 "src/core/ngx_inet.h"
struct __anonstruct_ngx_addr_t_142 {
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t name ;
};
#line 74 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_addr_t_142 ngx_addr_t;
#line 25 "src/core/ngx_cycle.h"
struct ngx_shm_zone_s;
#line 25 "src/core/ngx_cycle.h"
typedef struct ngx_shm_zone_s ngx_shm_zone_t;
#line 29 "src/core/ngx_cycle.h"
struct ngx_shm_zone_s {
   void *data ;
   ngx_shm_t shm ;
   ngx_int_t (*init)(ngx_shm_zone_t *zone , void *data ) ;
   void *tag ;
   ngx_uint_t noreuse ;
};
#line 40 "src/core/ngx_resolver.h"
struct ngx_resolver_s;
#line 40 "src/core/ngx_resolver.h"
typedef struct ngx_resolver_s ngx_resolver_t;
#line 56
struct ngx_resolver_ctx_s;
#line 56 "src/core/ngx_resolver.h"
typedef struct ngx_resolver_ctx_s ngx_resolver_ctx_t;
#line 61 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_addr_t_146 {
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t name ;
   u_short priority ;
   u_short weight ;
};
#line 61 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_addr_t_146 ngx_resolver_addr_t;
#line 70 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_srv_t_147 {
   ngx_str_t name ;
   u_short priority ;
   u_short weight ;
   u_short port ;
};
#line 70 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_srv_t_147 ngx_resolver_srv_t;
#line 78 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_srv_name_t_148 {
   ngx_str_t name ;
   u_short priority ;
   u_short weight ;
   u_short port ;
   ngx_resolver_ctx_t *ctx ;
   ngx_int_t state ;
   ngx_uint_t naddrs ;
   ngx_addr_t *addrs ;
};
#line 78 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_srv_name_t_148 ngx_resolver_srv_name_t;
#line 92 "src/core/ngx_resolver.h"
union __anonunion_u_150 {
   in_addr_t addr ;
   in_addr_t *addrs ;
   u_char *cname ;
   ngx_resolver_srv_t *srvs ;
};
#line 92 "src/core/ngx_resolver.h"
union __anonunion_u6_151 {
   struct in6_addr addr6 ;
   struct in6_addr *addrs6 ;
};
#line 92 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_node_t_149 {
   ngx_rbtree_node_t node ;
   ngx_queue_t queue ;
   u_char *name ;
   struct in6_addr addr6 ;
   u_short nlen ;
   u_short qlen ;
   u_char *query ;
   u_char *query6 ;
   union __anonunion_u_150 u ;
   u_char code ;
   u_short naddrs ;
   u_short nsrvs ;
   u_short cnlen ;
   union __anonunion_u6_151 u6 ;
   u_short naddrs6 ;
   time_t expire ;
   time_t valid ;
   uint32_t ttl ;
   unsigned int tcp : 1 ;
   unsigned int tcp6 : 1 ;
   ngx_uint_t last_connection ;
   ngx_resolver_ctx_t *waiting ;
};
#line 92 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_node_t_149 ngx_resolver_node_t;
#line 148 "src/core/ngx_resolver.h"
struct ngx_resolver_s {
   ngx_event_t *event ;
   void *dummy ;
   ngx_log_t *log ;
   ngx_int_t ident ;
   ngx_array_t connections ;
   ngx_uint_t last_connection ;
   ngx_rbtree_t name_rbtree ;
   ngx_rbtree_node_t name_sentinel ;
   ngx_rbtree_t srv_rbtree ;
   ngx_rbtree_node_t srv_sentinel ;
   ngx_rbtree_t addr_rbtree ;
   ngx_rbtree_node_t addr_sentinel ;
   ngx_queue_t name_resend_queue ;
   ngx_queue_t srv_resend_queue ;
   ngx_queue_t addr_resend_queue ;
   ngx_queue_t name_expire_queue ;
   ngx_queue_t srv_expire_queue ;
   ngx_queue_t addr_expire_queue ;
   ngx_uint_t ipv6 ;
   ngx_rbtree_t addr6_rbtree ;
   ngx_rbtree_node_t addr6_sentinel ;
   ngx_queue_t addr6_resend_queue ;
   ngx_queue_t addr6_expire_queue ;
   time_t resend_timeout ;
   time_t tcp_timeout ;
   time_t expire ;
   time_t valid ;
   ngx_uint_t log_level ;
};
#line 195 "src/core/ngx_resolver.h"
struct ngx_resolver_ctx_s {
   ngx_resolver_ctx_t *next ;
   ngx_resolver_t *resolver ;
   ngx_resolver_node_t *node ;
   ngx_int_t ident ;
   ngx_int_t state ;
   ngx_str_t name ;
   ngx_str_t service ;
   time_t valid ;
   ngx_uint_t naddrs ;
   ngx_resolver_addr_t *addrs ;
   ngx_resolver_addr_t addr ;
   struct sockaddr_in sin ;
   ngx_uint_t count ;
   ngx_uint_t nsrvs ;
   ngx_resolver_srv_name_t *srvs ;
   void (*handler)(ngx_resolver_ctx_t *ctx ) ;
   void *data ;
   ngx_msec_t timeout ;
   unsigned int quick : 1 ;
   unsigned int async : 1 ;
   unsigned int cancelable : 1 ;
   ngx_uint_t recursion ;
   ngx_event_t *event ;
};
#line 91 "src/core/ngx_open_file_cache.h"
struct __anonstruct_ngx_open_file_cache_t_162 {
   ngx_rbtree_t rbtree ;
   ngx_rbtree_node_t sentinel ;
   ngx_queue_t expire_queue ;
   ngx_uint_t current ;
   ngx_uint_t max ;
   time_t inactive ;
};
#line 91 "src/core/ngx_open_file_cache.h"
typedef struct __anonstruct_ngx_open_file_cache_t_162 ngx_open_file_cache_t;
#line 16 "src/http/ngx_http.h"
struct ngx_http_request_s;
#line 16 "src/http/ngx_http.h"
typedef struct ngx_http_request_s ngx_http_request_t;
#line 17
struct ngx_http_upstream_s;
#line 17 "src/http/ngx_http.h"
typedef struct ngx_http_upstream_s ngx_http_upstream_t;
#line 18
struct ngx_http_cache_s;
#line 18 "src/http/ngx_http.h"
typedef struct ngx_http_cache_s ngx_http_cache_t;
#line 19
struct ngx_http_file_cache_s;
#line 19 "src/http/ngx_http.h"
typedef struct ngx_http_file_cache_s ngx_http_file_cache_t;
#line 21
struct ngx_http_chunked_s;
#line 21 "src/http/ngx_http.h"
typedef struct ngx_http_chunked_s ngx_http_chunked_t;
#line 22
struct ngx_http_v2_stream_s;
#line 22 "src/http/ngx_http.h"
typedef struct ngx_http_v2_stream_s ngx_http_v2_stream_t;
#line 17 "src/http/ngx_http_variables.h"
typedef ngx_variable_value_t ngx_http_variable_value_t;
#line 66 "src/http/ngx_http_variables.h"
struct __anonstruct_ngx_http_regex_variable_t_171 {
   ngx_uint_t capture ;
   ngx_int_t index ;
};
#line 66 "src/http/ngx_http_variables.h"
typedef struct __anonstruct_ngx_http_regex_variable_t_171 ngx_http_regex_variable_t;
#line 72 "src/http/ngx_http_variables.h"
struct __anonstruct_ngx_http_regex_t_172 {
   ngx_regex_t *regex ;
   ngx_uint_t ncaptures ;
   ngx_http_regex_variable_t *variables ;
   ngx_uint_t nvariables ;
   ngx_str_t name ;
};
#line 72 "src/http/ngx_http_variables.h"
typedef struct __anonstruct_ngx_http_regex_t_172 ngx_http_regex_t;
#line 17 "src/http/ngx_http_config.h"
struct __anonstruct_ngx_http_conf_ctx_t_175 {
   void **main_conf ;
   void **srv_conf ;
   void **loc_conf ;
};
#line 17 "src/http/ngx_http_config.h"
typedef struct __anonstruct_ngx_http_conf_ctx_t_175 ngx_http_conf_ctx_t;
#line 24 "src/http/ngx_http_config.h"
struct __anonstruct_ngx_http_module_t_176 {
   ngx_int_t (*preconfiguration)(ngx_conf_t *cf ) ;
   ngx_int_t (*postconfiguration)(ngx_conf_t *cf ) ;
   void *(*create_main_conf)(ngx_conf_t *cf ) ;
   char *(*init_main_conf)(ngx_conf_t *cf , void *conf ) ;
   void *(*create_srv_conf)(ngx_conf_t *cf ) ;
   char *(*merge_srv_conf)(ngx_conf_t *cf , void *prev , void *conf ) ;
   void *(*create_loc_conf)(ngx_conf_t *cf ) ;
   char *(*merge_loc_conf)(ngx_conf_t *cf , void *prev , void *conf ) ;
};
#line 24 "src/http/ngx_http_config.h"
typedef struct __anonstruct_ngx_http_module_t_176 ngx_http_module_t;
#line 181 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_headers_in_t_180 {
   ngx_list_t headers ;
   ngx_table_elt_t *host ;
   ngx_table_elt_t *connection ;
   ngx_table_elt_t *if_modified_since ;
   ngx_table_elt_t *if_unmodified_since ;
   ngx_table_elt_t *if_match ;
   ngx_table_elt_t *if_none_match ;
   ngx_table_elt_t *user_agent ;
   ngx_table_elt_t *referer ;
   ngx_table_elt_t *content_length ;
   ngx_table_elt_t *content_range ;
   ngx_table_elt_t *content_type ;
   ngx_table_elt_t *range ;
   ngx_table_elt_t *if_range ;
   ngx_table_elt_t *transfer_encoding ;
   ngx_table_elt_t *expect ;
   ngx_table_elt_t *upgrade ;
   ngx_table_elt_t *accept_encoding ;
   ngx_table_elt_t *via ;
   ngx_table_elt_t *authorization ;
   ngx_table_elt_t *keep_alive ;
   ngx_array_t x_forwarded_for ;
   ngx_str_t user ;
   ngx_str_t passwd ;
   ngx_array_t cookies ;
   ngx_str_t server ;
   off_t content_length_n ;
   time_t keep_alive_n ;
   unsigned int connection_type : 2 ;
   unsigned int chunked : 1 ;
   unsigned int msie : 1 ;
   unsigned int msie6 : 1 ;
   unsigned int opera : 1 ;
   unsigned int gecko : 1 ;
   unsigned int chrome : 1 ;
   unsigned int safari : 1 ;
   unsigned int konqueror : 1 ;
};
#line 181 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_headers_in_t_180 ngx_http_headers_in_t;
#line 253 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_headers_out_t_181 {
   ngx_list_t headers ;
   ngx_list_t trailers ;
   ngx_uint_t status ;
   ngx_str_t status_line ;
   ngx_table_elt_t *server ;
   ngx_table_elt_t *date ;
   ngx_table_elt_t *content_length ;
   ngx_table_elt_t *content_encoding ;
   ngx_table_elt_t *location ;
   ngx_table_elt_t *refresh ;
   ngx_table_elt_t *last_modified ;
   ngx_table_elt_t *content_range ;
   ngx_table_elt_t *accept_ranges ;
   ngx_table_elt_t *www_authenticate ;
   ngx_table_elt_t *expires ;
   ngx_table_elt_t *etag ;
   ngx_str_t *override_charset ;
   size_t content_type_len ;
   ngx_str_t content_type ;
   ngx_str_t charset ;
   u_char *content_type_lowcase ;
   ngx_uint_t content_type_hash ;
   ngx_array_t cache_control ;
   off_t content_length_n ;
   off_t content_offset ;
   time_t date_time ;
   time_t last_modified_time ;
};
#line 253 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_headers_out_t_181 ngx_http_headers_out_t;
#line 292 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_request_body_t_182 {
   ngx_temp_file_t *temp_file ;
   ngx_chain_t *bufs ;
   ngx_buf_t *buf ;
   off_t rest ;
   off_t received ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   ngx_http_chunked_t *chunked ;
   void (*post_handler)(ngx_http_request_t *r ) ;
};
#line 292 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_request_body_t_182 ngx_http_request_body_t;
#line 305
struct ngx_http_addr_conf_s;
#line 305 "src/http/ngx_http_request.h"
typedef struct ngx_http_addr_conf_s ngx_http_addr_conf_t;
#line 307 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_connection_t_183 {
   ngx_http_addr_conf_t *addr_conf ;
   ngx_http_conf_ctx_t *conf_ctx ;
   ngx_chain_t *busy ;
   ngx_int_t nbusy ;
   ngx_chain_t *free ;
   unsigned int ssl : 1 ;
   unsigned int proxy_protocol : 1 ;
};
#line 307 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_connection_t_183 ngx_http_connection_t;
#line 328 "src/http/ngx_http_request.h"
typedef void (*ngx_http_cleanup_pt)(void *data );
#line 330
struct ngx_http_cleanup_s;
#line 330 "src/http/ngx_http_request.h"
typedef struct ngx_http_cleanup_s ngx_http_cleanup_t;
#line 332 "src/http/ngx_http_request.h"
struct ngx_http_cleanup_s {
   void (*handler)(void *data ) ;
   void *data ;
   ngx_http_cleanup_t *next ;
};
#line 342 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_post_subrequest_t_184 {
   ngx_int_t (*handler)(ngx_http_request_t *r , void *data , ngx_int_t rc ) ;
   void *data ;
};
#line 342 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_post_subrequest_t_184 ngx_http_post_subrequest_t;
#line 348
struct ngx_http_postponed_request_s;
#line 348 "src/http/ngx_http_request.h"
typedef struct ngx_http_postponed_request_s ngx_http_postponed_request_t;
#line 350 "src/http/ngx_http_request.h"
struct ngx_http_postponed_request_s {
   ngx_http_request_t *request ;
   ngx_chain_t *out ;
   ngx_http_postponed_request_t *next ;
};
#line 357
struct ngx_http_posted_request_s;
#line 357 "src/http/ngx_http_request.h"
typedef struct ngx_http_posted_request_s ngx_http_posted_request_t;
#line 359 "src/http/ngx_http_request.h"
struct ngx_http_posted_request_s {
   ngx_http_request_t *request ;
   ngx_http_posted_request_t *next ;
};
#line 369 "src/http/ngx_http_request.h"
struct ngx_http_request_s {
   uint32_t signature ;
   ngx_connection_t *connection ;
   void **ctx ;
   void **main_conf ;
   void **srv_conf ;
   void **loc_conf ;
   void (*read_event_handler)(ngx_http_request_t *r ) ;
   void (*write_event_handler)(ngx_http_request_t *r ) ;
   ngx_http_cache_t *cache ;
   ngx_http_upstream_t *upstream ;
   ngx_array_t *upstream_states ;
   ngx_pool_t *pool ;
   ngx_buf_t *header_in ;
   ngx_http_headers_in_t headers_in ;
   ngx_http_headers_out_t headers_out ;
   ngx_http_request_body_t *request_body ;
   time_t lingering_time ;
   time_t start_sec ;
   ngx_msec_t start_msec ;
   ngx_uint_t method ;
   ngx_uint_t http_version ;
   ngx_str_t request_line ;
   ngx_str_t uri ;
   ngx_str_t args ;
   ngx_str_t exten ;
   ngx_str_t unparsed_uri ;
   ngx_str_t method_name ;
   ngx_str_t http_protocol ;
   ngx_chain_t *out ;
   ngx_http_request_t *main ;
   ngx_http_request_t *parent ;
   ngx_http_postponed_request_t *postponed ;
   ngx_http_post_subrequest_t *post_subrequest ;
   ngx_http_posted_request_t *posted_requests ;
   ngx_int_t phase_handler ;
   ngx_int_t (*content_handler)(ngx_http_request_t *r ) ;
   ngx_uint_t access_code ;
   ngx_http_variable_value_t *variables ;
   ngx_uint_t ncaptures ;
   int *captures ;
   u_char *captures_data ;
   size_t limit_rate ;
   size_t limit_rate_after ;
   size_t header_size ;
   off_t request_length ;
   ngx_uint_t err_status ;
   ngx_http_connection_t *http_connection ;
   ngx_http_v2_stream_t *stream ;
   u_char *(*log_handler)(ngx_http_request_t *r , ngx_http_request_t *sr , u_char *buf ,
                          size_t len ) ;
   ngx_http_cleanup_t *cleanup ;
   unsigned int count : 16 ;
   unsigned int subrequests : 8 ;
   unsigned int blocked : 8 ;
   unsigned int aio : 1 ;
   unsigned int http_state : 4 ;
   unsigned int complex_uri : 1 ;
   unsigned int quoted_uri : 1 ;
   unsigned int plus_in_uri : 1 ;
   unsigned int space_in_uri : 1 ;
   unsigned int invalid_header : 1 ;
   unsigned int add_uri_to_alias : 1 ;
   unsigned int valid_location : 1 ;
   unsigned int valid_unparsed_uri : 1 ;
   unsigned int uri_changed : 1 ;
   unsigned int uri_changes : 4 ;
   unsigned int request_body_in_single_buf : 1 ;
   unsigned int request_body_in_file_only : 1 ;
   unsigned int request_body_in_persistent_file : 1 ;
   unsigned int request_body_in_clean_file : 1 ;
   unsigned int request_body_file_group_access : 1 ;
   unsigned int request_body_file_log_level : 3 ;
   unsigned int request_body_no_buffering : 1 ;
   unsigned int subrequest_in_memory : 1 ;
   unsigned int waited : 1 ;
   unsigned int cached : 1 ;
   unsigned int gzip_tested : 1 ;
   unsigned int gzip_ok : 1 ;
   unsigned int gzip_vary : 1 ;
   unsigned int proxy : 1 ;
   unsigned int bypass_cache : 1 ;
   unsigned int no_cache : 1 ;
   unsigned int limit_conn_set : 1 ;
   unsigned int limit_req_set : 1 ;
   unsigned int pipeline : 1 ;
   unsigned int chunked : 1 ;
   unsigned int header_only : 1 ;
   unsigned int expect_trailers : 1 ;
   unsigned int keepalive : 1 ;
   unsigned int lingering_close : 1 ;
   unsigned int discard_body : 1 ;
   unsigned int reading_body : 1 ;
   unsigned int internal : 1 ;
   unsigned int error_page : 1 ;
   unsigned int filter_finalize : 1 ;
   unsigned int post_action : 1 ;
   unsigned int request_complete : 1 ;
   unsigned int request_output : 1 ;
   unsigned int header_sent : 1 ;
   unsigned int expect_tested : 1 ;
   unsigned int root_tested : 1 ;
   unsigned int done : 1 ;
   unsigned int logged : 1 ;
   unsigned int buffered : 4 ;
   unsigned int main_filter_need_in_memory : 1 ;
   unsigned int filter_need_in_memory : 1 ;
   unsigned int filter_need_temporary : 1 ;
   unsigned int preserve_body : 1 ;
   unsigned int allow_ranges : 1 ;
   unsigned int subrequest_ranges : 1 ;
   unsigned int single_range : 1 ;
   unsigned int disable_not_modified : 1 ;
   unsigned int stat_reading : 1 ;
   unsigned int stat_writing : 1 ;
   unsigned int stat_processing : 1 ;
   unsigned int background : 1 ;
   unsigned int health_check : 1 ;
   ngx_uint_t state ;
   ngx_uint_t header_hash ;
   ngx_uint_t lowcase_index ;
   u_char lowcase_header[32] ;
   u_char *header_name_start ;
   u_char *header_name_end ;
   u_char *header_start ;
   u_char *header_end ;
   u_char *uri_start ;
   u_char *uri_end ;
   u_char *uri_ext ;
   u_char *args_start ;
   u_char *request_start ;
   u_char *request_end ;
   u_char *method_end ;
   u_char *schema_start ;
   u_char *schema_end ;
   u_char *host_start ;
   u_char *host_end ;
   u_char *port_start ;
   u_char *port_end ;
   unsigned int http_minor : 16 ;
   unsigned int http_major : 16 ;
};
#line 66 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_complex_value_t_188 {
   ngx_str_t value ;
   ngx_uint_t *flushes ;
   void *lengths ;
   void *values ;
};
#line 66 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_complex_value_t_188 ngx_http_complex_value_t;
#line 30 "src/event/ngx_event.h"
struct ngx_event_s {
   void *data ;
   unsigned int write : 1 ;
   unsigned int accept : 1 ;
   unsigned int instance : 1 ;
   unsigned int active : 1 ;
   unsigned int disabled : 1 ;
   unsigned int ready : 1 ;
   unsigned int oneshot : 1 ;
   unsigned int complete : 1 ;
   unsigned int eof : 1 ;
   unsigned int error : 1 ;
   unsigned int timedout : 1 ;
   unsigned int timer_set : 1 ;
   unsigned int delayed : 1 ;
   unsigned int deferred_accept : 1 ;
   unsigned int pending_eof : 1 ;
   unsigned int posted : 1 ;
   unsigned int closed : 1 ;
   unsigned int channel : 1 ;
   unsigned int resolver : 1 ;
   unsigned int cancelable : 1 ;
   unsigned int available : 1 ;
   void (*handler)(ngx_event_t *ev ) ;
   ngx_uint_t index ;
   ngx_log_t *log ;
   ngx_rbtree_node_t timer ;
   ngx_queue_t queue ;
};
#line 22 "src/event/ngx_event_connect.h"
struct ngx_peer_connection_s;
#line 22 "src/event/ngx_event_connect.h"
typedef struct ngx_peer_connection_s ngx_peer_connection_t;
#line 36 "src/event/ngx_event_connect.h"
struct ngx_peer_connection_s {
   ngx_connection_t *connection ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t *name ;
   ngx_uint_t tries ;
   ngx_msec_t start_time ;
   ngx_int_t (*get)(ngx_peer_connection_t *pc , void *data ) ;
   void (*free)(ngx_peer_connection_t *pc , void *data , ngx_uint_t state ) ;
   void (*notify)(ngx_peer_connection_t *pc , void *data , ngx_uint_t type ) ;
   void *data ;
   ngx_addr_t *local ;
   int type ;
   int rcvbuf ;
   ngx_log_t *log ;
   unsigned int cached : 1 ;
   unsigned int transparent : 1 ;
   unsigned int log_error : 2 ;
};
#line 17 "src/event/ngx_event_pipe.h"
struct ngx_event_pipe_s;
#line 17 "src/event/ngx_event_pipe.h"
typedef struct ngx_event_pipe_s ngx_event_pipe_t;
#line 25 "src/event/ngx_event_pipe.h"
struct ngx_event_pipe_s {
   ngx_connection_t *upstream ;
   ngx_connection_t *downstream ;
   ngx_chain_t *free_raw_bufs ;
   ngx_chain_t *in ;
   ngx_chain_t **last_in ;
   ngx_chain_t *writing ;
   ngx_chain_t *out ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   ngx_int_t (*input_filter)(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
   void *input_ctx ;
   ngx_int_t (*output_filter)(void *data , ngx_chain_t *chain ) ;
   void *output_ctx ;
   unsigned int read : 1 ;
   unsigned int cacheable : 1 ;
   unsigned int single_buf : 1 ;
   unsigned int free_bufs : 1 ;
   unsigned int upstream_done : 1 ;
   unsigned int upstream_error : 1 ;
   unsigned int upstream_eof : 1 ;
   unsigned int upstream_blocked : 1 ;
   unsigned int downstream_done : 1 ;
   unsigned int downstream_error : 1 ;
   unsigned int cyclic_temp_file : 1 ;
   unsigned int aio : 1 ;
   ngx_int_t allocated ;
   ngx_bufs_t bufs ;
   ngx_buf_tag_t tag ;
   ssize_t busy_size ;
   off_t read_length ;
   off_t length ;
   off_t max_temp_file_size ;
   ssize_t temp_file_write_size ;
   ngx_msec_t read_timeout ;
   ngx_msec_t send_timeout ;
   ssize_t send_lowat ;
   ngx_pool_t *pool ;
   ngx_log_t *log ;
   ngx_chain_t *preread_bufs ;
   size_t preread_size ;
   ngx_buf_t *buf_to_file ;
   size_t limit_rate ;
   time_t start_sec ;
   ngx_temp_file_t *temp_file ;
   int num ;
};
#line 59 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_state_t_206 {
   ngx_uint_t status ;
   ngx_msec_t response_time ;
   ngx_msec_t connect_time ;
   ngx_msec_t header_time ;
   off_t response_length ;
   off_t bytes_received ;
   ngx_str_t *peer ;
};
#line 59 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_state_t_206 ngx_http_upstream_state_t;
#line 71 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_main_conf_t_207 {
   ngx_hash_t headers_in_hash ;
   ngx_array_t upstreams ;
};
#line 71 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_main_conf_t_207 ngx_http_upstream_main_conf_t;
#line 77
struct ngx_http_upstream_srv_conf_s;
#line 77 "src/http/ngx_http_upstream.h"
typedef struct ngx_http_upstream_srv_conf_s ngx_http_upstream_srv_conf_t;
#line 85 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_peer_t_208 {
   ngx_int_t (*init_upstream)(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
   ngx_int_t (*init)(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
   void *data ;
};
#line 85 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_peer_t_208 ngx_http_upstream_peer_t;
#line 119 "src/http/ngx_http_upstream.h"
struct ngx_http_upstream_srv_conf_s {
   ngx_http_upstream_peer_t peer ;
   void **srv_conf ;
   ngx_array_t *servers ;
   ngx_uint_t flags ;
   ngx_str_t host ;
   u_char *file_name ;
   ngx_uint_t line ;
   in_port_t port ;
   ngx_uint_t no_port ;
   ngx_shm_zone_t *shm_zone ;
};
#line 138 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_local_t_210 {
   ngx_addr_t *addr ;
   ngx_http_complex_value_t *value ;
   ngx_uint_t transparent ;
};
#line 138 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_local_t_210 ngx_http_upstream_local_t;
#line 147 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_conf_t_211 {
   ngx_http_upstream_srv_conf_t *upstream ;
   ngx_msec_t connect_timeout ;
   ngx_msec_t send_timeout ;
   ngx_msec_t read_timeout ;
   ngx_msec_t next_upstream_timeout ;
   size_t send_lowat ;
   size_t buffer_size ;
   size_t limit_rate ;
   size_t busy_buffers_size ;
   size_t max_temp_file_size ;
   size_t temp_file_write_size ;
   size_t busy_buffers_size_conf ;
   size_t max_temp_file_size_conf ;
   size_t temp_file_write_size_conf ;
   ngx_bufs_t bufs ;
   ngx_uint_t ignore_headers ;
   ngx_uint_t next_upstream ;
   ngx_uint_t store_access ;
   ngx_uint_t next_upstream_tries ;
   ngx_flag_t buffering ;
   ngx_flag_t request_buffering ;
   ngx_flag_t pass_request_headers ;
   ngx_flag_t pass_request_body ;
   ngx_flag_t ignore_client_abort ;
   ngx_flag_t intercept_errors ;
   ngx_flag_t cyclic_temp_file ;
   ngx_flag_t force_ranges ;
   ngx_path_t *temp_path ;
   ngx_hash_t hide_headers_hash ;
   ngx_array_t *hide_headers ;
   ngx_array_t *pass_headers ;
   ngx_http_upstream_local_t *local ;
   ngx_shm_zone_t *cache_zone ;
   ngx_http_complex_value_t *cache_value ;
   ngx_uint_t cache_min_uses ;
   ngx_uint_t cache_use_stale ;
   ngx_uint_t cache_methods ;
   off_t cache_max_range_offset ;
   ngx_flag_t cache_lock ;
   ngx_msec_t cache_lock_timeout ;
   ngx_msec_t cache_lock_age ;
   ngx_flag_t cache_revalidate ;
   ngx_flag_t cache_convert_head ;
   ngx_flag_t cache_background_update ;
   ngx_array_t *cache_valid ;
   ngx_array_t *cache_bypass ;
   ngx_array_t *cache_purge ;
   ngx_array_t *no_cache ;
   ngx_array_t *store_lengths ;
   ngx_array_t *store_values ;
   int cache : 2 ;
   int store : 2 ;
   unsigned int intercept_404 : 1 ;
   unsigned int change_buffering : 1 ;
   ngx_str_t module ;
};
#line 147 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_conf_t_211 ngx_http_upstream_conf_t;
#line 251 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_headers_in_t_213 {
   ngx_list_t headers ;
   ngx_uint_t status_n ;
   ngx_str_t status_line ;
   ngx_table_elt_t *status ;
   ngx_table_elt_t *date ;
   ngx_table_elt_t *server ;
   ngx_table_elt_t *connection ;
   ngx_table_elt_t *expires ;
   ngx_table_elt_t *etag ;
   ngx_table_elt_t *x_accel_expires ;
   ngx_table_elt_t *x_accel_redirect ;
   ngx_table_elt_t *x_accel_limit_rate ;
   ngx_table_elt_t *content_type ;
   ngx_table_elt_t *content_length ;
   ngx_table_elt_t *last_modified ;
   ngx_table_elt_t *location ;
   ngx_table_elt_t *accept_ranges ;
   ngx_table_elt_t *www_authenticate ;
   ngx_table_elt_t *transfer_encoding ;
   ngx_table_elt_t *vary ;
   ngx_table_elt_t *content_encoding ;
   ngx_array_t cache_control ;
   ngx_array_t cookies ;
   off_t content_length_n ;
   time_t last_modified_time ;
   unsigned int connection_close : 1 ;
   unsigned int chunked : 1 ;
};
#line 251 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_headers_in_t_213 ngx_http_upstream_headers_in_t;
#line 293 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_resolved_t_214 {
   ngx_str_t host ;
   in_port_t port ;
   ngx_uint_t no_port ;
   ngx_uint_t naddrs ;
   ngx_resolver_addr_t *addrs ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t name ;
   ngx_resolver_ctx_t *ctx ;
};
#line 293 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_resolved_t_214 ngx_http_upstream_resolved_t;
#line 313 "src/http/ngx_http_upstream.h"
struct ngx_http_upstream_s {
   void (*read_event_handler)(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
   void (*write_event_handler)(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
   ngx_peer_connection_t peer ;
   ngx_event_pipe_t *pipe ;
   ngx_chain_t *request_bufs ;
   ngx_output_chain_ctx_t output ;
   ngx_chain_writer_ctx_t writer ;
   ngx_http_upstream_conf_t *conf ;
   ngx_http_upstream_srv_conf_t *upstream ;
   ngx_array_t *caches ;
   ngx_http_upstream_headers_in_t headers_in ;
   ngx_http_upstream_resolved_t *resolved ;
   ngx_buf_t from_client ;
   ngx_buf_t buffer ;
   off_t length ;
   ngx_chain_t *out_bufs ;
   ngx_chain_t *busy_bufs ;
   ngx_chain_t *free_bufs ;
   ngx_int_t (*input_filter_init)(void *data ) ;
   ngx_int_t (*input_filter)(void *data , ssize_t bytes ) ;
   void *input_filter_ctx ;
   ngx_int_t (*create_key)(ngx_http_request_t *r ) ;
   ngx_int_t (*create_request)(ngx_http_request_t *r ) ;
   ngx_int_t (*reinit_request)(ngx_http_request_t *r ) ;
   ngx_int_t (*process_header)(ngx_http_request_t *r ) ;
   void (*abort_request)(ngx_http_request_t *r ) ;
   void (*finalize_request)(ngx_http_request_t *r , ngx_int_t rc ) ;
   ngx_int_t (*rewrite_redirect)(ngx_http_request_t *r , ngx_table_elt_t *h , size_t prefix ) ;
   ngx_int_t (*rewrite_cookie)(ngx_http_request_t *r , ngx_table_elt_t *h ) ;
   ngx_msec_t timeout ;
   ngx_http_upstream_state_t *state ;
   ngx_str_t method ;
   ngx_str_t schema ;
   ngx_str_t uri ;
   ngx_http_cleanup_pt *cleanup ;
   unsigned int store : 1 ;
   unsigned int cacheable : 1 ;
   unsigned int accel : 1 ;
   unsigned int ssl : 1 ;
   unsigned int cache_status : 3 ;
   unsigned int buffering : 1 ;
   unsigned int keepalive : 1 ;
   unsigned int upgrade : 1 ;
   unsigned int request_sent : 1 ;
   unsigned int request_body_sent : 1 ;
   unsigned int header_sent : 1 ;
};
#line 17 "src/http/ngx_http_upstream_round_robin.h"
struct ngx_http_upstream_rr_peer_s;
#line 17 "src/http/ngx_http_upstream_round_robin.h"
typedef struct ngx_http_upstream_rr_peer_s ngx_http_upstream_rr_peer_t;
#line 19 "src/http/ngx_http_upstream_round_robin.h"
struct ngx_http_upstream_rr_peer_s {
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t name ;
   ngx_str_t server ;
   ngx_int_t current_weight ;
   ngx_int_t effective_weight ;
   ngx_int_t weight ;
   ngx_uint_t conns ;
   ngx_uint_t max_conns ;
   ngx_uint_t fails ;
   time_t accessed ;
   time_t checked ;
   ngx_uint_t max_fails ;
   time_t fail_timeout ;
   ngx_msec_t slow_start ;
   ngx_msec_t start_time ;
   ngx_uint_t down ;
   ngx_atomic_t lock ;
   ngx_http_upstream_rr_peer_t *next ;
};
#line 59
struct ngx_http_upstream_rr_peers_s;
#line 59 "src/http/ngx_http_upstream_round_robin.h"
typedef struct ngx_http_upstream_rr_peers_s ngx_http_upstream_rr_peers_t;
#line 61 "src/http/ngx_http_upstream_round_robin.h"
struct ngx_http_upstream_rr_peers_s {
   ngx_uint_t number ;
   ngx_slab_pool_t *shpool ;
   ngx_atomic_t rwlock ;
   ngx_http_upstream_rr_peers_t *zone_next ;
   ngx_uint_t total_weight ;
   unsigned int single : 1 ;
   unsigned int weighted : 1 ;
   ngx_str_t *name ;
   ngx_http_upstream_rr_peers_t *next ;
   ngx_http_upstream_rr_peer_t *peer ;
};
#line 63 "src/http/ngx_http_core_module.h"
struct ngx_http_location_tree_node_s;
#line 63 "src/http/ngx_http_core_module.h"
typedef struct ngx_http_location_tree_node_s ngx_http_location_tree_node_t;
#line 64
struct ngx_http_core_loc_conf_s;
#line 64 "src/http/ngx_http_core_module.h"
typedef struct ngx_http_core_loc_conf_s ngx_http_core_loc_conf_t;
#line 180 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_core_srv_conf_t_223 {
   ngx_array_t server_names ;
   ngx_http_conf_ctx_t *ctx ;
   ngx_str_t server_name ;
   size_t connection_pool_size ;
   size_t request_pool_size ;
   size_t client_header_buffer_size ;
   ngx_bufs_t large_client_header_buffers ;
   ngx_msec_t client_header_timeout ;
   ngx_flag_t ignore_invalid_headers ;
   ngx_flag_t merge_slashes ;
   ngx_flag_t underscores_in_headers ;
   unsigned int listen : 1 ;
   unsigned int captures : 1 ;
   ngx_http_core_loc_conf_t **named_locations ;
};
#line 180 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_core_srv_conf_t_223 ngx_http_core_srv_conf_t;
#line 213 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_server_name_t_224 {
   ngx_http_regex_t *regex ;
   ngx_http_core_srv_conf_t *server ;
   ngx_str_t name ;
};
#line 213 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_server_name_t_224 ngx_http_server_name_t;
#line 222 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_virtual_names_t_225 {
   ngx_hash_combined_t names ;
   ngx_uint_t nregex ;
   ngx_http_server_name_t *regex ;
};
#line 222 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_virtual_names_t_225 ngx_http_virtual_names_t;
#line 230 "src/http/ngx_http_core_module.h"
struct ngx_http_addr_conf_s {
   ngx_http_core_srv_conf_t *default_server ;
   ngx_http_virtual_names_t *virtual_names ;
   unsigned int ssl : 1 ;
   unsigned int http2 : 1 ;
   unsigned int proxy_protocol : 1 ;
};
#line 298 "src/http/ngx_http_core_module.h"
struct ngx_http_core_loc_conf_s {
   ngx_str_t name ;
   ngx_http_regex_t *regex ;
   unsigned int noname : 1 ;
   unsigned int lmt_excpt : 1 ;
   unsigned int named : 1 ;
   unsigned int exact_match : 1 ;
   unsigned int noregex : 1 ;
   unsigned int auto_redirect : 1 ;
   unsigned int gzip_disable_msie6 : 2 ;
   unsigned int gzip_disable_degradation : 2 ;
   ngx_http_location_tree_node_t *static_locations ;
   ngx_http_core_loc_conf_t **regex_locations ;
   void **loc_conf ;
   uint32_t limit_except ;
   void **limit_except_loc_conf ;
   ngx_int_t (*handler)(ngx_http_request_t *r ) ;
   size_t alias ;
   ngx_str_t root ;
   ngx_str_t post_action ;
   ngx_array_t *root_lengths ;
   ngx_array_t *root_values ;
   ngx_array_t *types ;
   ngx_hash_t types_hash ;
   ngx_str_t default_type ;
   off_t client_max_body_size ;
   off_t directio ;
   off_t directio_alignment ;
   size_t client_body_buffer_size ;
   size_t send_lowat ;
   size_t postpone_output ;
   size_t limit_rate ;
   size_t limit_rate_after ;
   size_t sendfile_max_chunk ;
   size_t read_ahead ;
   ngx_msec_t client_body_timeout ;
   ngx_msec_t send_timeout ;
   ngx_msec_t keepalive_timeout ;
   ngx_msec_t lingering_time ;
   ngx_msec_t lingering_timeout ;
   ngx_msec_t resolver_timeout ;
   ngx_resolver_t *resolver ;
   time_t keepalive_header ;
   ngx_uint_t keepalive_requests ;
   ngx_uint_t keepalive_disable ;
   ngx_uint_t satisfy ;
   ngx_uint_t lingering_close ;
   ngx_uint_t if_modified_since ;
   ngx_uint_t max_ranges ;
   ngx_uint_t client_body_in_file_only ;
   ngx_flag_t client_body_in_single_buffer ;
   ngx_flag_t internal ;
   ngx_flag_t sendfile ;
   ngx_flag_t aio ;
   ngx_flag_t aio_write ;
   ngx_flag_t tcp_nopush ;
   ngx_flag_t tcp_nodelay ;
   ngx_flag_t reset_timedout_connection ;
   ngx_flag_t absolute_redirect ;
   ngx_flag_t server_name_in_redirect ;
   ngx_flag_t port_in_redirect ;
   ngx_flag_t msie_padding ;
   ngx_flag_t msie_refresh ;
   ngx_flag_t log_not_found ;
   ngx_flag_t log_subrequest ;
   ngx_flag_t recursive_error_pages ;
   ngx_uint_t server_tokens ;
   ngx_flag_t chunked_transfer_encoding ;
   ngx_flag_t etag ;
   ngx_flag_t gzip_vary ;
   ngx_uint_t gzip_http_version ;
   ngx_uint_t gzip_proxied ;
   ngx_array_t *gzip_disable ;
   ngx_uint_t disable_symlinks ;
   ngx_http_complex_value_t *disable_symlinks_from ;
   ngx_array_t *error_pages ;
   ngx_path_t *client_body_temp_path ;
   ngx_open_file_cache_t *open_file_cache ;
   time_t open_file_cache_valid ;
   ngx_uint_t open_file_cache_min_uses ;
   ngx_flag_t open_file_cache_errors ;
   ngx_flag_t open_file_cache_events ;
   ngx_log_t *error_log ;
   ngx_uint_t types_hash_max_size ;
   ngx_uint_t types_hash_bucket_size ;
   ngx_queue_t *locations ;
};
#line 450 "src/http/ngx_http_core_module.h"
struct ngx_http_location_tree_node_s {
   ngx_http_location_tree_node_t *left ;
   ngx_http_location_tree_node_t *right ;
   ngx_http_location_tree_node_t *tree ;
   ngx_http_core_loc_conf_t *exact ;
   ngx_http_core_loc_conf_t *inclusive ;
   u_char auto_redirect ;
   u_char len ;
   u_char name[1] ;
};
#line 39 "src/http/ngx_http_cache.h"
struct __anonstruct_ngx_http_file_cache_node_t_234 {
   ngx_rbtree_node_t node ;
   ngx_queue_t queue ;
   u_char key[16UL - sizeof(ngx_rbtree_key_t )] ;
   unsigned int count : 20 ;
   unsigned int uses : 10 ;
   unsigned int valid_msec : 10 ;
   unsigned int error : 10 ;
   unsigned int exists : 1 ;
   unsigned int updating : 1 ;
   unsigned int deleting : 1 ;
   unsigned int purged : 1 ;
   ngx_file_uniq_t uniq ;
   time_t expire ;
   time_t valid_sec ;
   size_t body_start ;
   off_t fs_size ;
   ngx_msec_t lock_time ;
};
#line 39 "src/http/ngx_http_cache.h"
typedef struct __anonstruct_ngx_http_file_cache_node_t_234 ngx_http_file_cache_node_t;
#line 65 "src/http/ngx_http_cache.h"
struct ngx_http_cache_s {
   ngx_file_t file ;
   ngx_array_t keys ;
   uint32_t crc32 ;
   u_char key[16] ;
   u_char main[16] ;
   ngx_file_uniq_t uniq ;
   time_t valid_sec ;
   time_t updating_sec ;
   time_t error_sec ;
   time_t last_modified ;
   time_t date ;
   ngx_str_t etag ;
   ngx_str_t vary ;
   u_char variant[16] ;
   size_t header_start ;
   size_t body_start ;
   off_t length ;
   off_t fs_size ;
   ngx_uint_t min_uses ;
   ngx_uint_t error ;
   ngx_uint_t valid_msec ;
   ngx_uint_t vary_tag ;
   ngx_buf_t *buf ;
   ngx_http_file_cache_t *file_cache ;
   ngx_http_file_cache_node_t *node ;
   ngx_msec_t lock_timeout ;
   ngx_msec_t lock_age ;
   ngx_msec_t lock_time ;
   ngx_msec_t wait_time ;
   ngx_event_t wait_event ;
   unsigned int lock : 1 ;
   unsigned int waiting : 1 ;
   unsigned int updated : 1 ;
   unsigned int updating : 1 ;
   unsigned int exists : 1 ;
   unsigned int temp_file : 1 ;
   unsigned int purged : 1 ;
   unsigned int reading : 1 ;
   unsigned int secondary : 1 ;
   unsigned int background : 1 ;
   unsigned int stale_updating : 1 ;
   unsigned int stale_error : 1 ;
};
#line 145 "src/http/ngx_http_cache.h"
struct __anonstruct_ngx_http_file_cache_sh_t_236 {
   ngx_rbtree_t rbtree ;
   ngx_rbtree_node_t sentinel ;
   ngx_queue_t queue ;
   ngx_atomic_t cold ;
   ngx_atomic_t loading ;
   off_t size ;
   ngx_uint_t count ;
   ngx_uint_t watermark ;
};
#line 145 "src/http/ngx_http_cache.h"
typedef struct __anonstruct_ngx_http_file_cache_sh_t_236 ngx_http_file_cache_sh_t;
#line 157 "src/http/ngx_http_cache.h"
struct ngx_http_file_cache_s {
   ngx_http_file_cache_sh_t *sh ;
   ngx_slab_pool_t *shpool ;
   ngx_path_t *path ;
   off_t max_size ;
   size_t bsize ;
   time_t inactive ;
   time_t fail_time ;
   ngx_uint_t files ;
   ngx_uint_t loader_files ;
   ngx_msec_t last ;
   ngx_msec_t loader_sleep ;
   ngx_msec_t loader_threshold ;
   ngx_uint_t manager_files ;
   ngx_msec_t manager_sleep ;
   ngx_msec_t manager_threshold ;
   ngx_shm_zone_t *shm_zone ;
   ngx_uint_t use_temp_path ;
};
#line 59 "src/http/ngx_http.h"
struct ngx_http_chunked_s {
   ngx_uint_t state ;
   off_t size ;
   off_t length ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
struct __anonstruct_ngx_http_upstream_keepalive_srv_conf_t_242 {
   ngx_uint_t max_cached ;
   ngx_queue_t cache ;
   ngx_queue_t free ;
   ngx_int_t (*original_init_upstream)(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
   ngx_int_t (*original_init_peer)(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
typedef struct __anonstruct_ngx_http_upstream_keepalive_srv_conf_t_242 ngx_http_upstream_keepalive_srv_conf_t;
#line 25 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
struct __anonstruct_ngx_http_upstream_keepalive_cache_t_243 {
   ngx_http_upstream_keepalive_srv_conf_t *conf ;
   ngx_queue_t queue ;
   ngx_connection_t *connection ;
   socklen_t socklen ;
   ngx_sockaddr_t sockaddr ;
};
#line 25 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
typedef struct __anonstruct_ngx_http_upstream_keepalive_cache_t_243 ngx_http_upstream_keepalive_cache_t;
#line 37 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
struct __anonstruct_ngx_http_upstream_keepalive_peer_data_t_244 {
   ngx_http_upstream_keepalive_srv_conf_t *conf ;
   ngx_http_upstream_t *upstream ;
   void *data ;
   ngx_int_t (*original_get_peer)(ngx_peer_connection_t *pc , void *data ) ;
   void (*original_free_peer)(ngx_peer_connection_t *pc , void *data , ngx_uint_t state ) ;
};
#line 37 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
typedef struct __anonstruct_ngx_http_upstream_keepalive_peer_data_t_244 ngx_http_upstream_keepalive_peer_data_t;
#line 16 "src/core/ngx_times.h"
struct __anonstruct_ngx_time_t_132 {
   time_t sec ;
   ngx_uint_t msec ;
   ngx_int_t gmtoff ;
};
#line 16 "src/core/ngx_times.h"
typedef struct __anonstruct_ngx_time_t_132 ngx_time_t;
#line 127 "src/http/ngx_http_upstream_round_robin.h"
struct __anonstruct_ngx_http_upstream_rr_peer_data_t_217 {
   ngx_uint_t config ;
   ngx_http_upstream_rr_peers_t *peers ;
   ngx_http_upstream_rr_peer_t *current ;
   uintptr_t *tried ;
   uintptr_t data ;
};
#line 127 "src/http/ngx_http_upstream_round_robin.h"
typedef struct __anonstruct_ngx_http_upstream_rr_peer_data_t_217 ngx_http_upstream_rr_peer_data_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
struct __anonstruct_ngx_http_upstream_ip_hash_peer_data_t_242 {
   ngx_http_upstream_rr_peer_data_t rrp ;
   ngx_uint_t hash ;
   u_char addrlen ;
   u_char *addr ;
   u_char tries ;
   ngx_int_t (*get_rr_peer)(ngx_peer_connection_t *pc , void *data ) ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_ip_hash_peer_data_t_242 ngx_http_upstream_ip_hash_peer_data_t;
#line 74 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_compile_complex_value_t_189 {
   ngx_conf_t *cf ;
   ngx_str_t *value ;
   ngx_http_complex_value_t *complex_value ;
   unsigned int zero : 1 ;
   unsigned int conf_prefix : 1 ;
   unsigned int root_prefix : 1 ;
};
#line 74 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_compile_complex_value_t_189 ngx_http_compile_complex_value_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
struct __anonstruct_ngx_http_upstream_chash_point_t_242 {
   uint32_t hash ;
   ngx_str_t *server ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_chash_point_t_242 ngx_http_upstream_chash_point_t;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
struct __anonstruct_ngx_http_upstream_chash_points_t_243 {
   ngx_uint_t number ;
   ngx_http_upstream_chash_point_t point[1] ;
};
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_chash_points_t_243 ngx_http_upstream_chash_points_t;
#line 25 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
struct __anonstruct_ngx_http_upstream_hash_srv_conf_t_244 {
   ngx_http_complex_value_t key ;
   ngx_http_upstream_chash_points_t *points ;
};
#line 25 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_hash_srv_conf_t_244 ngx_http_upstream_hash_srv_conf_t;
#line 31 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
struct __anonstruct_ngx_http_upstream_hash_peer_data_t_245 {
   ngx_http_upstream_rr_peer_data_t rrp ;
   ngx_http_upstream_hash_srv_conf_t *conf ;
   ngx_str_t key ;
   ngx_uint_t tries ;
   ngx_uint_t rehash ;
   uint32_t hash ;
   ngx_int_t (*get_rr_peer)(ngx_peer_connection_t *pc , void *data ) ;
};
#line 31 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
typedef struct __anonstruct_ngx_http_upstream_hash_peer_data_t_245 ngx_http_upstream_hash_peer_data_t;
#line 291 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
union __anonunion_prev_hash_246 {
   uint32_t value ;
   u_char byte[4] ;
};
#line 21 "src/http/ngx_http_variables.h"
struct ngx_http_variable_s;
#line 21 "src/http/ngx_http_variables.h"
typedef struct ngx_http_variable_s ngx_http_variable_t;
#line 37 "src/http/ngx_http_variables.h"
struct ngx_http_variable_s {
   ngx_str_t name ;
   void (*set_handler)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ) ;
   ngx_int_t (*get_handler)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                            uintptr_t data ) ;
   uintptr_t data ;
   ngx_uint_t flags ;
   ngx_uint_t index ;
};
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
struct __anonstruct_ngx_http_modern_browser_mask_t_242 {
   u_char browser[12] ;
   size_t skip ;
   size_t add ;
   u_char name[12] ;
};
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
typedef struct __anonstruct_ngx_http_modern_browser_mask_t_242 ngx_http_modern_browser_mask_t;
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
struct __anonstruct_ngx_http_modern_browser_t_243 {
   ngx_uint_t version ;
   size_t skip ;
   size_t add ;
   u_char name[12] ;
};
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
typedef struct __anonstruct_ngx_http_modern_browser_t_243 ngx_http_modern_browser_t;
#line 40 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
struct __anonstruct_ngx_http_browser_conf_t_244 {
   ngx_array_t *modern_browsers ;
   ngx_array_t *ancient_browsers ;
   ngx_http_variable_value_t *modern_browser_value ;
   ngx_http_variable_value_t *ancient_browser_value ;
   unsigned int modern_unlisted_browsers : 1 ;
   unsigned int netscape4 : 1 ;
};
#line 40 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
typedef struct __anonstruct_ngx_http_browser_conf_t_244 ngx_http_browser_conf_t;
#line 81 "src/core/ngx_inet.h"
struct __anonstruct_ngx_url_t_143 {
   ngx_str_t url ;
   ngx_str_t host ;
   ngx_str_t port_text ;
   ngx_str_t uri ;
   in_port_t port ;
   in_port_t default_port ;
   int family ;
   unsigned int listen : 1 ;
   unsigned int uri_part : 1 ;
   unsigned int no_resolve : 1 ;
   unsigned int no_port : 1 ;
   unsigned int wildcard : 1 ;
   socklen_t socklen ;
   ngx_sockaddr_t sockaddr ;
   ngx_addr_t *addrs ;
   ngx_uint_t naddrs ;
   char *err ;
};
#line 81 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_url_t_143 ngx_url_t;
#line 165 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_bitmask_t_159 {
   ngx_str_t name ;
   ngx_uint_t mask ;
};
#line 165 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_bitmask_t_159 ngx_conf_bitmask_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
struct __anonstruct_ngx_http_memcached_loc_conf_t_242 {
   ngx_http_upstream_conf_t upstream ;
   ngx_int_t index ;
   ngx_uint_t gzip_flag ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
typedef struct __anonstruct_ngx_http_memcached_loc_conf_t_242 ngx_http_memcached_loc_conf_t;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
struct __anonstruct_ngx_http_memcached_ctx_t_243 {
   size_t rest ;
   ngx_http_request_t *request ;
   ngx_str_t key ;
};
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
typedef struct __anonstruct_ngx_http_memcached_ctx_t_243 ngx_http_memcached_ctx_t;
#line 22 "src/core/ngx_string.h"
struct __anonstruct_ngx_keyval_t_100 {
   ngx_str_t key ;
   ngx_str_t value ;
};
#line 22 "src/core/ngx_string.h"
typedef struct __anonstruct_ngx_keyval_t_100 ngx_keyval_t;
#line 35 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_key_t_118 {
   ngx_str_t key ;
   ngx_uint_t key_hash ;
   void *value ;
};
#line 35 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_key_t_118 ngx_hash_key_t;
#line 52 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_init_t_120 {
   ngx_hash_t *hash ;
   ngx_uint_t (*key)(u_char *data , size_t len ) ;
   ngx_uint_t max_size ;
   ngx_uint_t bucket_size ;
   char *name ;
   ngx_pool_t *pool ;
   ngx_pool_t *temp_pool ;
};
#line 52 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_init_t_120 ngx_hash_init_t;
#line 65 "src/core/ngx_file.h"
struct __anonstruct_ngx_path_init_t_124 {
   ngx_str_t name ;
   size_t level[3] ;
};
#line 65 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_path_init_t_124 ngx_path_init_t;
#line 17 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_engine_t_186 {
   u_char *ip ;
   u_char *pos ;
   ngx_http_variable_value_t *sp ;
   ngx_str_t buf ;
   ngx_str_t line ;
   u_char *args ;
   unsigned int flushed : 1 ;
   unsigned int skip : 1 ;
   unsigned int quote : 1 ;
   unsigned int is_args : 1 ;
   unsigned int log : 1 ;
   ngx_int_t status ;
   ngx_http_request_t *request ;
};
#line 17 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_engine_t_186 ngx_http_script_engine_t;
#line 39 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_compile_t_187 {
   ngx_conf_t *cf ;
   ngx_str_t *source ;
   ngx_array_t **flushes ;
   ngx_array_t **lengths ;
   ngx_array_t **values ;
   ngx_uint_t variables ;
   ngx_uint_t ncaptures ;
   ngx_uint_t captures_mask ;
   ngx_uint_t size ;
   void *main ;
   unsigned int compile_args : 1 ;
   unsigned int complete_lengths : 1 ;
   unsigned int complete_values : 1 ;
   unsigned int zero : 1 ;
   unsigned int conf_prefix : 1 ;
   unsigned int root_prefix : 1 ;
   unsigned int dup_capture : 1 ;
   unsigned int args : 1 ;
};
#line 39 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_compile_t_187 ngx_http_script_compile_t;
#line 85 "src/http/ngx_http_script.h"
typedef void (*ngx_http_script_code_pt)(ngx_http_script_engine_t *e );
#line 86 "src/http/ngx_http_script.h"
typedef size_t (*ngx_http_script_len_code_pt)(ngx_http_script_engine_t *e );
#line 89 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_copy_code_t_190 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t len ;
};
#line 89 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_copy_code_t_190 ngx_http_script_copy_code_t;
#line 241 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_header_t_212 {
   ngx_str_t name ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_table_elt_t *h , ngx_uint_t offset ) ;
   ngx_uint_t offset ;
   ngx_int_t (*copy_handler)(ngx_http_request_t *r , ngx_table_elt_t *h , ngx_uint_t offset ) ;
   ngx_uint_t conf ;
   ngx_uint_t redirect ;
};
#line 241 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_header_t_212 ngx_http_upstream_header_t;
#line 401 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_param_t_216 {
   ngx_str_t key ;
   ngx_str_t value ;
   ngx_uint_t skip_empty ;
};
#line 401 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_param_t_216 ngx_http_upstream_param_t;
#line 66 "src/http/ngx_http.h"
struct __anonstruct_ngx_http_status_t_241 {
   ngx_uint_t http_version ;
   ngx_uint_t code ;
   ngx_uint_t count ;
   u_char *start ;
   u_char *end ;
};
#line 66 "src/http/ngx_http.h"
typedef struct __anonstruct_ngx_http_status_t_241 ngx_http_status_t;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
struct __anonstruct_ngx_http_scgi_main_conf_t_242 {
   ngx_array_t caches ;
};
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
typedef struct __anonstruct_ngx_http_scgi_main_conf_t_242 ngx_http_scgi_main_conf_t;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
struct __anonstruct_ngx_http_scgi_params_t_243 {
   ngx_array_t *flushes ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_uint_t number ;
   ngx_hash_t hash ;
};
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
typedef struct __anonstruct_ngx_http_scgi_params_t_243 ngx_http_scgi_params_t;
#line 28 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
struct __anonstruct_ngx_http_scgi_loc_conf_t_244 {
   ngx_http_upstream_conf_t upstream ;
   ngx_http_scgi_params_t params ;
   ngx_http_scgi_params_t params_cache ;
   ngx_array_t *params_source ;
   ngx_array_t *scgi_lengths ;
   ngx_array_t *scgi_values ;
   ngx_http_complex_value_t cache_key ;
};
#line 28 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
typedef struct __anonstruct_ngx_http_scgi_loc_conf_t_244 ngx_http_scgi_loc_conf_t;
#line 150 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_num_bounds_t_157 {
   char *(*post_handler)(ngx_conf_t *cf , void *data , void *conf ) ;
   ngx_int_t low ;
   ngx_int_t high ;
};
#line 150 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_num_bounds_t_157 ngx_conf_num_bounds_t;
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
struct __anonstruct_ngx_http_uwsgi_main_conf_t_242 {
   ngx_array_t caches ;
};
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
typedef struct __anonstruct_ngx_http_uwsgi_main_conf_t_242 ngx_http_uwsgi_main_conf_t;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
struct __anonstruct_ngx_http_uwsgi_params_t_243 {
   ngx_array_t *flushes ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_uint_t number ;
   ngx_hash_t hash ;
};
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
typedef struct __anonstruct_ngx_http_uwsgi_params_t_243 ngx_http_uwsgi_params_t;
#line 29 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
struct __anonstruct_ngx_http_uwsgi_loc_conf_t_244 {
   ngx_http_upstream_conf_t upstream ;
   ngx_http_uwsgi_params_t params ;
   ngx_http_uwsgi_params_t params_cache ;
   ngx_array_t *params_source ;
   ngx_array_t *uwsgi_lengths ;
   ngx_array_t *uwsgi_values ;
   ngx_http_complex_value_t cache_key ;
   ngx_str_t uwsgi_string ;
   ngx_uint_t modifier1 ;
   ngx_uint_t modifier2 ;
};
#line 29 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
typedef struct __anonstruct_ngx_http_uwsgi_loc_conf_t_244 ngx_http_uwsgi_loc_conf_t;
#line 29 "src/core/ngx_regex.h"
struct __anonstruct_ngx_regex_compile_t_129 {
   ngx_str_t pattern ;
   ngx_pool_t *pool ;
   ngx_int_t options ;
   ngx_regex_t *regex ;
   int captures ;
   int named_captures ;
   int name_size ;
   u_char *names ;
   ngx_str_t err ;
};
#line 29 "src/core/ngx_regex.h"
typedef struct __anonstruct_ngx_regex_compile_t_129 ngx_regex_compile_t;
#line 138 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_post_t_155 {
   char *(*post_handler)(ngx_conf_t *cf , void *data , void *conf ) ;
};
#line 138 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_post_t_155 ngx_conf_post_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_main_conf_t_242 {
   ngx_array_t caches ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_main_conf_t_242 ngx_http_fastcgi_main_conf_t;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_params_t_243 {
   ngx_array_t *flushes ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_uint_t number ;
   ngx_hash_t hash ;
};
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_params_t_243 ngx_http_fastcgi_params_t;
#line 27 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_loc_conf_t_244 {
   ngx_http_upstream_conf_t upstream ;
   ngx_str_t index ;
   ngx_http_fastcgi_params_t params ;
   ngx_http_fastcgi_params_t params_cache ;
   ngx_array_t *params_source ;
   ngx_array_t *catch_stderr ;
   ngx_array_t *fastcgi_lengths ;
   ngx_array_t *fastcgi_values ;
   ngx_flag_t keep_conn ;
   ngx_http_complex_value_t cache_key ;
   ngx_regex_t *split_regex ;
   ngx_str_t split_name ;
};
#line 27 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_loc_conf_t_244 ngx_http_fastcgi_loc_conf_t;
#line 56
enum __anonenum_ngx_http_fastcgi_state_e_245 {
    ngx_http_fastcgi_st_version = 0,
    ngx_http_fastcgi_st_type = 1,
    ngx_http_fastcgi_st_request_id_hi = 2,
    ngx_http_fastcgi_st_request_id_lo = 3,
    ngx_http_fastcgi_st_content_length_hi = 4,
    ngx_http_fastcgi_st_content_length_lo = 5,
    ngx_http_fastcgi_st_padding_length = 6,
    ngx_http_fastcgi_st_reserved = 7,
    ngx_http_fastcgi_st_data = 8,
    ngx_http_fastcgi_st_padding = 9
} ;
#line 56 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef enum __anonenum_ngx_http_fastcgi_state_e_245 ngx_http_fastcgi_state_e;
#line 70 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_split_part_t_246 {
   u_char *start ;
   u_char *end ;
};
#line 70 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_split_part_t_246 ngx_http_fastcgi_split_part_t;
#line 76 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_ctx_t_247 {
   ngx_http_fastcgi_state_e state ;
   u_char *pos ;
   u_char *last ;
   ngx_uint_t type ;
   size_t length ;
   size_t padding ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   unsigned int fastcgi_stdout : 1 ;
   unsigned int large_stderr : 1 ;
   unsigned int header_sent : 1 ;
   ngx_array_t *split_parts ;
   ngx_str_t script_name ;
   ngx_str_t path_info ;
};
#line 76 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_ctx_t_247 ngx_http_fastcgi_ctx_t;
#line 112 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_header_t_248 {
   u_char version ;
   u_char type ;
   u_char request_id_hi ;
   u_char request_id_lo ;
   u_char content_length_hi ;
   u_char content_length_lo ;
   u_char padding_length ;
   u_char reserved ;
};
#line 112 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_header_t_248 ngx_http_fastcgi_header_t;
#line 124 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_begin_request_t_249 {
   u_char role_hi ;
   u_char role_lo ;
   u_char flags ;
   u_char reserved[5] ;
};
#line 124 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_begin_request_t_249 ngx_http_fastcgi_begin_request_t;
#line 132 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_header_small_t_250 {
   u_char version ;
   u_char type ;
   u_char request_id_hi ;
   u_char request_id_lo ;
};
#line 132 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_header_small_t_250 ngx_http_fastcgi_header_small_t;
#line 140 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
struct __anonstruct_ngx_http_fastcgi_request_start_t_251 {
   ngx_http_fastcgi_header_t h0 ;
   ngx_http_fastcgi_begin_request_t br ;
   ngx_http_fastcgi_header_small_t h1 ;
};
#line 140 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
typedef struct __anonstruct_ngx_http_fastcgi_request_start_t_251 ngx_http_fastcgi_request_start_t;
#line 157 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_enum_t_158 {
   ngx_str_t name ;
   ngx_uint_t value ;
};
#line 157 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_enum_t_158 ngx_conf_enum_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_main_conf_t_242 {
   ngx_array_t caches ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_main_conf_t_242 ngx_http_proxy_main_conf_t;
#line 18
struct ngx_http_proxy_rewrite_s;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
typedef struct ngx_http_proxy_rewrite_s ngx_http_proxy_rewrite_t;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
union __anonunion_pattern_243 {
   ngx_http_complex_value_t complex ;
   ngx_http_regex_t *regex ;
};
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
struct ngx_http_proxy_rewrite_s {
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_table_elt_t *h , size_t prefix ,
                        size_t len , ngx_http_proxy_rewrite_t *pr ) ;
   union __anonunion_pattern_243 pattern ;
   ngx_http_complex_value_t replacement ;
};
#line 38 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_vars_t_244 {
   ngx_str_t key_start ;
   ngx_str_t schema ;
   ngx_str_t host_header ;
   ngx_str_t port ;
   ngx_str_t uri ;
};
#line 38 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_vars_t_244 ngx_http_proxy_vars_t;
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_headers_t_245 {
   ngx_array_t *flushes ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_hash_t hash ;
};
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_headers_t_245 ngx_http_proxy_headers_t;
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_loc_conf_t_246 {
   ngx_http_upstream_conf_t upstream ;
   ngx_array_t *body_flushes ;
   ngx_array_t *body_lengths ;
   ngx_array_t *body_values ;
   ngx_str_t body_source ;
   ngx_http_proxy_headers_t headers ;
   ngx_http_proxy_headers_t headers_cache ;
   ngx_array_t *headers_source ;
   ngx_array_t *proxy_lengths ;
   ngx_array_t *proxy_values ;
   ngx_array_t *redirects ;
   ngx_array_t *cookie_domains ;
   ngx_array_t *cookie_paths ;
   ngx_http_complex_value_t *method ;
   ngx_str_t location ;
   ngx_str_t url ;
   ngx_http_complex_value_t cache_key ;
   ngx_http_proxy_vars_t vars ;
   ngx_flag_t redirect ;
   ngx_uint_t http_version ;
   ngx_uint_t headers_hash_max_size ;
   ngx_uint_t headers_hash_bucket_size ;
};
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_loc_conf_t_246 ngx_http_proxy_loc_conf_t;
#line 107 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
struct __anonstruct_ngx_http_proxy_ctx_t_247 {
   ngx_http_status_t status ;
   ngx_http_chunked_t chunked ;
   ngx_http_proxy_vars_t vars ;
   off_t internal_body_length ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   unsigned int head : 1 ;
   unsigned int internal_chunked : 1 ;
   unsigned int header_sent : 1 ;
};
#line 107 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
typedef struct __anonstruct_ngx_http_proxy_ctx_t_247 ngx_http_proxy_ctx_t;
#line 75 "src/core/ngx_hash.h"
struct __anonstruct_ngx_hash_keys_arrays_t_121 {
   ngx_uint_t hsize ;
   ngx_pool_t *pool ;
   ngx_pool_t *temp_pool ;
   ngx_array_t keys ;
   ngx_array_t *keys_hash ;
   ngx_array_t dns_wc_head ;
   ngx_array_t *dns_wc_head_hash ;
   ngx_array_t dns_wc_tail ;
   ngx_array_t *dns_wc_tail_hash ;
};
#line 75 "src/core/ngx_hash.h"
typedef struct __anonstruct_ngx_hash_keys_arrays_t_121 ngx_hash_keys_arrays_t;
#line 365 "src/http/ngx_http_request.h"
typedef ngx_int_t (*ngx_http_handler_pt)(ngx_http_request_t *r );
#line 95 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_var_code_t_191 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t index ;
};
#line 95 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_var_code_t_191 ngx_http_script_var_code_t;
#line 101 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_var_handler_code_t_192 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   void (*handler)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ) ;
   uintptr_t data ;
};
#line 101 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_var_handler_code_t_192 ngx_http_script_var_handler_code_t;
#line 116 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_regex_code_t_194 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   ngx_http_regex_t *regex ;
   ngx_array_t *lengths ;
   uintptr_t size ;
   uintptr_t status ;
   uintptr_t next ;
   unsigned int test : 1 ;
   unsigned int negative_test : 1 ;
   unsigned int uri : 1 ;
   unsigned int args : 1 ;
   unsigned int add_args : 1 ;
   unsigned int redirect : 1 ;
   unsigned int break_cycle : 1 ;
   ngx_str_t name ;
};
#line 116 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_regex_code_t_194 ngx_http_script_regex_code_t;
#line 139 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_regex_end_code_t_195 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   unsigned int uri : 1 ;
   unsigned int args : 1 ;
   unsigned int add_args : 1 ;
   unsigned int redirect : 1 ;
};
#line 139 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_regex_end_code_t_195 ngx_http_script_regex_end_code_t;
#line 160 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_return_code_t_197 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t status ;
   ngx_http_complex_value_t text ;
};
#line 160 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_return_code_t_197 ngx_http_script_return_code_t;
#line 179 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_file_code_t_199 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t op ;
};
#line 179 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_file_code_t_199 ngx_http_script_file_code_t;
#line 185 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_if_code_t_200 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t next ;
   void **loc_conf ;
};
#line 185 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_if_code_t_200 ngx_http_script_if_code_t;
#line 192 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_complex_value_code_t_201 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   ngx_array_t *lengths ;
};
#line 192 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_complex_value_code_t_201 ngx_http_script_complex_value_code_t;
#line 198 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_value_code_t_202 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t value ;
   uintptr_t text_len ;
   uintptr_t text_data ;
};
#line 198 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_value_code_t_202 ngx_http_script_value_code_t;
#line 129 "src/http/ngx_http_core_module.h"
struct ngx_http_phase_handler_s;
#line 129 "src/http/ngx_http_core_module.h"
typedef struct ngx_http_phase_handler_s ngx_http_phase_handler_t;
#line 134 "src/http/ngx_http_core_module.h"
struct ngx_http_phase_handler_s {
   ngx_int_t (*checker)(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
   ngx_int_t (*handler)(ngx_http_request_t *r ) ;
   ngx_uint_t next ;
};
#line 141 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_phase_engine_t_220 {
   ngx_http_phase_handler_t *handlers ;
   ngx_uint_t server_rewrite_index ;
   ngx_uint_t location_rewrite_index ;
};
#line 141 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_phase_engine_t_220 ngx_http_phase_engine_t;
#line 148 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_phase_t_221 {
   ngx_array_t handlers ;
};
#line 148 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_phase_t_221 ngx_http_phase_t;
#line 153 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_core_main_conf_t_222 {
   ngx_array_t servers ;
   ngx_http_phase_engine_t phase_engine ;
   ngx_hash_t headers_in_hash ;
   ngx_hash_t variables_hash ;
   ngx_array_t variables ;
   ngx_array_t prefix_variables ;
   ngx_uint_t ncaptures ;
   ngx_uint_t server_names_hash_max_size ;
   ngx_uint_t server_names_hash_bucket_size ;
   ngx_uint_t variables_hash_max_size ;
   ngx_uint_t variables_hash_bucket_size ;
   ngx_hash_keys_arrays_t *variables_keys ;
   ngx_array_t *ports ;
   ngx_http_phase_t phases[11] ;
};
#line 153 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_core_main_conf_t_222 ngx_http_core_main_conf_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
struct __anonstruct_ngx_http_rewrite_loc_conf_t_242 {
   ngx_array_t *codes ;
   ngx_uint_t stack_size ;
   ngx_flag_t log ;
   ngx_flag_t uninitialized_variable_warn ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
typedef struct __anonstruct_ngx_http_rewrite_loc_conf_t_242 ngx_http_rewrite_loc_conf_t;
#line 43 "src/core/ngx_regex.h"
struct __anonstruct_ngx_regex_elt_t_130 {
   ngx_regex_t *regex ;
   u_char *name ;
};
#line 43 "src/core/ngx_regex.h"
typedef struct __anonstruct_ngx_regex_elt_t_130 ngx_regex_elt_t;
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
struct __anonstruct_ngx_http_referer_conf_t_242 {
   ngx_hash_combined_t hash ;
   ngx_array_t *regex ;
   ngx_array_t *server_name_regex ;
   ngx_flag_t no_referer ;
   ngx_flag_t blocked_referer ;
   ngx_flag_t server_names ;
   ngx_hash_keys_arrays_t *keys ;
   ngx_uint_t referer_hash_max_size ;
   ngx_uint_t referer_hash_bucket_size ;
};
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
typedef struct __anonstruct_ngx_http_referer_conf_t_242 ngx_http_referer_conf_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
struct __anonstruct_ngx_http_split_clients_part_t_242 {
   uint32_t percent ;
   ngx_http_variable_value_t value ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
typedef struct __anonstruct_ngx_http_split_clients_part_t_242 ngx_http_split_clients_part_t;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
struct __anonstruct_ngx_http_split_clients_ctx_t_243 {
   ngx_http_complex_value_t value ;
   ngx_array_t parts ;
};
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
typedef struct __anonstruct_ngx_http_split_clients_ctx_t_243 ngx_http_split_clients_ctx_t;
#line 81 "src/http/ngx_http_variables.h"
struct __anonstruct_ngx_http_map_regex_t_173 {
   ngx_http_regex_t *regex ;
   void *value ;
};
#line 81 "src/http/ngx_http_variables.h"
typedef struct __anonstruct_ngx_http_map_regex_t_173 ngx_http_map_regex_t;
#line 95 "src/http/ngx_http_variables.h"
struct __anonstruct_ngx_http_map_t_174 {
   ngx_hash_combined_t hash ;
   ngx_http_map_regex_t *regex ;
   ngx_uint_t nregex ;
};
#line 95 "src/http/ngx_http_variables.h"
typedef struct __anonstruct_ngx_http_map_t_174 ngx_http_map_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
struct __anonstruct_ngx_http_map_conf_t_242 {
   ngx_uint_t hash_max_size ;
   ngx_uint_t hash_bucket_size ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
typedef struct __anonstruct_ngx_http_map_conf_t_242 ngx_http_map_conf_t;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
struct __anonstruct_ngx_http_map_conf_ctx_t_243 {
   ngx_hash_keys_arrays_t keys ;
   ngx_array_t *values_hash ;
   ngx_array_t regexes ;
   ngx_http_variable_value_t *default_value ;
   ngx_conf_t *cf ;
   unsigned int hostnames : 1 ;
   unsigned int no_cacheable : 1 ;
};
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
typedef struct __anonstruct_ngx_http_map_conf_ctx_t_243 ngx_http_map_conf_ctx_t;
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
struct __anonstruct_ngx_http_map_ctx_t_244 {
   ngx_http_map_t map ;
   ngx_http_complex_value_t value ;
   ngx_http_variable_value_t *default_value ;
   ngx_uint_t hostnames ;
};
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
typedef struct __anonstruct_ngx_http_map_ctx_t_244 ngx_http_map_ctx_t;
#line 215 "src/core/ngx_string.h"
struct __anonstruct_ngx_str_node_t_102 {
   ngx_rbtree_node_t node ;
   ngx_str_t str ;
};
#line 215 "src/core/ngx_string.h"
typedef struct __anonstruct_ngx_str_node_t_102 ngx_str_node_t;
#line 21 "src/os/unix/ngx_files.h"
struct __anonstruct_ngx_file_mapping_t_103 {
   u_char *name ;
   size_t size ;
   void *addr ;
   ngx_fd_t fd ;
   ngx_log_t *log ;
};
#line 21 "src/os/unix/ngx_files.h"
typedef struct __anonstruct_ngx_file_mapping_t_103 ngx_file_mapping_t;
#line 18 "src/core/ngx_radix_tree.h"
struct ngx_radix_node_s;
#line 18 "src/core/ngx_radix_tree.h"
typedef struct ngx_radix_node_s ngx_radix_node_t;
#line 20 "src/core/ngx_radix_tree.h"
struct ngx_radix_node_s {
   ngx_radix_node_t *right ;
   ngx_radix_node_t *left ;
   ngx_radix_node_t *parent ;
   uintptr_t value ;
};
#line 28 "src/core/ngx_radix_tree.h"
struct __anonstruct_ngx_radix_tree_t_131 {
   ngx_radix_node_t *root ;
   ngx_pool_t *pool ;
   ngx_radix_node_t *free ;
   char *start ;
   size_t size ;
};
#line 28 "src/core/ngx_radix_tree.h"
typedef struct __anonstruct_ngx_radix_tree_t_131 ngx_radix_tree_t;
#line 47 "src/core/ngx_inet.h"
struct __anonstruct_ngx_in_cidr_t_138 {
   in_addr_t addr ;
   in_addr_t mask ;
};
#line 47 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_in_cidr_t_138 ngx_in_cidr_t;
#line 55 "src/core/ngx_inet.h"
struct __anonstruct_ngx_in6_cidr_t_139 {
   struct in6_addr addr ;
   struct in6_addr mask ;
};
#line 55 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_in6_cidr_t_139 ngx_in6_cidr_t;
#line 63 "src/core/ngx_inet.h"
union __anonunion_u_141 {
   ngx_in_cidr_t in ;
   ngx_in6_cidr_t in6 ;
};
#line 63 "src/core/ngx_inet.h"
struct __anonstruct_ngx_cidr_t_140 {
   ngx_uint_t family ;
   union __anonunion_u_141 u ;
};
#line 63 "src/core/ngx_inet.h"
typedef struct __anonstruct_ngx_cidr_t_140 ngx_cidr_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_range_t_242 {
   ngx_http_variable_value_t *value ;
   u_short start ;
   u_short end ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_range_t_242 ngx_http_geo_range_t;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_trees_t_243 {
   ngx_radix_tree_t *tree ;
   ngx_radix_tree_t *tree6 ;
};
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_trees_t_243 ngx_http_geo_trees_t;
#line 28 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_high_ranges_t_244 {
   ngx_http_geo_range_t **low ;
   ngx_http_variable_value_t *default_value ;
};
#line 28 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_high_ranges_t_244 ngx_http_geo_high_ranges_t;
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_variable_value_node_t_245 {
   ngx_str_node_t sn ;
   ngx_http_variable_value_t *value ;
   size_t offset ;
};
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_variable_value_node_t_245 ngx_http_geo_variable_value_node_t;
#line 41 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_conf_ctx_t_246 {
   ngx_http_variable_value_t *value ;
   ngx_str_t *net ;
   ngx_http_geo_high_ranges_t high ;
   ngx_radix_tree_t *tree ;
   ngx_radix_tree_t *tree6 ;
   ngx_rbtree_t rbtree ;
   ngx_rbtree_node_t sentinel ;
   ngx_array_t *proxies ;
   ngx_pool_t *pool ;
   ngx_pool_t *temp_pool ;
   size_t data_size ;
   ngx_str_t include_name ;
   ngx_uint_t includes ;
   ngx_uint_t entries ;
   unsigned int ranges : 1 ;
   unsigned int outside_entries : 1 ;
   unsigned int allow_binary_include : 1 ;
   unsigned int binary_include : 1 ;
   unsigned int proxy_recursive : 1 ;
};
#line 41 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_conf_ctx_t_246 ngx_http_geo_conf_ctx_t;
#line 69 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
union __anonunion_u_248 {
   ngx_http_geo_trees_t trees ;
   ngx_http_geo_high_ranges_t high ;
};
#line 69 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_ctx_t_247 {
   union __anonunion_u_248 u ;
   ngx_array_t *proxies ;
   unsigned int proxy_recursive : 1 ;
   ngx_int_t index ;
};
#line 69 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_ctx_t_247 ngx_http_geo_ctx_t;
#line 157 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
struct __anonstruct_ngx_http_geo_header_t_249 {
   u_char GEORNG[6] ;
   u_char version ;
   u_char ptr_size ;
   uint32_t endianness ;
   uint32_t crc32 ;
};
#line 157 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
typedef struct __anonstruct_ngx_http_geo_header_t_249 ngx_http_geo_header_t;
#line 17 "src/core/ngx_rbtree.h"
typedef ngx_int_t ngx_rbtree_key_int_t;
#line 17 "src/os/unix/ngx_time.h"
typedef ngx_rbtree_key_int_t ngx_msec_int_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_node_t_242 {
   u_char color ;
   u_char dummy ;
   u_short len ;
   ngx_queue_t queue ;
   ngx_msec_t last ;
   ngx_uint_t excess ;
   ngx_uint_t count ;
   u_char data[1] ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_node_t_242 ngx_http_limit_req_node_t;
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_shctx_t_243 {
   ngx_rbtree_t rbtree ;
   ngx_rbtree_node_t sentinel ;
   ngx_queue_t queue ;
};
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_shctx_t_243 ngx_http_limit_req_shctx_t;
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_ctx_t_244 {
   ngx_http_limit_req_shctx_t *sh ;
   ngx_slab_pool_t *shpool ;
   ngx_uint_t rate ;
   ngx_http_complex_value_t key ;
   ngx_http_limit_req_node_t *node ;
};
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_ctx_t_244 ngx_http_limit_req_ctx_t;
#line 43 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_limit_t_245 {
   ngx_shm_zone_t *shm_zone ;
   ngx_uint_t burst ;
   ngx_uint_t nodelay ;
};
#line 43 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_limit_t_245 ngx_http_limit_req_limit_t;
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
struct __anonstruct_ngx_http_limit_req_conf_t_246 {
   ngx_array_t limits ;
   ngx_uint_t limit_log_level ;
   ngx_uint_t delay_log_level ;
   ngx_uint_t status_code ;
};
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
typedef struct __anonstruct_ngx_http_limit_req_conf_t_246 ngx_http_limit_req_conf_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_node_t_242 {
   u_char color ;
   u_char len ;
   u_short conn ;
   u_char data[1] ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_node_t_242 ngx_http_limit_conn_node_t;
#line 21 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_cleanup_t_243 {
   ngx_shm_zone_t *shm_zone ;
   ngx_rbtree_node_t *node ;
};
#line 21 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_cleanup_t_243 ngx_http_limit_conn_cleanup_t;
#line 27 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_ctx_t_244 {
   ngx_rbtree_t *rbtree ;
   ngx_http_complex_value_t key ;
};
#line 27 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_ctx_t_244 ngx_http_limit_conn_ctx_t;
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_limit_t_245 {
   ngx_shm_zone_t *shm_zone ;
   ngx_uint_t conn ;
};
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_limit_t_245 ngx_http_limit_conn_limit_t;
#line 39 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
struct __anonstruct_ngx_http_limit_conn_conf_t_246 {
   ngx_array_t limits ;
   ngx_uint_t log_level ;
   ngx_uint_t status_code ;
};
#line 39 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
typedef struct __anonstruct_ngx_http_limit_conn_conf_t_246 ngx_http_limit_conn_conf_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
struct __anonstruct_ngx_http_access_rule_t_242 {
   in_addr_t mask ;
   in_addr_t addr ;
   ngx_uint_t deny ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
typedef struct __anonstruct_ngx_http_access_rule_t_242 ngx_http_access_rule_t;
#line 21 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
struct __anonstruct_ngx_http_access_rule6_t_243 {
   struct in6_addr addr ;
   struct in6_addr mask ;
   ngx_uint_t deny ;
};
#line 21 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
typedef struct __anonstruct_ngx_http_access_rule6_t_243 ngx_http_access_rule6_t;
#line 31 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
struct __anonstruct_ngx_http_access_rule_un_t_244 {
   ngx_uint_t deny ;
};
#line 31 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
typedef struct __anonstruct_ngx_http_access_rule_un_t_244 ngx_http_access_rule_un_t;
#line 37 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
struct __anonstruct_ngx_http_access_loc_conf_t_245 {
   ngx_array_t *rules ;
   ngx_array_t *rules6 ;
   ngx_array_t *rules_un ;
};
#line 37 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
typedef struct __anonstruct_ngx_http_access_loc_conf_t_245 ngx_http_access_loc_conf_t;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
struct __anonstruct_ngx_http_auth_basic_loc_conf_t_242 {
   ngx_http_complex_value_t *realm ;
   ngx_http_complex_value_t user_file ;
};
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
typedef struct __anonstruct_ngx_http_auth_basic_loc_conf_t_242 ngx_http_auth_basic_loc_conf_t;
#line 103
enum __anonenum_state_243 {
    sw_login = 0,
    sw_passwd = 1,
    sw_skip = 2
} ;
#line 19 "src/core/ngx_open_file_cache.h"
struct __anonstruct_ngx_open_file_info_t_161 {
   ngx_fd_t fd ;
   ngx_file_uniq_t uniq ;
   time_t mtime ;
   off_t size ;
   off_t fs_size ;
   off_t directio ;
   size_t read_ahead ;
   ngx_err_t err ;
   char *failed ;
   time_t valid ;
   ngx_uint_t min_uses ;
   size_t disable_symlinks_from ;
   unsigned int disable_symlinks : 2 ;
   unsigned int test_dir : 1 ;
   unsigned int test_only : 1 ;
   unsigned int log : 1 ;
   unsigned int errors : 1 ;
   unsigned int events : 1 ;
   unsigned int is_dir : 1 ;
   unsigned int is_file : 1 ;
   unsigned int is_link : 1 ;
   unsigned int is_exec : 1 ;
   unsigned int is_directio : 1 ;
};
#line 19 "src/core/ngx_open_file_cache.h"
typedef struct __anonstruct_ngx_open_file_info_t_161 ngx_open_file_info_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
struct __anonstruct_ngx_http_try_file_t_242 {
   ngx_array_t *lengths ;
   ngx_array_t *values ;
   ngx_str_t name ;
   unsigned int code : 10 ;
   unsigned int test_dir : 1 ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
typedef struct __anonstruct_ngx_http_try_file_t_242 ngx_http_try_file_t;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
struct __anonstruct_ngx_http_try_files_loc_conf_t_243 {
   ngx_http_try_file_t *try_files ;
};
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
typedef struct __anonstruct_ngx_http_try_files_loc_conf_t_243 ngx_http_try_files_loc_conf_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
struct __anonstruct_ngx_http_mirror_loc_conf_t_242 {
   ngx_array_t *mirror ;
   ngx_flag_t request_body ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
typedef struct __anonstruct_ngx_http_mirror_loc_conf_t_242 ngx_http_mirror_loc_conf_t;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
struct __anonstruct_ngx_http_mirror_ctx_t_243 {
   ngx_int_t status ;
};
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
typedef struct __anonstruct_ngx_http_mirror_ctx_t_243 ngx_http_mirror_ctx_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
struct __anonstruct_ngx_http_index_t_242 {
   ngx_str_t name ;
   ngx_array_t *lengths ;
   ngx_array_t *values ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
typedef struct __anonstruct_ngx_http_index_t_242 ngx_http_index_t;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
struct __anonstruct_ngx_http_index_loc_conf_t_243 {
   ngx_array_t *indices ;
   size_t max_index_len ;
};
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
typedef struct __anonstruct_ngx_http_index_loc_conf_t_243 ngx_http_index_loc_conf_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino64_t d_ino ;
   __off64_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 19 "src/os/unix/ngx_time.h"
typedef struct tm ngx_tm_t;
#line 30 "src/os/unix/ngx_files.h"
struct __anonstruct_ngx_dir_t_104 {
   DIR *dir ;
   struct dirent *de ;
   struct stat info ;
   unsigned int type : 8 ;
   unsigned int valid_info : 1 ;
};
#line 30 "src/os/unix/ngx_files.h"
typedef struct __anonstruct_ngx_dir_t_104 ngx_dir_t;
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
struct __anonstruct_ngx_http_autoindex_entry_t_242 {
   ngx_str_t name ;
   size_t utf_len ;
   size_t escape ;
   size_t escape_html ;
   unsigned int dir : 1 ;
   unsigned int file : 1 ;
   time_t mtime ;
   off_t size ;
};
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
typedef struct __anonstruct_ngx_http_autoindex_entry_t_242 ngx_http_autoindex_entry_t;
#line 40 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
struct __anonstruct_ngx_http_autoindex_loc_conf_t_243 {
   ngx_flag_t enable ;
   ngx_uint_t format ;
   ngx_flag_t localtime ;
   ngx_flag_t exact_size ;
};
#line 40 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
typedef struct __anonstruct_ngx_http_autoindex_loc_conf_t_243 ngx_http_autoindex_loc_conf_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
struct __anonstruct_ngx_http_copy_filter_conf_t_242 {
   ngx_bufs_t bufs ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
typedef struct __anonstruct_ngx_http_copy_filter_conf_t_242 ngx_http_copy_filter_conf_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
struct ngx_http_header_val_s;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
typedef struct ngx_http_header_val_s ngx_http_header_val_t;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
struct __anonstruct_ngx_http_set_header_t_242 {
   ngx_str_t name ;
   ngx_uint_t offset ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_http_header_val_t *hv , ngx_str_t *value ) ;
};
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
typedef struct __anonstruct_ngx_http_set_header_t_242 ngx_http_set_header_t;
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
struct ngx_http_header_val_s {
   ngx_http_complex_value_t value ;
   ngx_str_t key ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_http_header_val_t *hv , ngx_str_t *value ) ;
   ngx_uint_t offset ;
   ngx_uint_t always ;
};
#line 35
enum __anonenum_ngx_http_expires_t_243 {
    NGX_HTTP_EXPIRES_OFF = 0,
    NGX_HTTP_EXPIRES_EPOCH = 1,
    NGX_HTTP_EXPIRES_MAX = 2,
    NGX_HTTP_EXPIRES_ACCESS = 3,
    NGX_HTTP_EXPIRES_MODIFIED = 4,
    NGX_HTTP_EXPIRES_DAILY = 5,
    NGX_HTTP_EXPIRES_UNSET = 6
} ;
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
typedef enum __anonenum_ngx_http_expires_t_243 ngx_http_expires_t;
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
struct __anonstruct_ngx_http_headers_conf_t_244 {
   ngx_http_expires_t expires ;
   time_t expires_time ;
   ngx_http_complex_value_t *expires_value ;
   ngx_array_t *headers ;
   ngx_array_t *trailers ;
};
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
typedef struct __anonstruct_ngx_http_headers_conf_t_244 ngx_http_headers_conf_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 16 "src/os/unix/ngx_process.h"
typedef pid_t ngx_pid_t;
#line 22 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
struct __anonstruct_ngx_http_userid_conf_t_242 {
   ngx_uint_t enable ;
   ngx_int_t service ;
   ngx_str_t name ;
   ngx_str_t domain ;
   ngx_str_t path ;
   ngx_str_t p3p ;
   time_t expires ;
   u_char mark ;
};
#line 22 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
typedef struct __anonstruct_ngx_http_userid_conf_t_242 ngx_http_userid_conf_t;
#line 38 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
struct __anonstruct_ngx_http_userid_ctx_t_243 {
   uint32_t uid_got[4] ;
   uint32_t uid_set[4] ;
   ngx_str_t cookie ;
   ngx_uint_t reset ;
};
#line 38 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
typedef struct __anonstruct_ngx_http_userid_ctx_t_243 ngx_http_userid_ctx_t;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_t_242 {
   u_char **tables ;
   ngx_str_t name ;
   unsigned int length : 16 ;
   unsigned int utf8 : 1 ;
};
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_t_242 ngx_http_charset_t;
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_recode_t_243 {
   ngx_int_t src ;
   ngx_int_t dst ;
};
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_recode_t_243 ngx_http_charset_recode_t;
#line 38 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_tables_t_244 {
   ngx_int_t src ;
   ngx_int_t dst ;
   u_char *src2dst ;
   u_char *dst2src ;
};
#line 38 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_tables_t_244 ngx_http_charset_tables_t;
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_main_conf_t_245 {
   ngx_array_t charsets ;
   ngx_array_t tables ;
   ngx_array_t recodes ;
};
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_main_conf_t_245 ngx_http_charset_main_conf_t;
#line 53 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_loc_conf_t_246 {
   ngx_int_t charset ;
   ngx_int_t source_charset ;
   ngx_flag_t override_charset ;
   ngx_hash_t types ;
   ngx_array_t *types_keys ;
};
#line 53 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_loc_conf_t_246 ngx_http_charset_loc_conf_t;
#line 63 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_ctx_t_247 {
   u_char *table ;
   ngx_int_t charset ;
   ngx_str_t charset_name ;
   ngx_chain_t *busy ;
   ngx_chain_t *free_bufs ;
   ngx_chain_t *free_buffers ;
   size_t saved_len ;
   u_char saved[4] ;
   unsigned int length : 16 ;
   unsigned int from_utf8 : 1 ;
   unsigned int to_utf8 : 1 ;
};
#line 63 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_ctx_t_247 ngx_http_charset_ctx_t;
#line 81 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
struct __anonstruct_ngx_http_charset_conf_ctx_t_248 {
   ngx_http_charset_tables_t *table ;
   ngx_http_charset_t *charset ;
   ngx_uint_t characters ;
};
#line 81 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
typedef struct __anonstruct_ngx_http_charset_conf_ctx_t_248 ngx_http_charset_conf_ctx_t;
#line 33 "src/http/modules/ngx_http_ssi_filter_module.h"
struct __anonstruct_ngx_http_ssi_main_conf_t_237 {
   ngx_hash_t hash ;
   ngx_hash_keys_arrays_t commands ;
};
#line 33 "src/http/modules/ngx_http_ssi_filter_module.h"
typedef struct __anonstruct_ngx_http_ssi_main_conf_t_237 ngx_http_ssi_main_conf_t;
#line 39 "src/http/modules/ngx_http_ssi_filter_module.h"
struct __anonstruct_ngx_http_ssi_ctx_t_238 {
   ngx_buf_t *buf ;
   u_char *pos ;
   u_char *copy_start ;
   u_char *copy_end ;
   ngx_uint_t key ;
   ngx_str_t command ;
   ngx_array_t params ;
   ngx_table_elt_t *param ;
   ngx_table_elt_t params_array[4] ;
   ngx_chain_t *in ;
   ngx_chain_t *out ;
   ngx_chain_t **last_out ;
   ngx_chain_t *busy ;
   ngx_chain_t *free ;
   ngx_uint_t state ;
   ngx_uint_t saved_state ;
   size_t saved ;
   size_t looked ;
   size_t value_len ;
   ngx_list_t *variables ;
   ngx_array_t *blocks ;
   ngx_uint_t ncaptures ;
   int *captures ;
   u_char *captures_data ;
   unsigned int conditional : 2 ;
   unsigned int encoding : 2 ;
   unsigned int block : 1 ;
   unsigned int output : 1 ;
   unsigned int output_chosen : 1 ;
   ngx_http_request_t *wait ;
   void *value_buf ;
   ngx_str_t timefmt ;
   ngx_str_t errmsg ;
};
#line 39 "src/http/modules/ngx_http_ssi_filter_module.h"
typedef struct __anonstruct_ngx_http_ssi_ctx_t_238 ngx_http_ssi_ctx_t;
#line 91 "src/http/modules/ngx_http_ssi_filter_module.h"
struct __anonstruct_ngx_http_ssi_param_t_239 {
   ngx_str_t name ;
   ngx_uint_t index ;
   unsigned int mandatory : 1 ;
   unsigned int multiple : 1 ;
};
#line 91 "src/http/modules/ngx_http_ssi_filter_module.h"
typedef struct __anonstruct_ngx_http_ssi_param_t_239 ngx_http_ssi_param_t;
#line 100 "src/http/modules/ngx_http_ssi_filter_module.h"
struct __anonstruct_ngx_http_ssi_command_t_240 {
   ngx_str_t name ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx , ngx_str_t ** ) ;
   ngx_http_ssi_param_t *params ;
   unsigned int conditional : 2 ;
   unsigned int block : 1 ;
   unsigned int flush : 1 ;
};
#line 100 "src/http/modules/ngx_http_ssi_filter_module.h"
typedef struct __anonstruct_ngx_http_ssi_command_t_240 ngx_http_ssi_command_t;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
struct __anonstruct_ngx_http_ssi_loc_conf_t_242 {
   ngx_flag_t enable ;
   ngx_flag_t silent_errors ;
   ngx_flag_t ignore_recycled_buffers ;
   ngx_flag_t last_modified ;
   ngx_hash_t types ;
   size_t min_file_chunk ;
   size_t value_len ;
   ngx_array_t *types_keys ;
};
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
typedef struct __anonstruct_ngx_http_ssi_loc_conf_t_242 ngx_http_ssi_loc_conf_t;
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
struct __anonstruct_ngx_http_ssi_var_t_243 {
   ngx_str_t name ;
   ngx_uint_t key ;
   ngx_str_t value ;
};
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
typedef struct __anonstruct_ngx_http_ssi_var_t_243 ngx_http_ssi_var_t;
#line 42 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
struct __anonstruct_ngx_http_ssi_block_t_244 {
   ngx_str_t name ;
   ngx_chain_t *bufs ;
   ngx_uint_t count ;
};
#line 42 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
typedef struct __anonstruct_ngx_http_ssi_block_t_244 ngx_http_ssi_block_t;
#line 49
enum __anonenum_ngx_http_ssi_state_e_245 {
    ssi_start_state = 0,
    ssi_tag_state = 1,
    ssi_comment0_state = 2,
    ssi_comment1_state = 3,
    ssi_sharp_state = 4,
    ssi_precommand_state = 5,
    ssi_command_state = 6,
    ssi_preparam_state = 7,
    ssi_param_state = 8,
    ssi_preequal_state = 9,
    ssi_prevalue_state = 10,
    ssi_double_quoted_value_state = 11,
    ssi_quoted_value_state = 12,
    ssi_quoted_symbol_state = 13,
    ssi_postparam_state = 14,
    ssi_comment_end0_state = 15,
    ssi_comment_end1_state = 16,
    ssi_error_state = 17,
    ssi_error_end0_state = 18,
    ssi_error_end1_state = 19
} ;
#line 49 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
typedef enum __anonenum_ngx_http_ssi_state_e_245 ngx_http_ssi_state_e;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 391 "/home/khheo/.linuxbrew/include/zconf.h"
typedef unsigned char Byte;
#line 393 "/home/khheo/.linuxbrew/include/zconf.h"
typedef unsigned int uInt;
#line 394 "/home/khheo/.linuxbrew/include/zconf.h"
typedef unsigned long uLong;
#line 400 "/home/khheo/.linuxbrew/include/zconf.h"
typedef Byte Bytef;
#line 409 "/home/khheo/.linuxbrew/include/zconf.h"
typedef void *voidpf;
#line 84 "/home/khheo/.linuxbrew/include/zlib.h"
struct internal_state;
#line 86 "/home/khheo/.linuxbrew/include/zlib.h"
struct z_stream_s {
   Bytef *next_in ;
   uInt avail_in ;
   uLong total_in ;
   Bytef *next_out ;
   uInt avail_out ;
   uLong total_out ;
   char *msg ;
   struct internal_state *state ;
   voidpf (*zalloc)(voidpf opaque , uInt items , uInt size ) ;
   void (*zfree)(voidpf opaque , voidpf address ) ;
   voidpf opaque ;
   int data_type ;
   uLong adler ;
   uLong reserved ;
};
#line 86 "/home/khheo/.linuxbrew/include/zlib.h"
typedef struct z_stream_s z_stream;
#line 108 "/home/khheo/.linuxbrew/include/zlib.h"
typedef z_stream *z_streamp;
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
struct __anonstruct_ngx_http_gzip_conf_t_242 {
   ngx_flag_t enable ;
   ngx_flag_t no_buffer ;
   ngx_hash_t types ;
   ngx_bufs_t bufs ;
   size_t postpone_gzipping ;
   ngx_int_t level ;
   size_t wbits ;
   size_t memlevel ;
   ssize_t min_length ;
   ngx_array_t *types_keys ;
};
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
typedef struct __anonstruct_ngx_http_gzip_conf_t_242 ngx_http_gzip_conf_t;
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
struct __anonstruct_ngx_http_gzip_ctx_t_243 {
   ngx_chain_t *in ;
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
   ngx_chain_t *out ;
   ngx_chain_t **last_out ;
   ngx_chain_t *copied ;
   ngx_chain_t *copy_buf ;
   ngx_buf_t *in_buf ;
   ngx_buf_t *out_buf ;
   ngx_int_t bufs ;
   void *preallocated ;
   char *free_mem ;
   ngx_uint_t allocated ;
   int wbits ;
   int memlevel ;
   unsigned int flush : 4 ;
   unsigned int redo : 1 ;
   unsigned int done : 1 ;
   unsigned int nomem : 1 ;
   unsigned int gzheader : 1 ;
   unsigned int buffering : 1 ;
   unsigned int intel : 1 ;
   size_t zin ;
   size_t zout ;
   uint32_t crc32 ;
   z_stream zstream ;
   ngx_http_request_t *request ;
};
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
typedef struct __anonstruct_ngx_http_gzip_ctx_t_243 ngx_http_gzip_ctx_t;
#line 73 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
struct gztrailer {
   uint32_t crc32 ;
   uint32_t zlen ;
};
#line 48 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
struct __anonstruct_ngx_http_range_t_242 {
   off_t start ;
   off_t end ;
   ngx_str_t content_range ;
};
#line 48 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
typedef struct __anonstruct_ngx_http_range_t_242 ngx_http_range_t;
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
struct __anonstruct_ngx_http_range_filter_ctx_t_243 {
   off_t offset ;
   ngx_str_t boundary_header ;
   ngx_array_t ranges ;
};
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
typedef struct __anonstruct_ngx_http_range_filter_ctx_t_243 ngx_http_range_filter_ctx_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
struct __anonstruct_ngx_http_chunked_filter_ctx_t_242 {
   ngx_chain_t *free ;
   ngx_chain_t *busy ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
typedef struct __anonstruct_ngx_http_chunked_filter_ctx_t_242 ngx_http_chunked_filter_ctx_t;
#line 175 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_header_out_t_179 {
   ngx_str_t name ;
   ngx_uint_t offset ;
};
#line 175 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_header_out_t_179 ngx_http_header_out_t;
#line 140 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __useconds_t;
#line 87 "src/core/ngx_file.h"
struct __anonstruct_ngx_ext_rename_file_t_126 {
   ngx_uint_t access ;
   ngx_uint_t path_access ;
   time_t time ;
   ngx_fd_t fd ;
   unsigned int create_path : 1 ;
   unsigned int delete_file : 1 ;
   ngx_log_t *log ;
};
#line 87 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_ext_rename_file_t_126 ngx_ext_rename_file_t;
#line 111
struct ngx_tree_ctx_s;
#line 111 "src/core/ngx_file.h"
typedef struct ngx_tree_ctx_s ngx_tree_ctx_t;
#line 116 "src/core/ngx_file.h"
struct ngx_tree_ctx_s {
   off_t size ;
   off_t fs_size ;
   ngx_uint_t access ;
   time_t mtime ;
   ngx_int_t (*init_handler)(void *ctx , void *prev ) ;
   ngx_int_t (*file_handler)(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
   ngx_int_t (*pre_tree_handler)(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
   ngx_int_t (*post_tree_handler)(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
   ngx_int_t (*spec_handler)(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
   void *data ;
   size_t alloc ;
   ngx_log_t *log ;
};
#line 20 "src/http/ngx_http.h"
struct ngx_http_log_ctx_s;
#line 20 "src/http/ngx_http.h"
typedef struct ngx_http_log_ctx_s ngx_http_log_ctx_t;
#line 33 "src/http/ngx_http_cache.h"
struct __anonstruct_ngx_http_cache_valid_t_233 {
   ngx_uint_t status ;
   time_t valid ;
};
#line 33 "src/http/ngx_http_cache.h"
typedef struct __anonstruct_ngx_http_cache_valid_t_233 ngx_http_cache_valid_t;
#line 126 "src/http/ngx_http_cache.h"
struct __anonstruct_ngx_http_file_cache_header_t_235 {
   ngx_uint_t version ;
   time_t valid_sec ;
   time_t updating_sec ;
   time_t error_sec ;
   time_t last_modified ;
   time_t date ;
   uint32_t crc32 ;
   u_short valid_msec ;
   u_short header_start ;
   u_short body_start ;
   u_char etag_len ;
   u_char etag[128] ;
   u_char vary_len ;
   u_char vary[128] ;
   u_char variant[16] ;
};
#line 126 "src/http/ngx_http_cache.h"
typedef struct __anonstruct_ngx_http_file_cache_header_t_235 ngx_http_file_cache_header_t;
#line 52 "src/http/ngx_http.h"
struct ngx_http_log_ctx_s {
   ngx_connection_t *connection ;
   ngx_http_request_t *request ;
   ngx_http_request_t *current_request ;
};
#line 16 "src/core/ngx_md5.h"
struct __anonstruct_ngx_md5_t_242 {
   uint64_t bytes ;
   uint32_t a ;
   uint32_t b ;
   uint32_t c ;
   uint32_t d ;
   u_char buffer[64] ;
};
#line 16 "src/core/ngx_md5.h"
typedef struct __anonstruct_ngx_md5_t_242 ngx_md5_t;
#line 92 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_server_t_209 {
   ngx_str_t name ;
   ngx_addr_t *addrs ;
   ngx_uint_t naddrs ;
   ngx_uint_t weight ;
   ngx_uint_t max_conns ;
   ngx_uint_t max_fails ;
   time_t fail_timeout ;
   ngx_msec_t slow_start ;
   ngx_uint_t down ;
   unsigned int backup : 1 ;
};
#line 92 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_server_t_209 ngx_http_upstream_server_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 118 "/usr/include/x86_64-linux-gnu/bits/sched.h"
typedef unsigned long __cpu_mask;
#line 125 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct __anonstruct_cpu_set_t_73 {
   __cpu_mask __bits[1024UL / (8UL * sizeof(__cpu_mask ))] ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/sched.h"
typedef struct __anonstruct_cpu_set_t_73 cpu_set_t;
#line 16 "src/os/unix/ngx_setaffinity.h"
typedef cpu_set_t ngx_cpuset_t;
#line 16 "src/os/unix/ngx_user.h"
typedef uid_t ngx_uid_t;
#line 17 "src/os/unix/ngx_user.h"
typedef gid_t ngx_gid_t;
#line 86 "src/core/ngx_cycle.h"
struct __anonstruct_ngx_core_conf_t_144 {
   ngx_flag_t daemon ;
   ngx_flag_t master ;
   ngx_msec_t timer_resolution ;
   ngx_msec_t shutdown_timeout ;
   ngx_int_t worker_processes ;
   ngx_int_t debug_points ;
   ngx_int_t rlimit_nofile ;
   off_t rlimit_core ;
   int priority ;
   ngx_uint_t cpu_affinity_auto ;
   ngx_uint_t cpu_affinity_n ;
   ngx_cpuset_t *cpu_affinity ;
   char *username ;
   ngx_uid_t user ;
   ngx_gid_t group ;
   ngx_str_t working_directory ;
   ngx_str_t lock_file ;
   ngx_str_t pid ;
   ngx_str_t oldpid ;
   ngx_array_t env ;
   char **environment ;
   ngx_uint_t transparent ;
};
#line 86 "src/core/ngx_cycle.h"
typedef struct __anonstruct_ngx_core_conf_t_144 ngx_core_conf_t;
#line 177 "src/event/ngx_event.h"
struct __anonstruct_ngx_event_actions_t_203 {
   ngx_int_t (*add)(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
   ngx_int_t (*del)(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
   ngx_int_t (*enable)(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
   ngx_int_t (*disable)(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
   ngx_int_t (*add_conn)(ngx_connection_t *c ) ;
   ngx_int_t (*del_conn)(ngx_connection_t *c , ngx_uint_t flags ) ;
   ngx_int_t (*notify)(void (*handler)(ngx_event_t *ev ) ) ;
   ngx_int_t (*process_events)(ngx_cycle_t *cycle , ngx_msec_t timer , ngx_uint_t flags ) ;
   ngx_int_t (*init)(ngx_cycle_t *cycle , ngx_msec_t timer ) ;
   void (*done)(ngx_cycle_t *cycle ) ;
};
#line 177 "src/event/ngx_event.h"
typedef struct __anonstruct_ngx_event_actions_t_203 ngx_event_actions_t;
#line 395 "src/http/ngx_http_upstream.h"
struct __anonstruct_ngx_http_upstream_next_t_215 {
   ngx_uint_t status ;
   ngx_uint_t mask ;
};
#line 395 "src/http/ngx_http_upstream.h"
typedef struct __anonstruct_ngx_http_upstream_next_t_215 ngx_http_upstream_next_t;
#line 290 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_err_page_t_231 {
   ngx_int_t status ;
   ngx_int_t overwrite ;
   ngx_http_complex_value_t value ;
   ngx_str_t args ;
};
#line 290 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_err_page_t_231 ngx_http_err_page_t;
#line 108 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_copy_capture_code_t_193 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t n ;
};
#line 108 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_copy_capture_code_t_193 ngx_http_script_copy_capture_code_t;
#line 154 "src/http/ngx_http_script.h"
struct __anonstruct_ngx_http_script_full_name_code_t_196 {
   void (*code)(ngx_http_script_engine_t *e ) ;
   uintptr_t conf_prefix ;
};
#line 154 "src/http/ngx_http_script.h"
typedef struct __anonstruct_ngx_http_script_full_name_code_t_196 ngx_http_script_full_name_code_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 202 "/usr/include/netinet/tcp.h"
struct tcp_info {
   u_int8_t tcpi_state ;
   u_int8_t tcpi_ca_state ;
   u_int8_t tcpi_retransmits ;
   u_int8_t tcpi_probes ;
   u_int8_t tcpi_backoff ;
   u_int8_t tcpi_options ;
   u_int8_t tcpi_snd_wscale : 4 ;
   u_int8_t tcpi_rcv_wscale : 4 ;
   u_int32_t tcpi_rto ;
   u_int32_t tcpi_ato ;
   u_int32_t tcpi_snd_mss ;
   u_int32_t tcpi_rcv_mss ;
   u_int32_t tcpi_unacked ;
   u_int32_t tcpi_sacked ;
   u_int32_t tcpi_lost ;
   u_int32_t tcpi_retrans ;
   u_int32_t tcpi_fackets ;
   u_int32_t tcpi_last_data_sent ;
   u_int32_t tcpi_last_ack_sent ;
   u_int32_t tcpi_last_data_recv ;
   u_int32_t tcpi_last_ack_recv ;
   u_int32_t tcpi_pmtu ;
   u_int32_t tcpi_rcv_ssthresh ;
   u_int32_t tcpi_rtt ;
   u_int32_t tcpi_rttvar ;
   u_int32_t tcpi_snd_ssthresh ;
   u_int32_t tcpi_snd_cwnd ;
   u_int32_t tcpi_advmss ;
   u_int32_t tcpi_reordering ;
   u_int32_t tcpi_rcv_rtt ;
   u_int32_t tcpi_rcv_space ;
   u_int32_t tcpi_total_retrans ;
};
#line 11 "src/core/ngx_syslog.h"
struct __anonstruct_ngx_syslog_peer_t_170 {
   ngx_pool_t *pool ;
   ngx_uint_t facility ;
   ngx_uint_t severity ;
   ngx_str_t tag ;
   ngx_addr_t server ;
   ngx_connection_t conn ;
   unsigned int busy : 1 ;
   unsigned int nohostname : 1 ;
};
#line 11 "src/core/ngx_syslog.h"
typedef struct __anonstruct_ngx_syslog_peer_t_170 ngx_syslog_peer_t;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct ngx_http_log_op_s;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
typedef struct ngx_http_log_op_s ngx_http_log_op_t;
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct ngx_http_log_op_s {
   size_t len ;
   size_t (*getlen)(ngx_http_request_t *r , uintptr_t data ) ;
   u_char *(*run)(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
   uintptr_t data ;
};
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_fmt_t_242 {
   ngx_str_t name ;
   ngx_array_t *flushes ;
   ngx_array_t *ops ;
};
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_fmt_t_242 ngx_http_log_fmt_t;
#line 41 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_main_conf_t_243 {
   ngx_array_t formats ;
   ngx_uint_t combined_used ;
};
#line 41 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_main_conf_t_243 ngx_http_log_main_conf_t;
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_buf_t_244 {
   u_char *start ;
   u_char *pos ;
   u_char *last ;
   ngx_event_t *event ;
   ngx_msec_t flush ;
   ngx_int_t gzip ;
};
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_buf_t_244 ngx_http_log_buf_t;
#line 58 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_script_t_245 {
   ngx_array_t *lengths ;
   ngx_array_t *values ;
};
#line 58 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_script_t_245 ngx_http_log_script_t;
#line 64 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_t_246 {
   ngx_open_file_t *file ;
   ngx_http_log_script_t *script ;
   time_t disk_full_time ;
   time_t error_log_time ;
   ngx_syslog_peer_t *syslog_peer ;
   ngx_http_log_fmt_t *format ;
   ngx_http_complex_value_t *filter ;
};
#line 64 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_t_246 ngx_http_log_t;
#line 75 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_loc_conf_t_247 {
   ngx_array_t *logs ;
   ngx_open_file_cache_t *open_file_cache ;
   time_t open_file_cache_valid ;
   ngx_uint_t open_file_cache_min_uses ;
   ngx_uint_t off ;
};
#line 75 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_loc_conf_t_247 ngx_http_log_loc_conf_t;
#line 86 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
struct __anonstruct_ngx_http_log_var_t_248 {
   ngx_str_t name ;
   size_t len ;
   u_char *(*run)(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
};
#line 86 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
typedef struct __anonstruct_ngx_http_log_var_t_248 ngx_http_log_var_t;
#line 107 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
enum __anonenum_state_242 {
    sw_start = 0,
    sw_method = 1,
    sw_spaces_before_uri = 2,
    sw_schema = 3,
    sw_schema_slash = 4,
    sw_schema_slash_slash = 5,
    sw_host_start = 6,
    sw_host = 7,
    sw_host_end = 8,
    sw_host_ip_literal = 9,
    sw_port = 10,
    sw_host_http_09 = 11,
    sw_after_slash_in_uri = 12,
    sw_check_uri = 13,
    sw_check_uri_http_09 = 14,
    sw_uri = 15,
    sw_http_09 = 16,
    sw_http_H = 17,
    sw_http_HT = 18,
    sw_http_HTT = 19,
    sw_http_HTTP = 20,
    sw_first_major_digit = 21,
    sw_major_digit = 22,
    sw_first_minor_digit = 23,
    sw_minor_digit = 24,
    sw_spaces_after_digit = 25,
    sw_almost_done = 26
} ;
#line 846
enum __anonenum_state_243___0 {
    sw_start___0 = 0,
    sw_name = 1,
    sw_space_before_value = 2,
    sw_value = 3,
    sw_space_after_value = 4,
    sw_ignore_line = 5,
    sw_almost_done___0 = 6,
    sw_header_almost_done = 7
} ;
#line 1113
enum __anonenum_state_244 {
    sw_start___1 = 0,
    sw_after_slash_in_uri___0 = 1,
    sw_check_uri___0 = 2,
    sw_uri___0 = 3
} ;
#line 1261
enum __anonenum_state_245 {
    sw_usual = 0,
    sw_slash = 1,
    sw_dot = 2,
    sw_dot_dot = 3,
    sw_quoted = 4,
    sw_quoted_second = 5
} ;
#line 1605
enum __anonenum_state_246 {
    sw_start___2 = 0,
    sw_H = 1,
    sw_HT = 2,
    sw_HTT = 3,
    sw_HTTP = 4,
    sw_first_major_digit___0 = 5,
    sw_major_digit___0 = 6,
    sw_first_minor_digit___0 = 7,
    sw_minor_digit___0 = 8,
    sw_status = 9,
    sw_space_after_status = 10,
    sw_status_text = 11,
    sw_almost_done___1 = 12
} ;
#line 2132
enum __anonenum_state_247 {
    sw_chunk_start = 0,
    sw_chunk_size = 1,
    sw_chunk_extension = 2,
    sw_chunk_extension_almost_done = 3,
    sw_chunk_data = 4,
    sw_after_data = 5,
    sw_after_data_almost_done = 6,
    sw_last_chunk_extension = 7,
    sw_last_chunk_extension_almost_done = 8,
    sw_trailer = 9,
    sw_trailer_almost_done = 10,
    sw_trailer_header = 11,
    sw_trailer_header_almost_done = 12
} ;
#line 379 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct linger {
   int l_onoff ;
   int l_linger ;
};
#line 168 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_header_t_178 {
   ngx_str_t name ;
   ngx_uint_t offset ;
   ngx_int_t (*handler)(ngx_http_request_t *r , ngx_table_elt_t *h , ngx_uint_t offset ) ;
};
#line 168 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_header_t_178 ngx_http_header_t;
#line 589 "src/http/ngx_http_request.h"
struct __anonstruct_ngx_http_ephemeral_t_185 {
   ngx_http_posted_request_t terminal_posted_request ;
};
#line 589 "src/http/ngx_http_request.h"
typedef struct __anonstruct_ngx_http_ephemeral_t_185 ngx_http_ephemeral_t;
#line 242 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_in_addr_t_226 {
   in_addr_t addr ;
   ngx_http_addr_conf_t conf ;
};
#line 242 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_in_addr_t_226 ngx_http_in_addr_t;
#line 250 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_in6_addr_t_227 {
   struct in6_addr addr6 ;
   ngx_http_addr_conf_t conf ;
};
#line 250 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_in6_addr_t_227 ngx_http_in6_addr_t;
#line 258 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_port_t_228 {
   void *addrs ;
   ngx_uint_t naddrs ;
};
#line 258 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_port_t_228 ngx_http_port_t;
#line 1960 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
enum __anonenum_state_242___0 {
    sw_usual___0 = 0,
    sw_literal = 1,
    sw_rest = 2
} ;
#line 26 "src/os/unix/ngx_os.h"
struct __anonstruct_ngx_os_io_t_165 {
   ssize_t (*recv)(ngx_connection_t *c , u_char *buf , size_t size ) ;
   ssize_t (*recv_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ssize_t (*udp_recv)(ngx_connection_t *c , u_char *buf , size_t size ) ;
   ssize_t (*send)(ngx_connection_t *c , u_char *buf , size_t size ) ;
   ssize_t (*udp_send)(ngx_connection_t *c , u_char *buf , size_t size ) ;
   ngx_chain_t *(*udp_send_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ngx_chain_t *(*send_chain)(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
   ngx_uint_t flags ;
};
#line 26 "src/os/unix/ngx_os.h"
typedef struct __anonstruct_ngx_os_io_t_165 ngx_os_io_t;
#line 67 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_listen_opt_t_218 {
   ngx_sockaddr_t sockaddr ;
   socklen_t socklen ;
   unsigned int set : 1 ;
   unsigned int default_server : 1 ;
   unsigned int bind : 1 ;
   unsigned int wildcard : 1 ;
   unsigned int ssl : 1 ;
   unsigned int http2 : 1 ;
   unsigned int ipv6only : 1 ;
   unsigned int deferred_accept : 1 ;
   unsigned int reuseport : 1 ;
   unsigned int so_keepalive : 2 ;
   unsigned int proxy_protocol : 1 ;
   int backlog ;
   int rcvbuf ;
   int sndbuf ;
   int fastopen ;
   int tcp_keepidle ;
   int tcp_keepintvl ;
   int tcp_keepcnt ;
   u_char addr[(((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)) + 1UL] ;
};
#line 67 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_listen_opt_t_218 ngx_http_listen_opt_t;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
struct __anonstruct_ngx_http_method_name_t_242 {
   u_char *name ;
   uint32_t method ;
};
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
typedef struct __anonstruct_ngx_http_method_name_t_242 ngx_http_method_name_t;
#line 260 "src/core/ngx_module.h"
struct __anonstruct_ngx_core_module_t_160 {
   ngx_str_t name ;
   void *(*create_conf)(ngx_cycle_t *cycle ) ;
   char *(*init_conf)(ngx_cycle_t *cycle , void *conf ) ;
};
#line 260 "src/core/ngx_module.h"
typedef struct __anonstruct_ngx_core_module_t_160 ngx_core_module_t;
#line 265 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_conf_port_t_229 {
   ngx_int_t family ;
   in_port_t port ;
   ngx_array_t addrs ;
};
#line 265 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_conf_port_t_229 ngx_http_conf_port_t;
#line 272 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_conf_addr_t_230 {
   ngx_http_listen_opt_t opt ;
   ngx_hash_t hash ;
   ngx_hash_wildcard_t *wc_head ;
   ngx_hash_wildcard_t *wc_tail ;
   ngx_uint_t nregex ;
   ngx_http_server_name_t *regex ;
   ngx_http_core_srv_conf_t *default_server ;
   ngx_array_t servers ;
};
#line 272 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_conf_addr_t_230 ngx_http_conf_addr_t;
#line 439 "src/http/ngx_http_core_module.h"
struct __anonstruct_ngx_http_location_queue_t_232 {
   ngx_queue_t queue ;
   ngx_http_core_loc_conf_t *exact ;
   ngx_http_core_loc_conf_t *inclusive ;
   ngx_str_t *name ;
   u_char *file_name ;
   ngx_uint_t line ;
   ngx_queue_t list ;
};
#line 439 "src/http/ngx_http_core_module.h"
typedef struct __anonstruct_ngx_http_location_queue_t_232 ngx_http_location_queue_t;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
struct __anonstruct_ngx_regex_conf_t_171 {
   ngx_flag_t pcre_jit ;
};
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
typedef struct __anonstruct_ngx_regex_conf_t_171 ngx_regex_conf_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 64 "src/os/unix/ngx_os.h"
struct __anonstruct_ngx_iovec_t_166 {
   struct iovec *iovs ;
   ngx_uint_t count ;
   size_t size ;
   ngx_uint_t nalloc ;
};
#line 64 "src/os/unix/ngx_os.h"
typedef struct __anonstruct_ngx_iovec_t_166 ngx_iovec_t;
#line 79 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
union epoll_data {
   void *ptr ;
   int fd ;
   uint32_t u32 ;
   uint64_t u64 ;
};
#line 79 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
typedef union epoll_data epoll_data_t;
#line 87 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
struct epoll_event {
   uint32_t events ;
   epoll_data_t data ;
} __attribute__((__packed__)) ;
#line 457 "src/event/ngx_event.h"
struct __anonstruct_ngx_event_module_t_173 {
   ngx_str_t *name ;
   void *(*create_conf)(ngx_cycle_t *cycle ) ;
   char *(*init_conf)(ngx_cycle_t *cycle , void *conf ) ;
   ngx_event_actions_t actions ;
};
#line 457 "src/event/ngx_event.h"
typedef struct __anonstruct_ngx_event_module_t_173 ngx_event_module_t;
#line 98 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
struct __anonstruct_ngx_epoll_conf_t_174 {
   ngx_uint_t events ;
   ngx_uint_t aio_requests ;
};
#line 98 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
typedef struct __anonstruct_ngx_epoll_conf_t_174 ngx_epoll_conf_t;
#line 48 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
struct utsname {
   char sysname[65] ;
   char nodename[65] ;
   char release[65] ;
   char version[65] ;
   char machine[65] ;
   char domainname[65] ;
};
#line 137 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim64_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 91 "/usr/include/x86_64-linux-gnu/sys/time.h"
enum __itimer_which {
    ITIMER_REAL = 0,
    ITIMER_VIRTUAL = 1,
    ITIMER_PROF = 2
} ;
#line 107 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct itimerval {
   struct timeval it_interval ;
   struct timeval it_value ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef enum __itimer_which __itimer_which_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/resource.h"
enum __rlimit_resource {
    RLIMIT_CPU = 0,
    RLIMIT_FSIZE = 1,
    RLIMIT_DATA = 2,
    RLIMIT_STACK = 3,
    RLIMIT_CORE = 4,
    __RLIMIT_RSS = 5,
    RLIMIT_NOFILE = 7,
    __RLIMIT_OFILE = 7,
    RLIMIT_AS = 9,
    __RLIMIT_NPROC = 6,
    __RLIMIT_MEMLOCK = 8,
    __RLIMIT_LOCKS = 10,
    __RLIMIT_SIGPENDING = 11,
    __RLIMIT_MSGQUEUE = 12,
    __RLIMIT_NICE = 13,
    __RLIMIT_RTPRIO = 14,
    __RLIMIT_RTTIME = 15,
    __RLIMIT_NLIMITS = 16,
    __RLIM_NLIMITS = 16
} ;
#line 133 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim64_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 292
enum __priority_which {
    PRIO_PROCESS = 0,
    PRIO_PGRP = 1,
    PRIO_USER = 2
} ;
#line 38 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __rlimit_resource __rlimit_resource_t;
#line 40 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef enum __priority_which __priority_which_t;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 40 "/usr/include/linux/capability.h"
struct __user_cap_header_struct {
   __u32 version ;
   int pid ;
};
#line 45 "/usr/include/linux/capability.h"
struct __user_cap_data_struct {
   __u32 effective ;
   __u32 permitted ;
   __u32 inheritable ;
};
#line 22 "src/os/unix/ngx_process.h"
struct __anonstruct_ngx_process_t_107 {
   ngx_pid_t pid ;
   int status ;
   ngx_socket_t channel[2] ;
   void (*proc)(ngx_cycle_t *cycle , void *data ) ;
   void *data ;
   char *name ;
   unsigned int respawn : 1 ;
   unsigned int just_spawn : 1 ;
   unsigned int detached : 1 ;
   unsigned int exiting : 1 ;
   unsigned int exited : 1 ;
};
#line 22 "src/os/unix/ngx_process.h"
typedef struct __anonstruct_ngx_process_t_107 ngx_process_t;
#line 30 "src/os/unix/ngx_process_cycle.h"
struct __anonstruct_ngx_cache_manager_ctx_t_152 {
   void (*handler)(ngx_event_t *ev ) ;
   char *name ;
   ngx_msec_t delay ;
};
#line 30 "src/os/unix/ngx_process_cycle.h"
typedef struct __anonstruct_ngx_cache_manager_ctx_t_152 ngx_cache_manager_ctx_t;
#line 17 "src/os/unix/ngx_channel.h"
struct __anonstruct_ngx_channel_t_174 {
   ngx_uint_t command ;
   ngx_pid_t pid ;
   ngx_int_t slot ;
   ngx_fd_t fd ;
};
#line 17 "src/os/unix/ngx_channel.h"
typedef struct __anonstruct_ngx_channel_t_174 ngx_channel_t;
#line 46 "/usr/include/crypt.h"
struct crypt_data {
   char keysched[128] ;
   char sb0[32768] ;
   char sb1[32768] ;
   char sb2[32768] ;
   char sb3[32768] ;
   char crypt_3_buf[14] ;
   char current_salt[2] ;
   long current_saltbits ;
   int direction ;
   int initialized ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_34 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_36 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_37 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_38 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_39 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_32 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_33 _kill ;
   struct __anonstruct__timer_34 _timer ;
   struct __anonstruct__rt_35 _rt ;
   struct __anonstruct__sigchld_36 _sigchld ;
   struct __anonstruct__sigfault_37 _sigfault ;
   struct __anonstruct__sigpoll_38 _sigpoll ;
   struct __anonstruct__sigsys_39 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_31 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_32 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_31 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_51 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_51 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 39 "src/os/unix/ngx_process.h"
struct __anonstruct_ngx_exec_ctx_t_108 {
   char *path ;
   char *name ;
   char * const  *argv ;
   char * const  *envp ;
};
#line 39 "src/os/unix/ngx_process.h"
typedef struct __anonstruct_ngx_exec_ctx_t_108 ngx_exec_ctx_t;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
struct __anonstruct_ngx_signal_t_175 {
   int signo ;
   char *signame ;
   char *name ;
   void (*handler)(int signo , siginfo_t *siginfo , void *ucontext ) ;
};
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
typedef struct __anonstruct_ngx_signal_t_175 ngx_signal_t;
#line 535 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
union __anonunion_176 {
   int __in ;
   int __i ;
};
#line 535 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
union __anonunion_177 {
   int __in ;
   int __i ;
};
#line 535 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
union __anonunion_178 {
   int __in ;
   int __i ;
};
#line 546 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
union __anonunion_179 {
   int __in ;
   int __i ;
};
#line 533 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
union __anonunion_180 {
   int __in ;
   int __i ;
};
#line 552 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
union __anonunion_181 {
   int __in ;
   int __i ;
};
#line 551 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
union __anonunion_182 {
   int __in ;
   int __i ;
};
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 224 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct msghdr {
   void *msg_name ;
   socklen_t msg_namelen ;
   struct iovec *msg_iov ;
   size_t msg_iovlen ;
   void *msg_control ;
   size_t msg_controllen ;
   int msg_flags ;
};
#line 242 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct cmsghdr {
   size_t cmsg_len ;
   int cmsg_level ;
   int cmsg_type ;
   unsigned char __cmsg_data[] ;
};
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_channel.c"
union __anonunion_cmsg_175 {
   struct cmsghdr cm ;
   char space[(((sizeof(int ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
};
#line 104 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_channel.c"
union __anonunion_cmsg_176 {
   struct cmsghdr cm ;
   char space[(((sizeof(int ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/in.h"
struct in_pktinfo {
   int ipi_ifindex ;
   struct in_addr ipi_spec_dst ;
   struct in_addr ipi_addr ;
};
#line 534 "/usr/include/netinet/in.h"
struct in6_pktinfo {
   struct in6_addr ipi6_addr ;
   unsigned int ipi6_ifindex ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
struct __anonstruct___fsid_t_1 {
   int __val[2] ;
};
#line 134 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef struct __anonstruct___fsid_t_1 __fsid_t;
#line 163 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsblkcnt64_t;
#line 167 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __fsfilcnt64_t;
#line 170 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __fsword_t;
#line 82 "/usr/include/glob.h"
struct __anonstruct_glob_t_57 {
   size_t gl_pathc ;
   char **gl_pathv ;
   size_t gl_offs ;
   int gl_flags ;
   void (*gl_closedir)(void * ) ;
   struct dirent *(*gl_readdir)(void * ) ;
   void *(*gl_opendir)(char const   * ) ;
   int (*gl_lstat)(char const   * __restrict   , struct stat * __restrict   ) ;
   int (*gl_stat)(char const   * __restrict   , struct stat * __restrict   ) ;
};
#line 82 "/usr/include/glob.h"
typedef struct __anonstruct_glob_t_57 glob_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/statfs.h"
struct statfs {
   __fsword_t f_type ;
   __fsword_t f_bsize ;
   __fsblkcnt64_t f_blocks ;
   __fsblkcnt64_t f_bfree ;
   __fsblkcnt64_t f_bavail ;
   __fsfilcnt64_t f_files ;
   __fsfilcnt64_t f_ffree ;
   __fsid_t f_fsid ;
   __fsword_t f_namelen ;
   __fsword_t f_frsize ;
   __fsword_t f_flags ;
   __fsword_t f_spare[4] ;
};
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off64_t l_start ;
   __off64_t l_len ;
   __pid_t l_pid ;
};
#line 40 "src/os/unix/ngx_files.h"
struct __anonstruct_ngx_glob_t_105 {
   size_t n ;
   glob_t pglob ;
   u_char *pattern ;
   ngx_log_t *log ;
   ngx_uint_t test ;
};
#line 40 "src/os/unix/ngx_files.h"
typedef struct __anonstruct_ngx_glob_t_105 ngx_glob_t;
#line 440 "src/event/ngx_event.h"
struct __anonstruct_ngx_event_conf_t_172 {
   ngx_uint_t connections ;
   ngx_uint_t use ;
   ngx_flag_t multi_accept ;
   ngx_flag_t accept_mutex ;
   ngx_msec_t accept_mutex_delay ;
   u_char *name ;
};
#line 440 "src/event/ngx_event.h"
typedef struct __anonstruct_ngx_event_conf_t_172 ngx_event_conf_t;
#line 97 "src/os/unix/ngx_atomic.h"
typedef long ngx_atomic_int_t;
#line 16 "src/core/ngx_sha1.h"
struct __anonstruct_ngx_sha1_t_172 {
   uint64_t bytes ;
   uint32_t a ;
   uint32_t b ;
   uint32_t c ;
   uint32_t d ;
   uint32_t e ;
   uint32_t f ;
   u_char buffer[64] ;
};
#line 16 "src/core/ngx_sha1.h"
typedef struct __anonstruct_ngx_sha1_t_172 ngx_sha1_t;
#line 68 "src/core/ngx_palloc.h"
struct __anonstruct_ngx_pool_cleanup_file_t_110 {
   ngx_fd_t fd ;
   u_char *name ;
   ngx_log_t *log ;
};
#line 68 "src/core/ngx_palloc.h"
typedef struct __anonstruct_ngx_pool_cleanup_file_t_110 ngx_pool_cleanup_file_t;
#line 54 "src/core/ngx_open_file_cache.h"
struct ngx_cached_open_file_s;
#line 54 "src/core/ngx_open_file_cache.h"
typedef struct ngx_cached_open_file_s ngx_cached_open_file_t;
#line 56 "src/core/ngx_open_file_cache.h"
struct ngx_cached_open_file_s {
   ngx_rbtree_node_t node ;
   ngx_queue_t queue ;
   u_char *name ;
   time_t created ;
   time_t accessed ;
   ngx_fd_t fd ;
   ngx_file_uniq_t uniq ;
   time_t mtime ;
   off_t size ;
   ngx_err_t err ;
   uint32_t uses ;
   size_t disable_symlinks_from ;
   unsigned int disable_symlinks : 2 ;
   unsigned int count : 24 ;
   unsigned int close : 1 ;
   unsigned int use_event : 1 ;
   unsigned int is_dir : 1 ;
   unsigned int is_file : 1 ;
   unsigned int is_link : 1 ;
   unsigned int is_exec : 1 ;
   unsigned int is_directio : 1 ;
   ngx_event_t *event ;
};
#line 102 "src/core/ngx_open_file_cache.h"
struct __anonstruct_ngx_open_file_cache_cleanup_t_163 {
   ngx_open_file_cache_t *cache ;
   ngx_cached_open_file_t *file ;
   ngx_uint_t min_uses ;
   ngx_log_t *log ;
};
#line 102 "src/core/ngx_open_file_cache.h"
typedef struct __anonstruct_ngx_open_file_cache_cleanup_t_163 ngx_open_file_cache_cleanup_t;
#line 110 "src/core/ngx_open_file_cache.h"
struct __anonstruct_ngx_open_file_cache_event_t_164 {
   void *data ;
   ngx_event_t *read ;
   ngx_event_t *write ;
   ngx_fd_t fd ;
   ngx_cached_open_file_t *file ;
   ngx_open_file_cache_t *cache ;
};
#line 110 "src/core/ngx_open_file_cache.h"
typedef struct __anonstruct_ngx_open_file_cache_event_t_164 ngx_open_file_cache_event_t;
#line 196 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef int int32_t;
#line 43 "src/core/ngx_resolver.h"
struct __anonstruct_ngx_resolver_connection_t_145 {
   ngx_connection_t *udp ;
   ngx_connection_t *tcp ;
   struct sockaddr *sockaddr ;
   socklen_t socklen ;
   ngx_str_t server ;
   ngx_log_t log ;
   ngx_buf_t *read_buf ;
   ngx_buf_t *write_buf ;
   ngx_resolver_t *resolver ;
};
#line 43 "src/core/ngx_resolver.h"
typedef struct __anonstruct_ngx_resolver_connection_t_145 ngx_resolver_connection_t;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
struct __anonstruct_ngx_resolver_hdr_t_174 {
   u_char ident_hi ;
   u_char ident_lo ;
   u_char flags_hi ;
   u_char flags_lo ;
   u_char nqs_hi ;
   u_char nqs_lo ;
   u_char nan_hi ;
   u_char nan_lo ;
   u_char nns_hi ;
   u_char nns_lo ;
   u_char nar_hi ;
   u_char nar_lo ;
};
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
typedef struct __anonstruct_ngx_resolver_hdr_t_174 ngx_resolver_hdr_t;
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
struct __anonstruct_ngx_resolver_qs_t_175 {
   u_char type_hi ;
   u_char type_lo ;
   u_char class_hi ;
   u_char class_lo ;
};
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
typedef struct __anonstruct_ngx_resolver_qs_t_175 ngx_resolver_qs_t;
#line 43 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
struct __anonstruct_ngx_resolver_an_t_176 {
   u_char type_hi ;
   u_char type_lo ;
   u_char class_hi ;
   u_char class_lo ;
   u_char ttl[4] ;
   u_char len_hi ;
   u_char len_lo ;
};
#line 43 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
typedef struct __anonstruct_ngx_resolver_an_t_176 ngx_resolver_an_t;
#line 40 "/home/khheo/.linuxbrew/Cellar/gcc/5.3.0/lib/gcc/x86_64-unknown-linux-gnu/5.3.0/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/home/khheo/.linuxbrew/Cellar/gcc/5.3.0/lib/gcc/x86_64-unknown-linux-gnu/5.3.0/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 106 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_dump_t_154 {
   ngx_str_t name ;
   ngx_buf_t *buffer ;
};
#line 106 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_dump_t_154 ngx_conf_dump_t;
#line 143 "src/core/ngx_conf_file.h"
struct __anonstruct_ngx_conf_deprecated_t_156 {
   char *(*post_handler)(ngx_conf_t *cf , void *data , void *conf ) ;
   char *old_name ;
   char *new_name ;
};
#line 143 "src/core/ngx_conf_file.h"
typedef struct __anonstruct_ngx_conf_deprecated_t_156 ngx_conf_deprecated_t;
#line 165 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
enum __anonenum_type_171 {
    parse_file = 0,
    parse_block = 1,
    parse_param = 2
} ;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 100 "src/core/ngx_file.h"
struct __anonstruct_ngx_copy_file_t_127 {
   off_t size ;
   size_t buf_size ;
   ngx_uint_t access ;
   time_t time ;
   ngx_log_t *log ;
};
#line 100 "src/core/ngx_file.h"
typedef struct __anonstruct_ngx_copy_file_t_127 ngx_copy_file_t;
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 21 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_parse_time.c"
enum __anonenum_fmt_171 {
    no = 0,
    rfc822 = 1,
    rfc850 = 2,
    isoc = 3
} ;
#line 118 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_parse.c"
enum __anonenum_step_171 {
    st_start = 0,
    st_year = 1,
    st_month = 2,
    st_week = 3,
    st_day = 4,
    st_hour = 5,
    st_min = 6,
    st_sec = 7,
    st_msec = 8,
    st_last = 9
} ;
#line 197 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef long int64_t;
#line 1613 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
enum __anonenum_state_171 {
    sw_usual___1 = 0,
    sw_quoted___0 = 1,
    sw_quoted_second___0 = 2
} ;
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 264 "src/core/ngx_log.h"
ngx_module_t ngx_errlog_module ;
#line 140 "src/core/ngx_cycle.h"
ngx_module_t ngx_core_module ;
#line 277 "src/core/ngx_module.h"
ngx_module_t *ngx_modules[51] ;
#line 280
char *ngx_module_names[51] ;
#line 9 "/home/khheo/project/nginx-release-1.13.8/objs/ngx_modules.c"
ngx_module_t ngx_conf_module ;
#line 10
ngx_module_t ngx_regex_module ;
#line 11
ngx_module_t ngx_events_module ;
#line 12
ngx_module_t ngx_event_core_module ;
#line 13
ngx_module_t ngx_epoll_module ;
#line 14
ngx_module_t ngx_http_module ;
#line 15
ngx_module_t ngx_http_core_module ;
#line 16
ngx_module_t ngx_http_log_module ;
#line 17
ngx_module_t ngx_http_upstream_module ;
#line 18
ngx_module_t ngx_http_static_module ;
#line 19
ngx_module_t ngx_http_autoindex_module ;
#line 20
ngx_module_t ngx_http_index_module ;
#line 21
ngx_module_t ngx_http_mirror_module ;
#line 22
ngx_module_t ngx_http_try_files_module ;
#line 23
ngx_module_t ngx_http_auth_basic_module ;
#line 24
ngx_module_t ngx_http_access_module ;
#line 25
ngx_module_t ngx_http_limit_conn_module ;
#line 26
ngx_module_t ngx_http_limit_req_module ;
#line 27
ngx_module_t ngx_http_geo_module ;
#line 28
ngx_module_t ngx_http_map_module ;
#line 29
ngx_module_t ngx_http_split_clients_module ;
#line 30
ngx_module_t ngx_http_referer_module ;
#line 31
ngx_module_t ngx_http_rewrite_module ;
#line 32
ngx_module_t ngx_http_proxy_module ;
#line 33
ngx_module_t ngx_http_fastcgi_module ;
#line 34
ngx_module_t ngx_http_uwsgi_module ;
#line 35
ngx_module_t ngx_http_scgi_module ;
#line 36
ngx_module_t ngx_http_memcached_module ;
#line 37
ngx_module_t ngx_http_empty_gif_module ;
#line 38
ngx_module_t ngx_http_browser_module ;
#line 39
ngx_module_t ngx_http_upstream_hash_module ;
#line 40
ngx_module_t ngx_http_upstream_ip_hash_module ;
#line 41
ngx_module_t ngx_http_upstream_least_conn_module ;
#line 42
ngx_module_t ngx_http_upstream_keepalive_module ;
#line 43
ngx_module_t ngx_http_upstream_zone_module ;
#line 44
ngx_module_t ngx_http_write_filter_module ;
#line 45
ngx_module_t ngx_http_header_filter_module ;
#line 46
ngx_module_t ngx_http_chunked_filter_module ;
#line 47
ngx_module_t ngx_http_range_header_filter_module ;
#line 48
ngx_module_t ngx_http_gzip_filter_module ;
#line 49
ngx_module_t ngx_http_postpone_filter_module ;
#line 50
ngx_module_t ngx_http_ssi_filter_module ;
#line 51
ngx_module_t ngx_http_charset_filter_module ;
#line 52
ngx_module_t ngx_http_userid_filter_module ;
#line 53
ngx_module_t ngx_http_headers_filter_module ;
#line 54
ngx_module_t ngx_http_copy_filter_module ;
#line 55
ngx_module_t ngx_http_range_body_filter_module ;
#line 56
ngx_module_t ngx_http_not_modified_filter_module ;
#line 58 "/home/khheo/project/nginx-release-1.13.8/objs/ngx_modules.c"
ngx_module_t *ngx_modules[51]  = 
#line 58
  {      & ngx_core_module,      & ngx_errlog_module,      & ngx_conf_module,      & ngx_regex_module, 
        & ngx_events_module,      & ngx_event_core_module,      & ngx_epoll_module,      & ngx_http_module, 
        & ngx_http_core_module,      & ngx_http_log_module,      & ngx_http_upstream_module,      & ngx_http_static_module, 
        & ngx_http_autoindex_module,      & ngx_http_index_module,      & ngx_http_mirror_module,      & ngx_http_try_files_module, 
        & ngx_http_auth_basic_module,      & ngx_http_access_module,      & ngx_http_limit_conn_module,      & ngx_http_limit_req_module, 
        & ngx_http_geo_module,      & ngx_http_map_module,      & ngx_http_split_clients_module,      & ngx_http_referer_module, 
        & ngx_http_rewrite_module,      & ngx_http_proxy_module,      & ngx_http_fastcgi_module,      & ngx_http_uwsgi_module, 
        & ngx_http_scgi_module,      & ngx_http_memcached_module,      & ngx_http_empty_gif_module,      & ngx_http_browser_module, 
        & ngx_http_upstream_hash_module,      & ngx_http_upstream_ip_hash_module,      & ngx_http_upstream_least_conn_module,      & ngx_http_upstream_keepalive_module, 
        & ngx_http_upstream_zone_module,      & ngx_http_write_filter_module,      & ngx_http_header_filter_module,      & ngx_http_chunked_filter_module, 
        & ngx_http_range_header_filter_module,      & ngx_http_gzip_filter_module,      & ngx_http_postpone_filter_module,      & ngx_http_ssi_filter_module, 
        & ngx_http_charset_filter_module,      & ngx_http_userid_filter_module,      & ngx_http_headers_filter_module,      & ngx_http_copy_filter_module, 
        & ngx_http_range_body_filter_module,      & ngx_http_not_modified_filter_module,      (ngx_module_t *)((void *)0)};
#line 112 "/home/khheo/project/nginx-release-1.13.8/objs/ngx_modules.c"
char *ngx_module_names[51]  = 
#line 112
  {      (char *)"ngx_core_module",      (char *)"ngx_errlog_module",      (char *)"ngx_conf_module",      (char *)"ngx_regex_module", 
        (char *)"ngx_events_module",      (char *)"ngx_event_core_module",      (char *)"ngx_epoll_module",      (char *)"ngx_http_module", 
        (char *)"ngx_http_core_module",      (char *)"ngx_http_log_module",      (char *)"ngx_http_upstream_module",      (char *)"ngx_http_static_module", 
        (char *)"ngx_http_autoindex_module",      (char *)"ngx_http_index_module",      (char *)"ngx_http_mirror_module",      (char *)"ngx_http_try_files_module", 
        (char *)"ngx_http_auth_basic_module",      (char *)"ngx_http_access_module",      (char *)"ngx_http_limit_conn_module",      (char *)"ngx_http_limit_req_module", 
        (char *)"ngx_http_geo_module",      (char *)"ngx_http_map_module",      (char *)"ngx_http_split_clients_module",      (char *)"ngx_http_referer_module", 
        (char *)"ngx_http_rewrite_module",      (char *)"ngx_http_proxy_module",      (char *)"ngx_http_fastcgi_module",      (char *)"ngx_http_uwsgi_module", 
        (char *)"ngx_http_scgi_module",      (char *)"ngx_http_memcached_module",      (char *)"ngx_http_empty_gif_module",      (char *)"ngx_http_browser_module", 
        (char *)"ngx_http_upstream_hash_module",      (char *)"ngx_http_upstream_ip_hash_module",      (char *)"ngx_http_upstream_least_conn_module",      (char *)"ngx_http_upstream_keepalive_module", 
        (char *)"ngx_http_upstream_zone_module",      (char *)"ngx_http_write_filter_module",      (char *)"ngx_http_header_filter_module",      (char *)"ngx_http_chunked_filter_module", 
        (char *)"ngx_http_range_header_filter_module",      (char *)"ngx_http_gzip_filter_module",      (char *)"ngx_http_postpone_filter_module",      (char *)"ngx_http_ssi_filter_module", 
        (char *)"ngx_http_charset_filter_module",      (char *)"ngx_http_userid_filter_module",      (char *)"ngx_http_headers_filter_module",      (char *)"ngx_http_copy_filter_module", 
        (char *)"ngx_http_range_body_filter_module",      (char *)"ngx_http_not_modified_filter_module",      (char *)((void *)0)};
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 151 "src/core/ngx_string.h"
u_char *ngx_sprintf(u_char *buf , char const   *fmt  , ...) ;
#line 16 "src/core/ngx_parse.h"
ssize_t ngx_parse_size(ngx_str_t *line ) ;
#line 40 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_pagesize ;
#line 64 "src/core/ngx_slab.h"
void *ngx_slab_alloc(ngx_slab_pool_t *pool , size_t size ) ;
#line 65
void *ngx_slab_alloc_locked(ngx_slab_pool_t *pool , size_t size ) ;
#line 67
void *ngx_slab_calloc_locked(ngx_slab_pool_t *pool , size_t size ) ;
#line 69
void ngx_slab_free_locked(ngx_slab_pool_t *pool , void *p ) ;
#line 133 "src/core/ngx_cycle.h"
ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf , ngx_str_t *name , size_t size ,
                                      void *tag ) ;
#line 276 "src/core/ngx_conf_file.h"
void ngx_conf_log_error(ngx_uint_t level , ngx_conf_t *cf , ngx_err_t err , char const   *fmt 
                        , ...) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_zone_module.c"
static char *ngx_http_upstream_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 15
static ngx_int_t ngx_http_upstream_init_zone(ngx_shm_zone_t *shm_zone , void *data ) ;
#line 17
static ngx_http_upstream_rr_peers_t *ngx_http_upstream_zone_copy_peers(ngx_slab_pool_t *shpool ,
                                                                       ngx_http_upstream_srv_conf_t *uscf ) ;
#line 19
static ngx_http_upstream_rr_peer_t *ngx_http_upstream_zone_copy_peer(ngx_http_upstream_rr_peers_t *peers ,
                                                                     ngx_http_upstream_rr_peer_t *src ) ;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_command_t ngx_http_upstream_zone_commands[2]  = {      {{sizeof("zone") - 1UL, (u_char *)"zone"}, (ngx_uint_t )268435462, & ngx_http_upstream_zone,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 36 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_http_module_t ngx_http_upstream_zone_module_ctx  = 
#line 36
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_zone_module.c"
ngx_module_t ngx_http_upstream_zone_module  = 
#line 51
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_zone_module_ctx),
    ngx_http_upstream_zone_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 67 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_zone_module.c"
static char *ngx_http_upstream_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ssize_t size ;
  ngx_str_t *value ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_main_conf_t *umcf ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 75
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 76
  umcf = (ngx_http_upstream_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_upstream_module.ctx_index);
#line 78
  value = (ngx_str_t *)(cf->args)->elts;
#line 80
  if (! (value + 1)->len) {
    {
#line 81
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone name \"%V\"", value + 1);
    }
#line 83
    return ((char *)((void *)-1));
  }
#line 86
  if ((cf->args)->nelts == 3UL) {
    {
#line 87
    size = ngx_parse_size(value + 2);
    }
#line 89
    if (size == -1L) {
      {
#line 90
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + 2);
      }
#line 92
      return ((char *)((void *)-1));
    }
#line 95
    if (size < (ssize_t )(8UL * ngx_pagesize)) {
      {
#line 96
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "zone \"%V\" is too small", value + 1);
      }
#line 98
      return ((char *)((void *)-1));
    }
  } else {
#line 102
    size = (ssize_t )0;
  }
  {
#line 105
  uscf->shm_zone = ngx_shared_memory_add(cf, value + 1, (size_t )size, (void *)(& ngx_http_upstream_module));
  }
#line 107
  if ((unsigned long )uscf->shm_zone == (unsigned long )((void *)0)) {
#line 108
    return ((char *)((void *)-1));
  }
#line 111
  (uscf->shm_zone)->init = & ngx_http_upstream_init_zone;
#line 112
  (uscf->shm_zone)->data = (void *)umcf;
#line 114
  (uscf->shm_zone)->noreuse = (ngx_uint_t )1;
#line 116
  return ((char *)((void *)0));
}
}
#line 120 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_int_t ngx_http_upstream_init_zone(ngx_shm_zone_t *shm_zone , void *data ) 
{ 
  size_t len ;
  ngx_uint_t i ;
  ngx_slab_pool_t *shpool ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_rr_peers_t **peersp ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_srv_conf_t **uscfp ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 130
  shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;
#line 131
  umcf = (ngx_http_upstream_main_conf_t *)shm_zone->data;
#line 132
  uscfp = (ngx_http_upstream_srv_conf_t **)umcf->upstreams.elts;
#line 134
  if (shm_zone->shm.exists) {
#line 135
    peers = (ngx_http_upstream_rr_peers_t *)shpool->data;
#line 137
    i = (ngx_uint_t )0;
    {
#line 137
    while (1) {
      while_continue: /* CIL Label */ ;
#line 137
      if (! (i < umcf->upstreams.nelts)) {
#line 137
        goto while_break;
      }
#line 138
      uscf = *(uscfp + i);
#line 140
      if ((unsigned long )uscf->shm_zone != (unsigned long )shm_zone) {
#line 141
        goto __Cont;
      }
#line 144
      uscf->peer.data = (void *)peers;
#line 145
      peers = peers->zone_next;
      __Cont: /* CIL Label */ 
#line 137
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 148
    return ((ngx_int_t )0);
  }
  {
#line 151
  len = sizeof(" in upstream zone \"\"") + shm_zone->shm.name.len;
#line 153
  tmp = ngx_slab_alloc(shpool, len);
#line 153
  shpool->log_ctx = (u_char *)tmp;
  }
#line 154
  if ((unsigned long )shpool->log_ctx == (unsigned long )((void *)0)) {
#line 155
    return ((ngx_int_t )-1);
  }
  {
#line 158
  ngx_sprintf(shpool->log_ctx, " in upstream zone \"%V\"%Z", & shm_zone->shm.name);
#line 164
  peersp = (ngx_http_upstream_rr_peers_t **)((void *)(& shpool->data));
#line 166
  i = (ngx_uint_t )0;
  }
  {
#line 166
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 166
    if (! (i < umcf->upstreams.nelts)) {
#line 166
      goto while_break___0;
    }
#line 167
    uscf = *(uscfp + i);
#line 169
    if ((unsigned long )uscf->shm_zone != (unsigned long )shm_zone) {
#line 170
      goto __Cont___0;
    }
    {
#line 173
    peers = ngx_http_upstream_zone_copy_peers(shpool, uscf);
    }
#line 174
    if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 175
      return ((ngx_int_t )-1);
    }
#line 178
    *peersp = peers;
#line 179
    peersp = & peers->zone_next;
    __Cont___0: /* CIL Label */ 
#line 166
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 182
  return ((ngx_int_t )0);
}
}
#line 186 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_http_upstream_rr_peers_t *ngx_http_upstream_zone_copy_peers(ngx_slab_pool_t *shpool ,
                                                                       ngx_http_upstream_srv_conf_t *uscf ) 
{ 
  ngx_str_t *name ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t **peerp ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_rr_peers_t *backup ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 194
  tmp = ngx_slab_alloc(shpool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 194
  peers = (ngx_http_upstream_rr_peers_t *)tmp;
  }
#line 195
  if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 196
    return ((ngx_http_upstream_rr_peers_t *)((void *)0));
  }
  {
#line 199
  memcpy((void */* __restrict  */)peers, (void const   */* __restrict  */)uscf->peer.data,
         sizeof(ngx_http_upstream_rr_peers_t ));
#line 201
  tmp___0 = ngx_slab_alloc(shpool, sizeof(ngx_str_t ));
#line 201
  name = (ngx_str_t *)tmp___0;
  }
#line 202
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 203
    return ((ngx_http_upstream_rr_peers_t *)((void *)0));
  }
  {
#line 206
  tmp___1 = ngx_slab_alloc(shpool, (peers->name)->len);
#line 206
  name->data = (u_char *)tmp___1;
  }
#line 207
  if ((unsigned long )name->data == (unsigned long )((void *)0)) {
#line 208
    return ((ngx_http_upstream_rr_peers_t *)((void *)0));
  }
  {
#line 211
  memcpy((void */* __restrict  */)name->data, (void const   */* __restrict  */)(peers->name)->data,
         (peers->name)->len);
#line 212
  name->len = (peers->name)->len;
#line 214
  peers->name = name;
#line 216
  peers->shpool = shpool;
#line 218
  peerp = & peers->peer;
  }
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
#line 218
    if (! *peerp) {
#line 218
      goto while_break;
    }
    {
#line 220
    peer = ngx_http_upstream_zone_copy_peer(peers, *peerp);
    }
#line 221
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 222
      return ((ngx_http_upstream_rr_peers_t *)((void *)0));
    }
#line 225
    *peerp = peer;
#line 218
    peerp = & peer->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 228
  if ((unsigned long )peers->next == (unsigned long )((void *)0)) {
#line 229
    goto done;
  }
  {
#line 232
  tmp___2 = ngx_slab_alloc(shpool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 232
  backup = (ngx_http_upstream_rr_peers_t *)tmp___2;
  }
#line 233
  if ((unsigned long )backup == (unsigned long )((void *)0)) {
#line 234
    return ((ngx_http_upstream_rr_peers_t *)((void *)0));
  }
  {
#line 237
  memcpy((void */* __restrict  */)backup, (void const   */* __restrict  */)peers->next,
         sizeof(ngx_http_upstream_rr_peers_t ));
#line 239
  backup->name = name;
#line 241
  backup->shpool = shpool;
#line 243
  peerp = & backup->peer;
  }
  {
#line 243
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 243
    if (! *peerp) {
#line 243
      goto while_break___0;
    }
    {
#line 245
    peer = ngx_http_upstream_zone_copy_peer(backup, *peerp);
    }
#line 246
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 247
      return ((ngx_http_upstream_rr_peers_t *)((void *)0));
    }
#line 250
    *peerp = peer;
#line 243
    peerp = & peer->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 253
  peers->next = backup;
  done: 
#line 257
  uscf->peer.data = (void *)peers;
#line 259
  return (peers);
}
}
#line 263 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_zone_module.c"
static ngx_http_upstream_rr_peer_t *ngx_http_upstream_zone_copy_peer(ngx_http_upstream_rr_peers_t *peers ,
                                                                     ngx_http_upstream_rr_peer_t *src ) 
{ 
  ngx_slab_pool_t *pool ;
  ngx_http_upstream_rr_peer_t *dst ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 270
  pool = peers->shpool;
#line 272
  tmp = ngx_slab_calloc_locked(pool, sizeof(ngx_http_upstream_rr_peer_t ));
#line 272
  dst = (ngx_http_upstream_rr_peer_t *)tmp;
  }
#line 273
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 274
    return ((ngx_http_upstream_rr_peer_t *)((void *)0));
  }
#line 277
  if (src) {
    {
#line 278
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, sizeof(ngx_http_upstream_rr_peer_t ));
#line 279
    dst->sockaddr = (struct sockaddr *)((void *)0);
#line 280
    dst->name.data = (u_char *)((void *)0);
#line 281
    dst->server.data = (u_char *)((void *)0);
    }
  }
  {
#line 284
  tmp___0 = ngx_slab_calloc_locked(pool, sizeof(ngx_sockaddr_t ));
#line 284
  dst->sockaddr = (struct sockaddr *)tmp___0;
  }
#line 285
  if ((unsigned long )dst->sockaddr == (unsigned long )((void *)0)) {
#line 286
    goto failed;
  }
  {
#line 289
  tmp___1 = ngx_slab_calloc_locked(pool, ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path));
#line 289
  dst->name.data = (u_char *)tmp___1;
  }
#line 290
  if ((unsigned long )dst->name.data == (unsigned long )((void *)0)) {
#line 291
    goto failed;
  }
#line 294
  if (src) {
    {
#line 295
    memcpy((void */* __restrict  */)dst->sockaddr, (void const   */* __restrict  */)src->sockaddr,
           (size_t )src->socklen);
#line 296
    memcpy((void */* __restrict  */)dst->name.data, (void const   */* __restrict  */)src->name.data,
           src->name.len);
#line 298
    tmp___2 = ngx_slab_alloc_locked(pool, src->server.len);
#line 298
    dst->server.data = (u_char *)tmp___2;
    }
#line 299
    if ((unsigned long )dst->server.data == (unsigned long )((void *)0)) {
#line 300
      goto failed;
    }
    {
#line 303
    memcpy((void */* __restrict  */)dst->server.data, (void const   */* __restrict  */)src->server.data,
           src->server.len);
    }
  }
#line 306
  return (dst);
  failed: 
#line 310
  if (dst->server.data) {
    {
#line 311
    ngx_slab_free_locked(pool, (void *)dst->server.data);
    }
  }
#line 314
  if (dst->name.data) {
    {
#line 315
    ngx_slab_free_locked(pool, (void *)dst->name.data);
    }
  }
#line 318
  if (dst->sockaddr) {
    {
#line 319
    ngx_slab_free_locked(pool, (void *)dst->sockaddr);
    }
  }
  {
#line 322
  ngx_slab_free_locked(pool, (void *)dst);
  }
#line 324
  return ((ngx_http_upstream_rr_peer_t *)((void *)0));
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 156 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 52 "src/core/ngx_rbtree.h"
void ngx_rbtree_delete(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) ;
#line 170 "src/core/ngx_string.h"
ngx_int_t ngx_memn2cmp(u_char *s1 , u_char *s2 , size_t n1 , size_t n2 ) ;
#line 174
ngx_int_t ngx_atoi(u_char *line , size_t n ) ;
#line 76 "src/core/ngx_palloc.h"
void ngx_destroy_pool(ngx_pool_t *pool ) ;
#line 79
void *ngx_palloc(ngx_pool_t *pool , size_t size ) ;
#line 81
void *ngx_pcalloc(ngx_pool_t *pool , size_t size ) ;
#line 138 "src/core/ngx_cycle.h"
ngx_cycle_t volatile   *ngx_cycle ;
#line 47 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_exiting ;
#line 54
sig_atomic_t ngx_terminate ;
#line 213 "src/core/ngx_connection.h"
void ngx_close_connection(ngx_connection_t *c ) ;
#line 515 "src/event/ngx_event.h"
ngx_int_t ngx_handle_read_event(ngx_event_t *rev , ngx_uint_t flags ) ;
#line 28 "src/event/ngx_event_timer.h"
ngx_rbtree_t ngx_event_timer_rbtree ;
#line 31 "src/event/ngx_event_timer.h"
__inline static void ngx_event_del_timer(ngx_event_t *ev ) 
{ 


  {
  {
#line 38
  ngx_rbtree_delete(& ngx_event_timer_rbtree, & ev->timer);
#line 46
  ev->timer_set = 0U;
  }
#line 47
  return;
}
}
#line 136 "src/http/ngx_http_upstream_round_robin.h"
ngx_int_t ngx_http_upstream_init_round_robin(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_int_t ngx_http_upstream_init_keepalive_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 57
static ngx_int_t ngx_http_upstream_get_keepalive_peer(ngx_peer_connection_t *pc ,
                                                      void *data ) ;
#line 59
static void ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc , void *data ,
                                                  ngx_uint_t state ) ;
#line 62
static void ngx_http_upstream_keepalive_dummy_handler(ngx_event_t *ev ) ;
#line 63
static void ngx_http_upstream_keepalive_close_handler(ngx_event_t *ev ) ;
#line 64
static void ngx_http_upstream_keepalive_close(ngx_connection_t *c ) ;
#line 73
static void *ngx_http_upstream_keepalive_create_conf(ngx_conf_t *cf ) ;
#line 74
static char *ngx_http_upstream_keepalive(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 78 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_command_t ngx_http_upstream_keepalive_commands[2]  = {      {{sizeof("keepalive") - 1UL, (u_char *)"keepalive"}, (ngx_uint_t )268435458,
      & ngx_http_upstream_keepalive, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 91 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_http_module_t ngx_http_upstream_keepalive_module_ctx  = 
#line 91
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    & ngx_http_upstream_keepalive_create_conf, (char *(*)(ngx_conf_t *cf , void *prev ,
                                                          void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 106 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
ngx_module_t ngx_http_upstream_keepalive_module  = 
#line 106
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_keepalive_module_ctx),
    ngx_http_upstream_keepalive_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 122 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_int_t ngx_http_upstream_init_keepalive(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_uint_t i ;
  ngx_http_upstream_keepalive_srv_conf_t *kcf ;
  ngx_http_upstream_keepalive_cache_t *cached ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
  {
#line 133
  kcf = (ngx_http_upstream_keepalive_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_keepalive_module.ctx_index);
#line 136
  tmp = (*(kcf->original_init_upstream))(cf, us);
  }
#line 136
  if (tmp != 0L) {
#line 137
    return ((ngx_int_t )-1);
  }
  {
#line 140
  kcf->original_init_peer = us->peer.init;
#line 142
  us->peer.init = & ngx_http_upstream_init_keepalive_peer;
#line 146
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_keepalive_cache_t ) * kcf->max_cached);
#line 146
  cached = (ngx_http_upstream_keepalive_cache_t *)tmp___0;
  }
#line 148
  if ((unsigned long )cached == (unsigned long )((void *)0)) {
#line 149
    return ((ngx_int_t )-1);
  }
#line 152
  kcf->cache.prev = & kcf->cache;
#line 152
  kcf->cache.next = & kcf->cache;
#line 153
  kcf->free.prev = & kcf->free;
#line 153
  kcf->free.next = & kcf->free;
#line 155
  i = (ngx_uint_t )0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (! (i < kcf->max_cached)) {
#line 155
      goto while_break;
    }
#line 156
    (cached + i)->queue.next = kcf->free.next;
#line 156
    ((cached + i)->queue.next)->prev = & (cached + i)->queue;
#line 156
    (cached + i)->queue.prev = & kcf->free;
#line 156
    kcf->free.next = & (cached + i)->queue;
#line 157
    (cached + i)->conf = kcf;
#line 155
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return ((ngx_int_t )0);
}
}
#line 164 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_int_t ngx_http_upstream_init_keepalive_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_http_upstream_keepalive_peer_data_t *kp ;
  ngx_http_upstream_keepalive_srv_conf_t *kcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 174
  kcf = (ngx_http_upstream_keepalive_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_keepalive_module.ctx_index);
#line 177
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_keepalive_peer_data_t ));
#line 177
  kp = (ngx_http_upstream_keepalive_peer_data_t *)tmp;
  }
#line 178
  if ((unsigned long )kp == (unsigned long )((void *)0)) {
#line 179
    return ((ngx_int_t )-1);
  }
  {
#line 182
  tmp___0 = (*(kcf->original_init_peer))(r, us);
  }
#line 182
  if (tmp___0 != 0L) {
#line 183
    return ((ngx_int_t )-1);
  }
#line 186
  kp->conf = kcf;
#line 187
  kp->upstream = r->upstream;
#line 188
  kp->data = (r->upstream)->peer.data;
#line 189
  kp->original_get_peer = (r->upstream)->peer.get;
#line 190
  kp->original_free_peer = (r->upstream)->peer.free;
#line 192
  (r->upstream)->peer.data = (void *)kp;
#line 193
  (r->upstream)->peer.get = & ngx_http_upstream_get_keepalive_peer;
#line 194
  (r->upstream)->peer.free = & ngx_http_upstream_free_keepalive_peer;
#line 203
  return ((ngx_int_t )0);
}
}
#line 207 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static ngx_int_t ngx_http_upstream_get_keepalive_peer(ngx_peer_connection_t *pc ,
                                                      void *data ) 
{ 
  ngx_http_upstream_keepalive_peer_data_t *kp ;
  ngx_http_upstream_keepalive_cache_t *item ;
  ngx_int_t rc ;
  ngx_queue_t *q ;
  ngx_queue_t *cache ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;

  {
  {
#line 210
  kp = (ngx_http_upstream_keepalive_peer_data_t *)data;
#line 222
  rc = (*(kp->original_get_peer))(pc, kp->data);
  }
#line 224
  if (rc != 0L) {
#line 225
    return (rc);
  }
#line 230
  cache = & (kp->conf)->cache;
#line 232
  q = cache->next;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! ((unsigned long )q != (unsigned long )cache)) {
#line 232
      goto while_break;
    }
    {
#line 236
    item = (ngx_http_upstream_keepalive_cache_t *)((u_char *)q - (unsigned long )(& ((ngx_http_upstream_keepalive_cache_t *)0)->queue));
#line 237
    c = item->connection;
#line 239
    tmp = ngx_memn2cmp((u_char *)(& item->sockaddr), (u_char *)pc->sockaddr, (size_t )item->socklen,
                       (size_t )pc->socklen);
    }
#line 239
    if (tmp == 0L) {
#line 243
      (q->next)->prev = q->prev;
#line 243
      (q->prev)->next = q->next;
#line 244
      q->next = (kp->conf)->free.next;
#line 244
      (q->next)->prev = q;
#line 244
      q->prev = & (kp->conf)->free;
#line 244
      (kp->conf)->free.next = q;
#line 246
      goto found;
    }
#line 232
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  return ((ngx_int_t )0);
  found: 
#line 257
  c->idle = 0U;
#line 258
  c->sent = (off_t )0;
#line 259
  c->log = pc->log;
#line 260
  (c->read)->log = pc->log;
#line 261
  (c->write)->log = pc->log;
#line 262
  (c->pool)->log = pc->log;
#line 264
  pc->connection = c;
#line 265
  pc->cached = 1U;
#line 267
  return ((ngx_int_t )-4);
}
}
#line 271 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void ngx_http_upstream_free_keepalive_peer(ngx_peer_connection_t *pc , void *data ,
                                                  ngx_uint_t state ) 
{ 
  ngx_http_upstream_keepalive_peer_data_t *kp ;
  ngx_http_upstream_keepalive_cache_t *item ;
  ngx_queue_t *q ;
  ngx_connection_t *c ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;

  {
#line 275
  kp = (ngx_http_upstream_keepalive_peer_data_t *)data;
#line 287
  u = kp->upstream;
#line 288
  c = pc->connection;
#line 290
  if (state & 4UL) {
#line 298
    goto invalid;
  } else
#line 290
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->read)->eof) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->read)->error) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->read)->timedout) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->write)->error) {
#line 298
    goto invalid;
  } else
#line 290
  if ((c->write)->timedout) {
#line 298
    goto invalid;
  }
#line 301
  if (! u->keepalive) {
#line 302
    goto invalid;
  }
#line 305
  if (! u->request_body_sent) {
#line 306
    goto invalid;
  }
#line 309
  if (ngx_terminate) {
#line 310
    goto invalid;
  } else
#line 309
  if (ngx_exiting) {
#line 310
    goto invalid;
  }
  {
#line 313
  tmp = ngx_handle_read_event(c->read, (ngx_uint_t )0);
  }
#line 313
  if (tmp != 0L) {
#line 314
    goto invalid;
  }
#line 320
  if ((unsigned long )(& (kp->conf)->free) == (unsigned long )(kp->conf)->free.prev) {
    {
#line 322
    q = (kp->conf)->cache.prev;
#line 323
    (q->next)->prev = q->prev;
#line 323
    (q->prev)->next = q->next;
#line 325
    item = (ngx_http_upstream_keepalive_cache_t *)((u_char *)q - (unsigned long )(& ((ngx_http_upstream_keepalive_cache_t *)0)->queue));
#line 327
    ngx_http_upstream_keepalive_close(item->connection);
    }
  } else {
#line 330
    q = (kp->conf)->free.next;
#line 331
    (q->next)->prev = q->prev;
#line 331
    (q->prev)->next = q->next;
#line 333
    item = (ngx_http_upstream_keepalive_cache_t *)((u_char *)q - (unsigned long )(& ((ngx_http_upstream_keepalive_cache_t *)0)->queue));
  }
#line 336
  q->next = (kp->conf)->cache.next;
#line 336
  (q->next)->prev = q;
#line 336
  q->prev = & (kp->conf)->cache;
#line 336
  (kp->conf)->cache.next = q;
#line 338
  item->connection = c;
#line 340
  pc->connection = (ngx_connection_t *)((void *)0);
#line 342
  if ((c->read)->timer_set) {
    {
#line 343
    (c->read)->delayed = 0U;
#line 344
    ngx_event_del_timer(c->read);
    }
  }
#line 346
  if ((c->write)->timer_set) {
    {
#line 347
    ngx_event_del_timer(c->write);
    }
  }
  {
#line 350
  (c->write)->handler = & ngx_http_upstream_keepalive_dummy_handler;
#line 351
  (c->read)->handler = & ngx_http_upstream_keepalive_close_handler;
#line 353
  c->data = (void *)item;
#line 354
  c->idle = 1U;
#line 355
  c->log = (ngx_log_t *)ngx_cycle->log;
#line 356
  (c->read)->log = (ngx_log_t *)ngx_cycle->log;
#line 357
  (c->write)->log = (ngx_log_t *)ngx_cycle->log;
#line 358
  (c->pool)->log = (ngx_log_t *)ngx_cycle->log;
#line 360
  item->socklen = pc->socklen;
#line 361
  memcpy((void */* __restrict  */)(& item->sockaddr), (void const   */* __restrict  */)pc->sockaddr,
         (size_t )pc->socklen);
  }
#line 363
  if ((c->read)->ready) {
    {
#line 364
    ngx_http_upstream_keepalive_close_handler(c->read);
    }
  }
  invalid: 
  {
#line 369
  (*(kp->original_free_peer))(pc, kp->data, state);
  }
#line 370
  return;
}
}
#line 373 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void ngx_http_upstream_keepalive_dummy_handler(ngx_event_t *ev ) 
{ 


  {
#line 378
  return;
}
}
#line 381 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void ngx_http_upstream_keepalive_close_handler(ngx_event_t *ev ) 
{ 
  ngx_http_upstream_keepalive_srv_conf_t *conf ;
  ngx_http_upstream_keepalive_cache_t *item ;
  int n ;
  char buf[1] ;
  ngx_connection_t *c ;
  ssize_t tmp ;
  ngx_int_t tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp10 ;

  {
#line 394
  c = (ngx_connection_t *)ev->data;
#line 396
  if (c->close) {
#line 397
    goto close;
  }
  {
#line 400
  tmp = recv(c->fd, (void *)(buf), (size_t )1, 2);
#line 400
  n = (int )tmp;
  }
#line 402
  if (n == -1) {
    {
#line 402
    tmp___1 = __errno_location();
    }
#line 402
    if (*tmp___1 == 11) {
      {
#line 403
      ev->ready = 0U;
#line 405
      tmp___0 = ngx_handle_read_event(c->read, (ngx_uint_t )0);
      }
#line 405
      if (tmp___0 != 0L) {
#line 406
        goto close;
      }
#line 409
      return;
    }
  }
  close: 
  {
#line 414
  item = (ngx_http_upstream_keepalive_cache_t *)c->data;
#line 415
  conf = item->conf;
#line 417
  ngx_http_upstream_keepalive_close(c);
#line 419
  (item->queue.next)->prev = item->queue.prev;
#line 419
  (item->queue.prev)->next = item->queue.next;
#line 420
  item->queue.next = conf->free.next;
#line 420
  (item->queue.next)->prev = & item->queue;
#line 420
  item->queue.prev = & conf->free;
#line 420
  conf->free.next = & item->queue;
  }
#line 421
  return;
}
}
#line 424 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void ngx_http_upstream_keepalive_close(ngx_connection_t *c ) 
{ 


  {
  {
#line 442
  ngx_destroy_pool(c->pool);
#line 443
  ngx_close_connection(c);
  }
#line 444
  return;
}
}
#line 470 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static void *ngx_http_upstream_keepalive_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_upstream_keepalive_srv_conf_t *conf ;
  void *tmp ;

  {
  {
#line 475
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_keepalive_srv_conf_t ));
#line 475
  conf = (ngx_http_upstream_keepalive_srv_conf_t *)tmp;
  }
#line 477
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 478
    return ((void *)0);
  }
#line 489
  return ((void *)conf);
}
}
#line 493 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_keepalive_module.c"
static char *ngx_http_upstream_keepalive(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_keepalive_srv_conf_t *kcf ;
  ngx_int_t n ;
  ngx_str_t *value ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 497
  kcf = (ngx_http_upstream_keepalive_srv_conf_t *)conf;
#line 502
  if (kcf->max_cached) {
#line 503
    return ((char *)"is duplicate");
  }
  {
#line 508
  value = (ngx_str_t *)(cf->args)->elts;
#line 510
  n = ngx_atoi((value + 1)->data, (value + 1)->len);
  }
#line 512
  if (n == -1L) {
    {
#line 513
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\" in \"%V\" directive",
                       value + 1, & cmd->name);
    }
#line 516
    return ((char *)((void *)-1));
  } else
#line 512
  if (n == 0L) {
    {
#line 513
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\" in \"%V\" directive",
                       value + 1, & cmd->name);
    }
#line 516
    return ((char *)((void *)-1));
  }
#line 519
  kcf->max_cached = (ngx_uint_t )n;
#line 521
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 523
  if (uscf->peer.init_upstream) {
#line 523
    kcf->original_init_upstream = uscf->peer.init_upstream;
  } else {
#line 523
    kcf->original_init_upstream = & ngx_http_upstream_init_round_robin;
  }
#line 527
  uscf->peer.init_upstream = & ngx_http_upstream_init_keepalive;
#line 529
  return ((char *)((void *)0));
}
}
#line 34 "src/core/ngx_times.h"
ngx_time_t volatile   *ngx_cached_time ;
#line 16 "src/core/ngx_rwlock.h"
void ngx_rwlock_wlock(ngx_atomic_t *lock ) ;
#line 18
void ngx_rwlock_unlock(ngx_atomic_t *lock ) ;
#line 138 "src/http/ngx_http_upstream_round_robin.h"
ngx_int_t ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 142
ngx_int_t ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_int_t ngx_http_upstream_init_least_conn_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 15
static ngx_int_t ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc ,
                                                       void *data ) ;
#line 17
static char *ngx_http_upstream_least_conn(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 21 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_command_t ngx_http_upstream_least_conn_commands[2]  = {      {{sizeof("least_conn") - 1UL, (u_char *)"least_conn"}, (ngx_uint_t )268435457,
      & ngx_http_upstream_least_conn, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_http_module_t ngx_http_upstream_least_conn_module_ctx  = 
#line 34
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 49 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_least_conn_module.c"
ngx_module_t ngx_http_upstream_least_conn_module  = 
#line 49
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_least_conn_module_ctx),
    ngx_http_upstream_least_conn_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 65 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_int_t ngx_http_upstream_init_least_conn(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 72
  tmp = ngx_http_upstream_init_round_robin(cf, us);
  }
#line 72
  if (tmp != 0L) {
#line 73
    return ((ngx_int_t )-1);
  }
#line 76
  us->peer.init = & ngx_http_upstream_init_least_conn_peer;
#line 78
  return ((ngx_int_t )0);
}
}
#line 82 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_int_t ngx_http_upstream_init_least_conn_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 89
  tmp = ngx_http_upstream_init_round_robin_peer(r, us);
  }
#line 89
  if (tmp != 0L) {
#line 90
    return ((ngx_int_t )-1);
  }
#line 93
  (r->upstream)->peer.get = & ngx_http_upstream_get_least_conn_peer;
#line 95
  return ((ngx_int_t )0);
}
}
#line 99 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_least_conn_module.c"
static ngx_int_t ngx_http_upstream_get_least_conn_peer(ngx_peer_connection_t *pc ,
                                                       void *data ) 
{ 
  ngx_http_upstream_rr_peer_data_t *rrp ;
  time_t now ;
  uintptr_t m ;
  ngx_int_t rc ;
  ngx_int_t total ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t p ;
  ngx_uint_t many ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t *best ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_int_t tmp ;

  {
#line 102
  rrp = (ngx_http_upstream_rr_peer_data_t *)data;
#line 114
  if ((rrp->peers)->single) {
    {
#line 115
    tmp = ngx_http_upstream_get_round_robin_peer(pc, (void *)rrp);
    }
#line 115
    return (tmp);
  }
#line 118
  pc->cached = 0U;
#line 119
  pc->connection = (ngx_connection_t *)((void *)0);
#line 121
  now = (time_t )ngx_cached_time->sec;
#line 123
  peers = rrp->peers;
#line 125
  if (peers->shpool) {
    {
#line 125
    ngx_rwlock_wlock(& peers->rwlock);
    }
  }
#line 127
  best = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 128
  total = (ngx_int_t )0;
#line 131
  many = (ngx_uint_t )0;
#line 132
  p = (ngx_uint_t )0;
#line 135
  peer = peers->peer;
#line 135
  i = (ngx_uint_t )0;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! peer) {
#line 135
      goto while_break;
    }
#line 139
    n = i / (8UL * sizeof(uintptr_t ));
#line 140
    m = 1UL << i % (8UL * sizeof(uintptr_t ));
#line 142
    if (*(rrp->tried + n) & m) {
#line 143
      goto __Cont;
    }
#line 146
    if (peer->down) {
#line 147
      goto __Cont;
    }
#line 150
    if (peer->max_fails) {
#line 150
      if (peer->fails >= peer->max_fails) {
#line 150
        if (now - peer->checked <= peer->fail_timeout) {
#line 154
          goto __Cont;
        }
      }
    }
#line 157
    if (peer->max_conns) {
#line 157
      if (peer->conns >= peer->max_conns) {
#line 158
        goto __Cont;
      }
    }
#line 167
    if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 170
      best = peer;
#line 171
      many = (ngx_uint_t )0;
#line 172
      p = i;
    } else
#line 167
    if (peer->conns * (ngx_uint_t )best->weight < best->conns * (ngx_uint_t )peer->weight) {
#line 170
      best = peer;
#line 171
      many = (ngx_uint_t )0;
#line 172
      p = i;
    } else
#line 174
    if (peer->conns * (ngx_uint_t )best->weight == best->conns * (ngx_uint_t )peer->weight) {
#line 175
      many = (ngx_uint_t )1;
    }
    __Cont: /* CIL Label */ 
#line 135
    peer = peer->next;
#line 135
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 183
    goto failed;
  }
#line 186
  if (many) {
#line 190
    peer = best;
#line 190
    i = p;
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! peer) {
#line 190
        goto while_break___0;
      }
#line 194
      n = i / (8UL * sizeof(uintptr_t ));
#line 195
      m = 1UL << i % (8UL * sizeof(uintptr_t ));
#line 197
      if (*(rrp->tried + n) & m) {
#line 198
        goto __Cont___0;
      }
#line 201
      if (peer->down) {
#line 202
        goto __Cont___0;
      }
#line 205
      if (peer->conns * (ngx_uint_t )best->weight != best->conns * (ngx_uint_t )peer->weight) {
#line 206
        goto __Cont___0;
      }
#line 209
      if (peer->max_fails) {
#line 209
        if (peer->fails >= peer->max_fails) {
#line 209
          if (now - peer->checked <= peer->fail_timeout) {
#line 213
            goto __Cont___0;
          }
        }
      }
#line 216
      if (peer->max_conns) {
#line 216
        if (peer->conns >= peer->max_conns) {
#line 217
          goto __Cont___0;
        }
      }
#line 220
      peer->current_weight += peer->effective_weight;
#line 221
      total += peer->effective_weight;
#line 223
      if (peer->effective_weight < peer->weight) {
#line 224
        (peer->effective_weight) ++;
      }
#line 227
      if (peer->current_weight > best->current_weight) {
#line 228
        best = peer;
#line 229
        p = i;
      }
      __Cont___0: /* CIL Label */ 
#line 190
      peer = peer->next;
#line 190
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 234
  best->current_weight -= total;
#line 236
  if (now - best->checked > best->fail_timeout) {
#line 237
    best->checked = now;
  }
#line 240
  pc->sockaddr = best->sockaddr;
#line 241
  pc->socklen = best->socklen;
#line 242
  pc->name = & best->name;
#line 244
  (best->conns) ++;
#line 246
  rrp->current = best;
#line 248
  n = p / (8UL * sizeof(uintptr_t ));
#line 249
  m = 1UL << p % (8UL * sizeof(uintptr_t ));
#line 251
  *(rrp->tried + n) |= m;
#line 253
  if (peers->shpool) {
    {
#line 253
    ngx_rwlock_unlock(& peers->rwlock);
    }
  }
#line 255
  return ((ngx_int_t )0);
  failed: 
#line 259
  if (peers->next) {
#line 263
    rrp->peers = peers->next;
#line 265
    n = ((rrp->peers)->number + (8UL * sizeof(uintptr_t ) - 1UL)) / (8UL * sizeof(uintptr_t ));
#line 268
    i = (ngx_uint_t )0;
    {
#line 268
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 268
      if (! (i < n)) {
#line 268
        goto while_break___1;
      }
#line 269
      *(rrp->tried + i) = (uintptr_t )0;
#line 268
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 272
    if (peers->shpool) {
      {
#line 272
      ngx_rwlock_unlock(& peers->rwlock);
      }
    }
    {
#line 274
    rc = ngx_http_upstream_get_least_conn_peer(pc, (void *)rrp);
    }
#line 276
    if (rc != -3L) {
#line 277
      return (rc);
    }
#line 280
    if (peers->shpool) {
      {
#line 280
      ngx_rwlock_wlock(& peers->rwlock);
      }
    }
  }
#line 283
  if (peers->shpool) {
    {
#line 283
    ngx_rwlock_unlock(& peers->rwlock);
    }
  }
#line 285
  pc->name = peers->name;
#line 287
  return ((ngx_int_t )-3);
}
}
#line 291 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_least_conn_module.c"
static char *ngx_http_upstream_least_conn(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_srv_conf_t *uscf ;
  char *__cil_tmp5 ;

  {
#line 296
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 298
  if (uscf->peer.init_upstream) {
    {
#line 299
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "load balancing method redefined");
    }
  }
#line 303
  uscf->peer.init_upstream = & ngx_http_upstream_init_least_conn;
#line 305
  uscf->flags = (ngx_uint_t )319;
#line 313
  return ((char *)((void *)0));
}
}
#line 28 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_int_t ngx_http_upstream_init_ip_hash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 30
static ngx_int_t ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 32
static char *ngx_http_upstream_ip_hash(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 36 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_command_t ngx_http_upstream_ip_hash_commands[2]  = {      {{sizeof("ip_hash") - 1UL, (u_char *)"ip_hash"}, (ngx_uint_t )268435457, & ngx_http_upstream_ip_hash,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 49 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_http_module_t ngx_http_upstream_ip_hash_module_ctx  = 
#line 49
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 64 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
ngx_module_t ngx_http_upstream_ip_hash_module  = 
#line 64
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_ip_hash_module_ctx),
    ngx_http_upstream_ip_hash_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 80 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static u_char ngx_http_upstream_ip_hash_pseudo_addr[3]  ;
#line 83 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_int_t ngx_http_upstream_init_ip_hash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 86
  tmp = ngx_http_upstream_init_round_robin(cf, us);
  }
#line 86
  if (tmp != 0L) {
#line 87
    return ((ngx_int_t )-1);
  }
#line 90
  us->peer.init = & ngx_http_upstream_init_ip_hash_peer;
#line 92
  return ((ngx_int_t )0);
}
}
#line 96 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_int_t ngx_http_upstream_init_ip_hash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  ngx_http_upstream_ip_hash_peer_data_t *iphp ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 106
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_ip_hash_peer_data_t ));
#line 106
  iphp = (ngx_http_upstream_ip_hash_peer_data_t *)tmp;
  }
#line 107
  if ((unsigned long )iphp == (unsigned long )((void *)0)) {
#line 108
    return ((ngx_int_t )-1);
  }
  {
#line 111
  (r->upstream)->peer.data = (void *)(& iphp->rrp);
#line 113
  tmp___0 = ngx_http_upstream_init_round_robin_peer(r, us);
  }
#line 113
  if (tmp___0 != 0L) {
#line 114
    return ((ngx_int_t )-1);
  }
#line 117
  (r->upstream)->peer.get = & ngx_http_upstream_get_ip_hash_peer;
  {
#line 121
  if ((int )((r->connection)->sockaddr)->sa_family == 2) {
#line 121
    goto case_2;
  }
#line 128
  if ((int )((r->connection)->sockaddr)->sa_family == 10) {
#line 128
    goto case_10;
  }
#line 135
  goto switch_default;
  case_2: /* CIL Label */ 
#line 122
  sin = (struct sockaddr_in *)(r->connection)->sockaddr;
#line 123
  iphp->addr = (u_char *)(& sin->sin_addr.s_addr);
#line 124
  iphp->addrlen = (u_char )3;
#line 125
  goto switch_break;
  case_10: /* CIL Label */ 
#line 129
  sin6 = (struct sockaddr_in6 *)(r->connection)->sockaddr;
#line 130
  iphp->addr = (u_char *)(& sin6->sin6_addr.__in6_u.__u6_addr8);
#line 131
  iphp->addrlen = (u_char )16;
#line 132
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 136
  iphp->addr = ngx_http_upstream_ip_hash_pseudo_addr;
#line 137
  iphp->addrlen = (u_char )3;
  switch_break: /* CIL Label */ ;
  }
#line 140
  iphp->hash = (ngx_uint_t )89;
#line 141
  iphp->tries = (u_char )0;
#line 142
  iphp->get_rr_peer = & ngx_http_upstream_get_round_robin_peer;
#line 144
  return ((ngx_int_t )0);
}
}
#line 148 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static ngx_int_t ngx_http_upstream_get_ip_hash_peer(ngx_peer_connection_t *pc , void *data ) 
{ 
  ngx_http_upstream_ip_hash_peer_data_t *iphp ;
  time_t now ;
  ngx_int_t w ;
  uintptr_t m ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t p ;
  ngx_uint_t hash ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 151
  iphp = (ngx_http_upstream_ip_hash_peer_data_t *)data;
#line 164
  if ((iphp->rrp.peers)->shpool) {
    {
#line 164
    ngx_rwlock_wlock(& (iphp->rrp.peers)->rwlock);
    }
  }
#line 166
  if ((int )iphp->tries > 20) {
#line 166
    goto _L;
  } else
#line 166
  if ((iphp->rrp.peers)->single) {
    _L: /* CIL Label */ 
#line 167
    if ((iphp->rrp.peers)->shpool) {
      {
#line 167
      ngx_rwlock_unlock(& (iphp->rrp.peers)->rwlock);
      }
    }
    {
#line 168
    tmp = (*(iphp->get_rr_peer))(pc, (void *)(& iphp->rrp));
    }
#line 168
    return (tmp);
  }
#line 171
  now = (time_t )ngx_cached_time->sec;
#line 173
  pc->cached = 0U;
#line 174
  pc->connection = (ngx_connection_t *)((void *)0);
#line 176
  hash = iphp->hash;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    i = (ngx_uint_t )0;
    {
#line 180
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 180
      if (! (i < (ngx_uint_t )iphp->addrlen)) {
#line 180
        goto while_break___0;
      }
#line 181
      hash = (hash * 113UL + (ngx_uint_t )*(iphp->addr + i)) % 6271UL;
#line 180
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 184
    w = (ngx_int_t )(hash % (iphp->rrp.peers)->total_weight);
#line 185
    peer = (iphp->rrp.peers)->peer;
#line 186
    p = (ngx_uint_t )0;
    {
#line 188
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 188
      if (! (w >= peer->weight)) {
#line 188
        goto while_break___1;
      }
#line 189
      w -= peer->weight;
#line 190
      peer = peer->next;
#line 191
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 194
    n = p / (8UL * sizeof(uintptr_t ));
#line 195
    m = 1UL << p % (8UL * sizeof(uintptr_t ));
#line 197
    if (*(iphp->rrp.tried + n) & m) {
#line 198
      goto next;
    }
#line 204
    if (peer->down) {
#line 205
      goto next;
    }
#line 208
    if (peer->max_fails) {
#line 208
      if (peer->fails >= peer->max_fails) {
#line 208
        if (now - peer->checked <= peer->fail_timeout) {
#line 212
          goto next;
        }
      }
    }
#line 215
    if (peer->max_conns) {
#line 215
      if (peer->conns >= peer->max_conns) {
#line 216
        goto next;
      }
    }
#line 219
    goto while_break;
    next: 
#line 223
    iphp->tries = (u_char )((int )iphp->tries + 1);
#line 223
    if ((int )iphp->tries > 20) {
#line 224
      if ((iphp->rrp.peers)->shpool) {
        {
#line 224
        ngx_rwlock_unlock(& (iphp->rrp.peers)->rwlock);
        }
      }
      {
#line 225
      tmp___0 = (*(iphp->get_rr_peer))(pc, (void *)(& iphp->rrp));
      }
#line 225
      return (tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  iphp->rrp.current = peer;
#line 231
  pc->sockaddr = peer->sockaddr;
#line 232
  pc->socklen = peer->socklen;
#line 233
  pc->name = & peer->name;
#line 235
  (peer->conns) ++;
#line 237
  if (now - peer->checked > peer->fail_timeout) {
#line 238
    peer->checked = now;
  }
#line 241
  if ((iphp->rrp.peers)->shpool) {
    {
#line 241
    ngx_rwlock_unlock(& (iphp->rrp.peers)->rwlock);
    }
  }
#line 243
  *(iphp->rrp.tried + n) |= m;
#line 244
  iphp->hash = hash;
#line 246
  return ((ngx_int_t )0);
}
}
#line 250 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_ip_hash_module.c"
static char *ngx_http_upstream_ip_hash(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_srv_conf_t *uscf ;
  char *__cil_tmp5 ;

  {
#line 255
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 257
  if (uscf->peer.init_upstream) {
    {
#line 258
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "load balancing method redefined");
    }
  }
#line 262
  uscf->peer.init_upstream = & ngx_http_upstream_init_ip_hash;
#line 264
  uscf->flags = (ngx_uint_t )287;
#line 271
  return ((char *)((void *)0));
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 160 "src/core/ngx_string.h"
ngx_int_t ngx_strncasecmp(u_char *s1 , u_char *s2 , size_t n ) ;
#line 17 "src/core/ngx_crc32.h"
uint32_t ngx_crc32_table256[256] ;
#line 38 "src/core/ngx_crc32.h"
__inline static uint32_t ngx_crc32_long(u_char *p , size_t len ) 
{ 
  uint32_t crc ;
  u_char *tmp ;
  size_t tmp___0 ;

  {
#line 43
  crc = 4294967295U;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    tmp___0 = len;
#line 45
    len --;
#line 45
    if (! tmp___0) {
#line 45
      goto while_break;
    }
#line 46
    tmp = p;
#line 46
    p ++;
#line 46
    crc = ngx_crc32_table256[(crc ^ (unsigned int )*tmp) & 255U] ^ (crc >> 8);
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return (crc ^ 4294967295U);
}
}
#line 57 "src/core/ngx_crc32.h"
__inline static void ngx_crc32_update(uint32_t *crc , u_char *p , size_t len ) 
{ 
  uint32_t c ;
  u_char *tmp ;
  size_t tmp___0 ;

  {
#line 62
  c = *crc;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    tmp___0 = len;
#line 64
    len --;
#line 64
    if (! tmp___0) {
#line 64
      goto while_break;
    }
#line 65
    tmp = p;
#line 65
    p ++;
#line 65
    c = ngx_crc32_table256[(c ^ (unsigned int )*tmp) & 255U] ^ (c >> 8);
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  *crc = c;
#line 69
  return;
}
}
#line 17 "src/core/ngx_rwlock.h"
void ngx_rwlock_rlock(ngx_atomic_t *lock ) ;
#line 208 "src/http/ngx_http_script.h"
ngx_int_t ngx_http_complex_value(ngx_http_request_t *r , ngx_http_complex_value_t *val ,
                                 ngx_str_t *value ) ;
#line 210
ngx_int_t ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv ) ;
#line 43 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_hash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
#line 45
static ngx_int_t ngx_http_upstream_init_hash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 47
static ngx_int_t ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 50
static ngx_int_t ngx_http_upstream_init_chash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
#line 52
static int ngx_http_upstream_chash_cmp_points(void const   *one , void const   *two ) ;
#line 54
static ngx_uint_t ngx_http_upstream_find_chash_point(ngx_http_upstream_chash_points_t *points ,
                                                     uint32_t hash ) ;
#line 56
static ngx_int_t ngx_http_upstream_init_chash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) ;
#line 58
static ngx_int_t ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 61
static void *ngx_http_upstream_hash_create_conf(ngx_conf_t *cf ) ;
#line 62
static char *ngx_http_upstream_hash(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 66 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_command_t ngx_http_upstream_hash_commands[2]  = {      {{sizeof("hash") - 1UL, (u_char *)"hash"}, (ngx_uint_t )268435462, & ngx_http_upstream_hash,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 79 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_http_module_t ngx_http_upstream_hash_module_ctx  = 
#line 79
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    & ngx_http_upstream_hash_create_conf, (char *(*)(ngx_conf_t *cf , void *prev ,
                                                     void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 94 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
ngx_module_t ngx_http_upstream_hash_module  = 
#line 94
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_hash_module_ctx),
    ngx_http_upstream_hash_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 110 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_hash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 113
  tmp = ngx_http_upstream_init_round_robin(cf, us);
  }
#line 113
  if (tmp != 0L) {
#line 114
    return ((ngx_int_t )-1);
  }
#line 117
  us->peer.init = & ngx_http_upstream_init_hash_peer;
#line 119
  return ((ngx_int_t )0);
}
}
#line 123 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_hash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  ngx_http_upstream_hash_peer_data_t *hp ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 130
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_hash_peer_data_t ));
#line 130
  hp = (ngx_http_upstream_hash_peer_data_t *)tmp;
  }
#line 131
  if ((unsigned long )hp == (unsigned long )((void *)0)) {
#line 132
    return ((ngx_int_t )-1);
  }
  {
#line 135
  (r->upstream)->peer.data = (void *)(& hp->rrp);
#line 137
  tmp___0 = ngx_http_upstream_init_round_robin_peer(r, us);
  }
#line 137
  if (tmp___0 != 0L) {
#line 138
    return ((ngx_int_t )-1);
  }
  {
#line 141
  (r->upstream)->peer.get = & ngx_http_upstream_get_hash_peer;
#line 143
  hcf = (ngx_http_upstream_hash_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_hash_module.ctx_index);
#line 145
  tmp___1 = ngx_http_complex_value(r, & hcf->key, & hp->key);
  }
#line 145
  if (tmp___1 != 0L) {
#line 146
    return ((ngx_int_t )-1);
  }
#line 152
  hp->conf = hcf;
#line 153
  hp->tries = (ngx_uint_t )0;
#line 154
  hp->rehash = (ngx_uint_t )0;
#line 155
  hp->hash = (uint32_t )0;
#line 156
  hp->get_rr_peer = & ngx_http_upstream_get_round_robin_peer;
#line 158
  return ((ngx_int_t )0);
}
}
#line 162 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_get_hash_peer(ngx_peer_connection_t *pc , void *data ) 
{ 
  ngx_http_upstream_hash_peer_data_t *hp ;
  time_t now ;
  u_char buf[sizeof("-9223372036854775808") - 1UL] ;
  size_t size ;
  uint32_t hash ;
  ngx_int_t w ;
  uintptr_t m ;
  ngx_uint_t n ;
  ngx_uint_t p ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 165
  hp = (ngx_http_upstream_hash_peer_data_t *)data;
#line 179
  if ((hp->rrp.peers)->shpool) {
    {
#line 179
    ngx_rwlock_wlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 181
  if (hp->tries > 20UL) {
#line 181
    goto _L;
  } else
#line 181
  if ((hp->rrp.peers)->single) {
    _L: /* CIL Label */ 
#line 182
    if ((hp->rrp.peers)->shpool) {
      {
#line 182
      ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
      }
    }
    {
#line 183
    tmp = (*(hp->get_rr_peer))(pc, (void *)(& hp->rrp));
    }
#line 183
    return (tmp);
  }
#line 186
  now = (time_t )ngx_cached_time->sec;
#line 188
  pc->cached = 0U;
#line 189
  pc->connection = (ngx_connection_t *)((void *)0);
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    hash = 4294967295U;
#line 201
    if (hp->rehash > 0UL) {
      {
#line 202
      tmp___0 = ngx_sprintf(buf, "%ui", hp->rehash);
#line 202
      size = (size_t )(tmp___0 - buf);
#line 203
      ngx_crc32_update(& hash, buf, size);
      }
    }
    {
#line 206
    ngx_crc32_update(& hash, hp->key.data, hp->key.len);
#line 207
    hash ^= 4294967295U;
#line 209
    hash = (hash >> 16) & 32767U;
#line 211
    hp->hash += hash;
#line 212
    (hp->rehash) ++;
#line 214
    w = (ngx_int_t )((unsigned long )hp->hash % (hp->rrp.peers)->total_weight);
#line 215
    peer = (hp->rrp.peers)->peer;
#line 216
    p = (ngx_uint_t )0;
    }
    {
#line 218
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 218
      if (! (w >= peer->weight)) {
#line 218
        goto while_break___0;
      }
#line 219
      w -= peer->weight;
#line 220
      peer = peer->next;
#line 221
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 224
    n = p / (8UL * sizeof(uintptr_t ));
#line 225
    m = 1UL << p % (8UL * sizeof(uintptr_t ));
#line 227
    if (*(hp->rrp.tried + n) & m) {
#line 228
      goto next;
    }
#line 234
    if (peer->down) {
#line 235
      goto next;
    }
#line 238
    if (peer->max_fails) {
#line 238
      if (peer->fails >= peer->max_fails) {
#line 238
        if (now - peer->checked <= peer->fail_timeout) {
#line 242
          goto next;
        }
      }
    }
#line 245
    if (peer->max_conns) {
#line 245
      if (peer->conns >= peer->max_conns) {
#line 246
        goto next;
      }
    }
#line 249
    goto while_break;
    next: 
#line 253
    (hp->tries) ++;
#line 253
    if (hp->tries > 20UL) {
#line 254
      if ((hp->rrp.peers)->shpool) {
        {
#line 254
        ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
        }
      }
      {
#line 255
      tmp___1 = (*(hp->get_rr_peer))(pc, (void *)(& hp->rrp));
      }
#line 255
      return (tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  hp->rrp.current = peer;
#line 261
  pc->sockaddr = peer->sockaddr;
#line 262
  pc->socklen = peer->socklen;
#line 263
  pc->name = & peer->name;
#line 265
  (peer->conns) ++;
#line 267
  if (now - peer->checked > peer->fail_timeout) {
#line 268
    peer->checked = now;
  }
#line 271
  if ((hp->rrp.peers)->shpool) {
    {
#line 271
    ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 273
  *(hp->rrp.tried + n) |= m;
#line 275
  return ((ngx_int_t )0);
}
}
#line 279 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_chash(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  u_char *host ;
  u_char *port ;
  u_char c ;
  size_t host_len ;
  size_t port_len ;
  size_t size ;
  uint32_t hash ;
  uint32_t base_hash ;
  ngx_str_t *server ;
  ngx_uint_t npoints ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_chash_points_t *points ;
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  union __anonunion_prev_hash_246 prev_hash ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 296
  tmp = ngx_http_upstream_init_round_robin(cf, us);
  }
#line 296
  if (tmp != 0L) {
#line 297
    return ((ngx_int_t )-1);
  }
  {
#line 300
  us->peer.init = & ngx_http_upstream_init_chash_peer;
#line 302
  peers = (ngx_http_upstream_rr_peers_t *)us->peer.data;
#line 303
  npoints = peers->total_weight * 160UL;
#line 305
  size = sizeof(ngx_http_upstream_chash_points_t ) + sizeof(ngx_http_upstream_chash_point_t ) * (npoints - 1UL);
#line 308
  tmp___0 = ngx_palloc(cf->pool, size);
#line 308
  points = (ngx_http_upstream_chash_points_t *)tmp___0;
  }
#line 309
  if ((unsigned long )points == (unsigned long )((void *)0)) {
#line 310
    return ((ngx_int_t )-1);
  }
#line 313
  points->number = (ngx_uint_t )0;
#line 315
  peer = peers->peer;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! peer) {
#line 315
      goto while_break;
    }
#line 316
    server = & peer->server;
#line 323
    if (server->len >= 5UL) {
      {
#line 323
      tmp___1 = ngx_strncasecmp(server->data, (u_char *)"unix:", (size_t )5);
      }
#line 323
      if (tmp___1 == 0L) {
#line 326
        host = server->data + 5;
#line 327
        host_len = server->len - 5UL;
#line 328
        port = (u_char *)((void *)0);
#line 329
        port_len = (size_t )0;
#line 330
        goto done;
      }
    }
#line 333
    j = (ngx_uint_t )0;
    {
#line 333
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 333
      if (! (j < server->len)) {
#line 333
        goto while_break___0;
      }
#line 334
      c = *(server->data + ((server->len - j) - 1UL));
#line 336
      if ((int )c == 58) {
#line 337
        host = server->data;
#line 338
        host_len = (server->len - j) - 1UL;
#line 339
        port = (server->data + server->len) - j;
#line 340
        port_len = j;
#line 341
        goto done;
      }
#line 344
      if ((int )c < 48) {
#line 345
        goto while_break___0;
      } else
#line 344
      if ((int )c > 57) {
#line 345
        goto while_break___0;
      }
#line 333
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 349
    host = server->data;
#line 350
    host_len = server->len;
#line 351
    port = (u_char *)((void *)0);
#line 352
    port_len = (size_t )0;
    done: 
    {
#line 356
    base_hash = 4294967295U;
#line 357
    ngx_crc32_update(& base_hash, host, host_len);
#line 358
    ngx_crc32_update(& base_hash, (u_char *)"", (size_t )1);
#line 359
    ngx_crc32_update(& base_hash, port, port_len);
#line 361
    prev_hash.value = (uint32_t )0;
#line 362
    npoints = (ngx_uint_t )(peer->weight * 160L);
#line 364
    j = (ngx_uint_t )0;
    }
    {
#line 364
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 364
      if (! (j < npoints)) {
#line 364
        goto while_break___1;
      }
      {
#line 365
      hash = base_hash;
#line 367
      ngx_crc32_update(& hash, prev_hash.byte, (size_t )4);
#line 368
      hash ^= 4294967295U;
#line 370
      points->point[points->number].hash = hash;
#line 371
      points->point[points->number].server = server;
#line 372
      (points->number) ++;
#line 375
      prev_hash.value = hash;
#line 364
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 315
    peer = peer->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  qsort((void *)(points->point), points->number, sizeof(ngx_http_upstream_chash_point_t ),
        & ngx_http_upstream_chash_cmp_points);
#line 390
  i = (ngx_uint_t )0;
#line 390
  j = (ngx_uint_t )1;
  }
  {
#line 390
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 390
    if (! (j < points->number)) {
#line 390
      goto while_break___2;
    }
#line 391
    if (points->point[i].hash != points->point[j].hash) {
#line 392
      i ++;
#line 392
      points->point[i] = points->point[j];
    }
#line 390
    j ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 396
  points->number = i + 1UL;
#line 398
  hcf = (ngx_http_upstream_hash_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_hash_module.ctx_index);
#line 399
  hcf->points = points;
#line 401
  return ((ngx_int_t )0);
}
}
#line 405 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static int ngx_http_upstream_chash_cmp_points(void const   *one , void const   *two ) 
{ 
  ngx_http_upstream_chash_point_t *first ;
  ngx_http_upstream_chash_point_t *second ;

  {
#line 408
  first = (ngx_http_upstream_chash_point_t *)one;
#line 410
  second = (ngx_http_upstream_chash_point_t *)two;
#line 413
  if (first->hash < second->hash) {
#line 414
    return (-1);
  } else
#line 416
  if (first->hash > second->hash) {
#line 417
    return (1);
  } else {
#line 420
    return (0);
  }
}
}
#line 425 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_uint_t ngx_http_upstream_find_chash_point(ngx_http_upstream_chash_points_t *points ,
                                                     uint32_t hash ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t k ;
  ngx_http_upstream_chash_point_t *point ;

  {
#line 434
  point = & points->point[0];
#line 436
  i = (ngx_uint_t )0;
#line 437
  j = points->number;
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! (i < j)) {
#line 439
      goto while_break;
    }
#line 440
    k = (i + j) / 2UL;
#line 442
    if (hash > (point + k)->hash) {
#line 443
      i = k + 1UL;
    } else
#line 445
    if (hash < (point + k)->hash) {
#line 446
      j = k;
    } else {
#line 449
      return (k);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 453
  return (i);
}
}
#line 457 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_init_chash_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  uint32_t hash ;
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  ngx_http_upstream_hash_peer_data_t *hp ;
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;

  {
  {
#line 465
  tmp = ngx_http_upstream_init_hash_peer(r, us);
  }
#line 465
  if (tmp != 0L) {
#line 466
    return ((ngx_int_t )-1);
  }
  {
#line 469
  (r->upstream)->peer.get = & ngx_http_upstream_get_chash_peer;
#line 471
  hp = (ngx_http_upstream_hash_peer_data_t *)(r->upstream)->peer.data;
#line 472
  hcf = (ngx_http_upstream_hash_srv_conf_t *)*(us->srv_conf + ngx_http_upstream_hash_module.ctx_index);
#line 474
  hash = ngx_crc32_long(hp->key.data, hp->key.len);
  }
#line 476
  if ((hp->rrp.peers)->shpool) {
    {
#line 476
    ngx_rwlock_rlock(& (hp->rrp.peers)->rwlock);
    }
  }
  {
#line 478
  tmp___0 = ngx_http_upstream_find_chash_point(hcf->points, hash);
#line 478
  hp->hash = (uint32_t )tmp___0;
  }
#line 480
  if ((hp->rrp.peers)->shpool) {
    {
#line 480
    ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 482
  return ((ngx_int_t )0);
}
}
#line 486 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static ngx_int_t ngx_http_upstream_get_chash_peer(ngx_peer_connection_t *pc , void *data ) 
{ 
  ngx_http_upstream_hash_peer_data_t *hp ;
  time_t now ;
  intptr_t m ;
  ngx_str_t *server ;
  ngx_int_t total ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t best_i ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t *best ;
  ngx_http_upstream_chash_point_t *point ;
  ngx_http_upstream_chash_points_t *points ;
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  ngx_int_t tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 489
  hp = (ngx_http_upstream_hash_peer_data_t *)data;
#line 504
  if ((hp->rrp.peers)->shpool) {
    {
#line 504
    ngx_rwlock_wlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 506
  if (hp->tries > 20UL) {
#line 506
    goto _L;
  } else
#line 506
  if ((hp->rrp.peers)->single) {
    _L: /* CIL Label */ 
#line 507
    if ((hp->rrp.peers)->shpool) {
      {
#line 507
      ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
      }
    }
    {
#line 508
    tmp = (*(hp->get_rr_peer))(pc, (void *)(& hp->rrp));
    }
#line 508
    return (tmp);
  }
#line 511
  pc->cached = 0U;
#line 512
  pc->connection = (ngx_connection_t *)((void *)0);
#line 514
  now = (time_t )ngx_cached_time->sec;
#line 515
  hcf = hp->conf;
#line 517
  points = hcf->points;
#line 518
  point = & points->point[0];
  {
#line 520
  while (1) {
    while_continue: /* CIL Label */ ;
#line 521
    server = (point + (unsigned long )hp->hash % points->number)->server;
#line 527
    best = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 528
    best_i = (ngx_uint_t )0;
#line 529
    total = (ngx_int_t )0;
#line 531
    peer = (hp->rrp.peers)->peer;
#line 531
    i = (ngx_uint_t )0;
    {
#line 531
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 531
      if (! peer) {
#line 531
        goto while_break___0;
      }
#line 535
      n = i / (8UL * sizeof(uintptr_t ));
#line 536
      m = (intptr_t )(1UL << i % (8UL * sizeof(uintptr_t )));
#line 538
      if (*(hp->rrp.tried + n) & (unsigned long )m) {
#line 539
        goto __Cont;
      }
#line 542
      if (peer->down) {
#line 543
        goto __Cont;
      }
#line 546
      if (peer->max_fails) {
#line 546
        if (peer->fails >= peer->max_fails) {
#line 546
          if (now - peer->checked <= peer->fail_timeout) {
#line 550
            goto __Cont;
          }
        }
      }
#line 553
      if (peer->max_conns) {
#line 553
        if (peer->conns >= peer->max_conns) {
#line 554
          goto __Cont;
        }
      }
#line 557
      if (peer->server.len != server->len) {
#line 561
        goto __Cont;
      } else {
        {
#line 557
        tmp___0 = strncmp((char const   *)peer->server.data, (char const   *)server->data,
                          server->len);
        }
#line 557
        if (tmp___0 != 0) {
#line 561
          goto __Cont;
        }
      }
#line 564
      peer->current_weight += peer->effective_weight;
#line 565
      total += peer->effective_weight;
#line 567
      if (peer->effective_weight < peer->weight) {
#line 568
        (peer->effective_weight) ++;
      }
#line 571
      if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 572
        best = peer;
#line 573
        best_i = i;
      } else
#line 571
      if (peer->current_weight > best->current_weight) {
#line 572
        best = peer;
#line 573
        best_i = i;
      }
      __Cont: /* CIL Label */ 
#line 531
      peer = peer->next;
#line 531
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 577
    if (best) {
#line 578
      best->current_weight -= total;
#line 579
      goto found;
    }
#line 582
    (hp->hash) ++;
#line 583
    (hp->tries) ++;
#line 585
    if (hp->tries > 20UL) {
#line 586
      if ((hp->rrp.peers)->shpool) {
        {
#line 586
        ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
        }
      }
      {
#line 587
      tmp___1 = (*(hp->get_rr_peer))(pc, (void *)(& hp->rrp));
      }
#line 587
      return (tmp___1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  found: 
#line 593
  hp->rrp.current = best;
#line 595
  pc->sockaddr = best->sockaddr;
#line 596
  pc->socklen = best->socklen;
#line 597
  pc->name = & best->name;
#line 599
  (best->conns) ++;
#line 601
  if (now - best->checked > best->fail_timeout) {
#line 602
    best->checked = now;
  }
#line 605
  if ((hp->rrp.peers)->shpool) {
    {
#line 605
    ngx_rwlock_unlock(& (hp->rrp.peers)->rwlock);
    }
  }
#line 607
  n = best_i / (8UL * sizeof(uintptr_t ));
#line 608
  m = (intptr_t )(1UL << best_i % (8UL * sizeof(uintptr_t )));
#line 610
  *(hp->rrp.tried + n) |= (unsigned long )m;
#line 612
  return ((ngx_int_t )0);
}
}
#line 616 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static void *ngx_http_upstream_hash_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_upstream_hash_srv_conf_t *conf ;
  void *tmp ;

  {
  {
#line 621
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_upstream_hash_srv_conf_t ));
#line 621
  conf = (ngx_http_upstream_hash_srv_conf_t *)tmp;
  }
#line 622
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 623
    return ((void *)0);
  }
#line 626
  conf->points = (ngx_http_upstream_chash_points_t *)((void *)0);
#line 628
  return ((void *)conf);
}
}
#line 632 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_upstream_hash_module.c"
static char *ngx_http_upstream_hash(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_hash_srv_conf_t *hcf ;
  ngx_str_t *value ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 635
  hcf = (ngx_http_upstream_hash_srv_conf_t *)conf;
#line 641
  value = (ngx_str_t *)(cf->args)->elts;
#line 643
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 645
  ccv.cf = cf;
#line 646
  ccv.value = value + 1;
#line 647
  ccv.complex_value = & hcf->key;
#line 649
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 649
  if (tmp != 0L) {
#line 650
    return ((char *)((void *)-1));
  }
#line 653
  uscf = (ngx_http_upstream_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_upstream_module.ctx_index);
#line 655
  if (uscf->peer.init_upstream) {
    {
#line 656
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "load balancing method redefined");
    }
  }
#line 660
  uscf->flags = (ngx_uint_t )287;
#line 667
  if ((cf->args)->nelts == 2UL) {
#line 668
    uscf->peer.init_upstream = & ngx_http_upstream_init_hash;
  } else {
    {
#line 670
    tmp___0 = strcmp((char const   *)(value + 2)->data, "consistent");
    }
#line 670
    if (tmp___0 == 0) {
#line 671
      uscf->peer.init_upstream = & ngx_http_upstream_init_chash;
    } else {
      {
#line 674
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 2);
      }
#line 676
      return ((char *)((void *)-1));
    }
  }
#line 679
  return ((char *)((void *)0));
}
}
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 149 "src/core/ngx_string.h"
u_char *ngx_cpystrn(u_char *dst , u_char *src , size_t n ) ;
#line 159
ngx_int_t ngx_strcasecmp(u_char *s1 , u_char *s2 ) ;
#line 25 "src/core/ngx_array.h"
ngx_array_t *ngx_array_create(ngx_pool_t *p , ngx_uint_t n , size_t size ) ;
#line 27
void *ngx_array_push(ngx_array_t *a ) ;
#line 49 "src/http/ngx_http_variables.h"
ngx_http_variable_t *ngx_http_add_variable(ngx_conf_t *cf , ngx_str_t *name , ngx_uint_t flags ) ;
#line 112
ngx_http_variable_value_t ngx_http_variable_null_value ;
#line 113
ngx_http_variable_value_t ngx_http_variable_true_value ;
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_int_t ngx_http_msie_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) ;
#line 53
static ngx_int_t ngx_http_browser_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 56
static ngx_uint_t ngx_http_browser(ngx_http_request_t *r , ngx_http_browser_conf_t *cf ) ;
#line 59
static ngx_int_t ngx_http_browser_add_variables(ngx_conf_t *cf ) ;
#line 60
static void *ngx_http_browser_create_conf(ngx_conf_t *cf ) ;
#line 61
static char *ngx_http_browser_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 63
static int ngx_http_modern_browser_sort(void const   *one , void const   *two ) ;
#line 65
static char *ngx_http_modern_browser(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 67
static char *ngx_http_ancient_browser(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 69
static char *ngx_http_modern_browser_value(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 71
static char *ngx_http_ancient_browser_value(ngx_conf_t *cf , ngx_command_t *cmd ,
                                            void *conf ) ;
#line 75 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_command_t ngx_http_browser_commands[5]  = {      {{sizeof("modern_browser") - 1UL, (u_char *)"modern_browser"}, (ngx_uint_t )234881030,
      & ngx_http_modern_browser, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("ancient_browser") - 1UL, (u_char *)"ancient_browser"}, (ngx_uint_t )234883072,
      & ngx_http_ancient_browser, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("modern_browser_value") - 1UL, (u_char *)"modern_browser_value"}, (ngx_uint_t )234881026,
      & ngx_http_modern_browser_value, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("ancient_browser_value") - 1UL, (u_char *)"ancient_browser_value"},
      (ngx_uint_t )234881026, & ngx_http_ancient_browser_value, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 109 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_http_module_t ngx_http_browser_module_ctx  = 
#line 109
     {& ngx_http_browser_add_variables, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_browser_create_conf, & ngx_http_browser_merge_conf};
#line 124 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
ngx_module_t ngx_http_browser_module  = 
#line 124
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_browser_module_ctx),
    ngx_http_browser_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 140 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_http_modern_browser_mask_t ngx_http_modern_browser_masks[6]  = {      {{(u_char )'o', (u_char )'p', (u_char )'e', (u_char )'r', (u_char )'a', (u_char )'\000'},
      (size_t )0, sizeof("Opera ") - 1UL, {(u_char )'O', (u_char )'p', (u_char )'e',
                                           (u_char )'r', (u_char )'a', (u_char )'\000'}}, 
        {{(u_char )'m',
       (u_char )'s', (u_char )'i', (u_char )'e', (u_char )'\000'}, sizeof("Mozilla/4.0 (compatible; ") - 1UL,
      sizeof("MSIE ") - 1UL, {(u_char )'M', (u_char )'S', (u_char )'I', (u_char )'E',
                              (u_char )' ', (u_char )'\000'}}, 
        {{(u_char )'g', (u_char )'e', (u_char )'c', (u_char )'k', (u_char )'o', (u_char )'\000'},
      sizeof("Mozilla/5.0 (") - 1UL, sizeof("rv:") - 1UL, {(u_char )'r', (u_char )'v',
                                                           (u_char )':', (u_char )'\000'}}, 
        {{(u_char )'s',
       (u_char )'a', (u_char )'f', (u_char )'a', (u_char )'r', (u_char )'i', (u_char )'\000'},
      sizeof("Mozilla/5.0 (") - 1UL, sizeof("Safari/") - 1UL, {(u_char )'S', (u_char )'a',
                                                               (u_char )'f', (u_char )'a',
                                                               (u_char )'r', (u_char )'i',
                                                               (u_char )'/', (u_char )'\000'}}, 
        {{(u_char )'k',
       (u_char )'o', (u_char )'n', (u_char )'q', (u_char )'u', (u_char )'e', (u_char )'r',
       (u_char )'o', (u_char )'r', (u_char )'\000'}, sizeof("Mozilla/5.0 (compatible; ") - 1UL,
      sizeof("Konqueror/") - 1UL, {(u_char )'K', (u_char )'o', (u_char )'n', (u_char )'q',
                                   (u_char )'u', (u_char )'e', (u_char )'r', (u_char )'o',
                                   (u_char )'r', (u_char )'/', (u_char )'\000'}}, 
        {{(u_char )'\000'}, (size_t )0, (size_t )0, {(u_char )'\000'}}};
#line 214 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_http_variable_t ngx_http_browser_vars[4]  = {      {{sizeof("msie") - 1UL, (u_char *)"msie"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_msie_variable, (uintptr_t )0, (ngx_uint_t )1, (ngx_uint_t )0}, 
        {{sizeof("modern_browser") - 1UL, (u_char *)"modern_browser"}, (void (*)(ngx_http_request_t *r ,
                                                                              ngx_http_variable_value_t *v ,
                                                                              uintptr_t data ))((void *)0),
      & ngx_http_browser_variable, (uintptr_t )0, (ngx_uint_t )1, (ngx_uint_t )0}, 
        {{sizeof("ancient_browser") - 1UL,
       (u_char *)"ancient_browser"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ))((void *)0), & ngx_http_browser_variable,
      (uintptr_t )1, (ngx_uint_t )1, (ngx_uint_t )0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 229 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_int_t ngx_http_browser_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  ngx_uint_t rc ;
  ngx_http_browser_conf_t *cf ;

  {
  {
#line 236
  cf = (ngx_http_browser_conf_t *)*(r->loc_conf + ngx_http_browser_module.ctx_index);
#line 238
  rc = ngx_http_browser(r, cf);
  }
#line 240
  if (data == 0UL) {
#line 240
    if (rc == 0UL) {
#line 241
      *v = *(cf->modern_browser_value);
#line 242
      return ((ngx_int_t )0);
    }
  }
#line 245
  if (data == 1UL) {
#line 245
    if (rc == 1UL) {
#line 246
      *v = *(cf->ancient_browser_value);
#line 247
      return ((ngx_int_t )0);
    }
  }
#line 250
  *v = ngx_http_variable_null_value;
#line 251
  return ((ngx_int_t )0);
}
}
#line 255 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_uint_t ngx_http_browser(ngx_http_request_t *r , ngx_http_browser_conf_t *cf ) 
{ 
  size_t len ;
  u_char *name ;
  u_char *ua ;
  u_char *last ;
  u_char c ;
  ngx_str_t *ancient ;
  ngx_uint_t i ;
  ngx_uint_t version ;
  ngx_uint_t ver ;
  ngx_uint_t scale ;
  ngx_http_modern_browser_t *modern ;
  char *tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 264
  if ((unsigned long )r->headers_in.user_agent == (unsigned long )((void *)0)) {
#line 265
    if (cf->modern_unlisted_browsers) {
#line 266
      return ((ngx_uint_t )0);
    }
#line 269
    return ((ngx_uint_t )1);
  }
#line 272
  ua = (r->headers_in.user_agent)->value.data;
#line 273
  len = (r->headers_in.user_agent)->value.len;
#line 274
  last = ua + len;
#line 276
  if (cf->modern_browsers) {
#line 277
    modern = (ngx_http_modern_browser_t *)(cf->modern_browsers)->elts;
#line 279
    i = (ngx_uint_t )0;
    {
#line 279
    while (1) {
      while_continue: /* CIL Label */ ;
#line 279
      if (! (i < (cf->modern_browsers)->nelts)) {
#line 279
        goto while_break;
      }
#line 280
      name = ua + (modern + i)->skip;
#line 282
      if ((unsigned long )name >= (unsigned long )last) {
#line 283
        goto __Cont;
      }
      {
#line 286
      tmp = strstr((char const   *)name, (char const   *)((modern + i)->name));
#line 286
      name = (u_char *)tmp;
      }
#line 288
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 289
        goto __Cont;
      }
#line 295
      name += (modern + i)->add;
#line 297
      if ((unsigned long )name >= (unsigned long )last) {
#line 298
        goto __Cont;
      }
#line 304
      version = (ngx_uint_t )0;
#line 305
      ver = (ngx_uint_t )0;
#line 306
      scale = (ngx_uint_t )1000000;
      {
#line 308
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 308
        if (! ((unsigned long )name < (unsigned long )last)) {
#line 308
          goto while_break___0;
        }
#line 310
        tmp___0 = name;
#line 310
        name ++;
#line 310
        c = *tmp___0;
#line 312
        if ((int )c >= 48) {
#line 312
          if ((int )c <= 57) {
#line 313
            ver = ver * 10UL + (ngx_uint_t )((int )c - 48);
#line 314
            goto while_continue___0;
          }
        }
#line 317
        if ((int )c == 46) {
#line 318
          version += ver * scale;
#line 324
          if (version > (modern + i)->version) {
#line 325
            return ((ngx_uint_t )0);
          }
#line 328
          ver = (ngx_uint_t )0;
#line 329
          scale /= 100UL;
#line 330
          goto while_continue___0;
        }
#line 333
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 336
      version += ver * scale;
#line 342
      if (version >= (modern + i)->version) {
#line 343
        return ((ngx_uint_t )0);
      }
#line 346
      return ((ngx_uint_t )1);
      __Cont: /* CIL Label */ 
#line 279
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 349
    if (! cf->modern_unlisted_browsers) {
#line 350
      return ((ngx_uint_t )1);
    }
  }
#line 354
  if (cf->netscape4) {
#line 355
    if (len > sizeof("Mozilla/4.72 ") - 1UL) {
      {
#line 355
      tmp___1 = strncmp((char const   *)ua, "Mozilla/", sizeof("Mozilla/") - 1UL);
      }
#line 355
      if (tmp___1 == 0) {
#line 355
        if ((int )*(ua + 8) > 48) {
#line 355
          if ((int )*(ua + 8) < 53) {
#line 359
            return ((ngx_uint_t )1);
          }
        }
      }
    }
  }
#line 363
  if (cf->ancient_browsers) {
#line 364
    ancient = (ngx_str_t *)(cf->ancient_browsers)->elts;
#line 366
    i = (ngx_uint_t )0;
    {
#line 366
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 366
      if (! (i < (cf->ancient_browsers)->nelts)) {
#line 366
        goto while_break___1;
      }
#line 367
      if (len >= (ancient + i)->len) {
        {
#line 367
        tmp___2 = strstr((char const   *)ua, (char const   *)(ancient + i)->data);
        }
#line 367
        if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 370
          return ((ngx_uint_t )1);
        }
      }
#line 366
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 375
  if (cf->modern_unlisted_browsers) {
#line 376
    return ((ngx_uint_t )0);
  }
#line 379
  return ((ngx_uint_t )1);
}
}
#line 383 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_int_t ngx_http_msie_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) 
{ 


  {
#line 387
  if (r->headers_in.msie) {
#line 388
    *v = ngx_http_variable_true_value;
#line 389
    return ((ngx_int_t )0);
  }
#line 392
  *v = ngx_http_variable_null_value;
#line 393
  return ((ngx_int_t )0);
}
}
#line 397 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static ngx_int_t ngx_http_browser_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;

  {
#line 402
  v = ngx_http_browser_vars;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if (! v->name.len) {
#line 402
      goto while_break;
    }
    {
#line 404
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 405
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 406
      return ((ngx_int_t )-1);
    }
#line 409
    var->get_handler = v->get_handler;
#line 410
    var->data = v->data;
#line 402
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 413
  return ((ngx_int_t )0);
}
}
#line 417 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static void *ngx_http_browser_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_browser_conf_t *conf ;
  void *tmp ;

  {
  {
#line 422
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_browser_conf_t ));
#line 422
  conf = (ngx_http_browser_conf_t *)tmp;
  }
#line 423
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 424
    return ((void *)0);
  }
#line 439
  return ((void *)conf);
}
}
#line 443 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_browser_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_browser_conf_t *prev ;
  ngx_http_browser_conf_t *conf ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_modern_browser_t *browsers ;
  ngx_http_modern_browser_t *opera ;
  void *tmp ;

  {
#line 446
  prev = (ngx_http_browser_conf_t *)parent;
#line 447
  conf = (ngx_http_browser_conf_t *)child;
#line 458
  if ((unsigned long )conf->modern_browsers == (unsigned long )((void *)0)) {
#line 458
    if (conf->modern_unlisted_browsers == 0U) {
#line 459
      conf->modern_browsers = prev->modern_browsers;
#line 460
      conf->modern_unlisted_browsers = prev->modern_unlisted_browsers;
    } else {
#line 458
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 462
  if ((unsigned long )conf->modern_browsers != (unsigned long )((void *)0)) {
#line 463
    browsers = (ngx_http_modern_browser_t *)(conf->modern_browsers)->elts;
#line 465
    i = (ngx_uint_t )0;
    {
#line 465
    while (1) {
      while_continue: /* CIL Label */ ;
#line 465
      if (! (i < (conf->modern_browsers)->nelts)) {
#line 465
        goto while_break;
      }
#line 466
      if ((browsers + i)->skip == 0UL) {
#line 467
        goto found;
      }
#line 465
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 476
    tmp = ngx_array_push(conf->modern_browsers);
#line 476
    opera = (ngx_http_modern_browser_t *)tmp;
    }
#line 477
    if ((unsigned long )opera == (unsigned long )((void *)0)) {
#line 478
      return ((char *)((void *)-1));
    }
#line 481
    opera->skip = (size_t )0;
#line 482
    opera->version = (ngx_uint_t )4001000000U;
#line 484
    browsers = (ngx_http_modern_browser_t *)(conf->modern_browsers)->elts;
    found: 
    {
#line 488
    qsort((void *)browsers, (conf->modern_browsers)->nelts, sizeof(ngx_http_modern_browser_t ),
          & ngx_http_modern_browser_sort);
#line 492
    i = (ngx_uint_t )0;
    }
    {
#line 492
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 492
      if (! (i < (conf->modern_browsers)->nelts)) {
#line 492
        goto while_break___0;
      }
      {
#line 493
      n = (browsers + i)->skip;
#line 495
      (browsers + i)->skip = ngx_http_modern_browser_masks[n].skip;
#line 496
      (browsers + i)->add = ngx_http_modern_browser_masks[n].add;
#line 497
      ngx_cpystrn((browsers + i)->name, ngx_http_modern_browser_masks[n].name, (size_t )12);
#line 492
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 502
  if ((unsigned long )conf->ancient_browsers == (unsigned long )((void *)0)) {
#line 502
    if (conf->netscape4 == 0U) {
#line 503
      conf->ancient_browsers = prev->ancient_browsers;
#line 504
      conf->netscape4 = prev->netscape4;
    }
  }
#line 507
  if ((unsigned long )conf->modern_browser_value == (unsigned long )((void *)0)) {
#line 508
    conf->modern_browser_value = prev->modern_browser_value;
  }
#line 511
  if ((unsigned long )conf->modern_browser_value == (unsigned long )((void *)0)) {
#line 512
    conf->modern_browser_value = & ngx_http_variable_true_value;
  }
#line 515
  if ((unsigned long )conf->ancient_browser_value == (unsigned long )((void *)0)) {
#line 516
    conf->ancient_browser_value = prev->ancient_browser_value;
  }
#line 519
  if ((unsigned long )conf->ancient_browser_value == (unsigned long )((void *)0)) {
#line 520
    conf->ancient_browser_value = & ngx_http_variable_true_value;
  }
#line 523
  return ((char *)((void *)0));
}
}
#line 527 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static int ngx_http_modern_browser_sort(void const   *one , void const   *two ) 
{ 
  ngx_http_modern_browser_t *first ;
  ngx_http_modern_browser_t *second ;

  {
#line 530
  first = (ngx_http_modern_browser_t *)one;
#line 531
  second = (ngx_http_modern_browser_t *)two;
#line 533
  return ((int )(first->skip - second->skip));
}
}
#line 537 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_modern_browser(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_browser_conf_t *bcf ;
  u_char c ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t version ;
  ngx_uint_t ver ;
  ngx_uint_t scale ;
  ngx_http_modern_browser_t *browser ;
  ngx_http_modern_browser_mask_t *mask ;
  int tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 540
  bcf = (ngx_http_browser_conf_t *)conf;
#line 548
  value = (ngx_str_t *)(cf->args)->elts;
#line 550
  if ((cf->args)->nelts == 2UL) {
    {
#line 551
    tmp = strcmp((char const   *)(value + 1)->data, "unlisted");
    }
#line 551
    if (tmp == 0) {
#line 552
      bcf->modern_unlisted_browsers = 1U;
#line 553
      return ((char *)((void *)0));
    }
#line 556
    return ((char *)((void *)-1));
  }
#line 559
  if ((unsigned long )bcf->modern_browsers == (unsigned long )((void *)0)) {
    {
#line 560
    bcf->modern_browsers = ngx_array_create(cf->pool, (ngx_uint_t )5, sizeof(ngx_http_modern_browser_t ));
    }
#line 562
    if ((unsigned long )bcf->modern_browsers == (unsigned long )((void *)0)) {
#line 563
      return ((char *)((void *)-1));
    }
  }
  {
#line 567
  tmp___0 = ngx_array_push(bcf->modern_browsers);
#line 567
  browser = (ngx_http_modern_browser_t *)tmp___0;
  }
#line 568
  if ((unsigned long )browser == (unsigned long )((void *)0)) {
#line 569
    return ((char *)((void *)-1));
  }
#line 572
  mask = ngx_http_modern_browser_masks;
#line 574
  n = (ngx_uint_t )0;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! ((int )(mask + n)->browser[0] != 0)) {
#line 574
      goto while_break;
    }
    {
#line 575
    tmp___1 = ngx_strcasecmp((mask + n)->browser, (value + 1)->data);
    }
#line 575
    if (tmp___1 == 0L) {
#line 576
      goto found;
    }
#line 574
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 580
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown browser name \"%V\"", value + 1);
  }
#line 583
  return ((char *)((void *)-1));
  found: 
#line 593
  browser->skip = n;
#line 595
  version = (ngx_uint_t )0;
#line 596
  ver = (ngx_uint_t )0;
#line 597
  scale = (ngx_uint_t )1000000;
#line 599
  i = (ngx_uint_t )0;
  {
#line 599
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 599
    if (! (i < (value + 2)->len)) {
#line 599
      goto while_break___0;
    }
#line 601
    c = *((value + 2)->data + i);
#line 603
    if ((int )c >= 48) {
#line 603
      if ((int )c <= 57) {
#line 604
        ver = ver * 10UL + (ngx_uint_t )((int )c - 48);
#line 605
        goto __Cont;
      }
    }
#line 608
    if ((int )c == 46) {
#line 609
      version += ver * scale;
#line 610
      ver = (ngx_uint_t )0;
#line 611
      scale /= 100UL;
#line 612
      goto __Cont;
    }
    {
#line 615
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid browser version \"%V\"", value + 2);
    }
#line 618
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 599
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 621
  version += ver * scale;
#line 623
  browser->version = version;
#line 625
  return ((char *)((void *)0));
}
}
#line 629 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_ancient_browser(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_browser_conf_t *bcf ;
  ngx_str_t *value ;
  ngx_str_t *browser ;
  ngx_uint_t i ;
  int tmp ;
  void *tmp___0 ;

  {
#line 632
  bcf = (ngx_http_browser_conf_t *)conf;
#line 637
  value = (ngx_str_t *)(cf->args)->elts;
#line 639
  i = (ngx_uint_t )1;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! (i < (cf->args)->nelts)) {
#line 639
      goto while_break;
    }
    {
#line 640
    tmp = strcmp((char const   *)(value + i)->data, "netscape4");
    }
#line 640
    if (tmp == 0) {
#line 641
      bcf->netscape4 = 1U;
#line 642
      goto __Cont;
    }
#line 645
    if ((unsigned long )bcf->ancient_browsers == (unsigned long )((void *)0)) {
      {
#line 646
      bcf->ancient_browsers = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
      }
#line 648
      if ((unsigned long )bcf->ancient_browsers == (unsigned long )((void *)0)) {
#line 649
        return ((char *)((void *)-1));
      }
    }
    {
#line 653
    tmp___0 = ngx_array_push(bcf->ancient_browsers);
#line 653
    browser = (ngx_str_t *)tmp___0;
    }
#line 654
    if ((unsigned long )browser == (unsigned long )((void *)0)) {
#line 655
      return ((char *)((void *)-1));
    }
#line 658
    *browser = *(value + i);
    __Cont: /* CIL Label */ 
#line 639
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 661
  return ((char *)((void *)0));
}
}
#line 665 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_modern_browser_value(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_browser_conf_t *bcf ;
  ngx_str_t *value ;
  void *tmp ;

  {
  {
#line 668
  bcf = (ngx_http_browser_conf_t *)conf;
#line 672
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_variable_value_t ));
#line 672
  bcf->modern_browser_value = (ngx_http_variable_value_t *)tmp;
  }
#line 674
  if ((unsigned long )bcf->modern_browser_value == (unsigned long )((void *)0)) {
#line 675
    return ((char *)((void *)-1));
  }
#line 678
  value = (ngx_str_t *)(cf->args)->elts;
#line 680
  (bcf->modern_browser_value)->len = (unsigned int )(value + 1)->len;
#line 681
  (bcf->modern_browser_value)->valid = 1U;
#line 682
  (bcf->modern_browser_value)->no_cacheable = 0U;
#line 683
  (bcf->modern_browser_value)->not_found = 0U;
#line 684
  (bcf->modern_browser_value)->data = (value + 1)->data;
#line 686
  return ((char *)((void *)0));
}
}
#line 690 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_browser_module.c"
static char *ngx_http_ancient_browser_value(ngx_conf_t *cf , ngx_command_t *cmd ,
                                            void *conf ) 
{ 
  ngx_http_browser_conf_t *bcf ;
  ngx_str_t *value ;
  void *tmp ;

  {
  {
#line 693
  bcf = (ngx_http_browser_conf_t *)conf;
#line 697
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_variable_value_t ));
#line 697
  bcf->ancient_browser_value = (ngx_http_variable_value_t *)tmp;
  }
#line 699
  if ((unsigned long )bcf->ancient_browser_value == (unsigned long )((void *)0)) {
#line 700
    return ((char *)((void *)-1));
  }
#line 703
  value = (ngx_str_t *)(cf->args)->elts;
#line 705
  (bcf->ancient_browser_value)->len = (unsigned int )(value + 1)->len;
#line 706
  (bcf->ancient_browser_value)->valid = 1U;
#line 707
  (bcf->ancient_browser_value)->no_cacheable = 0U;
#line 708
  (bcf->ancient_browser_value)->not_found = 0U;
#line 709
  (bcf->ancient_browser_value)->data = (value + 1)->data;
#line 711
  return ((char *)((void *)0));
}
}
#line 486 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_send_response(ngx_http_request_t *r , ngx_uint_t status , ngx_str_t *ct ,
                                 ngx_http_complex_value_t *cv ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_empty_gif_module.c"
static char *ngx_http_empty_gif(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_empty_gif_module.c"
static ngx_command_t ngx_http_empty_gif_commands[2]  = {      {{sizeof("empty_gif") - 1UL, (u_char *)"empty_gif"}, (ngx_uint_t )134217729,
      & ngx_http_empty_gif, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 30 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_empty_gif_module.c"
static u_char ngx_empty_gif[43]  = 
#line 30
  {      (u_char )'G',      (u_char )'I',      (u_char )'F',      (u_char )'8', 
        (u_char )'9',      (u_char )'a',      (u_char )1,      (u_char )0, 
        (u_char )1,      (u_char )0,      (u_char )128,      (u_char )1, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )255,      (u_char )255,      (u_char )255,      (u_char )33, 
        (u_char )249,      (u_char )4,      (u_char )1,      (u_char )0, 
        (u_char )0,      (u_char )1,      (u_char )0,      (u_char )44, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )1,      (u_char )0,      (u_char )1,      (u_char )0, 
        (u_char )0,      (u_char )2,      (u_char )2,      (u_char )76, 
        (u_char )1,      (u_char )0,      (u_char )59};
#line 78 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_empty_gif_module.c"
static ngx_http_module_t ngx_http_empty_gif_module_ctx  = 
#line 78
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 93 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_empty_gif_module.c"
ngx_module_t ngx_http_empty_gif_module  = 
#line 93
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_empty_gif_module_ctx),
    ngx_http_empty_gif_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 109 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_empty_gif_module.c"
static ngx_str_t ngx_http_gif_type  =    {sizeof("image/gif") - 1UL, (u_char *)"image/gif"};
#line 112 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_empty_gif_module.c"
static ngx_int_t ngx_http_empty_gif_handler(ngx_http_request_t *r ) 
{ 
  ngx_http_complex_value_t cv ;
  ngx_int_t tmp ;

  {
#line 117
  if (! (r->method & 6UL)) {
#line 118
    return ((ngx_int_t )405);
  }
  {
#line 121
  memset((void *)(& cv), 0, sizeof(ngx_http_complex_value_t ));
#line 123
  cv.value.len = sizeof(ngx_empty_gif);
#line 124
  cv.value.data = ngx_empty_gif;
#line 125
  r->headers_out.last_modified_time = (time_t )23349600;
#line 127
  tmp = ngx_http_send_response(r, (ngx_uint_t )200, & ngx_http_gif_type, & cv);
  }
#line 127
  return (tmp);
}
}
#line 131 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_empty_gif_module.c"
static char *ngx_http_empty_gif(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 136
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 137
  clcf->handler = & ngx_http_empty_gif_handler;
#line 139
  return ((char *)((void *)0));
}
}
#line 177 "src/core/ngx_string.h"
off_t ngx_atoof(u_char *line , size_t n ) ;
#line 208
uintptr_t ngx_escape_uri(u_char *dst , u_char *src , size_t size , ngx_uint_t type ) ;
#line 88 "src/core/ngx_log.h"
void ngx_log_error_core(ngx_uint_t level , ngx_log_t *log , ngx_err_t err , char const   *fmt 
                        , ...) ;
#line 143 "src/core/ngx_buf.h"
ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool , size_t size ) ;
#line 150
ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool ) ;
#line 162
ngx_chain_t *ngx_chain_get_free_buf(ngx_pool_t *p , ngx_chain_t **free___0 ) ;
#line 80 "src/core/ngx_list.h"
void *ngx_list_push(ngx_list_t *l ) ;
#line 285 "src/core/ngx_conf_file.h"
char *ngx_conf_set_num_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 286
char *ngx_conf_set_size_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 288
char *ngx_conf_set_msec_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 292
char *ngx_conf_set_bitmask_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 51 "src/http/ngx_http_variables.h"
ngx_int_t ngx_http_get_variable_index(ngx_conf_t *cf , ngx_str_t *name ) ;
#line 52
ngx_http_variable_value_t *ngx_http_get_indexed_variable(ngx_http_request_t *r , ngx_uint_t index___0 ) ;
#line 408 "src/http/ngx_http_upstream.h"
ngx_int_t ngx_http_upstream_create(ngx_http_request_t *r ) ;
#line 409
void ngx_http_upstream_init(ngx_http_request_t *r ) ;
#line 410
ngx_http_upstream_srv_conf_t *ngx_http_upstream_add(ngx_conf_t *cf , ngx_url_t *u ,
                                                    ngx_uint_t flags ) ;
#line 412
char *ngx_http_upstream_bind_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 482 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_set_content_type(ngx_http_request_t *r ) ;
#line 148 "src/http/ngx_http.h"
ngx_int_t ngx_http_discard_request_body(ngx_http_request_t *r ) ;
#line 27 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_create_request(ngx_http_request_t *r ) ;
#line 28
static ngx_int_t ngx_http_memcached_reinit_request(ngx_http_request_t *r ) ;
#line 29
static ngx_int_t ngx_http_memcached_process_header(ngx_http_request_t *r ) ;
#line 30
static ngx_int_t ngx_http_memcached_filter_init(void *data ) ;
#line 31
static ngx_int_t ngx_http_memcached_filter(void *data , ssize_t bytes ) ;
#line 32
static void ngx_http_memcached_abort_request(ngx_http_request_t *r ) ;
#line 33
static void ngx_http_memcached_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 36
static void *ngx_http_memcached_create_loc_conf(ngx_conf_t *cf ) ;
#line 37
static char *ngx_http_memcached_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 40
static char *ngx_http_memcached_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 44 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_conf_bitmask_t ngx_http_memcached_next_upstream_masks[6]  = {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_response") - 1UL, (u_char *)"invalid_response"}, (ngx_uint_t )8}, 
        {{sizeof("not_found") - 1UL,
       (u_char *)"not_found"}, (ngx_uint_t )512}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 54 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_command_t ngx_http_memcached_commands[11]  = 
#line 54
  {      {{sizeof("memcached_pass") - 1UL, (u_char *)"memcached_pass"}, (ngx_uint_t )1207959554,
      & ngx_http_memcached_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("memcached_bind") - 1UL, (u_char *)"memcached_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("memcached_connect_timeout") - 1UL,
       (u_char *)"memcached_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("memcached_send_timeout") - 1UL, (u_char *)"memcached_send_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("memcached_buffer_size") - 1UL, (u_char *)"memcached_buffer_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.buffer_size),
      (void *)0}, 
        {{sizeof("memcached_read_timeout") - 1UL, (u_char *)"memcached_read_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("memcached_next_upstream") - 1UL, (u_char *)"memcached_next_upstream"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_memcached_next_upstream_masks)}, 
        {{sizeof("memcached_next_upstream_tries") - 1UL, (u_char *)"memcached_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("memcached_next_upstream_timeout") - 1UL, (u_char *)"memcached_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("memcached_gzip_flag") - 1UL, (u_char *)"memcached_gzip_flag"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_memcached_loc_conf_t *)0)->gzip_flag), (void *)0}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 130 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_http_module_t ngx_http_memcached_module_ctx  = 
#line 130
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_memcached_create_loc_conf, & ngx_http_memcached_merge_loc_conf};
#line 145 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
ngx_module_t ngx_http_memcached_module  = 
#line 145
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_memcached_module_ctx),
    ngx_http_memcached_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 161 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_str_t ngx_http_memcached_key  =    {sizeof("memcached_key") - 1UL, (u_char *)"memcached_key"};
#line 165 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static u_char ngx_http_memcached_end[8]  = 
#line 165
  {      (u_char )'\r',      (u_char )'\n',      (u_char )'E',      (u_char )'N', 
        (u_char )'D',      (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 168 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_upstream_t *u ;
  ngx_http_memcached_ctx_t *ctx ;
  ngx_http_memcached_loc_conf_t *mlcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 176
  if (! (r->method & 6UL)) {
#line 177
    return ((ngx_int_t )405);
  }
  {
#line 180
  rc = ngx_http_discard_request_body(r);
  }
#line 182
  if (rc != 0L) {
#line 183
    return (rc);
  }
  {
#line 186
  tmp = ngx_http_set_content_type(r);
  }
#line 186
  if (tmp != 0L) {
#line 187
    return ((ngx_int_t )500);
  }
  {
#line 190
  tmp___0 = ngx_http_upstream_create(r);
  }
#line 190
  if (tmp___0 != 0L) {
#line 191
    return ((ngx_int_t )500);
  }
  {
#line 194
  u = r->upstream;
#line 196
  u->schema.len = sizeof("memcached://") - 1UL;
#line 196
  u->schema.data = (u_char *)"memcached://";
#line 197
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_memcached_module);
#line 199
  mlcf = (ngx_http_memcached_loc_conf_t *)*(r->loc_conf + ngx_http_memcached_module.ctx_index);
#line 201
  u->conf = & mlcf->upstream;
#line 203
  u->create_request = & ngx_http_memcached_create_request;
#line 204
  u->reinit_request = & ngx_http_memcached_reinit_request;
#line 205
  u->process_header = & ngx_http_memcached_process_header;
#line 206
  u->abort_request = & ngx_http_memcached_abort_request;
#line 207
  u->finalize_request = & ngx_http_memcached_finalize_request;
#line 209
  tmp___1 = ngx_palloc(r->pool, sizeof(ngx_http_memcached_ctx_t ));
#line 209
  ctx = (ngx_http_memcached_ctx_t *)tmp___1;
  }
#line 210
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 211
    return ((ngx_int_t )500);
  }
  {
#line 214
  ctx->request = r;
#line 216
  *(r->ctx + ngx_http_memcached_module.ctx_index) = (void *)ctx;
#line 218
  u->input_filter_init = & ngx_http_memcached_filter_init;
#line 219
  u->input_filter = & ngx_http_memcached_filter;
#line 220
  u->input_filter_ctx = (void *)ctx;
#line 222
  ((r->main)->count) ++;
#line 224
  ngx_http_upstream_init(r);
  }
#line 226
  return ((ngx_int_t )-4);
}
}
#line 230 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_create_request(ngx_http_request_t *r ) 
{ 
  size_t len ;
  uintptr_t escape___0 ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_memcached_ctx_t *ctx ;
  ngx_http_variable_value_t *vv ;
  ngx_http_memcached_loc_conf_t *mlcf ;
  uintptr_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  void *tmp___4 ;
  uintptr_t tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 241
  mlcf = (ngx_http_memcached_loc_conf_t *)*(r->loc_conf + ngx_http_memcached_module.ctx_index);
#line 243
  vv = ngx_http_get_indexed_variable(r, (ngx_uint_t )mlcf->index);
  }
#line 245
  if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 245
    goto _L;
  } else
#line 245
  if (vv->not_found) {
#line 245
    goto _L;
  } else
#line 245
  if (vv->len == 0U) {
    _L: /* CIL Label */ 
#line 246
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 246
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the \"$memcached_key\" variable is not set");
      }
    }
#line 248
    return ((ngx_int_t )-1);
  }
  {
#line 251
  tmp = ngx_escape_uri((u_char *)((void *)0), vv->data, (size_t )vv->len, (ngx_uint_t )5);
#line 251
  escape___0 = 2UL * tmp;
#line 253
  len = ((((sizeof("get ") - 1UL) + (unsigned long )vv->len) + escape___0) + sizeof("\r\n")) - 1UL;
#line 255
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 256
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 257
    return ((ngx_int_t )-1);
  }
  {
#line 260
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 261
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 262
    return ((ngx_int_t )-1);
  }
#line 265
  cl->buf = b;
#line 266
  cl->next = (ngx_chain_t *)((void *)0);
#line 268
  (r->upstream)->request_bufs = cl;
#line 270
  tmp___0 = b->last;
#line 270
  (b->last) ++;
#line 270
  *tmp___0 = (u_char )'g';
#line 270
  tmp___1 = b->last;
#line 270
  (b->last) ++;
#line 270
  *tmp___1 = (u_char )'e';
#line 270
  tmp___2 = b->last;
#line 270
  (b->last) ++;
#line 270
  *tmp___2 = (u_char )'t';
#line 270
  tmp___3 = b->last;
#line 270
  (b->last) ++;
#line 270
  *tmp___3 = (u_char )' ';
#line 272
  ctx = (ngx_http_memcached_ctx_t *)*(r->ctx + ngx_http_memcached_module.ctx_index);
#line 274
  ctx->key.data = b->last;
#line 276
  if (escape___0 == 0UL) {
    {
#line 277
    tmp___4 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)vv->data,
                     (size_t )vv->len);
#line 277
    b->last = (u_char *)tmp___4 + vv->len;
    }
  } else {
    {
#line 280
    tmp___5 = ngx_escape_uri(b->last, vv->data, (size_t )vv->len, (ngx_uint_t )5);
#line 280
    b->last = (u_char *)tmp___5;
    }
  }
#line 284
  ctx->key.len = (size_t )(b->last - ctx->key.data);
#line 289
  tmp___6 = b->last;
#line 289
  (b->last) ++;
#line 289
  *tmp___6 = (u_char )'\r';
#line 289
  tmp___7 = b->last;
#line 289
  (b->last) ++;
#line 289
  *tmp___7 = (u_char )'\n';
#line 291
  return ((ngx_int_t )0);
}
}
#line 295 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_reinit_request(ngx_http_request_t *r ) 
{ 


  {
#line 298
  return ((ngx_int_t )0);
}
}
#line 302 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_process_header(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char *start ;
  ngx_str_t line ;
  ngx_uint_t flags ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_memcached_ctx_t *ctx ;
  ngx_http_memcached_loc_conf_t *mlcf ;
  int tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 313
  u = r->upstream;
#line 315
  p = u->buffer.pos;
  {
#line 315
  while (1) {
    while_continue: /* CIL Label */ ;
#line 315
    if (! ((unsigned long )p < (unsigned long )u->buffer.last)) {
#line 315
      goto while_break;
    }
#line 316
    if ((int )*p == 10) {
#line 317
      goto found;
    }
#line 315
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return ((ngx_int_t )-2);
  found: 
#line 325
  line.data = u->buffer.pos;
#line 326
  line.len = (size_t )(p - u->buffer.pos);
#line 328
  if (line.len == 0UL) {
#line 329
    goto no_valid;
  } else
#line 328
  if ((int )*(p - 1) != 13) {
#line 329
    goto no_valid;
  }
  {
#line 332
  *p = (u_char )'\000';
#line 333
  (line.len) --;
#line 338
  p = u->buffer.pos;
#line 340
  ctx = (ngx_http_memcached_ctx_t *)*(r->ctx + ngx_http_memcached_module.ctx_index);
#line 341
  mlcf = (ngx_http_memcached_loc_conf_t *)*(r->loc_conf + ngx_http_memcached_module.ctx_index);
#line 343
  tmp___4 = strncmp((char const   *)p, "VALUE ", sizeof("VALUE ") - 1UL);
  }
#line 343
  if (tmp___4 == 0) {
    {
#line 345
    p += sizeof("VALUE ") - 1UL;
#line 347
    tmp = strncmp((char const   *)p, (char const   *)ctx->key.data, ctx->key.len);
    }
#line 347
    if (tmp != 0) {
#line 348
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 348
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "memcached sent invalid key in response \"%V\" for key \"%V\"",
                           & line, & ctx->key);
        }
      }
#line 353
      return ((ngx_int_t )40);
    }
#line 356
    p += ctx->key.len;
#line 358
    tmp___0 = p;
#line 358
    p ++;
#line 358
    if ((int )*tmp___0 != 32) {
#line 359
      goto no_valid;
    }
#line 364
    start = p;
    {
#line 366
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 366
      if (! *p) {
#line 366
        goto while_break___0;
      }
#line 367
      tmp___1 = p;
#line 367
      p ++;
#line 367
      if ((int )*tmp___1 == 32) {
#line 368
        if (mlcf->gzip_flag) {
#line 369
          goto flags;
        } else {
#line 371
          goto length;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 376
    goto no_valid;
    flags: 
    {
#line 380
    tmp___2 = ngx_atoi(start, (size_t )((p - start) - 1L));
#line 380
    flags = (ngx_uint_t )tmp___2;
    }
#line 382
    if (flags == 0xffffffffffffffffUL) {
#line 383
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 383
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "memcached sent invalid flags in response \"%V\" for key \"%V\"",
                           & line, & ctx->key);
        }
      }
#line 387
      return ((ngx_int_t )40);
    }
#line 390
    if (flags & mlcf->gzip_flag) {
      {
#line 391
      tmp___3 = ngx_list_push(& r->headers_out.headers);
#line 391
      h = (ngx_table_elt_t *)tmp___3;
      }
#line 392
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 393
        return ((ngx_int_t )-1);
      }
#line 396
      h->hash = (ngx_uint_t )1;
#line 397
      h->key.len = sizeof("Content-Encoding") - 1UL;
#line 397
      h->key.data = (u_char *)"Content-Encoding";
#line 398
      h->value.len = sizeof("gzip") - 1UL;
#line 398
      h->value.data = (u_char *)"gzip";
#line 399
      r->headers_out.content_encoding = h;
    }
    length: 
    {
#line 404
    start = p;
#line 405
    p = line.data + line.len;
#line 407
    u->headers_in.content_length_n = ngx_atoof(start, (size_t )(p - start));
    }
#line 408
    if (u->headers_in.content_length_n == -1L) {
#line 409
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 409
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "memcached sent invalid length in response \"%V\" for key \"%V\"",
                           & line, & ctx->key);
        }
      }
#line 413
      return ((ngx_int_t )40);
    }
#line 416
    u->headers_in.status_n = (ngx_uint_t )200;
#line 417
    (u->state)->status = (ngx_uint_t )200;
#line 418
    u->buffer.pos = (p + sizeof("\r\n")) - 1;
#line 420
    return ((ngx_int_t )0);
  }
  {
#line 423
  tmp___5 = strcmp((char const   *)p, "END\r");
  }
#line 423
  if (tmp___5 == 0) {
#line 424
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 424
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "key: \"%V\" was not found by memcached",
                         & ctx->key);
      }
    }
#line 427
    u->headers_in.content_length_n = (off_t )0;
#line 428
    u->headers_in.status_n = (ngx_uint_t )404;
#line 429
    (u->state)->status = (ngx_uint_t )404;
#line 430
    u->buffer.pos = (p + sizeof("END\r\n")) - 1;
#line 431
    u->keepalive = 1U;
#line 433
    return ((ngx_int_t )0);
  }
  no_valid: 
#line 438
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 438
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "memcached sent invalid response: \"%V\"",
                       & line);
    }
  }
#line 441
  return ((ngx_int_t )40);
}
}
#line 445 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_filter_init(void *data ) 
{ 
  ngx_http_memcached_ctx_t *ctx ;
  ngx_http_upstream_t *u ;

  {
#line 448
  ctx = (ngx_http_memcached_ctx_t *)data;
#line 452
  u = (ctx->request)->upstream;
#line 454
  if (u->headers_in.status_n != 404UL) {
#line 455
    u->length = (off_t )((unsigned long )u->headers_in.content_length_n + (sizeof(ngx_http_memcached_end) - 1UL));
#line 456
    ctx->rest = sizeof(ngx_http_memcached_end) - 1UL;
  } else {
#line 459
    u->length = (off_t )0;
  }
#line 462
  return ((ngx_int_t )0);
}
}
#line 466 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static ngx_int_t ngx_http_memcached_filter(void *data , ssize_t bytes ) 
{ 
  ngx_http_memcached_ctx_t *ctx ;
  u_char *last ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_upstream_t *u ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 469
  ctx = (ngx_http_memcached_ctx_t *)data;
#line 476
  u = (ctx->request)->upstream;
#line 477
  b = & u->buffer;
#line 479
  if (u->length == (ssize_t )ctx->rest) {
    {
#line 481
    tmp = strncmp((char const   *)b->last, ((char const   *)(ngx_http_memcached_end) + (sizeof(ngx_http_memcached_end) - 1UL)) - ctx->rest,
                  (size_t )bytes);
    }
#line 481
    if (tmp != 0) {
#line 486
      if ((((ctx->request)->connection)->log)->log_level >= 4UL) {
        {
#line 486
        ngx_log_error_core((ngx_uint_t )4, ((ctx->request)->connection)->log, 0, "memcached sent invalid trailer");
        }
      }
#line 489
      u->length = (off_t )0;
#line 490
      ctx->rest = (size_t )0;
#line 492
      return ((ngx_int_t )0);
    }
#line 495
    u->length -= bytes;
#line 496
    ctx->rest -= (size_t )bytes;
#line 498
    if (u->length == 0L) {
#line 499
      u->keepalive = 1U;
    }
#line 502
    return ((ngx_int_t )0);
  }
#line 505
  cl = u->out_bufs;
#line 505
  ll = & u->out_bufs;
  {
#line 505
  while (1) {
    while_continue: /* CIL Label */ ;
#line 505
    if (! cl) {
#line 505
      goto while_break;
    }
#line 506
    ll = & cl->next;
#line 505
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 509
  cl = ngx_chain_get_free_buf((ctx->request)->pool, & u->free_bufs);
  }
#line 510
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 511
    return ((ngx_int_t )-1);
  }
#line 514
  (cl->buf)->flush = 1U;
#line 515
  (cl->buf)->memory = 1U;
#line 517
  *ll = cl;
#line 519
  last = b->last;
#line 520
  (cl->buf)->pos = last;
#line 521
  b->last += bytes;
#line 522
  (cl->buf)->last = b->last;
#line 523
  (cl->buf)->tag = u->output.tag;
#line 529
  if (bytes <= (ssize_t )((unsigned long )u->length - (sizeof(ngx_http_memcached_end) - 1UL))) {
#line 530
    u->length -= bytes;
#line 531
    return ((ngx_int_t )0);
  }
  {
#line 534
  last += (unsigned long )u->length - (sizeof(ngx_http_memcached_end) - 1UL);
#line 536
  tmp___0 = strncmp((char const   *)last, (char const   *)(ngx_http_memcached_end),
                    (size_t )(b->last - last));
  }
#line 536
  if (tmp___0 != 0) {
#line 537
    if ((((ctx->request)->connection)->log)->log_level >= 4UL) {
      {
#line 537
      ngx_log_error_core((ngx_uint_t )4, ((ctx->request)->connection)->log, 0, "memcached sent invalid trailer");
      }
    }
#line 540
    b->last = last;
#line 541
    (cl->buf)->last = last;
#line 542
    u->length = (off_t )0;
#line 543
    ctx->rest = (size_t )0;
#line 545
    return ((ngx_int_t )0);
  }
#line 548
  ctx->rest -= (size_t )(b->last - last);
#line 549
  b->last = last;
#line 550
  (cl->buf)->last = last;
#line 551
  u->length = (off_t )ctx->rest;
#line 553
  if (u->length == 0L) {
#line 554
    u->keepalive = 1U;
  }
#line 557
  return ((ngx_int_t )0);
}
}
#line 561 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static void ngx_http_memcached_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 566
  return;
}
}
#line 570 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static void ngx_http_memcached_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 575
  return;
}
}
#line 579 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static void *ngx_http_memcached_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_memcached_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 584
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_memcached_loc_conf_t ));
#line 584
  conf = (ngx_http_memcached_loc_conf_t *)tmp;
  }
#line 585
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 586
    return ((void *)0);
  }
#line 599
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 600
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 601
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 602
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 603
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 604
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 606
  conf->upstream.buffer_size = (size_t )-1;
#line 609
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 610
  conf->upstream.buffering = (ngx_flag_t )0;
#line 611
  conf->upstream.ignore_client_abort = (ngx_flag_t )0;
#line 612
  conf->upstream.send_lowat = (size_t )0;
#line 613
  conf->upstream.bufs.num = (ngx_int_t )0;
#line 614
  conf->upstream.busy_buffers_size = (size_t )0;
#line 615
  conf->upstream.max_temp_file_size = (size_t )0;
#line 616
  conf->upstream.temp_file_write_size = (size_t )0;
#line 617
  conf->upstream.intercept_errors = (ngx_flag_t )1;
#line 618
  conf->upstream.intercept_404 = 1U;
#line 619
  conf->upstream.pass_request_headers = (ngx_flag_t )0;
#line 620
  conf->upstream.pass_request_body = (ngx_flag_t )0;
#line 621
  conf->upstream.force_ranges = (ngx_flag_t )1;
#line 623
  conf->index = (ngx_int_t )-1;
#line 624
  conf->gzip_flag = (ngx_uint_t )-1;
#line 626
  return ((void *)conf);
}
}
#line 630 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static char *ngx_http_memcached_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_memcached_loc_conf_t *prev ;
  ngx_http_memcached_loc_conf_t *conf ;

  {
#line 633
  prev = (ngx_http_memcached_loc_conf_t *)parent;
#line 634
  conf = (ngx_http_memcached_loc_conf_t *)child;
#line 636
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 636
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 636
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 636
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 639
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 639
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 639
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 639
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 642
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 642
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 642
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 642
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 645
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 645
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 645
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 645
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 648
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 648
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 648
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 648
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 651
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 651
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 651
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 651
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 654
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 654
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 654
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 654
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 658
  if (conf->upstream.next_upstream == 0UL) {
#line 658
    if (prev->upstream.next_upstream == 0UL) {
#line 658
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 658
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 664
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 665
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
#line 669
  if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 670
    conf->upstream.upstream = prev->upstream.upstream;
  }
#line 673
  if (conf->index == -1L) {
#line 674
    conf->index = prev->index;
  }
#line 677
  if (conf->gzip_flag == 0xffffffffffffffffUL) {
#line 677
    if (prev->gzip_flag == 0xffffffffffffffffUL) {
#line 677
      conf->gzip_flag = (ngx_uint_t )0;
    } else {
#line 677
      conf->gzip_flag = prev->gzip_flag;
    }
  }
#line 679
  return ((char *)((void *)0));
}
}
#line 683 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_memcached_module.c"
static char *ngx_http_memcached_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_memcached_loc_conf_t *mlcf ;
  ngx_str_t *value ;
  ngx_url_t u ;
  ngx_http_core_loc_conf_t *clcf ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 686
  mlcf = (ngx_http_memcached_loc_conf_t *)conf;
#line 692
  if (mlcf->upstream.upstream) {
#line 693
    return ((char *)"is duplicate");
  }
  {
#line 696
  value = (ngx_str_t *)(cf->args)->elts;
#line 698
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 700
  u.url = *(value + 1);
#line 701
  u.no_resolve = 1U;
#line 703
  mlcf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 704
  if ((unsigned long )mlcf->upstream.upstream == (unsigned long )((void *)0)) {
#line 705
    return ((char *)((void *)-1));
  }
#line 708
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 710
  clcf->handler = & ngx_http_memcached_handler;
#line 712
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 713
    clcf->auto_redirect = 1U;
  }
  {
#line 716
  mlcf->index = ngx_http_get_variable_index(cf, & ngx_http_memcached_key);
  }
#line 718
  if (mlcf->index == -1L) {
#line 719
    return ((char *)((void *)-1));
  }
#line 722
  return ((char *)((void *)0));
}
}
#line 50 "src/core/ngx_string.h"
void ngx_strlow(u_char *dst , u_char *src , size_t n ) ;
#line 42 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_cacheline_size ;
#line 80 "src/core/ngx_palloc.h"
void *ngx_pnalloc(ngx_pool_t *pool , size_t size ) ;
#line 28 "src/core/ngx_array.h"
void *ngx_array_push_n(ngx_array_t *a , ngx_uint_t n ) ;
#line 31 "src/core/ngx_array.h"
__inline static ngx_int_t ngx_array_init(ngx_array_t *array , ngx_pool_t *pool , ngx_uint_t n ,
                                         size_t size ) 
{ 


  {
  {
#line 39
  array->nelts = (ngx_uint_t )0;
#line 40
  array->size = size;
#line 41
  array->nalloc = n;
#line 42
  array->pool = pool;
#line 44
  array->elts = ngx_palloc(pool, n * size);
  }
#line 45
  if ((unsigned long )array->elts == (unsigned long )((void *)0)) {
#line 46
    return ((ngx_int_t )-1);
  }
#line 49
  return ((ngx_int_t )0);
}
}
#line 100 "src/core/ngx_hash.h"
void *ngx_hash_find(ngx_hash_t *hash , ngx_uint_t key , u_char *name , size_t len ) ;
#line 106
ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit , ngx_hash_key_t *names , ngx_uint_t nelts ) ;
#line 113
ngx_uint_t ngx_hash_key_lc(u_char *data , size_t len ) ;
#line 154 "src/core/ngx_file.h"
char *ngx_conf_set_path_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 155
char *ngx_conf_merge_path_value(ngx_conf_t *cf , ngx_path_t **path , ngx_path_t *prev ,
                                ngx_path_init_t *init ) ;
#line 157
char *ngx_conf_set_access_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 122 "src/core/ngx_inet.h"
ngx_int_t ngx_parse_url(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 280 "src/core/ngx_conf_file.h"
char *ngx_conf_set_flag_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 282
char *ngx_conf_set_str_array_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 287
char *ngx_conf_set_off_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 290
char *ngx_conf_set_bufs_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 217 "src/http/ngx_http_script.h"
char *ngx_http_set_predicate_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 220
ngx_uint_t ngx_http_script_variables_count(ngx_str_t *value ) ;
#line 221
ngx_int_t ngx_http_script_compile(ngx_http_script_compile_t *sc ) ;
#line 222
u_char *ngx_http_script_run(ngx_http_request_t *r , ngx_str_t *value , void *code_lengths ,
                            size_t len , void *code_values ) ;
#line 224
void ngx_http_script_flush_no_cacheable_variables(ngx_http_request_t *r , ngx_array_t *indices ) ;
#line 231
size_t ngx_http_script_copy_len_code(ngx_http_script_engine_t *e ) ;
#line 232
void ngx_http_script_copy_code(ngx_http_script_engine_t *e ) ;
#line 103 "src/event/ngx_event_pipe.h"
ngx_int_t ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
#line 414 "src/http/ngx_http_upstream.h"
char *ngx_http_upstream_param_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 416
ngx_int_t ngx_http_upstream_hide_headers_hash(ngx_conf_t *cf , ngx_http_upstream_conf_t *conf ,
                                              ngx_http_upstream_conf_t *prev , ngx_str_t *default_hide_headers ,
                                              ngx_hash_init_t *hash ) ;
#line 426
ngx_conf_bitmask_t ngx_http_upstream_cache_method_mask[4] ;
#line 427
ngx_conf_bitmask_t ngx_http_upstream_ignore_headers_masks[10] ;
#line 198 "src/http/ngx_http_cache.h"
char *ngx_http_file_cache_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 200
char *ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 96 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_status_line(ngx_http_request_t *r , ngx_buf_t *b , ngx_http_status_t *status ) ;
#line 100
ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r , ngx_buf_t *b , ngx_uint_t allow_underscores ) ;
#line 136
ngx_int_t ngx_http_read_client_request_body(ngx_http_request_t *r , void (*post_handler)(ngx_http_request_t *r ) ) ;
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_eval(ngx_http_request_t *r , ngx_http_scgi_loc_conf_t *scf ) ;
#line 48
static ngx_int_t ngx_http_scgi_create_request(ngx_http_request_t *r ) ;
#line 49
static ngx_int_t ngx_http_scgi_reinit_request(ngx_http_request_t *r ) ;
#line 50
static ngx_int_t ngx_http_scgi_process_status_line(ngx_http_request_t *r ) ;
#line 51
static ngx_int_t ngx_http_scgi_process_header(ngx_http_request_t *r ) ;
#line 52
static void ngx_http_scgi_abort_request(ngx_http_request_t *r ) ;
#line 53
static void ngx_http_scgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 55
static void *ngx_http_scgi_create_main_conf(ngx_conf_t *cf ) ;
#line 56
static void *ngx_http_scgi_create_loc_conf(ngx_conf_t *cf ) ;
#line 57
static char *ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 59
static ngx_int_t ngx_http_scgi_init_params(ngx_conf_t *cf , ngx_http_scgi_loc_conf_t *conf ,
                                           ngx_http_scgi_params_t *params , ngx_keyval_t *default_params ) ;
#line 63
static char *ngx_http_scgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 64
static char *ngx_http_scgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 68
static ngx_int_t ngx_http_scgi_create_key(ngx_http_request_t *r ) ;
#line 69
static char *ngx_http_scgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 71
static char *ngx_http_scgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 76 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_conf_bitmask_t ngx_http_scgi_next_upstream_masks[12]  = 
#line 76
  {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_header") - 1UL, (u_char *)"invalid_header"}, (ngx_uint_t )8}, 
        {{sizeof("non_idempotent") - 1UL,
       (u_char *)"non_idempotent"}, (ngx_uint_t )16384}, 
        {{sizeof("http_500") - 1UL, (u_char *)"http_500"}, (ngx_uint_t )16}, 
        {{sizeof("http_503") - 1UL, (u_char *)"http_503"}, (ngx_uint_t )64}, 
        {{sizeof("http_403") - 1UL, (u_char *)"http_403"}, (ngx_uint_t )256}, 
        {{sizeof("http_404") - 1UL, (u_char *)"http_404"}, (ngx_uint_t )512}, 
        {{sizeof("http_429") - 1UL, (u_char *)"http_429"}, (ngx_uint_t )1024}, 
        {{sizeof("updating") - 1UL, (u_char *)"updating"}, (ngx_uint_t )2048}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 95 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_command_t ngx_http_scgi_commands[44]  = 
#line 95
  {      {{sizeof("scgi_pass") - 1UL, (u_char *)"scgi_pass"}, (ngx_uint_t )1207959554,
      & ngx_http_scgi_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("scgi_store") - 1UL, (u_char *)"scgi_store"}, (ngx_uint_t )234881026,
      & ngx_http_scgi_store, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("scgi_store_access") - 1UL, (u_char *)"scgi_store_access"}, (ngx_uint_t )234881038,
      & ngx_conf_set_access_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.store_access),
      (void *)0}, 
        {{sizeof("scgi_buffering") - 1UL, (u_char *)"scgi_buffering"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.buffering), (void *)0}, 
        {{sizeof("scgi_request_buffering") - 1UL,
       (u_char *)"scgi_request_buffering"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.request_buffering),
      (void *)0}, 
        {{sizeof("scgi_ignore_client_abort") - 1UL, (u_char *)"scgi_ignore_client_abort"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.ignore_client_abort),
      (void *)0}, 
        {{sizeof("scgi_bind") - 1UL, (u_char *)"scgi_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("scgi_connect_timeout") - 1UL,
       (u_char *)"scgi_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("scgi_send_timeout") - 1UL, (u_char *)"scgi_send_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("scgi_buffer_size") - 1UL, (u_char *)"scgi_buffer_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.buffer_size), (void *)0}, 
        {{sizeof("scgi_pass_request_headers") - 1UL,
       (u_char *)"scgi_pass_request_headers"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.pass_request_headers),
      (void *)0}, 
        {{sizeof("scgi_pass_request_body") - 1UL, (u_char *)"scgi_pass_request_body"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.pass_request_body),
      (void *)0}, 
        {{sizeof("scgi_intercept_errors") - 1UL, (u_char *)"scgi_intercept_errors"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.intercept_errors),
      (void *)0}, 
        {{sizeof("scgi_read_timeout") - 1UL, (u_char *)"scgi_read_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("scgi_buffers") - 1UL, (u_char *)"scgi_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.bufs), (void *)0}, 
        {{sizeof("scgi_busy_buffers_size") - 1UL,
       (u_char *)"scgi_busy_buffers_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.busy_buffers_size_conf),
      (void *)0}, 
        {{sizeof("scgi_force_ranges") - 1UL, (u_char *)"scgi_force_ranges"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.force_ranges),
      (void *)0}, 
        {{sizeof("scgi_limit_rate") - 1UL, (u_char *)"scgi_limit_rate"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.limit_rate), (void *)0}, 
        {{sizeof("scgi_cache") - 1UL,
       (u_char *)"scgi_cache"}, (ngx_uint_t )234881026, & ngx_http_scgi_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("scgi_cache_key") - 1UL, (u_char *)"scgi_cache_key"}, (ngx_uint_t )234881026,
      & ngx_http_scgi_cache_key, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("scgi_cache_path") - 1UL, (u_char *)"scgi_cache_path"}, (ngx_uint_t )33558528,
      & ngx_http_file_cache_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_scgi_main_conf_t *)0)->caches), (void *)(& ngx_http_scgi_module)}, 
        {{sizeof("scgi_cache_bypass") - 1UL,
       (u_char *)"scgi_cache_bypass"}, (ngx_uint_t )234883072, & ngx_http_set_predicate_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_bypass),
      (void *)0}, 
        {{sizeof("scgi_no_cache") - 1UL, (u_char *)"scgi_no_cache"}, (ngx_uint_t )234883072,
      & ngx_http_set_predicate_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.no_cache), (void *)0}, 
        {{sizeof("scgi_cache_valid") - 1UL,
       (u_char *)"scgi_cache_valid"}, (ngx_uint_t )234883072, & ngx_http_file_cache_valid_set_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_valid),
      (void *)0}, 
        {{sizeof("scgi_cache_min_uses") - 1UL, (u_char *)"scgi_cache_min_uses"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_min_uses),
      (void *)0}, 
        {{sizeof("scgi_cache_max_range_offset") - 1UL, (u_char *)"scgi_cache_max_range_offset"},
      (ngx_uint_t )234881026, & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_max_range_offset),
      (void *)0}, 
        {{sizeof("scgi_cache_use_stale") - 1UL, (u_char *)"scgi_cache_use_stale"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_use_stale),
      (void *)(& ngx_http_scgi_next_upstream_masks)}, 
        {{sizeof("scgi_cache_methods") - 1UL, (u_char *)"scgi_cache_methods"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_methods),
      (void *)(& ngx_http_upstream_cache_method_mask)}, 
        {{sizeof("scgi_cache_lock") - 1UL, (u_char *)"scgi_cache_lock"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_lock), (void *)0}, 
        {{sizeof("scgi_cache_lock_timeout") - 1UL,
       (u_char *)"scgi_cache_lock_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_lock_timeout),
      (void *)0}, 
        {{sizeof("scgi_cache_lock_age") - 1UL, (u_char *)"scgi_cache_lock_age"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_lock_age),
      (void *)0}, 
        {{sizeof("scgi_cache_revalidate") - 1UL, (u_char *)"scgi_cache_revalidate"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_revalidate),
      (void *)0}, 
        {{sizeof("scgi_cache_background_update") - 1UL, (u_char *)"scgi_cache_background_update"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.cache_background_update),
      (void *)0}, 
        {{sizeof("scgi_temp_path") - 1UL, (u_char *)"scgi_temp_path"}, (ngx_uint_t )234881054,
      & ngx_conf_set_path_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.temp_path), (void *)0}, 
        {{sizeof("scgi_max_temp_file_size") - 1UL,
       (u_char *)"scgi_max_temp_file_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.max_temp_file_size_conf),
      (void *)0}, 
        {{sizeof("scgi_temp_file_write_size") - 1UL, (u_char *)"scgi_temp_file_write_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.temp_file_write_size_conf),
      (void *)0}, 
        {{sizeof("scgi_next_upstream") - 1UL, (u_char *)"scgi_next_upstream"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_scgi_next_upstream_masks)}, 
        {{sizeof("scgi_next_upstream_tries") - 1UL, (u_char *)"scgi_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("scgi_next_upstream_timeout") - 1UL, (u_char *)"scgi_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("scgi_param") - 1UL, (u_char *)"scgi_param"}, (ngx_uint_t )234881036,
      & ngx_http_upstream_param_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->params_source), (void *)0}, 
        {{sizeof("scgi_pass_header") - 1UL,
       (u_char *)"scgi_pass_header"}, (ngx_uint_t )234881026, & ngx_conf_set_str_array_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.pass_headers),
      (void *)0}, 
        {{sizeof("scgi_hide_header") - 1UL, (u_char *)"scgi_hide_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.hide_headers),
      (void *)0}, 
        {{sizeof("scgi_ignore_headers") - 1UL, (u_char *)"scgi_ignore_headers"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_scgi_loc_conf_t *)0)->upstream.ignore_headers),
      (void *)(& ngx_http_upstream_ignore_headers_masks)}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 406 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_http_module_t ngx_http_scgi_module_ctx  = 
#line 406
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_scgi_create_main_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_scgi_create_loc_conf, & ngx_http_scgi_merge_loc_conf};
#line 421 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
ngx_module_t ngx_http_scgi_module  = 
#line 421
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_scgi_module_ctx),
    ngx_http_scgi_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 437 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_str_t ngx_http_scgi_hide_headers[7]  = {      {sizeof("Status") - 1UL, (u_char *)"Status"}, 
        {sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, 
        {sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, 
        {sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, 
        {sizeof("X-Accel-Buffering") - 1UL, (u_char *)"X-Accel-Buffering"}, 
        {sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, 
        {(size_t )0, (u_char *)((void *)0)}};
#line 450 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_keyval_t ngx_http_scgi_cache_headers[7]  = {      {{sizeof("HTTP_IF_MODIFIED_SINCE") - 1UL, (u_char *)"HTTP_IF_MODIFIED_SINCE"},
      {sizeof("$upstream_cache_last_modified") - 1UL, (u_char *)"$upstream_cache_last_modified"}}, 
        {{sizeof("HTTP_IF_UNMODIFIED_SINCE") - 1UL,
       (u_char *)"HTTP_IF_UNMODIFIED_SINCE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_NONE_MATCH") - 1UL, (u_char *)"HTTP_IF_NONE_MATCH"}, {sizeof("$upstream_cache_etag") - 1UL,
                                                                             (u_char *)"$upstream_cache_etag"}}, 
        {{sizeof("HTTP_IF_MATCH") - 1UL,
       (u_char *)"HTTP_IF_MATCH"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_RANGE") - 1UL, (u_char *)"HTTP_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_RANGE") - 1UL,
       (u_char *)"HTTP_IF_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t )0, (u_char *)((void *)0)}, {(size_t )0, (u_char *)((void *)0)}}};
#line 464 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_path_init_t ngx_http_scgi_temp_path  =    {{sizeof("scgi_temp") - 1UL, (u_char *)"scgi_temp"}, {(size_t )1, (size_t )2, (size_t )0}};
#line 469 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_status_t *status ;
  ngx_http_upstream_t *u ;
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_http_scgi_main_conf_t *smcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 480
  tmp = ngx_http_upstream_create(r);
  }
#line 480
  if (tmp != 0L) {
#line 481
    return ((ngx_int_t )500);
  }
  {
#line 484
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_status_t ));
#line 484
  status = (ngx_http_status_t *)tmp___0;
  }
#line 485
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 486
    return ((ngx_int_t )500);
  }
#line 489
  *(r->ctx + ngx_http_scgi_module.ctx_index) = (void *)status;
#line 491
  scf = (ngx_http_scgi_loc_conf_t *)*(r->loc_conf + ngx_http_scgi_module.ctx_index);
#line 493
  if (scf->scgi_lengths) {
    {
#line 494
    tmp___1 = ngx_http_scgi_eval(r, scf);
    }
#line 494
    if (tmp___1 != 0L) {
#line 495
      return ((ngx_int_t )500);
    }
  }
  {
#line 499
  u = r->upstream;
#line 501
  u->schema.len = sizeof("scgi://") - 1UL;
#line 501
  u->schema.data = (u_char *)"scgi://";
#line 502
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_scgi_module);
#line 504
  u->conf = & scf->upstream;
#line 507
  smcf = (ngx_http_scgi_main_conf_t *)*(r->main_conf + ngx_http_scgi_module.ctx_index);
#line 509
  u->caches = & smcf->caches;
#line 510
  u->create_key = & ngx_http_scgi_create_key;
#line 513
  u->create_request = & ngx_http_scgi_create_request;
#line 514
  u->reinit_request = & ngx_http_scgi_reinit_request;
#line 515
  u->process_header = & ngx_http_scgi_process_status_line;
#line 516
  u->abort_request = & ngx_http_scgi_abort_request;
#line 517
  u->finalize_request = & ngx_http_scgi_finalize_request;
#line 518
  r->state = (ngx_uint_t )0;
#line 520
  u->buffering = (unsigned int )scf->upstream.buffering;
#line 522
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t ));
#line 522
  u->pipe = (ngx_event_pipe_t *)tmp___2;
  }
#line 523
  if ((unsigned long )u->pipe == (unsigned long )((void *)0)) {
#line 524
    return ((ngx_int_t )500);
  }
#line 527
  (u->pipe)->input_filter = & ngx_event_pipe_copy_input_filter;
#line 528
  (u->pipe)->input_ctx = (void *)r;
#line 530
  if (! scf->upstream.request_buffering) {
#line 530
    if (scf->upstream.pass_request_body) {
#line 530
      if (! r->headers_in.chunked) {
#line 534
        r->request_body_no_buffering = 1U;
      }
    }
  }
  {
#line 537
  rc = ngx_http_read_client_request_body(r, & ngx_http_upstream_init);
  }
#line 539
  if (rc >= 300L) {
#line 540
    return (rc);
  }
#line 543
  return ((ngx_int_t )-4);
}
}
#line 547 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_eval(ngx_http_request_t *r , ngx_http_scgi_loc_conf_t *scf ) 
{ 
  ngx_url_t url ;
  ngx_http_upstream_t *u ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 553
  memset((void *)(& url), 0, sizeof(ngx_url_t ));
#line 555
  tmp = ngx_http_script_run(r, & url.url, (scf->scgi_lengths)->elts, (size_t )0, (scf->scgi_values)->elts);
  }
#line 555
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 559
    return ((ngx_int_t )-1);
  }
  {
#line 562
  url.no_resolve = 1U;
#line 564
  tmp___0 = ngx_parse_url(r->pool, & url);
  }
#line 564
  if (tmp___0 != 0L) {
#line 565
    if (url.err) {
#line 566
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 566
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%s in upstream \"%V\"",
                           url.err, & url.url);
        }
      }
    }
#line 570
    return ((ngx_int_t )-1);
  }
  {
#line 573
  u = r->upstream;
#line 575
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t ));
#line 575
  u->resolved = (ngx_http_upstream_resolved_t *)tmp___1;
  }
#line 576
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 577
    return ((ngx_int_t )-1);
  }
#line 580
  if (url.addrs) {
#line 581
    (u->resolved)->sockaddr = (url.addrs + 0)->sockaddr;
#line 582
    (u->resolved)->socklen = (url.addrs + 0)->socklen;
#line 583
    (u->resolved)->name = (url.addrs + 0)->name;
#line 584
    (u->resolved)->naddrs = (ngx_uint_t )1;
  }
#line 587
  (u->resolved)->host = url.host;
#line 588
  (u->resolved)->port = url.port;
#line 589
  (u->resolved)->no_port = (ngx_uint_t )url.no_port;
#line 591
  return ((ngx_int_t )0);
}
}
#line 597 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_create_key(ngx_http_request_t *r ) 
{ 
  ngx_str_t *key ;
  ngx_http_scgi_loc_conf_t *scf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 603
  tmp = ngx_array_push(& (r->cache)->keys);
#line 603
  key = (ngx_str_t *)tmp;
  }
#line 604
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 605
    return ((ngx_int_t )-1);
  }
  {
#line 608
  scf = (ngx_http_scgi_loc_conf_t *)*(r->loc_conf + ngx_http_scgi_module.ctx_index);
#line 610
  tmp___0 = ngx_http_complex_value(r, & scf->cache_key, key);
  }
#line 610
  if (tmp___0 != 0L) {
#line 611
    return ((ngx_int_t )-1);
  }
#line 614
  return ((ngx_int_t )0);
}
}
#line 620 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_create_request(ngx_http_request_t *r ) 
{ 
  off_t content_length_n ;
  u_char ch ;
  u_char *key ;
  u_char *val ;
  u_char *lowcase_key ;
  size_t len ;
  size_t key_len ;
  size_t val_len ;
  size_t allocated ;
  ngx_buf_t *b ;
  ngx_str_t content_length ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t hash ;
  ngx_uint_t skip_empty ;
  ngx_uint_t header_params ;
  ngx_chain_t *cl ;
  ngx_chain_t *body ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_table_elt_t **ignored ;
  ngx_http_scgi_params_t *params ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_script_engine_t le ;
  ngx_http_scgi_loc_conf_t *scf ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  u_char buffer___0[sizeof("-9223372036854775808") - 1UL] ;
  off_t tmp ;
  u_char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_uint_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  u_char *tmp___7 ;
  void *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  void *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  void *tmp___14 ;
  void *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 639
  content_length_n = (off_t )0;
#line 640
  body = (r->upstream)->request_bufs;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! body) {
#line 642
      goto while_break;
    }
#line 643
    if ((body->buf)->temporary) {
#line 643
      tmp = (body->buf)->last - (body->buf)->pos;
    } else
#line 643
    if ((body->buf)->memory) {
#line 643
      tmp = (body->buf)->last - (body->buf)->pos;
    } else
#line 643
    if ((body->buf)->mmap) {
#line 643
      tmp = (body->buf)->last - (body->buf)->pos;
    } else {
#line 643
      tmp = (body->buf)->file_last - (body->buf)->file_pos;
    }
#line 643
    content_length_n += tmp;
#line 644
    body = body->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 647
  content_length.data = buffer___0;
#line 648
  tmp___0 = ngx_sprintf(buffer___0, "%O", content_length_n);
#line 648
  content_length.len = (size_t )(tmp___0 - buffer___0);
#line 650
  len = (sizeof("CONTENT_LENGTH") + content_length.len) + 1UL;
#line 652
  header_params = (ngx_uint_t )0;
#line 653
  ignored = (ngx_table_elt_t **)((void *)0);
#line 655
  scf = (ngx_http_scgi_loc_conf_t *)*(r->loc_conf + ngx_http_scgi_module.ctx_index);
  }
#line 658
  if ((r->upstream)->cacheable) {
#line 658
    params = & scf->params_cache;
  } else {
#line 658
    params = & scf->params;
  }
#line 663
  if (params->lengths) {
    {
#line 664
    memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 666
    ngx_http_script_flush_no_cacheable_variables(r, params->flushes);
#line 667
    le.flushed = 1U;
#line 669
    le.ip = (u_char *)(params->lengths)->elts;
#line 670
    le.request = r;
    }
    {
#line 672
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 672
      if (! *((uintptr_t *)le.ip)) {
#line 672
        goto while_break___0;
      }
      {
#line 674
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 675
      key_len = (*lcode)(& le);
#line 677
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 678
      skip_empty = (*lcode)(& le);
#line 680
      val_len = (size_t )0;
      }
      {
#line 680
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 680
        if (! *((uintptr_t *)le.ip)) {
#line 680
          goto while_break___1;
        }
        {
#line 681
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 680
        tmp___1 = (*lcode)(& le);
#line 680
        val_len += tmp___1;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 683
      le.ip += sizeof(uintptr_t );
#line 685
      if (skip_empty) {
#line 685
        if (val_len == 0UL) {
#line 686
          goto while_continue___0;
        }
      }
#line 689
      len += (key_len + val_len) + 1UL;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 693
  if (scf->upstream.pass_request_headers) {
#line 695
    allocated = (size_t )0;
#line 696
    lowcase_key = (u_char *)((void *)0);
#line 698
    if (params->number) {
#line 699
      n = (ngx_uint_t )0;
#line 700
      part = & r->headers_in.headers.part;
      {
#line 702
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 702
        if (! part) {
#line 702
          goto while_break___2;
        }
#line 703
        n += part->nelts;
#line 704
        part = part->next;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 707
      tmp___2 = ngx_palloc(r->pool, n * sizeof(void *));
#line 707
      ignored = (ngx_table_elt_t **)tmp___2;
      }
#line 708
      if ((unsigned long )ignored == (unsigned long )((void *)0)) {
#line 709
        return ((ngx_int_t )-1);
      }
    }
#line 713
    part = & r->headers_in.headers.part;
#line 714
    header___0 = (ngx_table_elt_t *)part->elts;
#line 716
    i = (ngx_uint_t )0;
    {
#line 716
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 718
      if (i >= part->nelts) {
#line 719
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 720
          goto while_break___3;
        }
#line 723
        part = part->next;
#line 724
        header___0 = (ngx_table_elt_t *)part->elts;
#line 725
        i = (ngx_uint_t )0;
      }
#line 728
      if (params->number) {
#line 729
        if (allocated < (header___0 + i)->key.len) {
          {
#line 730
          allocated = (header___0 + i)->key.len + 16UL;
#line 731
          tmp___3 = ngx_pnalloc(r->pool, allocated);
#line 731
          lowcase_key = (u_char *)tmp___3;
          }
#line 732
          if ((unsigned long )lowcase_key == (unsigned long )((void *)0)) {
#line 733
            return ((ngx_int_t )-1);
          }
        }
#line 737
        hash = (ngx_uint_t )0;
#line 739
        n = (ngx_uint_t )0;
        {
#line 739
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 739
          if (! (n < (header___0 + i)->key.len)) {
#line 739
            goto while_break___4;
          }
#line 740
          ch = *((header___0 + i)->key.data + n);
#line 742
          if ((int )ch >= 65) {
#line 742
            if ((int )ch <= 90) {
#line 743
              ch = (u_char )((int )ch | 32);
            } else {
#line 742
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 745
          if ((int )ch == 45) {
#line 746
            ch = (u_char )'_';
          }
#line 749
          hash = hash * 31UL + (ngx_uint_t )ch;
#line 750
          *(lowcase_key + n) = ch;
#line 739
          n ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        {
#line 753
        tmp___5 = ngx_hash_find(& params->hash, hash, lowcase_key, n);
        }
#line 753
        if (tmp___5) {
#line 754
          tmp___4 = header_params;
#line 754
          header_params ++;
#line 754
          *(ignored + tmp___4) = header___0 + i;
#line 755
          goto __Cont;
        }
      }
#line 759
      len += ((((sizeof("HTTP_") - 1UL) + (header___0 + i)->key.len) + 1UL) + (header___0 + i)->value.len) + 1UL;
      __Cont: /* CIL Label */ 
#line 716
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 766
  b = ngx_create_temp_buf(r->pool, (((sizeof("-9223372036854775808") - 1UL) + 1UL) + len) + 1UL);
  }
#line 767
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 768
    return ((ngx_int_t )-1);
  }
  {
#line 771
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 772
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 773
    return ((ngx_int_t )-1);
  }
  {
#line 776
  cl->buf = b;
#line 778
  b->last = ngx_sprintf(b->last, "%ui:CONTENT_LENGTH%Z%V%Z", len, & content_length);
  }
#line 781
  if (params->lengths) {
    {
#line 782
    memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 784
    e.ip = (u_char *)(params->values)->elts;
#line 785
    e.pos = b->last;
#line 786
    e.request = r;
#line 787
    e.flushed = 1U;
#line 789
    le.ip = (u_char *)(params->lengths)->elts;
    }
    {
#line 791
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 791
      if (! *((uintptr_t *)le.ip)) {
#line 791
        goto while_break___5;
      }
      {
#line 793
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 794
      (*lcode)(& le);
#line 796
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 797
      skip_empty = (*lcode)(& le);
#line 799
      val_len = (size_t )0;
      }
      {
#line 799
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 799
        if (! *((uintptr_t *)le.ip)) {
#line 799
          goto while_break___6;
        }
        {
#line 800
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 799
        tmp___6 = (*lcode)(& le);
#line 799
        val_len += tmp___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 802
      le.ip += sizeof(uintptr_t );
#line 804
      if (skip_empty) {
#line 804
        if (val_len == 0UL) {
#line 805
          e.skip = 1U;
          {
#line 807
          while (1) {
            while_continue___7: /* CIL Label */ ;
#line 807
            if (! *((uintptr_t *)e.ip)) {
#line 807
              goto while_break___7;
            }
            {
#line 808
            code = *((ngx_http_script_code_pt *)e.ip);
#line 809
            (*code)(& e);
            }
          }
          while_break___7: /* CIL Label */ ;
          }
#line 811
          e.ip += sizeof(uintptr_t );
#line 813
          e.skip = 0U;
#line 815
          goto while_continue___5;
        }
      }
      {
#line 821
      code = *((ngx_http_script_code_pt *)e.ip);
#line 822
      (*code)(& e);
      }
      {
#line 827
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 827
        if (! *((uintptr_t *)e.ip)) {
#line 827
          goto while_break___8;
        }
        {
#line 828
        code = *((ngx_http_script_code_pt *)e.ip);
#line 829
        (*code)(& e);
        }
      }
      while_break___8: /* CIL Label */ ;
      }
#line 831
      tmp___7 = e.pos;
#line 831
      (e.pos) ++;
#line 831
      *tmp___7 = (u_char )'\000';
#line 832
      e.ip += sizeof(uintptr_t );
    }
    while_break___5: /* CIL Label */ ;
    }
#line 838
    b->last = e.pos;
  }
#line 841
  if (scf->upstream.pass_request_headers) {
#line 843
    part = & r->headers_in.headers.part;
#line 844
    header___0 = (ngx_table_elt_t *)part->elts;
#line 846
    i = (ngx_uint_t )0;
    {
#line 846
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 848
      if (i >= part->nelts) {
#line 849
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 850
          goto while_break___9;
        }
#line 853
        part = part->next;
#line 854
        header___0 = (ngx_table_elt_t *)part->elts;
#line 855
        i = (ngx_uint_t )0;
      }
#line 858
      n = (ngx_uint_t )0;
      {
#line 858
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 858
        if (! (n < header_params)) {
#line 858
          goto while_break___10;
        }
#line 859
        if ((unsigned long )(header___0 + i) == (unsigned long )*(ignored + n)) {
#line 860
          goto next;
        }
#line 858
        n ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 864
      key = b->last;
#line 865
      tmp___8 = memcpy((void */* __restrict  */)key, (void const   */* __restrict  */)"HTTP_",
                       sizeof("HTTP_") - 1UL);
#line 865
      b->last = (u_char *)tmp___8 + (sizeof("HTTP_") - 1UL);
#line 867
      n = (ngx_uint_t )0;
      }
      {
#line 867
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 867
        if (! (n < (header___0 + i)->key.len)) {
#line 867
          goto while_break___11;
        }
#line 868
        ch = *((header___0 + i)->key.data + n);
#line 870
        if ((int )ch >= 97) {
#line 870
          if ((int )ch <= 122) {
#line 871
            ch = (u_char )((int )ch & -33);
          } else {
#line 870
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 873
        if ((int )ch == 45) {
#line 874
          ch = (u_char )'_';
        }
#line 877
        tmp___9 = b->last;
#line 877
        (b->last) ++;
#line 877
        *tmp___9 = ch;
#line 867
        n ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      {
#line 880
      tmp___10 = b->last;
#line 880
      (b->last) ++;
#line 880
      *tmp___10 = (u_char )0;
#line 882
      val = b->last;
#line 883
      tmp___11 = memcpy((void */* __restrict  */)val, (void const   */* __restrict  */)(header___0 + i)->value.data,
                        (header___0 + i)->value.len);
#line 883
      b->last = (u_char *)tmp___11 + (header___0 + i)->value.len;
#line 884
      tmp___12 = b->last;
#line 884
      (b->last) ++;
#line 884
      *tmp___12 = (u_char )0;
      }
      next: 
#line 891
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 846
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
#line 895
  tmp___13 = b->last;
#line 895
  (b->last) ++;
#line 895
  *tmp___13 = (u_char )',';
#line 897
  if (r->request_body_no_buffering) {
#line 898
    (r->upstream)->request_bufs = cl;
  } else
#line 900
  if (scf->upstream.pass_request_body) {
#line 901
    body = (r->upstream)->request_bufs;
#line 902
    (r->upstream)->request_bufs = cl;
    {
#line 904
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 904
      if (! body) {
#line 904
        goto while_break___12;
      }
      {
#line 905
      tmp___14 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 905
      b = (ngx_buf_t *)tmp___14;
      }
#line 906
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 907
        return ((ngx_int_t )-1);
      }
      {
#line 910
      memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)body->buf,
             sizeof(ngx_buf_t ));
#line 912
      cl->next = ngx_alloc_chain_link(r->pool);
      }
#line 913
      if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 914
        return ((ngx_int_t )-1);
      }
#line 917
      cl = cl->next;
#line 918
      cl->buf = b;
#line 920
      body = body->next;
    }
    while_break___12: /* CIL Label */ ;
    }
  } else {
#line 924
    (r->upstream)->request_bufs = cl;
  }
#line 927
  cl->next = (ngx_chain_t *)((void *)0);
#line 929
  return ((ngx_int_t )0);
}
}
#line 933 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_reinit_request(ngx_http_request_t *r ) 
{ 
  ngx_http_status_t *status ;

  {
#line 938
  status = (ngx_http_status_t *)*(r->ctx + ngx_http_scgi_module.ctx_index);
#line 940
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 941
    return ((ngx_int_t )0);
  }
#line 944
  status->code = (ngx_uint_t )0;
#line 945
  status->count = (ngx_uint_t )0;
#line 946
  status->start = (u_char *)((void *)0);
#line 947
  status->end = (u_char *)((void *)0);
#line 949
  (r->upstream)->process_header = & ngx_http_scgi_process_status_line;
#line 950
  r->state = (ngx_uint_t )0;
#line 952
  return ((ngx_int_t )0);
}
}
#line 956 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_process_status_line(ngx_http_request_t *r ) 
{ 
  size_t len ;
  ngx_int_t rc ;
  ngx_http_status_t *status ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 964
  status = (ngx_http_status_t *)*(r->ctx + ngx_http_scgi_module.ctx_index);
#line 966
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 967
    return ((ngx_int_t )-1);
  }
  {
#line 970
  u = r->upstream;
#line 972
  rc = ngx_http_parse_status_line(r, & u->buffer, status);
  }
#line 974
  if (rc == -2L) {
#line 975
    return (rc);
  }
#line 978
  if (rc == -1L) {
    {
#line 979
    u->process_header = & ngx_http_scgi_process_header;
#line 980
    tmp = ngx_http_scgi_process_header(r);
    }
#line 980
    return (tmp);
  }
#line 983
  if (u->state) {
#line 983
    if ((u->state)->status == 0UL) {
#line 984
      (u->state)->status = status->code;
    }
  }
  {
#line 987
  u->headers_in.status_n = status->code;
#line 989
  len = (size_t )(status->end - status->start);
#line 990
  u->headers_in.status_line.len = len;
#line 992
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 992
  u->headers_in.status_line.data = (u_char *)tmp___0;
  }
#line 993
  if ((unsigned long )u->headers_in.status_line.data == (unsigned long )((void *)0)) {
#line 994
    return ((ngx_int_t )-1);
  }
  {
#line 997
  memcpy((void */* __restrict  */)u->headers_in.status_line.data, (void const   */* __restrict  */)status->start,
         len);
#line 1003
  u->process_header = & ngx_http_scgi_process_header;
#line 1005
  tmp___1 = ngx_http_scgi_process_header(r);
  }
#line 1005
  return (tmp___1);
}
}
#line 1009 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_process_header(ngx_http_request_t *r ) 
{ 
  ngx_str_t *status_line ;
  ngx_int_t rc ;
  ngx_int_t status ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1019
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
  {
#line 1021
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1023
    rc = ngx_http_parse_header_line(r, & (r->upstream)->buffer, (ngx_uint_t )1);
    }
#line 1025
    if (rc == 0L) {
      {
#line 1029
      tmp = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1029
      h = (ngx_table_elt_t *)tmp;
      }
#line 1030
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1031
        return ((ngx_int_t )-1);
      }
      {
#line 1034
      h->hash = r->header_hash;
#line 1036
      h->key.len = (size_t )(r->header_name_end - r->header_name_start);
#line 1037
      h->value.len = (size_t )(r->header_end - r->header_start);
#line 1039
      tmp___0 = ngx_pnalloc(r->pool, (((h->key.len + 1UL) + h->value.len) + 1UL) + h->key.len);
#line 1039
      h->key.data = (u_char *)tmp___0;
      }
#line 1042
      if ((unsigned long )h->key.data == (unsigned long )((void *)0)) {
#line 1043
        h->hash = (ngx_uint_t )0;
#line 1044
        return ((ngx_int_t )-1);
      }
      {
#line 1047
      h->value.data = (h->key.data + h->key.len) + 1;
#line 1048
      h->lowcase_key = (((h->key.data + h->key.len) + 1) + h->value.len) + 1;
#line 1050
      memcpy((void */* __restrict  */)h->key.data, (void const   */* __restrict  */)r->header_name_start,
             h->key.len);
#line 1051
      *(h->key.data + h->key.len) = (u_char )'\000';
#line 1052
      memcpy((void */* __restrict  */)h->value.data, (void const   */* __restrict  */)r->header_start,
             h->value.len);
#line 1053
      *(h->value.data + h->value.len) = (u_char )'\000';
      }
#line 1055
      if (h->key.len == r->lowcase_index) {
        {
#line 1056
        memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
               h->key.len);
        }
      } else {
        {
#line 1059
        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
        }
      }
      {
#line 1062
      tmp___1 = ngx_hash_find(& umcf->headers_in_hash, h->hash, h->lowcase_key, h->key.len);
#line 1062
      hh = (ngx_http_upstream_header_t *)tmp___1;
      }
#line 1065
      if (hh) {
        {
#line 1065
        tmp___2 = (*(hh->handler))(r, h, hh->offset);
        }
#line 1065
        if (tmp___2 != 0L) {
#line 1066
          return ((ngx_int_t )-1);
        }
      }
#line 1072
      goto __Cont;
    }
#line 1075
    if (rc == 1L) {
#line 1082
      u = r->upstream;
#line 1084
      if (u->headers_in.status_n) {
#line 1085
        goto done;
      }
#line 1088
      if (u->headers_in.status) {
        {
#line 1089
        status_line = & (u->headers_in.status)->value;
#line 1091
        status = ngx_atoi(status_line->data, (size_t )3);
        }
#line 1092
        if (status == -1L) {
#line 1093
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 1093
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid status \"%V\"",
                               status_line);
            }
          }
#line 1096
          return ((ngx_int_t )40);
        }
#line 1099
        u->headers_in.status_n = (ngx_uint_t )status;
#line 1100
        u->headers_in.status_line = *status_line;
      } else
#line 1102
      if (u->headers_in.location) {
#line 1103
        u->headers_in.status_n = (ngx_uint_t )302;
#line 1104
        u->headers_in.status_line.len = sizeof("302 Moved Temporarily") - 1UL;
#line 1104
        u->headers_in.status_line.data = (u_char *)"302 Moved Temporarily";
      } else {
#line 1108
        u->headers_in.status_n = (ngx_uint_t )200;
#line 1109
        u->headers_in.status_line.len = sizeof("200 OK") - 1UL;
#line 1109
        u->headers_in.status_line.data = (u_char *)"200 OK";
      }
#line 1112
      if (u->state) {
#line 1112
        if ((u->state)->status == 0UL) {
#line 1113
          (u->state)->status = u->headers_in.status_n;
        }
      }
      done: 
#line 1118
      if (u->headers_in.status_n == 101UL) {
#line 1118
        if (r->headers_in.upgrade) {
#line 1121
          u->upgrade = 1U;
        }
      }
#line 1124
      return ((ngx_int_t )0);
    }
#line 1127
    if (rc == -2L) {
#line 1128
      return ((ngx_int_t )-2);
    }
#line 1133
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1133
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid header");
      }
    }
#line 1136
    return ((ngx_int_t )40);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1141 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static void ngx_http_scgi_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 1147
  return;
}
}
#line 1151 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static void ngx_http_scgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 1157
  return;
}
}
#line 1161 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static void *ngx_http_scgi_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_scgi_main_conf_t *conf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1166
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_scgi_main_conf_t ));
#line 1166
  conf = (ngx_http_scgi_main_conf_t *)tmp;
  }
#line 1167
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1168
    return ((void *)0);
  }
  {
#line 1172
  tmp___0 = ngx_array_init(& conf->caches, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_file_cache_t *));
  }
#line 1172
  if (tmp___0 != 0L) {
#line 1176
    return ((void *)0);
  }
#line 1180
  return ((void *)conf);
}
}
#line 1184 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static void *ngx_http_scgi_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_scgi_loc_conf_t *conf ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1189
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_scgi_loc_conf_t ));
#line 1189
  conf = (ngx_http_scgi_loc_conf_t *)tmp;
  }
#line 1190
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1191
    return ((void *)0);
  }
#line 1194
  conf->upstream.store = -1;
#line 1195
  conf->upstream.store_access = (ngx_uint_t )-1;
#line 1196
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 1197
  conf->upstream.buffering = (ngx_flag_t )-1;
#line 1198
  conf->upstream.request_buffering = (ngx_flag_t )-1;
#line 1199
  conf->upstream.ignore_client_abort = (ngx_flag_t )-1;
#line 1200
  conf->upstream.force_ranges = (ngx_flag_t )-1;
#line 1202
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 1204
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 1205
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 1206
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 1207
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 1209
  conf->upstream.send_lowat = (size_t )-1;
#line 1210
  conf->upstream.buffer_size = (size_t )-1;
#line 1211
  conf->upstream.limit_rate = (size_t )-1;
#line 1213
  conf->upstream.busy_buffers_size_conf = (size_t )-1;
#line 1214
  conf->upstream.max_temp_file_size_conf = (size_t )-1;
#line 1215
  conf->upstream.temp_file_write_size_conf = (size_t )-1;
#line 1217
  conf->upstream.pass_request_headers = (ngx_flag_t )-1;
#line 1218
  conf->upstream.pass_request_body = (ngx_flag_t )-1;
#line 1221
  conf->upstream.cache = -1;
#line 1222
  conf->upstream.cache_min_uses = (ngx_uint_t )-1;
#line 1223
  conf->upstream.cache_max_range_offset = (off_t )-1;
#line 1224
  conf->upstream.cache_bypass = (ngx_array_t *)((void *)-1);
#line 1225
  conf->upstream.no_cache = (ngx_array_t *)((void *)-1);
#line 1226
  conf->upstream.cache_valid = (ngx_array_t *)((void *)-1);
#line 1227
  conf->upstream.cache_lock = (ngx_flag_t )-1;
#line 1228
  conf->upstream.cache_lock_timeout = (ngx_msec_t )-1;
#line 1229
  conf->upstream.cache_lock_age = (ngx_msec_t )-1;
#line 1230
  conf->upstream.cache_revalidate = (ngx_flag_t )-1;
#line 1231
  conf->upstream.cache_background_update = (ngx_flag_t )-1;
#line 1234
  conf->upstream.hide_headers = (ngx_array_t *)((void *)-1);
#line 1235
  conf->upstream.pass_headers = (ngx_array_t *)((void *)-1);
#line 1237
  conf->upstream.intercept_errors = (ngx_flag_t )-1;
#line 1240
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 1242
  conf->upstream.change_buffering = 1U;
#line 1244
  conf->upstream.module.len = sizeof("scgi") - 1UL;
#line 1244
  conf->upstream.module.data = (u_char *)"scgi";
#line 1246
  return ((void *)conf);
}
}
#line 1250 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_scgi_loc_conf_t *prev ;
  ngx_http_scgi_loc_conf_t *conf ;
  size_t size ;
  ngx_int_t rc ;
  ngx_hash_init_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  char *tmp ;
  ngx_shm_zone_t *shm_zone ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1253
  prev = (ngx_http_scgi_loc_conf_t *)parent;
#line 1254
  conf = (ngx_http_scgi_loc_conf_t *)child;
#line 1263
  if (conf->upstream.store > 0) {
#line 1264
    conf->upstream.cache = 0;
  }
#line 1267
  if (conf->upstream.cache > 0) {
#line 1268
    conf->upstream.store = 0;
  }
#line 1273
  if (conf->upstream.store == -1) {
#line 1274
    if (conf->upstream.store == -1) {
#line 1274
      if (prev->upstream.store == -1) {
#line 1274
        conf->upstream.store = 0;
      } else {
#line 1274
        conf->upstream.store = prev->upstream.store;
      }
    }
#line 1276
    conf->upstream.store_lengths = prev->upstream.store_lengths;
#line 1277
    conf->upstream.store_values = prev->upstream.store_values;
  }
#line 1280
  if (conf->upstream.store_access == 0xffffffffffffffffUL) {
#line 1280
    if (prev->upstream.store_access == 0xffffffffffffffffUL) {
#line 1280
      conf->upstream.store_access = (ngx_uint_t )384;
    } else {
#line 1280
      conf->upstream.store_access = prev->upstream.store_access;
    }
  }
#line 1283
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 1283
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 1283
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 1283
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 1286
  if (conf->upstream.buffering == -1L) {
#line 1286
    if (prev->upstream.buffering == -1L) {
#line 1286
      conf->upstream.buffering = (ngx_flag_t )1;
    } else {
#line 1286
      conf->upstream.buffering = prev->upstream.buffering;
    }
  }
#line 1289
  if (conf->upstream.request_buffering == -1L) {
#line 1289
    if (prev->upstream.request_buffering == -1L) {
#line 1289
      conf->upstream.request_buffering = (ngx_flag_t )1;
    } else {
#line 1289
      conf->upstream.request_buffering = prev->upstream.request_buffering;
    }
  }
#line 1292
  if (conf->upstream.ignore_client_abort == -1L) {
#line 1292
    if (prev->upstream.ignore_client_abort == -1L) {
#line 1292
      conf->upstream.ignore_client_abort = (ngx_flag_t )0;
    } else {
#line 1292
      conf->upstream.ignore_client_abort = prev->upstream.ignore_client_abort;
    }
  }
#line 1295
  if (conf->upstream.force_ranges == -1L) {
#line 1295
    if (prev->upstream.force_ranges == -1L) {
#line 1295
      conf->upstream.force_ranges = (ngx_flag_t )0;
    } else {
#line 1295
      conf->upstream.force_ranges = prev->upstream.force_ranges;
    }
  }
#line 1298
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 1298
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 1298
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 1298
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 1301
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 1301
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 1301
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 1301
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 1304
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 1304
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 1304
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 1304
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 1307
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 1307
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 1307
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 1307
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 1310
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 1310
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 1310
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 1310
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 1313
  if (conf->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 1313
    if (prev->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 1313
      conf->upstream.send_lowat = (size_t )0;
    } else {
#line 1313
      conf->upstream.send_lowat = prev->upstream.send_lowat;
    }
  }
#line 1316
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 1316
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 1316
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 1316
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 1320
  if (conf->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 1320
    if (prev->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 1320
      conf->upstream.limit_rate = (size_t )0;
    } else {
#line 1320
      conf->upstream.limit_rate = prev->upstream.limit_rate;
    }
  }
#line 1324
  if (conf->upstream.bufs.num == 0L) {
#line 1324
    if (prev->upstream.bufs.num) {
#line 1324
      conf->upstream.bufs.num = prev->upstream.bufs.num;
#line 1324
      conf->upstream.bufs.size = prev->upstream.bufs.size;
    } else {
#line 1324
      conf->upstream.bufs.num = (ngx_int_t )8;
#line 1324
      conf->upstream.bufs.size = ngx_pagesize;
    }
  }
#line 1327
  if (conf->upstream.bufs.num < 2L) {
    {
#line 1328
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "there must be at least 2 \"scgi_buffers\"");
    }
#line 1330
    return ((char *)((void *)-1));
  }
#line 1334
  size = conf->upstream.buffer_size;
#line 1335
  if (size < conf->upstream.bufs.size) {
#line 1336
    size = conf->upstream.bufs.size;
  }
#line 1340
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1340
    if (prev->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1340
      conf->upstream.busy_buffers_size_conf = (size_t )-1;
    } else {
#line 1340
      conf->upstream.busy_buffers_size_conf = prev->upstream.busy_buffers_size_conf;
    }
  }
#line 1344
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1345
    conf->upstream.busy_buffers_size = 2UL * size;
  } else {
#line 1347
    conf->upstream.busy_buffers_size = conf->upstream.busy_buffers_size_conf;
  }
#line 1351
  if (conf->upstream.busy_buffers_size < size) {
    {
#line 1352
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_busy_buffers_size\" must be equal to or greater than the maximum of the value of \"scgi_buffer_size\" and one of the \"scgi_buffers\"");
    }
#line 1357
    return ((char *)((void *)-1));
  }
#line 1360
  if (conf->upstream.busy_buffers_size > (size_t )(conf->upstream.bufs.num - 1L) * conf->upstream.bufs.size) {
    {
#line 1363
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_busy_buffers_size\" must be less than the size of all \"scgi_buffers\" minus one buffer");
    }
#line 1367
    return ((char *)((void *)-1));
  }
#line 1371
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1371
    if (prev->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1371
      conf->upstream.temp_file_write_size_conf = (size_t )-1;
    } else {
#line 1371
      conf->upstream.temp_file_write_size_conf = prev->upstream.temp_file_write_size_conf;
    }
  }
#line 1375
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1376
    conf->upstream.temp_file_write_size = 2UL * size;
  } else {
#line 1378
    conf->upstream.temp_file_write_size = conf->upstream.temp_file_write_size_conf;
  }
#line 1382
  if (conf->upstream.temp_file_write_size < size) {
    {
#line 1383
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_temp_file_write_size\" must be equal to or greater than the maximum of the value of \"scgi_buffer_size\" and one of the \"scgi_buffers\"");
    }
#line 1388
    return ((char *)((void *)-1));
  }
#line 1392
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1392
    if (prev->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1392
      conf->upstream.max_temp_file_size_conf = (size_t )-1;
    } else {
#line 1392
      conf->upstream.max_temp_file_size_conf = prev->upstream.max_temp_file_size_conf;
    }
  }
#line 1396
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1397
    conf->upstream.max_temp_file_size = (size_t )1073741824;
  } else {
#line 1399
    conf->upstream.max_temp_file_size = conf->upstream.max_temp_file_size_conf;
  }
#line 1403
  if (conf->upstream.max_temp_file_size != 0UL) {
#line 1403
    if (conf->upstream.max_temp_file_size < size) {
      {
#line 1406
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_max_temp_file_size\" must be equal to zero to disable temporary files usage or must be equal to or greater than the maximum of the value of \"scgi_buffer_size\" and one of the \"scgi_buffers\"");
      }
#line 1412
      return ((char *)((void *)-1));
    }
  }
#line 1416
  if (conf->upstream.ignore_headers == 0UL) {
#line 1416
    if (prev->upstream.ignore_headers == 0UL) {
#line 1416
      conf->upstream.ignore_headers = (ngx_uint_t )1;
    } else {
#line 1416
      conf->upstream.ignore_headers = prev->upstream.ignore_headers;
    }
  }
#line 1421
  if (conf->upstream.next_upstream == 0UL) {
#line 1421
    if (prev->upstream.next_upstream == 0UL) {
#line 1421
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 1421
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 1427
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 1428
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
  {
#line 1432
  tmp = ngx_conf_merge_path_value(cf, & conf->upstream.temp_path, prev->upstream.temp_path,
                                  & ngx_http_scgi_temp_path);
  }
#line 1432
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1437
    return ((char *)((void *)-1));
  }
#line 1442
  if (conf->upstream.cache == -1) {
#line 1443
    if (conf->upstream.cache == -1) {
#line 1443
      if (prev->upstream.cache == -1) {
#line 1443
        conf->upstream.cache = 0;
      } else {
#line 1443
        conf->upstream.cache = prev->upstream.cache;
      }
    }
#line 1446
    conf->upstream.cache_zone = prev->upstream.cache_zone;
#line 1447
    conf->upstream.cache_value = prev->upstream.cache_value;
  }
#line 1450
  if (conf->upstream.cache_zone) {
#line 1450
    if ((unsigned long )(conf->upstream.cache_zone)->data == (unsigned long )((void *)0)) {
      {
#line 1453
      shm_zone = conf->upstream.cache_zone;
#line 1455
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"scgi_cache\" zone \"%V\" is unknown",
                         & shm_zone->shm.name);
      }
#line 1459
      return ((char *)((void *)-1));
    }
  }
#line 1462
  if (conf->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 1462
    if (prev->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 1462
      conf->upstream.cache_min_uses = (ngx_uint_t )1;
    } else {
#line 1462
      conf->upstream.cache_min_uses = prev->upstream.cache_min_uses;
    }
  }
#line 1465
  if (conf->upstream.cache_max_range_offset == -1L) {
#line 1465
    if (prev->upstream.cache_max_range_offset == -1L) {
#line 1465
      conf->upstream.cache_max_range_offset = (off_t )9223372036854775807LL;
    } else {
#line 1465
      conf->upstream.cache_max_range_offset = prev->upstream.cache_max_range_offset;
    }
  }
#line 1469
  if (conf->upstream.cache_use_stale == 0UL) {
#line 1469
    if (prev->upstream.cache_use_stale == 0UL) {
#line 1469
      conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
    } else {
#line 1469
      conf->upstream.cache_use_stale = prev->upstream.cache_use_stale;
    }
  }
#line 1474
  if (conf->upstream.cache_use_stale & 2147483648UL) {
#line 1475
    conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
  }
#line 1479
  if (conf->upstream.cache_use_stale & 2UL) {
#line 1480
    conf->upstream.cache_use_stale |= 1073741824UL;
  }
#line 1483
  if (conf->upstream.cache_methods == 0UL) {
#line 1484
    conf->upstream.cache_methods = prev->upstream.cache_methods;
  }
#line 1487
  conf->upstream.cache_methods |= 6UL;
#line 1489
  if ((unsigned long )conf->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 1489
    if ((unsigned long )prev->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 1489
      conf->upstream.cache_bypass = (ngx_array_t *)((void *)0);
    } else {
#line 1489
      conf->upstream.cache_bypass = prev->upstream.cache_bypass;
    }
  }
#line 1492
  if ((unsigned long )conf->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 1492
    if ((unsigned long )prev->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 1492
      conf->upstream.no_cache = (ngx_array_t *)((void *)0);
    } else {
#line 1492
      conf->upstream.no_cache = prev->upstream.no_cache;
    }
  }
#line 1495
  if ((unsigned long )conf->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 1495
    if ((unsigned long )prev->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 1495
      conf->upstream.cache_valid = (ngx_array_t *)((void *)0);
    } else {
#line 1495
      conf->upstream.cache_valid = prev->upstream.cache_valid;
    }
  }
#line 1498
  if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
#line 1499
    conf->cache_key = prev->cache_key;
  }
#line 1502
  if (conf->upstream.cache) {
#line 1502
    if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
      {
#line 1503
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no \"scgi_cache_key\" for \"scgi_cache\"");
      }
    }
  }
#line 1507
  if (conf->upstream.cache_lock == -1L) {
#line 1507
    if (prev->upstream.cache_lock == -1L) {
#line 1507
      conf->upstream.cache_lock = (ngx_flag_t )0;
    } else {
#line 1507
      conf->upstream.cache_lock = prev->upstream.cache_lock;
    }
  }
#line 1510
  if (conf->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 1510
    if (prev->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 1510
      conf->upstream.cache_lock_timeout = (ngx_msec_t )5000;
    } else {
#line 1510
      conf->upstream.cache_lock_timeout = prev->upstream.cache_lock_timeout;
    }
  }
#line 1513
  if (conf->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 1513
    if (prev->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 1513
      conf->upstream.cache_lock_age = (ngx_msec_t )5000;
    } else {
#line 1513
      conf->upstream.cache_lock_age = prev->upstream.cache_lock_age;
    }
  }
#line 1516
  if (conf->upstream.cache_revalidate == -1L) {
#line 1516
    if (prev->upstream.cache_revalidate == -1L) {
#line 1516
      conf->upstream.cache_revalidate = (ngx_flag_t )0;
    } else {
#line 1516
      conf->upstream.cache_revalidate = prev->upstream.cache_revalidate;
    }
  }
#line 1519
  if (conf->upstream.cache_background_update == -1L) {
#line 1519
    if (prev->upstream.cache_background_update == -1L) {
#line 1519
      conf->upstream.cache_background_update = (ngx_flag_t )0;
    } else {
#line 1519
      conf->upstream.cache_background_update = prev->upstream.cache_background_update;
    }
  }
#line 1524
  if (conf->upstream.pass_request_headers == -1L) {
#line 1524
    if (prev->upstream.pass_request_headers == -1L) {
#line 1524
      conf->upstream.pass_request_headers = (ngx_flag_t )1;
    } else {
#line 1524
      conf->upstream.pass_request_headers = prev->upstream.pass_request_headers;
    }
  }
#line 1526
  if (conf->upstream.pass_request_body == -1L) {
#line 1526
    if (prev->upstream.pass_request_body == -1L) {
#line 1526
      conf->upstream.pass_request_body = (ngx_flag_t )1;
    } else {
#line 1526
      conf->upstream.pass_request_body = prev->upstream.pass_request_body;
    }
  }
#line 1529
  if (conf->upstream.intercept_errors == -1L) {
#line 1529
    if (prev->upstream.intercept_errors == -1L) {
#line 1529
      conf->upstream.intercept_errors = (ngx_flag_t )0;
    } else {
#line 1529
      conf->upstream.intercept_errors = prev->upstream.intercept_errors;
    }
  }
  {
#line 1532
  hash.max_size = (ngx_uint_t )512;
#line 1533
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 1534
  hash.name = (char *)"scgi_hide_headers_hash";
#line 1536
  tmp___0 = ngx_http_upstream_hide_headers_hash(cf, & conf->upstream, & prev->upstream,
                                                ngx_http_scgi_hide_headers, & hash);
  }
#line 1536
  if (tmp___0 != 0L) {
#line 1540
    return ((char *)((void *)-1));
  }
#line 1543
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 1545
  if (clcf->noname) {
#line 1545
    if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 1545
      if ((unsigned long )conf->scgi_lengths == (unsigned long )((void *)0)) {
#line 1548
        conf->upstream.upstream = prev->upstream.upstream;
#line 1549
        conf->scgi_lengths = prev->scgi_lengths;
#line 1550
        conf->scgi_values = prev->scgi_values;
      }
    }
  }
#line 1553
  if (clcf->lmt_excpt) {
#line 1553
    if ((unsigned long )clcf->handler == (unsigned long )((void *)0)) {
#line 1553
      if (conf->upstream.upstream) {
#line 1556
        clcf->handler = & ngx_http_scgi_handler;
      } else
#line 1553
      if (conf->scgi_lengths) {
#line 1556
        clcf->handler = & ngx_http_scgi_handler;
      }
    }
  }
#line 1559
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 1560
    conf->params = prev->params;
#line 1562
    conf->params_cache = prev->params_cache;
#line 1564
    conf->params_source = prev->params_source;
  }
  {
#line 1567
  rc = ngx_http_scgi_init_params(cf, conf, & conf->params, (ngx_keyval_t *)((void *)0));
  }
#line 1568
  if (rc != 0L) {
#line 1569
    return ((char *)((void *)-1));
  }
#line 1574
  if (conf->upstream.cache) {
    {
#line 1575
    rc = ngx_http_scgi_init_params(cf, conf, & conf->params_cache, ngx_http_scgi_cache_headers);
    }
#line 1577
    if (rc != 0L) {
#line 1578
      return ((char *)((void *)-1));
    }
  }
#line 1589
  if ((unsigned long )prev->params.hash.buckets == (unsigned long )((void *)0)) {
#line 1589
    if ((unsigned long )conf->params_source == (unsigned long )prev->params_source) {
#line 1592
      prev->params = conf->params;
#line 1594
      prev->params_cache = conf->params_cache;
    }
  }
#line 1598
  return ((char *)((void *)0));
}
}
#line 1602 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static ngx_int_t ngx_http_scgi_init_params(ngx_conf_t *cf , ngx_http_scgi_loc_conf_t *conf ,
                                           ngx_http_scgi_params_t *params , ngx_keyval_t *default_params ) 
{ 
  u_char *p ;
  size_t size ;
  uintptr_t *code ;
  ngx_uint_t i ;
  ngx_uint_t nsrc ;
  ngx_array_t headers_names ;
  ngx_array_t params_merged ;
  ngx_keyval_t *h ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_upstream_param_t *src ;
  ngx_http_upstream_param_t *s ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_copy_code_t *copy ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  ngx_int_t tmp___13 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 1618
  if (params->hash.buckets) {
#line 1619
    return ((ngx_int_t )0);
  }
#line 1622
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 1622
    if ((unsigned long )default_params == (unsigned long )((void *)0)) {
#line 1623
      params->hash.buckets = (ngx_hash_elt_t **)((void *)1);
#line 1624
      return ((ngx_int_t )0);
    }
  }
  {
#line 1627
  params->lengths = ngx_array_create(cf->pool, (ngx_uint_t )64, (size_t )1);
  }
#line 1628
  if ((unsigned long )params->lengths == (unsigned long )((void *)0)) {
#line 1629
    return ((ngx_int_t )-1);
  }
  {
#line 1632
  params->values = ngx_array_create(cf->pool, (ngx_uint_t )512, (size_t )1);
  }
#line 1633
  if ((unsigned long )params->values == (unsigned long )((void *)0)) {
#line 1634
    return ((ngx_int_t )-1);
  }
  {
#line 1637
  tmp = ngx_array_init(& headers_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 1637
  if (tmp != 0L) {
#line 1640
    return ((ngx_int_t )-1);
  }
#line 1643
  if (conf->params_source) {
#line 1644
    src = (ngx_http_upstream_param_t *)(conf->params_source)->elts;
#line 1645
    nsrc = (conf->params_source)->nelts;
  } else {
#line 1648
    src = (ngx_http_upstream_param_t *)((void *)0);
#line 1649
    nsrc = (ngx_uint_t )0;
  }
#line 1652
  if (default_params) {
    {
#line 1653
    tmp___0 = ngx_array_init(& params_merged, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_param_t ));
    }
#line 1653
    if (tmp___0 != 0L) {
#line 1657
      return ((ngx_int_t )-1);
    }
#line 1660
    i = (ngx_uint_t )0;
    {
#line 1660
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1660
      if (! (i < nsrc)) {
#line 1660
        goto while_break;
      }
      {
#line 1662
      tmp___1 = ngx_array_push(& params_merged);
#line 1662
      s = (ngx_http_upstream_param_t *)tmp___1;
      }
#line 1663
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1664
        return ((ngx_int_t )-1);
      }
#line 1667
      *s = *(src + i);
#line 1660
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1670
    h = default_params;
    {
#line 1672
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1672
      if (! h->key.len) {
#line 1672
        goto while_break___0;
      }
#line 1674
      src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 1675
      nsrc = params_merged.nelts;
#line 1677
      i = (ngx_uint_t )0;
      {
#line 1677
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1677
        if (! (i < nsrc)) {
#line 1677
          goto while_break___1;
        }
        {
#line 1678
        tmp___2 = ngx_strcasecmp(h->key.data, (src + i)->key.data);
        }
#line 1678
        if (tmp___2 == 0L) {
#line 1679
          goto next;
        }
#line 1677
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1683
      tmp___3 = ngx_array_push(& params_merged);
#line 1683
      s = (ngx_http_upstream_param_t *)tmp___3;
      }
#line 1684
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1685
        return ((ngx_int_t )-1);
      }
#line 1688
      s->key = h->key;
#line 1689
      s->value = h->value;
#line 1690
      s->skip_empty = (ngx_uint_t )1;
      next: 
#line 1694
      h ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1697
    src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 1698
    nsrc = params_merged.nelts;
  }
#line 1701
  i = (ngx_uint_t )0;
  {
#line 1701
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1701
    if (! (i < nsrc)) {
#line 1701
      goto while_break___2;
    }
#line 1703
    if ((src + i)->key.len > sizeof("HTTP_") - 1UL) {
      {
#line 1703
      tmp___5 = strncmp((char const   *)(src + i)->key.data, "HTTP_", sizeof("HTTP_") - 1UL);
      }
#line 1703
      if (tmp___5 == 0) {
        {
#line 1706
        tmp___4 = ngx_array_push(& headers_names);
#line 1706
        hk = (ngx_hash_key_t *)tmp___4;
        }
#line 1707
        if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 1708
          return ((ngx_int_t )-1);
        }
        {
#line 1711
        hk->key.len = (src + i)->key.len - 5UL;
#line 1712
        hk->key.data = (src + i)->key.data + 5;
#line 1713
        hk->key_hash = ngx_hash_key_lc(hk->key.data, hk->key.len);
#line 1714
        hk->value = (void *)1;
        }
#line 1716
        if ((src + i)->value.len == 0UL) {
#line 1717
          goto __Cont;
        }
      }
    }
    {
#line 1721
    tmp___6 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 1721
    copy = (ngx_http_script_copy_code_t *)tmp___6;
    }
#line 1723
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1724
      return ((ngx_int_t )-1);
    }
    {
#line 1727
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 1728
    copy->len = (src + i)->key.len + 1UL;
#line 1730
    tmp___7 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 1730
    copy = (ngx_http_script_copy_code_t *)tmp___7;
    }
#line 1732
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1733
      return ((ngx_int_t )-1);
    }
    {
#line 1736
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 1737
    copy->len = (src + i)->skip_empty;
#line 1740
    size = ((((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + 1UL) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 1744
    tmp___8 = ngx_array_push_n(params->values, size);
#line 1744
    copy = (ngx_http_script_copy_code_t *)tmp___8;
    }
#line 1745
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1746
      return ((ngx_int_t )-1);
    }
    {
#line 1749
    copy->code = & ngx_http_script_copy_code;
#line 1750
    copy->len = (src + i)->key.len + 1UL;
#line 1752
    p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 1753
    ngx_cpystrn(p, (src + i)->key.data, (src + i)->key.len + 1UL);
#line 1756
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1758
    sc.cf = cf;
#line 1759
    sc.source = & (src + i)->value;
#line 1760
    sc.flushes = & params->flushes;
#line 1761
    sc.lengths = & params->lengths;
#line 1762
    sc.values = & params->values;
#line 1764
    tmp___9 = ngx_http_script_compile(& sc);
    }
#line 1764
    if (tmp___9 != 0L) {
#line 1765
      return ((ngx_int_t )-1);
    }
    {
#line 1768
    tmp___10 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 1768
    code = (uintptr_t *)tmp___10;
    }
#line 1769
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1770
      return ((ngx_int_t )-1);
    }
    {
#line 1773
    *code = (uintptr_t )((void *)0);
#line 1776
    tmp___11 = ngx_array_push_n(params->values, sizeof(uintptr_t ));
#line 1776
    code = (uintptr_t *)tmp___11;
    }
#line 1777
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1778
      return ((ngx_int_t )-1);
    }
#line 1781
    *code = (uintptr_t )((void *)0);
    __Cont: /* CIL Label */ 
#line 1701
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1784
  tmp___12 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 1784
  code = (uintptr_t *)tmp___12;
  }
#line 1785
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1786
    return ((ngx_int_t )-1);
  }
  {
#line 1789
  *code = (uintptr_t )((void *)0);
#line 1791
  params->number = headers_names.nelts;
#line 1793
  hash.hash = & params->hash;
#line 1794
  hash.key = & ngx_hash_key_lc;
#line 1795
  hash.max_size = (ngx_uint_t )512;
#line 1796
  hash.bucket_size = (ngx_uint_t )64;
#line 1797
  hash.name = (char *)"scgi_params_hash";
#line 1798
  hash.pool = cf->pool;
#line 1799
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 1801
  tmp___13 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_names.elts, headers_names.nelts);
  }
#line 1801
  return (tmp___13);
}
}
#line 1805 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_url_t u ;
  ngx_str_t *value ;
  ngx_str_t *url ;
  ngx_uint_t n ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1808
  scf = (ngx_http_scgi_loc_conf_t *)conf;
#line 1816
  if (scf->upstream.upstream) {
#line 1817
    return ((char *)"is duplicate");
  } else
#line 1816
  if (scf->scgi_lengths) {
#line 1817
    return ((char *)"is duplicate");
  }
  {
#line 1820
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 1821
  clcf->handler = & ngx_http_scgi_handler;
#line 1823
  value = (ngx_str_t *)(cf->args)->elts;
#line 1825
  url = value + 1;
#line 1827
  n = ngx_http_script_variables_count(url);
  }
#line 1829
  if (n) {
    {
#line 1831
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1833
    sc.cf = cf;
#line 1834
    sc.source = url;
#line 1835
    sc.lengths = & scf->scgi_lengths;
#line 1836
    sc.values = & scf->scgi_values;
#line 1837
    sc.variables = n;
#line 1838
    sc.complete_lengths = 1U;
#line 1839
    sc.complete_values = 1U;
#line 1841
    tmp = ngx_http_script_compile(& sc);
    }
#line 1841
    if (tmp != 0L) {
#line 1842
      return ((char *)((void *)-1));
    }
#line 1845
    return ((char *)((void *)0));
  }
  {
#line 1848
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 1850
  u.url = *(value + 1);
#line 1851
  u.no_resolve = 1U;
#line 1853
  scf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 1854
  if ((unsigned long )scf->upstream.upstream == (unsigned long )((void *)0)) {
#line 1855
    return ((char *)((void *)-1));
  }
#line 1858
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 1859
    clcf->auto_redirect = 1U;
  }
#line 1862
  return ((char *)((void *)0));
}
}
#line 1866 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_str_t *value ;
  ngx_http_script_compile_t sc ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1869
  scf = (ngx_http_scgi_loc_conf_t *)conf;
#line 1874
  if (scf->upstream.store != -1) {
#line 1875
    return ((char *)"is duplicate");
  }
  {
#line 1878
  value = (ngx_str_t *)(cf->args)->elts;
#line 1880
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 1880
  if (tmp == 0) {
#line 1881
    scf->upstream.store = 0;
#line 1882
    return ((char *)((void *)0));
  }
#line 1886
  if (scf->upstream.cache > 0) {
#line 1887
    return ((char *)"is incompatible with \"scgi_cache\"");
  }
  {
#line 1891
  scf->upstream.store = 1;
#line 1893
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 1893
  if (tmp___0 == 0) {
#line 1894
    return ((char *)((void *)0));
  }
  {
#line 1898
  ((value + 1)->len) ++;
#line 1900
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1902
  sc.cf = cf;
#line 1903
  sc.source = value + 1;
#line 1904
  sc.lengths = & scf->upstream.store_lengths;
#line 1905
  sc.values = & scf->upstream.store_values;
#line 1906
  sc.variables = ngx_http_script_variables_count(value + 1);
#line 1907
  sc.complete_lengths = 1U;
#line 1908
  sc.complete_values = 1U;
#line 1910
  tmp___1 = ngx_http_script_compile(& sc);
  }
#line 1910
  if (tmp___1 != 0L) {
#line 1911
    return ((char *)((void *)-1));
  }
#line 1914
  return ((char *)((void *)0));
}
}
#line 1920 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1923
  scf = (ngx_http_scgi_loc_conf_t *)conf;
#line 1929
  value = (ngx_str_t *)(cf->args)->elts;
#line 1931
  if (scf->upstream.cache != -1) {
#line 1932
    return ((char *)"is duplicate");
  }
  {
#line 1935
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 1935
  if (tmp == 0) {
#line 1936
    scf->upstream.cache = 0;
#line 1937
    return ((char *)((void *)0));
  }
#line 1940
  if (scf->upstream.store > 0) {
#line 1941
    return ((char *)"is incompatible with \"scgi_store\"");
  }
  {
#line 1944
  scf->upstream.cache = 1;
#line 1946
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 1948
  ccv.cf = cf;
#line 1949
  ccv.value = value + 1;
#line 1950
  ccv.complex_value = & cv;
#line 1952
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 1952
  if (tmp___0 != 0L) {
#line 1953
    return ((char *)((void *)-1));
  }
#line 1956
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 1958
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 1958
    scf->upstream.cache_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 1960
    if ((unsigned long )scf->upstream.cache_value == (unsigned long )((void *)0)) {
#line 1961
      return ((char *)((void *)-1));
    }
#line 1964
    *(scf->upstream.cache_value) = cv;
#line 1966
    return ((char *)((void *)0));
  }
  {
#line 1969
  scf->upstream.cache_zone = ngx_shared_memory_add(cf, value + 1, (size_t )0, (void *)(& ngx_http_scgi_module));
  }
#line 1971
  if ((unsigned long )scf->upstream.cache_zone == (unsigned long )((void *)0)) {
#line 1972
    return ((char *)((void *)-1));
  }
#line 1975
  return ((char *)((void *)0));
}
}
#line 1979 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_scgi_module.c"
static char *ngx_http_scgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_scgi_loc_conf_t *scf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;

  {
#line 1982
  scf = (ngx_http_scgi_loc_conf_t *)conf;
#line 1987
  value = (ngx_str_t *)(cf->args)->elts;
#line 1989
  if (scf->cache_key.value.data) {
#line 1990
    return ((char *)"is duplicate");
  }
  {
#line 1993
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 1995
  ccv.cf = cf;
#line 1996
  ccv.value = value + 1;
#line 1997
  ccv.complex_value = & scf->cache_key;
#line 1999
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 1999
  if (tmp != 0L) {
#line 2000
    return ((char *)((void *)-1));
  }
#line 2003
  return ((char *)((void *)0));
}
}
#line 173 "src/core/ngx_conf_file.h"
char *ngx_conf_check_num_bounds(ngx_conf_t *cf , void *post , void *data ) ;
#line 281
char *ngx_conf_set_str_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 64 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_eval(ngx_http_request_t *r , ngx_http_uwsgi_loc_conf_t *uwcf ) ;
#line 66
static ngx_int_t ngx_http_uwsgi_create_request(ngx_http_request_t *r ) ;
#line 67
static ngx_int_t ngx_http_uwsgi_reinit_request(ngx_http_request_t *r ) ;
#line 68
static ngx_int_t ngx_http_uwsgi_process_status_line(ngx_http_request_t *r ) ;
#line 69
static ngx_int_t ngx_http_uwsgi_process_header(ngx_http_request_t *r ) ;
#line 70
static void ngx_http_uwsgi_abort_request(ngx_http_request_t *r ) ;
#line 71
static void ngx_http_uwsgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 74
static void *ngx_http_uwsgi_create_main_conf(ngx_conf_t *cf ) ;
#line 75
static void *ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf ) ;
#line 76
static char *ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 78
static ngx_int_t ngx_http_uwsgi_init_params(ngx_conf_t *cf , ngx_http_uwsgi_loc_conf_t *conf ,
                                            ngx_http_uwsgi_params_t *params , ngx_keyval_t *default_params ) ;
#line 82
static char *ngx_http_uwsgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 84
static char *ngx_http_uwsgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 88
static ngx_int_t ngx_http_uwsgi_create_key(ngx_http_request_t *r ) ;
#line 89
static char *ngx_http_uwsgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 91
static char *ngx_http_uwsgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 103 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_conf_num_bounds_t ngx_http_uwsgi_modifier_bounds  =    {& ngx_conf_check_num_bounds, (ngx_int_t )0, (ngx_int_t )255};
#line 108 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_conf_bitmask_t ngx_http_uwsgi_next_upstream_masks[12]  = 
#line 108
  {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_header") - 1UL, (u_char *)"invalid_header"}, (ngx_uint_t )8}, 
        {{sizeof("non_idempotent") - 1UL,
       (u_char *)"non_idempotent"}, (ngx_uint_t )16384}, 
        {{sizeof("http_500") - 1UL, (u_char *)"http_500"}, (ngx_uint_t )16}, 
        {{sizeof("http_503") - 1UL, (u_char *)"http_503"}, (ngx_uint_t )64}, 
        {{sizeof("http_403") - 1UL, (u_char *)"http_403"}, (ngx_uint_t )256}, 
        {{sizeof("http_404") - 1UL, (u_char *)"http_404"}, (ngx_uint_t )512}, 
        {{sizeof("http_429") - 1UL, (u_char *)"http_429"}, (ngx_uint_t )1024}, 
        {{sizeof("updating") - 1UL, (u_char *)"updating"}, (ngx_uint_t )2048}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 142 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_command_t ngx_http_uwsgi_commands[47]  = 
#line 142
  {      {{sizeof("uwsgi_pass") - 1UL, (u_char *)"uwsgi_pass"}, (ngx_uint_t )1207959554,
      & ngx_http_uwsgi_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("uwsgi_modifier1") - 1UL, (u_char *)"uwsgi_modifier1"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->modifier1), (void *)(& ngx_http_uwsgi_modifier_bounds)}, 
        {{sizeof("uwsgi_modifier2") - 1UL,
       (u_char *)"uwsgi_modifier2"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->modifier2),
      (void *)(& ngx_http_uwsgi_modifier_bounds)}, 
        {{sizeof("uwsgi_store") - 1UL, (u_char *)"uwsgi_store"}, (ngx_uint_t )234881026,
      & ngx_http_uwsgi_store, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("uwsgi_store_access") - 1UL, (u_char *)"uwsgi_store_access"}, (ngx_uint_t )234881038,
      & ngx_conf_set_access_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.store_access),
      (void *)0}, 
        {{sizeof("uwsgi_buffering") - 1UL, (u_char *)"uwsgi_buffering"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.buffering), (void *)0}, 
        {{sizeof("uwsgi_request_buffering") - 1UL,
       (u_char *)"uwsgi_request_buffering"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.request_buffering),
      (void *)0}, 
        {{sizeof("uwsgi_ignore_client_abort") - 1UL, (u_char *)"uwsgi_ignore_client_abort"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.ignore_client_abort),
      (void *)0}, 
        {{sizeof("uwsgi_bind") - 1UL, (u_char *)"uwsgi_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("uwsgi_connect_timeout") - 1UL,
       (u_char *)"uwsgi_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_send_timeout") - 1UL, (u_char *)"uwsgi_send_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_buffer_size") - 1UL, (u_char *)"uwsgi_buffer_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.buffer_size),
      (void *)0}, 
        {{sizeof("uwsgi_pass_request_headers") - 1UL, (u_char *)"uwsgi_pass_request_headers"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.pass_request_headers),
      (void *)0}, 
        {{sizeof("uwsgi_pass_request_body") - 1UL, (u_char *)"uwsgi_pass_request_body"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.pass_request_body),
      (void *)0}, 
        {{sizeof("uwsgi_intercept_errors") - 1UL, (u_char *)"uwsgi_intercept_errors"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.intercept_errors),
      (void *)0}, 
        {{sizeof("uwsgi_read_timeout") - 1UL, (u_char *)"uwsgi_read_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_buffers") - 1UL, (u_char *)"uwsgi_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.bufs), (void *)0}, 
        {{sizeof("uwsgi_busy_buffers_size") - 1UL,
       (u_char *)"uwsgi_busy_buffers_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.busy_buffers_size_conf),
      (void *)0}, 
        {{sizeof("uwsgi_force_ranges") - 1UL, (u_char *)"uwsgi_force_ranges"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.force_ranges),
      (void *)0}, 
        {{sizeof("uwsgi_limit_rate") - 1UL, (u_char *)"uwsgi_limit_rate"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.limit_rate), (void *)0}, 
        {{sizeof("uwsgi_cache") - 1UL,
       (u_char *)"uwsgi_cache"}, (ngx_uint_t )234881026, & ngx_http_uwsgi_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("uwsgi_cache_key") - 1UL, (u_char *)"uwsgi_cache_key"}, (ngx_uint_t )234881026,
      & ngx_http_uwsgi_cache_key, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("uwsgi_cache_path") - 1UL, (u_char *)"uwsgi_cache_path"}, (ngx_uint_t )33558528,
      & ngx_http_file_cache_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_uwsgi_main_conf_t *)0)->caches), (void *)(& ngx_http_uwsgi_module)}, 
        {{sizeof("uwsgi_cache_bypass") - 1UL,
       (u_char *)"uwsgi_cache_bypass"}, (ngx_uint_t )234883072, & ngx_http_set_predicate_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_bypass),
      (void *)0}, 
        {{sizeof("uwsgi_no_cache") - 1UL, (u_char *)"uwsgi_no_cache"}, (ngx_uint_t )234883072,
      & ngx_http_set_predicate_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.no_cache), (void *)0}, 
        {{sizeof("uwsgi_cache_valid") - 1UL,
       (u_char *)"uwsgi_cache_valid"}, (ngx_uint_t )234883072, & ngx_http_file_cache_valid_set_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_valid),
      (void *)0}, 
        {{sizeof("uwsgi_cache_min_uses") - 1UL, (u_char *)"uwsgi_cache_min_uses"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_min_uses),
      (void *)0}, 
        {{sizeof("uwsgi_cache_max_range_offset") - 1UL, (u_char *)"uwsgi_cache_max_range_offset"},
      (ngx_uint_t )234881026, & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_max_range_offset),
      (void *)0}, 
        {{sizeof("uwsgi_cache_use_stale") - 1UL, (u_char *)"uwsgi_cache_use_stale"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_use_stale),
      (void *)(& ngx_http_uwsgi_next_upstream_masks)}, 
        {{sizeof("uwsgi_cache_methods") - 1UL, (u_char *)"uwsgi_cache_methods"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_methods),
      (void *)(& ngx_http_upstream_cache_method_mask)}, 
        {{sizeof("uwsgi_cache_lock") - 1UL, (u_char *)"uwsgi_cache_lock"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_lock), (void *)0}, 
        {{sizeof("uwsgi_cache_lock_timeout") - 1UL,
       (u_char *)"uwsgi_cache_lock_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_lock_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_cache_lock_age") - 1UL, (u_char *)"uwsgi_cache_lock_age"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_lock_age),
      (void *)0}, 
        {{sizeof("uwsgi_cache_revalidate") - 1UL, (u_char *)"uwsgi_cache_revalidate"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_revalidate),
      (void *)0}, 
        {{sizeof("uwsgi_cache_background_update") - 1UL, (u_char *)"uwsgi_cache_background_update"},
      (ngx_uint_t )234881026, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.cache_background_update),
      (void *)0}, 
        {{sizeof("uwsgi_temp_path") - 1UL, (u_char *)"uwsgi_temp_path"}, (ngx_uint_t )234881054,
      & ngx_conf_set_path_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.temp_path), (void *)0}, 
        {{sizeof("uwsgi_max_temp_file_size") - 1UL,
       (u_char *)"uwsgi_max_temp_file_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.max_temp_file_size_conf),
      (void *)0}, 
        {{sizeof("uwsgi_temp_file_write_size") - 1UL, (u_char *)"uwsgi_temp_file_write_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.temp_file_write_size_conf),
      (void *)0}, 
        {{sizeof("uwsgi_next_upstream") - 1UL, (u_char *)"uwsgi_next_upstream"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_uwsgi_next_upstream_masks)}, 
        {{sizeof("uwsgi_next_upstream_tries") - 1UL, (u_char *)"uwsgi_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("uwsgi_next_upstream_timeout") - 1UL, (u_char *)"uwsgi_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("uwsgi_param") - 1UL, (u_char *)"uwsgi_param"}, (ngx_uint_t )234881036,
      & ngx_http_upstream_param_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->params_source), (void *)0}, 
        {{sizeof("uwsgi_string") - 1UL,
       (u_char *)"uwsgi_string"}, (ngx_uint_t )234881026, & ngx_conf_set_str_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->uwsgi_string),
      (void *)0}, 
        {{sizeof("uwsgi_pass_header") - 1UL, (u_char *)"uwsgi_pass_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.pass_headers),
      (void *)0}, 
        {{sizeof("uwsgi_hide_header") - 1UL, (u_char *)"uwsgi_hide_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.hide_headers),
      (void *)0}, 
        {{sizeof("uwsgi_ignore_headers") - 1UL, (u_char *)"uwsgi_ignore_headers"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_uwsgi_loc_conf_t *)0)->upstream.ignore_headers),
      (void *)(& ngx_http_upstream_ignore_headers_masks)}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 562 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_http_module_t ngx_http_uwsgi_module_ctx  = 
#line 562
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_uwsgi_create_main_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_uwsgi_create_loc_conf, & ngx_http_uwsgi_merge_loc_conf};
#line 577 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
ngx_module_t ngx_http_uwsgi_module  = 
#line 577
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_uwsgi_module_ctx),
    ngx_http_uwsgi_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 593 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_str_t ngx_http_uwsgi_hide_headers[6]  = {      {sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, 
        {sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, 
        {sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, 
        {sizeof("X-Accel-Buffering") - 1UL, (u_char *)"X-Accel-Buffering"}, 
        {sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, 
        {(size_t )0, (u_char *)((void *)0)}};
#line 605 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_keyval_t ngx_http_uwsgi_cache_headers[7]  = {      {{sizeof("HTTP_IF_MODIFIED_SINCE") - 1UL, (u_char *)"HTTP_IF_MODIFIED_SINCE"},
      {sizeof("$upstream_cache_last_modified") - 1UL, (u_char *)"$upstream_cache_last_modified"}}, 
        {{sizeof("HTTP_IF_UNMODIFIED_SINCE") - 1UL,
       (u_char *)"HTTP_IF_UNMODIFIED_SINCE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_NONE_MATCH") - 1UL, (u_char *)"HTTP_IF_NONE_MATCH"}, {sizeof("$upstream_cache_etag") - 1UL,
                                                                             (u_char *)"$upstream_cache_etag"}}, 
        {{sizeof("HTTP_IF_MATCH") - 1UL,
       (u_char *)"HTTP_IF_MATCH"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_RANGE") - 1UL, (u_char *)"HTTP_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_RANGE") - 1UL,
       (u_char *)"HTTP_IF_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t )0, (u_char *)((void *)0)}, {(size_t )0, (u_char *)((void *)0)}}};
#line 619 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_path_init_t ngx_http_uwsgi_temp_path  =    {{sizeof("uwsgi_temp") - 1UL, (u_char *)"uwsgi_temp"}, {(size_t )1, (size_t )2,
                                                           (size_t )0}};
#line 624 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_status_t *status ;
  ngx_http_upstream_t *u ;
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  ngx_http_uwsgi_main_conf_t *uwmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 635
  tmp = ngx_http_upstream_create(r);
  }
#line 635
  if (tmp != 0L) {
#line 636
    return ((ngx_int_t )500);
  }
  {
#line 639
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_status_t ));
#line 639
  status = (ngx_http_status_t *)tmp___0;
  }
#line 640
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 641
    return ((ngx_int_t )500);
  }
#line 644
  *(r->ctx + ngx_http_uwsgi_module.ctx_index) = (void *)status;
#line 646
  uwcf = (ngx_http_uwsgi_loc_conf_t *)*(r->loc_conf + ngx_http_uwsgi_module.ctx_index);
#line 648
  u = r->upstream;
#line 650
  if ((unsigned long )uwcf->uwsgi_lengths == (unsigned long )((void *)0)) {
#line 662
    u->schema.len = sizeof("uwsgi://") - 1UL;
#line 662
    u->schema.data = (u_char *)"uwsgi://";
  } else {
    {
#line 666
    tmp___1 = ngx_http_uwsgi_eval(r, uwcf);
    }
#line 666
    if (tmp___1 != 0L) {
#line 667
      return ((ngx_int_t )500);
    }
  }
  {
#line 671
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_uwsgi_module);
#line 673
  u->conf = & uwcf->upstream;
#line 676
  uwmcf = (ngx_http_uwsgi_main_conf_t *)*(r->main_conf + ngx_http_uwsgi_module.ctx_index);
#line 678
  u->caches = & uwmcf->caches;
#line 679
  u->create_key = & ngx_http_uwsgi_create_key;
#line 682
  u->create_request = & ngx_http_uwsgi_create_request;
#line 683
  u->reinit_request = & ngx_http_uwsgi_reinit_request;
#line 684
  u->process_header = & ngx_http_uwsgi_process_status_line;
#line 685
  u->abort_request = & ngx_http_uwsgi_abort_request;
#line 686
  u->finalize_request = & ngx_http_uwsgi_finalize_request;
#line 687
  r->state = (ngx_uint_t )0;
#line 689
  u->buffering = (unsigned int )uwcf->upstream.buffering;
#line 691
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t ));
#line 691
  u->pipe = (ngx_event_pipe_t *)tmp___2;
  }
#line 692
  if ((unsigned long )u->pipe == (unsigned long )((void *)0)) {
#line 693
    return ((ngx_int_t )500);
  }
#line 696
  (u->pipe)->input_filter = & ngx_event_pipe_copy_input_filter;
#line 697
  (u->pipe)->input_ctx = (void *)r;
#line 699
  if (! uwcf->upstream.request_buffering) {
#line 699
    if (uwcf->upstream.pass_request_body) {
#line 699
      if (! r->headers_in.chunked) {
#line 703
        r->request_body_no_buffering = 1U;
      }
    }
  }
  {
#line 706
  rc = ngx_http_read_client_request_body(r, & ngx_http_upstream_init);
  }
#line 708
  if (rc >= 300L) {
#line 709
    return (rc);
  }
#line 712
  return ((ngx_int_t )-4);
}
}
#line 716 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_eval(ngx_http_request_t *r , ngx_http_uwsgi_loc_conf_t *uwcf ) 
{ 
  size_t add ;
  ngx_url_t url ;
  ngx_http_upstream_t *u ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 723
  memset((void *)(& url), 0, sizeof(ngx_url_t ));
#line 725
  tmp = ngx_http_script_run(r, & url.url, (uwcf->uwsgi_lengths)->elts, (size_t )0,
                            (uwcf->uwsgi_values)->elts);
  }
#line 725
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 729
    return ((ngx_int_t )-1);
  }
#line 732
  if (url.url.len > 8UL) {
    {
#line 732
    tmp___1 = ngx_strncasecmp(url.url.data, (u_char *)"uwsgi://", (size_t )8);
    }
#line 732
    if (tmp___1 == 0L) {
#line 735
      add = (size_t )8;
    } else {
#line 732
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 737
  if (url.url.len > 9UL) {
    {
#line 737
    tmp___0 = ngx_strncasecmp(url.url.data, (u_char *)"suwsgi://", (size_t )9);
    }
#line 737
    if (tmp___0 == 0L) {
#line 745
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 745
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "suwsgi protocol requires SSL support");
        }
      }
#line 747
      return ((ngx_int_t )-1);
    } else {
#line 751
      add = (size_t )0;
    }
  } else {
#line 751
    add = (size_t )0;
  }
#line 754
  u = r->upstream;
#line 756
  if (add) {
#line 757
    u->schema.len = add;
#line 758
    u->schema.data = url.url.data;
#line 760
    url.url.data += add;
#line 761
    url.url.len -= add;
  } else {
#line 764
    u->schema.len = sizeof("uwsgi://") - 1UL;
#line 764
    u->schema.data = (u_char *)"uwsgi://";
  }
  {
#line 767
  url.no_resolve = 1U;
#line 769
  tmp___2 = ngx_parse_url(r->pool, & url);
  }
#line 769
  if (tmp___2 != 0L) {
#line 770
    if (url.err) {
#line 771
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 771
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%s in upstream \"%V\"",
                           url.err, & url.url);
        }
      }
    }
#line 775
    return ((ngx_int_t )-1);
  }
  {
#line 778
  tmp___3 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t ));
#line 778
  u->resolved = (ngx_http_upstream_resolved_t *)tmp___3;
  }
#line 779
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 780
    return ((ngx_int_t )-1);
  }
#line 783
  if (url.addrs) {
#line 784
    (u->resolved)->sockaddr = (url.addrs + 0)->sockaddr;
#line 785
    (u->resolved)->socklen = (url.addrs + 0)->socklen;
#line 786
    (u->resolved)->name = (url.addrs + 0)->name;
#line 787
    (u->resolved)->naddrs = (ngx_uint_t )1;
  }
#line 790
  (u->resolved)->host = url.host;
#line 791
  (u->resolved)->port = url.port;
#line 792
  (u->resolved)->no_port = (ngx_uint_t )url.no_port;
#line 794
  return ((ngx_int_t )0);
}
}
#line 800 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_create_key(ngx_http_request_t *r ) 
{ 
  ngx_str_t *key ;
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 806
  tmp = ngx_array_push(& (r->cache)->keys);
#line 806
  key = (ngx_str_t *)tmp;
  }
#line 807
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 808
    return ((ngx_int_t )-1);
  }
  {
#line 811
  uwcf = (ngx_http_uwsgi_loc_conf_t *)*(r->loc_conf + ngx_http_uwsgi_module.ctx_index);
#line 813
  tmp___0 = ngx_http_complex_value(r, & uwcf->cache_key, key);
  }
#line 813
  if (tmp___0 != 0L) {
#line 814
    return ((ngx_int_t )-1);
  }
#line 817
  return ((ngx_int_t )0);
}
}
#line 823 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_create_request(ngx_http_request_t *r ) 
{ 
  u_char ch ;
  u_char *lowcase_key ;
  size_t key_len ;
  size_t val_len ;
  size_t len ;
  size_t allocated ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t hash ;
  ngx_uint_t skip_empty ;
  ngx_uint_t header_params ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *body ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_table_elt_t **ignored ;
  ngx_http_uwsgi_params_t *params ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_script_engine_t le ;
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_uint_t tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  void *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
#line 839
  len = (size_t )0;
#line 840
  header_params = (ngx_uint_t )0;
#line 841
  ignored = (ngx_table_elt_t **)((void *)0);
#line 843
  uwcf = (ngx_http_uwsgi_loc_conf_t *)*(r->loc_conf + ngx_http_uwsgi_module.ctx_index);
#line 846
  if ((r->upstream)->cacheable) {
#line 846
    params = & uwcf->params_cache;
  } else {
#line 846
    params = & uwcf->params;
  }
#line 851
  if (params->lengths) {
    {
#line 852
    memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 854
    ngx_http_script_flush_no_cacheable_variables(r, params->flushes);
#line 855
    le.flushed = 1U;
#line 857
    le.ip = (u_char *)(params->lengths)->elts;
#line 858
    le.request = r;
    }
    {
#line 860
    while (1) {
      while_continue: /* CIL Label */ ;
#line 860
      if (! *((uintptr_t *)le.ip)) {
#line 860
        goto while_break;
      }
      {
#line 862
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 863
      key_len = (*lcode)(& le);
#line 865
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 866
      skip_empty = (*lcode)(& le);
#line 868
      val_len = (size_t )0;
      }
      {
#line 868
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 868
        if (! *((uintptr_t *)le.ip)) {
#line 868
          goto while_break___0;
        }
        {
#line 869
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 868
        tmp = (*lcode)(& le);
#line 868
        val_len += tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 871
      le.ip += sizeof(uintptr_t );
#line 873
      if (skip_empty) {
#line 873
        if (val_len == 0UL) {
#line 874
          goto while_continue;
        }
      }
#line 877
      len += ((2UL + key_len) + 2UL) + val_len;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 881
  if (uwcf->upstream.pass_request_headers) {
#line 883
    allocated = (size_t )0;
#line 884
    lowcase_key = (u_char *)((void *)0);
#line 886
    if (params->number) {
#line 887
      n = (ngx_uint_t )0;
#line 888
      part = & r->headers_in.headers.part;
      {
#line 890
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 890
        if (! part) {
#line 890
          goto while_break___1;
        }
#line 891
        n += part->nelts;
#line 892
        part = part->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 895
      tmp___0 = ngx_palloc(r->pool, n * sizeof(void *));
#line 895
      ignored = (ngx_table_elt_t **)tmp___0;
      }
#line 896
      if ((unsigned long )ignored == (unsigned long )((void *)0)) {
#line 897
        return ((ngx_int_t )-1);
      }
    }
#line 901
    part = & r->headers_in.headers.part;
#line 902
    header___0 = (ngx_table_elt_t *)part->elts;
#line 904
    i = (ngx_uint_t )0;
    {
#line 904
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 906
      if (i >= part->nelts) {
#line 907
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 908
          goto while_break___2;
        }
#line 911
        part = part->next;
#line 912
        header___0 = (ngx_table_elt_t *)part->elts;
#line 913
        i = (ngx_uint_t )0;
      }
#line 916
      if (params->number) {
#line 917
        if (allocated < (header___0 + i)->key.len) {
          {
#line 918
          allocated = (header___0 + i)->key.len + 16UL;
#line 919
          tmp___1 = ngx_pnalloc(r->pool, allocated);
#line 919
          lowcase_key = (u_char *)tmp___1;
          }
#line 920
          if ((unsigned long )lowcase_key == (unsigned long )((void *)0)) {
#line 921
            return ((ngx_int_t )-1);
          }
        }
#line 925
        hash = (ngx_uint_t )0;
#line 927
        n = (ngx_uint_t )0;
        {
#line 927
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 927
          if (! (n < (header___0 + i)->key.len)) {
#line 927
            goto while_break___3;
          }
#line 928
          ch = *((header___0 + i)->key.data + n);
#line 930
          if ((int )ch >= 65) {
#line 930
            if ((int )ch <= 90) {
#line 931
              ch = (u_char )((int )ch | 32);
            } else {
#line 930
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 933
          if ((int )ch == 45) {
#line 934
            ch = (u_char )'_';
          }
#line 937
          hash = hash * 31UL + (ngx_uint_t )ch;
#line 938
          *(lowcase_key + n) = ch;
#line 927
          n ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 941
        tmp___3 = ngx_hash_find(& params->hash, hash, lowcase_key, n);
        }
#line 941
        if (tmp___3) {
#line 942
          tmp___2 = header_params;
#line 942
          header_params ++;
#line 942
          *(ignored + tmp___2) = header___0 + i;
#line 943
          goto __Cont;
        }
      }
#line 947
      len += ((((2UL + sizeof("HTTP_")) - 1UL) + (header___0 + i)->key.len) + 2UL) + (header___0 + i)->value.len;
      __Cont: /* CIL Label */ 
#line 904
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 952
  len += uwcf->uwsgi_string.len;
#line 963
  b = ngx_create_temp_buf(r->pool, len + 4UL);
  }
#line 964
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 965
    return ((ngx_int_t )-1);
  }
  {
#line 968
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 969
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 970
    return ((ngx_int_t )-1);
  }
#line 973
  cl->buf = b;
#line 975
  tmp___4 = b->last;
#line 975
  (b->last) ++;
#line 975
  *tmp___4 = (u_char )uwcf->modifier1;
#line 976
  tmp___5 = b->last;
#line 976
  (b->last) ++;
#line 976
  *tmp___5 = (u_char )(len & 255UL);
#line 977
  tmp___6 = b->last;
#line 977
  (b->last) ++;
#line 977
  *tmp___6 = (u_char )((len >> 8) & 255UL);
#line 978
  tmp___7 = b->last;
#line 978
  (b->last) ++;
#line 978
  *tmp___7 = (u_char )uwcf->modifier2;
#line 980
  if (params->lengths) {
    {
#line 981
    memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 983
    e.ip = (u_char *)(params->values)->elts;
#line 984
    e.pos = b->last;
#line 985
    e.request = r;
#line 986
    e.flushed = 1U;
#line 988
    le.ip = (u_char *)(params->lengths)->elts;
    }
    {
#line 990
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 990
      if (! *((uintptr_t *)le.ip)) {
#line 990
        goto while_break___4;
      }
      {
#line 992
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 993
      tmp___8 = (*lcode)(& le);
#line 993
      key_len = (size_t )((u_char )tmp___8);
#line 995
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 996
      skip_empty = (*lcode)(& le);
#line 998
      val_len = (size_t )0;
      }
      {
#line 998
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 998
        if (! *((uintptr_t *)le.ip)) {
#line 998
          goto while_break___5;
        }
        {
#line 999
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 998
        tmp___9 = (*lcode)(& le);
#line 998
        val_len += tmp___9;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1001
      le.ip += sizeof(uintptr_t );
#line 1003
      if (skip_empty) {
#line 1003
        if (val_len == 0UL) {
#line 1004
          e.skip = 1U;
          {
#line 1006
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1006
            if (! *((uintptr_t *)e.ip)) {
#line 1006
              goto while_break___6;
            }
            {
#line 1007
            code = *((ngx_http_script_code_pt *)e.ip);
#line 1008
            (*code)(& e);
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1010
          e.ip += sizeof(uintptr_t );
#line 1012
          e.skip = 0U;
#line 1014
          goto while_continue___4;
        }
      }
      {
#line 1017
      tmp___10 = e.pos;
#line 1017
      (e.pos) ++;
#line 1017
      *tmp___10 = (u_char )(key_len & 255UL);
#line 1018
      tmp___11 = e.pos;
#line 1018
      (e.pos) ++;
#line 1018
      *tmp___11 = (u_char )((key_len >> 8) & 255UL);
#line 1020
      code = *((ngx_http_script_code_pt *)e.ip);
#line 1021
      (*code)(& e);
#line 1023
      tmp___12 = e.pos;
#line 1023
      (e.pos) ++;
#line 1023
      *tmp___12 = (u_char )(val_len & 255UL);
#line 1024
      tmp___13 = e.pos;
#line 1024
      (e.pos) ++;
#line 1024
      *tmp___13 = (u_char )((val_len >> 8) & 255UL);
      }
      {
#line 1026
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1026
        if (! *((uintptr_t *)e.ip)) {
#line 1026
          goto while_break___7;
        }
        {
#line 1027
        code = *((ngx_http_script_code_pt *)e.ip);
#line 1028
        (*code)(& e);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1031
      e.ip += sizeof(uintptr_t );
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1039
    b->last = e.pos;
  }
#line 1042
  if (uwcf->upstream.pass_request_headers) {
#line 1044
    part = & r->headers_in.headers.part;
#line 1045
    header___0 = (ngx_table_elt_t *)part->elts;
#line 1047
    i = (ngx_uint_t )0;
    {
#line 1047
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1049
      if (i >= part->nelts) {
#line 1050
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1051
          goto while_break___8;
        }
#line 1054
        part = part->next;
#line 1055
        header___0 = (ngx_table_elt_t *)part->elts;
#line 1056
        i = (ngx_uint_t )0;
      }
#line 1059
      n = (ngx_uint_t )0;
      {
#line 1059
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1059
        if (! (n < header_params)) {
#line 1059
          goto while_break___9;
        }
#line 1060
        if ((unsigned long )(header___0 + i) == (unsigned long )*(ignored + n)) {
#line 1061
          goto next;
        }
#line 1059
        n ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 1065
      key_len = (sizeof("HTTP_") - 1UL) + (header___0 + i)->key.len;
#line 1066
      tmp___14 = b->last;
#line 1066
      (b->last) ++;
#line 1066
      *tmp___14 = (u_char )(key_len & 255UL);
#line 1067
      tmp___15 = b->last;
#line 1067
      (b->last) ++;
#line 1067
      *tmp___15 = (u_char )((key_len >> 8) & 255UL);
#line 1069
      tmp___16 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"HTTP_",
                        sizeof("HTTP_") - 1UL);
#line 1069
      b->last = (u_char *)tmp___16 + (sizeof("HTTP_") - 1UL);
#line 1070
      n = (ngx_uint_t )0;
      }
      {
#line 1070
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1070
        if (! (n < (header___0 + i)->key.len)) {
#line 1070
          goto while_break___10;
        }
#line 1071
        ch = *((header___0 + i)->key.data + n);
#line 1073
        if ((int )ch >= 97) {
#line 1073
          if ((int )ch <= 122) {
#line 1074
            ch = (u_char )((int )ch & -33);
          } else {
#line 1073
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1076
        if ((int )ch == 45) {
#line 1077
          ch = (u_char )'_';
        }
#line 1080
        tmp___17 = b->last;
#line 1080
        (b->last) ++;
#line 1080
        *tmp___17 = ch;
#line 1070
        n ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1083
      val_len = (header___0 + i)->value.len;
#line 1084
      tmp___18 = b->last;
#line 1084
      (b->last) ++;
#line 1084
      *tmp___18 = (u_char )(val_len & 255UL);
#line 1085
      tmp___19 = b->last;
#line 1085
      (b->last) ++;
#line 1085
      *tmp___19 = (u_char )((val_len >> 8) & 255UL);
#line 1086
      tmp___20 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                        val_len);
#line 1086
      b->last = (u_char *)tmp___20 + val_len;
      }
      next: 
#line 1094
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1047
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
  {
#line 1098
  tmp___21 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)uwcf->uwsgi_string.data,
                    uwcf->uwsgi_string.len);
#line 1098
  b->last = (u_char *)tmp___21 + uwcf->uwsgi_string.len;
  }
#line 1101
  if (r->request_body_no_buffering) {
#line 1102
    (r->upstream)->request_bufs = cl;
  } else
#line 1104
  if (uwcf->upstream.pass_request_body) {
#line 1105
    body = (r->upstream)->request_bufs;
#line 1106
    (r->upstream)->request_bufs = cl;
    {
#line 1108
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1108
      if (! body) {
#line 1108
        goto while_break___11;
      }
      {
#line 1109
      tmp___22 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 1109
      b = (ngx_buf_t *)tmp___22;
      }
#line 1110
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1111
        return ((ngx_int_t )-1);
      }
      {
#line 1114
      memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)body->buf,
             sizeof(ngx_buf_t ));
#line 1116
      cl->next = ngx_alloc_chain_link(r->pool);
      }
#line 1117
      if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1118
        return ((ngx_int_t )-1);
      }
#line 1121
      cl = cl->next;
#line 1122
      cl->buf = b;
#line 1124
      body = body->next;
    }
    while_break___11: /* CIL Label */ ;
    }
  } else {
#line 1128
    (r->upstream)->request_bufs = cl;
  }
#line 1131
  cl->next = (ngx_chain_t *)((void *)0);
#line 1133
  return ((ngx_int_t )0);
}
}
#line 1137 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_reinit_request(ngx_http_request_t *r ) 
{ 
  ngx_http_status_t *status ;

  {
#line 1142
  status = (ngx_http_status_t *)*(r->ctx + ngx_http_uwsgi_module.ctx_index);
#line 1144
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 1145
    return ((ngx_int_t )0);
  }
#line 1148
  status->code = (ngx_uint_t )0;
#line 1149
  status->count = (ngx_uint_t )0;
#line 1150
  status->start = (u_char *)((void *)0);
#line 1151
  status->end = (u_char *)((void *)0);
#line 1153
  (r->upstream)->process_header = & ngx_http_uwsgi_process_status_line;
#line 1154
  r->state = (ngx_uint_t )0;
#line 1156
  return ((ngx_int_t )0);
}
}
#line 1160 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_process_status_line(ngx_http_request_t *r ) 
{ 
  size_t len ;
  ngx_int_t rc ;
  ngx_http_status_t *status ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1168
  status = (ngx_http_status_t *)*(r->ctx + ngx_http_uwsgi_module.ctx_index);
#line 1170
  if ((unsigned long )status == (unsigned long )((void *)0)) {
#line 1171
    return ((ngx_int_t )-1);
  }
  {
#line 1174
  u = r->upstream;
#line 1176
  rc = ngx_http_parse_status_line(r, & u->buffer, status);
  }
#line 1178
  if (rc == -2L) {
#line 1179
    return (rc);
  }
#line 1182
  if (rc == -1L) {
    {
#line 1183
    u->process_header = & ngx_http_uwsgi_process_header;
#line 1184
    tmp = ngx_http_uwsgi_process_header(r);
    }
#line 1184
    return (tmp);
  }
#line 1187
  if (u->state) {
#line 1187
    if ((u->state)->status == 0UL) {
#line 1188
      (u->state)->status = status->code;
    }
  }
  {
#line 1191
  u->headers_in.status_n = status->code;
#line 1193
  len = (size_t )(status->end - status->start);
#line 1194
  u->headers_in.status_line.len = len;
#line 1196
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 1196
  u->headers_in.status_line.data = (u_char *)tmp___0;
  }
#line 1197
  if ((unsigned long )u->headers_in.status_line.data == (unsigned long )((void *)0)) {
#line 1198
    return ((ngx_int_t )-1);
  }
  {
#line 1201
  memcpy((void */* __restrict  */)u->headers_in.status_line.data, (void const   */* __restrict  */)status->start,
         len);
#line 1207
  u->process_header = & ngx_http_uwsgi_process_header;
#line 1209
  tmp___1 = ngx_http_uwsgi_process_header(r);
  }
#line 1209
  return (tmp___1);
}
}
#line 1213 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_process_header(ngx_http_request_t *r ) 
{ 
  ngx_str_t *status_line ;
  ngx_int_t rc ;
  ngx_int_t status ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1223
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
  {
#line 1225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1227
    rc = ngx_http_parse_header_line(r, & (r->upstream)->buffer, (ngx_uint_t )1);
    }
#line 1229
    if (rc == 0L) {
      {
#line 1233
      tmp = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1233
      h = (ngx_table_elt_t *)tmp;
      }
#line 1234
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1235
        return ((ngx_int_t )-1);
      }
      {
#line 1238
      h->hash = r->header_hash;
#line 1240
      h->key.len = (size_t )(r->header_name_end - r->header_name_start);
#line 1241
      h->value.len = (size_t )(r->header_end - r->header_start);
#line 1243
      tmp___0 = ngx_pnalloc(r->pool, (((h->key.len + 1UL) + h->value.len) + 1UL) + h->key.len);
#line 1243
      h->key.data = (u_char *)tmp___0;
      }
#line 1246
      if ((unsigned long )h->key.data == (unsigned long )((void *)0)) {
#line 1247
        h->hash = (ngx_uint_t )0;
#line 1248
        return ((ngx_int_t )-1);
      }
      {
#line 1251
      h->value.data = (h->key.data + h->key.len) + 1;
#line 1252
      h->lowcase_key = (((h->key.data + h->key.len) + 1) + h->value.len) + 1;
#line 1254
      memcpy((void */* __restrict  */)h->key.data, (void const   */* __restrict  */)r->header_name_start,
             h->key.len);
#line 1255
      *(h->key.data + h->key.len) = (u_char )'\000';
#line 1256
      memcpy((void */* __restrict  */)h->value.data, (void const   */* __restrict  */)r->header_start,
             h->value.len);
#line 1257
      *(h->value.data + h->value.len) = (u_char )'\000';
      }
#line 1259
      if (h->key.len == r->lowcase_index) {
        {
#line 1260
        memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
               h->key.len);
        }
      } else {
        {
#line 1263
        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
        }
      }
      {
#line 1266
      tmp___1 = ngx_hash_find(& umcf->headers_in_hash, h->hash, h->lowcase_key, h->key.len);
#line 1266
      hh = (ngx_http_upstream_header_t *)tmp___1;
      }
#line 1269
      if (hh) {
        {
#line 1269
        tmp___2 = (*(hh->handler))(r, h, hh->offset);
        }
#line 1269
        if (tmp___2 != 0L) {
#line 1270
          return ((ngx_int_t )-1);
        }
      }
#line 1276
      goto __Cont;
    }
#line 1279
    if (rc == 1L) {
#line 1286
      u = r->upstream;
#line 1288
      if (u->headers_in.status_n) {
#line 1289
        goto done;
      }
#line 1292
      if (u->headers_in.status) {
        {
#line 1293
        status_line = & (u->headers_in.status)->value;
#line 1295
        status = ngx_atoi(status_line->data, (size_t )3);
        }
#line 1296
        if (status == -1L) {
#line 1297
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 1297
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid status \"%V\"",
                               status_line);
            }
          }
#line 1300
          return ((ngx_int_t )40);
        }
#line 1303
        u->headers_in.status_n = (ngx_uint_t )status;
#line 1304
        u->headers_in.status_line = *status_line;
      } else
#line 1306
      if (u->headers_in.location) {
#line 1307
        u->headers_in.status_n = (ngx_uint_t )302;
#line 1308
        u->headers_in.status_line.len = sizeof("302 Moved Temporarily") - 1UL;
#line 1308
        u->headers_in.status_line.data = (u_char *)"302 Moved Temporarily";
      } else {
#line 1312
        u->headers_in.status_n = (ngx_uint_t )200;
#line 1313
        u->headers_in.status_line.len = sizeof("200 OK") - 1UL;
#line 1313
        u->headers_in.status_line.data = (u_char *)"200 OK";
      }
#line 1316
      if (u->state) {
#line 1316
        if ((u->state)->status == 0UL) {
#line 1317
          (u->state)->status = u->headers_in.status_n;
        }
      }
      done: 
#line 1322
      if (u->headers_in.status_n == 101UL) {
#line 1322
        if (r->headers_in.upgrade) {
#line 1325
          u->upgrade = 1U;
        }
      }
#line 1328
      return ((ngx_int_t )0);
    }
#line 1331
    if (rc == -2L) {
#line 1332
      return ((ngx_int_t )-2);
    }
#line 1337
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1337
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid header");
      }
    }
#line 1340
    return ((ngx_int_t )40);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1345 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static void ngx_http_uwsgi_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 1351
  return;
}
}
#line 1355 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static void ngx_http_uwsgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 1361
  return;
}
}
#line 1365 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static void *ngx_http_uwsgi_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_uwsgi_main_conf_t *conf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1370
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_uwsgi_main_conf_t ));
#line 1370
  conf = (ngx_http_uwsgi_main_conf_t *)tmp;
  }
#line 1371
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1372
    return ((void *)0);
  }
  {
#line 1376
  tmp___0 = ngx_array_init(& conf->caches, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_file_cache_t *));
  }
#line 1376
  if (tmp___0 != 0L) {
#line 1380
    return ((void *)0);
  }
#line 1384
  return ((void *)conf);
}
}
#line 1388 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static void *ngx_http_uwsgi_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *conf ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 1393
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_uwsgi_loc_conf_t ));
#line 1393
  conf = (ngx_http_uwsgi_loc_conf_t *)tmp;
  }
#line 1394
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1395
    return ((void *)0);
  }
#line 1398
  conf->modifier1 = (ngx_uint_t )-1;
#line 1399
  conf->modifier2 = (ngx_uint_t )-1;
#line 1401
  conf->upstream.store = -1;
#line 1402
  conf->upstream.store_access = (ngx_uint_t )-1;
#line 1403
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 1404
  conf->upstream.buffering = (ngx_flag_t )-1;
#line 1405
  conf->upstream.request_buffering = (ngx_flag_t )-1;
#line 1406
  conf->upstream.ignore_client_abort = (ngx_flag_t )-1;
#line 1407
  conf->upstream.force_ranges = (ngx_flag_t )-1;
#line 1409
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 1411
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 1412
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 1413
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 1414
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 1416
  conf->upstream.send_lowat = (size_t )-1;
#line 1417
  conf->upstream.buffer_size = (size_t )-1;
#line 1418
  conf->upstream.limit_rate = (size_t )-1;
#line 1420
  conf->upstream.busy_buffers_size_conf = (size_t )-1;
#line 1421
  conf->upstream.max_temp_file_size_conf = (size_t )-1;
#line 1422
  conf->upstream.temp_file_write_size_conf = (size_t )-1;
#line 1424
  conf->upstream.pass_request_headers = (ngx_flag_t )-1;
#line 1425
  conf->upstream.pass_request_body = (ngx_flag_t )-1;
#line 1428
  conf->upstream.cache = -1;
#line 1429
  conf->upstream.cache_min_uses = (ngx_uint_t )-1;
#line 1430
  conf->upstream.cache_max_range_offset = (off_t )-1;
#line 1431
  conf->upstream.cache_bypass = (ngx_array_t *)((void *)-1);
#line 1432
  conf->upstream.no_cache = (ngx_array_t *)((void *)-1);
#line 1433
  conf->upstream.cache_valid = (ngx_array_t *)((void *)-1);
#line 1434
  conf->upstream.cache_lock = (ngx_flag_t )-1;
#line 1435
  conf->upstream.cache_lock_timeout = (ngx_msec_t )-1;
#line 1436
  conf->upstream.cache_lock_age = (ngx_msec_t )-1;
#line 1437
  conf->upstream.cache_revalidate = (ngx_flag_t )-1;
#line 1438
  conf->upstream.cache_background_update = (ngx_flag_t )-1;
#line 1441
  conf->upstream.hide_headers = (ngx_array_t *)((void *)-1);
#line 1442
  conf->upstream.pass_headers = (ngx_array_t *)((void *)-1);
#line 1444
  conf->upstream.intercept_errors = (ngx_flag_t )-1;
#line 1455
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 1457
  conf->upstream.change_buffering = 1U;
#line 1459
  conf->upstream.module.len = sizeof("uwsgi") - 1UL;
#line 1459
  conf->upstream.module.data = (u_char *)"uwsgi";
#line 1461
  return ((void *)conf);
}
}
#line 1465 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_uwsgi_loc_conf_t *prev ;
  ngx_http_uwsgi_loc_conf_t *conf ;
  size_t size ;
  ngx_int_t rc ;
  ngx_hash_init_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  char *tmp ;
  ngx_shm_zone_t *shm_zone ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 1468
  prev = (ngx_http_uwsgi_loc_conf_t *)parent;
#line 1469
  conf = (ngx_http_uwsgi_loc_conf_t *)child;
#line 1478
  if (conf->upstream.store > 0) {
#line 1479
    conf->upstream.cache = 0;
  }
#line 1482
  if (conf->upstream.cache > 0) {
#line 1483
    conf->upstream.store = 0;
  }
#line 1488
  if (conf->upstream.store == -1) {
#line 1489
    if (conf->upstream.store == -1) {
#line 1489
      if (prev->upstream.store == -1) {
#line 1489
        conf->upstream.store = 0;
      } else {
#line 1489
        conf->upstream.store = prev->upstream.store;
      }
    }
#line 1491
    conf->upstream.store_lengths = prev->upstream.store_lengths;
#line 1492
    conf->upstream.store_values = prev->upstream.store_values;
  }
#line 1495
  if (conf->upstream.store_access == 0xffffffffffffffffUL) {
#line 1495
    if (prev->upstream.store_access == 0xffffffffffffffffUL) {
#line 1495
      conf->upstream.store_access = (ngx_uint_t )384;
    } else {
#line 1495
      conf->upstream.store_access = prev->upstream.store_access;
    }
  }
#line 1498
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 1498
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 1498
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 1498
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 1501
  if (conf->upstream.buffering == -1L) {
#line 1501
    if (prev->upstream.buffering == -1L) {
#line 1501
      conf->upstream.buffering = (ngx_flag_t )1;
    } else {
#line 1501
      conf->upstream.buffering = prev->upstream.buffering;
    }
  }
#line 1504
  if (conf->upstream.request_buffering == -1L) {
#line 1504
    if (prev->upstream.request_buffering == -1L) {
#line 1504
      conf->upstream.request_buffering = (ngx_flag_t )1;
    } else {
#line 1504
      conf->upstream.request_buffering = prev->upstream.request_buffering;
    }
  }
#line 1507
  if (conf->upstream.ignore_client_abort == -1L) {
#line 1507
    if (prev->upstream.ignore_client_abort == -1L) {
#line 1507
      conf->upstream.ignore_client_abort = (ngx_flag_t )0;
    } else {
#line 1507
      conf->upstream.ignore_client_abort = prev->upstream.ignore_client_abort;
    }
  }
#line 1510
  if (conf->upstream.force_ranges == -1L) {
#line 1510
    if (prev->upstream.force_ranges == -1L) {
#line 1510
      conf->upstream.force_ranges = (ngx_flag_t )0;
    } else {
#line 1510
      conf->upstream.force_ranges = prev->upstream.force_ranges;
    }
  }
#line 1513
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 1513
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 1513
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 1513
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 1516
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 1516
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 1516
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 1516
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 1519
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 1519
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 1519
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 1519
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 1522
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 1522
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 1522
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 1522
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 1525
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 1525
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 1525
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 1525
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 1528
  if (conf->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 1528
    if (prev->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 1528
      conf->upstream.send_lowat = (size_t )0;
    } else {
#line 1528
      conf->upstream.send_lowat = prev->upstream.send_lowat;
    }
  }
#line 1531
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 1531
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 1531
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 1531
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 1535
  if (conf->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 1535
    if (prev->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 1535
      conf->upstream.limit_rate = (size_t )0;
    } else {
#line 1535
      conf->upstream.limit_rate = prev->upstream.limit_rate;
    }
  }
#line 1539
  if (conf->upstream.bufs.num == 0L) {
#line 1539
    if (prev->upstream.bufs.num) {
#line 1539
      conf->upstream.bufs.num = prev->upstream.bufs.num;
#line 1539
      conf->upstream.bufs.size = prev->upstream.bufs.size;
    } else {
#line 1539
      conf->upstream.bufs.num = (ngx_int_t )8;
#line 1539
      conf->upstream.bufs.size = ngx_pagesize;
    }
  }
#line 1542
  if (conf->upstream.bufs.num < 2L) {
    {
#line 1543
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "there must be at least 2 \"uwsgi_buffers\"");
    }
#line 1545
    return ((char *)((void *)-1));
  }
#line 1549
  size = conf->upstream.buffer_size;
#line 1550
  if (size < conf->upstream.bufs.size) {
#line 1551
    size = conf->upstream.bufs.size;
  }
#line 1555
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1555
    if (prev->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1555
      conf->upstream.busy_buffers_size_conf = (size_t )-1;
    } else {
#line 1555
      conf->upstream.busy_buffers_size_conf = prev->upstream.busy_buffers_size_conf;
    }
  }
#line 1559
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 1560
    conf->upstream.busy_buffers_size = 2UL * size;
  } else {
#line 1562
    conf->upstream.busy_buffers_size = conf->upstream.busy_buffers_size_conf;
  }
#line 1566
  if (conf->upstream.busy_buffers_size < size) {
    {
#line 1567
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_busy_buffers_size\" must be equal to or greater than the maximum of the value of \"uwsgi_buffer_size\" and one of the \"uwsgi_buffers\"");
    }
#line 1572
    return ((char *)((void *)-1));
  }
#line 1575
  if (conf->upstream.busy_buffers_size > (size_t )(conf->upstream.bufs.num - 1L) * conf->upstream.bufs.size) {
    {
#line 1578
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_busy_buffers_size\" must be less than the size of all \"uwsgi_buffers\" minus one buffer");
    }
#line 1582
    return ((char *)((void *)-1));
  }
#line 1586
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1586
    if (prev->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1586
      conf->upstream.temp_file_write_size_conf = (size_t )-1;
    } else {
#line 1586
      conf->upstream.temp_file_write_size_conf = prev->upstream.temp_file_write_size_conf;
    }
  }
#line 1590
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 1591
    conf->upstream.temp_file_write_size = 2UL * size;
  } else {
#line 1593
    conf->upstream.temp_file_write_size = conf->upstream.temp_file_write_size_conf;
  }
#line 1597
  if (conf->upstream.temp_file_write_size < size) {
    {
#line 1598
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_temp_file_write_size\" must be equal to or greater than the maximum of the value of \"uwsgi_buffer_size\" and one of the \"uwsgi_buffers\"");
    }
#line 1603
    return ((char *)((void *)-1));
  }
#line 1607
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1607
    if (prev->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1607
      conf->upstream.max_temp_file_size_conf = (size_t )-1;
    } else {
#line 1607
      conf->upstream.max_temp_file_size_conf = prev->upstream.max_temp_file_size_conf;
    }
  }
#line 1611
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 1612
    conf->upstream.max_temp_file_size = (size_t )1073741824;
  } else {
#line 1614
    conf->upstream.max_temp_file_size = conf->upstream.max_temp_file_size_conf;
  }
#line 1618
  if (conf->upstream.max_temp_file_size != 0UL) {
#line 1618
    if (conf->upstream.max_temp_file_size < size) {
      {
#line 1621
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_max_temp_file_size\" must be equal to zero to disable temporary files usage or must be equal to or greater than the maximum of the value of \"uwsgi_buffer_size\" and one of the \"uwsgi_buffers\"");
      }
#line 1627
      return ((char *)((void *)-1));
    }
  }
#line 1631
  if (conf->upstream.ignore_headers == 0UL) {
#line 1631
    if (prev->upstream.ignore_headers == 0UL) {
#line 1631
      conf->upstream.ignore_headers = (ngx_uint_t )1;
    } else {
#line 1631
      conf->upstream.ignore_headers = prev->upstream.ignore_headers;
    }
  }
#line 1636
  if (conf->upstream.next_upstream == 0UL) {
#line 1636
    if (prev->upstream.next_upstream == 0UL) {
#line 1636
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 1636
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 1642
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 1643
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
  {
#line 1647
  tmp = ngx_conf_merge_path_value(cf, & conf->upstream.temp_path, prev->upstream.temp_path,
                                  & ngx_http_uwsgi_temp_path);
  }
#line 1647
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1652
    return ((char *)((void *)-1));
  }
#line 1657
  if (conf->upstream.cache == -1) {
#line 1658
    if (conf->upstream.cache == -1) {
#line 1658
      if (prev->upstream.cache == -1) {
#line 1658
        conf->upstream.cache = 0;
      } else {
#line 1658
        conf->upstream.cache = prev->upstream.cache;
      }
    }
#line 1661
    conf->upstream.cache_zone = prev->upstream.cache_zone;
#line 1662
    conf->upstream.cache_value = prev->upstream.cache_value;
  }
#line 1665
  if (conf->upstream.cache_zone) {
#line 1665
    if ((unsigned long )(conf->upstream.cache_zone)->data == (unsigned long )((void *)0)) {
      {
#line 1668
      shm_zone = conf->upstream.cache_zone;
#line 1670
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"uwsgi_cache\" zone \"%V\" is unknown",
                         & shm_zone->shm.name);
      }
#line 1674
      return ((char *)((void *)-1));
    }
  }
#line 1677
  if (conf->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 1677
    if (prev->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 1677
      conf->upstream.cache_min_uses = (ngx_uint_t )1;
    } else {
#line 1677
      conf->upstream.cache_min_uses = prev->upstream.cache_min_uses;
    }
  }
#line 1680
  if (conf->upstream.cache_max_range_offset == -1L) {
#line 1680
    if (prev->upstream.cache_max_range_offset == -1L) {
#line 1680
      conf->upstream.cache_max_range_offset = (off_t )9223372036854775807LL;
    } else {
#line 1680
      conf->upstream.cache_max_range_offset = prev->upstream.cache_max_range_offset;
    }
  }
#line 1684
  if (conf->upstream.cache_use_stale == 0UL) {
#line 1684
    if (prev->upstream.cache_use_stale == 0UL) {
#line 1684
      conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
    } else {
#line 1684
      conf->upstream.cache_use_stale = prev->upstream.cache_use_stale;
    }
  }
#line 1689
  if (conf->upstream.cache_use_stale & 2147483648UL) {
#line 1690
    conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
  }
#line 1694
  if (conf->upstream.cache_use_stale & 2UL) {
#line 1695
    conf->upstream.cache_use_stale |= 1073741824UL;
  }
#line 1698
  if (conf->upstream.cache_methods == 0UL) {
#line 1699
    conf->upstream.cache_methods = prev->upstream.cache_methods;
  }
#line 1702
  conf->upstream.cache_methods |= 6UL;
#line 1704
  if ((unsigned long )conf->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 1704
    if ((unsigned long )prev->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 1704
      conf->upstream.cache_bypass = (ngx_array_t *)((void *)0);
    } else {
#line 1704
      conf->upstream.cache_bypass = prev->upstream.cache_bypass;
    }
  }
#line 1707
  if ((unsigned long )conf->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 1707
    if ((unsigned long )prev->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 1707
      conf->upstream.no_cache = (ngx_array_t *)((void *)0);
    } else {
#line 1707
      conf->upstream.no_cache = prev->upstream.no_cache;
    }
  }
#line 1710
  if ((unsigned long )conf->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 1710
    if ((unsigned long )prev->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 1710
      conf->upstream.cache_valid = (ngx_array_t *)((void *)0);
    } else {
#line 1710
      conf->upstream.cache_valid = prev->upstream.cache_valid;
    }
  }
#line 1713
  if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
#line 1714
    conf->cache_key = prev->cache_key;
  }
#line 1717
  if (conf->upstream.cache) {
#line 1717
    if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
      {
#line 1718
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no \"uwsgi_cache_key\" for \"uwsgi_cache\"");
      }
    }
  }
#line 1722
  if (conf->upstream.cache_lock == -1L) {
#line 1722
    if (prev->upstream.cache_lock == -1L) {
#line 1722
      conf->upstream.cache_lock = (ngx_flag_t )0;
    } else {
#line 1722
      conf->upstream.cache_lock = prev->upstream.cache_lock;
    }
  }
#line 1725
  if (conf->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 1725
    if (prev->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 1725
      conf->upstream.cache_lock_timeout = (ngx_msec_t )5000;
    } else {
#line 1725
      conf->upstream.cache_lock_timeout = prev->upstream.cache_lock_timeout;
    }
  }
#line 1728
  if (conf->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 1728
    if (prev->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 1728
      conf->upstream.cache_lock_age = (ngx_msec_t )5000;
    } else {
#line 1728
      conf->upstream.cache_lock_age = prev->upstream.cache_lock_age;
    }
  }
#line 1731
  if (conf->upstream.cache_revalidate == -1L) {
#line 1731
    if (prev->upstream.cache_revalidate == -1L) {
#line 1731
      conf->upstream.cache_revalidate = (ngx_flag_t )0;
    } else {
#line 1731
      conf->upstream.cache_revalidate = prev->upstream.cache_revalidate;
    }
  }
#line 1734
  if (conf->upstream.cache_background_update == -1L) {
#line 1734
    if (prev->upstream.cache_background_update == -1L) {
#line 1734
      conf->upstream.cache_background_update = (ngx_flag_t )0;
    } else {
#line 1734
      conf->upstream.cache_background_update = prev->upstream.cache_background_update;
    }
  }
#line 1739
  if (conf->upstream.pass_request_headers == -1L) {
#line 1739
    if (prev->upstream.pass_request_headers == -1L) {
#line 1739
      conf->upstream.pass_request_headers = (ngx_flag_t )1;
    } else {
#line 1739
      conf->upstream.pass_request_headers = prev->upstream.pass_request_headers;
    }
  }
#line 1741
  if (conf->upstream.pass_request_body == -1L) {
#line 1741
    if (prev->upstream.pass_request_body == -1L) {
#line 1741
      conf->upstream.pass_request_body = (ngx_flag_t )1;
    } else {
#line 1741
      conf->upstream.pass_request_body = prev->upstream.pass_request_body;
    }
  }
#line 1744
  if (conf->upstream.intercept_errors == -1L) {
#line 1744
    if (prev->upstream.intercept_errors == -1L) {
#line 1744
      conf->upstream.intercept_errors = (ngx_flag_t )0;
    } else {
#line 1744
      conf->upstream.intercept_errors = prev->upstream.intercept_errors;
    }
  }
#line 1785
  if ((unsigned long )conf->uwsgi_string.data == (unsigned long )((void *)0)) {
#line 1785
    if (prev->uwsgi_string.data) {
#line 1785
      conf->uwsgi_string.len = prev->uwsgi_string.len;
#line 1785
      conf->uwsgi_string.data = prev->uwsgi_string.data;
    } else {
#line 1785
      conf->uwsgi_string.len = sizeof("") - 1UL;
#line 1785
      conf->uwsgi_string.data = (u_char *)"";
    }
  }
  {
#line 1787
  hash.max_size = (ngx_uint_t )512;
#line 1788
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 1789
  hash.name = (char *)"uwsgi_hide_headers_hash";
#line 1791
  tmp___0 = ngx_http_upstream_hide_headers_hash(cf, & conf->upstream, & prev->upstream,
                                                ngx_http_uwsgi_hide_headers, & hash);
  }
#line 1791
  if (tmp___0 != 0L) {
#line 1795
    return ((char *)((void *)-1));
  }
#line 1798
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 1800
  if (clcf->noname) {
#line 1800
    if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 1800
      if ((unsigned long )conf->uwsgi_lengths == (unsigned long )((void *)0)) {
#line 1803
        conf->upstream.upstream = prev->upstream.upstream;
#line 1805
        conf->uwsgi_lengths = prev->uwsgi_lengths;
#line 1806
        conf->uwsgi_values = prev->uwsgi_values;
      }
    }
  }
#line 1813
  if (clcf->lmt_excpt) {
#line 1813
    if ((unsigned long )clcf->handler == (unsigned long )((void *)0)) {
#line 1813
      if (conf->upstream.upstream) {
#line 1816
        clcf->handler = & ngx_http_uwsgi_handler;
      } else
#line 1813
      if (conf->uwsgi_lengths) {
#line 1816
        clcf->handler = & ngx_http_uwsgi_handler;
      }
    }
  }
#line 1819
  if (conf->modifier1 == 0xffffffffffffffffUL) {
#line 1819
    if (prev->modifier1 == 0xffffffffffffffffUL) {
#line 1819
      conf->modifier1 = (ngx_uint_t )0;
    } else {
#line 1819
      conf->modifier1 = prev->modifier1;
    }
  }
#line 1820
  if (conf->modifier2 == 0xffffffffffffffffUL) {
#line 1820
    if (prev->modifier2 == 0xffffffffffffffffUL) {
#line 1820
      conf->modifier2 = (ngx_uint_t )0;
    } else {
#line 1820
      conf->modifier2 = prev->modifier2;
    }
  }
#line 1822
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 1823
    conf->params = prev->params;
#line 1825
    conf->params_cache = prev->params_cache;
#line 1827
    conf->params_source = prev->params_source;
  }
  {
#line 1830
  rc = ngx_http_uwsgi_init_params(cf, conf, & conf->params, (ngx_keyval_t *)((void *)0));
  }
#line 1831
  if (rc != 0L) {
#line 1832
    return ((char *)((void *)-1));
  }
#line 1837
  if (conf->upstream.cache) {
    {
#line 1838
    rc = ngx_http_uwsgi_init_params(cf, conf, & conf->params_cache, ngx_http_uwsgi_cache_headers);
    }
#line 1840
    if (rc != 0L) {
#line 1841
      return ((char *)((void *)-1));
    }
  }
#line 1852
  if ((unsigned long )prev->params.hash.buckets == (unsigned long )((void *)0)) {
#line 1852
    if ((unsigned long )conf->params_source == (unsigned long )prev->params_source) {
#line 1855
      prev->params = conf->params;
#line 1857
      prev->params_cache = conf->params_cache;
    }
  }
#line 1861
  return ((char *)((void *)0));
}
}
#line 1865 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static ngx_int_t ngx_http_uwsgi_init_params(ngx_conf_t *cf , ngx_http_uwsgi_loc_conf_t *conf ,
                                            ngx_http_uwsgi_params_t *params , ngx_keyval_t *default_params ) 
{ 
  u_char *p ;
  size_t size ;
  uintptr_t *code ;
  ngx_uint_t i ;
  ngx_uint_t nsrc ;
  ngx_array_t headers_names ;
  ngx_array_t params_merged ;
  ngx_keyval_t *h ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_upstream_param_t *src ;
  ngx_http_upstream_param_t *s ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_copy_code_t *copy ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  ngx_int_t tmp___13 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 1881
  if (params->hash.buckets) {
#line 1882
    return ((ngx_int_t )0);
  }
#line 1885
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 1885
    if ((unsigned long )default_params == (unsigned long )((void *)0)) {
#line 1886
      params->hash.buckets = (ngx_hash_elt_t **)((void *)1);
#line 1887
      return ((ngx_int_t )0);
    }
  }
  {
#line 1890
  params->lengths = ngx_array_create(cf->pool, (ngx_uint_t )64, (size_t )1);
  }
#line 1891
  if ((unsigned long )params->lengths == (unsigned long )((void *)0)) {
#line 1892
    return ((ngx_int_t )-1);
  }
  {
#line 1895
  params->values = ngx_array_create(cf->pool, (ngx_uint_t )512, (size_t )1);
  }
#line 1896
  if ((unsigned long )params->values == (unsigned long )((void *)0)) {
#line 1897
    return ((ngx_int_t )-1);
  }
  {
#line 1900
  tmp = ngx_array_init(& headers_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 1900
  if (tmp != 0L) {
#line 1903
    return ((ngx_int_t )-1);
  }
#line 1906
  if (conf->params_source) {
#line 1907
    src = (ngx_http_upstream_param_t *)(conf->params_source)->elts;
#line 1908
    nsrc = (conf->params_source)->nelts;
  } else {
#line 1911
    src = (ngx_http_upstream_param_t *)((void *)0);
#line 1912
    nsrc = (ngx_uint_t )0;
  }
#line 1915
  if (default_params) {
    {
#line 1916
    tmp___0 = ngx_array_init(& params_merged, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_param_t ));
    }
#line 1916
    if (tmp___0 != 0L) {
#line 1920
      return ((ngx_int_t )-1);
    }
#line 1923
    i = (ngx_uint_t )0;
    {
#line 1923
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1923
      if (! (i < nsrc)) {
#line 1923
        goto while_break;
      }
      {
#line 1925
      tmp___1 = ngx_array_push(& params_merged);
#line 1925
      s = (ngx_http_upstream_param_t *)tmp___1;
      }
#line 1926
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1927
        return ((ngx_int_t )-1);
      }
#line 1930
      *s = *(src + i);
#line 1923
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1933
    h = default_params;
    {
#line 1935
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1935
      if (! h->key.len) {
#line 1935
        goto while_break___0;
      }
#line 1937
      src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 1938
      nsrc = params_merged.nelts;
#line 1940
      i = (ngx_uint_t )0;
      {
#line 1940
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1940
        if (! (i < nsrc)) {
#line 1940
          goto while_break___1;
        }
        {
#line 1941
        tmp___2 = ngx_strcasecmp(h->key.data, (src + i)->key.data);
        }
#line 1941
        if (tmp___2 == 0L) {
#line 1942
          goto next;
        }
#line 1940
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 1946
      tmp___3 = ngx_array_push(& params_merged);
#line 1946
      s = (ngx_http_upstream_param_t *)tmp___3;
      }
#line 1947
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1948
        return ((ngx_int_t )-1);
      }
#line 1951
      s->key = h->key;
#line 1952
      s->value = h->value;
#line 1953
      s->skip_empty = (ngx_uint_t )1;
      next: 
#line 1957
      h ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1960
    src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 1961
    nsrc = params_merged.nelts;
  }
#line 1964
  i = (ngx_uint_t )0;
  {
#line 1964
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1964
    if (! (i < nsrc)) {
#line 1964
      goto while_break___2;
    }
#line 1966
    if ((src + i)->key.len > sizeof("HTTP_") - 1UL) {
      {
#line 1966
      tmp___5 = strncmp((char const   *)(src + i)->key.data, "HTTP_", sizeof("HTTP_") - 1UL);
      }
#line 1966
      if (tmp___5 == 0) {
        {
#line 1969
        tmp___4 = ngx_array_push(& headers_names);
#line 1969
        hk = (ngx_hash_key_t *)tmp___4;
        }
#line 1970
        if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 1971
          return ((ngx_int_t )-1);
        }
        {
#line 1974
        hk->key.len = (src + i)->key.len - 5UL;
#line 1975
        hk->key.data = (src + i)->key.data + 5;
#line 1976
        hk->key_hash = ngx_hash_key_lc(hk->key.data, hk->key.len);
#line 1977
        hk->value = (void *)1;
        }
#line 1979
        if ((src + i)->value.len == 0UL) {
#line 1980
          goto __Cont;
        }
      }
    }
    {
#line 1984
    tmp___6 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 1984
    copy = (ngx_http_script_copy_code_t *)tmp___6;
    }
#line 1986
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1987
      return ((ngx_int_t )-1);
    }
    {
#line 1990
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 1991
    copy->len = (src + i)->key.len;
#line 1993
    tmp___7 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 1993
    copy = (ngx_http_script_copy_code_t *)tmp___7;
    }
#line 1995
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 1996
      return ((ngx_int_t )-1);
    }
    {
#line 1999
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 2000
    copy->len = (src + i)->skip_empty;
#line 2003
    size = (((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 2007
    tmp___8 = ngx_array_push_n(params->values, size);
#line 2007
    copy = (ngx_http_script_copy_code_t *)tmp___8;
    }
#line 2008
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 2009
      return ((ngx_int_t )-1);
    }
    {
#line 2012
    copy->code = & ngx_http_script_copy_code;
#line 2013
    copy->len = (src + i)->key.len;
#line 2015
    p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 2016
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(src + i)->key.data,
           (src + i)->key.len);
#line 2019
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 2021
    sc.cf = cf;
#line 2022
    sc.source = & (src + i)->value;
#line 2023
    sc.flushes = & params->flushes;
#line 2024
    sc.lengths = & params->lengths;
#line 2025
    sc.values = & params->values;
#line 2027
    tmp___9 = ngx_http_script_compile(& sc);
    }
#line 2027
    if (tmp___9 != 0L) {
#line 2028
      return ((ngx_int_t )-1);
    }
    {
#line 2031
    tmp___10 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 2031
    code = (uintptr_t *)tmp___10;
    }
#line 2032
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 2033
      return ((ngx_int_t )-1);
    }
    {
#line 2036
    *code = (uintptr_t )((void *)0);
#line 2039
    tmp___11 = ngx_array_push_n(params->values, sizeof(uintptr_t ));
#line 2039
    code = (uintptr_t *)tmp___11;
    }
#line 2040
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 2041
      return ((ngx_int_t )-1);
    }
#line 2044
    *code = (uintptr_t )((void *)0);
    __Cont: /* CIL Label */ 
#line 1964
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2047
  tmp___12 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 2047
  code = (uintptr_t *)tmp___12;
  }
#line 2048
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 2049
    return ((ngx_int_t )-1);
  }
  {
#line 2052
  *code = (uintptr_t )((void *)0);
#line 2054
  params->number = headers_names.nelts;
#line 2056
  hash.hash = & params->hash;
#line 2057
  hash.key = & ngx_hash_key_lc;
#line 2058
  hash.max_size = (ngx_uint_t )512;
#line 2059
  hash.bucket_size = (ngx_uint_t )64;
#line 2060
  hash.name = (char *)"uwsgi_params_hash";
#line 2061
  hash.pool = cf->pool;
#line 2062
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2064
  tmp___13 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_names.elts, headers_names.nelts);
  }
#line 2064
  return (tmp___13);
}
}
#line 2068 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  size_t add ;
  ngx_url_t u ;
  ngx_str_t *value ;
  ngx_str_t *url ;
  ngx_uint_t n ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 2071
  uwcf = (ngx_http_uwsgi_loc_conf_t *)conf;
#line 2080
  if (uwcf->upstream.upstream) {
#line 2081
    return ((char *)"is duplicate");
  } else
#line 2080
  if (uwcf->uwsgi_lengths) {
#line 2081
    return ((char *)"is duplicate");
  }
  {
#line 2084
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 2085
  clcf->handler = & ngx_http_uwsgi_handler;
#line 2087
  value = (ngx_str_t *)(cf->args)->elts;
#line 2089
  url = value + 1;
#line 2091
  n = ngx_http_script_variables_count(url);
  }
#line 2093
  if (n) {
    {
#line 2095
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 2097
    sc.cf = cf;
#line 2098
    sc.source = url;
#line 2099
    sc.lengths = & uwcf->uwsgi_lengths;
#line 2100
    sc.values = & uwcf->uwsgi_values;
#line 2101
    sc.variables = n;
#line 2102
    sc.complete_lengths = 1U;
#line 2103
    sc.complete_values = 1U;
#line 2105
    tmp = ngx_http_script_compile(& sc);
    }
#line 2105
    if (tmp != 0L) {
#line 2106
      return ((char *)((void *)-1));
    }
#line 2113
    return ((char *)((void *)0));
  }
  {
#line 2116
  tmp___1 = ngx_strncasecmp(url->data, (u_char *)"uwsgi://", (size_t )8);
  }
#line 2116
  if (tmp___1 == 0L) {
#line 2117
    add = (size_t )8;
  } else {
    {
#line 2119
    tmp___0 = ngx_strncasecmp(url->data, (u_char *)"suwsgi://", (size_t )9);
    }
#line 2119
    if (tmp___0 == 0L) {
      {
#line 2125
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "suwsgi protocol requires SSL support");
      }
#line 2127
      return ((char *)((void *)-1));
    } else {
#line 2131
      add = (size_t )0;
    }
  }
  {
#line 2134
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 2136
  u.url.len = url->len - add;
#line 2137
  u.url.data = url->data + add;
#line 2138
  u.no_resolve = 1U;
#line 2140
  uwcf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 2141
  if ((unsigned long )uwcf->upstream.upstream == (unsigned long )((void *)0)) {
#line 2142
    return ((char *)((void *)-1));
  }
#line 2145
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 2146
    clcf->auto_redirect = 1U;
  }
#line 2149
  return ((char *)((void *)0));
}
}
#line 2153 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  ngx_str_t *value ;
  ngx_http_script_compile_t sc ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2156
  uwcf = (ngx_http_uwsgi_loc_conf_t *)conf;
#line 2161
  if (uwcf->upstream.store != -1) {
#line 2162
    return ((char *)"is duplicate");
  }
  {
#line 2165
  value = (ngx_str_t *)(cf->args)->elts;
#line 2167
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 2167
  if (tmp == 0) {
#line 2168
    uwcf->upstream.store = 0;
#line 2169
    return ((char *)((void *)0));
  }
#line 2174
  if (uwcf->upstream.cache > 0) {
#line 2175
    return ((char *)"is incompatible with \"uwsgi_cache\"");
  }
  {
#line 2180
  uwcf->upstream.store = 1;
#line 2182
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 2182
  if (tmp___0 == 0) {
#line 2183
    return ((char *)((void *)0));
  }
  {
#line 2187
  ((value + 1)->len) ++;
#line 2189
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 2191
  sc.cf = cf;
#line 2192
  sc.source = value + 1;
#line 2193
  sc.lengths = & uwcf->upstream.store_lengths;
#line 2194
  sc.values = & uwcf->upstream.store_values;
#line 2195
  sc.variables = ngx_http_script_variables_count(value + 1);
#line 2196
  sc.complete_lengths = 1U;
#line 2197
  sc.complete_values = 1U;
#line 2199
  tmp___1 = ngx_http_script_compile(& sc);
  }
#line 2199
  if (tmp___1 != 0L) {
#line 2200
    return ((char *)((void *)-1));
  }
#line 2203
  return ((char *)((void *)0));
}
}
#line 2209 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 2212
  uwcf = (ngx_http_uwsgi_loc_conf_t *)conf;
#line 2218
  value = (ngx_str_t *)(cf->args)->elts;
#line 2220
  if (uwcf->upstream.cache != -1) {
#line 2221
    return ((char *)"is duplicate");
  }
  {
#line 2224
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 2224
  if (tmp == 0) {
#line 2225
    uwcf->upstream.cache = 0;
#line 2226
    return ((char *)((void *)0));
  }
#line 2229
  if (uwcf->upstream.store > 0) {
#line 2230
    return ((char *)"is incompatible with \"uwsgi_store\"");
  }
  {
#line 2233
  uwcf->upstream.cache = 1;
#line 2235
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 2237
  ccv.cf = cf;
#line 2238
  ccv.value = value + 1;
#line 2239
  ccv.complex_value = & cv;
#line 2241
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 2241
  if (tmp___0 != 0L) {
#line 2242
    return ((char *)((void *)-1));
  }
#line 2245
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 2247
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 2247
    uwcf->upstream.cache_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 2249
    if ((unsigned long )uwcf->upstream.cache_value == (unsigned long )((void *)0)) {
#line 2250
      return ((char *)((void *)-1));
    }
#line 2253
    *(uwcf->upstream.cache_value) = cv;
#line 2255
    return ((char *)((void *)0));
  }
  {
#line 2258
  uwcf->upstream.cache_zone = ngx_shared_memory_add(cf, value + 1, (size_t )0, (void *)(& ngx_http_uwsgi_module));
  }
#line 2260
  if ((unsigned long )uwcf->upstream.cache_zone == (unsigned long )((void *)0)) {
#line 2261
    return ((char *)((void *)-1));
  }
#line 2264
  return ((char *)((void *)0));
}
}
#line 2268 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_uwsgi_module.c"
static char *ngx_http_uwsgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_uwsgi_loc_conf_t *uwcf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;

  {
#line 2271
  uwcf = (ngx_http_uwsgi_loc_conf_t *)conf;
#line 2276
  value = (ngx_str_t *)(cf->args)->elts;
#line 2278
  if (uwcf->cache_key.value.data) {
#line 2279
    return ((char *)"is duplicate");
  }
  {
#line 2282
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 2284
  ccv.cf = cf;
#line 2285
  ccv.value = value + 1;
#line 2286
  ccv.complex_value = & uwcf->cache_key;
#line 2288
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 2288
  if (tmp != 0L) {
#line 2289
    return ((char *)((void *)-1));
  }
#line 2292
  return ((char *)((void *)0));
}
}
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 162 "src/core/ngx_string.h"
u_char *ngx_strnstr(u_char *s1 , char *s2 , size_t len ) ;
#line 158 "src/core/ngx_buf.h"
ngx_int_t ngx_chain_writer(void *data , ngx_chain_t *in ) ;
#line 163
void ngx_chain_update_chains(ngx_pool_t *p , ngx_chain_t **free___0 , ngx_chain_t **busy ,
                             ngx_chain_t **out , ngx_buf_tag_t tag ) ;
#line 573 "/home/khheo/.linuxbrew/include/pcre.h"
extern int pcre_exec(pcre const   * , pcre_extra const   * , char const   * , int  ,
                     int  , int  , int * , int  ) ;
#line 50 "src/core/ngx_regex.h"
ngx_int_t ngx_regex_compile(ngx_regex_compile_t *rc ) ;
#line 104 "src/event/ngx_event_pipe.h"
ngx_int_t ngx_event_pipe_add_free_buf(ngx_event_pipe_t *p , ngx_buf_t *b ) ;
#line 147 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_eval(ngx_http_request_t *r , ngx_http_fastcgi_loc_conf_t *flcf ) ;
#line 150
static ngx_int_t ngx_http_fastcgi_create_key(ngx_http_request_t *r ) ;
#line 152
static ngx_int_t ngx_http_fastcgi_create_request(ngx_http_request_t *r ) ;
#line 153
static ngx_int_t ngx_http_fastcgi_reinit_request(ngx_http_request_t *r ) ;
#line 154
static ngx_int_t ngx_http_fastcgi_body_output_filter(void *data , ngx_chain_t *in ) ;
#line 156
static ngx_int_t ngx_http_fastcgi_process_header(ngx_http_request_t *r ) ;
#line 157
static ngx_int_t ngx_http_fastcgi_input_filter_init(void *data ) ;
#line 158
static ngx_int_t ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
#line 160
static ngx_int_t ngx_http_fastcgi_non_buffered_filter(void *data , ssize_t bytes ) ;
#line 162
static ngx_int_t ngx_http_fastcgi_process_record(ngx_http_request_t *r , ngx_http_fastcgi_ctx_t *f ) ;
#line 164
static void ngx_http_fastcgi_abort_request(ngx_http_request_t *r ) ;
#line 165
static void ngx_http_fastcgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 168
static ngx_int_t ngx_http_fastcgi_add_variables(ngx_conf_t *cf ) ;
#line 169
static void *ngx_http_fastcgi_create_main_conf(ngx_conf_t *cf ) ;
#line 170
static void *ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf ) ;
#line 171
static char *ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 173
static ngx_int_t ngx_http_fastcgi_init_params(ngx_conf_t *cf , ngx_http_fastcgi_loc_conf_t *conf ,
                                              ngx_http_fastcgi_params_t *params ,
                                              ngx_keyval_t *default_params ) ;
#line 177
static ngx_int_t ngx_http_fastcgi_script_name_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 179
static ngx_int_t ngx_http_fastcgi_path_info_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) ;
#line 181
static ngx_http_fastcgi_ctx_t *ngx_http_fastcgi_split(ngx_http_request_t *r , ngx_http_fastcgi_loc_conf_t *flcf ) ;
#line 184
static char *ngx_http_fastcgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 186
static char *ngx_http_fastcgi_split_path_info(ngx_conf_t *cf , ngx_command_t *cmd ,
                                              void *conf ) ;
#line 188
static char *ngx_http_fastcgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 191
static char *ngx_http_fastcgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 193
static char *ngx_http_fastcgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 197
static char *ngx_http_fastcgi_lowat_check(ngx_conf_t *cf , void *post , void *data ) ;
#line 201 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_conf_post_t ngx_http_fastcgi_lowat_post  =    {& ngx_http_fastcgi_lowat_check};
#line 205 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_conf_bitmask_t ngx_http_fastcgi_next_upstream_masks[12]  = 
#line 205
  {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_header") - 1UL, (u_char *)"invalid_header"}, (ngx_uint_t )8}, 
        {{sizeof("non_idempotent") - 1UL,
       (u_char *)"non_idempotent"}, (ngx_uint_t )16384}, 
        {{sizeof("http_500") - 1UL, (u_char *)"http_500"}, (ngx_uint_t )16}, 
        {{sizeof("http_503") - 1UL, (u_char *)"http_503"}, (ngx_uint_t )64}, 
        {{sizeof("http_403") - 1UL, (u_char *)"http_403"}, (ngx_uint_t )256}, 
        {{sizeof("http_404") - 1UL, (u_char *)"http_404"}, (ngx_uint_t )512}, 
        {{sizeof("http_429") - 1UL, (u_char *)"http_429"}, (ngx_uint_t )1024}, 
        {{sizeof("updating") - 1UL, (u_char *)"updating"}, (ngx_uint_t )2048}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 224 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_command_t ngx_http_fastcgi_commands[49]  = 
#line 224
  {      {{sizeof("fastcgi_pass") - 1UL, (u_char *)"fastcgi_pass"}, (ngx_uint_t )1207959554,
      & ngx_http_fastcgi_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_index") - 1UL, (u_char *)"fastcgi_index"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->index), (void *)0}, 
        {{sizeof("fastcgi_split_path_info") - 1UL, (u_char *)"fastcgi_split_path_info"},
      (ngx_uint_t )234881026, & ngx_http_fastcgi_split_path_info, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_store") - 1UL, (u_char *)"fastcgi_store"}, (ngx_uint_t )234881026,
      & ngx_http_fastcgi_store, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_store_access") - 1UL, (u_char *)"fastcgi_store_access"}, (ngx_uint_t )234881038,
      & ngx_conf_set_access_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.store_access),
      (void *)0}, 
        {{sizeof("fastcgi_buffering") - 1UL, (u_char *)"fastcgi_buffering"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.buffering),
      (void *)0}, 
        {{sizeof("fastcgi_request_buffering") - 1UL, (u_char *)"fastcgi_request_buffering"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.request_buffering),
      (void *)0}, 
        {{sizeof("fastcgi_ignore_client_abort") - 1UL, (u_char *)"fastcgi_ignore_client_abort"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.ignore_client_abort),
      (void *)0}, 
        {{sizeof("fastcgi_bind") - 1UL, (u_char *)"fastcgi_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("fastcgi_connect_timeout") - 1UL,
       (u_char *)"fastcgi_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_send_timeout") - 1UL, (u_char *)"fastcgi_send_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_send_lowat") - 1UL, (u_char *)"fastcgi_send_lowat"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.send_lowat),
      (void *)(& ngx_http_fastcgi_lowat_post)}, 
        {{sizeof("fastcgi_buffer_size") - 1UL, (u_char *)"fastcgi_buffer_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.buffer_size),
      (void *)0}, 
        {{sizeof("fastcgi_pass_request_headers") - 1UL, (u_char *)"fastcgi_pass_request_headers"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.pass_request_headers),
      (void *)0}, 
        {{sizeof("fastcgi_pass_request_body") - 1UL, (u_char *)"fastcgi_pass_request_body"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.pass_request_body),
      (void *)0}, 
        {{sizeof("fastcgi_intercept_errors") - 1UL, (u_char *)"fastcgi_intercept_errors"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.intercept_errors),
      (void *)0}, 
        {{sizeof("fastcgi_read_timeout") - 1UL, (u_char *)"fastcgi_read_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_buffers") - 1UL, (u_char *)"fastcgi_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.bufs), (void *)0}, 
        {{sizeof("fastcgi_busy_buffers_size") - 1UL,
       (u_char *)"fastcgi_busy_buffers_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.busy_buffers_size_conf),
      (void *)0}, 
        {{sizeof("fastcgi_force_ranges") - 1UL, (u_char *)"fastcgi_force_ranges"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.force_ranges),
      (void *)0}, 
        {{sizeof("fastcgi_limit_rate") - 1UL, (u_char *)"fastcgi_limit_rate"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.limit_rate),
      (void *)0}, 
        {{sizeof("fastcgi_cache") - 1UL, (u_char *)"fastcgi_cache"}, (ngx_uint_t )234881026,
      & ngx_http_fastcgi_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_cache_key") - 1UL, (u_char *)"fastcgi_cache_key"}, (ngx_uint_t )234881026,
      & ngx_http_fastcgi_cache_key, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("fastcgi_cache_path") - 1UL, (u_char *)"fastcgi_cache_path"}, (ngx_uint_t )33558528,
      & ngx_http_file_cache_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_fastcgi_main_conf_t *)0)->caches), (void *)(& ngx_http_fastcgi_module)}, 
        {{sizeof("fastcgi_cache_bypass") - 1UL,
       (u_char *)"fastcgi_cache_bypass"}, (ngx_uint_t )234883072, & ngx_http_set_predicate_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_bypass),
      (void *)0}, 
        {{sizeof("fastcgi_no_cache") - 1UL, (u_char *)"fastcgi_no_cache"}, (ngx_uint_t )234883072,
      & ngx_http_set_predicate_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.no_cache), (void *)0}, 
        {{sizeof("fastcgi_cache_valid") - 1UL,
       (u_char *)"fastcgi_cache_valid"}, (ngx_uint_t )234883072, & ngx_http_file_cache_valid_set_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_valid),
      (void *)0}, 
        {{sizeof("fastcgi_cache_min_uses") - 1UL, (u_char *)"fastcgi_cache_min_uses"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_min_uses),
      (void *)0}, 
        {{sizeof("fastcgi_cache_max_range_offset") - 1UL, (u_char *)"fastcgi_cache_max_range_offset"},
      (ngx_uint_t )234881026, & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_max_range_offset),
      (void *)0}, 
        {{sizeof("fastcgi_cache_use_stale") - 1UL, (u_char *)"fastcgi_cache_use_stale"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_use_stale),
      (void *)(& ngx_http_fastcgi_next_upstream_masks)}, 
        {{sizeof("fastcgi_cache_methods") - 1UL, (u_char *)"fastcgi_cache_methods"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_methods),
      (void *)(& ngx_http_upstream_cache_method_mask)}, 
        {{sizeof("fastcgi_cache_lock") - 1UL, (u_char *)"fastcgi_cache_lock"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_lock),
      (void *)0}, 
        {{sizeof("fastcgi_cache_lock_timeout") - 1UL, (u_char *)"fastcgi_cache_lock_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_lock_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_cache_lock_age") - 1UL, (u_char *)"fastcgi_cache_lock_age"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_lock_age),
      (void *)0}, 
        {{sizeof("fastcgi_cache_revalidate") - 1UL, (u_char *)"fastcgi_cache_revalidate"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_revalidate),
      (void *)0}, 
        {{sizeof("fastcgi_cache_background_update") - 1UL, (u_char *)"fastcgi_cache_background_update"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.cache_background_update),
      (void *)0}, 
        {{sizeof("fastcgi_temp_path") - 1UL, (u_char *)"fastcgi_temp_path"}, (ngx_uint_t )234881054,
      & ngx_conf_set_path_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.temp_path),
      (void *)0}, 
        {{sizeof("fastcgi_max_temp_file_size") - 1UL, (u_char *)"fastcgi_max_temp_file_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.max_temp_file_size_conf),
      (void *)0}, 
        {{sizeof("fastcgi_temp_file_write_size") - 1UL, (u_char *)"fastcgi_temp_file_write_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.temp_file_write_size_conf),
      (void *)0}, 
        {{sizeof("fastcgi_next_upstream") - 1UL, (u_char *)"fastcgi_next_upstream"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_fastcgi_next_upstream_masks)}, 
        {{sizeof("fastcgi_next_upstream_tries") - 1UL, (u_char *)"fastcgi_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("fastcgi_next_upstream_timeout") - 1UL, (u_char *)"fastcgi_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("fastcgi_param") - 1UL, (u_char *)"fastcgi_param"}, (ngx_uint_t )234881036,
      & ngx_http_upstream_param_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->params_source), (void *)0}, 
        {{sizeof("fastcgi_pass_header") - 1UL,
       (u_char *)"fastcgi_pass_header"}, (ngx_uint_t )234881026, & ngx_conf_set_str_array_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.pass_headers),
      (void *)0}, 
        {{sizeof("fastcgi_hide_header") - 1UL, (u_char *)"fastcgi_hide_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.hide_headers),
      (void *)0}, 
        {{sizeof("fastcgi_ignore_headers") - 1UL, (u_char *)"fastcgi_ignore_headers"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->upstream.ignore_headers),
      (void *)(& ngx_http_upstream_ignore_headers_masks)}, 
        {{sizeof("fastcgi_catch_stderr") - 1UL, (u_char *)"fastcgi_catch_stderr"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->catch_stderr), (void *)0}, 
        {{sizeof("fastcgi_keep_conn") - 1UL,
       (u_char *)"fastcgi_keep_conn"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_fastcgi_loc_conf_t *)0)->keep_conn),
      (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 570 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_http_module_t ngx_http_fastcgi_module_ctx  = 
#line 570
     {& ngx_http_fastcgi_add_variables, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_fastcgi_create_main_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_fastcgi_create_loc_conf, & ngx_http_fastcgi_merge_loc_conf};
#line 585 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
ngx_module_t ngx_http_fastcgi_module  = 
#line 585
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_fastcgi_module_ctx),
    ngx_http_fastcgi_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 601 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_http_fastcgi_request_start_t ngx_http_fastcgi_request_start  =    {{(u_char )1, (u_char )1, (u_char )0, (u_char )1, (u_char )0, (u_char )sizeof(ngx_http_fastcgi_begin_request_t ),
     (u_char )0, (u_char )0}, {(u_char )0, (u_char )1, (u_char )0, {(u_char )0, (u_char )0,
                                                                    (u_char )0, (u_char )0,
                                                                    (u_char )0}},
    {(u_char )1, (u_char )4, (u_char )0, (u_char )1}};
#line 624 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_http_variable_t ngx_http_fastcgi_vars[3]  = {      {{sizeof("fastcgi_script_name") - 1UL, (u_char *)"fastcgi_script_name"}, (void (*)(ngx_http_request_t *r ,
                                                                                        ngx_http_variable_value_t *v ,
                                                                                        uintptr_t data ))((void *)0),
      & ngx_http_fastcgi_script_name_variable, (uintptr_t )0, (ngx_uint_t )10, (ngx_uint_t )0}, 
        {{sizeof("fastcgi_path_info") - 1UL,
       (u_char *)"fastcgi_path_info"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ))((void *)0), & ngx_http_fastcgi_path_info_variable,
      (uintptr_t )0, (ngx_uint_t )10, (ngx_uint_t )0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 638 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_str_t ngx_http_fastcgi_hide_headers[7]  = {      {sizeof("Status") - 1UL, (u_char *)"Status"}, 
        {sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, 
        {sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, 
        {sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, 
        {sizeof("X-Accel-Buffering") - 1UL, (u_char *)"X-Accel-Buffering"}, 
        {sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, 
        {(size_t )0, (u_char *)((void *)0)}};
#line 651 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_keyval_t ngx_http_fastcgi_cache_headers[7]  = {      {{sizeof("HTTP_IF_MODIFIED_SINCE") - 1UL, (u_char *)"HTTP_IF_MODIFIED_SINCE"},
      {sizeof("$upstream_cache_last_modified") - 1UL, (u_char *)"$upstream_cache_last_modified"}}, 
        {{sizeof("HTTP_IF_UNMODIFIED_SINCE") - 1UL,
       (u_char *)"HTTP_IF_UNMODIFIED_SINCE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_NONE_MATCH") - 1UL, (u_char *)"HTTP_IF_NONE_MATCH"}, {sizeof("$upstream_cache_etag") - 1UL,
                                                                             (u_char *)"$upstream_cache_etag"}}, 
        {{sizeof("HTTP_IF_MATCH") - 1UL,
       (u_char *)"HTTP_IF_MATCH"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_RANGE") - 1UL, (u_char *)"HTTP_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("HTTP_IF_RANGE") - 1UL,
       (u_char *)"HTTP_IF_RANGE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t )0, (u_char *)((void *)0)}, {(size_t )0, (u_char *)((void *)0)}}};
#line 665 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_path_init_t ngx_http_fastcgi_temp_path  =    {{sizeof("fastcgi_temp") - 1UL, (u_char *)"fastcgi_temp"}, {(size_t )1, (size_t )2,
                                                               (size_t )0}};
#line 670 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_upstream_t *u ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_http_fastcgi_main_conf_t *fmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 681
  tmp = ngx_http_upstream_create(r);
  }
#line 681
  if (tmp != 0L) {
#line 682
    return ((ngx_int_t )500);
  }
  {
#line 685
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_fastcgi_ctx_t ));
#line 685
  f = (ngx_http_fastcgi_ctx_t *)tmp___0;
  }
#line 686
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 687
    return ((ngx_int_t )500);
  }
#line 690
  *(r->ctx + ngx_http_fastcgi_module.ctx_index) = (void *)f;
#line 692
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 694
  if (flcf->fastcgi_lengths) {
    {
#line 695
    tmp___1 = ngx_http_fastcgi_eval(r, flcf);
    }
#line 695
    if (tmp___1 != 0L) {
#line 696
      return ((ngx_int_t )500);
    }
  }
  {
#line 700
  u = r->upstream;
#line 702
  u->schema.len = sizeof("fastcgi://") - 1UL;
#line 702
  u->schema.data = (u_char *)"fastcgi://";
#line 703
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_fastcgi_module);
#line 705
  u->conf = & flcf->upstream;
#line 708
  fmcf = (ngx_http_fastcgi_main_conf_t *)*(r->main_conf + ngx_http_fastcgi_module.ctx_index);
#line 710
  u->caches = & fmcf->caches;
#line 711
  u->create_key = & ngx_http_fastcgi_create_key;
#line 714
  u->create_request = & ngx_http_fastcgi_create_request;
#line 715
  u->reinit_request = & ngx_http_fastcgi_reinit_request;
#line 716
  u->process_header = & ngx_http_fastcgi_process_header;
#line 717
  u->abort_request = & ngx_http_fastcgi_abort_request;
#line 718
  u->finalize_request = & ngx_http_fastcgi_finalize_request;
#line 719
  r->state = (ngx_uint_t )0;
#line 721
  u->buffering = (unsigned int )flcf->upstream.buffering;
#line 723
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t ));
#line 723
  u->pipe = (ngx_event_pipe_t *)tmp___2;
  }
#line 724
  if ((unsigned long )u->pipe == (unsigned long )((void *)0)) {
#line 725
    return ((ngx_int_t )500);
  }
#line 728
  (u->pipe)->input_filter = & ngx_http_fastcgi_input_filter;
#line 729
  (u->pipe)->input_ctx = (void *)r;
#line 731
  u->input_filter_init = & ngx_http_fastcgi_input_filter_init;
#line 732
  u->input_filter = & ngx_http_fastcgi_non_buffered_filter;
#line 733
  u->input_filter_ctx = (void *)r;
#line 735
  if (! flcf->upstream.request_buffering) {
#line 735
    if (flcf->upstream.pass_request_body) {
#line 738
      r->request_body_no_buffering = 1U;
    }
  }
  {
#line 741
  rc = ngx_http_read_client_request_body(r, & ngx_http_upstream_init);
  }
#line 743
  if (rc >= 300L) {
#line 744
    return (rc);
  }
#line 747
  return ((ngx_int_t )-4);
}
}
#line 751 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_eval(ngx_http_request_t *r , ngx_http_fastcgi_loc_conf_t *flcf ) 
{ 
  ngx_url_t url ;
  ngx_http_upstream_t *u ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 757
  memset((void *)(& url), 0, sizeof(ngx_url_t ));
#line 759
  tmp = ngx_http_script_run(r, & url.url, (flcf->fastcgi_lengths)->elts, (size_t )0,
                            (flcf->fastcgi_values)->elts);
  }
#line 759
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 763
    return ((ngx_int_t )-1);
  }
  {
#line 766
  url.no_resolve = 1U;
#line 768
  tmp___0 = ngx_parse_url(r->pool, & url);
  }
#line 768
  if (tmp___0 != 0L) {
#line 769
    if (url.err) {
#line 770
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 770
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%s in upstream \"%V\"",
                           url.err, & url.url);
        }
      }
    }
#line 774
    return ((ngx_int_t )-1);
  }
  {
#line 777
  u = r->upstream;
#line 779
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t ));
#line 779
  u->resolved = (ngx_http_upstream_resolved_t *)tmp___1;
  }
#line 780
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 781
    return ((ngx_int_t )-1);
  }
#line 784
  if (url.addrs) {
#line 785
    (u->resolved)->sockaddr = (url.addrs + 0)->sockaddr;
#line 786
    (u->resolved)->socklen = (url.addrs + 0)->socklen;
#line 787
    (u->resolved)->name = (url.addrs + 0)->name;
#line 788
    (u->resolved)->naddrs = (ngx_uint_t )1;
  }
#line 791
  (u->resolved)->host = url.host;
#line 792
  (u->resolved)->port = url.port;
#line 793
  (u->resolved)->no_port = (ngx_uint_t )url.no_port;
#line 795
  return ((ngx_int_t )0);
}
}
#line 801 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_create_key(ngx_http_request_t *r ) 
{ 
  ngx_str_t *key ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 807
  tmp = ngx_array_push(& (r->cache)->keys);
#line 807
  key = (ngx_str_t *)tmp;
  }
#line 808
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 809
    return ((ngx_int_t )-1);
  }
  {
#line 812
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 814
  tmp___0 = ngx_http_complex_value(r, & flcf->cache_key, key);
  }
#line 814
  if (tmp___0 != 0L) {
#line 815
    return ((ngx_int_t )-1);
  }
#line 818
  return ((ngx_int_t )0);
}
}
#line 824 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_create_request(ngx_http_request_t *r ) 
{ 
  off_t file_pos ;
  u_char ch ;
  u_char *pos ;
  u_char *lowcase_key ;
  size_t size ;
  size_t len ;
  size_t key_len ;
  size_t val_len ;
  size_t padding ;
  size_t allocated ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t next ;
  ngx_uint_t hash ;
  ngx_uint_t skip_empty ;
  ngx_uint_t header_params ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *body ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_table_elt_t **ignored ;
  ngx_http_upstream_t *u ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_script_engine_t le ;
  ngx_http_fastcgi_header_t *h ;
  ngx_http_fastcgi_params_t *params ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ngx_uint_t tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  u_char *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  u_char *tmp___23 ;
  u_char *tmp___24 ;
  void *tmp___25 ;
  u_char *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;

  {
#line 844
  len = (size_t )0;
#line 845
  header_params = (ngx_uint_t )0;
#line 846
  ignored = (ngx_table_elt_t **)((void *)0);
#line 848
  u = r->upstream;
#line 850
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 853
  if (u->cacheable) {
#line 853
    params = & flcf->params_cache;
  } else {
#line 853
    params = & flcf->params;
  }
#line 858
  if (params->lengths) {
    {
#line 859
    memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 861
    ngx_http_script_flush_no_cacheable_variables(r, params->flushes);
#line 862
    le.flushed = 1U;
#line 864
    le.ip = (u_char *)(params->lengths)->elts;
#line 865
    le.request = r;
    }
    {
#line 867
    while (1) {
      while_continue: /* CIL Label */ ;
#line 867
      if (! *((uintptr_t *)le.ip)) {
#line 867
        goto while_break;
      }
      {
#line 869
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 870
      key_len = (*lcode)(& le);
#line 872
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 873
      skip_empty = (*lcode)(& le);
#line 875
      val_len = (size_t )0;
      }
      {
#line 875
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 875
        if (! *((uintptr_t *)le.ip)) {
#line 875
          goto while_break___0;
        }
        {
#line 876
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 875
        tmp = (*lcode)(& le);
#line 875
        val_len += tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 878
      le.ip += sizeof(uintptr_t );
#line 880
      if (skip_empty) {
#line 880
        if (val_len == 0UL) {
#line 881
          goto while_continue;
        }
      }
#line 884
      if (val_len > 127UL) {
#line 884
        tmp___0 = 4;
      } else {
#line 884
        tmp___0 = 1;
      }
#line 884
      len += ((1UL + key_len) + (size_t )tmp___0) + val_len;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 888
  if (flcf->upstream.pass_request_headers) {
#line 890
    allocated = (size_t )0;
#line 891
    lowcase_key = (u_char *)((void *)0);
#line 893
    if (params->number) {
#line 894
      n = (ngx_uint_t )0;
#line 895
      part = & r->headers_in.headers.part;
      {
#line 897
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 897
        if (! part) {
#line 897
          goto while_break___1;
        }
#line 898
        n += part->nelts;
#line 899
        part = part->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 902
      tmp___1 = ngx_palloc(r->pool, n * sizeof(void *));
#line 902
      ignored = (ngx_table_elt_t **)tmp___1;
      }
#line 903
      if ((unsigned long )ignored == (unsigned long )((void *)0)) {
#line 904
        return ((ngx_int_t )-1);
      }
    }
#line 908
    part = & r->headers_in.headers.part;
#line 909
    header___0 = (ngx_table_elt_t *)part->elts;
#line 911
    i = (ngx_uint_t )0;
    {
#line 911
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 913
      if (i >= part->nelts) {
#line 914
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 915
          goto while_break___2;
        }
#line 918
        part = part->next;
#line 919
        header___0 = (ngx_table_elt_t *)part->elts;
#line 920
        i = (ngx_uint_t )0;
      }
#line 923
      if (params->number) {
#line 924
        if (allocated < (header___0 + i)->key.len) {
          {
#line 925
          allocated = (header___0 + i)->key.len + 16UL;
#line 926
          tmp___2 = ngx_pnalloc(r->pool, allocated);
#line 926
          lowcase_key = (u_char *)tmp___2;
          }
#line 927
          if ((unsigned long )lowcase_key == (unsigned long )((void *)0)) {
#line 928
            return ((ngx_int_t )-1);
          }
        }
#line 932
        hash = (ngx_uint_t )0;
#line 934
        n = (ngx_uint_t )0;
        {
#line 934
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 934
          if (! (n < (header___0 + i)->key.len)) {
#line 934
            goto while_break___3;
          }
#line 935
          ch = *((header___0 + i)->key.data + n);
#line 937
          if ((int )ch >= 65) {
#line 937
            if ((int )ch <= 90) {
#line 938
              ch = (u_char )((int )ch | 32);
            } else {
#line 937
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 940
          if ((int )ch == 45) {
#line 941
            ch = (u_char )'_';
          }
#line 944
          hash = hash * 31UL + (ngx_uint_t )ch;
#line 945
          *(lowcase_key + n) = ch;
#line 934
          n ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 948
        tmp___4 = ngx_hash_find(& params->hash, hash, lowcase_key, n);
        }
#line 948
        if (tmp___4) {
#line 949
          tmp___3 = header_params;
#line 949
          header_params ++;
#line 949
          *(ignored + tmp___3) = header___0 + i;
#line 950
          goto __Cont;
        }
#line 953
        n += sizeof("HTTP_") - 1UL;
      } else {
#line 956
        n = (sizeof("HTTP_") - 1UL) + (header___0 + i)->key.len;
      }
#line 959
      if (n > 127UL) {
#line 959
        tmp___5 = 4;
      } else {
#line 959
        tmp___5 = 1;
      }
#line 959
      if ((header___0 + i)->value.len > 127UL) {
#line 959
        tmp___6 = 4;
      } else {
#line 959
        tmp___6 = 1;
      }
#line 959
      len += ((ngx_uint_t )(tmp___5 + tmp___6) + n) + (header___0 + i)->value.len;
      __Cont: /* CIL Label */ 
#line 911
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 965
  if (len > 65535UL) {
#line 966
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 966
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "fastcgi request record is too big: %uz",
                         len);
      }
    }
#line 968
    return ((ngx_int_t )-1);
  }
#line 972
  padding = 8UL - len % 8UL;
#line 973
  if (padding == 8UL) {
#line 973
    padding = (size_t )0;
  } else {
#line 973
    padding = padding;
  }
  {
#line 976
  size = (((((sizeof(ngx_http_fastcgi_header_t ) + sizeof(ngx_http_fastcgi_begin_request_t )) + sizeof(ngx_http_fastcgi_header_t )) + len) + padding) + sizeof(ngx_http_fastcgi_header_t )) + sizeof(ngx_http_fastcgi_header_t );
#line 986
  b = ngx_create_temp_buf(r->pool, size);
  }
#line 987
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 988
    return ((ngx_int_t )-1);
  }
  {
#line 991
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 992
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 993
    return ((ngx_int_t )-1);
  }
#line 996
  cl->buf = b;
#line 998
  if (flcf->keep_conn) {
#line 998
    ngx_http_fastcgi_request_start.br.flags = (u_char )1;
  } else {
#line 998
    ngx_http_fastcgi_request_start.br.flags = (u_char )0;
  }
  {
#line 1001
  memcpy((void */* __restrict  */)b->pos, (void const   */* __restrict  */)(& ngx_http_fastcgi_request_start),
         sizeof(ngx_http_fastcgi_request_start_t ));
#line 1004
  h = (ngx_http_fastcgi_header_t *)((b->pos + sizeof(ngx_http_fastcgi_header_t )) + sizeof(ngx_http_fastcgi_begin_request_t ));
#line 1008
  h->content_length_hi = (u_char )((len >> 8) & 255UL);
#line 1009
  h->content_length_lo = (u_char )(len & 255UL);
#line 1010
  h->padding_length = (u_char )padding;
#line 1011
  h->reserved = (u_char )0;
#line 1013
  b->last = ((b->pos + sizeof(ngx_http_fastcgi_header_t )) + sizeof(ngx_http_fastcgi_begin_request_t )) + sizeof(ngx_http_fastcgi_header_t );
  }
#line 1018
  if (params->lengths) {
    {
#line 1019
    memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 1021
    e.ip = (u_char *)(params->values)->elts;
#line 1022
    e.pos = b->last;
#line 1023
    e.request = r;
#line 1024
    e.flushed = 1U;
#line 1026
    le.ip = (u_char *)(params->lengths)->elts;
    }
    {
#line 1028
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1028
      if (! *((uintptr_t *)le.ip)) {
#line 1028
        goto while_break___4;
      }
      {
#line 1030
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1031
      tmp___7 = (*lcode)(& le);
#line 1031
      key_len = (size_t )((u_char )tmp___7);
#line 1033
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1034
      skip_empty = (*lcode)(& le);
#line 1036
      val_len = (size_t )0;
      }
      {
#line 1036
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1036
        if (! *((uintptr_t *)le.ip)) {
#line 1036
          goto while_break___5;
        }
        {
#line 1037
        lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1036
        tmp___8 = (*lcode)(& le);
#line 1036
        val_len += tmp___8;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1039
      le.ip += sizeof(uintptr_t );
#line 1041
      if (skip_empty) {
#line 1041
        if (val_len == 0UL) {
#line 1042
          e.skip = 1U;
          {
#line 1044
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 1044
            if (! *((uintptr_t *)e.ip)) {
#line 1044
              goto while_break___6;
            }
            {
#line 1045
            code = *((ngx_http_script_code_pt *)e.ip);
#line 1046
            (*code)(& e);
            }
          }
          while_break___6: /* CIL Label */ ;
          }
#line 1048
          e.ip += sizeof(uintptr_t );
#line 1050
          e.skip = 0U;
#line 1052
          goto while_continue___4;
        }
      }
#line 1055
      tmp___9 = e.pos;
#line 1055
      (e.pos) ++;
#line 1055
      *tmp___9 = (u_char )key_len;
#line 1057
      if (val_len > 127UL) {
#line 1058
        tmp___10 = e.pos;
#line 1058
        (e.pos) ++;
#line 1058
        *tmp___10 = (u_char )(((val_len >> 24) & 127UL) | 128UL);
#line 1059
        tmp___11 = e.pos;
#line 1059
        (e.pos) ++;
#line 1059
        *tmp___11 = (u_char )((val_len >> 16) & 255UL);
#line 1060
        tmp___12 = e.pos;
#line 1060
        (e.pos) ++;
#line 1060
        *tmp___12 = (u_char )((val_len >> 8) & 255UL);
#line 1061
        tmp___13 = e.pos;
#line 1061
        (e.pos) ++;
#line 1061
        *tmp___13 = (u_char )(val_len & 255UL);
      } else {
#line 1064
        tmp___14 = e.pos;
#line 1064
        (e.pos) ++;
#line 1064
        *tmp___14 = (u_char )val_len;
      }
      {
#line 1067
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 1067
        if (! *((uintptr_t *)e.ip)) {
#line 1067
          goto while_break___7;
        }
        {
#line 1068
        code = *((ngx_http_script_code_pt *)e.ip);
#line 1069
        (*code)(& e);
        }
      }
      while_break___7: /* CIL Label */ ;
      }
#line 1071
      e.ip += sizeof(uintptr_t );
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1079
    b->last = e.pos;
  }
#line 1083
  if (flcf->upstream.pass_request_headers) {
#line 1085
    part = & r->headers_in.headers.part;
#line 1086
    header___0 = (ngx_table_elt_t *)part->elts;
#line 1088
    i = (ngx_uint_t )0;
    {
#line 1088
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1090
      if (i >= part->nelts) {
#line 1091
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1092
          goto while_break___8;
        }
#line 1095
        part = part->next;
#line 1096
        header___0 = (ngx_table_elt_t *)part->elts;
#line 1097
        i = (ngx_uint_t )0;
      }
#line 1100
      n = (ngx_uint_t )0;
      {
#line 1100
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1100
        if (! (n < header_params)) {
#line 1100
          goto while_break___9;
        }
#line 1101
        if ((unsigned long )(header___0 + i) == (unsigned long )*(ignored + n)) {
#line 1102
          goto next;
        }
#line 1100
        n ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1106
      key_len = (sizeof("HTTP_") - 1UL) + (header___0 + i)->key.len;
#line 1107
      if (key_len > 127UL) {
#line 1108
        tmp___15 = b->last;
#line 1108
        (b->last) ++;
#line 1108
        *tmp___15 = (u_char )(((key_len >> 24) & 127UL) | 128UL);
#line 1109
        tmp___16 = b->last;
#line 1109
        (b->last) ++;
#line 1109
        *tmp___16 = (u_char )((key_len >> 16) & 255UL);
#line 1110
        tmp___17 = b->last;
#line 1110
        (b->last) ++;
#line 1110
        *tmp___17 = (u_char )((key_len >> 8) & 255UL);
#line 1111
        tmp___18 = b->last;
#line 1111
        (b->last) ++;
#line 1111
        *tmp___18 = (u_char )(key_len & 255UL);
      } else {
#line 1114
        tmp___19 = b->last;
#line 1114
        (b->last) ++;
#line 1114
        *tmp___19 = (u_char )key_len;
      }
#line 1117
      val_len = (header___0 + i)->value.len;
#line 1118
      if (val_len > 127UL) {
#line 1119
        tmp___20 = b->last;
#line 1119
        (b->last) ++;
#line 1119
        *tmp___20 = (u_char )(((val_len >> 24) & 127UL) | 128UL);
#line 1120
        tmp___21 = b->last;
#line 1120
        (b->last) ++;
#line 1120
        *tmp___21 = (u_char )((val_len >> 16) & 255UL);
#line 1121
        tmp___22 = b->last;
#line 1121
        (b->last) ++;
#line 1121
        *tmp___22 = (u_char )((val_len >> 8) & 255UL);
#line 1122
        tmp___23 = b->last;
#line 1122
        (b->last) ++;
#line 1122
        *tmp___23 = (u_char )(val_len & 255UL);
      } else {
#line 1125
        tmp___24 = b->last;
#line 1125
        (b->last) ++;
#line 1125
        *tmp___24 = (u_char )val_len;
      }
      {
#line 1128
      tmp___25 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"HTTP_",
                        sizeof("HTTP_") - 1UL);
#line 1128
      b->last = (u_char *)tmp___25 + (sizeof("HTTP_") - 1UL);
#line 1130
      n = (ngx_uint_t )0;
      }
      {
#line 1130
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1130
        if (! (n < (header___0 + i)->key.len)) {
#line 1130
          goto while_break___10;
        }
#line 1131
        ch = *((header___0 + i)->key.data + n);
#line 1133
        if ((int )ch >= 97) {
#line 1133
          if ((int )ch <= 122) {
#line 1134
            ch = (u_char )((int )ch & -33);
          } else {
#line 1133
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1136
        if ((int )ch == 45) {
#line 1137
          ch = (u_char )'_';
        }
#line 1140
        tmp___26 = b->last;
#line 1140
        (b->last) ++;
#line 1140
        *tmp___26 = ch;
#line 1130
        n ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1143
      tmp___27 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                        val_len);
#line 1143
      b->last = (u_char *)tmp___27 + val_len;
      }
      next: 
#line 1151
      goto __Cont___0;
      __Cont___0: /* CIL Label */ 
#line 1088
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
  }
#line 1156
  if (padding) {
    {
#line 1157
    memset((void *)b->last, 0, padding);
#line 1158
    b->last += padding;
    }
  }
#line 1162
  h = (ngx_http_fastcgi_header_t *)b->last;
#line 1163
  b->last += sizeof(ngx_http_fastcgi_header_t );
#line 1165
  h->version = (u_char )1;
#line 1166
  h->type = (u_char )4;
#line 1167
  h->request_id_hi = (u_char )0;
#line 1168
  h->request_id_lo = (u_char )1;
#line 1169
  h->content_length_hi = (u_char )0;
#line 1170
  h->content_length_lo = (u_char )0;
#line 1171
  h->padding_length = (u_char )0;
#line 1172
  h->reserved = (u_char )0;
#line 1174
  if (r->request_body_no_buffering) {
#line 1176
    u->request_bufs = cl;
#line 1178
    u->output.output_filter = & ngx_http_fastcgi_body_output_filter;
#line 1179
    u->output.filter_ctx = (void *)r;
  } else
#line 1181
  if (flcf->upstream.pass_request_body) {
#line 1183
    body = u->request_bufs;
#line 1184
    u->request_bufs = cl;
#line 1187
    file_pos = (off_t )0;
#line 1188
    pos = (u_char *)((void *)0);
    {
#line 1191
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 1191
      if (! body) {
#line 1191
        goto while_break___11;
      }
#line 1193
      if ((body->buf)->flush) {
#line 1193
        goto _L___1;
      } else
#line 1193
      if ((body->buf)->last_buf) {
#line 1193
        goto _L___1;
      } else
#line 1193
      if ((body->buf)->sync) {
        _L___1: /* CIL Label */ 
#line 1193
        if (! (body->buf)->temporary) {
#line 1193
          if (! (body->buf)->memory) {
#line 1193
            if (! (body->buf)->mmap) {
#line 1193
              if (! (body->buf)->in_file) {
#line 1194
                body = body->next;
#line 1195
                goto while_continue___11;
              }
            }
          }
        }
      }
#line 1198
      if ((body->buf)->in_file) {
#line 1199
        file_pos = (body->buf)->file_pos;
      } else {
#line 1202
        pos = (body->buf)->pos;
      }
#line 1205
      next = (ngx_uint_t )0;
      {
#line 1207
      while (1) {
        while_continue___12: /* CIL Label */ ;
        {
#line 1208
        tmp___28 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 1208
        b = (ngx_buf_t *)tmp___28;
        }
#line 1209
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1210
          return ((ngx_int_t )-1);
        }
        {
#line 1213
        memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)body->buf,
               sizeof(ngx_buf_t ));
        }
#line 1215
        if ((body->buf)->in_file) {
#line 1216
          b->file_pos = file_pos;
#line 1217
          file_pos += 32768L;
#line 1219
          if (file_pos >= (body->buf)->file_last) {
#line 1220
            file_pos = (body->buf)->file_last;
#line 1221
            next = (ngx_uint_t )1;
          }
#line 1224
          b->file_last = file_pos;
#line 1225
          len = (ngx_uint_t )(file_pos - b->file_pos);
        } else {
#line 1228
          b->pos = pos;
#line 1229
          b->start = pos;
#line 1230
          pos += 32768;
#line 1232
          if ((unsigned long )pos >= (unsigned long )(body->buf)->last) {
#line 1233
            pos = (body->buf)->last;
#line 1234
            next = (ngx_uint_t )1;
          }
#line 1237
          b->last = pos;
#line 1238
          len = (ngx_uint_t )(pos - b->pos);
        }
#line 1241
        padding = 8UL - len % 8UL;
#line 1242
        if (padding == 8UL) {
#line 1242
          padding = (size_t )0;
        } else {
#line 1242
          padding = padding;
        }
        {
#line 1244
        h = (ngx_http_fastcgi_header_t *)(cl->buf)->last;
#line 1245
        (cl->buf)->last += sizeof(ngx_http_fastcgi_header_t );
#line 1247
        h->version = (u_char )1;
#line 1248
        h->type = (u_char )5;
#line 1249
        h->request_id_hi = (u_char )0;
#line 1250
        h->request_id_lo = (u_char )1;
#line 1251
        h->content_length_hi = (u_char )((len >> 8) & 255UL);
#line 1252
        h->content_length_lo = (u_char )(len & 255UL);
#line 1253
        h->padding_length = (u_char )padding;
#line 1254
        h->reserved = (u_char )0;
#line 1256
        cl->next = ngx_alloc_chain_link(r->pool);
        }
#line 1257
        if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1258
          return ((ngx_int_t )-1);
        }
        {
#line 1261
        cl = cl->next;
#line 1262
        cl->buf = b;
#line 1264
        b = ngx_create_temp_buf(r->pool, sizeof(ngx_http_fastcgi_header_t ) + padding);
        }
#line 1267
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1268
          return ((ngx_int_t )-1);
        }
#line 1271
        if (padding) {
          {
#line 1272
          memset((void *)b->last, 0, padding);
#line 1273
          b->last += padding;
          }
        }
        {
#line 1276
        cl->next = ngx_alloc_chain_link(r->pool);
        }
#line 1277
        if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1278
          return ((ngx_int_t )-1);
        }
#line 1281
        cl = cl->next;
#line 1282
        cl->buf = b;
#line 1207
        if (! (! next)) {
#line 1207
          goto while_break___12;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
#line 1286
      body = body->next;
    }
    while_break___11: /* CIL Label */ ;
    }
  } else {
#line 1290
    u->request_bufs = cl;
  }
#line 1293
  if (! r->request_body_no_buffering) {
#line 1294
    h = (ngx_http_fastcgi_header_t *)(cl->buf)->last;
#line 1295
    (cl->buf)->last += sizeof(ngx_http_fastcgi_header_t );
#line 1297
    h->version = (u_char )1;
#line 1298
    h->type = (u_char )5;
#line 1299
    h->request_id_hi = (u_char )0;
#line 1300
    h->request_id_lo = (u_char )1;
#line 1301
    h->content_length_hi = (u_char )0;
#line 1302
    h->content_length_lo = (u_char )0;
#line 1303
    h->padding_length = (u_char )0;
#line 1304
    h->reserved = (u_char )0;
  }
#line 1307
  cl->next = (ngx_chain_t *)((void *)0);
#line 1309
  return ((ngx_int_t )0);
}
}
#line 1313 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_reinit_request(ngx_http_request_t *r ) 
{ 
  ngx_http_fastcgi_ctx_t *f ;

  {
#line 1318
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 1320
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1321
    return ((ngx_int_t )0);
  }
#line 1324
  f->state = (ngx_http_fastcgi_state_e )0;
#line 1325
  f->fastcgi_stdout = 0U;
#line 1326
  f->large_stderr = 0U;
#line 1328
  if (f->split_parts) {
#line 1329
    (f->split_parts)->nelts = (ngx_uint_t )0;
  }
#line 1332
  r->state = (ngx_uint_t )0;
#line 1334
  return ((ngx_int_t )0);
}
}
#line 1338 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_body_output_filter(void *data , ngx_chain_t *in ) 
{ 
  ngx_http_request_t *r ;
  off_t file_pos ;
  u_char *pos ;
  u_char *start ;
  size_t len ;
  size_t padding ;
  ngx_buf_t *b ;
  ngx_int_t rc ;
  ngx_uint_t next ;
  ngx_uint_t last ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_header_t *h ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1341
  r = (ngx_http_request_t *)data;
#line 1356
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 1358
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1359
    out = in;
#line 1360
    goto out;
  }
#line 1363
  out = (ngx_chain_t *)((void *)0);
#line 1364
  ll = & out;
#line 1366
  if (! f->header_sent) {
    {
#line 1372
    f->header_sent = 1U;
#line 1374
    tl = ngx_alloc_chain_link(r->pool);
    }
#line 1375
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1376
      return ((ngx_int_t )-1);
    }
#line 1379
    tl->buf = in->buf;
#line 1380
    *ll = tl;
#line 1381
    ll = & tl->next;
#line 1383
    in = in->next;
#line 1385
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1386
      tl->next = (ngx_chain_t *)((void *)0);
#line 1387
      goto out;
    }
  }
  {
#line 1391
  cl = ngx_chain_get_free_buf(r->pool, & f->free);
  }
#line 1392
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1393
    return ((ngx_int_t )-1);
  }
#line 1396
  b = cl->buf;
#line 1398
  b->tag = (ngx_buf_tag_t )(& ngx_http_fastcgi_body_output_filter);
#line 1399
  b->temporary = 1U;
#line 1401
  if ((unsigned long )b->start == (unsigned long )((void *)0)) {
    {
#line 1404
    tmp = ngx_palloc(r->pool, sizeof(ngx_http_fastcgi_header_t ) + 7UL);
#line 1404
    b->start = (u_char *)tmp;
    }
#line 1406
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 1407
      return ((ngx_int_t )-1);
    }
#line 1410
    b->pos = b->start;
#line 1411
    b->last = b->start;
#line 1413
    b->end = (b->start + sizeof(ngx_http_fastcgi_header_t )) + 7;
  }
#line 1416
  *ll = cl;
#line 1418
  last = (ngx_uint_t )0;
#line 1419
  padding = (size_t )0;
#line 1422
  file_pos = (off_t )0;
#line 1423
  pos = (u_char *)((void *)0);
  {
#line 1426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1426
    if (! in) {
#line 1426
      goto while_break;
    }
#line 1438
    if ((in->buf)->last_buf) {
#line 1439
      last = (ngx_uint_t )1;
    }
#line 1442
    if ((in->buf)->flush) {
#line 1442
      goto _L;
    } else
#line 1442
    if ((in->buf)->last_buf) {
#line 1442
      goto _L;
    } else
#line 1442
    if ((in->buf)->sync) {
      _L: /* CIL Label */ 
#line 1442
      if (! (in->buf)->temporary) {
#line 1442
        if (! (in->buf)->memory) {
#line 1442
          if (! (in->buf)->mmap) {
#line 1442
            if (! (in->buf)->in_file) {
#line 1443
              in = in->next;
#line 1444
              goto while_continue;
            }
          }
        }
      }
    }
#line 1447
    if ((in->buf)->in_file) {
#line 1448
      file_pos = (in->buf)->file_pos;
    } else {
#line 1451
      pos = (in->buf)->pos;
    }
#line 1454
    next = (ngx_uint_t )0;
    {
#line 1456
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1457
      tl = ngx_chain_get_free_buf(r->pool, & f->free);
      }
#line 1458
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1459
        return ((ngx_int_t )-1);
      }
      {
#line 1462
      b = tl->buf;
#line 1463
      start = b->start;
#line 1465
      memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)in->buf,
             sizeof(ngx_buf_t ));
#line 1472
      b->start = start;
      }
#line 1474
      if ((in->buf)->in_file) {
#line 1475
        b->file_pos = file_pos;
#line 1476
        file_pos += 32768L;
#line 1478
        if (file_pos >= (in->buf)->file_last) {
#line 1479
          file_pos = (in->buf)->file_last;
#line 1480
          next = (ngx_uint_t )1;
        }
#line 1483
        b->file_last = file_pos;
#line 1484
        len = (ngx_uint_t )(file_pos - b->file_pos);
      } else {
#line 1487
        b->pos = pos;
#line 1488
        pos += 32768;
#line 1490
        if ((unsigned long )pos >= (unsigned long )(in->buf)->last) {
#line 1491
          pos = (in->buf)->last;
#line 1492
          next = (ngx_uint_t )1;
        }
#line 1495
        b->last = pos;
#line 1496
        len = (ngx_uint_t )(pos - b->pos);
      }
#line 1499
      b->tag = (ngx_buf_tag_t )(& ngx_http_fastcgi_body_output_filter);
#line 1500
      b->shadow = in->buf;
#line 1501
      b->last_shadow = (unsigned int )next;
#line 1503
      b->last_buf = 0U;
#line 1504
      b->last_in_chain = 0U;
#line 1506
      padding = 8UL - len % 8UL;
#line 1507
      if (padding == 8UL) {
#line 1507
        padding = (size_t )0;
      } else {
#line 1507
        padding = padding;
      }
      {
#line 1509
      h = (ngx_http_fastcgi_header_t *)(cl->buf)->last;
#line 1510
      (cl->buf)->last += sizeof(ngx_http_fastcgi_header_t );
#line 1512
      h->version = (u_char )1;
#line 1513
      h->type = (u_char )5;
#line 1514
      h->request_id_hi = (u_char )0;
#line 1515
      h->request_id_lo = (u_char )1;
#line 1516
      h->content_length_hi = (u_char )((len >> 8) & 255UL);
#line 1517
      h->content_length_lo = (u_char )(len & 255UL);
#line 1518
      h->padding_length = (u_char )padding;
#line 1519
      h->reserved = (u_char )0;
#line 1521
      cl->next = tl;
#line 1522
      cl = tl;
#line 1524
      tl = ngx_chain_get_free_buf(r->pool, & f->free);
      }
#line 1525
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1526
        return ((ngx_int_t )-1);
      }
#line 1529
      b = tl->buf;
#line 1531
      b->tag = (ngx_buf_tag_t )(& ngx_http_fastcgi_body_output_filter);
#line 1532
      b->temporary = 1U;
#line 1534
      if ((unsigned long )b->start == (unsigned long )((void *)0)) {
        {
#line 1537
        tmp___0 = ngx_palloc(r->pool, sizeof(ngx_http_fastcgi_header_t ) + 7UL);
#line 1537
        b->start = (u_char *)tmp___0;
        }
#line 1539
        if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 1540
          return ((ngx_int_t )-1);
        }
#line 1543
        b->pos = b->start;
#line 1544
        b->last = b->start;
#line 1546
        b->end = (b->start + sizeof(ngx_http_fastcgi_header_t )) + 7;
      }
#line 1549
      if (padding) {
        {
#line 1550
        memset((void *)b->last, 0, padding);
#line 1551
        b->last += padding;
        }
      }
#line 1554
      cl->next = tl;
#line 1555
      cl = tl;
#line 1456
      if (! (! next)) {
#line 1456
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1559
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1562
  if (last) {
#line 1563
    h = (ngx_http_fastcgi_header_t *)(cl->buf)->last;
#line 1564
    (cl->buf)->last += sizeof(ngx_http_fastcgi_header_t );
#line 1566
    h->version = (u_char )1;
#line 1567
    h->type = (u_char )5;
#line 1568
    h->request_id_hi = (u_char )0;
#line 1569
    h->request_id_lo = (u_char )1;
#line 1570
    h->content_length_hi = (u_char )0;
#line 1571
    h->content_length_lo = (u_char )0;
#line 1572
    h->padding_length = (u_char )0;
#line 1573
    h->reserved = (u_char )0;
#line 1575
    (cl->buf)->last_buf = 1U;
  } else
#line 1577
  if (padding == 0UL) {
#line 1579
    (cl->buf)->temporary = 0U;
#line 1580
    (cl->buf)->sync = 1U;
  }
#line 1583
  cl->next = (ngx_chain_t *)((void *)0);
  out: 
  {
#line 1603
  rc = ngx_chain_writer((void *)(& (r->upstream)->writer), out);
#line 1605
  ngx_chain_update_chains(r->pool, & f->free, & f->busy, & out, (ngx_buf_tag_t )(& ngx_http_fastcgi_body_output_filter));
#line 1608
  cl = f->free;
  }
  {
#line 1608
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1608
    if (! cl) {
#line 1608
      goto while_break___1;
    }
#line 1612
    if ((cl->buf)->shadow) {
#line 1613
      if ((cl->buf)->last_shadow) {
#line 1614
        b = (cl->buf)->shadow;
#line 1615
        b->pos = b->last;
      }
#line 1618
      (cl->buf)->shadow = (ngx_buf_t *)((void *)0);
    }
#line 1608
    cl = cl->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1622
  return (rc);
}
}
#line 1626 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_process_header(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char *msg ;
  u_char *start ;
  u_char *last ;
  u_char *part_start ;
  u_char *part_end ;
  size_t size ;
  ngx_str_t *status_line ;
  ngx_str_t *pattern ;
  ngx_int_t rc ;
  ngx_int_t status ;
  ngx_buf_t buf ;
  ngx_uint_t i ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_http_fastcgi_split_part_t *part ;
  ngx_http_upstream_main_conf_t *umcf ;
  u_char *tmp ;
  ssize_t len ;
  ngx_http_fastcgi_header_t *fh ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  ngx_int_t tmp___7 ;
  void *tmp___8 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 1644
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 1646
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
#line 1648
  u = r->upstream;
  {
#line 1650
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1652
    if ((unsigned int )f->state < 8U) {
      {
#line 1654
      f->pos = u->buffer.pos;
#line 1655
      f->last = u->buffer.last;
#line 1657
      rc = ngx_http_fastcgi_process_record(r, f);
#line 1659
      u->buffer.pos = f->pos;
#line 1660
      u->buffer.last = f->last;
      }
#line 1662
      if (rc == -2L) {
#line 1663
        return ((ngx_int_t )-2);
      }
#line 1666
      if (rc == -1L) {
#line 1667
        return ((ngx_int_t )40);
      }
#line 1670
      if (f->type != 6UL) {
#line 1670
        if (f->type != 7UL) {
#line 1673
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 1673
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent unexpected FastCGI record: %ui",
                               f->type);
            }
          }
#line 1677
          return ((ngx_int_t )40);
        }
      }
#line 1680
      if (f->type == 6UL) {
#line 1680
        if (f->length == 0UL) {
#line 1681
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 1681
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream prematurely closed FastCGI stdout");
            }
          }
#line 1684
          return ((ngx_int_t )40);
        }
      }
    }
#line 1688
    if ((unsigned int )f->state == 9U) {
#line 1690
      if ((unsigned long )(u->buffer.pos + f->padding) < (unsigned long )u->buffer.last) {
#line 1691
        f->state = (ngx_http_fastcgi_state_e )0;
#line 1692
        u->buffer.pos += f->padding;
#line 1694
        goto __Cont;
      }
#line 1697
      if ((unsigned long )(u->buffer.pos + f->padding) == (unsigned long )u->buffer.last) {
#line 1698
        f->state = (ngx_http_fastcgi_state_e )0;
#line 1699
        u->buffer.pos = u->buffer.last;
#line 1701
        return ((ngx_int_t )-2);
      }
#line 1704
      f->padding -= (size_t )(u->buffer.last - u->buffer.pos);
#line 1705
      u->buffer.pos = u->buffer.last;
#line 1707
      return ((ngx_int_t )-2);
    }
#line 1713
    if (f->type == 7UL) {
#line 1715
      if (f->length) {
#line 1716
        msg = u->buffer.pos;
#line 1718
        if ((unsigned long )(u->buffer.pos + f->length) <= (unsigned long )u->buffer.last) {
#line 1719
          u->buffer.pos += f->length;
#line 1720
          f->length = (size_t )0;
#line 1721
          f->state = (ngx_http_fastcgi_state_e )9;
        } else {
#line 1724
          f->length -= (size_t )(u->buffer.last - u->buffer.pos);
#line 1725
          u->buffer.pos = u->buffer.last;
        }
#line 1728
        p = u->buffer.pos - 1;
        {
#line 1728
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1728
          if (! ((unsigned long )msg < (unsigned long )p)) {
#line 1728
            goto while_break___0;
          }
#line 1729
          if ((int )*p != 10) {
#line 1729
            if ((int )*p != 13) {
#line 1729
              if ((int )*p != 46) {
#line 1729
                if ((int )*p != 32) {
#line 1730
                  goto while_break___0;
                }
              }
            }
          }
#line 1728
          p --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1734
        p ++;
#line 1736
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 1736
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "FastCGI sent in stderr: \"%*s\"",
                             p - msg, msg);
          }
        }
#line 1739
        flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 1741
        if (flcf->catch_stderr) {
#line 1742
          pattern = (ngx_str_t *)(flcf->catch_stderr)->elts;
#line 1744
          i = (ngx_uint_t )0;
          {
#line 1744
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1744
            if (! (i < (flcf->catch_stderr)->nelts)) {
#line 1744
              goto while_break___1;
            }
            {
#line 1745
            tmp = ngx_strnstr(msg, (char *)(pattern + i)->data, (size_t )(p - msg));
            }
#line 1745
            if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1749
              return ((ngx_int_t )40);
            }
#line 1744
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 1754
        if ((unsigned long )u->buffer.pos == (unsigned long )u->buffer.last) {
#line 1756
          if (! f->fastcgi_stdout) {
#line 1764
            if (r->cache) {
#line 1765
              u->buffer.pos = u->buffer.start + (r->cache)->header_start;
            } else {
#line 1768
              u->buffer.pos = u->buffer.start;
            }
#line 1773
            u->buffer.last = u->buffer.pos;
#line 1774
            f->large_stderr = 1U;
          }
#line 1777
          return ((ngx_int_t )-2);
        }
      } else {
#line 1781
        f->state = (ngx_http_fastcgi_state_e )9;
      }
#line 1784
      goto __Cont;
    }
#line 1792
    if (f->large_stderr) {
#line 1792
      if (r->cache) {
#line 1796
        start = u->buffer.start + (r->cache)->header_start;
#line 1798
        len = (ssize_t )((unsigned long )(u->buffer.pos - start) - 2UL * sizeof(ngx_http_fastcgi_header_t ));
#line 1808
        if (len >= 0L) {
#line 1809
          fh = (ngx_http_fastcgi_header_t *)start;
#line 1810
          fh->version = (u_char )1;
#line 1811
          fh->type = (u_char )7;
#line 1812
          fh->request_id_hi = (u_char )0;
#line 1813
          fh->request_id_lo = (u_char )1;
#line 1814
          fh->content_length_hi = (u_char )((len >> 8) & 255L);
#line 1815
          fh->content_length_lo = (u_char )(len & 255L);
#line 1816
          fh->padding_length = (u_char )0;
#line 1817
          fh->reserved = (u_char )0;
        } else {
#line 1820
          (r->cache)->header_start += (unsigned long )(u->buffer.pos - start) - sizeof(ngx_http_fastcgi_header_t );
        }
#line 1824
        f->large_stderr = 0U;
      }
    }
#line 1829
    f->fastcgi_stdout = 1U;
#line 1831
    start = u->buffer.pos;
#line 1833
    if ((unsigned long )(u->buffer.pos + f->length) < (unsigned long )u->buffer.last) {
#line 1840
      last = u->buffer.last;
#line 1841
      u->buffer.last = u->buffer.pos + f->length;
    } else {
#line 1844
      last = (u_char *)((void *)0);
    }
    {
#line 1847
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1849
      part_start = u->buffer.pos;
#line 1850
      part_end = u->buffer.last;
#line 1852
      rc = ngx_http_parse_header_line(r, & u->buffer, (ngx_uint_t )1);
      }
#line 1857
      if (rc == -2L) {
#line 1858
        goto while_break___2;
      }
#line 1861
      if (rc == 0L) {
        {
#line 1865
        tmp___0 = ngx_list_push(& u->headers_in.headers);
#line 1865
        h = (ngx_table_elt_t *)tmp___0;
        }
#line 1866
        if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1867
          return ((ngx_int_t )-1);
        }
#line 1870
        if (f->split_parts) {
#line 1870
          if ((f->split_parts)->nelts) {
#line 1872
            part = (ngx_http_fastcgi_split_part_t *)(f->split_parts)->elts;
#line 1873
            size = (size_t )(u->buffer.pos - part_start);
#line 1875
            i = (ngx_uint_t )0;
            {
#line 1875
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 1875
              if (! (i < (f->split_parts)->nelts)) {
#line 1875
                goto while_break___3;
              }
#line 1876
              size += (size_t )((part + i)->end - (part + i)->start);
#line 1875
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 1879
            tmp___1 = ngx_pnalloc(r->pool, size);
#line 1879
            p = (u_char *)tmp___1;
            }
#line 1880
            if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1881
              h->hash = (ngx_uint_t )0;
#line 1882
              return ((ngx_int_t )-1);
            }
#line 1885
            buf.pos = p;
#line 1887
            i = (ngx_uint_t )0;
            {
#line 1887
            while (1) {
              while_continue___4: /* CIL Label */ ;
#line 1887
              if (! (i < (f->split_parts)->nelts)) {
#line 1887
                goto while_break___4;
              }
              {
#line 1888
              tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(part + i)->start,
                               (size_t )((part + i)->end - (part + i)->start));
#line 1888
              p = (u_char *)tmp___2 + ((part + i)->end - (part + i)->start);
#line 1887
              i ++;
              }
            }
            while_break___4: /* CIL Label */ ;
            }
            {
#line 1892
            tmp___3 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)part_start,
                             (size_t )(u->buffer.pos - part_start));
#line 1892
            p = (u_char *)tmp___3 + (u->buffer.pos - part_start);
#line 1894
            buf.last = p;
#line 1896
            (f->split_parts)->nelts = (ngx_uint_t )0;
#line 1898
            rc = ngx_http_parse_header_line(r, & buf, (ngx_uint_t )1);
            }
#line 1900
            if (rc != 0L) {
#line 1901
              if (((r->connection)->log)->log_level >= 2UL) {
                {
#line 1901
                ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "invalid header after joining FastCGI records");
                }
              }
#line 1904
              h->hash = (ngx_uint_t )0;
#line 1905
              return ((ngx_int_t )-1);
            }
            {
#line 1908
            h->key.len = (size_t )(r->header_name_end - r->header_name_start);
#line 1909
            h->key.data = r->header_name_start;
#line 1910
            *(h->key.data + h->key.len) = (u_char )'\000';
#line 1912
            h->value.len = (size_t )(r->header_end - r->header_start);
#line 1913
            h->value.data = r->header_start;
#line 1914
            *(h->value.data + h->value.len) = (u_char )'\000';
#line 1916
            tmp___4 = ngx_pnalloc(r->pool, h->key.len);
#line 1916
            h->lowcase_key = (u_char *)tmp___4;
            }
#line 1917
            if ((unsigned long )h->lowcase_key == (unsigned long )((void *)0)) {
#line 1918
              return ((ngx_int_t )-1);
            }
          } else {
#line 1870
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 1923
          h->key.len = (size_t )(r->header_name_end - r->header_name_start);
#line 1924
          h->value.len = (size_t )(r->header_end - r->header_start);
#line 1926
          tmp___5 = ngx_pnalloc(r->pool, (((h->key.len + 1UL) + h->value.len) + 1UL) + h->key.len);
#line 1926
          h->key.data = (u_char *)tmp___5;
          }
#line 1929
          if ((unsigned long )h->key.data == (unsigned long )((void *)0)) {
#line 1930
            h->hash = (ngx_uint_t )0;
#line 1931
            return ((ngx_int_t )-1);
          }
          {
#line 1934
          h->value.data = (h->key.data + h->key.len) + 1;
#line 1935
          h->lowcase_key = (((h->key.data + h->key.len) + 1) + h->value.len) + 1;
#line 1938
          memcpy((void */* __restrict  */)h->key.data, (void const   */* __restrict  */)r->header_name_start,
                 h->key.len);
#line 1939
          *(h->key.data + h->key.len) = (u_char )'\000';
#line 1940
          memcpy((void */* __restrict  */)h->value.data, (void const   */* __restrict  */)r->header_start,
                 h->value.len);
#line 1941
          *(h->value.data + h->value.len) = (u_char )'\000';
          }
        }
#line 1944
        h->hash = r->header_hash;
#line 1946
        if (h->key.len == r->lowcase_index) {
          {
#line 1947
          memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
                 h->key.len);
          }
        } else {
          {
#line 1950
          ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
          }
        }
        {
#line 1953
        tmp___6 = ngx_hash_find(& umcf->headers_in_hash, h->hash, h->lowcase_key,
                                h->key.len);
#line 1953
        hh = (ngx_http_upstream_header_t *)tmp___6;
        }
#line 1956
        if (hh) {
          {
#line 1956
          tmp___7 = (*(hh->handler))(r, h, hh->offset);
          }
#line 1956
          if (tmp___7 != 0L) {
#line 1957
            return ((ngx_int_t )-1);
          }
        }
#line 1964
        if ((unsigned long )u->buffer.pos < (unsigned long )u->buffer.last) {
#line 1965
          goto __Cont___0;
        }
#line 1970
        goto while_break___2;
      }
#line 1973
      if (rc == 1L) {
#line 1980
        if (u->headers_in.status) {
          {
#line 1981
          status_line = & (u->headers_in.status)->value;
#line 1983
          status = ngx_atoi(status_line->data, (size_t )3);
          }
#line 1985
          if (status == -1L) {
#line 1986
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 1986
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid status \"%V\"",
                                 status_line);
              }
            }
#line 1989
            return ((ngx_int_t )40);
          }
#line 1992
          u->headers_in.status_n = (ngx_uint_t )status;
#line 1993
          u->headers_in.status_line = *status_line;
        } else
#line 1995
        if (u->headers_in.location) {
#line 1996
          u->headers_in.status_n = (ngx_uint_t )302;
#line 1997
          u->headers_in.status_line.len = sizeof("302 Moved Temporarily") - 1UL;
#line 1997
          u->headers_in.status_line.data = (u_char *)"302 Moved Temporarily";
        } else {
#line 2001
          u->headers_in.status_n = (ngx_uint_t )200;
#line 2002
          u->headers_in.status_line.len = sizeof("200 OK") - 1UL;
#line 2002
          u->headers_in.status_line.data = (u_char *)"200 OK";
        }
#line 2005
        if (u->state) {
#line 2005
          if ((u->state)->status == 0UL) {
#line 2006
            (u->state)->status = u->headers_in.status_n;
          }
        }
#line 2009
        goto while_break___2;
      }
#line 2014
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2014
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid header");
        }
      }
#line 2017
      return ((ngx_int_t )40);
      __Cont___0: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2020
    if (last) {
#line 2021
      u->buffer.last = last;
    }
#line 2024
    f->length -= (size_t )(u->buffer.pos - start);
#line 2026
    if (f->length == 0UL) {
#line 2027
      f->state = (ngx_http_fastcgi_state_e )9;
    }
#line 2030
    if (rc == 1L) {
#line 2031
      return ((ngx_int_t )0);
    }
#line 2034
    if (rc == 0L) {
#line 2035
      goto __Cont;
    }
#line 2043
    if ((unsigned long )f->split_parts == (unsigned long )((void *)0)) {
      {
#line 2044
      f->split_parts = ngx_array_create(r->pool, (ngx_uint_t )1, sizeof(ngx_http_fastcgi_split_part_t ));
      }
#line 2046
      if ((unsigned long )f->split_parts == (unsigned long )((void *)0)) {
#line 2047
        return ((ngx_int_t )-1);
      }
    }
    {
#line 2051
    tmp___8 = ngx_array_push(f->split_parts);
#line 2051
    part = (ngx_http_fastcgi_split_part_t *)tmp___8;
    }
#line 2052
    if ((unsigned long )part == (unsigned long )((void *)0)) {
#line 2053
      return ((ngx_int_t )-1);
    }
#line 2056
    part->start = part_start;
#line 2057
    part->end = part_end;
#line 2059
    if ((unsigned long )u->buffer.pos < (unsigned long )u->buffer.last) {
#line 2060
      goto __Cont;
    }
#line 2063
    return ((ngx_int_t )-2);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2068 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_input_filter_init(void *data ) 
{ 
  ngx_http_request_t *r ;
  ngx_http_fastcgi_loc_conf_t *flcf ;

  {
#line 2071
  r = (ngx_http_request_t *)data;
#line 2074
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 2076
  if (flcf->keep_conn) {
#line 2076
    ((r->upstream)->pipe)->length = (off_t )sizeof(ngx_http_fastcgi_header_t );
  } else {
#line 2076
    ((r->upstream)->pipe)->length = (off_t )-1;
  }
#line 2079
  return ((ngx_int_t )0);
}
}
#line 2083 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_input_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) 
{ 
  u_char *m ;
  u_char *msg ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_buf_t **prev ;
  ngx_chain_t *cl ;
  ngx_http_request_t *r ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_int_t tmp ;
  char *__cil_tmp13 ;

  {
#line 2094
  if ((unsigned long )buf->pos == (unsigned long )buf->last) {
#line 2095
    return ((ngx_int_t )0);
  }
#line 2098
  r = (ngx_http_request_t *)p->input_ctx;
#line 2099
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 2100
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 2102
  b = (ngx_buf_t *)((void *)0);
#line 2103
  prev = & buf->shadow;
#line 2105
  f->pos = buf->pos;
#line 2106
  f->last = buf->last;
  {
#line 2108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2109
    if ((unsigned int )f->state < 8U) {
      {
#line 2111
      rc = ngx_http_fastcgi_process_record(r, f);
      }
#line 2113
      if (rc == -2L) {
#line 2114
        goto while_break;
      }
#line 2117
      if (rc == -1L) {
#line 2118
        return ((ngx_int_t )-1);
      }
#line 2121
      if (f->type == 6UL) {
#line 2121
        if (f->length == 0UL) {
#line 2122
          f->state = (ngx_http_fastcgi_state_e )9;
#line 2124
          if (! flcf->keep_conn) {
#line 2125
            p->upstream_done = 1U;
          }
#line 2131
          goto __Cont;
        }
      }
#line 2134
      if (f->type == 3UL) {
#line 2139
        if (! flcf->keep_conn) {
#line 2140
          p->upstream_done = 1U;
#line 2141
          goto while_break;
        }
#line 2144
        goto __Cont;
      }
    }
#line 2149
    if ((unsigned int )f->state == 9U) {
#line 2151
      if (f->type == 3UL) {
#line 2153
        if ((unsigned long )(f->pos + f->padding) < (unsigned long )f->last) {
#line 2154
          p->upstream_done = 1U;
#line 2155
          goto while_break;
        }
#line 2158
        if ((unsigned long )(f->pos + f->padding) == (unsigned long )f->last) {
#line 2159
          p->upstream_done = 1U;
#line 2160
          (r->upstream)->keepalive = 1U;
#line 2161
          goto while_break;
        }
#line 2164
        f->padding -= (size_t )(f->last - f->pos);
#line 2166
        goto while_break;
      }
#line 2169
      if ((unsigned long )(f->pos + f->padding) < (unsigned long )f->last) {
#line 2170
        f->state = (ngx_http_fastcgi_state_e )0;
#line 2171
        f->pos += f->padding;
#line 2173
        goto __Cont;
      }
#line 2176
      if ((unsigned long )(f->pos + f->padding) == (unsigned long )f->last) {
#line 2177
        f->state = (ngx_http_fastcgi_state_e )0;
#line 2179
        goto while_break;
      }
#line 2182
      f->padding -= (size_t )(f->last - f->pos);
#line 2184
      goto while_break;
    }
#line 2190
    if (f->type == 7UL) {
#line 2192
      if (f->length) {
#line 2194
        if ((unsigned long )f->pos == (unsigned long )f->last) {
#line 2195
          goto while_break;
        }
#line 2198
        msg = f->pos;
#line 2200
        if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2201
          f->pos += f->length;
#line 2202
          f->length = (size_t )0;
#line 2203
          f->state = (ngx_http_fastcgi_state_e )9;
        } else {
#line 2206
          f->length -= (size_t )(f->last - f->pos);
#line 2207
          f->pos = f->last;
        }
#line 2210
        m = f->pos - 1;
        {
#line 2210
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 2210
          if (! ((unsigned long )msg < (unsigned long )m)) {
#line 2210
            goto while_break___0;
          }
#line 2211
          if ((int )*m != 10) {
#line 2211
            if ((int )*m != 13) {
#line 2211
              if ((int )*m != 46) {
#line 2211
                if ((int )*m != 32) {
#line 2212
                  goto while_break___0;
                }
              }
            }
          }
#line 2210
          m --;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 2216
        if ((p->log)->log_level >= 4UL) {
          {
#line 2216
          ngx_log_error_core((ngx_uint_t )4, p->log, 0, "FastCGI sent in stderr: \"%*s\"",
                             (m + 1) - msg, msg);
          }
        }
      } else {
#line 2221
        f->state = (ngx_http_fastcgi_state_e )9;
      }
#line 2224
      goto __Cont;
    }
#line 2227
    if (f->type == 3UL) {
#line 2229
      if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2230
        f->state = (ngx_http_fastcgi_state_e )9;
#line 2231
        f->pos += f->length;
#line 2233
        goto __Cont;
      }
#line 2236
      f->length -= (size_t )(f->last - f->pos);
#line 2238
      goto while_break;
    }
#line 2244
    if ((unsigned long )f->pos == (unsigned long )f->last) {
#line 2245
      goto while_break;
    }
    {
#line 2248
    cl = ngx_chain_get_free_buf(p->pool, & p->free);
    }
#line 2249
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2250
      return ((ngx_int_t )-1);
    }
    {
#line 2253
    b = cl->buf;
#line 2255
    memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 2257
    b->pos = f->pos;
#line 2258
    b->start = buf->start;
#line 2259
    b->end = buf->end;
#line 2260
    b->tag = p->tag;
#line 2261
    b->temporary = 1U;
#line 2262
    b->recycled = 1U;
#line 2264
    *prev = b;
#line 2265
    prev = & b->shadow;
    }
#line 2267
    if (p->in) {
#line 2268
      *(p->last_in) = cl;
    } else {
#line 2270
      p->in = cl;
    }
#line 2272
    p->last_in = & cl->next;
#line 2275
    b->num = buf->num;
#line 2280
    if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2281
      f->state = (ngx_http_fastcgi_state_e )9;
#line 2282
      f->pos += f->length;
#line 2283
      b->last = f->pos;
#line 2285
      goto __Cont;
    }
#line 2288
    f->length -= (size_t )(f->last - f->pos);
#line 2290
    b->last = f->last;
#line 2292
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2296
  if (flcf->keep_conn) {
#line 2300
    if ((unsigned int )f->state < 8U) {
#line 2301
      p->length = (off_t )1;
    } else
#line 2303
    if ((unsigned int )f->state == 9U) {
#line 2304
      p->length = (off_t )f->padding;
    } else {
#line 2309
      p->length = (off_t )f->length;
    }
  }
#line 2313
  if (b) {
#line 2314
    b->shadow = buf;
#line 2315
    b->last_shadow = 1U;
#line 2320
    return ((ngx_int_t )0);
  }
  {
#line 2325
  tmp = ngx_event_pipe_add_free_buf(p, buf);
  }
#line 2325
  if (tmp != 0L) {
#line 2326
    return ((ngx_int_t )-1);
  }
#line 2329
  return ((ngx_int_t )0);
}
}
#line 2333 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_non_buffered_filter(void *data , ssize_t bytes ) 
{ 
  u_char *m ;
  u_char *msg ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_buf_t *buf ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_request_t *r ;
  ngx_http_upstream_t *u ;
  ngx_http_fastcgi_ctx_t *f ;
  void *tmp ;
  char *__cil_tmp14 ;

  {
#line 2344
  r = (ngx_http_request_t *)data;
#line 2345
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 2347
  u = r->upstream;
#line 2348
  buf = & u->buffer;
#line 2350
  buf->pos = buf->last;
#line 2351
  buf->last += bytes;
#line 2353
  cl = u->out_bufs;
#line 2353
  ll = & u->out_bufs;
  {
#line 2353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2353
    if (! cl) {
#line 2353
      goto while_break;
    }
#line 2354
    ll = & cl->next;
#line 2353
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2357
  f->pos = buf->pos;
#line 2358
  f->last = buf->last;
  {
#line 2360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2361
    if ((unsigned int )f->state < 8U) {
      {
#line 2363
      rc = ngx_http_fastcgi_process_record(r, f);
      }
#line 2365
      if (rc == -2L) {
#line 2366
        goto while_break___0;
      }
#line 2369
      if (rc == -1L) {
#line 2370
        return ((ngx_int_t )-1);
      }
#line 2373
      if (f->type == 6UL) {
#line 2373
        if (f->length == 0UL) {
#line 2374
          f->state = (ngx_http_fastcgi_state_e )9;
#line 2379
          goto __Cont;
        }
      }
    }
#line 2383
    if ((unsigned int )f->state == 9U) {
#line 2385
      if (f->type == 3UL) {
#line 2387
        if ((unsigned long )(f->pos + f->padding) < (unsigned long )f->last) {
#line 2388
          u->length = (off_t )0;
#line 2389
          goto while_break___0;
        }
#line 2392
        if ((unsigned long )(f->pos + f->padding) == (unsigned long )f->last) {
#line 2393
          u->length = (off_t )0;
#line 2394
          u->keepalive = 1U;
#line 2395
          goto while_break___0;
        }
#line 2398
        f->padding -= (size_t )(f->last - f->pos);
#line 2400
        goto while_break___0;
      }
#line 2403
      if ((unsigned long )(f->pos + f->padding) < (unsigned long )f->last) {
#line 2404
        f->state = (ngx_http_fastcgi_state_e )0;
#line 2405
        f->pos += f->padding;
#line 2407
        goto __Cont;
      }
#line 2410
      if ((unsigned long )(f->pos + f->padding) == (unsigned long )f->last) {
#line 2411
        f->state = (ngx_http_fastcgi_state_e )0;
#line 2413
        goto while_break___0;
      }
#line 2416
      f->padding -= (size_t )(f->last - f->pos);
#line 2418
      goto while_break___0;
    }
#line 2424
    if (f->type == 7UL) {
#line 2426
      if (f->length) {
#line 2428
        if ((unsigned long )f->pos == (unsigned long )f->last) {
#line 2429
          goto while_break___0;
        }
#line 2432
        msg = f->pos;
#line 2434
        if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2435
          f->pos += f->length;
#line 2436
          f->length = (size_t )0;
#line 2437
          f->state = (ngx_http_fastcgi_state_e )9;
        } else {
#line 2440
          f->length -= (size_t )(f->last - f->pos);
#line 2441
          f->pos = f->last;
        }
#line 2444
        m = f->pos - 1;
        {
#line 2444
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2444
          if (! ((unsigned long )msg < (unsigned long )m)) {
#line 2444
            goto while_break___1;
          }
#line 2445
          if ((int )*m != 10) {
#line 2445
            if ((int )*m != 13) {
#line 2445
              if ((int )*m != 46) {
#line 2445
                if ((int )*m != 32) {
#line 2446
                  goto while_break___1;
                }
              }
            }
          }
#line 2444
          m --;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 2450
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 2450
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "FastCGI sent in stderr: \"%*s\"",
                             (m + 1) - msg, msg);
          }
        }
      } else {
#line 2455
        f->state = (ngx_http_fastcgi_state_e )9;
      }
#line 2458
      goto __Cont;
    }
#line 2461
    if (f->type == 3UL) {
#line 2463
      if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2464
        f->state = (ngx_http_fastcgi_state_e )9;
#line 2465
        f->pos += f->length;
#line 2467
        goto __Cont;
      }
#line 2470
      f->length -= (size_t )(f->last - f->pos);
#line 2472
      goto while_break___0;
    }
#line 2478
    if ((unsigned long )f->pos == (unsigned long )f->last) {
#line 2479
      goto while_break___0;
    }
    {
#line 2482
    cl = ngx_chain_get_free_buf(r->pool, & u->free_bufs);
    }
#line 2483
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2484
      return ((ngx_int_t )-1);
    }
#line 2487
    *ll = cl;
#line 2488
    ll = & cl->next;
#line 2490
    b = cl->buf;
#line 2492
    b->flush = 1U;
#line 2493
    b->memory = 1U;
#line 2495
    b->pos = f->pos;
#line 2496
    b->tag = u->output.tag;
#line 2501
    if ((unsigned long )(f->pos + f->length) <= (unsigned long )f->last) {
#line 2502
      f->state = (ngx_http_fastcgi_state_e )9;
#line 2503
      f->pos += f->length;
#line 2504
      b->last = f->pos;
#line 2506
      goto __Cont;
    }
#line 2509
    f->length -= (size_t )(f->last - f->pos);
#line 2510
    b->last = f->last;
#line 2512
    goto while_break___0;
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2517
  if (r->subrequest_in_memory) {
#line 2519
    cl = u->out_bufs;
#line 2521
    if (cl) {
#line 2522
      buf->pos = (cl->buf)->pos;
    }
#line 2525
    buf->last = buf->pos;
#line 2527
    cl = u->out_bufs;
    {
#line 2527
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2527
      if (! cl) {
#line 2527
        goto while_break___2;
      }
#line 2532
      if ((unsigned long )buf->last == (unsigned long )(cl->buf)->pos) {
#line 2533
        buf->last = (cl->buf)->last;
#line 2534
        goto __Cont___0;
      }
      {
#line 2537
      tmp = memmove((void *)buf->last, (void const   *)(cl->buf)->pos, (size_t )((cl->buf)->last - (cl->buf)->pos));
#line 2537
      buf->last = (u_char *)tmp + ((cl->buf)->last - (cl->buf)->pos);
#line 2540
      (cl->buf)->pos = buf->last - ((cl->buf)->last - (cl->buf)->pos);
#line 2541
      (cl->buf)->last = buf->last;
      }
      __Cont___0: /* CIL Label */ 
#line 2527
      cl = cl->next;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 2545
  return ((ngx_int_t )0);
}
}
#line 2549 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_process_record(ngx_http_request_t *r , ngx_http_fastcgi_ctx_t *f ) 
{ 
  u_char ch ;
  u_char *p ;
  ngx_http_fastcgi_state_e state ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 2556
  state = f->state;
#line 2558
  p = f->pos;
  {
#line 2558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2558
    if (! ((unsigned long )p < (unsigned long )f->last)) {
#line 2558
      goto while_break;
    }
#line 2560
    ch = *p;
    {
#line 2567
    if ((unsigned int )state == 0U) {
#line 2567
      goto case_0;
    }
#line 2577
    if ((unsigned int )state == 1U) {
#line 2577
      goto case_1;
    }
#line 2596
    if ((unsigned int )state == 2U) {
#line 2596
      goto case_2;
    }
#line 2606
    if ((unsigned int )state == 3U) {
#line 2606
      goto case_3___0;
    }
#line 2616
    if ((unsigned int )state == 4U) {
#line 2616
      goto case_4;
    }
#line 2621
    if ((unsigned int )state == 5U) {
#line 2621
      goto case_5;
    }
#line 2626
    if ((unsigned int )state == 6U) {
#line 2626
      goto case_6___0;
    }
#line 2631
    if ((unsigned int )state == 7U) {
#line 2631
      goto case_7___0;
    }
#line 2644
    if ((unsigned int )state == 9U) {
#line 2644
      goto case_9;
    }
#line 2644
    if ((unsigned int )state == 8U) {
#line 2644
      goto case_9;
    }
#line 2565
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2568
    if ((int )ch != 1) {
#line 2569
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2569
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent unsupported FastCGI protocol version: %d",
                           (int )ch);
        }
      }
#line 2572
      return ((ngx_int_t )-1);
    }
#line 2574
    state = (ngx_http_fastcgi_state_e )1;
#line 2575
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 2581
    if ((int )ch == 3) {
#line 2581
      goto case_3;
    }
#line 2581
    if ((int )ch == 7) {
#line 2581
      goto case_3;
    }
#line 2581
    if ((int )ch == 6) {
#line 2581
      goto case_3;
    }
#line 2584
    goto switch_default;
    case_3: /* CIL Label */ 
    case_7: /* CIL Label */ 
    case_6: /* CIL Label */ 
#line 2582
    f->type = (ngx_uint_t )ch;
#line 2583
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 2585
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2585
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid FastCGI record type: %d",
                         (int )ch);
      }
    }
#line 2588
    return ((ngx_int_t )-1);
    switch_break___0: /* CIL Label */ ;
    }
#line 2591
    state = (ngx_http_fastcgi_state_e )2;
#line 2592
    goto switch_break;
    case_2: /* CIL Label */ 
#line 2597
    if ((int )ch != 0) {
#line 2598
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2598
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent unexpected FastCGI request id high byte: %d",
                           (int )ch);
        }
      }
#line 2601
      return ((ngx_int_t )-1);
    }
#line 2603
    state = (ngx_http_fastcgi_state_e )3;
#line 2604
    goto switch_break;
    case_3___0: /* CIL Label */ 
#line 2607
    if ((int )ch != 1) {
#line 2608
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2608
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent unexpected FastCGI request id low byte: %d",
                           (int )ch);
        }
      }
#line 2611
      return ((ngx_int_t )-1);
    }
#line 2613
    state = (ngx_http_fastcgi_state_e )4;
#line 2614
    goto switch_break;
    case_4: /* CIL Label */ 
#line 2617
    f->length = (size_t )((int )ch << 8);
#line 2618
    state = (ngx_http_fastcgi_state_e )5;
#line 2619
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2622
    f->length |= (size_t )ch;
#line 2623
    state = (ngx_http_fastcgi_state_e )6;
#line 2624
    goto switch_break;
    case_6___0: /* CIL Label */ 
#line 2627
    f->padding = (size_t )ch;
#line 2628
    state = (ngx_http_fastcgi_state_e )7;
#line 2629
    goto switch_break;
    case_7___0: /* CIL Label */ 
#line 2632
    state = (ngx_http_fastcgi_state_e )8;
#line 2637
    f->pos = p + 1;
#line 2638
    f->state = state;
#line 2640
    return ((ngx_int_t )0);
    case_9: /* CIL Label */ 
    case_8: /* CIL Label */ 
#line 2645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 2558
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2649
  f->pos = p;
#line 2650
  f->state = state;
#line 2652
  return ((ngx_int_t )-2);
}
}
#line 2656 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static void ngx_http_fastcgi_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 2662
  return;
}
}
#line 2666 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static void ngx_http_fastcgi_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 2672
  return;
}
}
#line 2676 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;

  {
#line 2681
  v = ngx_http_fastcgi_vars;
  {
#line 2681
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2681
    if (! v->name.len) {
#line 2681
      goto while_break;
    }
    {
#line 2682
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 2683
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2684
      return ((ngx_int_t )-1);
    }
#line 2687
    var->get_handler = v->get_handler;
#line 2688
    var->data = v->data;
#line 2681
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2691
  return ((ngx_int_t )0);
}
}
#line 2695 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static void *ngx_http_fastcgi_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_fastcgi_main_conf_t *conf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 2700
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_fastcgi_main_conf_t ));
#line 2700
  conf = (ngx_http_fastcgi_main_conf_t *)tmp;
  }
#line 2701
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 2702
    return ((void *)0);
  }
  {
#line 2706
  tmp___0 = ngx_array_init(& conf->caches, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_file_cache_t *));
  }
#line 2706
  if (tmp___0 != 0L) {
#line 2710
    return ((void *)0);
  }
#line 2714
  return ((void *)conf);
}
}
#line 2718 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static void *ngx_http_fastcgi_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *conf ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2723
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_fastcgi_loc_conf_t ));
#line 2723
  conf = (ngx_http_fastcgi_loc_conf_t *)tmp;
  }
#line 2724
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 2725
    return ((void *)0);
  }
#line 2747
  conf->upstream.store = -1;
#line 2748
  conf->upstream.store_access = (ngx_uint_t )-1;
#line 2749
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 2750
  conf->upstream.buffering = (ngx_flag_t )-1;
#line 2751
  conf->upstream.request_buffering = (ngx_flag_t )-1;
#line 2752
  conf->upstream.ignore_client_abort = (ngx_flag_t )-1;
#line 2753
  conf->upstream.force_ranges = (ngx_flag_t )-1;
#line 2755
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 2757
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 2758
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 2759
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 2760
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 2762
  conf->upstream.send_lowat = (size_t )-1;
#line 2763
  conf->upstream.buffer_size = (size_t )-1;
#line 2764
  conf->upstream.limit_rate = (size_t )-1;
#line 2766
  conf->upstream.busy_buffers_size_conf = (size_t )-1;
#line 2767
  conf->upstream.max_temp_file_size_conf = (size_t )-1;
#line 2768
  conf->upstream.temp_file_write_size_conf = (size_t )-1;
#line 2770
  conf->upstream.pass_request_headers = (ngx_flag_t )-1;
#line 2771
  conf->upstream.pass_request_body = (ngx_flag_t )-1;
#line 2774
  conf->upstream.cache = -1;
#line 2775
  conf->upstream.cache_min_uses = (ngx_uint_t )-1;
#line 2776
  conf->upstream.cache_max_range_offset = (off_t )-1;
#line 2777
  conf->upstream.cache_bypass = (ngx_array_t *)((void *)-1);
#line 2778
  conf->upstream.no_cache = (ngx_array_t *)((void *)-1);
#line 2779
  conf->upstream.cache_valid = (ngx_array_t *)((void *)-1);
#line 2780
  conf->upstream.cache_lock = (ngx_flag_t )-1;
#line 2781
  conf->upstream.cache_lock_timeout = (ngx_msec_t )-1;
#line 2782
  conf->upstream.cache_lock_age = (ngx_msec_t )-1;
#line 2783
  conf->upstream.cache_revalidate = (ngx_flag_t )-1;
#line 2784
  conf->upstream.cache_background_update = (ngx_flag_t )-1;
#line 2787
  conf->upstream.hide_headers = (ngx_array_t *)((void *)-1);
#line 2788
  conf->upstream.pass_headers = (ngx_array_t *)((void *)-1);
#line 2790
  conf->upstream.intercept_errors = (ngx_flag_t )-1;
#line 2793
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 2795
  conf->upstream.change_buffering = 1U;
#line 2797
  conf->catch_stderr = (ngx_array_t *)((void *)-1);
#line 2799
  conf->keep_conn = (ngx_flag_t )-1;
#line 2801
  conf->upstream.module.len = sizeof("fastcgi") - 1UL;
#line 2801
  conf->upstream.module.data = (u_char *)"fastcgi";
#line 2803
  return ((void *)conf);
}
}
#line 2807 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_fastcgi_loc_conf_t *prev ;
  ngx_http_fastcgi_loc_conf_t *conf ;
  size_t size ;
  ngx_int_t rc ;
  ngx_hash_init_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  char *tmp ;
  ngx_shm_zone_t *shm_zone ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 2810
  prev = (ngx_http_fastcgi_loc_conf_t *)parent;
#line 2811
  conf = (ngx_http_fastcgi_loc_conf_t *)child;
#line 2820
  if (conf->upstream.store > 0) {
#line 2821
    conf->upstream.cache = 0;
  }
#line 2824
  if (conf->upstream.cache > 0) {
#line 2825
    conf->upstream.store = 0;
  }
#line 2830
  if (conf->upstream.store == -1) {
#line 2831
    if (conf->upstream.store == -1) {
#line 2831
      if (prev->upstream.store == -1) {
#line 2831
        conf->upstream.store = 0;
      } else {
#line 2831
        conf->upstream.store = prev->upstream.store;
      }
    }
#line 2834
    conf->upstream.store_lengths = prev->upstream.store_lengths;
#line 2835
    conf->upstream.store_values = prev->upstream.store_values;
  }
#line 2838
  if (conf->upstream.store_access == 0xffffffffffffffffUL) {
#line 2838
    if (prev->upstream.store_access == 0xffffffffffffffffUL) {
#line 2838
      conf->upstream.store_access = (ngx_uint_t )384;
    } else {
#line 2838
      conf->upstream.store_access = prev->upstream.store_access;
    }
  }
#line 2841
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 2841
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 2841
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 2841
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 2844
  if (conf->upstream.buffering == -1L) {
#line 2844
    if (prev->upstream.buffering == -1L) {
#line 2844
      conf->upstream.buffering = (ngx_flag_t )1;
    } else {
#line 2844
      conf->upstream.buffering = prev->upstream.buffering;
    }
  }
#line 2847
  if (conf->upstream.request_buffering == -1L) {
#line 2847
    if (prev->upstream.request_buffering == -1L) {
#line 2847
      conf->upstream.request_buffering = (ngx_flag_t )1;
    } else {
#line 2847
      conf->upstream.request_buffering = prev->upstream.request_buffering;
    }
  }
#line 2850
  if (conf->upstream.ignore_client_abort == -1L) {
#line 2850
    if (prev->upstream.ignore_client_abort == -1L) {
#line 2850
      conf->upstream.ignore_client_abort = (ngx_flag_t )0;
    } else {
#line 2850
      conf->upstream.ignore_client_abort = prev->upstream.ignore_client_abort;
    }
  }
#line 2853
  if (conf->upstream.force_ranges == -1L) {
#line 2853
    if (prev->upstream.force_ranges == -1L) {
#line 2853
      conf->upstream.force_ranges = (ngx_flag_t )0;
    } else {
#line 2853
      conf->upstream.force_ranges = prev->upstream.force_ranges;
    }
  }
#line 2856
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 2856
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 2856
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 2856
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 2859
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 2859
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 2859
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 2859
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 2862
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 2862
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 2862
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 2862
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 2865
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 2865
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 2865
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 2865
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 2868
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 2868
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 2868
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 2868
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 2871
  if (conf->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 2871
    if (prev->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 2871
      conf->upstream.send_lowat = (size_t )0;
    } else {
#line 2871
      conf->upstream.send_lowat = prev->upstream.send_lowat;
    }
  }
#line 2874
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 2874
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 2874
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 2874
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 2878
  if (conf->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 2878
    if (prev->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 2878
      conf->upstream.limit_rate = (size_t )0;
    } else {
#line 2878
      conf->upstream.limit_rate = prev->upstream.limit_rate;
    }
  }
#line 2882
  if (conf->upstream.bufs.num == 0L) {
#line 2882
    if (prev->upstream.bufs.num) {
#line 2882
      conf->upstream.bufs.num = prev->upstream.bufs.num;
#line 2882
      conf->upstream.bufs.size = prev->upstream.bufs.size;
    } else {
#line 2882
      conf->upstream.bufs.num = (ngx_int_t )8;
#line 2882
      conf->upstream.bufs.size = ngx_pagesize;
    }
  }
#line 2885
  if (conf->upstream.bufs.num < 2L) {
    {
#line 2886
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "there must be at least 2 \"fastcgi_buffers\"");
    }
#line 2888
    return ((char *)((void *)-1));
  }
#line 2892
  size = conf->upstream.buffer_size;
#line 2893
  if (size < conf->upstream.bufs.size) {
#line 2894
    size = conf->upstream.bufs.size;
  }
#line 2898
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 2898
    if (prev->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 2898
      conf->upstream.busy_buffers_size_conf = (size_t )-1;
    } else {
#line 2898
      conf->upstream.busy_buffers_size_conf = prev->upstream.busy_buffers_size_conf;
    }
  }
#line 2902
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 2903
    conf->upstream.busy_buffers_size = 2UL * size;
  } else {
#line 2905
    conf->upstream.busy_buffers_size = conf->upstream.busy_buffers_size_conf;
  }
#line 2909
  if (conf->upstream.busy_buffers_size < size) {
    {
#line 2910
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_busy_buffers_size\" must be equal to or greater than the maximum of the value of \"fastcgi_buffer_size\" and one of the \"fastcgi_buffers\"");
    }
#line 2915
    return ((char *)((void *)-1));
  }
#line 2918
  if (conf->upstream.busy_buffers_size > (size_t )(conf->upstream.bufs.num - 1L) * conf->upstream.bufs.size) {
    {
#line 2921
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_busy_buffers_size\" must be less than the size of all \"fastcgi_buffers\" minus one buffer");
    }
#line 2925
    return ((char *)((void *)-1));
  }
#line 2929
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 2929
    if (prev->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 2929
      conf->upstream.temp_file_write_size_conf = (size_t )-1;
    } else {
#line 2929
      conf->upstream.temp_file_write_size_conf = prev->upstream.temp_file_write_size_conf;
    }
  }
#line 2933
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 2934
    conf->upstream.temp_file_write_size = 2UL * size;
  } else {
#line 2936
    conf->upstream.temp_file_write_size = conf->upstream.temp_file_write_size_conf;
  }
#line 2940
  if (conf->upstream.temp_file_write_size < size) {
    {
#line 2941
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_temp_file_write_size\" must be equal to or greater than the maximum of the value of \"fastcgi_buffer_size\" and one of the \"fastcgi_buffers\"");
    }
#line 2946
    return ((char *)((void *)-1));
  }
#line 2950
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 2950
    if (prev->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 2950
      conf->upstream.max_temp_file_size_conf = (size_t )-1;
    } else {
#line 2950
      conf->upstream.max_temp_file_size_conf = prev->upstream.max_temp_file_size_conf;
    }
  }
#line 2954
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 2955
    conf->upstream.max_temp_file_size = (size_t )1073741824;
  } else {
#line 2957
    conf->upstream.max_temp_file_size = conf->upstream.max_temp_file_size_conf;
  }
#line 2961
  if (conf->upstream.max_temp_file_size != 0UL) {
#line 2961
    if (conf->upstream.max_temp_file_size < size) {
      {
#line 2964
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_max_temp_file_size\" must be equal to zero to disable temporary files usage or must be equal to or greater than the maximum of the value of \"fastcgi_buffer_size\" and one of the \"fastcgi_buffers\"");
      }
#line 2970
      return ((char *)((void *)-1));
    }
  }
#line 2974
  if (conf->upstream.ignore_headers == 0UL) {
#line 2974
    if (prev->upstream.ignore_headers == 0UL) {
#line 2974
      conf->upstream.ignore_headers = (ngx_uint_t )1;
    } else {
#line 2974
      conf->upstream.ignore_headers = prev->upstream.ignore_headers;
    }
  }
#line 2979
  if (conf->upstream.next_upstream == 0UL) {
#line 2979
    if (prev->upstream.next_upstream == 0UL) {
#line 2979
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 2979
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 2985
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 2986
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
  {
#line 2990
  tmp = ngx_conf_merge_path_value(cf, & conf->upstream.temp_path, prev->upstream.temp_path,
                                  & ngx_http_fastcgi_temp_path);
  }
#line 2990
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 2995
    return ((char *)((void *)-1));
  }
#line 3000
  if (conf->upstream.cache == -1) {
#line 3001
    if (conf->upstream.cache == -1) {
#line 3001
      if (prev->upstream.cache == -1) {
#line 3001
        conf->upstream.cache = 0;
      } else {
#line 3001
        conf->upstream.cache = prev->upstream.cache;
      }
    }
#line 3004
    conf->upstream.cache_zone = prev->upstream.cache_zone;
#line 3005
    conf->upstream.cache_value = prev->upstream.cache_value;
  }
#line 3008
  if (conf->upstream.cache_zone) {
#line 3008
    if ((unsigned long )(conf->upstream.cache_zone)->data == (unsigned long )((void *)0)) {
      {
#line 3011
      shm_zone = conf->upstream.cache_zone;
#line 3013
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"fastcgi_cache\" zone \"%V\" is unknown",
                         & shm_zone->shm.name);
      }
#line 3017
      return ((char *)((void *)-1));
    }
  }
#line 3020
  if (conf->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 3020
    if (prev->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 3020
      conf->upstream.cache_min_uses = (ngx_uint_t )1;
    } else {
#line 3020
      conf->upstream.cache_min_uses = prev->upstream.cache_min_uses;
    }
  }
#line 3023
  if (conf->upstream.cache_max_range_offset == -1L) {
#line 3023
    if (prev->upstream.cache_max_range_offset == -1L) {
#line 3023
      conf->upstream.cache_max_range_offset = (off_t )9223372036854775807LL;
    } else {
#line 3023
      conf->upstream.cache_max_range_offset = prev->upstream.cache_max_range_offset;
    }
  }
#line 3027
  if (conf->upstream.cache_use_stale == 0UL) {
#line 3027
    if (prev->upstream.cache_use_stale == 0UL) {
#line 3027
      conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
    } else {
#line 3027
      conf->upstream.cache_use_stale = prev->upstream.cache_use_stale;
    }
  }
#line 3032
  if (conf->upstream.cache_use_stale & 2147483648UL) {
#line 3033
    conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
  }
#line 3037
  if (conf->upstream.cache_use_stale & 2UL) {
#line 3038
    conf->upstream.cache_use_stale |= 1073741824UL;
  }
#line 3041
  if (conf->upstream.cache_methods == 0UL) {
#line 3042
    conf->upstream.cache_methods = prev->upstream.cache_methods;
  }
#line 3045
  conf->upstream.cache_methods |= 6UL;
#line 3047
  if ((unsigned long )conf->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 3047
    if ((unsigned long )prev->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 3047
      conf->upstream.cache_bypass = (ngx_array_t *)((void *)0);
    } else {
#line 3047
      conf->upstream.cache_bypass = prev->upstream.cache_bypass;
    }
  }
#line 3050
  if ((unsigned long )conf->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 3050
    if ((unsigned long )prev->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 3050
      conf->upstream.no_cache = (ngx_array_t *)((void *)0);
    } else {
#line 3050
      conf->upstream.no_cache = prev->upstream.no_cache;
    }
  }
#line 3053
  if ((unsigned long )conf->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 3053
    if ((unsigned long )prev->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 3053
      conf->upstream.cache_valid = (ngx_array_t *)((void *)0);
    } else {
#line 3053
      conf->upstream.cache_valid = prev->upstream.cache_valid;
    }
  }
#line 3056
  if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
#line 3057
    conf->cache_key = prev->cache_key;
  }
#line 3060
  if (conf->upstream.cache) {
#line 3060
    if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
      {
#line 3061
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no \"fastcgi_cache_key\" for \"fastcgi_cache\"");
      }
    }
  }
#line 3065
  if (conf->upstream.cache_lock == -1L) {
#line 3065
    if (prev->upstream.cache_lock == -1L) {
#line 3065
      conf->upstream.cache_lock = (ngx_flag_t )0;
    } else {
#line 3065
      conf->upstream.cache_lock = prev->upstream.cache_lock;
    }
  }
#line 3068
  if (conf->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 3068
    if (prev->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 3068
      conf->upstream.cache_lock_timeout = (ngx_msec_t )5000;
    } else {
#line 3068
      conf->upstream.cache_lock_timeout = prev->upstream.cache_lock_timeout;
    }
  }
#line 3071
  if (conf->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 3071
    if (prev->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 3071
      conf->upstream.cache_lock_age = (ngx_msec_t )5000;
    } else {
#line 3071
      conf->upstream.cache_lock_age = prev->upstream.cache_lock_age;
    }
  }
#line 3074
  if (conf->upstream.cache_revalidate == -1L) {
#line 3074
    if (prev->upstream.cache_revalidate == -1L) {
#line 3074
      conf->upstream.cache_revalidate = (ngx_flag_t )0;
    } else {
#line 3074
      conf->upstream.cache_revalidate = prev->upstream.cache_revalidate;
    }
  }
#line 3077
  if (conf->upstream.cache_background_update == -1L) {
#line 3077
    if (prev->upstream.cache_background_update == -1L) {
#line 3077
      conf->upstream.cache_background_update = (ngx_flag_t )0;
    } else {
#line 3077
      conf->upstream.cache_background_update = prev->upstream.cache_background_update;
    }
  }
#line 3082
  if (conf->upstream.pass_request_headers == -1L) {
#line 3082
    if (prev->upstream.pass_request_headers == -1L) {
#line 3082
      conf->upstream.pass_request_headers = (ngx_flag_t )1;
    } else {
#line 3082
      conf->upstream.pass_request_headers = prev->upstream.pass_request_headers;
    }
  }
#line 3084
  if (conf->upstream.pass_request_body == -1L) {
#line 3084
    if (prev->upstream.pass_request_body == -1L) {
#line 3084
      conf->upstream.pass_request_body = (ngx_flag_t )1;
    } else {
#line 3084
      conf->upstream.pass_request_body = prev->upstream.pass_request_body;
    }
  }
#line 3087
  if (conf->upstream.intercept_errors == -1L) {
#line 3087
    if (prev->upstream.intercept_errors == -1L) {
#line 3087
      conf->upstream.intercept_errors = (ngx_flag_t )0;
    } else {
#line 3087
      conf->upstream.intercept_errors = prev->upstream.intercept_errors;
    }
  }
#line 3090
  if ((unsigned long )conf->catch_stderr == (unsigned long )((void *)-1)) {
#line 3090
    if ((unsigned long )prev->catch_stderr == (unsigned long )((void *)-1)) {
#line 3090
      conf->catch_stderr = (ngx_array_t *)((void *)0);
    } else {
#line 3090
      conf->catch_stderr = prev->catch_stderr;
    }
  }
#line 3092
  if (conf->keep_conn == -1L) {
#line 3092
    if (prev->keep_conn == -1L) {
#line 3092
      conf->keep_conn = (ngx_flag_t )0;
    } else {
#line 3092
      conf->keep_conn = prev->keep_conn;
    }
  }
#line 3095
  if ((unsigned long )conf->index.data == (unsigned long )((void *)0)) {
#line 3095
    if (prev->index.data) {
#line 3095
      conf->index.len = prev->index.len;
#line 3095
      conf->index.data = prev->index.data;
    } else {
#line 3095
      conf->index.len = sizeof("") - 1UL;
#line 3095
      conf->index.data = (u_char *)"";
    }
  }
  {
#line 3097
  hash.max_size = (ngx_uint_t )512;
#line 3098
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3099
  hash.name = (char *)"fastcgi_hide_headers_hash";
#line 3101
  tmp___0 = ngx_http_upstream_hide_headers_hash(cf, & conf->upstream, & prev->upstream,
                                                ngx_http_fastcgi_hide_headers, & hash);
  }
#line 3101
  if (tmp___0 != 0L) {
#line 3105
    return ((char *)((void *)-1));
  }
#line 3108
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 3110
  if (clcf->noname) {
#line 3110
    if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 3110
      if ((unsigned long )conf->fastcgi_lengths == (unsigned long )((void *)0)) {
#line 3113
        conf->upstream.upstream = prev->upstream.upstream;
#line 3114
        conf->fastcgi_lengths = prev->fastcgi_lengths;
#line 3115
        conf->fastcgi_values = prev->fastcgi_values;
      }
    }
  }
#line 3118
  if (clcf->lmt_excpt) {
#line 3118
    if ((unsigned long )clcf->handler == (unsigned long )((void *)0)) {
#line 3118
      if (conf->upstream.upstream) {
#line 3121
        clcf->handler = & ngx_http_fastcgi_handler;
      } else
#line 3118
      if (conf->fastcgi_lengths) {
#line 3121
        clcf->handler = & ngx_http_fastcgi_handler;
      }
    }
  }
#line 3125
  if ((unsigned long )conf->split_regex == (unsigned long )((void *)0)) {
#line 3126
    conf->split_regex = prev->split_regex;
#line 3127
    conf->split_name = prev->split_name;
  }
#line 3131
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 3132
    conf->params = prev->params;
#line 3134
    conf->params_cache = prev->params_cache;
#line 3136
    conf->params_source = prev->params_source;
  }
  {
#line 3139
  rc = ngx_http_fastcgi_init_params(cf, conf, & conf->params, (ngx_keyval_t *)((void *)0));
  }
#line 3140
  if (rc != 0L) {
#line 3141
    return ((char *)((void *)-1));
  }
#line 3146
  if (conf->upstream.cache) {
    {
#line 3147
    rc = ngx_http_fastcgi_init_params(cf, conf, & conf->params_cache, ngx_http_fastcgi_cache_headers);
    }
#line 3149
    if (rc != 0L) {
#line 3150
      return ((char *)((void *)-1));
    }
  }
#line 3161
  if ((unsigned long )prev->params.hash.buckets == (unsigned long )((void *)0)) {
#line 3161
    if ((unsigned long )conf->params_source == (unsigned long )prev->params_source) {
#line 3164
      prev->params = conf->params;
#line 3166
      prev->params_cache = conf->params_cache;
    }
  }
#line 3170
  return ((char *)((void *)0));
}
}
#line 3174 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_init_params(ngx_conf_t *cf , ngx_http_fastcgi_loc_conf_t *conf ,
                                              ngx_http_fastcgi_params_t *params ,
                                              ngx_keyval_t *default_params ) 
{ 
  u_char *p ;
  size_t size ;
  uintptr_t *code ;
  ngx_uint_t i ;
  ngx_uint_t nsrc ;
  ngx_array_t headers_names ;
  ngx_array_t params_merged ;
  ngx_keyval_t *h ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_upstream_param_t *src ;
  ngx_http_upstream_param_t *s ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_copy_code_t *copy ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  ngx_int_t tmp___13 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 3190
  if (params->hash.buckets) {
#line 3191
    return ((ngx_int_t )0);
  }
#line 3194
  if ((unsigned long )conf->params_source == (unsigned long )((void *)0)) {
#line 3194
    if ((unsigned long )default_params == (unsigned long )((void *)0)) {
#line 3195
      params->hash.buckets = (ngx_hash_elt_t **)((void *)1);
#line 3196
      return ((ngx_int_t )0);
    }
  }
  {
#line 3199
  params->lengths = ngx_array_create(cf->pool, (ngx_uint_t )64, (size_t )1);
  }
#line 3200
  if ((unsigned long )params->lengths == (unsigned long )((void *)0)) {
#line 3201
    return ((ngx_int_t )-1);
  }
  {
#line 3204
  params->values = ngx_array_create(cf->pool, (ngx_uint_t )512, (size_t )1);
  }
#line 3205
  if ((unsigned long )params->values == (unsigned long )((void *)0)) {
#line 3206
    return ((ngx_int_t )-1);
  }
  {
#line 3209
  tmp = ngx_array_init(& headers_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 3209
  if (tmp != 0L) {
#line 3212
    return ((ngx_int_t )-1);
  }
#line 3215
  if (conf->params_source) {
#line 3216
    src = (ngx_http_upstream_param_t *)(conf->params_source)->elts;
#line 3217
    nsrc = (conf->params_source)->nelts;
  } else {
#line 3220
    src = (ngx_http_upstream_param_t *)((void *)0);
#line 3221
    nsrc = (ngx_uint_t )0;
  }
#line 3224
  if (default_params) {
    {
#line 3225
    tmp___0 = ngx_array_init(& params_merged, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_param_t ));
    }
#line 3225
    if (tmp___0 != 0L) {
#line 3229
      return ((ngx_int_t )-1);
    }
#line 3232
    i = (ngx_uint_t )0;
    {
#line 3232
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3232
      if (! (i < nsrc)) {
#line 3232
        goto while_break;
      }
      {
#line 3234
      tmp___1 = ngx_array_push(& params_merged);
#line 3234
      s = (ngx_http_upstream_param_t *)tmp___1;
      }
#line 3235
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3236
        return ((ngx_int_t )-1);
      }
#line 3239
      *s = *(src + i);
#line 3232
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 3242
    h = default_params;
    {
#line 3244
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3244
      if (! h->key.len) {
#line 3244
        goto while_break___0;
      }
#line 3246
      src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 3247
      nsrc = params_merged.nelts;
#line 3249
      i = (ngx_uint_t )0;
      {
#line 3249
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3249
        if (! (i < nsrc)) {
#line 3249
          goto while_break___1;
        }
        {
#line 3250
        tmp___2 = ngx_strcasecmp(h->key.data, (src + i)->key.data);
        }
#line 3250
        if (tmp___2 == 0L) {
#line 3251
          goto next;
        }
#line 3249
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 3255
      tmp___3 = ngx_array_push(& params_merged);
#line 3255
      s = (ngx_http_upstream_param_t *)tmp___3;
      }
#line 3256
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3257
        return ((ngx_int_t )-1);
      }
#line 3260
      s->key = h->key;
#line 3261
      s->value = h->value;
#line 3262
      s->skip_empty = (ngx_uint_t )1;
      next: 
#line 3266
      h ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3269
    src = (ngx_http_upstream_param_t *)params_merged.elts;
#line 3270
    nsrc = params_merged.nelts;
  }
#line 3273
  i = (ngx_uint_t )0;
  {
#line 3273
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3273
    if (! (i < nsrc)) {
#line 3273
      goto while_break___2;
    }
#line 3275
    if ((src + i)->key.len > sizeof("HTTP_") - 1UL) {
      {
#line 3275
      tmp___5 = strncmp((char const   *)(src + i)->key.data, "HTTP_", sizeof("HTTP_") - 1UL);
      }
#line 3275
      if (tmp___5 == 0) {
        {
#line 3278
        tmp___4 = ngx_array_push(& headers_names);
#line 3278
        hk = (ngx_hash_key_t *)tmp___4;
        }
#line 3279
        if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 3280
          return ((ngx_int_t )-1);
        }
        {
#line 3283
        hk->key.len = (src + i)->key.len - 5UL;
#line 3284
        hk->key.data = (src + i)->key.data + 5;
#line 3285
        hk->key_hash = ngx_hash_key_lc(hk->key.data, hk->key.len);
#line 3286
        hk->value = (void *)1;
        }
#line 3288
        if ((src + i)->value.len == 0UL) {
#line 3289
          goto __Cont;
        }
      }
    }
    {
#line 3293
    tmp___6 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 3293
    copy = (ngx_http_script_copy_code_t *)tmp___6;
    }
#line 3295
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3296
      return ((ngx_int_t )-1);
    }
    {
#line 3299
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 3300
    copy->len = (src + i)->key.len;
#line 3302
    tmp___7 = ngx_array_push_n(params->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 3302
    copy = (ngx_http_script_copy_code_t *)tmp___7;
    }
#line 3304
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3305
      return ((ngx_int_t )-1);
    }
    {
#line 3308
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 3309
    copy->len = (src + i)->skip_empty;
#line 3312
    size = (((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 3316
    tmp___8 = ngx_array_push_n(params->values, size);
#line 3316
    copy = (ngx_http_script_copy_code_t *)tmp___8;
    }
#line 3317
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3318
      return ((ngx_int_t )-1);
    }
    {
#line 3321
    copy->code = & ngx_http_script_copy_code;
#line 3322
    copy->len = (src + i)->key.len;
#line 3324
    p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 3325
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(src + i)->key.data,
           (src + i)->key.len);
#line 3328
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3330
    sc.cf = cf;
#line 3331
    sc.source = & (src + i)->value;
#line 3332
    sc.flushes = & params->flushes;
#line 3333
    sc.lengths = & params->lengths;
#line 3334
    sc.values = & params->values;
#line 3336
    tmp___9 = ngx_http_script_compile(& sc);
    }
#line 3336
    if (tmp___9 != 0L) {
#line 3337
      return ((ngx_int_t )-1);
    }
    {
#line 3340
    tmp___10 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 3340
    code = (uintptr_t *)tmp___10;
    }
#line 3341
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3342
      return ((ngx_int_t )-1);
    }
    {
#line 3345
    *code = (uintptr_t )((void *)0);
#line 3348
    tmp___11 = ngx_array_push_n(params->values, sizeof(uintptr_t ));
#line 3348
    code = (uintptr_t *)tmp___11;
    }
#line 3349
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3350
      return ((ngx_int_t )-1);
    }
#line 3353
    *code = (uintptr_t )((void *)0);
    __Cont: /* CIL Label */ 
#line 3273
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 3356
  tmp___12 = ngx_array_push_n(params->lengths, sizeof(uintptr_t ));
#line 3356
  code = (uintptr_t *)tmp___12;
  }
#line 3357
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3358
    return ((ngx_int_t )-1);
  }
  {
#line 3361
  *code = (uintptr_t )((void *)0);
#line 3363
  params->number = headers_names.nelts;
#line 3365
  hash.hash = & params->hash;
#line 3366
  hash.key = & ngx_hash_key_lc;
#line 3367
  hash.max_size = (ngx_uint_t )512;
#line 3368
  hash.bucket_size = (ngx_uint_t )64;
#line 3369
  hash.name = (char *)"fastcgi_params_hash";
#line 3370
  hash.pool = cf->pool;
#line 3371
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 3373
  tmp___13 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_names.elts, headers_names.nelts);
  }
#line 3373
  return (tmp___13);
}
}
#line 3377 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_script_name_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  u_char *p ;
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_loc_conf_t *flcf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 3385
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 3387
  f = ngx_http_fastcgi_split(r, flcf);
  }
#line 3389
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 3390
    return ((ngx_int_t )-1);
  }
#line 3393
  if (f->script_name.len == 0UL) {
#line 3393
    goto _L;
  } else
#line 3393
  if ((int )*(f->script_name.data + (f->script_name.len - 1UL)) != 47) {
    _L: /* CIL Label */ 
#line 3396
    v->len = (unsigned int )f->script_name.len;
#line 3397
    v->valid = 1U;
#line 3398
    v->no_cacheable = 0U;
#line 3399
    v->not_found = 0U;
#line 3400
    v->data = f->script_name.data;
#line 3402
    return ((ngx_int_t )0);
  }
  {
#line 3405
  v->len = (unsigned int )(f->script_name.len + flcf->index.len);
#line 3407
  tmp = ngx_pnalloc(r->pool, (size_t )v->len);
#line 3407
  v->data = (u_char *)tmp;
  }
#line 3408
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 3409
    return ((ngx_int_t )-1);
  }
  {
#line 3412
  tmp___0 = memcpy((void */* __restrict  */)v->data, (void const   */* __restrict  */)f->script_name.data,
                   f->script_name.len);
#line 3412
  p = (u_char *)tmp___0 + f->script_name.len;
#line 3413
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)flcf->index.data,
         flcf->index.len);
  }
#line 3415
  return ((ngx_int_t )0);
}
}
#line 3419 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_int_t ngx_http_fastcgi_path_info_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) 
{ 
  ngx_http_fastcgi_ctx_t *f ;
  ngx_http_fastcgi_loc_conf_t *flcf ;

  {
  {
#line 3426
  flcf = (ngx_http_fastcgi_loc_conf_t *)*(r->loc_conf + ngx_http_fastcgi_module.ctx_index);
#line 3428
  f = ngx_http_fastcgi_split(r, flcf);
  }
#line 3430
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 3431
    return ((ngx_int_t )-1);
  }
#line 3434
  v->len = (unsigned int )f->path_info.len;
#line 3435
  v->valid = 1U;
#line 3436
  v->no_cacheable = 0U;
#line 3437
  v->not_found = 0U;
#line 3438
  v->data = f->path_info.data;
#line 3440
  return ((ngx_int_t )0);
}
}
#line 3444 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static ngx_http_fastcgi_ctx_t *ngx_http_fastcgi_split(ngx_http_request_t *r , ngx_http_fastcgi_loc_conf_t *flcf ) 
{ 
  ngx_http_fastcgi_ctx_t *f ;
  ngx_int_t n ;
  int captures[9] ;
  void *tmp ;
  int tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3452
  f = (ngx_http_fastcgi_ctx_t *)*(r->ctx + ngx_http_fastcgi_module.ctx_index);
#line 3454
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 3455
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_fastcgi_ctx_t ));
#line 3455
    f = (ngx_http_fastcgi_ctx_t *)tmp;
    }
#line 3456
    if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 3457
      return ((ngx_http_fastcgi_ctx_t *)((void *)0));
    }
#line 3460
    *(r->ctx + ngx_http_fastcgi_module.ctx_index) = (void *)f;
  }
#line 3463
  if (f->script_name.len) {
#line 3464
    return (f);
  }
#line 3467
  if ((unsigned long )flcf->split_regex == (unsigned long )((void *)0)) {
#line 3468
    f->script_name = r->uri;
#line 3469
    return (f);
  }
  {
#line 3472
  tmp___0 = pcre_exec((pcre const   *)(flcf->split_regex)->code, (pcre_extra const   *)(flcf->split_regex)->extra,
                      (char const   *)r->uri.data, (int )r->uri.len, 0, 0, captures,
                      9);
#line 3472
  n = (ngx_int_t )tmp___0;
  }
#line 3474
  if (n >= 0L) {
#line 3475
    f->script_name.len = (size_t )(captures[3] - captures[2]);
#line 3476
    f->script_name.data = r->uri.data + captures[2];
#line 3478
    f->path_info.len = (size_t )(captures[5] - captures[4]);
#line 3479
    f->path_info.data = r->uri.data + captures[4];
#line 3481
    return (f);
  }
#line 3484
  if (n == -1L) {
#line 3485
    f->script_name = r->uri;
#line 3486
    return (f);
  }
#line 3489
  if (((r->connection)->log)->log_level >= 2UL) {
    {
#line 3489
    ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "pcre_exec() failed: %i on \"%V\" using \"%V\"",
                       n, & r->uri, & flcf->split_name);
    }
  }
#line 3492
  return ((ngx_http_fastcgi_ctx_t *)((void *)0));
}
}
#line 3515 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_url_t u ;
  ngx_str_t *value ;
  ngx_str_t *url ;
  ngx_uint_t n ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 3518
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3526
  if (flcf->upstream.upstream) {
#line 3527
    return ((char *)"is duplicate");
  } else
#line 3526
  if (flcf->fastcgi_lengths) {
#line 3527
    return ((char *)"is duplicate");
  }
#line 3530
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 3532
  clcf->handler = & ngx_http_fastcgi_handler;
#line 3534
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 3535
    clcf->auto_redirect = 1U;
  }
  {
#line 3538
  value = (ngx_str_t *)(cf->args)->elts;
#line 3540
  url = value + 1;
#line 3542
  n = ngx_http_script_variables_count(url);
  }
#line 3544
  if (n) {
    {
#line 3546
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3548
    sc.cf = cf;
#line 3549
    sc.source = url;
#line 3550
    sc.lengths = & flcf->fastcgi_lengths;
#line 3551
    sc.values = & flcf->fastcgi_values;
#line 3552
    sc.variables = n;
#line 3553
    sc.complete_lengths = 1U;
#line 3554
    sc.complete_values = 1U;
#line 3556
    tmp = ngx_http_script_compile(& sc);
    }
#line 3556
    if (tmp != 0L) {
#line 3557
      return ((char *)((void *)-1));
    }
#line 3560
    return ((char *)((void *)0));
  }
  {
#line 3563
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 3565
  u.url = *(value + 1);
#line 3566
  u.no_resolve = 1U;
#line 3568
  flcf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 3569
  if ((unsigned long )flcf->upstream.upstream == (unsigned long )((void *)0)) {
#line 3570
    return ((char *)((void *)-1));
  }
#line 3573
  return ((char *)((void *)0));
}
}
#line 3577 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_split_path_info(ngx_conf_t *cf , ngx_command_t *cmd ,
                                              void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_str_t *value ;
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;
  ngx_int_t tmp ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 3581
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3587
  value = (ngx_str_t *)(cf->args)->elts;
#line 3589
  flcf->split_name = *(value + 1);
#line 3591
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 3593
  rc.pattern = *(value + 1);
#line 3594
  rc.pool = cf->pool;
#line 3595
  rc.err.len = (size_t )1024;
#line 3596
  rc.err.data = errstr;
#line 3598
  tmp = ngx_regex_compile(& rc);
  }
#line 3598
  if (tmp != 0L) {
    {
#line 3599
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V", & rc.err);
    }
#line 3600
    return ((char *)((void *)-1));
  }
#line 3603
  if (rc.captures != 2) {
    {
#line 3604
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "pattern \"%V\" must have 2 captures",
                       value + 1);
    }
#line 3606
    return ((char *)((void *)-1));
  }
#line 3609
  flcf->split_regex = rc.regex;
#line 3611
  return ((char *)((void *)0));
}
}
#line 3623 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_str_t *value ;
  ngx_http_script_compile_t sc ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 3626
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3631
  if (flcf->upstream.store != -1) {
#line 3632
    return ((char *)"is duplicate");
  }
  {
#line 3635
  value = (ngx_str_t *)(cf->args)->elts;
#line 3637
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 3637
  if (tmp == 0) {
#line 3638
    flcf->upstream.store = 0;
#line 3639
    return ((char *)((void *)0));
  }
#line 3643
  if (flcf->upstream.cache > 0) {
#line 3644
    return ((char *)"is incompatible with \"fastcgi_cache\"");
  }
  {
#line 3648
  flcf->upstream.store = 1;
#line 3650
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 3650
  if (tmp___0 == 0) {
#line 3651
    return ((char *)((void *)0));
  }
  {
#line 3655
  ((value + 1)->len) ++;
#line 3657
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3659
  sc.cf = cf;
#line 3660
  sc.source = value + 1;
#line 3661
  sc.lengths = & flcf->upstream.store_lengths;
#line 3662
  sc.values = & flcf->upstream.store_values;
#line 3663
  sc.variables = ngx_http_script_variables_count(value + 1);
#line 3664
  sc.complete_lengths = 1U;
#line 3665
  sc.complete_values = 1U;
#line 3667
  tmp___1 = ngx_http_script_compile(& sc);
  }
#line 3667
  if (tmp___1 != 0L) {
#line 3668
    return ((char *)((void *)-1));
  }
#line 3671
  return ((char *)((void *)0));
}
}
#line 3677 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 3680
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3686
  value = (ngx_str_t *)(cf->args)->elts;
#line 3688
  if (flcf->upstream.cache != -1) {
#line 3689
    return ((char *)"is duplicate");
  }
  {
#line 3692
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 3692
  if (tmp == 0) {
#line 3693
    flcf->upstream.cache = 0;
#line 3694
    return ((char *)((void *)0));
  }
#line 3697
  if (flcf->upstream.store > 0) {
#line 3698
    return ((char *)"is incompatible with \"fastcgi_store\"");
  }
  {
#line 3701
  flcf->upstream.cache = 1;
#line 3703
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3705
  ccv.cf = cf;
#line 3706
  ccv.value = value + 1;
#line 3707
  ccv.complex_value = & cv;
#line 3709
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 3709
  if (tmp___0 != 0L) {
#line 3710
    return ((char *)((void *)-1));
  }
#line 3713
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 3715
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 3715
    flcf->upstream.cache_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 3717
    if ((unsigned long )flcf->upstream.cache_value == (unsigned long )((void *)0)) {
#line 3718
      return ((char *)((void *)-1));
    }
#line 3721
    *(flcf->upstream.cache_value) = cv;
#line 3723
    return ((char *)((void *)0));
  }
  {
#line 3726
  flcf->upstream.cache_zone = ngx_shared_memory_add(cf, value + 1, (size_t )0, (void *)(& ngx_http_fastcgi_module));
  }
#line 3728
  if ((unsigned long )flcf->upstream.cache_zone == (unsigned long )((void *)0)) {
#line 3729
    return ((char *)((void *)-1));
  }
#line 3732
  return ((char *)((void *)0));
}
}
#line 3736 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_fastcgi_loc_conf_t *flcf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;

  {
#line 3739
  flcf = (ngx_http_fastcgi_loc_conf_t *)conf;
#line 3744
  value = (ngx_str_t *)(cf->args)->elts;
#line 3746
  if (flcf->cache_key.value.data) {
#line 3747
    return ((char *)"is duplicate");
  }
  {
#line 3750
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3752
  ccv.cf = cf;
#line 3753
  ccv.value = value + 1;
#line 3754
  ccv.complex_value = & flcf->cache_key;
#line 3756
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 3756
  if (tmp != 0L) {
#line 3757
    return ((char *)((void *)-1));
  }
#line 3760
  return ((char *)((void *)0));
}
}
#line 3766 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_fastcgi_module.c"
static char *ngx_http_fastcgi_lowat_check(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ssize_t *np ;
  char *__cil_tmp5 ;

  {
  {
#line 3782
  np = (ssize_t *)data;
#line 3784
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "\"fastcgi_send_lowat\" is not supported, ignored");
#line 3787
  *np = (ssize_t )0;
  }
#line 3791
  return ((char *)((void *)0));
}
}
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 165 "src/core/ngx_string.h"
u_char *ngx_strcasestrn(u_char *s1 , char *s2 , size_t n ) ;
#line 168
ngx_int_t ngx_rstrncmp(u_char *s1 , u_char *s2 , size_t n ) ;
#line 169
ngx_int_t ngx_rstrncasecmp(u_char *s1 , u_char *s2 , size_t n ) ;
#line 284 "src/core/ngx_conf_file.h"
char *ngx_conf_set_keyval_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 291
char *ngx_conf_set_enum_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 87 "src/http/ngx_http_variables.h"
ngx_http_regex_t *ngx_http_regex_compile(ngx_conf_t *cf , ngx_regex_compile_t *rc ) ;
#line 89
ngx_int_t ngx_http_regex_exec(ngx_http_request_t *r , ngx_http_regex_t *re , ngx_str_t *s ) ;
#line 211 "src/http/ngx_http_script.h"
char *ngx_http_set_complex_value_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 110 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_chunked(ngx_http_request_t *r , ngx_buf_t *b , ngx_http_chunked_t *ctx ) ;
#line 122 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_eval(ngx_http_request_t *r , ngx_http_proxy_ctx_t *ctx ,
                                     ngx_http_proxy_loc_conf_t *plcf ) ;
#line 125
static ngx_int_t ngx_http_proxy_create_key(ngx_http_request_t *r ) ;
#line 127
static ngx_int_t ngx_http_proxy_create_request(ngx_http_request_t *r ) ;
#line 128
static ngx_int_t ngx_http_proxy_reinit_request(ngx_http_request_t *r ) ;
#line 129
static ngx_int_t ngx_http_proxy_body_output_filter(void *data , ngx_chain_t *in ) ;
#line 130
static ngx_int_t ngx_http_proxy_process_status_line(ngx_http_request_t *r ) ;
#line 131
static ngx_int_t ngx_http_proxy_process_header(ngx_http_request_t *r ) ;
#line 132
static ngx_int_t ngx_http_proxy_input_filter_init(void *data ) ;
#line 133
static ngx_int_t ngx_http_proxy_copy_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
#line 135
static ngx_int_t ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) ;
#line 137
static ngx_int_t ngx_http_proxy_non_buffered_copy_filter(void *data , ssize_t bytes ) ;
#line 139
static ngx_int_t ngx_http_proxy_non_buffered_chunked_filter(void *data , ssize_t bytes ) ;
#line 141
static void ngx_http_proxy_abort_request(ngx_http_request_t *r ) ;
#line 142
static void ngx_http_proxy_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 145
static ngx_int_t ngx_http_proxy_host_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 147
static ngx_int_t ngx_http_proxy_port_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 149
static ngx_int_t ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r ,
                                                             ngx_http_variable_value_t *v ,
                                                             uintptr_t data ) ;
#line 152
static ngx_int_t ngx_http_proxy_internal_body_length_variable(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ) ;
#line 155
static ngx_int_t ngx_http_proxy_internal_chunked_variable(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) ;
#line 157
static ngx_int_t ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                 size_t prefix ) ;
#line 159
static ngx_int_t ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ) ;
#line 161
static ngx_int_t ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     u_char *value , ngx_array_t *rewrites ) ;
#line 163
static ngx_int_t ngx_http_proxy_rewrite(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                        size_t prefix , size_t len , ngx_str_t *replacement ) ;
#line 166
static ngx_int_t ngx_http_proxy_add_variables(ngx_conf_t *cf ) ;
#line 167
static void *ngx_http_proxy_create_main_conf(ngx_conf_t *cf ) ;
#line 168
static void *ngx_http_proxy_create_loc_conf(ngx_conf_t *cf ) ;
#line 169
static char *ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 171
static ngx_int_t ngx_http_proxy_init_headers(ngx_conf_t *cf , ngx_http_proxy_loc_conf_t *conf ,
                                             ngx_http_proxy_headers_t *headers , ngx_keyval_t *default_headers ) ;
#line 175
static char *ngx_http_proxy_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 177
static char *ngx_http_proxy_redirect(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 179
static char *ngx_http_proxy_cookie_domain(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 181
static char *ngx_http_proxy_cookie_path(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 183
static char *ngx_http_proxy_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 186
static char *ngx_http_proxy_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 188
static char *ngx_http_proxy_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 196
static char *ngx_http_proxy_lowat_check(ngx_conf_t *cf , void *post , void *data ) ;
#line 198
static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf , ngx_http_proxy_rewrite_t *pr ,
                                              ngx_str_t *regex , ngx_uint_t caseless ) ;
#line 205
static void ngx_http_proxy_set_vars(ngx_url_t *u , ngx_http_proxy_vars_t *v ) ;
#line 208 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_conf_post_t ngx_http_proxy_lowat_post  =    {& ngx_http_proxy_lowat_check};
#line 212 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_conf_bitmask_t ngx_http_proxy_next_upstream_masks[14]  = 
#line 212
  {      {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )2}, 
        {{sizeof("timeout") - 1UL, (u_char *)"timeout"}, (ngx_uint_t )4}, 
        {{sizeof("invalid_header") - 1UL, (u_char *)"invalid_header"}, (ngx_uint_t )8}, 
        {{sizeof("non_idempotent") - 1UL,
       (u_char *)"non_idempotent"}, (ngx_uint_t )16384}, 
        {{sizeof("http_500") - 1UL, (u_char *)"http_500"}, (ngx_uint_t )16}, 
        {{sizeof("http_502") - 1UL, (u_char *)"http_502"}, (ngx_uint_t )32}, 
        {{sizeof("http_503") - 1UL, (u_char *)"http_503"}, (ngx_uint_t )64}, 
        {{sizeof("http_504") - 1UL, (u_char *)"http_504"}, (ngx_uint_t )128}, 
        {{sizeof("http_403") - 1UL, (u_char *)"http_403"}, (ngx_uint_t )256}, 
        {{sizeof("http_404") - 1UL, (u_char *)"http_404"}, (ngx_uint_t )512}, 
        {{sizeof("http_429") - 1UL, (u_char *)"http_429"}, (ngx_uint_t )1024}, 
        {{sizeof("updating") - 1UL, (u_char *)"updating"}, (ngx_uint_t )2048}, 
        {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2147483648U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 245 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_conf_enum_t ngx_http_proxy_http_version[3]  = {      {{sizeof("1.0") - 1UL, (u_char *)"1.0"}, (ngx_uint_t )1000}, 
        {{sizeof("1.1") - 1UL, (u_char *)"1.1"}, (ngx_uint_t )1001}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 255 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_command_t ngx_http_proxy_commands[54]  = 
#line 255
  {      {{sizeof("proxy_pass") - 1UL, (u_char *)"proxy_pass"}, (ngx_uint_t )3355443202U,
      & ngx_http_proxy_pass, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_redirect") - 1UL, (u_char *)"proxy_redirect"}, (ngx_uint_t )234881030,
      & ngx_http_proxy_redirect, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_cookie_domain") - 1UL, (u_char *)"proxy_cookie_domain"}, (ngx_uint_t )234881030,
      & ngx_http_proxy_cookie_domain, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_cookie_path") - 1UL, (u_char *)"proxy_cookie_path"}, (ngx_uint_t )234881030,
      & ngx_http_proxy_cookie_path, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_store") - 1UL, (u_char *)"proxy_store"}, (ngx_uint_t )234881026,
      & ngx_http_proxy_store, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_store_access") - 1UL, (u_char *)"proxy_store_access"}, (ngx_uint_t )234881038,
      & ngx_conf_set_access_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.store_access),
      (void *)0}, 
        {{sizeof("proxy_buffering") - 1UL, (u_char *)"proxy_buffering"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.buffering), (void *)0}, 
        {{sizeof("proxy_request_buffering") - 1UL,
       (u_char *)"proxy_request_buffering"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.request_buffering),
      (void *)0}, 
        {{sizeof("proxy_ignore_client_abort") - 1UL, (u_char *)"proxy_ignore_client_abort"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.ignore_client_abort),
      (void *)0}, 
        {{sizeof("proxy_bind") - 1UL, (u_char *)"proxy_bind"}, (ngx_uint_t )234881030,
      & ngx_http_upstream_bind_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.local), (void *)0}, 
        {{sizeof("proxy_connect_timeout") - 1UL,
       (u_char *)"proxy_connect_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.connect_timeout),
      (void *)0}, 
        {{sizeof("proxy_send_timeout") - 1UL, (u_char *)"proxy_send_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.send_timeout),
      (void *)0}, 
        {{sizeof("proxy_send_lowat") - 1UL, (u_char *)"proxy_send_lowat"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.send_lowat), (void *)(& ngx_http_proxy_lowat_post)}, 
        {{sizeof("proxy_intercept_errors") - 1UL,
       (u_char *)"proxy_intercept_errors"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.intercept_errors),
      (void *)0}, 
        {{sizeof("proxy_set_header") - 1UL, (u_char *)"proxy_set_header"}, (ngx_uint_t )234881028,
      & ngx_conf_set_keyval_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->headers_source), (void *)0}, 
        {{sizeof("proxy_headers_hash_max_size") - 1UL,
       (u_char *)"proxy_headers_hash_max_size"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->headers_hash_max_size),
      (void *)0}, 
        {{sizeof("proxy_headers_hash_bucket_size") - 1UL, (u_char *)"proxy_headers_hash_bucket_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->headers_hash_bucket_size),
      (void *)0}, 
        {{sizeof("proxy_set_body") - 1UL, (u_char *)"proxy_set_body"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->body_source), (void *)0}, 
        {{sizeof("proxy_method") - 1UL,
       (u_char *)"proxy_method"}, (ngx_uint_t )234881026, & ngx_http_set_complex_value_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->method),
      (void *)0}, 
        {{sizeof("proxy_pass_request_headers") - 1UL, (u_char *)"proxy_pass_request_headers"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.pass_request_headers),
      (void *)0}, 
        {{sizeof("proxy_pass_request_body") - 1UL, (u_char *)"proxy_pass_request_body"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.pass_request_body),
      (void *)0}, 
        {{sizeof("proxy_buffer_size") - 1UL, (u_char *)"proxy_buffer_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.buffer_size),
      (void *)0}, 
        {{sizeof("proxy_read_timeout") - 1UL, (u_char *)"proxy_read_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.read_timeout),
      (void *)0}, 
        {{sizeof("proxy_buffers") - 1UL, (u_char *)"proxy_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.bufs), (void *)0}, 
        {{sizeof("proxy_busy_buffers_size") - 1UL,
       (u_char *)"proxy_busy_buffers_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.busy_buffers_size_conf),
      (void *)0}, 
        {{sizeof("proxy_force_ranges") - 1UL, (u_char *)"proxy_force_ranges"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.force_ranges),
      (void *)0}, 
        {{sizeof("proxy_limit_rate") - 1UL, (u_char *)"proxy_limit_rate"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.limit_rate), (void *)0}, 
        {{sizeof("proxy_cache") - 1UL,
       (u_char *)"proxy_cache"}, (ngx_uint_t )234881026, & ngx_http_proxy_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_cache_key") - 1UL, (u_char *)"proxy_cache_key"}, (ngx_uint_t )234881026,
      & ngx_http_proxy_cache_key, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("proxy_cache_path") - 1UL, (u_char *)"proxy_cache_path"}, (ngx_uint_t )33558528,
      & ngx_http_file_cache_set_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_proxy_main_conf_t *)0)->caches), (void *)(& ngx_http_proxy_module)}, 
        {{sizeof("proxy_cache_bypass") - 1UL,
       (u_char *)"proxy_cache_bypass"}, (ngx_uint_t )234883072, & ngx_http_set_predicate_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_bypass),
      (void *)0}, 
        {{sizeof("proxy_no_cache") - 1UL, (u_char *)"proxy_no_cache"}, (ngx_uint_t )234883072,
      & ngx_http_set_predicate_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.no_cache), (void *)0}, 
        {{sizeof("proxy_cache_valid") - 1UL,
       (u_char *)"proxy_cache_valid"}, (ngx_uint_t )234883072, & ngx_http_file_cache_valid_set_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_valid),
      (void *)0}, 
        {{sizeof("proxy_cache_min_uses") - 1UL, (u_char *)"proxy_cache_min_uses"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_min_uses),
      (void *)0}, 
        {{sizeof("proxy_cache_max_range_offset") - 1UL, (u_char *)"proxy_cache_max_range_offset"},
      (ngx_uint_t )234881026, & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_max_range_offset),
      (void *)0}, 
        {{sizeof("proxy_cache_use_stale") - 1UL, (u_char *)"proxy_cache_use_stale"},
      (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_use_stale),
      (void *)(& ngx_http_proxy_next_upstream_masks)}, 
        {{sizeof("proxy_cache_methods") - 1UL, (u_char *)"proxy_cache_methods"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_methods),
      (void *)(& ngx_http_upstream_cache_method_mask)}, 
        {{sizeof("proxy_cache_lock") - 1UL, (u_char *)"proxy_cache_lock"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_lock), (void *)0}, 
        {{sizeof("proxy_cache_lock_timeout") - 1UL,
       (u_char *)"proxy_cache_lock_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_lock_timeout),
      (void *)0}, 
        {{sizeof("proxy_cache_lock_age") - 1UL, (u_char *)"proxy_cache_lock_age"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_lock_age),
      (void *)0}, 
        {{sizeof("proxy_cache_revalidate") - 1UL, (u_char *)"proxy_cache_revalidate"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_revalidate),
      (void *)0}, 
        {{sizeof("proxy_cache_convert_head") - 1UL, (u_char *)"proxy_cache_convert_head"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_convert_head),
      (void *)0}, 
        {{sizeof("proxy_cache_background_update") - 1UL, (u_char *)"proxy_cache_background_update"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.cache_background_update),
      (void *)0}, 
        {{sizeof("proxy_temp_path") - 1UL, (u_char *)"proxy_temp_path"}, (ngx_uint_t )234881054,
      & ngx_conf_set_path_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.temp_path), (void *)0}, 
        {{sizeof("proxy_max_temp_file_size") - 1UL,
       (u_char *)"proxy_max_temp_file_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.max_temp_file_size_conf),
      (void *)0}, 
        {{sizeof("proxy_temp_file_write_size") - 1UL, (u_char *)"proxy_temp_file_write_size"},
      (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.temp_file_write_size_conf),
      (void *)0}, 
        {{sizeof("proxy_next_upstream") - 1UL, (u_char *)"proxy_next_upstream"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.next_upstream),
      (void *)(& ngx_http_proxy_next_upstream_masks)}, 
        {{sizeof("proxy_next_upstream_tries") - 1UL, (u_char *)"proxy_next_upstream_tries"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.next_upstream_tries),
      (void *)0}, 
        {{sizeof("proxy_next_upstream_timeout") - 1UL, (u_char *)"proxy_next_upstream_timeout"},
      (ngx_uint_t )234881026, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.next_upstream_timeout),
      (void *)0}, 
        {{sizeof("proxy_pass_header") - 1UL, (u_char *)"proxy_pass_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.pass_headers),
      (void *)0}, 
        {{sizeof("proxy_hide_header") - 1UL, (u_char *)"proxy_hide_header"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_array_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.hide_headers),
      (void *)0}, 
        {{sizeof("proxy_ignore_headers") - 1UL, (u_char *)"proxy_ignore_headers"}, (ngx_uint_t )234883072,
      & ngx_conf_set_bitmask_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->upstream.ignore_headers),
      (void *)(& ngx_http_upstream_ignore_headers_masks)}, 
        {{sizeof("proxy_http_version") - 1UL, (u_char *)"proxy_http_version"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_proxy_loc_conf_t *)0)->http_version), (void *)(& ngx_http_proxy_http_version)}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 724 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_http_module_t ngx_http_proxy_module_ctx  = 
#line 724
     {& ngx_http_proxy_add_variables, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_proxy_create_main_conf,
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_proxy_create_loc_conf,
    & ngx_http_proxy_merge_loc_conf};
#line 739 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
ngx_module_t ngx_http_proxy_module  = 
#line 739
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_proxy_module_ctx),
    ngx_http_proxy_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 755 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char ngx_http_proxy_version[12]  = 
#line 755
  {      (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'/',      (char )'1',      (char )'.', 
        (char )'0',      (char )'\r',      (char )'\n',      (char )'\000'};
#line 756 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char ngx_http_proxy_version_11[12]  = 
#line 756
  {      (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'/',      (char )'1',      (char )'.', 
        (char )'1',      (char )'\r',      (char )'\n',      (char )'\000'};
#line 759 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_keyval_t ngx_http_proxy_headers[9]  = 
#line 759
  {      {{sizeof("Host") - 1UL, (u_char *)"Host"}, {sizeof("$proxy_host") - 1UL, (u_char *)"$proxy_host"}}, 
        {{sizeof("Connection") - 1UL,
       (u_char *)"Connection"}, {sizeof("close") - 1UL, (u_char *)"close"}}, 
        {{sizeof("Content-Length") - 1UL, (u_char *)"Content-Length"}, {sizeof("$proxy_internal_body_length") - 1UL,
                                                                     (u_char *)"$proxy_internal_body_length"}}, 
        {{sizeof("Transfer-Encoding") - 1UL,
       (u_char *)"Transfer-Encoding"}, {sizeof("$proxy_internal_chunked") - 1UL, (u_char *)"$proxy_internal_chunked"}}, 
        {{sizeof("TE") - 1UL,
       (u_char *)"TE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Keep-Alive") - 1UL, (u_char *)"Keep-Alive"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Expect") - 1UL,
       (u_char *)"Expect"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Upgrade") - 1UL, (u_char *)"Upgrade"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, {(size_t )0, (u_char *)((void *)0)}}};
#line 772 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_str_t ngx_http_proxy_hide_headers[9]  = 
#line 772
  {      {sizeof("Date") - 1UL, (u_char *)"Date"}, 
        {sizeof("Server") - 1UL, (u_char *)"Server"}, 
        {sizeof("X-Pad") - 1UL, (u_char *)"X-Pad"}, 
        {sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, 
        {sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, 
        {sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, 
        {sizeof("X-Accel-Buffering") - 1UL, (u_char *)"X-Accel-Buffering"}, 
        {sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, 
        {(size_t )0, (u_char *)((void *)0)}};
#line 787 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_keyval_t ngx_http_proxy_cache_headers[15]  = 
#line 787
  {      {{sizeof("Host") - 1UL, (u_char *)"Host"}, {sizeof("$proxy_host") - 1UL, (u_char *)"$proxy_host"}}, 
        {{sizeof("Connection") - 1UL,
       (u_char *)"Connection"}, {sizeof("close") - 1UL, (u_char *)"close"}}, 
        {{sizeof("Content-Length") - 1UL, (u_char *)"Content-Length"}, {sizeof("$proxy_internal_body_length") - 1UL,
                                                                     (u_char *)"$proxy_internal_body_length"}}, 
        {{sizeof("Transfer-Encoding") - 1UL,
       (u_char *)"Transfer-Encoding"}, {sizeof("$proxy_internal_chunked") - 1UL, (u_char *)"$proxy_internal_chunked"}}, 
        {{sizeof("TE") - 1UL,
       (u_char *)"TE"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Keep-Alive") - 1UL, (u_char *)"Keep-Alive"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Expect") - 1UL,
       (u_char *)"Expect"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Upgrade") - 1UL, (u_char *)"Upgrade"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("If-Modified-Since") - 1UL,
       (u_char *)"If-Modified-Since"}, {sizeof("$upstream_cache_last_modified") - 1UL,
                                        (u_char *)"$upstream_cache_last_modified"}}, 
        {{sizeof("If-Unmodified-Since") - 1UL,
       (u_char *)"If-Unmodified-Since"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("If-None-Match") - 1UL, (u_char *)"If-None-Match"}, {sizeof("$upstream_cache_etag") - 1UL,
                                                                   (u_char *)"$upstream_cache_etag"}}, 
        {{sizeof("If-Match") - 1UL,
       (u_char *)"If-Match"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("Range") - 1UL, (u_char *)"Range"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{sizeof("If-Range") - 1UL,
       (u_char *)"If-Range"}, {sizeof("") - 1UL, (u_char *)""}}, 
        {{(size_t )0, (u_char *)((void *)0)}, {(size_t )0, (u_char *)((void *)0)}}};
#line 809 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_http_variable_t ngx_http_proxy_vars[6]  = {      {{sizeof("proxy_host") - 1UL, (u_char *)"proxy_host"}, (void (*)(ngx_http_request_t *r ,
                                                                      ngx_http_variable_value_t *v ,
                                                                      uintptr_t data ))((void *)0),
      & ngx_http_proxy_host_variable, (uintptr_t )0, (ngx_uint_t )11, (ngx_uint_t )0}, 
        {{sizeof("proxy_port") - 1UL,
       (u_char *)"proxy_port"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ))((void *)0), & ngx_http_proxy_port_variable,
      (uintptr_t )0, (ngx_uint_t )11, (ngx_uint_t )0}, 
        {{sizeof("proxy_add_x_forwarded_for") - 1UL, (u_char *)"proxy_add_x_forwarded_for"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_proxy_add_x_forwarded_for_variable, (uintptr_t )0, (ngx_uint_t )8,
      (ngx_uint_t )0}, 
        {{sizeof("proxy_internal_body_length") - 1UL, (u_char *)"proxy_internal_body_length"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_proxy_internal_body_length_variable, (uintptr_t )0, (ngx_uint_t )10,
      (ngx_uint_t )0}, 
        {{sizeof("proxy_internal_chunked") - 1UL, (u_char *)"proxy_internal_chunked"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_proxy_internal_chunked_variable, (uintptr_t )0, (ngx_uint_t )10,
      (ngx_uint_t )0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 836 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_path_init_t ngx_http_proxy_temp_path  =    {{sizeof("proxy_temp") - 1UL, (u_char *)"proxy_temp"}, {(size_t )1, (size_t )2,
                                                           (size_t )0}};
#line 841 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_http_proxy_main_conf_t *pmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 852
  tmp = ngx_http_upstream_create(r);
  }
#line 852
  if (tmp != 0L) {
#line 853
    return ((ngx_int_t )500);
  }
  {
#line 856
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_proxy_ctx_t ));
#line 856
  ctx = (ngx_http_proxy_ctx_t *)tmp___0;
  }
#line 857
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 858
    return ((ngx_int_t )500);
  }
#line 861
  *(r->ctx + ngx_http_proxy_module.ctx_index) = (void *)ctx;
#line 863
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 865
  u = r->upstream;
#line 867
  if ((unsigned long )plcf->proxy_lengths == (unsigned long )((void *)0)) {
#line 868
    ctx->vars = plcf->vars;
#line 869
    u->schema = plcf->vars.schema;
  } else {
    {
#line 875
    tmp___1 = ngx_http_proxy_eval(r, ctx, plcf);
    }
#line 875
    if (tmp___1 != 0L) {
#line 876
      return ((ngx_int_t )500);
    }
  }
#line 880
  u->output.tag = (ngx_buf_tag_t )(& ngx_http_proxy_module);
#line 882
  u->conf = & plcf->upstream;
#line 885
  pmcf = (ngx_http_proxy_main_conf_t *)*(r->main_conf + ngx_http_proxy_module.ctx_index);
#line 887
  u->caches = & pmcf->caches;
#line 888
  u->create_key = & ngx_http_proxy_create_key;
#line 891
  u->create_request = & ngx_http_proxy_create_request;
#line 892
  u->reinit_request = & ngx_http_proxy_reinit_request;
#line 893
  u->process_header = & ngx_http_proxy_process_status_line;
#line 894
  u->abort_request = & ngx_http_proxy_abort_request;
#line 895
  u->finalize_request = & ngx_http_proxy_finalize_request;
#line 896
  r->state = (ngx_uint_t )0;
#line 898
  if (plcf->redirects) {
#line 899
    u->rewrite_redirect = & ngx_http_proxy_rewrite_redirect;
  }
#line 902
  if (plcf->cookie_domains) {
#line 903
    u->rewrite_cookie = & ngx_http_proxy_rewrite_cookie;
  } else
#line 902
  if (plcf->cookie_paths) {
#line 903
    u->rewrite_cookie = & ngx_http_proxy_rewrite_cookie;
  }
  {
#line 906
  u->buffering = (unsigned int )plcf->upstream.buffering;
#line 908
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_event_pipe_t ));
#line 908
  u->pipe = (ngx_event_pipe_t *)tmp___2;
  }
#line 909
  if ((unsigned long )u->pipe == (unsigned long )((void *)0)) {
#line 910
    return ((ngx_int_t )500);
  }
#line 913
  (u->pipe)->input_filter = & ngx_http_proxy_copy_filter;
#line 914
  (u->pipe)->input_ctx = (void *)r;
#line 916
  u->input_filter_init = & ngx_http_proxy_input_filter_init;
#line 917
  u->input_filter = & ngx_http_proxy_non_buffered_copy_filter;
#line 918
  u->input_filter_ctx = (void *)r;
#line 920
  u->accel = 1U;
#line 922
  if (! plcf->upstream.request_buffering) {
#line 922
    if ((unsigned long )plcf->body_values == (unsigned long )((void *)0)) {
#line 922
      if (plcf->upstream.pass_request_body) {
#line 922
        if (! r->headers_in.chunked) {
#line 927
          r->request_body_no_buffering = 1U;
        } else
#line 922
        if (plcf->http_version == 1001UL) {
#line 927
          r->request_body_no_buffering = 1U;
        }
      }
    }
  }
  {
#line 930
  rc = ngx_http_read_client_request_body(r, & ngx_http_upstream_init);
  }
#line 932
  if (rc >= 300L) {
#line 933
    return (rc);
  }
#line 936
  return ((ngx_int_t )-4);
}
}
#line 940 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_eval(ngx_http_request_t *r , ngx_http_proxy_ctx_t *ctx ,
                                     ngx_http_proxy_loc_conf_t *plcf ) 
{ 
  u_char *p ;
  size_t add ;
  u_short port ;
  ngx_str_t proxy ;
  ngx_url_t url ;
  ngx_http_upstream_t *u ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 951
  tmp = ngx_http_script_run(r, & proxy, (plcf->proxy_lengths)->elts, (size_t )0, (plcf->proxy_values)->elts);
  }
#line 951
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 955
    return ((ngx_int_t )-1);
  }
#line 958
  if (proxy.len > 7UL) {
    {
#line 958
    tmp___0 = ngx_strncasecmp(proxy.data, (u_char *)"http://", (size_t )7);
    }
#line 958
    if (tmp___0 == 0L) {
#line 961
      add = (size_t )7;
#line 962
      port = (u_short )80;
    } else {
#line 958
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 976
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 976
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid URL prefix in \"%V\"",
                         & proxy);
      }
    }
#line 978
    return ((ngx_int_t )-1);
  }
  {
#line 981
  u = r->upstream;
#line 983
  u->schema.len = add;
#line 984
  u->schema.data = proxy.data;
#line 986
  memset((void *)(& url), 0, sizeof(ngx_url_t ));
#line 988
  url.url.len = proxy.len - add;
#line 989
  url.url.data = proxy.data + add;
#line 990
  url.default_port = port;
#line 991
  url.uri_part = 1U;
#line 992
  url.no_resolve = 1U;
#line 994
  tmp___1 = ngx_parse_url(r->pool, & url);
  }
#line 994
  if (tmp___1 != 0L) {
#line 995
    if (url.err) {
#line 996
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 996
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%s in upstream \"%V\"",
                           url.err, & url.url);
        }
      }
    }
#line 1000
    return ((ngx_int_t )-1);
  }
#line 1003
  if (url.uri.len) {
#line 1004
    if ((int )*(url.uri.data + 0) == 63) {
      {
#line 1005
      tmp___2 = ngx_pnalloc(r->pool, url.uri.len + 1UL);
#line 1005
      p = (u_char *)tmp___2;
      }
#line 1006
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1007
        return ((ngx_int_t )-1);
      }
      {
#line 1010
      tmp___3 = p;
#line 1010
      p ++;
#line 1010
      *tmp___3 = (u_char )'/';
#line 1011
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)url.uri.data,
             url.uri.len);
#line 1013
      (url.uri.len) ++;
#line 1014
      url.uri.data = p - 1;
      }
    }
  }
  {
#line 1018
  ctx->vars.key_start = u->schema;
#line 1020
  ngx_http_proxy_set_vars(& url, & ctx->vars);
#line 1022
  tmp___4 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_resolved_t ));
#line 1022
  u->resolved = (ngx_http_upstream_resolved_t *)tmp___4;
  }
#line 1023
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 1024
    return ((ngx_int_t )-1);
  }
#line 1027
  if (url.addrs) {
#line 1028
    (u->resolved)->sockaddr = (url.addrs + 0)->sockaddr;
#line 1029
    (u->resolved)->socklen = (url.addrs + 0)->socklen;
#line 1030
    (u->resolved)->name = (url.addrs + 0)->name;
#line 1031
    (u->resolved)->naddrs = (ngx_uint_t )1;
  }
#line 1034
  (u->resolved)->host = url.host;
#line 1035
  if (url.no_port) {
#line 1035
    tmp___5 = (int )port;
  } else {
#line 1035
    tmp___5 = (int )url.port;
  }
#line 1035
  (u->resolved)->port = (in_port_t )tmp___5;
#line 1036
  (u->resolved)->no_port = (ngx_uint_t )url.no_port;
#line 1038
  return ((ngx_int_t )0);
}
}
#line 1044 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_create_key(ngx_http_request_t *r ) 
{ 
  size_t len ;
  size_t loc_len ;
  u_char *p ;
  uintptr_t escape___0 ;
  ngx_str_t *key ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  ngx_http_proxy_loc_conf_t *plcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  uintptr_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  void *tmp___7 ;
  char *__cil_tmp19 ;

  {
  {
#line 1055
  u = r->upstream;
#line 1057
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 1059
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1061
  tmp = ngx_array_push(& (r->cache)->keys);
#line 1061
  key = (ngx_str_t *)tmp;
  }
#line 1062
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 1063
    return ((ngx_int_t )-1);
  }
#line 1066
  if (plcf->cache_key.value.data) {
    {
#line 1068
    tmp___0 = ngx_http_complex_value(r, & plcf->cache_key, key);
    }
#line 1068
    if (tmp___0 != 0L) {
#line 1069
      return ((ngx_int_t )-1);
    }
#line 1072
    return ((ngx_int_t )0);
  }
  {
#line 1075
  *key = ctx->vars.key_start;
#line 1077
  tmp___1 = ngx_array_push(& (r->cache)->keys);
#line 1077
  key = (ngx_str_t *)tmp___1;
  }
#line 1078
  if ((unsigned long )key == (unsigned long )((void *)0)) {
#line 1079
    return ((ngx_int_t )-1);
  }
#line 1082
  if (plcf->proxy_lengths) {
#line 1082
    if (ctx->vars.uri.len) {
#line 1084
      *key = ctx->vars.uri;
#line 1085
      u->uri = ctx->vars.uri;
#line 1087
      return ((ngx_int_t )0);
    } else {
#line 1082
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1089
  if (ctx->vars.uri.len == 0UL) {
#line 1089
    if (r->valid_unparsed_uri) {
#line 1090
      *key = r->unparsed_uri;
#line 1091
      u->uri = r->unparsed_uri;
#line 1093
      return ((ngx_int_t )0);
    }
  }
#line 1096
  if (r->valid_location) {
#line 1096
    if (ctx->vars.uri.len) {
#line 1096
      loc_len = plcf->location.len;
    } else {
#line 1096
      loc_len = (size_t )0;
    }
  } else {
#line 1096
    loc_len = (size_t )0;
  }
#line 1098
  if (r->quoted_uri) {
    {
#line 1099
    tmp___2 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                             (ngx_uint_t )0);
#line 1099
    escape___0 = 2UL * tmp___2;
    }
  } else
#line 1098
  if (r->space_in_uri) {
    {
#line 1099
    tmp___2 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                             (ngx_uint_t )0);
#line 1099
    escape___0 = 2UL * tmp___2;
    }
  } else
#line 1098
  if (r->internal) {
    {
#line 1099
    tmp___2 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                             (ngx_uint_t )0);
#line 1099
    escape___0 = 2UL * tmp___2;
    }
  } else {
#line 1102
    escape___0 = (uintptr_t )0;
  }
  {
#line 1105
  len = (((((ctx->vars.uri.len + r->uri.len) - loc_len) + escape___0) + sizeof("?")) - 1UL) + r->args.len;
#line 1108
  tmp___3 = ngx_pnalloc(r->pool, len);
#line 1108
  p = (u_char *)tmp___3;
  }
#line 1109
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1110
    return ((ngx_int_t )-1);
  }
#line 1113
  key->data = p;
#line 1115
  if (r->valid_location) {
    {
#line 1116
    tmp___4 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ctx->vars.uri.data,
                     ctx->vars.uri.len);
#line 1116
    p = (u_char *)tmp___4 + ctx->vars.uri.len;
    }
  }
#line 1119
  if (escape___0) {
    {
#line 1120
    ngx_escape_uri(p, r->uri.data + loc_len, r->uri.len - loc_len, (ngx_uint_t )0);
#line 1122
    p += (r->uri.len - loc_len) + escape___0;
    }
  } else {
    {
#line 1125
    tmp___5 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(r->uri.data + loc_len),
                     r->uri.len - loc_len);
#line 1125
    p = (u_char *)tmp___5 + (r->uri.len - loc_len);
    }
  }
#line 1128
  if (r->args.len > 0UL) {
    {
#line 1129
    tmp___6 = p;
#line 1129
    p ++;
#line 1129
    *tmp___6 = (u_char )'?';
#line 1130
    tmp___7 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)r->args.data,
                     r->args.len);
#line 1130
    p = (u_char *)tmp___7 + r->args.len;
    }
  }
#line 1133
  key->len = (size_t )(p - key->data);
#line 1134
  u->uri = *key;
#line 1136
  return ((ngx_int_t )0);
}
}
#line 1142 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_create_request(ngx_http_request_t *r ) 
{ 
  size_t len ;
  size_t uri_len ;
  size_t loc_len ;
  size_t body_len ;
  size_t key_len ;
  size_t val_len ;
  uintptr_t escape___0 ;
  ngx_buf_t *b ;
  ngx_str_t method ;
  ngx_uint_t i ;
  ngx_uint_t unparsed_uri ;
  ngx_chain_t *cl ;
  ngx_chain_t *body ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_proxy_headers_t *headers ;
  ngx_http_script_engine_t e ;
  ngx_http_script_engine_t le ;
  ngx_http_proxy_loc_conf_t *plcf ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  uintptr_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  u_char *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  size_t tmp___15 ;
  u_char *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  void *tmp___20 ;
  void *tmp___21 ;
  u_char *tmp___22 ;
  u_char *tmp___23 ;
  void *tmp___24 ;
  u_char *tmp___25 ;
  u_char *tmp___26 ;
  u_char *tmp___27 ;
  u_char *tmp___28 ;
  void *tmp___29 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
#line 1162
  u = r->upstream;
#line 1164
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 1167
  if (u->cacheable) {
#line 1167
    headers = & plcf->headers_cache;
  } else {
#line 1167
    headers = & plcf->headers;
  }
#line 1172
  if (u->method.len) {
#line 1174
    method = u->method;
  } else
#line 1176
  if (plcf->method) {
    {
#line 1177
    tmp = ngx_http_complex_value(r, plcf->method, & method);
    }
#line 1177
    if (tmp != 0L) {
#line 1178
      return ((ngx_int_t )-1);
    }
  } else {
#line 1182
    method = r->method_name;
  }
#line 1185
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1187
  if (method.len == 4UL) {
    {
#line 1187
    tmp___0 = ngx_strncasecmp(method.data, (u_char *)"HEAD", (size_t )4);
    }
#line 1187
    if (tmp___0 == 0L) {
#line 1190
      ctx->head = 1U;
    }
  }
#line 1193
  len = ((((method.len + 1UL) + sizeof(ngx_http_proxy_version)) - 1UL) + sizeof("\r\n")) - 1UL;
#line 1196
  escape___0 = (uintptr_t )0;
#line 1197
  loc_len = (size_t )0;
#line 1198
  unparsed_uri = (ngx_uint_t )0;
#line 1200
  if (plcf->proxy_lengths) {
#line 1200
    if (ctx->vars.uri.len) {
#line 1201
      uri_len = ctx->vars.uri.len;
    } else {
#line 1200
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1203
  if (ctx->vars.uri.len == 0UL) {
#line 1203
    if (r->valid_unparsed_uri) {
#line 1204
      unparsed_uri = (ngx_uint_t )1;
#line 1205
      uri_len = r->unparsed_uri.len;
    } else {
#line 1203
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 1208
    if (r->valid_location) {
#line 1208
      if (ctx->vars.uri.len) {
#line 1208
        loc_len = plcf->location.len;
      } else {
#line 1208
        loc_len = (size_t )0;
      }
    } else {
#line 1208
      loc_len = (size_t )0;
    }
#line 1211
    if (r->quoted_uri) {
      {
#line 1212
      tmp___1 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                               (ngx_uint_t )0);
#line 1212
      escape___0 = 2UL * tmp___1;
      }
    } else
#line 1211
    if (r->space_in_uri) {
      {
#line 1212
      tmp___1 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                               (ngx_uint_t )0);
#line 1212
      escape___0 = 2UL * tmp___1;
      }
    } else
#line 1211
    if (r->internal) {
      {
#line 1212
      tmp___1 = ngx_escape_uri((u_char *)((void *)0), r->uri.data + loc_len, r->uri.len - loc_len,
                               (ngx_uint_t )0);
#line 1212
      escape___0 = 2UL * tmp___1;
      }
    }
#line 1216
    uri_len = (((((ctx->vars.uri.len + r->uri.len) - loc_len) + escape___0) + sizeof("?")) - 1UL) + r->args.len;
  }
#line 1220
  if (uri_len == 0UL) {
#line 1221
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1221
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "zero length URI to proxy");
      }
    }
#line 1223
    return ((ngx_int_t )-1);
  }
  {
#line 1226
  len += uri_len;
#line 1228
  memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 1230
  ngx_http_script_flush_no_cacheable_variables(r, plcf->body_flushes);
#line 1231
  ngx_http_script_flush_no_cacheable_variables(r, headers->flushes);
  }
#line 1233
  if (plcf->body_lengths) {
#line 1234
    le.ip = (u_char *)(plcf->body_lengths)->elts;
#line 1235
    le.request = r;
#line 1236
    le.flushed = 1U;
#line 1237
    body_len = (size_t )0;
    {
#line 1239
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1239
      if (! *((uintptr_t *)le.ip)) {
#line 1239
        goto while_break;
      }
      {
#line 1240
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1241
      tmp___2 = (*lcode)(& le);
#line 1241
      body_len += tmp___2;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 1244
    ctx->internal_body_length = (off_t )body_len;
#line 1245
    len += body_len;
  } else
#line 1247
  if (r->headers_in.chunked) {
#line 1247
    if (r->reading_body) {
#line 1248
      ctx->internal_body_length = (off_t )-1;
#line 1249
      ctx->internal_chunked = 1U;
    } else {
#line 1252
      ctx->internal_body_length = r->headers_in.content_length_n;
    }
  } else {
#line 1252
    ctx->internal_body_length = r->headers_in.content_length_n;
  }
#line 1255
  le.ip = (u_char *)(headers->lengths)->elts;
#line 1256
  le.request = r;
#line 1257
  le.flushed = 1U;
  {
#line 1259
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1259
    if (! *((uintptr_t *)le.ip)) {
#line 1259
      goto while_break___0;
    }
    {
#line 1261
    lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1262
    key_len = (*lcode)(& le);
#line 1264
    val_len = (size_t )0;
    }
    {
#line 1264
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1264
      if (! *((uintptr_t *)le.ip)) {
#line 1264
        goto while_break___1;
      }
      {
#line 1265
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1264
      tmp___3 = (*lcode)(& le);
#line 1264
      val_len += tmp___3;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1267
    le.ip += sizeof(uintptr_t );
#line 1269
    if (val_len == 0UL) {
#line 1270
      goto while_continue___0;
    }
#line 1273
    len += ((((key_len + sizeof(": ")) - 1UL) + val_len) + sizeof("\r\n")) - 1UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1277
  if (plcf->upstream.pass_request_headers) {
#line 1278
    part = & r->headers_in.headers.part;
#line 1279
    header___0 = (ngx_table_elt_t *)part->elts;
#line 1281
    i = (ngx_uint_t )0;
    {
#line 1281
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1283
      if (i >= part->nelts) {
#line 1284
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1285
          goto while_break___2;
        }
#line 1288
        part = part->next;
#line 1289
        header___0 = (ngx_table_elt_t *)part->elts;
#line 1290
        i = (ngx_uint_t )0;
      }
      {
#line 1293
      tmp___4 = ngx_hash_find(& headers->hash, (header___0 + i)->hash, (header___0 + i)->lowcase_key,
                              (header___0 + i)->key.len);
      }
#line 1293
      if (tmp___4) {
#line 1296
        goto __Cont;
      }
#line 1299
      len += (((((header___0 + i)->key.len + sizeof(": ")) - 1UL) + (header___0 + i)->value.len) + sizeof("\r\n")) - 1UL;
      __Cont: /* CIL Label */ 
#line 1281
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 1305
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 1306
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1307
    return ((ngx_int_t )-1);
  }
  {
#line 1310
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 1311
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1312
    return ((ngx_int_t )-1);
  }
  {
#line 1315
  cl->buf = b;
#line 1320
  tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)method.data,
                   method.len);
#line 1320
  b->last = (u_char *)tmp___5 + method.len;
#line 1321
  tmp___6 = b->last;
#line 1321
  (b->last) ++;
#line 1321
  *tmp___6 = (u_char )' ';
#line 1323
  u->uri.data = b->last;
  }
#line 1325
  if (plcf->proxy_lengths) {
#line 1325
    if (ctx->vars.uri.len) {
      {
#line 1326
      tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ctx->vars.uri.data,
                       ctx->vars.uri.len);
#line 1326
      b->last = (u_char *)tmp___7 + ctx->vars.uri.len;
      }
    } else {
#line 1325
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1328
  if (unparsed_uri) {
    {
#line 1329
    tmp___8 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->unparsed_uri.data,
                     r->unparsed_uri.len);
#line 1329
    b->last = (u_char *)tmp___8 + r->unparsed_uri.len;
    }
  } else {
#line 1332
    if (r->valid_location) {
      {
#line 1333
      tmp___9 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ctx->vars.uri.data,
                       ctx->vars.uri.len);
#line 1333
      b->last = (u_char *)tmp___9 + ctx->vars.uri.len;
      }
    }
#line 1336
    if (escape___0) {
      {
#line 1337
      ngx_escape_uri(b->last, r->uri.data + loc_len, r->uri.len - loc_len, (ngx_uint_t )0);
#line 1339
      b->last += (r->uri.len - loc_len) + escape___0;
      }
    } else {
      {
#line 1342
      tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(r->uri.data + loc_len),
                        r->uri.len - loc_len);
#line 1342
      b->last = (u_char *)tmp___10 + (r->uri.len - loc_len);
      }
    }
#line 1346
    if (r->args.len > 0UL) {
      {
#line 1347
      tmp___11 = b->last;
#line 1347
      (b->last) ++;
#line 1347
      *tmp___11 = (u_char )'?';
#line 1348
      tmp___12 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->args.data,
                        r->args.len);
#line 1348
      b->last = (u_char *)tmp___12 + r->args.len;
      }
    }
  }
#line 1352
  u->uri.len = (size_t )(b->last - u->uri.data);
#line 1354
  if (plcf->http_version == 1001UL) {
    {
#line 1355
    tmp___13 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(ngx_http_proxy_version_11),
                      sizeof(ngx_http_proxy_version_11) - 1UL);
#line 1355
    b->last = (u_char *)tmp___13 + (sizeof(ngx_http_proxy_version_11) - 1UL);
    }
  } else {
    {
#line 1359
    tmp___14 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(ngx_http_proxy_version),
                      sizeof(ngx_http_proxy_version) - 1UL);
#line 1359
    b->last = (u_char *)tmp___14 + (sizeof(ngx_http_proxy_version) - 1UL);
    }
  }
  {
#line 1363
  memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 1365
  e.ip = (u_char *)(headers->values)->elts;
#line 1366
  e.pos = b->last;
#line 1367
  e.request = r;
#line 1368
  e.flushed = 1U;
#line 1370
  le.ip = (u_char *)(headers->lengths)->elts;
  }
  {
#line 1372
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1372
    if (! *((uintptr_t *)le.ip)) {
#line 1372
      goto while_break___3;
    }
    {
#line 1374
    lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1375
    (*lcode)(& le);
#line 1377
    val_len = (size_t )0;
    }
    {
#line 1377
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1377
      if (! *((uintptr_t *)le.ip)) {
#line 1377
        goto while_break___4;
      }
      {
#line 1378
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1377
      tmp___15 = (*lcode)(& le);
#line 1377
      val_len += tmp___15;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1380
    le.ip += sizeof(uintptr_t );
#line 1382
    if (val_len == 0UL) {
#line 1383
      e.skip = 1U;
      {
#line 1385
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 1385
        if (! *((uintptr_t *)e.ip)) {
#line 1385
          goto while_break___5;
        }
        {
#line 1386
        code = *((ngx_http_script_code_pt *)e.ip);
#line 1387
        (*code)(& e);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1389
      e.ip += sizeof(uintptr_t );
#line 1391
      e.skip = 0U;
#line 1393
      goto while_continue___3;
    }
    {
#line 1396
    code = *((ngx_http_script_code_pt *)e.ip);
#line 1397
    (*code)(& e);
#line 1399
    tmp___16 = e.pos;
#line 1399
    (e.pos) ++;
#line 1399
    *tmp___16 = (u_char )':';
#line 1399
    tmp___17 = e.pos;
#line 1399
    (e.pos) ++;
#line 1399
    *tmp___17 = (u_char )' ';
    }
    {
#line 1401
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1401
      if (! *((uintptr_t *)e.ip)) {
#line 1401
        goto while_break___6;
      }
      {
#line 1402
      code = *((ngx_http_script_code_pt *)e.ip);
#line 1403
      (*code)(& e);
      }
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1405
    e.ip += sizeof(uintptr_t );
#line 1407
    tmp___18 = e.pos;
#line 1407
    (e.pos) ++;
#line 1407
    *tmp___18 = (u_char )'\r';
#line 1407
    tmp___19 = e.pos;
#line 1407
    (e.pos) ++;
#line 1407
    *tmp___19 = (u_char )'\n';
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1410
  b->last = e.pos;
#line 1413
  if (plcf->upstream.pass_request_headers) {
#line 1414
    part = & r->headers_in.headers.part;
#line 1415
    header___0 = (ngx_table_elt_t *)part->elts;
#line 1417
    i = (ngx_uint_t )0;
    {
#line 1417
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1419
      if (i >= part->nelts) {
#line 1420
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1421
          goto while_break___7;
        }
#line 1424
        part = part->next;
#line 1425
        header___0 = (ngx_table_elt_t *)part->elts;
#line 1426
        i = (ngx_uint_t )0;
      }
      {
#line 1429
      tmp___20 = ngx_hash_find(& headers->hash, (header___0 + i)->hash, (header___0 + i)->lowcase_key,
                               (header___0 + i)->key.len);
      }
#line 1429
      if (tmp___20) {
#line 1432
        goto __Cont___0;
      }
      {
#line 1435
      tmp___21 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->key.data,
                        (header___0 + i)->key.len);
#line 1435
      b->last = (u_char *)tmp___21 + (header___0 + i)->key.len;
#line 1437
      tmp___22 = b->last;
#line 1437
      (b->last) ++;
#line 1437
      *tmp___22 = (u_char )':';
#line 1437
      tmp___23 = b->last;
#line 1437
      (b->last) ++;
#line 1437
      *tmp___23 = (u_char )' ';
#line 1439
      tmp___24 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                        (header___0 + i)->value.len);
#line 1439
      b->last = (u_char *)tmp___24 + (header___0 + i)->value.len;
#line 1442
      tmp___25 = b->last;
#line 1442
      (b->last) ++;
#line 1442
      *tmp___25 = (u_char )'\r';
#line 1442
      tmp___26 = b->last;
#line 1442
      (b->last) ++;
#line 1442
      *tmp___26 = (u_char )'\n';
      }
      __Cont___0: /* CIL Label */ 
#line 1417
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  }
#line 1452
  tmp___27 = b->last;
#line 1452
  (b->last) ++;
#line 1452
  *tmp___27 = (u_char )'\r';
#line 1452
  tmp___28 = b->last;
#line 1452
  (b->last) ++;
#line 1452
  *tmp___28 = (u_char )'\n';
#line 1454
  if (plcf->body_values) {
#line 1455
    e.ip = (u_char *)(plcf->body_values)->elts;
#line 1456
    e.pos = b->last;
#line 1457
    e.skip = 0U;
    {
#line 1459
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1459
      if (! *((uintptr_t *)e.ip)) {
#line 1459
        goto while_break___8;
      }
      {
#line 1460
      code = *((ngx_http_script_code_pt *)e.ip);
#line 1461
      (*code)(& e);
      }
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1464
    b->last = e.pos;
  }
#line 1471
  if (r->request_body_no_buffering) {
#line 1473
    u->request_bufs = cl;
#line 1475
    if (ctx->internal_chunked) {
#line 1476
      u->output.output_filter = & ngx_http_proxy_body_output_filter;
#line 1477
      u->output.filter_ctx = (void *)r;
    }
  } else
#line 1480
  if ((unsigned long )plcf->body_values == (unsigned long )((void *)0)) {
#line 1480
    if (plcf->upstream.pass_request_body) {
#line 1482
      body = u->request_bufs;
#line 1483
      u->request_bufs = cl;
      {
#line 1485
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 1485
        if (! body) {
#line 1485
          goto while_break___9;
        }
        {
#line 1486
        tmp___29 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 1486
        b = (ngx_buf_t *)tmp___29;
        }
#line 1487
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1488
          return ((ngx_int_t )-1);
        }
        {
#line 1491
        memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)body->buf,
               sizeof(ngx_buf_t ));
#line 1493
        cl->next = ngx_alloc_chain_link(r->pool);
        }
#line 1494
        if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1495
          return ((ngx_int_t )-1);
        }
#line 1498
        cl = cl->next;
#line 1499
        cl->buf = b;
#line 1501
        body = body->next;
      }
      while_break___9: /* CIL Label */ ;
      }
    } else {
#line 1505
      u->request_bufs = cl;
    }
  } else {
#line 1505
    u->request_bufs = cl;
  }
#line 1508
  b->flush = 1U;
#line 1509
  cl->next = (ngx_chain_t *)((void *)0);
#line 1511
  return ((ngx_int_t )0);
}
}
#line 1515 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_reinit_request(ngx_http_request_t *r ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 1520
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1522
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 1523
    return ((ngx_int_t )0);
  }
#line 1526
  ctx->status.code = (ngx_uint_t )0;
#line 1527
  ctx->status.count = (ngx_uint_t )0;
#line 1528
  ctx->status.start = (u_char *)((void *)0);
#line 1529
  ctx->status.end = (u_char *)((void *)0);
#line 1530
  ctx->chunked.state = (ngx_uint_t )0;
#line 1532
  (r->upstream)->process_header = & ngx_http_proxy_process_status_line;
#line 1533
  ((r->upstream)->pipe)->input_filter = & ngx_http_proxy_copy_filter;
#line 1534
  (r->upstream)->input_filter = & ngx_http_proxy_non_buffered_copy_filter;
#line 1535
  r->state = (ngx_uint_t )0;
#line 1537
  return ((ngx_int_t )0);
}
}
#line 1541 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_body_output_filter(void *data , ngx_chain_t *in ) 
{ 
  ngx_http_request_t *r ;
  off_t size ;
  u_char *chunk ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t **ll ;
  ngx_chain_t **fl ;
  ngx_http_proxy_ctx_t *ctx ;
  off_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1544
  r = (ngx_http_request_t *)data;
#line 1556
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1558
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1559
    out = in;
#line 1560
    goto out;
  }
#line 1563
  out = (ngx_chain_t *)((void *)0);
#line 1564
  ll = & out;
#line 1566
  if (! ctx->header_sent) {
    {
#line 1572
    ctx->header_sent = 1U;
#line 1574
    tl = ngx_alloc_chain_link(r->pool);
    }
#line 1575
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1576
      return ((ngx_int_t )-1);
    }
#line 1579
    tl->buf = in->buf;
#line 1580
    *ll = tl;
#line 1581
    ll = & tl->next;
#line 1583
    in = in->next;
#line 1585
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1586
      tl->next = (ngx_chain_t *)((void *)0);
#line 1587
      goto out;
    }
  }
#line 1591
  size = (off_t )0;
#line 1592
  cl = in;
#line 1593
  fl = ll;
  {
#line 1595
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1599
    if ((cl->buf)->temporary) {
#line 1599
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 1599
    if ((cl->buf)->memory) {
#line 1599
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 1599
    if ((cl->buf)->mmap) {
#line 1599
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 1599
      tmp = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 1599
    size += tmp;
#line 1601
    if ((cl->buf)->flush) {
#line 1601
      goto _L;
    } else
#line 1601
    if ((cl->buf)->sync) {
#line 1601
      goto _L;
    } else
#line 1601
    if ((cl->buf)->temporary) {
#line 1601
      goto _L;
    } else
#line 1601
    if ((cl->buf)->memory) {
#line 1601
      goto _L;
    } else
#line 1601
    if ((cl->buf)->mmap) {
#line 1601
      goto _L;
    } else
#line 1601
    if ((cl->buf)->in_file) {
      _L: /* CIL Label */ 
      {
#line 1606
      tl = ngx_alloc_chain_link(r->pool);
      }
#line 1607
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1608
        return ((ngx_int_t )-1);
      }
#line 1611
      tl->buf = cl->buf;
#line 1612
      *ll = tl;
#line 1613
      ll = & tl->next;
    }
#line 1616
    if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 1617
      goto while_break;
    }
#line 1620
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1623
  if (size) {
    {
#line 1624
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 1625
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1626
      return ((ngx_int_t )-1);
    }
#line 1629
    b = tl->buf;
#line 1630
    chunk = b->start;
#line 1632
    if ((unsigned long )chunk == (unsigned long )((void *)0)) {
      {
#line 1635
      tmp___0 = ngx_palloc(r->pool, sizeof("0000000000000000\r\n") - 1UL);
#line 1635
      chunk = (u_char *)tmp___0;
      }
#line 1636
      if ((unsigned long )chunk == (unsigned long )((void *)0)) {
#line 1637
        return ((ngx_int_t )-1);
      }
#line 1640
      b->start = chunk;
#line 1641
      b->end = (chunk + sizeof("0000000000000000\r\n")) - 1;
    }
    {
#line 1644
    b->tag = (ngx_buf_tag_t )(& ngx_http_proxy_body_output_filter);
#line 1645
    b->memory = 0U;
#line 1646
    b->temporary = 1U;
#line 1647
    b->pos = chunk;
#line 1648
    b->last = ngx_sprintf(chunk, "%xO\r\n", size);
#line 1650
    tl->next = *fl;
#line 1651
    *fl = tl;
    }
  }
#line 1654
  if ((cl->buf)->last_buf) {
    {
#line 1655
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 1656
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1657
      return ((ngx_int_t )-1);
    }
#line 1660
    b = tl->buf;
#line 1662
    b->tag = (ngx_buf_tag_t )(& ngx_http_proxy_body_output_filter);
#line 1663
    b->temporary = 0U;
#line 1664
    b->memory = 1U;
#line 1665
    b->last_buf = 1U;
#line 1666
    b->pos = (u_char *)"\r\n0\r\n\r\n";
#line 1667
    b->last = b->pos + 7;
#line 1669
    (cl->buf)->last_buf = 0U;
#line 1671
    *ll = tl;
#line 1673
    if (size == 0L) {
#line 1674
      b->pos += 2;
    }
  } else
#line 1677
  if (size > 0L) {
    {
#line 1678
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 1679
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1680
      return ((ngx_int_t )-1);
    }
#line 1683
    b = tl->buf;
#line 1685
    b->tag = (ngx_buf_tag_t )(& ngx_http_proxy_body_output_filter);
#line 1686
    b->temporary = 0U;
#line 1687
    b->memory = 1U;
#line 1688
    b->pos = (u_char *)"\r\n";
#line 1689
    b->last = b->pos + 2;
#line 1691
    *ll = tl;
  } else {
#line 1694
    *ll = (ngx_chain_t *)((void *)0);
  }
  out: 
  {
#line 1699
  rc = ngx_chain_writer((void *)(& (r->upstream)->writer), out);
#line 1701
  ngx_chain_update_chains(r->pool, & ctx->free, & ctx->busy, & out, (ngx_buf_tag_t )(& ngx_http_proxy_body_output_filter));
  }
#line 1704
  return (rc);
}
}
#line 1708 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_process_status_line(ngx_http_request_t *r ) 
{ 
  size_t len ;
  ngx_int_t rc ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp8 ;

  {
#line 1716
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1718
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 1719
    return ((ngx_int_t )-1);
  }
  {
#line 1722
  u = r->upstream;
#line 1724
  rc = ngx_http_parse_status_line(r, & u->buffer, & ctx->status);
  }
#line 1726
  if (rc == -2L) {
#line 1727
    return (rc);
  }
#line 1730
  if (rc == -1L) {
#line 1734
    if (r->cache) {
#line 1735
      r->http_version = (ngx_uint_t )9;
#line 1736
      return ((ngx_int_t )0);
    }
#line 1741
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1741
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent no valid HTTP/1.0 header");
      }
    }
#line 1750
    r->http_version = (ngx_uint_t )9;
#line 1751
    (u->state)->status = (ngx_uint_t )200;
#line 1752
    u->headers_in.connection_close = 1U;
#line 1754
    return ((ngx_int_t )0);
  }
#line 1757
  if (u->state) {
#line 1757
    if ((u->state)->status == 0UL) {
#line 1758
      (u->state)->status = ctx->status.code;
    }
  }
  {
#line 1761
  u->headers_in.status_n = ctx->status.code;
#line 1763
  len = (size_t )(ctx->status.end - ctx->status.start);
#line 1764
  u->headers_in.status_line.len = len;
#line 1766
  tmp = ngx_pnalloc(r->pool, len);
#line 1766
  u->headers_in.status_line.data = (u_char *)tmp;
  }
#line 1767
  if ((unsigned long )u->headers_in.status_line.data == (unsigned long )((void *)0)) {
#line 1768
    return ((ngx_int_t )-1);
  }
  {
#line 1771
  memcpy((void */* __restrict  */)u->headers_in.status_line.data, (void const   */* __restrict  */)ctx->status.start,
         len);
  }
#line 1777
  if (ctx->status.http_version < 1001UL) {
#line 1778
    u->headers_in.connection_close = 1U;
  }
  {
#line 1781
  u->process_header = & ngx_http_proxy_process_header;
#line 1783
  tmp___0 = ngx_http_proxy_process_header(r);
  }
#line 1783
  return (tmp___0);
}
}
#line 1787 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_process_header(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1797
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
  {
#line 1799
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1801
    rc = ngx_http_parse_header_line(r, & (r->upstream)->buffer, (ngx_uint_t )1);
    }
#line 1803
    if (rc == 0L) {
      {
#line 1807
      tmp = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1807
      h = (ngx_table_elt_t *)tmp;
      }
#line 1808
      if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1809
        return ((ngx_int_t )-1);
      }
      {
#line 1812
      h->hash = r->header_hash;
#line 1814
      h->key.len = (size_t )(r->header_name_end - r->header_name_start);
#line 1815
      h->value.len = (size_t )(r->header_end - r->header_start);
#line 1817
      tmp___0 = ngx_pnalloc(r->pool, (((h->key.len + 1UL) + h->value.len) + 1UL) + h->key.len);
#line 1817
      h->key.data = (u_char *)tmp___0;
      }
#line 1819
      if ((unsigned long )h->key.data == (unsigned long )((void *)0)) {
#line 1820
        h->hash = (ngx_uint_t )0;
#line 1821
        return ((ngx_int_t )-1);
      }
      {
#line 1824
      h->value.data = (h->key.data + h->key.len) + 1;
#line 1825
      h->lowcase_key = (((h->key.data + h->key.len) + 1) + h->value.len) + 1;
#line 1827
      memcpy((void */* __restrict  */)h->key.data, (void const   */* __restrict  */)r->header_name_start,
             h->key.len);
#line 1828
      *(h->key.data + h->key.len) = (u_char )'\000';
#line 1829
      memcpy((void */* __restrict  */)h->value.data, (void const   */* __restrict  */)r->header_start,
             h->value.len);
#line 1830
      *(h->value.data + h->value.len) = (u_char )'\000';
      }
#line 1832
      if (h->key.len == r->lowcase_index) {
        {
#line 1833
        memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
               h->key.len);
        }
      } else {
        {
#line 1836
        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
        }
      }
      {
#line 1839
      tmp___1 = ngx_hash_find(& umcf->headers_in_hash, h->hash, h->lowcase_key, h->key.len);
#line 1839
      hh = (ngx_http_upstream_header_t *)tmp___1;
      }
#line 1842
      if (hh) {
        {
#line 1842
        tmp___2 = (*(hh->handler))(r, h, hh->offset);
        }
#line 1842
        if (tmp___2 != 0L) {
#line 1843
          return ((ngx_int_t )-1);
        }
      }
#line 1850
      goto __Cont;
    }
#line 1853
    if (rc == 1L) {
#line 1865
      if ((unsigned long )(r->upstream)->headers_in.server == (unsigned long )((void *)0)) {
        {
#line 1866
        tmp___3 = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1866
        h = (ngx_table_elt_t *)tmp___3;
        }
#line 1867
        if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1868
          return ((ngx_int_t )-1);
        }
#line 1871
        h->hash = 3389140803UL;
#line 1874
        h->key.len = sizeof("Server") - 1UL;
#line 1874
        h->key.data = (u_char *)"Server";
#line 1875
        h->value.len = (size_t )0;
#line 1875
        h->value.data = (u_char *)((void *)0);
#line 1876
        h->lowcase_key = (u_char *)"server";
      }
#line 1879
      if ((unsigned long )(r->upstream)->headers_in.date == (unsigned long )((void *)0)) {
        {
#line 1880
        tmp___4 = ngx_list_push(& (r->upstream)->headers_in.headers);
#line 1880
        h = (ngx_table_elt_t *)tmp___4;
        }
#line 1881
        if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1882
          return ((ngx_int_t )-1);
        }
#line 1885
        h->hash = 3076014UL;
#line 1887
        h->key.len = sizeof("Date") - 1UL;
#line 1887
        h->key.data = (u_char *)"Date";
#line 1888
        h->value.len = (size_t )0;
#line 1888
        h->value.data = (u_char *)((void *)0);
#line 1889
        h->lowcase_key = (u_char *)"date";
      }
#line 1894
      u = r->upstream;
#line 1896
      if (u->headers_in.chunked) {
#line 1897
        u->headers_in.content_length_n = (off_t )-1;
      }
#line 1905
      ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1907
      if (u->headers_in.status_n == 204UL) {
#line 1913
        u->keepalive = (unsigned int )(! u->headers_in.connection_close);
      } else
#line 1907
      if (u->headers_in.status_n == 304UL) {
#line 1913
        u->keepalive = (unsigned int )(! u->headers_in.connection_close);
      } else
#line 1907
      if (ctx->head) {
#line 1913
        u->keepalive = (unsigned int )(! u->headers_in.connection_close);
      } else
#line 1907
      if (! u->headers_in.chunked) {
#line 1907
        if (u->headers_in.content_length_n == 0L) {
#line 1913
          u->keepalive = (unsigned int )(! u->headers_in.connection_close);
        }
      }
#line 1916
      if (u->headers_in.status_n == 101UL) {
#line 1917
        u->keepalive = 0U;
#line 1919
        if (r->headers_in.upgrade) {
#line 1920
          u->upgrade = 1U;
        }
      }
#line 1924
      return ((ngx_int_t )0);
    }
#line 1927
    if (rc == -2L) {
#line 1928
      return ((ngx_int_t )-2);
    }
#line 1933
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1933
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid header");
      }
    }
#line 1936
    return ((ngx_int_t )40);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1941 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_input_filter_init(void *data ) 
{ 
  ngx_http_request_t *r ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 1944
  r = (ngx_http_request_t *)data;
#line 1948
  u = r->upstream;
#line 1949
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 1951
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 1952
    return ((ngx_int_t )-1);
  }
#line 1962
  if (u->headers_in.status_n == 204UL) {
#line 1969
    (u->pipe)->length = (off_t )0;
#line 1970
    u->length = (off_t )0;
#line 1971
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  } else
#line 1962
  if (u->headers_in.status_n == 304UL) {
#line 1969
    (u->pipe)->length = (off_t )0;
#line 1970
    u->length = (off_t )0;
#line 1971
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  } else
#line 1962
  if (ctx->head) {
#line 1969
    (u->pipe)->length = (off_t )0;
#line 1970
    u->length = (off_t )0;
#line 1971
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  } else
#line 1973
  if (u->headers_in.chunked) {
#line 1976
    (u->pipe)->input_filter = & ngx_http_proxy_chunked_filter;
#line 1977
    (u->pipe)->length = (off_t )3;
#line 1979
    u->input_filter = & ngx_http_proxy_non_buffered_chunked_filter;
#line 1980
    u->length = (off_t )1;
  } else
#line 1982
  if (u->headers_in.content_length_n == 0L) {
#line 1985
    (u->pipe)->length = (off_t )0;
#line 1986
    u->length = (off_t )0;
#line 1987
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  } else {
#line 1992
    (u->pipe)->length = u->headers_in.content_length_n;
#line 1993
    u->length = u->headers_in.content_length_n;
  }
#line 1996
  return ((ngx_int_t )0);
}
}
#line 2000 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_copy_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_request_t *r ;
  char *__cil_tmp6 ;

  {
#line 2007
  if ((unsigned long )buf->pos == (unsigned long )buf->last) {
#line 2008
    return ((ngx_int_t )0);
  }
  {
#line 2011
  cl = ngx_chain_get_free_buf(p->pool, & p->free);
  }
#line 2012
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2013
    return ((ngx_int_t )-1);
  }
  {
#line 2016
  b = cl->buf;
#line 2018
  memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)buf, sizeof(ngx_buf_t ));
#line 2019
  b->shadow = buf;
#line 2020
  b->tag = p->tag;
#line 2021
  b->last_shadow = 1U;
#line 2022
  b->recycled = 1U;
#line 2023
  buf->shadow = b;
  }
#line 2027
  if (p->in) {
#line 2028
    *(p->last_in) = cl;
  } else {
#line 2030
    p->in = cl;
  }
#line 2032
  p->last_in = & cl->next;
#line 2034
  if (p->length == -1L) {
#line 2035
    return ((ngx_int_t )0);
  }
#line 2038
  p->length -= b->last - b->pos;
#line 2040
  if (p->length == 0L) {
#line 2041
    r = (ngx_http_request_t *)p->input_ctx;
#line 2042
    p->upstream_done = 1U;
#line 2043
    (r->upstream)->keepalive = (unsigned int )(! (r->upstream)->headers_in.connection_close);
  } else
#line 2045
  if (p->length < 0L) {
#line 2046
    r = (ngx_http_request_t *)p->input_ctx;
#line 2047
    p->upstream_done = 1U;
#line 2049
    if (((r->connection)->log)->log_level >= 5UL) {
      {
#line 2049
      ngx_log_error_core((ngx_uint_t )5, (r->connection)->log, 0, "upstream sent more data than specified in \"Content-Length\" header");
      }
    }
  }
#line 2054
  return ((ngx_int_t )0);
}
}
#line 2058 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_chunked_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) 
{ 
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_buf_t **prev ;
  ngx_chain_t *cl ;
  ngx_http_request_t *r ;
  ngx_http_proxy_ctx_t *ctx ;
  ngx_int_t tmp ;
  char *__cil_tmp10 ;

  {
#line 2067
  if ((unsigned long )buf->pos == (unsigned long )buf->last) {
#line 2068
    return ((ngx_int_t )0);
  }
#line 2071
  r = (ngx_http_request_t *)p->input_ctx;
#line 2072
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2074
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2075
    return ((ngx_int_t )-1);
  }
#line 2078
  b = (ngx_buf_t *)((void *)0);
#line 2079
  prev = & buf->shadow;
  {
#line 2081
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2083
    rc = ngx_http_parse_chunked(r, buf, & ctx->chunked);
    }
#line 2085
    if (rc == 0L) {
      {
#line 2089
      cl = ngx_chain_get_free_buf(p->pool, & p->free);
      }
#line 2090
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2091
        return ((ngx_int_t )-1);
      }
      {
#line 2094
      b = cl->buf;
#line 2096
      memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 2098
      b->pos = buf->pos;
#line 2099
      b->start = buf->start;
#line 2100
      b->end = buf->end;
#line 2101
      b->tag = p->tag;
#line 2102
      b->temporary = 1U;
#line 2103
      b->recycled = 1U;
#line 2105
      *prev = b;
#line 2106
      prev = & b->shadow;
      }
#line 2108
      if (p->in) {
#line 2109
        *(p->last_in) = cl;
      } else {
#line 2111
        p->in = cl;
      }
#line 2113
      p->last_in = & cl->next;
#line 2115
      b->num = buf->num;
#line 2120
      if (buf->last - buf->pos >= ctx->chunked.size) {
#line 2122
        buf->pos += (size_t )ctx->chunked.size;
#line 2123
        b->last = buf->pos;
#line 2124
        ctx->chunked.size = (off_t )0;
#line 2126
        goto __Cont;
      }
#line 2129
      ctx->chunked.size -= buf->last - buf->pos;
#line 2130
      buf->pos = buf->last;
#line 2131
      b->last = buf->last;
#line 2133
      goto __Cont;
    }
#line 2136
    if (rc == -4L) {
#line 2140
      p->upstream_done = 1U;
#line 2141
      (r->upstream)->keepalive = (unsigned int )(! (r->upstream)->headers_in.connection_close);
#line 2143
      goto while_break;
    }
#line 2146
    if (rc == -2L) {
#line 2150
      p->length = ctx->chunked.length;
#line 2152
      goto while_break;
    }
#line 2157
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2157
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid chunked response");
      }
    }
#line 2160
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2167
  if (b) {
#line 2168
    b->shadow = buf;
#line 2169
    b->last_shadow = 1U;
#line 2174
    return ((ngx_int_t )0);
  }
  {
#line 2179
  tmp = ngx_event_pipe_add_free_buf(p, buf);
  }
#line 2179
  if (tmp != 0L) {
#line 2180
    return ((ngx_int_t )-1);
  }
#line 2183
  return ((ngx_int_t )0);
}
}
#line 2187 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_non_buffered_copy_filter(void *data , ssize_t bytes ) 
{ 
  ngx_http_request_t *r ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_upstream_t *u ;

  {
#line 2190
  r = (ngx_http_request_t *)data;
#line 2196
  u = r->upstream;
#line 2198
  cl = u->out_bufs;
#line 2198
  ll = & u->out_bufs;
  {
#line 2198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2198
    if (! cl) {
#line 2198
      goto while_break;
    }
#line 2199
    ll = & cl->next;
#line 2198
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2202
  cl = ngx_chain_get_free_buf(r->pool, & u->free_bufs);
  }
#line 2203
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2204
    return ((ngx_int_t )-1);
  }
#line 2207
  *ll = cl;
#line 2209
  (cl->buf)->flush = 1U;
#line 2210
  (cl->buf)->memory = 1U;
#line 2212
  b = & u->buffer;
#line 2214
  (cl->buf)->pos = b->last;
#line 2215
  b->last += bytes;
#line 2216
  (cl->buf)->last = b->last;
#line 2217
  (cl->buf)->tag = u->output.tag;
#line 2219
  if (u->length == -1L) {
#line 2220
    return ((ngx_int_t )0);
  }
#line 2223
  u->length -= bytes;
#line 2225
  if (u->length == 0L) {
#line 2226
    u->keepalive = (unsigned int )(! u->headers_in.connection_close);
  }
#line 2229
  return ((ngx_int_t )0);
}
}
#line 2233 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_non_buffered_chunked_filter(void *data , ssize_t bytes ) 
{ 
  ngx_http_request_t *r ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_buf_t *buf ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_upstream_t *u ;
  ngx_http_proxy_ctx_t *ctx ;
  void *tmp ;
  char *__cil_tmp12 ;

  {
#line 2236
  r = (ngx_http_request_t *)data;
#line 2244
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2246
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2247
    return ((ngx_int_t )-1);
  }
#line 2250
  u = r->upstream;
#line 2251
  buf = & u->buffer;
#line 2253
  buf->pos = buf->last;
#line 2254
  buf->last += bytes;
#line 2256
  cl = u->out_bufs;
#line 2256
  ll = & u->out_bufs;
  {
#line 2256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2256
    if (! cl) {
#line 2256
      goto while_break;
    }
#line 2257
    ll = & cl->next;
#line 2256
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2260
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2262
    rc = ngx_http_parse_chunked(r, buf, & ctx->chunked);
    }
#line 2264
    if (rc == 0L) {
      {
#line 2268
      cl = ngx_chain_get_free_buf(r->pool, & u->free_bufs);
      }
#line 2269
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2270
        return ((ngx_int_t )-1);
      }
#line 2273
      *ll = cl;
#line 2274
      ll = & cl->next;
#line 2276
      b = cl->buf;
#line 2278
      b->flush = 1U;
#line 2279
      b->memory = 1U;
#line 2281
      b->pos = buf->pos;
#line 2282
      b->tag = u->output.tag;
#line 2284
      if (buf->last - buf->pos >= ctx->chunked.size) {
#line 2285
        buf->pos += (size_t )ctx->chunked.size;
#line 2286
        b->last = buf->pos;
#line 2287
        ctx->chunked.size = (off_t )0;
      } else {
#line 2290
        ctx->chunked.size -= buf->last - buf->pos;
#line 2291
        buf->pos = buf->last;
#line 2292
        b->last = buf->last;
      }
#line 2299
      goto __Cont;
    }
#line 2302
    if (rc == -4L) {
#line 2306
      u->keepalive = (unsigned int )(! u->headers_in.connection_close);
#line 2307
      u->length = (off_t )0;
#line 2309
      goto while_break___0;
    }
#line 2312
    if (rc == -2L) {
#line 2313
      goto while_break___0;
    }
#line 2318
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2318
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream sent invalid chunked response");
      }
    }
#line 2321
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2326
  if (r->subrequest_in_memory) {
#line 2328
    cl = u->out_bufs;
#line 2330
    if (cl) {
#line 2331
      buf->pos = (cl->buf)->pos;
    }
#line 2334
    buf->last = buf->pos;
#line 2336
    cl = u->out_bufs;
    {
#line 2336
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2336
      if (! cl) {
#line 2336
        goto while_break___1;
      }
#line 2341
      if ((unsigned long )buf->last == (unsigned long )(cl->buf)->pos) {
#line 2342
        buf->last = (cl->buf)->last;
#line 2343
        goto __Cont___0;
      }
      {
#line 2346
      tmp = memmove((void *)buf->last, (void const   *)(cl->buf)->pos, (size_t )((cl->buf)->last - (cl->buf)->pos));
#line 2346
      buf->last = (u_char *)tmp + ((cl->buf)->last - (cl->buf)->pos);
#line 2349
      (cl->buf)->pos = buf->last - ((cl->buf)->last - (cl->buf)->pos);
#line 2350
      (cl->buf)->last = buf->last;
      }
      __Cont___0: /* CIL Label */ 
#line 2336
      cl = cl->next;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2354
  return ((ngx_int_t )0);
}
}
#line 2358 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static void ngx_http_proxy_abort_request(ngx_http_request_t *r ) 
{ 


  {
#line 2364
  return;
}
}
#line 2368 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static void ngx_http_proxy_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 


  {
#line 2374
  return;
}
}
#line 2378 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_host_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 2384
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2386
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2387
    v->not_found = 1U;
#line 2388
    return ((ngx_int_t )0);
  }
#line 2391
  v->len = (unsigned int )ctx->vars.host_header.len;
#line 2392
  v->valid = 1U;
#line 2393
  v->no_cacheable = 0U;
#line 2394
  v->not_found = 0U;
#line 2395
  v->data = ctx->vars.host_header.data;
#line 2397
  return ((ngx_int_t )0);
}
}
#line 2401 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_port_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;

  {
#line 2407
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2409
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2410
    v->not_found = 1U;
#line 2411
    return ((ngx_int_t )0);
  }
#line 2414
  v->len = (unsigned int )ctx->vars.port.len;
#line 2415
  v->valid = 1U;
#line 2416
  v->no_cacheable = 0U;
#line 2417
  v->not_found = 0U;
#line 2418
  v->data = ctx->vars.port.data;
#line 2420
  return ((ngx_int_t )0);
}
}
#line 2424 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_add_x_forwarded_for_variable(ngx_http_request_t *r ,
                                                             ngx_http_variable_value_t *v ,
                                                             uintptr_t data ) 
{ 
  size_t len ;
  u_char *p ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_table_elt_t **h ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  char *__cil_tmp13 ;

  {
#line 2433
  v->valid = 1U;
#line 2434
  v->no_cacheable = 0U;
#line 2435
  v->not_found = 0U;
#line 2437
  n = r->headers_in.x_forwarded_for.nelts;
#line 2438
  h = (ngx_table_elt_t **)r->headers_in.x_forwarded_for.elts;
#line 2440
  len = (size_t )0;
#line 2442
  i = (ngx_uint_t )0;
  {
#line 2442
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2442
    if (! (i < n)) {
#line 2442
      goto while_break;
    }
#line 2443
    len += ((*(h + i))->value.len + sizeof(", ")) - 1UL;
#line 2442
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2446
  if (len == 0UL) {
#line 2447
    v->len = (unsigned int )(r->connection)->addr_text.len;
#line 2448
    v->data = (r->connection)->addr_text.data;
#line 2449
    return ((ngx_int_t )0);
  }
  {
#line 2452
  len += (r->connection)->addr_text.len;
#line 2454
  tmp = ngx_pnalloc(r->pool, len);
#line 2454
  p = (u_char *)tmp;
  }
#line 2455
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2456
    return ((ngx_int_t )-1);
  }
#line 2459
  v->len = (unsigned int )len;
#line 2460
  v->data = p;
#line 2462
  i = (ngx_uint_t )0;
  {
#line 2462
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2462
    if (! (i < n)) {
#line 2462
      goto while_break___0;
    }
    {
#line 2463
    tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(*(h + i))->value.data,
                     (*(h + i))->value.len);
#line 2463
    p = (u_char *)tmp___0 + (*(h + i))->value.len;
#line 2464
    tmp___1 = p;
#line 2464
    p ++;
#line 2464
    *tmp___1 = (u_char )',';
#line 2464
    tmp___2 = p;
#line 2464
    p ++;
#line 2464
    *tmp___2 = (u_char )' ';
#line 2462
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2467
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(r->connection)->addr_text.data,
         (r->connection)->addr_text.len);
  }
#line 2469
  return ((ngx_int_t )0);
}
}
#line 2473 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_internal_body_length_variable(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 2479
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2481
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2482
    v->not_found = 1U;
#line 2483
    return ((ngx_int_t )0);
  } else
#line 2481
  if (ctx->internal_body_length < 0L) {
#line 2482
    v->not_found = 1U;
#line 2483
    return ((ngx_int_t )0);
  }
  {
#line 2486
  v->valid = 1U;
#line 2487
  v->no_cacheable = 0U;
#line 2488
  v->not_found = 0U;
#line 2490
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2490
  v->data = (u_char *)tmp;
  }
#line 2492
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 2493
    return ((ngx_int_t )-1);
  }
  {
#line 2496
  tmp___0 = ngx_sprintf(v->data, "%O", ctx->internal_body_length);
#line 2496
  v->len = (unsigned int )(tmp___0 - v->data);
  }
#line 2498
  return ((ngx_int_t )0);
}
}
#line 2502 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_internal_chunked_variable(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) 
{ 
  ngx_http_proxy_ctx_t *ctx ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 2508
  ctx = (ngx_http_proxy_ctx_t *)*(r->ctx + ngx_http_proxy_module.ctx_index);
#line 2510
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2511
    v->not_found = 1U;
#line 2512
    return ((ngx_int_t )0);
  } else
#line 2510
  if (! ctx->internal_chunked) {
#line 2511
    v->not_found = 1U;
#line 2512
    return ((ngx_int_t )0);
  }
#line 2515
  v->valid = 1U;
#line 2516
  v->no_cacheable = 0U;
#line 2517
  v->not_found = 0U;
#line 2519
  v->data = (u_char *)"chunked";
#line 2520
  v->len = (unsigned int )(sizeof("chunked") - 1UL);
#line 2522
  return ((ngx_int_t )0);
}
}
#line 2526 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_redirect(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                 size_t prefix ) 
{ 
  size_t len ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_proxy_loc_conf_t *plcf ;

  {
#line 2536
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 2538
  pr = (ngx_http_proxy_rewrite_t *)(plcf->redirects)->elts;
#line 2540
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 2541
    return ((ngx_int_t )-5);
  }
#line 2544
  len = h->value.len - prefix;
#line 2546
  i = (ngx_uint_t )0;
  {
#line 2546
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2546
    if (! (i < (plcf->redirects)->nelts)) {
#line 2546
      goto while_break;
    }
    {
#line 2547
    rc = (*((pr + i)->handler))(r, h, prefix, len, pr + i);
    }
#line 2549
    if (rc != -5L) {
#line 2550
      return (rc);
    }
#line 2546
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2554
  return ((ngx_int_t )-5);
}
}
#line 2558 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ) 
{ 
  size_t prefix ;
  u_char *p ;
  ngx_int_t rc ;
  ngx_int_t rv ;
  ngx_http_proxy_loc_conf_t *plcf ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2566
  tmp = strchr((char const   *)h->value.data, ';');
#line 2566
  p = (u_char *)tmp;
  }
#line 2567
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2568
    return ((ngx_int_t )-5);
  }
#line 2571
  prefix = (size_t )((p + 1) - h->value.data);
#line 2573
  rv = (ngx_int_t )-5;
#line 2575
  plcf = (ngx_http_proxy_loc_conf_t *)*(r->loc_conf + ngx_http_proxy_module.ctx_index);
#line 2577
  if (plcf->cookie_domains) {
    {
#line 2578
    p = ngx_strcasestrn(h->value.data + prefix, (char *)"domain=", (size_t )6);
    }
#line 2580
    if (p) {
      {
#line 2581
      rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 7, plcf->cookie_domains);
      }
#line 2583
      if (rc == -1L) {
#line 2584
        return ((ngx_int_t )-1);
      }
#line 2587
      if (rc != -5L) {
#line 2588
        rv = rc;
      }
    }
  }
#line 2593
  if (plcf->cookie_paths) {
    {
#line 2594
    p = ngx_strcasestrn(h->value.data + prefix, (char *)"path=", (size_t )4);
    }
#line 2596
    if (p) {
      {
#line 2597
      rc = ngx_http_proxy_rewrite_cookie_value(r, h, p + 5, plcf->cookie_paths);
      }
#line 2599
      if (rc == -1L) {
#line 2600
        return ((ngx_int_t )-1);
      }
#line 2603
      if (rc != -5L) {
#line 2604
        rv = rc;
      }
    }
  }
#line 2609
  return (rv);
}
}
#line 2613 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_cookie_value(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     u_char *value , ngx_array_t *rewrites ) 
{ 
  size_t len ;
  size_t prefix ;
  u_char *p ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_http_proxy_rewrite_t *pr ;
  char *tmp ;

  {
  {
#line 2623
  prefix = (size_t )(value - h->value.data);
#line 2625
  tmp = strchr((char const   *)value, ';');
#line 2625
  p = (u_char *)tmp;
  }
#line 2627
  if (p) {
#line 2627
    len = (size_t )(p - value);
  } else {
#line 2627
    len = h->value.len - prefix;
  }
#line 2629
  pr = (ngx_http_proxy_rewrite_t *)rewrites->elts;
#line 2631
  i = (ngx_uint_t )0;
  {
#line 2631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2631
    if (! (i < rewrites->nelts)) {
#line 2631
      goto while_break;
    }
    {
#line 2632
    rc = (*((pr + i)->handler))(r, h, prefix, len, pr + i);
    }
#line 2634
    if (rc != -5L) {
#line 2635
      return (rc);
    }
#line 2631
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2639
  return ((ngx_int_t )-5);
}
}
#line 2643 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_complex_handler(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                        size_t prefix , size_t len ,
                                                        ngx_http_proxy_rewrite_t *pr ) 
{ 
  ngx_str_t pattern ;
  ngx_str_t replacement ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 2649
  tmp = ngx_http_complex_value(r, & pr->pattern.complex, & pattern);
  }
#line 2649
  if (tmp != 0L) {
#line 2650
    return ((ngx_int_t )-1);
  }
#line 2653
  if (pattern.len > len) {
#line 2657
    return ((ngx_int_t )-5);
  } else {
    {
#line 2653
    tmp___0 = ngx_rstrncmp(h->value.data + prefix, pattern.data, pattern.len);
    }
#line 2653
    if (tmp___0 != 0L) {
#line 2657
      return ((ngx_int_t )-5);
    }
  }
  {
#line 2660
  tmp___1 = ngx_http_complex_value(r, & pr->replacement, & replacement);
  }
#line 2660
  if (tmp___1 != 0L) {
#line 2661
    return ((ngx_int_t )-1);
  }
  {
#line 2664
  tmp___2 = ngx_http_proxy_rewrite(r, h, prefix, pattern.len, & replacement);
  }
#line 2664
  return (tmp___2);
}
}
#line 2670 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_regex_handler(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      size_t prefix , size_t len ,
                                                      ngx_http_proxy_rewrite_t *pr ) 
{ 
  ngx_str_t pattern ;
  ngx_str_t replacement ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 2676
  pattern.len = len;
#line 2677
  pattern.data = h->value.data + prefix;
#line 2679
  tmp = ngx_http_regex_exec(r, pr->pattern.regex, & pattern);
  }
#line 2679
  if (tmp != 0L) {
#line 2680
    return ((ngx_int_t )-5);
  }
  {
#line 2683
  tmp___0 = ngx_http_complex_value(r, & pr->replacement, & replacement);
  }
#line 2683
  if (tmp___0 != 0L) {
#line 2684
    return ((ngx_int_t )-1);
  }
#line 2687
  if (prefix == 0UL) {
#line 2687
    if (h->value.len == len) {
#line 2688
      h->value = replacement;
#line 2689
      return ((ngx_int_t )0);
    }
  }
  {
#line 2692
  tmp___1 = ngx_http_proxy_rewrite(r, h, prefix, len, & replacement);
  }
#line 2692
  return (tmp___1);
}
}
#line 2698 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_domain_handler(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                       size_t prefix , size_t len ,
                                                       ngx_http_proxy_rewrite_t *pr ) 
{ 
  u_char *p ;
  ngx_str_t pattern ;
  ngx_str_t replacement ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 2705
  tmp = ngx_http_complex_value(r, & pr->pattern.complex, & pattern);
  }
#line 2705
  if (tmp != 0L) {
#line 2706
    return ((ngx_int_t )-1);
  }
#line 2709
  p = h->value.data + prefix;
#line 2711
  if ((int )*(p + 0) == 46) {
#line 2712
    p ++;
#line 2713
    prefix ++;
#line 2714
    len --;
  }
#line 2717
  if (pattern.len != len) {
#line 2718
    return ((ngx_int_t )-5);
  } else {
    {
#line 2717
    tmp___0 = ngx_rstrncasecmp(pattern.data, p, len);
    }
#line 2717
    if (tmp___0 != 0L) {
#line 2718
      return ((ngx_int_t )-5);
    }
  }
  {
#line 2721
  tmp___1 = ngx_http_complex_value(r, & pr->replacement, & replacement);
  }
#line 2721
  if (tmp___1 != 0L) {
#line 2722
    return ((ngx_int_t )-1);
  }
  {
#line 2725
  tmp___2 = ngx_http_proxy_rewrite(r, h, prefix, len, & replacement);
  }
#line 2725
  return (tmp___2);
}
}
#line 2729 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                        size_t prefix , size_t len , ngx_str_t *replacement ) 
{ 
  u_char *p ;
  u_char *data ;
  size_t new_len ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 2736
  new_len = (replacement->len + h->value.len) - len;
#line 2738
  if (replacement->len > len) {
    {
#line 2740
    tmp = ngx_pnalloc(r->pool, new_len + 1UL);
#line 2740
    data = (u_char *)tmp;
    }
#line 2741
    if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 2742
      return ((ngx_int_t )-1);
    }
    {
#line 2745
    tmp___0 = memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)h->value.data,
                     prefix);
#line 2745
    p = (u_char *)tmp___0 + prefix;
#line 2746
    tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)replacement->data,
                     replacement->len);
#line 2746
    p = (u_char *)tmp___1 + replacement->len;
#line 2748
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)((h->value.data + prefix) + len),
           ((h->value.len - len) - prefix) + 1UL);
#line 2751
    h->value.data = data;
    }
  } else {
    {
#line 2754
    tmp___2 = memcpy((void */* __restrict  */)(h->value.data + prefix), (void const   */* __restrict  */)replacement->data,
                     replacement->len);
#line 2754
    p = (u_char *)tmp___2 + replacement->len;
#line 2757
    memmove((void *)p, (void const   *)((h->value.data + prefix) + len), ((h->value.len - len) - prefix) + 1UL);
    }
  }
#line 2761
  h->value.len = new_len;
#line 2763
  return ((ngx_int_t )0);
}
}
#line 2767 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;

  {
#line 2772
  v = ngx_http_proxy_vars;
  {
#line 2772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2772
    if (! v->name.len) {
#line 2772
      goto while_break;
    }
    {
#line 2773
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 2774
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2775
      return ((ngx_int_t )-1);
    }
#line 2778
    var->get_handler = v->get_handler;
#line 2779
    var->data = v->data;
#line 2772
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2782
  return ((ngx_int_t )0);
}
}
#line 2786 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static void *ngx_http_proxy_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_proxy_main_conf_t *conf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 2791
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_proxy_main_conf_t ));
#line 2791
  conf = (ngx_http_proxy_main_conf_t *)tmp;
  }
#line 2792
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 2793
    return ((void *)0);
  }
  {
#line 2797
  tmp___0 = ngx_array_init(& conf->caches, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_file_cache_t *));
  }
#line 2797
  if (tmp___0 != 0L) {
#line 2801
    return ((void *)0);
  }
#line 2805
  return ((void *)conf);
}
}
#line 2809 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static void *ngx_http_proxy_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_proxy_loc_conf_t *conf ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 2814
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_proxy_loc_conf_t ));
#line 2814
  conf = (ngx_http_proxy_loc_conf_t *)tmp;
  }
#line 2815
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 2816
    return ((void *)0);
  }
#line 2857
  conf->upstream.store = -1;
#line 2858
  conf->upstream.store_access = (ngx_uint_t )-1;
#line 2859
  conf->upstream.next_upstream_tries = (ngx_uint_t )-1;
#line 2860
  conf->upstream.buffering = (ngx_flag_t )-1;
#line 2861
  conf->upstream.request_buffering = (ngx_flag_t )-1;
#line 2862
  conf->upstream.ignore_client_abort = (ngx_flag_t )-1;
#line 2863
  conf->upstream.force_ranges = (ngx_flag_t )-1;
#line 2865
  conf->upstream.local = (ngx_http_upstream_local_t *)((void *)-1);
#line 2867
  conf->upstream.connect_timeout = (ngx_msec_t )-1;
#line 2868
  conf->upstream.send_timeout = (ngx_msec_t )-1;
#line 2869
  conf->upstream.read_timeout = (ngx_msec_t )-1;
#line 2870
  conf->upstream.next_upstream_timeout = (ngx_msec_t )-1;
#line 2872
  conf->upstream.send_lowat = (size_t )-1;
#line 2873
  conf->upstream.buffer_size = (size_t )-1;
#line 2874
  conf->upstream.limit_rate = (size_t )-1;
#line 2876
  conf->upstream.busy_buffers_size_conf = (size_t )-1;
#line 2877
  conf->upstream.max_temp_file_size_conf = (size_t )-1;
#line 2878
  conf->upstream.temp_file_write_size_conf = (size_t )-1;
#line 2880
  conf->upstream.pass_request_headers = (ngx_flag_t )-1;
#line 2881
  conf->upstream.pass_request_body = (ngx_flag_t )-1;
#line 2884
  conf->upstream.cache = -1;
#line 2885
  conf->upstream.cache_min_uses = (ngx_uint_t )-1;
#line 2886
  conf->upstream.cache_max_range_offset = (off_t )-1;
#line 2887
  conf->upstream.cache_bypass = (ngx_array_t *)((void *)-1);
#line 2888
  conf->upstream.no_cache = (ngx_array_t *)((void *)-1);
#line 2889
  conf->upstream.cache_valid = (ngx_array_t *)((void *)-1);
#line 2890
  conf->upstream.cache_lock = (ngx_flag_t )-1;
#line 2891
  conf->upstream.cache_lock_timeout = (ngx_msec_t )-1;
#line 2892
  conf->upstream.cache_lock_age = (ngx_msec_t )-1;
#line 2893
  conf->upstream.cache_revalidate = (ngx_flag_t )-1;
#line 2894
  conf->upstream.cache_convert_head = (ngx_flag_t )-1;
#line 2895
  conf->upstream.cache_background_update = (ngx_flag_t )-1;
#line 2898
  conf->upstream.hide_headers = (ngx_array_t *)((void *)-1);
#line 2899
  conf->upstream.pass_headers = (ngx_array_t *)((void *)-1);
#line 2901
  conf->upstream.intercept_errors = (ngx_flag_t )-1;
#line 2912
  conf->upstream.cyclic_temp_file = (ngx_flag_t )0;
#line 2914
  conf->redirect = (ngx_flag_t )-1;
#line 2915
  conf->upstream.change_buffering = 1U;
#line 2917
  conf->cookie_domains = (ngx_array_t *)((void *)-1);
#line 2918
  conf->cookie_paths = (ngx_array_t *)((void *)-1);
#line 2920
  conf->http_version = (ngx_uint_t )-1;
#line 2922
  conf->headers_hash_max_size = (ngx_uint_t )-1;
#line 2923
  conf->headers_hash_bucket_size = (ngx_uint_t )-1;
#line 2925
  conf->upstream.module.len = sizeof("proxy") - 1UL;
#line 2925
  conf->upstream.module.data = (u_char *)"proxy";
#line 2927
  return ((void *)conf);
}
}
#line 2931 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_proxy_loc_conf_t *prev ;
  ngx_http_proxy_loc_conf_t *conf ;
  u_char *p ;
  size_t size ;
  ngx_int_t rc ;
  ngx_hash_init_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_script_compile_t sc ;
  char *tmp ;
  ngx_shm_zone_t *shm_zone ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 2934
  prev = (ngx_http_proxy_loc_conf_t *)parent;
#line 2935
  conf = (ngx_http_proxy_loc_conf_t *)child;
#line 2947
  if (conf->upstream.store > 0) {
#line 2948
    conf->upstream.cache = 0;
  }
#line 2951
  if (conf->upstream.cache > 0) {
#line 2952
    conf->upstream.store = 0;
  }
#line 2957
  if (conf->upstream.store == -1) {
#line 2958
    if (conf->upstream.store == -1) {
#line 2958
      if (prev->upstream.store == -1) {
#line 2958
        conf->upstream.store = 0;
      } else {
#line 2958
        conf->upstream.store = prev->upstream.store;
      }
    }
#line 2961
    conf->upstream.store_lengths = prev->upstream.store_lengths;
#line 2962
    conf->upstream.store_values = prev->upstream.store_values;
  }
#line 2965
  if (conf->upstream.store_access == 0xffffffffffffffffUL) {
#line 2965
    if (prev->upstream.store_access == 0xffffffffffffffffUL) {
#line 2965
      conf->upstream.store_access = (ngx_uint_t )384;
    } else {
#line 2965
      conf->upstream.store_access = prev->upstream.store_access;
    }
  }
#line 2968
  if (conf->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 2968
    if (prev->upstream.next_upstream_tries == 0xffffffffffffffffUL) {
#line 2968
      conf->upstream.next_upstream_tries = (ngx_uint_t )0;
    } else {
#line 2968
      conf->upstream.next_upstream_tries = prev->upstream.next_upstream_tries;
    }
  }
#line 2971
  if (conf->upstream.buffering == -1L) {
#line 2971
    if (prev->upstream.buffering == -1L) {
#line 2971
      conf->upstream.buffering = (ngx_flag_t )1;
    } else {
#line 2971
      conf->upstream.buffering = prev->upstream.buffering;
    }
  }
#line 2974
  if (conf->upstream.request_buffering == -1L) {
#line 2974
    if (prev->upstream.request_buffering == -1L) {
#line 2974
      conf->upstream.request_buffering = (ngx_flag_t )1;
    } else {
#line 2974
      conf->upstream.request_buffering = prev->upstream.request_buffering;
    }
  }
#line 2977
  if (conf->upstream.ignore_client_abort == -1L) {
#line 2977
    if (prev->upstream.ignore_client_abort == -1L) {
#line 2977
      conf->upstream.ignore_client_abort = (ngx_flag_t )0;
    } else {
#line 2977
      conf->upstream.ignore_client_abort = prev->upstream.ignore_client_abort;
    }
  }
#line 2980
  if (conf->upstream.force_ranges == -1L) {
#line 2980
    if (prev->upstream.force_ranges == -1L) {
#line 2980
      conf->upstream.force_ranges = (ngx_flag_t )0;
    } else {
#line 2980
      conf->upstream.force_ranges = prev->upstream.force_ranges;
    }
  }
#line 2983
  if ((unsigned long )conf->upstream.local == (unsigned long )((void *)-1)) {
#line 2983
    if ((unsigned long )prev->upstream.local == (unsigned long )((void *)-1)) {
#line 2983
      conf->upstream.local = (ngx_http_upstream_local_t *)((void *)0);
    } else {
#line 2983
      conf->upstream.local = prev->upstream.local;
    }
  }
#line 2986
  if (conf->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 2986
    if (prev->upstream.connect_timeout == 0xffffffffffffffffUL) {
#line 2986
      conf->upstream.connect_timeout = (ngx_msec_t )60000;
    } else {
#line 2986
      conf->upstream.connect_timeout = prev->upstream.connect_timeout;
    }
  }
#line 2989
  if (conf->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 2989
    if (prev->upstream.send_timeout == 0xffffffffffffffffUL) {
#line 2989
      conf->upstream.send_timeout = (ngx_msec_t )60000;
    } else {
#line 2989
      conf->upstream.send_timeout = prev->upstream.send_timeout;
    }
  }
#line 2992
  if (conf->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 2992
    if (prev->upstream.read_timeout == 0xffffffffffffffffUL) {
#line 2992
      conf->upstream.read_timeout = (ngx_msec_t )60000;
    } else {
#line 2992
      conf->upstream.read_timeout = prev->upstream.read_timeout;
    }
  }
#line 2995
  if (conf->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 2995
    if (prev->upstream.next_upstream_timeout == 0xffffffffffffffffUL) {
#line 2995
      conf->upstream.next_upstream_timeout = (ngx_msec_t )0;
    } else {
#line 2995
      conf->upstream.next_upstream_timeout = prev->upstream.next_upstream_timeout;
    }
  }
#line 2998
  if (conf->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 2998
    if (prev->upstream.send_lowat == 0xffffffffffffffffUL) {
#line 2998
      conf->upstream.send_lowat = (size_t )0;
    } else {
#line 2998
      conf->upstream.send_lowat = prev->upstream.send_lowat;
    }
  }
#line 3001
  if (conf->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 3001
    if (prev->upstream.buffer_size == 0xffffffffffffffffUL) {
#line 3001
      conf->upstream.buffer_size = ngx_pagesize;
    } else {
#line 3001
      conf->upstream.buffer_size = prev->upstream.buffer_size;
    }
  }
#line 3005
  if (conf->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 3005
    if (prev->upstream.limit_rate == 0xffffffffffffffffUL) {
#line 3005
      conf->upstream.limit_rate = (size_t )0;
    } else {
#line 3005
      conf->upstream.limit_rate = prev->upstream.limit_rate;
    }
  }
#line 3008
  if (conf->upstream.bufs.num == 0L) {
#line 3008
    if (prev->upstream.bufs.num) {
#line 3008
      conf->upstream.bufs.num = prev->upstream.bufs.num;
#line 3008
      conf->upstream.bufs.size = prev->upstream.bufs.size;
    } else {
#line 3008
      conf->upstream.bufs.num = (ngx_int_t )8;
#line 3008
      conf->upstream.bufs.size = ngx_pagesize;
    }
  }
#line 3011
  if (conf->upstream.bufs.num < 2L) {
    {
#line 3012
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "there must be at least 2 \"proxy_buffers\"");
    }
#line 3014
    return ((char *)((void *)-1));
  }
#line 3018
  size = conf->upstream.buffer_size;
#line 3019
  if (size < conf->upstream.bufs.size) {
#line 3020
    size = conf->upstream.bufs.size;
  }
#line 3024
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 3024
    if (prev->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 3024
      conf->upstream.busy_buffers_size_conf = (size_t )-1;
    } else {
#line 3024
      conf->upstream.busy_buffers_size_conf = prev->upstream.busy_buffers_size_conf;
    }
  }
#line 3028
  if (conf->upstream.busy_buffers_size_conf == 0xffffffffffffffffUL) {
#line 3029
    conf->upstream.busy_buffers_size = 2UL * size;
  } else {
#line 3031
    conf->upstream.busy_buffers_size = conf->upstream.busy_buffers_size_conf;
  }
#line 3035
  if (conf->upstream.busy_buffers_size < size) {
    {
#line 3036
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_busy_buffers_size\" must be equal to or greater than the maximum of the value of \"proxy_buffer_size\" and one of the \"proxy_buffers\"");
    }
#line 3041
    return ((char *)((void *)-1));
  }
#line 3044
  if (conf->upstream.busy_buffers_size > (size_t )(conf->upstream.bufs.num - 1L) * conf->upstream.bufs.size) {
    {
#line 3047
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_busy_buffers_size\" must be less than the size of all \"proxy_buffers\" minus one buffer");
    }
#line 3051
    return ((char *)((void *)-1));
  }
#line 3055
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 3055
    if (prev->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 3055
      conf->upstream.temp_file_write_size_conf = (size_t )-1;
    } else {
#line 3055
      conf->upstream.temp_file_write_size_conf = prev->upstream.temp_file_write_size_conf;
    }
  }
#line 3059
  if (conf->upstream.temp_file_write_size_conf == 0xffffffffffffffffUL) {
#line 3060
    conf->upstream.temp_file_write_size = 2UL * size;
  } else {
#line 3062
    conf->upstream.temp_file_write_size = conf->upstream.temp_file_write_size_conf;
  }
#line 3066
  if (conf->upstream.temp_file_write_size < size) {
    {
#line 3067
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_temp_file_write_size\" must be equal to or greater than the maximum of the value of \"proxy_buffer_size\" and one of the \"proxy_buffers\"");
    }
#line 3072
    return ((char *)((void *)-1));
  }
#line 3075
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 3075
    if (prev->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 3075
      conf->upstream.max_temp_file_size_conf = (size_t )-1;
    } else {
#line 3075
      conf->upstream.max_temp_file_size_conf = prev->upstream.max_temp_file_size_conf;
    }
  }
#line 3079
  if (conf->upstream.max_temp_file_size_conf == 0xffffffffffffffffUL) {
#line 3080
    conf->upstream.max_temp_file_size = (size_t )1073741824;
  } else {
#line 3082
    conf->upstream.max_temp_file_size = conf->upstream.max_temp_file_size_conf;
  }
#line 3086
  if (conf->upstream.max_temp_file_size != 0UL) {
#line 3086
    if (conf->upstream.max_temp_file_size < size) {
      {
#line 3089
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_max_temp_file_size\" must be equal to zero to disable temporary files usage or must be equal to or greater than the maximum of the value of \"proxy_buffer_size\" and one of the \"proxy_buffers\"");
      }
#line 3095
      return ((char *)((void *)-1));
    }
  }
#line 3099
  if (conf->upstream.ignore_headers == 0UL) {
#line 3099
    if (prev->upstream.ignore_headers == 0UL) {
#line 3099
      conf->upstream.ignore_headers = (ngx_uint_t )1;
    } else {
#line 3099
      conf->upstream.ignore_headers = prev->upstream.ignore_headers;
    }
  }
#line 3104
  if (conf->upstream.next_upstream == 0UL) {
#line 3104
    if (prev->upstream.next_upstream == 0UL) {
#line 3104
      conf->upstream.next_upstream = (ngx_uint_t )7;
    } else {
#line 3104
      conf->upstream.next_upstream = prev->upstream.next_upstream;
    }
  }
#line 3110
  if (conf->upstream.next_upstream & 2147483648UL) {
#line 3111
    conf->upstream.next_upstream = (ngx_uint_t )2147483649U;
  }
  {
#line 3115
  tmp = ngx_conf_merge_path_value(cf, & conf->upstream.temp_path, prev->upstream.temp_path,
                                  & ngx_http_proxy_temp_path);
  }
#line 3115
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 3120
    return ((char *)((void *)-1));
  }
#line 3126
  if (conf->upstream.cache == -1) {
#line 3127
    if (conf->upstream.cache == -1) {
#line 3127
      if (prev->upstream.cache == -1) {
#line 3127
        conf->upstream.cache = 0;
      } else {
#line 3127
        conf->upstream.cache = prev->upstream.cache;
      }
    }
#line 3130
    conf->upstream.cache_zone = prev->upstream.cache_zone;
#line 3131
    conf->upstream.cache_value = prev->upstream.cache_value;
  }
#line 3134
  if (conf->upstream.cache_zone) {
#line 3134
    if ((unsigned long )(conf->upstream.cache_zone)->data == (unsigned long )((void *)0)) {
      {
#line 3137
      shm_zone = conf->upstream.cache_zone;
#line 3139
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_cache\" zone \"%V\" is unknown",
                         & shm_zone->shm.name);
      }
#line 3143
      return ((char *)((void *)-1));
    }
  }
#line 3146
  if (conf->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 3146
    if (prev->upstream.cache_min_uses == 0xffffffffffffffffUL) {
#line 3146
      conf->upstream.cache_min_uses = (ngx_uint_t )1;
    } else {
#line 3146
      conf->upstream.cache_min_uses = prev->upstream.cache_min_uses;
    }
  }
#line 3149
  if (conf->upstream.cache_max_range_offset == -1L) {
#line 3149
    if (prev->upstream.cache_max_range_offset == -1L) {
#line 3149
      conf->upstream.cache_max_range_offset = (off_t )9223372036854775807LL;
    } else {
#line 3149
      conf->upstream.cache_max_range_offset = prev->upstream.cache_max_range_offset;
    }
  }
#line 3153
  if (conf->upstream.cache_use_stale == 0UL) {
#line 3153
    if (prev->upstream.cache_use_stale == 0UL) {
#line 3153
      conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
    } else {
#line 3153
      conf->upstream.cache_use_stale = prev->upstream.cache_use_stale;
    }
  }
#line 3158
  if (conf->upstream.cache_use_stale & 2147483648UL) {
#line 3159
    conf->upstream.cache_use_stale = (ngx_uint_t )2147483649U;
  }
#line 3163
  if (conf->upstream.cache_use_stale & 2UL) {
#line 3164
    conf->upstream.cache_use_stale |= 1073741824UL;
  }
#line 3167
  if (conf->upstream.cache_methods == 0UL) {
#line 3168
    conf->upstream.cache_methods = prev->upstream.cache_methods;
  }
#line 3171
  conf->upstream.cache_methods |= 6UL;
#line 3173
  if ((unsigned long )conf->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 3173
    if ((unsigned long )prev->upstream.cache_bypass == (unsigned long )((void *)-1)) {
#line 3173
      conf->upstream.cache_bypass = (ngx_array_t *)((void *)0);
    } else {
#line 3173
      conf->upstream.cache_bypass = prev->upstream.cache_bypass;
    }
  }
#line 3176
  if ((unsigned long )conf->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 3176
    if ((unsigned long )prev->upstream.no_cache == (unsigned long )((void *)-1)) {
#line 3176
      conf->upstream.no_cache = (ngx_array_t *)((void *)0);
    } else {
#line 3176
      conf->upstream.no_cache = prev->upstream.no_cache;
    }
  }
#line 3179
  if ((unsigned long )conf->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 3179
    if ((unsigned long )prev->upstream.cache_valid == (unsigned long )((void *)-1)) {
#line 3179
      conf->upstream.cache_valid = (ngx_array_t *)((void *)0);
    } else {
#line 3179
      conf->upstream.cache_valid = prev->upstream.cache_valid;
    }
  }
#line 3182
  if ((unsigned long )conf->cache_key.value.data == (unsigned long )((void *)0)) {
#line 3183
    conf->cache_key = prev->cache_key;
  }
#line 3186
  if (conf->upstream.cache_lock == -1L) {
#line 3186
    if (prev->upstream.cache_lock == -1L) {
#line 3186
      conf->upstream.cache_lock = (ngx_flag_t )0;
    } else {
#line 3186
      conf->upstream.cache_lock = prev->upstream.cache_lock;
    }
  }
#line 3189
  if (conf->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 3189
    if (prev->upstream.cache_lock_timeout == 0xffffffffffffffffUL) {
#line 3189
      conf->upstream.cache_lock_timeout = (ngx_msec_t )5000;
    } else {
#line 3189
      conf->upstream.cache_lock_timeout = prev->upstream.cache_lock_timeout;
    }
  }
#line 3192
  if (conf->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 3192
    if (prev->upstream.cache_lock_age == 0xffffffffffffffffUL) {
#line 3192
      conf->upstream.cache_lock_age = (ngx_msec_t )5000;
    } else {
#line 3192
      conf->upstream.cache_lock_age = prev->upstream.cache_lock_age;
    }
  }
#line 3195
  if (conf->upstream.cache_revalidate == -1L) {
#line 3195
    if (prev->upstream.cache_revalidate == -1L) {
#line 3195
      conf->upstream.cache_revalidate = (ngx_flag_t )0;
    } else {
#line 3195
      conf->upstream.cache_revalidate = prev->upstream.cache_revalidate;
    }
  }
#line 3198
  if (conf->upstream.cache_convert_head == -1L) {
#line 3198
    if (prev->upstream.cache_convert_head == -1L) {
#line 3198
      conf->upstream.cache_convert_head = (ngx_flag_t )1;
    } else {
#line 3198
      conf->upstream.cache_convert_head = prev->upstream.cache_convert_head;
    }
  }
#line 3201
  if (conf->upstream.cache_background_update == -1L) {
#line 3201
    if (prev->upstream.cache_background_update == -1L) {
#line 3201
      conf->upstream.cache_background_update = (ngx_flag_t )0;
    } else {
#line 3201
      conf->upstream.cache_background_update = prev->upstream.cache_background_update;
    }
  }
#line 3206
  if ((unsigned long )conf->method == (unsigned long )((void *)0)) {
#line 3207
    conf->method = prev->method;
  }
#line 3210
  if (conf->upstream.pass_request_headers == -1L) {
#line 3210
    if (prev->upstream.pass_request_headers == -1L) {
#line 3210
      conf->upstream.pass_request_headers = (ngx_flag_t )1;
    } else {
#line 3210
      conf->upstream.pass_request_headers = prev->upstream.pass_request_headers;
    }
  }
#line 3212
  if (conf->upstream.pass_request_body == -1L) {
#line 3212
    if (prev->upstream.pass_request_body == -1L) {
#line 3212
      conf->upstream.pass_request_body = (ngx_flag_t )1;
    } else {
#line 3212
      conf->upstream.pass_request_body = prev->upstream.pass_request_body;
    }
  }
#line 3215
  if (conf->upstream.intercept_errors == -1L) {
#line 3215
    if (prev->upstream.intercept_errors == -1L) {
#line 3215
      conf->upstream.intercept_errors = (ngx_flag_t )0;
    } else {
#line 3215
      conf->upstream.intercept_errors = prev->upstream.intercept_errors;
    }
  }
#line 3256
  if (conf->redirect == -1L) {
#line 3256
    if (prev->redirect == -1L) {
#line 3256
      conf->redirect = (ngx_flag_t )1;
    } else {
#line 3256
      conf->redirect = prev->redirect;
    }
  }
#line 3258
  if (conf->redirect) {
#line 3260
    if ((unsigned long )conf->redirects == (unsigned long )((void *)0)) {
#line 3261
      conf->redirects = prev->redirects;
    }
#line 3264
    if ((unsigned long )conf->redirects == (unsigned long )((void *)0)) {
#line 3264
      if (conf->url.data) {
        {
#line 3266
        conf->redirects = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_proxy_rewrite_t ));
        }
#line 3268
        if ((unsigned long )conf->redirects == (unsigned long )((void *)0)) {
#line 3269
          return ((char *)((void *)-1));
        }
        {
#line 3272
        tmp___0 = ngx_array_push(conf->redirects);
#line 3272
        pr = (ngx_http_proxy_rewrite_t *)tmp___0;
        }
#line 3273
        if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 3274
          return ((char *)((void *)-1));
        }
        {
#line 3277
        memset((void *)(& pr->pattern.complex), 0, sizeof(ngx_http_complex_value_t ));
#line 3280
        memset((void *)(& pr->replacement), 0, sizeof(ngx_http_complex_value_t ));
#line 3282
        pr->handler = & ngx_http_proxy_rewrite_complex_handler;
        }
#line 3284
        if (conf->vars.uri.len) {
#line 3285
          pr->pattern.complex.value = conf->url;
#line 3286
          pr->replacement.value = conf->location;
        } else {
          {
#line 3289
          pr->pattern.complex.value.len = (conf->url.len + sizeof("/")) - 1UL;
#line 3292
          tmp___1 = ngx_pnalloc(cf->pool, pr->pattern.complex.value.len);
#line 3292
          p = (u_char *)tmp___1;
          }
#line 3293
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3294
            return ((char *)((void *)-1));
          }
          {
#line 3297
          pr->pattern.complex.value.data = p;
#line 3299
          tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)conf->url.data,
                           conf->url.len);
#line 3299
          p = (u_char *)tmp___2 + conf->url.len;
#line 3300
          *p = (u_char )'/';
#line 3302
          pr->replacement.value.len = sizeof("/") - 1UL;
#line 3302
          pr->replacement.value.data = (u_char *)"/";
          }
        }
      }
    }
  }
#line 3307
  if ((unsigned long )conf->cookie_domains == (unsigned long )((void *)-1)) {
#line 3307
    if ((unsigned long )prev->cookie_domains == (unsigned long )((void *)-1)) {
#line 3307
      conf->cookie_domains = (ngx_array_t *)((void *)0);
    } else {
#line 3307
      conf->cookie_domains = prev->cookie_domains;
    }
  }
#line 3309
  if ((unsigned long )conf->cookie_paths == (unsigned long )((void *)-1)) {
#line 3309
    if ((unsigned long )prev->cookie_paths == (unsigned long )((void *)-1)) {
#line 3309
      conf->cookie_paths = (ngx_array_t *)((void *)0);
    } else {
#line 3309
      conf->cookie_paths = prev->cookie_paths;
    }
  }
#line 3311
  if (conf->http_version == 0xffffffffffffffffUL) {
#line 3311
    if (prev->http_version == 0xffffffffffffffffUL) {
#line 3311
      conf->http_version = (ngx_uint_t )1000;
    } else {
#line 3311
      conf->http_version = prev->http_version;
    }
  }
#line 3314
  if (conf->headers_hash_max_size == 0xffffffffffffffffUL) {
#line 3314
    if (prev->headers_hash_max_size == 0xffffffffffffffffUL) {
#line 3314
      conf->headers_hash_max_size = (ngx_uint_t )512;
    } else {
#line 3314
      conf->headers_hash_max_size = prev->headers_hash_max_size;
    }
  }
#line 3317
  if (conf->headers_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3317
    if (prev->headers_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3317
      conf->headers_hash_bucket_size = (ngx_uint_t )64;
    } else {
#line 3317
      conf->headers_hash_bucket_size = prev->headers_hash_bucket_size;
    }
  }
  {
#line 3320
  conf->headers_hash_bucket_size = (conf->headers_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3323
  hash.max_size = conf->headers_hash_max_size;
#line 3324
  hash.bucket_size = conf->headers_hash_bucket_size;
#line 3325
  hash.name = (char *)"proxy_headers_hash";
#line 3327
  tmp___3 = ngx_http_upstream_hide_headers_hash(cf, & conf->upstream, & prev->upstream,
                                                ngx_http_proxy_hide_headers, & hash);
  }
#line 3327
  if (tmp___3 != 0L) {
#line 3331
    return ((char *)((void *)-1));
  }
#line 3334
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 3336
  if (clcf->noname) {
#line 3336
    if ((unsigned long )conf->upstream.upstream == (unsigned long )((void *)0)) {
#line 3336
      if ((unsigned long )conf->proxy_lengths == (unsigned long )((void *)0)) {
#line 3339
        conf->upstream.upstream = prev->upstream.upstream;
#line 3340
        conf->location = prev->location;
#line 3341
        conf->vars = prev->vars;
#line 3343
        conf->proxy_lengths = prev->proxy_lengths;
#line 3344
        conf->proxy_values = prev->proxy_values;
      }
    }
  }
#line 3351
  if (clcf->lmt_excpt) {
#line 3351
    if ((unsigned long )clcf->handler == (unsigned long )((void *)0)) {
#line 3351
      if (conf->upstream.upstream) {
#line 3354
        clcf->handler = & ngx_http_proxy_handler;
      } else
#line 3351
      if (conf->proxy_lengths) {
#line 3354
        clcf->handler = & ngx_http_proxy_handler;
      }
    }
  }
#line 3357
  if ((unsigned long )conf->body_source.data == (unsigned long )((void *)0)) {
#line 3358
    conf->body_flushes = prev->body_flushes;
#line 3359
    conf->body_source = prev->body_source;
#line 3360
    conf->body_lengths = prev->body_lengths;
#line 3361
    conf->body_values = prev->body_values;
  }
#line 3364
  if (conf->body_source.data) {
#line 3364
    if ((unsigned long )conf->body_lengths == (unsigned long )((void *)0)) {
      {
#line 3366
      memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3368
      sc.cf = cf;
#line 3369
      sc.source = & conf->body_source;
#line 3370
      sc.flushes = & conf->body_flushes;
#line 3371
      sc.lengths = & conf->body_lengths;
#line 3372
      sc.values = & conf->body_values;
#line 3373
      sc.complete_lengths = 1U;
#line 3374
      sc.complete_values = 1U;
#line 3376
      tmp___4 = ngx_http_script_compile(& sc);
      }
#line 3376
      if (tmp___4 != 0L) {
#line 3377
        return ((char *)((void *)-1));
      }
    }
  }
#line 3381
  if ((unsigned long )conf->headers_source == (unsigned long )((void *)0)) {
#line 3382
    conf->headers = prev->headers;
#line 3384
    conf->headers_cache = prev->headers_cache;
#line 3386
    conf->headers_source = prev->headers_source;
  }
  {
#line 3389
  rc = ngx_http_proxy_init_headers(cf, conf, & conf->headers, ngx_http_proxy_headers);
  }
#line 3391
  if (rc != 0L) {
#line 3392
    return ((char *)((void *)-1));
  }
#line 3397
  if (conf->upstream.cache) {
    {
#line 3398
    rc = ngx_http_proxy_init_headers(cf, conf, & conf->headers_cache, ngx_http_proxy_cache_headers);
    }
#line 3400
    if (rc != 0L) {
#line 3401
      return ((char *)((void *)-1));
    }
  }
#line 3412
  if ((unsigned long )prev->headers.hash.buckets == (unsigned long )((void *)0)) {
#line 3412
    if ((unsigned long )conf->headers_source == (unsigned long )prev->headers_source) {
#line 3415
      prev->headers = conf->headers;
#line 3417
      prev->headers_cache = conf->headers_cache;
    }
  }
#line 3421
  return ((char *)((void *)0));
}
}
#line 3425 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_init_headers(ngx_conf_t *cf , ngx_http_proxy_loc_conf_t *conf ,
                                             ngx_http_proxy_headers_t *headers , ngx_keyval_t *default_headers ) 
{ 
  u_char *p ;
  size_t size ;
  uintptr_t *code ;
  ngx_uint_t i ;
  ngx_array_t headers_names ;
  ngx_array_t headers_merged ;
  ngx_keyval_t *src ;
  ngx_keyval_t *s ;
  ngx_keyval_t *h ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_copy_code_t *copy ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  ngx_int_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  ngx_int_t tmp___11 ;
  char *__cil_tmp31 ;

  {
#line 3440
  if (headers->hash.buckets) {
#line 3441
    return ((ngx_int_t )0);
  }
  {
#line 3444
  tmp = ngx_array_init(& headers_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 3444
  if (tmp != 0L) {
#line 3447
    return ((ngx_int_t )-1);
  }
  {
#line 3450
  tmp___0 = ngx_array_init(& headers_merged, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_keyval_t ));
  }
#line 3450
  if (tmp___0 != 0L) {
#line 3453
    return ((ngx_int_t )-1);
  }
  {
#line 3456
  headers->lengths = ngx_array_create(cf->pool, (ngx_uint_t )64, (size_t )1);
  }
#line 3457
  if ((unsigned long )headers->lengths == (unsigned long )((void *)0)) {
#line 3458
    return ((ngx_int_t )-1);
  }
  {
#line 3461
  headers->values = ngx_array_create(cf->pool, (ngx_uint_t )512, (size_t )1);
  }
#line 3462
  if ((unsigned long )headers->values == (unsigned long )((void *)0)) {
#line 3463
    return ((ngx_int_t )-1);
  }
#line 3466
  if (conf->headers_source) {
#line 3468
    src = (ngx_keyval_t *)(conf->headers_source)->elts;
#line 3469
    i = (ngx_uint_t )0;
    {
#line 3469
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3469
      if (! (i < (conf->headers_source)->nelts)) {
#line 3469
        goto while_break;
      }
      {
#line 3471
      tmp___1 = ngx_array_push(& headers_merged);
#line 3471
      s = (ngx_keyval_t *)tmp___1;
      }
#line 3472
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3473
        return ((ngx_int_t )-1);
      }
#line 3476
      *s = *(src + i);
#line 3469
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3480
  h = default_headers;
  {
#line 3482
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3482
    if (! h->key.len) {
#line 3482
      goto while_break___0;
    }
#line 3484
    src = (ngx_keyval_t *)headers_merged.elts;
#line 3485
    i = (ngx_uint_t )0;
    {
#line 3485
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3485
      if (! (i < headers_merged.nelts)) {
#line 3485
        goto while_break___1;
      }
      {
#line 3486
      tmp___2 = ngx_strcasecmp(h->key.data, (src + i)->key.data);
      }
#line 3486
      if (tmp___2 == 0L) {
#line 3487
        goto next;
      }
#line 3485
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3491
    tmp___3 = ngx_array_push(& headers_merged);
#line 3491
    s = (ngx_keyval_t *)tmp___3;
    }
#line 3492
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 3493
      return ((ngx_int_t )-1);
    }
#line 3496
    *s = *h;
    next: 
#line 3500
    h ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3504
  src = (ngx_keyval_t *)headers_merged.elts;
#line 3505
  i = (ngx_uint_t )0;
  {
#line 3505
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3505
    if (! (i < headers_merged.nelts)) {
#line 3505
      goto while_break___2;
    }
    {
#line 3507
    tmp___4 = ngx_array_push(& headers_names);
#line 3507
    hk = (ngx_hash_key_t *)tmp___4;
    }
#line 3508
    if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 3509
      return ((ngx_int_t )-1);
    }
    {
#line 3512
    hk->key = (src + i)->key;
#line 3513
    hk->key_hash = ngx_hash_key_lc((src + i)->key.data, (src + i)->key.len);
#line 3514
    hk->value = (void *)1;
    }
#line 3516
    if ((src + i)->value.len == 0UL) {
#line 3517
      goto __Cont;
    }
    {
#line 3520
    tmp___5 = ngx_array_push_n(headers->lengths, sizeof(ngx_http_script_copy_code_t ));
#line 3520
    copy = (ngx_http_script_copy_code_t *)tmp___5;
    }
#line 3522
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3523
      return ((ngx_int_t )-1);
    }
    {
#line 3526
    copy->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 3527
    copy->len = (src + i)->key.len;
#line 3529
    size = (((sizeof(ngx_http_script_copy_code_t ) + (src + i)->key.len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 3533
    tmp___6 = ngx_array_push_n(headers->values, size);
#line 3533
    copy = (ngx_http_script_copy_code_t *)tmp___6;
    }
#line 3534
    if ((unsigned long )copy == (unsigned long )((void *)0)) {
#line 3535
      return ((ngx_int_t )-1);
    }
    {
#line 3538
    copy->code = & ngx_http_script_copy_code;
#line 3539
    copy->len = (src + i)->key.len;
#line 3541
    p = (u_char *)copy + sizeof(ngx_http_script_copy_code_t );
#line 3542
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(src + i)->key.data,
           (src + i)->key.len);
#line 3544
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3546
    sc.cf = cf;
#line 3547
    sc.source = & (src + i)->value;
#line 3548
    sc.flushes = & headers->flushes;
#line 3549
    sc.lengths = & headers->lengths;
#line 3550
    sc.values = & headers->values;
#line 3552
    tmp___7 = ngx_http_script_compile(& sc);
    }
#line 3552
    if (tmp___7 != 0L) {
#line 3553
      return ((ngx_int_t )-1);
    }
    {
#line 3556
    tmp___8 = ngx_array_push_n(headers->lengths, sizeof(uintptr_t ));
#line 3556
    code = (uintptr_t *)tmp___8;
    }
#line 3557
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3558
      return ((ngx_int_t )-1);
    }
    {
#line 3561
    *code = (uintptr_t )((void *)0);
#line 3563
    tmp___9 = ngx_array_push_n(headers->values, sizeof(uintptr_t ));
#line 3563
    code = (uintptr_t *)tmp___9;
    }
#line 3564
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3565
      return ((ngx_int_t )-1);
    }
#line 3568
    *code = (uintptr_t )((void *)0);
    __Cont: /* CIL Label */ 
#line 3505
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 3571
  tmp___10 = ngx_array_push_n(headers->lengths, sizeof(uintptr_t ));
#line 3571
  code = (uintptr_t *)tmp___10;
  }
#line 3572
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 3573
    return ((ngx_int_t )-1);
  }
  {
#line 3576
  *code = (uintptr_t )((void *)0);
#line 3579
  hash.hash = & headers->hash;
#line 3580
  hash.key = & ngx_hash_key_lc;
#line 3581
  hash.max_size = conf->headers_hash_max_size;
#line 3582
  hash.bucket_size = conf->headers_hash_bucket_size;
#line 3583
  hash.name = (char *)"proxy_headers_hash";
#line 3584
  hash.pool = cf->pool;
#line 3585
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 3587
  tmp___11 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_names.elts, headers_names.nelts);
  }
#line 3587
  return (tmp___11);
}
}
#line 3591 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_pass(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  size_t add ;
  u_short port ;
  ngx_str_t *value ;
  ngx_str_t *url ;
  ngx_url_t u ;
  ngx_uint_t n ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 3594
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 3604
  if (plcf->upstream.upstream) {
#line 3605
    return ((char *)"is duplicate");
  } else
#line 3604
  if (plcf->proxy_lengths) {
#line 3605
    return ((char *)"is duplicate");
  }
#line 3608
  clcf = (ngx_http_core_loc_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 3610
  clcf->handler = & ngx_http_proxy_handler;
#line 3612
  if ((int )*(clcf->name.data + (clcf->name.len - 1UL)) == 47) {
#line 3613
    clcf->auto_redirect = 1U;
  }
  {
#line 3616
  value = (ngx_str_t *)(cf->args)->elts;
#line 3618
  url = value + 1;
#line 3620
  n = ngx_http_script_variables_count(url);
  }
#line 3622
  if (n) {
    {
#line 3624
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 3626
    sc.cf = cf;
#line 3627
    sc.source = url;
#line 3628
    sc.lengths = & plcf->proxy_lengths;
#line 3629
    sc.values = & plcf->proxy_values;
#line 3630
    sc.variables = n;
#line 3631
    sc.complete_lengths = 1U;
#line 3632
    sc.complete_values = 1U;
#line 3634
    tmp = ngx_http_script_compile(& sc);
    }
#line 3634
    if (tmp != 0L) {
#line 3635
      return ((char *)((void *)-1));
    }
#line 3642
    return ((char *)((void *)0));
  }
  {
#line 3645
  tmp___1 = ngx_strncasecmp(url->data, (u_char *)"http://", (size_t )7);
  }
#line 3645
  if (tmp___1 == 0L) {
#line 3646
    add = (size_t )7;
#line 3647
    port = (u_short )80;
  } else {
    {
#line 3649
    tmp___0 = ngx_strncasecmp(url->data, (u_char *)"https://", (size_t )8);
    }
#line 3649
    if (tmp___0 == 0L) {
      {
#line 3657
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "https protocol requires SSL support");
      }
#line 3659
      return ((char *)((void *)-1));
    } else {
      {
#line 3663
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid URL prefix");
      }
#line 3664
      return ((char *)((void *)-1));
    }
  }
  {
#line 3667
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 3669
  u.url.len = url->len - add;
#line 3670
  u.url.data = url->data + add;
#line 3671
  u.default_port = port;
#line 3672
  u.uri_part = 1U;
#line 3673
  u.no_resolve = 1U;
#line 3675
  plcf->upstream.upstream = ngx_http_upstream_add(cf, & u, (ngx_uint_t )0);
  }
#line 3676
  if ((unsigned long )plcf->upstream.upstream == (unsigned long )((void *)0)) {
#line 3677
    return ((char *)((void *)-1));
  }
  {
#line 3680
  plcf->vars.schema.len = add;
#line 3681
  plcf->vars.schema.data = url->data;
#line 3682
  plcf->vars.key_start = plcf->vars.schema;
#line 3684
  ngx_http_proxy_set_vars(& u, & plcf->vars);
#line 3686
  plcf->location = clcf->name;
  }
#line 3688
  if (clcf->named) {
#line 3688
    goto _L;
  } else
#line 3688
  if (clcf->regex) {
#line 3688
    goto _L;
  } else
#line 3688
  if (clcf->noname) {
    _L: /* CIL Label */ 
#line 3694
    if (plcf->vars.uri.len) {
      {
#line 3695
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_pass\" cannot have URI part in location given by regular expression, or inside named location, or inside \"if\" statement, or inside \"limit_except\" block");
      }
#line 3701
      return ((char *)((void *)-1));
    }
#line 3704
    plcf->location.len = (size_t )0;
  }
#line 3707
  plcf->url = *url;
#line 3709
  return ((char *)((void *)0));
}
}
#line 3713 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_redirect(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 3716
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 3723
  if (plcf->redirect == 0L) {
#line 3724
    return ((char *)((void *)0));
  }
#line 3727
  plcf->redirect = (ngx_flag_t )1;
#line 3729
  value = (ngx_str_t *)(cf->args)->elts;
#line 3731
  if ((cf->args)->nelts == 2UL) {
    {
#line 3732
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 3732
    if (tmp == 0) {
#line 3733
      plcf->redirect = (ngx_flag_t )0;
#line 3734
      plcf->redirects = (ngx_array_t *)((void *)0);
#line 3735
      return ((char *)((void *)0));
    }
    {
#line 3738
    tmp___0 = strcmp((char const   *)(value + 1)->data, "false");
    }
#line 3738
    if (tmp___0 == 0) {
      {
#line 3739
      ngx_conf_log_error((ngx_uint_t )4, cf, 0, "invalid parameter \"false\", use \"off\" instead");
#line 3741
      plcf->redirect = (ngx_flag_t )0;
#line 3742
      plcf->redirects = (ngx_array_t *)((void *)0);
      }
#line 3743
      return ((char *)((void *)0));
    }
    {
#line 3746
    tmp___1 = strcmp((char const   *)(value + 1)->data, "default");
    }
#line 3746
    if (tmp___1 != 0) {
      {
#line 3747
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 1);
      }
#line 3749
      return ((char *)((void *)-1));
    }
  }
#line 3753
  if ((unsigned long )plcf->redirects == (unsigned long )((void *)0)) {
    {
#line 3754
    plcf->redirects = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_proxy_rewrite_t ));
    }
#line 3756
    if ((unsigned long )plcf->redirects == (unsigned long )((void *)0)) {
#line 3757
      return ((char *)((void *)-1));
    }
  }
  {
#line 3761
  tmp___2 = ngx_array_push(plcf->redirects);
#line 3761
  pr = (ngx_http_proxy_rewrite_t *)tmp___2;
  }
#line 3762
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 3763
    return ((char *)((void *)-1));
  }
  {
#line 3766
  tmp___5 = strcmp((char const   *)(value + 1)->data, "default");
  }
#line 3766
  if (tmp___5 == 0) {
#line 3767
    if (plcf->proxy_lengths) {
      {
#line 3768
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_redirect default\" cannot be used with \"proxy_pass\" directive with variables");
      }
#line 3771
      return ((char *)((void *)-1));
    }
#line 3774
    if ((unsigned long )plcf->url.data == (unsigned long )((void *)0)) {
      {
#line 3775
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"proxy_redirect default\" should be placed after the \"proxy_pass\" directive");
      }
#line 3778
      return ((char *)((void *)-1));
    }
    {
#line 3781
    pr->handler = & ngx_http_proxy_rewrite_complex_handler;
#line 3783
    memset((void *)(& pr->pattern.complex), 0, sizeof(ngx_http_complex_value_t ));
#line 3785
    memset((void *)(& pr->replacement), 0, sizeof(ngx_http_complex_value_t ));
    }
#line 3787
    if (plcf->vars.uri.len) {
#line 3788
      pr->pattern.complex.value = plcf->url;
#line 3789
      pr->replacement.value = plcf->location;
    } else {
      {
#line 3792
      pr->pattern.complex.value.len = (plcf->url.len + sizeof("/")) - 1UL;
#line 3794
      tmp___3 = ngx_pnalloc(cf->pool, pr->pattern.complex.value.len);
#line 3794
      p = (u_char *)tmp___3;
      }
#line 3795
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3796
        return ((char *)((void *)-1));
      }
      {
#line 3799
      pr->pattern.complex.value.data = p;
#line 3801
      tmp___4 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)plcf->url.data,
                       plcf->url.len);
#line 3801
      p = (u_char *)tmp___4 + plcf->url.len;
#line 3802
      *p = (u_char )'/';
#line 3804
      pr->replacement.value.len = sizeof("/") - 1UL;
#line 3804
      pr->replacement.value.data = (u_char *)"/";
      }
    }
#line 3807
    return ((char *)((void *)0));
  }
#line 3811
  if ((int )*((value + 1)->data + 0) == 126) {
#line 3812
    ((value + 1)->len) --;
#line 3813
    ((value + 1)->data) ++;
#line 3815
    if ((int )*((value + 1)->data + 0) == 42) {
      {
#line 3816
      ((value + 1)->len) --;
#line 3817
      ((value + 1)->data) ++;
#line 3819
      tmp___6 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )1);
      }
#line 3819
      if (tmp___6 != 0L) {
#line 3820
        return ((char *)((void *)-1));
      }
    } else {
      {
#line 3824
      tmp___7 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )0);
      }
#line 3824
      if (tmp___7 != 0L) {
#line 3825
        return ((char *)((void *)-1));
      }
    }
  } else {
    {
#line 3831
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3833
    ccv.cf = cf;
#line 3834
    ccv.value = value + 1;
#line 3835
    ccv.complex_value = & pr->pattern.complex;
#line 3837
    tmp___8 = ngx_http_compile_complex_value(& ccv);
    }
#line 3837
    if (tmp___8 != 0L) {
#line 3838
      return ((char *)((void *)-1));
    }
#line 3841
    pr->handler = & ngx_http_proxy_rewrite_complex_handler;
  }
  {
#line 3845
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3847
  ccv.cf = cf;
#line 3848
  ccv.value = value + 2;
#line 3849
  ccv.complex_value = & pr->replacement;
#line 3851
  tmp___9 = ngx_http_compile_complex_value(& ccv);
  }
#line 3851
  if (tmp___9 != 0L) {
#line 3852
    return ((char *)((void *)-1));
  }
#line 3855
  return ((char *)((void *)0));
}
}
#line 3859 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_cookie_domain(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp13 ;

  {
#line 3862
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 3868
  if ((unsigned long )plcf->cookie_domains == (unsigned long )((void *)0)) {
#line 3869
    return ((char *)((void *)0));
  }
#line 3872
  value = (ngx_str_t *)(cf->args)->elts;
#line 3874
  if ((cf->args)->nelts == 2UL) {
    {
#line 3876
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 3876
    if (tmp == 0) {
#line 3877
      plcf->cookie_domains = (ngx_array_t *)((void *)0);
#line 3878
      return ((char *)((void *)0));
    }
    {
#line 3881
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 1);
    }
#line 3883
    return ((char *)((void *)-1));
  }
#line 3886
  if ((unsigned long )plcf->cookie_domains == (unsigned long )((void *)-1)) {
    {
#line 3887
    plcf->cookie_domains = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_proxy_rewrite_t ));
    }
#line 3889
    if ((unsigned long )plcf->cookie_domains == (unsigned long )((void *)0)) {
#line 3890
      return ((char *)((void *)-1));
    }
  }
  {
#line 3894
  tmp___0 = ngx_array_push(plcf->cookie_domains);
#line 3894
  pr = (ngx_http_proxy_rewrite_t *)tmp___0;
  }
#line 3895
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 3896
    return ((char *)((void *)-1));
  }
#line 3899
  if ((int )*((value + 1)->data + 0) == 126) {
    {
#line 3900
    ((value + 1)->len) --;
#line 3901
    ((value + 1)->data) ++;
#line 3903
    tmp___1 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )1);
    }
#line 3903
    if (tmp___1 != 0L) {
#line 3904
      return ((char *)((void *)-1));
    }
  } else {
#line 3909
    if ((int )*((value + 1)->data + 0) == 46) {
#line 3910
      ((value + 1)->len) --;
#line 3911
      ((value + 1)->data) ++;
    }
    {
#line 3914
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3916
    ccv.cf = cf;
#line 3917
    ccv.value = value + 1;
#line 3918
    ccv.complex_value = & pr->pattern.complex;
#line 3920
    tmp___2 = ngx_http_compile_complex_value(& ccv);
    }
#line 3920
    if (tmp___2 != 0L) {
#line 3921
      return ((char *)((void *)-1));
    }
#line 3924
    pr->handler = & ngx_http_proxy_rewrite_domain_handler;
#line 3926
    if ((int )*((value + 2)->data + 0) == 46) {
#line 3927
      ((value + 2)->len) --;
#line 3928
      ((value + 2)->data) ++;
    }
  }
  {
#line 3932
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 3934
  ccv.cf = cf;
#line 3935
  ccv.value = value + 2;
#line 3936
  ccv.complex_value = & pr->replacement;
#line 3938
  tmp___3 = ngx_http_compile_complex_value(& ccv);
  }
#line 3938
  if (tmp___3 != 0L) {
#line 3939
    return ((char *)((void *)-1));
  }
#line 3942
  return ((char *)((void *)0));
}
}
#line 3946 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_cookie_path(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_proxy_rewrite_t *pr ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp14 ;

  {
#line 3949
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 3955
  if ((unsigned long )plcf->cookie_paths == (unsigned long )((void *)0)) {
#line 3956
    return ((char *)((void *)0));
  }
#line 3959
  value = (ngx_str_t *)(cf->args)->elts;
#line 3961
  if ((cf->args)->nelts == 2UL) {
    {
#line 3963
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 3963
    if (tmp == 0) {
#line 3964
      plcf->cookie_paths = (ngx_array_t *)((void *)0);
#line 3965
      return ((char *)((void *)0));
    }
    {
#line 3968
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 1);
    }
#line 3970
    return ((char *)((void *)-1));
  }
#line 3973
  if ((unsigned long )plcf->cookie_paths == (unsigned long )((void *)-1)) {
    {
#line 3974
    plcf->cookie_paths = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_proxy_rewrite_t ));
    }
#line 3976
    if ((unsigned long )plcf->cookie_paths == (unsigned long )((void *)0)) {
#line 3977
      return ((char *)((void *)-1));
    }
  }
  {
#line 3981
  tmp___0 = ngx_array_push(plcf->cookie_paths);
#line 3981
  pr = (ngx_http_proxy_rewrite_t *)tmp___0;
  }
#line 3982
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 3983
    return ((char *)((void *)-1));
  }
#line 3986
  if ((int )*((value + 1)->data + 0) == 126) {
#line 3987
    ((value + 1)->len) --;
#line 3988
    ((value + 1)->data) ++;
#line 3990
    if ((int )*((value + 1)->data + 0) == 42) {
      {
#line 3991
      ((value + 1)->len) --;
#line 3992
      ((value + 1)->data) ++;
#line 3994
      tmp___1 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )1);
      }
#line 3994
      if (tmp___1 != 0L) {
#line 3995
        return ((char *)((void *)-1));
      }
    } else {
      {
#line 3999
      tmp___2 = ngx_http_proxy_rewrite_regex(cf, pr, value + 1, (ngx_uint_t )0);
      }
#line 3999
      if (tmp___2 != 0L) {
#line 4000
        return ((char *)((void *)-1));
      }
    }
  } else {
    {
#line 4006
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4008
    ccv.cf = cf;
#line 4009
    ccv.value = value + 1;
#line 4010
    ccv.complex_value = & pr->pattern.complex;
#line 4012
    tmp___3 = ngx_http_compile_complex_value(& ccv);
    }
#line 4012
    if (tmp___3 != 0L) {
#line 4013
      return ((char *)((void *)-1));
    }
#line 4016
    pr->handler = & ngx_http_proxy_rewrite_complex_handler;
  }
  {
#line 4019
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4021
  ccv.cf = cf;
#line 4022
  ccv.value = value + 2;
#line 4023
  ccv.complex_value = & pr->replacement;
#line 4025
  tmp___4 = ngx_http_compile_complex_value(& ccv);
  }
#line 4025
  if (tmp___4 != 0L) {
#line 4026
    return ((char *)((void *)-1));
  }
#line 4029
  return ((char *)((void *)0));
}
}
#line 4033 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static ngx_int_t ngx_http_proxy_rewrite_regex(ngx_conf_t *cf , ngx_http_proxy_rewrite_t *pr ,
                                              ngx_str_t *regex , ngx_uint_t caseless ) 
{ 
  u_char errstr[1024] ;
  ngx_regex_compile_t rc ;
  void *__cil_tmp7 ;

  {
  {
#line 4041
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 4043
  rc.pattern = *regex;
#line 4044
  rc.err.len = (size_t )1024;
#line 4045
  rc.err.data = errstr;
  }
#line 4047
  if (caseless) {
#line 4048
    rc.options = (ngx_int_t )1;
  }
  {
#line 4051
  pr->pattern.regex = ngx_http_regex_compile(cf, & rc);
  }
#line 4052
  if ((unsigned long )pr->pattern.regex == (unsigned long )((void *)0)) {
#line 4053
    return ((ngx_int_t )-1);
  }
#line 4056
  pr->handler = & ngx_http_proxy_rewrite_regex_handler;
#line 4058
  return ((ngx_int_t )0);
}
}
#line 4070 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_store(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_script_compile_t sc ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 4073
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 4078
  if (plcf->upstream.store != -1) {
#line 4079
    return ((char *)"is duplicate");
  }
  {
#line 4082
  value = (ngx_str_t *)(cf->args)->elts;
#line 4084
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 4084
  if (tmp == 0) {
#line 4085
    plcf->upstream.store = 0;
#line 4086
    return ((char *)((void *)0));
  }
#line 4090
  if (plcf->upstream.cache > 0) {
#line 4091
    return ((char *)"is incompatible with \"proxy_cache\"");
  }
  {
#line 4095
  plcf->upstream.store = 1;
#line 4097
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 4097
  if (tmp___0 == 0) {
#line 4098
    return ((char *)((void *)0));
  }
  {
#line 4102
  ((value + 1)->len) ++;
#line 4104
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 4106
  sc.cf = cf;
#line 4107
  sc.source = value + 1;
#line 4108
  sc.lengths = & plcf->upstream.store_lengths;
#line 4109
  sc.values = & plcf->upstream.store_values;
#line 4110
  sc.variables = ngx_http_script_variables_count(value + 1);
#line 4111
  sc.complete_lengths = 1U;
#line 4112
  sc.complete_values = 1U;
#line 4114
  tmp___1 = ngx_http_script_compile(& sc);
  }
#line 4114
  if (tmp___1 != 0L) {
#line 4115
    return ((char *)((void *)-1));
  }
#line 4118
  return ((char *)((void *)0));
}
}
#line 4124 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 4127
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 4133
  value = (ngx_str_t *)(cf->args)->elts;
#line 4135
  if (plcf->upstream.cache != -1) {
#line 4136
    return ((char *)"is duplicate");
  }
  {
#line 4139
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 4139
  if (tmp == 0) {
#line 4140
    plcf->upstream.cache = 0;
#line 4141
    return ((char *)((void *)0));
  }
#line 4144
  if (plcf->upstream.store > 0) {
#line 4145
    return ((char *)"is incompatible with \"proxy_store\"");
  }
  {
#line 4148
  plcf->upstream.cache = 1;
#line 4150
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4152
  ccv.cf = cf;
#line 4153
  ccv.value = value + 1;
#line 4154
  ccv.complex_value = & cv;
#line 4156
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 4156
  if (tmp___0 != 0L) {
#line 4157
    return ((char *)((void *)-1));
  }
#line 4160
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 4162
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 4162
    plcf->upstream.cache_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 4164
    if ((unsigned long )plcf->upstream.cache_value == (unsigned long )((void *)0)) {
#line 4165
      return ((char *)((void *)-1));
    }
#line 4168
    *(plcf->upstream.cache_value) = cv;
#line 4170
    return ((char *)((void *)0));
  }
  {
#line 4173
  plcf->upstream.cache_zone = ngx_shared_memory_add(cf, value + 1, (size_t )0, (void *)(& ngx_http_proxy_module));
  }
#line 4175
  if ((unsigned long )plcf->upstream.cache_zone == (unsigned long )((void *)0)) {
#line 4176
    return ((char *)((void *)-1));
  }
#line 4179
  return ((char *)((void *)0));
}
}
#line 4183 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_cache_key(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_proxy_loc_conf_t *plcf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;

  {
#line 4186
  plcf = (ngx_http_proxy_loc_conf_t *)conf;
#line 4191
  value = (ngx_str_t *)(cf->args)->elts;
#line 4193
  if (plcf->cache_key.value.data) {
#line 4194
    return ((char *)"is duplicate");
  }
  {
#line 4197
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4199
  ccv.cf = cf;
#line 4200
  ccv.value = value + 1;
#line 4201
  ccv.complex_value = & plcf->cache_key;
#line 4203
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 4203
  if (tmp != 0L) {
#line 4204
    return ((char *)((void *)-1));
  }
#line 4207
  return ((char *)((void *)0));
}
}
#line 4240 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static char *ngx_http_proxy_lowat_check(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ssize_t *np ;
  char *__cil_tmp5 ;

  {
  {
#line 4256
  np = (ssize_t *)data;
#line 4258
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "\"proxy_send_lowat\" is not supported, ignored");
#line 4261
  *np = (ssize_t )0;
  }
#line 4265
  return ((char *)((void *)0));
}
}
#line 4346 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_proxy_module.c"
static void ngx_http_proxy_set_vars(ngx_url_t *u , ngx_http_proxy_vars_t *v ) 
{ 
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4349
  if (u->family != 1) {
#line 4351
    if (u->no_port) {
#line 4351
      goto _L;
    } else
#line 4351
    if ((int )u->port == (int )u->default_port) {
      _L: /* CIL Label */ 
#line 4353
      v->host_header = u->host;
#line 4355
      if ((int )u->default_port == 80) {
#line 4356
        v->port.len = sizeof("80") - 1UL;
#line 4356
        v->port.data = (u_char *)"80";
      } else {
#line 4359
        v->port.len = sizeof("443") - 1UL;
#line 4359
        v->port.data = (u_char *)"443";
      }
    } else {
#line 4363
      v->host_header.len = (u->host.len + 1UL) + u->port_text.len;
#line 4364
      v->host_header.data = u->host.data;
#line 4365
      v->port = u->port_text;
    }
#line 4368
    v->key_start.len += v->host_header.len;
  } else {
#line 4371
    v->host_header.len = sizeof("localhost") - 1UL;
#line 4371
    v->host_header.data = (u_char *)"localhost";
#line 4372
    v->port.len = (size_t )0;
#line 4372
    v->port.data = (u_char *)((void *)0);
#line 4373
    v->key_start.len += ((sizeof("unix:") - 1UL) + u->host.len) + 1UL;
  }
#line 4376
  v->uri = u->uri;
#line 4377
  return;
}
}
#line 269 "src/core/ngx_conf_file.h"
char *ngx_conf_parse(ngx_conf_t *cf , ngx_str_t *filename ) ;
#line 227 "src/http/ngx_http_script.h"
void *ngx_http_script_start_code(ngx_pool_t *pool , ngx_array_t **codes , size_t size ) ;
#line 229
void *ngx_http_script_add_code(ngx_array_t *codes , size_t size , void *code ) ;
#line 240
void ngx_http_script_regex_start_code(ngx_http_script_engine_t *e ) ;
#line 241
void ngx_http_script_regex_end_code(ngx_http_script_engine_t *e ) ;
#line 243
void ngx_http_script_return_code(ngx_http_script_engine_t *e ) ;
#line 244
void ngx_http_script_break_code(ngx_http_script_engine_t *e ) ;
#line 245
void ngx_http_script_if_code(ngx_http_script_engine_t *e ) ;
#line 246
void ngx_http_script_equal_code(ngx_http_script_engine_t *e ) ;
#line 247
void ngx_http_script_not_equal_code(ngx_http_script_engine_t *e ) ;
#line 248
void ngx_http_script_file_code(ngx_http_script_engine_t *e ) ;
#line 249
void ngx_http_script_complex_value_code(ngx_http_script_engine_t *e ) ;
#line 250
void ngx_http_script_value_code(ngx_http_script_engine_t *e ) ;
#line 251
void ngx_http_script_set_var_code(ngx_http_script_engine_t *e ) ;
#line 252
void ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e ) ;
#line 253
void ngx_http_script_var_code(ngx_http_script_engine_t *e ) ;
#line 530 "src/http/ngx_http_core_module.h"
ngx_uint_t ngx_http_max_module ;
#line 79 "src/http/ngx_http.h"
ngx_int_t ngx_http_add_location(ngx_conf_t *cf , ngx_queue_t **locations , ngx_http_core_loc_conf_t *clcf ) ;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf ) ;
#line 24
static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 26
static ngx_int_t ngx_http_rewrite_init(ngx_conf_t *cf ) ;
#line 27
static char *ngx_http_rewrite(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 28
static char *ngx_http_rewrite_return(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 30
static char *ngx_http_rewrite_break(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 32
static char *ngx_http_rewrite_if(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 34
static char *ngx_http_rewrite_if_condition(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ) ;
#line 36
static char *ngx_http_rewrite_variable(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ,
                                       ngx_str_t *value ) ;
#line 38
static char *ngx_http_rewrite_set(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 40
static char *ngx_http_rewrite_value(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ,
                                    ngx_str_t *value ) ;
#line 44 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static ngx_command_t ngx_http_rewrite_commands[8]  = 
#line 44
  {      {{sizeof("rewrite") - 1UL, (u_char *)"rewrite"}, (ngx_uint_t )1811939340, & ngx_http_rewrite,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("return") - 1UL,
       (u_char *)"return"}, (ngx_uint_t )1811939334, & ngx_http_rewrite_return, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("break") - 1UL, (u_char *)"break"}, (ngx_uint_t )1811939329, & ngx_http_rewrite_break,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("if") - 1UL,
       (u_char *)"if"}, (ngx_uint_t )201328896, & ngx_http_rewrite_if, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("set") - 1UL, (u_char *)"set"}, (ngx_uint_t )1811939332, & ngx_http_rewrite_set,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("rewrite_log") - 1UL,
       (u_char *)"rewrite_log"}, (ngx_uint_t )1845494272, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_rewrite_loc_conf_t *)0)->log),
      (void *)0}, 
        {{sizeof("uninitialized_variable_warn") - 1UL, (u_char *)"uninitialized_variable_warn"},
      (ngx_uint_t )1845494272, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_rewrite_loc_conf_t *)0)->uninitialized_variable_warn),
      (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 105 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static ngx_http_module_t ngx_http_rewrite_module_ctx  = 
#line 105
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_rewrite_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_rewrite_create_loc_conf,
    & ngx_http_rewrite_merge_loc_conf};
#line 120 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
ngx_module_t ngx_http_rewrite_module  = 
#line 120
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_rewrite_module_ctx),
    ngx_http_rewrite_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 136 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static ngx_int_t ngx_http_rewrite_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t index___0 ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t *e ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_http_rewrite_loc_conf_t *rlcf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 146
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 147
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 148
  index___0 = (ngx_int_t )cmcf->phase_engine.location_rewrite_index;
#line 150
  if (r->phase_handler == index___0) {
#line 150
    if ((unsigned long )r->loc_conf == (unsigned long )(cscf->ctx)->loc_conf) {
#line 152
      return ((ngx_int_t )-5);
    }
  }
#line 155
  rlcf = (ngx_http_rewrite_loc_conf_t *)*(r->loc_conf + ngx_http_rewrite_module.ctx_index);
#line 157
  if ((unsigned long )rlcf->codes == (unsigned long )((void *)0)) {
#line 158
    return ((ngx_int_t )-5);
  }
  {
#line 161
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_script_engine_t ));
#line 161
  e = (ngx_http_script_engine_t *)tmp;
  }
#line 162
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 163
    return ((ngx_int_t )500);
  }
  {
#line 166
  tmp___0 = ngx_pcalloc(r->pool, rlcf->stack_size * sizeof(ngx_http_variable_value_t ));
#line 166
  e->sp = (ngx_http_variable_value_t *)tmp___0;
  }
#line 168
  if ((unsigned long )e->sp == (unsigned long )((void *)0)) {
#line 169
    return ((ngx_int_t )500);
  }
#line 172
  e->ip = (u_char *)(rlcf->codes)->elts;
#line 173
  e->request = r;
#line 174
  e->quote = 1U;
#line 175
  e->log = (unsigned int )rlcf->log;
#line 176
  e->status = (ngx_int_t )-5;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! *((uintptr_t *)e->ip)) {
#line 178
      goto while_break;
    }
    {
#line 179
    code = *((ngx_http_script_code_pt *)e->ip);
#line 180
    (*code)(e);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  if (e->status < 400L) {
#line 184
    return (e->status);
  }
#line 187
  if (r->err_status == 0UL) {
#line 188
    return (e->status);
  }
#line 191
  return ((ngx_int_t )r->err_status);
}
}
#line 195 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static ngx_int_t ngx_http_rewrite_var(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                      uintptr_t data ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_http_rewrite_loc_conf_t *rlcf ;
  char *__cil_tmp7 ;

  {
#line 203
  rlcf = (ngx_http_rewrite_loc_conf_t *)*(r->loc_conf + ngx_http_rewrite_module.ctx_index);
#line 205
  if (rlcf->uninitialized_variable_warn == 0L) {
#line 206
    *v = ngx_http_variable_null_value;
#line 207
    return ((ngx_int_t )0);
  }
#line 210
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 212
  var = (ngx_http_variable_t *)cmcf->variables.elts;
#line 220
  if (((r->connection)->log)->log_level >= 5UL) {
    {
#line 220
    ngx_log_error_core((ngx_uint_t )5, (r->connection)->log, 0, "using uninitialized \"%V\" variable",
                       & (var + data)->name);
    }
  }
#line 223
  *v = ngx_http_variable_null_value;
#line 225
  return ((ngx_int_t )0);
}
}
#line 229 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static void *ngx_http_rewrite_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_rewrite_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 234
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_rewrite_loc_conf_t ));
#line 234
  conf = (ngx_http_rewrite_loc_conf_t *)tmp;
  }
#line 235
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 236
    return ((void *)0);
  }
#line 239
  conf->stack_size = (ngx_uint_t )-1;
#line 240
  conf->log = (ngx_flag_t )-1;
#line 241
  conf->uninitialized_variable_warn = (ngx_flag_t )-1;
#line 243
  return ((void *)conf);
}
}
#line 247 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_rewrite_loc_conf_t *prev ;
  ngx_http_rewrite_loc_conf_t *conf ;
  uintptr_t *code ;
  void *tmp ;

  {
#line 250
  prev = (ngx_http_rewrite_loc_conf_t *)parent;
#line 251
  conf = (ngx_http_rewrite_loc_conf_t *)child;
#line 255
  if (conf->log == -1L) {
#line 255
    if (prev->log == -1L) {
#line 255
      conf->log = (ngx_flag_t )0;
    } else {
#line 255
      conf->log = prev->log;
    }
  }
#line 256
  if (conf->uninitialized_variable_warn == -1L) {
#line 256
    if (prev->uninitialized_variable_warn == -1L) {
#line 256
      conf->uninitialized_variable_warn = (ngx_flag_t )1;
    } else {
#line 256
      conf->uninitialized_variable_warn = prev->uninitialized_variable_warn;
    }
  }
#line 258
  if (conf->stack_size == 0xffffffffffffffffUL) {
#line 258
    if (prev->stack_size == 0xffffffffffffffffUL) {
#line 258
      conf->stack_size = (ngx_uint_t )10;
    } else {
#line 258
      conf->stack_size = prev->stack_size;
    }
  }
#line 260
  if ((unsigned long )conf->codes == (unsigned long )((void *)0)) {
#line 261
    return ((char *)((void *)0));
  }
#line 264
  if ((unsigned long )conf->codes == (unsigned long )prev->codes) {
#line 265
    return ((char *)((void *)0));
  }
  {
#line 268
  tmp = ngx_array_push_n(conf->codes, sizeof(uintptr_t ));
#line 268
  code = (uintptr_t *)tmp;
  }
#line 269
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 270
    return ((char *)((void *)-1));
  }
#line 273
  *code = (uintptr_t )((void *)0);
#line 275
  return ((char *)((void *)0));
}
}
#line 279 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static ngx_int_t ngx_http_rewrite_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 285
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 287
  tmp = ngx_array_push(& cmcf->phases[1].handlers);
#line 287
  h = (ngx_http_handler_pt *)tmp;
  }
#line 288
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 289
    return ((ngx_int_t )-1);
  }
  {
#line 292
  *h = & ngx_http_rewrite_handler;
#line 294
  tmp___0 = ngx_array_push(& cmcf->phases[3].handlers);
#line 294
  h = (ngx_http_handler_pt *)tmp___0;
  }
#line 295
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 296
    return ((ngx_int_t )-1);
  }
#line 299
  *h = & ngx_http_rewrite_handler;
#line 301
  return ((ngx_int_t )0);
}
}
#line 305 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  ngx_str_t *value ;
  ngx_uint_t last ;
  ngx_regex_compile_t rc ;
  ngx_http_script_code_pt *code ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_regex_code_t *regex ;
  ngx_http_script_regex_end_code_t *regex_end ;
  u_char errstr[1024] ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ngx_int_t tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 308
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 319
  tmp = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_regex_code_t ));
#line 319
  regex = (ngx_http_script_regex_code_t *)tmp;
  }
#line 321
  if ((unsigned long )regex == (unsigned long )((void *)0)) {
#line 322
    return ((char *)((void *)-1));
  }
  {
#line 325
  memset((void *)regex, 0, sizeof(ngx_http_script_regex_code_t ));
#line 327
  value = (ngx_str_t *)(cf->args)->elts;
#line 329
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 331
  rc.pattern = *(value + 1);
#line 332
  rc.err.len = (size_t )1024;
#line 333
  rc.err.data = errstr;
#line 337
  regex->regex = ngx_http_regex_compile(cf, & rc);
  }
#line 338
  if ((unsigned long )regex->regex == (unsigned long )((void *)0)) {
#line 339
    return ((char *)((void *)-1));
  }
#line 342
  regex->code = & ngx_http_script_regex_start_code;
#line 343
  regex->uri = 1U;
#line 344
  regex->name = *(value + 1);
#line 346
  if ((int )*((value + 2)->data + ((value + 2)->len - 1UL)) == 63) {
#line 349
    ((value + 2)->len) --;
  } else {
#line 352
    regex->add_args = 1U;
  }
  {
#line 355
  last = (ngx_uint_t )0;
#line 357
  tmp___0 = strncmp((char const   *)(value + 2)->data, "http://", sizeof("http://") - 1UL);
  }
#line 357
  if (tmp___0 == 0) {
#line 361
    regex->status = (uintptr_t )302;
#line 362
    regex->redirect = 1U;
#line 363
    last = (ngx_uint_t )1;
  } else {
    {
#line 357
    tmp___1 = strncmp((char const   *)(value + 2)->data, "https://", sizeof("https://") - 1UL);
    }
#line 357
    if (tmp___1 == 0) {
#line 361
      regex->status = (uintptr_t )302;
#line 362
      regex->redirect = 1U;
#line 363
      last = (ngx_uint_t )1;
    } else {
      {
#line 357
      tmp___2 = strncmp((char const   *)(value + 2)->data, "$scheme", sizeof("$scheme") - 1UL);
      }
#line 357
      if (tmp___2 == 0) {
#line 361
        regex->status = (uintptr_t )302;
#line 362
        regex->redirect = 1U;
#line 363
        last = (ngx_uint_t )1;
      }
    }
  }
#line 366
  if ((cf->args)->nelts == 4UL) {
    {
#line 367
    tmp___6 = strcmp((char const   *)(value + 3)->data, "last");
    }
#line 367
    if (tmp___6 == 0) {
#line 368
      last = (ngx_uint_t )1;
    } else {
      {
#line 370
      tmp___5 = strcmp((char const   *)(value + 3)->data, "break");
      }
#line 370
      if (tmp___5 == 0) {
#line 371
        regex->break_cycle = 1U;
#line 372
        last = (ngx_uint_t )1;
      } else {
        {
#line 374
        tmp___4 = strcmp((char const   *)(value + 3)->data, "redirect");
        }
#line 374
        if (tmp___4 == 0) {
#line 375
          regex->status = (uintptr_t )302;
#line 376
          regex->redirect = 1U;
#line 377
          last = (ngx_uint_t )1;
        } else {
          {
#line 379
          tmp___3 = strcmp((char const   *)(value + 3)->data, "permanent");
          }
#line 379
          if (tmp___3 == 0) {
#line 380
            regex->status = (uintptr_t )301;
#line 381
            regex->redirect = 1U;
#line 382
            last = (ngx_uint_t )1;
          } else {
            {
#line 385
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"",
                               value + 3);
            }
#line 387
            return ((char *)((void *)-1));
          }
        }
      }
    }
  }
  {
#line 391
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 393
  sc.cf = cf;
#line 394
  sc.source = value + 2;
#line 395
  sc.lengths = & regex->lengths;
#line 396
  sc.values = & lcf->codes;
#line 397
  sc.variables = ngx_http_script_variables_count(value + 2);
#line 398
  sc.main = (void *)regex;
#line 399
  sc.complete_lengths = 1U;
#line 400
  sc.compile_args = (unsigned int )(! regex->redirect);
#line 402
  tmp___7 = ngx_http_script_compile(& sc);
  }
#line 402
  if (tmp___7 != 0L) {
#line 403
    return ((char *)((void *)-1));
  }
#line 406
  regex = (ngx_http_script_regex_code_t *)sc.main;
#line 408
  regex->size = sc.size;
#line 409
  regex->args = sc.args;
#line 411
  if (sc.variables == 0UL) {
#line 411
    if (! sc.dup_capture) {
#line 412
      regex->lengths = (ngx_array_t *)((void *)0);
    }
  }
  {
#line 415
  tmp___8 = ngx_http_script_add_code(lcf->codes, sizeof(ngx_http_script_regex_end_code_t ),
                                     (void *)(& regex));
#line 415
  regex_end = (ngx_http_script_regex_end_code_t *)tmp___8;
  }
#line 418
  if ((unsigned long )regex_end == (unsigned long )((void *)0)) {
#line 419
    return ((char *)((void *)-1));
  }
#line 422
  regex_end->code = & ngx_http_script_regex_end_code;
#line 423
  regex_end->uri = regex->uri;
#line 424
  regex_end->args = regex->args;
#line 425
  regex_end->add_args = regex->add_args;
#line 426
  regex_end->redirect = regex->redirect;
#line 428
  if (last) {
    {
#line 429
    tmp___9 = ngx_http_script_add_code(lcf->codes, sizeof(uintptr_t ), (void *)(& regex));
#line 429
    code = (ngx_http_script_code_pt *)tmp___9;
    }
#line 430
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 431
      return ((char *)((void *)-1));
    }
#line 434
    *code = (ngx_http_script_code_pt )((void *)0);
  }
#line 437
  regex->next = (uintptr_t )(((u_char *)(lcf->codes)->elts + (lcf->codes)->nelts) - (u_char *)regex);
#line 440
  return ((char *)((void *)0));
}
}
#line 444 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_return(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_str_t *v ;
  ngx_http_script_return_code_t *ret ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 447
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 454
  tmp = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_return_code_t ));
#line 454
  ret = (ngx_http_script_return_code_t *)tmp;
  }
#line 456
  if ((unsigned long )ret == (unsigned long )((void *)0)) {
#line 457
    return ((char *)((void *)-1));
  }
  {
#line 460
  value = (ngx_str_t *)(cf->args)->elts;
#line 462
  memset((void *)ret, 0, sizeof(ngx_http_script_return_code_t ));
#line 464
  ret->code = & ngx_http_script_return_code;
#line 466
  p = (value + 1)->data;
#line 468
  tmp___0 = ngx_atoi(p, (value + 1)->len);
#line 468
  ret->status = (uintptr_t )tmp___0;
  }
#line 470
  if (ret->status == 0xffffffffffffffffUL) {
#line 472
    if ((cf->args)->nelts == 2UL) {
      {
#line 472
      tmp___1 = strncmp((char const   *)p, "http://", sizeof("http://") - 1UL);
      }
#line 472
      if (tmp___1 == 0) {
#line 477
        ret->status = (uintptr_t )302;
#line 478
        v = value + 1;
      } else {
        {
#line 472
        tmp___2 = strncmp((char const   *)p, "https://", sizeof("https://") - 1UL);
        }
#line 472
        if (tmp___2 == 0) {
#line 477
          ret->status = (uintptr_t )302;
#line 478
          v = value + 1;
        } else {
          {
#line 472
          tmp___3 = strncmp((char const   *)p, "$scheme", sizeof("$scheme") - 1UL);
          }
#line 472
          if (tmp___3 == 0) {
#line 477
            ret->status = (uintptr_t )302;
#line 478
            v = value + 1;
          } else {
            {
#line 481
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid return code \"%V\"",
                               value + 1);
            }
#line 483
            return ((char *)((void *)-1));
          }
        }
      }
    } else {
      {
#line 481
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid return code \"%V\"", value + 1);
      }
#line 483
      return ((char *)((void *)-1));
    }
  } else {
#line 488
    if (ret->status > 999UL) {
      {
#line 489
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid return code \"%V\"", value + 1);
      }
#line 491
      return ((char *)((void *)-1));
    }
#line 494
    if ((cf->args)->nelts == 2UL) {
#line 495
      return ((char *)((void *)0));
    }
#line 498
    v = value + 2;
  }
  {
#line 501
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 503
  ccv.cf = cf;
#line 504
  ccv.value = v;
#line 505
  ccv.complex_value = & ret->text;
#line 507
  tmp___4 = ngx_http_compile_complex_value(& ccv);
  }
#line 507
  if (tmp___4 != 0L) {
#line 508
    return ((char *)((void *)-1));
  }
#line 511
  return ((char *)((void *)0));
}
}
#line 515 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_break(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  ngx_http_script_code_pt *code ;
  void *tmp ;

  {
  {
#line 518
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 522
  tmp = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(uintptr_t ));
#line 522
  code = (ngx_http_script_code_pt *)tmp;
  }
#line 523
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 524
    return ((char *)((void *)-1));
  }
#line 527
  *code = & ngx_http_script_break_code;
#line 529
  return ((char *)((void *)0));
}
}
#line 533 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_if(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  void *mconf ;
  char *rv ;
  u_char *elts ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *pctx ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_loc_conf_t *pclcf ;
  ngx_http_script_if_code_t *if_code ;
  ngx_http_rewrite_loc_conf_t *nlcf ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 536
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 549
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 549
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 550
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 551
    return ((char *)((void *)-1));
  }
  {
#line 554
  pctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 555
  ctx->main_conf = pctx->main_conf;
#line 556
  ctx->srv_conf = pctx->srv_conf;
#line 558
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 558
  ctx->loc_conf = (void **)tmp___0;
  }
#line 559
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 560
    return ((char *)((void *)-1));
  }
#line 563
  i = (ngx_uint_t )0;
  {
#line 563
  while (1) {
    while_continue: /* CIL Label */ ;
#line 563
    if (! *((cf->cycle)->modules + i)) {
#line 563
      goto while_break;
    }
#line 564
    if ((*((cf->cycle)->modules + i))->type != 1347703880UL) {
#line 565
      goto __Cont;
    }
#line 568
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 570
    if (module->create_loc_conf) {
      {
#line 572
      mconf = (*(module->create_loc_conf))(cf);
      }
#line 573
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 574
        return ((char *)((void *)-1));
      }
#line 577
      *(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) = mconf;
    }
    __Cont: /* CIL Label */ 
#line 563
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 581
  pclcf = (ngx_http_core_loc_conf_t *)*(pctx->loc_conf + ngx_http_core_module.ctx_index);
#line 583
  clcf = (ngx_http_core_loc_conf_t *)*(ctx->loc_conf + ngx_http_core_module.ctx_index);
#line 584
  clcf->loc_conf = ctx->loc_conf;
#line 585
  clcf->name = pclcf->name;
#line 586
  clcf->noname = 1U;
#line 588
  tmp___1 = ngx_http_add_location(cf, & pclcf->locations, clcf);
  }
#line 588
  if (tmp___1 != 0L) {
#line 589
    return ((char *)((void *)-1));
  }
  {
#line 592
  tmp___2 = ngx_http_rewrite_if_condition(cf, lcf);
  }
#line 592
  if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 593
    return ((char *)((void *)-1));
  }
  {
#line 596
  tmp___3 = ngx_array_push_n(lcf->codes, sizeof(ngx_http_script_if_code_t ));
#line 596
  if_code = (ngx_http_script_if_code_t *)tmp___3;
  }
#line 597
  if ((unsigned long )if_code == (unsigned long )((void *)0)) {
#line 598
    return ((char *)((void *)-1));
  }
#line 601
  if_code->code = & ngx_http_script_if_code;
#line 603
  elts = (u_char *)(lcf->codes)->elts;
#line 608
  nlcf = (ngx_http_rewrite_loc_conf_t *)*(ctx->loc_conf + ngx_http_rewrite_module.ctx_index);
#line 609
  nlcf->codes = lcf->codes;
#line 612
  save = *cf;
#line 613
  cf->ctx = (void *)ctx;
#line 615
  if (cf->cmd_type == 67108864UL) {
#line 616
    if_code->loc_conf = (void **)((void *)0);
#line 617
    cf->cmd_type = (ngx_uint_t )536870912;
  } else {
#line 620
    if_code->loc_conf = ctx->loc_conf;
#line 621
    cf->cmd_type = (ngx_uint_t )1073741824;
  }
  {
#line 624
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 626
  *cf = save;
  }
#line 628
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 629
    return (rv);
  }
#line 633
  if ((unsigned long )elts != (unsigned long )(lcf->codes)->elts) {
#line 634
    if_code = (ngx_http_script_if_code_t *)((u_char *)if_code + ((u_char *)(lcf->codes)->elts - elts));
  }
#line 638
  if_code->next = (uintptr_t )(((u_char *)(lcf->codes)->elts + (lcf->codes)->nelts) - (u_char *)if_code);
#line 643
  nlcf->codes = (ngx_array_t *)((void *)0);
#line 645
  return ((char *)((void *)0));
}
}
#line 649 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_if_condition(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_str_t *value ;
  ngx_uint_t cur ;
  ngx_uint_t last ;
  ngx_regex_compile_t rc ;
  ngx_http_script_code_pt *code ;
  ngx_http_script_file_code_t *fop ;
  ngx_http_script_regex_code_t *regex ;
  u_char errstr[1024] ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 662
  value = (ngx_str_t *)(cf->args)->elts;
#line 663
  last = (cf->args)->nelts - 1UL;
#line 665
  if ((value + 1)->len < 1UL) {
    {
#line 666
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + 1);
    }
#line 668
    return ((char *)((void *)-1));
  } else
#line 665
  if ((int )*((value + 1)->data + 0) != 40) {
    {
#line 666
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + 1);
    }
#line 668
    return ((char *)((void *)-1));
  }
#line 671
  if ((value + 1)->len == 1UL) {
#line 672
    cur = (ngx_uint_t )2;
  } else {
#line 675
    cur = (ngx_uint_t )1;
#line 676
    ((value + 1)->len) --;
#line 677
    ((value + 1)->data) ++;
  }
#line 680
  if ((value + last)->len < 1UL) {
    {
#line 681
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + last);
    }
#line 683
    return ((char *)((void *)-1));
  } else
#line 680
  if ((int )*((value + last)->data + ((value + last)->len - 1UL)) != 41) {
    {
#line 681
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + last);
    }
#line 683
    return ((char *)((void *)-1));
  }
#line 686
  if ((value + last)->len == 1UL) {
#line 687
    last --;
  } else {
#line 690
    ((value + last)->len) --;
#line 691
    *((value + last)->data + (value + last)->len) = (u_char )'\000';
  }
#line 694
  len = (value + cur)->len;
#line 695
  p = (value + cur)->data;
#line 697
  if (len > 1UL) {
#line 697
    if ((int )*(p + 0) == 36) {
#line 699
      if (cur != last) {
#line 699
        if (cur + 2UL != last) {
          {
#line 700
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + cur);
          }
#line 702
          return ((char *)((void *)-1));
        }
      }
      {
#line 705
      tmp = ngx_http_rewrite_variable(cf, lcf, value + cur);
      }
#line 705
      if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 706
        return ((char *)((void *)-1));
      }
#line 709
      if (cur == last) {
#line 710
        return ((char *)((void *)0));
      }
#line 713
      cur ++;
#line 715
      len = (value + cur)->len;
#line 716
      p = (value + cur)->data;
#line 718
      if (len == 1UL) {
#line 718
        if ((int )*(p + 0) == 61) {
          {
#line 720
          tmp___0 = ngx_http_rewrite_value(cf, lcf, value + last);
          }
#line 720
          if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 721
            return ((char *)((void *)-1));
          }
          {
#line 724
          tmp___1 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(uintptr_t ));
#line 724
          code = (ngx_http_script_code_pt *)tmp___1;
          }
#line 726
          if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 727
            return ((char *)((void *)-1));
          }
#line 730
          *code = & ngx_http_script_equal_code;
#line 732
          return ((char *)((void *)0));
        }
      }
#line 735
      if (len == 2UL) {
#line 735
        if ((int )*(p + 0) == 33) {
#line 735
          if ((int )*(p + 1) == 61) {
            {
#line 737
            tmp___2 = ngx_http_rewrite_value(cf, lcf, value + last);
            }
#line 737
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 738
              return ((char *)((void *)-1));
            }
            {
#line 741
            tmp___3 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(uintptr_t ));
#line 741
            code = (ngx_http_script_code_pt *)tmp___3;
            }
#line 743
            if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 744
              return ((char *)((void *)-1));
            }
#line 747
            *code = & ngx_http_script_not_equal_code;
#line 748
            return ((char *)((void *)0));
          }
        }
      }
#line 751
      if (len == 1UL) {
#line 751
        if ((int )*(p + 0) == 126) {
#line 751
          goto _L;
        } else {
#line 751
          goto _L___4;
        }
      } else
      _L___4: /* CIL Label */ 
#line 751
      if (len == 2UL) {
#line 751
        if ((int )*(p + 0) == 126) {
#line 751
          if ((int )*(p + 1) == 42) {
#line 751
            goto _L;
          } else {
#line 751
            goto _L___3;
          }
        } else {
#line 751
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 751
      if (len == 2UL) {
#line 751
        if ((int )*(p + 0) == 33) {
#line 751
          if ((int )*(p + 1) == 126) {
#line 751
            goto _L;
          } else {
#line 751
            goto _L___1;
          }
        } else {
#line 751
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 751
      if (len == 3UL) {
#line 751
        if ((int )*(p + 0) == 33) {
#line 751
          if ((int )*(p + 1) == 126) {
#line 751
            if ((int )*(p + 2) == 42) {
              _L: /* CIL Label */ 
              {
#line 756
              tmp___4 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_regex_code_t ));
#line 756
              regex = (ngx_http_script_regex_code_t *)tmp___4;
              }
#line 758
              if ((unsigned long )regex == (unsigned long )((void *)0)) {
#line 759
                return ((char *)((void *)-1));
              }
              {
#line 762
              memset((void *)regex, 0, sizeof(ngx_http_script_regex_code_t ));
#line 764
              memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 766
              rc.pattern = *(value + last);
              }
#line 767
              if ((int )*(p + (len - 1UL)) == 42) {
#line 767
                rc.options = (ngx_int_t )1;
              } else {
#line 767
                rc.options = (ngx_int_t )0;
              }
              {
#line 768
              rc.err.len = (size_t )1024;
#line 769
              rc.err.data = errstr;
#line 771
              regex->regex = ngx_http_regex_compile(cf, & rc);
              }
#line 772
              if ((unsigned long )regex->regex == (unsigned long )((void *)0)) {
#line 773
                return ((char *)((void *)-1));
              }
#line 776
              regex->code = & ngx_http_script_regex_start_code;
#line 777
              regex->next = sizeof(ngx_http_script_regex_code_t );
#line 778
              regex->test = 1U;
#line 779
              if ((int )*(p + 0) == 33) {
#line 780
                regex->negative_test = 1U;
              }
#line 782
              regex->name = *(value + last);
#line 784
              return ((char *)((void *)0));
            }
          }
        }
      }
      {
#line 787
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"%V\" in condition",
                         value + cur);
      }
#line 789
      return ((char *)((void *)-1));
    } else {
#line 697
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 791
  if (len == 2UL) {
#line 791
    if ((int )*(p + 0) == 45) {
#line 791
      goto _L___5;
    } else {
#line 791
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 791
  if (len == 3UL) {
#line 791
    if ((int )*(p + 0) == 33) {
#line 791
      if ((int )*(p + 1) == 45) {
        _L___5: /* CIL Label */ 
#line 794
        if (cur + 1UL != last) {
          {
#line 795
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + cur);
          }
#line 797
          return ((char *)((void *)-1));
        }
        {
#line 800
        *((value + last)->data + (value + last)->len) = (u_char )'\000';
#line 801
        ((value + last)->len) ++;
#line 803
        tmp___5 = ngx_http_rewrite_value(cf, lcf, value + last);
        }
#line 803
        if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 804
          return ((char *)((void *)-1));
        }
        {
#line 807
        tmp___6 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_file_code_t ));
#line 807
        fop = (ngx_http_script_file_code_t *)tmp___6;
        }
#line 809
        if ((unsigned long )fop == (unsigned long )((void *)0)) {
#line 810
          return ((char *)((void *)-1));
        }
#line 813
        fop->code = & ngx_http_script_file_code;
#line 815
        if ((int )*(p + 1) == 102) {
#line 816
          fop->op = (uintptr_t )0;
#line 817
          return ((char *)((void *)0));
        }
#line 820
        if ((int )*(p + 1) == 100) {
#line 821
          fop->op = (uintptr_t )2;
#line 822
          return ((char *)((void *)0));
        }
#line 825
        if ((int )*(p + 1) == 101) {
#line 826
          fop->op = (uintptr_t )4;
#line 827
          return ((char *)((void *)0));
        }
#line 830
        if ((int )*(p + 1) == 120) {
#line 831
          fop->op = (uintptr_t )6;
#line 832
          return ((char *)((void *)0));
        }
#line 835
        if ((int )*(p + 0) == 33) {
#line 836
          if ((int )*(p + 2) == 102) {
#line 837
            fop->op = (uintptr_t )1;
#line 838
            return ((char *)((void *)0));
          }
#line 841
          if ((int )*(p + 2) == 100) {
#line 842
            fop->op = (uintptr_t )3;
#line 843
            return ((char *)((void *)0));
          }
#line 846
          if ((int )*(p + 2) == 101) {
#line 847
            fop->op = (uintptr_t )5;
#line 848
            return ((char *)((void *)0));
          }
#line 851
          if ((int )*(p + 2) == 120) {
#line 852
            fop->op = (uintptr_t )7;
#line 853
            return ((char *)((void *)0));
          }
        }
        {
#line 857
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + cur);
        }
#line 859
        return ((char *)((void *)-1));
      }
    }
  }
  {
#line 862
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid condition \"%V\"", value + cur);
  }
#line 865
  return ((char *)((void *)-1));
}
}
#line 869 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_variable(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ,
                                       ngx_str_t *value ) 
{ 
  ngx_int_t index___0 ;
  ngx_http_script_var_code_t *var_code ;
  void *tmp ;

  {
  {
#line 876
  (value->len) --;
#line 877
  (value->data) ++;
#line 879
  index___0 = ngx_http_get_variable_index(cf, value);
  }
#line 881
  if (index___0 == -1L) {
#line 882
    return ((char *)((void *)-1));
  }
  {
#line 885
  tmp = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_var_code_t ));
#line 885
  var_code = (ngx_http_script_var_code_t *)tmp;
  }
#line 887
  if ((unsigned long )var_code == (unsigned long )((void *)0)) {
#line 888
    return ((char *)((void *)-1));
  }
#line 891
  var_code->code = & ngx_http_script_var_code;
#line 892
  var_code->index = (uintptr_t )index___0;
#line 894
  return ((char *)((void *)0));
}
}
#line 898 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_set(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_rewrite_loc_conf_t *lcf ;
  ngx_int_t index___0 ;
  ngx_str_t *value ;
  ngx_http_variable_t *v ;
  ngx_http_script_var_code_t *vcode ;
  ngx_http_script_var_handler_code_t *vhcode ;
  char *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp13 ;

  {
#line 901
  lcf = (ngx_http_rewrite_loc_conf_t *)conf;
#line 909
  value = (ngx_str_t *)(cf->args)->elts;
#line 911
  if ((int )*((value + 1)->data + 0) != 36) {
    {
#line 912
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", value + 1);
    }
#line 914
    return ((char *)((void *)-1));
  }
  {
#line 917
  ((value + 1)->len) --;
#line 918
  ((value + 1)->data) ++;
#line 920
  v = ngx_http_add_variable(cf, value + 1, (ngx_uint_t )17);
  }
#line 922
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 923
    return ((char *)((void *)-1));
  }
  {
#line 926
  index___0 = ngx_http_get_variable_index(cf, value + 1);
  }
#line 927
  if (index___0 == -1L) {
#line 928
    return ((char *)((void *)-1));
  }
#line 931
  if ((unsigned long )v->get_handler == (unsigned long )((void *)0)) {
#line 932
    v->get_handler = & ngx_http_rewrite_var;
#line 933
    v->data = (uintptr_t )index___0;
  }
  {
#line 936
  tmp = ngx_http_rewrite_value(cf, lcf, value + 2);
  }
#line 936
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 937
    return ((char *)((void *)-1));
  }
#line 940
  if (v->set_handler) {
    {
#line 941
    tmp___0 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_var_handler_code_t ));
#line 941
    vhcode = (ngx_http_script_var_handler_code_t *)tmp___0;
    }
#line 943
    if ((unsigned long )vhcode == (unsigned long )((void *)0)) {
#line 944
      return ((char *)((void *)-1));
    }
#line 947
    vhcode->code = & ngx_http_script_var_set_handler_code;
#line 948
    vhcode->handler = v->set_handler;
#line 949
    vhcode->data = v->data;
#line 951
    return ((char *)((void *)0));
  }
  {
#line 954
  tmp___1 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_var_code_t ));
#line 954
  vcode = (ngx_http_script_var_code_t *)tmp___1;
  }
#line 956
  if ((unsigned long )vcode == (unsigned long )((void *)0)) {
#line 957
    return ((char *)((void *)-1));
  }
#line 960
  vcode->code = & ngx_http_script_set_var_code;
#line 961
  vcode->index = (uintptr_t )index___0;
#line 963
  return ((char *)((void *)0));
}
}
#line 967 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_rewrite_module.c"
static char *ngx_http_rewrite_value(ngx_conf_t *cf , ngx_http_rewrite_loc_conf_t *lcf ,
                                    ngx_str_t *value ) 
{ 
  ngx_int_t n ;
  ngx_http_script_compile_t sc ;
  ngx_http_script_value_code_t *val ;
  ngx_http_script_complex_value_code_t *complex ;
  ngx_uint_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 976
  tmp = ngx_http_script_variables_count(value);
#line 976
  n = (ngx_int_t )tmp;
  }
#line 978
  if (n == 0L) {
    {
#line 979
    tmp___0 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_value_code_t ));
#line 979
    val = (ngx_http_script_value_code_t *)tmp___0;
    }
#line 981
    if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 982
      return ((char *)((void *)-1));
    }
    {
#line 985
    n = ngx_atoi(value->data, value->len);
    }
#line 987
    if (n == -1L) {
#line 988
      n = (ngx_int_t )0;
    }
#line 991
    val->code = & ngx_http_script_value_code;
#line 992
    val->value = (uintptr_t )n;
#line 993
    val->text_len = value->len;
#line 994
    val->text_data = (uintptr_t )value->data;
#line 996
    return ((char *)((void *)0));
  }
  {
#line 999
  tmp___1 = ngx_http_script_start_code(cf->pool, & lcf->codes, sizeof(ngx_http_script_complex_value_code_t ));
#line 999
  complex = (ngx_http_script_complex_value_code_t *)tmp___1;
  }
#line 1001
  if ((unsigned long )complex == (unsigned long )((void *)0)) {
#line 1002
    return ((char *)((void *)-1));
  }
  {
#line 1005
  complex->code = & ngx_http_script_complex_value_code;
#line 1006
  complex->lengths = (ngx_array_t *)((void *)0);
#line 1008
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1010
  sc.cf = cf;
#line 1011
  sc.source = value;
#line 1012
  sc.lengths = & complex->lengths;
#line 1013
  sc.values = & lcf->codes;
#line 1014
  sc.variables = (ngx_uint_t )n;
#line 1015
  sc.complete_lengths = 1U;
#line 1017
  tmp___2 = ngx_http_script_compile(& sc);
  }
#line 1017
  if (tmp___2 != 0L) {
#line 1018
    return ((char *)((void *)-1));
  }
#line 1021
  return ((char *)((void *)0));
}
}
#line 171 "src/core/ngx_string.h"
ngx_int_t ngx_dns_strcmp(u_char *s1 , u_char *s2 ) ;
#line 103 "src/core/ngx_hash.h"
void *ngx_hash_find_combined(ngx_hash_combined_t *hash , ngx_uint_t key , u_char *name ,
                             size_t len ) ;
#line 108
ngx_int_t ngx_hash_wildcard_init(ngx_hash_init_t *hinit , ngx_hash_key_t *names ,
                                 ngx_uint_t nelts ) ;
#line 117
ngx_int_t ngx_hash_keys_array_init(ngx_hash_keys_arrays_t *ha , ngx_uint_t type ) ;
#line 118
ngx_int_t ngx_hash_add_key(ngx_hash_keys_arrays_t *ha , ngx_str_t *key , void *value ,
                           ngx_uint_t flags ) ;
#line 57 "src/core/ngx_regex.h"
ngx_int_t ngx_regex_exec_array(ngx_array_t *a , ngx_str_t *s , ngx_log_t *log ) ;
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_referer_add_variables(ngx_conf_t *cf ) ;
#line 36
static void *ngx_http_referer_create_conf(ngx_conf_t *cf ) ;
#line 37
static char *ngx_http_referer_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 39
static char *ngx_http_valid_referers(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 41
static ngx_int_t ngx_http_add_referer(ngx_conf_t *cf , ngx_hash_keys_arrays_t *keys ,
                                      ngx_str_t *value , ngx_str_t *uri___0 ) ;
#line 43
static ngx_int_t ngx_http_add_regex_referer(ngx_conf_t *cf , ngx_http_referer_conf_t *rlcf ,
                                            ngx_str_t *name ) ;
#line 46
static ngx_int_t ngx_http_add_regex_server_name(ngx_conf_t *cf , ngx_http_referer_conf_t *rlcf ,
                                                ngx_http_regex_t *regex ) ;
#line 49
static int ngx_http_cmp_referer_wildcards(void const   *one , void const   *two ) ;
#line 53 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_command_t ngx_http_referer_commands[4]  = {      {{sizeof("valid_referers") - 1UL, (u_char *)"valid_referers"}, (ngx_uint_t )201328640,
      & ngx_http_valid_referers, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("referer_hash_max_size") - 1UL, (u_char *)"referer_hash_max_size"},
      (ngx_uint_t )201326594, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_referer_conf_t *)0)->referer_hash_max_size), (void *)0}, 
        {{sizeof("referer_hash_bucket_size") - 1UL,
       (u_char *)"referer_hash_bucket_size"}, (ngx_uint_t )201326594, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_referer_conf_t *)0)->referer_hash_bucket_size),
      (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 80 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_http_module_t ngx_http_referer_module_ctx  = 
#line 80
     {& ngx_http_referer_add_variables, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_referer_create_conf, & ngx_http_referer_merge_conf};
#line 95 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
ngx_module_t ngx_http_referer_module  = 
#line 95
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_referer_module_ctx),
    ngx_http_referer_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 111 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_str_t ngx_http_invalid_referer_name  =    {sizeof("invalid_referer") - 1UL, (u_char *)"invalid_referer"};
#line 114 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_referer_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  u_char *p ;
  u_char *ref ;
  u_char *last ;
  size_t len ;
  ngx_str_t *uri___0 ;
  ngx_uint_t i ;
  ngx_uint_t key ;
  ngx_http_referer_conf_t *rlcf ;
  u_char buf[256] ;
  ngx_int_t rc ;
  ngx_str_t referer ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  ngx_uint_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 129
  rlcf = (ngx_http_referer_conf_t *)*(r->loc_conf + ngx_http_referer_module.ctx_index);
#line 131
  if ((unsigned long )rlcf->hash.hash.buckets == (unsigned long )((void *)0)) {
#line 131
    if ((unsigned long )rlcf->hash.wc_head == (unsigned long )((void *)0)) {
#line 131
      if ((unsigned long )rlcf->hash.wc_tail == (unsigned long )((void *)0)) {
#line 131
        if ((unsigned long )rlcf->regex == (unsigned long )((void *)0)) {
#line 131
          if ((unsigned long )rlcf->server_name_regex == (unsigned long )((void *)0)) {
#line 140
            goto valid;
          }
        }
      }
    }
  }
#line 143
  if ((unsigned long )r->headers_in.referer == (unsigned long )((void *)0)) {
#line 144
    if (rlcf->no_referer) {
#line 145
      goto valid;
    }
#line 148
    goto invalid;
  }
#line 151
  len = (r->headers_in.referer)->value.len;
#line 152
  ref = (r->headers_in.referer)->value.data;
#line 154
  if (len >= sizeof("http://i.ru") - 1UL) {
    {
#line 155
    last = ref + len;
#line 157
    tmp___0 = ngx_strncasecmp(ref, (u_char *)"http://", (size_t )7);
    }
#line 157
    if (tmp___0 == 0L) {
#line 158
      ref += 7;
#line 159
      len -= 7UL;
#line 160
      goto valid_scheme;
    } else {
      {
#line 162
      tmp = ngx_strncasecmp(ref, (u_char *)"https://", (size_t )8);
      }
#line 162
      if (tmp == 0L) {
#line 163
        ref += 8;
#line 164
        len -= 8UL;
#line 165
        goto valid_scheme;
      }
    }
  }
#line 169
  if (rlcf->blocked_referer) {
#line 170
    goto valid;
  }
#line 173
  goto invalid;
  valid_scheme: 
#line 177
  i = (ngx_uint_t )0;
#line 178
  key = (ngx_uint_t )0;
#line 180
  p = ref;
  {
#line 180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 180
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 180
      goto while_break;
    }
#line 181
    if ((int )*p == 47) {
#line 182
      goto while_break;
    } else
#line 181
    if ((int )*p == 58) {
#line 182
      goto while_break;
    }
#line 185
    if (i == 256UL) {
#line 186
      goto invalid;
    }
#line 189
    if ((int )*p >= 65) {
#line 189
      if ((int )*p <= 90) {
#line 189
        tmp___1 = (int )*p | 32;
      } else {
#line 189
        tmp___1 = (int )*p;
      }
    } else {
#line 189
      tmp___1 = (int )*p;
    }
#line 189
    buf[i] = (u_char )tmp___1;
#line 190
    tmp___2 = i;
#line 190
    i ++;
#line 190
    key = key * 31UL + (ngx_uint_t )buf[tmp___2];
#line 180
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 193
  tmp___3 = ngx_hash_find_combined(& rlcf->hash, key, buf, (size_t )(p - ref));
#line 193
  uri___0 = (ngx_str_t *)tmp___3;
  }
#line 195
  if (uri___0) {
#line 196
    goto uri;
  }
#line 201
  if (rlcf->server_name_regex) {
    {
#line 202
    referer.len = (size_t )(p - ref);
#line 203
    referer.data = buf;
#line 205
    rc = ngx_regex_exec_array(rlcf->server_name_regex, & referer, (r->connection)->log);
    }
#line 208
    if (rc == 0L) {
#line 209
      goto valid;
    }
#line 212
    if (rc == -1L) {
#line 213
      return (rc);
    }
  }
#line 219
  if (rlcf->regex) {
    {
#line 220
    referer.len = len;
#line 221
    referer.data = ref;
#line 223
    rc = ngx_regex_exec_array(rlcf->regex, & referer, (r->connection)->log);
    }
#line 225
    if (rc == 0L) {
#line 226
      goto valid;
    }
#line 229
    if (rc == -1L) {
#line 230
      return (rc);
    }
  }
  invalid: 
#line 240
  *v = ngx_http_variable_true_value;
#line 242
  return ((ngx_int_t )0);
  uri: 
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 246
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 246
      goto while_break___0;
    }
#line 247
    if ((int )*p == 47) {
#line 248
      goto while_break___0;
    }
#line 246
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 252
  len = (size_t )(last - p);
#line 254
  if ((unsigned long )uri___0 == (unsigned long )((void *)4)) {
#line 255
    goto valid;
  }
#line 258
  if (len < uri___0->len) {
#line 259
    goto invalid;
  } else {
    {
#line 258
    tmp___4 = strncmp((char const   *)uri___0->data, (char const   *)p, uri___0->len);
    }
#line 258
    if (tmp___4 != 0) {
#line 259
      goto invalid;
    }
  }
  valid: 
#line 264
  *v = ngx_http_variable_null_value;
#line 266
  return ((ngx_int_t )0);
}
}
#line 270 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_referer_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;

  {
  {
#line 275
  var = ngx_http_add_variable(cf, & ngx_http_invalid_referer_name, (ngx_uint_t )1);
  }
#line 277
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 278
    return ((ngx_int_t )-1);
  }
#line 281
  var->get_handler = & ngx_http_referer_variable;
#line 283
  return ((ngx_int_t )0);
}
}
#line 287 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static void *ngx_http_referer_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_referer_conf_t *conf ;
  void *tmp ;

  {
  {
#line 292
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_referer_conf_t ));
#line 292
  conf = (ngx_http_referer_conf_t *)tmp;
  }
#line 293
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 294
    return ((void *)0);
  }
#line 306
  conf->regex = (ngx_array_t *)((void *)-1);
#line 307
  conf->server_name_regex = (ngx_array_t *)((void *)-1);
#line 310
  conf->no_referer = (ngx_flag_t )-1;
#line 311
  conf->blocked_referer = (ngx_flag_t )-1;
#line 312
  conf->referer_hash_max_size = (ngx_uint_t )-1;
#line 313
  conf->referer_hash_bucket_size = (ngx_uint_t )-1;
#line 315
  return ((void *)conf);
}
}
#line 319 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static char *ngx_http_referer_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_referer_conf_t *prev ;
  ngx_http_referer_conf_t *conf ;
  ngx_uint_t n ;
  ngx_hash_init_t hash ;
  ngx_http_server_name_t *sn ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 322
  prev = (ngx_http_referer_conf_t *)parent;
#line 323
  conf = (ngx_http_referer_conf_t *)child;
#line 330
  if ((unsigned long )conf->keys == (unsigned long )((void *)0)) {
#line 331
    conf->hash = prev->hash;
#line 334
    if ((unsigned long )conf->regex == (unsigned long )((void *)-1)) {
#line 334
      if ((unsigned long )prev->regex == (unsigned long )((void *)-1)) {
#line 334
        conf->regex = (ngx_array_t *)((void *)0);
      } else {
#line 334
        conf->regex = prev->regex;
      }
    }
#line 335
    if ((unsigned long )conf->server_name_regex == (unsigned long )((void *)-1)) {
#line 335
      if ((unsigned long )prev->server_name_regex == (unsigned long )((void *)-1)) {
#line 335
        conf->server_name_regex = (ngx_array_t *)((void *)0);
      } else {
#line 335
        conf->server_name_regex = prev->server_name_regex;
      }
    }
#line 338
    if (conf->no_referer == -1L) {
#line 338
      if (prev->no_referer == -1L) {
#line 338
        conf->no_referer = (ngx_flag_t )0;
      } else {
#line 338
        conf->no_referer = prev->no_referer;
      }
    }
#line 339
    if (conf->blocked_referer == -1L) {
#line 339
      if (prev->blocked_referer == -1L) {
#line 339
        conf->blocked_referer = (ngx_flag_t )0;
      } else {
#line 339
        conf->blocked_referer = prev->blocked_referer;
      }
    }
#line 340
    if (conf->referer_hash_max_size == 0xffffffffffffffffUL) {
#line 340
      if (prev->referer_hash_max_size == 0xffffffffffffffffUL) {
#line 340
        conf->referer_hash_max_size = (ngx_uint_t )2048;
      } else {
#line 340
        conf->referer_hash_max_size = prev->referer_hash_max_size;
      }
    }
#line 342
    if (conf->referer_hash_bucket_size == 0xffffffffffffffffUL) {
#line 342
      if (prev->referer_hash_bucket_size == 0xffffffffffffffffUL) {
#line 342
        conf->referer_hash_bucket_size = (ngx_uint_t )64;
      } else {
#line 342
        conf->referer_hash_bucket_size = prev->referer_hash_bucket_size;
      }
    }
#line 345
    return ((char *)((void *)0));
  }
#line 348
  if (conf->server_names == 1L) {
#line 349
    cscf = (ngx_http_core_srv_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->srv_conf + ngx_http_core_module.ctx_index);
#line 351
    sn = (ngx_http_server_name_t *)cscf->server_names.elts;
#line 352
    n = (ngx_uint_t )0;
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;
#line 352
      if (! (n < cscf->server_names.nelts)) {
#line 352
        goto while_break;
      }
#line 355
      if ((sn + n)->regex) {
        {
#line 357
        tmp = ngx_http_add_regex_server_name(cf, conf, (sn + n)->regex);
        }
#line 357
        if (tmp != 0L) {
#line 360
          return ((char *)((void *)-1));
        }
#line 363
        goto __Cont;
      }
      {
#line 367
      tmp___0 = ngx_http_add_referer(cf, conf->keys, & (sn + n)->name, (ngx_str_t *)((void *)0));
      }
#line 367
      if (tmp___0 != 0L) {
#line 370
        return ((char *)((void *)-1));
      }
      __Cont: /* CIL Label */ 
#line 352
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 375
  if (conf->no_referer == 1L) {
#line 375
    goto _L;
  } else
#line 375
  if (conf->blocked_referer == 1L) {
    _L: /* CIL Label */ 
#line 375
    if ((conf->keys)->keys.nelts == 0UL) {
#line 375
      if ((conf->keys)->dns_wc_head.nelts == 0UL) {
#line 375
        if ((conf->keys)->dns_wc_tail.nelts == 0UL) {
#line 380
          if ((cf->log)->log_level >= 1UL) {
            {
#line 380
            ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "the \"none\" or \"blocked\" referers are specified in the \"valid_referers\" directive without any valid referer");
            }
          }
#line 384
          return ((char *)((void *)-1));
        }
      }
    }
  }
#line 387
  if (conf->referer_hash_max_size == 0xffffffffffffffffUL) {
#line 387
    if (prev->referer_hash_max_size == 0xffffffffffffffffUL) {
#line 387
      conf->referer_hash_max_size = (ngx_uint_t )2048;
    } else {
#line 387
      conf->referer_hash_max_size = prev->referer_hash_max_size;
    }
  }
#line 389
  if (conf->referer_hash_bucket_size == 0xffffffffffffffffUL) {
#line 389
    if (prev->referer_hash_bucket_size == 0xffffffffffffffffUL) {
#line 389
      conf->referer_hash_bucket_size = (ngx_uint_t )64;
    } else {
#line 389
      conf->referer_hash_bucket_size = prev->referer_hash_bucket_size;
    }
  }
#line 391
  conf->referer_hash_bucket_size = (conf->referer_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 394
  hash.key = & ngx_hash_key_lc;
#line 395
  hash.max_size = conf->referer_hash_max_size;
#line 396
  hash.bucket_size = conf->referer_hash_bucket_size;
#line 397
  hash.name = (char *)"referer_hash";
#line 398
  hash.pool = cf->pool;
#line 400
  if ((conf->keys)->keys.nelts) {
    {
#line 401
    hash.hash = & conf->hash.hash;
#line 402
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 404
    tmp___1 = ngx_hash_init(& hash, (ngx_hash_key_t *)(conf->keys)->keys.elts, (conf->keys)->keys.nelts);
    }
#line 404
    if (tmp___1 != 0L) {
#line 407
      return ((char *)((void *)-1));
    }
  }
#line 411
  if ((conf->keys)->dns_wc_head.nelts) {
    {
#line 413
    qsort((conf->keys)->dns_wc_head.elts, (conf->keys)->dns_wc_head.nelts, sizeof(ngx_hash_key_t ),
          & ngx_http_cmp_referer_wildcards);
#line 418
    hash.hash = (ngx_hash_t *)((void *)0);
#line 419
    hash.temp_pool = cf->temp_pool;
#line 421
    tmp___2 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)(conf->keys)->dns_wc_head.elts,
                                     (conf->keys)->dns_wc_head.nelts);
    }
#line 421
    if (tmp___2 != 0L) {
#line 425
      return ((char *)((void *)-1));
    }
#line 428
    conf->hash.wc_head = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 431
  if ((conf->keys)->dns_wc_tail.nelts) {
    {
#line 433
    qsort((conf->keys)->dns_wc_tail.elts, (conf->keys)->dns_wc_tail.nelts, sizeof(ngx_hash_key_t ),
          & ngx_http_cmp_referer_wildcards);
#line 438
    hash.hash = (ngx_hash_t *)((void *)0);
#line 439
    hash.temp_pool = cf->temp_pool;
#line 441
    tmp___3 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)(conf->keys)->dns_wc_tail.elts,
                                     (conf->keys)->dns_wc_tail.nelts);
    }
#line 441
    if (tmp___3 != 0L) {
#line 445
      return ((char *)((void *)-1));
    }
#line 448
    conf->hash.wc_tail = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 452
  if ((unsigned long )conf->regex == (unsigned long )((void *)-1)) {
#line 452
    if ((unsigned long )prev->regex == (unsigned long )((void *)-1)) {
#line 452
      conf->regex = (ngx_array_t *)((void *)0);
    } else {
#line 452
      conf->regex = prev->regex;
    }
  }
#line 453
  if ((unsigned long )conf->server_name_regex == (unsigned long )((void *)-1)) {
#line 453
    if ((unsigned long )prev->server_name_regex == (unsigned long )((void *)-1)) {
#line 453
      conf->server_name_regex = (ngx_array_t *)((void *)0);
    } else {
#line 453
      conf->server_name_regex = prev->server_name_regex;
    }
  }
#line 457
  if (conf->no_referer == -1L) {
#line 458
    conf->no_referer = (ngx_flag_t )0;
  }
#line 461
  if (conf->blocked_referer == -1L) {
#line 462
    conf->blocked_referer = (ngx_flag_t )0;
  }
#line 465
  conf->keys = (ngx_hash_keys_arrays_t *)((void *)0);
#line 467
  return ((char *)((void *)0));
}
}
#line 471 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static char *ngx_http_valid_referers(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_referer_conf_t *rlcf ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_str_t uri___0 ;
  ngx_uint_t i ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  char *tmp___5 ;
  ngx_int_t tmp___6 ;
  char *__cil_tmp17 ;

  {
#line 474
  rlcf = (ngx_http_referer_conf_t *)conf;
#line 480
  if ((unsigned long )rlcf->keys == (unsigned long )((void *)0)) {
    {
#line 481
    tmp = ngx_pcalloc(cf->temp_pool, sizeof(ngx_hash_keys_arrays_t ));
#line 481
    rlcf->keys = (ngx_hash_keys_arrays_t *)tmp;
    }
#line 482
    if ((unsigned long )rlcf->keys == (unsigned long )((void *)0)) {
#line 483
      return ((char *)((void *)-1));
    }
    {
#line 486
    (rlcf->keys)->pool = cf->pool;
#line 487
    (rlcf->keys)->temp_pool = cf->pool;
#line 489
    tmp___0 = ngx_hash_keys_array_init(rlcf->keys, (ngx_uint_t )1);
    }
#line 489
    if (tmp___0 != 0L) {
#line 490
      return ((char *)((void *)-1));
    }
  }
#line 494
  value = (ngx_str_t *)(cf->args)->elts;
#line 496
  i = (ngx_uint_t )1;
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    if (! (i < (cf->args)->nelts)) {
#line 496
      goto while_break;
    }
#line 497
    if ((value + i)->len == 0UL) {
      {
#line 498
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid referer \"%V\"", value + i);
      }
#line 500
      return ((char *)((void *)-1));
    }
    {
#line 503
    tmp___1 = strcmp((char const   *)(value + i)->data, "none");
    }
#line 503
    if (tmp___1 == 0) {
#line 504
      rlcf->no_referer = (ngx_flag_t )1;
#line 505
      goto __Cont;
    }
    {
#line 508
    tmp___2 = strcmp((char const   *)(value + i)->data, "blocked");
    }
#line 508
    if (tmp___2 == 0) {
#line 509
      rlcf->blocked_referer = (ngx_flag_t )1;
#line 510
      goto __Cont;
    }
    {
#line 513
    tmp___3 = strcmp((char const   *)(value + i)->data, "server_names");
    }
#line 513
    if (tmp___3 == 0) {
#line 514
      rlcf->server_names = (ngx_flag_t )1;
#line 515
      goto __Cont;
    }
#line 518
    if ((int )*((value + i)->data + 0) == 126) {
      {
#line 519
      tmp___4 = ngx_http_add_regex_referer(cf, rlcf, value + i);
      }
#line 519
      if (tmp___4 != 0L) {
#line 520
        return ((char *)((void *)-1));
      }
#line 523
      goto __Cont;
    }
    {
#line 526
    uri___0.len = (size_t )0;
#line 526
    uri___0.data = (u_char *)((void *)0);
#line 528
    tmp___5 = strchr((char const   *)(value + i)->data, '/');
#line 528
    p = (u_char *)tmp___5;
    }
#line 530
    if (p) {
#line 531
      uri___0.len = (size_t )(((value + i)->data + (value + i)->len) - p);
#line 532
      uri___0.data = p;
#line 533
      (value + i)->len = (size_t )(p - (value + i)->data);
    }
    {
#line 536
    tmp___6 = ngx_http_add_referer(cf, rlcf->keys, value + i, & uri___0);
    }
#line 536
    if (tmp___6 != 0L) {
#line 537
      return ((char *)((void *)-1));
    }
    __Cont: /* CIL Label */ 
#line 496
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 541
  return ((char *)((void *)0));
}
}
#line 545 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_add_referer(ngx_conf_t *cf , ngx_hash_keys_arrays_t *keys ,
                                      ngx_str_t *value , ngx_str_t *uri___0 ) 
{ 
  ngx_int_t rc ;
  ngx_str_t *u ;
  void *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 552
  if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 553
    u = (ngx_str_t *)((void *)4);
  } else
#line 552
  if (uri___0->len == 0UL) {
#line 553
    u = (ngx_str_t *)((void *)4);
  } else {
    {
#line 556
    tmp = ngx_palloc(cf->pool, sizeof(ngx_str_t ));
#line 556
    u = (ngx_str_t *)tmp;
    }
#line 557
    if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 558
      return ((ngx_int_t )-1);
    }
#line 561
    *u = *uri___0;
  }
  {
#line 564
  rc = ngx_hash_add_key(keys, value, (void *)u, (ngx_uint_t )1);
  }
#line 566
  if (rc == 0L) {
#line 567
    return ((ngx_int_t )0);
  }
#line 570
  if (rc == -5L) {
    {
#line 571
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid hostname or wildcard \"%V\"",
                       value);
    }
  }
#line 575
  if (rc == -3L) {
    {
#line 576
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "conflicting parameter \"%V\"", value);
    }
  }
#line 580
  return ((ngx_int_t )-1);
}
}
#line 584 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_add_regex_referer(ngx_conf_t *cf , ngx_http_referer_conf_t *rlcf ,
                                            ngx_str_t *name ) 
{ 
  ngx_regex_elt_t *re ;
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 593
  if (name->len == 1UL) {
    {
#line 594
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "empty regex in \"%V\"", name);
    }
#line 595
    return ((ngx_int_t )-1);
  }
#line 598
  if ((unsigned long )rlcf->regex == (unsigned long )((void *)-1)) {
    {
#line 599
    rlcf->regex = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_regex_elt_t ));
    }
#line 600
    if ((unsigned long )rlcf->regex == (unsigned long )((void *)0)) {
#line 601
      return ((ngx_int_t )-1);
    }
  }
  {
#line 605
  tmp = ngx_array_push(rlcf->regex);
#line 605
  re = (ngx_regex_elt_t *)tmp;
  }
#line 606
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 607
    return ((ngx_int_t )-1);
  }
  {
#line 610
  (name->len) --;
#line 611
  (name->data) ++;
#line 613
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 615
  rc.pattern = *name;
#line 616
  rc.pool = cf->pool;
#line 617
  rc.options = (ngx_int_t )1;
#line 618
  rc.err.len = (size_t )1024;
#line 619
  rc.err.data = errstr;
#line 621
  tmp___0 = ngx_regex_compile(& rc);
  }
#line 621
  if (tmp___0 != 0L) {
    {
#line 622
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V", & rc.err);
    }
#line 623
    return ((ngx_int_t )-1);
  }
#line 626
  re->regex = rc.regex;
#line 627
  re->name = name->data;
#line 629
  return ((ngx_int_t )0);
}
}
#line 645 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static ngx_int_t ngx_http_add_regex_server_name(ngx_conf_t *cf , ngx_http_referer_conf_t *rlcf ,
                                                ngx_http_regex_t *regex ) 
{ 
  ngx_regex_elt_t *re ;
  void *tmp ;

  {
#line 651
  if ((unsigned long )rlcf->server_name_regex == (unsigned long )((void *)-1)) {
    {
#line 652
    rlcf->server_name_regex = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_regex_elt_t ));
    }
#line 654
    if ((unsigned long )rlcf->server_name_regex == (unsigned long )((void *)0)) {
#line 655
      return ((ngx_int_t )-1);
    }
  }
  {
#line 659
  tmp = ngx_array_push(rlcf->server_name_regex);
#line 659
  re = (ngx_regex_elt_t *)tmp;
  }
#line 660
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 661
    return ((ngx_int_t )-1);
  }
#line 664
  re->regex = regex->regex;
#line 665
  re->name = regex->name.data;
#line 667
  return ((ngx_int_t )0);
}
}
#line 673 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_referer_module.c"
static int ngx_http_cmp_referer_wildcards(void const   *one , void const   *two ) 
{ 
  ngx_hash_key_t *first ;
  ngx_hash_key_t *second ;
  ngx_int_t tmp ;

  {
  {
#line 678
  first = (ngx_hash_key_t *)one;
#line 679
  second = (ngx_hash_key_t *)two;
#line 681
  tmp = ngx_dns_strcmp(first->key.data, second->key.data);
  }
#line 681
  return ((int )tmp);
}
}
#line 175 "src/core/ngx_string.h"
ngx_int_t ngx_atofp(u_char *line , size_t n , size_t point ) ;
#line 16 "src/core/ngx_murmurhash.h"
uint32_t ngx_murmur_hash2(u_char *data , size_t len ) ;
#line 25 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
static char *ngx_conf_split_clients_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 27
static char *ngx_http_split_clients(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 30 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
static ngx_command_t ngx_http_split_clients_commands[2]  = {      {{sizeof("split_clients") - 1UL, (u_char *)"split_clients"}, (ngx_uint_t )33554692,
      & ngx_conf_split_clients_block, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 43 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
static ngx_http_module_t ngx_http_split_clients_module_ctx  = 
#line 43
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 58 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
ngx_module_t ngx_http_split_clients_module  = 
#line 58
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_split_clients_module_ctx),
    ngx_http_split_clients_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 74 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
static ngx_int_t ngx_http_split_clients_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  ngx_http_split_clients_ctx_t *ctx ;
  uint32_t hash ;
  ngx_str_t val ;
  ngx_uint_t i ;
  ngx_http_split_clients_part_t *part ;
  ngx_int_t tmp ;

  {
  {
#line 78
  ctx = (ngx_http_split_clients_ctx_t *)data;
#line 85
  *v = ngx_http_variable_null_value;
#line 87
  tmp = ngx_http_complex_value(r, & ctx->value, & val);
  }
#line 87
  if (tmp != 0L) {
#line 88
    return ((ngx_int_t )0);
  }
  {
#line 91
  hash = ngx_murmur_hash2(val.data, val.len);
#line 93
  part = (ngx_http_split_clients_part_t *)ctx->parts.elts;
#line 95
  i = (ngx_uint_t )0;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (i < ctx->parts.nelts)) {
#line 95
      goto while_break;
    }
#line 100
    if (hash < (part + i)->percent) {
#line 101
      *v = (part + i)->value;
#line 102
      return ((ngx_int_t )0);
    } else
#line 100
    if ((part + i)->percent == 0U) {
#line 101
      *v = (part + i)->value;
#line 102
      return ((ngx_int_t )0);
    }
#line 95
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return ((ngx_int_t )0);
}
}
#line 110 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
static char *ngx_conf_split_clients_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  uint32_t sum ;
  uint32_t last ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_http_variable_t *var ;
  ngx_http_split_clients_ctx_t *ctx ;
  ngx_http_split_clients_part_t *part ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 123
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_split_clients_ctx_t ));
#line 123
  ctx = (ngx_http_split_clients_ctx_t *)tmp;
  }
#line 124
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 125
    return ((char *)((void *)-1));
  }
  {
#line 128
  value = (ngx_str_t *)(cf->args)->elts;
#line 130
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 132
  ccv.cf = cf;
#line 133
  ccv.value = value + 1;
#line 134
  ccv.complex_value = & ctx->value;
#line 136
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 136
  if (tmp___0 != 0L) {
#line 137
    return ((char *)((void *)-1));
  }
#line 140
  name = *(value + 2);
#line 142
  if ((int )*(name.data + 0) != 36) {
    {
#line 143
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", & name);
    }
#line 145
    return ((char *)((void *)-1));
  }
  {
#line 148
  (name.len) --;
#line 149
  (name.data) ++;
#line 151
  var = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
  }
#line 152
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 153
    return ((char *)((void *)-1));
  }
  {
#line 156
  var->get_handler = & ngx_http_split_clients_variable;
#line 157
  var->data = (uintptr_t )ctx;
#line 159
  tmp___1 = ngx_array_init(& ctx->parts, cf->pool, (ngx_uint_t )2, sizeof(ngx_http_split_clients_part_t ));
  }
#line 159
  if (tmp___1 != 0L) {
#line 163
    return ((char *)((void *)-1));
  }
  {
#line 166
  save = *cf;
#line 167
  cf->ctx = (void *)ctx;
#line 168
  cf->handler = & ngx_http_split_clients;
#line 169
  cf->handler_conf = conf;
#line 171
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 173
  *cf = save;
  }
#line 175
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 176
    return (rv);
  }
#line 179
  sum = (uint32_t )0;
#line 180
  last = (uint32_t )0;
#line 181
  part = (ngx_http_split_clients_part_t *)ctx->parts.elts;
#line 183
  i = (ngx_uint_t )0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (i < ctx->parts.nelts)) {
#line 183
      goto while_break;
    }
#line 184
    if ((part + i)->percent) {
#line 184
      sum += (part + i)->percent;
    } else {
#line 184
      sum = (uint32_t )10000;
    }
#line 185
    if (sum > 10000U) {
      {
#line 186
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "percent total is greater than 100%%");
      }
#line 188
      return ((char *)((void *)-1));
    }
#line 191
    if ((part + i)->percent) {
#line 192
      last = (uint32_t )((uint64_t )last + ((uint64_t )(part + i)->percent * 4294967295UL) / 10000UL);
#line 193
      (part + i)->percent = last;
    }
#line 183
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (rv);
}
}
#line 201 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_split_clients_module.c"
static char *ngx_http_split_clients(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  ngx_int_t n ;
  ngx_str_t *value ;
  ngx_http_split_clients_ctx_t *ctx ;
  ngx_http_split_clients_part_t *part ;
  void *tmp ;
  char *__cil_tmp9 ;

  {
  {
#line 209
  ctx = (ngx_http_split_clients_ctx_t *)cf->ctx;
#line 210
  value = (ngx_str_t *)(cf->args)->elts;
#line 212
  tmp = ngx_array_push(& ctx->parts);
#line 212
  part = (ngx_http_split_clients_part_t *)tmp;
  }
#line 213
  if ((unsigned long )part == (unsigned long )((void *)0)) {
#line 214
    return ((char *)((void *)-1));
  }
#line 217
  if ((value + 0)->len == 1UL) {
#line 217
    if ((int )*((value + 0)->data + 0) == 42) {
#line 218
      part->percent = (uint32_t )0;
    } else {
#line 217
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 221
    if ((value + 0)->len == 0UL) {
#line 222
      goto invalid;
    } else
#line 221
    if ((int )*((value + 0)->data + ((value + 0)->len - 1UL)) != 37) {
#line 222
      goto invalid;
    }
    {
#line 225
    n = ngx_atofp((value + 0)->data, (value + 0)->len - 1UL, (size_t )2);
    }
#line 226
    if (n == -1L) {
#line 227
      goto invalid;
    } else
#line 226
    if (n == 0L) {
#line 227
      goto invalid;
    }
#line 230
    part->percent = (uint32_t )n;
  }
#line 233
  part->value.len = (unsigned int )(value + 1)->len;
#line 234
  part->value.valid = 1U;
#line 235
  part->value.no_cacheable = 0U;
#line 236
  part->value.not_found = 0U;
#line 237
  part->value.data = (value + 1)->data;
#line 239
  return ((char *)((void *)0));
  invalid: 
  {
#line 243
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid percent value \"%V\"", value + 0);
  }
#line 245
  return ((char *)((void *)-1));
}
}
#line 150 "src/core/ngx_string.h"
u_char *ngx_pstrdup(ngx_pool_t *pool , ngx_str_t *src ) ;
#line 75 "src/core/ngx_palloc.h"
ngx_pool_t *ngx_create_pool(size_t size , ngx_log_t *log ) ;
#line 270 "src/core/ngx_conf_file.h"
char *ngx_conf_include(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 104 "src/http/ngx_http_variables.h"
void *ngx_http_map_find(ngx_http_request_t *r , ngx_http_map_t *map___0 , ngx_str_t *match ) ;
#line 42 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
static int ngx_http_map_cmp_dns_wildcards(void const   *one , void const   *two ) ;
#line 44
static void *ngx_http_map_create_conf(ngx_conf_t *cf ) ;
#line 45
static char *ngx_http_map_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 46
static char *ngx_http_map(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 49 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
static ngx_command_t ngx_http_map_commands[4]  = {      {{sizeof("map") - 1UL, (u_char *)"map"}, (ngx_uint_t )33554692, & ngx_http_map_block,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("map_hash_max_size") - 1UL,
       (u_char *)"map_hash_max_size"}, (ngx_uint_t )33554434, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf), (unsigned long )(& ((ngx_http_map_conf_t *)0)->hash_max_size),
      (void *)0}, 
        {{sizeof("map_hash_bucket_size") - 1UL, (u_char *)"map_hash_bucket_size"}, (ngx_uint_t )33554434,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_map_conf_t *)0)->hash_bucket_size), (void *)0}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 76 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
static ngx_http_module_t ngx_http_map_module_ctx  = 
#line 76
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_map_create_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 91 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
ngx_module_t ngx_http_map_module  = 
#line 91
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_map_module_ctx),
    ngx_http_map_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 107 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
static ngx_int_t ngx_http_map_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) 
{ 
  ngx_http_map_ctx_t *map___0 ;
  ngx_str_t val ;
  ngx_str_t str ;
  ngx_http_complex_value_t *cv ;
  ngx_http_variable_value_t *value ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 111
  map___0 = (ngx_http_map_ctx_t *)data;
#line 120
  tmp = ngx_http_complex_value(r, & map___0->value, & val);
  }
#line 120
  if (tmp != 0L) {
#line 121
    return ((ngx_int_t )-1);
  }
#line 124
  if (map___0->hostnames) {
#line 124
    if (val.len > 0UL) {
#line 124
      if ((int )*(val.data + (val.len - 1UL)) == 46) {
#line 125
        (val.len) --;
      }
    }
  }
  {
#line 128
  tmp___0 = ngx_http_map_find(r, & map___0->map, & val);
#line 128
  value = (ngx_http_variable_value_t *)tmp___0;
  }
#line 130
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 131
    value = map___0->default_value;
  }
#line 134
  if (! value->valid) {
    {
#line 135
    cv = (ngx_http_complex_value_t *)value->data;
#line 137
    tmp___1 = ngx_http_complex_value(r, cv, & str);
    }
#line 137
    if (tmp___1 != 0L) {
#line 138
      return ((ngx_int_t )-1);
    }
#line 141
    v->valid = 1U;
#line 142
    v->no_cacheable = 0U;
#line 143
    v->not_found = 0U;
#line 144
    v->len = (unsigned int )str.len;
#line 145
    v->data = str.data;
  } else {
#line 148
    *v = *value;
  }
#line 154
  return ((ngx_int_t )0);
}
}
#line 158 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
static void *ngx_http_map_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_map_conf_t *mcf ;
  void *tmp ;

  {
  {
#line 163
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_map_conf_t ));
#line 163
  mcf = (ngx_http_map_conf_t *)tmp;
  }
#line 164
  if ((unsigned long )mcf == (unsigned long )((void *)0)) {
#line 165
    return ((void *)0);
  }
#line 168
  mcf->hash_max_size = (ngx_uint_t )-1;
#line 169
  mcf->hash_bucket_size = (ngx_uint_t )-1;
#line 171
  return ((void *)mcf);
}
}
#line 175 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
static char *ngx_http_map_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_map_conf_t *mcf ;
  char *rv ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_conf_t save ;
  ngx_pool_t *pool ;
  ngx_hash_init_t hash ;
  ngx_http_map_ctx_t *map___0 ;
  ngx_http_variable_t *var ;
  ngx_http_map_conf_ctx_t ctx ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 178
  mcf = (ngx_http_map_conf_t *)conf;
#line 190
  if (mcf->hash_max_size == 0xffffffffffffffffUL) {
#line 191
    mcf->hash_max_size = (ngx_uint_t )2048;
  }
#line 194
  if (mcf->hash_bucket_size == 0xffffffffffffffffUL) {
#line 195
    mcf->hash_bucket_size = ngx_cacheline_size;
  } else {
#line 198
    mcf->hash_bucket_size = (mcf->hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
  }
  {
#line 202
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_map_ctx_t ));
#line 202
  map___0 = (ngx_http_map_ctx_t *)tmp;
  }
#line 203
  if ((unsigned long )map___0 == (unsigned long )((void *)0)) {
#line 204
    return ((char *)((void *)-1));
  }
  {
#line 207
  value = (ngx_str_t *)(cf->args)->elts;
#line 209
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 211
  ccv.cf = cf;
#line 212
  ccv.value = value + 1;
#line 213
  ccv.complex_value = & map___0->value;
#line 215
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 215
  if (tmp___0 != 0L) {
#line 216
    return ((char *)((void *)-1));
  }
#line 219
  name = *(value + 2);
#line 221
  if ((int )*(name.data + 0) != 36) {
    {
#line 222
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", & name);
    }
#line 224
    return ((char *)((void *)-1));
  }
  {
#line 227
  (name.len) --;
#line 228
  (name.data) ++;
#line 230
  var = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
  }
#line 231
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 232
    return ((char *)((void *)-1));
  }
  {
#line 235
  var->get_handler = & ngx_http_map_variable;
#line 236
  var->data = (uintptr_t )map___0;
#line 238
  pool = ngx_create_pool((size_t )16384, cf->log);
  }
#line 239
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 240
    return ((char *)((void *)-1));
  }
  {
#line 243
  ctx.keys.pool = cf->pool;
#line 244
  ctx.keys.temp_pool = pool;
#line 246
  tmp___1 = ngx_hash_keys_array_init(& ctx.keys, (ngx_uint_t )2);
  }
#line 246
  if (tmp___1 != 0L) {
    {
#line 247
    ngx_destroy_pool(pool);
    }
#line 248
    return ((char *)((void *)-1));
  }
  {
#line 251
  tmp___2 = ngx_pcalloc(pool, sizeof(ngx_array_t ) * ctx.keys.hsize);
#line 251
  ctx.values_hash = (ngx_array_t *)tmp___2;
  }
#line 252
  if ((unsigned long )ctx.values_hash == (unsigned long )((void *)0)) {
    {
#line 253
    ngx_destroy_pool(pool);
    }
#line 254
    return ((char *)((void *)-1));
  }
  {
#line 258
  tmp___3 = ngx_array_init(& ctx.regexes, cf->pool, (ngx_uint_t )2, sizeof(ngx_http_map_regex_t ));
  }
#line 258
  if (tmp___3 != 0L) {
    {
#line 261
    ngx_destroy_pool(pool);
    }
#line 262
    return ((char *)((void *)-1));
  }
  {
#line 266
  ctx.default_value = (ngx_http_variable_value_t *)((void *)0);
#line 267
  ctx.cf = & save;
#line 268
  ctx.hostnames = 0U;
#line 269
  ctx.no_cacheable = 0U;
#line 271
  save = *cf;
#line 272
  cf->pool = pool;
#line 273
  cf->ctx = (void *)(& ctx);
#line 274
  cf->handler = & ngx_http_map;
#line 275
  cf->handler_conf = conf;
#line 277
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 279
  *cf = save;
  }
#line 281
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
    {
#line 282
    ngx_destroy_pool(pool);
    }
#line 283
    return (rv);
  }
#line 286
  if (ctx.no_cacheable) {
#line 287
    var->flags |= 2UL;
  }
#line 290
  if (ctx.default_value) {
#line 290
    map___0->default_value = ctx.default_value;
  } else {
#line 290
    map___0->default_value = & ngx_http_variable_null_value;
  }
#line 293
  map___0->hostnames = (ngx_uint_t )ctx.hostnames;
#line 295
  hash.key = & ngx_hash_key_lc;
#line 296
  hash.max_size = mcf->hash_max_size;
#line 297
  hash.bucket_size = mcf->hash_bucket_size;
#line 298
  hash.name = (char *)"map_hash";
#line 299
  hash.pool = cf->pool;
#line 301
  if (ctx.keys.keys.nelts) {
    {
#line 302
    hash.hash = & map___0->map.hash.hash;
#line 303
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 305
    tmp___4 = ngx_hash_init(& hash, (ngx_hash_key_t *)ctx.keys.keys.elts, ctx.keys.keys.nelts);
    }
#line 305
    if (tmp___4 != 0L) {
      {
#line 308
      ngx_destroy_pool(pool);
      }
#line 309
      return ((char *)((void *)-1));
    }
  }
#line 313
  if (ctx.keys.dns_wc_head.nelts) {
    {
#line 315
    qsort(ctx.keys.dns_wc_head.elts, ctx.keys.dns_wc_head.nelts, sizeof(ngx_hash_key_t ),
          & ngx_http_map_cmp_dns_wildcards);
#line 319
    hash.hash = (ngx_hash_t *)((void *)0);
#line 320
    hash.temp_pool = pool;
#line 322
    tmp___5 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)ctx.keys.dns_wc_head.elts,
                                     ctx.keys.dns_wc_head.nelts);
    }
#line 322
    if (tmp___5 != 0L) {
      {
#line 326
      ngx_destroy_pool(pool);
      }
#line 327
      return ((char *)((void *)-1));
    }
#line 330
    map___0->map.hash.wc_head = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 333
  if (ctx.keys.dns_wc_tail.nelts) {
    {
#line 335
    qsort(ctx.keys.dns_wc_tail.elts, ctx.keys.dns_wc_tail.nelts, sizeof(ngx_hash_key_t ),
          & ngx_http_map_cmp_dns_wildcards);
#line 339
    hash.hash = (ngx_hash_t *)((void *)0);
#line 340
    hash.temp_pool = pool;
#line 342
    tmp___6 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)ctx.keys.dns_wc_tail.elts,
                                     ctx.keys.dns_wc_tail.nelts);
    }
#line 342
    if (tmp___6 != 0L) {
      {
#line 346
      ngx_destroy_pool(pool);
      }
#line 347
      return ((char *)((void *)-1));
    }
#line 350
    map___0->map.hash.wc_tail = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 355
  if (ctx.regexes.nelts) {
#line 356
    map___0->map.regex = (ngx_http_map_regex_t *)ctx.regexes.elts;
#line 357
    map___0->map.nregex = ctx.regexes.nelts;
  }
  {
#line 362
  ngx_destroy_pool(pool);
  }
#line 364
  return (rv);
}
}
#line 368 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
static int ngx_http_map_cmp_dns_wildcards(void const   *one , void const   *two ) 
{ 
  ngx_hash_key_t *first ;
  ngx_hash_key_t *second ;
  ngx_int_t tmp ;

  {
  {
#line 373
  first = (ngx_hash_key_t *)one;
#line 374
  second = (ngx_hash_key_t *)two;
#line 376
  tmp = ngx_dns_strcmp(first->key.data, second->key.data);
  }
#line 376
  return ((int )tmp);
}
}
#line 380 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_map_module.c"
static char *ngx_http_map(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  u_char *data ;
  size_t len ;
  ngx_int_t rv ;
  ngx_str_t *value ;
  ngx_str_t v ;
  ngx_uint_t i ;
  ngx_uint_t key ;
  ngx_http_map_conf_ctx_t *ctx ;
  ngx_http_complex_value_t cv ;
  ngx_http_complex_value_t *cvp ;
  ngx_http_variable_value_t *var ;
  ngx_http_variable_value_t **vp ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  ngx_regex_compile_t rc ;
  ngx_http_map_regex_t *regex ;
  u_char errstr[1024] ;
  void *tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 393
  ctx = (ngx_http_map_conf_ctx_t *)cf->ctx;
#line 395
  value = (ngx_str_t *)(cf->args)->elts;
#line 397
  if ((cf->args)->nelts == 1UL) {
    {
#line 397
    tmp = strcmp((char const   *)(value + 0)->data, "hostnames");
    }
#line 397
    if (tmp == 0) {
#line 400
      ctx->hostnames = 1U;
#line 401
      return ((char *)((void *)0));
    }
  }
#line 404
  if ((cf->args)->nelts == 1UL) {
    {
#line 404
    tmp___0 = strcmp((char const   *)(value + 0)->data, "volatile");
    }
#line 404
    if (tmp___0 == 0) {
#line 407
      ctx->no_cacheable = 1U;
#line 408
      return ((char *)((void *)0));
    }
  }
#line 411
  if ((cf->args)->nelts != 2UL) {
    {
#line 412
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of the map parameters");
    }
#line 414
    return ((char *)((void *)-1));
  }
  {
#line 417
  tmp___2 = strcmp((char const   *)(value + 0)->data, "include");
  }
#line 417
  if (tmp___2 == 0) {
    {
#line 418
    tmp___1 = ngx_conf_include(cf, dummy, conf);
    }
#line 418
    return (tmp___1);
  }
#line 421
  key = (ngx_uint_t )0;
#line 423
  i = (ngx_uint_t )0;
  {
#line 423
  while (1) {
    while_continue: /* CIL Label */ ;
#line 423
    if (! (i < (value + 1)->len)) {
#line 423
      goto while_break;
    }
#line 424
    key = key * 31UL + (ngx_uint_t )*((value + 1)->data + i);
#line 423
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 427
  key %= ctx->keys.hsize;
#line 429
  vp = (ngx_http_variable_value_t **)(ctx->values_hash + key)->elts;
#line 431
  if (vp) {
#line 432
    i = (ngx_uint_t )0;
    {
#line 432
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 432
      if (! (i < (ctx->values_hash + key)->nelts)) {
#line 432
        goto while_break___0;
      }
#line 434
      if ((*(vp + i))->valid) {
#line 435
        data = (*(vp + i))->data;
#line 436
        len = (size_t )(*(vp + i))->len;
      } else {
#line 439
        cvp = (ngx_http_complex_value_t *)(*(vp + i))->data;
#line 440
        data = cvp->value.data;
#line 441
        len = cvp->value.len;
      }
#line 444
      if ((value + 1)->len != len) {
#line 445
        goto __Cont;
      }
      {
#line 448
      tmp___3 = strncmp((char const   *)(value + 1)->data, (char const   *)data, len);
      }
#line 448
      if (tmp___3 == 0) {
#line 449
        var = *(vp + i);
#line 450
        goto found;
      }
      __Cont: /* CIL Label */ 
#line 432
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 455
    tmp___4 = ngx_array_init(ctx->values_hash + key, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_variable_value_t *));
    }
#line 455
    if (tmp___4 != 0L) {
#line 459
      return ((char *)((void *)-1));
    }
  }
  {
#line 463
  tmp___5 = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_variable_value_t ));
#line 463
  var = (ngx_http_variable_value_t *)tmp___5;
  }
#line 464
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 465
    return ((char *)((void *)-1));
  }
  {
#line 468
  v.len = (value + 1)->len;
#line 469
  v.data = ngx_pstrdup(ctx->keys.pool, value + 1);
  }
#line 470
  if ((unsigned long )v.data == (unsigned long )((void *)0)) {
#line 471
    return ((char *)((void *)-1));
  }
  {
#line 474
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 476
  ccv.cf = ctx->cf;
#line 477
  ccv.value = & v;
#line 478
  ccv.complex_value = & cv;
#line 480
  tmp___6 = ngx_http_compile_complex_value(& ccv);
  }
#line 480
  if (tmp___6 != 0L) {
#line 481
    return ((char *)((void *)-1));
  }
#line 484
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 485
    tmp___7 = ngx_palloc(ctx->keys.pool, sizeof(ngx_http_complex_value_t ));
#line 485
    cvp = (ngx_http_complex_value_t *)tmp___7;
    }
#line 486
    if ((unsigned long )cvp == (unsigned long )((void *)0)) {
#line 487
      return ((char *)((void *)-1));
    }
#line 490
    *cvp = cv;
#line 492
    var->len = 0U;
#line 493
    var->data = (u_char *)cvp;
#line 494
    var->valid = 0U;
  } else {
#line 497
    var->len = (unsigned int )v.len;
#line 498
    var->data = v.data;
#line 499
    var->valid = 1U;
  }
  {
#line 502
  var->no_cacheable = 0U;
#line 503
  var->not_found = 0U;
#line 505
  tmp___8 = ngx_array_push(ctx->values_hash + key);
#line 505
  vp = (ngx_http_variable_value_t **)tmp___8;
  }
#line 506
  if ((unsigned long )vp == (unsigned long )((void *)0)) {
#line 507
    return ((char *)((void *)-1));
  }
#line 510
  *vp = var;
  found: 
  {
#line 514
  tmp___9 = strcmp((char const   *)(value + 0)->data, "default");
  }
#line 514
  if (tmp___9 == 0) {
#line 516
    if (ctx->default_value) {
      {
#line 517
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate default map parameter");
      }
#line 519
      return ((char *)((void *)-1));
    }
#line 522
    ctx->default_value = var;
#line 524
    return ((char *)((void *)0));
  }
#line 529
  if ((value + 0)->len) {
#line 529
    if ((int )*((value + 0)->data + 0) == 126) {
      {
#line 534
      tmp___10 = ngx_array_push(& ctx->regexes);
#line 534
      regex = (ngx_http_map_regex_t *)tmp___10;
      }
#line 535
      if ((unsigned long )regex == (unsigned long )((void *)0)) {
#line 536
        return ((char *)((void *)-1));
      }
      {
#line 539
      ((value + 0)->len) --;
#line 540
      ((value + 0)->data) ++;
#line 542
      memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
      }
#line 544
      if ((int )*((value + 0)->data + 0) == 42) {
#line 545
        ((value + 0)->len) --;
#line 546
        ((value + 0)->data) ++;
#line 547
        rc.options = (ngx_int_t )1;
      }
      {
#line 550
      rc.pattern = *(value + 0);
#line 551
      rc.err.len = (size_t )1024;
#line 552
      rc.err.data = errstr;
#line 554
      regex->regex = ngx_http_regex_compile(ctx->cf, & rc);
      }
#line 555
      if ((unsigned long )regex->regex == (unsigned long )((void *)0)) {
#line 556
        return ((char *)((void *)-1));
      }
#line 559
      regex->value = (void *)var;
#line 561
      return ((char *)((void *)0));
    }
  }
#line 566
  if ((value + 0)->len) {
#line 566
    if ((int )*((value + 0)->data + 0) == 92) {
#line 567
      ((value + 0)->len) --;
#line 568
      ((value + 0)->data) ++;
    }
  }
#line 571
  if (ctx->hostnames) {
#line 571
    tmp___11 = 1;
  } else {
#line 571
    tmp___11 = 0;
  }
  {
#line 571
  rv = ngx_hash_add_key(& ctx->keys, value + 0, (void *)var, (ngx_uint_t )tmp___11);
  }
#line 574
  if (rv == 0L) {
#line 575
    return ((char *)((void *)0));
  }
#line 578
  if (rv == -5L) {
    {
#line 579
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid hostname or wildcard \"%V\"",
                       value + 0);
    }
  }
#line 583
  if (rv == -3L) {
    {
#line 584
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "conflicting parameter \"%V\"", value + 0);
    }
  }
#line 588
  return ((char *)((void *)-1));
}
}
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 220
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 51 "src/core/ngx_rbtree.h"
void ngx_rbtree_insert(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) ;
#line 67 "src/core/ngx_string.h"
__inline static u_char *ngx_strlchr(u_char *p , u_char *last , u_char c ) 
{ 


  {
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 70
      goto while_break;
    }
#line 72
    if ((int )*p == (int )c) {
#line 73
      return (p);
    }
#line 76
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return ((u_char *)((void *)0));
}
}
#line 221
void ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                 ngx_rbtree_node_t *sentinel ) ;
#line 223
ngx_str_node_t *ngx_str_rbtree_lookup(ngx_rbtree_t *rbtree , ngx_str_t *val , uint32_t hash ) ;
#line 122 "src/os/unix/ngx_files.h"
ssize_t ngx_read_file(ngx_file_t *file , u_char *buf , size_t size , off_t offset ) ;
#line 193
ngx_int_t ngx_create_file_mapping(ngx_file_mapping_t *fm ) ;
#line 194
void ngx_close_file_mapping(ngx_file_mapping_t *fm ) ;
#line 77 "src/core/ngx_palloc.h"
void ngx_reset_pool(ngx_pool_t *pool ) ;
#line 37 "src/core/ngx_radix_tree.h"
ngx_radix_tree_t *ngx_radix_tree_create(ngx_pool_t *pool , ngx_int_t preallocate ) ;
#line 40
ngx_int_t ngx_radix32tree_insert(ngx_radix_tree_t *tree , uint32_t key , uint32_t mask ,
                                 uintptr_t value ) ;
#line 42
ngx_int_t ngx_radix32tree_delete(ngx_radix_tree_t *tree , uint32_t key , uint32_t mask ) ;
#line 44
uintptr_t ngx_radix32tree_find(ngx_radix_tree_t *tree , uint32_t key ) ;
#line 47
ngx_int_t ngx_radix128tree_insert(ngx_radix_tree_t *tree , u_char *key , u_char *mask ,
                                  uintptr_t value ) ;
#line 49
ngx_int_t ngx_radix128tree_delete(ngx_radix_tree_t *tree , u_char *key , u_char *mask ) ;
#line 51
uintptr_t ngx_radix128tree_find(ngx_radix_tree_t *tree , u_char *key ) ;
#line 108 "src/core/ngx_inet.h"
in_addr_t ngx_inet_addr(u_char *text , size_t len ) ;
#line 116
ngx_int_t ngx_ptocidr(ngx_str_t *text , ngx_cidr_t *cidr ) ;
#line 118
ngx_int_t ngx_parse_addr(ngx_pool_t *pool , ngx_addr_t *addr , u_char *text , size_t len ) ;
#line 273 "src/core/ngx_conf_file.h"
ngx_int_t ngx_conf_full_name(ngx_cycle_t *cycle , ngx_str_t *name , ngx_uint_t conf_prefix ) ;
#line 54 "src/http/ngx_http_variables.h"
ngx_http_variable_value_t *ngx_http_get_flushed_variable(ngx_http_request_t *r , ngx_uint_t index___0 ) ;
#line 523 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r , ngx_addr_t *addr , ngx_array_t *headers ,
                                      ngx_str_t *value , ngx_array_t *proxies , int recursive ) ;
#line 82 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_addr(ngx_http_request_t *r , ngx_http_geo_ctx_t *ctx ,
                                   ngx_addr_t *addr ) ;
#line 84
static ngx_int_t ngx_http_geo_real_addr(ngx_http_request_t *r , ngx_http_geo_ctx_t *ctx ,
                                        ngx_addr_t *addr ) ;
#line 86
static char *ngx_http_geo_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 87
static char *ngx_http_geo(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 88
static char *ngx_http_geo_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx , ngx_str_t *value ) ;
#line 90
static char *ngx_http_geo_add_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                    in_addr_t start , in_addr_t end ) ;
#line 92
static ngx_uint_t ngx_http_geo_delete_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                            in_addr_t start , in_addr_t end ) ;
#line 94
static char *ngx_http_geo_cidr(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx , ngx_str_t *value ) ;
#line 96
static char *ngx_http_geo_cidr_add(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                   ngx_cidr_t *cidr , ngx_str_t *value , ngx_str_t *net ) ;
#line 98
static ngx_http_variable_value_t *ngx_http_geo_value(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                                     ngx_str_t *value ) ;
#line 100
static char *ngx_http_geo_add_proxy(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                    ngx_cidr_t *cidr ) ;
#line 102
static ngx_int_t ngx_http_geo_cidr_value(ngx_conf_t *cf , ngx_str_t *net , ngx_cidr_t *cidr ) ;
#line 104
static char *ngx_http_geo_include(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                  ngx_str_t *name ) ;
#line 106
static ngx_int_t ngx_http_geo_include_binary_base(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                                  ngx_str_t *name ) ;
#line 108
static void ngx_http_geo_create_binary_base(ngx_http_geo_conf_ctx_t *ctx ) ;
#line 109
static u_char *ngx_http_geo_copy_values(u_char *base , u_char *p , ngx_rbtree_node_t *node ,
                                        ngx_rbtree_node_t *sentinel ) ;
#line 113 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_command_t ngx_http_geo_commands[2]  = {      {{sizeof("geo") - 1UL, (u_char *)"geo"}, (ngx_uint_t )33554694, & ngx_http_geo_block,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 126 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_http_module_t ngx_http_geo_module_ctx  = 
#line 126
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 141 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
ngx_module_t ngx_http_geo_module  = 
#line 141
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_geo_module_ctx),
    ngx_http_geo_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 166 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_http_geo_header_t ngx_http_geo_header  =    {{(u_char )'G', (u_char )'E', (u_char )'O', (u_char )'R', (u_char )'N', (u_char )'G'},
    (u_char )0, (u_char )sizeof(void *), (uint32_t )305419896, (uint32_t )0};
#line 173 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_cidr_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) 
{ 
  ngx_http_geo_ctx_t *ctx ;
  in_addr_t inaddr ;
  ngx_addr_t addr ;
  struct sockaddr_in *sin ;
  ngx_http_variable_value_t *vv ;
  u_char *p ;
  struct in6_addr *inaddr6 ;
  uintptr_t tmp ;
  ngx_int_t tmp___0 ;
  uintptr_t tmp___1 ;
  uintptr_t tmp___2 ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___3 ;
  int tmp___4 ;
  uintptr_t tmp___5 ;

  {
  {
#line 177
  ctx = (ngx_http_geo_ctx_t *)data;
#line 188
  tmp___0 = ngx_http_geo_addr(r, ctx, & addr);
  }
#line 188
  if (tmp___0 != 0L) {
    {
#line 189
    tmp = ngx_radix32tree_find(ctx->u.trees.tree, 4294967295U);
#line 189
    vv = (ngx_http_variable_value_t *)tmp;
    }
#line 191
    goto done;
  }
  {
#line 197
  if ((int )(addr.sockaddr)->sa_family == 10) {
#line 197
    goto case_10;
  }
#line 218
  goto switch_default;
  case_10: /* CIL Label */ 
#line 198
  inaddr6 = & ((struct sockaddr_in6 *)addr.sockaddr)->sin6_addr;
#line 199
  p = inaddr6->__in6_u.__u6_addr8;
#line 201
  __a = (struct in6_addr  const  *)inaddr6;
#line 201
  if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 201
    if (__a->__in6_u.__u6_addr32[1] == 0U) {
      {
#line 201
      tmp___3 = htonl((uint32_t )65535);
      }
#line 201
      if (__a->__in6_u.__u6_addr32[2] == tmp___3) {
#line 201
        tmp___4 = 1;
      } else {
#line 201
        tmp___4 = 0;
      }
    } else {
#line 201
      tmp___4 = 0;
    }
  } else {
#line 201
    tmp___4 = 0;
  }
#line 201
  if (tmp___4) {
    {
#line 202
    inaddr = (in_addr_t )((int )*(p + 12) << 24);
#line 203
    inaddr += (in_addr_t )((int )*(p + 13) << 16);
#line 204
    inaddr += (in_addr_t )((int )*(p + 14) << 8);
#line 205
    inaddr += (in_addr_t )*(p + 15);
#line 207
    tmp___1 = ngx_radix32tree_find(ctx->u.trees.tree, inaddr);
#line 207
    vv = (ngx_http_variable_value_t *)tmp___1;
    }
  } else {
    {
#line 211
    tmp___2 = ngx_radix128tree_find(ctx->u.trees.tree6, p);
#line 211
    vv = (ngx_http_variable_value_t *)tmp___2;
    }
  }
#line 215
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 219
  sin = (struct sockaddr_in *)addr.sockaddr;
#line 220
  inaddr = ntohl(sin->sin_addr.s_addr);
#line 222
  tmp___5 = ngx_radix32tree_find(ctx->u.trees.tree, inaddr);
#line 222
  vv = (ngx_http_variable_value_t *)tmp___5;
  }
#line 225
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  done: 
#line 230
  *v = *vv;
#line 235
  return ((ngx_int_t )0);
}
}
#line 239 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_range_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                             uintptr_t data ) 
{ 
  ngx_http_geo_ctx_t *ctx ;
  in_addr_t inaddr ;
  ngx_addr_t addr ;
  ngx_uint_t n ;
  struct sockaddr_in *sin ;
  ngx_http_geo_range_t *range ;
  u_char *p ;
  struct in6_addr *inaddr6 ;
  struct in6_addr  const  *__a ;
  uint32_t tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 243
  ctx = (ngx_http_geo_ctx_t *)data;
#line 255
  *v = *(ctx->u.high.default_value);
#line 257
  tmp___1 = ngx_http_geo_addr(r, ctx, & addr);
  }
#line 257
  if (tmp___1 == 0L) {
    {
#line 262
    if ((int )(addr.sockaddr)->sa_family == 10) {
#line 262
      goto case_10;
    }
#line 280
    goto switch_default;
    case_10: /* CIL Label */ 
#line 263
    inaddr6 = & ((struct sockaddr_in6 *)addr.sockaddr)->sin6_addr;
#line 265
    __a = (struct in6_addr  const  *)inaddr6;
#line 265
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 265
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
        {
#line 265
        tmp = htonl((uint32_t )65535);
        }
#line 265
        if (__a->__in6_u.__u6_addr32[2] == tmp) {
#line 265
          tmp___0 = 1;
        } else {
#line 265
          tmp___0 = 0;
        }
      } else {
#line 265
        tmp___0 = 0;
      }
    } else {
#line 265
      tmp___0 = 0;
    }
#line 265
    if (tmp___0) {
#line 266
      p = inaddr6->__in6_u.__u6_addr8;
#line 268
      inaddr = (in_addr_t )((int )*(p + 12) << 24);
#line 269
      inaddr += (in_addr_t )((int )*(p + 13) << 16);
#line 270
      inaddr += (in_addr_t )((int )*(p + 14) << 8);
#line 271
      inaddr += (in_addr_t )*(p + 15);
    } else {
#line 274
      inaddr = 4294967295U;
    }
#line 277
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 281
    sin = (struct sockaddr_in *)addr.sockaddr;
#line 282
    inaddr = ntohl(sin->sin_addr.s_addr);
    }
#line 283
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 287
    inaddr = 4294967295U;
  }
#line 290
  if (ctx->u.high.low) {
#line 291
    range = *(ctx->u.high.low + (inaddr >> 16));
#line 293
    if (range) {
#line 294
      n = (ngx_uint_t )(inaddr & 65535U);
      {
#line 295
      while (1) {
        while_continue: /* CIL Label */ ;
#line 296
        if (n >= (ngx_uint_t )range->start) {
#line 296
          if (n <= (ngx_uint_t )range->end) {
#line 299
            *v = *(range->value);
#line 300
            goto while_break;
          }
        }
#line 295
        range ++;
#line 295
        if (! range->value) {
#line 295
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 309
  return ((ngx_int_t )0);
}
}
#line 313 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_addr(ngx_http_request_t *r , ngx_http_geo_ctx_t *ctx ,
                                   ngx_addr_t *addr ) 
{ 
  ngx_array_t *xfwd ;
  ngx_int_t tmp ;

  {
  {
#line 319
  tmp = ngx_http_geo_real_addr(r, ctx, addr);
  }
#line 319
  if (tmp != 0L) {
#line 320
    return ((ngx_int_t )-1);
  }
#line 323
  xfwd = & r->headers_in.x_forwarded_for;
#line 325
  if (xfwd->nelts > 0UL) {
#line 325
    if ((unsigned long )ctx->proxies != (unsigned long )((void *)0)) {
      {
#line 326
      ngx_http_get_forwarded_addr(r, addr, xfwd, (ngx_str_t *)((void *)0), ctx->proxies,
                                  (int )ctx->proxy_recursive);
      }
    }
  }
#line 330
  return ((ngx_int_t )0);
}
}
#line 334 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_real_addr(ngx_http_request_t *r , ngx_http_geo_ctx_t *ctx ,
                                        ngx_addr_t *addr ) 
{ 
  ngx_http_variable_value_t *v ;
  ngx_int_t tmp ;

  {
#line 340
  if (ctx->index == -1L) {
#line 344
    addr->sockaddr = (r->connection)->sockaddr;
#line 345
    addr->socklen = (r->connection)->socklen;
#line 348
    return ((ngx_int_t )0);
  }
  {
#line 351
  v = ngx_http_get_flushed_variable(r, (ngx_uint_t )ctx->index);
  }
#line 353
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 357
    return ((ngx_int_t )-1);
  } else
#line 353
  if (v->not_found) {
#line 357
    return ((ngx_int_t )-1);
  }
  {
#line 363
  tmp = ngx_parse_addr(r->pool, addr, v->data, (size_t )v->len);
  }
#line 363
  if (tmp == 0L) {
#line 364
    return ((ngx_int_t )0);
  }
#line 367
  return ((ngx_int_t )-1);
}
}
#line 385 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static struct in6_addr zero  ;
#line 371 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  size_t len ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_pool_t *pool ;
  ngx_array_t *a ;
  ngx_http_variable_t *var ;
  ngx_http_geo_ctx_t *geo ;
  ngx_http_geo_conf_ctx_t ctx ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 388
  value = (ngx_str_t *)(cf->args)->elts;
#line 390
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_geo_ctx_t ));
#line 390
  geo = (ngx_http_geo_ctx_t *)tmp;
  }
#line 391
  if ((unsigned long )geo == (unsigned long )((void *)0)) {
#line 392
    return ((char *)((void *)-1));
  }
#line 395
  name = *(value + 1);
#line 397
  if ((int )*(name.data + 0) != 36) {
    {
#line 398
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", & name);
    }
#line 400
    return ((char *)((void *)-1));
  }
#line 403
  (name.len) --;
#line 404
  (name.data) ++;
#line 406
  if ((cf->args)->nelts == 3UL) {
    {
#line 408
    geo->index = ngx_http_get_variable_index(cf, & name);
    }
#line 409
    if (geo->index == -1L) {
#line 410
      return ((char *)((void *)-1));
    }
#line 413
    name = *(value + 2);
#line 415
    if ((int )*(name.data + 0) != 36) {
      {
#line 416
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"%V\"", & name);
      }
#line 418
      return ((char *)((void *)-1));
    }
#line 421
    (name.len) --;
#line 422
    (name.data) ++;
  } else {
#line 425
    geo->index = (ngx_int_t )-1;
  }
  {
#line 428
  var = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
  }
#line 429
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 430
    return ((char *)((void *)-1));
  }
  {
#line 433
  pool = ngx_create_pool((size_t )16384, cf->log);
  }
#line 434
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 435
    return ((char *)((void *)-1));
  }
  {
#line 438
  memset((void *)(& ctx), 0, sizeof(ngx_http_geo_conf_ctx_t ));
#line 440
  ctx.temp_pool = ngx_create_pool((size_t )16384, cf->log);
  }
#line 441
  if ((unsigned long )ctx.temp_pool == (unsigned long )((void *)0)) {
#line 442
    return ((char *)((void *)-1));
  }
  {
#line 445
  ctx.sentinel.color = (u_char )0;
#line 445
  ctx.rbtree.root = & ctx.sentinel;
#line 445
  ctx.rbtree.sentinel = & ctx.sentinel;
#line 445
  ctx.rbtree.insert = & ngx_str_rbtree_insert_value;
#line 447
  ctx.pool = cf->pool;
#line 448
  ctx.data_size = (sizeof(ngx_http_geo_header_t ) + sizeof(ngx_http_variable_value_t )) + 65536UL * sizeof(ngx_http_geo_range_t *);
#line 451
  ctx.allow_binary_include = 1U;
#line 453
  save = *cf;
#line 454
  cf->pool = pool;
#line 455
  cf->ctx = (void *)(& ctx);
#line 456
  cf->handler = & ngx_http_geo;
#line 457
  cf->handler_conf = conf;
#line 459
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 461
  *cf = save;
#line 463
  geo->proxies = ctx.proxies;
#line 464
  geo->proxy_recursive = ctx.proxy_recursive;
  }
#line 466
  if (ctx.ranges) {
#line 468
    if (ctx.high.low) {
#line 468
      if (! ctx.binary_include) {
#line 469
        i = (ngx_uint_t )0;
        {
#line 469
        while (1) {
          while_continue: /* CIL Label */ ;
#line 469
          if (! (i < 65536UL)) {
#line 469
            goto while_break;
          }
#line 470
          a = (ngx_array_t *)*(ctx.high.low + i);
#line 472
          if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 473
            goto __Cont;
          }
#line 476
          if (a->nelts == 0UL) {
#line 477
            *(ctx.high.low + i) = (ngx_http_geo_range_t *)((void *)0);
#line 478
            goto __Cont;
          }
          {
#line 481
          len = a->nelts * sizeof(ngx_http_geo_range_t );
#line 483
          tmp___0 = ngx_palloc(cf->pool, len + sizeof(void *));
#line 483
          *(ctx.high.low + i) = (ngx_http_geo_range_t *)tmp___0;
          }
#line 484
          if ((unsigned long )*(ctx.high.low + i) == (unsigned long )((void *)0)) {
#line 485
            return ((char *)((void *)-1));
          }
          {
#line 488
          memcpy((void */* __restrict  */)*(ctx.high.low + i), (void const   */* __restrict  */)a->elts,
                 len);
#line 489
          (*(ctx.high.low + i) + a->nelts)->value = (ngx_http_variable_value_t *)((void *)0);
#line 490
          ctx.data_size += len + sizeof(void *);
          }
          __Cont: /* CIL Label */ 
#line 469
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 493
        if (ctx.allow_binary_include) {
#line 493
          if (! ctx.outside_entries) {
#line 493
            if (ctx.entries > 100000UL) {
#line 493
              if (ctx.includes == 1UL) {
                {
#line 498
                ngx_http_geo_create_binary_base(& ctx);
                }
              }
            }
          }
        }
      }
    }
#line 502
    if ((unsigned long )ctx.high.default_value == (unsigned long )((void *)0)) {
#line 503
      ctx.high.default_value = & ngx_http_variable_null_value;
    }
    {
#line 506
    geo->u.high = ctx.high;
#line 508
    var->get_handler = & ngx_http_geo_range_variable;
#line 509
    var->data = (uintptr_t )geo;
#line 511
    ngx_destroy_pool(ctx.temp_pool);
#line 512
    ngx_destroy_pool(pool);
    }
  } else {
#line 515
    if ((unsigned long )ctx.tree == (unsigned long )((void *)0)) {
      {
#line 516
      ctx.tree = ngx_radix_tree_create(cf->pool, (ngx_int_t )-1);
      }
#line 517
      if ((unsigned long )ctx.tree == (unsigned long )((void *)0)) {
#line 518
        return ((char *)((void *)-1));
      }
    }
#line 522
    geo->u.trees.tree = ctx.tree;
#line 525
    if ((unsigned long )ctx.tree6 == (unsigned long )((void *)0)) {
      {
#line 526
      ctx.tree6 = ngx_radix_tree_create(cf->pool, (ngx_int_t )-1);
      }
#line 527
      if ((unsigned long )ctx.tree6 == (unsigned long )((void *)0)) {
#line 528
        return ((char *)((void *)-1));
      }
    }
    {
#line 532
    geo->u.trees.tree6 = ctx.tree6;
#line 535
    var->get_handler = & ngx_http_geo_cidr_variable;
#line 536
    var->data = (uintptr_t )geo;
#line 538
    ngx_destroy_pool(ctx.temp_pool);
#line 539
    ngx_destroy_pool(pool);
#line 541
    tmp___1 = ngx_radix32tree_insert(ctx.tree, (uint32_t )0, (uint32_t )0, (uintptr_t )(& ngx_http_variable_null_value));
    }
#line 541
    if (tmp___1 == -1L) {
#line 545
      return ((char *)((void *)-1));
    }
    {
#line 551
    tmp___2 = ngx_radix128tree_insert(ctx.tree6, zero.__in6_u.__u6_addr8, zero.__in6_u.__u6_addr8,
                                      (uintptr_t )(& ngx_http_variable_null_value));
    }
#line 551
    if (tmp___2 == -1L) {
#line 555
      return ((char *)((void *)-1));
    }
  }
#line 560
  return (rv);
}
}
#line 564 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  char *rv ;
  ngx_str_t *value ;
  ngx_cidr_t cidr ;
  ngx_http_geo_conf_ctx_t *ctx ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 572
  ctx = (ngx_http_geo_conf_ctx_t *)cf->ctx;
#line 574
  value = (ngx_str_t *)(cf->args)->elts;
#line 576
  if ((cf->args)->nelts == 1UL) {
    {
#line 578
    tmp___0 = strcmp((char const   *)(value + 0)->data, "ranges");
    }
#line 578
    if (tmp___0 == 0) {
#line 580
      if (ctx->tree) {
        {
#line 586
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"ranges\" directive must be the first directive inside \"geo\" block");
        }
#line 589
        goto failed;
      } else
#line 580
      if (ctx->tree6) {
        {
#line 586
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"ranges\" directive must be the first directive inside \"geo\" block");
        }
#line 589
        goto failed;
      }
#line 592
      ctx->ranges = 1U;
#line 594
      rv = (char *)((void *)0);
#line 596
      goto done;
    } else {
      {
#line 599
      tmp = strcmp((char const   *)(value + 0)->data, "proxy_recursive");
      }
#line 599
      if (tmp == 0) {
#line 600
        ctx->proxy_recursive = 1U;
#line 601
        rv = (char *)((void *)0);
#line 602
        goto done;
      }
    }
  }
#line 606
  if ((cf->args)->nelts != 2UL) {
    {
#line 607
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of the geo parameters");
    }
#line 609
    goto failed;
  }
  {
#line 612
  tmp___3 = strcmp((char const   *)(value + 0)->data, "include");
  }
#line 612
  if (tmp___3 == 0) {
    {
#line 614
    rv = ngx_http_geo_include(cf, ctx, value + 1);
    }
#line 616
    goto done;
  } else {
    {
#line 618
    tmp___2 = strcmp((char const   *)(value + 0)->data, "proxy");
    }
#line 618
    if (tmp___2 == 0) {
      {
#line 620
      tmp___1 = ngx_http_geo_cidr_value(cf, value + 1, & cidr);
      }
#line 620
      if (tmp___1 != 0L) {
#line 621
        goto failed;
      }
      {
#line 624
      rv = ngx_http_geo_add_proxy(cf, ctx, & cidr);
      }
#line 626
      goto done;
    }
  }
#line 629
  if (ctx->ranges) {
    {
#line 630
    rv = ngx_http_geo_range(cf, ctx, value);
    }
  } else {
    {
#line 633
    rv = ngx_http_geo_cidr(cf, ctx, value);
    }
  }
  done: 
  {
#line 638
  ngx_reset_pool(cf->pool);
  }
#line 640
  return (rv);
  failed: 
  {
#line 644
  ngx_reset_pool(cf->pool);
  }
#line 646
  return ((char *)((void *)-1));
}
}
#line 650 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx , ngx_str_t *value ) 
{ 
  u_char *p ;
  u_char *last ;
  in_addr_t start ;
  in_addr_t end ;
  ngx_str_t *net ;
  ngx_uint_t del ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  ngx_uint_t tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 659
  tmp = strcmp((char const   *)(value + 0)->data, "default");
  }
#line 659
  if (tmp == 0) {
#line 661
    if (ctx->high.default_value) {
      {
#line 662
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate default geo range value: \"%V\", old value: \"%v\"",
                         value + 1, ctx->high.default_value);
      }
    }
    {
#line 667
    ctx->high.default_value = ngx_http_geo_value(cf, ctx, value + 1);
    }
#line 668
    if ((unsigned long )ctx->high.default_value == (unsigned long )((void *)0)) {
#line 669
      return ((char *)((void *)-1));
    }
#line 672
    return ((char *)((void *)0));
  }
#line 675
  if (ctx->binary_include) {
    {
#line 676
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "binary geo range base \"%s\" cannot be mixed with usual entries",
                       ctx->include_name.data);
    }
#line 679
    return ((char *)((void *)-1));
  }
#line 682
  if ((unsigned long )ctx->high.low == (unsigned long )((void *)0)) {
    {
#line 683
    tmp___0 = ngx_pcalloc(ctx->pool, 65536UL * sizeof(ngx_http_geo_range_t *));
#line 683
    ctx->high.low = (ngx_http_geo_range_t **)tmp___0;
    }
#line 685
    if ((unsigned long )ctx->high.low == (unsigned long )((void *)0)) {
#line 686
      return ((char *)((void *)-1));
    }
  }
  {
#line 690
  (ctx->entries) ++;
#line 691
  ctx->outside_entries = 1U;
#line 693
  tmp___1 = strcmp((char const   *)(value + 0)->data, "delete");
  }
#line 693
  if (tmp___1 == 0) {
#line 694
    net = value + 1;
#line 695
    del = (ngx_uint_t )1;
  } else {
#line 698
    net = value + 0;
#line 699
    del = (ngx_uint_t )0;
  }
  {
#line 702
  last = net->data + net->len;
#line 704
  p = ngx_strlchr(net->data, last, (u_char )'-');
  }
#line 706
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 707
    goto invalid;
  }
  {
#line 710
  start = ngx_inet_addr(net->data, (size_t )(p - net->data));
  }
#line 712
  if (start == 4294967295U) {
#line 713
    goto invalid;
  }
  {
#line 716
  start = ntohl(start);
#line 718
  p ++;
#line 720
  end = ngx_inet_addr(p, (size_t )(last - p));
  }
#line 722
  if (end == 4294967295U) {
#line 723
    goto invalid;
  }
  {
#line 726
  end = ntohl(end);
  }
#line 728
  if (start > end) {
#line 729
    goto invalid;
  }
#line 732
  if (del) {
    {
#line 733
    tmp___2 = ngx_http_geo_delete_range(cf, ctx, start, end);
    }
#line 733
    if (tmp___2) {
      {
#line 734
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no address range \"%V\" to delete",
                         net);
      }
    }
#line 738
    return ((char *)((void *)0));
  }
  {
#line 741
  ctx->value = ngx_http_geo_value(cf, ctx, value + 1);
  }
#line 743
  if ((unsigned long )ctx->value == (unsigned long )((void *)0)) {
#line 744
    return ((char *)((void *)-1));
  }
  {
#line 747
  ctx->net = net;
#line 749
  tmp___3 = ngx_http_geo_add_range(cf, ctx, start, end);
  }
#line 749
  return (tmp___3);
  invalid: 
  {
#line 753
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid range \"%V\"", net);
  }
#line 755
  return ((char *)((void *)-1));
}
}
#line 761 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_add_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                    in_addr_t start , in_addr_t end ) 
{ 
  in_addr_t n ;
  ngx_uint_t h ;
  ngx_uint_t i ;
  ngx_uint_t s ;
  ngx_uint_t e ;
  ngx_array_t *a ;
  ngx_http_geo_range_t *range ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 770
  n = start;
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (n <= end)) {
#line 770
      goto while_break;
    }
#line 772
    h = (ngx_uint_t )(n >> 16);
#line 774
    if (n == start) {
#line 775
      s = (ngx_uint_t )(n & 65535U);
    } else {
#line 777
      s = (ngx_uint_t )0;
    }
#line 780
    if ((n | 65535U) > end) {
#line 781
      e = (ngx_uint_t )(end & 65535U);
    } else {
#line 784
      e = (ngx_uint_t )65535;
    }
#line 787
    a = (ngx_array_t *)*(ctx->high.low + h);
#line 789
    if ((unsigned long )a == (unsigned long )((void *)0)) {
      {
#line 790
      a = ngx_array_create(ctx->temp_pool, (ngx_uint_t )64, sizeof(ngx_http_geo_range_t ));
      }
#line 792
      if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 793
        return ((char *)((void *)-1));
      }
#line 796
      *(ctx->high.low + h) = (ngx_http_geo_range_t *)a;
    }
#line 799
    i = a->nelts;
#line 800
    range = (ngx_http_geo_range_t *)a->elts;
    {
#line 802
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 802
      if (! i) {
#line 802
        goto while_break___0;
      }
#line 804
      i --;
#line 806
      if (e < (ngx_uint_t )(range + i)->start) {
#line 807
        goto while_continue___0;
      }
#line 810
      if (s > (ngx_uint_t )(range + i)->end) {
        {
#line 814
        tmp = ngx_array_push(a);
#line 814
        range = (ngx_http_geo_range_t *)tmp;
        }
#line 815
        if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 816
          return ((char *)((void *)-1));
        }
        {
#line 819
        range = (ngx_http_geo_range_t *)a->elts;
#line 821
        memmove((void *)(range + (i + 2UL)), (void const   *)(range + (i + 1UL)),
                ((a->nelts - 2UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 824
        (range + (i + 1UL))->start = (u_short )s;
#line 825
        (range + (i + 1UL))->end = (u_short )e;
#line 826
        (range + (i + 1UL))->value = ctx->value;
        }
#line 828
        goto next;
      }
#line 831
      if (s == (ngx_uint_t )(range + i)->start) {
#line 831
        if (e == (ngx_uint_t )(range + i)->end) {
          {
#line 834
          ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate range \"%V\", value: \"%v\", old value: \"%v\"",
                             ctx->net, ctx->value, (range + i)->value);
#line 838
          (range + i)->value = ctx->value;
          }
#line 840
          goto next;
        }
      }
#line 843
      if (s > (ngx_uint_t )(range + i)->start) {
#line 843
        if (e < (ngx_uint_t )(range + i)->end) {
          {
#line 848
          tmp___0 = ngx_array_push(a);
#line 848
          range = (ngx_http_geo_range_t *)tmp___0;
          }
#line 849
          if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 850
            return ((char *)((void *)-1));
          }
          {
#line 853
          tmp___1 = ngx_array_push(a);
#line 853
          range = (ngx_http_geo_range_t *)tmp___1;
          }
#line 854
          if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 855
            return ((char *)((void *)-1));
          }
          {
#line 858
          range = (ngx_http_geo_range_t *)a->elts;
#line 860
          memmove((void *)(range + (i + 3UL)), (void const   *)(range + (i + 1UL)),
                  ((a->nelts - 3UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 863
          (range + (i + 2UL))->start = (u_short )(e + 1UL);
#line 864
          (range + (i + 2UL))->end = (range + i)->end;
#line 865
          (range + (i + 2UL))->value = (range + i)->value;
#line 867
          (range + (i + 1UL))->start = (u_short )s;
#line 868
          (range + (i + 1UL))->end = (u_short )e;
#line 869
          (range + (i + 1UL))->value = ctx->value;
#line 871
          (range + i)->end = (u_short )(s - 1UL);
          }
#line 873
          goto next;
        }
      }
#line 876
      if (s == (ngx_uint_t )(range + i)->start) {
#line 876
        if (e < (ngx_uint_t )(range + i)->end) {
          {
#line 881
          tmp___2 = ngx_array_push(a);
#line 881
          range = (ngx_http_geo_range_t *)tmp___2;
          }
#line 882
          if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 883
            return ((char *)((void *)-1));
          }
          {
#line 886
          range = (ngx_http_geo_range_t *)a->elts;
#line 888
          memmove((void *)(range + (i + 1UL)), (void const   *)(range + i), ((a->nelts - 1UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 891
          (range + (i + 1UL))->start = (u_short )(e + 1UL);
#line 893
          (range + i)->start = (u_short )s;
#line 894
          (range + i)->end = (u_short )e;
#line 895
          (range + i)->value = ctx->value;
          }
#line 897
          goto next;
        }
      }
#line 900
      if (s > (ngx_uint_t )(range + i)->start) {
#line 900
        if (e == (ngx_uint_t )(range + i)->end) {
          {
#line 905
          tmp___3 = ngx_array_push(a);
#line 905
          range = (ngx_http_geo_range_t *)tmp___3;
          }
#line 906
          if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 907
            return ((char *)((void *)-1));
          }
          {
#line 910
          range = (ngx_http_geo_range_t *)a->elts;
#line 912
          memmove((void *)(range + (i + 2UL)), (void const   *)(range + (i + 1UL)),
                  ((a->nelts - 2UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 915
          (range + (i + 1UL))->start = (u_short )s;
#line 916
          (range + (i + 1UL))->end = (u_short )e;
#line 917
          (range + (i + 1UL))->value = ctx->value;
#line 919
          (range + i)->end = (u_short )(s - 1UL);
          }
#line 921
          goto next;
        }
      }
      {
#line 924
      s = (ngx_uint_t )(range + i)->start;
#line 925
      e = (ngx_uint_t )(range + i)->end;
#line 927
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "range \"%V\" overlaps \"%d.%d.%d.%d-%d.%d.%d.%d\"",
                         ctx->net, h >> 8, h & 255UL, s >> 8, s & 255UL, h >> 8, h & 255UL,
                         e >> 8, e & 255UL);
      }
#line 933
      return ((char *)((void *)-1));
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 938
    tmp___4 = ngx_array_push(a);
#line 938
    range = (ngx_http_geo_range_t *)tmp___4;
    }
#line 939
    if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 940
      return ((char *)((void *)-1));
    }
    {
#line 943
    range = (ngx_http_geo_range_t *)a->elts;
#line 945
    memmove((void *)(range + 1), (void const   *)(range + 0), (a->nelts - 1UL) * sizeof(ngx_http_geo_range_t ));
#line 948
    (range + 0)->start = (u_short )s;
#line 949
    (range + 0)->end = (u_short )e;
#line 950
    (range + 0)->value = ctx->value;
    }
    next: 
#line 954
    if (h == 65535UL) {
#line 955
      goto while_break;
    }
#line 770
    n = (n + 65536U) & 4294901760U;
  }
  while_break: /* CIL Label */ ;
  }
#line 959
  return ((char *)((void *)0));
}
}
#line 963 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_uint_t ngx_http_geo_delete_range(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                            in_addr_t start , in_addr_t end ) 
{ 
  in_addr_t n ;
  ngx_uint_t h ;
  ngx_uint_t i ;
  ngx_uint_t s ;
  ngx_uint_t e ;
  ngx_uint_t warn ;
  ngx_array_t *a ;
  ngx_http_geo_range_t *range ;

  {
#line 972
  warn = (ngx_uint_t )0;
#line 974
  n = start;
  {
#line 974
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    if (! (n <= end)) {
#line 974
      goto while_break;
    }
#line 976
    h = (ngx_uint_t )(n >> 16);
#line 978
    if (n == start) {
#line 979
      s = (ngx_uint_t )(n & 65535U);
    } else {
#line 981
      s = (ngx_uint_t )0;
    }
#line 984
    if ((n | 65535U) > end) {
#line 985
      e = (ngx_uint_t )(end & 65535U);
    } else {
#line 988
      e = (ngx_uint_t )65535;
    }
#line 991
    a = (ngx_array_t *)*(ctx->high.low + h);
#line 993
    if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 994
      warn = (ngx_uint_t )1;
#line 995
      goto next;
    } else
#line 993
    if (a->nelts == 0UL) {
#line 994
      warn = (ngx_uint_t )1;
#line 995
      goto next;
    }
#line 998
    range = (ngx_http_geo_range_t *)a->elts;
#line 999
    i = (ngx_uint_t )0;
    {
#line 999
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 999
      if (! (i < a->nelts)) {
#line 999
        goto while_break___0;
      }
#line 1001
      if (s == (ngx_uint_t )(range + i)->start) {
#line 1001
        if (e == (ngx_uint_t )(range + i)->end) {
          {
#line 1004
          memmove((void *)(range + i), (void const   *)(range + (i + 1UL)), ((a->nelts - 1UL) - i) * sizeof(ngx_http_geo_range_t ));
#line 1007
          (a->nelts) --;
          }
#line 1009
          goto while_break___0;
        }
      }
#line 1012
      if (i == a->nelts - 1UL) {
#line 1013
        warn = (ngx_uint_t )1;
      }
#line 999
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    next: 
#line 1019
    if (h == 65535UL) {
#line 1020
      goto while_break;
    }
#line 974
    n = (n + 65536U) & 4294901760U;
  }
  while_break: /* CIL Label */ ;
  }
#line 1024
  return (warn);
}
}
#line 1028 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_cidr(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx , ngx_str_t *value ) 
{ 
  char *rv ;
  ngx_int_t rc ;
  ngx_int_t del ;
  ngx_str_t *net ;
  ngx_cidr_t cidr ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  char *tmp___2 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1037
  if ((unsigned long )ctx->tree == (unsigned long )((void *)0)) {
    {
#line 1038
    ctx->tree = ngx_radix_tree_create(ctx->pool, (ngx_int_t )-1);
    }
#line 1039
    if ((unsigned long )ctx->tree == (unsigned long )((void *)0)) {
#line 1040
      return ((char *)((void *)-1));
    }
  }
#line 1045
  if ((unsigned long )ctx->tree6 == (unsigned long )((void *)0)) {
    {
#line 1046
    ctx->tree6 = ngx_radix_tree_create(ctx->pool, (ngx_int_t )-1);
    }
#line 1047
    if ((unsigned long )ctx->tree6 == (unsigned long )((void *)0)) {
#line 1048
      return ((char *)((void *)-1));
    }
  }
  {
#line 1053
  tmp = strcmp((char const   *)(value + 0)->data, "default");
  }
#line 1053
  if (tmp == 0) {
    {
#line 1054
    cidr.family = (ngx_uint_t )2;
#line 1055
    cidr.u.in.addr = (in_addr_t )0;
#line 1056
    cidr.u.in.mask = (in_addr_t )0;
#line 1058
    rv = ngx_http_geo_cidr_add(cf, ctx, & cidr, value + 1, value + 0);
    }
#line 1060
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 1061
      return (rv);
    }
    {
#line 1065
    cidr.family = (ngx_uint_t )10;
#line 1066
    memset((void *)(& cidr.u.in6), 0, sizeof(ngx_in6_cidr_t ));
#line 1068
    rv = ngx_http_geo_cidr_add(cf, ctx, & cidr, value + 1, value + 0);
    }
#line 1070
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 1071
      return (rv);
    }
#line 1075
    return ((char *)((void *)0));
  }
  {
#line 1078
  tmp___0 = strcmp((char const   *)(value + 0)->data, "delete");
  }
#line 1078
  if (tmp___0 == 0) {
#line 1079
    net = value + 1;
#line 1080
    del = (ngx_int_t )1;
  } else {
#line 1083
    net = value + 0;
#line 1084
    del = (ngx_int_t )0;
  }
  {
#line 1087
  tmp___1 = ngx_http_geo_cidr_value(cf, net, & cidr);
  }
#line 1087
  if (tmp___1 != 0L) {
#line 1088
    return ((char *)((void *)-1));
  }
#line 1091
  if (cidr.family == 2UL) {
    {
#line 1092
    cidr.u.in.addr = ntohl(cidr.u.in.addr);
#line 1093
    cidr.u.in.mask = ntohl(cidr.u.in.mask);
    }
  }
#line 1096
  if (del) {
    {
#line 1100
    if (cidr.family == 10UL) {
#line 1100
      goto case_10;
    }
#line 1107
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 1101
    rc = ngx_radix128tree_delete(ctx->tree6, cidr.u.in6.addr.__in6_u.__u6_addr8, cidr.u.in6.mask.__in6_u.__u6_addr8);
    }
#line 1104
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1108
    rc = ngx_radix32tree_delete(ctx->tree, cidr.u.in.addr, cidr.u.in.mask);
    }
#line 1110
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1113
    if (rc != 0L) {
      {
#line 1114
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "no network \"%V\" to delete", net);
      }
    }
#line 1118
    return ((char *)((void *)0));
  }
  {
#line 1121
  tmp___2 = ngx_http_geo_cidr_add(cf, ctx, & cidr, value + 1, net);
  }
#line 1121
  return (tmp___2);
}
}
#line 1125 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_cidr_add(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                   ngx_cidr_t *cidr , ngx_str_t *value , ngx_str_t *net ) 
{ 
  ngx_int_t rc ;
  ngx_http_variable_value_t *val ;
  ngx_http_variable_value_t *old ;
  uintptr_t tmp ;
  uintptr_t tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1132
  val = ngx_http_geo_value(cf, ctx, value);
  }
#line 1134
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1135
    return ((char *)((void *)-1));
  }
  {
#line 1141
  if (cidr->family == 10UL) {
#line 1141
    goto case_10;
  }
#line 1180
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1142
  rc = ngx_radix128tree_insert(ctx->tree6, cidr->u.in6.addr.__in6_u.__u6_addr8, cidr->u.in6.mask.__in6_u.__u6_addr8,
                               (uintptr_t )val);
  }
#line 1146
  if (rc == 0L) {
#line 1147
    return ((char *)((void *)0));
  }
#line 1150
  if (rc == -1L) {
#line 1151
    return ((char *)((void *)-1));
  }
  {
#line 1156
  tmp = ngx_radix128tree_find(ctx->tree6, cidr->u.in6.addr.__in6_u.__u6_addr8);
#line 1156
  old = (ngx_http_variable_value_t *)tmp;
#line 1160
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate network \"%V\", value: \"%v\", old value: \"%v\"",
                     net, val, old);
#line 1164
  rc = ngx_radix128tree_delete(ctx->tree6, cidr->u.in6.addr.__in6_u.__u6_addr8, cidr->u.in6.mask.__in6_u.__u6_addr8);
  }
#line 1168
  if (rc == -1L) {
    {
#line 1169
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid radix tree");
    }
#line 1170
    return ((char *)((void *)-1));
  }
  {
#line 1173
  rc = ngx_radix128tree_insert(ctx->tree6, cidr->u.in6.addr.__in6_u.__u6_addr8, cidr->u.in6.mask.__in6_u.__u6_addr8,
                               (uintptr_t )val);
  }
#line 1177
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1181
  rc = ngx_radix32tree_insert(ctx->tree, cidr->u.in.addr, cidr->u.in.mask, (uintptr_t )val);
  }
#line 1184
  if (rc == 0L) {
#line 1185
    return ((char *)((void *)0));
  }
#line 1188
  if (rc == -1L) {
#line 1189
    return ((char *)((void *)-1));
  }
  {
#line 1194
  tmp___0 = ngx_radix32tree_find(ctx->tree, cidr->u.in.addr);
#line 1194
  old = (ngx_http_variable_value_t *)tmp___0;
#line 1197
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate network \"%V\", value: \"%v\", old value: \"%v\"",
                     net, val, old);
#line 1201
  rc = ngx_radix32tree_delete(ctx->tree, cidr->u.in.addr, cidr->u.in.mask);
  }
#line 1204
  if (rc == -1L) {
    {
#line 1205
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid radix tree");
    }
#line 1206
    return ((char *)((void *)-1));
  }
  {
#line 1209
  rc = ngx_radix32tree_insert(ctx->tree, cidr->u.in.addr, cidr->u.in.mask, (uintptr_t )val);
  }
#line 1212
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1215
  if (rc == 0L) {
#line 1216
    return ((char *)((void *)0));
  }
#line 1219
  return ((char *)((void *)-1));
}
}
#line 1223 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_http_variable_value_t *ngx_http_geo_value(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                                     ngx_str_t *value ) 
{ 
  uint32_t hash ;
  ngx_http_variable_value_t *val ;
  ngx_http_geo_variable_value_node_t *gvvn ;
  ngx_str_node_t *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1231
  hash = ngx_crc32_long(value->data, value->len);
#line 1233
  tmp = ngx_str_rbtree_lookup(& ctx->rbtree, value, hash);
#line 1233
  gvvn = (ngx_http_geo_variable_value_node_t *)tmp;
  }
#line 1236
  if (gvvn) {
#line 1237
    return (gvvn->value);
  }
  {
#line 1240
  tmp___0 = ngx_palloc(ctx->pool, sizeof(ngx_http_variable_value_t ));
#line 1240
  val = (ngx_http_variable_value_t *)tmp___0;
  }
#line 1241
  if ((unsigned long )val == (unsigned long )((void *)0)) {
#line 1242
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 1245
  val->len = (unsigned int )value->len;
#line 1246
  val->data = ngx_pstrdup(ctx->pool, value);
  }
#line 1247
  if ((unsigned long )val->data == (unsigned long )((void *)0)) {
#line 1248
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 1251
  val->valid = 1U;
#line 1252
  val->no_cacheable = 0U;
#line 1253
  val->not_found = 0U;
#line 1255
  tmp___1 = ngx_palloc(ctx->temp_pool, sizeof(ngx_http_geo_variable_value_node_t ));
#line 1255
  gvvn = (ngx_http_geo_variable_value_node_t *)tmp___1;
  }
#line 1257
  if ((unsigned long )gvvn == (unsigned long )((void *)0)) {
#line 1258
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 1261
  gvvn->sn.node.key = (ngx_rbtree_key_t )hash;
#line 1262
  gvvn->sn.str.len = (size_t )val->len;
#line 1263
  gvvn->sn.str.data = val->data;
#line 1264
  gvvn->value = val;
#line 1265
  gvvn->offset = (size_t )0;
#line 1267
  ngx_rbtree_insert(& ctx->rbtree, & gvvn->sn.node);
#line 1269
  ctx->data_size += ((sizeof(ngx_http_variable_value_t ) + value->len) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL);
  }
#line 1272
  return (val);
}
}
#line 1276 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_add_proxy(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                    ngx_cidr_t *cidr ) 
{ 
  ngx_cidr_t *c ;
  void *tmp ;

  {
#line 1282
  if ((unsigned long )ctx->proxies == (unsigned long )((void *)0)) {
    {
#line 1283
    ctx->proxies = ngx_array_create(ctx->pool, (ngx_uint_t )4, sizeof(ngx_cidr_t ));
    }
#line 1284
    if ((unsigned long )ctx->proxies == (unsigned long )((void *)0)) {
#line 1285
      return ((char *)((void *)-1));
    }
  }
  {
#line 1289
  tmp = ngx_array_push(ctx->proxies);
#line 1289
  c = (ngx_cidr_t *)tmp;
  }
#line 1290
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1291
    return ((char *)((void *)-1));
  }
#line 1294
  *c = *cidr;
#line 1296
  return ((char *)((void *)0));
}
}
#line 1300 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_cidr_value(ngx_conf_t *cf , ngx_str_t *net , ngx_cidr_t *cidr ) 
{ 
  ngx_int_t rc ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1305
  tmp = strcmp((char const   *)net->data, "255.255.255.255");
  }
#line 1305
  if (tmp == 0) {
#line 1306
    cidr->family = (ngx_uint_t )2;
#line 1307
    cidr->u.in.addr = 4294967295U;
#line 1308
    cidr->u.in.mask = 4294967295U;
#line 1310
    return ((ngx_int_t )0);
  }
  {
#line 1313
  rc = ngx_ptocidr(net, cidr);
  }
#line 1315
  if (rc == -1L) {
    {
#line 1316
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid network \"%V\"", net);
    }
#line 1317
    return ((ngx_int_t )-1);
  }
#line 1320
  if (rc == -4L) {
    {
#line 1321
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "low address bits of %V are meaningless",
                       net);
    }
  }
#line 1325
  return ((ngx_int_t )0);
}
}
#line 1329 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static char *ngx_http_geo_include(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                  ngx_str_t *name ) 
{ 
  char *rv ;
  ngx_str_t file ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 1336
  file.len = name->len + 4UL;
#line 1337
  tmp = ngx_pnalloc(ctx->temp_pool, name->len + 5UL);
#line 1337
  file.data = (u_char *)tmp;
  }
#line 1338
  if ((unsigned long )file.data == (unsigned long )((void *)0)) {
#line 1339
    return ((char *)((void *)-1));
  }
  {
#line 1342
  ngx_sprintf(file.data, "%V.bin%Z", name);
#line 1344
  tmp___0 = ngx_conf_full_name(cf->cycle, & file, (ngx_uint_t )1);
  }
#line 1344
  if (tmp___0 != 0L) {
#line 1345
    return ((char *)((void *)-1));
  }
#line 1348
  if (ctx->ranges) {
    {
#line 1351
    tmp___1 = ngx_http_geo_include_binary_base(cf, ctx, & file);
    }
    {
#line 1352
    if (tmp___1 == 0L) {
#line 1352
      goto case_0;
    }
#line 1354
    if (tmp___1 == -1L) {
#line 1354
      goto case_neg_1;
    }
#line 1356
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1353
    return ((char *)((void *)0));
    case_neg_1: /* CIL Label */ 
#line 1355
    return ((char *)((void *)-1));
    switch_default: /* CIL Label */ 
#line 1357
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1361
  file.len -= 4UL;
#line 1362
  *(file.data + file.len) = (u_char )'\000';
#line 1364
  ctx->include_name = file;
#line 1366
  if (ctx->outside_entries) {
#line 1367
    ctx->allow_binary_include = 0U;
  }
  {
#line 1372
  rv = ngx_conf_parse(cf, & file);
#line 1374
  (ctx->includes) ++;
#line 1375
  ctx->outside_entries = 0U;
  }
#line 1377
  return (rv);
}
}
#line 1381 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static ngx_int_t ngx_http_geo_include_binary_base(ngx_conf_t *cf , ngx_http_geo_conf_ctx_t *ctx ,
                                                  ngx_str_t *name ) 
{ 
  u_char *base ;
  u_char ch ;
  time_t mtime ;
  size_t size ;
  size_t len ;
  ssize_t n ;
  uint32_t crc32___0 ;
  ngx_err_t err ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_file_t file ;
  ngx_file_info_t fi ;
  ngx_http_geo_range_t *range ;
  ngx_http_geo_range_t **ranges ;
  ngx_http_geo_header_t *header___0 ;
  ngx_http_variable_value_t *vv ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 1399
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 1400
  file.name = *name;
#line 1401
  file.log = cf->log;
#line 1403
  file.fd = open((char const   *)name->data, 0, 0);
  }
#line 1405
  if (file.fd == -1) {
    {
#line 1406
    tmp = __errno_location();
#line 1406
    err = *tmp;
    }
#line 1407
    if (err != 2) {
      {
#line 1408
      ngx_conf_log_error((ngx_uint_t )3, cf, err, "open() \"%s\" failed", name->data);
      }
    }
#line 1411
    return ((ngx_int_t )-5);
  }
#line 1414
  if (ctx->outside_entries) {
    {
#line 1415
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "binary geo range base \"%s\" cannot be mixed with usual entries",
                       name->data);
#line 1418
    rc = (ngx_int_t )-1;
    }
#line 1419
    goto done;
  }
#line 1422
  if (ctx->binary_include) {
    {
#line 1423
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "second binary geo range base \"%s\" cannot be mixed with \"%s\"",
                       name->data, ctx->include_name.data);
#line 1426
    rc = (ngx_int_t )-1;
    }
#line 1427
    goto done;
  }
  {
#line 1430
  tmp___1 = fstat(file.fd, & fi);
  }
#line 1430
  if (tmp___1 == -1) {
    {
#line 1431
    tmp___0 = __errno_location();
#line 1431
    ngx_conf_log_error((ngx_uint_t )3, cf, *tmp___0, "fstat() \"%s\" failed", name->data);
    }
#line 1433
    goto failed;
  }
  {
#line 1436
  size = (size_t )fi.st_size;
#line 1437
  mtime = fi.st_mtim.tv_sec;
#line 1439
  ch = *(name->data + (name->len - 4UL));
#line 1440
  *(name->data + (name->len - 4UL)) = (u_char )'\000';
#line 1442
  tmp___3 = stat((char const   */* __restrict  */)((char const   *)name->data), (struct stat */* __restrict  */)(& fi));
  }
#line 1442
  if (tmp___3 == -1) {
    {
#line 1443
    tmp___2 = __errno_location();
#line 1443
    ngx_conf_log_error((ngx_uint_t )3, cf, *tmp___2, "stat() \"%s\" failed", name->data);
    }
#line 1445
    goto failed;
  }
#line 1448
  *(name->data + (name->len - 4UL)) = ch;
#line 1450
  if (mtime < fi.st_mtim.tv_sec) {
    {
#line 1451
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "stale binary geo range base \"%s\"",
                       name->data);
    }
#line 1453
    goto failed;
  }
  {
#line 1456
  tmp___4 = ngx_palloc(ctx->pool, size);
#line 1456
  base = (u_char *)tmp___4;
  }
#line 1457
  if ((unsigned long )base == (unsigned long )((void *)0)) {
#line 1458
    goto failed;
  }
  {
#line 1461
  n = ngx_read_file(& file, base, size, (off_t )0);
  }
#line 1463
  if (n == -1L) {
    {
#line 1464
    tmp___5 = __errno_location();
#line 1464
    ngx_conf_log_error((ngx_uint_t )3, cf, *tmp___5, "pread() \"%s\" failed", name->data);
    }
#line 1466
    goto failed;
  }
#line 1469
  if ((size_t )n != size) {
    {
#line 1470
    ngx_conf_log_error((ngx_uint_t )3, cf, 0, "pread() \"%s\" returned only %z bytes instead of %z",
                       name->data, n, size);
    }
#line 1473
    goto failed;
  }
#line 1476
  header___0 = (ngx_http_geo_header_t *)base;
#line 1478
  if (size < 16UL) {
    {
#line 1479
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "incompatible binary geo range base \"%s\"",
                       name->data);
    }
#line 1481
    goto failed;
  } else {
    {
#line 1478
    tmp___6 = memcmp((void const   *)((char const   *)(& ngx_http_geo_header)), (void const   *)((char const   *)header___0),
                     (size_t )12);
    }
#line 1478
    if (tmp___6 != 0) {
      {
#line 1479
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "incompatible binary geo range base \"%s\"",
                         name->data);
      }
#line 1481
      goto failed;
    }
  }
#line 1484
  crc32___0 = 4294967295U;
#line 1486
  vv = (ngx_http_variable_value_t *)(base + sizeof(ngx_http_geo_header_t ));
  {
#line 1488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1488
    if (! vv->data) {
#line 1488
      goto while_break;
    }
    {
#line 1489
    len = ((sizeof(ngx_http_variable_value_t ) + (unsigned long )vv->len) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL);
#line 1491
    ngx_crc32_update(& crc32___0, (u_char *)vv, len);
#line 1492
    vv->data += (size_t )base;
#line 1493
    vv = (ngx_http_variable_value_t *)((u_char *)vv + len);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1495
  ngx_crc32_update(& crc32___0, (u_char *)vv, sizeof(ngx_http_variable_value_t ));
#line 1496
  vv ++;
#line 1498
  ranges = (ngx_http_geo_range_t **)vv;
#line 1500
  i = (ngx_uint_t )0;
  }
  {
#line 1500
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1500
    if (! (i < 65536UL)) {
#line 1500
      goto while_break___0;
    }
    {
#line 1501
    ngx_crc32_update(& crc32___0, (u_char *)(ranges + i), sizeof(void *));
    }
#line 1502
    if (*(ranges + i)) {
#line 1503
      *(ranges + i) = (ngx_http_geo_range_t *)((u_char *)*(ranges + i) + (size_t )base);
    }
#line 1500
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1508
  range = (ngx_http_geo_range_t *)(ranges + 65536);
  {
#line 1510
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1510
    if (! ((unsigned long )((u_char *)range) < (unsigned long )(base + size))) {
#line 1510
      goto while_break___1;
    }
    {
#line 1511
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1511
      if (! range->value) {
#line 1511
        goto while_break___2;
      }
      {
#line 1512
      ngx_crc32_update(& crc32___0, (u_char *)range, sizeof(ngx_http_geo_range_t ));
#line 1514
      range->value = (ngx_http_variable_value_t *)((u_char *)range->value + (size_t )base);
#line 1516
      range ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1518
    ngx_crc32_update(& crc32___0, (u_char *)range, sizeof(void *));
#line 1519
    range = (ngx_http_geo_range_t *)((u_char *)range + sizeof(void *));
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1522
  crc32___0 ^= 4294967295U;
#line 1524
  if (crc32___0 != header___0->crc32) {
    {
#line 1525
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "CRC32 mismatch in binary geo range base \"%s\"",
                       name->data);
    }
#line 1527
    goto failed;
  }
  {
#line 1530
  ngx_conf_log_error((ngx_uint_t )6, cf, 0, "using binary geo range base \"%s\"",
                     name->data);
#line 1533
  ctx->include_name = *name;
#line 1534
  ctx->binary_include = 1U;
#line 1535
  ctx->high.low = ranges;
#line 1536
  rc = (ngx_int_t )0;
  }
#line 1538
  goto done;
  failed: 
#line 1542
  rc = (ngx_int_t )-5;
  done: 
  {
#line 1546
  tmp___8 = close(file.fd);
  }
#line 1546
  if (tmp___8 == -1) {
#line 1547
    if ((cf->log)->log_level >= 2UL) {
      {
#line 1547
      tmp___7 = __errno_location();
#line 1547
      ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___7, "close() \"%s\" failed",
                         name->data);
      }
    }
  }
#line 1551
  return (rc);
}
}
#line 1555 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static void ngx_http_geo_create_binary_base(ngx_http_geo_conf_ctx_t *ctx ) 
{ 
  u_char *p ;
  uint32_t hash ;
  ngx_str_t s ;
  ngx_uint_t i ;
  ngx_file_mapping_t fm ;
  ngx_http_geo_range_t *r ;
  ngx_http_geo_range_t *range ;
  ngx_http_geo_range_t **ranges ;
  ngx_http_geo_header_t *header___0 ;
  ngx_http_geo_variable_value_node_t *gvvn ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_str_node_t *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1567
  tmp = ngx_pnalloc(ctx->temp_pool, ctx->include_name.len + 5UL);
#line 1567
  fm.name = (u_char *)tmp;
  }
#line 1568
  if ((unsigned long )fm.name == (unsigned long )((void *)0)) {
#line 1569
    return;
  }
  {
#line 1572
  ngx_sprintf(fm.name, "%V.bin%Z", & ctx->include_name);
#line 1574
  fm.size = ctx->data_size;
#line 1575
  fm.log = (ctx->pool)->log;
  }
#line 1577
  if ((fm.log)->log_level >= 6UL) {
    {
#line 1577
    ngx_log_error_core((ngx_uint_t )6, fm.log, 0, "creating binary geo range base \"%s\"",
                       fm.name);
    }
  }
  {
#line 1580
  tmp___0 = ngx_create_file_mapping(& fm);
  }
#line 1580
  if (tmp___0 != 0L) {
#line 1581
    return;
  }
  {
#line 1584
  tmp___1 = memcpy((void */* __restrict  */)fm.addr, (void const   */* __restrict  */)(& ngx_http_geo_header),
                   sizeof(ngx_http_geo_header_t ));
#line 1584
  p = (u_char *)tmp___1 + sizeof(ngx_http_geo_header_t );
#line 1587
  p = ngx_http_geo_copy_values((u_char *)fm.addr, p, ctx->rbtree.root, ctx->rbtree.sentinel);
#line 1590
  p += sizeof(ngx_http_variable_value_t );
#line 1592
  ranges = (ngx_http_geo_range_t **)p;
#line 1594
  p += 65536UL * sizeof(ngx_http_geo_range_t *);
#line 1596
  i = (ngx_uint_t )0;
  }
  {
#line 1596
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1596
    if (! (i < 65536UL)) {
#line 1596
      goto while_break;
    }
#line 1597
    r = *(ctx->high.low + i);
#line 1598
    if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 1599
      goto __Cont;
    }
#line 1602
    range = (ngx_http_geo_range_t *)p;
#line 1603
    *(ranges + i) = (ngx_http_geo_range_t *)(p - (u_char *)fm.addr);
    {
#line 1605
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1606
      s.len = (size_t )(r->value)->len;
#line 1607
      s.data = (r->value)->data;
#line 1608
      hash = ngx_crc32_long(s.data, s.len);
#line 1609
      tmp___2 = ngx_str_rbtree_lookup(& ctx->rbtree, & s, hash);
#line 1609
      gvvn = (ngx_http_geo_variable_value_node_t *)tmp___2;
#line 1612
      range->value = (ngx_http_variable_value_t *)gvvn->offset;
#line 1613
      range->start = r->start;
#line 1614
      range->end = r->end;
#line 1615
      range ++;
#line 1605
      r ++;
      }
#line 1605
      if (! r->value) {
#line 1605
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1619
    range->value = (ngx_http_variable_value_t *)((void *)0);
#line 1621
    p = (u_char *)range + sizeof(void *);
    __Cont: /* CIL Label */ 
#line 1596
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1624
  header___0 = (ngx_http_geo_header_t *)fm.addr;
#line 1625
  header___0->crc32 = ngx_crc32_long((u_char *)fm.addr + sizeof(ngx_http_geo_header_t ),
                                     fm.size - sizeof(ngx_http_geo_header_t ));
#line 1629
  ngx_close_file_mapping(& fm);
  }
#line 1630
  return;
}
}
#line 1633 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_geo_module.c"
static u_char *ngx_http_geo_copy_values(u_char *base , u_char *p , ngx_rbtree_node_t *node ,
                                        ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_http_variable_value_t *vv ;
  ngx_http_geo_variable_value_node_t *gvvn ;
  void *tmp ;
  u_char *tmp___0 ;

  {
#line 1640
  if ((unsigned long )node == (unsigned long )sentinel) {
#line 1641
    return (p);
  }
  {
#line 1644
  gvvn = (ngx_http_geo_variable_value_node_t *)node;
#line 1645
  gvvn->offset = (size_t )(p - base);
#line 1647
  vv = (ngx_http_variable_value_t *)p;
#line 1648
  *vv = *(gvvn->value);
#line 1649
  p += sizeof(ngx_http_variable_value_t );
#line 1650
  vv->data = (u_char *)(p - base);
#line 1652
  tmp = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)gvvn->sn.str.data,
               gvvn->sn.str.len);
#line 1652
  p = (u_char *)tmp + gvvn->sn.str.len;
#line 1654
  p = (u_char *)(((uintptr_t )p + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL));
#line 1656
  p = ngx_http_geo_copy_values(base, p, node->left, sentinel);
#line 1658
  tmp___0 = ngx_http_geo_copy_values(base, p, node->right, sentinel);
  }
#line 1658
  return (tmp___0);
}
}
#line 16 "src/core/ngx_crc32.h"
uint32_t *ngx_crc32_table_short ;
#line 20 "src/core/ngx_crc32.h"
__inline static uint32_t ngx_crc32_short(u_char *p , size_t len ) 
{ 
  u_char c ;
  uint32_t crc ;
  u_char *tmp ;
  size_t tmp___0 ;

  {
#line 26
  crc = 4294967295U;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    tmp___0 = len;
#line 28
    len --;
#line 28
    if (! tmp___0) {
#line 28
      goto while_break;
    }
#line 29
    tmp = p;
#line 29
    p ++;
#line 29
    c = *tmp;
#line 30
    crc = *(ngx_crc32_table_short + ((crc ^ (unsigned int )((int )c & 15)) & 15U)) ^ (crc >> 4);
#line 31
    crc = *(ngx_crc32_table_short + ((crc ^ (unsigned int )((int )c >> 4)) & 15U)) ^ (crc >> 4);
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  return (crc ^ 4294967295U);
}
}
#line 49 "src/core/ngx_times.h"
ngx_msec_t volatile   ngx_current_msec ;
#line 44 "src/core/ngx_shmtx.h"
void ngx_shmtx_lock(ngx_shmtx_t *mtx ) ;
#line 45
void ngx_shmtx_unlock(ngx_shmtx_t *mtx ) ;
#line 516 "src/event/ngx_event.h"
ngx_int_t ngx_handle_write_event(ngx_event_t *wev , size_t lowat ) ;
#line 50 "src/event/ngx_event_timer.h"
__inline static void ngx_event_add_timer(ngx_event_t *ev , ngx_msec_t timer ) 
{ 
  ngx_msec_t key ;
  ngx_msec_int_t diff ;
  ngx_msec_int_t tmp ;

  {
#line 56
  key = (ngx_msec_t )(ngx_current_msec + (ngx_msec_t volatile   )timer);
#line 58
  if (ev->timer_set) {
#line 66
    diff = (ngx_msec_int_t )(key - ev->timer.key);
#line 68
    if (diff >= 0L) {
#line 68
      tmp = diff;
    } else {
#line 68
      tmp = - diff;
    }
#line 68
    if (tmp < 300L) {
#line 72
      return;
    }
    {
#line 75
    ngx_event_del_timer(ev);
    }
  }
  {
#line 78
  ev->timer.key = key;
#line 84
  ngx_rbtree_insert(& ngx_event_timer_rbtree, & ev->timer);
#line 86
  ev->timer_set = 1U;
  }
#line 87
  return;
}
}
#line 464 "src/http/ngx_http_core_module.h"
void ngx_http_core_run_phases(ngx_http_request_t *r ) ;
#line 123 "src/http/ngx_http.h"
void ngx_http_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 150
void ngx_http_block_reading(ngx_http_request_t *r ) ;
#line 151
void ngx_http_test_reading(ngx_http_request_t *r ) ;
#line 59 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static void ngx_http_limit_req_delay(ngx_http_request_t *r ) ;
#line 60
static ngx_int_t ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit , ngx_uint_t hash ,
                                           ngx_str_t *key , ngx_uint_t *ep___0 , ngx_uint_t account ) ;
#line 62
static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits ,
                                             ngx_uint_t n , ngx_uint_t *ep___0 , ngx_http_limit_req_limit_t **limit ) ;
#line 64
static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx , ngx_uint_t n ) ;
#line 67
static void *ngx_http_limit_req_create_conf(ngx_conf_t *cf ) ;
#line 68
static char *ngx_http_limit_req_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 70
static char *ngx_http_limit_req_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 72
static char *ngx_http_limit_req(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 74
static ngx_int_t ngx_http_limit_req_init(ngx_conf_t *cf ) ;
#line 77 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_conf_enum_t ngx_http_limit_req_log_levels[5]  = {      {{sizeof("info") - 1UL, (u_char *)"info"}, (ngx_uint_t )7}, 
        {{sizeof("notice") - 1UL, (u_char *)"notice"}, (ngx_uint_t )6}, 
        {{sizeof("warn") - 1UL, (u_char *)"warn"}, (ngx_uint_t )5}, 
        {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )4}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 86 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_conf_num_bounds_t ngx_http_limit_req_status_bounds  =    {& ngx_conf_check_num_bounds, (ngx_int_t )400, (ngx_int_t )599};
#line 91 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_command_t ngx_http_limit_req_commands[5]  = {      {{sizeof("limit_req_zone") - 1UL, (u_char *)"limit_req_zone"}, (ngx_uint_t )33554440,
      & ngx_http_limit_req_zone, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_req") - 1UL, (u_char *)"limit_req"}, (ngx_uint_t )234881038,
      & ngx_http_limit_req, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_req_log_level") - 1UL, (u_char *)"limit_req_log_level"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_limit_req_conf_t *)0)->limit_log_level), (void *)(& ngx_http_limit_req_log_levels)}, 
        {{sizeof("limit_req_status") - 1UL,
       (u_char *)"limit_req_status"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_limit_req_conf_t *)0)->status_code),
      (void *)(& ngx_http_limit_req_status_bounds)}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 125 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_http_module_t ngx_http_limit_req_module_ctx  = 
#line 125
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_limit_req_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_limit_req_create_conf,
    & ngx_http_limit_req_merge_conf};
#line 140 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
ngx_module_t ngx_http_limit_req_module  = 
#line 140
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_limit_req_module_ctx),
    ngx_http_limit_req_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 156 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_int_t ngx_http_limit_req_handler(ngx_http_request_t *r ) 
{ 
  uint32_t hash ;
  ngx_str_t key ;
  ngx_int_t rc ;
  ngx_uint_t n ;
  ngx_uint_t excess ;
  ngx_msec_t delay ;
  ngx_http_limit_req_ctx_t *ctx ;
  ngx_http_limit_req_conf_t *lrcf ;
  ngx_http_limit_req_limit_t *limit ;
  ngx_http_limit_req_limit_t *limits ;
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 168
  if ((r->main)->limit_req_set) {
#line 169
    return ((ngx_int_t )-5);
  }
#line 172
  lrcf = (ngx_http_limit_req_conf_t *)*(r->loc_conf + ngx_http_limit_req_module.ctx_index);
#line 173
  limits = (ngx_http_limit_req_limit_t *)lrcf->limits.elts;
#line 175
  excess = (ngx_uint_t )0;
#line 177
  rc = (ngx_int_t )-5;
#line 180
  limit = (ngx_http_limit_req_limit_t *)((void *)0);
#line 183
  n = (ngx_uint_t )0;
  {
#line 183
  while (1) {
    while_continue: /* CIL Label */ ;
#line 183
    if (! (n < lrcf->limits.nelts)) {
#line 183
      goto while_break;
    }
    {
#line 185
    limit = limits + n;
#line 187
    ctx = (ngx_http_limit_req_ctx_t *)(limit->shm_zone)->data;
#line 189
    tmp = ngx_http_complex_value(r, & ctx->key, & key);
    }
#line 189
    if (tmp != 0L) {
#line 190
      return ((ngx_int_t )500);
    }
#line 193
    if (key.len == 0UL) {
#line 194
      goto __Cont;
    }
#line 197
    if (key.len > 65535UL) {
#line 198
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 198
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the value of the \"%V\" key is more than 65535 bytes: \"%V\"",
                           & ctx->key.value, & key);
        }
      }
#line 202
      goto __Cont;
    }
    {
#line 205
    hash = ngx_crc32_short(key.data, key.len);
#line 207
    ngx_shmtx_lock(& (ctx->shpool)->mutex);
#line 209
    rc = ngx_http_limit_req_lookup(limit, (ngx_uint_t )hash, & key, & excess, (ngx_uint_t )(n == lrcf->limits.nelts - 1UL));
#line 212
    ngx_shmtx_unlock(& (ctx->shpool)->mutex);
    }
#line 218
    if (rc != -2L) {
#line 219
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 183
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 223
  if (rc == -5L) {
#line 224
    return ((ngx_int_t )-5);
  }
#line 227
  (r->main)->limit_req_set = 1U;
#line 229
  if (rc == -3L) {
#line 229
    goto _L;
  } else
#line 229
  if (rc == -1L) {
    _L: /* CIL Label */ 
#line 231
    if (rc == -3L) {
#line 232
      if (((r->connection)->log)->log_level >= lrcf->limit_log_level) {
        {
#line 232
        ngx_log_error_core(lrcf->limit_log_level, (r->connection)->log, 0, "limiting requests, excess: %ui.%03ui by zone \"%V\"",
                           excess / 1000UL, excess % 1000UL, & (limit->shm_zone)->shm.name);
        }
      }
    }
    {
#line 238
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 238
      tmp___0 = n;
#line 238
      n --;
#line 238
      if (! tmp___0) {
#line 238
        goto while_break___0;
      }
#line 239
      ctx = (ngx_http_limit_req_ctx_t *)((limits + n)->shm_zone)->data;
#line 241
      if ((unsigned long )ctx->node == (unsigned long )((void *)0)) {
#line 242
        goto while_continue___0;
      }
      {
#line 245
      ngx_shmtx_lock(& (ctx->shpool)->mutex);
#line 247
      ((ctx->node)->count) --;
#line 249
      ngx_shmtx_unlock(& (ctx->shpool)->mutex);
#line 251
      ctx->node = (ngx_http_limit_req_node_t *)((void *)0);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 254
    return ((ngx_int_t )lrcf->status_code);
  }
#line 259
  if (rc == -2L) {
#line 260
    excess = (ngx_uint_t )0;
  }
  {
#line 263
  delay = ngx_http_limit_req_account(limits, n, & excess, & limit);
  }
#line 265
  if (! delay) {
#line 266
    return ((ngx_int_t )-5);
  }
#line 269
  if (((r->connection)->log)->log_level >= lrcf->delay_log_level) {
    {
#line 269
    ngx_log_error_core(lrcf->delay_log_level, (r->connection)->log, 0, "delaying request, excess: %ui.%03ui, by zone \"%V\"",
                       excess / 1000UL, excess % 1000UL, & (limit->shm_zone)->shm.name);
    }
  }
  {
#line 273
  tmp___1 = ngx_handle_read_event((r->connection)->read, (ngx_uint_t )0);
  }
#line 273
  if (tmp___1 != 0L) {
#line 274
    return ((ngx_int_t )500);
  }
  {
#line 277
  r->read_event_handler = & ngx_http_test_reading;
#line 278
  r->write_event_handler = & ngx_http_limit_req_delay;
#line 280
  ((r->connection)->write)->delayed = 1U;
#line 281
  ngx_event_add_timer((r->connection)->write, delay);
  }
#line 283
  return ((ngx_int_t )-2);
}
}
#line 287 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static void ngx_http_limit_req_delay(ngx_http_request_t *r ) 
{ 
  ngx_event_t *wev ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 295
  wev = (r->connection)->write;
#line 297
  if (wev->delayed) {
    {
#line 299
    tmp = ngx_handle_write_event(wev, (size_t )0);
    }
#line 299
    if (tmp != 0L) {
      {
#line 300
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
    }
#line 303
    return;
  }
  {
#line 306
  tmp___0 = ngx_handle_read_event((r->connection)->read, (ngx_uint_t )0);
  }
#line 306
  if (tmp___0 != 0L) {
    {
#line 307
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 308
    return;
  }
  {
#line 311
  r->read_event_handler = & ngx_http_block_reading;
#line 312
  r->write_event_handler = & ngx_http_core_run_phases;
#line 314
  ngx_http_core_run_phases(r);
  }
#line 315
  return;
}
}
#line 318 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static void ngx_http_limit_req_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                   ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_http_limit_req_node_t *lrn ;
  ngx_http_limit_req_node_t *lrnt ;
  ngx_int_t tmp___0 ;

  {
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 327
    if (node->key < temp->key) {
#line 329
      p = & temp->left;
    } else
#line 331
    if (node->key > temp->key) {
#line 333
      p = & temp->right;
    } else {
      {
#line 337
      lrn = (ngx_http_limit_req_node_t *)(& node->color);
#line 338
      lrnt = (ngx_http_limit_req_node_t *)(& temp->color);
#line 340
      tmp___0 = ngx_memn2cmp(lrn->data, lrnt->data, (size_t )lrn->len, (size_t )lrnt->len);
      }
#line 340
      if (tmp___0 < 0L) {
#line 340
        p = & temp->left;
      } else {
#line 340
        p = & temp->right;
      }
    }
#line 344
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 345
      goto while_break;
    }
#line 348
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  *p = node;
#line 352
  node->parent = temp;
#line 353
  node->left = sentinel;
#line 354
  node->right = sentinel;
#line 355
  node->color = (u_char )1;
#line 356
  return;
}
}
#line 359 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_int_t ngx_http_limit_req_lookup(ngx_http_limit_req_limit_t *limit , ngx_uint_t hash ,
                                           ngx_str_t *key , ngx_uint_t *ep___0 , ngx_uint_t account ) 
{ 
  size_t size ;
  ngx_int_t rc ;
  ngx_int_t excess ;
  ngx_msec_t now ;
  ngx_msec_int_t ms ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_http_limit_req_ctx_t *ctx ;
  ngx_http_limit_req_node_t *lr ;
  ngx_msec_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp18 ;

  {
#line 371
  now = (ngx_msec_t )ngx_current_msec;
#line 373
  ctx = (ngx_http_limit_req_ctx_t *)(limit->shm_zone)->data;
#line 375
  node = (ctx->sh)->rbtree.root;
#line 376
  sentinel = (ctx->sh)->rbtree.sentinel;
  {
#line 378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 378
      goto while_break;
    }
#line 380
    if (hash < node->key) {
#line 381
      node = node->left;
#line 382
      goto while_continue;
    }
#line 385
    if (hash > node->key) {
#line 386
      node = node->right;
#line 387
      goto while_continue;
    }
    {
#line 392
    lr = (ngx_http_limit_req_node_t *)(& node->color);
#line 394
    rc = ngx_memn2cmp(key->data, lr->data, key->len, (size_t )lr->len);
    }
#line 396
    if (rc == 0L) {
#line 397
      (lr->queue.next)->prev = lr->queue.prev;
#line 397
      (lr->queue.prev)->next = lr->queue.next;
#line 398
      lr->queue.next = (ctx->sh)->queue.next;
#line 398
      (lr->queue.next)->prev = & lr->queue;
#line 398
      lr->queue.prev = & (ctx->sh)->queue;
#line 398
      (ctx->sh)->queue.next = & lr->queue;
#line 400
      ms = (ngx_msec_int_t )(now - lr->last);
#line 402
      if (ms >= 0L) {
#line 402
        tmp = ms;
      } else {
#line 402
        tmp = - ms;
      }
#line 402
      excess = (ngx_int_t )((lr->excess - (ctx->rate * (ngx_uint_t )tmp) / 1000UL) + 1000UL);
#line 404
      if (excess < 0L) {
#line 405
        excess = (ngx_int_t )0;
      }
#line 408
      *ep___0 = (ngx_uint_t )excess;
#line 410
      if ((ngx_uint_t )excess > limit->burst) {
#line 411
        return ((ngx_int_t )-3);
      }
#line 414
      if (account) {
#line 415
        lr->excess = (ngx_uint_t )excess;
#line 416
        lr->last = now;
#line 417
        return ((ngx_int_t )0);
      }
#line 420
      (lr->count) ++;
#line 422
      ctx->node = lr;
#line 424
      return ((ngx_int_t )-2);
    }
#line 427
    if (rc < 0L) {
#line 427
      node = node->left;
    } else {
#line 427
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 430
  *ep___0 = (ngx_uint_t )0;
#line 432
  size = ((unsigned long )(& ((ngx_rbtree_node_t *)0)->color) + (unsigned long )(& ((ngx_http_limit_req_node_t *)0)->data)) + key->len;
#line 436
  ngx_http_limit_req_expire(ctx, (ngx_uint_t )1);
#line 438
  tmp___0 = ngx_slab_alloc_locked(ctx->shpool, size);
#line 438
  node = (ngx_rbtree_node_t *)tmp___0;
  }
#line 440
  if ((unsigned long )node == (unsigned long )((void *)0)) {
    {
#line 441
    ngx_http_limit_req_expire(ctx, (ngx_uint_t )0);
#line 443
    tmp___1 = ngx_slab_alloc_locked(ctx->shpool, size);
#line 443
    node = (ngx_rbtree_node_t *)tmp___1;
    }
#line 444
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 445
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 445
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "could not allocate node%s",
                           (ctx->shpool)->log_ctx);
        }
      }
#line 447
      return ((ngx_int_t )-1);
    }
  }
  {
#line 451
  node->key = hash;
#line 453
  lr = (ngx_http_limit_req_node_t *)(& node->color);
#line 455
  lr->len = (u_short )key->len;
#line 456
  lr->excess = (ngx_uint_t )0;
#line 458
  memcpy((void */* __restrict  */)(lr->data), (void const   */* __restrict  */)key->data,
         key->len);
#line 460
  ngx_rbtree_insert(& (ctx->sh)->rbtree, node);
#line 462
  lr->queue.next = (ctx->sh)->queue.next;
#line 462
  (lr->queue.next)->prev = & lr->queue;
#line 462
  lr->queue.prev = & (ctx->sh)->queue;
#line 462
  (ctx->sh)->queue.next = & lr->queue;
  }
#line 464
  if (account) {
#line 465
    lr->last = now;
#line 466
    lr->count = (ngx_uint_t )0;
#line 467
    return ((ngx_int_t )0);
  }
#line 470
  lr->last = (ngx_msec_t )0;
#line 471
  lr->count = (ngx_uint_t )1;
#line 473
  ctx->node = lr;
#line 475
  return ((ngx_int_t )-2);
}
}
#line 479 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_msec_t ngx_http_limit_req_account(ngx_http_limit_req_limit_t *limits ,
                                             ngx_uint_t n , ngx_uint_t *ep___0 , ngx_http_limit_req_limit_t **limit ) 
{ 
  ngx_int_t excess ;
  ngx_msec_t now ;
  ngx_msec_t delay ;
  ngx_msec_t max_delay ;
  ngx_msec_int_t ms ;
  ngx_http_limit_req_ctx_t *ctx ;
  ngx_http_limit_req_node_t *lr ;
  ngx_msec_int_t tmp ;
  ngx_uint_t tmp___0 ;

  {
#line 489
  excess = (ngx_int_t )*ep___0;
#line 491
  if (excess == 0L) {
#line 492
    max_delay = (ngx_msec_t )0;
  } else
#line 491
  if ((*limit)->nodelay) {
#line 492
    max_delay = (ngx_msec_t )0;
  } else {
#line 495
    ctx = (ngx_http_limit_req_ctx_t *)((*limit)->shm_zone)->data;
#line 496
    max_delay = (ngx_uint_t )(excess * 1000L) / ctx->rate;
  }
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    tmp___0 = n;
#line 499
    n --;
#line 499
    if (! tmp___0) {
#line 499
      goto while_break;
    }
#line 500
    ctx = (ngx_http_limit_req_ctx_t *)((limits + n)->shm_zone)->data;
#line 501
    lr = ctx->node;
#line 503
    if ((unsigned long )lr == (unsigned long )((void *)0)) {
#line 504
      goto while_continue;
    }
    {
#line 507
    ngx_shmtx_lock(& (ctx->shpool)->mutex);
#line 509
    now = (ngx_msec_t )ngx_current_msec;
#line 510
    ms = (ngx_msec_int_t )(now - lr->last);
    }
#line 512
    if (ms >= 0L) {
#line 512
      tmp = ms;
    } else {
#line 512
      tmp = - ms;
    }
#line 512
    excess = (ngx_int_t )((lr->excess - (ctx->rate * (ngx_uint_t )tmp) / 1000UL) + 1000UL);
#line 514
    if (excess < 0L) {
#line 515
      excess = (ngx_int_t )0;
    }
    {
#line 518
    lr->last = now;
#line 519
    lr->excess = (ngx_uint_t )excess;
#line 520
    (lr->count) --;
#line 522
    ngx_shmtx_unlock(& (ctx->shpool)->mutex);
#line 524
    ctx->node = (ngx_http_limit_req_node_t *)((void *)0);
    }
#line 526
    if ((limits + n)->nodelay) {
#line 527
      goto while_continue;
    }
#line 530
    delay = (ngx_uint_t )(excess * 1000L) / ctx->rate;
#line 532
    if (delay > max_delay) {
#line 533
      max_delay = delay;
#line 534
      *ep___0 = (ngx_uint_t )excess;
#line 535
      *limit = limits + n;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return (max_delay);
}
}
#line 543 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static void ngx_http_limit_req_expire(ngx_http_limit_req_ctx_t *ctx , ngx_uint_t n ) 
{ 
  ngx_int_t excess ;
  ngx_msec_t now ;
  ngx_queue_t *q ;
  ngx_msec_int_t ms ;
  ngx_rbtree_node_t *node ;
  ngx_http_limit_req_node_t *lr ;
  ngx_uint_t tmp ;

  {
#line 553
  now = (ngx_msec_t )ngx_current_msec;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! (n < 3UL)) {
#line 561
      goto while_break;
    }
#line 563
    if ((unsigned long )(& (ctx->sh)->queue) == (unsigned long )(ctx->sh)->queue.prev) {
#line 564
      return;
    }
#line 567
    q = (ctx->sh)->queue.prev;
#line 569
    lr = (ngx_http_limit_req_node_t *)((u_char *)q - (unsigned long )(& ((ngx_http_limit_req_node_t *)0)->queue));
#line 571
    if (lr->count) {
#line 578
      return;
    }
#line 581
    tmp = n;
#line 581
    n ++;
#line 581
    if (tmp != 0UL) {
#line 583
      ms = (ngx_msec_int_t )(now - lr->last);
#line 584
      if (ms >= 0L) {
#line 584
        ms = ms;
      } else {
#line 584
        ms = - ms;
      }
#line 586
      if (ms < 60000L) {
#line 587
        return;
      }
#line 590
      excess = (ngx_int_t )(lr->excess - (ctx->rate * (ngx_uint_t )ms) / 1000UL);
#line 592
      if (excess > 0L) {
#line 593
        return;
      }
    }
    {
#line 597
    (q->next)->prev = q->prev;
#line 597
    (q->prev)->next = q->next;
#line 599
    node = (ngx_rbtree_node_t *)((u_char *)lr - (unsigned long )(& ((ngx_rbtree_node_t *)0)->color));
#line 602
    ngx_rbtree_delete(& (ctx->sh)->rbtree, node);
#line 604
    ngx_slab_free_locked(ctx->shpool, (void *)node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 606
  return;
}
}
#line 609 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_int_t ngx_http_limit_req_init_zone(ngx_shm_zone_t *shm_zone , void *data ) 
{ 
  ngx_http_limit_req_ctx_t *octx ;
  size_t len ;
  ngx_http_limit_req_ctx_t *ctx ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 612
  octx = (ngx_http_limit_req_ctx_t *)data;
#line 617
  ctx = (ngx_http_limit_req_ctx_t *)shm_zone->data;
#line 619
  if (octx) {
#line 620
    if (ctx->key.value.len != octx->key.value.len) {
#line 620
      goto _L;
    } else {
      {
#line 620
      tmp = strncmp((char const   *)ctx->key.value.data, (char const   *)octx->key.value.data,
                    ctx->key.value.len);
      }
#line 620
      if (tmp != 0) {
        _L: /* CIL Label */ 
#line 625
        if ((shm_zone->shm.log)->log_level >= 1UL) {
          {
#line 625
          ngx_log_error_core((ngx_uint_t )1, shm_zone->shm.log, 0, "limit_req \"%V\" uses the \"%V\" key while previously it used the \"%V\" key",
                             & shm_zone->shm.name, & ctx->key.value, & octx->key.value);
          }
        }
#line 630
        return ((ngx_int_t )-1);
      }
    }
#line 633
    ctx->sh = octx->sh;
#line 634
    ctx->shpool = octx->shpool;
#line 636
    return ((ngx_int_t )0);
  }
#line 639
  ctx->shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;
#line 641
  if (shm_zone->shm.exists) {
#line 642
    ctx->sh = (ngx_http_limit_req_shctx_t *)(ctx->shpool)->data;
#line 644
    return ((ngx_int_t )0);
  }
  {
#line 647
  tmp___0 = ngx_slab_alloc(ctx->shpool, sizeof(ngx_http_limit_req_shctx_t ));
#line 647
  ctx->sh = (ngx_http_limit_req_shctx_t *)tmp___0;
  }
#line 648
  if ((unsigned long )ctx->sh == (unsigned long )((void *)0)) {
#line 649
    return ((ngx_int_t )-1);
  }
  {
#line 652
  (ctx->shpool)->data = (void *)ctx->sh;
#line 654
  (ctx->sh)->sentinel.color = (u_char )0;
#line 654
  (ctx->sh)->rbtree.root = & (ctx->sh)->sentinel;
#line 654
  (ctx->sh)->rbtree.sentinel = & (ctx->sh)->sentinel;
#line 654
  (ctx->sh)->rbtree.insert = & ngx_http_limit_req_rbtree_insert_value;
#line 657
  (ctx->sh)->queue.prev = & (ctx->sh)->queue;
#line 657
  (ctx->sh)->queue.next = & (ctx->sh)->queue;
#line 659
  len = sizeof(" in limit_req zone \"\"") + shm_zone->shm.name.len;
#line 661
  tmp___1 = ngx_slab_alloc(ctx->shpool, len);
#line 661
  (ctx->shpool)->log_ctx = (u_char *)tmp___1;
  }
#line 662
  if ((unsigned long )(ctx->shpool)->log_ctx == (unsigned long )((void *)0)) {
#line 663
    return ((ngx_int_t )-1);
  }
  {
#line 666
  ngx_sprintf((ctx->shpool)->log_ctx, " in limit_req zone \"%V\"%Z", & shm_zone->shm.name);
#line 669
  (ctx->shpool)->log_nomem = 0U;
  }
#line 671
  return ((ngx_int_t )0);
}
}
#line 675 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static void *ngx_http_limit_req_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_limit_req_conf_t *conf ;
  void *tmp ;

  {
  {
#line 680
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_req_conf_t ));
#line 680
  conf = (ngx_http_limit_req_conf_t *)tmp;
  }
#line 681
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 682
    return ((void *)0);
  }
#line 691
  conf->limit_log_level = (ngx_uint_t )-1;
#line 692
  conf->status_code = (ngx_uint_t )-1;
#line 694
  return ((void *)conf);
}
}
#line 698 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static char *ngx_http_limit_req_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_limit_req_conf_t *prev ;
  ngx_http_limit_req_conf_t *conf ;

  {
#line 701
  prev = (ngx_http_limit_req_conf_t *)parent;
#line 702
  conf = (ngx_http_limit_req_conf_t *)child;
#line 704
  if ((unsigned long )conf->limits.elts == (unsigned long )((void *)0)) {
#line 705
    conf->limits = prev->limits;
  }
#line 708
  if (conf->limit_log_level == 0xffffffffffffffffUL) {
#line 708
    if (prev->limit_log_level == 0xffffffffffffffffUL) {
#line 708
      conf->limit_log_level = (ngx_uint_t )4;
    } else {
#line 708
      conf->limit_log_level = prev->limit_log_level;
    }
  }
#line 711
  if (conf->limit_log_level == 7UL) {
#line 711
    conf->delay_log_level = (ngx_uint_t )7;
  } else {
#line 711
    conf->delay_log_level = conf->limit_log_level + 1UL;
  }
#line 714
  if (conf->status_code == 0xffffffffffffffffUL) {
#line 714
    if (prev->status_code == 0xffffffffffffffffUL) {
#line 714
      conf->status_code = (ngx_uint_t )503;
    } else {
#line 714
      conf->status_code = prev->status_code;
    }
  }
#line 717
  return ((char *)((void *)0));
}
}
#line 721 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static char *ngx_http_limit_req_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  u_char *p ;
  size_t len ;
  ssize_t size ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_str_t s ;
  ngx_int_t rate ;
  ngx_int_t scale ;
  ngx_uint_t i ;
  ngx_shm_zone_t *shm_zone ;
  ngx_http_limit_req_ctx_t *ctx ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 734
  value = (ngx_str_t *)(cf->args)->elts;
#line 736
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_req_ctx_t ));
#line 736
  ctx = (ngx_http_limit_req_ctx_t *)tmp;
  }
#line 737
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 738
    return ((char *)((void *)-1));
  }
  {
#line 741
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 743
  ccv.cf = cf;
#line 744
  ccv.value = value + 1;
#line 745
  ccv.complex_value = & ctx->key;
#line 747
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 747
  if (tmp___0 != 0L) {
#line 748
    return ((char *)((void *)-1));
  }
#line 751
  size = (ssize_t )0;
#line 752
  rate = (ngx_int_t )1;
#line 753
  scale = (ngx_int_t )1;
#line 754
  name.len = (size_t )0;
#line 756
  i = (ngx_uint_t )2;
  {
#line 756
  while (1) {
    while_continue: /* CIL Label */ ;
#line 756
    if (! (i < (cf->args)->nelts)) {
#line 756
      goto while_break;
    }
    {
#line 758
    tmp___2 = strncmp((char const   *)(value + i)->data, "zone=", (size_t )5);
    }
#line 758
    if (tmp___2 == 0) {
      {
#line 760
      name.data = (value + i)->data + 5;
#line 762
      tmp___1 = strchr((char const   *)name.data, ':');
#line 762
      p = (u_char *)tmp___1;
      }
#line 764
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 765
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + i);
        }
#line 767
        return ((char *)((void *)-1));
      }
      {
#line 770
      name.len = (size_t )(p - name.data);
#line 772
      s.data = p + 1;
#line 773
      s.len = (size_t )(((value + i)->data + (value + i)->len) - s.data);
#line 775
      size = ngx_parse_size(& s);
      }
#line 777
      if (size == -1L) {
        {
#line 778
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + i);
        }
#line 780
        return ((char *)((void *)-1));
      }
#line 783
      if (size < (ssize_t )(8UL * ngx_pagesize)) {
        {
#line 784
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "zone \"%V\" is too small", value + i);
        }
#line 786
        return ((char *)((void *)-1));
      }
#line 789
      goto __Cont;
    }
    {
#line 792
    tmp___5 = strncmp((char const   *)(value + i)->data, "rate=", (size_t )5);
    }
#line 792
    if (tmp___5 == 0) {
      {
#line 794
      len = (value + i)->len;
#line 795
      p = ((value + i)->data + len) - 3;
#line 797
      tmp___4 = strncmp((char const   *)p, "r/s", (size_t )3);
      }
#line 797
      if (tmp___4 == 0) {
#line 798
        scale = (ngx_int_t )1;
#line 799
        len -= 3UL;
      } else {
        {
#line 801
        tmp___3 = strncmp((char const   *)p, "r/m", (size_t )3);
        }
#line 801
        if (tmp___3 == 0) {
#line 802
          scale = (ngx_int_t )60;
#line 803
          len -= 3UL;
        }
      }
      {
#line 806
      rate = ngx_atoi((value + i)->data + 5, len - 5UL);
      }
#line 807
      if (rate <= 0L) {
        {
#line 808
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid rate \"%V\"", value + i);
        }
#line 810
        return ((char *)((void *)-1));
      }
#line 813
      goto __Cont;
    }
    {
#line 816
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 818
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 756
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 821
  if (name.len == 0UL) {
    {
#line 822
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"zone\" parameter",
                       & cmd->name);
    }
#line 825
    return ((char *)((void *)-1));
  }
  {
#line 828
  ctx->rate = (ngx_uint_t )((rate * 1000L) / scale);
#line 830
  shm_zone = ngx_shared_memory_add(cf, & name, (size_t )size, (void *)(& ngx_http_limit_req_module));
  }
#line 832
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 833
    return ((char *)((void *)-1));
  }
#line 836
  if (shm_zone->data) {
    {
#line 837
    ctx = (ngx_http_limit_req_ctx_t *)shm_zone->data;
#line 839
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V \"%V\" is already bound to key \"%V\"",
                       & cmd->name, & name, & ctx->key.value);
    }
#line 842
    return ((char *)((void *)-1));
  }
#line 845
  shm_zone->init = & ngx_http_limit_req_init_zone;
#line 846
  shm_zone->data = (void *)ctx;
#line 848
  return ((char *)((void *)0));
}
}
#line 852 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static char *ngx_http_limit_req(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_limit_req_conf_t *lrcf ;
  ngx_int_t burst ;
  ngx_str_t *value ;
  ngx_str_t s ;
  ngx_uint_t i ;
  ngx_uint_t nodelay ;
  ngx_shm_zone_t *shm_zone ;
  ngx_http_limit_req_limit_t *limit ;
  ngx_http_limit_req_limit_t *limits ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 855
  lrcf = (ngx_http_limit_req_conf_t *)conf;
#line 863
  value = (ngx_str_t *)(cf->args)->elts;
#line 865
  shm_zone = (ngx_shm_zone_t *)((void *)0);
#line 866
  burst = (ngx_int_t )0;
#line 867
  nodelay = (ngx_uint_t )0;
#line 869
  i = (ngx_uint_t )1;
  {
#line 869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 869
    if (! (i < (cf->args)->nelts)) {
#line 869
      goto while_break;
    }
    {
#line 871
    tmp = strncmp((char const   *)(value + i)->data, "zone=", (size_t )5);
    }
#line 871
    if (tmp == 0) {
      {
#line 873
      s.len = (value + i)->len - 5UL;
#line 874
      s.data = (value + i)->data + 5;
#line 876
      shm_zone = ngx_shared_memory_add(cf, & s, (size_t )0, (void *)(& ngx_http_limit_req_module));
      }
#line 878
      if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 879
        return ((char *)((void *)-1));
      }
#line 882
      goto __Cont;
    }
    {
#line 885
    tmp___0 = strncmp((char const   *)(value + i)->data, "burst=", (size_t )6);
    }
#line 885
    if (tmp___0 == 0) {
      {
#line 887
      burst = ngx_atoi((value + i)->data + 6, (value + i)->len - 6UL);
      }
#line 888
      if (burst <= 0L) {
        {
#line 889
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid burst rate \"%V\"", value + i);
        }
#line 891
        return ((char *)((void *)-1));
      }
#line 894
      goto __Cont;
    }
    {
#line 897
    tmp___1 = strcmp((char const   *)(value + i)->data, "nodelay");
    }
#line 897
    if (tmp___1 == 0) {
#line 898
      nodelay = (ngx_uint_t )1;
#line 899
      goto __Cont;
    }
    {
#line 902
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 904
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 869
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 907
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
    {
#line 908
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"zone\" parameter",
                       & cmd->name);
    }
#line 911
    return ((char *)((void *)-1));
  }
#line 914
  limits = (ngx_http_limit_req_limit_t *)lrcf->limits.elts;
#line 916
  if ((unsigned long )limits == (unsigned long )((void *)0)) {
    {
#line 917
    tmp___2 = ngx_array_init(& lrcf->limits, cf->pool, (ngx_uint_t )1, sizeof(ngx_http_limit_req_limit_t ));
    }
#line 917
    if (tmp___2 != 0L) {
#line 921
      return ((char *)((void *)-1));
    }
  }
#line 925
  i = (ngx_uint_t )0;
  {
#line 925
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 925
    if (! (i < lrcf->limits.nelts)) {
#line 925
      goto while_break___0;
    }
#line 926
    if ((unsigned long )shm_zone == (unsigned long )(limits + i)->shm_zone) {
#line 927
      return ((char *)"is duplicate");
    }
#line 925
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 931
  tmp___3 = ngx_array_push(& lrcf->limits);
#line 931
  limit = (ngx_http_limit_req_limit_t *)tmp___3;
  }
#line 932
  if ((unsigned long )limit == (unsigned long )((void *)0)) {
#line 933
    return ((char *)((void *)-1));
  }
#line 936
  limit->shm_zone = shm_zone;
#line 937
  limit->burst = (ngx_uint_t )(burst * 1000L);
#line 938
  limit->nodelay = nodelay;
#line 940
  return ((char *)((void *)0));
}
}
#line 944 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_req_module.c"
static ngx_int_t ngx_http_limit_req_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 950
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 952
  tmp = ngx_array_push(& cmcf->phases[5].handlers);
#line 952
  h = (ngx_http_handler_pt *)tmp;
  }
#line 953
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 954
    return ((ngx_int_t )-1);
  }
#line 957
  *h = & ngx_http_limit_req_handler;
#line 959
  return ((ngx_int_t )0);
}
}
#line 86 "src/core/ngx_palloc.h"
ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p , size_t size ) ;
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_rbtree_node_t *ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree , ngx_str_t *key ,
                                                     uint32_t hash ) ;
#line 48
static void ngx_http_limit_conn_cleanup(void *data ) ;
#line 49
__inline static void ngx_http_limit_conn_cleanup_all(ngx_pool_t *pool ) ;
#line 51
static void *ngx_http_limit_conn_create_conf(ngx_conf_t *cf ) ;
#line 52
static char *ngx_http_limit_conn_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 54
static char *ngx_http_limit_conn_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 56
static char *ngx_http_limit_conn(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 58
static ngx_int_t ngx_http_limit_conn_init(ngx_conf_t *cf ) ;
#line 61 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_conf_enum_t ngx_http_limit_conn_log_levels[5]  = {      {{sizeof("info") - 1UL, (u_char *)"info"}, (ngx_uint_t )7}, 
        {{sizeof("notice") - 1UL, (u_char *)"notice"}, (ngx_uint_t )6}, 
        {{sizeof("warn") - 1UL, (u_char *)"warn"}, (ngx_uint_t )5}, 
        {{sizeof("error") - 1UL, (u_char *)"error"}, (ngx_uint_t )4}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 70 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_conf_num_bounds_t ngx_http_limit_conn_status_bounds  =    {& ngx_conf_check_num_bounds, (ngx_int_t )400, (ngx_int_t )599};
#line 75 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_command_t ngx_http_limit_conn_commands[5]  = {      {{sizeof("limit_conn_zone") - 1UL, (u_char *)"limit_conn_zone"}, (ngx_uint_t )33554436,
      & ngx_http_limit_conn_zone, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_conn") - 1UL, (u_char *)"limit_conn"}, (ngx_uint_t )234881028,
      & ngx_http_limit_conn, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_conn_log_level") - 1UL, (u_char *)"limit_conn_log_level"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_limit_conn_conf_t *)0)->log_level), (void *)(& ngx_http_limit_conn_log_levels)}, 
        {{sizeof("limit_conn_status") - 1UL,
       (u_char *)"limit_conn_status"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_limit_conn_conf_t *)0)->status_code),
      (void *)(& ngx_http_limit_conn_status_bounds)}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 109 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_http_module_t ngx_http_limit_conn_module_ctx  = 
#line 109
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_limit_conn_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_limit_conn_create_conf,
    & ngx_http_limit_conn_merge_conf};
#line 124 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
ngx_module_t ngx_http_limit_conn_module  = 
#line 124
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_limit_conn_module_ctx),
    ngx_http_limit_conn_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 140 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_int_t ngx_http_limit_conn_handler(ngx_http_request_t *r ) 
{ 
  size_t n ;
  uint32_t hash ;
  ngx_str_t key ;
  ngx_uint_t i ;
  ngx_slab_pool_t *shpool ;
  ngx_rbtree_node_t *node ;
  ngx_pool_cleanup_t *cln ;
  ngx_http_limit_conn_ctx_t *ctx ;
  ngx_http_limit_conn_node_t *lc ;
  ngx_http_limit_conn_conf_t *lccf ;
  ngx_http_limit_conn_limit_t *limits ;
  ngx_http_limit_conn_cleanup_t *lccln ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 156
  if ((r->main)->limit_conn_set) {
#line 157
    return ((ngx_int_t )-5);
  }
#line 160
  lccf = (ngx_http_limit_conn_conf_t *)*(r->loc_conf + ngx_http_limit_conn_module.ctx_index);
#line 161
  limits = (ngx_http_limit_conn_limit_t *)lccf->limits.elts;
#line 163
  i = (ngx_uint_t )0;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (i < lccf->limits.nelts)) {
#line 163
      goto while_break;
    }
    {
#line 164
    ctx = (ngx_http_limit_conn_ctx_t *)((limits + i)->shm_zone)->data;
#line 166
    tmp = ngx_http_complex_value(r, & ctx->key, & key);
    }
#line 166
    if (tmp != 0L) {
#line 167
      return ((ngx_int_t )500);
    }
#line 170
    if (key.len == 0UL) {
#line 171
      goto __Cont;
    }
#line 174
    if (key.len > 255UL) {
#line 175
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 175
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the value of the \"%V\" key is more than 255 bytes: \"%V\"",
                           & ctx->key.value, & key);
        }
      }
#line 179
      goto __Cont;
    }
    {
#line 182
    (r->main)->limit_conn_set = 1U;
#line 184
    hash = ngx_crc32_short(key.data, key.len);
#line 186
    shpool = (ngx_slab_pool_t *)((limits + i)->shm_zone)->shm.addr;
#line 188
    ngx_shmtx_lock(& shpool->mutex);
#line 190
    node = ngx_http_limit_conn_lookup(ctx->rbtree, & key, hash);
    }
#line 192
    if ((unsigned long )node == (unsigned long )((void *)0)) {
      {
#line 194
      n = ((unsigned long )(& ((ngx_rbtree_node_t *)0)->color) + (unsigned long )(& ((ngx_http_limit_conn_node_t *)0)->data)) + key.len;
#line 198
      tmp___0 = ngx_slab_alloc_locked(shpool, n);
#line 198
      node = (ngx_rbtree_node_t *)tmp___0;
      }
#line 200
      if ((unsigned long )node == (unsigned long )((void *)0)) {
        {
#line 201
        ngx_shmtx_unlock(& shpool->mutex);
#line 202
        ngx_http_limit_conn_cleanup_all(r->pool);
        }
#line 203
        return ((ngx_int_t )lccf->status_code);
      }
      {
#line 206
      lc = (ngx_http_limit_conn_node_t *)(& node->color);
#line 208
      node->key = (ngx_rbtree_key_t )hash;
#line 209
      lc->len = (u_char )key.len;
#line 210
      lc->conn = (u_short )1;
#line 211
      memcpy((void */* __restrict  */)(lc->data), (void const   */* __restrict  */)key.data,
             key.len);
#line 213
      ngx_rbtree_insert(ctx->rbtree, node);
      }
    } else {
#line 217
      lc = (ngx_http_limit_conn_node_t *)(& node->color);
#line 219
      if ((ngx_uint_t )lc->conn >= (limits + i)->conn) {
        {
#line 221
        ngx_shmtx_unlock(& shpool->mutex);
        }
#line 223
        if (((r->connection)->log)->log_level >= lccf->log_level) {
          {
#line 223
          ngx_log_error_core(lccf->log_level, (r->connection)->log, 0, "limiting connections by zone \"%V\"",
                             & ((limits + i)->shm_zone)->shm.name);
          }
        }
        {
#line 227
        ngx_http_limit_conn_cleanup_all(r->pool);
        }
#line 228
        return ((ngx_int_t )lccf->status_code);
      }
#line 231
      lc->conn = (u_short )((int )lc->conn + 1);
    }
    {
#line 237
    ngx_shmtx_unlock(& shpool->mutex);
#line 239
    cln = ngx_pool_cleanup_add(r->pool, sizeof(ngx_http_limit_conn_cleanup_t ));
    }
#line 241
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 242
      return ((ngx_int_t )500);
    }
#line 245
    cln->handler = & ngx_http_limit_conn_cleanup;
#line 246
    lccln = (ngx_http_limit_conn_cleanup_t *)cln->data;
#line 248
    lccln->shm_zone = (limits + i)->shm_zone;
#line 249
    lccln->node = node;
    __Cont: /* CIL Label */ 
#line 163
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return ((ngx_int_t )-5);
}
}
#line 256 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static void ngx_http_limit_conn_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_http_limit_conn_node_t *lcn ;
  ngx_http_limit_conn_node_t *lcnt ;
  ngx_int_t tmp___0 ;

  {
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 265
    if (node->key < temp->key) {
#line 267
      p = & temp->left;
    } else
#line 269
    if (node->key > temp->key) {
#line 271
      p = & temp->right;
    } else {
      {
#line 275
      lcn = (ngx_http_limit_conn_node_t *)(& node->color);
#line 276
      lcnt = (ngx_http_limit_conn_node_t *)(& temp->color);
#line 278
      tmp___0 = ngx_memn2cmp(lcn->data, lcnt->data, (size_t )lcn->len, (size_t )lcnt->len);
      }
#line 278
      if (tmp___0 < 0L) {
#line 278
        p = & temp->left;
      } else {
#line 278
        p = & temp->right;
      }
    }
#line 282
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 283
      goto while_break;
    }
#line 286
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  *p = node;
#line 290
  node->parent = temp;
#line 291
  node->left = sentinel;
#line 292
  node->right = sentinel;
#line 293
  node->color = (u_char )1;
#line 294
  return;
}
}
#line 297 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_rbtree_node_t *ngx_http_limit_conn_lookup(ngx_rbtree_t *rbtree , ngx_str_t *key ,
                                                     uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_http_limit_conn_node_t *lcn ;

  {
#line 304
  node = rbtree->root;
#line 305
  sentinel = rbtree->sentinel;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 307
      goto while_break;
    }
#line 309
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 310
      node = node->left;
#line 311
      goto while_continue;
    }
#line 314
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 315
      node = node->right;
#line 316
      goto while_continue;
    }
    {
#line 321
    lcn = (ngx_http_limit_conn_node_t *)(& node->color);
#line 323
    rc = ngx_memn2cmp(key->data, lcn->data, key->len, (size_t )lcn->len);
    }
#line 325
    if (rc == 0L) {
#line 326
      return (node);
    }
#line 329
    if (rc < 0L) {
#line 329
      node = node->left;
    } else {
#line 329
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 332
  return ((ngx_rbtree_node_t *)((void *)0));
}
}
#line 336 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static void ngx_http_limit_conn_cleanup(void *data ) 
{ 
  ngx_http_limit_conn_cleanup_t *lccln ;
  ngx_slab_pool_t *shpool ;
  ngx_rbtree_node_t *node ;
  ngx_http_limit_conn_ctx_t *ctx ;
  ngx_http_limit_conn_node_t *lc ;

  {
  {
#line 339
  lccln = (ngx_http_limit_conn_cleanup_t *)data;
#line 346
  ctx = (ngx_http_limit_conn_ctx_t *)(lccln->shm_zone)->data;
#line 347
  shpool = (ngx_slab_pool_t *)(lccln->shm_zone)->shm.addr;
#line 348
  node = lccln->node;
#line 349
  lc = (ngx_http_limit_conn_node_t *)(& node->color);
#line 351
  ngx_shmtx_lock(& shpool->mutex);
#line 356
  lc->conn = (u_short )((int )lc->conn - 1);
  }
#line 358
  if ((int )lc->conn == 0) {
    {
#line 359
    ngx_rbtree_delete(ctx->rbtree, node);
#line 360
    ngx_slab_free_locked(shpool, (void *)node);
    }
  }
  {
#line 363
  ngx_shmtx_unlock(& shpool->mutex);
  }
#line 364
  return;
}
}
#line 367 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
__inline static void ngx_http_limit_conn_cleanup_all(ngx_pool_t *pool ) 
{ 
  ngx_pool_cleanup_t *cln ;

  {
#line 372
  cln = pool->cleanup;
  {
#line 374
  while (1) {
    while_continue: /* CIL Label */ ;
#line 374
    if (cln) {
#line 374
      if (! ((unsigned long )cln->handler == (unsigned long )(& ngx_http_limit_conn_cleanup))) {
#line 374
        goto while_break;
      }
    } else {
#line 374
      goto while_break;
    }
    {
#line 375
    ngx_http_limit_conn_cleanup(cln->data);
#line 376
    cln = cln->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 379
  pool->cleanup = cln;
#line 380
  return;
}
}
#line 383 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_int_t ngx_http_limit_conn_init_zone(ngx_shm_zone_t *shm_zone , void *data ) 
{ 
  ngx_http_limit_conn_ctx_t *octx ;
  size_t len ;
  ngx_slab_pool_t *shpool ;
  ngx_rbtree_node_t *sentinel ;
  ngx_http_limit_conn_ctx_t *ctx ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 386
  octx = (ngx_http_limit_conn_ctx_t *)data;
#line 393
  ctx = (ngx_http_limit_conn_ctx_t *)shm_zone->data;
#line 395
  if (octx) {
#line 396
    if (ctx->key.value.len != octx->key.value.len) {
#line 396
      goto _L;
    } else {
      {
#line 396
      tmp = strncmp((char const   *)ctx->key.value.data, (char const   *)octx->key.value.data,
                    ctx->key.value.len);
      }
#line 396
      if (tmp != 0) {
        _L: /* CIL Label */ 
#line 401
        if ((shm_zone->shm.log)->log_level >= 1UL) {
          {
#line 401
          ngx_log_error_core((ngx_uint_t )1, shm_zone->shm.log, 0, "limit_conn_zone \"%V\" uses the \"%V\" key while previously it used the \"%V\" key",
                             & shm_zone->shm.name, & ctx->key.value, & octx->key.value);
          }
        }
#line 406
        return ((ngx_int_t )-1);
      }
    }
#line 409
    ctx->rbtree = octx->rbtree;
#line 411
    return ((ngx_int_t )0);
  }
#line 414
  shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;
#line 416
  if (shm_zone->shm.exists) {
#line 417
    ctx->rbtree = (ngx_rbtree_t *)shpool->data;
#line 419
    return ((ngx_int_t )0);
  }
  {
#line 422
  tmp___0 = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_t ));
#line 422
  ctx->rbtree = (ngx_rbtree_t *)tmp___0;
  }
#line 423
  if ((unsigned long )ctx->rbtree == (unsigned long )((void *)0)) {
#line 424
    return ((ngx_int_t )-1);
  }
  {
#line 427
  shpool->data = (void *)ctx->rbtree;
#line 429
  tmp___1 = ngx_slab_alloc(shpool, sizeof(ngx_rbtree_node_t ));
#line 429
  sentinel = (ngx_rbtree_node_t *)tmp___1;
  }
#line 430
  if ((unsigned long )sentinel == (unsigned long )((void *)0)) {
#line 431
    return ((ngx_int_t )-1);
  }
  {
#line 434
  sentinel->color = (u_char )0;
#line 434
  (ctx->rbtree)->root = sentinel;
#line 434
  (ctx->rbtree)->sentinel = sentinel;
#line 434
  (ctx->rbtree)->insert = & ngx_http_limit_conn_rbtree_insert_value;
#line 437
  len = sizeof(" in limit_conn_zone \"\"") + shm_zone->shm.name.len;
#line 439
  tmp___2 = ngx_slab_alloc(shpool, len);
#line 439
  shpool->log_ctx = (u_char *)tmp___2;
  }
#line 440
  if ((unsigned long )shpool->log_ctx == (unsigned long )((void *)0)) {
#line 441
    return ((ngx_int_t )-1);
  }
  {
#line 444
  ngx_sprintf(shpool->log_ctx, " in limit_conn_zone \"%V\"%Z", & shm_zone->shm.name);
  }
#line 447
  return ((ngx_int_t )0);
}
}
#line 451 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static void *ngx_http_limit_conn_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_limit_conn_conf_t *conf ;
  void *tmp ;

  {
  {
#line 456
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_conn_conf_t ));
#line 456
  conf = (ngx_http_limit_conn_conf_t *)tmp;
  }
#line 457
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 458
    return ((void *)0);
  }
#line 467
  conf->log_level = (ngx_uint_t )-1;
#line 468
  conf->status_code = (ngx_uint_t )-1;
#line 470
  return ((void *)conf);
}
}
#line 474 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static char *ngx_http_limit_conn_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_limit_conn_conf_t *prev ;
  ngx_http_limit_conn_conf_t *conf ;

  {
#line 477
  prev = (ngx_http_limit_conn_conf_t *)parent;
#line 478
  conf = (ngx_http_limit_conn_conf_t *)child;
#line 480
  if ((unsigned long )conf->limits.elts == (unsigned long )((void *)0)) {
#line 481
    conf->limits = prev->limits;
  }
#line 484
  if (conf->log_level == 0xffffffffffffffffUL) {
#line 484
    if (prev->log_level == 0xffffffffffffffffUL) {
#line 484
      conf->log_level = (ngx_uint_t )4;
    } else {
#line 484
      conf->log_level = prev->log_level;
    }
  }
#line 485
  if (conf->status_code == 0xffffffffffffffffUL) {
#line 485
    if (prev->status_code == 0xffffffffffffffffUL) {
#line 485
      conf->status_code = (ngx_uint_t )503;
    } else {
#line 485
      conf->status_code = prev->status_code;
    }
  }
#line 488
  return ((char *)((void *)0));
}
}
#line 492 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static char *ngx_http_limit_conn_zone(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  u_char *p ;
  ssize_t size ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_str_t s ;
  ngx_uint_t i ;
  ngx_shm_zone_t *shm_zone ;
  ngx_http_limit_conn_ctx_t *ctx ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
  {
#line 503
  value = (ngx_str_t *)(cf->args)->elts;
#line 505
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_limit_conn_ctx_t ));
#line 505
  ctx = (ngx_http_limit_conn_ctx_t *)tmp;
  }
#line 506
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 507
    return ((char *)((void *)-1));
  }
  {
#line 510
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 512
  ccv.cf = cf;
#line 513
  ccv.value = value + 1;
#line 514
  ccv.complex_value = & ctx->key;
#line 516
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 516
  if (tmp___0 != 0L) {
#line 517
    return ((char *)((void *)-1));
  }
#line 520
  size = (ssize_t )0;
#line 521
  name.len = (size_t )0;
#line 523
  i = (ngx_uint_t )2;
  {
#line 523
  while (1) {
    while_continue: /* CIL Label */ ;
#line 523
    if (! (i < (cf->args)->nelts)) {
#line 523
      goto while_break;
    }
    {
#line 525
    tmp___2 = strncmp((char const   *)(value + i)->data, "zone=", (size_t )5);
    }
#line 525
    if (tmp___2 == 0) {
      {
#line 527
      name.data = (value + i)->data + 5;
#line 529
      tmp___1 = strchr((char const   *)name.data, ':');
#line 529
      p = (u_char *)tmp___1;
      }
#line 531
      if ((unsigned long )p == (unsigned long )((void *)0)) {
        {
#line 532
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + i);
        }
#line 534
        return ((char *)((void *)-1));
      }
      {
#line 537
      name.len = (size_t )(p - name.data);
#line 539
      s.data = p + 1;
#line 540
      s.len = (size_t )(((value + i)->data + (value + i)->len) - s.data);
#line 542
      size = ngx_parse_size(& s);
      }
#line 544
      if (size == -1L) {
        {
#line 545
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid zone size \"%V\"", value + i);
        }
#line 547
        return ((char *)((void *)-1));
      }
#line 550
      if (size < (ssize_t )(8UL * ngx_pagesize)) {
        {
#line 551
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "zone \"%V\" is too small", value + i);
        }
#line 553
        return ((char *)((void *)-1));
      }
#line 556
      goto __Cont;
    }
    {
#line 559
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 561
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 523
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  if (name.len == 0UL) {
    {
#line 565
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"zone\" parameter",
                       & cmd->name);
    }
#line 568
    return ((char *)((void *)-1));
  }
  {
#line 571
  shm_zone = ngx_shared_memory_add(cf, & name, (size_t )size, (void *)(& ngx_http_limit_conn_module));
  }
#line 573
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 574
    return ((char *)((void *)-1));
  }
#line 577
  if (shm_zone->data) {
    {
#line 578
    ctx = (ngx_http_limit_conn_ctx_t *)shm_zone->data;
#line 580
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V \"%V\" is already bound to key \"%V\"",
                       & cmd->name, & name, & ctx->key.value);
    }
#line 583
    return ((char *)((void *)-1));
  }
#line 586
  shm_zone->init = & ngx_http_limit_conn_init_zone;
#line 587
  shm_zone->data = (void *)ctx;
#line 589
  return ((char *)((void *)0));
}
}
#line 593 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static char *ngx_http_limit_conn(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_shm_zone_t *shm_zone ;
  ngx_http_limit_conn_conf_t *lccf ;
  ngx_http_limit_conn_limit_t *limit ;
  ngx_http_limit_conn_limit_t *limits ;
  ngx_str_t *value ;
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 597
  lccf = (ngx_http_limit_conn_conf_t *)conf;
#line 604
  value = (ngx_str_t *)(cf->args)->elts;
#line 606
  shm_zone = ngx_shared_memory_add(cf, value + 1, (size_t )0, (void *)(& ngx_http_limit_conn_module));
  }
#line 608
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 609
    return ((char *)((void *)-1));
  }
#line 612
  limits = (ngx_http_limit_conn_limit_t *)lccf->limits.elts;
#line 614
  if ((unsigned long )limits == (unsigned long )((void *)0)) {
    {
#line 615
    tmp = ngx_array_init(& lccf->limits, cf->pool, (ngx_uint_t )1, sizeof(ngx_http_limit_conn_limit_t ));
    }
#line 615
    if (tmp != 0L) {
#line 619
      return ((char *)((void *)-1));
    }
  }
#line 623
  i = (ngx_uint_t )0;
  {
#line 623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 623
    if (! (i < lccf->limits.nelts)) {
#line 623
      goto while_break;
    }
#line 624
    if ((unsigned long )shm_zone == (unsigned long )(limits + i)->shm_zone) {
#line 625
      return ((char *)"is duplicate");
    }
#line 623
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 629
  n = ngx_atoi((value + 2)->data, (value + 2)->len);
  }
#line 630
  if (n <= 0L) {
    {
#line 631
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of connections \"%V\"",
                       value + 2);
    }
#line 633
    return ((char *)((void *)-1));
  }
#line 636
  if (n > 65535L) {
    {
#line 637
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "connection limit must be less 65536");
    }
#line 639
    return ((char *)((void *)-1));
  }
  {
#line 642
  tmp___0 = ngx_array_push(& lccf->limits);
#line 642
  limit = (ngx_http_limit_conn_limit_t *)tmp___0;
  }
#line 643
  if ((unsigned long )limit == (unsigned long )((void *)0)) {
#line 644
    return ((char *)((void *)-1));
  }
#line 647
  limit->conn = (ngx_uint_t )n;
#line 648
  limit->shm_zone = shm_zone;
#line 650
  return ((char *)((void *)0));
}
}
#line 654 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_limit_conn_module.c"
static ngx_int_t ngx_http_limit_conn_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 660
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 662
  tmp = ngx_array_push(& cmcf->phases[5].handlers);
#line 662
  h = (ngx_http_handler_pt *)tmp;
  }
#line 663
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 664
    return ((ngx_int_t )-1);
  }
#line 667
  *h = & ngx_http_limit_conn_handler;
#line 669
  return ((ngx_int_t )0);
}
}
#line 48 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_handler(ngx_http_request_t *r ) ;
#line 49
static ngx_int_t ngx_http_access_inet(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ,
                                      in_addr_t addr ) ;
#line 52
static ngx_int_t ngx_http_access_inet6(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ,
                                       u_char *p ) ;
#line 56
static ngx_int_t ngx_http_access_unix(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ) ;
#line 59
static ngx_int_t ngx_http_access_found(ngx_http_request_t *r , ngx_uint_t deny ) ;
#line 60
static char *ngx_http_access_rule(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 62
static void *ngx_http_access_create_loc_conf(ngx_conf_t *cf ) ;
#line 63
static char *ngx_http_access_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 65
static ngx_int_t ngx_http_access_init(ngx_conf_t *cf ) ;
#line 68 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_command_t ngx_http_access_commands[3]  = {      {{sizeof("allow") - 1UL, (u_char *)"allow"}, (ngx_uint_t )2382364674U, & ngx_http_access_rule,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("deny") - 1UL,
       (u_char *)"deny"}, (ngx_uint_t )2382364674U, & ngx_http_access_rule, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 91 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_http_module_t ngx_http_access_module_ctx  = 
#line 91
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_access_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_access_create_loc_conf,
    & ngx_http_access_merge_loc_conf};
#line 106 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
ngx_module_t ngx_http_access_module  = 
#line 106
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_access_module_ctx),
    ngx_http_access_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 122 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_handler(ngx_http_request_t *r ) 
{ 
  struct sockaddr_in *sin ;
  ngx_http_access_loc_conf_t *alcf ;
  u_char *p ;
  in_addr_t addr ;
  struct sockaddr_in6 *sin6 ;
  ngx_int_t tmp ;
  uint32_t tmp___0 ;
  ngx_int_t tmp___1 ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;

  {
#line 133
  alcf = (ngx_http_access_loc_conf_t *)*(r->loc_conf + ngx_http_access_module.ctx_index);
  {
#line 137
  if ((int )((r->connection)->sockaddr)->sa_family == 2) {
#line 137
    goto case_2;
  }
#line 146
  if ((int )((r->connection)->sockaddr)->sa_family == 10) {
#line 146
    goto case_10;
  }
#line 168
  if ((int )((r->connection)->sockaddr)->sa_family == 1) {
#line 168
    goto case_1;
  }
#line 135
  goto switch_break;
  case_2: /* CIL Label */ 
#line 138
  if (alcf->rules) {
    {
#line 139
    sin = (struct sockaddr_in *)(r->connection)->sockaddr;
#line 140
    tmp = ngx_http_access_inet(r, alcf, sin->sin_addr.s_addr);
    }
#line 140
    return (tmp);
  }
#line 142
  goto switch_break;
  case_10: /* CIL Label */ 
#line 147
  sin6 = (struct sockaddr_in6 *)(r->connection)->sockaddr;
#line 148
  p = sin6->sin6_addr.__in6_u.__u6_addr8;
#line 150
  if (alcf->rules) {
#line 150
    __a = (struct in6_addr  const  *)(& sin6->sin6_addr);
#line 150
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 150
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
        {
#line 150
        tmp___2 = htonl((uint32_t )65535);
        }
#line 150
        if (__a->__in6_u.__u6_addr32[2] == tmp___2) {
#line 150
          tmp___3 = 1;
        } else {
#line 150
          tmp___3 = 0;
        }
      } else {
#line 150
        tmp___3 = 0;
      }
    } else {
#line 150
      tmp___3 = 0;
    }
#line 150
    if (tmp___3) {
      {
#line 151
      addr = (in_addr_t )((int )*(p + 12) << 24);
#line 152
      addr += (in_addr_t )((int )*(p + 13) << 16);
#line 153
      addr += (in_addr_t )((int )*(p + 14) << 8);
#line 154
      addr += (in_addr_t )*(p + 15);
#line 155
      tmp___0 = htonl(addr);
#line 155
      tmp___1 = ngx_http_access_inet(r, alcf, tmp___0);
      }
#line 155
      return (tmp___1);
    }
  }
#line 158
  if (alcf->rules6) {
    {
#line 159
    tmp___4 = ngx_http_access_inet6(r, alcf, p);
    }
#line 159
    return (tmp___4);
  }
#line 162
  goto switch_break;
  case_1: /* CIL Label */ 
#line 169
  if (alcf->rules_un) {
    {
#line 170
    tmp___5 = ngx_http_access_unix(r, alcf);
    }
#line 170
    return (tmp___5);
  }
#line 173
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 178
  return ((ngx_int_t )-5);
}
}
#line 182 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_inet(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ,
                                      in_addr_t addr ) 
{ 
  ngx_uint_t i ;
  ngx_http_access_rule_t *rule ;
  ngx_int_t tmp ;

  {
#line 189
  rule = (ngx_http_access_rule_t *)(alcf->rules)->elts;
#line 190
  i = (ngx_uint_t )0;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i < (alcf->rules)->nelts)) {
#line 190
      goto while_break;
    }
#line 196
    if ((addr & (rule + i)->mask) == (rule + i)->addr) {
      {
#line 197
      tmp = ngx_http_access_found(r, (rule + i)->deny);
      }
#line 197
      return (tmp);
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  return ((ngx_int_t )-5);
}
}
#line 207 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_inet6(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ,
                                       u_char *p ) 
{ 
  ngx_uint_t n ;
  ngx_uint_t i ;
  ngx_http_access_rule6_t *rule6 ;
  ngx_int_t tmp ;

  {
#line 215
  rule6 = (ngx_http_access_rule6_t *)(alcf->rules6)->elts;
#line 216
  i = (ngx_uint_t )0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (! (i < (alcf->rules6)->nelts)) {
#line 216
      goto while_break;
    }
#line 234
    n = (ngx_uint_t )0;
    {
#line 234
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 234
      if (! (n < 16UL)) {
#line 234
        goto while_break___0;
      }
#line 235
      if (((int )*(p + n) & (int )(rule6 + i)->mask.__in6_u.__u6_addr8[n]) != (int )(rule6 + i)->addr.__in6_u.__u6_addr8[n]) {
#line 236
        goto next;
      }
#line 234
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 240
    tmp = ngx_http_access_found(r, (rule6 + i)->deny);
    }
#line 240
    return (tmp);
    next: 
#line 243
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return ((ngx_int_t )-5);
}
}
#line 254 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_unix(ngx_http_request_t *r , ngx_http_access_loc_conf_t *alcf ) 
{ 
  ngx_uint_t i ;
  ngx_http_access_rule_un_t *rule_un ;
  ngx_int_t tmp ;

  {
#line 260
  rule_un = (ngx_http_access_rule_un_t *)(alcf->rules_un)->elts;
#line 261
  i = (ngx_uint_t )0;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! (i < (alcf->rules_un)->nelts)) {
#line 261
      goto while_break;
    }
    {
#line 265
    tmp = ngx_http_access_found(r, (rule_un + i)->deny);
    }
#line 265
    return (tmp);
#line 261
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 269
  return ((ngx_int_t )-5);
}
}
#line 275 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_found(ngx_http_request_t *r , ngx_uint_t deny ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  char *__cil_tmp4 ;

  {
#line 280
  if (deny) {
#line 281
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 283
    if (clcf->satisfy == 0UL) {
#line 284
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 284
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "access forbidden by rule");
        }
      }
    }
#line 288
    return ((ngx_int_t )403);
  }
#line 291
  return ((ngx_int_t )0);
}
}
#line 295 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static char *ngx_http_access_rule(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_access_loc_conf_t *alcf ;
  ngx_int_t rc ;
  ngx_uint_t all ;
  ngx_str_t *value ;
  ngx_cidr_t cidr ;
  ngx_http_access_rule_t *rule ;
  ngx_http_access_rule6_t *rule6 ;
  ngx_http_access_rule_un_t *rule_un ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 298
  alcf = (ngx_http_access_loc_conf_t *)conf;
#line 312
  all = (ngx_uint_t )0;
#line 313
  memset((void *)(& cidr), 0, sizeof(ngx_cidr_t ));
#line 315
  value = (ngx_str_t *)(cf->args)->elts;
  }
#line 317
  if ((value + 1)->len == 3UL) {
    {
#line 317
    tmp___0 = strcmp((char const   *)(value + 1)->data, "all");
    }
#line 317
    if (tmp___0 == 0) {
#line 318
      all = (ngx_uint_t )1;
    } else {
#line 317
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 321
  if ((value + 1)->len == 5UL) {
    {
#line 321
    tmp = strcmp((char const   *)(value + 1)->data, "unix:");
    }
#line 321
    if (tmp == 0) {
#line 322
      cidr.family = (ngx_uint_t )1;
    } else {
#line 321
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 326
    rc = ngx_ptocidr(value + 1, & cidr);
    }
#line 328
    if (rc == -1L) {
      {
#line 329
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 1);
      }
#line 331
      return ((char *)((void *)-1));
    }
#line 334
    if (rc == -4L) {
      {
#line 335
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "low address bits of %V are meaningless",
                         value + 1);
      }
    }
  }
#line 340
  if (cidr.family == 2UL) {
#line 340
    goto _L___1;
  } else
#line 340
  if (all) {
    _L___1: /* CIL Label */ 
#line 342
    if ((unsigned long )alcf->rules == (unsigned long )((void *)0)) {
      {
#line 343
      alcf->rules = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_access_rule_t ));
      }
#line 345
      if ((unsigned long )alcf->rules == (unsigned long )((void *)0)) {
#line 346
        return ((char *)((void *)-1));
      }
    }
    {
#line 350
    tmp___1 = ngx_array_push(alcf->rules);
#line 350
    rule = (ngx_http_access_rule_t *)tmp___1;
    }
#line 351
    if ((unsigned long )rule == (unsigned long )((void *)0)) {
#line 352
      return ((char *)((void *)-1));
    }
#line 355
    rule->mask = cidr.u.in.mask;
#line 356
    rule->addr = cidr.u.in.addr;
#line 357
    if ((int )*((value + 0)->data + 0) == 100) {
#line 357
      rule->deny = (ngx_uint_t )1;
    } else {
#line 357
      rule->deny = (ngx_uint_t )0;
    }
  }
#line 361
  if (cidr.family == 10UL) {
#line 361
    goto _L___2;
  } else
#line 361
  if (all) {
    _L___2: /* CIL Label */ 
#line 363
    if ((unsigned long )alcf->rules6 == (unsigned long )((void *)0)) {
      {
#line 364
      alcf->rules6 = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_access_rule6_t ));
      }
#line 366
      if ((unsigned long )alcf->rules6 == (unsigned long )((void *)0)) {
#line 367
        return ((char *)((void *)-1));
      }
    }
    {
#line 371
    tmp___2 = ngx_array_push(alcf->rules6);
#line 371
    rule6 = (ngx_http_access_rule6_t *)tmp___2;
    }
#line 372
    if ((unsigned long )rule6 == (unsigned long )((void *)0)) {
#line 373
      return ((char *)((void *)-1));
    }
#line 376
    rule6->mask = cidr.u.in6.mask;
#line 377
    rule6->addr = cidr.u.in6.addr;
#line 378
    if ((int )*((value + 0)->data + 0) == 100) {
#line 378
      rule6->deny = (ngx_uint_t )1;
    } else {
#line 378
      rule6->deny = (ngx_uint_t )0;
    }
  }
#line 383
  if (cidr.family == 1UL) {
#line 383
    goto _L___3;
  } else
#line 383
  if (all) {
    _L___3: /* CIL Label */ 
#line 385
    if ((unsigned long )alcf->rules_un == (unsigned long )((void *)0)) {
      {
#line 386
      alcf->rules_un = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_access_rule_un_t ));
      }
#line 388
      if ((unsigned long )alcf->rules_un == (unsigned long )((void *)0)) {
#line 389
        return ((char *)((void *)-1));
      }
    }
    {
#line 393
    tmp___3 = ngx_array_push(alcf->rules_un);
#line 393
    rule_un = (ngx_http_access_rule_un_t *)tmp___3;
    }
#line 394
    if ((unsigned long )rule_un == (unsigned long )((void *)0)) {
#line 395
      return ((char *)((void *)-1));
    }
#line 398
    if ((int )*((value + 0)->data + 0) == 100) {
#line 398
      rule_un->deny = (ngx_uint_t )1;
    } else {
#line 398
      rule_un->deny = (ngx_uint_t )0;
    }
  }
#line 402
  return ((char *)((void *)0));
}
}
#line 406 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static void *ngx_http_access_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_access_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 411
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_access_loc_conf_t ));
#line 411
  conf = (ngx_http_access_loc_conf_t *)tmp;
  }
#line 412
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 413
    return ((void *)0);
  }
#line 416
  return ((void *)conf);
}
}
#line 420 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static char *ngx_http_access_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_access_loc_conf_t *prev ;
  ngx_http_access_loc_conf_t *conf ;

  {
#line 423
  prev = (ngx_http_access_loc_conf_t *)parent;
#line 424
  conf = (ngx_http_access_loc_conf_t *)child;
#line 426
  if ((unsigned long )conf->rules == (unsigned long )((void *)0)) {
#line 426
    if ((unsigned long )conf->rules6 == (unsigned long )((void *)0)) {
#line 426
      if ((unsigned long )conf->rules_un == (unsigned long )((void *)0)) {
#line 434
        conf->rules = prev->rules;
#line 436
        conf->rules6 = prev->rules6;
#line 439
        conf->rules_un = prev->rules_un;
      }
    }
  }
#line 443
  return ((char *)((void *)0));
}
}
#line 447 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_access_module.c"
static ngx_int_t ngx_http_access_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 453
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 455
  tmp = ngx_array_push(& cmcf->phases[6].handlers);
#line 455
  h = (ngx_http_handler_pt *)tmp;
  }
#line 456
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 457
    return ((ngx_int_t )-1);
  }
#line 460
  *h = & ngx_http_access_handler;
#line 462
  return ((ngx_int_t )0);
}
}
#line 490 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_auth_basic_user(ngx_http_request_t *r ) ;
#line 16 "src/core/ngx_crypt.h"
ngx_int_t ngx_crypt(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_handler(ngx_http_request_t *r ) ;
#line 24
static ngx_int_t ngx_http_auth_basic_crypt_handler(ngx_http_request_t *r , ngx_str_t *passwd ,
                                                   ngx_str_t *realm ) ;
#line 26
static ngx_int_t ngx_http_auth_basic_set_realm(ngx_http_request_t *r , ngx_str_t *realm ) ;
#line 28
static void ngx_http_auth_basic_close(ngx_file_t *file ) ;
#line 29
static void *ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf ) ;
#line 30
static char *ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 32
static ngx_int_t ngx_http_auth_basic_init(ngx_conf_t *cf ) ;
#line 33
static char *ngx_http_auth_basic_user_file(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 37 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_command_t ngx_http_auth_basic_commands[3]  = {      {{sizeof("auth_basic") - 1UL, (u_char *)"auth_basic"}, (ngx_uint_t )2382364674U,
      & ngx_http_set_complex_value_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_auth_basic_loc_conf_t *)0)->realm), (void *)0}, 
        {{sizeof("auth_basic_user_file") - 1UL,
       (u_char *)"auth_basic_user_file"}, (ngx_uint_t )2382364674U, & ngx_http_auth_basic_user_file,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_auth_basic_loc_conf_t *)0)->user_file),
      (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 59 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_http_module_t ngx_http_auth_basic_module_ctx  = 
#line 59
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_auth_basic_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_auth_basic_create_loc_conf,
    & ngx_http_auth_basic_merge_loc_conf};
#line 74 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
ngx_module_t ngx_http_auth_basic_module  = 
#line 74
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_auth_basic_module_ctx),
    ngx_http_auth_basic_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 90 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_handler(ngx_http_request_t *r ) 
{ 
  off_t offset ;
  ssize_t n ;
  ngx_fd_t fd ;
  ngx_int_t rc ;
  ngx_err_t err ;
  ngx_str_t pwd ;
  ngx_str_t realm ;
  ngx_str_t user_file ;
  ngx_uint_t i ;
  ngx_uint_t level ;
  ngx_uint_t login ;
  ngx_uint_t left ;
  ngx_uint_t passwd ;
  ngx_file_t file ;
  ngx_http_auth_basic_loc_conf_t *alcf ;
  u_char buf[2048] ;
  enum __anonenum_state_243 state ;
  ngx_int_t tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  int *tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 109
  alcf = (ngx_http_auth_basic_loc_conf_t *)*(r->loc_conf + ngx_http_auth_basic_module.ctx_index);
#line 111
  if ((unsigned long )alcf->realm == (unsigned long )((void *)0)) {
#line 112
    return ((ngx_int_t )-5);
  } else
#line 111
  if ((unsigned long )alcf->user_file.value.data == (unsigned long )((void *)0)) {
#line 112
    return ((ngx_int_t )-5);
  }
  {
#line 115
  tmp = ngx_http_complex_value(r, alcf->realm, & realm);
  }
#line 115
  if (tmp != 0L) {
#line 116
    return ((ngx_int_t )-1);
  }
#line 119
  if (realm.len == 3UL) {
    {
#line 119
    tmp___0 = strncmp((char const   *)realm.data, "off", (size_t )3);
    }
#line 119
    if (tmp___0 == 0) {
#line 120
      return ((ngx_int_t )-5);
    }
  }
  {
#line 123
  rc = ngx_http_auth_basic_user(r);
  }
#line 125
  if (rc == -5L) {
#line 127
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 127
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "no user/password was provided for basic authentication");
      }
    }
    {
#line 130
    tmp___1 = ngx_http_auth_basic_set_realm(r, & realm);
    }
#line 130
    return (tmp___1);
  }
#line 133
  if (rc == -1L) {
#line 134
    return ((ngx_int_t )500);
  }
  {
#line 137
  tmp___2 = ngx_http_complex_value(r, & alcf->user_file, & user_file);
  }
#line 137
  if (tmp___2 != 0L) {
#line 138
    return ((ngx_int_t )-1);
  }
  {
#line 141
  fd = open((char const   *)user_file.data, 0, 0);
  }
#line 143
  if (fd == -1) {
    {
#line 144
    tmp___3 = __errno_location();
#line 144
    err = *tmp___3;
    }
#line 146
    if (err == 2) {
#line 147
      level = (ngx_uint_t )4;
#line 148
      rc = (ngx_int_t )403;
    } else {
#line 151
      level = (ngx_uint_t )3;
#line 152
      rc = (ngx_int_t )500;
    }
#line 155
    if (((r->connection)->log)->log_level >= level) {
      {
#line 155
      ngx_log_error_core(level, (r->connection)->log, err, "open() \"%s\" failed",
                         user_file.data);
      }
    }
#line 158
    return (rc);
  }
  {
#line 161
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 163
  file.fd = fd;
#line 164
  file.name = user_file;
#line 165
  file.log = (r->connection)->log;
#line 167
  state = (enum __anonenum_state_243 )0;
#line 168
  passwd = (ngx_uint_t )0;
#line 169
  login = (ngx_uint_t )0;
#line 170
  left = (ngx_uint_t )0;
#line 171
  offset = (off_t )0;
  }
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 174
    i = left;
#line 176
    n = ngx_read_file(& file, buf + left, 2048UL - left, offset);
    }
#line 179
    if (n == -1L) {
      {
#line 180
      ngx_http_auth_basic_close(& file);
      }
#line 181
      return ((ngx_int_t )500);
    }
#line 184
    if (n == 0L) {
#line 185
      goto while_break;
    }
#line 188
    i = left;
    {
#line 188
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 188
      if (! (i < left + (ngx_uint_t )n)) {
#line 188
        goto while_break___0;
      }
      {
#line 191
      if ((unsigned int )state == 0U) {
#line 191
        goto case_0;
      }
#line 218
      if ((unsigned int )state == 1U) {
#line 218
        goto case_1;
      }
#line 232
      if ((unsigned int )state == 2U) {
#line 232
        goto case_2;
      }
#line 189
      goto switch_break;
      case_0: /* CIL Label */ 
#line 192
      if (login == 0UL) {
#line 194
        if ((int )buf[i] == 35) {
#line 195
          state = (enum __anonenum_state_243 )2;
#line 196
          goto switch_break;
        } else
#line 194
        if ((int )buf[i] == 13) {
#line 195
          state = (enum __anonenum_state_243 )2;
#line 196
          goto switch_break;
        }
#line 199
        if ((int )buf[i] == 10) {
#line 200
          goto switch_break;
        }
      }
#line 204
      if ((int )buf[i] != (int )*(r->headers_in.user.data + login)) {
#line 205
        state = (enum __anonenum_state_243 )2;
#line 206
        goto switch_break;
      }
#line 209
      if (login == r->headers_in.user.len) {
#line 210
        state = (enum __anonenum_state_243 )1;
#line 211
        passwd = i + 1UL;
      }
#line 214
      login ++;
#line 216
      goto switch_break;
      case_1: /* CIL Label */ 
#line 219
      if ((int )buf[i] == 10) {
#line 219
        goto _L;
      } else
#line 219
      if ((int )buf[i] == 13) {
#line 219
        goto _L;
      } else
#line 219
      if ((int )buf[i] == 58) {
        _L: /* CIL Label */ 
        {
#line 220
        buf[i] = (u_char )'\000';
#line 222
        ngx_http_auth_basic_close(& file);
#line 224
        pwd.len = i - passwd;
#line 225
        pwd.data = & buf[passwd];
#line 227
        tmp___4 = ngx_http_auth_basic_crypt_handler(r, & pwd, & realm);
        }
#line 227
        return (tmp___4);
      }
#line 230
      goto switch_break;
      case_2: /* CIL Label */ 
#line 233
      if ((int )buf[i] == 10) {
#line 234
        state = (enum __anonenum_state_243 )0;
#line 235
        login = (ngx_uint_t )0;
      }
#line 238
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 188
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 242
    if ((unsigned int )state == 1U) {
      {
#line 243
      left = (left + (ngx_uint_t )n) - passwd;
#line 244
      memmove((void *)(buf), (void const   *)(& buf[passwd]), left);
#line 245
      passwd = (ngx_uint_t )0;
      }
    } else {
#line 248
      left = (ngx_uint_t )0;
    }
#line 251
    offset += n;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  ngx_http_auth_basic_close(& file);
  }
#line 256
  if ((unsigned int )state == 1U) {
    {
#line 257
    pwd.len = i - passwd;
#line 258
    tmp___5 = ngx_pnalloc(r->pool, pwd.len + 1UL);
#line 258
    pwd.data = (u_char *)tmp___5;
    }
#line 259
    if ((unsigned long )pwd.data == (unsigned long )((void *)0)) {
#line 260
      return ((ngx_int_t )500);
    }
    {
#line 263
    ngx_cpystrn(pwd.data, & buf[passwd], pwd.len + 1UL);
#line 265
    tmp___6 = ngx_http_auth_basic_crypt_handler(r, & pwd, & realm);
    }
#line 265
    return (tmp___6);
  }
#line 268
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 268
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "user \"%V\" was not found in \"%V\"",
                       & r->headers_in.user, & user_file);
    }
  }
  {
#line 272
  tmp___7 = ngx_http_auth_basic_set_realm(r, & realm);
  }
#line 272
  return (tmp___7);
}
}
#line 276 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_crypt_handler(ngx_http_request_t *r , ngx_str_t *passwd ,
                                                   ngx_str_t *realm ) 
{ 
  ngx_int_t rc ;
  u_char *encrypted ;
  int tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 283
  rc = ngx_crypt(r->pool, r->headers_in.passwd.data, passwd->data, & encrypted);
  }
#line 290
  if (rc != 0L) {
#line 291
    return ((ngx_int_t )500);
  }
  {
#line 294
  tmp = strcmp((char const   *)encrypted, (char const   *)passwd->data);
  }
#line 294
  if (tmp == 0) {
#line 295
    return ((ngx_int_t )0);
  }
#line 301
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 301
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "user \"%V\": password mismatch",
                       & r->headers_in.user);
    }
  }
  {
#line 305
  tmp___0 = ngx_http_auth_basic_set_realm(r, realm);
  }
#line 305
  return (tmp___0);
}
}
#line 309 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_set_realm(ngx_http_request_t *r , ngx_str_t *realm ) 
{ 
  size_t len ;
  u_char *basic ;
  u_char *p ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 315
  tmp = ngx_list_push(& r->headers_out.headers);
#line 315
  r->headers_out.www_authenticate = (ngx_table_elt_t *)tmp;
  }
#line 316
  if ((unsigned long )r->headers_out.www_authenticate == (unsigned long )((void *)0)) {
#line 317
    return ((ngx_int_t )500);
  }
  {
#line 320
  len = (sizeof("Basic realm=\"\"") - 1UL) + realm->len;
#line 322
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 322
  basic = (u_char *)tmp___0;
  }
#line 323
  if ((unsigned long )basic == (unsigned long )((void *)0)) {
#line 324
    (r->headers_out.www_authenticate)->hash = (ngx_uint_t )0;
#line 325
    r->headers_out.www_authenticate = (ngx_table_elt_t *)((void *)0);
#line 326
    return ((ngx_int_t )500);
  }
  {
#line 329
  tmp___1 = memcpy((void */* __restrict  */)basic, (void const   */* __restrict  */)"Basic realm=\"",
                   sizeof("Basic realm=\"") - 1UL);
#line 329
  p = (u_char *)tmp___1 + (sizeof("Basic realm=\"") - 1UL);
#line 330
  tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)realm->data,
                   realm->len);
#line 330
  p = (u_char *)tmp___2 + realm->len;
#line 331
  *p = (u_char )'\"';
#line 333
  (r->headers_out.www_authenticate)->hash = (ngx_uint_t )1;
#line 334
  (r->headers_out.www_authenticate)->key.len = sizeof("WWW-Authenticate") - 1UL;
#line 334
  (r->headers_out.www_authenticate)->key.data = (u_char *)"WWW-Authenticate";
#line 335
  (r->headers_out.www_authenticate)->value.data = basic;
#line 336
  (r->headers_out.www_authenticate)->value.len = len;
  }
#line 338
  return ((ngx_int_t )401);
}
}
#line 341 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static void ngx_http_auth_basic_close(ngx_file_t *file ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 344
  tmp___0 = close(file->fd);
  }
#line 344
  if (tmp___0 == -1) {
#line 345
    if ((file->log)->log_level >= 2UL) {
      {
#line 345
      tmp = __errno_location();
#line 345
      ngx_log_error_core((ngx_uint_t )2, file->log, *tmp, "close() \"%s\" failed",
                         file->name.data);
      }
    }
  }
#line 348
  return;
}
}
#line 351 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static void *ngx_http_auth_basic_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_auth_basic_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 356
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_auth_basic_loc_conf_t ));
#line 356
  conf = (ngx_http_auth_basic_loc_conf_t *)tmp;
  }
#line 357
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 358
    return ((void *)0);
  }
#line 361
  return ((void *)conf);
}
}
#line 365 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static char *ngx_http_auth_basic_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_auth_basic_loc_conf_t *prev ;
  ngx_http_auth_basic_loc_conf_t *conf ;

  {
#line 368
  prev = (ngx_http_auth_basic_loc_conf_t *)parent;
#line 369
  conf = (ngx_http_auth_basic_loc_conf_t *)child;
#line 371
  if ((unsigned long )conf->realm == (unsigned long )((void *)0)) {
#line 372
    conf->realm = prev->realm;
  }
#line 375
  if ((unsigned long )conf->user_file.value.data == (unsigned long )((void *)0)) {
#line 376
    conf->user_file = prev->user_file;
  }
#line 379
  return ((char *)((void *)0));
}
}
#line 383 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static ngx_int_t ngx_http_auth_basic_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 389
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 391
  tmp = ngx_array_push(& cmcf->phases[6].handlers);
#line 391
  h = (ngx_http_handler_pt *)tmp;
  }
#line 392
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 393
    return ((ngx_int_t )-1);
  }
#line 396
  *h = & ngx_http_auth_basic_handler;
#line 398
  return ((ngx_int_t )0);
}
}
#line 402 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_auth_basic_module.c"
static char *ngx_http_auth_basic_user_file(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_auth_basic_loc_conf_t *alcf ;
  ngx_str_t *value ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;

  {
#line 405
  alcf = (ngx_http_auth_basic_loc_conf_t *)conf;
#line 410
  if (alcf->user_file.value.data) {
#line 411
    return ((char *)"is duplicate");
  }
  {
#line 414
  value = (ngx_str_t *)(cf->args)->elts;
#line 416
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 418
  ccv.cf = cf;
#line 419
  ccv.value = value + 1;
#line 420
  ccv.complex_value = & alcf->user_file;
#line 421
  ccv.zero = 1U;
#line 422
  ccv.conf_prefix = 1U;
#line 424
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 424
  if (tmp != 0L) {
#line 425
    return ((char *)((void *)-1));
  }
#line 428
  return ((char *)((void *)0));
}
}
#line 125 "src/core/ngx_open_file_cache.h"
ngx_int_t ngx_open_cached_file(ngx_open_file_cache_t *cache , ngx_str_t *name , ngx_open_file_info_t *of ,
                               ngx_pool_t *pool ) ;
#line 483 "src/http/ngx_http_core_module.h"
void ngx_http_set_exten(ngx_http_request_t *r ) ;
#line 488
u_char *ngx_http_map_uri_to_path(ngx_http_request_t *r , ngx_str_t *path , size_t *root_length ,
                                 size_t reserved ) ;
#line 499
ngx_int_t ngx_http_internal_redirect(ngx_http_request_t *r , ngx_str_t *uri___0 ,
                                     ngx_str_t *args___0 ) ;
#line 501
ngx_int_t ngx_http_named_location(ngx_http_request_t *r , ngx_str_t *name ) ;
#line 520
ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                        ngx_str_t *path , ngx_open_file_info_t *of ) ;
#line 108 "src/http/ngx_http.h"
void ngx_http_split_args(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ) ;
#line 28 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
static ngx_int_t ngx_http_try_files_handler(ngx_http_request_t *r ) ;
#line 29
static char *ngx_http_try_files(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 30
static void *ngx_http_try_files_create_loc_conf(ngx_conf_t *cf ) ;
#line 31
static ngx_int_t ngx_http_try_files_init(ngx_conf_t *cf ) ;
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
static ngx_command_t ngx_http_try_files_commands[2]  = {      {{sizeof("try_files") - 1UL, (u_char *)"try_files"}, (ngx_uint_t )201330688,
      & ngx_http_try_files, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
static ngx_http_module_t ngx_http_try_files_module_ctx  = 
#line 47
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_try_files_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_try_files_create_loc_conf,
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 62 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
ngx_module_t ngx_http_try_files_module  = 
#line 62
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_try_files_module_ctx),
    ngx_http_try_files_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 78 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
static ngx_int_t ngx_http_try_files_handler(ngx_http_request_t *r ) 
{ 
  size_t len ;
  size_t root ;
  size_t alias ;
  size_t reserve ;
  size_t allocated ;
  u_char *p ;
  u_char *name ;
  ngx_str_t path ;
  ngx_str_t args___0 ;
  ngx_uint_t test_dir ;
  ngx_http_try_file_t *tf ;
  ngx_open_file_info_t of ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_core_loc_conf_t *clcf ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_try_files_loc_conf_t *tlcf ;
  size_t tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp26 ;

  {
#line 93
  tlcf = (ngx_http_try_files_loc_conf_t *)*(r->loc_conf + ngx_http_try_files_module.ctx_index);
#line 95
  if ((unsigned long )tlcf->try_files == (unsigned long )((void *)0)) {
#line 96
    return ((ngx_int_t )-5);
  }
#line 102
  allocated = (size_t )0;
#line 103
  root = (size_t )0;
#line 104
  name = (u_char *)((void *)0);
#line 106
  path.data = (u_char *)((void *)0);
#line 108
  tf = tlcf->try_files;
#line 110
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 112
  alias = clcf->alias;
  {
#line 114
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (tf->lengths) {
      {
#line 117
      memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 119
      e.ip = (u_char *)(tf->lengths)->elts;
#line 120
      e.request = r;
#line 123
      len = (size_t )1;
      }
      {
#line 125
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 125
        if (! *((uintptr_t *)e.ip)) {
#line 125
          goto while_break___0;
        }
        {
#line 126
        lcode = *((ngx_http_script_len_code_pt *)e.ip);
#line 127
        tmp = (*lcode)(& e);
#line 127
        len += tmp;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 131
      len = tf->name.len;
    }
#line 134
    if (! alias) {
#line 135
      if (len > r->uri.len) {
#line 135
        reserve = len - r->uri.len;
      } else {
#line 135
        reserve = (size_t )0;
      }
    } else
#line 137
    if ((long long )alias == 9223372036854775807LL) {
#line 138
      reserve = len;
    } else
#line 141
    if (len > r->uri.len - alias) {
#line 141
      reserve = len - (r->uri.len - alias);
    } else {
#line 141
      reserve = (size_t )0;
    }
#line 144
    if (reserve > allocated) {
#line 144
      goto _L;
    } else
#line 144
    if (! allocated) {
      _L: /* CIL Label */ 
      {
#line 147
      allocated = reserve + 16UL;
#line 149
      tmp___0 = ngx_http_map_uri_to_path(r, & path, & root, allocated);
      }
#line 149
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 150
        return ((ngx_int_t )500);
      }
#line 153
      name = path.data + root;
    }
#line 156
    if ((unsigned long )tf->values == (unsigned long )((void *)0)) {
      {
#line 160
      memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)tf->name.data,
             tf->name.len);
#line 162
      path.len = (size_t )(((name + tf->name.len) - 1) - path.data);
      }
    } else {
#line 165
      e.ip = (u_char *)(tf->values)->elts;
#line 166
      e.pos = name;
#line 167
      e.flushed = 1U;
      {
#line 169
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 169
        if (! *((uintptr_t *)e.ip)) {
#line 169
          goto while_break___1;
        }
        {
#line 170
        code = *((ngx_http_script_code_pt *)e.ip);
#line 171
        (*code)(& e);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 174
      path.len = (size_t )(e.pos - path.data);
#line 176
      *(e.pos) = (u_char )'\000';
#line 178
      if (alias) {
#line 178
        if ((long long )alias != 9223372036854775807LL) {
          {
#line 178
          tmp___1 = strncmp((char const   *)name, (char const   *)r->uri.data, alias);
          }
#line 178
          if (tmp___1 == 0) {
            {
#line 181
            memmove((void *)name, (void const   *)(name + alias), len - alias);
#line 182
            path.len -= alias;
            }
          }
        }
      }
    }
#line 186
    test_dir = (ngx_uint_t )tf->test_dir;
#line 188
    tf ++;
#line 194
    if ((unsigned long )tf->lengths == (unsigned long )((void *)0)) {
#line 194
      if (tf->name.len == 0UL) {
#line 196
        if (tf->code) {
#line 197
          return ((ngx_int_t )tf->code);
        }
#line 200
        path.len -= root;
#line 201
        path.data += root;
#line 203
        if ((int )*(path.data + 0) == 64) {
          {
#line 204
          ngx_http_named_location(r, & path);
          }
        } else {
          {
#line 207
          ngx_http_split_args(r, & path, & args___0);
#line 209
          ngx_http_internal_redirect(r, & path, & args___0);
          }
        }
        {
#line 212
        ngx_http_finalize_request(r, (ngx_int_t )-4);
        }
#line 213
        return ((ngx_int_t )-4);
      }
    }
    {
#line 216
    memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 218
    of.read_ahead = clcf->read_ahead;
#line 219
    of.directio = clcf->directio;
#line 220
    of.valid = clcf->open_file_cache_valid;
#line 221
    of.min_uses = clcf->open_file_cache_min_uses;
#line 222
    of.test_only = 1U;
#line 223
    of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 224
    of.events = (unsigned int )clcf->open_file_cache_events;
#line 226
    tmp___2 = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
    }
#line 226
    if (tmp___2 != 0L) {
#line 227
      return ((ngx_int_t )500);
    }
    {
#line 230
    tmp___3 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
    }
#line 230
    if (tmp___3 != 0L) {
#line 233
      if (of.err == 0) {
#line 234
        return ((ngx_int_t )500);
      }
#line 237
      if (of.err != 2) {
#line 237
        if (of.err != 20) {
#line 237
          if (of.err != 36) {
#line 241
            if (((r->connection)->log)->log_level >= 3UL) {
              {
#line 241
              ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "%s \"%s\" failed",
                                 of.failed, path.data);
              }
            }
          }
        }
      }
#line 245
      goto __Cont;
    }
#line 248
    if ((ngx_uint_t )of.is_dir != test_dir) {
#line 249
      goto __Cont;
    }
#line 252
    path.len -= root;
#line 253
    path.data += root;
#line 255
    if (! alias) {
#line 256
      r->uri = path;
    } else
#line 258
    if ((long long )alias == 9223372036854775807LL) {
#line 259
      if (! test_dir) {
#line 260
        r->uri = path;
#line 261
        r->add_uri_to_alias = 1U;
      }
    } else {
      {
#line 265
      name = r->uri.data;
#line 267
      r->uri.len = alias + path.len;
#line 268
      tmp___4 = ngx_pnalloc(r->pool, r->uri.len);
#line 268
      r->uri.data = (u_char *)tmp___4;
      }
#line 269
      if ((unsigned long )r->uri.data == (unsigned long )((void *)0)) {
#line 270
        r->uri.len = (size_t )0;
#line 271
        return ((ngx_int_t )500);
      }
      {
#line 274
      tmp___5 = memcpy((void */* __restrict  */)r->uri.data, (void const   */* __restrict  */)name,
                       alias);
#line 274
      p = (u_char *)tmp___5 + alias;
#line 275
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)path.data,
             path.len);
      }
    }
    {
#line 278
    ngx_http_set_exten(r);
    }
#line 283
    return ((ngx_int_t )-5);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 290 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
static char *ngx_http_try_files(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_try_files_loc_conf_t *tlcf ;
  ngx_str_t *value ;
  ngx_int_t code ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_try_file_t *tf ;
  ngx_http_script_compile_t sc ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 293
  tlcf = (ngx_http_try_files_loc_conf_t *)conf;
#line 301
  if (tlcf->try_files) {
#line 302
    return ((char *)"is duplicate");
  }
  {
#line 305
  tmp = ngx_pcalloc(cf->pool, (cf->args)->nelts * sizeof(ngx_http_try_file_t ));
#line 305
  tf = (ngx_http_try_file_t *)tmp;
  }
#line 306
  if ((unsigned long )tf == (unsigned long )((void *)0)) {
#line 307
    return ((char *)((void *)-1));
  }
#line 310
  tlcf->try_files = tf;
#line 312
  value = (ngx_str_t *)(cf->args)->elts;
#line 314
  i = (ngx_uint_t )0;
  {
#line 314
  while (1) {
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < (cf->args)->nelts - 1UL)) {
#line 314
      goto while_break;
    }
#line 316
    (tf + i)->name = *(value + (i + 1UL));
#line 318
    if ((tf + i)->name.len > 0UL) {
#line 318
      if ((int )*((tf + i)->name.data + ((tf + i)->name.len - 1UL)) == 47) {
#line 318
        if (i + 2UL < (cf->args)->nelts) {
#line 322
          (tf + i)->test_dir = 1U;
#line 323
          ((tf + i)->name.len) --;
#line 324
          *((tf + i)->name.data + (tf + i)->name.len) = (u_char )'\000';
        }
      }
    }
    {
#line 327
    n = ngx_http_script_variables_count(& (tf + i)->name);
    }
#line 329
    if (n) {
      {
#line 330
      memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 332
      sc.cf = cf;
#line 333
      sc.source = & (tf + i)->name;
#line 334
      sc.lengths = & (tf + i)->lengths;
#line 335
      sc.values = & (tf + i)->values;
#line 336
      sc.variables = n;
#line 337
      sc.complete_lengths = 1U;
#line 338
      sc.complete_values = 1U;
#line 340
      tmp___0 = ngx_http_script_compile(& sc);
      }
#line 340
      if (tmp___0 != 0L) {
#line 341
        return ((char *)((void *)-1));
      }
    } else {
#line 346
      ((tf + i)->name.len) ++;
    }
#line 314
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  if ((int )*((tf + (i - 1UL))->name.data + 0) == 61) {
    {
#line 352
    code = ngx_atoi((tf + (i - 1UL))->name.data + 1, (tf + (i - 1UL))->name.len - 2UL);
    }
#line 354
    if (code == -1L) {
      {
#line 355
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid code \"%*s\"", (tf + (i - 1UL))->name.len - 1UL,
                         (tf + (i - 1UL))->name.data);
      }
#line 358
      return ((char *)((void *)-1));
    } else
#line 354
    if (code > 999L) {
      {
#line 355
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid code \"%*s\"", (tf + (i - 1UL))->name.len - 1UL,
                         (tf + (i - 1UL))->name.data);
      }
#line 358
      return ((char *)((void *)-1));
    }
#line 361
    (tf + i)->code = (unsigned int )code;
  }
#line 364
  return ((char *)((void *)0));
}
}
#line 368 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
static void *ngx_http_try_files_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_try_files_loc_conf_t *tlcf ;
  void *tmp ;

  {
  {
#line 373
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_try_files_loc_conf_t ));
#line 373
  tlcf = (ngx_http_try_files_loc_conf_t *)tmp;
  }
#line 374
  if ((unsigned long )tlcf == (unsigned long )((void *)0)) {
#line 375
    return ((void *)0);
  }
#line 384
  return ((void *)tlcf);
}
}
#line 388 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_try_files_module.c"
static ngx_int_t ngx_http_try_files_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 394
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 396
  tmp = ngx_array_push(& cmcf->phases[8].handlers);
#line 396
  h = (ngx_http_handler_pt *)tmp;
  }
#line 397
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 398
    return ((ngx_int_t )-1);
  }
#line 401
  *h = & ngx_http_try_files_handler;
#line 403
  return ((ngx_int_t )0);
}
}
#line 496 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_subrequest(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ,
                              ngx_http_request_t **psr , ngx_http_post_subrequest_t *ps ,
                              ngx_uint_t flags ) ;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static ngx_int_t ngx_http_mirror_handler(ngx_http_request_t *r ) ;
#line 25
static void ngx_http_mirror_body_handler(ngx_http_request_t *r ) ;
#line 26
static ngx_int_t ngx_http_mirror_handler_internal(ngx_http_request_t *r ) ;
#line 27
static void *ngx_http_mirror_create_loc_conf(ngx_conf_t *cf ) ;
#line 28
static char *ngx_http_mirror_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 30
static char *ngx_http_mirror(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 31
static ngx_int_t ngx_http_mirror_init(ngx_conf_t *cf ) ;
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static ngx_command_t ngx_http_mirror_commands[3]  = {      {{sizeof("mirror") - 1UL, (u_char *)"mirror"}, (ngx_uint_t )234881026, & ngx_http_mirror,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("mirror_request_body") - 1UL,
       (u_char *)"mirror_request_body"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_mirror_loc_conf_t *)0)->request_body),
      (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 54 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static ngx_http_module_t ngx_http_mirror_module_ctx  = 
#line 54
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_mirror_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_mirror_create_loc_conf,
    & ngx_http_mirror_merge_loc_conf};
#line 69 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
ngx_module_t ngx_http_mirror_module  = 
#line 69
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_mirror_module_ctx),
    ngx_http_mirror_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 85 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static ngx_int_t ngx_http_mirror_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_mirror_ctx_t *ctx ;
  ngx_http_mirror_loc_conf_t *mlcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 92
  if ((unsigned long )r != (unsigned long )r->main) {
#line 93
    return ((ngx_int_t )-5);
  }
#line 96
  mlcf = (ngx_http_mirror_loc_conf_t *)*(r->loc_conf + ngx_http_mirror_module.ctx_index);
#line 98
  if ((unsigned long )mlcf->mirror == (unsigned long )((void *)0)) {
#line 99
    return ((ngx_int_t )-5);
  }
#line 104
  if (mlcf->request_body) {
#line 105
    ctx = (ngx_http_mirror_ctx_t *)*(r->ctx + ngx_http_mirror_module.ctx_index);
#line 107
    if (ctx) {
#line 108
      return (ctx->status);
    }
    {
#line 111
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_mirror_ctx_t ));
#line 111
    ctx = (ngx_http_mirror_ctx_t *)tmp;
    }
#line 112
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 113
      return ((ngx_int_t )-1);
    }
    {
#line 116
    ctx->status = (ngx_int_t )-4;
#line 118
    *(r->ctx + ngx_http_mirror_module.ctx_index) = (void *)ctx;
#line 120
    rc = ngx_http_read_client_request_body(r, & ngx_http_mirror_body_handler);
    }
#line 121
    if (rc >= 300L) {
#line 122
      return (rc);
    }
    {
#line 125
    ngx_http_finalize_request(r, (ngx_int_t )-4);
    }
#line 126
    return ((ngx_int_t )-4);
  }
  {
#line 129
  tmp___0 = ngx_http_mirror_handler_internal(r);
  }
#line 129
  return (tmp___0);
}
}
#line 133 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static void ngx_http_mirror_body_handler(ngx_http_request_t *r ) 
{ 
  ngx_http_mirror_ctx_t *ctx ;

  {
  {
#line 138
  ctx = (ngx_http_mirror_ctx_t *)*(r->ctx + ngx_http_mirror_module.ctx_index);
#line 140
  ctx->status = ngx_http_mirror_handler_internal(r);
#line 142
  r->preserve_body = 1U;
#line 144
  r->write_event_handler = & ngx_http_core_run_phases;
#line 145
  ngx_http_core_run_phases(r);
  }
#line 146
  return;
}
}
#line 149 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static ngx_int_t ngx_http_mirror_handler_internal(ngx_http_request_t *r ) 
{ 
  ngx_str_t *name ;
  ngx_uint_t i ;
  ngx_http_request_t *sr ;
  ngx_http_mirror_loc_conf_t *mlcf ;
  ngx_int_t tmp ;

  {
#line 157
  mlcf = (ngx_http_mirror_loc_conf_t *)*(r->loc_conf + ngx_http_mirror_module.ctx_index);
#line 159
  name = (ngx_str_t *)(mlcf->mirror)->elts;
#line 161
  i = (ngx_uint_t )0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (i < (mlcf->mirror)->nelts)) {
#line 161
      goto while_break;
    }
    {
#line 162
    tmp = ngx_http_subrequest(r, name + i, & r->args, & sr, (ngx_http_post_subrequest_t *)((void *)0),
                              (ngx_uint_t )16);
    }
#line 162
    if (tmp != 0L) {
#line 166
      return ((ngx_int_t )500);
    }
#line 169
    sr->header_only = 1U;
#line 170
    sr->method = r->method;
#line 171
    sr->method_name = r->method_name;
#line 161
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  return ((ngx_int_t )-5);
}
}
#line 178 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static void *ngx_http_mirror_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_mirror_loc_conf_t *mlcf ;
  void *tmp ;

  {
  {
#line 183
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_mirror_loc_conf_t ));
#line 183
  mlcf = (ngx_http_mirror_loc_conf_t *)tmp;
  }
#line 184
  if ((unsigned long )mlcf == (unsigned long )((void *)0)) {
#line 185
    return ((void *)0);
  }
#line 188
  mlcf->mirror = (ngx_array_t *)((void *)-1);
#line 189
  mlcf->request_body = (ngx_flag_t )-1;
#line 191
  return ((void *)mlcf);
}
}
#line 195 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static char *ngx_http_mirror_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_mirror_loc_conf_t *prev ;
  ngx_http_mirror_loc_conf_t *conf ;

  {
#line 198
  prev = (ngx_http_mirror_loc_conf_t *)parent;
#line 199
  conf = (ngx_http_mirror_loc_conf_t *)child;
#line 201
  if ((unsigned long )conf->mirror == (unsigned long )((void *)-1)) {
#line 201
    if ((unsigned long )prev->mirror == (unsigned long )((void *)-1)) {
#line 201
      conf->mirror = (ngx_array_t *)((void *)0);
    } else {
#line 201
      conf->mirror = prev->mirror;
    }
  }
#line 202
  if (conf->request_body == -1L) {
#line 202
    if (prev->request_body == -1L) {
#line 202
      conf->request_body = (ngx_flag_t )1;
    } else {
#line 202
      conf->request_body = prev->request_body;
    }
  }
#line 204
  return ((char *)((void *)0));
}
}
#line 208 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static char *ngx_http_mirror(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_mirror_loc_conf_t *mlcf ;
  ngx_str_t *value ;
  ngx_str_t *s ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 211
  mlcf = (ngx_http_mirror_loc_conf_t *)conf;
#line 215
  value = (ngx_str_t *)(cf->args)->elts;
#line 217
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 217
  if (tmp == 0) {
#line 218
    if ((unsigned long )mlcf->mirror != (unsigned long )((void *)-1)) {
#line 219
      return ((char *)"is duplicate");
    }
#line 222
    mlcf->mirror = (ngx_array_t *)((void *)0);
#line 223
    return ((char *)((void *)0));
  }
#line 226
  if ((unsigned long )mlcf->mirror == (unsigned long )((void *)0)) {
#line 227
    return ((char *)"is duplicate");
  }
#line 230
  if ((unsigned long )mlcf->mirror == (unsigned long )((void *)-1)) {
    {
#line 231
    mlcf->mirror = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
    }
#line 232
    if ((unsigned long )mlcf->mirror == (unsigned long )((void *)0)) {
#line 233
      return ((char *)((void *)-1));
    }
  }
  {
#line 237
  tmp___0 = ngx_array_push(mlcf->mirror);
#line 237
  s = (ngx_str_t *)tmp___0;
  }
#line 238
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 239
    return ((char *)((void *)-1));
  }
#line 242
  *s = *(value + 1);
#line 244
  return ((char *)((void *)0));
}
}
#line 248 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_mirror_module.c"
static ngx_int_t ngx_http_mirror_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 254
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 256
  tmp = ngx_array_push(& cmcf->phases[8].handlers);
#line 256
  h = (ngx_http_handler_pt *)tmp;
  }
#line 257
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 258
    return ((ngx_int_t )-1);
  }
#line 261
  *h = & ngx_http_mirror_handler;
#line 263
  return ((ngx_int_t )0);
}
}
#line 29 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_test_dir(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                         u_char *path , u_char *last ) ;
#line 31
static ngx_int_t ngx_http_index_error(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                      u_char *file , ngx_err_t err ) ;
#line 34
static ngx_int_t ngx_http_index_init(ngx_conf_t *cf ) ;
#line 35
static void *ngx_http_index_create_loc_conf(ngx_conf_t *cf ) ;
#line 36
static char *ngx_http_index_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 38
static char *ngx_http_index_set_index(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 42 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static ngx_command_t ngx_http_index_commands[2]  = {      {{sizeof("index") - 1UL, (u_char *)"index"}, (ngx_uint_t )234883072, & ngx_http_index_set_index,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static ngx_http_module_t ngx_http_index_module_ctx  = 
#line 55
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_index_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_index_create_loc_conf,
    & ngx_http_index_merge_loc_conf};
#line 70 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
ngx_module_t ngx_http_index_module  = 
#line 70
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_index_module_ctx),
    ngx_http_index_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 96 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_handler(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char *name ;
  size_t len ;
  size_t root ;
  size_t reserve ;
  size_t allocated ;
  ngx_int_t rc ;
  ngx_str_t path ;
  ngx_str_t uri___0 ;
  ngx_uint_t i ;
  ngx_uint_t dir_tested ;
  ngx_http_index_t *index___0 ;
  ngx_open_file_info_t of ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_index_loc_conf_t *ilcf ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_int_t tmp ;
  size_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  ngx_int_t tmp___7 ;
  char *__cil_tmp29 ;

  {
#line 112
  if ((int )*(r->uri.data + (r->uri.len - 1UL)) != 47) {
#line 113
    return ((ngx_int_t )-5);
  }
#line 116
  if (! (r->method & 14UL)) {
#line 117
    return ((ngx_int_t )-5);
  }
#line 120
  ilcf = (ngx_http_index_loc_conf_t *)*(r->loc_conf + ngx_http_index_module.ctx_index);
#line 121
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 123
  allocated = (size_t )0;
#line 124
  root = (size_t )0;
#line 125
  dir_tested = (ngx_uint_t )0;
#line 126
  name = (u_char *)((void *)0);
#line 128
  path.data = (u_char *)((void *)0);
#line 130
  index___0 = (ngx_http_index_t *)(ilcf->indices)->elts;
#line 131
  i = (ngx_uint_t )0;
  {
#line 131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 131
    if (! (i < (ilcf->indices)->nelts)) {
#line 131
      goto while_break;
    }
#line 133
    if ((unsigned long )(index___0 + i)->lengths == (unsigned long )((void *)0)) {
#line 135
      if ((int )*((index___0 + i)->name.data + 0) == 47) {
        {
#line 136
        tmp = ngx_http_internal_redirect(r, & (index___0 + i)->name, & r->args);
        }
#line 136
        return (tmp);
      }
#line 139
      reserve = ilcf->max_index_len;
#line 140
      len = (index___0 + i)->name.len;
    } else {
      {
#line 143
      memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 145
      e.ip = (u_char *)((index___0 + i)->lengths)->elts;
#line 146
      e.request = r;
#line 147
      e.flushed = 1U;
#line 150
      len = (size_t )1;
      }
      {
#line 152
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 152
        if (! *((uintptr_t *)e.ip)) {
#line 152
          goto while_break___0;
        }
        {
#line 153
        lcode = *((ngx_http_script_len_code_pt *)e.ip);
#line 154
        tmp___0 = (*lcode)(& e);
#line 154
        len += tmp___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 159
      reserve = len + 16UL;
    }
#line 162
    if (reserve > allocated) {
      {
#line 164
      name = ngx_http_map_uri_to_path(r, & path, & root, reserve);
      }
#line 165
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 166
        return ((ngx_int_t )-1);
      }
#line 169
      allocated = (size_t )((path.data + path.len) - name);
    }
#line 172
    if ((unsigned long )(index___0 + i)->values == (unsigned long )((void *)0)) {
      {
#line 176
      memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)(index___0 + i)->name.data,
             (index___0 + i)->name.len);
#line 178
      path.len = (size_t )(((name + (index___0 + i)->name.len) - 1) - path.data);
      }
    } else {
#line 181
      e.ip = (u_char *)((index___0 + i)->values)->elts;
#line 182
      e.pos = name;
      {
#line 184
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 184
        if (! *((uintptr_t *)e.ip)) {
#line 184
          goto while_break___1;
        }
        {
#line 185
        code = *((ngx_http_script_code_pt *)e.ip);
#line 186
        (*code)(& e);
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 189
      if ((int )*name == 47) {
        {
#line 190
        uri___0.len = len - 1UL;
#line 191
        uri___0.data = name;
#line 192
        tmp___1 = ngx_http_internal_redirect(r, & uri___0, & r->args);
        }
#line 192
        return (tmp___1);
      }
#line 195
      path.len = (size_t )(e.pos - path.data);
#line 197
      *(e.pos) = (u_char )'\000';
    }
    {
#line 203
    memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 205
    of.read_ahead = clcf->read_ahead;
#line 206
    of.directio = clcf->directio;
#line 207
    of.valid = clcf->open_file_cache_valid;
#line 208
    of.min_uses = clcf->open_file_cache_min_uses;
#line 209
    of.test_only = 1U;
#line 210
    of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 211
    of.events = (unsigned int )clcf->open_file_cache_events;
#line 213
    tmp___2 = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
    }
#line 213
    if (tmp___2 != 0L) {
#line 214
      return ((ngx_int_t )500);
    }
    {
#line 217
    tmp___4 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
    }
#line 217
    if (tmp___4 != 0L) {
#line 220
      if (of.err == 0) {
#line 221
        return ((ngx_int_t )500);
      }
#line 228
      if (of.err == 31) {
#line 231
        return ((ngx_int_t )403);
      } else
#line 228
      if (of.err == 40) {
#line 231
        return ((ngx_int_t )403);
      }
#line 235
      if (of.err == 20) {
        {
#line 239
        tmp___3 = ngx_http_index_error(r, clcf, path.data, of.err);
        }
#line 239
        return (tmp___3);
      } else
#line 235
      if (of.err == 36) {
        {
#line 239
        tmp___3 = ngx_http_index_error(r, clcf, path.data, of.err);
        }
#line 239
        return (tmp___3);
      } else
#line 235
      if (of.err == 13) {
        {
#line 239
        tmp___3 = ngx_http_index_error(r, clcf, path.data, of.err);
        }
#line 239
        return (tmp___3);
      }
#line 242
      if (! dir_tested) {
        {
#line 243
        rc = ngx_http_index_test_dir(r, clcf, path.data, name - 1);
        }
#line 245
        if (rc != 0L) {
#line 246
          return (rc);
        }
#line 249
        dir_tested = (ngx_uint_t )1;
      }
#line 252
      if (of.err == 2) {
#line 253
        goto __Cont;
      }
#line 256
      if (((r->connection)->log)->log_level >= 3UL) {
        {
#line 256
        ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "%s \"%s\" failed",
                           of.failed, path.data);
        }
      }
#line 259
      return ((ngx_int_t )500);
    }
#line 262
    uri___0.len = (r->uri.len + len) - 1UL;
#line 264
    if (! clcf->alias) {
#line 265
      uri___0.data = path.data + root;
    } else {
      {
#line 268
      tmp___5 = ngx_pnalloc(r->pool, uri___0.len);
#line 268
      uri___0.data = (u_char *)tmp___5;
      }
#line 269
      if ((unsigned long )uri___0.data == (unsigned long )((void *)0)) {
#line 270
        return ((ngx_int_t )500);
      }
      {
#line 273
      tmp___6 = memcpy((void */* __restrict  */)uri___0.data, (void const   */* __restrict  */)r->uri.data,
                       r->uri.len);
#line 273
      p = (u_char *)tmp___6 + r->uri.len;
#line 274
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)name, len - 1UL);
      }
    }
    {
#line 277
    tmp___7 = ngx_http_internal_redirect(r, & uri___0, & r->args);
    }
#line 277
    return (tmp___7);
    __Cont: /* CIL Label */ 
#line 131
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 280
  return ((ngx_int_t )-5);
}
}
#line 284 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_test_dir(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                         u_char *path , u_char *last ) 
{ 
  u_char c ;
  ngx_str_t dir ;
  ngx_open_file_info_t of ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 292
  c = *last;
#line 293
  if ((int )c != 47) {
#line 295
    last ++;
#line 295
    c = *last;
  } else
#line 293
  if ((unsigned long )path == (unsigned long )last) {
#line 295
    last ++;
#line 295
    c = *last;
  }
  {
#line 297
  *last = (u_char )'\000';
#line 299
  dir.len = (size_t )(last - path);
#line 300
  dir.data = path;
#line 305
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 307
  of.test_dir = 1U;
#line 308
  of.test_only = 1U;
#line 309
  of.valid = clcf->open_file_cache_valid;
#line 310
  of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 312
  tmp = ngx_http_set_disable_symlinks(r, clcf, & dir, & of);
  }
#line 312
  if (tmp != 0L) {
#line 313
    return ((ngx_int_t )500);
  }
  {
#line 316
  tmp___1 = ngx_open_cached_file(clcf->open_file_cache, & dir, & of, r->pool);
  }
#line 316
  if (tmp___1 != 0L) {
#line 319
    if (of.err) {
#line 322
      if (of.err == 31) {
#line 325
        return ((ngx_int_t )403);
      } else
#line 322
      if (of.err == 40) {
#line 325
        return ((ngx_int_t )403);
      }
#line 329
      if (of.err == 2) {
        {
#line 330
        *last = c;
#line 331
        tmp___0 = ngx_http_index_error(r, clcf, dir.data, 2);
        }
#line 331
        return (tmp___0);
      }
#line 334
      if (of.err == 13) {
#line 336
        *last = c;
#line 344
        return ((ngx_int_t )0);
      }
#line 347
      if (((r->connection)->log)->log_level >= 3UL) {
        {
#line 347
        ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "%s \"%s\" failed",
                           of.failed, dir.data);
        }
      }
    }
#line 351
    return ((ngx_int_t )500);
  }
#line 354
  *last = c;
#line 356
  if (of.is_dir) {
#line 357
    return ((ngx_int_t )0);
  }
#line 360
  if (((r->connection)->log)->log_level >= 2UL) {
    {
#line 360
    ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "\"%s\" is not a directory",
                       dir.data);
    }
  }
#line 363
  return ((ngx_int_t )500);
}
}
#line 367 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_error(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                      u_char *file , ngx_err_t err ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 371
  if (err == 13) {
#line 372
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 372
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, err, "\"%s\" is forbidden",
                         file);
      }
    }
#line 375
    return ((ngx_int_t )403);
  }
#line 378
  if (clcf->log_not_found) {
#line 379
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 379
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, err, "\"%s\" is not found",
                         file);
      }
    }
  }
#line 383
  return ((ngx_int_t )404);
}
}
#line 387 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static void *ngx_http_index_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_index_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 392
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_index_loc_conf_t ));
#line 392
  conf = (ngx_http_index_loc_conf_t *)tmp;
  }
#line 393
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 394
    return ((void *)0);
  }
#line 397
  conf->indices = (ngx_array_t *)((void *)0);
#line 398
  conf->max_index_len = (size_t )0;
#line 400
  return ((void *)conf);
}
}
#line 404 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static char *ngx_http_index_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_index_loc_conf_t *prev ;
  ngx_http_index_loc_conf_t *conf ;
  ngx_http_index_t *index___0 ;
  void *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 407
  prev = (ngx_http_index_loc_conf_t *)parent;
#line 408
  conf = (ngx_http_index_loc_conf_t *)child;
#line 412
  if ((unsigned long )conf->indices == (unsigned long )((void *)0)) {
#line 413
    conf->indices = prev->indices;
#line 414
    conf->max_index_len = prev->max_index_len;
  }
#line 417
  if ((unsigned long )conf->indices == (unsigned long )((void *)0)) {
    {
#line 418
    conf->indices = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_index_t ));
    }
#line 419
    if ((unsigned long )conf->indices == (unsigned long )((void *)0)) {
#line 420
      return ((char *)((void *)-1));
    }
    {
#line 423
    tmp = ngx_array_push(conf->indices);
#line 423
    index___0 = (ngx_http_index_t *)tmp;
    }
#line 424
    if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 425
      return ((char *)((void *)-1));
    }
#line 428
    index___0->name.len = sizeof("index.html");
#line 429
    index___0->name.data = (u_char *)"index.html";
#line 430
    index___0->lengths = (ngx_array_t *)((void *)0);
#line 431
    index___0->values = (ngx_array_t *)((void *)0);
#line 433
    conf->max_index_len = sizeof("index.html");
#line 435
    return ((char *)((void *)0));
  }
#line 438
  return ((char *)((void *)0));
}
}
#line 442 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static ngx_int_t ngx_http_index_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 448
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 450
  tmp = ngx_array_push(& cmcf->phases[9].handlers);
#line 450
  h = (ngx_http_handler_pt *)tmp;
  }
#line 451
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 452
    return ((ngx_int_t )-1);
  }
#line 455
  *h = & ngx_http_index_handler;
#line 457
  return ((ngx_int_t )0);
}
}
#line 463 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_index_module.c"
static char *ngx_http_index_set_index(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_index_loc_conf_t *ilcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_index_t *index___0 ;
  ngx_http_script_compile_t sc ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 466
  ilcf = (ngx_http_index_loc_conf_t *)conf;
#line 473
  if ((unsigned long )ilcf->indices == (unsigned long )((void *)0)) {
    {
#line 474
    ilcf->indices = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_http_index_t ));
    }
#line 475
    if ((unsigned long )ilcf->indices == (unsigned long )((void *)0)) {
#line 476
      return ((char *)((void *)-1));
    }
  }
#line 480
  value = (ngx_str_t *)(cf->args)->elts;
#line 482
  i = (ngx_uint_t )1;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
#line 482
    if (! (i < (cf->args)->nelts)) {
#line 482
      goto while_break;
    }
#line 484
    if ((int )*((value + i)->data + 0) == 47) {
#line 484
      if (i != (cf->args)->nelts - 1UL) {
        {
#line 485
        ngx_conf_log_error((ngx_uint_t )5, cf, 0, "only the last index in \"index\" directive should be absolute");
        }
      }
    }
#line 490
    if ((value + i)->len == 0UL) {
      {
#line 491
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "index \"%V\" in \"index\" directive is invalid",
                         value + 1);
      }
#line 494
      return ((char *)((void *)-1));
    }
    {
#line 497
    tmp = ngx_array_push(ilcf->indices);
#line 497
    index___0 = (ngx_http_index_t *)tmp;
    }
#line 498
    if ((unsigned long )index___0 == (unsigned long )((void *)0)) {
#line 499
      return ((char *)((void *)-1));
    }
    {
#line 502
    index___0->name.len = (value + i)->len;
#line 503
    index___0->name.data = (value + i)->data;
#line 504
    index___0->lengths = (ngx_array_t *)((void *)0);
#line 505
    index___0->values = (ngx_array_t *)((void *)0);
#line 507
    n = ngx_http_script_variables_count(value + i);
    }
#line 509
    if (n == 0UL) {
#line 510
      if (ilcf->max_index_len < index___0->name.len) {
#line 511
        ilcf->max_index_len = index___0->name.len;
      }
#line 514
      if ((int )*(index___0->name.data + 0) == 47) {
#line 515
        goto __Cont;
      }
#line 519
      (index___0->name.len) ++;
#line 521
      goto __Cont;
    }
    {
#line 524
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 526
    sc.cf = cf;
#line 527
    sc.source = value + i;
#line 528
    sc.lengths = & index___0->lengths;
#line 529
    sc.values = & index___0->values;
#line 530
    sc.variables = n;
#line 531
    sc.complete_lengths = 1U;
#line 532
    sc.complete_values = 1U;
#line 534
    tmp___0 = ngx_http_script_compile(& sc);
    }
#line 534
    if (tmp___0 != 0L) {
#line 535
      return ((char *)((void *)-1));
    }
    __Cont: /* CIL Label */ 
#line 482
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 539
  return ((char *)((void *)0));
}
}
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 149 "/usr/include/dirent.h"
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 267 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf )  __asm__("lstat64")  ;
#line 193 "src/core/ngx_string.h"
size_t ngx_utf8_length(u_char *p , size_t n ) ;
#line 194
u_char *ngx_utf8_cpystrn(u_char *dst , u_char *src , size_t n , size_t len ) ;
#line 211
uintptr_t ngx_escape_html(u_char *dst , u_char *src , size_t size ) ;
#line 212
uintptr_t ngx_escape_json(u_char *dst , u_char *src , size_t size ) ;
#line 219 "src/os/unix/ngx_files.h"
ngx_int_t ngx_open_dir(ngx_str_t *name , ngx_dir_t *dir ) ;
#line 227
ngx_int_t ngx_read_dir(ngx_dir_t *dir ) ;
#line 249 "src/os/unix/ngx_files.h"
__inline static ngx_int_t ngx_de_info(u_char *name , ngx_dir_t *dir ) 
{ 
  int tmp ;

  {
  {
#line 252
  dir->type = 0U;
#line 253
  tmp = stat((char const   */* __restrict  */)((char const   *)name), (struct stat */* __restrict  */)(& dir->info));
  }
#line 253
  return ((ngx_int_t )tmp);
}
}
#line 26 "src/core/ngx_times.h"
u_char *ngx_http_time(u_char *buf , time_t t ) ;
#line 28
void ngx_gmtime(time_t t , ngx_tm_t *tp ) ;
#line 514 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_output_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 106 "src/http/ngx_http.h"
ngx_int_t ngx_http_arg(ngx_http_request_t *r , u_char *name , size_t len , ngx_str_t *value ) ;
#line 140
ngx_int_t ngx_http_send_header(ngx_http_request_t *r ) ;
#line 58 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_buf_t *ngx_http_autoindex_html(ngx_http_request_t *r , ngx_array_t *entries ) ;
#line 60
static ngx_buf_t *ngx_http_autoindex_json(ngx_http_request_t *r , ngx_array_t *entries ,
                                          ngx_str_t *callback ) ;
#line 62
static ngx_int_t ngx_http_autoindex_jsonp_callback(ngx_http_request_t *r , ngx_str_t *callback ) ;
#line 64
static ngx_buf_t *ngx_http_autoindex_xml(ngx_http_request_t *r , ngx_array_t *entries ) ;
#line 67
static int ngx_http_autoindex_cmp_entries(void const   *one , void const   *two ) ;
#line 69
static ngx_int_t ngx_http_autoindex_error(ngx_http_request_t *r , ngx_dir_t *dir ,
                                          ngx_str_t *name ) ;
#line 72
static ngx_int_t ngx_http_autoindex_init(ngx_conf_t *cf ) ;
#line 73
static void *ngx_http_autoindex_create_loc_conf(ngx_conf_t *cf ) ;
#line 74
static char *ngx_http_autoindex_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 78 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_conf_enum_t ngx_http_autoindex_format[5]  = {      {{sizeof("html") - 1UL, (u_char *)"html"}, (ngx_uint_t )0}, 
        {{sizeof("json") - 1UL, (u_char *)"json"}, (ngx_uint_t )1}, 
        {{sizeof("jsonp") - 1UL, (u_char *)"jsonp"}, (ngx_uint_t )2}, 
        {{sizeof("xml") - 1UL, (u_char *)"xml"}, (ngx_uint_t )3}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 87 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_command_t ngx_http_autoindex_commands[5]  = {      {{sizeof("autoindex") - 1UL, (u_char *)"autoindex"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_autoindex_loc_conf_t *)0)->enable), (void *)0}, 
        {{sizeof("autoindex_format") - 1UL,
       (u_char *)"autoindex_format"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_autoindex_loc_conf_t *)0)->format),
      (void *)(& ngx_http_autoindex_format)}, 
        {{sizeof("autoindex_localtime") - 1UL, (u_char *)"autoindex_localtime"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_autoindex_loc_conf_t *)0)->localtime), (void *)0}, 
        {{sizeof("autoindex_exact_size") - 1UL,
       (u_char *)"autoindex_exact_size"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_autoindex_loc_conf_t *)0)->exact_size),
      (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 121 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_http_module_t ngx_http_autoindex_module_ctx  = 
#line 121
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_autoindex_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_autoindex_create_loc_conf,
    & ngx_http_autoindex_merge_loc_conf};
#line 136 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
ngx_module_t ngx_http_autoindex_module  = 
#line 136
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_autoindex_module_ctx),
    ngx_http_autoindex_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 152 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_int_t ngx_http_autoindex_handler(ngx_http_request_t *r ) 
{ 
  u_char *last ;
  u_char *filename ;
  size_t len ;
  size_t allocated ;
  size_t root ;
  ngx_err_t err ;
  ngx_buf_t *b ;
  ngx_int_t rc ;
  ngx_str_t path ;
  ngx_str_t callback ;
  ngx_dir_t dir ;
  ngx_uint_t level ;
  ngx_uint_t format ;
  ngx_pool_t *pool ;
  ngx_chain_t out ;
  ngx_array_t entries ;
  ngx_http_autoindex_entry_t *entry ;
  ngx_http_autoindex_loc_conf_t *alcf ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;
  void *tmp___10 ;
  ngx_int_t tmp___11 ;
  u_char *tmp___12 ;
  int *tmp___13 ;
  ngx_int_t tmp___14 ;
  int *tmp___15 ;
  ngx_int_t tmp___16 ;
  int tmp___17 ;
  ngx_int_t tmp___18 ;
  void *tmp___19 ;
  ngx_int_t tmp___20 ;
  void *tmp___21 ;
  ngx_int_t tmp___22 ;
  int *tmp___23 ;
  int tmp___24 ;
  ngx_int_t tmp___25 ;
  void *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;

  {
#line 169
  if ((int )*(r->uri.data + (r->uri.len - 1UL)) != 47) {
#line 170
    return ((ngx_int_t )-5);
  }
#line 173
  if (! (r->method & 6UL)) {
#line 174
    return ((ngx_int_t )-5);
  }
#line 177
  alcf = (ngx_http_autoindex_loc_conf_t *)*(r->loc_conf + ngx_http_autoindex_module.ctx_index);
#line 179
  if (! alcf->enable) {
#line 180
    return ((ngx_int_t )-5);
  }
  {
#line 183
  rc = ngx_http_discard_request_body(r);
  }
#line 185
  if (rc != 0L) {
#line 186
    return (rc);
  }
  {
#line 191
  last = ngx_http_map_uri_to_path(r, & path, & root, (size_t )50);
  }
#line 193
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 194
    return ((ngx_int_t )500);
  }
#line 197
  allocated = path.len;
#line 198
  path.len = (size_t )(last - path.data);
#line 199
  if (path.len > 1UL) {
#line 200
    (path.len) --;
  }
#line 202
  *(path.data + path.len) = (u_char )'\000';
#line 207
  format = alcf->format;
#line 209
  if (format == 2UL) {
    {
#line 210
    tmp = ngx_http_autoindex_jsonp_callback(r, & callback);
    }
#line 210
    if (tmp != 0L) {
#line 211
      return ((ngx_int_t )400);
    }
#line 214
    if (callback.len == 0UL) {
#line 215
      format = (ngx_uint_t )1;
    }
  }
  {
#line 219
  tmp___1 = ngx_open_dir(& path, & dir);
  }
#line 219
  if (tmp___1 == -1L) {
    {
#line 220
    tmp___0 = __errno_location();
#line 220
    err = *tmp___0;
    }
#line 222
    if (err == 2) {
#line 226
      level = (ngx_uint_t )4;
#line 227
      rc = (ngx_int_t )404;
    } else
#line 222
    if (err == 20) {
#line 226
      level = (ngx_uint_t )4;
#line 227
      rc = (ngx_int_t )404;
    } else
#line 222
    if (err == 36) {
#line 226
      level = (ngx_uint_t )4;
#line 227
      rc = (ngx_int_t )404;
    } else
#line 229
    if (err == 13) {
#line 230
      level = (ngx_uint_t )4;
#line 231
      rc = (ngx_int_t )403;
    } else {
#line 234
      level = (ngx_uint_t )3;
#line 235
      rc = (ngx_int_t )500;
    }
#line 238
    if (((r->connection)->log)->log_level >= level) {
      {
#line 238
      ngx_log_error_core(level, (r->connection)->log, err, "opendir() \"%s\" failed",
                         path.data);
      }
    }
#line 241
    return (rc);
  }
  {
#line 247
  memset((void *)(& entries), 0, sizeof(ngx_array_t ));
#line 252
  pool = r->pool;
#line 254
  tmp___3 = ngx_array_init(& entries, pool, (ngx_uint_t )40, sizeof(ngx_http_autoindex_entry_t ));
  }
#line 254
  if (tmp___3 != 0L) {
    {
#line 257
    tmp___2 = ngx_http_autoindex_error(r, & dir, & path);
    }
#line 257
    return (tmp___2);
  }
#line 260
  r->headers_out.status = (ngx_uint_t )200;
  {
#line 264
  if (format == 1UL) {
#line 264
    goto case_1;
  }
#line 268
  if (format == 2UL) {
#line 268
    goto case_2;
  }
#line 272
  if (format == 3UL) {
#line 272
    goto case_3;
  }
#line 277
  goto switch_default;
  case_1: /* CIL Label */ 
#line 265
  r->headers_out.content_type.len = sizeof("application/json") - 1UL;
#line 265
  r->headers_out.content_type.data = (u_char *)"application/json";
#line 266
  goto switch_break;
  case_2: /* CIL Label */ 
#line 269
  r->headers_out.content_type.len = sizeof("application/javascript") - 1UL;
#line 269
  r->headers_out.content_type.data = (u_char *)"application/javascript";
#line 270
  goto switch_break;
  case_3: /* CIL Label */ 
#line 273
  r->headers_out.content_type.len = sizeof("text/xml") - 1UL;
#line 273
  r->headers_out.content_type.data = (u_char *)"text/xml";
#line 274
  r->headers_out.charset.len = sizeof("utf-8") - 1UL;
#line 274
  r->headers_out.charset.data = (u_char *)"utf-8";
#line 275
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 278
  r->headers_out.content_type.len = sizeof("text/html") - 1UL;
#line 278
  r->headers_out.content_type.data = (u_char *)"text/html";
#line 279
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 282
  r->headers_out.content_type_len = r->headers_out.content_type.len;
#line 283
  r->headers_out.content_type_lowcase = (u_char *)((void *)0);
#line 285
  rc = ngx_http_send_header(r);
  }
#line 287
  if (rc == -1L) {
#line 287
    goto _L;
  } else
#line 287
  if (rc > 0L) {
#line 287
    goto _L;
  } else
#line 287
  if (r->header_only) {
    _L: /* CIL Label */ 
    {
#line 288
    tmp___5 = closedir(dir.dir);
    }
#line 288
    if (tmp___5 == -1) {
#line 289
      if (((r->connection)->log)->log_level >= 2UL) {
        {
#line 289
        tmp___4 = __errno_location();
#line 289
        ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, *tmp___4, "closedir() \"%V\" failed",
                           & path);
        }
      }
    }
#line 293
    return (rc);
  }
#line 296
  filename = path.data;
#line 297
  *(filename + path.len) = (u_char )'/';
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 300
    tmp___6 = __errno_location();
#line 300
    *tmp___6 = 0;
#line 302
    tmp___9 = ngx_read_dir(& dir);
    }
#line 302
    if (tmp___9 == -1L) {
      {
#line 303
      tmp___7 = __errno_location();
#line 303
      err = *tmp___7;
      }
#line 305
      if (err != 0) {
#line 306
        if (((r->connection)->log)->log_level >= 3UL) {
          {
#line 306
          ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, err, "readdir() \"%V\" failed",
                             & path);
          }
        }
        {
#line 308
        tmp___8 = ngx_http_autoindex_error(r, & dir, & path);
        }
#line 308
        return (tmp___8);
      }
#line 311
      goto while_break;
    }
    {
#line 317
    len = strlen((char const   *)((dir.de)->d_name));
    }
#line 319
    if ((int )*((u_char *)((dir.de)->d_name) + 0) == 46) {
#line 320
      goto __Cont;
    }
#line 323
    if (! dir.valid_info) {
#line 327
      if (((path.len + 1UL) + len) + 1UL > allocated) {
        {
#line 328
        allocated = (((path.len + 1UL) + len) + 1UL) + 50UL;
#line 331
        tmp___10 = ngx_pnalloc(pool, allocated);
#line 331
        filename = (u_char *)tmp___10;
        }
#line 332
        if ((unsigned long )filename == (unsigned long )((void *)0)) {
          {
#line 333
          tmp___11 = ngx_http_autoindex_error(r, & dir, & path);
          }
#line 333
          return (tmp___11);
        }
        {
#line 336
        last = ngx_cpystrn(filename, path.data, path.len + 1UL);
#line 337
        tmp___12 = last;
#line 337
        last ++;
#line 337
        *tmp___12 = (u_char )'/';
        }
      }
      {
#line 340
      ngx_cpystrn(last, (u_char *)((dir.de)->d_name), len + 1UL);
#line 342
      tmp___18 = ngx_de_info(filename, & dir);
      }
#line 342
      if (tmp___18 == -1L) {
        {
#line 343
        tmp___13 = __errno_location();
#line 343
        err = *tmp___13;
        }
#line 345
        if (err != 2) {
#line 345
          if (err != 40) {
#line 346
            if (((r->connection)->log)->log_level >= 3UL) {
              {
#line 346
              ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, err, "stat() \"%s\" failed",
                                 filename);
              }
            }
#line 349
            if (err == 13) {
#line 350
              goto __Cont;
            }
            {
#line 353
            tmp___14 = ngx_http_autoindex_error(r, & dir, & path);
            }
#line 353
            return (tmp___14);
          }
        }
        {
#line 356
        tmp___17 = lstat((char const   */* __restrict  */)((char const   *)filename),
                         (struct stat */* __restrict  */)(& dir.info));
        }
#line 356
        if (tmp___17 == -1) {
#line 357
          if (((r->connection)->log)->log_level >= 3UL) {
            {
#line 357
            tmp___15 = __errno_location();
#line 357
            ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___15, "lstat() \"%s\" failed",
                               filename);
            }
          }
          {
#line 360
          tmp___16 = ngx_http_autoindex_error(r, & dir, & path);
          }
#line 360
          return (tmp___16);
        }
      }
    }
    {
#line 365
    tmp___19 = ngx_array_push(& entries);
#line 365
    entry = (ngx_http_autoindex_entry_t *)tmp___19;
    }
#line 366
    if ((unsigned long )entry == (unsigned long )((void *)0)) {
      {
#line 367
      tmp___20 = ngx_http_autoindex_error(r, & dir, & path);
      }
#line 367
      return (tmp___20);
    }
    {
#line 370
    entry->name.len = len;
#line 372
    tmp___21 = ngx_pnalloc(pool, len + 1UL);
#line 372
    entry->name.data = (u_char *)tmp___21;
    }
#line 373
    if ((unsigned long )entry->name.data == (unsigned long )((void *)0)) {
      {
#line 374
      tmp___22 = ngx_http_autoindex_error(r, & dir, & path);
      }
#line 374
      return (tmp___22);
    }
    {
#line 377
    ngx_cpystrn(entry->name.data, (u_char *)((dir.de)->d_name), len + 1UL);
    }
#line 379
    if (dir.type) {
#line 379
      entry->dir = (unsigned int )(dir.type == 4U);
    } else {
#line 379
      entry->dir = (unsigned int )((dir.info.st_mode & 61440U) == 16384U);
    }
#line 380
    if (dir.type) {
#line 380
      entry->file = (unsigned int )(dir.type == 8U);
    } else {
#line 380
      entry->file = (unsigned int )((dir.info.st_mode & 61440U) == 32768U);
    }
#line 381
    entry->mtime = dir.info.st_mtim.tv_sec;
#line 382
    entry->size = dir.info.st_size;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 385
  tmp___24 = closedir(dir.dir);
  }
#line 385
  if (tmp___24 == -1) {
#line 386
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 386
      tmp___23 = __errno_location();
#line 386
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, *tmp___23, "closedir() \"%V\" failed",
                         & path);
      }
    }
  }
#line 390
  if (entries.nelts > 1UL) {
    {
#line 391
    qsort(entries.elts, entries.nelts, sizeof(ngx_http_autoindex_entry_t ), & ngx_http_autoindex_cmp_entries);
    }
  }
  {
#line 398
  if (format == 1UL) {
#line 398
    goto case_1___0;
  }
#line 402
  if (format == 2UL) {
#line 402
    goto case_2___0;
  }
#line 406
  if (format == 3UL) {
#line 406
    goto case_3___0;
  }
#line 410
  goto switch_default___0;
  case_1___0: /* CIL Label */ 
  {
#line 399
  b = ngx_http_autoindex_json(r, & entries, (ngx_str_t *)((void *)0));
  }
#line 400
  goto switch_break___0;
  case_2___0: /* CIL Label */ 
  {
#line 403
  b = ngx_http_autoindex_json(r, & entries, & callback);
  }
#line 404
  goto switch_break___0;
  case_3___0: /* CIL Label */ 
  {
#line 407
  b = ngx_http_autoindex_xml(r, & entries);
  }
#line 408
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 411
  b = ngx_http_autoindex_html(r, & entries);
  }
#line 412
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 415
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 416
    return ((ngx_int_t )-1);
  }
#line 421
  if ((unsigned long )r == (unsigned long )r->main) {
#line 422
    b->last_buf = 1U;
  }
  {
#line 425
  b->last_in_chain = 1U;
#line 427
  out.buf = b;
#line 428
  out.next = (ngx_chain_t *)((void *)0);
#line 430
  tmp___25 = ngx_http_output_filter(r, & out);
  }
#line 430
  return (tmp___25);
}
}
#line 448 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static u_char title[31]  = 
#line 448
  {      (u_char )'<',      (u_char )'h',      (u_char )'t',      (u_char )'m', 
        (u_char )'l',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'h',      (u_char )'e',      (u_char )'a', 
        (u_char )'d',      (u_char )'>',      (u_char )'<',      (u_char )'t', 
        (u_char )'i',      (u_char )'t',      (u_char )'l',      (u_char )'e', 
        (u_char )'>',      (u_char )'I',      (u_char )'n',      (u_char )'d', 
        (u_char )'e',      (u_char )'x',      (u_char )' ',      (u_char )'o', 
        (u_char )'f',      (u_char )' ',      (u_char )'\000'};
#line 453 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static u_char header[55]  = 
#line 453
  {      (u_char )'<',      (u_char )'/',      (u_char )'t',      (u_char )'i', 
        (u_char )'t',      (u_char )'l',      (u_char )'e',      (u_char )'>', 
        (u_char )'<',      (u_char )'/',      (u_char )'h',      (u_char )'e', 
        (u_char )'a',      (u_char )'d',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'b',      (u_char )'o', 
        (u_char )'d',      (u_char )'y',      (u_char )' ',      (u_char )'b', 
        (u_char )'g',      (u_char )'c',      (u_char )'o',      (u_char )'l', 
        (u_char )'o',      (u_char )'r',      (u_char )'=',      (u_char )'\"', 
        (u_char )'w',      (u_char )'h',      (u_char )'i',      (u_char )'t', 
        (u_char )'e',      (u_char )'\"',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'h',      (u_char )'1', 
        (u_char )'>',      (u_char )'I',      (u_char )'n',      (u_char )'d', 
        (u_char )'e',      (u_char )'x',      (u_char )' ',      (u_char )'o', 
        (u_char )'f',      (u_char )' ',      (u_char )'\000'};
#line 459 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static u_char tail[19]  = 
#line 459
  {      (u_char )'<',      (u_char )'/',      (u_char )'b',      (u_char )'o', 
        (u_char )'d',      (u_char )'y',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'/',      (u_char )'h', 
        (u_char )'t',      (u_char )'m',      (u_char )'l',      (u_char )'>', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 464 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static char *months[12]  = 
#line 464
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 434 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_buf_t *ngx_http_autoindex_html(ngx_http_request_t *r , ngx_array_t *entries ) 
{ 
  u_char *last ;
  u_char scale ;
  off_t length ;
  size_t len ;
  size_t char_len ;
  size_t escape_html ;
  ngx_tm_t tm ;
  ngx_buf_t *b ;
  ngx_int_t size ;
  ngx_uint_t i ;
  ngx_uint_t utf8 ;
  ngx_time_t *tp ;
  ngx_http_autoindex_entry_t *entry ;
  ngx_http_autoindex_loc_conf_t *alcf ;
  ngx_int_t tmp ;
  uintptr_t tmp___0 ;
  void *tmp___1 ;
  uintptr_t tmp___2 ;
  void *tmp___3 ;
  uintptr_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  uintptr_t tmp___15 ;
  uintptr_t tmp___16 ;
  void *tmp___17 ;
  u_char *tmp___18 ;
  void *tmp___19 ;
  u_char *tmp___20 ;
  void *tmp___21 ;
  void *tmp___22 ;
  u_char *tmp___23 ;
  u_char *tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;

  {
#line 467
  if (r->headers_out.charset.len == 5UL) {
    {
#line 467
    tmp = ngx_strncasecmp(r->headers_out.charset.data, (u_char *)"utf-8", (size_t )5);
    }
#line 467
    if (tmp == 0L) {
#line 471
      utf8 = (ngx_uint_t )1;
    } else {
#line 474
      utf8 = (ngx_uint_t )0;
    }
  } else {
#line 474
    utf8 = (ngx_uint_t )0;
  }
  {
#line 477
  escape_html = ngx_escape_html((u_char *)((void *)0), r->uri.data, r->uri.len);
#line 479
  len = ((((((((((((((sizeof(title) - 1UL) + r->uri.len) + escape_html) + sizeof(header)) - 1UL) + r->uri.len) + escape_html) + sizeof("</h1>")) - 1UL) + sizeof("<hr><pre><a href=\"../\">../</a>\r\n")) - 1UL) + sizeof("</pre><hr>")) - 1UL) + sizeof(tail)) - 1UL;
#line 488
  entry = (ngx_http_autoindex_entry_t *)entries->elts;
#line 489
  i = (ngx_uint_t )0;
  }
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (i < entries->nelts)) {
#line 489
      goto while_break;
    }
    {
#line 490
    tmp___0 = ngx_escape_uri((u_char *)((void *)0), (entry + i)->name.data, (entry + i)->name.len,
                             (ngx_uint_t )2);
#line 490
    (entry + i)->escape = 2UL * tmp___0;
#line 494
    (entry + i)->escape_html = ngx_escape_html((u_char *)((void *)0), (entry + i)->name.data,
                                               (entry + i)->name.len);
    }
#line 497
    if (utf8) {
      {
#line 498
      (entry + i)->utf_len = ngx_utf8_length((entry + i)->name.data, (entry + i)->name.len);
      }
    } else {
#line 501
      (entry + i)->utf_len = (entry + i)->name.len;
    }
#line 504
    len += (((((((((((((((((sizeof("<a href=\"") - 1UL) + (entry + i)->name.len) + (entry + i)->escape) + 1UL) + sizeof("\">")) - 1UL) + (entry + i)->name.len) - (entry + i)->utf_len) + (entry + i)->escape_html) + 50UL) + sizeof("&gt;")) - 2UL) + sizeof("</a>")) - 1UL) + sizeof(" 28-Sep-1970 12:00 ")) - 1UL) + 20UL) + 2UL;
#line 489
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 517
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 518
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 519
    return ((ngx_buf_t *)((void *)0));
  }
  {
#line 522
  tmp___1 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(title),
                   sizeof(title) - 1UL);
#line 522
  b->last = (u_char *)tmp___1 + (sizeof(title) - 1UL);
  }
#line 524
  if (escape_html) {
    {
#line 525
    tmp___2 = ngx_escape_html(b->last, r->uri.data, r->uri.len);
#line 525
    b->last = (u_char *)tmp___2;
#line 526
    tmp___3 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header),
                     sizeof(header) - 1UL);
#line 526
    b->last = (u_char *)tmp___3 + (sizeof(header) - 1UL);
#line 527
    tmp___4 = ngx_escape_html(b->last, r->uri.data, r->uri.len);
#line 527
    b->last = (u_char *)tmp___4;
    }
  } else {
    {
#line 530
    tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->uri.data,
                     r->uri.len);
#line 530
    b->last = (u_char *)tmp___5 + r->uri.len;
#line 531
    tmp___6 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header),
                     sizeof(header) - 1UL);
#line 531
    b->last = (u_char *)tmp___6 + (sizeof(header) - 1UL);
#line 532
    tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->uri.data,
                     r->uri.len);
#line 532
    b->last = (u_char *)tmp___7 + r->uri.len;
    }
  }
  {
#line 535
  tmp___8 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"</h1>",
                   sizeof("</h1>") - 1UL);
#line 535
  b->last = (u_char *)tmp___8 + (sizeof("</h1>") - 1UL);
#line 537
  tmp___9 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"<hr><pre><a href=\"../\">../</a>\r\n",
                   sizeof("<hr><pre><a href=\"../\">../</a>\r\n") - 1UL);
#line 537
  b->last = (u_char *)tmp___9 + (sizeof("<hr><pre><a href=\"../\">../</a>\r\n") - 1UL);
#line 540
  alcf = (ngx_http_autoindex_loc_conf_t *)*(r->loc_conf + ngx_http_autoindex_module.ctx_index);
#line 541
  tp = (ngx_time_t *)ngx_cached_time;
#line 543
  i = (ngx_uint_t )0;
  }
  {
#line 543
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 543
    if (! (i < entries->nelts)) {
#line 543
      goto while_break___0;
    }
    {
#line 544
    tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"<a href=\"",
                      sizeof("<a href=\"") - 1UL);
#line 544
    b->last = (u_char *)tmp___10 + (sizeof("<a href=\"") - 1UL);
    }
#line 546
    if ((entry + i)->escape) {
      {
#line 547
      ngx_escape_uri(b->last, (entry + i)->name.data, (entry + i)->name.len, (ngx_uint_t )2);
#line 550
      b->last += (entry + i)->name.len + (entry + i)->escape;
      }
    } else {
      {
#line 553
      tmp___11 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(entry + i)->name.data,
                        (entry + i)->name.len);
#line 553
      b->last = (u_char *)tmp___11 + (entry + i)->name.len;
      }
    }
#line 557
    if ((entry + i)->dir) {
#line 558
      tmp___12 = b->last;
#line 558
      (b->last) ++;
#line 558
      *tmp___12 = (u_char )'/';
    }
#line 561
    tmp___13 = b->last;
#line 561
    (b->last) ++;
#line 561
    *tmp___13 = (u_char )'\"';
#line 562
    tmp___14 = b->last;
#line 562
    (b->last) ++;
#line 562
    *tmp___14 = (u_char )'>';
#line 564
    len = (entry + i)->utf_len;
#line 566
    if ((entry + i)->name.len != len) {
#line 567
      if (len > 50UL) {
#line 568
        char_len = (size_t )48;
      } else {
#line 571
        char_len = (size_t )51;
      }
      {
#line 574
      last = b->last;
#line 575
      b->last = ngx_utf8_cpystrn(b->last, (entry + i)->name.data, char_len, (entry + i)->name.len + 1UL);
      }
#line 578
      if ((entry + i)->escape_html) {
        {
#line 579
        tmp___15 = ngx_escape_html(last, (entry + i)->name.data, (size_t )(b->last - last));
#line 579
        b->last = (u_char *)tmp___15;
        }
      }
#line 583
      last = b->last;
    } else
#line 586
    if ((entry + i)->escape_html) {
#line 587
      if (len > 50UL) {
#line 588
        char_len = (size_t )47;
      } else {
#line 591
        char_len = len;
      }
      {
#line 594
      tmp___16 = ngx_escape_html(b->last, (entry + i)->name.data, char_len);
#line 594
      b->last = (u_char *)tmp___16;
#line 596
      last = b->last;
      }
    } else {
      {
#line 599
      b->last = ngx_cpystrn(b->last, (entry + i)->name.data, (size_t )51);
#line 601
      last = b->last - 3;
      }
    }
#line 605
    if (len > 50UL) {
      {
#line 606
      tmp___17 = memcpy((void */* __restrict  */)last, (void const   */* __restrict  */)"..&gt;</a>",
                        sizeof("..&gt;</a>") - 1UL);
#line 606
      b->last = (u_char *)tmp___17 + (sizeof("..&gt;</a>") - 1UL);
      }
    } else {
#line 609
      if ((entry + i)->dir) {
#line 609
        if (50UL - len > 0UL) {
#line 610
          tmp___18 = b->last;
#line 610
          (b->last) ++;
#line 610
          *tmp___18 = (u_char )'/';
#line 611
          len ++;
        }
      }
      {
#line 614
      tmp___19 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"</a>",
                        sizeof("</a>") - 1UL);
#line 614
      b->last = (u_char *)tmp___19 + (sizeof("</a>") - 1UL);
      }
#line 616
      if (50UL - len > 0UL) {
        {
#line 617
        memset((void *)b->last, ' ', 50UL - len);
#line 618
        b->last += 50UL - len;
        }
      }
    }
    {
#line 622
    tmp___20 = b->last;
#line 622
    (b->last) ++;
#line 622
    *tmp___20 = (u_char )' ';
#line 624
    ngx_gmtime((entry + i)->mtime + (tp->gmtoff * 60L) * alcf->localtime, & tm);
#line 626
    b->last = ngx_sprintf(b->last, "%02d-%s-%d %02d:%02d ", tm.tm_mday, months[tm.tm_mon - 1],
                          tm.tm_year, tm.tm_hour, tm.tm_min);
    }
#line 633
    if (alcf->exact_size) {
#line 634
      if ((entry + i)->dir) {
        {
#line 635
        tmp___21 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"                  -",
                          sizeof("                  -") - 1UL);
#line 635
        b->last = (u_char *)tmp___21 + (sizeof("                  -") - 1UL);
        }
      } else {
        {
#line 638
        b->last = ngx_sprintf(b->last, "%19O", (entry + i)->size);
        }
      }
    } else
#line 642
    if ((entry + i)->dir) {
      {
#line 643
      tmp___22 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"      -",
                        sizeof("      -") - 1UL);
#line 643
      b->last = (u_char *)tmp___22 + (sizeof("      -") - 1UL);
      }
    } else {
#line 647
      length = (entry + i)->size;
#line 649
      if (length > 1073741823L) {
#line 650
        size = length / 1073741824L;
#line 651
        if (length % 1073741824L > 536870911L) {
#line 654
          size ++;
        }
#line 656
        scale = (u_char )'G';
      } else
#line 658
      if (length > 1048575L) {
#line 659
        size = length / 1048576L;
#line 660
        if (length % 1048576L > 524287L) {
#line 661
          size ++;
        }
#line 663
        scale = (u_char )'M';
      } else
#line 665
      if (length > 9999L) {
#line 666
        size = length / 1024L;
#line 667
        if (length % 1024L > 511L) {
#line 668
          size ++;
        }
#line 670
        scale = (u_char )'K';
      } else {
#line 673
        size = length;
#line 674
        scale = (u_char )'\000';
      }
#line 677
      if (scale) {
        {
#line 678
        b->last = ngx_sprintf(b->last, "%6i%c", size, (int )scale);
        }
      } else {
        {
#line 681
        b->last = ngx_sprintf(b->last, " %6i", size);
        }
      }
    }
#line 686
    tmp___23 = b->last;
#line 686
    (b->last) ++;
#line 686
    *tmp___23 = (u_char )'\r';
#line 687
    tmp___24 = b->last;
#line 687
    (b->last) ++;
#line 687
    *tmp___24 = (u_char )'\n';
#line 543
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 690
  tmp___25 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"</pre><hr>",
                    sizeof("</pre><hr>") - 1UL);
#line 690
  b->last = (u_char *)tmp___25 + (sizeof("</pre><hr>") - 1UL);
#line 692
  tmp___26 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(tail),
                    sizeof(tail) - 1UL);
#line 692
  b->last = (u_char *)tmp___26 + (sizeof(tail) - 1UL);
  }
#line 694
  return (b);
}
}
#line 698 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_buf_t *ngx_http_autoindex_json(ngx_http_request_t *r , ngx_array_t *entries ,
                                          ngx_str_t *callback ) 
{ 
  size_t len ;
  ngx_buf_t *b ;
  ngx_uint_t i ;
  ngx_http_autoindex_entry_t *entry ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  uintptr_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  u_char *tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
#line 707
  len = sizeof("[\r\n\r\n]") - 1UL;
#line 709
  if (callback) {
#line 710
    len += (sizeof("/* callback */\r\n();") - 1UL) + callback->len;
  }
#line 713
  entry = (ngx_http_autoindex_entry_t *)entries->elts;
#line 715
  i = (ngx_uint_t )0;
  {
#line 715
  while (1) {
    while_continue: /* CIL Label */ ;
#line 715
    if (! (i < entries->nelts)) {
#line 715
      goto while_break;
    }
    {
#line 716
    (entry + i)->escape = ngx_escape_json((u_char *)((void *)0), (entry + i)->name.data,
                                          (entry + i)->name.len);
#line 719
    len += ((((((((sizeof("{  },\r\n") - 1UL) + sizeof("\"name\":\"\"")) - 1UL) + (entry + i)->name.len) + (entry + i)->escape) + sizeof(", \"type\":\"directory\"")) - 1UL) + sizeof(", \"mtime\":\"Wed, 31 Dec 1986 10:00:00 GMT\"")) - 1UL;
    }
#line 725
    if ((entry + i)->file) {
#line 726
      len += (sizeof(", \"size\":") - 1UL) + (sizeof("-9223372036854775808") - 1UL);
    }
#line 715
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 730
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 731
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 732
    return ((ngx_buf_t *)((void *)0));
  }
#line 735
  if (callback) {
    {
#line 736
    tmp = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"/* callback */\r\n",
                 sizeof("/* callback */\r\n") - 1UL);
#line 736
    b->last = (u_char *)tmp + (sizeof("/* callback */\r\n") - 1UL);
#line 739
    tmp___0 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)callback->data,
                     callback->len);
#line 739
    b->last = (u_char *)tmp___0 + callback->len;
#line 741
    tmp___1 = b->last;
#line 741
    (b->last) ++;
#line 741
    *tmp___1 = (u_char )'(';
    }
  }
#line 744
  tmp___2 = b->last;
#line 744
  (b->last) ++;
#line 744
  *tmp___2 = (u_char )'[';
#line 746
  i = (ngx_uint_t )0;
  {
#line 746
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 746
    if (! (i < entries->nelts)) {
#line 746
      goto while_break___0;
    }
    {
#line 747
    tmp___3 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\r\n{ \"name\":\"",
                     sizeof("\r\n{ \"name\":\"") - 1UL);
#line 747
    b->last = (u_char *)tmp___3 + (sizeof("\r\n{ \"name\":\"") - 1UL);
    }
#line 750
    if ((entry + i)->escape) {
      {
#line 751
      tmp___4 = ngx_escape_json(b->last, (entry + i)->name.data, (entry + i)->name.len);
#line 751
      b->last = (u_char *)tmp___4;
      }
    } else {
      {
#line 754
      tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(entry + i)->name.data,
                       (entry + i)->name.len);
#line 754
      b->last = (u_char *)tmp___5 + (entry + i)->name.len;
      }
    }
    {
#line 758
    tmp___6 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\", \"type\":\"",
                     sizeof("\", \"type\":\"") - 1UL);
#line 758
    b->last = (u_char *)tmp___6 + (sizeof("\", \"type\":\"") - 1UL);
    }
#line 761
    if ((entry + i)->dir) {
      {
#line 762
      tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"directory",
                       sizeof("directory") - 1UL);
#line 762
      b->last = (u_char *)tmp___7 + (sizeof("directory") - 1UL);
      }
    } else
#line 764
    if ((entry + i)->file) {
      {
#line 765
      tmp___8 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"file",
                       sizeof("file") - 1UL);
#line 765
      b->last = (u_char *)tmp___8 + (sizeof("file") - 1UL);
      }
    } else {
      {
#line 768
      tmp___9 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"other",
                       sizeof("other") - 1UL);
#line 768
      b->last = (u_char *)tmp___9 + (sizeof("other") - 1UL);
      }
    }
    {
#line 771
    tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\", \"mtime\":\"",
                      sizeof("\", \"mtime\":\"") - 1UL);
#line 771
    b->last = (u_char *)tmp___10 + (sizeof("\", \"mtime\":\"") - 1UL);
#line 774
    b->last = ngx_http_time(b->last, (entry + i)->mtime);
    }
#line 776
    if ((entry + i)->file) {
      {
#line 777
      tmp___11 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\", \"size\":",
                        sizeof("\", \"size\":") - 1UL);
#line 777
      b->last = (u_char *)tmp___11 + (sizeof("\", \"size\":") - 1UL);
#line 779
      b->last = ngx_sprintf(b->last, "%O", (entry + i)->size);
      }
    } else {
#line 782
      tmp___12 = b->last;
#line 782
      (b->last) ++;
#line 782
      *tmp___12 = (u_char )'\"';
    }
    {
#line 785
    tmp___13 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)" },",
                      sizeof(" },") - 1UL);
#line 785
    b->last = (u_char *)tmp___13 + (sizeof(" },") - 1UL);
#line 746
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 788
  if (i > 0UL) {
#line 789
    (b->last) --;
  }
  {
#line 792
  tmp___14 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\r\n]",
                    sizeof("\r\n]") - 1UL);
#line 792
  b->last = (u_char *)tmp___14 + (sizeof("\r\n]") - 1UL);
  }
#line 794
  if (callback) {
#line 795
    tmp___15 = b->last;
#line 795
    (b->last) ++;
#line 795
    *tmp___15 = (u_char )')';
#line 795
    tmp___16 = b->last;
#line 795
    (b->last) ++;
#line 795
    *tmp___16 = (u_char )';';
  }
#line 798
  return (b);
}
}
#line 802 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_int_t ngx_http_autoindex_jsonp_callback(ngx_http_request_t *r , ngx_str_t *callback ) 
{ 
  u_char *p ;
  u_char c ;
  u_char ch ;
  ngx_uint_t i ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 808
  tmp = ngx_http_arg(r, (u_char *)"callback", (size_t )8, callback);
  }
#line 808
  if (tmp != 0L) {
#line 809
    callback->len = (size_t )0;
#line 810
    return ((ngx_int_t )0);
  }
#line 813
  if (callback->len > 128UL) {
#line 814
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 814
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent too long callback name: \"%V\"",
                         callback);
      }
    }
#line 816
    return ((ngx_int_t )-5);
  }
#line 819
  p = callback->data;
#line 821
  i = (ngx_uint_t )0;
  {
#line 821
  while (1) {
    while_continue: /* CIL Label */ ;
#line 821
    if (! (i < callback->len)) {
#line 821
      goto while_break;
    }
#line 822
    ch = *(p + i);
#line 824
    c = (u_char )((int )ch | 32);
#line 825
    if ((int )c >= 97) {
#line 825
      if ((int )c <= 122) {
#line 826
        goto __Cont;
      }
    }
#line 829
    if ((int )ch >= 48) {
#line 829
      if ((int )ch <= 57) {
#line 830
        goto __Cont;
      } else {
#line 829
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 829
    if ((int )ch == 95) {
#line 830
      goto __Cont;
    } else
#line 829
    if ((int )ch == 46) {
#line 830
      goto __Cont;
    }
#line 833
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 833
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent invalid callback name: \"%V\"",
                         callback);
      }
    }
#line 836
    return ((ngx_int_t )-5);
    __Cont: /* CIL Label */ 
#line 821
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  return ((ngx_int_t )0);
}
}
#line 853 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static u_char head[32]  = 
#line 853
  {      (u_char )'<',      (u_char )'?',      (u_char )'x',      (u_char )'m', 
        (u_char )'l',      (u_char )' ',      (u_char )'v',      (u_char )'e', 
        (u_char )'r',      (u_char )'s',      (u_char )'i',      (u_char )'o', 
        (u_char )'n',      (u_char )'=',      (u_char )'\"',      (u_char )'1', 
        (u_char )'.',      (u_char )'0',      (u_char )'\"',      (u_char )'?', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'l',      (u_char )'i',      (u_char )'s',      (u_char )'t', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 854 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static u_char tail___0[10]  = 
#line 854
  {      (u_char )'<',      (u_char )'/',      (u_char )'l',      (u_char )'i', 
        (u_char )'s',      (u_char )'t',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'\000'};
#line 843 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_buf_t *ngx_http_autoindex_xml(ngx_http_request_t *r , ngx_array_t *entries ) 
{ 
  size_t len ;
  ngx_tm_t tm ;
  ngx_buf_t *b ;
  ngx_str_t type ;
  ngx_uint_t i ;
  ngx_http_autoindex_entry_t *entry ;
  void *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  uintptr_t tmp___6 ;
  void *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  void *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  void *tmp___14 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 856
  len = ((sizeof(head) - 1UL) + sizeof(tail___0)) - 1UL;
#line 858
  entry = (ngx_http_autoindex_entry_t *)entries->elts;
#line 860
  i = (ngx_uint_t )0;
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    if (! (i < entries->nelts)) {
#line 860
      goto while_break;
    }
    {
#line 861
    (entry + i)->escape = ngx_escape_html((u_char *)((void *)0), (entry + i)->name.data,
                                          (entry + i)->name.len);
#line 864
    len += ((((sizeof("<directory></directory>\r\n") - 1UL) + (entry + i)->name.len) + (entry + i)->escape) + sizeof(" mtime=\"1986-12-31T10:00:00Z\"")) - 1UL;
    }
#line 868
    if ((entry + i)->file) {
#line 869
      len += (sizeof(" size=\"\"") - 1UL) + (sizeof("-9223372036854775808") - 1UL);
    }
#line 860
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 873
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 874
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 875
    return ((ngx_buf_t *)((void *)0));
  }
  {
#line 878
  tmp = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(head),
               sizeof(head) - 1UL);
#line 878
  b->last = (u_char *)tmp + (sizeof(head) - 1UL);
#line 880
  i = (ngx_uint_t )0;
  }
  {
#line 880
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 880
    if (! (i < entries->nelts)) {
#line 880
      goto while_break___0;
    }
#line 881
    tmp___0 = b->last;
#line 881
    (b->last) ++;
#line 881
    *tmp___0 = (u_char )'<';
#line 883
    if ((entry + i)->dir) {
#line 884
      type.len = sizeof("directory") - 1UL;
#line 884
      type.data = (u_char *)"directory";
    } else
#line 886
    if ((entry + i)->file) {
#line 887
      type.len = sizeof("file") - 1UL;
#line 887
      type.data = (u_char *)"file";
    } else {
#line 890
      type.len = sizeof("other") - 1UL;
#line 890
      type.data = (u_char *)"other";
    }
    {
#line 893
    tmp___1 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)type.data,
                     type.len);
#line 893
    b->last = (u_char *)tmp___1 + type.len;
#line 895
    tmp___2 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)" mtime=\"",
                     sizeof(" mtime=\"") - 1UL);
#line 895
    b->last = (u_char *)tmp___2 + (sizeof(" mtime=\"") - 1UL);
#line 897
    ngx_gmtime((entry + i)->mtime, & tm);
#line 899
    b->last = ngx_sprintf(b->last, "%4d-%02d-%02dT%02d:%02d:%02dZ", tm.tm_year, tm.tm_mon,
                          tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec);
    }
#line 904
    if ((entry + i)->file) {
      {
#line 905
      tmp___3 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"\" size=\"",
                       sizeof("\" size=\"") - 1UL);
#line 905
      b->last = (u_char *)tmp___3 + (sizeof("\" size=\"") - 1UL);
#line 907
      b->last = ngx_sprintf(b->last, "%O", (entry + i)->size);
      }
    }
#line 910
    tmp___4 = b->last;
#line 910
    (b->last) ++;
#line 910
    *tmp___4 = (u_char )'\"';
#line 910
    tmp___5 = b->last;
#line 910
    (b->last) ++;
#line 910
    *tmp___5 = (u_char )'>';
#line 912
    if ((entry + i)->escape) {
      {
#line 913
      tmp___6 = ngx_escape_html(b->last, (entry + i)->name.data, (entry + i)->name.len);
#line 913
      b->last = (u_char *)tmp___6;
      }
    } else {
      {
#line 916
      tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(entry + i)->name.data,
                       (entry + i)->name.len);
#line 916
      b->last = (u_char *)tmp___7 + (entry + i)->name.len;
      }
    }
    {
#line 920
    tmp___8 = b->last;
#line 920
    (b->last) ++;
#line 920
    *tmp___8 = (u_char )'<';
#line 920
    tmp___9 = b->last;
#line 920
    (b->last) ++;
#line 920
    *tmp___9 = (u_char )'/';
#line 922
    tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)type.data,
                      type.len);
#line 922
    b->last = (u_char *)tmp___10 + type.len;
#line 924
    tmp___11 = b->last;
#line 924
    (b->last) ++;
#line 924
    *tmp___11 = (u_char )'>';
#line 926
    tmp___12 = b->last;
#line 926
    (b->last) ++;
#line 926
    *tmp___12 = (u_char )'\r';
#line 926
    tmp___13 = b->last;
#line 926
    (b->last) ++;
#line 926
    *tmp___13 = (u_char )'\n';
#line 880
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 929
  tmp___14 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(tail___0),
                    sizeof(tail___0) - 1UL);
#line 929
  b->last = (u_char *)tmp___14 + (sizeof(tail___0) - 1UL);
  }
#line 931
  return (b);
}
}
#line 935 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static int ngx_http_autoindex_cmp_entries(void const   *one , void const   *two ) 
{ 
  ngx_http_autoindex_entry_t *first ;
  ngx_http_autoindex_entry_t *second ;
  int tmp ;

  {
#line 938
  first = (ngx_http_autoindex_entry_t *)one;
#line 939
  second = (ngx_http_autoindex_entry_t *)two;
#line 941
  if (first->dir) {
#line 941
    if (! second->dir) {
#line 943
      return (-1);
    }
  }
#line 946
  if (! first->dir) {
#line 946
    if (second->dir) {
#line 948
      return (1);
    }
  }
  {
#line 951
  tmp = strcmp((char const   *)first->name.data, (char const   *)second->name.data);
  }
#line 951
  return (tmp);
}
}
#line 993 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_int_t ngx_http_autoindex_error(ngx_http_request_t *r , ngx_dir_t *dir ,
                                          ngx_str_t *name ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
  {
#line 996
  tmp___0 = closedir(dir->dir);
  }
#line 996
  if (tmp___0 == -1) {
#line 997
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 997
      tmp = __errno_location();
#line 997
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, *tmp, "closedir() \"%V\" failed",
                         name);
      }
    }
  }
#line 1001
  if (r->header_sent) {
#line 1001
    tmp___1 = -1;
  } else {
#line 1001
    tmp___1 = 500;
  }
#line 1001
  return ((ngx_int_t )tmp___1);
}
}
#line 1005 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static void *ngx_http_autoindex_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_autoindex_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 1010
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_autoindex_loc_conf_t ));
#line 1010
  conf = (ngx_http_autoindex_loc_conf_t *)tmp;
  }
#line 1011
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1012
    return ((void *)0);
  }
#line 1015
  conf->enable = (ngx_flag_t )-1;
#line 1016
  conf->format = (ngx_uint_t )-1;
#line 1017
  conf->localtime = (ngx_flag_t )-1;
#line 1018
  conf->exact_size = (ngx_flag_t )-1;
#line 1020
  return ((void *)conf);
}
}
#line 1024 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static char *ngx_http_autoindex_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_autoindex_loc_conf_t *prev ;
  ngx_http_autoindex_loc_conf_t *conf ;

  {
#line 1027
  prev = (ngx_http_autoindex_loc_conf_t *)parent;
#line 1028
  conf = (ngx_http_autoindex_loc_conf_t *)child;
#line 1030
  if (conf->enable == -1L) {
#line 1030
    if (prev->enable == -1L) {
#line 1030
      conf->enable = (ngx_flag_t )0;
    } else {
#line 1030
      conf->enable = prev->enable;
    }
  }
#line 1031
  if (conf->format == 0xffffffffffffffffUL) {
#line 1031
    if (prev->format == 0xffffffffffffffffUL) {
#line 1031
      conf->format = (ngx_uint_t )0;
    } else {
#line 1031
      conf->format = prev->format;
    }
  }
#line 1033
  if (conf->localtime == -1L) {
#line 1033
    if (prev->localtime == -1L) {
#line 1033
      conf->localtime = (ngx_flag_t )0;
    } else {
#line 1033
      conf->localtime = prev->localtime;
    }
  }
#line 1034
  if (conf->exact_size == -1L) {
#line 1034
    if (prev->exact_size == -1L) {
#line 1034
      conf->exact_size = (ngx_flag_t )1;
    } else {
#line 1034
      conf->exact_size = prev->exact_size;
    }
  }
#line 1036
  return ((char *)((void *)0));
}
}
#line 1040 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_autoindex_module.c"
static ngx_int_t ngx_http_autoindex_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 1046
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 1048
  tmp = ngx_array_push(& cmcf->phases[9].handlers);
#line 1048
  h = (ngx_http_handler_pt *)tmp;
  }
#line 1049
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1050
    return ((ngx_int_t )-1);
  }
#line 1053
  *h = & ngx_http_autoindex_handler;
#line 1055
  return ((ngx_int_t )0);
}
}
#line 484 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_set_etag(ngx_http_request_t *r ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_static_module.c"
static ngx_int_t ngx_http_static_handler(ngx_http_request_t *r ) ;
#line 14
static ngx_int_t ngx_http_static_init(ngx_conf_t *cf ) ;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_static_module.c"
static ngx_http_module_t ngx_http_static_module_ctx  = 
#line 17
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_static_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_static_module.c"
ngx_module_t ngx_http_static_module  = 
#line 32
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_static_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 48 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_static_module.c"
static ngx_int_t ngx_http_static_handler(ngx_http_request_t *r ) 
{ 
  u_char *last ;
  u_char *location ;
  size_t root ;
  size_t len ;
  ngx_str_t path ;
  ngx_int_t rc ;
  ngx_uint_t level ;
  ngx_log_t *log ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  ngx_open_file_info_t of ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 62
  if (! (r->method & 14UL)) {
#line 63
    return ((ngx_int_t )405);
  }
#line 66
  if ((int )*(r->uri.data + (r->uri.len - 1UL)) == 47) {
#line 67
    return ((ngx_int_t )-5);
  }
  {
#line 70
  log = (r->connection)->log;
#line 77
  last = ngx_http_map_uri_to_path(r, & path, & root, (size_t )0);
  }
#line 78
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 79
    return ((ngx_int_t )500);
  }
  {
#line 82
  path.len = (size_t )(last - path.data);
#line 87
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 89
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 91
  of.read_ahead = clcf->read_ahead;
#line 92
  of.directio = clcf->directio;
#line 93
  of.valid = clcf->open_file_cache_valid;
#line 94
  of.min_uses = clcf->open_file_cache_min_uses;
#line 95
  of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 96
  of.events = (unsigned int )clcf->open_file_cache_events;
#line 98
  tmp = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
  }
#line 98
  if (tmp != 0L) {
#line 99
    return ((ngx_int_t )500);
  }
  {
#line 102
  tmp___0 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
  }
#line 102
  if (tmp___0 != 0L) {
    {
#line 107
    if (of.err == 0) {
#line 107
      goto case_0;
    }
#line 112
    if (of.err == 36) {
#line 112
      goto case_36;
    }
#line 112
    if (of.err == 20) {
#line 112
      goto case_36;
    }
#line 112
    if (of.err == 2) {
#line 112
      goto case_36;
    }
#line 121
    if (of.err == 40) {
#line 121
      goto case_40;
    }
#line 121
    if (of.err == 31) {
#line 121
      goto case_40;
    }
#line 121
    if (of.err == 13) {
#line 121
      goto case_40;
    }
#line 128
    goto switch_default;
    case_0: /* CIL Label */ 
#line 108
    return ((ngx_int_t )500);
    case_36: /* CIL Label */ 
    case_20: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 114
    level = (ngx_uint_t )4;
#line 115
    rc = (ngx_int_t )404;
#line 116
    goto switch_break;
    case_40: /* CIL Label */ 
    case_31: /* CIL Label */ 
    case_13: /* CIL Label */ 
#line 124
    level = (ngx_uint_t )4;
#line 125
    rc = (ngx_int_t )403;
#line 126
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 130
    level = (ngx_uint_t )3;
#line 131
    rc = (ngx_int_t )500;
#line 132
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 135
    if (rc != 404L) {
#line 135
      goto _L;
    } else
#line 135
    if (clcf->log_not_found) {
      _L: /* CIL Label */ 
#line 136
      if (log->log_level >= level) {
        {
#line 136
        ngx_log_error_core(level, log, of.err, "%s \"%s\" failed", of.failed, path.data);
        }
      }
    }
#line 140
    return (rc);
  }
#line 143
  r->root_tested = (unsigned int )(! r->error_page);
#line 147
  if (of.is_dir) {
#line 151
    if (r->headers_out.location) {
#line 151
      (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 151
      r->headers_out.location = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 153
    tmp___1 = ngx_list_push(& r->headers_out.headers);
#line 153
    r->headers_out.location = (ngx_table_elt_t *)tmp___1;
    }
#line 154
    if ((unsigned long )r->headers_out.location == (unsigned long )((void *)0)) {
#line 155
      return ((ngx_int_t )500);
    }
#line 158
    len = r->uri.len + 1UL;
#line 160
    if (! clcf->alias) {
#line 160
      if ((unsigned long )clcf->root_lengths == (unsigned long )((void *)0)) {
#line 160
        if (r->args.len == 0UL) {
#line 161
          location = path.data + clcf->root.len;
#line 163
          *last = (u_char )'/';
        } else {
#line 160
          goto _L___1;
        }
      } else {
#line 160
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 166
      if (r->args.len) {
#line 167
        len += r->args.len + 1UL;
      }
      {
#line 170
      tmp___2 = ngx_pnalloc(r->pool, len);
#line 170
      location = (u_char *)tmp___2;
      }
#line 171
      if ((unsigned long )location == (unsigned long )((void *)0)) {
#line 172
        if (r->headers_out.location) {
#line 172
          (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 172
          r->headers_out.location = (ngx_table_elt_t *)((void *)0);
        }
#line 173
        return ((ngx_int_t )500);
      }
      {
#line 176
      tmp___3 = memcpy((void */* __restrict  */)location, (void const   */* __restrict  */)r->uri.data,
                       r->uri.len);
#line 176
      last = (u_char *)tmp___3 + r->uri.len;
#line 178
      *last = (u_char )'/';
      }
#line 180
      if (r->args.len) {
        {
#line 181
        last ++;
#line 181
        *last = (u_char )'?';
#line 182
        last ++;
#line 182
        memcpy((void */* __restrict  */)last, (void const   */* __restrict  */)r->args.data,
               r->args.len);
        }
      }
    }
#line 186
    (r->headers_out.location)->hash = (ngx_uint_t )1;
#line 187
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 187
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 188
    (r->headers_out.location)->value.len = len;
#line 189
    (r->headers_out.location)->value.data = location;
#line 191
    return ((ngx_int_t )301);
  }
#line 196
  if (! of.is_file) {
#line 197
    if (log->log_level >= 3UL) {
      {
#line 197
      ngx_log_error_core((ngx_uint_t )3, log, 0, "\"%s\" is not a regular file", path.data);
      }
    }
#line 200
    return ((ngx_int_t )404);
  }
#line 205
  if (r->method == 8UL) {
#line 206
    return ((ngx_int_t )405);
  }
  {
#line 209
  rc = ngx_http_discard_request_body(r);
  }
#line 211
  if (rc != 0L) {
#line 212
    return (rc);
  }
  {
#line 215
  log->action = (char *)"sending response to client";
#line 217
  r->headers_out.status = (ngx_uint_t )200;
#line 218
  r->headers_out.content_length_n = of.size;
#line 219
  r->headers_out.last_modified_time = of.mtime;
#line 221
  tmp___4 = ngx_http_set_etag(r);
  }
#line 221
  if (tmp___4 != 0L) {
#line 222
    return ((ngx_int_t )500);
  }
  {
#line 225
  tmp___5 = ngx_http_set_content_type(r);
  }
#line 225
  if (tmp___5 != 0L) {
#line 226
    return ((ngx_int_t )500);
  }
#line 229
  if ((unsigned long )r != (unsigned long )r->main) {
#line 229
    if (of.size == 0L) {
      {
#line 230
      tmp___6 = ngx_http_send_header(r);
      }
#line 230
      return (tmp___6);
    }
  }
  {
#line 233
  r->allow_ranges = 1U;
#line 237
  tmp___7 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 237
  b = (ngx_buf_t *)tmp___7;
  }
#line 238
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 239
    return ((ngx_int_t )500);
  }
  {
#line 242
  tmp___8 = ngx_pcalloc(r->pool, sizeof(ngx_file_t ));
#line 242
  b->file = (ngx_file_t *)tmp___8;
  }
#line 243
  if ((unsigned long )b->file == (unsigned long )((void *)0)) {
#line 244
    return ((ngx_int_t )500);
  }
  {
#line 247
  rc = ngx_http_send_header(r);
  }
#line 249
  if (rc == -1L) {
#line 250
    return (rc);
  } else
#line 249
  if (rc > 0L) {
#line 250
    return (rc);
  } else
#line 249
  if (r->header_only) {
#line 250
    return (rc);
  }
#line 253
  b->file_pos = (off_t )0;
#line 254
  b->file_last = of.size;
#line 256
  if (b->file_last) {
#line 256
    b->in_file = 1U;
  } else {
#line 256
    b->in_file = 0U;
  }
#line 257
  if ((unsigned long )r == (unsigned long )r->main) {
#line 257
    b->last_buf = 1U;
  } else {
#line 257
    b->last_buf = 0U;
  }
  {
#line 258
  b->last_in_chain = 1U;
#line 260
  (b->file)->fd = of.fd;
#line 261
  (b->file)->name = path;
#line 262
  (b->file)->log = log;
#line 263
  (b->file)->directio = of.is_directio;
#line 265
  out.buf = b;
#line 266
  out.next = (ngx_chain_t *)((void *)0);
#line 268
  tmp___9 = ngx_http_output_filter(r, & out);
  }
#line 268
  return (tmp___9);
}
}
#line 272 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_static_module.c"
static ngx_int_t ngx_http_static_init(ngx_conf_t *cf ) 
{ 
  ngx_http_handler_pt *h ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;

  {
  {
#line 278
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 280
  tmp = ngx_array_push(& cmcf->phases[9].handlers);
#line 280
  h = (ngx_http_handler_pt *)tmp;
  }
#line 281
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 282
    return ((ngx_int_t )-1);
  }
#line 285
  *h = & ngx_http_static_handler;
#line 287
  return ((ngx_int_t )0);
}
}
#line 16 "src/core/ngx_parse_time.h"
time_t ngx_parse_http_time(u_char *value , size_t len ) ;
#line 143 "src/http/ngx_http.h"
ngx_int_t ngx_http_filter_finalize_request(ngx_http_request_t *r , ngx_module_t *m ,
                                           ngx_int_t error ) ;
#line 171
ngx_int_t (*ngx_http_top_header_filter)(ngx_http_request_t *r ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_uint_t ngx_http_test_if_unmodified(ngx_http_request_t *r ) ;
#line 14
static ngx_uint_t ngx_http_test_if_modified(ngx_http_request_t *r ) ;
#line 15
static ngx_uint_t ngx_http_test_if_match(ngx_http_request_t *r , ngx_table_elt_t *header___0 ,
                                         ngx_uint_t weak ) ;
#line 17
static ngx_int_t ngx_http_not_modified_filter_init(ngx_conf_t *cf ) ;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_http_module_t ngx_http_not_modified_filter_module_ctx  = 
#line 20
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_not_modified_filter_init,
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
ngx_module_t ngx_http_not_modified_filter_module  = 
#line 35
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_not_modified_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter)(ngx_http_request_t *r )  ;
#line 54 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_int_t ngx_http_not_modified_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_uint_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_uint_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_uint_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_uint_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;

  {
#line 57
  if (r->headers_out.status != 200UL) {
    {
#line 61
    tmp = (*ngx_http_next_header_filter)(r);
    }
#line 61
    return (tmp);
  } else
#line 57
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 61
    tmp = (*ngx_http_next_header_filter)(r);
    }
#line 61
    return (tmp);
  } else
#line 57
  if (r->disable_not_modified) {
    {
#line 61
    tmp = (*ngx_http_next_header_filter)(r);
    }
#line 61
    return (tmp);
  }
#line 64
  if (r->headers_in.if_unmodified_since) {
    {
#line 64
    tmp___1 = ngx_http_test_if_unmodified(r);
    }
#line 64
    if (! tmp___1) {
      {
#line 67
      tmp___0 = ngx_http_filter_finalize_request(r, (ngx_module_t *)((void *)0), (ngx_int_t )412);
      }
#line 67
      return (tmp___0);
    }
  }
#line 71
  if (r->headers_in.if_match) {
    {
#line 71
    tmp___3 = ngx_http_test_if_match(r, r->headers_in.if_match, (ngx_uint_t )0);
    }
#line 71
    if (! tmp___3) {
      {
#line 74
      tmp___2 = ngx_http_filter_finalize_request(r, (ngx_module_t *)((void *)0), (ngx_int_t )412);
      }
#line 74
      return (tmp___2);
    }
  }
#line 78
  if (r->headers_in.if_modified_since) {
#line 78
    goto _L;
  } else
#line 78
  if (r->headers_in.if_none_match) {
    _L: /* CIL Label */ 
#line 80
    if (r->headers_in.if_modified_since) {
      {
#line 80
      tmp___5 = ngx_http_test_if_modified(r);
      }
#line 80
      if (tmp___5) {
        {
#line 83
        tmp___4 = (*ngx_http_next_header_filter)(r);
        }
#line 83
        return (tmp___4);
      }
    }
#line 86
    if (r->headers_in.if_none_match) {
      {
#line 86
      tmp___7 = ngx_http_test_if_match(r, r->headers_in.if_none_match, (ngx_uint_t )1);
      }
#line 86
      if (! tmp___7) {
        {
#line 89
        tmp___6 = (*ngx_http_next_header_filter)(r);
        }
#line 89
        return (tmp___6);
      }
    }
#line 94
    r->headers_out.status = (ngx_uint_t )304;
#line 95
    r->headers_out.status_line.len = (size_t )0;
#line 96
    r->headers_out.content_type.len = (size_t )0;
#line 97
    r->headers_out.content_length_n = (off_t )-1;
#line 97
    if (r->headers_out.content_length) {
#line 97
      (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 97
      r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
    }
#line 98
    r->allow_ranges = 0U;
#line 98
    if (r->headers_out.accept_ranges) {
#line 98
      (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 98
      r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
    }
#line 100
    if (r->headers_out.content_encoding) {
#line 101
      (r->headers_out.content_encoding)->hash = (ngx_uint_t )0;
#line 102
      r->headers_out.content_encoding = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 105
    tmp___8 = (*ngx_http_next_header_filter)(r);
    }
#line 105
    return (tmp___8);
  }
  {
#line 108
  tmp___9 = (*ngx_http_next_header_filter)(r);
  }
#line 108
  return (tmp___9);
}
}
#line 112 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_uint_t ngx_http_test_if_unmodified(ngx_http_request_t *r ) 
{ 
  time_t iums ;

  {
#line 117
  if (r->headers_out.last_modified_time == -1L) {
#line 118
    return ((ngx_uint_t )0);
  }
  {
#line 121
  iums = ngx_parse_http_time((r->headers_in.if_unmodified_since)->value.data, (r->headers_in.if_unmodified_since)->value.len);
  }
#line 127
  if (iums >= r->headers_out.last_modified_time) {
#line 128
    return ((ngx_uint_t )1);
  }
#line 131
  return ((ngx_uint_t )0);
}
}
#line 135 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_uint_t ngx_http_test_if_modified(ngx_http_request_t *r ) 
{ 
  time_t ims ;
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 141
  if (r->headers_out.last_modified_time == -1L) {
#line 142
    return ((ngx_uint_t )1);
  }
#line 145
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 147
  if (clcf->if_modified_since == 0UL) {
#line 148
    return ((ngx_uint_t )1);
  }
  {
#line 151
  ims = ngx_parse_http_time((r->headers_in.if_modified_since)->value.data, (r->headers_in.if_modified_since)->value.len);
  }
#line 157
  if (ims == r->headers_out.last_modified_time) {
#line 158
    return ((ngx_uint_t )0);
  }
#line 161
  if (clcf->if_modified_since == 1UL) {
#line 164
    return ((ngx_uint_t )1);
  } else
#line 161
  if (ims < r->headers_out.last_modified_time) {
#line 164
    return ((ngx_uint_t )1);
  }
#line 167
  return ((ngx_uint_t )0);
}
}
#line 171 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_uint_t ngx_http_test_if_match(ngx_http_request_t *r , ngx_table_elt_t *header___0 ,
                                         ngx_uint_t weak ) 
{ 
  u_char *start ;
  u_char *end ;
  u_char ch ;
  ngx_str_t etag ;
  ngx_str_t *list ;
  int tmp ;

  {
#line 178
  list = & header___0->value;
#line 180
  if (list->len == 1UL) {
#line 180
    if ((int )*(list->data + 0) == 42) {
#line 181
      return ((ngx_uint_t )1);
    }
  }
#line 184
  if ((unsigned long )r->headers_out.etag == (unsigned long )((void *)0)) {
#line 185
    return ((ngx_uint_t )0);
  }
#line 188
  etag = (r->headers_out.etag)->value;
#line 193
  if (weak) {
#line 193
    if (etag.len > 2UL) {
#line 193
      if ((int )*(etag.data + 0) == 87) {
#line 193
        if ((int )*(etag.data + 1) == 47) {
#line 198
          etag.len -= 2UL;
#line 199
          etag.data += 2;
        }
      }
    }
  }
#line 202
  start = list->data;
#line 203
  end = list->data + list->len;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 205
    if (! ((unsigned long )start < (unsigned long )end)) {
#line 205
      goto while_break;
    }
#line 207
    if (weak) {
#line 207
      if (end - start > 2L) {
#line 207
        if ((int )*(start + 0) == 87) {
#line 207
          if ((int )*(start + 1) == 47) {
#line 212
            start += 2;
          }
        }
      }
    }
#line 215
    if (etag.len > (size_t )(end - start)) {
#line 216
      return ((ngx_uint_t )0);
    }
    {
#line 219
    tmp = strncmp((char const   *)start, (char const   *)etag.data, etag.len);
    }
#line 219
    if (tmp != 0) {
#line 220
      goto skip;
    }
#line 223
    start += etag.len;
    {
#line 225
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 225
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 225
        goto while_break___0;
      }
#line 226
      ch = *start;
#line 228
      if ((int )ch == 32) {
#line 229
        start ++;
#line 230
        goto while_continue___0;
      } else
#line 228
      if ((int )ch == 9) {
#line 229
        start ++;
#line 230
        goto while_continue___0;
      }
#line 233
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 236
    if ((unsigned long )start == (unsigned long )end) {
#line 237
      return ((ngx_uint_t )1);
    } else
#line 236
    if ((int )*start == 44) {
#line 237
      return ((ngx_uint_t )1);
    }
    skip: 
    {
#line 242
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 242
      if ((unsigned long )start < (unsigned long )end) {
#line 242
        if (! ((int )*start != 44)) {
#line 242
          goto while_break___1;
        }
      } else {
#line 242
        goto while_break___1;
      }
#line 242
      start ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 243
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 243
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 243
        goto while_break___2;
      }
#line 244
      ch = *start;
#line 246
      if ((int )ch == 32) {
#line 247
        start ++;
#line 248
        goto while_continue___2;
      } else
#line 246
      if ((int )ch == 9) {
#line 247
        start ++;
#line 248
        goto while_continue___2;
      } else
#line 246
      if ((int )ch == 44) {
#line 247
        start ++;
#line 248
        goto while_continue___2;
      }
#line 251
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return ((ngx_uint_t )0);
}
}
#line 259 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_not_modified_filter_module.c"
static ngx_int_t ngx_http_not_modified_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 262
  ngx_http_next_header_filter = ngx_http_top_header_filter;
#line 263
  ngx_http_top_header_filter = & ngx_http_not_modified_header_filter;
#line 265
  return ((ngx_int_t )0);
}
}
#line 157 "src/core/ngx_buf.h"
ngx_int_t ngx_output_chain(ngx_output_chain_ctx_t *ctx , ngx_chain_t *in ) ;
#line 172 "src/http/ngx_http.h"
ngx_int_t (*ngx_http_top_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain ) ;
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
static void *ngx_http_copy_filter_create_conf(ngx_conf_t *cf ) ;
#line 34
static char *ngx_http_copy_filter_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 36
static ngx_int_t ngx_http_copy_filter_init(ngx_conf_t *cf ) ;
#line 39 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
static ngx_command_t ngx_http_copy_filter_commands[2]  = {      {{sizeof("output_buffers") - 1UL, (u_char *)"output_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_copy_filter_conf_t *)0)->bufs), (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 52 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
static ngx_http_module_t ngx_http_copy_filter_module_ctx  = 
#line 52
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_copy_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_copy_filter_create_conf,
    & ngx_http_copy_filter_merge_conf};
#line 67 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
ngx_module_t ngx_http_copy_filter_module  = 
#line 67
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_copy_filter_module_ctx),
    ngx_http_copy_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 83 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 86 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
static ngx_int_t ngx_http_copy_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_int_t rc ;
  ngx_connection_t *c ;
  ngx_output_chain_ctx_t *ctx ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_copy_filter_conf_t *conf ;
  void *tmp ;
  int tmp___0 ;
  off_t tmp___1 ;

  {
#line 95
  c = r->connection;
#line 100
  ctx = (ngx_output_chain_ctx_t *)*(r->ctx + ngx_http_copy_filter_module.ctx_index);
#line 102
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 103
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_output_chain_ctx_t ));
#line 103
    ctx = (ngx_output_chain_ctx_t *)tmp;
    }
#line 104
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 105
      return ((ngx_int_t )-1);
    }
#line 108
    *(r->ctx + ngx_http_copy_filter_module.ctx_index) = (void *)ctx;
#line 110
    conf = (ngx_http_copy_filter_conf_t *)*(r->loc_conf + ngx_http_copy_filter_module.ctx_index);
#line 111
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 113
    ctx->sendfile = c->sendfile;
#line 114
    if (r->main_filter_need_in_memory) {
#line 114
      tmp___0 = 1;
    } else
#line 114
    if (r->filter_need_in_memory) {
#line 114
      tmp___0 = 1;
    } else {
#line 114
      tmp___0 = 0;
    }
#line 114
    ctx->need_in_memory = (unsigned int )tmp___0;
#line 116
    ctx->need_in_temp = r->filter_need_temporary;
#line 118
    ctx->alignment = clcf->directio_alignment;
#line 120
    ctx->pool = r->pool;
#line 121
    ctx->bufs = conf->bufs;
#line 122
    ctx->tag = (ngx_buf_tag_t )(& ngx_http_copy_filter_module);
#line 124
    ctx->output_filter = (ngx_int_t (*)(void *ctx , ngx_chain_t *in ))ngx_http_next_body_filter;
#line 126
    ctx->filter_ctx = (void *)r;
#line 143
    if (in) {
#line 143
      if (in->buf) {
#line 143
        if ((in->buf)->temporary) {
#line 143
          tmp___1 = (in->buf)->last - (in->buf)->pos;
        } else
#line 143
        if ((in->buf)->memory) {
#line 143
          tmp___1 = (in->buf)->last - (in->buf)->pos;
        } else
#line 143
        if ((in->buf)->mmap) {
#line 143
          tmp___1 = (in->buf)->last - (in->buf)->pos;
        } else {
#line 143
          tmp___1 = (in->buf)->file_last - (in->buf)->file_pos;
        }
#line 143
        if (tmp___1) {
#line 144
          r->request_output = 1U;
        }
      }
    }
  }
  {
#line 152
  rc = ngx_output_chain(ctx, in);
  }
#line 154
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
#line 155
    r->buffered &= 4294967291U;
  } else {
#line 158
    r->buffered |= 4U;
  }
#line 164
  return (rc);
}
}
#line 344 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
static void *ngx_http_copy_filter_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_copy_filter_conf_t *conf ;
  void *tmp ;

  {
  {
#line 349
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_copy_filter_conf_t ));
#line 349
  conf = (ngx_http_copy_filter_conf_t *)tmp;
  }
#line 350
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 351
    return ((void *)0);
  }
#line 354
  conf->bufs.num = (ngx_int_t )0;
#line 356
  return ((void *)conf);
}
}
#line 360 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
static char *ngx_http_copy_filter_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_copy_filter_conf_t *prev ;
  ngx_http_copy_filter_conf_t *conf ;

  {
#line 363
  prev = (ngx_http_copy_filter_conf_t *)parent;
#line 364
  conf = (ngx_http_copy_filter_conf_t *)child;
#line 366
  if (conf->bufs.num == 0L) {
#line 366
    if (prev->bufs.num) {
#line 366
      conf->bufs.num = prev->bufs.num;
#line 366
      conf->bufs.size = prev->bufs.size;
    } else {
#line 366
      conf->bufs.num = (ngx_int_t )2;
#line 366
      conf->bufs.size = (size_t )32768;
    }
  }
#line 368
  return ((char *)((void *)0));
}
}
#line 372 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_copy_filter_module.c"
static ngx_int_t ngx_http_copy_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 375
  ngx_http_next_body_filter = ngx_http_top_body_filter;
#line 376
  ngx_http_top_body_filter = & ngx_http_copy_filter;
#line 378
  return ((ngx_int_t )0);
}
}
#line 18 "src/core/ngx_parse.h"
ngx_int_t ngx_parse_time(ngx_str_t *line , ngx_uint_t is_sec ) ;
#line 30 "src/core/ngx_times.h"
time_t ngx_next_time(time_t when ) ;
#line 40
ngx_str_t volatile   ngx_cached_http_time ;
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_set_expires(ngx_http_request_t *r , ngx_http_headers_conf_t *conf ) ;
#line 57
static ngx_int_t ngx_http_parse_expires(ngx_str_t *value , ngx_http_expires_t *expires___0 ,
                                        time_t *expires_time , char **err ) ;
#line 59
static ngx_int_t ngx_http_add_cache_control(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                            ngx_str_t *value ) ;
#line 61
static ngx_int_t ngx_http_add_header(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                     ngx_str_t *value ) ;
#line 63
static ngx_int_t ngx_http_set_last_modified(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                            ngx_str_t *value ) ;
#line 65
static ngx_int_t ngx_http_set_response_header(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                              ngx_str_t *value ) ;
#line 68
static void *ngx_http_headers_create_conf(ngx_conf_t *cf ) ;
#line 69
static char *ngx_http_headers_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 71
static ngx_int_t ngx_http_headers_filter_init(ngx_conf_t *cf ) ;
#line 72
static char *ngx_http_headers_expires(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 74
static char *ngx_http_headers_add(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 78 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_http_set_header_t ngx_http_set_headers[4]  = {      {{sizeof("Cache-Control") - 1UL, (u_char *)"Cache-Control"}, (ngx_uint_t )0,
      & ngx_http_add_cache_control}, 
        {{sizeof("Last-Modified") - 1UL, (u_char *)"Last-Modified"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->last_modified),
      & ngx_http_set_last_modified}, 
        {{sizeof("ETag") - 1UL, (u_char *)"ETag"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->etag),
      & ngx_http_set_response_header}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                                          ngx_http_header_val_t *hv ,
                                                                          ngx_str_t *value ))((void *)0)}};
#line 94 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_command_t ngx_http_headers_filter_commands[4]  = {      {{sizeof("expires") - 1UL, (u_char *)"expires"}, (ngx_uint_t )1308622854, & ngx_http_headers_expires,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("add_header") - 1UL,
       (u_char *)"add_header"}, (ngx_uint_t )1308622860, & ngx_http_headers_add, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_headers_conf_t *)0)->headers), (void *)0}, 
        {{sizeof("add_trailer") - 1UL, (u_char *)"add_trailer"}, (ngx_uint_t )1308622860,
      & ngx_http_headers_add, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_headers_conf_t *)0)->trailers), (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 124 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_http_module_t ngx_http_headers_filter_module_ctx  = 
#line 124
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_headers_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_headers_create_conf,
    & ngx_http_headers_merge_conf};
#line 139 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
ngx_module_t ngx_http_headers_filter_module  = 
#line 139
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_headers_filter_module_ctx),
    ngx_http_headers_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 155 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___0)(ngx_http_request_t *r )  ;
#line 156 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___0)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 159 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_headers_filter(ngx_http_request_t *r ) 
{ 
  ngx_str_t value ;
  ngx_uint_t i ;
  ngx_uint_t safe_status ;
  ngx_http_header_val_t *h ;
  ngx_http_headers_conf_t *conf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 167
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 168
    tmp = (*ngx_http_next_header_filter___0)(r);
    }
#line 168
    return (tmp);
  }
#line 171
  conf = (ngx_http_headers_conf_t *)*(r->loc_conf + ngx_http_headers_filter_module.ctx_index);
#line 173
  if ((unsigned int )conf->expires == 0U) {
#line 173
    if ((unsigned long )conf->headers == (unsigned long )((void *)0)) {
#line 173
      if ((unsigned long )conf->trailers == (unsigned long )((void *)0)) {
        {
#line 177
        tmp___0 = (*ngx_http_next_header_filter___0)(r);
        }
#line 177
        return (tmp___0);
      }
    }
  }
  {
#line 191
  if (r->headers_out.status == 308UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 307UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 304UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 303UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 302UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 301UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 206UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 204UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 201UL) {
#line 191
    goto case_308;
  }
#line 191
  if (r->headers_out.status == 200UL) {
#line 191
    goto case_308;
  }
#line 195
  goto switch_default;
  case_308: /* CIL Label */ 
  case_307: /* CIL Label */ 
  case_304: /* CIL Label */ 
  case_303: /* CIL Label */ 
  case_302: /* CIL Label */ 
  case_301: /* CIL Label */ 
  case_206: /* CIL Label */ 
  case_204: /* CIL Label */ 
  case_201: /* CIL Label */ 
  case_200: /* CIL Label */ 
#line 192
  safe_status = (ngx_uint_t )1;
#line 193
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 196
  safe_status = (ngx_uint_t )0;
#line 197
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 200
  if ((unsigned int )conf->expires != 0U) {
#line 200
    if (safe_status) {
      {
#line 201
      tmp___1 = ngx_http_set_expires(r, conf);
      }
#line 201
      if (tmp___1 != 0L) {
#line 202
        return ((ngx_int_t )-1);
      }
    }
  }
#line 206
  if (conf->headers) {
#line 207
    h = (ngx_http_header_val_t *)(conf->headers)->elts;
#line 208
    i = (ngx_uint_t )0;
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 208
      if (! (i < (conf->headers)->nelts)) {
#line 208
        goto while_break;
      }
#line 210
      if (! safe_status) {
#line 210
        if (! (h + i)->always) {
#line 211
          goto __Cont;
        }
      }
      {
#line 214
      tmp___2 = ngx_http_complex_value(r, & (h + i)->value, & value);
      }
#line 214
      if (tmp___2 != 0L) {
#line 215
        return ((ngx_int_t )-1);
      }
      {
#line 218
      tmp___3 = (*((h + i)->handler))(r, h + i, & value);
      }
#line 218
      if (tmp___3 != 0L) {
#line 219
        return ((ngx_int_t )-1);
      }
      __Cont: /* CIL Label */ 
#line 208
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 224
  if (conf->trailers) {
#line 225
    h = (ngx_http_header_val_t *)(conf->trailers)->elts;
#line 226
    i = (ngx_uint_t )0;
    {
#line 226
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 226
      if (! (i < (conf->trailers)->nelts)) {
#line 226
        goto while_break___0;
      }
#line 228
      if (! safe_status) {
#line 228
        if (! (h + i)->always) {
#line 229
          goto __Cont___0;
        }
      }
#line 232
      r->expect_trailers = 1U;
#line 233
      goto while_break___0;
      __Cont___0: /* CIL Label */ 
#line 226
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 237
  tmp___4 = (*ngx_http_next_header_filter___0)(r);
  }
#line 237
  return (tmp___4);
}
}
#line 241 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_trailers_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_str_t value ;
  ngx_uint_t i ;
  ngx_uint_t safe_status ;
  ngx_chain_t *cl ;
  ngx_table_elt_t *t ;
  ngx_http_header_val_t *h ;
  ngx_http_headers_conf_t *conf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 251
  conf = (ngx_http_headers_conf_t *)*(r->loc_conf + ngx_http_headers_filter_module.ctx_index);
#line 253
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 258
    tmp = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 258
    return (tmp);
  } else
#line 253
  if ((unsigned long )conf->trailers == (unsigned long )((void *)0)) {
    {
#line 258
    tmp = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 258
    return (tmp);
  } else
#line 253
  if (! r->expect_trailers) {
    {
#line 258
    tmp = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 258
    return (tmp);
  } else
#line 253
  if (r->header_only) {
    {
#line 258
    tmp = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 258
    return (tmp);
  }
#line 261
  cl = in;
  {
#line 261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 261
    if (! cl) {
#line 261
      goto while_break;
    }
#line 262
    if ((cl->buf)->last_buf) {
#line 263
      goto while_break;
    }
#line 261
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
    {
#line 268
    tmp___0 = (*ngx_http_next_body_filter___0)(r, in);
    }
#line 268
    return (tmp___0);
  }
  {
#line 282
  if (r->headers_out.status == 308UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 307UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 304UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 303UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 302UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 301UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 206UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 204UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 201UL) {
#line 282
    goto case_308;
  }
#line 282
  if (r->headers_out.status == 200UL) {
#line 282
    goto case_308;
  }
#line 286
  goto switch_default;
  case_308: /* CIL Label */ 
  case_307: /* CIL Label */ 
  case_304: /* CIL Label */ 
  case_303: /* CIL Label */ 
  case_302: /* CIL Label */ 
  case_301: /* CIL Label */ 
  case_206: /* CIL Label */ 
  case_204: /* CIL Label */ 
  case_201: /* CIL Label */ 
  case_200: /* CIL Label */ 
#line 283
  safe_status = (ngx_uint_t )1;
#line 284
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 287
  safe_status = (ngx_uint_t )0;
#line 288
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 291
  h = (ngx_http_header_val_t *)(conf->trailers)->elts;
#line 292
  i = (ngx_uint_t )0;
  {
#line 292
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 292
    if (! (i < (conf->trailers)->nelts)) {
#line 292
      goto while_break___0;
    }
#line 294
    if (! safe_status) {
#line 294
      if (! (h + i)->always) {
#line 295
        goto __Cont;
      }
    }
    {
#line 298
    tmp___1 = ngx_http_complex_value(r, & (h + i)->value, & value);
    }
#line 298
    if (tmp___1 != 0L) {
#line 299
      return ((ngx_int_t )-1);
    }
#line 302
    if (value.len) {
      {
#line 303
      tmp___2 = ngx_list_push(& r->headers_out.trailers);
#line 303
      t = (ngx_table_elt_t *)tmp___2;
      }
#line 304
      if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 305
        return ((ngx_int_t )-1);
      }
#line 308
      t->key = (h + i)->key;
#line 309
      t->value = value;
#line 310
      t->hash = (ngx_uint_t )1;
    }
    __Cont: /* CIL Label */ 
#line 292
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 314
  tmp___3 = (*ngx_http_next_body_filter___0)(r, in);
  }
#line 314
  return (tmp___3);
}
}
#line 318 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_set_expires(ngx_http_request_t *r , ngx_http_headers_conf_t *conf ) 
{ 
  char *err ;
  size_t len ;
  time_t now ;
  time_t expires_time ;
  time_t max_age ;
  ngx_str_t value ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_table_elt_t *e ;
  ngx_table_elt_t *cc ;
  ngx_table_elt_t **ccp ;
  ngx_http_expires_t expires___0 ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;

  {
#line 330
  expires___0 = conf->expires;
#line 331
  expires_time = conf->expires_time;
#line 333
  if ((unsigned long )conf->expires_value != (unsigned long )((void *)0)) {
    {
#line 335
    tmp = ngx_http_complex_value(r, conf->expires_value, & value);
    }
#line 335
    if (tmp != 0L) {
#line 336
      return ((ngx_int_t )-1);
    }
    {
#line 339
    rc = ngx_http_parse_expires(& value, & expires___0, & expires_time, & err);
    }
#line 341
    if (rc != 0L) {
#line 342
      return ((ngx_int_t )0);
    }
#line 345
    if ((unsigned int )expires___0 == 0U) {
#line 346
      return ((ngx_int_t )0);
    }
  }
#line 350
  e = r->headers_out.expires;
#line 352
  if ((unsigned long )e == (unsigned long )((void *)0)) {
    {
#line 354
    tmp___0 = ngx_list_push(& r->headers_out.headers);
#line 354
    e = (ngx_table_elt_t *)tmp___0;
    }
#line 355
    if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 356
      return ((ngx_int_t )-1);
    }
#line 359
    r->headers_out.expires = e;
#line 361
    e->hash = (ngx_uint_t )1;
#line 362
    e->key.len = sizeof("Expires") - 1UL;
#line 362
    e->key.data = (u_char *)"Expires";
  }
#line 365
  len = sizeof("Mon, 28 Sep 1970 06:00:00 GMT");
#line 366
  e->value.len = len - 1UL;
#line 368
  ccp = (ngx_table_elt_t **)r->headers_out.cache_control.elts;
#line 370
  if ((unsigned long )ccp == (unsigned long )((void *)0)) {
    {
#line 372
    tmp___1 = ngx_array_init(& r->headers_out.cache_control, r->pool, (ngx_uint_t )1,
                             sizeof(ngx_table_elt_t *));
    }
#line 372
    if (tmp___1 != 0L) {
#line 376
      return ((ngx_int_t )-1);
    }
    {
#line 379
    tmp___2 = ngx_list_push(& r->headers_out.headers);
#line 379
    cc = (ngx_table_elt_t *)tmp___2;
    }
#line 380
    if ((unsigned long )cc == (unsigned long )((void *)0)) {
#line 381
      return ((ngx_int_t )-1);
    }
    {
#line 384
    cc->hash = (ngx_uint_t )1;
#line 385
    cc->key.len = sizeof("Cache-Control") - 1UL;
#line 385
    cc->key.data = (u_char *)"Cache-Control";
#line 387
    tmp___3 = ngx_array_push(& r->headers_out.cache_control);
#line 387
    ccp = (ngx_table_elt_t **)tmp___3;
    }
#line 388
    if ((unsigned long )ccp == (unsigned long )((void *)0)) {
#line 389
      return ((ngx_int_t )-1);
    }
#line 392
    *ccp = cc;
  } else {
#line 395
    i = (ngx_uint_t )1;
    {
#line 395
    while (1) {
      while_continue: /* CIL Label */ ;
#line 395
      if (! (i < r->headers_out.cache_control.nelts)) {
#line 395
        goto while_break;
      }
#line 396
      (*(ccp + i))->hash = (ngx_uint_t )0;
#line 395
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 399
    cc = *(ccp + 0);
  }
#line 402
  if ((unsigned int )expires___0 == 1U) {
#line 403
    e->value.data = (u_char *)"Thu, 01 Jan 1970 00:00:01 GMT";
#line 404
    cc->value.len = sizeof("no-cache") - 1UL;
#line 404
    cc->value.data = (u_char *)"no-cache";
#line 405
    return ((ngx_int_t )0);
  }
#line 408
  if ((unsigned int )expires___0 == 2U) {
#line 409
    e->value.data = (u_char *)"Thu, 31 Dec 2037 23:55:55 GMT";
#line 411
    cc->value.len = sizeof("max-age=315360000") - 1UL;
#line 411
    cc->value.data = (u_char *)"max-age=315360000";
#line 412
    return ((ngx_int_t )0);
  }
  {
#line 415
  tmp___4 = ngx_pnalloc(r->pool, len);
#line 415
  e->value.data = (u_char *)tmp___4;
  }
#line 416
  if ((unsigned long )e->value.data == (unsigned long )((void *)0)) {
#line 417
    return ((ngx_int_t )-1);
  }
#line 420
  if (expires_time == 0L) {
#line 420
    if ((unsigned int )expires___0 != 5U) {
      {
#line 421
      memcpy((void */* __restrict  */)e->value.data, (void const   */* __restrict  */)ngx_cached_http_time.data,
             (size_t )(ngx_cached_http_time.len + (size_t volatile   )1));
#line 423
      cc->value.len = sizeof("max-age=0") - 1UL;
#line 423
      cc->value.data = (u_char *)"max-age=0";
      }
#line 424
      return ((ngx_int_t )0);
    }
  }
#line 427
  now = (time_t )ngx_cached_time->sec;
#line 429
  if ((unsigned int )expires___0 == 5U) {
    {
#line 430
    expires_time = ngx_next_time(expires_time);
#line 431
    max_age = expires_time - now;
    }
  } else
#line 433
  if ((unsigned int )expires___0 == 3U) {
#line 436
    max_age = expires_time;
#line 437
    expires_time += now;
  } else
#line 433
  if (r->headers_out.last_modified_time == -1L) {
#line 436
    max_age = expires_time;
#line 437
    expires_time += now;
  } else {
#line 440
    expires_time += r->headers_out.last_modified_time;
#line 441
    max_age = expires_time - now;
  }
  {
#line 444
  ngx_http_time(e->value.data, expires_time);
  }
#line 446
  if (conf->expires_time < 0L) {
#line 447
    cc->value.len = sizeof("no-cache") - 1UL;
#line 447
    cc->value.data = (u_char *)"no-cache";
#line 448
    return ((ngx_int_t )0);
  } else
#line 446
  if (max_age < 0L) {
#line 447
    cc->value.len = sizeof("no-cache") - 1UL;
#line 447
    cc->value.data = (u_char *)"no-cache";
#line 448
    return ((ngx_int_t )0);
  }
  {
#line 451
  tmp___5 = ngx_pnalloc(r->pool, (sizeof("max-age=") + (sizeof("-9223372036854775808") - 1UL)) + 1UL);
#line 451
  cc->value.data = (u_char *)tmp___5;
  }
#line 453
  if ((unsigned long )cc->value.data == (unsigned long )((void *)0)) {
#line 454
    return ((ngx_int_t )-1);
  }
  {
#line 457
  tmp___6 = ngx_sprintf(cc->value.data, "max-age=%T", max_age);
#line 457
  cc->value.len = (size_t )(tmp___6 - cc->value.data);
  }
#line 460
  return ((ngx_int_t )0);
}
}
#line 464 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_parse_expires(ngx_str_t *value , ngx_http_expires_t *expires___0 ,
                                        time_t *expires_time , char **err ) 
{ 
  ngx_uint_t minus ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 470
  if ((unsigned int )*expires___0 != 4U) {
#line 472
    if (value->len == 5UL) {
      {
#line 472
      tmp = strncmp((char const   *)value->data, "epoch", (size_t )5);
      }
#line 472
      if (tmp == 0) {
#line 473
        *expires___0 = (ngx_http_expires_t )1;
#line 474
        return ((ngx_int_t )0);
      }
    }
#line 477
    if (value->len == 3UL) {
      {
#line 477
      tmp___0 = strncmp((char const   *)value->data, "max", (size_t )3);
      }
#line 477
      if (tmp___0 == 0) {
#line 478
        *expires___0 = (ngx_http_expires_t )2;
#line 479
        return ((ngx_int_t )0);
      }
    }
#line 482
    if (value->len == 3UL) {
      {
#line 482
      tmp___1 = strncmp((char const   *)value->data, "off", (size_t )3);
      }
#line 482
      if (tmp___1 == 0) {
#line 483
        *expires___0 = (ngx_http_expires_t )0;
#line 484
        return ((ngx_int_t )0);
      }
    }
  }
#line 488
  if (value->len) {
#line 488
    if ((int )*(value->data + 0) == 64) {
#line 489
      (value->data) ++;
#line 490
      (value->len) --;
#line 491
      minus = (ngx_uint_t )0;
#line 493
      if ((unsigned int )*expires___0 == 4U) {
#line 494
        *err = (char *)"daily time cannot be used with \"modified\" parameter";
#line 495
        return ((ngx_int_t )-1);
      }
#line 498
      *expires___0 = (ngx_http_expires_t )5;
    } else {
#line 488
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 500
  if (value->len) {
#line 500
    if ((int )*(value->data + 0) == 43) {
#line 501
      (value->data) ++;
#line 502
      (value->len) --;
#line 503
      minus = (ngx_uint_t )0;
    } else {
#line 500
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 505
  if (value->len) {
#line 505
    if ((int )*(value->data + 0) == 45) {
#line 506
      (value->data) ++;
#line 507
      (value->len) --;
#line 508
      minus = (ngx_uint_t )1;
    } else {
#line 511
      minus = (ngx_uint_t )0;
    }
  } else {
#line 511
    minus = (ngx_uint_t )0;
  }
  {
#line 514
  *expires_time = ngx_parse_time(value, (ngx_uint_t )1);
  }
#line 516
  if (*expires_time == -1L) {
#line 517
    *err = (char *)"invalid value";
#line 518
    return ((ngx_int_t )-1);
  }
#line 521
  if ((unsigned int )*expires___0 == 5U) {
#line 521
    if (*expires_time > 86400L) {
#line 524
      *err = (char *)"daily time value must be less than 24 hours";
#line 525
      return ((ngx_int_t )-1);
    }
  }
#line 528
  if (minus) {
#line 529
    *expires_time = - *expires_time;
  }
#line 532
  return ((ngx_int_t )0);
}
}
#line 536 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_add_header(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                     ngx_str_t *value ) 
{ 
  ngx_table_elt_t *h ;
  void *tmp ;

  {
#line 542
  if (value->len) {
    {
#line 543
    tmp = ngx_list_push(& r->headers_out.headers);
#line 543
    h = (ngx_table_elt_t *)tmp;
    }
#line 544
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 545
      return ((ngx_int_t )-1);
    }
#line 548
    h->hash = (ngx_uint_t )1;
#line 549
    h->key = hv->key;
#line 550
    h->value = *value;
  }
#line 553
  return ((ngx_int_t )0);
}
}
#line 557 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_add_cache_control(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                            ngx_str_t *value ) 
{ 
  ngx_table_elt_t *cc ;
  ngx_table_elt_t **ccp ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 563
  if (value->len == 0UL) {
#line 564
    return ((ngx_int_t )0);
  }
#line 567
  ccp = (ngx_table_elt_t **)r->headers_out.cache_control.elts;
#line 569
  if ((unsigned long )ccp == (unsigned long )((void *)0)) {
    {
#line 571
    tmp = ngx_array_init(& r->headers_out.cache_control, r->pool, (ngx_uint_t )1,
                         sizeof(ngx_table_elt_t *));
    }
#line 571
    if (tmp != 0L) {
#line 575
      return ((ngx_int_t )-1);
    }
  }
  {
#line 579
  tmp___0 = ngx_list_push(& r->headers_out.headers);
#line 579
  cc = (ngx_table_elt_t *)tmp___0;
  }
#line 580
  if ((unsigned long )cc == (unsigned long )((void *)0)) {
#line 581
    return ((ngx_int_t )-1);
  }
  {
#line 584
  cc->hash = (ngx_uint_t )1;
#line 585
  cc->key.len = sizeof("Cache-Control") - 1UL;
#line 585
  cc->key.data = (u_char *)"Cache-Control";
#line 586
  cc->value = *value;
#line 588
  tmp___1 = ngx_array_push(& r->headers_out.cache_control);
#line 588
  ccp = (ngx_table_elt_t **)tmp___1;
  }
#line 589
  if ((unsigned long )ccp == (unsigned long )((void *)0)) {
#line 590
    return ((ngx_int_t )-1);
  }
#line 593
  *ccp = cc;
#line 595
  return ((ngx_int_t )0);
}
}
#line 599 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_set_last_modified(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                            ngx_str_t *value ) 
{ 
  ngx_int_t tmp ;
  time_t tmp___0 ;

  {
  {
#line 603
  tmp = ngx_http_set_response_header(r, hv, value);
  }
#line 603
  if (tmp != 0L) {
#line 604
    return ((ngx_int_t )-1);
  }
#line 607
  if (value->len) {
    {
#line 607
    tmp___0 = ngx_parse_http_time(value->data, value->len);
#line 607
    r->headers_out.last_modified_time = tmp___0;
    }
  } else {
#line 607
    r->headers_out.last_modified_time = (time_t )-1;
  }
#line 610
  return ((ngx_int_t )0);
}
}
#line 614 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_set_response_header(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                                              ngx_str_t *value ) 
{ 
  ngx_table_elt_t *h ;
  ngx_table_elt_t **old ;
  void *tmp ;

  {
#line 620
  old = (ngx_table_elt_t **)((char *)(& r->headers_out) + hv->offset);
#line 622
  if (value->len == 0UL) {
#line 623
    if (*old) {
#line 624
      (*old)->hash = (ngx_uint_t )0;
#line 625
      *old = (ngx_table_elt_t *)((void *)0);
    }
#line 628
    return ((ngx_int_t )0);
  }
#line 631
  if (*old) {
#line 632
    h = *old;
  } else {
    {
#line 635
    tmp = ngx_list_push(& r->headers_out.headers);
#line 635
    h = (ngx_table_elt_t *)tmp;
    }
#line 636
    if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 637
      return ((ngx_int_t )-1);
    }
#line 640
    *old = h;
  }
#line 643
  h->hash = (ngx_uint_t )1;
#line 644
  h->key = hv->key;
#line 645
  h->value = *value;
#line 647
  return ((ngx_int_t )0);
}
}
#line 651 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static void *ngx_http_headers_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_headers_conf_t *conf ;
  void *tmp ;

  {
  {
#line 656
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_headers_conf_t ));
#line 656
  conf = (ngx_http_headers_conf_t *)tmp;
  }
#line 657
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 658
    return ((void *)0);
  }
#line 670
  conf->expires = (ngx_http_expires_t )6;
#line 672
  return ((void *)conf);
}
}
#line 676 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static char *ngx_http_headers_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_headers_conf_t *prev ;
  ngx_http_headers_conf_t *conf ;

  {
#line 679
  prev = (ngx_http_headers_conf_t *)parent;
#line 680
  conf = (ngx_http_headers_conf_t *)child;
#line 682
  if ((unsigned int )conf->expires == 6U) {
#line 683
    conf->expires = prev->expires;
#line 684
    conf->expires_time = prev->expires_time;
#line 685
    conf->expires_value = prev->expires_value;
#line 687
    if ((unsigned int )conf->expires == 6U) {
#line 688
      conf->expires = (ngx_http_expires_t )0;
    }
  }
#line 692
  if ((unsigned long )conf->headers == (unsigned long )((void *)0)) {
#line 693
    conf->headers = prev->headers;
  }
#line 696
  if ((unsigned long )conf->trailers == (unsigned long )((void *)0)) {
#line 697
    conf->trailers = prev->trailers;
  }
#line 700
  return ((char *)((void *)0));
}
}
#line 704 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static ngx_int_t ngx_http_headers_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 707
  ngx_http_next_header_filter___0 = ngx_http_top_header_filter;
#line 708
  ngx_http_top_header_filter = & ngx_http_headers_filter;
#line 710
  ngx_http_next_body_filter___0 = ngx_http_top_body_filter;
#line 711
  ngx_http_top_body_filter = & ngx_http_trailers_filter;
#line 713
  return ((ngx_int_t )0);
}
}
#line 717 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static char *ngx_http_headers_expires(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_headers_conf_t *hcf ;
  char *err ;
  ngx_str_t *value ;
  ngx_int_t rc ;
  ngx_uint_t n ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 720
  hcf = (ngx_http_headers_conf_t *)conf;
#line 729
  if ((unsigned int )hcf->expires != 6U) {
#line 730
    return ((char *)"is duplicate");
  }
#line 733
  value = (ngx_str_t *)(cf->args)->elts;
#line 735
  if ((cf->args)->nelts == 2UL) {
#line 737
    hcf->expires = (ngx_http_expires_t )3;
#line 739
    n = (ngx_uint_t )1;
  } else {
    {
#line 743
    tmp = strcmp((char const   *)(value + 1)->data, "modified");
    }
#line 743
    if (tmp != 0) {
#line 744
      return ((char *)"invalid value");
    }
#line 747
    hcf->expires = (ngx_http_expires_t )4;
#line 749
    n = (ngx_uint_t )2;
  }
  {
#line 752
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 754
  ccv.cf = cf;
#line 755
  ccv.value = value + n;
#line 756
  ccv.complex_value = & cv;
#line 758
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 758
  if (tmp___0 != 0L) {
#line 759
    return ((char *)((void *)-1));
  }
#line 762
  if ((unsigned long )cv.lengths != (unsigned long )((void *)0)) {
    {
#line 764
    tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 764
    hcf->expires_value = (ngx_http_complex_value_t *)tmp___1;
    }
#line 766
    if ((unsigned long )hcf->expires_value == (unsigned long )((void *)0)) {
#line 767
      return ((char *)((void *)-1));
    }
#line 770
    *(hcf->expires_value) = cv;
#line 772
    return ((char *)((void *)0));
  }
  {
#line 775
  rc = ngx_http_parse_expires(value + n, & hcf->expires, & hcf->expires_time, & err);
  }
#line 777
  if (rc != 0L) {
#line 778
    return (err);
  }
#line 781
  return ((char *)((void *)0));
}
}
#line 785 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_headers_filter_module.c"
static char *ngx_http_headers_add(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_headers_conf_t *hcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_array_t **headers ;
  ngx_http_header_val_t *hv ;
  ngx_http_set_header_t *set ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp15 ;

  {
#line 788
  hcf = (ngx_http_headers_conf_t *)conf;
#line 797
  value = (ngx_str_t *)(cf->args)->elts;
#line 799
  headers = (ngx_array_t **)((char *)hcf + cmd->offset);
#line 801
  if ((unsigned long )*headers == (unsigned long )((void *)0)) {
    {
#line 802
    *headers = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_header_val_t ));
    }
#line 804
    if ((unsigned long )*headers == (unsigned long )((void *)0)) {
#line 805
      return ((char *)((void *)-1));
    }
  }
  {
#line 809
  tmp = ngx_array_push(*headers);
#line 809
  hv = (ngx_http_header_val_t *)tmp;
  }
#line 810
  if ((unsigned long )hv == (unsigned long )((void *)0)) {
#line 811
    return ((char *)((void *)-1));
  }
#line 814
  hv->key = *(value + 1);
#line 815
  hv->handler = (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_header_val_t *hv ,
                               ngx_str_t *value ))((void *)0);
#line 816
  hv->offset = (ngx_uint_t )0;
#line 817
  hv->always = (ngx_uint_t )0;
#line 819
  if ((unsigned long )headers == (unsigned long )(& hcf->headers)) {
#line 820
    hv->handler = & ngx_http_add_header;
#line 822
    set = ngx_http_set_headers;
#line 823
    i = (ngx_uint_t )0;
    {
#line 823
    while (1) {
      while_continue: /* CIL Label */ ;
#line 823
      if (! (set + i)->name.len) {
#line 823
        goto while_break;
      }
      {
#line 824
      tmp___0 = ngx_strcasecmp((value + 1)->data, (set + i)->name.data);
      }
#line 824
      if (tmp___0 != 0L) {
#line 825
        goto __Cont;
      }
#line 828
      hv->offset = (set + i)->offset;
#line 829
      hv->handler = (set + i)->handler;
#line 831
      goto while_break;
      __Cont: /* CIL Label */ 
#line 823
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 835
  if ((value + 2)->len == 0UL) {
    {
#line 836
    memset((void *)(& hv->value), 0, sizeof(ngx_http_complex_value_t ));
    }
  } else {
    {
#line 839
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 841
    ccv.cf = cf;
#line 842
    ccv.value = value + 2;
#line 843
    ccv.complex_value = & hv->value;
#line 845
    tmp___1 = ngx_http_compile_complex_value(& ccv);
    }
#line 845
    if (tmp___1 != 0L) {
#line 846
      return ((char *)((void *)-1));
    }
  }
#line 850
  if ((cf->args)->nelts == 3UL) {
#line 851
    return ((char *)((void *)0));
  }
  {
#line 854
  tmp___2 = strcmp((char const   *)(value + 3)->data, "always");
  }
#line 854
  if (tmp___2 != 0) {
    {
#line 855
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 3);
    }
#line 857
    return ((char *)((void *)-1));
  }
#line 860
  hv->always = (ngx_uint_t )1;
#line 862
  return ((char *)((void *)0));
}
}
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 187 "src/core/ngx_string.h"
void ngx_encode_base64(ngx_str_t *dst , ngx_str_t *src ) ;
#line 189
ngx_int_t ngx_decode_base64(ngx_str_t *dst , ngx_str_t *src ) ;
#line 82 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_pid ;
#line 27 "src/core/ngx_times.h"
u_char *ngx_http_cookie_time(u_char *buf , time_t t ) ;
#line 215 "src/core/ngx_connection.h"
ngx_int_t ngx_connection_local_sockaddr(ngx_connection_t *c , ngx_str_t *s , ngx_uint_t port ) ;
#line 102 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers , ngx_str_t *name ,
                                            ngx_str_t *value ) ;
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_http_userid_ctx_t *ngx_http_userid_get_uid(ngx_http_request_t *r , ngx_http_userid_conf_t *conf ) ;
#line 48
static ngx_int_t ngx_http_userid_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          ngx_str_t *name , uint32_t *uid ) ;
#line 50
static ngx_int_t ngx_http_userid_set_uid(ngx_http_request_t *r , ngx_http_userid_ctx_t *ctx ,
                                         ngx_http_userid_conf_t *conf ) ;
#line 52
static ngx_int_t ngx_http_userid_create_uid(ngx_http_request_t *r , ngx_http_userid_ctx_t *ctx ,
                                            ngx_http_userid_conf_t *conf ) ;
#line 55
static ngx_int_t ngx_http_userid_add_variables(ngx_conf_t *cf ) ;
#line 56
static ngx_int_t ngx_http_userid_init(ngx_conf_t *cf ) ;
#line 57
static void *ngx_http_userid_create_conf(ngx_conf_t *cf ) ;
#line 58
static char *ngx_http_userid_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 60
static char *ngx_http_userid_domain(ngx_conf_t *cf , void *post , void *data ) ;
#line 61
static char *ngx_http_userid_path(ngx_conf_t *cf , void *post , void *data ) ;
#line 62
static char *ngx_http_userid_expires(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 64
static char *ngx_http_userid_p3p(ngx_conf_t *cf , void *post , void *data ) ;
#line 65
static char *ngx_http_userid_mark(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 67
static ngx_int_t ngx_http_userid_init_worker(ngx_cycle_t *cycle ) ;
#line 71 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static uint32_t start_value  ;
#line 72 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static uint32_t sequencer_v1  =    (uint32_t )1;
#line 73 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static uint32_t sequencer_v2  =    (uint32_t )50529026;
#line 76 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static u_char expires[38]  = 
#line 76
  {      (u_char )';',      (u_char )' ',      (u_char )'e',      (u_char )'x', 
        (u_char )'p',      (u_char )'i',      (u_char )'r',      (u_char )'e', 
        (u_char )'s',      (u_char )'=',      (u_char )'T',      (u_char )'h', 
        (u_char )'u',      (u_char )',',      (u_char )' ',      (u_char )'3', 
        (u_char )'1',      (u_char )'-',      (u_char )'D',      (u_char )'e', 
        (u_char )'c',      (u_char )'-',      (u_char )'3',      (u_char )'7', 
        (u_char )' ',      (u_char )'2',      (u_char )'3',      (u_char )':', 
        (u_char )'5',      (u_char )'5',      (u_char )':',      (u_char )'5', 
        (u_char )'5',      (u_char )' ',      (u_char )'G',      (u_char )'M', 
        (u_char )'T',      (u_char )'\000'};
#line 79 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___1)(ngx_http_request_t *r )  ;
#line 82 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_conf_enum_t ngx_http_userid_state[5]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("log") - 1UL, (u_char *)"log"}, (ngx_uint_t )1}, 
        {{sizeof("v1") - 1UL, (u_char *)"v1"}, (ngx_uint_t )2}, 
        {{sizeof("on") - 1UL, (u_char *)"on"}, (ngx_uint_t )3}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 91 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *(*ngx_http_userid_domain_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_userid_domain;
#line 93 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *(*ngx_http_userid_path_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_userid_path;
#line 94 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *(*ngx_http_userid_p3p_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_userid_p3p;
#line 97 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_command_t ngx_http_userid_commands[9]  = 
#line 97
  {      {{sizeof("userid") - 1UL, (u_char *)"userid"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_userid_conf_t *)0)->enable),
      (void *)(ngx_http_userid_state)}, 
        {{sizeof("userid_service") - 1UL, (u_char *)"userid_service"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_userid_conf_t *)0)->service), (void *)0}, 
        {{sizeof("userid_name") - 1UL, (u_char *)"userid_name"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_userid_conf_t *)0)->name), (void *)0}, 
        {{sizeof("userid_domain") - 1UL, (u_char *)"userid_domain"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_userid_conf_t *)0)->domain), (void *)(& ngx_http_userid_domain_p)}, 
        {{sizeof("userid_path") - 1UL,
       (u_char *)"userid_path"}, (ngx_uint_t )234881026, & ngx_conf_set_str_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_userid_conf_t *)0)->path),
      (void *)(& ngx_http_userid_path_p)}, 
        {{sizeof("userid_expires") - 1UL, (u_char *)"userid_expires"}, (ngx_uint_t )234881026,
      & ngx_http_userid_expires, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("userid_p3p") - 1UL, (u_char *)"userid_p3p"}, (ngx_uint_t )234881026,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_userid_conf_t *)0)->p3p), (void *)(& ngx_http_userid_p3p_p)}, 
        {{sizeof("userid_mark") - 1UL,
       (u_char *)"userid_mark"}, (ngx_uint_t )234881026, & ngx_http_userid_mark, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 159 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_http_module_t ngx_http_userid_filter_module_ctx  = 
#line 159
     {& ngx_http_userid_add_variables, & ngx_http_userid_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_userid_create_conf,
    & ngx_http_userid_merge_conf};
#line 174 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
ngx_module_t ngx_http_userid_filter_module  = 
#line 174
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_userid_filter_module_ctx),
    ngx_http_userid_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), & ngx_http_userid_init_worker,
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 190 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_str_t ngx_http_userid_got  =    {sizeof("uid_got") - 1UL, (u_char *)"uid_got"};
#line 191 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_str_t ngx_http_userid_set  =    {sizeof("uid_set") - 1UL, (u_char *)"uid_set"};
#line 192 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_str_t ngx_http_userid_reset  =    {sizeof("uid_reset") - 1UL, (u_char *)"uid_reset"};
#line 193 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_uint_t ngx_http_userid_reset_index  ;
#line 196 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_filter(ngx_http_request_t *r ) 
{ 
  ngx_http_userid_ctx_t *ctx ;
  ngx_http_userid_conf_t *conf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 202
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 203
    tmp = (*ngx_http_next_header_filter___1)(r);
    }
#line 203
    return (tmp);
  }
#line 206
  conf = (ngx_http_userid_conf_t *)*(r->loc_conf + ngx_http_userid_filter_module.ctx_index);
#line 208
  if (conf->enable < 2UL) {
    {
#line 209
    tmp___0 = (*ngx_http_next_header_filter___1)(r);
    }
#line 209
    return (tmp___0);
  }
  {
#line 212
  ctx = ngx_http_userid_get_uid(r, conf);
  }
#line 214
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 215
    return ((ngx_int_t )-1);
  }
  {
#line 218
  tmp___2 = ngx_http_userid_set_uid(r, ctx, conf);
  }
#line 218
  if (tmp___2 == 0L) {
    {
#line 219
    tmp___1 = (*ngx_http_next_header_filter___1)(r);
    }
#line 219
    return (tmp___1);
  }
#line 222
  return ((ngx_int_t )-1);
}
}
#line 226 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_got_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_http_userid_ctx_t *ctx ;
  ngx_http_userid_conf_t *conf ;
  ngx_int_t tmp ;

  {
#line 233
  conf = (ngx_http_userid_conf_t *)*((r->main)->loc_conf + ngx_http_userid_filter_module.ctx_index);
#line 235
  if (conf->enable == 0UL) {
#line 236
    v->not_found = 1U;
#line 237
    return ((ngx_int_t )0);
  }
  {
#line 240
  ctx = ngx_http_userid_get_uid(r->main, conf);
  }
#line 242
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 243
    return ((ngx_int_t )-1);
  }
#line 246
  if (ctx->uid_got[3] != 0U) {
    {
#line 247
    tmp = ngx_http_userid_variable(r->main, v, & conf->name, ctx->uid_got);
    }
#line 247
    return (tmp);
  }
#line 250
  v->not_found = 1U;
#line 252
  return ((ngx_int_t )0);
}
}
#line 256 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_set_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_http_userid_ctx_t *ctx ;
  ngx_http_userid_conf_t *conf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 263
  conf = (ngx_http_userid_conf_t *)*((r->main)->loc_conf + ngx_http_userid_filter_module.ctx_index);
#line 265
  if (conf->enable < 2UL) {
#line 266
    v->not_found = 1U;
#line 267
    return ((ngx_int_t )0);
  }
  {
#line 270
  ctx = ngx_http_userid_get_uid(r->main, conf);
  }
#line 272
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 273
    return ((ngx_int_t )-1);
  }
  {
#line 276
  tmp = ngx_http_userid_create_uid(r->main, ctx, conf);
  }
#line 276
  if (tmp != 0L) {
#line 277
    return ((ngx_int_t )-1);
  }
#line 280
  if (ctx->uid_set[3] == 0U) {
#line 281
    v->not_found = 1U;
#line 282
    return ((ngx_int_t )0);
  }
  {
#line 285
  tmp___0 = ngx_http_userid_variable(r->main, v, & conf->name, ctx->uid_set);
  }
#line 285
  return (tmp___0);
}
}
#line 289 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_http_userid_ctx_t *ngx_http_userid_get_uid(ngx_http_request_t *r , ngx_http_userid_conf_t *conf ) 
{ 
  ngx_int_t n ;
  ngx_str_t src ;
  ngx_str_t dst ;
  ngx_table_elt_t **cookies ;
  ngx_http_userid_ctx_t *ctx ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 297
  ctx = (ngx_http_userid_ctx_t *)*(r->ctx + ngx_http_userid_filter_module.ctx_index);
#line 299
  if (ctx) {
#line 300
    return (ctx);
  }
#line 303
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 304
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_userid_ctx_t ));
#line 304
    ctx = (ngx_http_userid_ctx_t *)tmp;
    }
#line 305
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 306
      return ((ngx_http_userid_ctx_t *)((void *)0));
    }
#line 309
    *(r->ctx + ngx_http_userid_filter_module.ctx_index) = (void *)ctx;
  }
  {
#line 312
  n = ngx_http_parse_multi_header_lines(& r->headers_in.cookies, & conf->name, & ctx->cookie);
  }
#line 314
  if (n == -5L) {
#line 315
    return (ctx);
  }
#line 321
  if (ctx->cookie.len < 22UL) {
#line 322
    cookies = (ngx_table_elt_t **)r->headers_in.cookies.elts;
#line 323
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 323
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client sent too short userid cookie \"%V\"",
                         & (*(cookies + n))->value);
      }
    }
#line 326
    return (ctx);
  }
  {
#line 329
  src = ctx->cookie;
#line 338
  src.len = (size_t )22;
#line 340
  dst.data = (u_char *)(ctx->uid_got);
#line 342
  tmp___0 = ngx_decode_base64(& dst, & src);
  }
#line 342
  if (tmp___0 == -1L) {
#line 343
    cookies = (ngx_table_elt_t **)r->headers_in.cookies.elts;
#line 344
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 344
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client sent invalid userid cookie \"%V\"",
                         & (*(cookies + n))->value);
      }
    }
#line 347
    return (ctx);
  }
#line 355
  return (ctx);
}
}
#line 359 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_set_uid(ngx_http_request_t *r , ngx_http_userid_ctx_t *ctx ,
                                         ngx_http_userid_conf_t *conf ) 
{ 
  u_char *cookie ;
  u_char *p ;
  size_t len ;
  ngx_str_t src ;
  ngx_str_t dst ;
  ngx_table_elt_t *set_cookie ;
  ngx_table_elt_t *p3p ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 368
  tmp = ngx_http_userid_create_uid(r, ctx, conf);
  }
#line 368
  if (tmp != 0L) {
#line 369
    return ((ngx_int_t )-1);
  }
#line 372
  if (ctx->uid_set[3] == 0U) {
#line 373
    return ((ngx_int_t )0);
  }
#line 376
  len = ((conf->name.len + 1UL) + 24UL) + conf->path.len;
#line 378
  if (conf->expires) {
#line 379
    len += (sizeof(expires) - 1UL) + 2UL;
  }
#line 382
  if (conf->domain.len) {
#line 383
    len += conf->domain.len;
  }
  {
#line 386
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 386
  cookie = (u_char *)tmp___0;
  }
#line 387
  if ((unsigned long )cookie == (unsigned long )((void *)0)) {
#line 388
    return ((ngx_int_t )-1);
  }
  {
#line 391
  tmp___1 = memcpy((void */* __restrict  */)cookie, (void const   */* __restrict  */)conf->name.data,
                   conf->name.len);
#line 391
  p = (u_char *)tmp___1 + conf->name.len;
#line 392
  tmp___2 = p;
#line 392
  p ++;
#line 392
  *tmp___2 = (u_char )'=';
  }
#line 394
  if (ctx->uid_got[3] == 0U) {
#line 394
    goto _L;
  } else
#line 394
  if (ctx->reset) {
    _L: /* CIL Label */ 
    {
#line 395
    src.len = (size_t )16;
#line 396
    src.data = (u_char *)(ctx->uid_set);
#line 397
    dst.data = p;
#line 399
    ngx_encode_base64(& dst, & src);
#line 401
    p += dst.len;
    }
#line 403
    if (conf->mark) {
#line 404
      *(p - 2) = conf->mark;
    }
  } else {
    {
#line 408
    tmp___3 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ctx->cookie.data,
                     (size_t )22);
#line 408
    p = (u_char *)tmp___3 + 22;
#line 409
    tmp___4 = p;
#line 409
    p ++;
#line 409
    *tmp___4 = conf->mark;
#line 410
    tmp___5 = p;
#line 410
    p ++;
#line 410
    *tmp___5 = (u_char )'=';
    }
  }
#line 413
  if (conf->expires == 2145916555L) {
    {
#line 414
    tmp___6 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(expires),
                     sizeof(expires) - 1UL);
#line 414
    p = (u_char *)tmp___6 + (sizeof(expires) - 1UL);
    }
  } else
#line 416
  if (conf->expires) {
    {
#line 417
    tmp___7 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(expires),
                     sizeof("; expires=") - 1UL);
#line 417
    p = (u_char *)tmp___7 + (sizeof("; expires=") - 1UL);
#line 418
    p = ngx_http_cookie_time(p, (time_t )(ngx_cached_time->sec + (time_t volatile   )conf->expires));
    }
  }
  {
#line 421
  tmp___8 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)conf->domain.data,
                   conf->domain.len);
#line 421
  p = (u_char *)tmp___8 + conf->domain.len;
#line 423
  tmp___9 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)conf->path.data,
                   conf->path.len);
#line 423
  p = (u_char *)tmp___9 + conf->path.len;
#line 425
  tmp___10 = ngx_list_push(& r->headers_out.headers);
#line 425
  set_cookie = (ngx_table_elt_t *)tmp___10;
  }
#line 426
  if ((unsigned long )set_cookie == (unsigned long )((void *)0)) {
#line 427
    return ((ngx_int_t )-1);
  }
#line 430
  set_cookie->hash = (ngx_uint_t )1;
#line 431
  set_cookie->key.len = sizeof("Set-Cookie") - 1UL;
#line 431
  set_cookie->key.data = (u_char *)"Set-Cookie";
#line 432
  set_cookie->value.len = (size_t )(p - cookie);
#line 433
  set_cookie->value.data = cookie;
#line 438
  if (conf->p3p.len == 0UL) {
#line 439
    return ((ngx_int_t )0);
  }
  {
#line 442
  tmp___11 = ngx_list_push(& r->headers_out.headers);
#line 442
  p3p = (ngx_table_elt_t *)tmp___11;
  }
#line 443
  if ((unsigned long )p3p == (unsigned long )((void *)0)) {
#line 444
    return ((ngx_int_t )-1);
  }
#line 447
  p3p->hash = (ngx_uint_t )1;
#line 448
  p3p->key.len = sizeof("P3P") - 1UL;
#line 448
  p3p->key.data = (u_char *)"P3P";
#line 449
  p3p->value = conf->p3p;
#line 451
  return ((ngx_int_t )0);
}
}
#line 455 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_create_uid(ngx_http_request_t *r , ngx_http_userid_ctx_t *ctx ,
                                            ngx_http_userid_conf_t *conf ) 
{ 
  ngx_connection_t *c ;
  struct sockaddr_in *sin ;
  ngx_http_variable_value_t *vv ;
  u_char *p ;
  struct sockaddr_in6 *sin6 ;
  int tmp ;
  ngx_int_t tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  char *__cil_tmp14 ;

  {
#line 467
  if (ctx->uid_set[3] != 0U) {
#line 468
    return ((ngx_int_t )0);
  }
#line 471
  if (ctx->uid_got[3] != 0U) {
    {
#line 473
    vv = ngx_http_get_indexed_variable(r, ngx_http_userid_reset_index);
    }
#line 475
    if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 476
      return ((ngx_int_t )-1);
    } else
#line 475
    if (vv->not_found) {
#line 476
      return ((ngx_int_t )-1);
    }
#line 479
    if (vv->len == 0U) {
#line 479
      goto _L;
    } else
#line 479
    if (vv->len == 1U) {
#line 479
      if ((int )*(vv->data + 0) == 48) {
        _L: /* CIL Label */ 
#line 481
        if ((int )conf->mark == 0) {
#line 486
          return ((ngx_int_t )0);
        } else
#line 481
        if (ctx->cookie.len > 23UL) {
#line 481
          if ((int )*(ctx->cookie.data + 22) == (int )conf->mark) {
#line 481
            if ((int )*(ctx->cookie.data + 23) == 61) {
#line 486
              return ((ngx_int_t )0);
            }
          }
        }
#line 489
        ctx->uid_set[0] = ctx->uid_got[0];
#line 490
        ctx->uid_set[1] = ctx->uid_got[1];
#line 491
        ctx->uid_set[2] = ctx->uid_got[2];
#line 492
        ctx->uid_set[3] = ctx->uid_got[3];
#line 494
        return ((ngx_int_t )0);
      } else {
#line 479
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
#line 497
      ctx->reset = (ngx_uint_t )1;
#line 499
      if (vv->len == 3U) {
        {
#line 499
        tmp = strncmp((char const   *)vv->data, "log", (size_t )3);
        }
#line 499
        if (tmp == 0) {
#line 500
          if (((r->connection)->log)->log_level >= 6UL) {
            {
#line 500
            ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "userid cookie \"%V=%08XD%08XD%08XD%08XD\" was reset",
                               & conf->name, ctx->uid_got[0], ctx->uid_got[1], ctx->uid_got[2],
                               ctx->uid_got[3]);
            }
          }
        }
      }
    }
  }
#line 513
  if (conf->enable == 2UL) {
#line 514
    if (conf->service == -1L) {
#line 515
      ctx->uid_set[0] = (uint32_t )0;
    } else {
#line 517
      ctx->uid_set[0] = (uint32_t )conf->service;
    }
#line 519
    ctx->uid_set[1] = (uint32_t )ngx_cached_time->sec;
#line 520
    ctx->uid_set[2] = start_value;
#line 521
    ctx->uid_set[3] = sequencer_v1;
#line 522
    sequencer_v1 += 256U;
  } else {
#line 525
    if (conf->service == -1L) {
      {
#line 527
      c = r->connection;
#line 529
      tmp___0 = ngx_connection_local_sockaddr(c, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
      }
#line 529
      if (tmp___0 != 0L) {
#line 530
        return ((ngx_int_t )-1);
      }
      {
#line 536
      if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 536
        goto case_10;
      }
#line 548
      goto switch_default;
      case_10: /* CIL Label */ 
#line 537
      sin6 = (struct sockaddr_in6 *)c->local_sockaddr;
#line 539
      p = (u_char *)(& ctx->uid_set[0]);
#line 541
      tmp___1 = p;
#line 541
      p ++;
#line 541
      *tmp___1 = sin6->sin6_addr.__in6_u.__u6_addr8[12];
#line 542
      tmp___2 = p;
#line 542
      p ++;
#line 542
      *tmp___2 = sin6->sin6_addr.__in6_u.__u6_addr8[13];
#line 543
      tmp___3 = p;
#line 543
      p ++;
#line 543
      *tmp___3 = sin6->sin6_addr.__in6_u.__u6_addr8[14];
#line 544
      *p = sin6->sin6_addr.__in6_u.__u6_addr8[15];
#line 546
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 549
      sin = (struct sockaddr_in *)c->local_sockaddr;
#line 550
      ctx->uid_set[0] = sin->sin_addr.s_addr;
#line 551
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 555
      ctx->uid_set[0] = htonl((uint32_t )conf->service);
      }
    }
    {
#line 558
    ctx->uid_set[1] = htonl((uint32_t )ngx_cached_time->sec);
#line 559
    ctx->uid_set[2] = htonl(start_value);
#line 560
    ctx->uid_set[3] = htonl(sequencer_v2);
#line 561
    sequencer_v2 += 256U;
    }
#line 562
    if (sequencer_v2 < 50529026U) {
#line 563
      sequencer_v2 = (uint32_t )50529026;
    }
  }
#line 567
  return ((ngx_int_t )0);
}
}
#line 571 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          ngx_str_t *name , uint32_t *uid ) 
{ 
  void *tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 575
  v->len = (unsigned int )((name->len + sizeof("=00001111222233334444555566667777")) - 1UL);
#line 576
  tmp = ngx_pnalloc(r->pool, (size_t )v->len);
#line 576
  v->data = (u_char *)tmp;
  }
#line 577
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 578
    return ((ngx_int_t )-1);
  }
  {
#line 581
  v->valid = 1U;
#line 582
  v->no_cacheable = 0U;
#line 583
  v->not_found = 0U;
#line 585
  ngx_sprintf(v->data, "%V=%08XD%08XD%08XD%08XD", name, *(uid + 0), *(uid + 1), *(uid + 2),
              *(uid + 3));
  }
#line 588
  return ((ngx_int_t )0);
}
}
#line 592 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_reset_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 


  {
#line 596
  *v = ngx_http_variable_null_value;
#line 598
  return ((ngx_int_t )0);
}
}
#line 602 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_int_t n ;
  ngx_http_variable_t *var ;

  {
  {
#line 608
  var = ngx_http_add_variable(cf, & ngx_http_userid_got, (ngx_uint_t )0);
  }
#line 609
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 610
    return ((ngx_int_t )-1);
  }
  {
#line 613
  var->get_handler = & ngx_http_userid_got_variable;
#line 615
  var = ngx_http_add_variable(cf, & ngx_http_userid_set, (ngx_uint_t )0);
  }
#line 616
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 617
    return ((ngx_int_t )-1);
  }
  {
#line 620
  var->get_handler = & ngx_http_userid_set_variable;
#line 622
  var = ngx_http_add_variable(cf, & ngx_http_userid_reset, (ngx_uint_t )1);
  }
#line 624
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 625
    return ((ngx_int_t )-1);
  }
  {
#line 628
  var->get_handler = & ngx_http_userid_reset_variable;
#line 630
  n = ngx_http_get_variable_index(cf, & ngx_http_userid_reset);
  }
#line 631
  if (n == -1L) {
#line 632
    return ((ngx_int_t )-1);
  }
#line 635
  ngx_http_userid_reset_index = (ngx_uint_t )n;
#line 637
  return ((ngx_int_t )0);
}
}
#line 641 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static void *ngx_http_userid_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_userid_conf_t *conf ;
  void *tmp ;

  {
  {
#line 646
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_userid_conf_t ));
#line 646
  conf = (ngx_http_userid_conf_t *)tmp;
  }
#line 647
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 648
    return ((void *)0);
  }
#line 660
  conf->enable = (ngx_uint_t )-1;
#line 661
  conf->service = (ngx_int_t )-1;
#line 662
  conf->expires = (time_t )-1;
#line 663
  conf->mark = (u_char )'\377';
#line 665
  return ((void *)conf);
}
}
#line 669 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_userid_conf_t *prev ;
  ngx_http_userid_conf_t *conf ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 672
  prev = (ngx_http_userid_conf_t *)parent;
#line 673
  conf = (ngx_http_userid_conf_t *)child;
#line 675
  if (conf->enable == 0xffffffffffffffffUL) {
#line 675
    if (prev->enable == 0xffffffffffffffffUL) {
#line 675
      conf->enable = (ngx_uint_t )0;
    } else {
#line 675
      conf->enable = prev->enable;
    }
  }
#line 678
  if ((unsigned long )conf->name.data == (unsigned long )((void *)0)) {
#line 678
    if (prev->name.data) {
#line 678
      conf->name.len = prev->name.len;
#line 678
      conf->name.data = prev->name.data;
    } else {
#line 678
      conf->name.len = sizeof("uid") - 1UL;
#line 678
      conf->name.data = (u_char *)"uid";
    }
  }
#line 679
  if ((unsigned long )conf->domain.data == (unsigned long )((void *)0)) {
#line 679
    if (prev->domain.data) {
#line 679
      conf->domain.len = prev->domain.len;
#line 679
      conf->domain.data = prev->domain.data;
    } else {
#line 679
      conf->domain.len = sizeof("") - 1UL;
#line 679
      conf->domain.data = (u_char *)"";
    }
  }
#line 680
  if ((unsigned long )conf->path.data == (unsigned long )((void *)0)) {
#line 680
    if (prev->path.data) {
#line 680
      conf->path.len = prev->path.len;
#line 680
      conf->path.data = prev->path.data;
    } else {
#line 680
      conf->path.len = sizeof("; path=/") - 1UL;
#line 680
      conf->path.data = (u_char *)"; path=/";
    }
  }
#line 681
  if ((unsigned long )conf->p3p.data == (unsigned long )((void *)0)) {
#line 681
    if (prev->p3p.data) {
#line 681
      conf->p3p.len = prev->p3p.len;
#line 681
      conf->p3p.data = prev->p3p.data;
    } else {
#line 681
      conf->p3p.len = sizeof("") - 1UL;
#line 681
      conf->p3p.data = (u_char *)"";
    }
  }
#line 683
  if (conf->service == -1L) {
#line 683
    if (prev->service == -1L) {
#line 683
      conf->service = (ngx_int_t )-1;
    } else {
#line 683
      conf->service = prev->service;
    }
  }
#line 684
  if (conf->expires == -1L) {
#line 684
    if (prev->expires == -1L) {
#line 684
      conf->expires = (time_t )0;
    } else {
#line 684
      conf->expires = prev->expires;
    }
  }
#line 686
  if ((int )conf->mark == 255) {
#line 687
    if ((int )prev->mark == 255) {
#line 688
      conf->mark = (u_char )'\000';
    } else {
#line 690
      conf->mark = prev->mark;
    }
  }
#line 694
  return ((char *)((void *)0));
}
}
#line 698 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_init(ngx_conf_t *cf ) 
{ 


  {
#line 701
  ngx_http_next_header_filter___1 = ngx_http_top_header_filter;
#line 702
  ngx_http_top_header_filter = & ngx_http_userid_filter;
#line 704
  return ((ngx_int_t )0);
}
}
#line 708 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_domain(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_str_t *domain ;
  u_char *p ;
  u_char *new ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 711
  domain = (ngx_str_t *)data;
#line 715
  tmp = strcmp((char const   *)domain->data, "none");
  }
#line 715
  if (tmp == 0) {
#line 716
    domain->len = sizeof("") - 1UL;
#line 716
    domain->data = (u_char *)"";
#line 717
    return ((char *)((void *)0));
  }
  {
#line 720
  tmp___0 = ngx_pnalloc(cf->pool, (sizeof("; domain=") - 1UL) + domain->len);
#line 720
  new = (u_char *)tmp___0;
  }
#line 721
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 722
    return ((char *)((void *)-1));
  }
  {
#line 725
  tmp___1 = memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)"; domain=",
                   sizeof("; domain=") - 1UL);
#line 725
  p = (u_char *)tmp___1 + (sizeof("; domain=") - 1UL);
#line 726
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)domain->data,
         domain->len);
#line 728
  domain->len += sizeof("; domain=") - 1UL;
#line 729
  domain->data = new;
  }
#line 731
  return ((char *)((void *)0));
}
}
#line 735 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_path(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_str_t *path ;
  u_char *p ;
  u_char *new ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 738
  path = (ngx_str_t *)data;
#line 742
  tmp = ngx_pnalloc(cf->pool, (sizeof("; path=") - 1UL) + path->len);
#line 742
  new = (u_char *)tmp;
  }
#line 743
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 744
    return ((char *)((void *)-1));
  }
  {
#line 747
  tmp___0 = memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)"; path=",
                   sizeof("; path=") - 1UL);
#line 747
  p = (u_char *)tmp___0 + (sizeof("; path=") - 1UL);
#line 748
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)path->data,
         path->len);
#line 750
  path->len += sizeof("; path=") - 1UL;
#line 751
  path->data = new;
  }
#line 753
  return ((char *)((void *)0));
}
}
#line 757 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_expires(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_userid_conf_t *ucf ;
  ngx_str_t *value ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 760
  ucf = (ngx_http_userid_conf_t *)conf;
#line 764
  if (ucf->expires != -1L) {
#line 765
    return ((char *)"is duplicate");
  }
  {
#line 768
  value = (ngx_str_t *)(cf->args)->elts;
#line 770
  tmp = strcmp((char const   *)(value + 1)->data, "max");
  }
#line 770
  if (tmp == 0) {
#line 771
    ucf->expires = (time_t )2145916555;
#line 772
    return ((char *)((void *)0));
  }
  {
#line 775
  tmp___0 = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 775
  if (tmp___0 == 0) {
#line 776
    ucf->expires = (time_t )0;
#line 777
    return ((char *)((void *)0));
  }
  {
#line 780
  ucf->expires = ngx_parse_time(value + 1, (ngx_uint_t )1);
  }
#line 781
  if (ucf->expires == -1L) {
#line 782
    return ((char *)"invalid value");
  }
#line 785
  return ((char *)((void *)0));
}
}
#line 789 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_p3p(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_str_t *p3p ;
  int tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 792
  p3p = (ngx_str_t *)data;
#line 794
  tmp = strcmp((char const   *)p3p->data, "none");
  }
#line 794
  if (tmp == 0) {
#line 795
    p3p->len = sizeof("") - 1UL;
#line 795
    p3p->data = (u_char *)"";
  }
#line 798
  return ((char *)((void *)0));
}
}
#line 802 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static char *ngx_http_userid_mark(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_userid_conf_t *ucf ;
  ngx_str_t *value ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 805
  ucf = (ngx_http_userid_conf_t *)conf;
#line 809
  if ((int )ucf->mark != 255) {
#line 810
    return ((char *)"is duplicate");
  }
  {
#line 813
  value = (ngx_str_t *)(cf->args)->elts;
#line 815
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 815
  if (tmp == 0) {
#line 816
    ucf->mark = (u_char )'\000';
#line 817
    return ((char *)((void *)0));
  }
#line 820
  if ((value + 1)->len != 1UL) {
#line 826
    return ((char *)"value must be \"off\" or a single letter, digit or \"=\"");
  } else
#line 820
  if ((int )*((value + 1)->data + 0) >= 48) {
#line 820
    if (! ((int )*((value + 1)->data + 0) <= 57)) {
#line 820
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 820
  if ((int )*((value + 1)->data + 0) >= 65) {
#line 820
    if (! ((int )*((value + 1)->data + 0) <= 90)) {
#line 820
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 820
  if ((int )*((value + 1)->data + 0) >= 97) {
#line 820
    if (! ((int )*((value + 1)->data + 0) <= 122)) {
#line 820
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 820
  if (! ((int )*((value + 1)->data + 0) == 61)) {
#line 826
    return ((char *)"value must be \"off\" or a single letter, digit or \"=\"");
  }
#line 829
  ucf->mark = *((value + 1)->data + 0);
#line 831
  return ((char *)((void *)0));
}
}
#line 835 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_userid_filter_module.c"
static ngx_int_t ngx_http_userid_init_worker(ngx_cycle_t *cycle ) 
{ 
  struct timeval tp ;

  {
  {
#line 840
  gettimeofday((struct timeval */* __restrict  */)(& tp), (__timezone_ptr_t )((void *)0));
#line 843
  start_value = ((uint32_t )tp.tv_usec / 20U << 16) | (unsigned int )ngx_pid;
  }
#line 845
  return ((ngx_int_t )0);
}
}
#line 179 "src/core/ngx_string.h"
ngx_int_t ngx_hextoi(u_char *line , size_t n ) ;
#line 192
uint32_t ngx_utf8_decode(u_char **p , size_t n ) ;
#line 481 "src/http/ngx_http_core_module.h"
void *ngx_http_test_content_type(ngx_http_request_t *r , ngx_hash_t *types_hash ) ;
#line 154 "src/http/ngx_http.h"
char *ngx_http_types_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 155
char *ngx_http_merge_types(ngx_conf_t *cf , ngx_array_t **keys , ngx_hash_t *types_hash ,
                           ngx_array_t **prev_keys , ngx_hash_t *prev_types_hash ,
                           ngx_str_t *default_types ) ;
#line 88 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_destination_charset(ngx_http_request_t *r , ngx_str_t *name ) ;
#line 90
static ngx_int_t ngx_http_main_request_charset(ngx_http_request_t *r , ngx_str_t *src ) ;
#line 92
static ngx_int_t ngx_http_source_charset(ngx_http_request_t *r , ngx_str_t *name ) ;
#line 94
static ngx_int_t ngx_http_get_charset(ngx_http_request_t *r , ngx_str_t *name ) ;
#line 95
__inline static void ngx_http_set_charset(ngx_http_request_t *r , ngx_str_t *charset ) ;
#line 97
static ngx_int_t ngx_http_charset_ctx(ngx_http_request_t *r , ngx_http_charset_t *charsets ,
                                      ngx_int_t charset , ngx_int_t source_charset ) ;
#line 99
static ngx_uint_t ngx_http_charset_recode(ngx_buf_t *b , u_char *table ) ;
#line 100
static ngx_chain_t *ngx_http_charset_recode_from_utf8(ngx_pool_t *pool , ngx_buf_t *buf ,
                                                      ngx_http_charset_ctx_t *ctx ) ;
#line 102
static ngx_chain_t *ngx_http_charset_recode_to_utf8(ngx_pool_t *pool , ngx_buf_t *buf ,
                                                    ngx_http_charset_ctx_t *ctx ) ;
#line 105
static ngx_chain_t *ngx_http_charset_get_buf(ngx_pool_t *pool , ngx_http_charset_ctx_t *ctx ) ;
#line 107
static ngx_chain_t *ngx_http_charset_get_buffer(ngx_pool_t *pool , ngx_http_charset_ctx_t *ctx ,
                                                size_t size ) ;
#line 110
static char *ngx_http_charset_map_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 112
static char *ngx_http_charset_map(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 115
static char *ngx_http_set_charset_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 117
static ngx_int_t ngx_http_add_charset(ngx_array_t *charsets , ngx_str_t *name ) ;
#line 119
static void *ngx_http_charset_create_main_conf(ngx_conf_t *cf ) ;
#line 120
static void *ngx_http_charset_create_loc_conf(ngx_conf_t *cf ) ;
#line 121
static char *ngx_http_charset_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 123
static ngx_int_t ngx_http_charset_postconfiguration(ngx_conf_t *cf ) ;
#line 126 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_str_t ngx_http_charset_default_types[7]  = {      {sizeof("text/html") - 1UL, (u_char *)"text/html"}, 
        {sizeof("text/xml") - 1UL, (u_char *)"text/xml"}, 
        {sizeof("text/plain") - 1UL, (u_char *)"text/plain"}, 
        {sizeof("text/vnd.wap.wml") - 1UL, (u_char *)"text/vnd.wap.wml"}, 
        {sizeof("application/javascript") - 1UL, (u_char *)"application/javascript"}, 
        {sizeof("application/rss+xml") - 1UL,
      (u_char *)"application/rss+xml"}, 
        {(size_t )0, (u_char *)((void *)0)}};
#line 137 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_command_t ngx_http_charset_filter_commands[6]  = {      {{sizeof("charset") - 1UL, (u_char *)"charset"}, (ngx_uint_t )1308622850, & ngx_http_set_charset_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->charset),
      (void *)0}, 
        {{sizeof("source_charset") - 1UL, (u_char *)"source_charset"}, (ngx_uint_t )1308622850,
      & ngx_http_set_charset_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->source_charset), (void *)0}, 
        {{sizeof("override_charset") - 1UL,
       (u_char *)"override_charset"}, (ngx_uint_t )1308623360, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->override_charset),
      (void *)0}, 
        {{sizeof("charset_types") - 1UL, (u_char *)"charset_types"}, (ngx_uint_t )234883072,
      & ngx_http_types_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->types_keys), (void *)(& ngx_http_charset_default_types[0])}, 
        {{sizeof("charset_map") - 1UL,
       (u_char *)"charset_map"}, (ngx_uint_t )33554692, & ngx_http_charset_map_block,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 181 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_http_module_t ngx_http_charset_filter_module_ctx  = 
#line 181
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_charset_postconfiguration,
    & ngx_http_charset_create_main_conf, (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    & ngx_http_charset_create_loc_conf, & ngx_http_charset_merge_loc_conf};
#line 196 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
ngx_module_t ngx_http_charset_filter_module  = 
#line 196
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_charset_filter_module_ctx),
    ngx_http_charset_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 212 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___2)(ngx_http_request_t *r )  ;
#line 213 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___1)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 216 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_charset_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_int_t charset ;
  ngx_int_t source_charset ;
  ngx_str_t dst ;
  ngx_str_t src ;
  ngx_http_charset_t *charsets ;
  ngx_http_charset_main_conf_t *mcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  char *__cil_tmp16 ;

  {
#line 224
  if ((unsigned long )r == (unsigned long )r->main) {
    {
#line 225
    charset = ngx_http_destination_charset(r, & dst);
    }
  } else {
    {
#line 228
    charset = ngx_http_main_request_charset(r, & dst);
    }
  }
#line 231
  if (charset == -1L) {
#line 232
    return ((ngx_int_t )-1);
  }
#line 235
  if (charset == -5L) {
    {
#line 236
    tmp = (*ngx_http_next_header_filter___2)(r);
    }
#line 236
    return (tmp);
  }
  {
#line 241
  source_charset = ngx_http_source_charset(r, & src);
  }
#line 243
  if (source_charset == -1L) {
#line 244
    return ((ngx_int_t )-1);
  }
#line 255
  if (source_charset == -2L) {
    {
#line 256
    ngx_http_set_charset(r, & dst);
#line 258
    tmp___0 = (*ngx_http_next_header_filter___2)(r);
    }
#line 258
    return (tmp___0);
  }
#line 261
  if (charset == -3L) {
#line 261
    goto _L;
  } else
#line 261
  if (source_charset == -3L) {
    _L: /* CIL Label */ 
#line 264
    if (source_charset != charset) {
#line 267
      goto no_charset_map;
    } else {
      {
#line 264
      tmp___1 = ngx_strncasecmp(dst.data, src.data, dst.len);
      }
#line 264
      if (tmp___1 != 0L) {
#line 267
        goto no_charset_map;
      }
    }
    {
#line 270
    ngx_http_set_charset(r, & dst);
#line 272
    tmp___2 = (*ngx_http_next_header_filter___2)(r);
    }
#line 272
    return (tmp___2);
  }
#line 275
  if (source_charset == charset) {
    {
#line 276
    r->headers_out.content_type.len = r->headers_out.content_type_len;
#line 278
    ngx_http_set_charset(r, & dst);
#line 280
    tmp___3 = (*ngx_http_next_header_filter___2)(r);
    }
#line 280
    return (tmp___3);
  }
#line 285
  if (r->headers_out.content_encoding) {
#line 285
    if ((r->headers_out.content_encoding)->value.len) {
      {
#line 288
      tmp___4 = (*ngx_http_next_header_filter___2)(r);
      }
#line 288
      return (tmp___4);
    }
  }
#line 291
  mcf = (ngx_http_charset_main_conf_t *)*(r->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 292
  charsets = (ngx_http_charset_t *)mcf->charsets.elts;
#line 294
  if ((unsigned long )(charsets + source_charset)->tables == (unsigned long )((void *)0)) {
#line 297
    goto no_charset_map;
  } else
#line 294
  if ((unsigned long )*((charsets + source_charset)->tables + charset) == (unsigned long )((void *)0)) {
#line 297
    goto no_charset_map;
  }
  {
#line 300
  r->headers_out.content_type.len = r->headers_out.content_type_len;
#line 302
  ngx_http_set_charset(r, & dst);
#line 304
  tmp___5 = ngx_http_charset_ctx(r, charsets, charset, source_charset);
  }
#line 304
  return (tmp___5);
  no_charset_map: 
#line 308
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 308
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no \"charset_map\" between the charsets \"%V\" and \"%V\"",
                       & src, & dst);
    }
  }
  {
#line 312
  tmp___6 = (*ngx_http_next_header_filter___2)(r);
  }
#line 312
  return (tmp___6);
}
}
#line 316 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_destination_charset(ngx_http_request_t *r , ngx_str_t *name ) 
{ 
  ngx_int_t charset ;
  ngx_http_charset_t *charsets ;
  ngx_http_variable_value_t *vv ;
  ngx_http_charset_loc_conf_t *mlcf ;
  ngx_http_charset_main_conf_t *mcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp10 ;

  {
#line 325
  if (r->headers_out.content_type.len == 0UL) {
#line 326
    return ((ngx_int_t )-5);
  }
#line 329
  if (r->headers_out.override_charset) {
#line 329
    if ((r->headers_out.override_charset)->len) {
      {
#line 332
      *name = *(r->headers_out.override_charset);
#line 334
      charset = ngx_http_get_charset(r, name);
      }
#line 336
      if (charset != -3L) {
#line 337
        return (charset);
      }
#line 340
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 340
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unknown charset \"%V\" to override",
                           name);
        }
      }
#line 343
      return ((ngx_int_t )-5);
    }
  }
#line 346
  mlcf = (ngx_http_charset_loc_conf_t *)*(r->loc_conf + ngx_http_charset_filter_module.ctx_index);
#line 347
  charset = mlcf->charset;
#line 349
  if (charset == -2L) {
#line 350
    return ((ngx_int_t )-5);
  }
#line 353
  if (r->headers_out.charset.len) {
#line 354
    if (mlcf->override_charset == 0L) {
#line 355
      return ((ngx_int_t )-5);
    }
  } else {
    {
#line 359
    tmp = ngx_http_test_content_type(r, & mlcf->types);
    }
#line 359
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 360
      return ((ngx_int_t )-5);
    }
  }
#line 364
  if (charset < 65536L) {
#line 365
    mcf = (ngx_http_charset_main_conf_t *)*(r->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 366
    charsets = (ngx_http_charset_t *)mcf->charsets.elts;
#line 367
    *name = (charsets + charset)->name;
#line 368
    return (charset);
  }
  {
#line 371
  vv = ngx_http_get_indexed_variable(r, (ngx_uint_t )(charset - 65536L));
  }
#line 373
  if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 374
    return ((ngx_int_t )-1);
  } else
#line 373
  if (vv->not_found) {
#line 374
    return ((ngx_int_t )-1);
  }
  {
#line 377
  name->len = (size_t )vv->len;
#line 378
  name->data = vv->data;
#line 380
  tmp___0 = ngx_http_get_charset(r, name);
  }
#line 380
  return (tmp___0);
}
}
#line 384 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_main_request_charset(ngx_http_request_t *r , ngx_str_t *src ) 
{ 
  ngx_int_t charset ;
  ngx_str_t *main_charset ;
  ngx_http_charset_ctx_t *ctx ;
  void *tmp ;

  {
#line 391
  ctx = (ngx_http_charset_ctx_t *)*((r->main)->ctx + ngx_http_charset_filter_module.ctx_index);
#line 393
  if (ctx) {
#line 394
    *src = ctx->charset_name;
#line 395
    return (ctx->charset);
  }
#line 398
  main_charset = & (r->main)->headers_out.charset;
#line 400
  if (main_charset->len == 0UL) {
#line 401
    return ((ngx_int_t )-5);
  }
  {
#line 404
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_charset_ctx_t ));
#line 404
  ctx = (ngx_http_charset_ctx_t *)tmp;
  }
#line 405
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 406
    return ((ngx_int_t )-1);
  }
  {
#line 409
  *((r->main)->ctx + ngx_http_charset_filter_module.ctx_index) = (void *)ctx;
#line 411
  charset = ngx_http_get_charset(r, main_charset);
#line 413
  ctx->charset = charset;
#line 414
  ctx->charset_name = *main_charset;
#line 415
  *src = *main_charset;
  }
#line 417
  return (charset);
}
}
#line 421 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_source_charset(ngx_http_request_t *r , ngx_str_t *name ) 
{ 
  ngx_int_t charset ;
  ngx_http_charset_t *charsets ;
  ngx_http_variable_value_t *vv ;
  ngx_http_charset_loc_conf_t *lcf ;
  ngx_http_charset_main_conf_t *mcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 430
  if (r->headers_out.charset.len) {
    {
#line 431
    *name = r->headers_out.charset;
#line 432
    tmp = ngx_http_get_charset(r, name);
    }
#line 432
    return (tmp);
  }
#line 435
  lcf = (ngx_http_charset_loc_conf_t *)*(r->loc_conf + ngx_http_charset_filter_module.ctx_index);
#line 437
  charset = lcf->source_charset;
#line 439
  if (charset == -2L) {
#line 440
    name->len = (size_t )0;
#line 441
    return (charset);
  }
#line 444
  if (charset < 65536L) {
#line 445
    mcf = (ngx_http_charset_main_conf_t *)*(r->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 446
    charsets = (ngx_http_charset_t *)mcf->charsets.elts;
#line 447
    *name = (charsets + charset)->name;
#line 448
    return (charset);
  }
  {
#line 451
  vv = ngx_http_get_indexed_variable(r, (ngx_uint_t )(charset - 65536L));
  }
#line 453
  if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 454
    return ((ngx_int_t )-1);
  } else
#line 453
  if (vv->not_found) {
#line 454
    return ((ngx_int_t )-1);
  }
  {
#line 457
  name->len = (size_t )vv->len;
#line 458
  name->data = vv->data;
#line 460
  tmp___0 = ngx_http_get_charset(r, name);
  }
#line 460
  return (tmp___0);
}
}
#line 464 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_get_charset(ngx_http_request_t *r , ngx_str_t *name ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_charset_t *charset ;
  ngx_http_charset_main_conf_t *mcf ;
  ngx_int_t tmp ;

  {
#line 471
  mcf = (ngx_http_charset_main_conf_t *)*(r->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 473
  charset = (ngx_http_charset_t *)mcf->charsets.elts;
#line 474
  n = mcf->charsets.nelts;
#line 476
  i = (ngx_uint_t )0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (i < n)) {
#line 476
      goto while_break;
    }
#line 477
    if ((charset + i)->name.len != name->len) {
#line 478
      goto __Cont;
    }
    {
#line 481
    tmp = ngx_strncasecmp((charset + i)->name.data, name->data, name->len);
    }
#line 481
    if (tmp == 0L) {
#line 482
      return ((ngx_int_t )i);
    }
    __Cont: /* CIL Label */ 
#line 476
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 486
  return ((ngx_int_t )-3);
}
}
#line 490 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
__inline static void ngx_http_set_charset(ngx_http_request_t *r , ngx_str_t *charset ) 
{ 


  {
#line 493
  if ((unsigned long )r != (unsigned long )r->main) {
#line 494
    return;
  }
#line 497
  if (r->headers_out.status == 301UL) {
#line 505
    r->headers_out.charset.len = (size_t )0;
#line 506
    return;
  } else
#line 497
  if (r->headers_out.status == 302UL) {
#line 505
    r->headers_out.charset.len = (size_t )0;
#line 506
    return;
  }
#line 509
  r->headers_out.charset = *charset;
#line 510
  return;
}
}
#line 513 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_charset_ctx(ngx_http_request_t *r , ngx_http_charset_t *charsets ,
                                      ngx_int_t charset , ngx_int_t source_charset ) 
{ 
  ngx_http_charset_ctx_t *ctx ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 519
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_charset_ctx_t ));
#line 519
  ctx = (ngx_http_charset_ctx_t *)tmp;
  }
#line 520
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 521
    return ((ngx_int_t )-1);
  }
#line 524
  *(r->ctx + ngx_http_charset_filter_module.ctx_index) = (void *)ctx;
#line 526
  ctx->table = *((charsets + source_charset)->tables + charset);
#line 527
  ctx->charset = charset;
#line 528
  ctx->charset_name = (charsets + charset)->name;
#line 529
  ctx->length = (charsets + charset)->length;
#line 530
  ctx->from_utf8 = (charsets + source_charset)->utf8;
#line 531
  ctx->to_utf8 = (charsets + charset)->utf8;
#line 533
  r->filter_need_in_memory = 1U;
#line 535
  if (ctx->to_utf8) {
#line 535
    goto _L;
  } else
#line 535
  if (ctx->from_utf8) {
    _L: /* CIL Label */ 
#line 535
    if ((unsigned long )r == (unsigned long )r->main) {
#line 536
      r->headers_out.content_length_n = (off_t )-1;
#line 536
      if (r->headers_out.content_length) {
#line 536
        (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 536
        r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
      }
    } else {
#line 539
      r->filter_need_temporary = 1U;
    }
  } else {
#line 539
    r->filter_need_temporary = 1U;
  }
  {
#line 542
  tmp___0 = (*ngx_http_next_header_filter___2)(r);
  }
#line 542
  return (tmp___0);
}
}
#line 546 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_charset_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_http_charset_ctx_t *ctx ;
  ngx_int_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 554
  ctx = (ngx_http_charset_ctx_t *)*(r->ctx + ngx_http_charset_filter_module.ctx_index);
#line 556
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 557
    tmp = (*ngx_http_next_body_filter___1)(r, in);
    }
#line 557
    return (tmp);
  } else
#line 556
  if ((unsigned long )ctx->table == (unsigned long )((void *)0)) {
    {
#line 557
    tmp = (*ngx_http_next_body_filter___1)(r, in);
    }
#line 557
    return (tmp);
  }
#line 560
  if (ctx->to_utf8) {
#line 560
    goto _L;
  } else
#line 560
  if (ctx->from_utf8) {
#line 560
    goto _L;
  } else
#line 560
  if (ctx->busy) {
    _L: /* CIL Label */ 
#line 562
    out = (ngx_chain_t *)((void *)0);
#line 563
    ll = & out;
#line 565
    cl = in;
    {
#line 565
    while (1) {
      while_continue: /* CIL Label */ ;
#line 565
      if (! cl) {
#line 565
        goto while_break;
      }
#line 566
      b = cl->buf;
#line 568
      if (b->temporary) {
#line 568
        tmp___0 = b->last - b->pos;
      } else
#line 568
      if (b->memory) {
#line 568
        tmp___0 = b->last - b->pos;
      } else
#line 568
      if (b->mmap) {
#line 568
        tmp___0 = b->last - b->pos;
      } else {
#line 568
        tmp___0 = b->file_last - b->file_pos;
      }
#line 568
      if (tmp___0 == 0L) {
        {
#line 570
        *ll = ngx_alloc_chain_link(r->pool);
        }
#line 571
        if ((unsigned long )*ll == (unsigned long )((void *)0)) {
#line 572
          return ((ngx_int_t )-1);
        }
#line 575
        (*ll)->buf = b;
#line 576
        (*ll)->next = (ngx_chain_t *)((void *)0);
#line 578
        ll = & (*ll)->next;
#line 580
        goto __Cont;
      }
#line 583
      if (ctx->to_utf8) {
        {
#line 584
        *ll = ngx_http_charset_recode_to_utf8(r->pool, b, ctx);
        }
      } else {
        {
#line 587
        *ll = ngx_http_charset_recode_from_utf8(r->pool, b, ctx);
        }
      }
#line 590
      if ((unsigned long )*ll == (unsigned long )((void *)0)) {
#line 591
        return ((ngx_int_t )-1);
      }
      {
#line 594
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 594
        if (! *ll) {
#line 594
          goto while_break___0;
        }
#line 595
        ll = & (*ll)->next;
      }
      while_break___0: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 565
      cl = cl->next;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 599
    rc = (*ngx_http_next_body_filter___1)(r, out);
    }
#line 601
    if (out) {
#line 602
      if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
#line 603
        ctx->busy = out;
      } else {
#line 606
        cl = ctx->busy;
        {
#line 606
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 606
          if (! cl->next) {
#line 606
            goto while_break___1;
          }
#line 606
          cl = cl->next;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 607
        cl->next = out;
      }
    }
    {
#line 611
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 611
      if (! ctx->busy) {
#line 611
        goto while_break___2;
      }
#line 613
      cl = ctx->busy;
#line 614
      b = cl->buf;
#line 616
      if (b->temporary) {
#line 616
        tmp___1 = b->last - b->pos;
      } else
#line 616
      if (b->memory) {
#line 616
        tmp___1 = b->last - b->pos;
      } else
#line 616
      if (b->mmap) {
#line 616
        tmp___1 = b->last - b->pos;
      } else {
#line 616
        tmp___1 = b->file_last - b->file_pos;
      }
#line 616
      if (tmp___1 != 0L) {
#line 617
        goto while_break___2;
      }
#line 620
      ctx->busy = cl->next;
#line 622
      if ((unsigned long )b->tag != (unsigned long )((ngx_buf_tag_t )(& ngx_http_charset_filter_module))) {
#line 623
        goto while_continue___2;
      }
#line 626
      if (b->shadow) {
#line 627
        (b->shadow)->pos = (b->shadow)->last;
      }
#line 630
      if (b->pos) {
#line 631
        cl->next = ctx->free_buffers;
#line 632
        ctx->free_buffers = cl;
#line 633
        goto while_continue___2;
      }
#line 636
      cl->next = ctx->free_bufs;
#line 637
      ctx->free_bufs = cl;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 640
    return (rc);
  }
#line 643
  cl = in;
  {
#line 643
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 643
    if (! cl) {
#line 643
      goto while_break___3;
    }
    {
#line 644
    ngx_http_charset_recode(cl->buf, ctx->table);
#line 643
    cl = cl->next;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 647
  tmp___2 = (*ngx_http_next_body_filter___1)(r, in);
  }
#line 647
  return (tmp___2);
}
}
#line 651 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_uint_t ngx_http_charset_recode(ngx_buf_t *b , u_char *table ) 
{ 
  u_char *p ;
  u_char *last ;

  {
#line 656
  last = b->last;
#line 658
  p = b->pos;
  {
#line 658
  while (1) {
    while_continue: /* CIL Label */ ;
#line 658
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 658
      goto while_break;
    }
#line 660
    if ((int )*p != (int )*(table + *p)) {
#line 661
      goto recode;
    }
#line 658
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 665
  return ((ngx_uint_t )0);
  recode: 
  {
#line 669
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 670
    if ((int )*p != (int )*(table + *p)) {
#line 671
      *p = *(table + *p);
    }
#line 674
    p ++;
#line 669
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 669
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 678
  b->in_file = 0U;
#line 680
  return ((ngx_uint_t )1);
}
}
#line 684 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_chain_t *ngx_http_charset_recode_from_utf8(ngx_pool_t *pool , ngx_buf_t *buf ,
                                                      ngx_http_charset_ctx_t *ctx ) 
{ 
  size_t len ;
  size_t size ;
  u_char c ;
  u_char *p ;
  u_char *src ;
  u_char *dst ;
  u_char *saved ;
  u_char **table ;
  uint32_t n ;
  ngx_buf_t *b ;
  ngx_uint_t i ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 695
  src = buf->pos;
#line 697
  if (ctx->saved_len == 0UL) {
    {
#line 699
    while (1) {
      while_continue: /* CIL Label */ ;
#line 699
      if (! ((unsigned long )src < (unsigned long )buf->last)) {
#line 699
        goto while_break;
      }
#line 701
      if ((int )*src < 128) {
#line 702
        goto __Cont;
      }
#line 705
      len = (size_t )(src - buf->pos);
#line 707
      if (len > 512UL) {
        {
#line 708
        out = ngx_http_charset_get_buf(pool, ctx);
        }
#line 709
        if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 710
          return ((ngx_chain_t *)((void *)0));
        }
        {
#line 713
        b = out->buf;
#line 715
        b->temporary = buf->temporary;
#line 716
        b->memory = buf->memory;
#line 717
        b->mmap = buf->mmap;
#line 718
        b->flush = buf->flush;
#line 720
        b->pos = buf->pos;
#line 721
        b->last = src;
#line 723
        out->buf = b;
#line 724
        out->next = (ngx_chain_t *)((void *)0);
#line 726
        size = (size_t )(buf->last - src);
#line 728
        saved = src;
#line 729
        n = ngx_utf8_decode(& saved, size);
        }
#line 731
        if (n == 4294967294U) {
          {
#line 734
          memcpy((void */* __restrict  */)(ctx->saved), (void const   */* __restrict  */)src,
                 size);
#line 735
          ctx->saved_len = size;
#line 737
          b->shadow = buf;
          }
#line 739
          return (out);
        }
      } else {
#line 743
        out = (ngx_chain_t *)((void *)0);
#line 744
        size = (size_t )((buf->last + len) - src);
#line 745
        src = buf->pos;
      }
#line 748
      if (size < sizeof("&#1114111;") - 1UL) {
#line 749
        size += sizeof("&#1114111;") - 1UL;
      }
      {
#line 752
      cl = ngx_http_charset_get_buffer(pool, ctx, size);
      }
#line 753
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 754
        return ((ngx_chain_t *)((void *)0));
      }
#line 757
      if (out) {
#line 758
        out->next = cl;
      } else {
#line 761
        out = cl;
      }
#line 764
      b = cl->buf;
#line 765
      dst = b->pos;
#line 767
      goto recode;
      __Cont: /* CIL Label */ 
#line 699
      src ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 770
    out = ngx_alloc_chain_link(pool);
    }
#line 771
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 772
      return ((ngx_chain_t *)((void *)0));
    }
#line 775
    out->buf = buf;
#line 776
    out->next = (ngx_chain_t *)((void *)0);
#line 778
    return (out);
  }
#line 786
  p = src;
#line 788
  i = ctx->saved_len;
  {
#line 788
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 788
    if (! (i < 4UL)) {
#line 788
      goto while_break___0;
    }
#line 789
    tmp = p;
#line 789
    p ++;
#line 789
    ctx->saved[i] = *tmp;
#line 791
    if ((unsigned long )p == (unsigned long )buf->last) {
#line 792
      goto while_break___0;
    }
#line 788
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 796
  saved = ctx->saved;
#line 797
  n = ngx_utf8_decode(& saved, i);
#line 799
  c = (u_char )'\000';
  }
#line 801
  if (n < 65536U) {
#line 802
    table = (u_char **)ctx->table;
#line 803
    p = *(table + (n >> 8));
#line 805
    if (p) {
#line 806
      c = *(p + (n & 255U));
    }
  } else
#line 809
  if (n == 4294967294U) {
#line 813
    if (i < 4UL) {
      {
#line 814
      out = ngx_http_charset_get_buf(pool, ctx);
      }
#line 815
      if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 816
        return ((ngx_chain_t *)((void *)0));
      }
      {
#line 819
      b = out->buf;
#line 821
      b->pos = buf->pos;
#line 822
      b->last = buf->last;
#line 823
      b->sync = 1U;
#line 824
      b->shadow = buf;
#line 826
      memcpy((void */* __restrict  */)(& ctx->saved[ctx->saved_len]), (void const   */* __restrict  */)src,
             i);
#line 827
      ctx->saved_len += i;
      }
#line 829
      return (out);
    }
  }
#line 833
  size = (size_t )(buf->last - buf->pos);
#line 835
  if (size < sizeof("&#1114111;") - 1UL) {
#line 836
    size += sizeof("&#1114111;") - 1UL;
  }
  {
#line 839
  cl = ngx_http_charset_get_buffer(pool, ctx, size);
  }
#line 840
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 841
    return ((ngx_chain_t *)((void *)0));
  }
#line 844
  out = cl;
#line 846
  b = cl->buf;
#line 847
  dst = b->pos;
#line 849
  if (c) {
#line 850
    tmp___0 = dst;
#line 850
    dst ++;
#line 850
    *tmp___0 = c;
  } else
#line 852
  if (n == 4294967294U) {
#line 853
    tmp___1 = dst;
#line 853
    dst ++;
#line 853
    *tmp___1 = (u_char )'?';
#line 858
    saved = & ctx->saved[4];
  } else
#line 860
  if (n > 1114111U) {
#line 861
    tmp___2 = dst;
#line 861
    dst ++;
#line 861
    *tmp___2 = (u_char )'?';
  } else {
    {
#line 867
    dst = ngx_sprintf(dst, "&#%uD;", n);
    }
  }
#line 870
  src += (size_t )(saved - ctx->saved) - ctx->saved_len;
#line 871
  ctx->saved_len = (size_t )0;
  recode: 
#line 875
  ll = & cl->next;
#line 877
  table = (u_char **)ctx->table;
  {
#line 879
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 879
    if (! ((unsigned long )src < (unsigned long )buf->last)) {
#line 879
      goto while_break___1;
    }
#line 881
    if ((size_t )(b->end - dst) < sizeof("&#1114111;") - 1UL) {
      {
#line 882
      b->last = dst;
#line 884
      size = (unsigned long )(buf->last - src) + (sizeof("&#1114111;") - 1UL);
#line 886
      cl = ngx_http_charset_get_buffer(pool, ctx, size);
      }
#line 887
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 888
        return ((ngx_chain_t *)((void *)0));
      }
#line 891
      *ll = cl;
#line 892
      ll = & cl->next;
#line 894
      b = cl->buf;
#line 895
      dst = b->pos;
    }
#line 898
    if ((int )*src < 128) {
#line 899
      tmp___3 = dst;
#line 899
      dst ++;
#line 899
      tmp___4 = src;
#line 899
      src ++;
#line 899
      *tmp___3 = *tmp___4;
#line 900
      goto while_continue___1;
    }
    {
#line 903
    len = (size_t )(buf->last - src);
#line 905
    n = ngx_utf8_decode(& src, len);
    }
#line 907
    if (n < 65536U) {
#line 909
      p = *(table + (n >> 8));
#line 911
      if (p) {
#line 912
        c = *(p + (n & 255U));
#line 914
        if (c) {
#line 915
          tmp___5 = dst;
#line 915
          dst ++;
#line 915
          *tmp___5 = c;
#line 916
          goto while_continue___1;
        }
      }
      {
#line 920
      dst = ngx_sprintf(dst, "&#%uD;", n);
      }
#line 922
      goto while_continue___1;
    }
#line 925
    if (n == 4294967294U) {
      {
#line 928
      memcpy((void */* __restrict  */)(ctx->saved), (void const   */* __restrict  */)src,
             len);
#line 929
      ctx->saved_len = len;
      }
#line 931
      if ((unsigned long )b->pos == (unsigned long )dst) {
#line 932
        b->sync = 1U;
#line 933
        b->temporary = 0U;
      }
#line 936
      goto while_break___1;
    }
#line 939
    if (n > 1114111U) {
#line 940
      tmp___6 = dst;
#line 940
      dst ++;
#line 940
      *tmp___6 = (u_char )'?';
#line 945
      goto while_continue___1;
    }
    {
#line 950
    dst = ngx_sprintf(dst, "&#%uD;", n);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 953
  b->last = dst;
#line 955
  b->last_buf = buf->last_buf;
#line 956
  b->last_in_chain = buf->last_in_chain;
#line 957
  b->flush = buf->flush;
#line 959
  b->shadow = buf;
#line 961
  return (out);
}
}
#line 965 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_chain_t *ngx_http_charset_recode_to_utf8(ngx_pool_t *pool , ngx_buf_t *buf ,
                                                    ngx_http_charset_ctx_t *ctx ) 
{ 
  size_t len ;
  size_t size ;
  u_char *p ;
  u_char *src ;
  u_char *dst ;
  u_char *table ;
  ngx_buf_t *b ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 974
  table = ctx->table;
#line 976
  src = buf->pos;
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if (! ((unsigned long )src < (unsigned long )buf->last)) {
#line 976
      goto while_break;
    }
#line 977
    if ((int )*(table + (int )*src * 4) == 1) {
#line 978
      goto __Cont;
    }
#line 981
    goto recode;
    __Cont: /* CIL Label */ 
#line 976
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 984
  out = ngx_alloc_chain_link(pool);
  }
#line 985
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 986
    return ((ngx_chain_t *)((void *)0));
  }
#line 989
  out->buf = buf;
#line 990
  out->next = (ngx_chain_t *)((void *)0);
#line 992
  return (out);
  recode: 
#line 1001
  len = (size_t )(src - buf->pos);
#line 1003
  if (len > 512UL) {
    {
#line 1004
    out = ngx_http_charset_get_buf(pool, ctx);
    }
#line 1005
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 1006
      return ((ngx_chain_t *)((void *)0));
    }
#line 1009
    b = out->buf;
#line 1011
    b->temporary = buf->temporary;
#line 1012
    b->memory = buf->memory;
#line 1013
    b->mmap = buf->mmap;
#line 1014
    b->flush = buf->flush;
#line 1016
    b->pos = buf->pos;
#line 1017
    b->last = src;
#line 1019
    out->buf = b;
#line 1020
    out->next = (ngx_chain_t *)((void *)0);
#line 1022
    size = (size_t )(buf->last - src);
#line 1023
    size = size / 2UL + (size / 2UL) * (size_t )ctx->length;
  } else {
#line 1026
    out = (ngx_chain_t *)((void *)0);
#line 1028
    size = (size_t )(buf->last - src);
#line 1029
    size = (len + size / 2UL) + (size / 2UL) * (size_t )ctx->length;
#line 1031
    src = buf->pos;
  }
  {
#line 1034
  cl = ngx_http_charset_get_buffer(pool, ctx, size);
  }
#line 1035
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1036
    return ((ngx_chain_t *)((void *)0));
  }
#line 1039
  if (out) {
#line 1040
    out->next = cl;
  } else {
#line 1043
    out = cl;
  }
#line 1046
  ll = & cl->next;
#line 1048
  b = cl->buf;
#line 1049
  dst = b->pos;
  {
#line 1051
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1051
    if (! ((unsigned long )src < (unsigned long )buf->last)) {
#line 1051
      goto while_break___0;
    }
#line 1053
    tmp = src;
#line 1053
    src ++;
#line 1053
    p = table + (int )*tmp * 4;
#line 1054
    tmp___0 = p;
#line 1054
    p ++;
#line 1054
    len = (size_t )*tmp___0;
#line 1056
    if ((size_t )(b->end - dst) < len) {
      {
#line 1057
      b->last = dst;
#line 1059
      size = (size_t )(buf->last - src);
#line 1060
      size = (len + size / 2UL) + (size / 2UL) * (size_t )ctx->length;
#line 1062
      cl = ngx_http_charset_get_buffer(pool, ctx, size);
      }
#line 1063
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1064
        return ((ngx_chain_t *)((void *)0));
      }
#line 1067
      *ll = cl;
#line 1068
      ll = & cl->next;
#line 1070
      b = cl->buf;
#line 1071
      dst = b->pos;
    }
    {
#line 1074
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1074
      if (! len) {
#line 1074
        goto while_break___1;
      }
#line 1075
      tmp___1 = dst;
#line 1075
      dst ++;
#line 1075
      tmp___2 = p;
#line 1075
      p ++;
#line 1075
      *tmp___1 = *tmp___2;
#line 1076
      len --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1080
  b->last = dst;
#line 1082
  b->last_buf = buf->last_buf;
#line 1083
  b->last_in_chain = buf->last_in_chain;
#line 1084
  b->flush = buf->flush;
#line 1086
  b->shadow = buf;
#line 1088
  return (out);
}
}
#line 1092 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_chain_t *ngx_http_charset_get_buf(ngx_pool_t *pool , ngx_http_charset_ctx_t *ctx ) 
{ 
  ngx_chain_t *cl ;
  void *tmp ;

  {
#line 1097
  cl = ctx->free_bufs;
#line 1099
  if (cl) {
#line 1100
    ctx->free_bufs = cl->next;
#line 1102
    (cl->buf)->shadow = (ngx_buf_t *)((void *)0);
#line 1103
    cl->next = (ngx_chain_t *)((void *)0);
#line 1105
    return (cl);
  }
  {
#line 1108
  cl = ngx_alloc_chain_link(pool);
  }
#line 1109
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1110
    return ((ngx_chain_t *)((void *)0));
  }
  {
#line 1113
  tmp = ngx_pcalloc(pool, sizeof(ngx_buf_t ));
#line 1113
  cl->buf = (ngx_buf_t *)tmp;
  }
#line 1114
  if ((unsigned long )cl->buf == (unsigned long )((void *)0)) {
#line 1115
    return ((ngx_chain_t *)((void *)0));
  }
#line 1118
  cl->next = (ngx_chain_t *)((void *)0);
#line 1120
  (cl->buf)->tag = (ngx_buf_tag_t )(& ngx_http_charset_filter_module);
#line 1122
  return (cl);
}
}
#line 1126 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_chain_t *ngx_http_charset_get_buffer(ngx_pool_t *pool , ngx_http_charset_ctx_t *ctx ,
                                                size_t size ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;

  {
#line 1133
  ll = & ctx->free_buffers;
#line 1133
  cl = ctx->free_buffers;
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! cl) {
#line 1133
      goto while_break;
    }
#line 1137
    b = cl->buf;
#line 1139
    if ((size_t )(b->end - b->start) >= size) {
#line 1140
      *ll = cl->next;
#line 1141
      cl->next = (ngx_chain_t *)((void *)0);
#line 1143
      b->pos = b->start;
#line 1144
      b->temporary = 1U;
#line 1145
      b->shadow = (ngx_buf_t *)((void *)0);
#line 1147
      return (cl);
    }
#line 1133
    ll = & cl->next;
#line 1133
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1151
  cl = ngx_alloc_chain_link(pool);
  }
#line 1152
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1153
    return ((ngx_chain_t *)((void *)0));
  }
  {
#line 1156
  cl->buf = ngx_create_temp_buf(pool, size);
  }
#line 1157
  if ((unsigned long )cl->buf == (unsigned long )((void *)0)) {
#line 1158
    return ((ngx_chain_t *)((void *)0));
  }
#line 1161
  cl->next = (ngx_chain_t *)((void *)0);
#line 1163
  (cl->buf)->temporary = 1U;
#line 1164
  (cl->buf)->tag = (ngx_buf_tag_t )(& ngx_http_charset_filter_module);
#line 1166
  return (cl);
}
}
#line 1170 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static char *ngx_http_charset_map_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_charset_main_conf_t *mcf ;
  char *rv ;
  u_char *p ;
  u_char *dst2src ;
  u_char **pp ;
  ngx_int_t src ;
  ngx_int_t dst ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_str_t *value ;
  ngx_conf_t pvcf ;
  ngx_http_charset_t *charset ;
  ngx_http_charset_tables_t *table ;
  ngx_http_charset_conf_ctx_t ctx ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ngx_int_t tmp___5 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 1173
  mcf = (ngx_http_charset_main_conf_t *)conf;
#line 1185
  value = (ngx_str_t *)(cf->args)->elts;
#line 1187
  src = ngx_http_add_charset(& mcf->charsets, value + 1);
  }
#line 1188
  if (src == -1L) {
#line 1189
    return ((char *)((void *)-1));
  }
  {
#line 1192
  dst = ngx_http_add_charset(& mcf->charsets, value + 2);
  }
#line 1193
  if (dst == -1L) {
#line 1194
    return ((char *)((void *)-1));
  }
#line 1197
  if (src == dst) {
    {
#line 1198
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"charset_map\" between the same charsets \"%V\" and \"%V\"",
                       value + 1, value + 2);
    }
#line 1201
    return ((char *)((void *)-1));
  }
#line 1204
  table = (ngx_http_charset_tables_t *)mcf->tables.elts;
#line 1205
  i = (ngx_uint_t )0;
  {
#line 1205
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1205
    if (! (i < mcf->tables.nelts)) {
#line 1205
      goto while_break;
    }
#line 1206
    if (src == table->src) {
#line 1206
      if (dst == table->dst) {
        {
#line 1209
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate \"charset_map\" between \"%V\" and \"%V\"",
                           value + 1, value + 2);
        }
#line 1212
        return ((char *)((void *)-1));
      } else {
#line 1206
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1206
    if (src == table->dst) {
#line 1206
      if (dst == table->src) {
        {
#line 1209
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate \"charset_map\" between \"%V\" and \"%V\"",
                           value + 1, value + 2);
        }
#line 1212
        return ((char *)((void *)-1));
      }
    }
#line 1205
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1216
  tmp = ngx_array_push(& mcf->tables);
#line 1216
  table = (ngx_http_charset_tables_t *)tmp;
  }
#line 1217
  if ((unsigned long )table == (unsigned long )((void *)0)) {
#line 1218
    return ((char *)((void *)-1));
  }
  {
#line 1221
  table->src = src;
#line 1222
  table->dst = dst;
#line 1224
  tmp___5 = ngx_strcasecmp((value + 2)->data, (u_char *)"utf-8");
  }
#line 1224
  if (tmp___5 == 0L) {
    {
#line 1225
    tmp___0 = ngx_pcalloc(cf->pool, (size_t )1024);
#line 1225
    table->src2dst = (u_char *)tmp___0;
    }
#line 1226
    if ((unsigned long )table->src2dst == (unsigned long )((void *)0)) {
#line 1227
      return ((char *)((void *)-1));
    }
    {
#line 1230
    tmp___1 = ngx_pcalloc(cf->pool, 256UL * sizeof(void *));
#line 1230
    table->dst2src = (u_char *)tmp___1;
    }
#line 1231
    if ((unsigned long )table->dst2src == (unsigned long )((void *)0)) {
#line 1232
      return ((char *)((void *)-1));
    }
    {
#line 1235
    tmp___2 = ngx_pcalloc(cf->pool, (size_t )256);
#line 1235
    dst2src = (u_char *)tmp___2;
    }
#line 1236
    if ((unsigned long )dst2src == (unsigned long )((void *)0)) {
#line 1237
      return ((char *)((void *)-1));
    }
#line 1240
    pp = (u_char **)(table->dst2src + 0);
#line 1241
    *(pp + 0) = dst2src;
#line 1243
    i = (ngx_uint_t )0;
    {
#line 1243
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1243
      if (! (i < 128UL)) {
#line 1243
        goto while_break___0;
      }
#line 1244
      p = table->src2dst + i * 4UL;
#line 1245
      *(p + 0) = (u_char )'\001';
#line 1246
      *(p + 1) = (u_char )i;
#line 1247
      *(dst2src + i) = (u_char )i;
#line 1243
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1250
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1250
      if (! (i < 256UL)) {
#line 1250
        goto while_break___1;
      }
#line 1251
      p = table->src2dst + i * 4UL;
#line 1252
      *(p + 0) = (u_char )'\001';
#line 1253
      *(p + 1) = (u_char )'?';
#line 1250
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1257
    tmp___3 = ngx_palloc(cf->pool, (size_t )256);
#line 1257
    table->src2dst = (u_char *)tmp___3;
    }
#line 1258
    if ((unsigned long )table->src2dst == (unsigned long )((void *)0)) {
#line 1259
      return ((char *)((void *)-1));
    }
    {
#line 1262
    tmp___4 = ngx_palloc(cf->pool, (size_t )256);
#line 1262
    table->dst2src = (u_char *)tmp___4;
    }
#line 1263
    if ((unsigned long )table->dst2src == (unsigned long )((void *)0)) {
#line 1264
      return ((char *)((void *)-1));
    }
#line 1267
    i = (ngx_uint_t )0;
    {
#line 1267
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1267
      if (! (i < 128UL)) {
#line 1267
        goto while_break___2;
      }
#line 1268
      *(table->src2dst + i) = (u_char )i;
#line 1269
      *(table->dst2src + i) = (u_char )i;
#line 1267
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 1272
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1272
      if (! (i < 256UL)) {
#line 1272
        goto while_break___3;
      }
#line 1273
      *(table->src2dst + i) = (u_char )'?';
#line 1274
      *(table->dst2src + i) = (u_char )'?';
#line 1272
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
  }
  {
#line 1278
  charset = (ngx_http_charset_t *)mcf->charsets.elts;
#line 1280
  ctx.table = table;
#line 1281
  ctx.charset = charset + dst;
#line 1282
  ctx.characters = (ngx_uint_t )0;
#line 1284
  pvcf = *cf;
#line 1285
  cf->ctx = (void *)(& ctx);
#line 1286
  cf->handler = & ngx_http_charset_map;
#line 1287
  cf->handler_conf = conf;
#line 1289
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 1291
  *cf = pvcf;
  }
#line 1293
  if (ctx.characters) {
#line 1294
    n = (ngx_uint_t )(ctx.charset)->length;
#line 1295
    (ctx.charset)->length = (unsigned int )((ngx_uint_t )(ctx.charset)->length / ctx.characters);
#line 1297
    if (((n * 10UL) / ctx.characters) % 10UL > 4UL) {
#line 1298
      ((ctx.charset)->length) ++;
    }
  }
#line 1302
  return (rv);
}
}
#line 1306 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static char *ngx_http_charset_map(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  u_char *p ;
  u_char *dst2src ;
  u_char **pp ;
  uint32_t n ;
  ngx_int_t src ;
  ngx_int_t dst ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_http_charset_tables_t *table ;
  ngx_http_charset_conf_ctx_t *ctx ;
  u_char *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 1317
  if ((cf->args)->nelts != 2UL) {
    {
#line 1318
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameters number");
    }
#line 1319
    return ((char *)((void *)-1));
  }
  {
#line 1322
  value = (ngx_str_t *)(cf->args)->elts;
#line 1324
  src = ngx_hextoi((value + 0)->data, (value + 0)->len);
  }
#line 1325
  if (src == -1L) {
    {
#line 1326
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 0);
    }
#line 1328
    return ((char *)((void *)-1));
  } else
#line 1325
  if (src > 255L) {
    {
#line 1326
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 0);
    }
#line 1328
    return ((char *)((void *)-1));
  }
#line 1331
  ctx = (ngx_http_charset_conf_ctx_t *)cf->ctx;
#line 1332
  table = ctx->table;
#line 1334
  if ((ctx->charset)->utf8) {
#line 1335
    p = table->src2dst + src * 4L;
#line 1337
    tmp = p;
#line 1337
    p ++;
#line 1337
    *tmp = (u_char )((value + 1)->len / 2UL);
#line 1339
    i = (ngx_uint_t )0;
    {
#line 1339
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1339
      if (! (i < (value + 1)->len)) {
#line 1339
        goto while_break;
      }
      {
#line 1340
      dst = ngx_hextoi((value + 1)->data + i, (size_t )2);
      }
#line 1341
      if (dst == -1L) {
        {
#line 1342
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
        }
#line 1344
        return ((char *)((void *)-1));
      } else
#line 1341
      if (dst > 255L) {
        {
#line 1342
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
        }
#line 1344
        return ((char *)((void *)-1));
      }
#line 1347
      tmp___0 = p;
#line 1347
      p ++;
#line 1347
      *tmp___0 = (u_char )dst;
#line 1339
      i += 2UL;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1350
    i /= 2UL;
#line 1352
    (ctx->charset)->length = (unsigned int )((ngx_uint_t )(ctx->charset)->length + i);
#line 1353
    (ctx->characters) ++;
#line 1355
    p = (table->src2dst + src * 4L) + 1;
#line 1357
    n = ngx_utf8_decode(& p, i);
    }
#line 1359
    if (n > 65535U) {
      {
#line 1360
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
      }
#line 1362
      return ((char *)((void *)-1));
    }
#line 1365
    pp = (u_char **)(table->dst2src + 0);
#line 1367
    dst2src = *(pp + (n >> 8));
#line 1369
    if ((unsigned long )dst2src == (unsigned long )((void *)0)) {
      {
#line 1370
      tmp___1 = ngx_pcalloc(cf->pool, (size_t )256);
#line 1370
      dst2src = (u_char *)tmp___1;
      }
#line 1371
      if ((unsigned long )dst2src == (unsigned long )((void *)0)) {
#line 1372
        return ((char *)((void *)-1));
      }
#line 1375
      *(pp + (n >> 8)) = dst2src;
    }
#line 1378
    *(dst2src + (n & 255U)) = (u_char )src;
  } else {
    {
#line 1381
    dst = ngx_hextoi((value + 1)->data, (value + 1)->len);
    }
#line 1382
    if (dst == -1L) {
      {
#line 1383
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
      }
#line 1385
      return ((char *)((void *)-1));
    } else
#line 1382
    if (dst > 255L) {
      {
#line 1383
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + 1);
      }
#line 1385
      return ((char *)((void *)-1));
    }
#line 1388
    *(table->src2dst + src) = (u_char )dst;
#line 1389
    *(table->dst2src + dst) = (u_char )src;
  }
#line 1392
  return ((char *)((void *)0));
}
}
#line 1396 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static char *ngx_http_set_charset_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_int_t *cp ;
  ngx_str_t *value ;
  ngx_str_t var ;
  ngx_http_charset_main_conf_t *mcf ;
  int tmp ;
  char *__cil_tmp10 ;

  {
#line 1399
  p = (char *)conf;
#line 1405
  cp = (ngx_int_t *)(p + cmd->offset);
#line 1407
  if (*cp != -1L) {
#line 1408
    return ((char *)"is duplicate");
  }
#line 1411
  value = (ngx_str_t *)(cf->args)->elts;
#line 1413
  if (cmd->offset == (unsigned long )(& ((ngx_http_charset_loc_conf_t *)0)->charset)) {
    {
#line 1413
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 1413
    if (tmp == 0) {
#line 1416
      *cp = (ngx_int_t )-2;
#line 1417
      return ((char *)((void *)0));
    }
  }
#line 1421
  if ((int )*((value + 1)->data + 0) == 36) {
    {
#line 1422
    var.len = (value + 1)->len - 1UL;
#line 1423
    var.data = (value + 1)->data + 1;
#line 1425
    *cp = ngx_http_get_variable_index(cf, & var);
    }
#line 1427
    if (*cp == -1L) {
#line 1428
      return ((char *)((void *)-1));
    }
#line 1431
    *cp += 65536L;
#line 1433
    return ((char *)((void *)0));
  }
  {
#line 1436
  mcf = (ngx_http_charset_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 1439
  *cp = ngx_http_add_charset(& mcf->charsets, value + 1);
  }
#line 1440
  if (*cp == -1L) {
#line 1441
    return ((char *)((void *)-1));
  }
#line 1444
  return ((char *)((void *)0));
}
}
#line 1448 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_add_charset(ngx_array_t *charsets , ngx_str_t *name ) 
{ 
  ngx_uint_t i ;
  ngx_http_charset_t *c ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 1454
  c = (ngx_http_charset_t *)charsets->elts;
#line 1455
  i = (ngx_uint_t )0;
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (i < charsets->nelts)) {
#line 1455
      goto while_break;
    }
#line 1456
    if (name->len != (c + i)->name.len) {
#line 1457
      goto __Cont;
    }
    {
#line 1460
    tmp = ngx_strcasecmp(name->data, (c + i)->name.data);
    }
#line 1460
    if (tmp == 0L) {
#line 1461
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 1455
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1465
  if (i < charsets->nelts) {
#line 1466
    return ((ngx_int_t )i);
  }
  {
#line 1469
  tmp___0 = ngx_array_push(charsets);
#line 1469
  c = (ngx_http_charset_t *)tmp___0;
  }
#line 1470
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1471
    return ((ngx_int_t )-1);
  }
  {
#line 1474
  c->tables = (u_char **)((void *)0);
#line 1475
  c->name = *name;
#line 1476
  c->length = 0U;
#line 1478
  tmp___1 = ngx_strcasecmp(name->data, (u_char *)"utf-8");
  }
#line 1478
  if (tmp___1 == 0L) {
#line 1479
    c->utf8 = 1U;
  } else {
#line 1482
    c->utf8 = 0U;
  }
#line 1485
  return ((ngx_int_t )i);
}
}
#line 1489 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static void *ngx_http_charset_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_charset_main_conf_t *mcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
  {
#line 1494
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_charset_main_conf_t ));
#line 1494
  mcf = (ngx_http_charset_main_conf_t *)tmp;
  }
#line 1495
  if ((unsigned long )mcf == (unsigned long )((void *)0)) {
#line 1496
    return ((void *)0);
  }
  {
#line 1499
  tmp___0 = ngx_array_init(& mcf->charsets, cf->pool, (ngx_uint_t )2, sizeof(ngx_http_charset_t ));
  }
#line 1499
  if (tmp___0 != 0L) {
#line 1502
    return ((void *)0);
  }
  {
#line 1505
  tmp___1 = ngx_array_init(& mcf->tables, cf->pool, (ngx_uint_t )1, sizeof(ngx_http_charset_tables_t ));
  }
#line 1505
  if (tmp___1 != 0L) {
#line 1509
    return ((void *)0);
  }
  {
#line 1512
  tmp___2 = ngx_array_init(& mcf->recodes, cf->pool, (ngx_uint_t )2, sizeof(ngx_http_charset_recode_t ));
  }
#line 1512
  if (tmp___2 != 0L) {
#line 1516
    return ((void *)0);
  }
#line 1519
  return ((void *)mcf);
}
}
#line 1523 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static void *ngx_http_charset_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_charset_loc_conf_t *lcf ;
  void *tmp ;

  {
  {
#line 1528
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_charset_loc_conf_t ));
#line 1528
  lcf = (ngx_http_charset_loc_conf_t *)tmp;
  }
#line 1529
  if ((unsigned long )lcf == (unsigned long )((void *)0)) {
#line 1530
    return ((void *)0);
  }
#line 1540
  lcf->charset = (ngx_int_t )-1;
#line 1541
  lcf->source_charset = (ngx_int_t )-1;
#line 1542
  lcf->override_charset = (ngx_flag_t )-1;
#line 1544
  return ((void *)lcf);
}
}
#line 1548 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static char *ngx_http_charset_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_charset_loc_conf_t *prev ;
  ngx_http_charset_loc_conf_t *conf ;
  ngx_uint_t i ;
  ngx_http_charset_recode_t *recode ;
  ngx_http_charset_main_conf_t *mcf ;
  char *tmp ;
  void *tmp___0 ;

  {
  {
#line 1551
  prev = (ngx_http_charset_loc_conf_t *)parent;
#line 1552
  conf = (ngx_http_charset_loc_conf_t *)child;
#line 1558
  tmp = ngx_http_merge_types(cf, & conf->types_keys, & conf->types, & prev->types_keys,
                             & prev->types, ngx_http_charset_default_types);
  }
#line 1558
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1563
    return ((char *)((void *)-1));
  }
#line 1566
  if (conf->override_charset == -1L) {
#line 1566
    if (prev->override_charset == -1L) {
#line 1566
      conf->override_charset = (ngx_flag_t )0;
    } else {
#line 1566
      conf->override_charset = prev->override_charset;
    }
  }
#line 1567
  if (conf->charset == -1L) {
#line 1567
    if (prev->charset == -1L) {
#line 1567
      conf->charset = (ngx_int_t )-2;
    } else {
#line 1567
      conf->charset = prev->charset;
    }
  }
#line 1568
  if (conf->source_charset == -1L) {
#line 1568
    if (prev->source_charset == -1L) {
#line 1568
      conf->source_charset = (ngx_int_t )-2;
    } else {
#line 1568
      conf->source_charset = prev->source_charset;
    }
  }
#line 1571
  if (conf->charset == -2L) {
#line 1575
    return ((char *)((void *)0));
  } else
#line 1571
  if (conf->source_charset == -2L) {
#line 1575
    return ((char *)((void *)0));
  } else
#line 1571
  if (conf->charset == conf->source_charset) {
#line 1575
    return ((char *)((void *)0));
  }
#line 1578
  if (conf->source_charset >= 65536L) {
#line 1581
    return ((char *)((void *)0));
  } else
#line 1578
  if (conf->charset >= 65536L) {
#line 1581
    return ((char *)((void *)0));
  }
#line 1584
  mcf = (ngx_http_charset_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 1586
  recode = (ngx_http_charset_recode_t *)mcf->recodes.elts;
#line 1587
  i = (ngx_uint_t )0;
  {
#line 1587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1587
    if (! (i < mcf->recodes.nelts)) {
#line 1587
      goto while_break;
    }
#line 1588
    if (conf->source_charset == (recode + i)->src) {
#line 1588
      if (conf->charset == (recode + i)->dst) {
#line 1591
        return ((char *)((void *)0));
      }
    }
#line 1587
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1595
  tmp___0 = ngx_array_push(& mcf->recodes);
#line 1595
  recode = (ngx_http_charset_recode_t *)tmp___0;
  }
#line 1596
  if ((unsigned long )recode == (unsigned long )((void *)0)) {
#line 1597
    return ((char *)((void *)-1));
  }
#line 1600
  recode->src = conf->source_charset;
#line 1601
  recode->dst = conf->charset;
#line 1603
  return ((char *)((void *)0));
}
}
#line 1607 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_charset_filter_module.c"
static ngx_int_t ngx_http_charset_postconfiguration(ngx_conf_t *cf ) 
{ 
  u_char **src ;
  u_char **dst ;
  ngx_int_t c ;
  ngx_uint_t i ;
  ngx_uint_t t ;
  ngx_http_charset_t *charset ;
  ngx_http_charset_recode_t *recode ;
  ngx_http_charset_tables_t *tables ;
  ngx_http_charset_main_conf_t *mcf ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp13 ;

  {
#line 1618
  mcf = (ngx_http_charset_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_charset_filter_module.ctx_index);
#line 1621
  recode = (ngx_http_charset_recode_t *)mcf->recodes.elts;
#line 1622
  tables = (ngx_http_charset_tables_t *)mcf->tables.elts;
#line 1623
  charset = (ngx_http_charset_t *)mcf->charsets.elts;
#line 1625
  i = (ngx_uint_t )0;
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    if (! (i < mcf->recodes.nelts)) {
#line 1625
      goto while_break;
    }
#line 1627
    c = (recode + i)->src;
#line 1629
    t = (ngx_uint_t )0;
    {
#line 1629
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1629
      if (! (t < mcf->tables.nelts)) {
#line 1629
        goto while_break___0;
      }
#line 1631
      if (c == (tables + t)->src) {
#line 1631
        if ((recode + i)->dst == (tables + t)->dst) {
#line 1632
          goto next;
        }
      }
#line 1635
      if (c == (tables + t)->dst) {
#line 1635
        if ((recode + i)->dst == (tables + t)->src) {
#line 1636
          goto next;
        }
      }
#line 1629
      t ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1640
    if ((cf->log)->log_level >= 1UL) {
      {
#line 1640
      ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "no \"charset_map\" between the charsets \"%V\" and \"%V\"",
                         & (charset + c)->name, & (charset + (recode + i)->dst)->name);
      }
    }
#line 1643
    return ((ngx_int_t )-1);
    next: 
#line 1646
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1625
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1650
  t = (ngx_uint_t )0;
  {
#line 1650
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1650
    if (! (t < mcf->tables.nelts)) {
#line 1650
      goto while_break___1;
    }
#line 1652
    src = (charset + (tables + t)->src)->tables;
#line 1654
    if ((unsigned long )src == (unsigned long )((void *)0)) {
      {
#line 1655
      tmp = ngx_pcalloc(cf->pool, sizeof(u_char *) * mcf->charsets.nelts);
#line 1655
      src = (u_char **)tmp;
      }
#line 1656
      if ((unsigned long )src == (unsigned long )((void *)0)) {
#line 1657
        return ((ngx_int_t )-1);
      }
#line 1660
      (charset + (tables + t)->src)->tables = src;
    }
#line 1663
    dst = (charset + (tables + t)->dst)->tables;
#line 1665
    if ((unsigned long )dst == (unsigned long )((void *)0)) {
      {
#line 1666
      tmp___0 = ngx_pcalloc(cf->pool, sizeof(u_char *) * mcf->charsets.nelts);
#line 1666
      dst = (u_char **)tmp___0;
      }
#line 1667
      if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1668
        return ((ngx_int_t )-1);
      }
#line 1671
      (charset + (tables + t)->dst)->tables = dst;
    }
#line 1674
    *(src + (tables + t)->dst) = (tables + t)->src2dst;
#line 1675
    *(dst + (tables + t)->src) = (tables + t)->dst2src;
#line 1650
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1678
  ngx_http_next_header_filter___2 = ngx_http_top_header_filter;
#line 1679
  ngx_http_top_header_filter = & ngx_http_charset_header_filter;
#line 1681
  ngx_http_next_body_filter___1 = ngx_http_top_body_filter;
#line 1682
  ngx_http_top_body_filter = & ngx_http_charset_body_filter;
#line 1684
  return ((ngx_int_t )0);
}
}
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 58 "src/os/unix/ngx_time.h"
void ngx_libc_localtime(time_t s , struct tm *tm ) ;
#line 59
void ngx_libc_gmtime(time_t s , struct tm *tm ) ;
#line 68 "src/os/unix/ngx_process.h"
void ngx_debug_point(void) ;
#line 160 "src/core/ngx_buf.h"
ngx_int_t ngx_chain_add_copy(ngx_pool_t *pool , ngx_chain_t **chain , ngx_chain_t *in ) ;
#line 34 "src/core/ngx_list.h"
ngx_list_t *ngx_list_create(ngx_pool_t *pool , ngx_uint_t n , size_t size ) ;
#line 112 "src/core/ngx_hash.h"
ngx_uint_t ngx_hash_key(u_char *data , size_t len ) ;
#line 114
ngx_uint_t ngx_hash_strlow(u_char *dst , u_char *src , size_t n ) ;
#line 57 "src/http/ngx_http_variables.h"
ngx_http_variable_value_t *ngx_http_get_variable(ngx_http_request_t *r , ngx_str_t *name ,
                                                 ngx_uint_t key ) ;
#line 485 "src/http/ngx_http_core_module.h"
void ngx_http_weak_etag(ngx_http_request_t *r ) ;
#line 98 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ,
                                    ngx_uint_t *flags ) ;
#line 168
ngx_str_t ngx_http_html_default_types[2] ;
#line 73 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_output(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) ;
#line 75
static void ngx_http_ssi_buffered(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) ;
#line 77
static ngx_int_t ngx_http_ssi_parse(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) ;
#line 79
static ngx_str_t *ngx_http_ssi_get_variable(ngx_http_request_t *r , ngx_str_t *name ,
                                            ngx_uint_t key ) ;
#line 81
static ngx_int_t ngx_http_ssi_evaluate_string(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                              ngx_str_t *text , ngx_uint_t flags ) ;
#line 83
static ngx_int_t ngx_http_ssi_regex_match(ngx_http_request_t *r , ngx_str_t *pattern ,
                                          ngx_str_t *str ) ;
#line 86
static ngx_int_t ngx_http_ssi_include(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                      ngx_str_t **params ) ;
#line 88
static ngx_int_t ngx_http_ssi_stub_output(ngx_http_request_t *r , void *data , ngx_int_t rc ) ;
#line 90
static ngx_int_t ngx_http_ssi_set_variable(ngx_http_request_t *r , void *data , ngx_int_t rc ) ;
#line 92
static ngx_int_t ngx_http_ssi_echo(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                   ngx_str_t **params ) ;
#line 94
static ngx_int_t ngx_http_ssi_config(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                     ngx_str_t **params ) ;
#line 96
static ngx_int_t ngx_http_ssi_set(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                  ngx_str_t **params ) ;
#line 98
static ngx_int_t ngx_http_ssi_if(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                 ngx_str_t **params ) ;
#line 100
static ngx_int_t ngx_http_ssi_else(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                   ngx_str_t **params ) ;
#line 102
static ngx_int_t ngx_http_ssi_endif(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                    ngx_str_t **params ) ;
#line 104
static ngx_int_t ngx_http_ssi_block(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                    ngx_str_t **params ) ;
#line 106
static ngx_int_t ngx_http_ssi_endblock(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                       ngx_str_t **params ) ;
#line 109
static ngx_int_t ngx_http_ssi_date_gmt_local_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t gmt ) ;
#line 112
static ngx_int_t ngx_http_ssi_preconfiguration(ngx_conf_t *cf ) ;
#line 113
static void *ngx_http_ssi_create_main_conf(ngx_conf_t *cf ) ;
#line 114
static char *ngx_http_ssi_init_main_conf(ngx_conf_t *cf , void *conf ) ;
#line 115
static void *ngx_http_ssi_create_loc_conf(ngx_conf_t *cf ) ;
#line 116
static char *ngx_http_ssi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 118
static ngx_int_t ngx_http_ssi_filter_init(ngx_conf_t *cf ) ;
#line 121 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_command_t ngx_http_ssi_filter_commands[8]  = 
#line 121
  {      {{sizeof("ssi") - 1UL, (u_char *)"ssi"}, (ngx_uint_t )1308623360, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->enable),
      (void *)0}, 
        {{sizeof("ssi_silent_errors") - 1UL, (u_char *)"ssi_silent_errors"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->silent_errors), (void *)0}, 
        {{sizeof("ssi_ignore_recycled_buffers") - 1UL,
       (u_char *)"ssi_ignore_recycled_buffers"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->ignore_recycled_buffers),
      (void *)0}, 
        {{sizeof("ssi_min_file_chunk") - 1UL, (u_char *)"ssi_min_file_chunk"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->min_file_chunk), (void *)0}, 
        {{sizeof("ssi_value_length") - 1UL,
       (u_char *)"ssi_value_length"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->value_len),
      (void *)0}, 
        {{sizeof("ssi_types") - 1UL, (u_char *)"ssi_types"}, (ngx_uint_t )234883072,
      & ngx_http_types_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->types_keys), (void *)(& ngx_http_html_default_types[0])}, 
        {{sizeof("ssi_last_modified") - 1UL,
       (u_char *)"ssi_last_modified"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_ssi_loc_conf_t *)0)->last_modified),
      (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 178 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_module_t ngx_http_ssi_filter_module_ctx  = 
#line 178
     {& ngx_http_ssi_preconfiguration, & ngx_http_ssi_filter_init, & ngx_http_ssi_create_main_conf,
    & ngx_http_ssi_init_main_conf, (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf ,
                                                                                       void *prev ,
                                                                                       void *conf ))((void *)0),
    & ngx_http_ssi_create_loc_conf, & ngx_http_ssi_merge_loc_conf};
#line 193 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
ngx_module_t ngx_http_ssi_filter_module  = 
#line 193
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_ssi_filter_module_ctx),
    ngx_http_ssi_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 209 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___3)(ngx_http_request_t *r )  ;
#line 210 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___2)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 213 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static u_char ngx_http_ssi_string[5]  = {      (u_char )'<',      (u_char )'!',      (u_char )'-',      (u_char )'-', 
        (u_char )'\000'};
#line 215 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_str_t ngx_http_ssi_none  =    {sizeof("(none)") - 1UL, (u_char *)"(none)"};
#line 216 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_str_t ngx_http_ssi_timefmt  =    {sizeof("%A, %d-%b-%Y %H:%M:%S %Z") - 1UL, (u_char *)"%A, %d-%b-%Y %H:%M:%S %Z"};
#line 217 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_str_t ngx_http_ssi_null_string  =    {(size_t )0, (u_char *)((void *)0)};
#line 241 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_include_params[6]  = {      {{sizeof("virtual") - 1UL, (u_char *)"virtual"}, (ngx_uint_t )0, 0U, 0U}, 
        {{sizeof("file") - 1UL, (u_char *)"file"}, (ngx_uint_t )1, 0U, 0U}, 
        {{sizeof("wait") - 1UL, (u_char *)"wait"}, (ngx_uint_t )2, 0U, 0U}, 
        {{sizeof("set") - 1UL, (u_char *)"set"}, (ngx_uint_t )3, 0U, 0U}, 
        {{sizeof("stub") - 1UL, (u_char *)"stub"}, (ngx_uint_t )4, 0U, 0U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 251 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_echo_params[4]  = {      {{sizeof("var") - 1UL, (u_char *)"var"}, (ngx_uint_t )0, 1U, 0U}, 
        {{sizeof("default") - 1UL, (u_char *)"default"}, (ngx_uint_t )1, 0U, 0U}, 
        {{sizeof("encoding") - 1UL, (u_char *)"encoding"}, (ngx_uint_t )2, 0U, 0U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 259 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_config_params[3]  = {      {{sizeof("errmsg") - 1UL, (u_char *)"errmsg"}, (ngx_uint_t )0, 0U, 0U}, 
        {{sizeof("timefmt") - 1UL, (u_char *)"timefmt"}, (ngx_uint_t )1, 0U, 0U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 266 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_set_params[3]  = {      {{sizeof("var") - 1UL, (u_char *)"var"}, (ngx_uint_t )0, 1U, 0U}, 
        {{sizeof("value") - 1UL, (u_char *)"value"}, (ngx_uint_t )1, 1U, 0U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 273 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_if_params[2]  = {      {{sizeof("expr") - 1UL, (u_char *)"expr"}, (ngx_uint_t )0, 1U, 0U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 279 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_block_params[2]  = {      {{sizeof("name") - 1UL, (u_char *)"name"}, (ngx_uint_t )0, 1U, 0U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 285 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_param_t ngx_http_ssi_no_params[1]  = {      {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, 0U, 0U}};
#line 290 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_ssi_command_t ngx_http_ssi_commands[11]  = 
#line 290
  {      {{sizeof("include") - 1UL, (u_char *)"include"}, & ngx_http_ssi_include, ngx_http_ssi_include_params,
      0U, 0U, 1U}, 
        {{sizeof("echo") - 1UL, (u_char *)"echo"}, & ngx_http_ssi_echo, ngx_http_ssi_echo_params,
      0U, 0U, 0U}, 
        {{sizeof("config") - 1UL, (u_char *)"config"}, & ngx_http_ssi_config, ngx_http_ssi_config_params,
      0U, 0U, 0U}, 
        {{sizeof("set") - 1UL, (u_char *)"set"}, & ngx_http_ssi_set, ngx_http_ssi_set_params,
      0U, 0U, 0U}, 
        {{sizeof("if") - 1UL, (u_char *)"if"}, & ngx_http_ssi_if, ngx_http_ssi_if_params,
      0U, 0U, 0U}, 
        {{sizeof("elif") - 1UL, (u_char *)"elif"}, & ngx_http_ssi_if, ngx_http_ssi_if_params,
      1U, 0U, 0U}, 
        {{sizeof("else") - 1UL, (u_char *)"else"}, & ngx_http_ssi_else, ngx_http_ssi_no_params,
      1U, 0U, 0U}, 
        {{sizeof("endif") - 1UL, (u_char *)"endif"}, & ngx_http_ssi_endif, ngx_http_ssi_no_params,
      2U, 0U, 0U}, 
        {{sizeof("block") - 1UL, (u_char *)"block"}, & ngx_http_ssi_block, ngx_http_ssi_block_params,
      0U, 0U, 0U}, 
        {{sizeof("endblock") - 1UL, (u_char *)"endblock"}, & ngx_http_ssi_endblock, ngx_http_ssi_no_params,
      0U, 1U, 0U}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                          ngx_http_ssi_ctx_t *ctx ,
                                                          ngx_str_t ** ))((void *)0),
      (ngx_http_ssi_param_t *)((void *)0), 0U, 0U, 0U}};
#line 316 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_http_variable_t ngx_http_ssi_vars[3]  = {      {{sizeof("date_local") - 1UL, (u_char *)"date_local"}, (void (*)(ngx_http_request_t *r ,
                                                                      ngx_http_variable_value_t *v ,
                                                                      uintptr_t data ))((void *)0),
      & ngx_http_ssi_date_gmt_local_variable, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("date_gmt") - 1UL,
       (u_char *)"date_gmt"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ))((void *)0), & ngx_http_ssi_date_gmt_local_variable,
      (uintptr_t )1, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 329 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_http_ssi_ctx_t *ctx ;
  ngx_http_ssi_loc_conf_t *slcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 335
  slcf = (ngx_http_ssi_loc_conf_t *)*(r->loc_conf + ngx_http_ssi_filter_module.ctx_index);
#line 337
  if (! slcf->enable) {
    {
#line 341
    tmp = (*ngx_http_next_header_filter___3)(r);
    }
#line 341
    return (tmp);
  } else
#line 337
  if (r->headers_out.content_length_n == 0L) {
    {
#line 341
    tmp = (*ngx_http_next_header_filter___3)(r);
    }
#line 341
    return (tmp);
  } else {
    {
#line 337
    tmp___0 = ngx_http_test_content_type(r, & slcf->types);
    }
#line 337
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 341
      tmp = (*ngx_http_next_header_filter___3)(r);
      }
#line 341
      return (tmp);
    }
  }
  {
#line 344
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_http_ssi_ctx_t ));
#line 344
  ctx = (ngx_http_ssi_ctx_t *)tmp___1;
  }
#line 345
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 346
    return ((ngx_int_t )-1);
  }
#line 349
  *(r->ctx + ngx_http_ssi_filter_module.ctx_index) = (void *)ctx;
#line 352
  ctx->value_len = slcf->value_len;
#line 353
  ctx->last_out = & ctx->out;
#line 355
  ctx->encoding = 2U;
#line 356
  ctx->output = 1U;
#line 358
  ctx->params.elts = (void *)(ctx->params_array);
#line 359
  ctx->params.size = sizeof(ngx_table_elt_t );
#line 360
  ctx->params.nalloc = (ngx_uint_t )4;
#line 361
  ctx->params.pool = r->pool;
#line 363
  ctx->timefmt = ngx_http_ssi_timefmt;
#line 364
  ctx->errmsg.len = sizeof("[an error occurred while processing the directive]") - 1UL;
#line 364
  ctx->errmsg.data = (u_char *)"[an error occurred while processing the directive]";
#line 367
  r->filter_need_in_memory = 1U;
#line 369
  if ((unsigned long )r == (unsigned long )r->main) {
#line 370
    r->headers_out.content_length_n = (off_t )-1;
#line 370
    if (r->headers_out.content_length) {
#line 370
      (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 370
      r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
    }
#line 371
    r->allow_ranges = 0U;
#line 371
    if (r->headers_out.accept_ranges) {
#line 371
      (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 371
      r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
    }
#line 373
    r->preserve_body = 1U;
#line 375
    if (! slcf->last_modified) {
#line 376
      r->headers_out.last_modified_time = (time_t )-1;
#line 376
      if (r->headers_out.last_modified) {
#line 376
        (r->headers_out.last_modified)->hash = (ngx_uint_t )0;
#line 376
        r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
      }
#line 377
      if (r->headers_out.etag) {
#line 377
        (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 377
        r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
      }
    } else {
      {
#line 380
      ngx_http_weak_etag(r);
      }
    }
  }
  {
#line 384
  tmp___2 = (*ngx_http_next_header_filter___3)(r);
  }
#line 384
  return (tmp___2);
}
}
#line 388 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  size_t len ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_uint_t i ;
  ngx_uint_t index___0 ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_table_elt_t *param ;
  ngx_http_ssi_ctx_t *ctx ;
  ngx_http_ssi_ctx_t *mctx ;
  ngx_http_ssi_block_t *bl ;
  ngx_http_ssi_param_t *prm ;
  ngx_http_ssi_command_t *cmd ;
  ngx_http_ssi_loc_conf_t *slcf ;
  ngx_http_ssi_main_conf_t *smcf ;
  ngx_str_t *params[17] ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  void *tmp___12 ;
  u_char *tmp___13 ;
  void *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  void *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  u_char *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  int tmp___23 ;
  ngx_int_t tmp___24 ;
  void *tmp___25 ;
  void *tmp___26 ;
  ngx_int_t tmp___27 ;
  void *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;

  {
#line 405
  ctx = (ngx_http_ssi_ctx_t *)*(r->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 407
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 413
    tmp = (*ngx_http_next_body_filter___2)(r, in);
    }
#line 413
    return (tmp);
  } else
#line 407
  if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 407
    if ((unsigned long )ctx->buf == (unsigned long )((void *)0)) {
#line 407
      if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
#line 407
        if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
          {
#line 413
          tmp = (*ngx_http_next_body_filter___2)(r, in);
          }
#line 413
          return (tmp);
        }
      }
    }
  }
#line 418
  if (in) {
    {
#line 419
    tmp___0 = ngx_chain_add_copy(r->pool, & ctx->in, in);
    }
#line 419
    if (tmp___0 != 0L) {
#line 420
      return ((ngx_int_t )-1);
    }
  }
#line 427
  if (ctx->wait) {
#line 429
    if ((unsigned long )r != (unsigned long )(r->connection)->data) {
#line 434
      return ((ngx_int_t )-2);
    }
#line 437
    if ((ctx->wait)->done) {
#line 442
      ctx->wait = (ngx_http_request_t *)((void *)0);
    } else {
      {
#line 449
      tmp___1 = (*ngx_http_next_body_filter___2)(r, (ngx_chain_t *)((void *)0));
      }
#line 449
      return (tmp___1);
    }
  }
#line 453
  slcf = (ngx_http_ssi_loc_conf_t *)*(r->loc_conf + ngx_http_ssi_filter_module.ctx_index);
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (! ctx->in) {
#line 455
      if (! ctx->buf) {
#line 455
        goto while_break;
      }
    }
#line 457
    if ((unsigned long )ctx->buf == (unsigned long )((void *)0)) {
#line 458
      ctx->buf = (ctx->in)->buf;
#line 459
      ctx->in = (ctx->in)->next;
#line 460
      ctx->pos = (ctx->buf)->pos;
    }
#line 463
    if (ctx->state == 0UL) {
#line 464
      ctx->copy_start = ctx->pos;
#line 465
      ctx->copy_end = ctx->pos;
    }
#line 468
    b = (ngx_buf_t *)((void *)0);
    {
#line 470
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 470
      if (! ((unsigned long )ctx->pos < (unsigned long )(ctx->buf)->last)) {
#line 470
        goto while_break___0;
      }
      {
#line 475
      rc = ngx_http_ssi_parse(r, ctx);
      }
#line 481
      if (rc == -1L) {
#line 482
        return (rc);
      }
#line 485
      if ((unsigned long )ctx->copy_start != (unsigned long )ctx->copy_end) {
#line 487
        if (ctx->output) {
#line 492
          if (ctx->saved) {
#line 494
            if (ctx->free) {
              {
#line 495
              cl = ctx->free;
#line 496
              ctx->free = (ctx->free)->next;
#line 497
              b = cl->buf;
#line 498
              memset((void *)b, 0, sizeof(ngx_buf_t ));
              }
            } else {
              {
#line 501
              tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 501
              b = (ngx_buf_t *)tmp___2;
              }
#line 502
              if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 503
                return ((ngx_int_t )-1);
              }
              {
#line 506
              cl = ngx_alloc_chain_link(r->pool);
              }
#line 507
              if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 508
                return ((ngx_int_t )-1);
              }
#line 511
              cl->buf = b;
            }
#line 514
            b->memory = 1U;
#line 515
            b->pos = ngx_http_ssi_string;
#line 516
            b->last = ngx_http_ssi_string + ctx->saved;
#line 518
            *(ctx->last_out) = cl;
#line 519
            ctx->last_out = & cl->next;
#line 521
            ctx->saved = (size_t )0;
          }
#line 524
          if (ctx->free) {
#line 525
            cl = ctx->free;
#line 526
            ctx->free = (ctx->free)->next;
#line 527
            b = cl->buf;
          } else {
            {
#line 530
            tmp___3 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 530
            b = (ngx_buf_t *)tmp___3;
            }
#line 531
            if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 532
              return ((ngx_int_t )-1);
            }
            {
#line 535
            cl = ngx_alloc_chain_link(r->pool);
            }
#line 536
            if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 537
              return ((ngx_int_t )-1);
            }
#line 540
            cl->buf = b;
          }
          {
#line 543
          memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)ctx->buf,
                 sizeof(ngx_buf_t ));
#line 545
          b->pos = ctx->copy_start;
#line 546
          b->last = ctx->copy_end;
#line 547
          b->shadow = (ngx_buf_t *)((void *)0);
#line 548
          b->last_buf = 0U;
#line 549
          b->recycled = 0U;
          }
#line 551
          if (b->in_file) {
#line 552
            if (slcf->min_file_chunk < (size_t )(b->last - b->pos)) {
#line 554
              b->file_last = b->file_pos + (b->last - (ctx->buf)->pos);
#line 556
              b->file_pos += b->pos - (ctx->buf)->pos;
            } else {
#line 559
              b->in_file = 0U;
            }
          }
#line 563
          cl->next = (ngx_chain_t *)((void *)0);
#line 564
          *(ctx->last_out) = cl;
#line 565
          ctx->last_out = & cl->next;
        } else {
#line 568
          if (ctx->block) {
#line 568
            if (ctx->saved + (size_t )(ctx->copy_end - ctx->copy_start)) {
              {
#line 571
              b = ngx_create_temp_buf(r->pool, ctx->saved + (size_t )(ctx->copy_end - ctx->copy_start));
              }
#line 574
              if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 575
                return ((ngx_int_t )-1);
              }
#line 578
              if (ctx->saved) {
                {
#line 579
                tmp___4 = memcpy((void */* __restrict  */)b->pos, (void const   */* __restrict  */)(ngx_http_ssi_string),
                                 ctx->saved);
#line 579
                b->last = (u_char *)tmp___4 + ctx->saved;
                }
              }
              {
#line 583
              tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ctx->copy_start,
                               (size_t )(ctx->copy_end - ctx->copy_start));
#line 583
              b->last = (u_char *)tmp___5 + (ctx->copy_end - ctx->copy_start);
#line 586
              cl = ngx_alloc_chain_link(r->pool);
              }
#line 587
              if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 588
                return ((ngx_int_t )-1);
              }
#line 591
              cl->buf = b;
#line 592
              cl->next = (ngx_chain_t *)((void *)0);
#line 594
              b = (ngx_buf_t *)((void *)0);
#line 596
              mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 598
              bl = (ngx_http_ssi_block_t *)(mctx->blocks)->elts;
#line 599
              ll = & (bl + ((mctx->blocks)->nelts - 1UL))->bufs;
              {
#line 599
              while (1) {
                while_continue___1: /* CIL Label */ ;
#line 599
                if (! *ll) {
#line 599
                  goto while_break___1;
                }
#line 599
                ll = & (*ll)->next;
              }
              while_break___1: /* CIL Label */ ;
              }
#line 606
              *ll = cl;
            }
          }
#line 609
          ctx->saved = (size_t )0;
        }
      }
#line 613
      if (ctx->state == 0UL) {
#line 614
        ctx->copy_start = ctx->pos;
#line 615
        ctx->copy_end = ctx->pos;
      } else {
#line 618
        ctx->copy_start = (u_char *)((void *)0);
#line 619
        ctx->copy_end = (u_char *)((void *)0);
      }
#line 622
      if (rc == -2L) {
#line 623
        goto while_continue___0;
      }
#line 627
      b = (ngx_buf_t *)((void *)0);
#line 629
      if (rc == 0L) {
        {
#line 631
        smcf = (ngx_http_ssi_main_conf_t *)*(r->main_conf + ngx_http_ssi_filter_module.ctx_index);
#line 634
        tmp___6 = ngx_hash_find(& smcf->hash, ctx->key, ctx->command.data, ctx->command.len);
#line 634
        cmd = (ngx_http_ssi_command_t *)tmp___6;
        }
#line 637
        if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 638
          if (ctx->output) {
#line 639
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 639
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid SSI command: \"%V\"",
                                 & ctx->command);
              }
            }
#line 642
            goto ssi_error;
          }
#line 645
          goto while_continue___0;
        }
#line 648
        if (! ctx->output) {
#line 648
          if (! cmd->block) {
#line 650
            if (ctx->block) {
#line 654
              len = (5UL + ctx->command.len) + 4UL;
#line 656
              param = (ngx_table_elt_t *)ctx->params.elts;
#line 657
              i = (ngx_uint_t )0;
              {
#line 657
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 657
                if (! (i < ctx->params.nelts)) {
#line 657
                  goto while_break___2;
                }
#line 658
                len += (((1UL + (param + i)->key.len) + 2UL) + (param + i)->value.len) + 1UL;
#line 657
                i ++;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 662
              b = ngx_create_temp_buf(r->pool, len);
              }
#line 664
              if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 665
                return ((ngx_int_t )-1);
              }
              {
#line 668
              cl = ngx_alloc_chain_link(r->pool);
              }
#line 669
              if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 670
                return ((ngx_int_t )-1);
              }
              {
#line 673
              cl->buf = b;
#line 674
              cl->next = (ngx_chain_t *)((void *)0);
#line 676
              tmp___7 = b->last;
#line 676
              (b->last) ++;
#line 676
              *tmp___7 = (u_char )'<';
#line 677
              tmp___8 = b->last;
#line 677
              (b->last) ++;
#line 677
              *tmp___8 = (u_char )'!';
#line 678
              tmp___9 = b->last;
#line 678
              (b->last) ++;
#line 678
              *tmp___9 = (u_char )'-';
#line 679
              tmp___10 = b->last;
#line 679
              (b->last) ++;
#line 679
              *tmp___10 = (u_char )'-';
#line 680
              tmp___11 = b->last;
#line 680
              (b->last) ++;
#line 680
              *tmp___11 = (u_char )'#';
#line 682
              tmp___12 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ctx->command.data,
                                ctx->command.len);
#line 682
              b->last = (u_char *)tmp___12 + ctx->command.len;
#line 685
              i = (ngx_uint_t )0;
              }
              {
#line 685
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 685
                if (! (i < ctx->params.nelts)) {
#line 685
                  goto while_break___3;
                }
                {
#line 686
                tmp___13 = b->last;
#line 686
                (b->last) ++;
#line 686
                *tmp___13 = (u_char )' ';
#line 687
                tmp___14 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(param + i)->key.data,
                                  (param + i)->key.len);
#line 687
                b->last = (u_char *)tmp___14 + (param + i)->key.len;
#line 689
                tmp___15 = b->last;
#line 689
                (b->last) ++;
#line 689
                *tmp___15 = (u_char )'=';
#line 690
                tmp___16 = b->last;
#line 690
                (b->last) ++;
#line 690
                *tmp___16 = (u_char )'\"';
#line 691
                tmp___17 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(param + i)->value.data,
                                  (param + i)->value.len);
#line 691
                b->last = (u_char *)tmp___17 + (param + i)->value.len;
#line 693
                tmp___18 = b->last;
#line 693
                (b->last) ++;
#line 693
                *tmp___18 = (u_char )'\"';
#line 685
                i ++;
                }
              }
              while_break___3: /* CIL Label */ ;
              }
#line 696
              tmp___19 = b->last;
#line 696
              (b->last) ++;
#line 696
              *tmp___19 = (u_char )' ';
#line 697
              tmp___20 = b->last;
#line 697
              (b->last) ++;
#line 697
              *tmp___20 = (u_char )'-';
#line 698
              tmp___21 = b->last;
#line 698
              (b->last) ++;
#line 698
              *tmp___21 = (u_char )'-';
#line 699
              tmp___22 = b->last;
#line 699
              (b->last) ++;
#line 699
              *tmp___22 = (u_char )'>';
#line 701
              mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 703
              bl = (ngx_http_ssi_block_t *)(mctx->blocks)->elts;
#line 704
              ll = & (bl + ((mctx->blocks)->nelts - 1UL))->bufs;
              {
#line 704
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 704
                if (! *ll) {
#line 704
                  goto while_break___4;
                }
#line 704
                ll = & (*ll)->next;
              }
              while_break___4: /* CIL Label */ ;
              }
#line 711
              *ll = cl;
#line 713
              b = (ngx_buf_t *)((void *)0);
#line 715
              goto while_continue___0;
            }
#line 718
            if (cmd->conditional == 0U) {
#line 719
              goto while_continue___0;
            }
          }
        }
#line 723
        if (cmd->conditional) {
#line 723
          if (ctx->conditional == 0U) {
#line 723
            goto _L;
          } else
#line 723
          if (ctx->conditional > cmd->conditional) {
            _L: /* CIL Label */ 
#line 727
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 727
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid context of SSI command: \"%V\"",
                                 & ctx->command);
              }
            }
#line 730
            goto ssi_error;
          }
        }
#line 733
        if (ctx->params.nelts > 16UL) {
#line 734
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 734
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too many SSI command parameters: \"%V\"",
                               & ctx->command);
            }
          }
#line 737
          goto ssi_error;
        }
        {
#line 740
        memset((void *)(params), 0, 17UL * sizeof(ngx_str_t *));
#line 743
        param = (ngx_table_elt_t *)ctx->params.elts;
#line 745
        i = (ngx_uint_t )0;
        }
        {
#line 745
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 745
          if (! (i < ctx->params.nelts)) {
#line 745
            goto while_break___5;
          }
#line 747
          prm = cmd->params;
          {
#line 747
          while (1) {
            while_continue___6: /* CIL Label */ ;
#line 747
            if (! prm->name.len) {
#line 747
              goto while_break___6;
            }
#line 749
            if ((param + i)->key.len != prm->name.len) {
#line 753
              goto __Cont;
            } else {
              {
#line 749
              tmp___23 = strncmp((char const   *)(param + i)->key.data, (char const   *)prm->name.data,
                                 prm->name.len);
              }
#line 749
              if (tmp___23 != 0) {
#line 753
                goto __Cont;
              }
            }
#line 756
            if (! prm->multiple) {
#line 757
              if (params[prm->index]) {
#line 758
                if (((r->connection)->log)->log_level >= 4UL) {
                  {
#line 758
                  ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "duplicate \"%V\" parameter in \"%V\" SSI command",
                                     & (param + i)->key, & ctx->command);
                  }
                }
#line 764
                goto ssi_error;
              }
#line 767
              params[prm->index] = & (param + i)->value;
#line 769
              goto while_break___6;
            }
#line 772
            index___0 = prm->index;
            {
#line 772
            while (1) {
              while_continue___7: /* CIL Label */ ;
#line 772
              if (! params[index___0]) {
#line 772
                goto while_break___7;
              }
#line 772
              index___0 ++;
            }
            while_break___7: /* CIL Label */ ;
            }
#line 776
            params[index___0] = & (param + i)->value;
#line 778
            goto while_break___6;
            __Cont: /* CIL Label */ 
#line 747
            prm ++;
          }
          while_break___6: /* CIL Label */ ;
          }
#line 781
          if (prm->name.len == 0UL) {
#line 782
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 782
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid parameter name: \"%V\" in \"%V\" SSI command",
                                 & (param + i)->key, & ctx->command);
              }
            }
#line 787
            goto ssi_error;
          }
#line 745
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 791
        prm = cmd->params;
        {
#line 791
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 791
          if (! prm->name.len) {
#line 791
            goto while_break___8;
          }
#line 792
          if (prm->mandatory) {
#line 792
            if ((unsigned long )params[prm->index] == (unsigned long )((ngx_str_t *)0)) {
#line 793
              if (((r->connection)->log)->log_level >= 4UL) {
                {
#line 793
                ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "mandatory \"%V\" parameter is absent in \"%V\" SSI command",
                                   & prm->name, & ctx->command);
                }
              }
#line 798
              goto ssi_error;
            }
          }
#line 791
          prm ++;
        }
        while_break___8: /* CIL Label */ ;
        }
#line 802
        if (cmd->flush) {
#line 802
          if (ctx->out) {
            {
#line 807
            tmp___24 = ngx_http_ssi_output(r, ctx);
            }
#line 807
            if (tmp___24 == -1L) {
#line 808
              return ((ngx_int_t )-1);
            }
          }
        }
        {
#line 812
        rc = (*(cmd->handler))(r, ctx, params);
        }
#line 814
        if (rc == 0L) {
#line 815
          goto while_continue___0;
        }
#line 818
        if (rc == -4L) {
          {
#line 819
          ngx_http_ssi_buffered(r, ctx);
          }
#line 820
          return (rc);
        } else
#line 818
        if (rc == -2L) {
          {
#line 819
          ngx_http_ssi_buffered(r, ctx);
          }
#line 820
          return (rc);
        } else
#line 818
        if (rc == -1L) {
          {
#line 819
          ngx_http_ssi_buffered(r, ctx);
          }
#line 820
          return (rc);
        }
      }
      ssi_error: 
#line 829
      if (slcf->silent_errors) {
#line 830
        goto while_continue___0;
      }
#line 833
      if (ctx->free) {
        {
#line 834
        cl = ctx->free;
#line 835
        ctx->free = (ctx->free)->next;
#line 836
        b = cl->buf;
#line 837
        memset((void *)b, 0, sizeof(ngx_buf_t ));
        }
      } else {
        {
#line 840
        tmp___25 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 840
        b = (ngx_buf_t *)tmp___25;
        }
#line 841
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 842
          return ((ngx_int_t )-1);
        }
        {
#line 845
        cl = ngx_alloc_chain_link(r->pool);
        }
#line 846
        if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 847
          return ((ngx_int_t )-1);
        }
#line 850
        cl->buf = b;
      }
#line 853
      b->memory = 1U;
#line 854
      b->pos = ctx->errmsg.data;
#line 855
      b->last = ctx->errmsg.data + ctx->errmsg.len;
#line 857
      cl->next = (ngx_chain_t *)((void *)0);
#line 858
      *(ctx->last_out) = cl;
#line 859
      ctx->last_out = & cl->next;
#line 861
      goto while_continue___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 864
    if ((ctx->buf)->last_buf) {
#line 864
      goto _L___1;
    } else
#line 864
    if ((ctx->buf)->temporary) {
#line 864
      goto _L___1;
    } else
#line 864
    if ((ctx->buf)->memory) {
#line 864
      goto _L___1;
    } else
#line 864
    if ((ctx->buf)->mmap) {
      _L___1: /* CIL Label */ 
#line 865
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 866
        if (ctx->free) {
          {
#line 867
          cl = ctx->free;
#line 868
          ctx->free = (ctx->free)->next;
#line 869
          b = cl->buf;
#line 870
          memset((void *)b, 0, sizeof(ngx_buf_t ));
          }
        } else {
          {
#line 873
          tmp___26 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 873
          b = (ngx_buf_t *)tmp___26;
          }
#line 874
          if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 875
            return ((ngx_int_t )-1);
          }
          {
#line 878
          cl = ngx_alloc_chain_link(r->pool);
          }
#line 879
          if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 880
            return ((ngx_int_t )-1);
          }
#line 883
          cl->buf = b;
        }
#line 886
        b->sync = 1U;
#line 888
        cl->next = (ngx_chain_t *)((void *)0);
#line 889
        *(ctx->last_out) = cl;
#line 890
        ctx->last_out = & cl->next;
      }
#line 893
      b->last_buf = (ctx->buf)->last_buf;
#line 894
      b->shadow = ctx->buf;
#line 896
      if (slcf->ignore_recycled_buffers == 0L) {
#line 897
        b->recycled = (ctx->buf)->recycled;
      }
    }
#line 901
    ctx->buf = (ngx_buf_t *)((void *)0);
#line 903
    ctx->saved = ctx->looked;
  }
  while_break: /* CIL Label */ ;
  }
#line 906
  if ((unsigned long )ctx->out == (unsigned long )((void *)0)) {
#line 906
    if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
#line 907
      return ((ngx_int_t )0);
    }
  }
  {
#line 910
  tmp___27 = ngx_http_ssi_output(r, ctx);
  }
#line 910
  return (tmp___27);
}
}
#line 914 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_output(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) 
{ 
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  off_t tmp ;
  char *__cil_tmp7 ;

  {
#line 922
  b = (ngx_buf_t *)((void *)0);
#line 923
  cl = ctx->out;
  {
#line 923
  while (1) {
    while_continue: /* CIL Label */ ;
#line 923
    if (! cl) {
#line 923
      goto while_break;
    }
#line 926
    if ((unsigned long )cl->buf == (unsigned long )b) {
#line 927
      if (((r->connection)->log)->log_level >= 2UL) {
        {
#line 927
        ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "the same buf was used in ssi");
        }
      }
      {
#line 929
      ngx_debug_point();
      }
#line 930
      return ((ngx_int_t )-1);
    }
#line 932
    b = cl->buf;
#line 923
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 936
  rc = (*ngx_http_next_body_filter___2)(r, ctx->out);
  }
#line 938
  if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
#line 939
    ctx->busy = ctx->out;
  } else {
#line 942
    cl = ctx->busy;
    {
#line 942
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 942
      if (! cl->next) {
#line 942
        goto while_break___0;
      }
#line 942
      cl = cl->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 943
    cl->next = ctx->out;
  }
#line 946
  ctx->out = (ngx_chain_t *)((void *)0);
#line 947
  ctx->last_out = & ctx->out;
  {
#line 949
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 949
    if (! ctx->busy) {
#line 949
      goto while_break___1;
    }
#line 951
    cl = ctx->busy;
#line 952
    b = cl->buf;
#line 954
    if (b->temporary) {
#line 954
      tmp = b->last - b->pos;
    } else
#line 954
    if (b->memory) {
#line 954
      tmp = b->last - b->pos;
    } else
#line 954
    if (b->mmap) {
#line 954
      tmp = b->last - b->pos;
    } else {
#line 954
      tmp = b->file_last - b->file_pos;
    }
#line 954
    if (tmp != 0L) {
#line 955
      goto while_break___1;
    }
#line 958
    if (b->shadow) {
#line 959
      (b->shadow)->pos = (b->shadow)->last;
    }
#line 962
    ctx->busy = cl->next;
#line 964
    if (b->temporary) {
#line 967
      cl->next = ctx->free;
#line 968
      ctx->free = cl;
    } else
#line 964
    if (b->memory) {
#line 967
      cl->next = ctx->free;
#line 968
      ctx->free = cl;
    } else
#line 964
    if (b->mmap) {
#line 967
      cl->next = ctx->free;
#line 968
      ctx->free = cl;
    } else
#line 964
    if (b->in_file) {
#line 967
      cl->next = ctx->free;
#line 968
      ctx->free = cl;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 972
  ngx_http_ssi_buffered(r, ctx);
  }
#line 974
  return (rc);
}
}
#line 978 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static void ngx_http_ssi_buffered(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) 
{ 


  {
#line 981
  if (ctx->in) {
#line 982
    r->buffered |= 1U;
  } else
#line 981
  if (ctx->buf) {
#line 982
    r->buffered |= 1U;
  } else {
#line 985
    r->buffered &= 4294967294U;
  }
#line 987
  return;
}
}
#line 990 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_parse(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ) 
{ 
  u_char *p ;
  u_char *value ;
  u_char *last ;
  u_char *copy_end ;
  u_char ch ;
  size_t looked ;
  ngx_http_ssi_state_e state ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  void *tmp___9 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 997
  state = (ngx_http_ssi_state_e )ctx->state;
#line 998
  looked = ctx->looked;
#line 999
  last = (ctx->buf)->last;
#line 1000
  copy_end = ctx->copy_end;
#line 1002
  p = ctx->pos;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 1002
      goto while_break;
    }
#line 1004
    ch = *p;
#line 1006
    if ((unsigned int )state == 0U) {
      {
#line 1010
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1011
        if ((int )ch == 60) {
#line 1012
          copy_end = p;
#line 1013
          looked = (size_t )1;
#line 1014
          state = (ngx_http_ssi_state_e )1;
#line 1016
          goto tag_started;
        }
#line 1019
        p ++;
#line 1019
        if ((unsigned long )p == (unsigned long )last) {
#line 1020
          goto while_break___0;
        }
#line 1023
        ch = *p;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1026
      ctx->state = (ngx_uint_t )state;
#line 1027
      ctx->pos = p;
#line 1028
      ctx->looked = looked;
#line 1029
      ctx->copy_end = p;
#line 1031
      if ((unsigned long )ctx->copy_start == (unsigned long )((void *)0)) {
#line 1032
        ctx->copy_start = (ctx->buf)->pos;
      }
#line 1035
      return ((ngx_int_t )-2);
      tag_started: 
#line 1039
      goto __Cont;
    }
    {
#line 1044
    if ((unsigned int )state == 0U) {
#line 1044
      goto case_0;
    }
#line 1048
    if ((unsigned int )state == 1U) {
#line 1048
      goto case_1;
    }
#line 1068
    if ((unsigned int )state == 2U) {
#line 1068
      goto case_2;
    }
#line 1090
    if ((unsigned int )state == 3U) {
#line 1090
      goto case_3;
    }
#line 1112
    if ((unsigned int )state == 4U) {
#line 1112
      goto case_4;
    }
#line 1137
    if ((unsigned int )state == 5U) {
#line 1137
      goto case_5;
    }
#line 1166
    if ((unsigned int )state == 6U) {
#line 1166
      goto case_6;
    }
#line 1195
    if ((unsigned int )state == 7U) {
#line 1195
      goto case_7;
    }
#line 1241
    if ((unsigned int )state == 8U) {
#line 1241
      goto case_8;
    }
#line 1278
    if ((unsigned int )state == 9U) {
#line 1278
      goto case_9___3;
    }
#line 1306
    if ((unsigned int )state == 10U) {
#line 1306
      goto case_10___4;
    }
#line 1338
    if ((unsigned int )state == 11U) {
#line 1338
      goto case_11;
    }
#line 1366
    if ((unsigned int )state == 12U) {
#line 1366
      goto case_12;
    }
#line 1394
    if ((unsigned int )state == 13U) {
#line 1394
      goto case_13___5;
    }
#line 1411
    if ((unsigned int )state == 14U) {
#line 1411
      goto case_14;
    }
#line 1453
    if ((unsigned int )state == 15U) {
#line 1453
      goto case_15;
    }
#line 1469
    if ((unsigned int )state == 16U) {
#line 1469
      goto case_16;
    }
#line 1493
    if ((unsigned int )state == 17U) {
#line 1493
      goto case_17;
    }
#line 1505
    if ((unsigned int )state == 18U) {
#line 1505
      goto case_18;
    }
#line 1518
    if ((unsigned int )state == 19U) {
#line 1518
      goto case_19;
    }
#line 1042
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1046
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1050
    if ((int )ch == 33) {
#line 1050
      goto case_33;
    }
#line 1055
    if ((int )ch == 60) {
#line 1055
      goto case_60;
    }
#line 1059
    goto switch_default;
    case_33: /* CIL Label */ 
#line 1051
    looked = (size_t )2;
#line 1052
    state = (ngx_http_ssi_state_e )2;
#line 1053
    goto switch_break___0;
    case_60: /* CIL Label */ 
#line 1056
    copy_end = p;
#line 1057
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1060
    copy_end = p;
#line 1061
    looked = (size_t )0;
#line 1062
    state = (ngx_http_ssi_state_e )0;
#line 1063
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1066
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1070
    if ((int )ch == 45) {
#line 1070
      goto case_45;
    }
#line 1075
    if ((int )ch == 60) {
#line 1075
      goto case_60___0;
    }
#line 1081
    goto switch_default___0;
    case_45: /* CIL Label */ 
#line 1071
    looked = (size_t )3;
#line 1072
    state = (ngx_http_ssi_state_e )3;
#line 1073
    goto switch_break___1;
    case_60___0: /* CIL Label */ 
#line 1076
    copy_end = p;
#line 1077
    looked = (size_t )1;
#line 1078
    state = (ngx_http_ssi_state_e )1;
#line 1079
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 1082
    copy_end = p;
#line 1083
    looked = (size_t )0;
#line 1084
    state = (ngx_http_ssi_state_e )0;
#line 1085
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1088
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1092
    if ((int )ch == 45) {
#line 1092
      goto case_45___0;
    }
#line 1097
    if ((int )ch == 60) {
#line 1097
      goto case_60___1;
    }
#line 1103
    goto switch_default___1;
    case_45___0: /* CIL Label */ 
#line 1093
    looked = (size_t )4;
#line 1094
    state = (ngx_http_ssi_state_e )4;
#line 1095
    goto switch_break___2;
    case_60___1: /* CIL Label */ 
#line 1098
    copy_end = p;
#line 1099
    looked = (size_t )1;
#line 1100
    state = (ngx_http_ssi_state_e )1;
#line 1101
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 1104
    copy_end = p;
#line 1105
    looked = (size_t )0;
#line 1106
    state = (ngx_http_ssi_state_e )0;
#line 1107
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1110
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1114
    if ((int )ch == 35) {
#line 1114
      goto case_35;
    }
#line 1122
    if ((int )ch == 60) {
#line 1122
      goto case_60___2;
    }
#line 1128
    goto switch_default___2;
    case_35: /* CIL Label */ 
#line 1115
    if (p - ctx->pos < 4L) {
#line 1116
      ctx->saved = (size_t )0;
    }
#line 1118
    looked = (size_t )0;
#line 1119
    state = (ngx_http_ssi_state_e )5;
#line 1120
    goto switch_break___3;
    case_60___2: /* CIL Label */ 
#line 1123
    copy_end = p;
#line 1124
    looked = (size_t )1;
#line 1125
    state = (ngx_http_ssi_state_e )1;
#line 1126
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 1129
    copy_end = p;
#line 1130
    looked = (size_t )0;
#line 1131
    state = (ngx_http_ssi_state_e )0;
#line 1132
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1135
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1142
    if ((int )ch == 9) {
#line 1142
      goto case_9;
    }
#line 1142
    if ((int )ch == 10) {
#line 1142
      goto case_9;
    }
#line 1142
    if ((int )ch == 13) {
#line 1142
      goto case_9;
    }
#line 1142
    if ((int )ch == 32) {
#line 1142
      goto case_9;
    }
#line 1145
    goto switch_default___3;
    case_9: /* CIL Label */ 
    case_10: /* CIL Label */ 
    case_13: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 1143
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 1146
    ctx->command.len = (size_t )1;
#line 1147
    tmp = ngx_pnalloc(r->pool, (size_t )32);
#line 1147
    ctx->command.data = (u_char *)tmp;
    }
#line 1149
    if ((unsigned long )ctx->command.data == (unsigned long )((void *)0)) {
#line 1150
      return ((ngx_int_t )-1);
    }
#line 1153
    *(ctx->command.data + 0) = ch;
#line 1155
    ctx->key = (ngx_uint_t )0;
#line 1156
    ctx->key = ctx->key * 31UL + (ngx_uint_t )ch;
#line 1158
    ctx->params.nelts = (ngx_uint_t )0;
#line 1160
    state = (ngx_http_ssi_state_e )6;
#line 1161
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1164
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1171
    if ((int )ch == 9) {
#line 1171
      goto case_9___0;
    }
#line 1171
    if ((int )ch == 10) {
#line 1171
      goto case_9___0;
    }
#line 1171
    if ((int )ch == 13) {
#line 1171
      goto case_9___0;
    }
#line 1171
    if ((int )ch == 32) {
#line 1171
      goto case_9___0;
    }
#line 1175
    if ((int )ch == 45) {
#line 1175
      goto case_45___1;
    }
#line 1179
    goto switch_default___4;
    case_9___0: /* CIL Label */ 
    case_10___0: /* CIL Label */ 
    case_13___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
#line 1172
    state = (ngx_http_ssi_state_e )7;
#line 1173
    goto switch_break___5;
    case_45___1: /* CIL Label */ 
#line 1176
    state = (ngx_http_ssi_state_e )15;
#line 1177
    goto switch_break___5;
    switch_default___4: /* CIL Label */ 
#line 1180
    if (ctx->command.len == 32UL) {
#line 1181
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1181
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the \"%V%c...\" SSI command is too long",
                           & ctx->command, (int )ch);
        }
      }
#line 1185
      state = (ngx_http_ssi_state_e )17;
#line 1186
      goto switch_break___5;
    }
#line 1189
    tmp___0 = ctx->command.len;
#line 1189
    (ctx->command.len) ++;
#line 1189
    *(ctx->command.data + tmp___0) = ch;
#line 1190
    ctx->key = ctx->key * 31UL + (ngx_uint_t )ch;
    switch_break___5: /* CIL Label */ ;
    }
#line 1193
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1200
    if ((int )ch == 9) {
#line 1200
      goto case_9___1;
    }
#line 1200
    if ((int )ch == 10) {
#line 1200
      goto case_9___1;
    }
#line 1200
    if ((int )ch == 13) {
#line 1200
      goto case_9___1;
    }
#line 1200
    if ((int )ch == 32) {
#line 1200
      goto case_9___1;
    }
#line 1203
    if ((int )ch == 45) {
#line 1203
      goto case_45___2;
    }
#line 1207
    goto switch_default___5;
    case_9___1: /* CIL Label */ 
    case_10___1: /* CIL Label */ 
    case_13___1: /* CIL Label */ 
    case_32___1: /* CIL Label */ 
#line 1201
    goto switch_break___6;
    case_45___2: /* CIL Label */ 
#line 1204
    state = (ngx_http_ssi_state_e )15;
#line 1205
    goto switch_break___6;
    switch_default___5: /* CIL Label */ 
    {
#line 1208
    tmp___1 = ngx_array_push(& ctx->params);
#line 1208
    ctx->param = (ngx_table_elt_t *)tmp___1;
    }
#line 1209
    if ((unsigned long )ctx->param == (unsigned long )((void *)0)) {
#line 1210
      return ((ngx_int_t )-1);
    }
    {
#line 1213
    (ctx->param)->key.len = (size_t )1;
#line 1214
    tmp___2 = ngx_pnalloc(r->pool, (size_t )32);
#line 1214
    (ctx->param)->key.data = (u_char *)tmp___2;
    }
#line 1216
    if ((unsigned long )(ctx->param)->key.data == (unsigned long )((void *)0)) {
#line 1217
      return ((ngx_int_t )-1);
    }
#line 1220
    *((ctx->param)->key.data + 0) = ch;
#line 1222
    (ctx->param)->value.len = (size_t )0;
#line 1224
    if ((unsigned long )ctx->value_buf == (unsigned long )((void *)0)) {
      {
#line 1225
      tmp___3 = ngx_pnalloc(r->pool, ctx->value_len + 1UL);
#line 1225
      (ctx->param)->value.data = (u_char *)tmp___3;
      }
#line 1227
      if ((unsigned long )(ctx->param)->value.data == (unsigned long )((void *)0)) {
#line 1228
        return ((ngx_int_t )-1);
      }
    } else {
#line 1232
      (ctx->param)->value.data = (u_char *)ctx->value_buf;
    }
#line 1235
    state = (ngx_http_ssi_state_e )8;
#line 1236
    goto switch_break___6;
    switch_break___6: /* CIL Label */ ;
    }
#line 1239
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 1246
    if ((int )ch == 9) {
#line 1246
      goto case_9___2;
    }
#line 1246
    if ((int )ch == 10) {
#line 1246
      goto case_9___2;
    }
#line 1246
    if ((int )ch == 13) {
#line 1246
      goto case_9___2;
    }
#line 1246
    if ((int )ch == 32) {
#line 1246
      goto case_9___2;
    }
#line 1250
    if ((int )ch == 61) {
#line 1250
      goto case_61;
    }
#line 1254
    if ((int )ch == 45) {
#line 1254
      goto case_45___3;
    }
#line 1263
    goto switch_default___6;
    case_9___2: /* CIL Label */ 
    case_10___2: /* CIL Label */ 
    case_13___2: /* CIL Label */ 
    case_32___2: /* CIL Label */ 
#line 1247
    state = (ngx_http_ssi_state_e )9;
#line 1248
    goto switch_break___7;
    case_61: /* CIL Label */ 
#line 1251
    state = (ngx_http_ssi_state_e )10;
#line 1252
    goto switch_break___7;
    case_45___3: /* CIL Label */ 
#line 1255
    state = (ngx_http_ssi_state_e )18;
#line 1257
    tmp___4 = (ctx->param)->key.len;
#line 1257
    ((ctx->param)->key.len) ++;
#line 1257
    *((ctx->param)->key.data + tmp___4) = ch;
#line 1258
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1258
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid \"%V\" parameter in \"%V\" SSI command",
                         & (ctx->param)->key, & ctx->command);
      }
    }
#line 1261
    goto switch_break___7;
    switch_default___6: /* CIL Label */ 
#line 1264
    if ((ctx->param)->key.len == 32UL) {
#line 1265
      state = (ngx_http_ssi_state_e )17;
#line 1266
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1266
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too long \"%V%c...\" parameter in \"%V\" SSI command",
                           & (ctx->param)->key, (int )ch, & ctx->command);
        }
      }
#line 1270
      goto switch_break___7;
    }
#line 1273
    tmp___5 = (ctx->param)->key.len;
#line 1273
    ((ctx->param)->key.len) ++;
#line 1273
    *((ctx->param)->key.data + tmp___5) = ch;
    switch_break___7: /* CIL Label */ ;
    }
#line 1276
    goto switch_break;
    case_9___3: /* CIL Label */ 
    {
#line 1283
    if ((int )ch == 9) {
#line 1283
      goto case_9___4;
    }
#line 1283
    if ((int )ch == 10) {
#line 1283
      goto case_9___4;
    }
#line 1283
    if ((int )ch == 13) {
#line 1283
      goto case_9___4;
    }
#line 1283
    if ((int )ch == 32) {
#line 1283
      goto case_9___4;
    }
#line 1286
    if ((int )ch == 61) {
#line 1286
      goto case_61___0;
    }
#line 1290
    goto switch_default___7;
    case_9___4: /* CIL Label */ 
    case_10___3: /* CIL Label */ 
    case_13___3: /* CIL Label */ 
    case_32___3: /* CIL Label */ 
#line 1284
    goto switch_break___8;
    case_61___0: /* CIL Label */ 
#line 1287
    state = (ngx_http_ssi_state_e )10;
#line 1288
    goto switch_break___8;
    switch_default___7: /* CIL Label */ 
#line 1291
    if ((int )ch == 45) {
#line 1292
      state = (ngx_http_ssi_state_e )18;
    } else {
#line 1294
      state = (ngx_http_ssi_state_e )17;
    }
#line 1297
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1297
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol after \"%V\" parameter in \"%V\" SSI command",
                         (int )ch, & (ctx->param)->key, & ctx->command);
      }
    }
#line 1301
    goto switch_break___8;
    switch_break___8: /* CIL Label */ ;
    }
#line 1304
    goto switch_break;
    case_10___4: /* CIL Label */ 
    {
#line 1311
    if ((int )ch == 9) {
#line 1311
      goto case_9___5;
    }
#line 1311
    if ((int )ch == 10) {
#line 1311
      goto case_9___5;
    }
#line 1311
    if ((int )ch == 13) {
#line 1311
      goto case_9___5;
    }
#line 1311
    if ((int )ch == 32) {
#line 1311
      goto case_9___5;
    }
#line 1314
    if ((int )ch == 34) {
#line 1314
      goto case_34;
    }
#line 1318
    if ((int )ch == 39) {
#line 1318
      goto case_39;
    }
#line 1322
    goto switch_default___8;
    case_9___5: /* CIL Label */ 
    case_10___5: /* CIL Label */ 
    case_13___4: /* CIL Label */ 
    case_32___4: /* CIL Label */ 
#line 1312
    goto switch_break___9;
    case_34: /* CIL Label */ 
#line 1315
    state = (ngx_http_ssi_state_e )11;
#line 1316
    goto switch_break___9;
    case_39: /* CIL Label */ 
#line 1319
    state = (ngx_http_ssi_state_e )12;
#line 1320
    goto switch_break___9;
    switch_default___8: /* CIL Label */ 
#line 1323
    if ((int )ch == 45) {
#line 1324
      state = (ngx_http_ssi_state_e )18;
    } else {
#line 1326
      state = (ngx_http_ssi_state_e )17;
    }
#line 1329
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1329
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol before value of \"%V\" parameter in \"%V\" SSI command",
                         (int )ch, & (ctx->param)->key, & ctx->command);
      }
    }
#line 1333
    goto switch_break___9;
    switch_break___9: /* CIL Label */ ;
    }
#line 1336
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 1340
    if ((int )ch == 34) {
#line 1340
      goto case_34___0;
    }
#line 1344
    if ((int )ch == 92) {
#line 1344
      goto case_92;
    }
#line 1350
    goto switch_default___9;
    case_34___0: /* CIL Label */ 
#line 1341
    state = (ngx_http_ssi_state_e )14;
#line 1342
    goto switch_break___10;
    case_92: /* CIL Label */ 
#line 1345
    ctx->saved_state = (ngx_uint_t )11;
#line 1346
    state = (ngx_http_ssi_state_e )13;
    switch_default___9: /* CIL Label */ 
#line 1351
    if ((ctx->param)->value.len == ctx->value_len) {
#line 1352
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1352
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too long \"%V%c...\" value of \"%V\" parameter in \"%V\" SSI command",
                           & (ctx->param)->value, (int )ch, & (ctx->param)->key, & ctx->command);
        }
      }
#line 1357
      state = (ngx_http_ssi_state_e )17;
#line 1358
      goto switch_break___10;
    }
#line 1361
    tmp___6 = (ctx->param)->value.len;
#line 1361
    ((ctx->param)->value.len) ++;
#line 1361
    *((ctx->param)->value.data + tmp___6) = ch;
    switch_break___10: /* CIL Label */ ;
    }
#line 1364
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 1368
    if ((int )ch == 39) {
#line 1368
      goto case_39___0;
    }
#line 1372
    if ((int )ch == 92) {
#line 1372
      goto case_92___0;
    }
#line 1378
    goto switch_default___10;
    case_39___0: /* CIL Label */ 
#line 1369
    state = (ngx_http_ssi_state_e )14;
#line 1370
    goto switch_break___11;
    case_92___0: /* CIL Label */ 
#line 1373
    ctx->saved_state = (ngx_uint_t )12;
#line 1374
    state = (ngx_http_ssi_state_e )13;
    switch_default___10: /* CIL Label */ 
#line 1379
    if ((ctx->param)->value.len == ctx->value_len) {
#line 1380
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1380
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too long \"%V%c...\" value of \"%V\" parameter in \"%V\" SSI command",
                           & (ctx->param)->value, (int )ch, & (ctx->param)->key, & ctx->command);
        }
      }
#line 1385
      state = (ngx_http_ssi_state_e )17;
#line 1386
      goto switch_break___11;
    }
#line 1389
    tmp___7 = (ctx->param)->value.len;
#line 1389
    ((ctx->param)->value.len) ++;
#line 1389
    *((ctx->param)->value.data + tmp___7) = ch;
    switch_break___11: /* CIL Label */ ;
    }
#line 1392
    goto switch_break;
    case_13___5: /* CIL Label */ 
#line 1395
    state = (ngx_http_ssi_state_e )ctx->saved_state;
#line 1397
    if ((ctx->param)->value.len == ctx->value_len) {
#line 1398
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1398
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "too long \"%V%c...\" value of \"%V\" parameter in \"%V\" SSI command",
                           & (ctx->param)->value, (int )ch, & (ctx->param)->key, & ctx->command);
        }
      }
#line 1403
      state = (ngx_http_ssi_state_e )17;
#line 1404
      goto switch_break;
    }
#line 1407
    tmp___8 = (ctx->param)->value.len;
#line 1407
    ((ctx->param)->value.len) ++;
#line 1407
    *((ctx->param)->value.data + tmp___8) = ch;
#line 1409
    goto switch_break;
    case_14: /* CIL Label */ 
#line 1413
    if ((ctx->param)->value.len + 1UL < ctx->value_len / 2UL) {
      {
#line 1414
      tmp___9 = ngx_pnalloc(r->pool, (ctx->param)->value.len + 1UL);
#line 1414
      value = (u_char *)tmp___9;
      }
#line 1415
      if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1416
        return ((ngx_int_t )-1);
      }
      {
#line 1419
      memcpy((void */* __restrict  */)value, (void const   */* __restrict  */)(ctx->param)->value.data,
             (ctx->param)->value.len);
#line 1422
      ctx->value_buf = (void *)(ctx->param)->value.data;
#line 1423
      (ctx->param)->value.data = value;
      }
    } else {
#line 1426
      ctx->value_buf = (void *)0;
    }
    {
#line 1433
    if ((int )ch == 9) {
#line 1433
      goto case_9___6;
    }
#line 1433
    if ((int )ch == 10) {
#line 1433
      goto case_9___6;
    }
#line 1433
    if ((int )ch == 13) {
#line 1433
      goto case_9___6;
    }
#line 1433
    if ((int )ch == 32) {
#line 1433
      goto case_9___6;
    }
#line 1437
    if ((int )ch == 45) {
#line 1437
      goto case_45___4;
    }
#line 1441
    goto switch_default___11;
    case_9___6: /* CIL Label */ 
    case_10___6: /* CIL Label */ 
    case_13___6: /* CIL Label */ 
    case_32___5: /* CIL Label */ 
#line 1434
    state = (ngx_http_ssi_state_e )7;
#line 1435
    goto switch_break___12;
    case_45___4: /* CIL Label */ 
#line 1438
    state = (ngx_http_ssi_state_e )15;
#line 1439
    goto switch_break___12;
    switch_default___11: /* CIL Label */ 
#line 1442
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1442
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol after \"%V\" value of \"%V\" parameter in \"%V\" SSI command",
                         (int )ch, & (ctx->param)->value, & (ctx->param)->key, & ctx->command);
      }
    }
#line 1447
    state = (ngx_http_ssi_state_e )17;
#line 1448
    goto switch_break___12;
    switch_break___12: /* CIL Label */ ;
    }
#line 1451
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 1455
    if ((int )ch == 45) {
#line 1455
      goto case_45___5;
    }
#line 1459
    goto switch_default___12;
    case_45___5: /* CIL Label */ 
#line 1456
    state = (ngx_http_ssi_state_e )16;
#line 1457
    goto switch_break___13;
    switch_default___12: /* CIL Label */ 
#line 1460
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1460
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol in \"%V\" SSI command",
                         (int )ch, & ctx->command);
      }
    }
#line 1463
    state = (ngx_http_ssi_state_e )17;
#line 1464
    goto switch_break___13;
    switch_break___13: /* CIL Label */ ;
    }
#line 1467
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 1471
    if ((int )ch == 62) {
#line 1471
      goto case_62;
    }
#line 1483
    goto switch_default___13;
    case_62: /* CIL Label */ 
#line 1472
    ctx->state = (ngx_uint_t )0;
#line 1473
    ctx->pos = p + 1;
#line 1474
    ctx->looked = looked;
#line 1475
    ctx->copy_end = copy_end;
#line 1477
    if ((unsigned long )ctx->copy_start == (unsigned long )((void *)0)) {
#line 1477
      if (copy_end) {
#line 1478
        ctx->copy_start = (ctx->buf)->pos;
      }
    }
#line 1481
    return ((ngx_int_t )0);
    switch_default___13: /* CIL Label */ 
#line 1484
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1484
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unexpected \"%c\" symbol in \"%V\" SSI command",
                         (int )ch, & ctx->command);
      }
    }
#line 1487
    state = (ngx_http_ssi_state_e )17;
#line 1488
    goto switch_break___14;
    switch_break___14: /* CIL Label */ ;
    }
#line 1491
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 1495
    if ((int )ch == 45) {
#line 1495
      goto case_45___6;
    }
#line 1499
    goto switch_default___14;
    case_45___6: /* CIL Label */ 
#line 1496
    state = (ngx_http_ssi_state_e )18;
#line 1497
    goto switch_break___15;
    switch_default___14: /* CIL Label */ 
#line 1500
    goto switch_break___15;
    switch_break___15: /* CIL Label */ ;
    }
#line 1503
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 1507
    if ((int )ch == 45) {
#line 1507
      goto case_45___7;
    }
#line 1511
    goto switch_default___15;
    case_45___7: /* CIL Label */ 
#line 1508
    state = (ngx_http_ssi_state_e )19;
#line 1509
    goto switch_break___16;
    switch_default___15: /* CIL Label */ 
#line 1512
    state = (ngx_http_ssi_state_e )17;
#line 1513
    goto switch_break___16;
    switch_break___16: /* CIL Label */ ;
    }
#line 1516
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 1520
    if ((int )ch == 62) {
#line 1520
      goto case_62___0;
    }
#line 1532
    goto switch_default___16;
    case_62___0: /* CIL Label */ 
#line 1521
    ctx->state = (ngx_uint_t )0;
#line 1522
    ctx->pos = p + 1;
#line 1523
    ctx->looked = looked;
#line 1524
    ctx->copy_end = copy_end;
#line 1526
    if ((unsigned long )ctx->copy_start == (unsigned long )((void *)0)) {
#line 1526
      if (copy_end) {
#line 1527
        ctx->copy_start = (ctx->buf)->pos;
      }
    }
#line 1530
    return ((ngx_int_t )1);
    switch_default___16: /* CIL Label */ 
#line 1533
    state = (ngx_http_ssi_state_e )17;
#line 1534
    goto switch_break___17;
    switch_break___17: /* CIL Label */ ;
    }
#line 1537
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1002
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1541
  ctx->state = (ngx_uint_t )state;
#line 1542
  ctx->pos = p;
#line 1543
  ctx->looked = looked;
#line 1545
  if ((unsigned int )state == 0U) {
#line 1545
    ctx->copy_end = p;
  } else {
#line 1545
    ctx->copy_end = copy_end;
  }
#line 1547
  if ((unsigned long )ctx->copy_start == (unsigned long )((void *)0)) {
#line 1547
    if (ctx->copy_end) {
#line 1548
      ctx->copy_start = (ctx->buf)->pos;
    }
  }
#line 1551
  return ((ngx_int_t )-2);
}
}
#line 1555 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_str_t *ngx_http_ssi_get_variable(ngx_http_request_t *r , ngx_str_t *name ,
                                            ngx_uint_t key ) 
{ 
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_http_ssi_var_t *var ;
  ngx_http_ssi_ctx_t *ctx ;
  ngx_str_t *value ;
  void *tmp ;
  int tmp___0 ;

  {
#line 1564
  ctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 1570
  if (key >= 48UL) {
#line 1570
    if (key <= 57UL) {
#line 1571
      i = key - 48UL;
#line 1573
      if (i < ctx->ncaptures) {
        {
#line 1574
        tmp = ngx_palloc(r->pool, sizeof(ngx_str_t ));
#line 1574
        value = (ngx_str_t *)tmp;
        }
#line 1575
        if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1576
          return ((ngx_str_t *)((void *)0));
        }
#line 1579
        i *= 2UL;
#line 1581
        value->data = ctx->captures_data + *(ctx->captures + i);
#line 1582
        value->len = (size_t )(*(ctx->captures + (i + 1UL)) - *(ctx->captures + i));
#line 1584
        return (value);
      }
    }
  }
#line 1590
  if ((unsigned long )ctx->variables == (unsigned long )((void *)0)) {
#line 1591
    return ((ngx_str_t *)((void *)0));
  }
#line 1594
  part = & (ctx->variables)->part;
#line 1595
  var = (ngx_http_ssi_var_t *)part->elts;
#line 1597
  i = (ngx_uint_t )0;
  {
#line 1597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1599
    if (i >= part->nelts) {
#line 1600
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1601
        goto while_break;
      }
#line 1604
      part = part->next;
#line 1605
      var = (ngx_http_ssi_var_t *)part->elts;
#line 1606
      i = (ngx_uint_t )0;
    }
#line 1609
    if (name->len != (var + i)->name.len) {
#line 1610
      goto __Cont;
    }
#line 1613
    if (key != (var + i)->key) {
#line 1614
      goto __Cont;
    }
    {
#line 1617
    tmp___0 = strncmp((char const   *)name->data, (char const   *)(var + i)->name.data,
                      name->len);
    }
#line 1617
    if (tmp___0 == 0) {
#line 1618
      return (& (var + i)->value);
    }
    __Cont: /* CIL Label */ 
#line 1597
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1622
  return ((ngx_str_t *)((void *)0));
}
}
#line 1626 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_evaluate_string(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                              ngx_str_t *text , ngx_uint_t flags ) 
{ 
  u_char ch ;
  u_char *p ;
  u_char **value ;
  u_char *data ;
  u_char *part_data ;
  size_t *size ;
  size_t len ;
  size_t prefix ;
  size_t part_len ;
  ngx_str_t var ;
  ngx_str_t *val ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t bracket ;
  ngx_uint_t quoted ;
  ngx_uint_t key ;
  ngx_array_t lengths ;
  ngx_array_t values ;
  ngx_http_variable_value_t *vv ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
  {
#line 1637
  n = ngx_http_script_variables_count(text);
  }
#line 1639
  if (n == 0UL) {
#line 1641
    data = text->data;
#line 1642
    p = data;
#line 1644
    if (flags & 1UL) {
#line 1644
      if ((int )*(text->data + 0) != 47) {
#line 1646
        prefix = r->uri.len;
        {
#line 1646
        while (1) {
          while_continue: /* CIL Label */ ;
#line 1646
          if (! prefix) {
#line 1646
            goto while_break;
          }
#line 1647
          if ((int )*(r->uri.data + (prefix - 1UL)) == 47) {
#line 1648
            goto while_break;
          }
#line 1646
          prefix --;
        }
        while_break: /* CIL Label */ ;
        }
#line 1652
        if (prefix) {
          {
#line 1653
          len = prefix + text->len;
#line 1655
          tmp = ngx_pnalloc(r->pool, len);
#line 1655
          data = (u_char *)tmp;
          }
#line 1656
          if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 1657
            return ((ngx_int_t )-1);
          }
          {
#line 1660
          tmp___0 = memcpy((void */* __restrict  */)data, (void const   */* __restrict  */)r->uri.data,
                           prefix);
#line 1660
          p = (u_char *)tmp___0 + prefix;
          }
        }
      }
    }
#line 1664
    quoted = (ngx_uint_t )0;
#line 1666
    i = (ngx_uint_t )0;
    {
#line 1666
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1666
      if (! (i < text->len)) {
#line 1666
        goto while_break___0;
      }
#line 1667
      ch = *(text->data + i);
#line 1669
      if (! quoted) {
#line 1671
        if ((int )ch == 92) {
#line 1672
          quoted = (ngx_uint_t )1;
#line 1673
          goto __Cont;
        }
      } else {
#line 1677
        quoted = (ngx_uint_t )0;
#line 1679
        if ((int )ch != 92) {
#line 1679
          if ((int )ch != 39) {
#line 1679
            if ((int )ch != 34) {
#line 1679
              if ((int )ch != 36) {
#line 1680
                tmp___1 = p;
#line 1680
                p ++;
#line 1680
                *tmp___1 = (u_char )'\\';
              }
            }
          }
        }
      }
#line 1684
      tmp___2 = p;
#line 1684
      p ++;
#line 1684
      *tmp___2 = ch;
      __Cont: /* CIL Label */ 
#line 1666
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1687
    text->len = (size_t )(p - data);
#line 1688
    text->data = data;
#line 1690
    return ((ngx_int_t )0);
  }
  {
#line 1693
  tmp___3 = ngx_array_init(& lengths, r->pool, (ngx_uint_t )8, sizeof(size_t *));
  }
#line 1693
  if (tmp___3 != 0L) {
#line 1694
    return ((ngx_int_t )-1);
  }
  {
#line 1697
  tmp___4 = ngx_array_init(& values, r->pool, (ngx_uint_t )8, sizeof(u_char *));
  }
#line 1697
  if (tmp___4 != 0L) {
#line 1698
    return ((ngx_int_t )-1);
  }
#line 1701
  len = (size_t )0;
#line 1702
  i = (ngx_uint_t )0;
  {
#line 1704
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1704
    if (! (i < text->len)) {
#line 1704
      goto while_break___1;
    }
#line 1706
    if ((int )*(text->data + i) == 36) {
#line 1708
      var.len = (size_t )0;
#line 1710
      i ++;
#line 1710
      if (i == text->len) {
#line 1711
        goto invalid_variable;
      }
#line 1714
      if ((int )*(text->data + i) == 123) {
#line 1715
        bracket = (ngx_uint_t )1;
#line 1717
        i ++;
#line 1717
        if (i == text->len) {
#line 1718
          goto invalid_variable;
        }
#line 1721
        var.data = text->data + i;
      } else {
#line 1724
        bracket = (ngx_uint_t )0;
#line 1725
        var.data = text->data + i;
      }
      {
#line 1728
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1728
        if (! (i < text->len)) {
#line 1728
          goto while_break___2;
        }
#line 1729
        ch = *(text->data + i);
#line 1731
        if ((int )ch == 125) {
#line 1731
          if (bracket) {
#line 1732
            i ++;
#line 1733
            bracket = (ngx_uint_t )0;
#line 1734
            goto while_break___2;
          }
        }
#line 1737
        if ((int )ch >= 65) {
#line 1737
          if ((int )ch <= 90) {
#line 1742
            goto __Cont___0;
          } else {
#line 1737
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1737
        if ((int )ch >= 97) {
#line 1737
          if ((int )ch <= 122) {
#line 1742
            goto __Cont___0;
          } else {
#line 1737
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1737
        if ((int )ch >= 48) {
#line 1737
          if ((int )ch <= 57) {
#line 1742
            goto __Cont___0;
          } else {
#line 1737
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1737
        if ((int )ch == 95) {
#line 1742
          goto __Cont___0;
        }
#line 1745
        goto while_break___2;
        __Cont___0: /* CIL Label */ 
#line 1728
        i ++;
#line 1728
        (var.len) ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1748
      if (bracket) {
#line 1749
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 1749
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the closing bracket in \"%V\" variable is missing",
                             & var);
          }
        }
#line 1752
        return ((ngx_int_t )1);
      }
#line 1755
      if (var.len == 0UL) {
#line 1756
        goto invalid_variable;
      }
      {
#line 1759
      key = ngx_hash_strlow(var.data, var.data, var.len);
#line 1761
      val = ngx_http_ssi_get_variable(r, & var, key);
      }
#line 1763
      if ((unsigned long )val == (unsigned long )((void *)0)) {
        {
#line 1764
        vv = ngx_http_get_variable(r, & var, key);
        }
#line 1765
        if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 1766
          return ((ngx_int_t )-1);
        }
#line 1769
        if (vv->not_found) {
#line 1770
          goto while_continue___1;
        }
#line 1773
        part_data = vv->data;
#line 1774
        part_len = (size_t )vv->len;
      } else {
#line 1777
        part_data = val->data;
#line 1778
        part_len = val->len;
      }
    } else {
#line 1782
      part_data = text->data + i;
#line 1783
      quoted = (ngx_uint_t )0;
#line 1785
      p = part_data;
      {
#line 1785
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1785
        if (! (i < text->len)) {
#line 1785
          goto while_break___3;
        }
#line 1786
        ch = *(text->data + i);
#line 1788
        if (! quoted) {
#line 1790
          if ((int )ch == 92) {
#line 1791
            quoted = (ngx_uint_t )1;
#line 1792
            goto __Cont___1;
          }
#line 1795
          if ((int )ch == 36) {
#line 1796
            goto while_break___3;
          }
        } else {
#line 1800
          quoted = (ngx_uint_t )0;
#line 1802
          if ((int )ch != 92) {
#line 1802
            if ((int )ch != 39) {
#line 1802
              if ((int )ch != 34) {
#line 1802
                if ((int )ch != 36) {
#line 1803
                  tmp___5 = p;
#line 1803
                  p ++;
#line 1803
                  *tmp___5 = (u_char )'\\';
                }
              }
            }
          }
        }
#line 1807
        tmp___6 = p;
#line 1807
        p ++;
#line 1807
        *tmp___6 = ch;
        __Cont___1: /* CIL Label */ 
#line 1785
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1810
      part_len = (size_t )(p - part_data);
    }
    {
#line 1813
    len += part_len;
#line 1815
    tmp___7 = ngx_array_push(& lengths);
#line 1815
    size = (size_t *)tmp___7;
    }
#line 1816
    if ((unsigned long )size == (unsigned long )((void *)0)) {
#line 1817
      return ((ngx_int_t )-1);
    }
    {
#line 1820
    *size = part_len;
#line 1822
    tmp___8 = ngx_array_push(& values);
#line 1822
    value = (u_char **)tmp___8;
    }
#line 1823
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1824
      return ((ngx_int_t )-1);
    }
#line 1827
    *value = part_data;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1830
  prefix = (size_t )0;
#line 1832
  size = (size_t *)lengths.elts;
#line 1833
  value = (u_char **)values.elts;
#line 1835
  if (flags & 1UL) {
#line 1836
    i = (ngx_uint_t )0;
    {
#line 1836
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1836
      if (! (i < values.nelts)) {
#line 1836
        goto while_break___4;
      }
#line 1837
      if (*(size + i) != 0UL) {
#line 1838
        if ((int )*(*(value + i)) != 47) {
#line 1839
          prefix = r->uri.len;
          {
#line 1839
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1839
            if (! prefix) {
#line 1839
              goto while_break___5;
            }
#line 1840
            if ((int )*(r->uri.data + (prefix - 1UL)) == 47) {
#line 1841
              len += prefix;
#line 1842
              goto while_break___5;
            }
#line 1839
            prefix --;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
#line 1847
        goto while_break___4;
      }
#line 1836
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  }
#line 1852
  if (flags & 2UL) {
#line 1852
    tmp___9 = 1;
  } else {
#line 1852
    tmp___9 = 0;
  }
  {
#line 1852
  tmp___10 = ngx_pnalloc(r->pool, len + (size_t )tmp___9);
#line 1852
  p = (u_char *)tmp___10;
  }
#line 1853
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1854
    return ((ngx_int_t )-1);
  }
  {
#line 1857
  text->len = len;
#line 1858
  text->data = p;
#line 1860
  tmp___11 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)r->uri.data,
                    prefix);
#line 1860
  p = (u_char *)tmp___11 + prefix;
#line 1862
  i = (ngx_uint_t )0;
  }
  {
#line 1862
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1862
    if (! (i < values.nelts)) {
#line 1862
      goto while_break___6;
    }
    {
#line 1863
    tmp___12 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)*(value + i),
                      *(size + i));
#line 1863
    p = (u_char *)tmp___12 + *(size + i);
#line 1862
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1866
  return ((ngx_int_t )0);
  invalid_variable: 
#line 1870
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 1870
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid variable name in \"%V\"",
                       text);
    }
  }
#line 1873
  return ((ngx_int_t )1);
}
}
#line 1877 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_regex_match(ngx_http_request_t *r , ngx_str_t *pattern ,
                                          ngx_str_t *str ) 
{ 
  int rc ;
  int *captures ;
  u_char *p ;
  u_char errstr[1024] ;
  size_t size ;
  ngx_str_t *vv ;
  ngx_str_t name ;
  ngx_str_t value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t key ;
  ngx_http_ssi_ctx_t *ctx ;
  ngx_http_ssi_var_t *var ;
  ngx_regex_compile_t rgc ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 1891
  memset((void *)(& rgc), 0, sizeof(ngx_regex_compile_t ));
#line 1893
  rgc.pattern = *pattern;
#line 1894
  rgc.pool = r->pool;
#line 1895
  rgc.err.len = (size_t )1024;
#line 1896
  rgc.err.data = errstr;
#line 1898
  tmp = ngx_regex_compile(& rgc);
  }
#line 1898
  if (tmp != 0L) {
#line 1899
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1899
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%V", & rgc.err);
      }
    }
#line 1900
    return ((ngx_int_t )1);
  }
  {
#line 1903
  n = (ngx_uint_t )((rgc.captures + 1) * 3);
#line 1905
  tmp___0 = ngx_palloc(r->pool, n * sizeof(int ));
#line 1905
  captures = (int *)tmp___0;
  }
#line 1906
  if ((unsigned long )captures == (unsigned long )((void *)0)) {
#line 1907
    return ((ngx_int_t )-1);
  }
  {
#line 1910
  rc = pcre_exec((pcre const   *)(rgc.regex)->code, (pcre_extra const   *)(rgc.regex)->extra,
                 (char const   *)str->data, (int )str->len, 0, 0, captures, (int )n);
  }
#line 1912
  if (rc < -1) {
#line 1913
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 1913
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "pcre_exec() failed: %d on \"%V\" using \"%V\"",
                         rc, str, pattern);
      }
    }
#line 1916
    return ((ngx_int_t )1);
  }
#line 1919
  if (rc == -1) {
#line 1920
    return ((ngx_int_t )-5);
  }
#line 1923
  ctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 1925
  ctx->ncaptures = (ngx_uint_t )rc;
#line 1926
  ctx->captures = captures;
#line 1927
  ctx->captures_data = str->data;
#line 1929
  if (rgc.named_captures > 0) {
#line 1931
    if ((unsigned long )ctx->variables == (unsigned long )((void *)0)) {
      {
#line 1932
      ctx->variables = ngx_list_create(r->pool, (ngx_uint_t )4, sizeof(ngx_http_ssi_var_t ));
      }
#line 1934
      if ((unsigned long )ctx->variables == (unsigned long )((void *)0)) {
#line 1935
        return ((ngx_int_t )-1);
      }
    }
#line 1939
    size = (size_t )rgc.name_size;
#line 1940
    p = rgc.names;
#line 1942
    i = (ngx_uint_t )0;
    {
#line 1942
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1942
      if (! (i < (ngx_uint_t )rgc.named_captures)) {
#line 1942
        goto while_break;
      }
      {
#line 1944
      name.data = p + 2;
#line 1945
      name.len = strlen((char const   *)name.data);
#line 1947
      n = (ngx_uint_t )(2 * (((int )*(p + 0) << 8) + (int )*(p + 1)));
#line 1949
      value.data = str->data + *(captures + n);
#line 1950
      value.len = (size_t )(*(captures + (n + 1UL)) - *(captures + n));
#line 1952
      key = ngx_hash_strlow(name.data, name.data, name.len);
#line 1954
      vv = ngx_http_ssi_get_variable(r, & name, key);
      }
#line 1956
      if (vv) {
#line 1957
        *vv = value;
#line 1958
        goto __Cont;
      }
      {
#line 1961
      tmp___1 = ngx_list_push(ctx->variables);
#line 1961
      var = (ngx_http_ssi_var_t *)tmp___1;
      }
#line 1962
      if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 1963
        return ((ngx_int_t )-1);
      }
#line 1966
      var->name = name;
#line 1967
      var->key = key;
#line 1968
      var->value = value;
      __Cont: /* CIL Label */ 
#line 1942
      i ++;
#line 1942
      p += size;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1972
  return ((ngx_int_t )0);
}
}
#line 1985 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_include(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                      ngx_str_t **params ) 
{ 
  ngx_int_t rc ;
  ngx_str_t *uri___0 ;
  ngx_str_t *file ;
  ngx_str_t *wait___0 ;
  ngx_str_t *set ;
  ngx_str_t *stub ;
  ngx_str_t args___0 ;
  ngx_buf_t *b ;
  ngx_uint_t flags ;
  ngx_uint_t i ;
  ngx_uint_t key ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t **ll ;
  ngx_chain_t *out ;
  ngx_http_request_t *sr ;
  ngx_http_ssi_var_t *var ;
  ngx_http_ssi_ctx_t *mctx ;
  ngx_http_ssi_block_t *bl ;
  ngx_http_post_subrequest_t *psr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ngx_uint_t tmp___5 ;
  void *tmp___6 ;
  ngx_str_t *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;

  {
#line 2000
  uri___0 = *(params + 0);
#line 2001
  file = *(params + 1);
#line 2002
  wait___0 = *(params + 2);
#line 2003
  set = *(params + 3);
#line 2004
  stub = *(params + 4);
#line 2006
  if (uri___0) {
#line 2006
    if (file) {
#line 2007
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2007
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "inclusion may be either virtual=\"%V\" or file=\"%V\"",
                           uri___0, file);
        }
      }
#line 2010
      return ((ngx_int_t )1);
    }
  }
#line 2013
  if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 2013
    if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 2014
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2014
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no parameter in \"include\" SSI command");
        }
      }
#line 2016
      return ((ngx_int_t )1);
    }
  }
#line 2019
  if (set) {
#line 2019
    if (stub) {
#line 2020
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2020
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "\"set\" and \"stub\" cannot be used together in \"include\" SSI command");
        }
      }
#line 2023
      return ((ngx_int_t )1);
    }
  }
#line 2026
  if (wait___0) {
#line 2027
    if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 2028
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2028
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "\"wait\" cannot be used with file=\"%V\"",
                           file);
        }
      }
#line 2030
      return ((ngx_int_t )1);
    }
#line 2033
    if (wait___0->len == 2UL) {
      {
#line 2033
      tmp___0 = ngx_strncasecmp(wait___0->data, (u_char *)"no", (size_t )2);
      }
#line 2033
      if (tmp___0 == 0L) {
#line 2036
        wait___0 = (ngx_str_t *)((void *)0);
      } else {
#line 2033
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2038
    if (wait___0->len != 3UL) {
#line 2038
      goto _L;
    } else {
      {
#line 2038
      tmp = ngx_strncasecmp(wait___0->data, (u_char *)"yes", (size_t )3);
      }
#line 2038
      if (tmp != 0L) {
        _L: /* CIL Label */ 
#line 2041
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 2041
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid value \"%V\" in the \"wait\" parameter",
                             wait___0);
          }
        }
#line 2044
        return ((ngx_int_t )1);
      }
    }
  }
#line 2048
  if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 2049
    uri___0 = file;
#line 2050
    wait___0 = (ngx_str_t *)-1;
  }
  {
#line 2053
  rc = ngx_http_ssi_evaluate_string(r, ctx, uri___0, (ngx_uint_t )1);
  }
#line 2055
  if (rc != 0L) {
#line 2056
    return (rc);
  }
  {
#line 2062
  args___0.len = (size_t )0;
#line 2062
  args___0.data = (u_char *)((void *)0);
#line 2063
  flags = (ngx_uint_t )1;
#line 2065
  tmp___1 = ngx_http_parse_unsafe_uri(r, uri___0, & args___0, & flags);
  }
#line 2065
  if (tmp___1 != 0L) {
#line 2066
    return ((ngx_int_t )1);
  }
#line 2069
  psr = (ngx_http_post_subrequest_t *)((void *)0);
#line 2071
  mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 2073
  if (stub) {
#line 2074
    if (mctx->blocks) {
#line 2075
      bl = (ngx_http_ssi_block_t *)(mctx->blocks)->elts;
#line 2076
      i = (ngx_uint_t )0;
      {
#line 2076
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2076
        if (! (i < (mctx->blocks)->nelts)) {
#line 2076
          goto while_break;
        }
#line 2077
        if (stub->len == (bl + i)->name.len) {
          {
#line 2077
          tmp___2 = strncmp((char const   *)stub->data, (char const   *)(bl + i)->name.data,
                            stub->len);
          }
#line 2077
          if (tmp___2 == 0) {
#line 2080
            goto found;
          }
        }
#line 2076
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 2085
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2085
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "\"stub\"=\"%V\" for \"include\" not found",
                         stub);
      }
    }
#line 2087
    return ((ngx_int_t )1);
    found: 
    {
#line 2091
    tmp___3 = ngx_palloc(r->pool, sizeof(ngx_http_post_subrequest_t ));
#line 2091
    psr = (ngx_http_post_subrequest_t *)tmp___3;
    }
#line 2092
    if ((unsigned long )psr == (unsigned long )((void *)0)) {
#line 2093
      return ((ngx_int_t )-1);
    }
#line 2096
    psr->handler = & ngx_http_ssi_stub_output;
#line 2098
    tmp___5 = (bl + i)->count;
#line 2098
    ((bl + i)->count) ++;
#line 2098
    if (tmp___5) {
#line 2100
      out = (ngx_chain_t *)((void *)0);
#line 2101
      ll = & out;
#line 2103
      tl = (bl + i)->bufs;
      {
#line 2103
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2103
        if (! tl) {
#line 2103
          goto while_break___0;
        }
#line 2105
        if (ctx->free) {
#line 2106
          cl = ctx->free;
#line 2107
          ctx->free = (ctx->free)->next;
#line 2108
          b = cl->buf;
        } else {
          {
#line 2111
          tmp___4 = ngx_palloc(r->pool, sizeof(ngx_buf_t ));
#line 2111
          b = (ngx_buf_t *)tmp___4;
          }
#line 2112
          if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 2113
            return ((ngx_int_t )-1);
          }
          {
#line 2116
          cl = ngx_alloc_chain_link(r->pool);
          }
#line 2117
          if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2118
            return ((ngx_int_t )-1);
          }
#line 2121
          cl->buf = b;
        }
        {
#line 2124
        memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)tl->buf,
               sizeof(ngx_buf_t ));
#line 2126
        b->pos = b->start;
#line 2128
        *ll = cl;
#line 2129
        cl->next = (ngx_chain_t *)((void *)0);
#line 2130
        ll = & cl->next;
#line 2103
        tl = tl->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2133
      psr->data = (void *)out;
    } else {
#line 2136
      psr->data = (void *)(bl + i)->bufs;
    }
  }
#line 2140
  if (wait___0) {
#line 2141
    flags |= 4UL;
  }
#line 2144
  if (set) {
    {
#line 2145
    key = ngx_hash_strlow(set->data, set->data, set->len);
#line 2147
    tmp___6 = ngx_palloc(r->pool, sizeof(ngx_http_post_subrequest_t ));
#line 2147
    psr = (ngx_http_post_subrequest_t *)tmp___6;
    }
#line 2148
    if ((unsigned long )psr == (unsigned long )((void *)0)) {
#line 2149
      return ((ngx_int_t )-1);
    }
    {
#line 2152
    psr->handler = & ngx_http_ssi_set_variable;
#line 2153
    tmp___7 = ngx_http_ssi_get_variable(r, set, key);
#line 2153
    psr->data = (void *)tmp___7;
    }
#line 2155
    if ((unsigned long )psr->data == (unsigned long )((void *)0)) {
#line 2157
      if ((unsigned long )mctx->variables == (unsigned long )((void *)0)) {
        {
#line 2158
        mctx->variables = ngx_list_create(r->pool, (ngx_uint_t )4, sizeof(ngx_http_ssi_var_t ));
        }
#line 2160
        if ((unsigned long )mctx->variables == (unsigned long )((void *)0)) {
#line 2161
          return ((ngx_int_t )-1);
        }
      }
      {
#line 2165
      tmp___8 = ngx_list_push(mctx->variables);
#line 2165
      var = (ngx_http_ssi_var_t *)tmp___8;
      }
#line 2166
      if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2167
        return ((ngx_int_t )-1);
      }
#line 2170
      var->name = *set;
#line 2171
      var->key = key;
#line 2172
      var->value = ngx_http_ssi_null_string;
#line 2173
      psr->data = (void *)(& var->value);
    }
#line 2176
    flags |= 6UL;
  }
  {
#line 2179
  tmp___9 = ngx_http_subrequest(r, uri___0, & args___0, & sr, psr, flags);
  }
#line 2179
  if (tmp___9 != 0L) {
#line 2180
    return ((ngx_int_t )1);
  }
#line 2183
  if ((unsigned long )wait___0 == (unsigned long )((void *)0)) {
#line 2183
    if ((unsigned long )set == (unsigned long )((void *)0)) {
#line 2184
      return ((ngx_int_t )0);
    }
  }
#line 2187
  if ((unsigned long )ctx->wait == (unsigned long )((void *)0)) {
#line 2188
    ctx->wait = sr;
#line 2190
    return ((ngx_int_t )-2);
  } else
#line 2193
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 2193
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "can only wait for one subrequest at a time");
    }
  }
#line 2197
  return ((ngx_int_t )0);
}
}
#line 2201 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_stub_output(ngx_http_request_t *r , void *data , ngx_int_t rc ) 
{ 
  ngx_chain_t *out ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 2206
  if (rc == -1L) {
#line 2207
    return (rc);
  } else
#line 2206
  if ((r->connection)->error) {
#line 2207
    return (rc);
  } else
#line 2206
  if (r->request_output) {
#line 2207
    return (rc);
  }
#line 2213
  out = (ngx_chain_t *)data;
#line 2215
  if (! r->header_sent) {
    {
#line 2216
    r->headers_out.content_type_len = (r->parent)->headers_out.content_type_len;
#line 2218
    r->headers_out.content_type = (r->parent)->headers_out.content_type;
#line 2220
    tmp = ngx_http_send_header(r);
    }
#line 2220
    if (tmp == -1L) {
#line 2221
      return ((ngx_int_t )-1);
    }
  }
  {
#line 2225
  tmp___0 = ngx_http_output_filter(r, out);
  }
#line 2225
  return (tmp___0);
}
}
#line 2229 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_set_variable(ngx_http_request_t *r , void *data , ngx_int_t rc ) 
{ 
  ngx_str_t *value ;

  {
#line 2232
  value = (ngx_str_t *)data;
#line 2234
  if (r->upstream) {
#line 2235
    value->len = (size_t )((r->upstream)->buffer.last - (r->upstream)->buffer.pos);
#line 2236
    value->data = (r->upstream)->buffer.pos;
  }
#line 2239
  return (rc);
}
}
#line 2243 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_echo(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                   ngx_str_t **params ) 
{ 
  u_char *p ;
  uintptr_t len ;
  ngx_buf_t *b ;
  ngx_str_t *var ;
  ngx_str_t *value ;
  ngx_str_t *enc ;
  ngx_str_t text ;
  ngx_uint_t key ;
  ngx_chain_t *cl ;
  ngx_http_variable_value_t *vv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uintptr_t tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp21 ;

  {
  {
#line 2255
  var = *(params + 0);
#line 2260
  key = ngx_hash_strlow(var->data, var->data, var->len);
#line 2262
  value = ngx_http_ssi_get_variable(r, var, key);
  }
#line 2264
  if ((unsigned long )value == (unsigned long )((void *)0)) {
    {
#line 2265
    vv = ngx_http_get_variable(r, var, key);
    }
#line 2267
    if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 2268
      return ((ngx_int_t )1);
    }
#line 2271
    if (! vv->not_found) {
#line 2272
      text.data = vv->data;
#line 2273
      text.len = (size_t )vv->len;
#line 2274
      value = & text;
    }
  }
#line 2278
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 2279
    value = *(params + 1);
#line 2281
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 2282
      value = & ngx_http_ssi_none;
    } else
#line 2284
    if (value->len == 0UL) {
#line 2285
      return ((ngx_int_t )0);
    }
  } else
#line 2289
  if (value->len == 0UL) {
#line 2290
    return ((ngx_int_t )0);
  }
#line 2294
  enc = *(params + 2);
#line 2296
  if (enc) {
#line 2297
    if (enc->len == 4UL) {
      {
#line 2297
      tmp___1 = strncmp((char const   *)enc->data, "none", (size_t )4);
      }
#line 2297
      if (tmp___1 == 0) {
#line 2299
        ctx->encoding = 0U;
      } else {
#line 2297
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2301
    if (enc->len == 3UL) {
      {
#line 2301
      tmp___0 = strncmp((char const   *)enc->data, "url", (size_t )3);
      }
#line 2301
      if (tmp___0 == 0) {
#line 2303
        ctx->encoding = 1U;
      } else {
#line 2301
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2305
    if (enc->len == 6UL) {
      {
#line 2305
      tmp = strncmp((char const   *)enc->data, "entity", (size_t )6);
      }
#line 2305
      if (tmp == 0) {
#line 2307
        ctx->encoding = 2U;
      } else {
#line 2305
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2310
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2310
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unknown encoding \"%V\" in the \"echo\" command",
                         enc);
      }
    }
  }
#line 2316
  p = value->data;
  {
#line 2320
  if (ctx->encoding == 1U) {
#line 2320
    goto case_1;
  }
#line 2336
  if (ctx->encoding == 2U) {
#line 2336
    goto case_2;
  }
#line 2351
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2321
  tmp___2 = ngx_escape_uri((u_char *)((void *)0), value->data, value->len, (ngx_uint_t )3);
#line 2321
  len = 2UL * tmp___2;
  }
#line 2324
  if (len) {
    {
#line 2325
    tmp___3 = ngx_pnalloc(r->pool, value->len + len);
#line 2325
    p = (u_char *)tmp___3;
    }
#line 2326
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2327
      return ((ngx_int_t )1);
    }
    {
#line 2330
    ngx_escape_uri(p, value->data, value->len, (ngx_uint_t )3);
    }
  }
#line 2333
  len += value->len;
#line 2334
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2337
  len = ngx_escape_html((u_char *)((void *)0), value->data, value->len);
  }
#line 2339
  if (len) {
    {
#line 2340
    tmp___4 = ngx_pnalloc(r->pool, value->len + len);
#line 2340
    p = (u_char *)tmp___4;
    }
#line 2341
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2342
      return ((ngx_int_t )1);
    }
    {
#line 2345
    ngx_escape_html(p, value->data, value->len);
    }
  }
#line 2348
  len += value->len;
#line 2349
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2352
  len = value->len;
#line 2353
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 2356
  tmp___5 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 2356
  b = (ngx_buf_t *)tmp___5;
  }
#line 2357
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 2358
    return ((ngx_int_t )1);
  }
  {
#line 2361
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 2362
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 2363
    return ((ngx_int_t )1);
  }
#line 2366
  b->memory = 1U;
#line 2367
  b->pos = p;
#line 2368
  b->last = p + len;
#line 2370
  cl->buf = b;
#line 2371
  cl->next = (ngx_chain_t *)((void *)0);
#line 2372
  *(ctx->last_out) = cl;
#line 2373
  ctx->last_out = & cl->next;
#line 2375
  return ((ngx_int_t )0);
}
}
#line 2379 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_config(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                     ngx_str_t **params ) 
{ 
  ngx_str_t *value ;
  void *tmp ;

  {
#line 2385
  value = *(params + 1);
#line 2387
  if (value) {
    {
#line 2388
    ctx->timefmt.len = value->len;
#line 2389
    tmp = ngx_pnalloc(r->pool, value->len + 1UL);
#line 2389
    ctx->timefmt.data = (u_char *)tmp;
    }
#line 2390
    if ((unsigned long )ctx->timefmt.data == (unsigned long )((void *)0)) {
#line 2391
      return ((ngx_int_t )-1);
    }
    {
#line 2394
    ngx_cpystrn(ctx->timefmt.data, value->data, value->len + 1UL);
    }
  }
#line 2397
  value = *(params + 0);
#line 2399
  if (value) {
#line 2400
    ctx->errmsg = *value;
  }
#line 2403
  return ((ngx_int_t )0);
}
}
#line 2407 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_set(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                  ngx_str_t **params ) 
{ 
  ngx_int_t rc ;
  ngx_str_t *name ;
  ngx_str_t *value ;
  ngx_str_t *vv ;
  ngx_uint_t key ;
  ngx_http_ssi_var_t *var ;
  ngx_http_ssi_ctx_t *mctx ;
  void *tmp ;

  {
#line 2417
  mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 2419
  if ((unsigned long )mctx->variables == (unsigned long )((void *)0)) {
    {
#line 2420
    mctx->variables = ngx_list_create(r->pool, (ngx_uint_t )4, sizeof(ngx_http_ssi_var_t ));
    }
#line 2422
    if ((unsigned long )mctx->variables == (unsigned long )((void *)0)) {
#line 2423
      return ((ngx_int_t )-1);
    }
  }
  {
#line 2427
  name = *(params + 0);
#line 2428
  value = *(params + 1);
#line 2433
  rc = ngx_http_ssi_evaluate_string(r, ctx, value, (ngx_uint_t )0);
  }
#line 2435
  if (rc != 0L) {
#line 2436
    return (rc);
  }
  {
#line 2439
  key = ngx_hash_strlow(name->data, name->data, name->len);
#line 2441
  vv = ngx_http_ssi_get_variable(r, name, key);
  }
#line 2443
  if (vv) {
#line 2444
    *vv = *value;
#line 2445
    return ((ngx_int_t )0);
  }
  {
#line 2448
  tmp = ngx_list_push(mctx->variables);
#line 2448
  var = (ngx_http_ssi_var_t *)tmp;
  }
#line 2449
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2450
    return ((ngx_int_t )-1);
  }
#line 2453
  var->name = *name;
#line 2454
  var->key = key;
#line 2455
  var->value = *value;
#line 2460
  return ((ngx_int_t )0);
}
}
#line 2464 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_if(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                 ngx_str_t **params ) 
{ 
  u_char *p ;
  u_char *last ;
  ngx_str_t *expr ;
  ngx_str_t left ;
  ngx_str_t right ;
  ngx_int_t rc ;
  ngx_uint_t negative ;
  ngx_uint_t noregex ;
  ngx_uint_t flags ;
  int tmp ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2473
  if (ctx->command.len == 2UL) {
#line 2474
    if (ctx->conditional) {
#line 2475
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 2475
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the \"if\" command inside the \"if\" command");
        }
      }
#line 2477
      return ((ngx_int_t )1);
    }
  }
#line 2481
  if (ctx->output_chosen) {
#line 2482
    ctx->output = 0U;
#line 2483
    return ((ngx_int_t )0);
  }
#line 2486
  expr = *(params + 0);
#line 2491
  left.data = expr->data;
#line 2492
  last = expr->data + expr->len;
#line 2494
  p = left.data;
  {
#line 2494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2494
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2494
      goto while_break;
    }
#line 2495
    if ((int )*p >= 65) {
#line 2495
      if ((int )*p <= 90) {
#line 2496
        *p = (u_char )((int )*p | 32);
#line 2497
        goto __Cont;
      }
    }
#line 2500
    if ((int )*p >= 97) {
#line 2500
      if ((int )*p <= 122) {
#line 2505
        goto __Cont;
      } else {
#line 2500
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2500
    if ((int )*p >= 48) {
#line 2500
      if ((int )*p <= 57) {
#line 2505
        goto __Cont;
      } else {
#line 2500
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2500
    if ((int )*p == 36) {
#line 2505
      goto __Cont;
    } else
#line 2500
    if ((int )*p == 123) {
#line 2505
      goto __Cont;
    } else
#line 2500
    if ((int )*p == 125) {
#line 2505
      goto __Cont;
    } else
#line 2500
    if ((int )*p == 95) {
#line 2505
      goto __Cont;
    } else
#line 2500
    if ((int )*p == 34) {
#line 2505
      goto __Cont;
    } else
#line 2500
    if ((int )*p == 39) {
#line 2505
      goto __Cont;
    }
#line 2508
    goto while_break;
    __Cont: /* CIL Label */ 
#line 2494
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2511
  left.len = (size_t )(p - left.data);
  {
#line 2513
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2513
    if ((unsigned long )p < (unsigned long )last) {
#line 2513
      if (! ((int )*p == 32)) {
#line 2513
        goto while_break___0;
      }
    } else {
#line 2513
      goto while_break___0;
    }
#line 2514
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2517
  flags = (ngx_uint_t )0;
#line 2522
  rc = ngx_http_ssi_evaluate_string(r, ctx, & left, flags);
  }
#line 2524
  if (rc != 0L) {
#line 2525
    return (rc);
  }
#line 2531
  if ((unsigned long )p == (unsigned long )last) {
#line 2532
    if (left.len) {
#line 2533
      ctx->output = 1U;
#line 2534
      ctx->output_chosen = 1U;
    } else {
#line 2537
      ctx->output = 0U;
    }
#line 2540
    ctx->conditional = 1U;
#line 2542
    return ((ngx_int_t )0);
  }
#line 2545
  if ((unsigned long )p < (unsigned long )last) {
#line 2545
    if ((int )*p == 61) {
#line 2546
      negative = (ngx_uint_t )0;
#line 2547
      p ++;
    } else {
#line 2545
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2549
  if ((unsigned long )(p + 1) < (unsigned long )last) {
#line 2549
    if ((int )*p == 33) {
#line 2549
      if ((int )*(p + 1) == 61) {
#line 2550
        negative = (ngx_uint_t )1;
#line 2551
        p += 2;
      } else {
#line 2554
        goto invalid_expression;
      }
    } else {
#line 2554
      goto invalid_expression;
    }
  } else {
#line 2554
    goto invalid_expression;
  }
  {
#line 2557
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2557
    if ((unsigned long )p < (unsigned long )last) {
#line 2557
      if (! ((int )*p == 32)) {
#line 2557
        goto while_break___1;
      }
    } else {
#line 2557
      goto while_break___1;
    }
#line 2558
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2561
  if ((unsigned long )p < (unsigned long )(last - 1)) {
#line 2561
    if ((int )*p == 47) {
#line 2562
      if ((int )*(last - 1) != 47) {
#line 2563
        goto invalid_expression;
      }
#line 2566
      noregex = (ngx_uint_t )0;
#line 2567
      flags = (ngx_uint_t )2;
#line 2568
      last --;
#line 2569
      p ++;
    } else {
#line 2561
      goto _L___2;
    }
  } else {
    _L___2: /* CIL Label */ 
#line 2572
    noregex = (ngx_uint_t )1;
#line 2573
    flags = (ngx_uint_t )0;
#line 2575
    if ((unsigned long )p < (unsigned long )(last - 1)) {
#line 2575
      if ((int )*(p + 0) == 92) {
#line 2575
        if ((int )*(p + 1) == 47) {
#line 2576
          p ++;
        }
      }
    }
  }
  {
#line 2580
  right.len = (size_t )(last - p);
#line 2581
  right.data = p;
#line 2586
  rc = ngx_http_ssi_evaluate_string(r, ctx, & right, flags);
  }
#line 2588
  if (rc != 0L) {
#line 2589
    return (rc);
  }
#line 2595
  if (noregex) {
#line 2596
    if (left.len != right.len) {
#line 2597
      rc = (ngx_int_t )-1;
    } else {
      {
#line 2600
      tmp = strncmp((char const   *)left.data, (char const   *)right.data, right.len);
#line 2600
      rc = (ngx_int_t )tmp;
      }
    }
  } else {
    {
#line 2604
    *(right.data + right.len) = (u_char )'\000';
#line 2606
    rc = ngx_http_ssi_regex_match(r, & right, & left);
    }
#line 2608
    if (rc == 0L) {
#line 2609
      rc = (ngx_int_t )0;
    } else
#line 2610
    if (rc == -5L) {
#line 2611
      rc = (ngx_int_t )-1;
    } else {
#line 2613
      return (rc);
    }
  }
#line 2617
  if (rc == 0L) {
#line 2617
    if (! negative) {
#line 2618
      ctx->output = 1U;
#line 2619
      ctx->output_chosen = 1U;
    } else {
#line 2617
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2617
  if (rc != 0L) {
#line 2617
    if (negative) {
#line 2618
      ctx->output = 1U;
#line 2619
      ctx->output_chosen = 1U;
    } else {
#line 2622
      ctx->output = 0U;
    }
  } else {
#line 2622
    ctx->output = 0U;
  }
#line 2625
  ctx->conditional = 1U;
#line 2627
  return ((ngx_int_t )0);
  invalid_expression: 
#line 2631
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 2631
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid expression in \"%V\"",
                       expr);
    }
  }
#line 2634
  return ((ngx_int_t )1);
}
}
#line 2638 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_else(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                   ngx_str_t **params ) 
{ 


  {
#line 2645
  if (ctx->output_chosen) {
#line 2646
    ctx->output = 0U;
  } else {
#line 2648
    ctx->output = 1U;
  }
#line 2651
  ctx->conditional = 2U;
#line 2653
  return ((ngx_int_t )0);
}
}
#line 2657 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_endif(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                    ngx_str_t **params ) 
{ 


  {
#line 2664
  ctx->output = 1U;
#line 2665
  ctx->output_chosen = 0U;
#line 2666
  ctx->conditional = 0U;
#line 2668
  return ((ngx_int_t )0);
}
}
#line 2672 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_block(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                    ngx_str_t **params ) 
{ 
  ngx_http_ssi_ctx_t *mctx ;
  ngx_http_ssi_block_t *bl ;
  void *tmp ;

  {
#line 2682
  mctx = (ngx_http_ssi_ctx_t *)*((r->main)->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 2684
  if ((unsigned long )mctx->blocks == (unsigned long )((void *)0)) {
    {
#line 2685
    mctx->blocks = ngx_array_create(r->pool, (ngx_uint_t )4, sizeof(ngx_http_ssi_block_t ));
    }
#line 2687
    if ((unsigned long )mctx->blocks == (unsigned long )((void *)0)) {
#line 2688
      return ((ngx_int_t )1);
    }
  }
  {
#line 2692
  tmp = ngx_array_push(mctx->blocks);
#line 2692
  bl = (ngx_http_ssi_block_t *)tmp;
  }
#line 2693
  if ((unsigned long )bl == (unsigned long )((void *)0)) {
#line 2694
    return ((ngx_int_t )1);
  }
#line 2697
  bl->name = *(*(params + 0));
#line 2698
  bl->bufs = (ngx_chain_t *)((void *)0);
#line 2699
  bl->count = (ngx_uint_t )0;
#line 2701
  ctx->output = 0U;
#line 2702
  ctx->block = 1U;
#line 2704
  return ((ngx_int_t )0);
}
}
#line 2708 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_endblock(ngx_http_request_t *r , ngx_http_ssi_ctx_t *ctx ,
                                       ngx_str_t **params ) 
{ 


  {
#line 2715
  ctx->output = 1U;
#line 2716
  ctx->block = 0U;
#line 2718
  return ((ngx_int_t )0);
}
}
#line 2722 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_date_gmt_local_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t gmt ) 
{ 
  time_t now ;
  ngx_http_ssi_ctx_t *ctx ;
  ngx_str_t *timefmt ;
  struct tm tm ;
  char buf[2048] ;
  void *tmp ;
  u_char *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2732
  v->valid = 1U;
#line 2733
  v->no_cacheable = 0U;
#line 2734
  v->not_found = 0U;
#line 2736
  now = (time_t )ngx_cached_time->sec;
#line 2738
  ctx = (ngx_http_ssi_ctx_t *)*(r->ctx + ngx_http_ssi_filter_module.ctx_index);
#line 2740
  if (ctx) {
#line 2740
    timefmt = & ctx->timefmt;
  } else {
#line 2740
    timefmt = & ngx_http_ssi_timefmt;
  }
#line 2742
  if (timefmt->len == sizeof("%s") - 1UL) {
#line 2742
    if ((int )*(timefmt->data + 0) == 37) {
#line 2742
      if ((int )*(timefmt->data + 1) == 115) {
        {
#line 2745
        tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2745
        v->data = (u_char *)tmp;
        }
#line 2746
        if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 2747
          return ((ngx_int_t )-1);
        }
        {
#line 2750
        tmp___0 = ngx_sprintf(v->data, "%T", now);
#line 2750
        v->len = (unsigned int )(tmp___0 - v->data);
        }
#line 2752
        return ((ngx_int_t )0);
      }
    }
  }
#line 2755
  if (gmt) {
    {
#line 2756
    ngx_libc_gmtime(now, & tm);
    }
  } else {
    {
#line 2758
    ngx_libc_localtime(now, & tm);
    }
  }
  {
#line 2761
  tmp___1 = strftime((char */* __restrict  */)(buf), (size_t )2048, (char const   */* __restrict  */)((char *)timefmt->data),
                     (struct tm  const  */* __restrict  */)(& tm));
#line 2761
  v->len = (unsigned int )tmp___1;
  }
#line 2763
  if (v->len == 0U) {
#line 2764
    return ((ngx_int_t )-1);
  }
  {
#line 2767
  tmp___2 = ngx_pnalloc(r->pool, (size_t )v->len);
#line 2767
  v->data = (u_char *)tmp___2;
  }
#line 2768
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 2769
    return ((ngx_int_t )-1);
  }
  {
#line 2772
  memcpy((void */* __restrict  */)v->data, (void const   */* __restrict  */)(buf),
         (size_t )v->len);
  }
#line 2774
  return ((ngx_int_t )0);
}
}
#line 2778 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_preconfiguration(ngx_conf_t *cf ) 
{ 
  ngx_int_t rc ;
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;
  ngx_http_ssi_command_t *cmd ;
  ngx_http_ssi_main_conf_t *smcf ;
  char *__cil_tmp7 ;

  {
#line 2786
  v = ngx_http_ssi_vars;
  {
#line 2786
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2786
    if (! v->name.len) {
#line 2786
      goto while_break;
    }
    {
#line 2787
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 2788
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 2789
      return ((ngx_int_t )-1);
    }
#line 2792
    var->get_handler = v->get_handler;
#line 2793
    var->data = v->data;
#line 2786
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2796
  smcf = (ngx_http_ssi_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_ssi_filter_module.ctx_index);
#line 2798
  cmd = ngx_http_ssi_commands;
  {
#line 2798
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2798
    if (! cmd->name.len) {
#line 2798
      goto while_break___0;
    }
    {
#line 2799
    rc = ngx_hash_add_key(& smcf->commands, & cmd->name, (void *)cmd, (ngx_uint_t )2);
    }
#line 2802
    if (rc == 0L) {
#line 2803
      goto __Cont;
    }
#line 2806
    if (rc == -3L) {
      {
#line 2807
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "conflicting SSI command \"%V\"",
                         & cmd->name);
      }
    }
#line 2811
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ 
#line 2798
    cmd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2814
  return ((ngx_int_t )0);
}
}
#line 2818 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static void *ngx_http_ssi_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_ssi_main_conf_t *smcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 2823
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_ssi_main_conf_t ));
#line 2823
  smcf = (ngx_http_ssi_main_conf_t *)tmp;
  }
#line 2824
  if ((unsigned long )smcf == (unsigned long )((void *)0)) {
#line 2825
    return ((void *)0);
  }
  {
#line 2828
  smcf->commands.pool = cf->pool;
#line 2829
  smcf->commands.temp_pool = cf->temp_pool;
#line 2831
  tmp___0 = ngx_hash_keys_array_init(& smcf->commands, (ngx_uint_t )1);
  }
#line 2831
  if (tmp___0 != 0L) {
#line 2832
    return ((void *)0);
  }
#line 2835
  return ((void *)smcf);
}
}
#line 2839 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static char *ngx_http_ssi_init_main_conf(ngx_conf_t *cf , void *conf ) 
{ 
  ngx_http_ssi_main_conf_t *smcf ;
  ngx_hash_init_t hash ;
  ngx_int_t tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 2842
  smcf = (ngx_http_ssi_main_conf_t *)conf;
#line 2846
  hash.hash = & smcf->hash;
#line 2847
  hash.key = & ngx_hash_key;
#line 2848
  hash.max_size = (ngx_uint_t )1024;
#line 2849
  hash.bucket_size = ngx_cacheline_size;
#line 2850
  hash.name = (char *)"ssi_command_hash";
#line 2851
  hash.pool = cf->pool;
#line 2852
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2854
  tmp = ngx_hash_init(& hash, (ngx_hash_key_t *)smcf->commands.keys.elts, smcf->commands.keys.nelts);
  }
#line 2854
  if (tmp != 0L) {
#line 2858
    return ((char *)((void *)-1));
  }
#line 2861
  return ((char *)((void *)0));
}
}
#line 2865 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static void *ngx_http_ssi_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_ssi_loc_conf_t *slcf ;
  void *tmp ;

  {
  {
#line 2870
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_ssi_loc_conf_t ));
#line 2870
  slcf = (ngx_http_ssi_loc_conf_t *)tmp;
  }
#line 2871
  if ((unsigned long )slcf == (unsigned long )((void *)0)) {
#line 2872
    return ((void *)0);
  }
#line 2882
  slcf->enable = (ngx_flag_t )-1;
#line 2883
  slcf->silent_errors = (ngx_flag_t )-1;
#line 2884
  slcf->ignore_recycled_buffers = (ngx_flag_t )-1;
#line 2885
  slcf->last_modified = (ngx_flag_t )-1;
#line 2887
  slcf->min_file_chunk = (size_t )-1;
#line 2888
  slcf->value_len = (size_t )-1;
#line 2890
  return ((void *)slcf);
}
}
#line 2894 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static char *ngx_http_ssi_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_ssi_loc_conf_t *prev ;
  ngx_http_ssi_loc_conf_t *conf ;
  char *tmp ;

  {
#line 2897
  prev = (ngx_http_ssi_loc_conf_t *)parent;
#line 2898
  conf = (ngx_http_ssi_loc_conf_t *)child;
#line 2900
  if (conf->enable == -1L) {
#line 2900
    if (prev->enable == -1L) {
#line 2900
      conf->enable = (ngx_flag_t )0;
    } else {
#line 2900
      conf->enable = prev->enable;
    }
  }
#line 2901
  if (conf->silent_errors == -1L) {
#line 2901
    if (prev->silent_errors == -1L) {
#line 2901
      conf->silent_errors = (ngx_flag_t )0;
    } else {
#line 2901
      conf->silent_errors = prev->silent_errors;
    }
  }
#line 2902
  if (conf->ignore_recycled_buffers == -1L) {
#line 2902
    if (prev->ignore_recycled_buffers == -1L) {
#line 2902
      conf->ignore_recycled_buffers = (ngx_flag_t )0;
    } else {
#line 2902
      conf->ignore_recycled_buffers = prev->ignore_recycled_buffers;
    }
  }
#line 2904
  if (conf->last_modified == -1L) {
#line 2904
    if (prev->last_modified == -1L) {
#line 2904
      conf->last_modified = (ngx_flag_t )0;
    } else {
#line 2904
      conf->last_modified = prev->last_modified;
    }
  }
#line 2906
  if (conf->min_file_chunk == 0xffffffffffffffffUL) {
#line 2906
    if (prev->min_file_chunk == 0xffffffffffffffffUL) {
#line 2906
      conf->min_file_chunk = (size_t )1024;
    } else {
#line 2906
      conf->min_file_chunk = prev->min_file_chunk;
    }
  }
#line 2907
  if (conf->value_len == 0xffffffffffffffffUL) {
#line 2907
    if (prev->value_len == 0xffffffffffffffffUL) {
#line 2907
      conf->value_len = (size_t )255;
    } else {
#line 2907
      conf->value_len = prev->value_len;
    }
  }
  {
#line 2909
  tmp = ngx_http_merge_types(cf, & conf->types_keys, & conf->types, & prev->types_keys,
                             & prev->types, ngx_http_html_default_types);
  }
#line 2909
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 2914
    return ((char *)((void *)-1));
  }
#line 2917
  return ((char *)((void *)0));
}
}
#line 2921 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_ssi_filter_module.c"
static ngx_int_t ngx_http_ssi_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 2924
  ngx_http_next_header_filter___3 = ngx_http_top_header_filter;
#line 2925
  ngx_http_top_header_filter = & ngx_http_ssi_header_filter;
#line 2927
  ngx_http_next_body_filter___2 = ngx_http_top_body_filter;
#line 2928
  ngx_http_top_body_filter = & ngx_http_ssi_body_filter;
#line 2930
  return ((ngx_int_t )0);
}
}
#line 121 "src/http/ngx_http.h"
ngx_int_t ngx_http_post_request(ngx_http_request_t *r , ngx_http_posted_request_t *pr ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t ngx_http_postpone_filter_add(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 15
static ngx_int_t ngx_http_postpone_filter_init(ngx_conf_t *cf ) ;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_postpone_filter_module.c"
static ngx_http_module_t ngx_http_postpone_filter_module_ctx  = 
#line 18
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_postpone_filter_init,
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_postpone_filter_module.c"
ngx_module_t ngx_http_postpone_filter_module  = 
#line 33
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_postpone_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 49 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___3)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 52 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t ngx_http_postpone_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_connection_t *c ;
  ngx_http_postponed_request_t *pr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp10 ;

  {
#line 58
  c = r->connection;
#line 63
  if ((unsigned long )r != (unsigned long )c->data) {
#line 65
    if (in) {
      {
#line 66
      tmp = ngx_http_postpone_filter_add(r, in);
      }
#line 66
      if (tmp != 0L) {
#line 67
        return ((ngx_int_t )-1);
      }
#line 70
      return ((ngx_int_t )0);
    }
#line 79
    return ((ngx_int_t )0);
  }
#line 82
  if ((unsigned long )r->postponed == (unsigned long )((void *)0)) {
#line 84
    if (in) {
      {
#line 85
      tmp___0 = (*ngx_http_next_body_filter___3)(r->main, in);
      }
#line 85
      return (tmp___0);
    } else
#line 84
    if (c->buffered) {
      {
#line 85
      tmp___0 = (*ngx_http_next_body_filter___3)(r->main, in);
      }
#line 85
      return (tmp___0);
    }
#line 88
    return ((ngx_int_t )0);
  }
#line 91
  if (in) {
    {
#line 92
    tmp___1 = ngx_http_postpone_filter_add(r, in);
    }
#line 92
    if (tmp___1 != 0L) {
#line 93
      return ((ngx_int_t )-1);
    }
  }
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    pr = r->postponed;
#line 100
    if (pr->request) {
      {
#line 106
      r->postponed = pr->next;
#line 108
      c->data = (void *)pr->request;
#line 110
      tmp___2 = ngx_http_post_request(pr->request, (ngx_http_posted_request_t *)((void *)0));
      }
#line 110
      return (tmp___2);
    }
#line 113
    if ((unsigned long )pr->out == (unsigned long )((void *)0)) {
#line 114
      if ((c->log)->log_level >= 2UL) {
        {
#line 114
        ngx_log_error_core((ngx_uint_t )2, c->log, 0, "http postpone filter NULL output");
        }
      }
    } else {
      {
#line 122
      tmp___3 = (*ngx_http_next_body_filter___3)(r->main, pr->out);
      }
#line 122
      if (tmp___3 == -1L) {
#line 123
        return ((ngx_int_t )-1);
      }
    }
#line 127
    r->postponed = pr->next;
#line 97
    if (! r->postponed) {
#line 97
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return ((ngx_int_t )0);
}
}
#line 135 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t ngx_http_postpone_filter_add(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_http_postponed_request_t *pr ;
  ngx_http_postponed_request_t **ppr ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 140
  if (r->postponed) {
#line 141
    pr = r->postponed;
    {
#line 141
    while (1) {
      while_continue: /* CIL Label */ ;
#line 141
      if (! pr->next) {
#line 141
        goto while_break;
      }
#line 141
      pr = pr->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 143
    if ((unsigned long )pr->request == (unsigned long )((void *)0)) {
#line 144
      goto found;
    }
#line 147
    ppr = & pr->next;
  } else {
#line 150
    ppr = & r->postponed;
  }
  {
#line 153
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_postponed_request_t ));
#line 153
  pr = (ngx_http_postponed_request_t *)tmp;
  }
#line 154
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 155
    return ((ngx_int_t )-1);
  }
#line 158
  *ppr = pr;
#line 160
  pr->request = (ngx_http_request_t *)((void *)0);
#line 161
  pr->out = (ngx_chain_t *)((void *)0);
#line 162
  pr->next = (ngx_http_postponed_request_t *)((void *)0);
  found: 
  {
#line 166
  tmp___0 = ngx_chain_add_copy(r->pool, & pr->out, in);
  }
#line 166
  if (tmp___0 == 0L) {
#line 167
    return ((ngx_int_t )0);
  }
#line 170
  return ((ngx_int_t )-1);
}
}
#line 174 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_postpone_filter_module.c"
static ngx_int_t ngx_http_postpone_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 177
  ngx_http_next_body_filter___3 = ngx_http_top_body_filter;
#line 178
  ngx_http_top_body_filter = & ngx_http_postpone_filter;
#line 180
  return ((ngx_int_t )0);
}
}
#line 83 "src/core/ngx_palloc.h"
ngx_int_t ngx_pfree(ngx_pool_t *pool , void *p ) ;
#line 492 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_gzip_ok(ngx_http_request_t *r ) ;
#line 250 "/home/khheo/.linuxbrew/include/zlib.h"
extern int deflate(z_streamp strm , int flush ) ;
#line 363
extern int deflateEnd(z_streamp strm ) ;
#line 1725
extern uLong crc32(uLong crc , Bytef const   *buf , uInt len ) ;
#line 1768
extern int deflateInit2_(z_streamp strm , int level , int method , int windowBits ,
                         int memLevel , int strategy , char const   *version , int stream_size ) ;
#line 88 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static void ngx_http_gzip_filter_memory(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 90
static ngx_int_t ngx_http_gzip_filter_buffer(ngx_http_gzip_ctx_t *ctx , ngx_chain_t *in ) ;
#line 92
static ngx_int_t ngx_http_gzip_filter_deflate_start(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 94
static ngx_int_t ngx_http_gzip_filter_gzheader(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 96
static ngx_int_t ngx_http_gzip_filter_add_data(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 98
static ngx_int_t ngx_http_gzip_filter_get_buf(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 100
static ngx_int_t ngx_http_gzip_filter_deflate(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 102
static ngx_int_t ngx_http_gzip_filter_deflate_end(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 105
static void *ngx_http_gzip_filter_alloc(void *opaque , u_int items , u_int size ) ;
#line 107
static void ngx_http_gzip_filter_free(void *opaque , void *address ) ;
#line 108
static void ngx_http_gzip_filter_free_copy_buf(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) ;
#line 111
static ngx_int_t ngx_http_gzip_add_variables(ngx_conf_t *cf ) ;
#line 112
static ngx_int_t ngx_http_gzip_ratio_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 115
static ngx_int_t ngx_http_gzip_filter_init(ngx_conf_t *cf ) ;
#line 116
static void *ngx_http_gzip_create_conf(ngx_conf_t *cf ) ;
#line 117
static char *ngx_http_gzip_merge_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 119
static char *ngx_http_gzip_window(ngx_conf_t *cf , void *post , void *data ) ;
#line 120
static char *ngx_http_gzip_hash(ngx_conf_t *cf , void *post , void *data ) ;
#line 123 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_conf_num_bounds_t ngx_http_gzip_comp_level_bounds  =    {& ngx_conf_check_num_bounds, (ngx_int_t )1, (ngx_int_t )9};
#line 127 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static char *(*ngx_http_gzip_window_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_gzip_window;
#line 128 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static char *(*ngx_http_gzip_hash_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_gzip_hash;
#line 131 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_command_t ngx_http_gzip_filter_commands[10]  = 
#line 131
  {      {{sizeof("gzip") - 1UL, (u_char *)"gzip"}, (ngx_uint_t )1308623360, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->enable),
      (void *)0}, 
        {{sizeof("gzip_buffers") - 1UL, (u_char *)"gzip_buffers"}, (ngx_uint_t )234881028,
      & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->bufs), (void *)0}, 
        {{sizeof("gzip_types") - 1UL, (u_char *)"gzip_types"}, (ngx_uint_t )234883072,
      & ngx_http_types_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->types_keys), (void *)(& ngx_http_html_default_types[0])}, 
        {{sizeof("gzip_comp_level") - 1UL,
       (u_char *)"gzip_comp_level"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->level),
      (void *)(& ngx_http_gzip_comp_level_bounds)}, 
        {{sizeof("gzip_window") - 1UL, (u_char *)"gzip_window"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->wbits), (void *)(& ngx_http_gzip_window_p)}, 
        {{sizeof("gzip_hash") - 1UL,
       (u_char *)"gzip_hash"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->memlevel), (void *)(& ngx_http_gzip_hash_p)}, 
        {{sizeof("postpone_gzipping") - 1UL,
       (u_char *)"postpone_gzipping"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->postpone_gzipping),
      (void *)0}, 
        {{sizeof("gzip_no_buffer") - 1UL, (u_char *)"gzip_no_buffer"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->no_buffer), (void *)0}, 
        {{sizeof("gzip_min_length") - 1UL, (u_char *)"gzip_min_length"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_gzip_conf_t *)0)->min_length), (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 201 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_http_module_t ngx_http_gzip_filter_module_ctx  = 
#line 201
     {& ngx_http_gzip_add_variables, & ngx_http_gzip_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_gzip_create_conf,
    & ngx_http_gzip_merge_conf};
#line 216 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
ngx_module_t ngx_http_gzip_filter_module  = 
#line 216
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_gzip_filter_module_ctx),
    ngx_http_gzip_filter_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 232 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_str_t ngx_http_gzip_ratio  =    {sizeof("gzip_ratio") - 1UL, (u_char *)"gzip_ratio"};
#line 234 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___4)(ngx_http_request_t *r )  ;
#line 235 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___4)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 237 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_uint_t ngx_http_gzip_assume_intel  ;
#line 240 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_table_elt_t *h ;
  ngx_http_gzip_ctx_t *ctx ;
  ngx_http_gzip_conf_t *conf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 247
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 249
  if (! conf->enable) {
    {
#line 260
    tmp = (*ngx_http_next_header_filter___4)(r);
    }
#line 260
    return (tmp);
  } else
#line 249
  if (r->headers_out.status != 200UL) {
#line 249
    if (r->headers_out.status != 403UL) {
#line 249
      if (r->headers_out.status != 404UL) {
        {
#line 260
        tmp = (*ngx_http_next_header_filter___4)(r);
        }
#line 260
        return (tmp);
      } else {
#line 249
        goto _L___2;
      }
    } else {
#line 249
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 249
  if (r->headers_out.content_encoding) {
#line 249
    if ((r->headers_out.content_encoding)->value.len) {
      {
#line 260
      tmp = (*ngx_http_next_header_filter___4)(r);
      }
#line 260
      return (tmp);
    } else {
#line 249
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 249
  if (r->headers_out.content_length_n != -1L) {
#line 249
    if (r->headers_out.content_length_n < conf->min_length) {
      {
#line 260
      tmp = (*ngx_http_next_header_filter___4)(r);
      }
#line 260
      return (tmp);
    } else {
#line 249
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 249
    tmp___0 = ngx_http_test_content_type(r, & conf->types);
    }
#line 249
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 260
      tmp = (*ngx_http_next_header_filter___4)(r);
      }
#line 260
      return (tmp);
    } else
#line 249
    if (r->header_only) {
      {
#line 260
      tmp = (*ngx_http_next_header_filter___4)(r);
      }
#line 260
      return (tmp);
    }
  }
#line 263
  r->gzip_vary = 1U;
#line 277
  if (! r->gzip_tested) {
    {
#line 278
    tmp___2 = ngx_http_gzip_ok(r);
    }
#line 278
    if (tmp___2 != 0L) {
      {
#line 279
      tmp___1 = (*ngx_http_next_header_filter___4)(r);
      }
#line 279
      return (tmp___1);
    }
  } else
#line 282
  if (! r->gzip_ok) {
    {
#line 283
    tmp___3 = (*ngx_http_next_header_filter___4)(r);
    }
#line 283
    return (tmp___3);
  }
  {
#line 286
  tmp___4 = ngx_pcalloc(r->pool, sizeof(ngx_http_gzip_ctx_t ));
#line 286
  ctx = (ngx_http_gzip_ctx_t *)tmp___4;
  }
#line 287
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 288
    return ((ngx_int_t )-1);
  }
  {
#line 291
  *(r->ctx + ngx_http_gzip_filter_module.ctx_index) = (void *)ctx;
#line 293
  ctx->request = r;
#line 294
  ctx->buffering = (unsigned int )(conf->postpone_gzipping != 0UL);
#line 296
  ngx_http_gzip_filter_memory(r, ctx);
#line 298
  tmp___5 = ngx_list_push(& r->headers_out.headers);
#line 298
  h = (ngx_table_elt_t *)tmp___5;
  }
#line 299
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 300
    return ((ngx_int_t )-1);
  }
#line 303
  h->hash = (ngx_uint_t )1;
#line 304
  h->key.len = sizeof("Content-Encoding") - 1UL;
#line 304
  h->key.data = (u_char *)"Content-Encoding";
#line 305
  h->value.len = sizeof("gzip") - 1UL;
#line 305
  h->value.data = (u_char *)"gzip";
#line 306
  r->headers_out.content_encoding = h;
#line 308
  r->main_filter_need_in_memory = 1U;
#line 310
  r->headers_out.content_length_n = (off_t )-1;
#line 310
  if (r->headers_out.content_length) {
#line 310
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 310
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 311
  r->allow_ranges = 0U;
#line 311
  if (r->headers_out.accept_ranges) {
#line 311
    (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 311
    r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 312
  ngx_http_weak_etag(r);
#line 314
  tmp___6 = (*ngx_http_next_header_filter___4)(r);
  }
#line 314
  return (tmp___6);
}
}
#line 318 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  int rc ;
  ngx_uint_t flush ;
  ngx_chain_t *cl ;
  ngx_http_gzip_ctx_t *ctx ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  int tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;

  {
#line 326
  ctx = (ngx_http_gzip_ctx_t *)*(r->ctx + ngx_http_gzip_filter_module.ctx_index);
#line 328
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 329
    tmp = (*ngx_http_next_body_filter___4)(r, in);
    }
#line 329
    return (tmp);
  } else
#line 328
  if (ctx->done) {
    {
#line 329
    tmp = (*ngx_http_next_body_filter___4)(r, in);
    }
#line 329
    return (tmp);
  } else
#line 328
  if (r->header_only) {
    {
#line 329
    tmp = (*ngx_http_next_body_filter___4)(r, in);
    }
#line 329
    return (tmp);
  }
#line 335
  if (ctx->buffering) {
#line 346
    if (in) {
      {
#line 347
      tmp___0 = ngx_http_gzip_filter_buffer(ctx, in);
      }
      {
#line 349
      if (tmp___0 == 0L) {
#line 349
        goto case_0;
      }
#line 352
      if (tmp___0 == -4L) {
#line 352
        goto case_neg_4;
      }
#line 356
      goto switch_default;
      case_0: /* CIL Label */ 
#line 350
      return ((ngx_int_t )0);
      case_neg_4: /* CIL Label */ 
#line 353
      in = (ngx_chain_t *)((void *)0);
#line 354
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 357
      goto failed;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 361
      ctx->buffering = 0U;
    }
  }
#line 365
  if ((unsigned long )ctx->preallocated == (unsigned long )((void *)0)) {
    {
#line 366
    tmp___1 = ngx_http_gzip_filter_deflate_start(r, ctx);
    }
#line 366
    if (tmp___1 != 0L) {
#line 367
      goto failed;
    }
  }
#line 371
  if (in) {
    {
#line 372
    tmp___2 = ngx_chain_add_copy(r->pool, & ctx->in, in);
    }
#line 372
    if (tmp___2 != 0L) {
#line 373
      goto failed;
    }
#line 376
    (r->connection)->buffered |= 32U;
  }
#line 379
  if (ctx->nomem) {
    {
#line 383
    tmp___3 = (*ngx_http_next_body_filter___4)(r, (ngx_chain_t *)((void *)0));
    }
#line 383
    if (tmp___3 == -1L) {
#line 384
      goto failed;
    }
    {
#line 387
    cl = (ngx_chain_t *)((void *)0);
#line 389
    ngx_chain_update_chains(r->pool, & ctx->free, & ctx->busy, & cl, (ngx_buf_tag_t )(& ngx_http_gzip_filter_module));
#line 391
    ctx->nomem = 0U;
#line 392
    flush = (ngx_uint_t )0;
    }
  } else
#line 395
  if (ctx->busy) {
#line 395
    flush = (ngx_uint_t )1;
  } else {
#line 395
    flush = (ngx_uint_t )0;
  }
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 402
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 406
      tmp___4 = ngx_http_gzip_filter_add_data(r, ctx);
#line 406
      rc = (int )tmp___4;
      }
#line 408
      if (rc == -5) {
#line 409
        goto while_break___0;
      }
#line 412
      if (rc == -2) {
#line 413
        goto __Cont;
      }
      {
#line 419
      tmp___5 = ngx_http_gzip_filter_get_buf(r, ctx);
#line 419
      rc = (int )tmp___5;
      }
#line 421
      if (rc == -5) {
#line 422
        goto while_break___0;
      }
#line 425
      if (rc == -1) {
#line 426
        goto failed;
      }
      {
#line 430
      tmp___6 = ngx_http_gzip_filter_deflate(r, ctx);
#line 430
      rc = (int )tmp___6;
      }
#line 432
      if (rc == 0) {
#line 433
        goto while_break___0;
      }
#line 436
      if (rc == -1) {
#line 437
        goto failed;
      }
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 443
    if ((unsigned long )ctx->out == (unsigned long )((void *)0)) {
#line 443
      if (! flush) {
        {
#line 444
        ngx_http_gzip_filter_free_copy_buf(r, ctx);
        }
#line 446
        if (ctx->busy) {
#line 446
          tmp___7 = -2;
        } else {
#line 446
          tmp___7 = 0;
        }
#line 446
        return ((ngx_int_t )tmp___7);
      }
    }
#line 449
    if (! ctx->gzheader) {
      {
#line 450
      tmp___8 = ngx_http_gzip_filter_gzheader(r, ctx);
      }
#line 450
      if (tmp___8 != 0L) {
#line 451
        goto failed;
      }
    }
    {
#line 455
    tmp___9 = (*ngx_http_next_body_filter___4)(r, ctx->out);
#line 455
    rc = (int )tmp___9;
    }
#line 457
    if (rc == -1) {
#line 458
      goto failed;
    }
    {
#line 461
    ngx_http_gzip_filter_free_copy_buf(r, ctx);
#line 463
    ngx_chain_update_chains(r->pool, & ctx->free, & ctx->busy, & ctx->out, (ngx_buf_tag_t )(& ngx_http_gzip_filter_module));
#line 465
    ctx->last_out = & ctx->out;
#line 467
    ctx->nomem = 0U;
#line 468
    flush = (ngx_uint_t )0;
    }
#line 470
    if (ctx->done) {
#line 471
      return ((ngx_int_t )rc);
    }
  }
  while_break: /* CIL Label */ ;
  }
  failed: 
#line 479
  ctx->done = 1U;
#line 481
  if (ctx->preallocated) {
    {
#line 482
    deflateEnd(& ctx->zstream);
#line 484
    ngx_pfree(r->pool, ctx->preallocated);
    }
  }
  {
#line 487
  ngx_http_gzip_filter_free_copy_buf(r, ctx);
  }
#line 489
  return ((ngx_int_t )-1);
}
}
#line 493 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static void ngx_http_gzip_filter_memory(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  int wbits ;
  int memlevel ;
  ngx_http_gzip_conf_t *conf ;
  int tmp ;

  {
#line 499
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 501
  wbits = (int )conf->wbits;
#line 502
  memlevel = (int )conf->memlevel;
#line 504
  if (r->headers_out.content_length_n > 0L) {
    {
#line 508
    while (1) {
      while_continue: /* CIL Label */ ;
#line 508
      if (! (r->headers_out.content_length_n < (off_t )((1 << (wbits - 1)) - 262))) {
#line 508
        goto while_break;
      }
#line 509
      wbits --;
#line 510
      memlevel --;
    }
    while_break: /* CIL Label */ ;
    }
#line 513
    if (memlevel < 1) {
#line 514
      memlevel = 1;
    }
  }
#line 518
  ctx->wbits = wbits;
#line 519
  ctx->memlevel = memlevel;
#line 533
  if (! ngx_http_gzip_assume_intel) {
#line 534
    ctx->allocated = (ngx_uint_t )((8192 + (1 << (wbits + 2))) + (1 << (memlevel + 9)));
  } else {
#line 545
    if (conf->level == 1L) {
#line 546
      if (wbits < 13) {
#line 546
        wbits = 13;
      } else {
#line 546
        wbits = wbits;
      }
    }
#line 549
    if (memlevel < 8) {
#line 549
      tmp = 8;
    } else {
#line 549
      tmp = memlevel;
    }
#line 549
    ctx->allocated = (ngx_uint_t )(((8208 + (1 << (wbits + 2))) + (1 << (tmp + 8))) + (1 << (memlevel + 8)));
#line 552
    ctx->intel = 1U;
  }
#line 554
  return;
}
}
#line 557 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_buffer(ngx_http_gzip_ctx_t *ctx , ngx_chain_t *in ) 
{ 
  size_t size ;
  size_t buffered ;
  ngx_buf_t *b ;
  ngx_buf_t *buf ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_request_t *r ;
  ngx_http_gzip_conf_t *conf ;
  void *tmp ;
  int tmp___0 ;

  {
#line 566
  r = ctx->request;
#line 568
  (r->connection)->buffered |= 32U;
#line 570
  buffered = (size_t )0;
#line 571
  ll = & ctx->in;
#line 573
  cl = ctx->in;
  {
#line 573
  while (1) {
    while_continue: /* CIL Label */ ;
#line 573
    if (! cl) {
#line 573
      goto while_break;
    }
#line 574
    buffered += (size_t )((cl->buf)->last - (cl->buf)->pos);
#line 575
    ll = & cl->next;
#line 573
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
  {
#line 580
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 580
    if (! in) {
#line 580
      goto while_break___0;
    }
    {
#line 581
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 582
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 583
      return ((ngx_int_t )-1);
    }
#line 586
    b = in->buf;
#line 588
    size = (size_t )(b->last - b->pos);
#line 589
    buffered += size;
#line 591
    if (b->flush) {
#line 592
      ctx->buffering = 0U;
    } else
#line 591
    if (b->last_buf) {
#line 592
      ctx->buffering = 0U;
    } else
#line 591
    if (buffered > conf->postpone_gzipping) {
#line 592
      ctx->buffering = 0U;
    }
#line 595
    if (ctx->buffering) {
#line 595
      if (size) {
        {
#line 597
        buf = ngx_create_temp_buf(r->pool, size);
        }
#line 598
        if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 599
          return ((ngx_int_t )-1);
        }
        {
#line 602
        tmp = memcpy((void */* __restrict  */)buf->pos, (void const   */* __restrict  */)b->pos,
                     size);
#line 602
        buf->last = (u_char *)tmp + size;
#line 603
        b->pos = b->last;
#line 605
        buf->last_buf = b->last_buf;
#line 606
        buf->tag = (ngx_buf_tag_t )(& ngx_http_gzip_filter_module);
#line 608
        cl->buf = buf;
        }
      } else {
#line 611
        cl->buf = b;
      }
    } else {
#line 611
      cl->buf = b;
    }
#line 614
    *ll = cl;
#line 615
    ll = & cl->next;
#line 616
    in = in->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 619
  *ll = (ngx_chain_t *)((void *)0);
#line 621
  if (ctx->buffering) {
#line 621
    tmp___0 = 0;
  } else {
#line 621
    tmp___0 = -4;
  }
#line 621
  return ((ngx_int_t )tmp___0);
}
}
#line 625 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_deflate_start(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  int rc ;
  ngx_http_gzip_conf_t *conf ;
  uLong tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 632
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 634
  ctx->preallocated = ngx_palloc(r->pool, ctx->allocated);
  }
#line 635
  if ((unsigned long )ctx->preallocated == (unsigned long )((void *)0)) {
#line 636
    return ((ngx_int_t )-1);
  }
  {
#line 639
  ctx->free_mem = (char *)ctx->preallocated;
#line 641
  ctx->zstream.zalloc = & ngx_http_gzip_filter_alloc;
#line 642
  ctx->zstream.zfree = & ngx_http_gzip_filter_free;
#line 643
  ctx->zstream.opaque = (voidpf )ctx;
#line 645
  rc = deflateInit2_(& ctx->zstream, (int )conf->level, 8, - ctx->wbits, ctx->memlevel,
                     0, "1.2.11", (int )sizeof(z_stream ));
  }
#line 648
  if (rc != 0) {
#line 649
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 649
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "deflateInit2() failed: %d",
                         rc);
      }
    }
#line 651
    return ((ngx_int_t )-1);
  }
  {
#line 654
  ctx->last_out = & ctx->out;
#line 655
  tmp = crc32((uLong )0L, (Bytef const   *)0, (uInt )0);
#line 655
  ctx->crc32 = (uint32_t )tmp;
#line 656
  ctx->flush = 0U;
  }
#line 658
  return ((ngx_int_t )0);
}
}
#line 667 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static u_char gzheader[10]  = 
#line 667
  {      (u_char )31,      (u_char )139,      (u_char )8,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )3};
#line 662 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_gzheader(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  void *tmp ;

  {
  {
#line 670
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 670
  b = (ngx_buf_t *)tmp;
  }
#line 671
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 672
    return ((ngx_int_t )-1);
  }
  {
#line 675
  b->memory = 1U;
#line 676
  b->pos = gzheader;
#line 677
  b->last = b->pos + 10;
#line 679
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 680
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 681
    return ((ngx_int_t )-1);
  }
#line 684
  cl->buf = b;
#line 685
  cl->next = ctx->out;
#line 686
  ctx->out = cl;
#line 688
  ctx->gzheader = 1U;
#line 690
  return ((ngx_int_t )0);
}
}
#line 694 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_add_data(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  ngx_chain_t *cl ;
  uLong tmp ;

  {
#line 699
  if (ctx->zstream.avail_in) {
#line 700
    return ((ngx_int_t )0);
  } else
#line 699
  if (ctx->flush != 0U) {
#line 700
    return ((ngx_int_t )0);
  } else
#line 699
  if (ctx->redo) {
#line 700
    return ((ngx_int_t )0);
  }
#line 706
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
#line 707
    return ((ngx_int_t )-5);
  }
#line 710
  if (ctx->copy_buf) {
#line 717
    (ctx->copy_buf)->next = ctx->copied;
#line 718
    ctx->copied = ctx->copy_buf;
#line 719
    ctx->copy_buf = (ngx_chain_t *)((void *)0);
  }
#line 722
  cl = ctx->in;
#line 723
  ctx->in_buf = cl->buf;
#line 724
  ctx->in = cl->next;
#line 726
  if ((unsigned long )(ctx->in_buf)->tag == (unsigned long )((ngx_buf_tag_t )(& ngx_http_gzip_filter_module))) {
#line 727
    ctx->copy_buf = cl;
  } else {
#line 730
    cl->next = (r->pool)->chain;
#line 730
    (r->pool)->chain = cl;
  }
#line 733
  ctx->zstream.next_in = (ctx->in_buf)->pos;
#line 734
  ctx->zstream.avail_in = (uInt )((ctx->in_buf)->last - (ctx->in_buf)->pos);
#line 741
  if ((ctx->in_buf)->last_buf) {
#line 742
    ctx->flush = 4U;
  } else
#line 744
  if ((ctx->in_buf)->flush) {
#line 745
    ctx->flush = 2U;
  }
#line 748
  if (ctx->zstream.avail_in) {
    {
#line 750
    tmp = crc32((uLong )ctx->crc32, (Bytef const   *)ctx->zstream.next_in, ctx->zstream.avail_in);
#line 750
    ctx->crc32 = (uint32_t )tmp;
    }
  } else
#line 753
  if (ctx->flush == 0U) {
#line 754
    return ((ngx_int_t )-2);
  }
#line 757
  return ((ngx_int_t )0);
}
}
#line 761 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_get_buf(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  ngx_chain_t *cl ;
  ngx_http_gzip_conf_t *conf ;

  {
#line 767
  if (ctx->zstream.avail_out) {
#line 768
    return ((ngx_int_t )0);
  }
#line 771
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 773
  if (ctx->free) {
#line 775
    cl = ctx->free;
#line 776
    ctx->out_buf = cl->buf;
#line 777
    ctx->free = cl->next;
#line 779
    cl->next = (r->pool)->chain;
#line 779
    (r->pool)->chain = cl;
  } else
#line 781
  if (ctx->bufs < conf->bufs.num) {
    {
#line 783
    ctx->out_buf = ngx_create_temp_buf(r->pool, conf->bufs.size);
    }
#line 784
    if ((unsigned long )ctx->out_buf == (unsigned long )((void *)0)) {
#line 785
      return ((ngx_int_t )-1);
    }
#line 788
    (ctx->out_buf)->tag = (ngx_buf_tag_t )(& ngx_http_gzip_filter_module);
#line 789
    (ctx->out_buf)->recycled = 1U;
#line 790
    (ctx->bufs) ++;
  } else {
#line 793
    ctx->nomem = 1U;
#line 794
    return ((ngx_int_t )-5);
  }
#line 797
  ctx->zstream.next_out = (ctx->out_buf)->pos;
#line 798
  ctx->zstream.avail_out = (uInt )conf->bufs.size;
#line 800
  return ((ngx_int_t )0);
}
}
#line 804 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_deflate(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  int rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_gzip_conf_t *conf ;
  void *tmp ;
  off_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp10 ;

  {
  {
#line 818
  rc = deflate(& ctx->zstream, (int )ctx->flush);
  }
#line 820
  if (rc != 0) {
#line 820
    if (rc != 1) {
#line 820
      if (rc != -5) {
#line 821
        if (((r->connection)->log)->log_level >= 2UL) {
          {
#line 821
          ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "deflate() failed: %d, %d",
                             ctx->flush, rc);
          }
        }
#line 823
        return ((ngx_int_t )-1);
      }
    }
  }
#line 836
  if (ctx->zstream.next_in) {
#line 837
    (ctx->in_buf)->pos = ctx->zstream.next_in;
#line 839
    if (ctx->zstream.avail_in == 0U) {
#line 840
      ctx->zstream.next_in = (Bytef *)((void *)0);
    }
  }
#line 844
  (ctx->out_buf)->last = ctx->zstream.next_out;
#line 846
  if (ctx->zstream.avail_out == 0U) {
    {
#line 850
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 851
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 852
      return ((ngx_int_t )-1);
    }
#line 855
    cl->buf = ctx->out_buf;
#line 856
    cl->next = (ngx_chain_t *)((void *)0);
#line 857
    *(ctx->last_out) = cl;
#line 858
    ctx->last_out = & cl->next;
#line 860
    ctx->redo = 1U;
#line 862
    return ((ngx_int_t )-2);
  }
#line 865
  ctx->redo = 0U;
#line 867
  if (ctx->flush == 2U) {
    {
#line 869
    ctx->flush = 0U;
#line 871
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 872
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 873
      return ((ngx_int_t )-1);
    }
#line 876
    b = ctx->out_buf;
#line 878
    if (b->temporary) {
#line 878
      tmp___0 = b->last - b->pos;
    } else
#line 878
    if (b->memory) {
#line 878
      tmp___0 = b->last - b->pos;
    } else
#line 878
    if (b->mmap) {
#line 878
      tmp___0 = b->last - b->pos;
    } else {
#line 878
      tmp___0 = b->file_last - b->file_pos;
    }
#line 878
    if (tmp___0 == 0L) {
      {
#line 880
      tmp = ngx_pcalloc((ctx->request)->pool, sizeof(ngx_buf_t ));
#line 880
      b = (ngx_buf_t *)tmp;
      }
#line 881
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 882
        return ((ngx_int_t )-1);
      }
    } else {
#line 886
      ctx->zstream.avail_out = (uInt )0;
    }
#line 889
    b->flush = 1U;
#line 891
    cl->buf = b;
#line 892
    cl->next = (ngx_chain_t *)((void *)0);
#line 893
    *(ctx->last_out) = cl;
#line 894
    ctx->last_out = & cl->next;
#line 896
    (r->connection)->buffered &= 4294967263U;
#line 898
    return ((ngx_int_t )0);
  }
#line 901
  if (rc == 1) {
    {
#line 903
    tmp___1 = ngx_http_gzip_filter_deflate_end(r, ctx);
    }
#line 903
    if (tmp___1 != 0L) {
#line 904
      return ((ngx_int_t )-1);
    }
#line 907
    return ((ngx_int_t )0);
  }
#line 910
  conf = (ngx_http_gzip_conf_t *)*(r->loc_conf + ngx_http_gzip_filter_module.ctx_index);
#line 912
  if (conf->no_buffer) {
#line 912
    if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
      {
#line 914
      cl = ngx_alloc_chain_link(r->pool);
      }
#line 915
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 916
        return ((ngx_int_t )-1);
      }
#line 919
      cl->buf = ctx->out_buf;
#line 920
      cl->next = (ngx_chain_t *)((void *)0);
#line 921
      *(ctx->last_out) = cl;
#line 922
      ctx->last_out = & cl->next;
#line 924
      return ((ngx_int_t )0);
    }
  }
#line 927
  return ((ngx_int_t )-2);
}
}
#line 931 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_deflate_end(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  int rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  struct gztrailer *trailer ;
  char *__cil_tmp7 ;

  {
  {
#line 940
  ctx->zin = ctx->zstream.total_in;
#line 941
  ctx->zout = (10UL + ctx->zstream.total_out) + 8UL;
#line 943
  rc = deflateEnd(& ctx->zstream);
  }
#line 945
  if (rc != 0) {
#line 946
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 946
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "deflateEnd() failed: %d",
                         rc);
      }
    }
#line 948
    return ((ngx_int_t )-1);
  }
  {
#line 951
  ngx_pfree(r->pool, ctx->preallocated);
#line 953
  cl = ngx_alloc_chain_link(r->pool);
  }
#line 954
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 955
    return ((ngx_int_t )-1);
  }
#line 958
  cl->buf = ctx->out_buf;
#line 959
  cl->next = (ngx_chain_t *)((void *)0);
#line 960
  *(ctx->last_out) = cl;
#line 961
  ctx->last_out = & cl->next;
#line 963
  if (ctx->zstream.avail_out >= 8U) {
#line 964
    trailer = (struct gztrailer *)(ctx->out_buf)->last;
#line 965
    (ctx->out_buf)->last += 8;
#line 966
    (ctx->out_buf)->last_buf = 1U;
  } else {
    {
#line 969
    b = ngx_create_temp_buf(r->pool, (size_t )8);
    }
#line 970
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 971
      return ((ngx_int_t )-1);
    }
    {
#line 974
    b->last_buf = 1U;
#line 976
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 977
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 978
      return ((ngx_int_t )-1);
    }
#line 981
    cl->buf = b;
#line 982
    cl->next = (ngx_chain_t *)((void *)0);
#line 983
    *(ctx->last_out) = cl;
#line 984
    ctx->last_out = & cl->next;
#line 985
    trailer = (struct gztrailer *)b->pos;
#line 986
    b->last += 8;
  }
#line 991
  trailer->crc32 = ctx->crc32;
#line 992
  trailer->zlen = (uint32_t )ctx->zin;
#line 1008
  ctx->zstream.avail_in = (uInt )0;
#line 1009
  ctx->zstream.avail_out = (uInt )0;
#line 1011
  ctx->done = 1U;
#line 1013
  (r->connection)->buffered &= 4294967263U;
#line 1015
  return ((ngx_int_t )0);
}
}
#line 1019 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static void *ngx_http_gzip_filter_alloc(void *opaque , u_int items , u_int size ) 
{ 
  ngx_http_gzip_ctx_t *ctx ;
  void *p ;
  ngx_uint_t alloc ;
  char *__cil_tmp7 ;

  {
#line 1022
  ctx = (ngx_http_gzip_ctx_t *)opaque;
#line 1027
  alloc = (ngx_uint_t )(items * size);
#line 1029
  if (items == 1U) {
#line 1029
    if (alloc % 512UL != 0UL) {
#line 1029
      if (alloc < 8192UL) {
#line 1036
        alloc = (ngx_uint_t )8192;
      }
    }
  }
#line 1039
  if (alloc <= ctx->allocated) {
#line 1040
    p = (void *)ctx->free_mem;
#line 1041
    ctx->free_mem += alloc;
#line 1042
    ctx->allocated -= alloc;
#line 1048
    return (p);
  }
#line 1051
  if (ctx->intel) {
#line 1052
    if ((((ctx->request)->connection)->log)->log_level >= 2UL) {
      {
#line 1052
      ngx_log_error_core((ngx_uint_t )2, ((ctx->request)->connection)->log, 0, "gzip filter failed to use preallocated memory: %ud of %ui",
                         items * size, ctx->allocated);
      }
    }
  } else {
#line 1057
    ngx_http_gzip_assume_intel = (ngx_uint_t )1;
  }
  {
#line 1060
  p = ngx_palloc((ctx->request)->pool, (size_t )(items * size));
  }
#line 1062
  return (p);
}
}
#line 1066 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static void ngx_http_gzip_filter_free(void *opaque , void *address ) 
{ 


  {
#line 1075
  return;
}
}
#line 1078 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static void ngx_http_gzip_filter_free_copy_buf(ngx_http_request_t *r , ngx_http_gzip_ctx_t *ctx ) 
{ 
  ngx_chain_t *cl ;

  {
#line 1084
  cl = ctx->copied;
  {
#line 1084
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1084
    if (! cl) {
#line 1084
      goto while_break;
    }
    {
#line 1085
    ngx_pfree(r->pool, (void *)(cl->buf)->start);
#line 1084
    cl = cl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1088
  ctx->copied = (ngx_chain_t *)((void *)0);
#line 1089
  return;
}
}
#line 1092 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;

  {
  {
#line 1097
  var = ngx_http_add_variable(cf, & ngx_http_gzip_ratio, (ngx_uint_t )8);
  }
#line 1098
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 1099
    return ((ngx_int_t )-1);
  }
#line 1102
  var->get_handler = & ngx_http_gzip_ratio_variable;
#line 1104
  return ((ngx_int_t )0);
}
}
#line 1108 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_ratio_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  ngx_uint_t zint ;
  ngx_uint_t zfrac ;
  ngx_http_gzip_ctx_t *ctx ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1115
  ctx = (ngx_http_gzip_ctx_t *)*(r->ctx + ngx_http_gzip_filter_module.ctx_index);
#line 1117
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 1118
    v->not_found = 1U;
#line 1119
    return ((ngx_int_t )0);
  } else
#line 1117
  if (ctx->zout == 0UL) {
#line 1118
    v->not_found = 1U;
#line 1119
    return ((ngx_int_t )0);
  }
  {
#line 1122
  v->valid = 1U;
#line 1123
  v->no_cacheable = 0U;
#line 1124
  v->not_found = 0U;
#line 1126
  tmp = ngx_pnalloc(r->pool, (sizeof("-2147483648") - 1UL) + 3UL);
#line 1126
  v->data = (u_char *)tmp;
  }
#line 1127
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1128
    return ((ngx_int_t )-1);
  }
#line 1131
  zint = ctx->zin / ctx->zout;
#line 1132
  zfrac = ((ctx->zin * 100UL) / ctx->zout) % 100UL;
#line 1134
  if (((ctx->zin * 1000UL) / ctx->zout) % 10UL > 4UL) {
#line 1138
    zfrac ++;
#line 1140
    if (zfrac > 99UL) {
#line 1141
      zint ++;
#line 1142
      zfrac = (ngx_uint_t )0;
    }
  }
  {
#line 1146
  tmp___0 = ngx_sprintf(v->data, "%ui.%02ui", zint, zfrac);
#line 1146
  v->len = (unsigned int )(tmp___0 - v->data);
  }
#line 1148
  return ((ngx_int_t )0);
}
}
#line 1152 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static void *ngx_http_gzip_create_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_gzip_conf_t *conf ;
  void *tmp ;

  {
  {
#line 1157
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_gzip_conf_t ));
#line 1157
  conf = (ngx_http_gzip_conf_t *)tmp;
  }
#line 1158
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1159
    return ((void *)0);
  }
#line 1170
  conf->enable = (ngx_flag_t )-1;
#line 1171
  conf->no_buffer = (ngx_flag_t )-1;
#line 1173
  conf->postpone_gzipping = (size_t )-1;
#line 1174
  conf->level = (ngx_int_t )-1;
#line 1175
  conf->wbits = (size_t )-1;
#line 1176
  conf->memlevel = (size_t )-1;
#line 1177
  conf->min_length = (ssize_t )-1;
#line 1179
  return ((void *)conf);
}
}
#line 1183 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static char *ngx_http_gzip_merge_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_gzip_conf_t *prev ;
  ngx_http_gzip_conf_t *conf ;
  char *tmp ;

  {
#line 1186
  prev = (ngx_http_gzip_conf_t *)parent;
#line 1187
  conf = (ngx_http_gzip_conf_t *)child;
#line 1189
  if (conf->enable == -1L) {
#line 1189
    if (prev->enable == -1L) {
#line 1189
      conf->enable = (ngx_flag_t )0;
    } else {
#line 1189
      conf->enable = prev->enable;
    }
  }
#line 1190
  if (conf->no_buffer == -1L) {
#line 1190
    if (prev->no_buffer == -1L) {
#line 1190
      conf->no_buffer = (ngx_flag_t )0;
    } else {
#line 1190
      conf->no_buffer = prev->no_buffer;
    }
  }
#line 1192
  if (conf->bufs.num == 0L) {
#line 1192
    if (prev->bufs.num) {
#line 1192
      conf->bufs.num = prev->bufs.num;
#line 1192
      conf->bufs.size = prev->bufs.size;
    } else {
#line 1192
      conf->bufs.num = (ngx_int_t )(131072UL / ngx_pagesize);
#line 1192
      conf->bufs.size = ngx_pagesize;
    }
  }
#line 1195
  if (conf->postpone_gzipping == 0xffffffffffffffffUL) {
#line 1195
    if (prev->postpone_gzipping == 0xffffffffffffffffUL) {
#line 1195
      conf->postpone_gzipping = (size_t )0;
    } else {
#line 1195
      conf->postpone_gzipping = prev->postpone_gzipping;
    }
  }
#line 1197
  if (conf->level == -1L) {
#line 1197
    if (prev->level == -1L) {
#line 1197
      conf->level = (ngx_int_t )1;
    } else {
#line 1197
      conf->level = prev->level;
    }
  }
#line 1198
  if (conf->wbits == 0xffffffffffffffffUL) {
#line 1198
    if (prev->wbits == 0xffffffffffffffffUL) {
#line 1198
      conf->wbits = (size_t )15;
    } else {
#line 1198
      conf->wbits = prev->wbits;
    }
  }
#line 1199
  if (conf->memlevel == 0xffffffffffffffffUL) {
#line 1199
    if (prev->memlevel == 0xffffffffffffffffUL) {
#line 1199
      conf->memlevel = (size_t )8;
    } else {
#line 1199
      conf->memlevel = prev->memlevel;
    }
  }
#line 1201
  if (conf->min_length == -1L) {
#line 1201
    if (prev->min_length == -1L) {
#line 1201
      conf->min_length = (ssize_t )20;
    } else {
#line 1201
      conf->min_length = prev->min_length;
    }
  }
  {
#line 1203
  tmp = ngx_http_merge_types(cf, & conf->types_keys, & conf->types, & prev->types_keys,
                             & prev->types, ngx_http_html_default_types);
  }
#line 1203
  if ((unsigned long )tmp != (unsigned long )((char *)0)) {
#line 1208
    return ((char *)((void *)-1));
  }
#line 1211
  return ((char *)((void *)0));
}
}
#line 1215 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static ngx_int_t ngx_http_gzip_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 1218
  ngx_http_next_header_filter___4 = ngx_http_top_header_filter;
#line 1219
  ngx_http_top_header_filter = & ngx_http_gzip_header_filter;
#line 1221
  ngx_http_next_body_filter___4 = ngx_http_top_body_filter;
#line 1222
  ngx_http_top_body_filter = & ngx_http_gzip_body_filter;
#line 1224
  return ((ngx_int_t )0);
}
}
#line 1228 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static char *ngx_http_gzip_window(ngx_conf_t *cf , void *post , void *data ) 
{ 
  size_t *np ;
  size_t wbits ;
  size_t wsize ;
  char *__cil_tmp7 ;

  {
#line 1231
  np = (size_t *)data;
#line 1235
  wbits = (size_t )15;
#line 1237
  wsize = (size_t )32768;
  {
#line 1237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1237
    if (! (wsize > 256UL)) {
#line 1237
      goto while_break;
    }
#line 1239
    if (wsize == *np) {
#line 1240
      *np = wbits;
#line 1242
      return ((char *)((void *)0));
    }
#line 1245
    wbits --;
#line 1237
    wsize >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1248
  return ((char *)"must be 512, 1k, 2k, 4k, 8k, 16k, or 32k");
}
}
#line 1252 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_gzip_filter_module.c"
static char *ngx_http_gzip_hash(ngx_conf_t *cf , void *post , void *data ) 
{ 
  size_t *np ;
  size_t memlevel ;
  size_t hsize ;
  char *__cil_tmp7 ;

  {
#line 1255
  np = (size_t *)data;
#line 1259
  memlevel = (size_t )9;
#line 1261
  hsize = (size_t )131072;
  {
#line 1261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1261
    if (! (hsize > 256UL)) {
#line 1261
      goto while_break;
    }
#line 1263
    if (hsize == *np) {
#line 1264
      *np = memlevel;
#line 1266
      return ((char *)((void *)0));
    }
#line 1269
    memlevel --;
#line 1261
    hsize >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1272
  return ((char *)"must be 512, 1k, 2k, 4k, 8k, 16k, 32k, 64k, or 128k");
}
}
#line 152 "src/core/ngx_file.h"
ngx_atomic_uint_t ngx_next_temp_number(ngx_uint_t collision ) ;
#line 62 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_parse(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                      ngx_uint_t ranges ) ;
#line 64
static ngx_int_t ngx_http_range_singlepart_header(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ) ;
#line 66
static ngx_int_t ngx_http_range_multipart_header(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ) ;
#line 68
static ngx_int_t ngx_http_range_not_satisfiable(ngx_http_request_t *r ) ;
#line 69
static ngx_int_t ngx_http_range_test_overlapped(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                                ngx_chain_t *in ) ;
#line 71
static ngx_int_t ngx_http_range_singlepart_body(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                                ngx_chain_t *in ) ;
#line 73
static ngx_int_t ngx_http_range_multipart_body(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                               ngx_chain_t *in ) ;
#line 76
static ngx_int_t ngx_http_range_header_filter_init(ngx_conf_t *cf ) ;
#line 77
static ngx_int_t ngx_http_range_body_filter_init(ngx_conf_t *cf ) ;
#line 80 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_http_module_t ngx_http_range_header_filter_module_ctx  = 
#line 80
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_range_header_filter_init,
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 95 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
ngx_module_t ngx_http_range_header_filter_module  = 
#line 95
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_range_header_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 111 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_http_module_t ngx_http_range_body_filter_module_ctx  = 
#line 111
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_range_body_filter_init,
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0),
    (void *(*)(ngx_conf_t *cf ))((void *)0), (char *(*)(ngx_conf_t *cf , void *prev ,
                                                        void *conf ))((void *)0)};
#line 126 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
ngx_module_t ngx_http_range_body_filter_module  = 
#line 126
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_range_body_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 142 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___5)(ngx_http_request_t *r )  ;
#line 143 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___5)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 146 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_header_filter(ngx_http_request_t *r ) 
{ 
  time_t if_range_time ;
  ngx_str_t *if_range ;
  ngx_str_t *etag ;
  ngx_uint_t ranges ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_range_filter_ctx_t *ctx ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 155
  if (r->http_version < 1000UL) {
    {
#line 161
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 161
    return (tmp);
  } else
#line 155
  if (r->headers_out.status != 200UL) {
    {
#line 161
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 161
    return (tmp);
  } else
#line 155
  if ((unsigned long )r != (unsigned long )r->main) {
#line 155
    if (! r->subrequest_ranges) {
      {
#line 161
      tmp = (*ngx_http_next_header_filter___5)(r);
      }
#line 161
      return (tmp);
    } else {
#line 155
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 155
  if (r->headers_out.content_length_n == -1L) {
    {
#line 161
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 161
    return (tmp);
  } else
#line 155
  if (! r->allow_ranges) {
    {
#line 161
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 161
    return (tmp);
  }
#line 164
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 166
  if (clcf->max_ranges == 0UL) {
    {
#line 167
    tmp___0 = (*ngx_http_next_header_filter___5)(r);
    }
#line 167
    return (tmp___0);
  }
#line 170
  if ((unsigned long )r->headers_in.range == (unsigned long )((void *)0)) {
#line 176
    goto next_filter;
  } else
#line 170
  if ((r->headers_in.range)->value.len < 7UL) {
#line 176
    goto next_filter;
  } else {
    {
#line 170
    tmp___1 = ngx_strncasecmp((r->headers_in.range)->value.data, (u_char *)"bytes=",
                              (size_t )6);
    }
#line 170
    if (tmp___1 != 0L) {
#line 176
      goto next_filter;
    }
  }
#line 179
  if (r->headers_in.if_range) {
#line 181
    if_range = & (r->headers_in.if_range)->value;
#line 183
    if (if_range->len >= 2UL) {
#line 183
      if ((int )*(if_range->data + (if_range->len - 1UL)) == 34) {
#line 185
        if ((unsigned long )r->headers_out.etag == (unsigned long )((void *)0)) {
#line 186
          goto next_filter;
        }
#line 189
        etag = & (r->headers_out.etag)->value;
#line 194
        if (if_range->len != etag->len) {
#line 197
          goto next_filter;
        } else {
          {
#line 194
          tmp___2 = strncmp((char const   *)if_range->data, (char const   *)etag->data,
                            etag->len);
          }
#line 194
          if (tmp___2 != 0) {
#line 197
            goto next_filter;
          }
        }
#line 200
        goto parse;
      }
    }
#line 203
    if (r->headers_out.last_modified_time == -1L) {
#line 204
      goto next_filter;
    }
    {
#line 207
    if_range_time = ngx_parse_http_time(if_range->data, if_range->len);
    }
#line 213
    if (if_range_time != r->headers_out.last_modified_time) {
#line 214
      goto next_filter;
    }
  }
  parse: 
  {
#line 220
  tmp___3 = ngx_pcalloc(r->pool, sizeof(ngx_http_range_filter_ctx_t ));
#line 220
  ctx = (ngx_http_range_filter_ctx_t *)tmp___3;
  }
#line 221
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 222
    return ((ngx_int_t )-1);
  }
#line 225
  ctx->offset = r->headers_out.content_offset;
#line 227
  if (r->single_range) {
#line 227
    ranges = (ngx_uint_t )1;
  } else {
#line 227
    ranges = clcf->max_ranges;
  }
  {
#line 229
  tmp___4 = ngx_http_range_parse(r, ctx, ranges);
  }
  {
#line 231
  if (tmp___4 == 0L) {
#line 231
    goto case_0;
  }
#line 243
  if (tmp___4 == 416L) {
#line 243
    goto case_416;
  }
#line 246
  if (tmp___4 == -1L) {
#line 246
    goto case_neg_1;
  }
#line 249
  goto switch_default;
  case_0: /* CIL Label */ 
#line 232
  *(r->ctx + ngx_http_range_body_filter_module.ctx_index) = (void *)ctx;
#line 234
  r->headers_out.status = (ngx_uint_t )206;
#line 235
  r->headers_out.status_line.len = (size_t )0;
#line 237
  if (ctx->ranges.nelts == 1UL) {
    {
#line 238
    tmp___5 = ngx_http_range_singlepart_header(r, ctx);
    }
#line 238
    return (tmp___5);
  }
  {
#line 241
  tmp___6 = ngx_http_range_multipart_header(r, ctx);
  }
#line 241
  return (tmp___6);
  case_416: /* CIL Label */ 
  {
#line 244
  tmp___7 = ngx_http_range_not_satisfiable(r);
  }
#line 244
  return (tmp___7);
  case_neg_1: /* CIL Label */ 
#line 247
  return ((ngx_int_t )-1);
  switch_default: /* CIL Label */ 
#line 250
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  next_filter: 
  {
#line 255
  tmp___8 = ngx_list_push(& r->headers_out.headers);
#line 255
  r->headers_out.accept_ranges = (ngx_table_elt_t *)tmp___8;
  }
#line 256
  if ((unsigned long )r->headers_out.accept_ranges == (unsigned long )((void *)0)) {
#line 257
    return ((ngx_int_t )-1);
  }
  {
#line 260
  (r->headers_out.accept_ranges)->hash = (ngx_uint_t )1;
#line 261
  (r->headers_out.accept_ranges)->key.len = sizeof("Accept-Ranges") - 1UL;
#line 261
  (r->headers_out.accept_ranges)->key.data = (u_char *)"Accept-Ranges";
#line 262
  (r->headers_out.accept_ranges)->value.len = sizeof("bytes") - 1UL;
#line 262
  (r->headers_out.accept_ranges)->value.data = (u_char *)"bytes";
#line 264
  tmp___9 = (*ngx_http_next_header_filter___5)(r);
  }
#line 264
  return (tmp___9);
}
}
#line 268 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_parse(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                      ngx_uint_t ranges ) 
{ 
  u_char *p ;
  off_t start ;
  off_t end ;
  off_t size ;
  off_t content_length ;
  off_t cutoff ;
  off_t cutlim ;
  ngx_uint_t suffix ;
  ngx_http_range_t *range ;
  ngx_http_range_filter_ctx_t *mctx ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  ngx_uint_t tmp___4 ;
  u_char *tmp___5 ;

  {
#line 279
  if ((unsigned long )r != (unsigned long )r->main) {
#line 280
    mctx = (ngx_http_range_filter_ctx_t *)*((r->main)->ctx + ngx_http_range_body_filter_module.ctx_index);
#line 282
    if (mctx) {
#line 283
      ctx->ranges = mctx->ranges;
#line 284
      return ((ngx_int_t )0);
    }
  }
  {
#line 288
  tmp = ngx_array_init(& ctx->ranges, r->pool, (ngx_uint_t )1, sizeof(ngx_http_range_t ));
  }
#line 288
  if (tmp != 0L) {
#line 291
    return ((ngx_int_t )-1);
  }
#line 294
  p = (r->headers_in.range)->value.data + 6;
#line 295
  size = (off_t )0;
#line 296
  content_length = r->headers_out.content_length_n;
#line 298
  cutoff = (off_t )922337203685477580LL;
#line 299
  cutlim = (off_t )7LL;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 302
    start = (off_t )0;
#line 303
    end = (off_t )0;
#line 304
    suffix = (ngx_uint_t )0;
    {
#line 306
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 306
      if (! ((int )*p == 32)) {
#line 306
        goto while_break___0;
      }
#line 306
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 308
    if ((int )*p != 45) {
#line 309
      if ((int )*p < 48) {
#line 310
        return ((ngx_int_t )416);
      } else
#line 309
      if ((int )*p > 57) {
#line 310
        return ((ngx_int_t )416);
      }
      {
#line 313
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 313
        if ((int )*p >= 48) {
#line 313
          if (! ((int )*p <= 57)) {
#line 313
            goto while_break___1;
          }
        } else {
#line 313
          goto while_break___1;
        }
#line 314
        if (start >= cutoff) {
#line 314
          if (start > cutoff) {
#line 315
            return ((ngx_int_t )416);
          } else
#line 314
          if ((off_t )((int )*p - 48) > cutlim) {
#line 315
            return ((ngx_int_t )416);
          }
        }
#line 318
        tmp___0 = p;
#line 318
        p ++;
#line 318
        start = start * 10L + (off_t )((int )*tmp___0 - 48);
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 321
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 321
        if (! ((int )*p == 32)) {
#line 321
          goto while_break___2;
        }
#line 321
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 323
      tmp___1 = p;
#line 323
      p ++;
#line 323
      if ((int )*tmp___1 != 45) {
#line 324
        return ((ngx_int_t )416);
      }
      {
#line 327
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 327
        if (! ((int )*p == 32)) {
#line 327
          goto while_break___3;
        }
#line 327
        p ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 329
      if ((int )*p == 44) {
#line 330
        end = content_length;
#line 331
        goto found;
      } else
#line 329
      if ((int )*p == 0) {
#line 330
        end = content_length;
#line 331
        goto found;
      }
    } else {
#line 335
      suffix = (ngx_uint_t )1;
#line 336
      p ++;
    }
#line 339
    if ((int )*p < 48) {
#line 340
      return ((ngx_int_t )416);
    } else
#line 339
    if ((int )*p > 57) {
#line 340
      return ((ngx_int_t )416);
    }
    {
#line 343
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 343
      if ((int )*p >= 48) {
#line 343
        if (! ((int )*p <= 57)) {
#line 343
          goto while_break___4;
        }
      } else {
#line 343
        goto while_break___4;
      }
#line 344
      if (end >= cutoff) {
#line 344
        if (end > cutoff) {
#line 345
          return ((ngx_int_t )416);
        } else
#line 344
        if ((off_t )((int )*p - 48) > cutlim) {
#line 345
          return ((ngx_int_t )416);
        }
      }
#line 348
      tmp___2 = p;
#line 348
      p ++;
#line 348
      end = end * 10L + (off_t )((int )*tmp___2 - 48);
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 351
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 351
      if (! ((int )*p == 32)) {
#line 351
        goto while_break___5;
      }
#line 351
      p ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 353
    if ((int )*p != 44) {
#line 353
      if ((int )*p != 0) {
#line 354
        return ((ngx_int_t )416);
      }
    }
#line 357
    if (suffix) {
#line 358
      if (end < content_length) {
#line 358
        start = content_length - end;
      } else {
#line 358
        start = (off_t )0;
      }
#line 359
      end = content_length - 1L;
    }
#line 362
    if (end >= content_length) {
#line 363
      end = content_length;
    } else {
#line 366
      end ++;
    }
    found: 
#line 371
    if (start < end) {
      {
#line 372
      tmp___3 = ngx_array_push(& ctx->ranges);
#line 372
      range = (ngx_http_range_t *)tmp___3;
      }
#line 373
      if ((unsigned long )range == (unsigned long )((void *)0)) {
#line 374
        return ((ngx_int_t )-1);
      }
#line 377
      range->start = start;
#line 378
      range->end = end;
#line 380
      if ((long long )size > 9223372036854775807LL - (long long )(end - start)) {
#line 381
        return ((ngx_int_t )416);
      }
#line 384
      size += end - start;
#line 386
      tmp___4 = ranges;
#line 386
      ranges --;
#line 386
      if (tmp___4 == 0UL) {
#line 387
        return ((ngx_int_t )-5);
      }
    } else
#line 390
    if (start == 0L) {
#line 391
      return ((ngx_int_t )-5);
    }
#line 394
    tmp___5 = p;
#line 394
    p ++;
#line 394
    if ((int )*tmp___5 != 44) {
#line 395
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 399
  if (ctx->ranges.nelts == 0UL) {
#line 400
    return ((ngx_int_t )416);
  }
#line 403
  if (size > content_length) {
#line 404
    return ((ngx_int_t )-5);
  }
#line 407
  return ((ngx_int_t )0);
}
}
#line 411 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_singlepart_header(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ) 
{ 
  ngx_table_elt_t *content_range ;
  ngx_http_range_t *range ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 418
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 419
    tmp = (*ngx_http_next_header_filter___5)(r);
    }
#line 419
    return (tmp);
  }
  {
#line 422
  tmp___0 = ngx_list_push(& r->headers_out.headers);
#line 422
  content_range = (ngx_table_elt_t *)tmp___0;
  }
#line 423
  if ((unsigned long )content_range == (unsigned long )((void *)0)) {
#line 424
    return ((ngx_int_t )-1);
  }
  {
#line 427
  r->headers_out.content_range = content_range;
#line 429
  content_range->hash = (ngx_uint_t )1;
#line 430
  content_range->key.len = sizeof("Content-Range") - 1UL;
#line 430
  content_range->key.data = (u_char *)"Content-Range";
#line 432
  tmp___1 = ngx_pnalloc(r->pool, (sizeof("bytes -/") - 1UL) + 3UL * (sizeof("-9223372036854775808") - 1UL));
#line 432
  content_range->value.data = (u_char *)tmp___1;
  }
#line 434
  if ((unsigned long )content_range->value.data == (unsigned long )((void *)0)) {
#line 435
    content_range->hash = (ngx_uint_t )0;
#line 436
    r->headers_out.content_range = (ngx_table_elt_t *)((void *)0);
#line 437
    return ((ngx_int_t )-1);
  }
  {
#line 442
  range = (ngx_http_range_t *)ctx->ranges.elts;
#line 444
  tmp___2 = ngx_sprintf(content_range->value.data, "bytes %O-%O/%O", range->start,
                        range->end - 1L, r->headers_out.content_length_n);
#line 444
  content_range->value.len = (size_t )(tmp___2 - content_range->value.data);
#line 450
  r->headers_out.content_length_n = range->end - range->start;
#line 451
  r->headers_out.content_offset = range->start;
  }
#line 453
  if (r->headers_out.content_length) {
#line 454
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 455
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 458
  tmp___3 = (*ngx_http_next_header_filter___5)(r);
  }
#line 458
  return (tmp___3);
}
}
#line 462 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_multipart_header(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ) 
{ 
  off_t len ;
  size_t size ;
  ngx_uint_t i ;
  ngx_http_range_t *range ;
  ngx_atomic_uint_t boundary ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  ngx_int_t tmp___7 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 472
  size = ((((((sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + sizeof("\r\nContent-Type: ")) - 1UL) + r->headers_out.content_type.len) + sizeof("\r\nContent-Range: bytes ")) - 1UL;
#line 477
  if (r->headers_out.content_type_len == r->headers_out.content_type.len) {
#line 477
    if (r->headers_out.charset.len) {
#line 480
      size += (sizeof("; charset=") - 1UL) + r->headers_out.charset.len;
    }
  }
  {
#line 483
  tmp = ngx_pnalloc(r->pool, size);
#line 483
  ctx->boundary_header.data = (u_char *)tmp;
  }
#line 484
  if ((unsigned long )ctx->boundary_header.data == (unsigned long )((void *)0)) {
#line 485
    return ((ngx_int_t )-1);
  }
  {
#line 488
  boundary = ngx_next_temp_number((ngx_uint_t )0);
  }
#line 498
  if (r->headers_out.content_type_len == r->headers_out.content_type.len) {
#line 498
    if (r->headers_out.charset.len) {
      {
#line 501
      tmp___0 = ngx_sprintf(ctx->boundary_header.data, "\r\n--%0muA\r\nContent-Type: %V; charset=%V\r\nContent-Range: bytes ",
                            boundary, & r->headers_out.content_type, & r->headers_out.charset);
#line 501
      ctx->boundary_header.len = (size_t )(tmp___0 - ctx->boundary_header.data);
      }
    } else {
#line 498
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 510
  if (r->headers_out.content_type.len) {
    {
#line 511
    tmp___1 = ngx_sprintf(ctx->boundary_header.data, "\r\n--%0muA\r\nContent-Type: %V\r\nContent-Range: bytes ",
                          boundary, & r->headers_out.content_type);
#line 511
    ctx->boundary_header.len = (size_t )(tmp___1 - ctx->boundary_header.data);
    }
  } else {
    {
#line 520
    tmp___2 = ngx_sprintf(ctx->boundary_header.data, "\r\n--%0muA\r\nContent-Range: bytes ",
                          boundary);
#line 520
    ctx->boundary_header.len = (size_t )(tmp___2 - ctx->boundary_header.data);
    }
  }
  {
#line 527
  tmp___3 = ngx_pnalloc(r->pool, (sizeof("Content-Type: multipart/byteranges; boundary=") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 527
  r->headers_out.content_type.data = (u_char *)tmp___3;
  }
#line 532
  if ((unsigned long )r->headers_out.content_type.data == (unsigned long )((void *)0)) {
#line 533
    return ((ngx_int_t )-1);
  }
  {
#line 536
  r->headers_out.content_type_lowcase = (u_char *)((void *)0);
#line 540
  tmp___4 = ngx_sprintf(r->headers_out.content_type.data, "multipart/byteranges; boundary=%0muA",
                        boundary);
#line 540
  r->headers_out.content_type.len = (size_t )(tmp___4 - r->headers_out.content_type.data);
#line 546
  r->headers_out.content_type_len = r->headers_out.content_type.len;
#line 548
  r->headers_out.charset.len = (size_t )0;
#line 552
  len = (off_t )((((sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + sizeof("--\r\n")) - 1UL);
#line 554
  range = (ngx_http_range_t *)ctx->ranges.elts;
#line 555
  i = (ngx_uint_t )0;
  }
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! (i < ctx->ranges.nelts)) {
#line 555
      goto while_break;
    }
    {
#line 559
    tmp___5 = ngx_pnalloc(r->pool, (3UL * (sizeof("-9223372036854775808") - 1UL) + 2UL) + 4UL);
#line 559
    (range + i)->content_range.data = (u_char *)tmp___5;
    }
#line 562
    if ((unsigned long )(range + i)->content_range.data == (unsigned long )((void *)0)) {
#line 563
      return ((ngx_int_t )-1);
    }
    {
#line 566
    tmp___6 = ngx_sprintf((range + i)->content_range.data, "%O-%O/%O\r\n\r\n", (range + i)->start,
                          (range + i)->end - 1L, r->headers_out.content_length_n);
#line 566
    (range + i)->content_range.len = (size_t )(tmp___6 - (range + i)->content_range.data);
#line 572
    len = (off_t )((size_t )len + ((ctx->boundary_header.len + (range + i)->content_range.len) + (size_t )((range + i)->end - (range + i)->start)));
#line 555
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  r->headers_out.content_length_n = len;
#line 578
  if (r->headers_out.content_length) {
#line 579
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 580
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 583
  tmp___7 = (*ngx_http_next_header_filter___5)(r);
  }
#line 583
  return (tmp___7);
}
}
#line 587 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_not_satisfiable(ngx_http_request_t *r ) 
{ 
  ngx_table_elt_t *content_range ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 592
  r->headers_out.status = (ngx_uint_t )416;
#line 594
  tmp = ngx_list_push(& r->headers_out.headers);
#line 594
  content_range = (ngx_table_elt_t *)tmp;
  }
#line 595
  if ((unsigned long )content_range == (unsigned long )((void *)0)) {
#line 596
    return ((ngx_int_t )-1);
  }
  {
#line 599
  r->headers_out.content_range = content_range;
#line 601
  content_range->hash = (ngx_uint_t )1;
#line 602
  content_range->key.len = sizeof("Content-Range") - 1UL;
#line 602
  content_range->key.data = (u_char *)"Content-Range";
#line 604
  tmp___0 = ngx_pnalloc(r->pool, (sizeof("bytes */") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 604
  content_range->value.data = (u_char *)tmp___0;
  }
#line 606
  if ((unsigned long )content_range->value.data == (unsigned long )((void *)0)) {
#line 607
    content_range->hash = (ngx_uint_t )0;
#line 608
    r->headers_out.content_range = (ngx_table_elt_t *)((void *)0);
#line 609
    return ((ngx_int_t )-1);
  }
  {
#line 612
  tmp___1 = ngx_sprintf(content_range->value.data, "bytes */%O", r->headers_out.content_length_n);
#line 612
  content_range->value.len = (size_t )(tmp___1 - content_range->value.data);
#line 617
  r->headers_out.content_length_n = (off_t )-1;
  }
#line 617
  if (r->headers_out.content_length) {
#line 617
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 617
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 619
  return ((ngx_int_t )416);
}
}
#line 623 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_http_range_filter_ctx_t *ctx ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 628
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 629
    tmp = (*ngx_http_next_body_filter___5)(r, in);
    }
#line 629
    return (tmp);
  }
#line 632
  ctx = (ngx_http_range_filter_ctx_t *)*(r->ctx + ngx_http_range_body_filter_module.ctx_index);
#line 634
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 635
    tmp___0 = (*ngx_http_next_body_filter___5)(r, in);
    }
#line 635
    return (tmp___0);
  }
#line 638
  if (ctx->ranges.nelts == 1UL) {
    {
#line 639
    tmp___1 = ngx_http_range_singlepart_body(r, ctx, in);
    }
#line 639
    return (tmp___1);
  }
#line 646
  if ((in->buf)->flush) {
#line 646
    goto _L;
  } else
#line 646
  if ((in->buf)->last_buf) {
#line 646
    goto _L;
  } else
#line 646
  if ((in->buf)->sync) {
    _L: /* CIL Label */ 
#line 646
    if (! (in->buf)->temporary) {
#line 646
      if (! (in->buf)->memory) {
#line 646
        if (! (in->buf)->mmap) {
#line 646
          if (! (in->buf)->in_file) {
            {
#line 647
            tmp___2 = (*ngx_http_next_body_filter___5)(r, in);
            }
#line 647
            return (tmp___2);
          }
        }
      }
    }
  }
  {
#line 650
  tmp___3 = ngx_http_range_test_overlapped(r, ctx, in);
  }
#line 650
  if (tmp___3 != 0L) {
#line 651
    return ((ngx_int_t )-1);
  }
  {
#line 654
  tmp___4 = ngx_http_range_multipart_body(r, ctx, in);
  }
#line 654
  return (tmp___4);
}
}
#line 658 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_test_overlapped(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                                ngx_chain_t *in ) 
{ 
  off_t start ;
  off_t last ;
  ngx_buf_t *buf ;
  ngx_uint_t i ;
  ngx_http_range_t *range ;
  off_t tmp ;
  char *__cil_tmp10 ;

  {
#line 667
  if (ctx->offset) {
#line 668
    goto overlapped;
  }
#line 671
  buf = in->buf;
#line 673
  if (! buf->last_buf) {
#line 674
    start = ctx->offset;
#line 675
    if (buf->temporary) {
#line 675
      tmp = buf->last - buf->pos;
    } else
#line 675
    if (buf->memory) {
#line 675
      tmp = buf->last - buf->pos;
    } else
#line 675
    if (buf->mmap) {
#line 675
      tmp = buf->last - buf->pos;
    } else {
#line 675
      tmp = buf->file_last - buf->file_pos;
    }
#line 675
    last = ctx->offset + tmp;
#line 677
    range = (ngx_http_range_t *)ctx->ranges.elts;
#line 678
    i = (ngx_uint_t )0;
    {
#line 678
    while (1) {
      while_continue: /* CIL Label */ ;
#line 678
      if (! (i < ctx->ranges.nelts)) {
#line 678
        goto while_break;
      }
#line 679
      if (start > (range + i)->start) {
#line 680
        goto overlapped;
      } else
#line 679
      if (last < (range + i)->end) {
#line 680
        goto overlapped;
      }
#line 678
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 685
  if (buf->temporary) {
#line 685
    ctx->offset = buf->last - buf->pos;
  } else
#line 685
  if (buf->memory) {
#line 685
    ctx->offset = buf->last - buf->pos;
  } else
#line 685
  if (buf->mmap) {
#line 685
    ctx->offset = buf->last - buf->pos;
  } else {
#line 685
    ctx->offset = buf->file_last - buf->file_pos;
  }
#line 687
  return ((ngx_int_t )0);
  overlapped: 
#line 691
  if (((r->connection)->log)->log_level >= 2UL) {
    {
#line 691
    ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "range in overlapped buffers");
    }
  }
#line 694
  return ((ngx_int_t )-1);
}
}
#line 698 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_singlepart_body(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                                ngx_chain_t *in ) 
{ 
  off_t start ;
  off_t last ;
  ngx_buf_t *buf ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_range_t *range ;
  off_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 707
  out = (ngx_chain_t *)((void *)0);
#line 708
  ll = & out;
#line 709
  range = (ngx_http_range_t *)ctx->ranges.elts;
#line 711
  cl = in;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! cl) {
#line 711
      goto while_break;
    }
#line 713
    buf = cl->buf;
#line 715
    start = ctx->offset;
#line 716
    if (buf->temporary) {
#line 716
      tmp = buf->last - buf->pos;
    } else
#line 716
    if (buf->memory) {
#line 716
      tmp = buf->last - buf->pos;
    } else
#line 716
    if (buf->mmap) {
#line 716
      tmp = buf->last - buf->pos;
    } else {
#line 716
      tmp = buf->file_last - buf->file_pos;
    }
#line 716
    last = ctx->offset + tmp;
#line 718
    ctx->offset = last;
#line 723
    if (buf->flush) {
#line 723
      goto _L;
    } else
#line 723
    if (buf->last_buf) {
#line 723
      goto _L;
    } else
#line 723
    if (buf->sync) {
      _L: /* CIL Label */ 
#line 723
      if (! buf->temporary) {
#line 723
        if (! buf->memory) {
#line 723
          if (! buf->mmap) {
#line 723
            if (! buf->in_file) {
#line 724
              *ll = cl;
#line 725
              ll = & cl->next;
#line 726
              goto __Cont;
            }
          }
        }
      }
    }
#line 729
    if (range->end <= start) {
#line 729
      goto _L___0;
    } else
#line 729
    if (range->start >= last) {
      _L___0: /* CIL Label */ 
#line 734
      if (buf->in_file) {
#line 735
        buf->file_pos = buf->file_last;
      }
#line 738
      buf->pos = buf->last;
#line 739
      buf->sync = 1U;
#line 741
      goto __Cont;
    }
#line 744
    if (range->start > start) {
#line 746
      if (buf->in_file) {
#line 747
        buf->file_pos += range->start - start;
      }
#line 750
      if (buf->temporary) {
#line 751
        buf->pos += (size_t )(range->start - start);
      } else
#line 750
      if (buf->memory) {
#line 751
        buf->pos += (size_t )(range->start - start);
      } else
#line 750
      if (buf->mmap) {
#line 751
        buf->pos += (size_t )(range->start - start);
      }
    }
#line 755
    if (range->end <= last) {
#line 757
      if (buf->in_file) {
#line 758
        buf->file_last -= last - range->end;
      }
#line 761
      if (buf->temporary) {
#line 762
        buf->last -= (size_t )(last - range->end);
      } else
#line 761
      if (buf->memory) {
#line 762
        buf->last -= (size_t )(last - range->end);
      } else
#line 761
      if (buf->mmap) {
#line 762
        buf->last -= (size_t )(last - range->end);
      }
#line 765
      if ((unsigned long )r == (unsigned long )r->main) {
#line 765
        buf->last_buf = 1U;
      } else {
#line 765
        buf->last_buf = 0U;
      }
#line 766
      buf->last_in_chain = 1U;
#line 767
      *ll = cl;
#line 768
      cl->next = (ngx_chain_t *)((void *)0);
#line 770
      goto while_break;
    }
#line 773
    *ll = cl;
#line 774
    ll = & cl->next;
    __Cont: /* CIL Label */ 
#line 711
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 777
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 778
    return ((ngx_int_t )0);
  }
  {
#line 781
  tmp___0 = (*ngx_http_next_body_filter___5)(r, out);
  }
#line 781
  return (tmp___0);
}
}
#line 785 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_multipart_body(ngx_http_request_t *r , ngx_http_range_filter_ctx_t *ctx ,
                                               ngx_chain_t *in ) 
{ 
  ngx_buf_t *b ;
  ngx_buf_t *buf ;
  ngx_uint_t i ;
  ngx_chain_t *out ;
  ngx_chain_t *hcl ;
  ngx_chain_t *rcl ;
  ngx_chain_t *dcl ;
  ngx_chain_t **ll ;
  ngx_http_range_t *range ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  ngx_int_t tmp___9 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
#line 794
  ll = & out;
#line 795
  buf = in->buf;
#line 796
  range = (ngx_http_range_t *)ctx->ranges.elts;
#line 798
  i = (ngx_uint_t )0;
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! (i < ctx->ranges.nelts)) {
#line 798
      goto while_break;
    }
    {
#line 808
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 808
    b = (ngx_buf_t *)tmp;
    }
#line 809
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 810
      return ((ngx_int_t )-1);
    }
    {
#line 813
    b->memory = 1U;
#line 814
    b->pos = ctx->boundary_header.data;
#line 815
    b->last = ctx->boundary_header.data + ctx->boundary_header.len;
#line 817
    hcl = ngx_alloc_chain_link(r->pool);
    }
#line 818
    if ((unsigned long )hcl == (unsigned long )((void *)0)) {
#line 819
      return ((ngx_int_t )-1);
    }
    {
#line 822
    hcl->buf = b;
#line 827
    tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 827
    b = (ngx_buf_t *)tmp___0;
    }
#line 828
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 829
      return ((ngx_int_t )-1);
    }
    {
#line 832
    b->temporary = 1U;
#line 833
    b->pos = (range + i)->content_range.data;
#line 834
    b->last = (range + i)->content_range.data + (range + i)->content_range.len;
#line 836
    rcl = ngx_alloc_chain_link(r->pool);
    }
#line 837
    if ((unsigned long )rcl == (unsigned long )((void *)0)) {
#line 838
      return ((ngx_int_t )-1);
    }
    {
#line 841
    rcl->buf = b;
#line 846
    tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 846
    b = (ngx_buf_t *)tmp___1;
    }
#line 847
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 848
      return ((ngx_int_t )-1);
    }
#line 851
    b->in_file = buf->in_file;
#line 852
    b->temporary = buf->temporary;
#line 853
    b->memory = buf->memory;
#line 854
    b->mmap = buf->mmap;
#line 855
    b->file = buf->file;
#line 857
    if (buf->in_file) {
#line 858
      b->file_pos = buf->file_pos + (range + i)->start;
#line 859
      b->file_last = buf->file_pos + (range + i)->end;
    }
#line 862
    if (buf->temporary) {
#line 863
      b->pos = buf->pos + (size_t )(range + i)->start;
#line 864
      b->last = buf->pos + (size_t )(range + i)->end;
    } else
#line 862
    if (buf->memory) {
#line 863
      b->pos = buf->pos + (size_t )(range + i)->start;
#line 864
      b->last = buf->pos + (size_t )(range + i)->end;
    } else
#line 862
    if (buf->mmap) {
#line 863
      b->pos = buf->pos + (size_t )(range + i)->start;
#line 864
      b->last = buf->pos + (size_t )(range + i)->end;
    }
    {
#line 867
    dcl = ngx_alloc_chain_link(r->pool);
    }
#line 868
    if ((unsigned long )dcl == (unsigned long )((void *)0)) {
#line 869
      return ((ngx_int_t )-1);
    }
#line 872
    dcl->buf = b;
#line 874
    *ll = hcl;
#line 875
    hcl->next = rcl;
#line 876
    rcl->next = dcl;
#line 877
    ll = & dcl->next;
#line 798
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 882
  tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 882
  b = (ngx_buf_t *)tmp___2;
  }
#line 883
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 884
    return ((ngx_int_t )-1);
  }
  {
#line 887
  b->temporary = 1U;
#line 888
  b->last_buf = 1U;
#line 890
  tmp___3 = ngx_pnalloc(r->pool, (((sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + sizeof("--\r\n")) - 1UL);
#line 890
  b->pos = (u_char *)tmp___3;
  }
#line 892
  if ((unsigned long )b->pos == (unsigned long )((void *)0)) {
#line 893
    return ((ngx_int_t )-1);
  }
  {
#line 896
  tmp___4 = memcpy((void */* __restrict  */)b->pos, (void const   */* __restrict  */)ctx->boundary_header.data,
                   (sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 896
  b->last = (u_char *)tmp___4 + ((sizeof("\r\n--") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 898
  tmp___5 = b->last;
#line 898
  (b->last) ++;
#line 898
  *tmp___5 = (u_char )'-';
#line 898
  tmp___6 = b->last;
#line 898
  (b->last) ++;
#line 898
  *tmp___6 = (u_char )'-';
#line 899
  tmp___7 = b->last;
#line 899
  (b->last) ++;
#line 899
  *tmp___7 = (u_char )'\r';
#line 899
  tmp___8 = b->last;
#line 899
  (b->last) ++;
#line 899
  *tmp___8 = (u_char )'\n';
#line 901
  hcl = ngx_alloc_chain_link(r->pool);
  }
#line 902
  if ((unsigned long )hcl == (unsigned long )((void *)0)) {
#line 903
    return ((ngx_int_t )-1);
  }
  {
#line 906
  hcl->buf = b;
#line 907
  hcl->next = (ngx_chain_t *)((void *)0);
#line 909
  *ll = hcl;
#line 911
  tmp___9 = (*ngx_http_next_body_filter___5)(r, out);
  }
#line 911
  return (tmp___9);
}
}
#line 915 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_header_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 918
  ngx_http_next_header_filter___5 = ngx_http_top_header_filter;
#line 919
  ngx_http_top_header_filter = & ngx_http_range_header_filter;
#line 921
  return ((ngx_int_t )0);
}
}
#line 925 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_range_filter_module.c"
static ngx_int_t ngx_http_range_body_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 928
  ngx_http_next_body_filter___5 = ngx_http_top_body_filter;
#line 929
  ngx_http_top_body_filter = & ngx_http_range_body_filter;
#line 931
  return ((ngx_int_t )0);
}
}
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t ngx_http_chunked_filter_init(ngx_conf_t *cf ) ;
#line 20
static ngx_chain_t *ngx_http_chunked_create_trailers(ngx_http_request_t *r , ngx_http_chunked_filter_ctx_t *ctx ) ;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_http_module_t ngx_http_chunked_filter_module_ctx  = 
#line 24
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_chunked_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 39 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
ngx_module_t ngx_http_chunked_filter_module  = 
#line 39
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_chunked_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t (*ngx_http_next_header_filter___6)(ngx_http_request_t *r )  ;
#line 56 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t (*ngx_http_next_body_filter___6)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 59 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t ngx_http_chunked_header_filter(ngx_http_request_t *r ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_chunked_filter_ctx_t *ctx ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 65
  if (r->headers_out.status == 304UL) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  } else
#line 65
  if (r->headers_out.status == 204UL) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  } else
#line 65
  if (r->headers_out.status < 200UL) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  } else
#line 65
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  } else
#line 65
  if (r->method == 4UL) {
    {
#line 71
    tmp = (*ngx_http_next_header_filter___6)(r);
    }
#line 71
    return (tmp);
  }
#line 74
  if (r->headers_out.content_length_n == -1L) {
#line 74
    goto _L___0;
  } else
#line 74
  if (r->expect_trailers) {
    _L___0: /* CIL Label */ 
#line 77
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 79
    if (r->http_version >= 1001UL) {
#line 79
      if (clcf->chunked_transfer_encoding) {
#line 82
        if (r->expect_trailers) {
#line 83
          r->headers_out.content_length_n = (off_t )-1;
#line 83
          if (r->headers_out.content_length) {
#line 83
            (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 83
            r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
          }
        }
        {
#line 86
        r->chunked = 1U;
#line 88
        tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_filter_ctx_t ));
#line 88
        ctx = (ngx_http_chunked_filter_ctx_t *)tmp___0;
        }
#line 89
        if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 90
          return ((ngx_int_t )-1);
        }
#line 93
        *(r->ctx + ngx_http_chunked_filter_module.ctx_index) = (void *)ctx;
      } else {
#line 79
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 95
    if (r->headers_out.content_length_n == -1L) {
#line 96
      r->keepalive = 0U;
    }
  }
  {
#line 100
  tmp___1 = (*ngx_http_next_header_filter___6)(r);
  }
#line 100
  return (tmp___1);
}
}
#line 104 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t ngx_http_chunked_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  u_char *chunk ;
  off_t size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t **ll ;
  ngx_http_chunked_filter_ctx_t *ctx ;
  ngx_int_t tmp ;
  off_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 114
  if ((unsigned long )in == (unsigned long )((void *)0)) {
    {
#line 115
    tmp = (*ngx_http_next_body_filter___6)(r, in);
    }
#line 115
    return (tmp);
  } else
#line 114
  if (! r->chunked) {
    {
#line 115
    tmp = (*ngx_http_next_body_filter___6)(r, in);
    }
#line 115
    return (tmp);
  } else
#line 114
  if (r->header_only) {
    {
#line 115
    tmp = (*ngx_http_next_body_filter___6)(r, in);
    }
#line 115
    return (tmp);
  }
#line 118
  ctx = (ngx_http_chunked_filter_ctx_t *)*(r->ctx + ngx_http_chunked_filter_module.ctx_index);
#line 120
  out = (ngx_chain_t *)((void *)0);
#line 121
  ll = & out;
#line 123
  size = (off_t )0;
#line 124
  cl = in;
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if ((cl->buf)->temporary) {
#line 130
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 130
    if ((cl->buf)->memory) {
#line 130
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 130
    if ((cl->buf)->mmap) {
#line 130
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 130
      tmp___0 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 130
    size += tmp___0;
#line 132
    if ((cl->buf)->flush) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->sync) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->temporary) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->memory) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->mmap) {
#line 132
      goto _L;
    } else
#line 132
    if ((cl->buf)->in_file) {
      _L: /* CIL Label */ 
      {
#line 137
      tl = ngx_alloc_chain_link(r->pool);
      }
#line 138
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 139
        return ((ngx_int_t )-1);
      }
#line 142
      tl->buf = cl->buf;
#line 143
      *ll = tl;
#line 144
      ll = & tl->next;
    }
#line 147
    if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 148
      goto while_break;
    }
#line 151
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 154
  if (size) {
    {
#line 155
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 156
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 157
      return ((ngx_int_t )-1);
    }
#line 160
    b = tl->buf;
#line 161
    chunk = b->start;
#line 163
    if ((unsigned long )chunk == (unsigned long )((void *)0)) {
      {
#line 166
      tmp___1 = ngx_palloc(r->pool, sizeof("0000000000000000\r\n") - 1UL);
#line 166
      chunk = (u_char *)tmp___1;
      }
#line 167
      if ((unsigned long )chunk == (unsigned long )((void *)0)) {
#line 168
        return ((ngx_int_t )-1);
      }
#line 171
      b->start = chunk;
#line 172
      b->end = (chunk + sizeof("0000000000000000\r\n")) - 1;
    }
    {
#line 175
    b->tag = (ngx_buf_tag_t )(& ngx_http_chunked_filter_module);
#line 176
    b->memory = 0U;
#line 177
    b->temporary = 1U;
#line 178
    b->pos = chunk;
#line 179
    b->last = ngx_sprintf(chunk, "%xO\r\n", size);
#line 181
    tl->next = out;
#line 182
    out = tl;
    }
  }
#line 185
  if ((cl->buf)->last_buf) {
    {
#line 186
    tl = ngx_http_chunked_create_trailers(r, ctx);
    }
#line 187
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 188
      return ((ngx_int_t )-1);
    }
#line 191
    (cl->buf)->last_buf = 0U;
#line 193
    *ll = tl;
#line 195
    if (size == 0L) {
#line 196
      (tl->buf)->pos += 2;
    }
  } else
#line 199
  if (size > 0L) {
    {
#line 200
    tl = ngx_chain_get_free_buf(r->pool, & ctx->free);
    }
#line 201
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 202
      return ((ngx_int_t )-1);
    }
#line 205
    b = tl->buf;
#line 207
    b->tag = (ngx_buf_tag_t )(& ngx_http_chunked_filter_module);
#line 208
    b->temporary = 0U;
#line 209
    b->memory = 1U;
#line 210
    b->pos = (u_char *)"\r\n";
#line 211
    b->last = b->pos + 2;
#line 213
    *ll = tl;
  } else {
#line 216
    *ll = (ngx_chain_t *)((void *)0);
  }
  {
#line 219
  rc = (*ngx_http_next_body_filter___6)(r, out);
#line 221
  ngx_chain_update_chains(r->pool, & ctx->free, & ctx->busy, & out, (ngx_buf_tag_t )(& ngx_http_chunked_filter_module));
  }
#line 224
  return (rc);
}
}
#line 228 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_chain_t *ngx_http_chunked_create_trailers(ngx_http_request_t *r , ngx_http_chunked_filter_ctx_t *ctx ) 
{ 
  size_t len ;
  ngx_buf_t *b ;
  ngx_uint_t i ;
  ngx_chain_t *cl ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  void *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 239
  len = (size_t )0;
#line 241
  part = & r->headers_out.trailers.part;
#line 242
  header___0 = (ngx_table_elt_t *)part->elts;
#line 244
  i = (ngx_uint_t )0;
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (i >= part->nelts) {
#line 247
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 248
        goto while_break;
      }
#line 251
      part = part->next;
#line 252
      header___0 = (ngx_table_elt_t *)part->elts;
#line 253
      i = (ngx_uint_t )0;
    }
#line 256
    if ((header___0 + i)->hash == 0UL) {
#line 257
      goto __Cont;
    }
#line 260
    len += (((((header___0 + i)->key.len + sizeof(": ")) - 1UL) + (header___0 + i)->value.len) + sizeof("\r\n")) - 1UL;
    __Cont: /* CIL Label */ 
#line 244
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 264
  cl = ngx_chain_get_free_buf(r->pool, & ctx->free);
  }
#line 265
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 266
    return ((ngx_chain_t *)((void *)0));
  }
#line 269
  b = cl->buf;
#line 271
  b->tag = (ngx_buf_tag_t )(& ngx_http_chunked_filter_module);
#line 272
  b->temporary = 0U;
#line 273
  b->memory = 1U;
#line 274
  b->last_buf = 1U;
#line 276
  if (len == 0UL) {
#line 277
    b->pos = (u_char *)"\r\n0\r\n\r\n";
#line 278
    b->last = (b->pos + sizeof("\r\n0\r\n\r\n")) - 1;
#line 279
    return (cl);
  }
  {
#line 282
  len += sizeof("\r\n0\r\n\r\n") - 1UL;
#line 284
  tmp = ngx_palloc(r->pool, len);
#line 284
  b->pos = (u_char *)tmp;
  }
#line 285
  if ((unsigned long )b->pos == (unsigned long )((void *)0)) {
#line 286
    return ((ngx_chain_t *)((void *)0));
  }
#line 289
  b->last = b->pos;
#line 291
  tmp___0 = b->last;
#line 291
  (b->last) ++;
#line 291
  *tmp___0 = (u_char )'\r';
#line 291
  tmp___1 = b->last;
#line 291
  (b->last) ++;
#line 291
  *tmp___1 = (u_char )'\n';
#line 292
  tmp___2 = b->last;
#line 292
  (b->last) ++;
#line 292
  *tmp___2 = (u_char )'0';
#line 293
  tmp___3 = b->last;
#line 293
  (b->last) ++;
#line 293
  *tmp___3 = (u_char )'\r';
#line 293
  tmp___4 = b->last;
#line 293
  (b->last) ++;
#line 293
  *tmp___4 = (u_char )'\n';
#line 295
  part = & r->headers_out.trailers.part;
#line 296
  header___0 = (ngx_table_elt_t *)part->elts;
#line 298
  i = (ngx_uint_t )0;
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 300
    if (i >= part->nelts) {
#line 301
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 302
        goto while_break___0;
      }
#line 305
      part = part->next;
#line 306
      header___0 = (ngx_table_elt_t *)part->elts;
#line 307
      i = (ngx_uint_t )0;
    }
#line 310
    if ((header___0 + i)->hash == 0UL) {
#line 311
      goto __Cont___0;
    }
    {
#line 318
    tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->key.data,
                     (header___0 + i)->key.len);
#line 318
    b->last = (u_char *)tmp___5 + (header___0 + i)->key.len;
#line 319
    tmp___6 = b->last;
#line 319
    (b->last) ++;
#line 319
    *tmp___6 = (u_char )':';
#line 319
    tmp___7 = b->last;
#line 319
    (b->last) ++;
#line 319
    *tmp___7 = (u_char )' ';
#line 321
    tmp___8 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                     (header___0 + i)->value.len);
#line 321
    b->last = (u_char *)tmp___8 + (header___0 + i)->value.len;
#line 322
    tmp___9 = b->last;
#line 322
    (b->last) ++;
#line 322
    *tmp___9 = (u_char )'\r';
#line 322
    tmp___10 = b->last;
#line 322
    (b->last) ++;
#line 322
    *tmp___10 = (u_char )'\n';
    }
    __Cont___0: /* CIL Label */ 
#line 298
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 325
  tmp___11 = b->last;
#line 325
  (b->last) ++;
#line 325
  *tmp___11 = (u_char )'\r';
#line 325
  tmp___12 = b->last;
#line 325
  (b->last) ++;
#line 325
  *tmp___12 = (u_char )'\n';
#line 327
  return (cl);
}
}
#line 331 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_chunked_filter_module.c"
static ngx_int_t ngx_http_chunked_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 334
  ngx_http_next_header_filter___6 = ngx_http_top_header_filter;
#line 335
  ngx_http_top_header_filter = & ngx_http_chunked_header_filter;
#line 337
  ngx_http_next_body_filter___6 = ngx_http_top_body_filter;
#line 338
  ngx_http_top_body_filter = & ngx_http_chunked_body_filter;
#line 340
  return ((ngx_int_t )0);
}
}
#line 126 "src/core/ngx_inet.h"
in_port_t ngx_inet_get_port(struct sockaddr *sa ) ;
#line 598 "src/http/ngx_http_request.h"
ngx_http_header_out_t ngx_http_headers_out[11] ;
#line 515 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_write_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
static ngx_int_t ngx_http_header_filter_init(ngx_conf_t *cf ) ;
#line 15
static ngx_int_t ngx_http_header_filter(ngx_http_request_t *r ) ;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
static ngx_http_module_t ngx_http_header_filter_module_ctx  = 
#line 18
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_header_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
ngx_module_t ngx_http_header_filter_module  = 
#line 33
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_header_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 49 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
static u_char ngx_http_server_string[16]  = 
#line 49
  {      (u_char )'S',      (u_char )'e',      (u_char )'r',      (u_char )'v', 
        (u_char )'e',      (u_char )'r',      (u_char )':',      (u_char )' ', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 50 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
static u_char ngx_http_server_full_string[23]  = 
#line 50
  {      (u_char )'S',      (u_char )'e',      (u_char )'r',      (u_char )'v', 
        (u_char )'e',      (u_char )'r',      (u_char )':',      (u_char )' ', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'/',      (u_char )'1',      (u_char )'.', 
        (u_char )'1',      (u_char )'3',      (u_char )'.',      (u_char )'8', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
static u_char ngx_http_server_build_string[23]  = 
#line 51
  {      (u_char )'S',      (u_char )'e',      (u_char )'r',      (u_char )'v', 
        (u_char )'e',      (u_char )'r',      (u_char )':',      (u_char )' ', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'/',      (u_char )'1',      (u_char )'.', 
        (u_char )'1',      (u_char )'3',      (u_char )'.',      (u_char )'8', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 54 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
static ngx_str_t ngx_http_status_lines[53]  = 
#line 54
  {      {sizeof("200 OK") - 1UL, (u_char *)"200 OK"}, 
        {sizeof("201 Created") - 1UL, (u_char *)"201 Created"}, 
        {sizeof("202 Accepted") - 1UL, (u_char *)"202 Accepted"}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof("204 No Content") - 1UL, (u_char *)"204 No Content"}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof("206 Partial Content") - 1UL, (u_char *)"206 Partial Content"}, 
        {sizeof("301 Moved Permanently") - 1UL, (u_char *)"301 Moved Permanently"}, 
        {sizeof("302 Moved Temporarily") - 1UL, (u_char *)"302 Moved Temporarily"}, 
        {sizeof("303 See Other") - 1UL, (u_char *)"303 See Other"}, 
        {sizeof("304 Not Modified") - 1UL, (u_char *)"304 Not Modified"}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof("307 Temporary Redirect") - 1UL, (u_char *)"307 Temporary Redirect"}, 
        {sizeof("308 Permanent Redirect") - 1UL,
      (u_char *)"308 Permanent Redirect"}, 
        {sizeof("400 Bad Request") - 1UL, (u_char *)"400 Bad Request"}, 
        {sizeof("401 Unauthorized") - 1UL, (u_char *)"401 Unauthorized"}, 
        {sizeof("402 Payment Required") - 1UL, (u_char *)"402 Payment Required"}, 
        {sizeof("403 Forbidden") - 1UL, (u_char *)"403 Forbidden"}, 
        {sizeof("404 Not Found") - 1UL, (u_char *)"404 Not Found"}, 
        {sizeof("405 Not Allowed") - 1UL, (u_char *)"405 Not Allowed"}, 
        {sizeof("406 Not Acceptable") - 1UL, (u_char *)"406 Not Acceptable"}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof("408 Request Time-out") - 1UL, (u_char *)"408 Request Time-out"}, 
        {sizeof("409 Conflict") - 1UL, (u_char *)"409 Conflict"}, 
        {sizeof("410 Gone") - 1UL, (u_char *)"410 Gone"}, 
        {sizeof("411 Length Required") - 1UL, (u_char *)"411 Length Required"}, 
        {sizeof("412 Precondition Failed") - 1UL, (u_char *)"412 Precondition Failed"}, 
        {sizeof("413 Request Entity Too Large") - 1UL,
      (u_char *)"413 Request Entity Too Large"}, 
        {sizeof("414 Request-URI Too Large") - 1UL, (u_char *)"414 Request-URI Too Large"}, 
        {sizeof("415 Unsupported Media Type") - 1UL,
      (u_char *)"415 Unsupported Media Type"}, 
        {sizeof("416 Requested Range Not Satisfiable") - 1UL, (u_char *)"416 Requested Range Not Satisfiable"}, 
        {(size_t )0,
      (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof("421 Misdirected Request") - 1UL, (u_char *)"421 Misdirected Request"}, 
        {(size_t )0,
      (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof("429 Too Many Requests") - 1UL, (u_char *)"429 Too Many Requests"}, 
        {sizeof("500 Internal Server Error") - 1UL, (u_char *)"500 Internal Server Error"}, 
        {sizeof("501 Not Implemented") - 1UL,
      (u_char *)"501 Not Implemented"}, 
        {sizeof("502 Bad Gateway") - 1UL, (u_char *)"502 Bad Gateway"}, 
        {sizeof("503 Service Temporarily Unavailable") - 1UL, (u_char *)"503 Service Temporarily Unavailable"}, 
        {sizeof("504 Gateway Time-out") - 1UL,
      (u_char *)"504 Gateway Time-out"}, 
        {sizeof("505 HTTP Version Not Supported") - 1UL, (u_char *)"505 HTTP Version Not Supported"}, 
        {(size_t )0,
      (u_char *)((void *)0)}, 
        {sizeof("507 Insufficient Storage") - 1UL, (u_char *)"507 Insufficient Storage"}};
#line 135 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
ngx_http_header_out_t ngx_http_headers_out[11]  = 
#line 135
  {      {{sizeof("Server") - 1UL, (u_char *)"Server"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->server)}, 
        {{sizeof("Date") - 1UL,
       (u_char *)"Date"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->date)}, 
        {{sizeof("Content-Length") - 1UL,
       (u_char *)"Content-Length"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->content_length)}, 
        {{sizeof("Content-Encoding") - 1UL,
       (u_char *)"Content-Encoding"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->content_encoding)}, 
        {{sizeof("Location") - 1UL,
       (u_char *)"Location"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->location)}, 
        {{sizeof("Last-Modified") - 1UL,
       (u_char *)"Last-Modified"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->last_modified)}, 
        {{sizeof("Accept-Ranges") - 1UL,
       (u_char *)"Accept-Ranges"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->accept_ranges)}, 
        {{sizeof("Expires") - 1UL,
       (u_char *)"Expires"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->expires)}, 
        {{sizeof("Cache-Control") - 1UL,
       (u_char *)"Cache-Control"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->cache_control)}, 
        {{sizeof("ETag") - 1UL,
       (u_char *)"ETag"}, (unsigned long )(& ((ngx_http_headers_out_t *)0)->etag)}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 156 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
static ngx_int_t ngx_http_header_filter(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_str_t host ;
  ngx_str_t *status_line ;
  ngx_buf_t *b ;
  ngx_uint_t status ;
  ngx_uint_t i ;
  ngx_uint_t port ;
  ngx_chain_t out ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t *cscf ;
  u_char addr[((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)] ;
  ngx_int_t tmp ;
  in_port_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  void *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  void *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  void *tmp___19 ;
  u_char *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  u_char *tmp___25 ;
  u_char *tmp___26 ;
  void *tmp___27 ;
  void *tmp___28 ;
  void *tmp___29 ;
  void *tmp___30 ;
  void *tmp___31 ;
  void *tmp___32 ;
  u_char *tmp___33 ;
  u_char *tmp___34 ;
  void *tmp___35 ;
  u_char *tmp___36 ;
  u_char *tmp___37 ;
  u_char *tmp___38 ;
  u_char *tmp___39 ;
  ngx_int_t tmp___40 ;
  void *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;

  {
#line 172
  if (r->header_sent) {
#line 173
    return ((ngx_int_t )0);
  }
#line 176
  r->header_sent = 1U;
#line 178
  if ((unsigned long )r != (unsigned long )r->main) {
#line 179
    return ((ngx_int_t )0);
  }
#line 182
  if (r->http_version < 1000UL) {
#line 183
    return ((ngx_int_t )0);
  }
#line 186
  if (r->method == 4UL) {
#line 187
    r->header_only = 1U;
  }
#line 190
  if (r->headers_out.last_modified_time != -1L) {
#line 191
    if (r->headers_out.status != 200UL) {
#line 191
      if (r->headers_out.status != 206UL) {
#line 191
        if (r->headers_out.status != 304UL) {
#line 195
          r->headers_out.last_modified_time = (time_t )-1;
#line 196
          r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
        }
      }
    }
  }
#line 200
  len = ((((sizeof("HTTP/1.x ") - 1UL) + sizeof("\r\n")) - 1UL) + sizeof("\r\n")) - 1UL;
#line 206
  if (r->headers_out.status_line.len) {
#line 207
    len += r->headers_out.status_line.len;
#line 208
    status_line = & r->headers_out.status_line;
#line 210
    status = (ngx_uint_t )0;
  } else {
#line 215
    status = r->headers_out.status;
#line 217
    if (status >= 200UL) {
#line 217
      if (status < 207UL) {
#line 222
        if (status == 204UL) {
#line 223
          r->header_only = 1U;
#line 224
          r->headers_out.content_type.len = (size_t )0;
#line 224
          r->headers_out.content_type.data = (u_char *)((void *)0);
#line 225
          r->headers_out.last_modified_time = (time_t )-1;
#line 226
          r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
#line 227
          r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
#line 228
          r->headers_out.content_length_n = (off_t )-1;
        }
#line 231
        status -= 200UL;
#line 232
        status_line = & ngx_http_status_lines[status];
#line 233
        len += ngx_http_status_lines[status].len;
      } else {
#line 217
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 235
    if (status >= 301UL) {
#line 235
      if (status < 309UL) {
#line 240
        if (status == 304UL) {
#line 241
          r->header_only = 1U;
        }
#line 244
        status = (status - 301UL) + 7UL;
#line 245
        status_line = & ngx_http_status_lines[status];
#line 246
        len += ngx_http_status_lines[status].len;
      } else {
#line 235
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 248
    if (status >= 400UL) {
#line 248
      if (status < 430UL) {
#line 252
        status = (status - 400UL) + 15UL;
#line 255
        status_line = & ngx_http_status_lines[status];
#line 256
        len += ngx_http_status_lines[status].len;
      } else {
#line 248
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 258
    if (status >= 500UL) {
#line 258
      if (status < 508UL) {
#line 262
        status = (status - 500UL) + 45UL;
#line 265
        status_line = & ngx_http_status_lines[status];
#line 266
        len += ngx_http_status_lines[status].len;
      } else {
#line 269
        len += (sizeof("-9223372036854775808") - 1UL) + 1UL;
#line 270
        status_line = (ngx_str_t *)((void *)0);
      }
    } else {
#line 269
      len += (sizeof("-9223372036854775808") - 1UL) + 1UL;
#line 270
      status_line = (ngx_str_t *)((void *)0);
    }
#line 273
    if (status_line) {
#line 273
      if (status_line->len == 0UL) {
#line 274
        status = r->headers_out.status;
#line 275
        len += (sizeof("-9223372036854775808") - 1UL) + 1UL;
#line 276
        status_line = (ngx_str_t *)((void *)0);
      }
    }
  }
#line 280
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 282
  if ((unsigned long )r->headers_out.server == (unsigned long )((void *)0)) {
#line 283
    if (clcf->server_tokens == 1UL) {
#line 284
      len += sizeof(ngx_http_server_full_string) - 1UL;
    } else
#line 286
    if (clcf->server_tokens == 2UL) {
#line 287
      len += sizeof(ngx_http_server_build_string) - 1UL;
    } else {
#line 290
      len += sizeof(ngx_http_server_string) - 1UL;
    }
  }
#line 294
  if ((unsigned long )r->headers_out.date == (unsigned long )((void *)0)) {
#line 295
    len += sizeof("Date: Mon, 28 Sep 1970 06:00:00 GMT\r\n") - 1UL;
  }
#line 298
  if (r->headers_out.content_type.len) {
#line 299
    len += ((sizeof("Content-Type: ") - 1UL) + r->headers_out.content_type.len) + 2UL;
#line 302
    if (r->headers_out.content_type_len == r->headers_out.content_type.len) {
#line 302
      if (r->headers_out.charset.len) {
#line 305
        len += (sizeof("; charset=") - 1UL) + r->headers_out.charset.len;
      }
    }
  }
#line 309
  if ((unsigned long )r->headers_out.content_length == (unsigned long )((void *)0)) {
#line 309
    if (r->headers_out.content_length_n >= 0L) {
#line 312
      len += ((sizeof("Content-Length: ") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + 2UL;
    }
  }
#line 315
  if ((unsigned long )r->headers_out.last_modified == (unsigned long )((void *)0)) {
#line 315
    if (r->headers_out.last_modified_time != -1L) {
#line 318
      len += sizeof("Last-Modified: Mon, 28 Sep 1970 06:00:00 GMT\r\n") - 1UL;
    }
  }
#line 321
  c = r->connection;
#line 323
  if (r->headers_out.location) {
#line 323
    if ((r->headers_out.location)->value.len) {
#line 323
      if ((int )*((r->headers_out.location)->value.data + 0) == 47) {
#line 323
        if (clcf->absolute_redirect) {
#line 328
          (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 330
          if (clcf->server_name_in_redirect) {
#line 331
            cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 332
            host = cscf->server_name;
          } else
#line 334
          if (r->headers_in.server.len) {
#line 335
            host = r->headers_in.server;
          } else {
            {
#line 338
            host.len = ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 339
            host.data = addr;
#line 341
            tmp = ngx_connection_local_sockaddr(c, & host, (ngx_uint_t )0);
            }
#line 341
            if (tmp != 0L) {
#line 342
              return ((ngx_int_t )-1);
            }
          }
          {
#line 346
          tmp___0 = ngx_inet_get_port(c->local_sockaddr);
#line 346
          port = (ngx_uint_t )tmp___0;
#line 348
          len += (((sizeof("Location: https://") - 1UL) + host.len) + (r->headers_out.location)->value.len) + 2UL;
          }
#line 352
          if (clcf->port_in_redirect) {
#line 359
            if (port == 80UL) {
#line 359
              port = (ngx_uint_t )0;
            } else {
#line 359
              port = port;
            }
          } else {
#line 362
            port = (ngx_uint_t )0;
          }
#line 365
          if (port) {
#line 366
            len += sizeof(":65535") - 1UL;
          }
        } else {
#line 370
          host.len = (size_t )0;
#line 370
          host.data = (u_char *)((void *)0);
#line 371
          port = (ngx_uint_t )0;
        }
      } else {
#line 370
        host.len = (size_t )0;
#line 370
        host.data = (u_char *)((void *)0);
#line 371
        port = (ngx_uint_t )0;
      }
    } else {
#line 370
      host.len = (size_t )0;
#line 370
      host.data = (u_char *)((void *)0);
#line 371
      port = (ngx_uint_t )0;
    }
  } else {
#line 370
    host.len = (size_t )0;
#line 370
    host.data = (u_char *)((void *)0);
#line 371
    port = (ngx_uint_t )0;
  }
#line 374
  if (r->chunked) {
#line 375
    len += sizeof("Transfer-Encoding: chunked\r\n") - 1UL;
  }
#line 378
  if (r->headers_out.status == 101UL) {
#line 379
    len += sizeof("Connection: upgrade\r\n") - 1UL;
  } else
#line 381
  if (r->keepalive) {
#line 382
    len += sizeof("Connection: keep-alive\r\n") - 1UL;
#line 392
    if (clcf->keepalive_header) {
#line 393
      len += ((sizeof("Keep-Alive: timeout=") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + 2UL;
    }
  } else {
#line 397
    len += sizeof("Connection: close\r\n") - 1UL;
  }
#line 401
  if (r->gzip_vary) {
#line 402
    if (clcf->gzip_vary) {
#line 403
      len += sizeof("Vary: Accept-Encoding\r\n") - 1UL;
    } else {
#line 406
      r->gzip_vary = 0U;
    }
  }
#line 411
  part = & r->headers_out.headers.part;
#line 412
  header___0 = (ngx_table_elt_t *)part->elts;
#line 414
  i = (ngx_uint_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (i >= part->nelts) {
#line 417
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 418
        goto while_break;
      }
#line 421
      part = part->next;
#line 422
      header___0 = (ngx_table_elt_t *)part->elts;
#line 423
      i = (ngx_uint_t )0;
    }
#line 426
    if ((header___0 + i)->hash == 0UL) {
#line 427
      goto __Cont;
    }
#line 430
    len += (((((header___0 + i)->key.len + sizeof(": ")) - 1UL) + (header___0 + i)->value.len) + sizeof("\r\n")) - 1UL;
    __Cont: /* CIL Label */ 
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  b = ngx_create_temp_buf(r->pool, len);
  }
#line 435
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 436
    return ((ngx_int_t )-1);
  }
  {
#line 440
  tmp___1 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"HTTP/1.1 ",
                   sizeof("HTTP/1.x ") - 1UL);
#line 440
  b->last = (u_char *)tmp___1 + (sizeof("HTTP/1.x ") - 1UL);
  }
#line 443
  if (status_line) {
    {
#line 444
    tmp___2 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)status_line->data,
                     status_line->len);
#line 444
    b->last = (u_char *)tmp___2 + status_line->len;
    }
  } else {
    {
#line 447
    b->last = ngx_sprintf(b->last, "%03ui ", status);
    }
  }
#line 449
  tmp___3 = b->last;
#line 449
  (b->last) ++;
#line 449
  *tmp___3 = (u_char )'\r';
#line 449
  tmp___4 = b->last;
#line 449
  (b->last) ++;
#line 449
  *tmp___4 = (u_char )'\n';
#line 451
  if ((unsigned long )r->headers_out.server == (unsigned long )((void *)0)) {
#line 452
    if (clcf->server_tokens == 1UL) {
#line 453
      p = ngx_http_server_full_string;
#line 454
      len = sizeof(ngx_http_server_full_string) - 1UL;
    } else
#line 456
    if (clcf->server_tokens == 2UL) {
#line 457
      p = ngx_http_server_build_string;
#line 458
      len = sizeof(ngx_http_server_build_string) - 1UL;
    } else {
#line 461
      p = ngx_http_server_string;
#line 462
      len = sizeof(ngx_http_server_string) - 1UL;
    }
    {
#line 465
    tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)p,
                     len);
#line 465
    b->last = (u_char *)tmp___5 + len;
    }
  }
#line 468
  if ((unsigned long )r->headers_out.date == (unsigned long )((void *)0)) {
    {
#line 469
    tmp___6 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Date: ",
                     sizeof("Date: ") - 1UL);
#line 469
    b->last = (u_char *)tmp___6 + (sizeof("Date: ") - 1UL);
#line 470
    tmp___7 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)ngx_cached_http_time.data,
                     (size_t )ngx_cached_http_time.len);
#line 470
    b->last = (u_char *)tmp___7 + ngx_cached_http_time.len;
#line 473
    tmp___8 = b->last;
#line 473
    (b->last) ++;
#line 473
    *tmp___8 = (u_char )'\r';
#line 473
    tmp___9 = b->last;
#line 473
    (b->last) ++;
#line 473
    *tmp___9 = (u_char )'\n';
    }
  }
#line 476
  if (r->headers_out.content_type.len) {
    {
#line 477
    tmp___10 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Content-Type: ",
                      sizeof("Content-Type: ") - 1UL);
#line 477
    b->last = (u_char *)tmp___10 + (sizeof("Content-Type: ") - 1UL);
#line 479
    p = b->last;
#line 480
    tmp___11 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->headers_out.content_type.data,
                      r->headers_out.content_type.len);
#line 480
    b->last = (u_char *)tmp___11 + r->headers_out.content_type.len;
    }
#line 483
    if (r->headers_out.content_type_len == r->headers_out.content_type.len) {
#line 483
      if (r->headers_out.charset.len) {
        {
#line 486
        tmp___12 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"; charset=",
                          sizeof("; charset=") - 1UL);
#line 486
        b->last = (u_char *)tmp___12 + (sizeof("; charset=") - 1UL);
#line 488
        tmp___13 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)r->headers_out.charset.data,
                          r->headers_out.charset.len);
#line 488
        b->last = (u_char *)tmp___13 + r->headers_out.charset.len;
#line 493
        r->headers_out.content_type.len = (size_t )(b->last - p);
#line 494
        r->headers_out.content_type.data = p;
        }
      }
    }
#line 497
    tmp___14 = b->last;
#line 497
    (b->last) ++;
#line 497
    *tmp___14 = (u_char )'\r';
#line 497
    tmp___15 = b->last;
#line 497
    (b->last) ++;
#line 497
    *tmp___15 = (u_char )'\n';
  }
#line 500
  if ((unsigned long )r->headers_out.content_length == (unsigned long )((void *)0)) {
#line 500
    if (r->headers_out.content_length_n >= 0L) {
      {
#line 503
      b->last = ngx_sprintf(b->last, "Content-Length: %O\r\n", r->headers_out.content_length_n);
      }
    }
  }
#line 507
  if ((unsigned long )r->headers_out.last_modified == (unsigned long )((void *)0)) {
#line 507
    if (r->headers_out.last_modified_time != -1L) {
      {
#line 510
      tmp___16 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Last-Modified: ",
                        sizeof("Last-Modified: ") - 1UL);
#line 510
      b->last = (u_char *)tmp___16 + (sizeof("Last-Modified: ") - 1UL);
#line 512
      b->last = ngx_http_time(b->last, r->headers_out.last_modified_time);
#line 514
      tmp___17 = b->last;
#line 514
      (b->last) ++;
#line 514
      *tmp___17 = (u_char )'\r';
#line 514
      tmp___18 = b->last;
#line 514
      (b->last) ++;
#line 514
      *tmp___18 = (u_char )'\n';
      }
    }
  }
#line 517
  if (host.data) {
    {
#line 519
    p = (b->last + sizeof("Location: ")) - 1;
#line 521
    tmp___19 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Location: http",
                      sizeof("Location: http") - 1UL);
#line 521
    b->last = (u_char *)tmp___19 + (sizeof("Location: http") - 1UL);
#line 530
    tmp___20 = b->last;
#line 530
    (b->last) ++;
#line 530
    *tmp___20 = (u_char )':';
#line 530
    tmp___21 = b->last;
#line 530
    (b->last) ++;
#line 530
    *tmp___21 = (u_char )'/';
#line 530
    tmp___22 = b->last;
#line 530
    (b->last) ++;
#line 530
    *tmp___22 = (u_char )'/';
#line 531
    tmp___23 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)host.data,
                      host.len);
#line 531
    b->last = (u_char *)tmp___23 + host.len;
    }
#line 533
    if (port) {
      {
#line 534
      b->last = ngx_sprintf(b->last, ":%ui", port);
      }
    }
    {
#line 537
    tmp___24 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(r->headers_out.location)->value.data,
                      (r->headers_out.location)->value.len);
#line 537
    b->last = (u_char *)tmp___24 + (r->headers_out.location)->value.len;
#line 542
    (r->headers_out.location)->value.len = (size_t )(b->last - p);
#line 543
    (r->headers_out.location)->value.data = p;
#line 544
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 544
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 546
    tmp___25 = b->last;
#line 546
    (b->last) ++;
#line 546
    *tmp___25 = (u_char )'\r';
#line 546
    tmp___26 = b->last;
#line 546
    (b->last) ++;
#line 546
    *tmp___26 = (u_char )'\n';
    }
  }
#line 549
  if (r->chunked) {
    {
#line 550
    tmp___27 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Transfer-Encoding: chunked\r\n",
                      sizeof("Transfer-Encoding: chunked\r\n") - 1UL);
#line 550
    b->last = (u_char *)tmp___27 + (sizeof("Transfer-Encoding: chunked\r\n") - 1UL);
    }
  }
#line 554
  if (r->headers_out.status == 101UL) {
    {
#line 555
    tmp___28 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Connection: upgrade\r\n",
                      sizeof("Connection: upgrade\r\n") - 1UL);
#line 555
    b->last = (u_char *)tmp___28 + (sizeof("Connection: upgrade\r\n") - 1UL);
    }
  } else
#line 558
  if (r->keepalive) {
    {
#line 559
    tmp___29 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Connection: keep-alive\r\n",
                      sizeof("Connection: keep-alive\r\n") - 1UL);
#line 559
    b->last = (u_char *)tmp___29 + (sizeof("Connection: keep-alive\r\n") - 1UL);
    }
#line 562
    if (clcf->keepalive_header) {
      {
#line 563
      b->last = ngx_sprintf(b->last, "Keep-Alive: timeout=%T\r\n", clcf->keepalive_header);
      }
    }
  } else {
    {
#line 568
    tmp___30 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Connection: close\r\n",
                      sizeof("Connection: close\r\n") - 1UL);
#line 568
    b->last = (u_char *)tmp___30 + (sizeof("Connection: close\r\n") - 1UL);
    }
  }
#line 573
  if (r->gzip_vary) {
    {
#line 574
    tmp___31 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)"Vary: Accept-Encoding\r\n",
                      sizeof("Vary: Accept-Encoding\r\n") - 1UL);
#line 574
    b->last = (u_char *)tmp___31 + (sizeof("Vary: Accept-Encoding\r\n") - 1UL);
    }
  }
#line 579
  part = & r->headers_out.headers.part;
#line 580
  header___0 = (ngx_table_elt_t *)part->elts;
#line 582
  i = (ngx_uint_t )0;
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 584
    if (i >= part->nelts) {
#line 585
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 586
        goto while_break___0;
      }
#line 589
      part = part->next;
#line 590
      header___0 = (ngx_table_elt_t *)part->elts;
#line 591
      i = (ngx_uint_t )0;
    }
#line 594
    if ((header___0 + i)->hash == 0UL) {
#line 595
      goto __Cont___0;
    }
    {
#line 598
    tmp___32 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->key.data,
                      (header___0 + i)->key.len);
#line 598
    b->last = (u_char *)tmp___32 + (header___0 + i)->key.len;
#line 599
    tmp___33 = b->last;
#line 599
    (b->last) ++;
#line 599
    *tmp___33 = (u_char )':';
#line 599
    tmp___34 = b->last;
#line 599
    (b->last) ++;
#line 599
    *tmp___34 = (u_char )' ';
#line 601
    tmp___35 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)(header___0 + i)->value.data,
                      (header___0 + i)->value.len);
#line 601
    b->last = (u_char *)tmp___35 + (header___0 + i)->value.len;
#line 602
    tmp___36 = b->last;
#line 602
    (b->last) ++;
#line 602
    *tmp___36 = (u_char )'\r';
#line 602
    tmp___37 = b->last;
#line 602
    (b->last) ++;
#line 602
    *tmp___37 = (u_char )'\n';
    }
    __Cont___0: /* CIL Label */ 
#line 582
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 609
  tmp___38 = b->last;
#line 609
  (b->last) ++;
#line 609
  *tmp___38 = (u_char )'\r';
#line 609
  tmp___39 = b->last;
#line 609
  (b->last) ++;
#line 609
  *tmp___39 = (u_char )'\n';
#line 611
  r->header_size = (size_t )(b->last - b->pos);
#line 613
  if (r->header_only) {
#line 614
    b->last_buf = 1U;
  }
  {
#line 617
  out.buf = b;
#line 618
  out.next = (ngx_chain_t *)((void *)0);
#line 620
  tmp___40 = ngx_http_write_filter(r, & out);
  }
#line 620
  return (tmp___40);
}
}
#line 624 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_header_filter_module.c"
static ngx_int_t ngx_http_header_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 627
  ngx_http_top_header_filter = & ngx_http_header_filter;
#line 629
  return ((ngx_int_t )0);
}
}
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_write_filter_module.c"
static ngx_int_t ngx_http_write_filter_init(ngx_conf_t *cf ) ;
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_write_filter_module.c"
static ngx_http_module_t ngx_http_write_filter_module_ctx  = 
#line 16
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_write_filter_init, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 31 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_write_filter_module.c"
ngx_module_t ngx_http_write_filter_module  = 
#line 31
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_write_filter_module_ctx),
    (ngx_command_t *)((void *)0), (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_write_filter_module.c"
ngx_int_t ngx_http_write_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  off_t size ;
  off_t sent ;
  off_t nsent ;
  off_t limit ;
  ngx_uint_t last ;
  ngx_uint_t flush ;
  ngx_uint_t sync___0 ;
  ngx_msec_t delay ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_chain_t **ll ;
  ngx_chain_t *chain ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  off_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  off_t tmp___2 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 57
  c = r->connection;
#line 59
  if (c->error) {
#line 60
    return ((ngx_int_t )-1);
  }
#line 63
  size = (off_t )0;
#line 64
  flush = (ngx_uint_t )0;
#line 65
  sync___0 = (ngx_uint_t )0;
#line 66
  last = (ngx_uint_t )0;
#line 67
  ll = & r->out;
#line 71
  cl = r->out;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! cl) {
#line 71
      goto while_break;
    }
#line 72
    ll = & cl->next;
#line 84
    if ((cl->buf)->temporary) {
#line 84
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 84
    if ((cl->buf)->memory) {
#line 84
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 84
    if ((cl->buf)->mmap) {
#line 84
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 84
      tmp = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 84
    if (tmp == 0L) {
#line 84
      if ((cl->buf)->flush) {
#line 84
        goto _L___1;
      } else
#line 84
      if ((cl->buf)->last_buf) {
#line 84
        goto _L___1;
      } else
#line 84
      if ((cl->buf)->sync) {
        _L___1: /* CIL Label */ 
#line 84
        if ((cl->buf)->temporary) {
#line 84
          goto _L___0;
        } else
#line 84
        if ((cl->buf)->memory) {
#line 84
          goto _L___0;
        } else
#line 84
        if ((cl->buf)->mmap) {
#line 84
          goto _L___0;
        } else
#line 84
        if (! (! (cl->buf)->in_file)) {
#line 84
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 85
        if ((c->log)->log_level >= 2UL) {
          {
#line 85
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "zero size buf in writer t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 98
        ngx_debug_point();
        }
#line 99
        return ((ngx_int_t )-1);
      }
    }
#line 103
    if ((cl->buf)->temporary) {
#line 103
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 103
    if ((cl->buf)->memory) {
#line 103
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 103
    if ((cl->buf)->mmap) {
#line 103
      tmp___0 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 103
      tmp___0 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 103
    size += tmp___0;
#line 105
    if ((cl->buf)->flush) {
#line 106
      flush = (ngx_uint_t )1;
    } else
#line 105
    if ((cl->buf)->recycled) {
#line 106
      flush = (ngx_uint_t )1;
    }
#line 109
    if ((cl->buf)->sync) {
#line 110
      sync___0 = (ngx_uint_t )1;
    }
#line 113
    if ((cl->buf)->last_buf) {
#line 114
      last = (ngx_uint_t )1;
    }
#line 71
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  ln = in;
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 120
    if (! ln) {
#line 120
      goto while_break___0;
    }
    {
#line 121
    cl = ngx_alloc_chain_link(r->pool);
    }
#line 122
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 123
      return ((ngx_int_t )-1);
    }
#line 126
    cl->buf = ln->buf;
#line 127
    *ll = cl;
#line 128
    ll = & cl->next;
#line 140
    if ((cl->buf)->temporary) {
#line 140
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 140
    if ((cl->buf)->memory) {
#line 140
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 140
    if ((cl->buf)->mmap) {
#line 140
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 140
      tmp___1 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 140
    if (tmp___1 == 0L) {
#line 140
      if ((cl->buf)->flush) {
#line 140
        goto _L___4;
      } else
#line 140
      if ((cl->buf)->last_buf) {
#line 140
        goto _L___4;
      } else
#line 140
      if ((cl->buf)->sync) {
        _L___4: /* CIL Label */ 
#line 140
        if ((cl->buf)->temporary) {
#line 140
          goto _L___3;
        } else
#line 140
        if ((cl->buf)->memory) {
#line 140
          goto _L___3;
        } else
#line 140
        if ((cl->buf)->mmap) {
#line 140
          goto _L___3;
        } else
#line 140
        if (! (! (cl->buf)->in_file)) {
#line 140
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 141
        if ((c->log)->log_level >= 2UL) {
          {
#line 141
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "zero size buf in writer t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 154
        ngx_debug_point();
        }
#line 155
        return ((ngx_int_t )-1);
      }
    }
#line 159
    if ((cl->buf)->temporary) {
#line 159
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 159
    if ((cl->buf)->memory) {
#line 159
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 159
    if ((cl->buf)->mmap) {
#line 159
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 159
      tmp___2 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 159
    size += tmp___2;
#line 161
    if ((cl->buf)->flush) {
#line 162
      flush = (ngx_uint_t )1;
    } else
#line 161
    if ((cl->buf)->recycled) {
#line 162
      flush = (ngx_uint_t )1;
    }
#line 165
    if ((cl->buf)->sync) {
#line 166
      sync___0 = (ngx_uint_t )1;
    }
#line 169
    if ((cl->buf)->last_buf) {
#line 170
      last = (ngx_uint_t )1;
    }
#line 120
    ln = ln->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 174
  *ll = (ngx_chain_t *)((void *)0);
#line 179
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 187
  if (! last) {
#line 187
    if (! flush) {
#line 187
      if (in) {
#line 187
        if (size < (off_t )clcf->postpone_output) {
#line 188
          return ((ngx_int_t )0);
        }
      }
    }
  }
#line 191
  if ((c->write)->delayed) {
#line 192
    c->buffered |= 16U;
#line 193
    return ((ngx_int_t )-2);
  }
#line 196
  if (size == 0L) {
#line 196
    if (! (c->buffered & 15U)) {
#line 196
      if (last) {
#line 196
        if (! c->need_last_buf) {
#line 196
          goto _L___6;
        }
      } else {
        _L___6: /* CIL Label */ 
#line 200
        if (last) {
#line 200
          goto _L___5;
        } else
#line 200
        if (flush) {
#line 200
          goto _L___5;
        } else
#line 200
        if (sync___0) {
          _L___5: /* CIL Label */ 
#line 201
          cl = r->out;
          {
#line 201
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 201
            if (! cl) {
#line 201
              goto while_break___1;
            }
#line 202
            ln = cl;
#line 203
            cl = cl->next;
#line 204
            ln->next = (r->pool)->chain;
#line 204
            (r->pool)->chain = ln;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 207
          r->out = (ngx_chain_t *)((void *)0);
#line 208
          c->buffered &= 4294967279U;
#line 210
          return ((ngx_int_t )0);
        }
#line 213
        if ((c->log)->log_level >= 2UL) {
          {
#line 213
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "the http output chain is empty");
          }
        }
        {
#line 216
        ngx_debug_point();
        }
#line 218
        return ((ngx_int_t )-1);
      }
    }
  }
#line 221
  if (r->limit_rate) {
#line 222
    if (r->limit_rate_after == 0UL) {
#line 223
      r->limit_rate_after = clcf->limit_rate_after;
    }
#line 226
    limit = (off_t )((size_t )((off_t )r->limit_rate * (off_t )((ngx_cached_time->sec - (time_t volatile   )r->start_sec) + (time_t volatile   )1)) - ((size_t )c->sent - r->limit_rate_after));
#line 229
    if (limit <= 0L) {
      {
#line 230
      (c->write)->delayed = 1U;
#line 231
      delay = (size_t )(- limit * 1000L) / r->limit_rate + 1UL;
#line 232
      ngx_event_add_timer(c->write, delay);
#line 234
      c->buffered |= 16U;
      }
#line 236
      return ((ngx_int_t )-2);
    }
#line 239
    if (clcf->sendfile_max_chunk) {
#line 239
      if ((off_t )clcf->sendfile_max_chunk < limit) {
#line 242
        limit = (off_t )clcf->sendfile_max_chunk;
      }
    }
  } else {
#line 246
    limit = (off_t )clcf->sendfile_max_chunk;
  }
  {
#line 249
  sent = c->sent;
#line 254
  chain = (*(c->send_chain))(c, r->out, limit);
  }
#line 259
  if ((unsigned long )chain == (unsigned long )((ngx_chain_t *)-1)) {
#line 260
    c->error = 1U;
#line 261
    return ((ngx_int_t )-1);
  }
#line 264
  if (r->limit_rate) {
#line 266
    nsent = c->sent;
#line 268
    if (r->limit_rate_after) {
#line 270
      sent = (off_t )((size_t )sent - r->limit_rate_after);
#line 271
      if (sent < 0L) {
#line 272
        sent = (off_t )0;
      }
#line 275
      nsent = (off_t )((size_t )nsent - r->limit_rate_after);
#line 276
      if (nsent < 0L) {
#line 277
        nsent = (off_t )0;
      }
    }
#line 281
    delay = (size_t )((nsent - sent) * 1000L) / r->limit_rate;
#line 283
    if (delay > 0UL) {
      {
#line 284
      limit = (off_t )0;
#line 285
      (c->write)->delayed = 1U;
#line 286
      ngx_event_add_timer(c->write, delay);
      }
    }
  }
#line 290
  if (limit) {
#line 290
    if ((c->write)->ready) {
#line 290
      if (c->sent - sent >= limit - (off_t )(2UL * ngx_pagesize)) {
        {
#line 294
        (c->write)->delayed = 1U;
#line 295
        ngx_event_add_timer(c->write, (ngx_msec_t )1);
        }
      }
    }
  }
#line 298
  cl = r->out;
  {
#line 298
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 298
    if (cl) {
#line 298
      if (! ((unsigned long )cl != (unsigned long )chain)) {
#line 298
        goto while_break___2;
      }
    } else {
#line 298
      goto while_break___2;
    }
#line 299
    ln = cl;
#line 300
    cl = cl->next;
#line 301
    ln->next = (r->pool)->chain;
#line 301
    (r->pool)->chain = ln;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 304
  r->out = chain;
#line 306
  if (chain) {
#line 307
    c->buffered |= 16U;
#line 308
    return ((ngx_int_t )-2);
  }
#line 311
  c->buffered &= 4294967279U;
#line 313
  if (c->buffered & 15U) {
#line 313
    if ((unsigned long )r->postponed == (unsigned long )((void *)0)) {
#line 314
      return ((ngx_int_t )-2);
    }
  }
#line 317
  return ((ngx_int_t )0);
}
}
#line 321 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_write_filter_module.c"
static ngx_int_t ngx_http_write_filter_init(ngx_conf_t *cf ) 
{ 


  {
#line 324
  ngx_http_top_body_filter = & ngx_http_write_filter;
#line 326
  return ((ngx_int_t )0);
}
}
/* compiler builtin: 
   _Bool __sync_bool_compare_and_swap(...) ;  */
#line 460 "/usr/include/unistd.h"
extern int usleep(__useconds_t __useconds ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 181 "src/core/ngx_string.h"
u_char *ngx_hex_dump(u_char *dst , u_char *src , size_t len ) ;
#line 129 "src/os/unix/ngx_files.h"
ssize_t ngx_write_file(ngx_file_t *file , u_char *buf , size_t size , off_t offset ) ;
#line 351
size_t ngx_fs_bsize(u_char *name ) ;
#line 17 "src/core/ngx_parse.h"
off_t ngx_parse_offset(ngx_str_t *line ) ;
#line 16 "src/os/unix/ngx_alloc.h"
void *ngx_alloc(size_t size , ngx_log_t *log ) ;
#line 142 "src/core/ngx_file.h"
void ngx_create_hashed_filename(ngx_path_t *path , u_char *file , size_t len ) ;
#line 145
ngx_int_t ngx_add_path(ngx_conf_t *cf , ngx_path_t **slot___0 ) ;
#line 147
ngx_int_t ngx_ext_rename_file(ngx_str_t *src , ngx_str_t *to , ngx_ext_rename_file_t *ext ) ;
#line 150
ngx_int_t ngx_walk_tree(ngx_tree_ctx_t *ctx , ngx_str_t *tree ) ;
#line 24 "src/core/ngx_times.h"
void ngx_time_update(void) ;
#line 52 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_quit ;
#line 187 "src/http/ngx_http_cache.h"
ngx_int_t ngx_http_file_cache_new(ngx_http_request_t *r ) ;
#line 188
ngx_int_t ngx_http_file_cache_create(ngx_http_request_t *r ) ;
#line 189
void ngx_http_file_cache_create_key(ngx_http_request_t *r ) ;
#line 190
ngx_int_t ngx_http_file_cache_open(ngx_http_request_t *r ) ;
#line 191
ngx_int_t ngx_http_file_cache_set_header(ngx_http_request_t *r , u_char *buf ) ;
#line 192
void ngx_http_file_cache_update(ngx_http_request_t *r , ngx_temp_file_t *tf ) ;
#line 193
void ngx_http_file_cache_update_header(ngx_http_request_t *r ) ;
#line 194
ngx_int_t ngx_http_cache_send(ngx_http_request_t *r ) ;
#line 195
void ngx_http_file_cache_free(ngx_http_cache_t *c , ngx_temp_file_t *tf ) ;
#line 196
time_t ngx_http_file_cache_valid(ngx_array_t *cache_valid , ngx_uint_t status ) ;
#line 204
ngx_str_t ngx_http_cache_status[7] ;
#line 120 "src/http/ngx_http.h"
void ngx_http_run_posted_requests(ngx_connection_t *c ) ;
#line 23 "src/core/ngx_md5.h"
void ngx_md5_init(ngx_md5_t *ctx ) ;
#line 24
void ngx_md5_update(ngx_md5_t *ctx , void const   *data , size_t size ) ;
#line 25
void ngx_md5_final(u_char *result___0 , ngx_md5_t *ctx ) ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_lock(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 16
static void ngx_http_file_cache_lock_wait_handler(ngx_event_t *ev ) ;
#line 17
static void ngx_http_file_cache_lock_wait(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 19
static ngx_int_t ngx_http_file_cache_read(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 21
static ssize_t ngx_http_file_cache_aio_read(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 31
static ngx_int_t ngx_http_file_cache_exists(ngx_http_file_cache_t *cache , ngx_http_cache_t *c ) ;
#line 33
static ngx_int_t ngx_http_file_cache_name(ngx_http_request_t *r , ngx_path_t *path ) ;
#line 35
static ngx_http_file_cache_node_t *ngx_http_file_cache_lookup(ngx_http_file_cache_t *cache ,
                                                              u_char *key ) ;
#line 37
static void ngx_http_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) ;
#line 39
static void ngx_http_file_cache_vary(ngx_http_request_t *r , u_char *vary , size_t len ,
                                     u_char *hash ) ;
#line 41
static void ngx_http_file_cache_vary_header(ngx_http_request_t *r , ngx_md5_t *md5 ,
                                            ngx_str_t *name ) ;
#line 43
static ngx_int_t ngx_http_file_cache_reopen(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 45
static ngx_int_t ngx_http_file_cache_update_variant(ngx_http_request_t *r , ngx_http_cache_t *c ) ;
#line 47
static void ngx_http_file_cache_cleanup(void *data ) ;
#line 48
static time_t ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache ) ;
#line 49
static time_t ngx_http_file_cache_expire(ngx_http_file_cache_t *cache ) ;
#line 50
static void ngx_http_file_cache_delete(ngx_http_file_cache_t *cache , ngx_queue_t *q ,
                                       u_char *name ) ;
#line 52
static void ngx_http_file_cache_loader_sleep(ngx_http_file_cache_t *cache ) ;
#line 53
static ngx_int_t ngx_http_file_cache_noop(ngx_tree_ctx_t *ctx , ngx_str_t *path ) ;
#line 55
static ngx_int_t ngx_http_file_cache_manage_file(ngx_tree_ctx_t *ctx , ngx_str_t *path ) ;
#line 57
static ngx_int_t ngx_http_file_cache_manage_directory(ngx_tree_ctx_t *ctx , ngx_str_t *path ) ;
#line 59
static ngx_int_t ngx_http_file_cache_add_file(ngx_tree_ctx_t *ctx , ngx_str_t *name ) ;
#line 61
static ngx_int_t ngx_http_file_cache_add(ngx_http_file_cache_t *cache , ngx_http_cache_t *c ) ;
#line 63
static ngx_int_t ngx_http_file_cache_delete_file(ngx_tree_ctx_t *ctx , ngx_str_t *path ) ;
#line 65
static void ngx_http_file_cache_set_watermark(ngx_http_file_cache_t *cache ) ;
#line 68 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
ngx_str_t ngx_http_cache_status[7]  = {      {sizeof("MISS") - 1UL, (u_char *)"MISS"}, 
        {sizeof("BYPASS") - 1UL, (u_char *)"BYPASS"}, 
        {sizeof("EXPIRED") - 1UL, (u_char *)"EXPIRED"}, 
        {sizeof("STALE") - 1UL, (u_char *)"STALE"}, 
        {sizeof("UPDATING") - 1UL, (u_char *)"UPDATING"}, 
        {sizeof("REVALIDATED") - 1UL, (u_char *)"REVALIDATED"}, 
        {sizeof("HIT") - 1UL, (u_char *)"HIT"}};
#line 79 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static u_char ngx_http_file_cache_key[6]  = {      (u_char )'\n',      (u_char )'K',      (u_char )'E',      (u_char )'Y', 
        (u_char )':',      (u_char )' '};
#line 82 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_init(ngx_shm_zone_t *shm_zone , void *data ) 
{ 
  ngx_http_file_cache_t *ocache ;
  size_t len ;
  ngx_uint_t n ;
  ngx_http_file_cache_t *cache ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 85
  ocache = (ngx_http_file_cache_t *)data;
#line 91
  cache = (ngx_http_file_cache_t *)shm_zone->data;
#line 93
  if (ocache) {
    {
#line 94
    tmp = strcmp((char const   *)(cache->path)->name.data, (char const   *)(ocache->path)->name.data);
    }
#line 94
    if (tmp != 0) {
#line 95
      if ((shm_zone->shm.log)->log_level >= 1UL) {
        {
#line 95
        ngx_log_error_core((ngx_uint_t )1, shm_zone->shm.log, 0, "cache \"%V\" uses the \"%V\" cache path while previously it used the \"%V\" cache path",
                           & shm_zone->shm.name, & (cache->path)->name, & (ocache->path)->name);
        }
      }
#line 101
      return ((ngx_int_t )-1);
    }
#line 104
    n = (ngx_uint_t )0;
    {
#line 104
    while (1) {
      while_continue: /* CIL Label */ ;
#line 104
      if (! (n < 3UL)) {
#line 104
        goto while_break;
      }
#line 105
      if ((cache->path)->level[n] != (ocache->path)->level[n]) {
#line 106
        if ((shm_zone->shm.log)->log_level >= 1UL) {
          {
#line 106
          ngx_log_error_core((ngx_uint_t )1, shm_zone->shm.log, 0, "cache \"%V\" had previously different levels",
                             & shm_zone->shm.name);
          }
        }
#line 109
        return ((ngx_int_t )-1);
      }
#line 104
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 113
    cache->sh = ocache->sh;
#line 115
    cache->shpool = ocache->shpool;
#line 116
    cache->bsize = ocache->bsize;
#line 118
    cache->max_size = (off_t )((size_t )cache->max_size / cache->bsize);
#line 120
    if (! (cache->sh)->cold) {
#line 121
      (cache->path)->loader = (void (*)(void *data ))((void *)0);
    } else
#line 120
    if ((cache->sh)->loading) {
#line 121
      (cache->path)->loader = (void (*)(void *data ))((void *)0);
    }
#line 124
    return ((ngx_int_t )0);
  }
#line 127
  cache->shpool = (ngx_slab_pool_t *)shm_zone->shm.addr;
#line 129
  if (shm_zone->shm.exists) {
    {
#line 130
    cache->sh = (ngx_http_file_cache_sh_t *)(cache->shpool)->data;
#line 131
    cache->bsize = ngx_fs_bsize((cache->path)->name.data);
#line 132
    cache->max_size = (off_t )((size_t )cache->max_size / cache->bsize);
    }
#line 134
    return ((ngx_int_t )0);
  }
  {
#line 137
  tmp___0 = ngx_slab_alloc(cache->shpool, sizeof(ngx_http_file_cache_sh_t ));
#line 137
  cache->sh = (ngx_http_file_cache_sh_t *)tmp___0;
  }
#line 138
  if ((unsigned long )cache->sh == (unsigned long )((void *)0)) {
#line 139
    return ((ngx_int_t )-1);
  }
  {
#line 142
  (cache->shpool)->data = (void *)cache->sh;
#line 144
  (cache->sh)->sentinel.color = (u_char )0;
#line 144
  (cache->sh)->rbtree.root = & (cache->sh)->sentinel;
#line 144
  (cache->sh)->rbtree.sentinel = & (cache->sh)->sentinel;
#line 144
  (cache->sh)->rbtree.insert = & ngx_http_file_cache_rbtree_insert_value;
#line 147
  (cache->sh)->queue.prev = & (cache->sh)->queue;
#line 147
  (cache->sh)->queue.next = & (cache->sh)->queue;
#line 149
  (cache->sh)->cold = (ngx_atomic_t )1;
#line 150
  (cache->sh)->loading = (ngx_atomic_t )0;
#line 151
  (cache->sh)->size = (off_t )0;
#line 152
  (cache->sh)->count = (ngx_uint_t )0;
#line 153
  (cache->sh)->watermark = (ngx_uint_t )-1;
#line 155
  cache->bsize = ngx_fs_bsize((cache->path)->name.data);
#line 157
  cache->max_size = (off_t )((size_t )cache->max_size / cache->bsize);
#line 159
  len = sizeof(" in cache keys zone \"\"") + shm_zone->shm.name.len;
#line 161
  tmp___1 = ngx_slab_alloc(cache->shpool, len);
#line 161
  (cache->shpool)->log_ctx = (u_char *)tmp___1;
  }
#line 162
  if ((unsigned long )(cache->shpool)->log_ctx == (unsigned long )((void *)0)) {
#line 163
    return ((ngx_int_t )-1);
  }
  {
#line 166
  ngx_sprintf((cache->shpool)->log_ctx, " in cache keys zone \"%V\"%Z", & shm_zone->shm.name);
#line 169
  (cache->shpool)->log_nomem = 0U;
  }
#line 171
  return ((ngx_int_t )0);
}
}
#line 175 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_file_cache_new(ngx_http_request_t *r ) 
{ 
  ngx_http_cache_t *c ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 180
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_cache_t ));
#line 180
  c = (ngx_http_cache_t *)tmp;
  }
#line 181
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 182
    return ((ngx_int_t )-1);
  }
  {
#line 185
  tmp___0 = ngx_array_init(& c->keys, r->pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
  }
#line 185
  if (tmp___0 != 0L) {
#line 186
    return ((ngx_int_t )-1);
  }
#line 189
  r->cache = c;
#line 190
  c->file.log = (r->connection)->log;
#line 191
  c->file.fd = -1;
#line 193
  return ((ngx_int_t )0);
}
}
#line 197 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_file_cache_create(ngx_http_request_t *r ) 
{ 
  ngx_http_cache_t *c ;
  ngx_pool_cleanup_t *cln ;
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 204
  c = r->cache;
#line 205
  cache = c->file_cache;
#line 207
  cln = ngx_pool_cleanup_add(r->pool, (size_t )0);
  }
#line 208
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 209
    return ((ngx_int_t )-1);
  }
  {
#line 212
  cln->handler = & ngx_http_file_cache_cleanup;
#line 213
  cln->data = (void *)c;
#line 215
  tmp = ngx_http_file_cache_exists(cache, c);
  }
#line 215
  if (tmp == -1L) {
#line 216
    return ((ngx_int_t )-1);
  }
  {
#line 219
  tmp___0 = ngx_http_file_cache_name(r, cache->path);
  }
#line 219
  if (tmp___0 != 0L) {
#line 220
    return ((ngx_int_t )-1);
  }
#line 223
  return ((ngx_int_t )0);
}
}
#line 227 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
void ngx_http_file_cache_create_key(ngx_http_request_t *r ) 
{ 
  size_t len ;
  ngx_str_t *key ;
  ngx_uint_t i ;
  ngx_md5_t md5 ;
  ngx_http_cache_t *c ;
  void *__cil_tmp7 ;

  {
  {
#line 236
  c = r->cache;
#line 238
  len = (size_t )0;
#line 240
  c->crc32 = 4294967295U;
#line 241
  ngx_md5_init(& md5);
#line 243
  key = (ngx_str_t *)c->keys.elts;
#line 244
  i = (ngx_uint_t )0;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
#line 244
    if (! (i < c->keys.nelts)) {
#line 244
      goto while_break;
    }
    {
#line 248
    len += (key + i)->len;
#line 250
    ngx_crc32_update(& c->crc32, (key + i)->data, (key + i)->len);
#line 251
    ngx_md5_update(& md5, (void const   *)(key + i)->data, (key + i)->len);
#line 244
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 254
  c->header_start = ((sizeof(ngx_http_file_cache_header_t ) + sizeof(ngx_http_file_cache_key)) + len) + 1UL;
#line 257
  c->crc32 ^= 4294967295U;
#line 258
  ngx_md5_final((u_char *)(c->key), & md5);
#line 260
  memcpy((void */* __restrict  */)(c->main), (void const   */* __restrict  */)(c->key),
         (size_t )16);
  }
#line 261
  return;
}
}
#line 264 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_file_cache_open(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_int_t rv ;
  ngx_uint_t test ;
  ngx_http_cache_t *c ;
  ngx_pool_cleanup_t *cln ;
  ngx_open_file_info_t of ;
  ngx_http_file_cache_t *cache ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp15 ;

  {
#line 275
  c = r->cache;
#line 277
  if (c->waiting) {
#line 278
    return ((ngx_int_t )-2);
  }
#line 281
  if (c->reading) {
    {
#line 282
    tmp = ngx_http_file_cache_read(r, c);
    }
#line 282
    return (tmp);
  }
#line 285
  cache = c->file_cache;
#line 287
  if ((unsigned long )c->node == (unsigned long )((void *)0)) {
    {
#line 288
    cln = ngx_pool_cleanup_add(r->pool, (size_t )0);
    }
#line 289
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 290
      return ((ngx_int_t )-1);
    }
#line 293
    cln->handler = & ngx_http_file_cache_cleanup;
#line 294
    cln->data = (void *)c;
  }
  {
#line 297
  rc = ngx_http_file_cache_exists(cache, c);
  }
#line 302
  if (rc == -1L) {
#line 303
    return (rc);
  }
#line 306
  if (rc == -2L) {
#line 307
    return ((ngx_int_t )8);
  }
#line 310
  if (rc == 0L) {
#line 312
    if (c->error) {
#line 313
      return ((ngx_int_t )c->error);
    }
#line 316
    c->temp_file = 1U;
#line 317
    if (c->exists) {
#line 317
      test = (ngx_uint_t )1;
    } else {
#line 317
      test = (ngx_uint_t )0;
    }
#line 318
    rv = (ngx_int_t )-5;
  } else {
#line 322
    if ((cache->sh)->cold) {
#line 322
      test = (ngx_uint_t )1;
    } else {
#line 322
      test = (ngx_uint_t )0;
    }
#line 324
    if (c->min_uses > 1UL) {
#line 326
      if (! test) {
#line 327
        return ((ngx_int_t )8);
      }
#line 330
      rv = (ngx_int_t )8;
    } else {
#line 333
      c->temp_file = 1U;
#line 334
      rv = (ngx_int_t )-5;
    }
  }
  {
#line 338
  tmp___0 = ngx_http_file_cache_name(r, cache->path);
  }
#line 338
  if (tmp___0 != 0L) {
#line 339
    return ((ngx_int_t )-1);
  }
#line 342
  if (! test) {
#line 343
    goto done;
  }
  {
#line 346
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 348
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 350
  of.uniq = c->uniq;
#line 351
  of.valid = clcf->open_file_cache_valid;
#line 352
  of.min_uses = clcf->open_file_cache_min_uses;
#line 353
  of.events = (unsigned int )clcf->open_file_cache_events;
#line 354
  of.directio = (off_t )9223372036854775807LL;
#line 355
  of.read_ahead = clcf->read_ahead;
#line 357
  tmp___1 = ngx_open_cached_file(clcf->open_file_cache, & c->file.name, & of, r->pool);
  }
#line 357
  if (tmp___1 != 0L) {
    {
#line 362
    if (of.err == 0) {
#line 362
      goto case_0;
    }
#line 366
    if (of.err == 20) {
#line 366
      goto case_20;
    }
#line 366
    if (of.err == 2) {
#line 366
      goto case_20;
    }
#line 369
    goto switch_default;
    case_0: /* CIL Label */ 
#line 363
    return ((ngx_int_t )-1);
    case_20: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 367
    goto done;
    switch_default: /* CIL Label */ 
#line 370
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 370
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "open() \"%s\" failed",
                         c->file.name.data);
      }
    }
#line 372
    return ((ngx_int_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 379
  c->file.fd = of.fd;
#line 380
  c->file.log = (r->connection)->log;
#line 381
  c->uniq = of.uniq;
#line 382
  c->length = of.size;
#line 383
  c->fs_size = (off_t )((((size_t )of.fs_size + cache->bsize) - 1UL) / cache->bsize);
#line 385
  c->buf = ngx_create_temp_buf(r->pool, c->body_start);
  }
#line 386
  if ((unsigned long )c->buf == (unsigned long )((void *)0)) {
#line 387
    return ((ngx_int_t )-1);
  }
  {
#line 390
  tmp___2 = ngx_http_file_cache_read(r, c);
  }
#line 390
  return (tmp___2);
  done: 
#line 394
  if (rv == -5L) {
    {
#line 395
    tmp___3 = ngx_http_file_cache_lock(r, c);
    }
#line 395
    return (tmp___3);
  }
#line 398
  return (rv);
}
}
#line 402 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_lock(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ngx_msec_t now ;
  ngx_msec_t timer ;
  ngx_http_file_cache_t *cache ;
  ngx_msec_t tmp ;

  {
#line 408
  if (! c->lock) {
#line 409
    return ((ngx_int_t )-5);
  }
  {
#line 412
  now = (ngx_msec_t )ngx_current_msec;
#line 414
  cache = c->file_cache;
#line 416
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 418
  timer = (c->node)->lock_time - now;
  }
#line 420
  if (! (c->node)->updating) {
#line 421
    (c->node)->updating = 1U;
#line 422
    (c->node)->lock_time = now + c->lock_age;
#line 423
    c->updating = 1U;
#line 424
    c->lock_time = (c->node)->lock_time;
  } else
#line 420
  if ((ngx_msec_int_t )timer <= 0L) {
#line 421
    (c->node)->updating = 1U;
#line 422
    (c->node)->lock_time = now + c->lock_age;
#line 423
    c->updating = 1U;
#line 424
    c->lock_time = (c->node)->lock_time;
  }
  {
#line 427
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 433
  if (c->updating) {
#line 434
    return ((ngx_int_t )-5);
  }
#line 437
  if (c->lock_timeout == 0UL) {
#line 438
    return ((ngx_int_t )8);
  }
#line 441
  c->waiting = 1U;
#line 443
  if (c->wait_time == 0UL) {
#line 444
    c->wait_time = now + c->lock_timeout;
#line 446
    c->wait_event.handler = & ngx_http_file_cache_lock_wait_handler;
#line 447
    c->wait_event.data = (void *)r;
#line 448
    c->wait_event.log = (r->connection)->log;
  }
#line 451
  timer = c->wait_time - now;
#line 453
  if (timer > 500UL) {
#line 453
    tmp = (ngx_msec_t )500;
  } else {
#line 453
    tmp = timer;
  }
  {
#line 453
  ngx_event_add_timer(& c->wait_event, tmp);
#line 455
  ((r->main)->blocked) ++;
  }
#line 457
  return ((ngx_int_t )-2);
}
}
#line 461 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_lock_wait_handler(ngx_event_t *ev ) 
{ 
  ngx_connection_t *c ;
  ngx_http_request_t *r ;

  {
  {
#line 467
  r = (ngx_http_request_t *)ev->data;
#line 468
  c = r->connection;
#line 470
  ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 475
  ngx_http_file_cache_lock_wait(r, r->cache);
#line 477
  ngx_http_run_posted_requests(c);
  }
#line 478
  return;
}
}
#line 481 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_lock_wait(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ngx_uint_t wait___0 ;
  ngx_msec_t now ;
  ngx_msec_t timer ;
  ngx_http_file_cache_t *cache ;
  ngx_msec_t tmp ;
  char *__cil_tmp8 ;

  {
#line 488
  now = (ngx_msec_t )ngx_current_msec;
#line 490
  timer = c->wait_time - now;
#line 492
  if ((ngx_msec_int_t )timer <= 0L) {
#line 493
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 493
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "cache lock timeout");
      }
    }
#line 495
    c->lock_timeout = (ngx_msec_t )0;
#line 496
    goto wakeup;
  }
  {
#line 499
  cache = c->file_cache;
#line 500
  wait___0 = (ngx_uint_t )0;
#line 502
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 504
  timer = (c->node)->lock_time - now;
  }
#line 506
  if ((c->node)->updating) {
#line 506
    if ((ngx_msec_int_t )timer > 0L) {
#line 507
      wait___0 = (ngx_uint_t )1;
    }
  }
  {
#line 510
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 512
  if (wait___0) {
#line 513
    if (timer > 500UL) {
#line 513
      tmp = (ngx_msec_t )500;
    } else {
#line 513
      tmp = timer;
    }
    {
#line 513
    ngx_event_add_timer(& c->wait_event, tmp);
    }
#line 514
    return;
  }
  wakeup: 
  {
#line 519
  c->waiting = 0U;
#line 520
  ((r->main)->blocked) --;
#line 521
  (*(r->write_event_handler))(r);
  }
#line 522
  return;
}
}
#line 525 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_read(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  u_char *p ;
  time_t now ;
  ssize_t n ;
  ngx_str_t *key ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_http_file_cache_t *cache ;
  ngx_http_file_cache_header_t *h ;
  int tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 537
  n = ngx_http_file_cache_aio_read(r, c);
  }
#line 539
  if (n < 0L) {
#line 540
    return (n);
  }
#line 543
  if ((size_t )n < c->header_start) {
#line 544
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 544
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" is too small",
                         c->file.name.data);
      }
    }
#line 546
    return ((ngx_int_t )-5);
  }
#line 549
  h = (ngx_http_file_cache_header_t *)(c->buf)->pos;
#line 551
  if (h->version != 5UL) {
#line 552
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 552
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "cache file \"%s\" version mismatch",
                         c->file.name.data);
      }
    }
#line 554
    return ((ngx_int_t )-5);
  }
#line 557
  if (h->crc32 != c->crc32) {
#line 557
    goto _L;
  } else
#line 557
  if ((size_t )h->header_start != c->header_start) {
    _L: /* CIL Label */ 
#line 558
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 558
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has md5 collision",
                         c->file.name.data);
      }
    }
#line 560
    return ((ngx_int_t )-5);
  }
#line 563
  p = ((c->buf)->pos + sizeof(ngx_http_file_cache_header_t )) + sizeof(ngx_http_file_cache_key);
#line 566
  key = (ngx_str_t *)c->keys.elts;
#line 567
  i = (ngx_uint_t )0;
  {
#line 567
  while (1) {
    while_continue: /* CIL Label */ ;
#line 567
    if (! (i < c->keys.nelts)) {
#line 567
      goto while_break;
    }
    {
#line 568
    tmp = memcmp((void const   *)((char const   *)p), (void const   *)((char const   *)(key + i)->data),
                 (key + i)->len);
    }
#line 568
    if (tmp != 0) {
#line 569
      if (((r->connection)->log)->log_level >= 3UL) {
        {
#line 569
        ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has md5 collision",
                           c->file.name.data);
        }
      }
#line 572
      return ((ngx_int_t )-5);
    }
#line 575
    p += (key + i)->len;
#line 567
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 578
  if ((size_t )h->body_start > c->body_start) {
#line 579
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 579
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has too long header",
                         c->file.name.data);
      }
    }
#line 582
    return ((ngx_int_t )-5);
  }
#line 585
  if ((int )h->vary_len > 128) {
#line 586
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 586
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has incorrect vary length",
                         c->file.name.data);
      }
    }
#line 589
    return ((ngx_int_t )-5);
  }
#line 592
  if (h->vary_len) {
    {
#line 593
    ngx_http_file_cache_vary(r, h->vary, (size_t )h->vary_len, c->variant);
#line 595
    tmp___1 = memcmp((void const   *)((char const   *)(c->variant)), (void const   *)((char const   *)(h->variant)),
                     (size_t )16);
    }
#line 595
    if (tmp___1 != 0) {
      {
#line 598
      tmp___0 = ngx_http_file_cache_reopen(r, c);
      }
#line 598
      return (tmp___0);
    }
  }
#line 602
  (c->buf)->last += n;
#line 604
  c->valid_sec = h->valid_sec;
#line 605
  c->updating_sec = h->updating_sec;
#line 606
  c->error_sec = h->error_sec;
#line 607
  c->last_modified = h->last_modified;
#line 608
  c->date = h->date;
#line 609
  c->valid_msec = (ngx_uint_t )h->valid_msec;
#line 610
  c->body_start = (size_t )h->body_start;
#line 611
  c->etag.len = (size_t )h->etag_len;
#line 612
  c->etag.data = h->etag;
#line 614
  r->cached = 1U;
#line 616
  cache = c->file_cache;
#line 618
  if ((cache->sh)->cold) {
    {
#line 620
    ngx_shmtx_lock(& (cache->shpool)->mutex);
    }
#line 622
    if (! (c->node)->exists) {
#line 623
      (c->node)->uses = 1U;
#line 624
      (c->node)->body_start = c->body_start;
#line 625
      (c->node)->exists = 1U;
#line 626
      (c->node)->uniq = c->uniq;
#line 627
      (c->node)->fs_size = c->fs_size;
#line 629
      (cache->sh)->size += c->fs_size;
    }
    {
#line 632
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
    }
  }
#line 635
  now = (time_t )ngx_cached_time->sec;
#line 637
  if (c->valid_sec < now) {
    {
#line 638
    c->stale_updating = (unsigned int )(c->valid_sec + c->updating_sec >= now);
#line 639
    c->stale_error = (unsigned int )(c->valid_sec + c->error_sec >= now);
#line 641
    ngx_shmtx_lock(& (cache->shpool)->mutex);
    }
#line 643
    if ((c->node)->updating) {
#line 644
      rc = (ngx_int_t )5;
    } else {
#line 647
      (c->node)->updating = 1U;
#line 648
      c->updating = 1U;
#line 649
      c->lock_time = (c->node)->lock_time;
#line 650
      rc = (ngx_int_t )4;
    }
    {
#line 653
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
    }
#line 659
    return (rc);
  }
#line 662
  return ((ngx_int_t )0);
}
}
#line 666 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ssize_t ngx_http_file_cache_aio_read(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ssize_t tmp ;

  {
  {
#line 716
  tmp = ngx_read_file(& c->file, (c->buf)->pos, c->body_start, (off_t )0);
  }
#line 716
  return (tmp);
}
}
#line 819 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_exists(ngx_http_file_cache_t *cache , ngx_http_cache_t *c ) 
{ 
  ngx_int_t rc ;
  ngx_http_file_cache_node_t *fcn ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp7 ;

  {
  {
#line 825
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 827
  fcn = c->node;
  }
#line 829
  if ((unsigned long )fcn == (unsigned long )((void *)0)) {
    {
#line 830
    fcn = ngx_http_file_cache_lookup(cache, c->key);
    }
  }
#line 833
  if (fcn) {
#line 834
    (fcn->queue.next)->prev = fcn->queue.prev;
#line 834
    (fcn->queue.prev)->next = fcn->queue.next;
#line 836
    if ((unsigned long )c->node == (unsigned long )((void *)0)) {
#line 837
      (fcn->uses) ++;
#line 838
      (fcn->count) ++;
    }
#line 841
    if (fcn->error) {
#line 843
      if (fcn->valid_sec < (time_t )ngx_cached_time->sec) {
#line 844
        goto renew;
      }
#line 847
      rc = (ngx_int_t )0;
#line 849
      goto done;
    }
#line 852
    if (fcn->exists) {
#line 852
      goto _L;
    } else
#line 852
    if ((ngx_uint_t )fcn->uses >= c->min_uses) {
      _L: /* CIL Label */ 
#line 854
      c->exists = fcn->exists;
#line 855
      if (fcn->body_start) {
#line 856
        c->body_start = fcn->body_start;
      }
#line 859
      rc = (ngx_int_t )0;
#line 861
      goto done;
    }
#line 864
    rc = (ngx_int_t )-2;
#line 866
    goto done;
  }
  {
#line 869
  tmp = ngx_slab_calloc_locked(cache->shpool, sizeof(ngx_http_file_cache_node_t ));
#line 869
  fcn = (ngx_http_file_cache_node_t *)tmp;
  }
#line 871
  if ((unsigned long )fcn == (unsigned long )((void *)0)) {
    {
#line 872
    ngx_http_file_cache_set_watermark(cache);
#line 874
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 876
    ngx_http_file_cache_forced_expire(cache);
#line 878
    ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 880
    tmp___0 = ngx_slab_calloc_locked(cache->shpool, sizeof(ngx_http_file_cache_node_t ));
#line 880
    fcn = (ngx_http_file_cache_node_t *)tmp___0;
    }
#line 882
    if ((unsigned long )fcn == (unsigned long )((void *)0)) {
#line 883
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 883
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "could not allocate node%s",
                           (cache->shpool)->log_ctx);
        }
      }
#line 885
      rc = (ngx_int_t )-1;
#line 886
      goto failed;
    }
  }
  {
#line 890
  ((cache->sh)->count) ++;
#line 892
  memcpy((void */* __restrict  */)((u_char *)(& fcn->node.key)), (void const   */* __restrict  */)(c->key),
         sizeof(ngx_rbtree_key_t ));
#line 894
  memcpy((void */* __restrict  */)(fcn->key), (void const   */* __restrict  */)(& c->key[sizeof(ngx_rbtree_key_t )]),
         16UL - sizeof(ngx_rbtree_key_t ));
#line 897
  ngx_rbtree_insert(& (cache->sh)->rbtree, & fcn->node);
#line 899
  fcn->uses = 1U;
#line 900
  fcn->count = 1U;
  }
  renew: 
#line 904
  rc = (ngx_int_t )-5;
#line 906
  fcn->valid_msec = 0U;
#line 907
  fcn->error = 0U;
#line 908
  fcn->exists = 0U;
#line 909
  fcn->valid_sec = (time_t )0;
#line 910
  fcn->uniq = (ngx_file_uniq_t )0;
#line 911
  fcn->body_start = (size_t )0;
#line 912
  fcn->fs_size = (off_t )0;
  done: 
#line 916
  fcn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )cache->inactive);
#line 918
  fcn->queue.next = (cache->sh)->queue.next;
#line 918
  (fcn->queue.next)->prev = & fcn->queue;
#line 918
  fcn->queue.prev = & (cache->sh)->queue;
#line 918
  (cache->sh)->queue.next = & fcn->queue;
#line 920
  c->uniq = fcn->uniq;
#line 921
  c->error = (ngx_uint_t )fcn->error;
#line 922
  c->node = fcn;
  failed: 
  {
#line 926
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 928
  return (rc);
}
}
#line 932 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_name(ngx_http_request_t *r , ngx_path_t *path ) 
{ 
  u_char *p ;
  ngx_http_cache_t *c ;
  void *tmp ;

  {
#line 938
  c = r->cache;
#line 940
  if (c->file.name.len) {
#line 941
    return ((ngx_int_t )0);
  }
  {
#line 944
  c->file.name.len = ((path->name.len + 1UL) + path->len) + 32UL;
#line 947
  tmp = ngx_pnalloc(r->pool, c->file.name.len + 1UL);
#line 947
  c->file.name.data = (u_char *)tmp;
  }
#line 948
  if ((unsigned long )c->file.name.data == (unsigned long )((void *)0)) {
#line 949
    return ((ngx_int_t )-1);
  }
  {
#line 952
  memcpy((void */* __restrict  */)c->file.name.data, (void const   */* __restrict  */)path->name.data,
         path->name.len);
#line 954
  p = ((c->file.name.data + path->name.len) + 1) + path->len;
#line 955
  p = ngx_hex_dump(p, c->key, (size_t )16);
#line 956
  *p = (u_char )'\000';
#line 958
  ngx_create_hashed_filename(path, c->file.name.data, c->file.name.len);
  }
#line 963
  return ((ngx_int_t )0);
}
}
#line 967 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_http_file_cache_node_t *ngx_http_file_cache_lookup(ngx_http_file_cache_t *cache ,
                                                              u_char *key ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_key_t node_key ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_http_file_cache_node_t *fcn ;
  int tmp ;

  {
  {
#line 975
  memcpy((void */* __restrict  */)((u_char *)(& node_key)), (void const   */* __restrict  */)key,
         sizeof(ngx_rbtree_key_t ));
#line 977
  node = (cache->sh)->rbtree.root;
#line 978
  sentinel = (cache->sh)->rbtree.sentinel;
  }
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 980
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 980
      goto while_break;
    }
#line 982
    if (node_key < node->key) {
#line 983
      node = node->left;
#line 984
      goto while_continue;
    }
#line 987
    if (node_key > node->key) {
#line 988
      node = node->right;
#line 989
      goto while_continue;
    }
    {
#line 994
    fcn = (ngx_http_file_cache_node_t *)node;
#line 996
    tmp = memcmp((void const   *)((char const   *)(key + sizeof(ngx_rbtree_key_t ))),
                 (void const   *)((char const   *)(fcn->key)), 16UL - sizeof(ngx_rbtree_key_t ));
#line 996
    rc = (ngx_int_t )tmp;
    }
#line 999
    if (rc == 0L) {
#line 1000
      return (fcn);
    }
#line 1003
    if (rc < 0L) {
#line 1003
      node = node->left;
    } else {
#line 1003
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1008
  return ((ngx_http_file_cache_node_t *)((void *)0));
}
}
#line 1012 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_http_file_cache_node_t *cn ;
  ngx_http_file_cache_node_t *cnt ;
  int tmp___0 ;

  {
  {
#line 1019
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1021
    if (node->key < temp->key) {
#line 1023
      p = & temp->left;
    } else
#line 1025
    if (node->key > temp->key) {
#line 1027
      p = & temp->right;
    } else {
      {
#line 1031
      cn = (ngx_http_file_cache_node_t *)node;
#line 1032
      cnt = (ngx_http_file_cache_node_t *)temp;
#line 1034
      tmp___0 = memcmp((void const   *)((char const   *)(cn->key)), (void const   *)((char const   *)(cnt->key)),
                       16UL - sizeof(ngx_rbtree_key_t ));
      }
#line 1034
      if (tmp___0 < 0) {
#line 1034
        p = & temp->left;
      } else {
#line 1034
        p = & temp->right;
      }
    }
#line 1040
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 1041
      goto while_break;
    }
#line 1044
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 1047
  *p = node;
#line 1048
  node->parent = temp;
#line 1049
  node->left = sentinel;
#line 1050
  node->right = sentinel;
#line 1051
  node->color = (u_char )1;
#line 1052
  return;
}
}
#line 1055 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_vary(ngx_http_request_t *r , u_char *vary , size_t len ,
                                     u_char *hash ) 
{ 
  u_char *p ;
  u_char *last ;
  ngx_str_t name ;
  ngx_md5_t md5 ;
  u_char buf[128] ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
  {
#line 1067
  ngx_md5_init(& md5);
#line 1068
  ngx_md5_update(& md5, (void const   *)((r->cache)->main), (size_t )16);
#line 1070
  ngx_strlow(buf, vary, len);
#line 1072
  p = buf;
#line 1073
  last = buf + len;
  }
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 1075
      goto while_break;
    }
    {
#line 1077
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1077
      if ((unsigned long )p < (unsigned long )last) {
#line 1077
        if (! ((int )*p == 32)) {
#line 1077
          if (! ((int )*p == 44)) {
#line 1077
            goto while_break___0;
          }
        }
      } else {
#line 1077
        goto while_break___0;
      }
#line 1077
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1079
    name.data = p;
    {
#line 1081
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1081
      if ((unsigned long )p < (unsigned long )last) {
#line 1081
        if ((int )*p != 44) {
#line 1081
          if (! ((int )*p != 32)) {
#line 1081
            goto while_break___1;
          }
        } else {
#line 1081
          goto while_break___1;
        }
      } else {
#line 1081
        goto while_break___1;
      }
#line 1081
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1083
    name.len = (size_t )(p - name.data);
#line 1085
    if (name.len == 0UL) {
#line 1086
      goto while_break;
    }
    {
#line 1092
    ngx_md5_update(& md5, (void const   *)name.data, name.len);
#line 1093
    ngx_md5_update(& md5, (void const   *)((u_char *)":"), sizeof(":") - 1UL);
#line 1095
    ngx_http_file_cache_vary_header(r, & md5, & name);
#line 1097
    ngx_md5_update(& md5, (void const   *)((u_char *)"\r\n"), sizeof("\r\n") - 1UL);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1100
  ngx_md5_final((u_char *)hash, & md5);
  }
#line 1101
  return;
}
}
#line 1104 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_vary_header(ngx_http_request_t *r , ngx_md5_t *md5 ,
                                            ngx_str_t *name ) 
{ 
  size_t len ;
  u_char *p ;
  u_char *start ;
  u_char *last ;
  ngx_uint_t i ;
  ngx_uint_t multiple ;
  ngx_uint_t normalize ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *header___0 ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;

  {
#line 1114
  multiple = (ngx_uint_t )0;
#line 1115
  normalize = (ngx_uint_t )0;
#line 1117
  if (name->len == sizeof("Accept-Charset") - 1UL) {
    {
#line 1117
    tmp___1 = ngx_strncasecmp(name->data, (u_char *)"Accept-Charset", sizeof("Accept-Charset") - 1UL);
    }
#line 1117
    if (tmp___1 == 0L) {
#line 1121
      normalize = (ngx_uint_t )1;
    } else {
#line 1117
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1123
  if (name->len == sizeof("Accept-Encoding") - 1UL) {
    {
#line 1123
    tmp___0 = ngx_strncasecmp(name->data, (u_char *)"Accept-Encoding", sizeof("Accept-Encoding") - 1UL);
    }
#line 1123
    if (tmp___0 == 0L) {
#line 1127
      normalize = (ngx_uint_t )1;
    } else {
#line 1123
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1129
  if (name->len == sizeof("Accept-Language") - 1UL) {
    {
#line 1129
    tmp = ngx_strncasecmp(name->data, (u_char *)"Accept-Language", sizeof("Accept-Language") - 1UL);
    }
#line 1129
    if (tmp == 0L) {
#line 1133
      normalize = (ngx_uint_t )1;
    }
  }
#line 1136
  part = & r->headers_in.headers.part;
#line 1137
  header___0 = (ngx_table_elt_t *)part->elts;
#line 1139
  i = (ngx_uint_t )0;
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1141
    if (i >= part->nelts) {
#line 1142
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1143
        goto while_break;
      }
#line 1146
      part = part->next;
#line 1147
      header___0 = (ngx_table_elt_t *)part->elts;
#line 1148
      i = (ngx_uint_t )0;
    }
#line 1151
    if ((header___0 + i)->hash == 0UL) {
#line 1152
      goto __Cont;
    }
#line 1155
    if ((header___0 + i)->key.len != name->len) {
#line 1156
      goto __Cont;
    }
    {
#line 1159
    tmp___2 = ngx_strncasecmp((header___0 + i)->key.data, name->data, name->len);
    }
#line 1159
    if (tmp___2 != 0L) {
#line 1160
      goto __Cont;
    }
#line 1163
    if (! normalize) {
#line 1165
      if (multiple) {
        {
#line 1166
        ngx_md5_update(md5, (void const   *)((u_char *)","), sizeof(",") - 1UL);
        }
      }
      {
#line 1169
      ngx_md5_update(md5, (void const   *)(header___0 + i)->value.data, (header___0 + i)->value.len);
#line 1171
      multiple = (ngx_uint_t )1;
      }
#line 1173
      goto __Cont;
    }
#line 1178
    p = (header___0 + i)->value.data;
#line 1179
    last = p + (header___0 + i)->value.len;
    {
#line 1181
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1181
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 1181
        goto while_break___0;
      }
      {
#line 1183
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1183
        if ((unsigned long )p < (unsigned long )last) {
#line 1183
          if (! ((int )*p == 32)) {
#line 1183
            if (! ((int )*p == 44)) {
#line 1183
              goto while_break___1;
            }
          }
        } else {
#line 1183
          goto while_break___1;
        }
#line 1183
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1185
      start = p;
      {
#line 1187
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1187
        if ((unsigned long )p < (unsigned long )last) {
#line 1187
          if ((int )*p != 44) {
#line 1187
            if (! ((int )*p != 32)) {
#line 1187
              goto while_break___2;
            }
          } else {
#line 1187
            goto while_break___2;
          }
        } else {
#line 1187
          goto while_break___2;
        }
#line 1187
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1189
      len = (size_t )(p - start);
#line 1191
      if (len == 0UL) {
#line 1192
        goto while_break___0;
      }
#line 1195
      if (multiple) {
        {
#line 1196
        ngx_md5_update(md5, (void const   *)((u_char *)","), sizeof(",") - 1UL);
        }
      }
      {
#line 1199
      ngx_md5_update(md5, (void const   *)start, len);
#line 1201
      multiple = (ngx_uint_t )1;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1204
  return;
}
}
#line 1207 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_reopen(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;
  char *__cil_tmp5 ;

  {
#line 1215
  if (c->secondary) {
#line 1216
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1216
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" has incorrect vary hash",
                         c->file.name.data);
      }
    }
#line 1219
    return ((ngx_int_t )-5);
  }
  {
#line 1222
  cache = c->file_cache;
#line 1224
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1226
  ((c->node)->count) --;
#line 1227
  c->node = (ngx_http_file_cache_node_t *)((void *)0);
#line 1229
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1231
  c->secondary = 1U;
#line 1232
  c->file.name.len = (size_t )0;
#line 1233
  c->body_start = (size_t )((c->buf)->end - (c->buf)->start);
#line 1235
  memcpy((void */* __restrict  */)(c->key), (void const   */* __restrict  */)(c->variant),
         (size_t )16);
#line 1237
  tmp = ngx_http_file_cache_open(r);
  }
#line 1237
  return (tmp);
}
}
#line 1241 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_file_cache_set_header(ngx_http_request_t *r , u_char *buf ) 
{ 
  ngx_http_file_cache_header_t *h ;
  u_char *p ;
  ngx_str_t *key ;
  ngx_uint_t i ;
  ngx_http_cache_t *c ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1244
  h = (ngx_http_file_cache_header_t *)buf;
#line 1254
  c = r->cache;
#line 1256
  memset((void *)h, 0, sizeof(ngx_http_file_cache_header_t ));
#line 1258
  h->version = (ngx_uint_t )5;
#line 1259
  h->valid_sec = c->valid_sec;
#line 1260
  h->updating_sec = c->updating_sec;
#line 1261
  h->error_sec = c->error_sec;
#line 1262
  h->last_modified = c->last_modified;
#line 1263
  h->date = c->date;
#line 1264
  h->crc32 = c->crc32;
#line 1265
  h->valid_msec = (u_short )c->valid_msec;
#line 1266
  h->header_start = (u_short )c->header_start;
#line 1267
  h->body_start = (u_short )c->body_start;
  }
#line 1269
  if (c->etag.len <= 128UL) {
    {
#line 1270
    h->etag_len = (u_char )c->etag.len;
#line 1271
    memcpy((void */* __restrict  */)(h->etag), (void const   */* __restrict  */)c->etag.data,
           c->etag.len);
    }
  }
#line 1274
  if (c->vary.len) {
#line 1275
    if (c->vary.len > 128UL) {
#line 1277
      c->vary.len = (size_t )128;
    }
    {
#line 1280
    h->vary_len = (u_char )c->vary.len;
#line 1281
    memcpy((void */* __restrict  */)(h->vary), (void const   */* __restrict  */)c->vary.data,
           c->vary.len);
#line 1283
    ngx_http_file_cache_vary(r, c->vary.data, c->vary.len, c->variant);
#line 1284
    memcpy((void */* __restrict  */)(h->variant), (void const   */* __restrict  */)(c->variant),
           (size_t )16);
    }
  }
  {
#line 1287
  tmp = ngx_http_file_cache_update_variant(r, c);
  }
#line 1287
  if (tmp != 0L) {
#line 1288
    return ((ngx_int_t )-1);
  }
  {
#line 1291
  p = buf + sizeof(ngx_http_file_cache_header_t );
#line 1293
  tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ngx_http_file_cache_key),
                   sizeof(ngx_http_file_cache_key));
#line 1293
  p = (u_char *)tmp___0 + sizeof(ngx_http_file_cache_key);
#line 1295
  key = (ngx_str_t *)c->keys.elts;
#line 1296
  i = (ngx_uint_t )0;
  }
  {
#line 1296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1296
    if (! (i < c->keys.nelts)) {
#line 1296
      goto while_break;
    }
    {
#line 1297
    tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(key + i)->data,
                     (key + i)->len);
#line 1297
    p = (u_char *)tmp___1 + (key + i)->len;
#line 1296
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1300
  *p = (u_char )'\n';
#line 1302
  return ((ngx_int_t )0);
}
}
#line 1306 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_update_variant(ngx_http_request_t *r , ngx_http_cache_t *c ) 
{ 
  ngx_http_file_cache_t *cache ;
  int tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1311
  if (! c->secondary) {
#line 1312
    return ((ngx_int_t )0);
  }
#line 1315
  if (c->vary.len) {
    {
#line 1315
    tmp = memcmp((void const   *)((char const   *)(c->variant)), (void const   *)((char const   *)(c->key)),
                 (size_t )16);
    }
#line 1315
    if (tmp == 0) {
#line 1318
      return ((ngx_int_t )0);
    }
  }
  {
#line 1326
  cache = c->file_cache;
#line 1331
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1333
  ((c->node)->count) --;
#line 1334
  (c->node)->updating = 0U;
#line 1335
  c->node = (ngx_http_file_cache_node_t *)((void *)0);
#line 1337
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1339
  c->file.name.len = (size_t )0;
#line 1341
  memcpy((void */* __restrict  */)(c->key), (void const   */* __restrict  */)(c->main),
         (size_t )16);
#line 1343
  tmp___0 = ngx_http_file_cache_exists(cache, c);
  }
#line 1343
  if (tmp___0 == -1L) {
#line 1344
    return ((ngx_int_t )-1);
  }
  {
#line 1347
  tmp___1 = ngx_http_file_cache_name(r, cache->path);
  }
#line 1347
  if (tmp___1 != 0L) {
#line 1348
    return ((ngx_int_t )-1);
  }
#line 1351
  return ((ngx_int_t )0);
}
}
#line 1355 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
void ngx_http_file_cache_update(ngx_http_request_t *r , ngx_temp_file_t *tf ) 
{ 
  off_t fs_size ;
  ngx_int_t rc ;
  ngx_file_uniq_t uniq ;
  ngx_file_info_t fi ;
  ngx_http_cache_t *c ;
  ngx_ext_rename_file_t ext ;
  ngx_http_file_cache_t *cache ;
  int *tmp ;
  __blkcnt_t tmp___0 ;
  int tmp___1 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1366
  c = r->cache;
#line 1368
  if (c->updated) {
#line 1369
    return;
  }
  {
#line 1375
  cache = c->file_cache;
#line 1377
  c->updated = 1U;
#line 1378
  c->updating = 0U;
#line 1380
  uniq = (ngx_file_uniq_t )0;
#line 1381
  fs_size = (off_t )0;
#line 1387
  ext.access = (ngx_uint_t )384;
#line 1388
  ext.path_access = (ngx_uint_t )384;
#line 1389
  ext.time = (time_t )-1;
#line 1390
  ext.create_path = 1U;
#line 1391
  ext.delete_file = 1U;
#line 1392
  ext.log = (r->connection)->log;
#line 1394
  rc = ngx_ext_rename_file(& tf->file.name, & c->file.name, & ext);
  }
#line 1396
  if (rc == 0L) {
    {
#line 1398
    tmp___1 = fstat(tf->file.fd, & fi);
    }
#line 1398
    if (tmp___1 == -1) {
#line 1399
      if (((r->connection)->log)->log_level >= 3UL) {
        {
#line 1399
        tmp = __errno_location();
#line 1399
        ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp, "fstat() \"%s\" failed",
                           tf->file.name.data);
        }
      }
#line 1402
      rc = (ngx_int_t )-1;
    } else {
#line 1405
      uniq = fi.st_ino;
#line 1406
      if (fi.st_size < fi.st_blocks * 512L) {
#line 1406
        tmp___0 = fi.st_blocks * 512L;
      } else {
#line 1406
        tmp___0 = fi.st_size;
      }
#line 1406
      fs_size = (off_t )((((size_t )tmp___0 + cache->bsize) - 1UL) / cache->bsize);
    }
  }
  {
#line 1410
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1412
  ((c->node)->count) --;
#line 1413
  (c->node)->error = 0U;
#line 1414
  (c->node)->uniq = uniq;
#line 1415
  (c->node)->body_start = c->body_start;
#line 1417
  (cache->sh)->size += fs_size - (c->node)->fs_size;
#line 1418
  (c->node)->fs_size = fs_size;
  }
#line 1420
  if (rc == 0L) {
#line 1421
    (c->node)->exists = 1U;
  }
  {
#line 1424
  (c->node)->updating = 0U;
#line 1426
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 1427
  return;
}
}
#line 1430 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
void ngx_http_file_cache_update_header(ngx_http_request_t *r ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_file_t file ;
  ngx_file_info_t fi ;
  ngx_http_cache_t *c ;
  ngx_http_file_cache_header_t h ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 1443
  c = r->cache;
#line 1445
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 1447
  file.name = c->file.name;
#line 1448
  file.log = (r->connection)->log;
#line 1449
  file.fd = open((char const   *)file.name.data, 2, 0);
  }
#line 1451
  if (file.fd == -1) {
    {
#line 1452
    tmp = __errno_location();
#line 1452
    err = *tmp;
    }
#line 1456
    if (err == 2) {
#line 1460
      return;
    }
#line 1463
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1463
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, err, "open() \"%s\" failed",
                         file.name.data);
      }
    }
#line 1465
    return;
  }
  {
#line 1473
  tmp___1 = fstat(file.fd, & fi);
  }
#line 1473
  if (tmp___1 == -1) {
#line 1474
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1474
      tmp___0 = __errno_location();
#line 1474
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___0, "fstat() \"%s\" failed",
                         file.name.data);
      }
    }
#line 1476
    goto done;
  }
#line 1479
  if (c->uniq != fi.st_ino) {
#line 1485
    goto done;
  } else
#line 1479
  if (c->length != fi.st_size) {
#line 1485
    goto done;
  }
  {
#line 1488
  n = ngx_read_file(& file, (u_char *)(& h), sizeof(ngx_http_file_cache_header_t ),
                    (off_t )0);
  }
#line 1491
  if (n == -1L) {
#line 1492
    goto done;
  }
#line 1495
  if ((size_t )n != sizeof(ngx_http_file_cache_header_t )) {
#line 1496
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1496
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "pread() read only %z of %z from \"%s\"",
                         n, sizeof(ngx_http_file_cache_header_t ), file.name.data);
      }
    }
#line 1499
    goto done;
  }
#line 1502
  if (h.version != 5UL) {
#line 1511
    goto done;
  } else
#line 1502
  if (h.last_modified != c->last_modified) {
#line 1511
    goto done;
  } else
#line 1502
  if (h.crc32 != c->crc32) {
#line 1511
    goto done;
  } else
#line 1502
  if ((size_t )h.header_start != c->header_start) {
#line 1511
    goto done;
  } else
#line 1502
  if ((size_t )h.body_start != c->body_start) {
#line 1511
    goto done;
  }
  {
#line 1519
  memset((void *)(& h), 0, sizeof(ngx_http_file_cache_header_t ));
#line 1521
  h.version = (ngx_uint_t )5;
#line 1522
  h.valid_sec = c->valid_sec;
#line 1523
  h.updating_sec = c->updating_sec;
#line 1524
  h.error_sec = c->error_sec;
#line 1525
  h.last_modified = c->last_modified;
#line 1526
  h.date = c->date;
#line 1527
  h.crc32 = c->crc32;
#line 1528
  h.valid_msec = (u_short )c->valid_msec;
#line 1529
  h.header_start = (u_short )c->header_start;
#line 1530
  h.body_start = (u_short )c->body_start;
  }
#line 1532
  if (c->etag.len <= 128UL) {
    {
#line 1533
    h.etag_len = (u_char )c->etag.len;
#line 1534
    memcpy((void */* __restrict  */)(h.etag), (void const   */* __restrict  */)c->etag.data,
           c->etag.len);
    }
  }
#line 1537
  if (c->vary.len) {
#line 1538
    if (c->vary.len > 128UL) {
#line 1540
      c->vary.len = (size_t )128;
    }
    {
#line 1543
    h.vary_len = (u_char )c->vary.len;
#line 1544
    memcpy((void */* __restrict  */)(h.vary), (void const   */* __restrict  */)c->vary.data,
           c->vary.len);
#line 1546
    ngx_http_file_cache_vary(r, c->vary.data, c->vary.len, c->variant);
#line 1547
    memcpy((void */* __restrict  */)(h.variant), (void const   */* __restrict  */)(c->variant),
           (size_t )16);
    }
  }
  {
#line 1550
  ngx_write_file(& file, (u_char *)(& h), sizeof(ngx_http_file_cache_header_t ), (off_t )0);
  }
  done: 
  {
#line 1555
  tmp___3 = close(file.fd);
  }
#line 1555
  if (tmp___3 == -1) {
#line 1556
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 1556
      tmp___2 = __errno_location();
#line 1556
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, *tmp___2, "close() \"%s\" failed",
                         file.name.data);
      }
    }
  }
#line 1559
  return;
}
}
#line 1562 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
ngx_int_t ngx_http_cache_send(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  ngx_http_cache_t *c ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1570
  c = r->cache;
#line 1575
  if ((unsigned long )r != (unsigned long )r->main) {
#line 1575
    if ((size_t )c->length - c->body_start == 0UL) {
      {
#line 1576
      tmp = ngx_http_send_header(r);
      }
#line 1576
      return (tmp);
    }
  }
  {
#line 1581
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 1581
  b = (ngx_buf_t *)tmp___0;
  }
#line 1582
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1583
    return ((ngx_int_t )500);
  }
  {
#line 1586
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_file_t ));
#line 1586
  b->file = (ngx_file_t *)tmp___1;
  }
#line 1587
  if ((unsigned long )b->file == (unsigned long )((void *)0)) {
#line 1588
    return ((ngx_int_t )500);
  }
  {
#line 1591
  rc = ngx_http_send_header(r);
  }
#line 1593
  if (rc == -1L) {
#line 1594
    return (rc);
  } else
#line 1593
  if (rc > 0L) {
#line 1594
    return (rc);
  } else
#line 1593
  if (r->header_only) {
#line 1594
    return (rc);
  }
#line 1597
  b->file_pos = (off_t )c->body_start;
#line 1598
  b->file_last = c->length;
#line 1600
  if ((size_t )c->length - c->body_start) {
#line 1600
    b->in_file = 1U;
  } else {
#line 1600
    b->in_file = 0U;
  }
#line 1601
  if ((unsigned long )r == (unsigned long )r->main) {
#line 1601
    b->last_buf = 1U;
  } else {
#line 1601
    b->last_buf = 0U;
  }
  {
#line 1602
  b->last_in_chain = 1U;
#line 1604
  (b->file)->fd = c->file.fd;
#line 1605
  (b->file)->name = c->file.name;
#line 1606
  (b->file)->log = (r->connection)->log;
#line 1608
  out.buf = b;
#line 1609
  out.next = (ngx_chain_t *)((void *)0);
#line 1611
  tmp___2 = ngx_http_output_filter(r, & out);
  }
#line 1611
  return (tmp___2);
}
}
#line 1615 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
void ngx_http_file_cache_free(ngx_http_cache_t *c , ngx_temp_file_t *tf ) 
{ 
  ngx_http_file_cache_t *cache ;
  ngx_http_file_cache_node_t *fcn ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 1621
  if (c->updated) {
#line 1622
    return;
  } else
#line 1621
  if ((unsigned long )c->node == (unsigned long )((void *)0)) {
#line 1622
    return;
  }
  {
#line 1625
  cache = c->file_cache;
#line 1630
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1632
  fcn = c->node;
#line 1633
  (fcn->count) --;
  }
#line 1635
  if (c->updating) {
#line 1635
    if (fcn->lock_time == c->lock_time) {
#line 1636
      fcn->updating = 0U;
    }
  }
#line 1639
  if (c->error) {
#line 1640
    fcn->error = (unsigned int )c->error;
#line 1642
    if (c->valid_sec) {
#line 1643
      fcn->valid_sec = c->valid_sec;
#line 1644
      fcn->valid_msec = (unsigned int )c->valid_msec;
    }
  } else
#line 1647
  if (! fcn->exists) {
#line 1647
    if (fcn->count == 0U) {
#line 1647
      if (c->min_uses == 1UL) {
        {
#line 1648
        (fcn->queue.next)->prev = fcn->queue.prev;
#line 1648
        (fcn->queue.prev)->next = fcn->queue.next;
#line 1649
        ngx_rbtree_delete(& (cache->sh)->rbtree, & fcn->node);
#line 1650
        ngx_slab_free_locked(cache->shpool, (void *)fcn);
#line 1651
        ((cache->sh)->count) --;
#line 1652
        c->node = (ngx_http_file_cache_node_t *)((void *)0);
        }
      }
    }
  }
  {
#line 1655
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1657
  c->updated = 1U;
#line 1658
  c->updating = 0U;
  }
#line 1660
  if (c->temp_file) {
#line 1661
    if (tf) {
#line 1661
      if (tf->file.fd != -1) {
        {
#line 1666
        tmp___0 = unlink((char const   *)tf->file.name.data);
        }
#line 1666
        if (tmp___0 == -1) {
#line 1667
          if ((c->file.log)->log_level >= 3UL) {
            {
#line 1667
            tmp = __errno_location();
#line 1667
            ngx_log_error_core((ngx_uint_t )3, c->file.log, *tmp, "unlink() \"%s\" failed",
                               tf->file.name.data);
            }
          }
        }
      }
    }
  }
#line 1674
  if (c->wait_event.timer_set) {
    {
#line 1675
    ngx_event_del_timer(& c->wait_event);
    }
  }
#line 1677
  return;
}
}
#line 1680 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_cleanup(void *data ) 
{ 
  ngx_http_cache_t *c ;
  char *__cil_tmp3 ;

  {
#line 1683
  c = (ngx_http_cache_t *)data;
#line 1685
  if (c->updated) {
#line 1686
    return;
  }
#line 1692
  if (c->updating) {
#line 1692
    if (! c->background) {
#line 1693
      if ((c->file.log)->log_level >= 2UL) {
        {
#line 1693
        ngx_log_error_core((ngx_uint_t )2, c->file.log, 0, "stalled cache updating, error:%ui",
                           c->error);
        }
      }
    }
  }
  {
#line 1697
  ngx_http_file_cache_free(c, (ngx_temp_file_t *)((void *)0));
  }
#line 1698
  return;
}
}
#line 1701 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static time_t ngx_http_file_cache_forced_expire(ngx_http_file_cache_t *cache ) 
{ 
  u_char *name ;
  u_char *p ;
  size_t len ;
  time_t wait___0 ;
  ngx_uint_t tries ;
  ngx_path_t *path ;
  ngx_queue_t *q ;
  ngx_queue_t *sentinel ;
  ngx_http_file_cache_node_t *fcn ;
  u_char key[32] ;
  void *tmp ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1716
  path = cache->path;
#line 1717
  len = ((path->name.len + 1UL) + path->len) + 32UL;
#line 1719
  tmp = ngx_alloc(len + 1UL, (ngx_log_t *)ngx_cycle->log);
#line 1719
  name = (u_char *)tmp;
  }
#line 1720
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1721
    return ((time_t )10);
  }
  {
#line 1724
  memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)path->name.data,
         path->name.len);
#line 1726
  wait___0 = (time_t )10;
#line 1727
  tries = (ngx_uint_t )20;
#line 1728
  sentinel = (ngx_queue_t *)((void *)0);
#line 1730
  ngx_shmtx_lock(& (cache->shpool)->mutex);
  }
  {
#line 1732
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1733
    if ((unsigned long )(& (cache->sh)->queue) == (unsigned long )(cache->sh)->queue.prev) {
#line 1734
      goto while_break;
    }
#line 1737
    q = (cache->sh)->queue.prev;
#line 1739
    if ((unsigned long )q == (unsigned long )sentinel) {
#line 1740
      goto while_break;
    }
#line 1743
    fcn = (ngx_http_file_cache_node_t *)((u_char *)q - (unsigned long )(& ((ngx_http_file_cache_node_t *)0)->queue));
#line 1750
    if (fcn->count == 0U) {
      {
#line 1751
      ngx_http_file_cache_delete(cache, q, name);
#line 1752
      wait___0 = (time_t )0;
      }
#line 1753
      goto while_break;
    }
    {
#line 1756
    p = ngx_hex_dump(key, (u_char *)(& fcn->node.key), sizeof(ngx_rbtree_key_t ));
#line 1758
    len = 16UL - sizeof(ngx_rbtree_key_t );
#line 1759
    ngx_hex_dump(p, fcn->key, len);
#line 1767
    (q->next)->prev = q->prev;
#line 1767
    (q->prev)->next = q->next;
#line 1768
    fcn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )cache->inactive);
#line 1769
    fcn->queue.next = (cache->sh)->queue.next;
#line 1769
    (fcn->queue.next)->prev = & fcn->queue;
#line 1769
    fcn->queue.prev = & (cache->sh)->queue;
#line 1769
    (cache->sh)->queue.next = & fcn->queue;
    }
#line 1771
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 1771
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "ignore long locked inactive cache entry %*s, count:%d",
                         32UL, key, fcn->count);
      }
    }
#line 1775
    if ((unsigned long )sentinel == (unsigned long )((void *)0)) {
#line 1776
      sentinel = q;
    }
#line 1779
    tries --;
#line 1779
    if (tries) {
#line 1780
      goto __Cont;
    }
#line 1783
    wait___0 = (time_t )1;
#line 1784
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1787
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1789
  free((void *)name);
  }
#line 1791
  return (wait___0);
}
}
#line 1795 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static time_t ngx_http_file_cache_expire(ngx_http_file_cache_t *cache ) 
{ 
  u_char *name ;
  u_char *p ;
  size_t len ;
  time_t now ;
  time_t wait___0 ;
  ngx_path_t *path ;
  ngx_msec_t elapsed ;
  ngx_queue_t *q ;
  ngx_http_file_cache_node_t *fcn ;
  u_char key[32] ;
  void *tmp ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 1810
  path = cache->path;
#line 1811
  len = ((path->name.len + 1UL) + path->len) + 32UL;
#line 1813
  tmp = ngx_alloc(len + 1UL, (ngx_log_t *)ngx_cycle->log);
#line 1813
  name = (u_char *)tmp;
  }
#line 1814
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 1815
    return ((time_t )10);
  }
  {
#line 1818
  memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)path->name.data,
         path->name.len);
#line 1820
  now = (time_t )ngx_cached_time->sec;
#line 1822
  ngx_shmtx_lock(& (cache->shpool)->mutex);
  }
  {
#line 1824
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1826
    if (ngx_quit) {
#line 1827
      wait___0 = (time_t )1;
#line 1828
      goto while_break;
    } else
#line 1826
    if (ngx_terminate) {
#line 1827
      wait___0 = (time_t )1;
#line 1828
      goto while_break;
    }
#line 1831
    if ((unsigned long )(& (cache->sh)->queue) == (unsigned long )(cache->sh)->queue.prev) {
#line 1832
      wait___0 = (time_t )10;
#line 1833
      goto while_break;
    }
#line 1836
    q = (cache->sh)->queue.prev;
#line 1838
    fcn = (ngx_http_file_cache_node_t *)((u_char *)q - (unsigned long )(& ((ngx_http_file_cache_node_t *)0)->queue));
#line 1840
    wait___0 = fcn->expire - now;
#line 1842
    if (wait___0 > 0L) {
#line 1843
      if (wait___0 > 10L) {
#line 1843
        wait___0 = (time_t )10;
      } else {
#line 1843
        wait___0 = wait___0;
      }
#line 1844
      goto while_break;
    }
#line 1852
    if (fcn->count == 0U) {
      {
#line 1853
      ngx_http_file_cache_delete(cache, q, name);
      }
#line 1854
      goto next;
    }
#line 1857
    if (fcn->deleting) {
#line 1858
      wait___0 = (time_t )1;
#line 1859
      goto while_break;
    }
    {
#line 1862
    p = ngx_hex_dump(key, (u_char *)(& fcn->node.key), sizeof(ngx_rbtree_key_t ));
#line 1864
    len = 16UL - sizeof(ngx_rbtree_key_t );
#line 1865
    ngx_hex_dump(p, fcn->key, len);
#line 1873
    (q->next)->prev = q->prev;
#line 1873
    (q->prev)->next = q->next;
#line 1874
    fcn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )cache->inactive);
#line 1875
    fcn->queue.next = (cache->sh)->queue.next;
#line 1875
    (fcn->queue.next)->prev = & fcn->queue;
#line 1875
    fcn->queue.prev = & (cache->sh)->queue;
#line 1875
    (cache->sh)->queue.next = & fcn->queue;
    }
#line 1877
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 1877
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "ignore long locked inactive cache entry %*s, count:%d",
                         32UL, key, fcn->count);
      }
    }
    next: 
#line 1883
    (cache->files) ++;
#line 1883
    if (cache->files >= cache->manager_files) {
#line 1884
      wait___0 = (time_t )0;
#line 1885
      goto while_break;
    }
    {
#line 1888
    ngx_time_update();
    }
#line 1890
    if ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last) >= 0L) {
#line 1890
      elapsed = (ngx_msec_t )((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last));
    } else {
#line 1890
      elapsed = (ngx_msec_t )(- ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last)));
    }
#line 1892
    if (elapsed >= cache->manager_threshold) {
#line 1893
      wait___0 = (time_t )0;
#line 1894
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1898
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1900
  free((void *)name);
  }
#line 1902
  return (wait___0);
}
}
#line 1906 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_delete(ngx_http_file_cache_t *cache , ngx_queue_t *q ,
                                       u_char *name ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_path_t *path ;
  ngx_http_file_cache_node_t *fcn ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;

  {
#line 1915
  fcn = (ngx_http_file_cache_node_t *)((u_char *)q - (unsigned long )(& ((ngx_http_file_cache_node_t *)0)->queue));
#line 1917
  if (fcn->exists) {
    {
#line 1918
    (cache->sh)->size -= fcn->fs_size;
#line 1920
    path = cache->path;
#line 1921
    p = ((name + path->name.len) + 1) + path->len;
#line 1922
    p = ngx_hex_dump(p, (u_char *)(& fcn->node.key), sizeof(ngx_rbtree_key_t ));
#line 1924
    len = 16UL - sizeof(ngx_rbtree_key_t );
#line 1925
    p = ngx_hex_dump(p, fcn->key, len);
#line 1926
    *p = (u_char )'\000';
#line 1928
    (fcn->count) ++;
#line 1929
    fcn->deleting = 1U;
#line 1930
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
#line 1932
    len = ((path->name.len + 1UL) + path->len) + 32UL;
#line 1933
    ngx_create_hashed_filename(path, name, len);
#line 1938
    tmp___0 = unlink((char const   *)name);
    }
#line 1938
    if (tmp___0 == -1) {
#line 1939
      if ((ngx_cycle->log)->log_level >= 3UL) {
        {
#line 1939
        tmp = __errno_location();
#line 1939
        ngx_log_error_core((ngx_uint_t )3, (ngx_log_t *)ngx_cycle->log, *tmp, "unlink() \"%s\" failed",
                           name);
        }
      }
    }
    {
#line 1943
    ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1944
    (fcn->count) --;
#line 1945
    fcn->deleting = 0U;
    }
  }
#line 1948
  if (fcn->count == 0U) {
    {
#line 1949
    (q->next)->prev = q->prev;
#line 1949
    (q->prev)->next = q->next;
#line 1950
    ngx_rbtree_delete(& (cache->sh)->rbtree, & fcn->node);
#line 1951
    ngx_slab_free_locked(cache->shpool, (void *)fcn);
#line 1952
    ((cache->sh)->count) --;
    }
  }
#line 1954
  return;
}
}
#line 1957 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_msec_t ngx_http_file_cache_manager(void *data ) 
{ 
  ngx_http_file_cache_t *cache ;
  off_t size ;
  time_t wait___0 ;
  ngx_msec_t elapsed ;
  ngx_msec_t next ;
  ngx_uint_t count ;
  ngx_uint_t watermark ;
  time_t tmp ;

  {
  {
#line 1960
  cache = (ngx_http_file_cache_t *)data;
#line 1967
  cache->last = (ngx_msec_t )ngx_current_msec;
#line 1968
  cache->files = (ngx_uint_t )0;
#line 1970
  tmp = ngx_http_file_cache_expire(cache);
#line 1970
  next = (ngx_msec_t )tmp * 1000UL;
  }
#line 1972
  if (next == 0UL) {
#line 1973
    next = cache->manager_sleep;
#line 1974
    goto done;
  }
  {
#line 1977
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1978
    ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 1980
    size = (cache->sh)->size;
#line 1981
    count = (cache->sh)->count;
#line 1982
    watermark = (cache->sh)->watermark;
#line 1984
    ngx_shmtx_unlock(& (cache->shpool)->mutex);
    }
#line 1990
    if (size < cache->max_size) {
#line 1990
      if (count < watermark) {
#line 1991
        goto while_break;
      }
    }
    {
#line 1994
    wait___0 = ngx_http_file_cache_forced_expire(cache);
    }
#line 1996
    if (wait___0 > 0L) {
#line 1997
      next = (ngx_msec_t )wait___0 * 1000UL;
#line 1998
      goto while_break;
    }
#line 2001
    if (ngx_quit) {
#line 2002
      goto while_break;
    } else
#line 2001
    if (ngx_terminate) {
#line 2002
      goto while_break;
    }
#line 2005
    (cache->files) ++;
#line 2005
    if (cache->files >= cache->manager_files) {
#line 2006
      next = cache->manager_sleep;
#line 2007
      goto while_break;
    }
    {
#line 2010
    ngx_time_update();
    }
#line 2012
    if ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last) >= 0L) {
#line 2012
      elapsed = (ngx_msec_t )((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last));
    } else {
#line 2012
      elapsed = (ngx_msec_t )(- ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last)));
    }
#line 2014
    if (elapsed >= cache->manager_threshold) {
#line 2015
      next = cache->manager_sleep;
#line 2016
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 2022
  if ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last) >= 0L) {
#line 2022
    elapsed = (ngx_msec_t )((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last));
  } else {
#line 2022
    elapsed = (ngx_msec_t )(- ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last)));
  }
#line 2028
  return (next);
}
}
#line 2032 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_loader(void *data ) 
{ 
  ngx_http_file_cache_t *cache ;
  ngx_tree_ctx_t tree ;
  _Bool tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 2035
  cache = (ngx_http_file_cache_t *)data;
#line 2039
  if (! (cache->sh)->cold) {
#line 2040
    return;
  } else
#line 2039
  if ((cache->sh)->loading) {
#line 2040
    return;
  }
  {
#line 2043
  tmp = __sync_bool_compare_and_swap(& (cache->sh)->loading, 0, ngx_pid);
  }
#line 2043
  if (! tmp) {
#line 2044
    return;
  }
  {
#line 2050
  tree.init_handler = (ngx_int_t (*)(void *ctx , void *prev ))((void *)0);
#line 2051
  tree.file_handler = & ngx_http_file_cache_manage_file;
#line 2052
  tree.pre_tree_handler = & ngx_http_file_cache_manage_directory;
#line 2053
  tree.post_tree_handler = & ngx_http_file_cache_noop;
#line 2054
  tree.spec_handler = & ngx_http_file_cache_delete_file;
#line 2055
  tree.data = (void *)cache;
#line 2056
  tree.alloc = (size_t )0;
#line 2057
  tree.log = (ngx_log_t *)ngx_cycle->log;
#line 2059
  cache->last = (ngx_msec_t )ngx_current_msec;
#line 2060
  cache->files = (ngx_uint_t )0;
#line 2062
  tmp___0 = ngx_walk_tree(& tree, & (cache->path)->name);
  }
#line 2062
  if (tmp___0 == -6L) {
#line 2063
    (cache->sh)->loading = (ngx_atomic_t )0;
#line 2064
    return;
  }
#line 2067
  (cache->sh)->cold = (ngx_atomic_t )0;
#line 2068
  (cache->sh)->loading = (ngx_atomic_t )0;
#line 2070
  if ((ngx_cycle->log)->log_level >= 6UL) {
    {
#line 2070
    ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "http file cache: %V %.3fM, bsize: %uz",
                       & (cache->path)->name, ((double )(cache->sh)->size * (double )cache->bsize) / (double )1048576,
                       cache->bsize);
    }
  }
#line 2075
  return;
}
}
#line 2078 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_noop(ngx_tree_ctx_t *ctx , ngx_str_t *path ) 
{ 


  {
#line 2081
  return ((ngx_int_t )0);
}
}
#line 2085 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_manage_file(ngx_tree_ctx_t *ctx , ngx_str_t *path ) 
{ 
  ngx_msec_t elapsed ;
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;
  int tmp___0 ;

  {
  {
#line 2091
  cache = (ngx_http_file_cache_t *)ctx->data;
#line 2093
  tmp = ngx_http_file_cache_add_file(ctx, path);
  }
#line 2093
  if (tmp != 0L) {
    {
#line 2094
    ngx_http_file_cache_delete_file(ctx, path);
    }
  }
#line 2097
  (cache->files) ++;
#line 2097
  if (cache->files >= cache->loader_files) {
    {
#line 2098
    ngx_http_file_cache_loader_sleep(cache);
    }
  } else {
    {
#line 2101
    ngx_time_update();
    }
#line 2103
    if ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last) >= 0L) {
#line 2103
      elapsed = (ngx_msec_t )((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last));
    } else {
#line 2103
      elapsed = (ngx_msec_t )(- ((ngx_msec_int_t )(ngx_current_msec - (ngx_msec_t volatile   )cache->last)));
    }
#line 2108
    if (elapsed >= cache->loader_threshold) {
      {
#line 2109
      ngx_http_file_cache_loader_sleep(cache);
      }
    }
  }
#line 2113
  if (ngx_quit) {
#line 2113
    tmp___0 = -6;
  } else
#line 2113
  if (ngx_terminate) {
#line 2113
    tmp___0 = -6;
  } else {
#line 2113
    tmp___0 = 0;
  }
#line 2113
  return ((ngx_int_t )tmp___0);
}
}
#line 2117 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_manage_directory(ngx_tree_ctx_t *ctx , ngx_str_t *path ) 
{ 
  int tmp ;

  {
#line 2120
  if (path->len >= 5UL) {
    {
#line 2120
    tmp = strncmp(((char const   *)path->data + path->len) - 5, "/temp", (size_t )5);
    }
#line 2120
    if (tmp == 0) {
#line 2123
      return ((ngx_int_t )-5);
    }
  }
#line 2126
  return ((ngx_int_t )0);
}
}
#line 2130 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_loader_sleep(ngx_http_file_cache_t *cache ) 
{ 


  {
  {
#line 2133
  usleep((__useconds_t )(cache->loader_sleep * 1000UL));
#line 2135
  ngx_time_update();
#line 2137
  cache->last = (ngx_msec_t )ngx_current_msec;
#line 2138
  cache->files = (ngx_uint_t )0;
  }
#line 2139
  return;
}
}
#line 2142 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_add_file(ngx_tree_ctx_t *ctx , ngx_str_t *name ) 
{ 
  u_char *p ;
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_http_cache_t c ;
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 2151
  if (name->len < 32UL) {
#line 2152
    return ((ngx_int_t )-1);
  }
#line 2160
  if (name->len >= 43UL) {
#line 2160
    if ((int )*(name->data + ((name->len - 10UL) - 1UL)) == 46) {
#line 2163
      return ((ngx_int_t )0);
    }
  }
#line 2166
  if (ctx->size < (off_t )sizeof(ngx_http_file_cache_header_t )) {
#line 2167
    if ((ctx->log)->log_level >= 3UL) {
      {
#line 2167
      ngx_log_error_core((ngx_uint_t )3, ctx->log, 0, "cache file \"%s\" is too small",
                         name->data);
      }
    }
#line 2169
    return ((ngx_int_t )-1);
  }
  {
#line 2172
  memset((void *)(& c), 0, sizeof(ngx_http_cache_t ));
#line 2173
  cache = (ngx_http_file_cache_t *)ctx->data;
#line 2175
  c.length = ctx->size;
#line 2176
  c.fs_size = (off_t )((((size_t )ctx->fs_size + cache->bsize) - 1UL) / cache->bsize);
#line 2178
  p = name->data + (name->len - 32UL);
#line 2180
  i = (ngx_uint_t )0;
  }
  {
#line 2180
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2180
    if (! (i < 16UL)) {
#line 2180
      goto while_break;
    }
    {
#line 2181
    n = ngx_hextoi(p, (size_t )2);
    }
#line 2183
    if (n == -1L) {
#line 2184
      return ((ngx_int_t )-1);
    }
#line 2187
    p += 2;
#line 2189
    c.key[i] = (u_char )n;
#line 2180
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2192
  tmp = ngx_http_file_cache_add(cache, & c);
  }
#line 2192
  return (tmp);
}
}
#line 2196 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_add(ngx_http_file_cache_t *cache , ngx_http_cache_t *c ) 
{ 
  ngx_http_file_cache_node_t *fcn ;
  void *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 2201
  ngx_shmtx_lock(& (cache->shpool)->mutex);
#line 2203
  fcn = ngx_http_file_cache_lookup(cache, c->key);
  }
#line 2205
  if ((unsigned long )fcn == (unsigned long )((void *)0)) {
    {
#line 2207
    tmp = ngx_slab_calloc_locked(cache->shpool, sizeof(ngx_http_file_cache_node_t ));
#line 2207
    fcn = (ngx_http_file_cache_node_t *)tmp;
    }
#line 2209
    if ((unsigned long )fcn == (unsigned long )((void *)0)) {
      {
#line 2210
      ngx_http_file_cache_set_watermark(cache);
      }
#line 2212
      if (cache->fail_time != (time_t )ngx_cached_time->sec) {
#line 2213
        cache->fail_time = (time_t )ngx_cached_time->sec;
#line 2214
        if ((ngx_cycle->log)->log_level >= 2UL) {
          {
#line 2214
          ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "could not allocate node%s",
                             (cache->shpool)->log_ctx);
          }
        }
      }
      {
#line 2218
      ngx_shmtx_unlock(& (cache->shpool)->mutex);
      }
#line 2219
      return ((ngx_int_t )-1);
    }
    {
#line 2222
    ((cache->sh)->count) ++;
#line 2224
    memcpy((void */* __restrict  */)((u_char *)(& fcn->node.key)), (void const   */* __restrict  */)(c->key),
           sizeof(ngx_rbtree_key_t ));
#line 2226
    memcpy((void */* __restrict  */)(fcn->key), (void const   */* __restrict  */)(& c->key[sizeof(ngx_rbtree_key_t )]),
           16UL - sizeof(ngx_rbtree_key_t ));
#line 2229
    ngx_rbtree_insert(& (cache->sh)->rbtree, & fcn->node);
#line 2231
    fcn->uses = 1U;
#line 2232
    fcn->exists = 1U;
#line 2233
    fcn->fs_size = c->fs_size;
#line 2235
    (cache->sh)->size += c->fs_size;
    }
  } else {
#line 2238
    (fcn->queue.next)->prev = fcn->queue.prev;
#line 2238
    (fcn->queue.prev)->next = fcn->queue.next;
  }
  {
#line 2241
  fcn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )cache->inactive);
#line 2243
  fcn->queue.next = (cache->sh)->queue.next;
#line 2243
  (fcn->queue.next)->prev = & fcn->queue;
#line 2243
  fcn->queue.prev = & (cache->sh)->queue;
#line 2243
  (cache->sh)->queue.next = & fcn->queue;
#line 2245
  ngx_shmtx_unlock(& (cache->shpool)->mutex);
  }
#line 2247
  return ((ngx_int_t )0);
}
}
#line 2251 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_int_t ngx_http_file_cache_delete_file(ngx_tree_ctx_t *ctx , ngx_str_t *path ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 2257
  tmp___0 = unlink((char const   *)path->data);
  }
#line 2257
  if (tmp___0 == -1) {
#line 2258
    if ((ctx->log)->log_level >= 3UL) {
      {
#line 2258
      tmp = __errno_location();
#line 2258
      ngx_log_error_core((ngx_uint_t )3, ctx->log, *tmp, "unlink() \"%s\" failed",
                         path->data);
      }
    }
  }
#line 2262
  return ((ngx_int_t )0);
}
}
#line 2266 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static void ngx_http_file_cache_set_watermark(ngx_http_file_cache_t *cache ) 
{ 


  {
#line 2269
  (cache->sh)->watermark = (cache->sh)->count - (cache->sh)->count / 8UL;
#line 2273
  return;
}
}
#line 2276 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
time_t ngx_http_file_cache_valid(ngx_array_t *cache_valid , ngx_uint_t status ) 
{ 
  ngx_uint_t i ;
  ngx_http_cache_valid_t *valid ;

  {
#line 2282
  if ((unsigned long )cache_valid == (unsigned long )((void *)0)) {
#line 2283
    return ((time_t )0);
  }
#line 2286
  valid = (ngx_http_cache_valid_t *)cache_valid->elts;
#line 2287
  i = (ngx_uint_t )0;
  {
#line 2287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2287
    if (! (i < cache_valid->nelts)) {
#line 2287
      goto while_break;
    }
#line 2289
    if ((valid + i)->status == 0UL) {
#line 2290
      return ((valid + i)->valid);
    }
#line 2293
    if ((valid + i)->status == status) {
#line 2294
      return ((valid + i)->valid);
    }
#line 2287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2298
  return ((time_t )0);
}
}
#line 2302 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
char *ngx_http_file_cache_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *confp ;
  off_t max_size ;
  u_char *last ;
  u_char *p ;
  time_t inactive ;
  ssize_t size ;
  ngx_str_t s ;
  ngx_str_t name ;
  ngx_str_t *value ;
  ngx_int_t loader_files ;
  ngx_int_t manager_files ;
  ngx_msec_t loader_sleep ;
  ngx_msec_t manager_sleep ;
  ngx_msec_t loader_threshold ;
  ngx_msec_t manager_threshold ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t use_temp_path ;
  ngx_array_t *caches ;
  ngx_http_file_cache_t *cache ;
  ngx_http_file_cache_t **ce ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  ngx_int_t tmp___13 ;
  int tmp___14 ;
  ngx_int_t tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  ngx_int_t tmp___18 ;
  int tmp___19 ;
  ngx_int_t tmp___20 ;
  int tmp___21 ;
  ngx_int_t tmp___22 ;
  void *tmp___23 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;

  {
  {
#line 2305
  confp = (char *)conf;
#line 2319
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_file_cache_t ));
#line 2319
  cache = (ngx_http_file_cache_t *)tmp;
  }
#line 2320
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 2321
    return ((char *)((void *)-1));
  }
  {
#line 2324
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_path_t ));
#line 2324
  cache->path = (ngx_path_t *)tmp___0;
  }
#line 2325
  if ((unsigned long )cache->path == (unsigned long )((void *)0)) {
#line 2326
    return ((char *)((void *)-1));
  }
#line 2329
  use_temp_path = (ngx_uint_t )1;
#line 2331
  inactive = (time_t )600;
#line 2333
  loader_files = (ngx_int_t )100;
#line 2334
  loader_sleep = (ngx_msec_t )50;
#line 2335
  loader_threshold = (ngx_msec_t )200;
#line 2337
  manager_files = (ngx_int_t )100;
#line 2338
  manager_sleep = (ngx_msec_t )50;
#line 2339
  manager_threshold = (ngx_msec_t )200;
#line 2341
  name.len = (size_t )0;
#line 2342
  size = (ssize_t )0;
#line 2343
  max_size = (off_t )9223372036854775807LL;
#line 2345
  value = (ngx_str_t *)(cf->args)->elts;
#line 2347
  (cache->path)->name = *(value + 1);
#line 2349
  if ((int )*((cache->path)->name.data + ((cache->path)->name.len - 1UL)) == 47) {
#line 2350
    ((cache->path)->name.len) --;
  }
  {
#line 2353
  tmp___1 = ngx_conf_full_name(cf->cycle, & (cache->path)->name, (ngx_uint_t )0);
  }
#line 2353
  if (tmp___1 != 0L) {
#line 2354
    return ((char *)((void *)-1));
  }
#line 2357
  i = (ngx_uint_t )2;
  {
#line 2357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2357
    if (! (i < (cf->args)->nelts)) {
#line 2357
      goto while_break;
    }
    {
#line 2359
    tmp___4 = strncmp((char const   *)(value + i)->data, "levels=", (size_t )7);
    }
#line 2359
    if (tmp___4 == 0) {
#line 2361
      p = (value + i)->data + 7;
#line 2362
      last = (value + i)->data + (value + i)->len;
#line 2364
      n = (ngx_uint_t )0;
      {
#line 2364
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 2364
        if (n < 3UL) {
#line 2364
          if (! ((unsigned long )p < (unsigned long )last)) {
#line 2364
            goto while_break___0;
          }
        } else {
#line 2364
          goto while_break___0;
        }
#line 2366
        if ((int )*p > 48) {
#line 2366
          if ((int )*p < 51) {
#line 2368
            tmp___2 = p;
#line 2368
            p ++;
#line 2368
            (cache->path)->level[n] = (size_t )((int )*tmp___2 - 48);
#line 2369
            (cache->path)->len += (cache->path)->level[n] + 1UL;
#line 2371
            if ((unsigned long )p == (unsigned long )last) {
#line 2372
              goto while_break___0;
            }
#line 2375
            tmp___3 = p;
#line 2375
            p ++;
#line 2375
            if ((int )*tmp___3 == 58) {
#line 2375
              if (n < 2UL) {
#line 2375
                if ((unsigned long )p < (unsigned long )last) {
#line 2376
                  goto __Cont;
                }
              }
            }
#line 2379
            goto invalid_levels;
          }
        }
#line 2382
        goto invalid_levels;
        __Cont: /* CIL Label */ 
#line 2364
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2385
      if ((cache->path)->len < 13UL) {
#line 2386
        goto __Cont___0;
      }
      invalid_levels: 
      {
#line 2391
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid \"levels\" \"%V\"", value + i);
      }
#line 2393
      return ((char *)((void *)-1));
    }
    {
#line 2396
    tmp___7 = strncmp((char const   *)(value + i)->data, "use_temp_path=", (size_t )14);
    }
#line 2396
    if (tmp___7 == 0) {
      {
#line 2398
      tmp___6 = strcmp((char const   *)((value + i)->data + 14), "on");
      }
#line 2398
      if (tmp___6 == 0) {
#line 2399
        use_temp_path = (ngx_uint_t )1;
      } else {
        {
#line 2401
        tmp___5 = strcmp((char const   *)((value + i)->data + 14), "off");
        }
#line 2401
        if (tmp___5 == 0) {
#line 2402
          use_temp_path = (ngx_uint_t )0;
        } else {
          {
#line 2405
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid use_temp_path value \"%V\", it must be \"on\" or \"off\"",
                             value + i);
          }
#line 2409
          return ((char *)((void *)-1));
        }
      }
#line 2412
      goto __Cont___0;
    }
    {
#line 2415
    tmp___9 = strncmp((char const   *)(value + i)->data, "keys_zone=", (size_t )10);
    }
#line 2415
    if (tmp___9 == 0) {
      {
#line 2417
      name.data = (value + i)->data + 10;
#line 2419
      tmp___8 = strchr((char const   *)name.data, ':');
#line 2419
      p = (u_char *)tmp___8;
      }
#line 2421
      if (p) {
        {
#line 2422
        name.len = (size_t )(p - name.data);
#line 2424
        p ++;
#line 2426
        s.len = (size_t )(((value + i)->data + (value + i)->len) - p);
#line 2427
        s.data = p;
#line 2429
        size = ngx_parse_size(& s);
        }
#line 2430
        if (size > 8191L) {
#line 2431
          goto __Cont___0;
        }
      }
      {
#line 2435
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid keys zone size \"%V\"", value + i);
      }
#line 2437
      return ((char *)((void *)-1));
    }
    {
#line 2440
    tmp___10 = strncmp((char const   *)(value + i)->data, "inactive=", (size_t )9);
    }
#line 2440
    if (tmp___10 == 0) {
      {
#line 2442
      s.len = (value + i)->len - 9UL;
#line 2443
      s.data = (value + i)->data + 9;
#line 2445
      inactive = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 2446
      if (inactive == -1L) {
        {
#line 2447
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid inactive value \"%V\"",
                           value + i);
        }
#line 2449
        return ((char *)((void *)-1));
      }
#line 2452
      goto __Cont___0;
    }
    {
#line 2455
    tmp___11 = strncmp((char const   *)(value + i)->data, "max_size=", (size_t )9);
    }
#line 2455
    if (tmp___11 == 0) {
      {
#line 2457
      s.len = (value + i)->len - 9UL;
#line 2458
      s.data = (value + i)->data + 9;
#line 2460
      max_size = ngx_parse_offset(& s);
      }
#line 2461
      if (max_size < 0L) {
        {
#line 2462
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid max_size value \"%V\"",
                           value + i);
        }
#line 2464
        return ((char *)((void *)-1));
      }
#line 2467
      goto __Cont___0;
    }
    {
#line 2470
    tmp___12 = strncmp((char const   *)(value + i)->data, "loader_files=", (size_t )13);
    }
#line 2470
    if (tmp___12 == 0) {
      {
#line 2472
      loader_files = ngx_atoi((value + i)->data + 13, (value + i)->len - 13UL);
      }
#line 2473
      if (loader_files == -1L) {
        {
#line 2474
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid loader_files value \"%V\"",
                           value + i);
        }
#line 2476
        return ((char *)((void *)-1));
      }
#line 2479
      goto __Cont___0;
    }
    {
#line 2482
    tmp___14 = strncmp((char const   *)(value + i)->data, "loader_sleep=", (size_t )13);
    }
#line 2482
    if (tmp___14 == 0) {
      {
#line 2484
      s.len = (value + i)->len - 13UL;
#line 2485
      s.data = (value + i)->data + 13;
#line 2487
      tmp___13 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 2487
      loader_sleep = (ngx_msec_t )tmp___13;
      }
#line 2488
      if (loader_sleep == 0xffffffffffffffffUL) {
        {
#line 2489
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid loader_sleep value \"%V\"",
                           value + i);
        }
#line 2491
        return ((char *)((void *)-1));
      }
#line 2494
      goto __Cont___0;
    }
    {
#line 2497
    tmp___16 = strncmp((char const   *)(value + i)->data, "loader_threshold=", (size_t )17);
    }
#line 2497
    if (tmp___16 == 0) {
      {
#line 2499
      s.len = (value + i)->len - 17UL;
#line 2500
      s.data = (value + i)->data + 17;
#line 2502
      tmp___15 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 2502
      loader_threshold = (ngx_msec_t )tmp___15;
      }
#line 2503
      if (loader_threshold == 0xffffffffffffffffUL) {
        {
#line 2504
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid loader_threshold value \"%V\"",
                           value + i);
        }
#line 2506
        return ((char *)((void *)-1));
      }
#line 2509
      goto __Cont___0;
    }
    {
#line 2512
    tmp___17 = strncmp((char const   *)(value + i)->data, "manager_files=", (size_t )14);
    }
#line 2512
    if (tmp___17 == 0) {
      {
#line 2514
      manager_files = ngx_atoi((value + i)->data + 14, (value + i)->len - 14UL);
      }
#line 2515
      if (manager_files == -1L) {
        {
#line 2516
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid manager_files value \"%V\"",
                           value + i);
        }
#line 2518
        return ((char *)((void *)-1));
      }
#line 2521
      goto __Cont___0;
    }
    {
#line 2524
    tmp___19 = strncmp((char const   *)(value + i)->data, "manager_sleep=", (size_t )14);
    }
#line 2524
    if (tmp___19 == 0) {
      {
#line 2526
      s.len = (value + i)->len - 14UL;
#line 2527
      s.data = (value + i)->data + 14;
#line 2529
      tmp___18 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 2529
      manager_sleep = (ngx_msec_t )tmp___18;
      }
#line 2530
      if (manager_sleep == 0xffffffffffffffffUL) {
        {
#line 2531
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid manager_sleep value \"%V\"",
                           value + i);
        }
#line 2533
        return ((char *)((void *)-1));
      }
#line 2536
      goto __Cont___0;
    }
    {
#line 2539
    tmp___21 = strncmp((char const   *)(value + i)->data, "manager_threshold=", (size_t )18);
    }
#line 2539
    if (tmp___21 == 0) {
      {
#line 2541
      s.len = (value + i)->len - 18UL;
#line 2542
      s.data = (value + i)->data + 18;
#line 2544
      tmp___20 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 2544
      manager_threshold = (ngx_msec_t )tmp___20;
      }
#line 2545
      if (manager_threshold == 0xffffffffffffffffUL) {
        {
#line 2546
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid manager_threshold value \"%V\"",
                           value + i);
        }
#line 2548
        return ((char *)((void *)-1));
      }
#line 2551
      goto __Cont___0;
    }
    {
#line 2554
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 2556
    return ((char *)((void *)-1));
    __Cont___0: /* CIL Label */ 
#line 2357
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2559
  if (name.len == 0UL) {
    {
#line 2560
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"keys_zone\" parameter",
                       & cmd->name);
    }
#line 2563
    return ((char *)((void *)-1));
  } else
#line 2559
  if (size == 0L) {
    {
#line 2560
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"keys_zone\" parameter",
                       & cmd->name);
    }
#line 2563
    return ((char *)((void *)-1));
  }
  {
#line 2566
  (cache->path)->manager = & ngx_http_file_cache_manager;
#line 2567
  (cache->path)->loader = & ngx_http_file_cache_loader;
#line 2568
  (cache->path)->data = (void *)cache;
#line 2569
  (cache->path)->conf_file = (cf->conf_file)->file.name.data;
#line 2570
  (cache->path)->line = (cf->conf_file)->line;
#line 2571
  cache->loader_files = (ngx_uint_t )loader_files;
#line 2572
  cache->loader_sleep = loader_sleep;
#line 2573
  cache->loader_threshold = loader_threshold;
#line 2574
  cache->manager_files = (ngx_uint_t )manager_files;
#line 2575
  cache->manager_sleep = manager_sleep;
#line 2576
  cache->manager_threshold = manager_threshold;
#line 2578
  tmp___22 = ngx_add_path(cf, & cache->path);
  }
#line 2578
  if (tmp___22 != 0L) {
#line 2579
    return ((char *)((void *)-1));
  }
  {
#line 2582
  cache->shm_zone = ngx_shared_memory_add(cf, & name, (size_t )size, cmd->post);
  }
#line 2583
  if ((unsigned long )cache->shm_zone == (unsigned long )((void *)0)) {
#line 2584
    return ((char *)((void *)-1));
  }
#line 2587
  if ((cache->shm_zone)->data) {
    {
#line 2588
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate zone \"%V\"", & name);
    }
#line 2590
    return ((char *)((void *)-1));
  }
  {
#line 2594
  (cache->shm_zone)->init = & ngx_http_file_cache_init;
#line 2595
  (cache->shm_zone)->data = (void *)cache;
#line 2597
  cache->use_temp_path = use_temp_path;
#line 2599
  cache->inactive = inactive;
#line 2600
  cache->max_size = max_size;
#line 2602
  caches = (ngx_array_t *)(confp + cmd->offset);
#line 2604
  tmp___23 = ngx_array_push(caches);
#line 2604
  ce = (ngx_http_file_cache_t **)tmp___23;
  }
#line 2605
  if ((unsigned long )ce == (unsigned long )((void *)0)) {
#line 2606
    return ((char *)((void *)-1));
  }
#line 2609
  *ce = cache;
#line 2611
  return ((char *)((void *)0));
}
}
#line 2626 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
static ngx_uint_t statuses[3]  = {      (ngx_uint_t )200,      (ngx_uint_t )301,      (ngx_uint_t )302};
#line 2615 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_file_cache.c"
char *ngx_http_file_cache_valid_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  time_t valid ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t status ;
  ngx_array_t **a ;
  ngx_http_cache_valid_t *v ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2619
  p = (char *)conf;
#line 2628
  a = (ngx_array_t **)(p + cmd->offset);
#line 2630
  if ((unsigned long )*a == (unsigned long )((void *)-1)) {
    {
#line 2631
    *a = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_cache_valid_t ));
    }
#line 2632
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 2633
      return ((char *)((void *)-1));
    }
  }
  {
#line 2637
  value = (ngx_str_t *)(cf->args)->elts;
#line 2638
  n = (cf->args)->nelts - 1UL;
#line 2640
  valid = ngx_parse_time(value + n, (ngx_uint_t )1);
  }
#line 2641
  if (valid == -1L) {
    {
#line 2642
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid time value \"%V\"", value + n);
    }
#line 2644
    return ((char *)((void *)-1));
  }
#line 2647
  if (n == 1UL) {
#line 2649
    i = (ngx_uint_t )0;
    {
#line 2649
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2649
      if (! (i < 3UL)) {
#line 2649
        goto while_break;
      }
      {
#line 2650
      tmp = ngx_array_push(*a);
#line 2650
      v = (ngx_http_cache_valid_t *)tmp;
      }
#line 2651
      if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 2652
        return ((char *)((void *)-1));
      }
#line 2655
      v->status = statuses[i];
#line 2656
      v->valid = valid;
#line 2649
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 2659
    return ((char *)((void *)0));
  }
#line 2662
  i = (ngx_uint_t )1;
  {
#line 2662
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2662
    if (! (i < n)) {
#line 2662
      goto while_break___0;
    }
    {
#line 2664
    tmp___1 = strcmp((char const   *)(value + i)->data, "any");
    }
#line 2664
    if (tmp___1 == 0) {
#line 2666
      status = (ngx_uint_t )0;
    } else {
      {
#line 2670
      tmp___0 = ngx_atoi((value + i)->data, (value + i)->len);
#line 2670
      status = (ngx_uint_t )tmp___0;
      }
#line 2671
      if (status < 100UL) {
        {
#line 2672
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid status \"%V\"", value + i);
        }
#line 2674
        return ((char *)((void *)-1));
      }
    }
    {
#line 2678
    tmp___2 = ngx_array_push(*a);
#line 2678
    v = (ngx_http_cache_valid_t *)tmp___2;
    }
#line 2679
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 2680
      return ((char *)((void *)-1));
    }
#line 2683
    v->status = status;
#line 2684
    v->valid = valid;
#line 2662
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2687
  return ((char *)((void *)0));
}
}
#line 113 "src/core/ngx_inet.h"
size_t ngx_sock_ntop(struct sockaddr *sa , socklen_t socklen , u_char *text , size_t len ,
                     ngx_uint_t port ) ;
#line 123
ngx_int_t ngx_inet_resolve_host(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 127
void ngx_inet_set_port(struct sockaddr *sa , in_port_t port ) ;
#line 140 "src/http/ngx_http_upstream_round_robin.h"
ngx_int_t ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r , ngx_http_upstream_resolved_t *ur ) ;
#line 144
void ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc , void *data ,
                                             ngx_uint_t state ) ;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream_round_robin.c"
static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp ) ;
#line 30 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream_round_robin.c"
ngx_int_t ngx_http_upstream_init_round_robin(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_url_t u ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t n ;
  ngx_uint_t w ;
  ngx_http_upstream_server_t *server ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t **peerp ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_rr_peers_t *backup ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 40
  us->peer.init = & ngx_http_upstream_init_round_robin_peer;
#line 42
  if (us->servers) {
#line 43
    server = (ngx_http_upstream_server_t *)(us->servers)->elts;
#line 45
    n = (ngx_uint_t )0;
#line 46
    w = (ngx_uint_t )0;
#line 48
    i = (ngx_uint_t )0;
    {
#line 48
    while (1) {
      while_continue: /* CIL Label */ ;
#line 48
      if (! (i < (us->servers)->nelts)) {
#line 48
        goto while_break;
      }
#line 49
      if ((server + i)->backup) {
#line 50
        goto __Cont;
      }
#line 53
      n += (server + i)->naddrs;
#line 54
      w += (server + i)->naddrs * (server + i)->weight;
      __Cont: /* CIL Label */ 
#line 48
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 57
    if (n == 0UL) {
#line 58
      if ((cf->log)->log_level >= 1UL) {
        {
#line 58
        ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "no servers in upstream \"%V\" in %s:%ui",
                           & us->host, us->file_name, us->line);
        }
      }
#line 61
      return ((ngx_int_t )-1);
    }
    {
#line 64
    tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 64
    peers = (ngx_http_upstream_rr_peers_t *)tmp;
    }
#line 65
    if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 66
      return ((ngx_int_t )-1);
    }
    {
#line 69
    tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peer_t ) * n);
#line 69
    peer = (ngx_http_upstream_rr_peer_t *)tmp___0;
    }
#line 70
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 71
      return ((ngx_int_t )-1);
    }
#line 74
    peers->single = (unsigned int )(n == 1UL);
#line 75
    peers->number = n;
#line 76
    peers->weighted = (unsigned int )(w != n);
#line 77
    peers->total_weight = w;
#line 78
    peers->name = & us->host;
#line 80
    n = (ngx_uint_t )0;
#line 81
    peerp = & peers->peer;
#line 83
    i = (ngx_uint_t )0;
    {
#line 83
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 83
      if (! (i < (us->servers)->nelts)) {
#line 83
        goto while_break___0;
      }
#line 84
      if ((server + i)->backup) {
#line 85
        goto __Cont___0;
      }
#line 88
      j = (ngx_uint_t )0;
      {
#line 88
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 88
        if (! (j < (server + i)->naddrs)) {
#line 88
          goto while_break___1;
        }
#line 89
        (peer + n)->sockaddr = ((server + i)->addrs + j)->sockaddr;
#line 90
        (peer + n)->socklen = ((server + i)->addrs + j)->socklen;
#line 91
        (peer + n)->name = ((server + i)->addrs + j)->name;
#line 92
        (peer + n)->weight = (ngx_int_t )(server + i)->weight;
#line 93
        (peer + n)->effective_weight = (ngx_int_t )(server + i)->weight;
#line 94
        (peer + n)->current_weight = (ngx_int_t )0;
#line 95
        (peer + n)->max_conns = (server + i)->max_conns;
#line 96
        (peer + n)->max_fails = (server + i)->max_fails;
#line 97
        (peer + n)->fail_timeout = (server + i)->fail_timeout;
#line 98
        (peer + n)->down = (server + i)->down;
#line 99
        (peer + n)->server = (server + i)->name;
#line 101
        *peerp = peer + n;
#line 102
        peerp = & (peer + n)->next;
#line 103
        n ++;
#line 88
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      __Cont___0: /* CIL Label */ 
#line 83
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 107
    us->peer.data = (void *)peers;
#line 111
    n = (ngx_uint_t )0;
#line 112
    w = (ngx_uint_t )0;
#line 114
    i = (ngx_uint_t )0;
    {
#line 114
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 114
      if (! (i < (us->servers)->nelts)) {
#line 114
        goto while_break___2;
      }
#line 115
      if (! (server + i)->backup) {
#line 116
        goto __Cont___1;
      }
#line 119
      n += (server + i)->naddrs;
#line 120
      w += (server + i)->naddrs * (server + i)->weight;
      __Cont___1: /* CIL Label */ 
#line 114
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 123
    if (n == 0UL) {
#line 124
      return ((ngx_int_t )0);
    }
    {
#line 127
    tmp___1 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 127
    backup = (ngx_http_upstream_rr_peers_t *)tmp___1;
    }
#line 128
    if ((unsigned long )backup == (unsigned long )((void *)0)) {
#line 129
      return ((ngx_int_t )-1);
    }
    {
#line 132
    tmp___2 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peer_t ) * n);
#line 132
    peer = (ngx_http_upstream_rr_peer_t *)tmp___2;
    }
#line 133
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 134
      return ((ngx_int_t )-1);
    }
#line 137
    peers->single = 0U;
#line 138
    backup->single = 0U;
#line 139
    backup->number = n;
#line 140
    backup->weighted = (unsigned int )(w != n);
#line 141
    backup->total_weight = w;
#line 142
    backup->name = & us->host;
#line 144
    n = (ngx_uint_t )0;
#line 145
    peerp = & backup->peer;
#line 147
    i = (ngx_uint_t )0;
    {
#line 147
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 147
      if (! (i < (us->servers)->nelts)) {
#line 147
        goto while_break___3;
      }
#line 148
      if (! (server + i)->backup) {
#line 149
        goto __Cont___2;
      }
#line 152
      j = (ngx_uint_t )0;
      {
#line 152
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 152
        if (! (j < (server + i)->naddrs)) {
#line 152
          goto while_break___4;
        }
#line 153
        (peer + n)->sockaddr = ((server + i)->addrs + j)->sockaddr;
#line 154
        (peer + n)->socklen = ((server + i)->addrs + j)->socklen;
#line 155
        (peer + n)->name = ((server + i)->addrs + j)->name;
#line 156
        (peer + n)->weight = (ngx_int_t )(server + i)->weight;
#line 157
        (peer + n)->effective_weight = (ngx_int_t )(server + i)->weight;
#line 158
        (peer + n)->current_weight = (ngx_int_t )0;
#line 159
        (peer + n)->max_conns = (server + i)->max_conns;
#line 160
        (peer + n)->max_fails = (server + i)->max_fails;
#line 161
        (peer + n)->fail_timeout = (server + i)->fail_timeout;
#line 162
        (peer + n)->down = (server + i)->down;
#line 163
        (peer + n)->server = (server + i)->name;
#line 165
        *peerp = peer + n;
#line 166
        peerp = & (peer + n)->next;
#line 167
        n ++;
#line 152
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      __Cont___2: /* CIL Label */ 
#line 147
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 171
    peers->next = backup;
#line 173
    return ((ngx_int_t )0);
  }
#line 179
  if ((int )us->port == 0) {
#line 180
    if ((cf->log)->log_level >= 1UL) {
      {
#line 180
      ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "no port in upstream \"%V\" in %s:%ui",
                         & us->host, us->file_name, us->line);
      }
    }
#line 183
    return ((ngx_int_t )-1);
  }
  {
#line 186
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 188
  u.host = us->host;
#line 189
  u.port = us->port;
#line 191
  tmp___3 = ngx_inet_resolve_host(cf->pool, & u);
  }
#line 191
  if (tmp___3 != 0L) {
#line 192
    if (u.err) {
#line 193
      if ((cf->log)->log_level >= 1UL) {
        {
#line 193
        ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "%s in upstream \"%V\" in %s:%ui",
                           u.err, & us->host, us->file_name, us->line);
        }
      }
    }
#line 198
    return ((ngx_int_t )-1);
  }
  {
#line 201
  n = u.naddrs;
#line 203
  tmp___4 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 203
  peers = (ngx_http_upstream_rr_peers_t *)tmp___4;
  }
#line 204
  if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 205
    return ((ngx_int_t )-1);
  }
  {
#line 208
  tmp___5 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_rr_peer_t ) * n);
#line 208
  peer = (ngx_http_upstream_rr_peer_t *)tmp___5;
  }
#line 209
  if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 210
    return ((ngx_int_t )-1);
  }
#line 213
  peers->single = (unsigned int )(n == 1UL);
#line 214
  peers->number = n;
#line 215
  peers->weighted = 0U;
#line 216
  peers->total_weight = n;
#line 217
  peers->name = & us->host;
#line 219
  peerp = & peers->peer;
#line 221
  i = (ngx_uint_t )0;
  {
#line 221
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 221
    if (! (i < u.naddrs)) {
#line 221
      goto while_break___5;
    }
#line 222
    (peer + i)->sockaddr = (u.addrs + i)->sockaddr;
#line 223
    (peer + i)->socklen = (u.addrs + i)->socklen;
#line 224
    (peer + i)->name = (u.addrs + i)->name;
#line 225
    (peer + i)->weight = (ngx_int_t )1;
#line 226
    (peer + i)->effective_weight = (ngx_int_t )1;
#line 227
    (peer + i)->current_weight = (ngx_int_t )0;
#line 228
    (peer + i)->max_conns = (ngx_uint_t )0;
#line 229
    (peer + i)->max_fails = (ngx_uint_t )1;
#line 230
    (peer + i)->fail_timeout = (time_t )10;
#line 231
    *peerp = peer + i;
#line 232
    peerp = & (peer + i)->next;
#line 221
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 235
  us->peer.data = (void *)peers;
#line 239
  return ((ngx_int_t )0);
}
}
#line 243 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream_round_robin.c"
ngx_int_t ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r , ngx_http_upstream_srv_conf_t *us ) 
{ 
  ngx_uint_t n ;
  ngx_http_upstream_rr_peer_data_t *rrp ;
  void *tmp ;
  void *tmp___0 ;
  ngx_uint_t tmp___1 ;

  {
#line 250
  rrp = (ngx_http_upstream_rr_peer_data_t *)(r->upstream)->peer.data;
#line 252
  if ((unsigned long )rrp == (unsigned long )((void *)0)) {
    {
#line 253
    tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t ));
#line 253
    rrp = (ngx_http_upstream_rr_peer_data_t *)tmp;
    }
#line 254
    if ((unsigned long )rrp == (unsigned long )((void *)0)) {
#line 255
      return ((ngx_int_t )-1);
    }
#line 258
    (r->upstream)->peer.data = (void *)rrp;
  }
#line 261
  rrp->peers = (ngx_http_upstream_rr_peers_t *)us->peer.data;
#line 262
  rrp->current = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 263
  rrp->config = (ngx_uint_t )0;
#line 265
  n = (rrp->peers)->number;
#line 267
  if ((rrp->peers)->next) {
#line 267
    if (((rrp->peers)->next)->number > n) {
#line 268
      n = ((rrp->peers)->next)->number;
    }
  }
#line 271
  if (n <= 8UL * sizeof(uintptr_t )) {
#line 272
    rrp->tried = & rrp->data;
#line 273
    rrp->data = (uintptr_t )0;
  } else {
    {
#line 276
    n = (n + (8UL * sizeof(uintptr_t ) - 1UL)) / (8UL * sizeof(uintptr_t ));
#line 278
    tmp___0 = ngx_pcalloc(r->pool, n * sizeof(uintptr_t ));
#line 278
    rrp->tried = (uintptr_t *)tmp___0;
    }
#line 279
    if ((unsigned long )rrp->tried == (unsigned long )((void *)0)) {
#line 280
      return ((ngx_int_t )-1);
    }
  }
#line 284
  (r->upstream)->peer.get = & ngx_http_upstream_get_round_robin_peer;
#line 285
  (r->upstream)->peer.free = & ngx_http_upstream_free_round_robin_peer;
#line 286
  if ((rrp->peers)->next) {
#line 286
    tmp___1 = ((rrp->peers)->next)->number;
  } else {
#line 286
    tmp___1 = (ngx_uint_t )0;
  }
#line 286
  (r->upstream)->peer.tries = (rrp->peers)->number + tmp___1;
#line 294
  return ((ngx_int_t )0);
}
}
#line 298 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream_round_robin.c"
ngx_int_t ngx_http_upstream_create_round_robin_peer(ngx_http_request_t *r , ngx_http_upstream_resolved_t *ur ) 
{ 
  u_char *p ;
  size_t len ;
  socklen_t socklen ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  struct sockaddr *sockaddr ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t **peerp ;
  ngx_http_upstream_rr_peers_t *peers ;
  ngx_http_upstream_rr_peer_data_t *rrp ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ngx_uint_t tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 311
  rrp = (ngx_http_upstream_rr_peer_data_t *)(r->upstream)->peer.data;
#line 313
  if ((unsigned long )rrp == (unsigned long )((void *)0)) {
    {
#line 314
    tmp = ngx_palloc(r->pool, sizeof(ngx_http_upstream_rr_peer_data_t ));
#line 314
    rrp = (ngx_http_upstream_rr_peer_data_t *)tmp;
    }
#line 315
    if ((unsigned long )rrp == (unsigned long )((void *)0)) {
#line 316
      return ((ngx_int_t )-1);
    }
#line 319
    (r->upstream)->peer.data = (void *)rrp;
  }
  {
#line 322
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peers_t ));
#line 322
  peers = (ngx_http_upstream_rr_peers_t *)tmp___0;
  }
#line 323
  if ((unsigned long )peers == (unsigned long )((void *)0)) {
#line 324
    return ((ngx_int_t )-1);
  }
  {
#line 327
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_rr_peer_t ) * ur->naddrs);
#line 327
  peer = (ngx_http_upstream_rr_peer_t *)tmp___1;
  }
#line 329
  if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 330
    return ((ngx_int_t )-1);
  }
#line 333
  peers->single = (unsigned int )(ur->naddrs == 1UL);
#line 334
  peers->number = ur->naddrs;
#line 335
  peers->name = & ur->host;
#line 337
  if (ur->sockaddr) {
#line 338
    (peer + 0)->sockaddr = ur->sockaddr;
#line 339
    (peer + 0)->socklen = ur->socklen;
#line 340
    if (ur->name.data) {
#line 340
      (peer + 0)->name = ur->name;
    } else {
#line 340
      (peer + 0)->name = ur->host;
    }
#line 341
    (peer + 0)->weight = (ngx_int_t )1;
#line 342
    (peer + 0)->effective_weight = (ngx_int_t )1;
#line 343
    (peer + 0)->current_weight = (ngx_int_t )0;
#line 344
    (peer + 0)->max_conns = (ngx_uint_t )0;
#line 345
    (peer + 0)->max_fails = (ngx_uint_t )1;
#line 346
    (peer + 0)->fail_timeout = (time_t )10;
#line 347
    peers->peer = peer;
  } else {
#line 350
    peerp = & peers->peer;
#line 352
    i = (ngx_uint_t )0;
    {
#line 352
    while (1) {
      while_continue: /* CIL Label */ ;
#line 352
      if (! (i < ur->naddrs)) {
#line 352
        goto while_break;
      }
      {
#line 354
      socklen = (ur->addrs + i)->socklen;
#line 356
      tmp___2 = ngx_palloc(r->pool, (size_t )socklen);
#line 356
      sockaddr = (struct sockaddr *)tmp___2;
      }
#line 357
      if ((unsigned long )sockaddr == (unsigned long )((void *)0)) {
#line 358
        return ((ngx_int_t )-1);
      }
      {
#line 361
      memcpy((void */* __restrict  */)sockaddr, (void const   */* __restrict  */)(ur->addrs + i)->sockaddr,
             (size_t )socklen);
#line 362
      ngx_inet_set_port(sockaddr, ur->port);
#line 364
      tmp___3 = ngx_pnalloc(r->pool, ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path));
#line 364
      p = (u_char *)tmp___3;
      }
#line 365
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 366
        return ((ngx_int_t )-1);
      }
      {
#line 369
      len = ngx_sock_ntop(sockaddr, socklen, p, ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path),
                          (ngx_uint_t )1);
#line 371
      (peer + i)->sockaddr = sockaddr;
#line 372
      (peer + i)->socklen = socklen;
#line 373
      (peer + i)->name.len = len;
#line 374
      (peer + i)->name.data = p;
#line 375
      (peer + i)->weight = (ngx_int_t )1;
#line 376
      (peer + i)->effective_weight = (ngx_int_t )1;
#line 377
      (peer + i)->current_weight = (ngx_int_t )0;
#line 378
      (peer + i)->max_conns = (ngx_uint_t )0;
#line 379
      (peer + i)->max_fails = (ngx_uint_t )1;
#line 380
      (peer + i)->fail_timeout = (time_t )10;
#line 381
      *peerp = peer + i;
#line 382
      peerp = & (peer + i)->next;
#line 352
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 386
  rrp->peers = peers;
#line 387
  rrp->current = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 388
  rrp->config = (ngx_uint_t )0;
#line 390
  if ((rrp->peers)->number <= 8UL * sizeof(uintptr_t )) {
#line 391
    rrp->tried = & rrp->data;
#line 392
    rrp->data = (uintptr_t )0;
  } else {
    {
#line 395
    n = ((rrp->peers)->number + (8UL * sizeof(uintptr_t ) - 1UL)) / (8UL * sizeof(uintptr_t ));
#line 398
    tmp___4 = ngx_pcalloc(r->pool, n * sizeof(uintptr_t ));
#line 398
    rrp->tried = (uintptr_t *)tmp___4;
    }
#line 399
    if ((unsigned long )rrp->tried == (unsigned long )((void *)0)) {
#line 400
      return ((ngx_int_t )-1);
    }
  }
#line 404
  (r->upstream)->peer.get = & ngx_http_upstream_get_round_robin_peer;
#line 405
  (r->upstream)->peer.free = & ngx_http_upstream_free_round_robin_peer;
#line 406
  if ((rrp->peers)->next) {
#line 406
    tmp___5 = ((rrp->peers)->next)->number;
  } else {
#line 406
    tmp___5 = (ngx_uint_t )0;
  }
#line 406
  (r->upstream)->peer.tries = (rrp->peers)->number + tmp___5;
#line 412
  return ((ngx_int_t )0);
}
}
#line 416 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream_round_robin.c"
ngx_int_t ngx_http_upstream_get_round_robin_peer(ngx_peer_connection_t *pc , void *data ) 
{ 
  ngx_http_upstream_rr_peer_data_t *rrp ;
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peers_t *peers ;

  {
#line 419
  rrp = (ngx_http_upstream_rr_peer_data_t *)data;
#line 429
  pc->cached = 0U;
#line 430
  pc->connection = (ngx_connection_t *)((void *)0);
#line 432
  peers = rrp->peers;
#line 433
  if (peers->shpool) {
    {
#line 433
    ngx_rwlock_wlock(& peers->rwlock);
    }
  }
#line 435
  if (peers->single) {
#line 436
    peer = peers->peer;
#line 438
    if (peer->down) {
#line 439
      goto failed;
    }
#line 442
    if (peer->max_conns) {
#line 442
      if (peer->conns >= peer->max_conns) {
#line 443
        goto failed;
      }
    }
#line 446
    rrp->current = peer;
  } else {
    {
#line 452
    peer = ngx_http_upstream_get_peer(rrp);
    }
#line 454
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 455
      goto failed;
    }
  }
#line 463
  pc->sockaddr = peer->sockaddr;
#line 464
  pc->socklen = peer->socklen;
#line 465
  pc->name = & peer->name;
#line 467
  (peer->conns) ++;
#line 469
  if (peers->shpool) {
    {
#line 469
    ngx_rwlock_unlock(& peers->rwlock);
    }
  }
#line 471
  return ((ngx_int_t )0);
  failed: 
#line 475
  if (peers->next) {
#line 479
    rrp->peers = peers->next;
#line 481
    n = ((rrp->peers)->number + (8UL * sizeof(uintptr_t ) - 1UL)) / (8UL * sizeof(uintptr_t ));
#line 484
    i = (ngx_uint_t )0;
    {
#line 484
    while (1) {
      while_continue: /* CIL Label */ ;
#line 484
      if (! (i < n)) {
#line 484
        goto while_break;
      }
#line 485
      *(rrp->tried + i) = (uintptr_t )0;
#line 484
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 488
    if (peers->shpool) {
      {
#line 488
      ngx_rwlock_unlock(& peers->rwlock);
      }
    }
    {
#line 490
    rc = ngx_http_upstream_get_round_robin_peer(pc, (void *)rrp);
    }
#line 492
    if (rc != -3L) {
#line 493
      return (rc);
    }
#line 496
    if (peers->shpool) {
      {
#line 496
      ngx_rwlock_wlock(& peers->rwlock);
      }
    }
  }
#line 499
  if (peers->shpool) {
    {
#line 499
    ngx_rwlock_unlock(& peers->rwlock);
    }
  }
#line 501
  pc->name = peers->name;
#line 503
  return ((ngx_int_t )-3);
}
}
#line 507 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream_round_robin.c"
static ngx_http_upstream_rr_peer_t *ngx_http_upstream_get_peer(ngx_http_upstream_rr_peer_data_t *rrp ) 
{ 
  time_t now ;
  uintptr_t m ;
  ngx_int_t total ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t p ;
  ngx_http_upstream_rr_peer_t *peer ;
  ngx_http_upstream_rr_peer_t *best ;

  {
#line 516
  now = (time_t )ngx_cached_time->sec;
#line 518
  best = (ngx_http_upstream_rr_peer_t *)((void *)0);
#line 519
  total = (ngx_int_t )0;
#line 522
  p = (ngx_uint_t )0;
#line 525
  peer = (rrp->peers)->peer;
#line 525
  i = (ngx_uint_t )0;
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (! peer) {
#line 525
      goto while_break;
    }
#line 529
    n = i / (8UL * sizeof(uintptr_t ));
#line 530
    m = 1UL << i % (8UL * sizeof(uintptr_t ));
#line 532
    if (*(rrp->tried + n) & m) {
#line 533
      goto __Cont;
    }
#line 536
    if (peer->down) {
#line 537
      goto __Cont;
    }
#line 540
    if (peer->max_fails) {
#line 540
      if (peer->fails >= peer->max_fails) {
#line 540
        if (now - peer->checked <= peer->fail_timeout) {
#line 544
          goto __Cont;
        }
      }
    }
#line 547
    if (peer->max_conns) {
#line 547
      if (peer->conns >= peer->max_conns) {
#line 548
        goto __Cont;
      }
    }
#line 551
    peer->current_weight += peer->effective_weight;
#line 552
    total += peer->effective_weight;
#line 554
    if (peer->effective_weight < peer->weight) {
#line 555
      (peer->effective_weight) ++;
    }
#line 558
    if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 559
      best = peer;
#line 560
      p = i;
    } else
#line 558
    if (peer->current_weight > best->current_weight) {
#line 559
      best = peer;
#line 560
      p = i;
    }
    __Cont: /* CIL Label */ 
#line 525
    peer = peer->next;
#line 525
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  if ((unsigned long )best == (unsigned long )((void *)0)) {
#line 565
    return ((ngx_http_upstream_rr_peer_t *)((void *)0));
  }
#line 568
  rrp->current = best;
#line 570
  n = p / (8UL * sizeof(uintptr_t ));
#line 571
  m = 1UL << p % (8UL * sizeof(uintptr_t ));
#line 573
  *(rrp->tried + n) |= m;
#line 575
  best->current_weight -= total;
#line 577
  if (now - best->checked > best->fail_timeout) {
#line 578
    best->checked = now;
  }
#line 581
  return (best);
}
}
#line 585 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream_round_robin.c"
void ngx_http_upstream_free_round_robin_peer(ngx_peer_connection_t *pc , void *data ,
                                             ngx_uint_t state ) 
{ 
  ngx_http_upstream_rr_peer_data_t *rrp ;
  time_t now ;
  ngx_http_upstream_rr_peer_t *peer ;
  char *__cil_tmp7 ;

  {
#line 589
  rrp = (ngx_http_upstream_rr_peer_data_t *)data;
#line 599
  peer = rrp->current;
#line 601
  if ((rrp->peers)->shpool) {
    {
#line 601
    ngx_rwlock_rlock(& (rrp->peers)->rwlock);
    }
  }
#line 602
  if ((rrp->peers)->shpool) {
    {
#line 602
    ngx_rwlock_wlock(& peer->lock);
    }
  }
#line 604
  if ((rrp->peers)->single) {
#line 606
    (peer->conns) --;
#line 608
    if ((rrp->peers)->shpool) {
      {
#line 608
      ngx_rwlock_unlock(& peer->lock);
      }
    }
#line 609
    if ((rrp->peers)->shpool) {
      {
#line 609
      ngx_rwlock_unlock(& (rrp->peers)->rwlock);
      }
    }
#line 611
    pc->tries = (ngx_uint_t )0;
#line 612
    return;
  }
#line 615
  if (state & 4UL) {
#line 616
    now = (time_t )ngx_cached_time->sec;
#line 618
    (peer->fails) ++;
#line 619
    peer->accessed = now;
#line 620
    peer->checked = now;
#line 622
    if (peer->max_fails) {
#line 623
      peer->effective_weight = (ngx_int_t )((ngx_uint_t )peer->effective_weight - (ngx_uint_t )peer->weight / peer->max_fails);
#line 625
      if (peer->fails >= peer->max_fails) {
#line 626
        if ((pc->log)->log_level >= 5UL) {
          {
#line 626
          ngx_log_error_core((ngx_uint_t )5, pc->log, 0, "upstream server temporarily disabled");
          }
        }
      }
    }
#line 635
    if (peer->effective_weight < 0L) {
#line 636
      peer->effective_weight = (ngx_int_t )0;
    }
  } else
#line 643
  if (peer->accessed < peer->checked) {
#line 644
    peer->fails = (ngx_uint_t )0;
  }
#line 648
  (peer->conns) --;
#line 650
  if ((rrp->peers)->shpool) {
    {
#line 650
    ngx_rwlock_unlock(& peer->lock);
    }
  }
#line 651
  if ((rrp->peers)->shpool) {
    {
#line 651
    ngx_rwlock_unlock(& (rrp->peers)->rwlock);
    }
  }
#line 653
  if (pc->tries) {
#line 654
    (pc->tries) --;
  }
#line 656
  return;
}
}
#line 219 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 42 "src/os/unix/ngx_socket.h"
int ngx_tcp_push(ngx_socket_t s ) ;
#line 166 "src/core/ngx_string.h"
u_char *ngx_strlcasestrn(u_char *s1 , u_char *last , u_char *s2 , size_t n ) ;
#line 87 "src/core/ngx_palloc.h"
void ngx_pool_run_cleanup_file(ngx_pool_t *p , ngx_fd_t fd ) ;
#line 36 "src/core/ngx_list.h"
__inline static ngx_int_t ngx_list_init(ngx_list_t *list , ngx_pool_t *pool , ngx_uint_t n ,
                                        size_t size ) 
{ 


  {
  {
#line 39
  list->part.elts = ngx_palloc(pool, n * size);
  }
#line 40
  if ((unsigned long )list->part.elts == (unsigned long )((void *)0)) {
#line 41
    return ((ngx_int_t )-1);
  }
#line 44
  list->part.nelts = (ngx_uint_t )0;
#line 45
  list->part.next = (ngx_list_part_t *)((void *)0);
#line 46
  list->last = & list->part;
#line 47
  list->size = size;
#line 48
  list->nalloc = n;
#line 49
  list->pool = pool;
#line 51
  return ((ngx_int_t )0);
}
}
#line 139 "src/core/ngx_file.h"
ngx_int_t ngx_create_temp_file(ngx_file_t *file , ngx_path_t *path , ngx_pool_t *pool ,
                               ngx_uint_t persistent , ngx_uint_t clean , ngx_uint_t access___0 ) ;
#line 120 "src/core/ngx_inet.h"
ngx_int_t ngx_parse_addr_port(ngx_pool_t *pool , ngx_addr_t *addr , u_char *text ,
                              size_t len ) ;
#line 231 "src/core/ngx_resolver.h"
ngx_resolver_ctx_t *ngx_resolve_start(ngx_resolver_t *r , ngx_resolver_ctx_t *temp ) ;
#line 233
ngx_int_t ngx_resolve_name(ngx_resolver_ctx_t *ctx ) ;
#line 234
void ngx_resolve_name_done(ngx_resolver_ctx_t *ctx ) ;
#line 237
char *ngx_resolver_strerror(ngx_int_t err ) ;
#line 217 "src/core/ngx_connection.h"
ngx_int_t ngx_tcp_nodelay(ngx_connection_t *c ) ;
#line 218
ngx_int_t ngx_connection_error(ngx_connection_t *c , ngx_err_t err , char *text ) ;
#line 60 "src/http/ngx_http_variables.h"
ngx_int_t ngx_http_variable_unknown_header(ngx_http_variable_value_t *v , ngx_str_t *var ,
                                           ngx_list_part_t *part , size_t prefix ) ;
#line 215 "src/http/ngx_http_script.h"
ngx_int_t ngx_http_test_predicates(ngx_http_request_t *r , ngx_array_t *predicates ) ;
#line 197 "src/event/ngx_event.h"
ngx_event_actions_t ngx_event_actions ;
#line 199
ngx_uint_t ngx_use_epoll_rdhup ;
#line 496
ngx_uint_t ngx_event_flags ;
#line 45 "src/event/ngx_event_posted.h"
ngx_queue_t ngx_posted_events ;
#line 74 "src/event/ngx_event_connect.h"
ngx_int_t ngx_event_connect_peer(ngx_peer_connection_t *pc ) ;
#line 102 "src/event/ngx_event_pipe.h"
ngx_int_t ngx_event_pipe(ngx_event_pipe_t *p , ngx_int_t do_write ) ;
#line 504 "src/http/ngx_http_core_module.h"
ngx_http_cleanup_t *ngx_http_cleanup_add(ngx_http_request_t *r , size_t size ) ;
#line 532
ngx_str_t ngx_http_core_get_method ;
#line 104 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers , ngx_str_t *name ,
                                          ngx_str_t *value ) ;
#line 127
void ngx_http_request_empty_handler(ngx_http_request_t *r ) ;
#line 133
ngx_int_t ngx_http_send_special(ngx_http_request_t *r , ngx_uint_t flags ) ;
#line 138
ngx_int_t ngx_http_read_unbuffered_request_body(ngx_http_request_t *r ) ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 16
static ngx_int_t ngx_http_upstream_cache_get(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                             ngx_http_file_cache_t **cache ) ;
#line 18
static ngx_int_t ngx_http_upstream_cache_send(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 20
static ngx_int_t ngx_http_upstream_cache_background_update(ngx_http_request_t *r ,
                                                           ngx_http_upstream_t *u ) ;
#line 22
static ngx_int_t ngx_http_upstream_cache_check_range(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 24
static ngx_int_t ngx_http_upstream_cache_status(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 26
static ngx_int_t ngx_http_upstream_cache_last_modified(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 28
static ngx_int_t ngx_http_upstream_cache_etag(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 32
static void ngx_http_upstream_init_request(ngx_http_request_t *r ) ;
#line 33
static void ngx_http_upstream_resolve_handler(ngx_resolver_ctx_t *ctx ) ;
#line 34
static void ngx_http_upstream_rd_check_broken_connection(ngx_http_request_t *r ) ;
#line 35
static void ngx_http_upstream_wr_check_broken_connection(ngx_http_request_t *r ) ;
#line 36
static void ngx_http_upstream_check_broken_connection(ngx_http_request_t *r , ngx_event_t *ev ) ;
#line 38
static void ngx_http_upstream_connect(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 40
static ngx_int_t ngx_http_upstream_reinit(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 42
static void ngx_http_upstream_send_request(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                           ngx_uint_t do_write ) ;
#line 44
static ngx_int_t ngx_http_upstream_send_request_body(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                                     ngx_uint_t do_write ) ;
#line 46
static void ngx_http_upstream_send_request_handler(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 48
static void ngx_http_upstream_read_request_handler(ngx_http_request_t *r ) ;
#line 49
static void ngx_http_upstream_process_header(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 51
static ngx_int_t ngx_http_upstream_test_next(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 53
static ngx_int_t ngx_http_upstream_intercept_errors(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 55
static ngx_int_t ngx_http_upstream_test_connect(ngx_connection_t *c ) ;
#line 56
static ngx_int_t ngx_http_upstream_process_headers(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 58
static void ngx_http_upstream_process_body_in_memory(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 60
static void ngx_http_upstream_send_response(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 62
static void ngx_http_upstream_upgrade(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 64
static void ngx_http_upstream_upgraded_read_downstream(ngx_http_request_t *r ) ;
#line 65
static void ngx_http_upstream_upgraded_write_downstream(ngx_http_request_t *r ) ;
#line 66
static void ngx_http_upstream_upgraded_read_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 68
static void ngx_http_upstream_upgraded_write_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 70
static void ngx_http_upstream_process_upgraded(ngx_http_request_t *r , ngx_uint_t from_upstream ,
                                               ngx_uint_t do_write ) ;
#line 72
static void ngx_http_upstream_process_non_buffered_downstream(ngx_http_request_t *r ) ;
#line 74
static void ngx_http_upstream_process_non_buffered_upstream(ngx_http_request_t *r ,
                                                            ngx_http_upstream_t *u ) ;
#line 77
static void ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r ,
                                                           ngx_uint_t do_write ) ;
#line 80
static ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data ) ;
#line 81
static ngx_int_t ngx_http_upstream_non_buffered_filter(void *data , ssize_t bytes ) ;
#line 88
static ngx_int_t ngx_http_upstream_output_filter(void *data , ngx_chain_t *chain ) ;
#line 90
static void ngx_http_upstream_process_downstream(ngx_http_request_t *r ) ;
#line 91
static void ngx_http_upstream_process_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 93
static void ngx_http_upstream_process_request(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 95
static void ngx_http_upstream_store(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 97
static void ngx_http_upstream_dummy_handler(ngx_http_request_t *r , ngx_http_upstream_t *u ) ;
#line 99
static void ngx_http_upstream_next(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                   ngx_uint_t ft_type ) ;
#line 101
static void ngx_http_upstream_cleanup(void *data ) ;
#line 102
static void ngx_http_upstream_finalize_request(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                               ngx_int_t rc ) ;
#line 105
static ngx_int_t ngx_http_upstream_process_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                       ngx_uint_t offset ) ;
#line 107
static ngx_int_t ngx_http_upstream_process_content_length(ngx_http_request_t *r ,
                                                          ngx_table_elt_t *h , ngx_uint_t offset ) ;
#line 109
static ngx_int_t ngx_http_upstream_process_last_modified(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) ;
#line 111
static ngx_int_t ngx_http_upstream_process_set_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 113
static ngx_int_t ngx_http_upstream_process_cache_control(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) ;
#line 116
static ngx_int_t ngx_http_upstream_ignore_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 118
static ngx_int_t ngx_http_upstream_process_expires(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) ;
#line 120
static ngx_int_t ngx_http_upstream_process_accel_expires(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) ;
#line 122
static ngx_int_t ngx_http_upstream_process_limit_rate(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 124
static ngx_int_t ngx_http_upstream_process_buffering(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 126
static ngx_int_t ngx_http_upstream_process_charset(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) ;
#line 128
static ngx_int_t ngx_http_upstream_process_connection(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 130
static ngx_int_t ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r ,
                                                             ngx_table_elt_t *h ,
                                                             ngx_uint_t offset ) ;
#line 133
static ngx_int_t ngx_http_upstream_process_vary(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                ngx_uint_t offset ) ;
#line 135
static ngx_int_t ngx_http_upstream_copy_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                    ngx_uint_t offset ) ;
#line 137
static ngx_int_t ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r ,
                                                           ngx_table_elt_t *h , ngx_uint_t offset ) ;
#line 140
static ngx_int_t ngx_http_upstream_copy_content_type(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 142
static ngx_int_t ngx_http_upstream_copy_last_modified(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 144
static ngx_int_t ngx_http_upstream_rewrite_location(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                    ngx_uint_t offset ) ;
#line 146
static ngx_int_t ngx_http_upstream_rewrite_refresh(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) ;
#line 148
static ngx_int_t ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) ;
#line 150
static ngx_int_t ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 154
static ngx_int_t ngx_http_upstream_copy_content_encoding(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) ;
#line 158
static ngx_int_t ngx_http_upstream_add_variables(ngx_conf_t *cf ) ;
#line 159
static ngx_int_t ngx_http_upstream_addr_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 161
static ngx_int_t ngx_http_upstream_status_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 163
static ngx_int_t ngx_http_upstream_response_time_variable(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) ;
#line 165
static ngx_int_t ngx_http_upstream_response_length_variable(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ) ;
#line 167
static ngx_int_t ngx_http_upstream_header_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 169
static ngx_int_t ngx_http_upstream_cookie_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 172
static char *ngx_http_upstream(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) ;
#line 173
static char *ngx_http_upstream_server(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 176
static ngx_int_t ngx_http_upstream_set_local(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                             ngx_http_upstream_local_t *local ) ;
#line 179
static void *ngx_http_upstream_create_main_conf(ngx_conf_t *cf ) ;
#line 180
static char *ngx_http_upstream_init_main_conf(ngx_conf_t *cf , void *conf ) ;
#line 193 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_http_upstream_header_t ngx_http_upstream_headers_in[28]  = 
#line 193
  {      {{sizeof("Status") - 1UL, (u_char *)"Status"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->status), & ngx_http_upstream_copy_header_line,
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Content-Type") - 1UL, (u_char *)"Content-Type"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->content_type), & ngx_http_upstream_copy_content_type,
      (ngx_uint_t )0, (ngx_uint_t )1}, 
        {{sizeof("Content-Length") - 1UL, (u_char *)"Content-Length"}, & ngx_http_upstream_process_content_length,
      (ngx_uint_t )0, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Date") - 1UL,
       (u_char *)"Date"}, & ngx_http_upstream_process_header_line, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->date),
      & ngx_http_upstream_copy_header_line, (unsigned long )(& ((ngx_http_headers_out_t *)0)->date),
      (ngx_uint_t )0}, 
        {{sizeof("Last-Modified") - 1UL, (u_char *)"Last-Modified"}, & ngx_http_upstream_process_last_modified,
      (ngx_uint_t )0, & ngx_http_upstream_copy_last_modified, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("ETag") - 1UL,
       (u_char *)"ETag"}, & ngx_http_upstream_process_header_line, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->etag),
      & ngx_http_upstream_copy_header_line, (unsigned long )(& ((ngx_http_headers_out_t *)0)->etag),
      (ngx_uint_t )0}, 
        {{sizeof("Server") - 1UL, (u_char *)"Server"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->server), & ngx_http_upstream_copy_header_line,
      (unsigned long )(& ((ngx_http_headers_out_t *)0)->server), (ngx_uint_t )0}, 
        {{sizeof("WWW-Authenticate") - 1UL, (u_char *)"WWW-Authenticate"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->www_authenticate),
      & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Location") - 1UL, (u_char *)"Location"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->location), & ngx_http_upstream_rewrite_location,
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Refresh") - 1UL, (u_char *)"Refresh"}, & ngx_http_upstream_ignore_header_line,
      (ngx_uint_t )0, & ngx_http_upstream_rewrite_refresh, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Set-Cookie") - 1UL,
       (u_char *)"Set-Cookie"}, & ngx_http_upstream_process_set_cookie, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->cookies),
      & ngx_http_upstream_rewrite_set_cookie, (ngx_uint_t )0, (ngx_uint_t )1}, 
        {{sizeof("Content-Disposition") - 1UL, (u_char *)"Content-Disposition"}, & ngx_http_upstream_ignore_header_line,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )1}, 
        {{sizeof("Cache-Control") - 1UL,
       (u_char *)"Cache-Control"}, & ngx_http_upstream_process_cache_control, (ngx_uint_t )0,
      & ngx_http_upstream_copy_multi_header_lines, (unsigned long )(& ((ngx_http_headers_out_t *)0)->cache_control),
      (ngx_uint_t )1}, 
        {{sizeof("Expires") - 1UL, (u_char *)"Expires"}, & ngx_http_upstream_process_expires,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (unsigned long )(& ((ngx_http_headers_out_t *)0)->expires),
      (ngx_uint_t )1}, 
        {{sizeof("Accept-Ranges") - 1UL, (u_char *)"Accept-Ranges"}, & ngx_http_upstream_process_header_line,
      (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->accept_ranges), & ngx_http_upstream_copy_allow_ranges,
      (unsigned long )(& ((ngx_http_headers_out_t *)0)->accept_ranges), (ngx_uint_t )1}, 
        {{sizeof("Content-Range") - 1UL,
       (u_char *)"Content-Range"}, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0,
      & ngx_http_upstream_copy_header_line, (unsigned long )(& ((ngx_http_headers_out_t *)0)->content_range),
      (ngx_uint_t )0}, 
        {{sizeof("Connection") - 1UL, (u_char *)"Connection"}, & ngx_http_upstream_process_connection,
      (ngx_uint_t )0, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Keep-Alive") - 1UL,
       (u_char *)"Keep-Alive"}, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0,
      & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Vary") - 1UL, (u_char *)"Vary"}, & ngx_http_upstream_process_vary,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Powered-By") - 1UL,
       (u_char *)"X-Powered-By"}, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0,
      & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Expires") - 1UL, (u_char *)"X-Accel-Expires"}, & ngx_http_upstream_process_accel_expires,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Redirect") - 1UL,
       (u_char *)"X-Accel-Redirect"}, & ngx_http_upstream_process_header_line, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->x_accel_redirect),
      & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, & ngx_http_upstream_process_limit_rate,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Buffering") - 1UL,
       (u_char *)"X-Accel-Buffering"}, & ngx_http_upstream_process_buffering, (ngx_uint_t )0,
      & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, & ngx_http_upstream_process_charset,
      (ngx_uint_t )0, & ngx_http_upstream_copy_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Transfer-Encoding") - 1UL,
       (u_char *)"Transfer-Encoding"}, & ngx_http_upstream_process_transfer_encoding,
      (ngx_uint_t )0, & ngx_http_upstream_ignore_header_line, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("Content-Encoding") - 1UL,
       (u_char *)"Content-Encoding"}, & ngx_http_upstream_process_header_line, (unsigned long )(& ((ngx_http_upstream_headers_in_t *)0)->content_encoding),
      & ngx_http_upstream_copy_content_encoding, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                          ngx_table_elt_t *h , ngx_uint_t offset ))((void *)0),
      (ngx_uint_t )0, (ngx_int_t (*)(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                     ngx_uint_t offset ))((void *)0), (ngx_uint_t )0,
      (ngx_uint_t )0}};
#line 327 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_command_t ngx_http_upstream_commands[3]  = {      {{sizeof("upstream") - 1UL, (u_char *)"upstream"}, (ngx_uint_t )33554690, & ngx_http_upstream,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("server") - 1UL, (u_char *)"server"}, (ngx_uint_t )268437504, & ngx_http_upstream_server,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 347 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_http_module_t ngx_http_upstream_module_ctx  = 
#line 347
     {& ngx_http_upstream_add_variables, (ngx_int_t (*)(ngx_conf_t *cf ))((void *)0),
    & ngx_http_upstream_create_main_conf, & ngx_http_upstream_init_main_conf, (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0)};
#line 362 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
ngx_module_t ngx_http_upstream_module  = 
#line 362
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_upstream_module_ctx),
    ngx_http_upstream_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 378 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_http_variable_t ngx_http_upstream_vars[13]  = 
#line 378
  {      {{sizeof("upstream_addr") - 1UL, (u_char *)"upstream_addr"}, (void (*)(ngx_http_request_t *r ,
                                                                            ngx_http_variable_value_t *v ,
                                                                            uintptr_t data ))((void *)0),
      & ngx_http_upstream_addr_variable, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_status") - 1UL,
       (u_char *)"upstream_status"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ))((void *)0), & ngx_http_upstream_status_variable,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_connect_time") - 1UL, (u_char *)"upstream_connect_time"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_time_variable, (uintptr_t )2, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_header_time") - 1UL,
       (u_char *)"upstream_header_time"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_time_variable, (uintptr_t )1, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_response_time") - 1UL,
       (u_char *)"upstream_response_time"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_time_variable, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_response_length") - 1UL,
       (u_char *)"upstream_response_length"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                        uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_length_variable, (uintptr_t )0, (ngx_uint_t )2,
      (ngx_uint_t )0}, 
        {{sizeof("upstream_bytes_received") - 1UL, (u_char *)"upstream_bytes_received"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_upstream_response_length_variable, (uintptr_t )1, (ngx_uint_t )2,
      (ngx_uint_t )0}, 
        {{sizeof("upstream_cache_status") - 1UL, (u_char *)"upstream_cache_status"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_upstream_cache_status, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("upstream_cache_last_modified") - 1UL,
       (u_char *)"upstream_cache_last_modified"}, (void (*)(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ))((void *)0),
      & ngx_http_upstream_cache_last_modified, (uintptr_t )0, (ngx_uint_t )10, (ngx_uint_t )0}, 
        {{sizeof("upstream_cache_etag") - 1UL,
       (u_char *)"upstream_cache_etag"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ))((void *)0), & ngx_http_upstream_cache_etag,
      (uintptr_t )0, (ngx_uint_t )10, (ngx_uint_t )0}, 
        {{sizeof("upstream_http_") - 1UL, (u_char *)"upstream_http_"}, (void (*)(ngx_http_request_t *r ,
                                                                              ngx_http_variable_value_t *v ,
                                                                              uintptr_t data ))((void *)0),
      & ngx_http_upstream_header_variable, (uintptr_t )0, (ngx_uint_t )34, (ngx_uint_t )0}, 
        {{sizeof("upstream_cookie_") - 1UL,
       (u_char *)"upstream_cookie_"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ))((void *)0), & ngx_http_upstream_cookie_variable,
      (uintptr_t )0, (ngx_uint_t )34, (ngx_uint_t )0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ))((void *)0),
      (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 434 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_http_upstream_next_t ngx_http_upstream_next_errors[8]  = 
#line 434
  {      {(ngx_uint_t )500, (ngx_uint_t )16}, 
        {(ngx_uint_t )502, (ngx_uint_t )32}, 
        {(ngx_uint_t )503, (ngx_uint_t )64}, 
        {(ngx_uint_t )504, (ngx_uint_t )128}, 
        {(ngx_uint_t )403, (ngx_uint_t )256}, 
        {(ngx_uint_t )404, (ngx_uint_t )512}, 
        {(ngx_uint_t )429, (ngx_uint_t )1024}, 
        {(ngx_uint_t )0, (ngx_uint_t )0}};
#line 446 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
ngx_conf_bitmask_t ngx_http_upstream_cache_method_mask[4]  = {      {{sizeof("GET") - 1UL, (u_char *)"GET"}, (ngx_uint_t )2}, 
        {{sizeof("HEAD") - 1UL, (u_char *)"HEAD"}, (ngx_uint_t )4}, 
        {{sizeof("POST") - 1UL, (u_char *)"POST"}, (ngx_uint_t )8}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 454 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
ngx_conf_bitmask_t ngx_http_upstream_ignore_headers_masks[10]  = 
#line 454
  {      {{sizeof("X-Accel-Redirect") - 1UL, (u_char *)"X-Accel-Redirect"}, (ngx_uint_t )2}, 
        {{sizeof("X-Accel-Expires") - 1UL,
       (u_char *)"X-Accel-Expires"}, (ngx_uint_t )4}, 
        {{sizeof("X-Accel-Limit-Rate") - 1UL, (u_char *)"X-Accel-Limit-Rate"}, (ngx_uint_t )64}, 
        {{sizeof("X-Accel-Buffering") - 1UL,
       (u_char *)"X-Accel-Buffering"}, (ngx_uint_t )128}, 
        {{sizeof("X-Accel-Charset") - 1UL, (u_char *)"X-Accel-Charset"}, (ngx_uint_t )256}, 
        {{sizeof("Expires") - 1UL,
       (u_char *)"Expires"}, (ngx_uint_t )8}, 
        {{sizeof("Cache-Control") - 1UL, (u_char *)"Cache-Control"}, (ngx_uint_t )16}, 
        {{sizeof("Set-Cookie") - 1UL,
       (u_char *)"Set-Cookie"}, (ngx_uint_t )32}, 
        {{sizeof("Vary") - 1UL, (u_char *)"Vary"}, (ngx_uint_t )512}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 468 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
ngx_int_t ngx_http_upstream_create(ngx_http_request_t *r ) 
{ 
  ngx_http_upstream_t *u ;
  void *tmp ;

  {
#line 473
  u = r->upstream;
#line 475
  if (u) {
#line 475
    if (u->cleanup) {
      {
#line 476
      ((r->main)->count) ++;
#line 477
      ngx_http_upstream_cleanup((void *)r);
      }
    }
  }
  {
#line 480
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_upstream_t ));
#line 480
  u = (ngx_http_upstream_t *)tmp;
  }
#line 481
  if ((unsigned long )u == (unsigned long )((void *)0)) {
#line 482
    return ((ngx_int_t )-1);
  }
#line 485
  r->upstream = u;
#line 487
  u->peer.log = (r->connection)->log;
#line 488
  u->peer.log_error = 1U;
#line 491
  r->cache = (ngx_http_cache_t *)((void *)0);
#line 494
  u->headers_in.content_length_n = (off_t )-1;
#line 495
  u->headers_in.last_modified_time = (time_t )-1;
#line 497
  return ((ngx_int_t )0);
}
}
#line 501 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
void ngx_http_upstream_init(ngx_http_request_t *r ) 
{ 
  ngx_connection_t *c ;
  ngx_int_t tmp ;

  {
#line 506
  c = r->connection;
#line 518
  if ((c->read)->timer_set) {
    {
#line 519
    ngx_event_del_timer(c->read);
    }
  }
#line 522
  if (ngx_event_flags & 4UL) {
#line 524
    if (! (c->write)->active) {
      {
#line 525
      tmp = (*(ngx_event_actions.add))(c->write, (ngx_int_t )4, (ngx_uint_t )2147483648U);
      }
#line 525
      if (tmp == -1L) {
        {
#line 528
        ngx_http_finalize_request(r, (ngx_int_t )500);
        }
#line 529
        return;
      }
    }
  }
  {
#line 534
  ngx_http_upstream_init_request(r);
  }
#line 535
  return;
}
}
#line 538 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_init_request(ngx_http_request_t *r ) 
{ 
  ngx_str_t *host ;
  ngx_uint_t i ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t temp ;
  ngx_http_cleanup_t *cln ;
  ngx_http_upstream_t *u ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_srv_conf_t **uscfp ;
  ngx_http_upstream_main_conf_t *umcf ;
  ngx_int_t rc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 550
  if (r->aio) {
#line 551
    return;
  }
#line 554
  u = r->upstream;
#line 558
  if ((u->conf)->cache) {
    {
#line 561
    rc = ngx_http_upstream_cache(r, u);
    }
#line 563
    if (rc == -3L) {
#line 564
      r->write_event_handler = & ngx_http_upstream_init_request;
#line 565
      return;
    }
#line 568
    r->write_event_handler = & ngx_http_request_empty_handler;
#line 570
    if (rc == -1L) {
      {
#line 571
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
#line 572
      return;
    }
#line 575
    if (rc == 0L) {
      {
#line 576
      rc = ngx_http_upstream_cache_send(r, u);
      }
#line 578
      if (rc == -4L) {
#line 579
        return;
      }
#line 582
      if (rc == 40L) {
#line 583
        rc = (ngx_int_t )-5;
#line 584
        r->cached = 0U;
#line 585
        u->buffer.start = (u_char *)((void *)0);
#line 586
        u->cache_status = 1U;
#line 587
        u->request_sent = 1U;
      }
      {
#line 590
      tmp = ngx_http_upstream_cache_background_update(r, u);
      }
#line 590
      if (tmp != 0L) {
#line 591
        rc = (ngx_int_t )-1;
      }
    }
#line 595
    if (rc != -5L) {
      {
#line 596
      ngx_http_finalize_request(r, rc);
      }
#line 597
      return;
    }
  }
#line 603
  u->store = (unsigned int )(u->conf)->store;
#line 605
  if (! u->store) {
#line 605
    if (! r->post_action) {
#line 605
      if (! (u->conf)->ignore_client_abort) {
#line 606
        r->read_event_handler = & ngx_http_upstream_rd_check_broken_connection;
#line 607
        r->write_event_handler = & ngx_http_upstream_wr_check_broken_connection;
      }
    }
  }
#line 610
  if (r->request_body) {
#line 611
    u->request_bufs = (r->request_body)->bufs;
  }
  {
#line 614
  tmp___0 = (*(u->create_request))(r);
  }
#line 614
  if (tmp___0 != 0L) {
    {
#line 615
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 616
    return;
  }
  {
#line 619
  tmp___1 = ngx_http_upstream_set_local(r, u, (u->conf)->local);
  }
#line 619
  if (tmp___1 != 0L) {
    {
#line 620
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 621
    return;
  }
#line 624
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 626
  u->output.alignment = clcf->directio_alignment;
#line 627
  u->output.pool = r->pool;
#line 628
  u->output.bufs.num = (ngx_int_t )1;
#line 629
  u->output.bufs.size = clcf->client_body_buffer_size;
#line 631
  if ((unsigned long )u->output.output_filter == (unsigned long )((void *)0)) {
#line 632
    u->output.output_filter = & ngx_chain_writer;
#line 633
    u->output.filter_ctx = (void *)(& u->writer);
  }
#line 636
  u->writer.pool = r->pool;
#line 638
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
    {
#line 640
    r->upstream_states = ngx_array_create(r->pool, (ngx_uint_t )1, sizeof(ngx_http_upstream_state_t ));
    }
#line 642
    if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
      {
#line 643
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
#line 644
      return;
    }
  } else {
    {
#line 649
    tmp___2 = ngx_array_push(r->upstream_states);
#line 649
    u->state = (ngx_http_upstream_state_t *)tmp___2;
    }
#line 650
    if ((unsigned long )u->state == (unsigned long )((void *)0)) {
      {
#line 651
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 653
      return;
    }
    {
#line 656
    memset((void *)u->state, 0, sizeof(ngx_http_upstream_state_t ));
    }
  }
  {
#line 659
  cln = ngx_http_cleanup_add(r, (size_t )0);
  }
#line 660
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
    {
#line 661
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 662
    return;
  }
#line 665
  cln->handler = & ngx_http_upstream_cleanup;
#line 666
  cln->data = (void *)r;
#line 667
  u->cleanup = & cln->handler;
#line 669
  if ((unsigned long )u->resolved == (unsigned long )((void *)0)) {
#line 671
    uscf = (u->conf)->upstream;
  } else {
#line 679
    host = & (u->resolved)->host;
#line 681
    umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
#line 683
    uscfp = (ngx_http_upstream_srv_conf_t **)umcf->upstreams.elts;
#line 685
    i = (ngx_uint_t )0;
    {
#line 685
    while (1) {
      while_continue: /* CIL Label */ ;
#line 685
      if (! (i < umcf->upstreams.nelts)) {
#line 685
        goto while_break;
      }
#line 687
      uscf = *(uscfp + i);
#line 689
      if (uscf->host.len == host->len) {
#line 689
        if ((int )uscf->port == 0) {
#line 689
          if ((u->resolved)->no_port) {
#line 689
            goto _L;
          } else {
#line 689
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 689
        if ((int )uscf->port == (int )(u->resolved)->port) {
          _L: /* CIL Label */ 
          {
#line 689
          tmp___3 = ngx_strncasecmp(uscf->host.data, host->data, host->len);
          }
#line 689
          if (tmp___3 == 0L) {
#line 694
            goto found;
          }
        }
      }
#line 685
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 698
    if ((u->resolved)->sockaddr) {
#line 700
      if ((int )(u->resolved)->port == 0) {
#line 700
        if ((int )((u->resolved)->sockaddr)->sa_family != 1) {
#line 703
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 703
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no port in upstream \"%V\"",
                               host);
            }
          }
          {
#line 705
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
          }
#line 707
          return;
        }
      }
      {
#line 710
      tmp___4 = ngx_http_upstream_create_round_robin_peer(r, u->resolved);
      }
#line 710
      if (tmp___4 != 0L) {
        {
#line 713
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
        }
#line 715
        return;
      }
      {
#line 718
      ngx_http_upstream_connect(r, u);
      }
#line 720
      return;
    }
#line 723
    if ((int )(u->resolved)->port == 0) {
#line 724
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 724
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no port in upstream \"%V\"",
                           host);
        }
      }
      {
#line 726
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 728
      return;
    }
    {
#line 731
    temp.name = *host;
#line 733
    ctx = ngx_resolve_start(clcf->resolver, & temp);
    }
#line 734
    if ((unsigned long )ctx == (unsigned long )((void *)0)) {
      {
#line 735
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 737
      return;
    }
#line 740
    if ((unsigned long )ctx == (unsigned long )((void *)-1)) {
#line 741
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 741
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no resolver defined to resolve %V",
                           host);
        }
      }
      {
#line 744
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
      }
#line 745
      return;
    }
    {
#line 748
    ctx->name = *host;
#line 749
    ctx->handler = & ngx_http_upstream_resolve_handler;
#line 750
    ctx->data = (void *)r;
#line 751
    ctx->timeout = clcf->resolver_timeout;
#line 753
    (u->resolved)->ctx = ctx;
#line 755
    tmp___5 = ngx_resolve_name(ctx);
    }
#line 755
    if (tmp___5 != 0L) {
      {
#line 756
      (u->resolved)->ctx = (ngx_resolver_ctx_t *)((void *)0);
#line 757
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 759
      return;
    }
#line 762
    return;
  }
  found: 
#line 767
  if ((unsigned long )uscf == (unsigned long )((void *)0)) {
#line 768
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 768
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "no upstream configuration");
      }
    }
    {
#line 770
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 772
    return;
  }
  {
#line 775
  u->upstream = uscf;
#line 781
  tmp___6 = (*(uscf->peer.init))(r, uscf);
  }
#line 781
  if (tmp___6 != 0L) {
    {
#line 782
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 784
    return;
  }
#line 787
  u->peer.start_time = (ngx_msec_t )ngx_current_msec;
#line 789
  if ((u->conf)->next_upstream_tries) {
#line 789
    if (u->peer.tries > (u->conf)->next_upstream_tries) {
#line 792
      u->peer.tries = (u->conf)->next_upstream_tries;
    }
  }
  {
#line 795
  ngx_http_upstream_connect(r, u);
  }
#line 796
  return;
}
}
#line 801 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_int_t rc ;
  ngx_http_cache_t *c ;
  ngx_http_file_cache_t *cache ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp10 ;

  {
#line 808
  c = r->cache;
#line 810
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 812
    if (! (r->method & (u->conf)->cache_methods)) {
#line 813
      return ((ngx_int_t )-5);
    }
    {
#line 816
    rc = ngx_http_upstream_cache_get(r, u, & cache);
    }
#line 818
    if (rc != 0L) {
#line 819
      return (rc);
    }
#line 822
    if (r->method == 4UL) {
#line 822
      if ((u->conf)->cache_convert_head) {
#line 823
        u->method = ngx_http_core_get_method;
      }
    }
    {
#line 826
    tmp = ngx_http_file_cache_new(r);
    }
#line 826
    if (tmp != 0L) {
#line 827
      return ((ngx_int_t )-1);
    }
    {
#line 830
    tmp___0 = (*(u->create_key))(r);
    }
#line 830
    if (tmp___0 != 0L) {
#line 831
      return ((ngx_int_t )-1);
    }
    {
#line 836
    ngx_http_file_cache_create_key(r);
    }
#line 838
    if ((r->cache)->header_start + 256UL >= (u->conf)->buffer_size) {
#line 839
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 839
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%V_buffer_size %uz is not enough for cache key, it should be increased to at least %uz",
                           & (u->conf)->module, (u->conf)->buffer_size, (((r->cache)->header_start + 256UL) + 1023UL) & 0xfffffffffffffc00UL);
        }
      }
#line 845
      r->cache = (ngx_http_cache_t *)((void *)0);
#line 846
      return ((ngx_int_t )-5);
    }
    {
#line 849
    u->cacheable = 1U;
#line 851
    c = r->cache;
#line 853
    c->body_start = (u->conf)->buffer_size;
#line 854
    c->min_uses = (u->conf)->cache_min_uses;
#line 855
    c->file_cache = cache;
#line 857
    tmp___1 = ngx_http_test_predicates(r, (u->conf)->cache_bypass);
    }
    {
#line 859
    if (tmp___1 == -1L) {
#line 859
      goto case_neg_1;
    }
#line 862
    if (tmp___1 == -5L) {
#line 862
      goto case_neg_5;
    }
#line 866
    goto switch_default;
    case_neg_1: /* CIL Label */ 
#line 860
    return ((ngx_int_t )-1);
    case_neg_5: /* CIL Label */ 
#line 863
    u->cache_status = 2U;
#line 864
    return ((ngx_int_t )-5);
    switch_default: /* CIL Label */ 
#line 867
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 870
    c->lock = (unsigned int )(u->conf)->cache_lock;
#line 871
    c->lock_timeout = (u->conf)->cache_lock_timeout;
#line 872
    c->lock_age = (u->conf)->cache_lock_age;
#line 874
    u->cache_status = 1U;
  }
  {
#line 877
  rc = ngx_http_file_cache_open(r);
  }
  {
#line 884
  if (rc == 4L) {
#line 884
    goto case_4;
  }
#line 897
  if (rc == 5L) {
#line 897
    goto case_5;
  }
#line 911
  if (rc == 0L) {
#line 911
    goto case_0;
  }
#line 882
  goto switch_break___0;
  case_4: /* CIL Label */ 
#line 886
  if ((u->conf)->cache_use_stale & 2048UL) {
#line 886
    goto _L;
  } else
#line 886
  if (c->stale_updating) {
    _L: /* CIL Label */ 
#line 886
    if (! r->background) {
#line 886
      if ((u->conf)->cache_background_update) {
#line 890
        (r->cache)->background = 1U;
#line 891
        u->cache_status = (unsigned int )rc;
#line 892
        rc = (ngx_int_t )0;
      }
    }
  }
#line 895
  goto switch_break___0;
  case_5: /* CIL Label */ 
#line 899
  if ((u->conf)->cache_use_stale & 2048UL) {
#line 899
    goto _L___0;
  } else
#line 899
  if (c->stale_updating) {
    _L___0: /* CIL Label */ 
#line 899
    if (! r->background) {
#line 902
      u->cache_status = (unsigned int )rc;
#line 903
      rc = (ngx_int_t )0;
    } else {
#line 906
      rc = (ngx_int_t )4;
    }
  } else {
#line 906
    rc = (ngx_int_t )4;
  }
#line 909
  goto switch_break___0;
  case_0: /* CIL Label */ 
#line 912
  u->cache_status = 7U;
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 917
  if (rc == 0L) {
#line 917
    goto case_0___0;
  }
#line 921
  if (rc == 4L) {
#line 921
    goto case_4___0;
  }
#line 932
  if (rc == -5L) {
#line 932
    goto case_neg_5___0;
  }
#line 944
  if (rc == 8L) {
#line 944
    goto case_8;
  }
#line 950
  if (rc == -2L) {
#line 950
    goto case_neg_2;
  }
#line 954
  if (rc == -1L) {
#line 954
    goto case_neg_1___0;
  }
#line 958
  goto switch_default___0;
  case_0___0: /* CIL Label */ 
#line 919
  return ((ngx_int_t )0);
  case_4___0: /* CIL Label */ 
#line 923
  c->valid_sec = (time_t )0;
#line 924
  c->updating_sec = (time_t )0;
#line 925
  c->error_sec = (time_t )0;
#line 927
  u->buffer.start = (u_char *)((void *)0);
#line 928
  u->cache_status = 3U;
#line 930
  goto switch_break___1;
  case_neg_5___0: /* CIL Label */ 
#line 934
  if ((size_t )(u->buffer.end - u->buffer.start) < (u->conf)->buffer_size) {
#line 935
    u->buffer.start = (u_char *)((void *)0);
  } else {
#line 938
    u->buffer.pos = u->buffer.start + c->header_start;
#line 939
    u->buffer.last = u->buffer.pos;
  }
#line 942
  goto switch_break___1;
  case_8: /* CIL Label */ 
#line 946
  u->cacheable = 0U;
#line 948
  goto switch_break___1;
  case_neg_2: /* CIL Label */ 
#line 952
  return ((ngx_int_t )-3);
  case_neg_1___0: /* CIL Label */ 
#line 956
  return ((ngx_int_t )-1);
  switch_default___0: /* CIL Label */ 
#line 962
  u->cache_status = 7U;
#line 964
  return (rc);
  switch_break___1: /* CIL Label */ ;
  }
  {
#line 967
  tmp___2 = ngx_http_upstream_cache_check_range(r, u);
  }
#line 967
  if (tmp___2 == -5L) {
#line 968
    u->cacheable = 0U;
  }
#line 971
  r->cached = 0U;
#line 973
  return ((ngx_int_t )-5);
}
}
#line 977 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_get(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                             ngx_http_file_cache_t **cache ) 
{ 
  ngx_str_t *name ;
  ngx_str_t val ;
  ngx_uint_t i ;
  ngx_http_file_cache_t **caches ;
  ngx_int_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;

  {
#line 985
  if ((u->conf)->cache_zone) {
#line 986
    *cache = (ngx_http_file_cache_t *)((u->conf)->cache_zone)->data;
#line 987
    return ((ngx_int_t )0);
  }
  {
#line 990
  tmp = ngx_http_complex_value(r, (u->conf)->cache_value, & val);
  }
#line 990
  if (tmp != 0L) {
#line 991
    return ((ngx_int_t )-1);
  }
#line 994
  if (val.len == 0UL) {
#line 997
    return ((ngx_int_t )-5);
  } else
#line 994
  if (val.len == 3UL) {
    {
#line 994
    tmp___0 = strncmp((char const   *)val.data, "off", (size_t )3);
    }
#line 994
    if (tmp___0 == 0) {
#line 997
      return ((ngx_int_t )-5);
    }
  }
#line 1000
  caches = (ngx_http_file_cache_t **)(u->caches)->elts;
#line 1002
  i = (ngx_uint_t )0;
  {
#line 1002
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1002
    if (! (i < (u->caches)->nelts)) {
#line 1002
      goto while_break;
    }
#line 1003
    name = & ((*(caches + i))->shm_zone)->shm.name;
#line 1005
    if (name->len == val.len) {
      {
#line 1005
      tmp___1 = strncmp((char const   *)name->data, (char const   *)val.data, val.len);
      }
#line 1005
      if (tmp___1 == 0) {
#line 1008
        *cache = *(caches + i);
#line 1009
        return ((ngx_int_t )0);
      }
    }
#line 1002
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 1013
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "cache \"%V\" not found",
                       & val);
    }
  }
#line 1016
  return ((ngx_int_t )-1);
}
}
#line 1020 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_send(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_int_t rc ;
  ngx_http_cache_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 1026
  r->cached = 1U;
#line 1027
  c = r->cache;
#line 1029
  if (c->header_start == c->body_start) {
    {
#line 1030
    r->http_version = (ngx_uint_t )9;
#line 1031
    tmp = ngx_http_cache_send(r);
    }
#line 1031
    return (tmp);
  }
  {
#line 1036
  u->buffer = *(c->buf);
#line 1037
  u->buffer.pos += c->header_start;
#line 1039
  memset((void *)(& u->headers_in), 0, sizeof(ngx_http_upstream_headers_in_t ));
#line 1040
  u->headers_in.content_length_n = (off_t )-1;
#line 1041
  u->headers_in.last_modified_time = (time_t )-1;
#line 1043
  tmp___0 = ngx_list_init(& u->headers_in.headers, r->pool, (ngx_uint_t )8, sizeof(ngx_table_elt_t ));
  }
#line 1043
  if (tmp___0 != 0L) {
#line 1047
    return ((ngx_int_t )-1);
  }
  {
#line 1050
  rc = (*(u->process_header))(r);
  }
#line 1052
  if (rc == 0L) {
    {
#line 1054
    tmp___1 = ngx_http_upstream_process_headers(r, u);
    }
#line 1054
    if (tmp___1 != 0L) {
#line 1055
      return ((ngx_int_t )-4);
    }
    {
#line 1058
    tmp___2 = ngx_http_cache_send(r);
    }
#line 1058
    return (tmp___2);
  }
#line 1061
  if (rc == -1L) {
#line 1062
    return ((ngx_int_t )-1);
  }
#line 1065
  if (rc == -2L) {
#line 1066
    rc = (ngx_int_t )40;
  }
#line 1071
  if (((r->connection)->log)->log_level >= 3UL) {
    {
#line 1071
    ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "cache file \"%s\" contains invalid header",
                       c->file.name.data);
    }
  }
#line 1077
  return (rc);
}
}
#line 1081 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_background_update(ngx_http_request_t *r ,
                                                           ngx_http_upstream_t *u ) 
{ 
  ngx_http_request_t *sr ;
  ngx_int_t tmp ;

  {
#line 1087
  if (! r->cached) {
#line 1088
    return ((ngx_int_t )0);
  } else
#line 1087
  if (! (r->cache)->background) {
#line 1088
    return ((ngx_int_t )0);
  }
#line 1091
  if ((unsigned long )r == (unsigned long )r->main) {
#line 1092
    r->preserve_body = 1U;
  }
  {
#line 1095
  tmp = ngx_http_subrequest(r, & r->uri, & r->args, & sr, (ngx_http_post_subrequest_t *)((void *)0),
                            (ngx_uint_t )24);
  }
#line 1095
  if (tmp != 0L) {
#line 1100
    return ((ngx_int_t )-1);
  }
#line 1103
  sr->header_only = 1U;
#line 1105
  return ((ngx_int_t )0);
}
}
#line 1109 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_check_range(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  off_t offset ;
  u_char *p ;
  u_char *start ;
  ngx_table_elt_t *h ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;

  {
#line 1117
  h = r->headers_in.range;
#line 1119
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1123
    return ((ngx_int_t )0);
  } else
#line 1119
  if (! u->cacheable) {
#line 1123
    return ((ngx_int_t )0);
  } else
#line 1119
  if ((long long )(u->conf)->cache_max_range_offset == 9223372036854775807LL) {
#line 1123
    return ((ngx_int_t )0);
  }
#line 1126
  if ((u->conf)->cache_max_range_offset == 0L) {
#line 1127
    return ((ngx_int_t )-5);
  }
#line 1130
  if (h->value.len < 7UL) {
#line 1133
    return ((ngx_int_t )0);
  } else {
    {
#line 1130
    tmp = ngx_strncasecmp(h->value.data, (u_char *)"bytes=", (size_t )6);
    }
#line 1130
    if (tmp != 0L) {
#line 1133
      return ((ngx_int_t )0);
    }
  }
#line 1136
  p = h->value.data + 6;
  {
#line 1138
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1138
    if (! ((int )*p == 32)) {
#line 1138
      goto while_break;
    }
#line 1138
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1140
  if ((int )*p == 45) {
#line 1141
    return ((ngx_int_t )-5);
  }
#line 1144
  start = p;
  {
#line 1146
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1146
    if ((int )*p >= 48) {
#line 1146
      if (! ((int )*p <= 57)) {
#line 1146
        goto while_break___0;
      }
    } else {
#line 1146
      goto while_break___0;
    }
#line 1146
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1148
  offset = ngx_atoof(start, (size_t )(p - start));
  }
#line 1150
  if (offset >= (u->conf)->cache_max_range_offset) {
#line 1151
    return ((ngx_int_t )-5);
  }
#line 1154
  return ((ngx_int_t )0);
}
}
#line 1160 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_resolve_handler(ngx_resolver_ctx_t *ctx ) 
{ 
  ngx_uint_t run_posted ;
  ngx_connection_t *c ;
  ngx_http_request_t *r ;
  ngx_http_upstream_t *u ;
  ngx_http_upstream_resolved_t *ur ;
  char *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 1169
  run_posted = (ngx_uint_t )ctx->async;
#line 1171
  r = (ngx_http_request_t *)ctx->data;
#line 1172
  c = r->connection;
#line 1174
  u = r->upstream;
#line 1175
  ur = u->resolved;
#line 1177
  ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 1182
  if (ctx->state) {
#line 1183
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1183
      tmp = ngx_resolver_strerror(ctx->state);
#line 1183
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "%V could not be resolved (%i: %s)",
                         & ctx->name, ctx->state, tmp);
      }
    }
    {
#line 1188
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
    }
#line 1189
    goto failed;
  }
  {
#line 1192
  ur->naddrs = ctx->naddrs;
#line 1193
  ur->addrs = ctx->addrs;
#line 1213
  tmp___0 = ngx_http_upstream_create_round_robin_peer(r, ur);
  }
#line 1213
  if (tmp___0 != 0L) {
    {
#line 1214
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 1216
    goto failed;
  }
  {
#line 1219
  ngx_resolve_name_done(ctx);
#line 1220
  ur->ctx = (ngx_resolver_ctx_t *)((void *)0);
#line 1222
  u->peer.start_time = (ngx_msec_t )ngx_current_msec;
  }
#line 1224
  if ((u->conf)->next_upstream_tries) {
#line 1224
    if (u->peer.tries > (u->conf)->next_upstream_tries) {
#line 1227
      u->peer.tries = (u->conf)->next_upstream_tries;
    }
  }
  {
#line 1230
  ngx_http_upstream_connect(r, u);
  }
  failed: 
#line 1234
  if (run_posted) {
    {
#line 1235
    ngx_http_run_posted_requests(c);
    }
  }
#line 1237
  return;
}
}
#line 1240 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_handler(ngx_event_t *ev ) 
{ 
  ngx_connection_t *c ;
  ngx_http_request_t *r ;
  ngx_http_upstream_t *u ;

  {
#line 1247
  c = (ngx_connection_t *)ev->data;
#line 1248
  r = (ngx_http_request_t *)c->data;
#line 1250
  u = r->upstream;
#line 1251
  c = r->connection;
#line 1253
  ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 1258
  if (ev->delayed) {
#line 1258
    if (ev->timedout) {
#line 1259
      ev->delayed = 0U;
#line 1260
      ev->timedout = 0U;
    }
  }
#line 1263
  if (ev->write) {
    {
#line 1264
    (*(u->write_event_handler))(r, u);
    }
  } else {
    {
#line 1267
    (*(u->read_event_handler))(r, u);
    }
  }
  {
#line 1270
  ngx_http_run_posted_requests(c);
  }
#line 1271
  return;
}
}
#line 1274 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_rd_check_broken_connection(ngx_http_request_t *r ) 
{ 


  {
  {
#line 1277
  ngx_http_upstream_check_broken_connection(r, (r->connection)->read);
  }
#line 1278
  return;
}
}
#line 1281 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_wr_check_broken_connection(ngx_http_request_t *r ) 
{ 


  {
  {
#line 1284
  ngx_http_upstream_check_broken_connection(r, (r->connection)->write);
  }
#line 1285
  return;
}
}
#line 1288 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_check_broken_connection(ngx_http_request_t *r , ngx_event_t *ev ) 
{ 
  int n ;
  char buf[1] ;
  ngx_err_t err ;
  ngx_int_t event ;
  ngx_connection_t *c ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  socklen_t len ;
  int *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int *tmp___3 ;
  ngx_int_t tmp___4 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1303
  c = r->connection;
#line 1304
  u = r->upstream;
#line 1306
  if (c->error) {
#line 1307
    if (ngx_event_flags & 1UL) {
#line 1307
      if (ev->active) {
#line 1309
        if (ev->write) {
#line 1309
          event = (ngx_int_t )4;
        } else {
#line 1309
          event = (ngx_int_t )8193;
        }
        {
#line 1311
        tmp = (*(ngx_event_actions.del))(ev, event, (ngx_uint_t )0);
        }
#line 1311
        if (tmp != 0L) {
          {
#line 1312
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
          }
#line 1314
          return;
        }
      }
    }
#line 1318
    if (! u->cacheable) {
      {
#line 1319
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
      }
    }
#line 1323
    return;
  }
#line 1372
  if (ngx_event_flags & 64UL) {
#line 1372
    if (ngx_use_epoll_rdhup) {
#line 1375
      if (! ev->pending_eof) {
#line 1376
        return;
      }
      {
#line 1379
      ev->eof = 1U;
#line 1380
      c->error = 1U;
#line 1382
      err = 0;
#line 1383
      len = (socklen_t )sizeof(ngx_err_t );
#line 1390
      tmp___1 = getsockopt(c->fd, 1, 4, (void */* __restrict  */)((void *)(& err)),
                           (socklen_t */* __restrict  */)(& len));
      }
#line 1390
      if (tmp___1 == -1) {
        {
#line 1393
        tmp___0 = __errno_location();
#line 1393
        err = *tmp___0;
        }
      }
#line 1396
      if (err) {
#line 1397
        ev->error = 1U;
      }
#line 1400
      if (! u->cacheable) {
#line 1400
        if (u->peer.connection) {
#line 1401
          if ((ev->log)->log_level >= 7UL) {
            {
#line 1401
            ngx_log_error_core((ngx_uint_t )7, ev->log, err, "epoll_wait() reported that client prematurely closed connection, so upstream connection is closed too");
            }
          }
          {
#line 1404
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
          }
#line 1406
          return;
        }
      }
#line 1409
      if ((ev->log)->log_level >= 7UL) {
        {
#line 1409
        ngx_log_error_core((ngx_uint_t )7, ev->log, err, "epoll_wait() reported that client prematurely closed connection");
        }
      }
#line 1413
      if ((unsigned long )u->peer.connection == (unsigned long )((void *)0)) {
        {
#line 1414
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
        }
      }
#line 1418
      return;
    }
  }
  {
#line 1423
  tmp___2 = recv(c->fd, (void *)(buf), (size_t )1, 2);
#line 1423
  n = (int )tmp___2;
#line 1425
  tmp___3 = __errno_location();
#line 1425
  err = *tmp___3;
  }
#line 1430
  if (ev->write) {
#line 1430
    if (n >= 0) {
#line 1431
      return;
    } else
#line 1430
    if (err == 11) {
#line 1431
      return;
    }
  }
#line 1434
  if (ngx_event_flags & 1UL) {
#line 1434
    if (ev->active) {
#line 1436
      if (ev->write) {
#line 1436
        event = (ngx_int_t )4;
      } else {
#line 1436
        event = (ngx_int_t )8193;
      }
      {
#line 1438
      tmp___4 = (*(ngx_event_actions.del))(ev, event, (ngx_uint_t )0);
      }
#line 1438
      if (tmp___4 != 0L) {
        {
#line 1439
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
        }
#line 1441
        return;
      }
    }
  }
#line 1445
  if (n > 0) {
#line 1446
    return;
  }
#line 1449
  if (n == -1) {
#line 1450
    if (err == 11) {
#line 1451
      return;
    }
#line 1454
    ev->error = 1U;
  } else {
#line 1457
    err = 0;
  }
#line 1460
  ev->eof = 1U;
#line 1461
  c->error = 1U;
#line 1463
  if (! u->cacheable) {
#line 1463
    if (u->peer.connection) {
#line 1464
      if ((ev->log)->log_level >= 7UL) {
        {
#line 1464
        ngx_log_error_core((ngx_uint_t )7, ev->log, err, "client prematurely closed connection, so upstream connection is closed too");
        }
      }
      {
#line 1467
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
      }
#line 1469
      return;
    }
  }
#line 1472
  if ((ev->log)->log_level >= 7UL) {
    {
#line 1472
    ngx_log_error_core((ngx_uint_t )7, ev->log, err, "client prematurely closed connection");
    }
  }
#line 1475
  if ((unsigned long )u->peer.connection == (unsigned long )((void *)0)) {
    {
#line 1476
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
    }
  }
#line 1479
  return;
}
}
#line 1482 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_connect(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_int_t rc ;
  ngx_connection_t *c ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1488
  ((r->connection)->log)->action = (char *)"connecting to upstream";
#line 1490
  if (u->state) {
#line 1490
    if ((u->state)->response_time) {
#line 1491
      (u->state)->response_time = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )(u->state)->response_time);
    }
  }
  {
#line 1494
  tmp = ngx_array_push(r->upstream_states);
#line 1494
  u->state = (ngx_http_upstream_state_t *)tmp;
  }
#line 1495
  if ((unsigned long )u->state == (unsigned long )((void *)0)) {
    {
#line 1496
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 1498
    return;
  }
  {
#line 1501
  memset((void *)u->state, 0, sizeof(ngx_http_upstream_state_t ));
#line 1503
  (u->state)->response_time = (ngx_msec_t )ngx_current_msec;
#line 1504
  (u->state)->connect_time = (ngx_msec_t )-1;
#line 1505
  (u->state)->header_time = (ngx_msec_t )-1;
#line 1507
  rc = ngx_event_connect_peer(& u->peer);
  }
#line 1512
  if (rc == -1L) {
    {
#line 1513
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 1515
    return;
  }
#line 1518
  (u->state)->peer = u->peer.name;
#line 1520
  if (rc == -3L) {
#line 1521
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1521
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no live upstreams");
      }
    }
    {
#line 1522
    ngx_http_upstream_next(r, u, (ngx_uint_t )1073741824);
    }
#line 1523
    return;
  }
#line 1526
  if (rc == -5L) {
    {
#line 1527
    ngx_http_upstream_next(r, u, (ngx_uint_t )2);
    }
#line 1528
    return;
  }
#line 1533
  c = u->peer.connection;
#line 1535
  c->data = (void *)r;
#line 1537
  (c->write)->handler = & ngx_http_upstream_handler;
#line 1538
  (c->read)->handler = & ngx_http_upstream_handler;
#line 1540
  u->write_event_handler = & ngx_http_upstream_send_request_handler;
#line 1541
  u->read_event_handler = & ngx_http_upstream_process_header;
#line 1543
  c->sendfile &= (r->connection)->sendfile;
#line 1544
  u->output.sendfile = c->sendfile;
#line 1546
  if ((unsigned long )c->pool == (unsigned long )((void *)0)) {
    {
#line 1550
    c->pool = ngx_create_pool((size_t )128, (r->connection)->log);
    }
#line 1551
    if ((unsigned long )c->pool == (unsigned long )((void *)0)) {
      {
#line 1552
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 1554
      return;
    }
  }
#line 1558
  c->log = (r->connection)->log;
#line 1559
  (c->pool)->log = c->log;
#line 1560
  (c->read)->log = c->log;
#line 1561
  (c->write)->log = c->log;
#line 1565
  u->writer.out = (ngx_chain_t *)((void *)0);
#line 1566
  u->writer.last = & u->writer.out;
#line 1567
  u->writer.connection = c;
#line 1568
  u->writer.limit = (off_t )0;
#line 1570
  if (u->request_sent) {
    {
#line 1571
    tmp___0 = ngx_http_upstream_reinit(r, u);
    }
#line 1571
    if (tmp___0 != 0L) {
      {
#line 1572
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 1574
      return;
    }
  }
#line 1578
  if (r->request_body) {
#line 1578
    if ((r->request_body)->buf) {
#line 1578
      if ((r->request_body)->temp_file) {
#line 1578
        if ((unsigned long )r == (unsigned long )r->main) {
          {
#line 1588
          u->output.free = ngx_alloc_chain_link(r->pool);
          }
#line 1589
          if ((unsigned long )u->output.free == (unsigned long )((void *)0)) {
            {
#line 1590
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
            }
#line 1592
            return;
          }
#line 1595
          (u->output.free)->buf = (r->request_body)->buf;
#line 1596
          (u->output.free)->next = (ngx_chain_t *)((void *)0);
#line 1597
          u->output.allocated = (ngx_int_t )1;
#line 1599
          ((r->request_body)->buf)->pos = ((r->request_body)->buf)->start;
#line 1600
          ((r->request_body)->buf)->last = ((r->request_body)->buf)->start;
#line 1601
          ((r->request_body)->buf)->tag = u->output.tag;
        }
      }
    }
  }
#line 1604
  u->request_sent = 0U;
#line 1605
  u->request_body_sent = 0U;
#line 1607
  if (rc == -2L) {
    {
#line 1608
    ngx_event_add_timer(c->write, (u->conf)->connect_timeout);
    }
#line 1609
    return;
  }
  {
#line 1621
  ngx_http_upstream_send_request(r, u, (ngx_uint_t )1);
  }
#line 1622
  return;
}
}
#line 1863 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_reinit(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  off_t file_pos ;
  ngx_chain_t *cl ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1869
  tmp = (*(u->reinit_request))(r);
  }
#line 1869
  if (tmp != 0L) {
#line 1870
    return ((ngx_int_t )-1);
  }
  {
#line 1873
  u->keepalive = 0U;
#line 1874
  u->upgrade = 0U;
#line 1876
  memset((void *)(& u->headers_in), 0, sizeof(ngx_http_upstream_headers_in_t ));
#line 1877
  u->headers_in.content_length_n = (off_t )-1;
#line 1878
  u->headers_in.last_modified_time = (time_t )-1;
#line 1880
  tmp___0 = ngx_list_init(& u->headers_in.headers, r->pool, (ngx_uint_t )8, sizeof(ngx_table_elt_t ));
  }
#line 1880
  if (tmp___0 != 0L) {
#line 1884
    return ((ngx_int_t )-1);
  }
#line 1889
  file_pos = (off_t )0;
#line 1891
  cl = u->request_bufs;
  {
#line 1891
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1891
    if (! cl) {
#line 1891
      goto while_break;
    }
#line 1892
    (cl->buf)->pos = (cl->buf)->start;
#line 1896
    if ((cl->buf)->in_file) {
#line 1897
      (cl->buf)->file_pos = file_pos;
#line 1898
      file_pos = (cl->buf)->file_last;
    }
#line 1891
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1904
  if (r->request_body) {
#line 1904
    if ((r->request_body)->temp_file) {
#line 1904
      if ((unsigned long )r != (unsigned long )r->main) {
#line 1904
        if (u->output.buf) {
          {
#line 1907
          u->output.free = ngx_alloc_chain_link(r->pool);
          }
#line 1908
          if ((unsigned long )u->output.free == (unsigned long )((void *)0)) {
#line 1909
            return ((ngx_int_t )-1);
          }
#line 1912
          (u->output.free)->buf = u->output.buf;
#line 1913
          (u->output.free)->next = (ngx_chain_t *)((void *)0);
#line 1915
          (u->output.buf)->pos = (u->output.buf)->start;
#line 1916
          (u->output.buf)->last = (u->output.buf)->start;
        }
      }
    }
  }
#line 1919
  u->output.buf = (ngx_buf_t *)((void *)0);
#line 1920
  u->output.in = (ngx_chain_t *)((void *)0);
#line 1921
  u->output.busy = (ngx_chain_t *)((void *)0);
#line 1925
  u->buffer.pos = u->buffer.start;
#line 1929
  if (r->cache) {
#line 1930
    u->buffer.pos += (r->cache)->header_start;
  }
#line 1935
  u->buffer.last = u->buffer.pos;
#line 1937
  return ((ngx_int_t )0);
}
}
#line 1941 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_send_request(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                           ngx_uint_t do_write ) 
{ 
  ngx_int_t rc ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1948
  c = u->peer.connection;
#line 1953
  if ((u->state)->connect_time == 0xffffffffffffffffUL) {
#line 1954
    (u->state)->connect_time = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )(u->state)->response_time);
  }
#line 1957
  if (! u->request_sent) {
    {
#line 1957
    tmp = ngx_http_upstream_test_connect(c);
    }
#line 1957
    if (tmp != 0L) {
      {
#line 1958
      ngx_http_upstream_next(r, u, (ngx_uint_t )2);
      }
#line 1959
      return;
    }
  }
  {
#line 1962
  (c->log)->action = (char *)"sending request to upstream";
#line 1964
  rc = ngx_http_upstream_send_request_body(r, u, do_write);
  }
#line 1966
  if (rc == -1L) {
    {
#line 1967
    ngx_http_upstream_next(r, u, (ngx_uint_t )2);
    }
#line 1968
    return;
  }
#line 1971
  if (rc >= 300L) {
    {
#line 1972
    ngx_http_upstream_finalize_request(r, u, rc);
    }
#line 1973
    return;
  }
#line 1976
  if (rc == -2L) {
#line 1977
    if (! (c->write)->ready) {
      {
#line 1978
      ngx_event_add_timer(c->write, (u->conf)->send_timeout);
      }
    } else
#line 1980
    if ((c->write)->timer_set) {
      {
#line 1981
      ngx_event_del_timer(c->write);
      }
    }
    {
#line 1984
    tmp___0 = ngx_handle_write_event(c->write, (u->conf)->send_lowat);
    }
#line 1984
    if (tmp___0 != 0L) {
      {
#line 1985
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 1987
      return;
    }
#line 1990
    return;
  }
#line 1995
  u->request_body_sent = 1U;
#line 1997
  if ((c->write)->timer_set) {
    {
#line 1998
    ngx_event_del_timer(c->write);
    }
  }
#line 2001
  if (c->tcp_nopush == 1U) {
    {
#line 2002
    tmp___2 = ngx_tcp_push(c->fd);
    }
#line 2002
    if (tmp___2 == -1) {
#line 2003
      if ((c->log)->log_level >= 3UL) {
        {
#line 2003
        tmp___1 = __errno_location();
#line 2003
        ngx_log_error_core((ngx_uint_t )3, c->log, *tmp___1, "setsockopt(!TCP_CORK) failed");
        }
      }
      {
#line 2005
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 2007
      return;
    }
#line 2010
    c->tcp_nopush = 0U;
  }
  {
#line 2013
  u->write_event_handler = & ngx_http_upstream_dummy_handler;
#line 2015
  tmp___3 = ngx_handle_write_event(c->write, (size_t )0);
  }
#line 2015
  if (tmp___3 != 0L) {
    {
#line 2016
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 2018
    return;
  }
  {
#line 2021
  ngx_event_add_timer(c->read, (u->conf)->read_timeout);
  }
#line 2023
  if ((c->read)->ready) {
    {
#line 2024
    ngx_http_upstream_process_header(r, u);
    }
#line 2025
    return;
  }
#line 2027
  return;
}
}
#line 2030 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_send_request_body(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                                     ngx_uint_t do_write ) 
{ 
  ngx_int_t rc ;
  ngx_chain_t *out ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 2042
  if (! r->request_body_no_buffering) {
#line 2046
    if (! u->request_sent) {
#line 2047
      u->request_sent = 1U;
#line 2048
      out = u->request_bufs;
    } else {
#line 2051
      out = (ngx_chain_t *)((void *)0);
    }
    {
#line 2054
    tmp = ngx_output_chain(& u->output, out);
    }
#line 2054
    return (tmp);
  }
#line 2057
  if (! u->request_sent) {
#line 2058
    u->request_sent = 1U;
#line 2059
    out = u->request_bufs;
#line 2061
    if ((r->request_body)->bufs) {
#line 2062
      cl = out;
      {
#line 2062
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2062
        if (! cl->next) {
#line 2062
          goto while_break;
        }
#line 2062
        cl = out->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 2063
      cl->next = (r->request_body)->bufs;
#line 2064
      (r->request_body)->bufs = (ngx_chain_t *)((void *)0);
    }
#line 2067
    c = u->peer.connection;
#line 2068
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2070
    if (clcf->tcp_nodelay) {
      {
#line 2070
      tmp___0 = ngx_tcp_nodelay(c);
      }
#line 2070
      if (tmp___0 != 0L) {
#line 2071
        return ((ngx_int_t )-1);
      }
    }
#line 2074
    r->read_event_handler = & ngx_http_upstream_read_request_handler;
  } else {
#line 2077
    out = (ngx_chain_t *)((void *)0);
  }
  {
#line 2080
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2082
    if (do_write) {
      {
#line 2083
      rc = ngx_output_chain(& u->output, out);
      }
#line 2085
      if (rc == -1L) {
#line 2086
        return ((ngx_int_t )-1);
      }
      {
#line 2089
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2089
        if (! out) {
#line 2089
          goto while_break___1;
        }
#line 2090
        ln = out;
#line 2091
        out = out->next;
#line 2092
        ln->next = (r->pool)->chain;
#line 2092
        (r->pool)->chain = ln;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 2095
      if (rc == 0L) {
#line 2095
        if (! r->reading_body) {
#line 2096
          goto while_break___0;
        }
      }
    }
#line 2100
    if (r->reading_body) {
      {
#line 2103
      rc = ngx_http_read_unbuffered_request_body(r);
      }
#line 2105
      if (rc >= 300L) {
#line 2106
        return (rc);
      }
#line 2109
      out = (r->request_body)->bufs;
#line 2110
      (r->request_body)->bufs = (ngx_chain_t *)((void *)0);
    }
#line 2115
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 2116
      rc = (ngx_int_t )-2;
#line 2117
      goto while_break___0;
    }
#line 2120
    do_write = (ngx_uint_t )1;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2123
  if (! r->reading_body) {
#line 2124
    if (! u->store) {
#line 2124
      if (! r->post_action) {
#line 2124
        if (! (u->conf)->ignore_client_abort) {
#line 2125
          r->read_event_handler = & ngx_http_upstream_rd_check_broken_connection;
        }
      }
    }
  }
#line 2130
  return (rc);
}
}
#line 2134 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_send_request_handler(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_connection_t *c ;

  {
#line 2140
  c = u->peer.connection;
#line 2145
  if ((c->write)->timedout) {
    {
#line 2146
    ngx_http_upstream_next(r, u, (ngx_uint_t )4);
    }
#line 2147
    return;
  }
#line 2159
  if (u->header_sent) {
    {
#line 2160
    u->write_event_handler = & ngx_http_upstream_dummy_handler;
#line 2162
    ngx_handle_write_event(c->write, (size_t )0);
    }
#line 2164
    return;
  }
  {
#line 2167
  ngx_http_upstream_send_request(r, u, (ngx_uint_t )1);
  }
#line 2168
  return;
}
}
#line 2171 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_read_request_handler(ngx_http_request_t *r ) 
{ 
  ngx_connection_t *c ;
  ngx_http_upstream_t *u ;

  {
#line 2177
  c = r->connection;
#line 2178
  u = r->upstream;
#line 2183
  if ((c->read)->timedout) {
    {
#line 2184
    c->timedout = 1U;
#line 2185
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )408);
    }
#line 2186
    return;
  }
  {
#line 2189
  ngx_http_upstream_send_request(r, u, (ngx_uint_t )0);
  }
#line 2190
  return;
}
}
#line 2193 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_header(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ssize_t n ;
  ngx_int_t rc ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 2200
  c = u->peer.connection;
#line 2205
  (c->log)->action = (char *)"reading response header from upstream";
#line 2207
  if ((c->read)->timedout) {
    {
#line 2208
    ngx_http_upstream_next(r, u, (ngx_uint_t )4);
    }
#line 2209
    return;
  }
#line 2212
  if (! u->request_sent) {
    {
#line 2212
    tmp = ngx_http_upstream_test_connect(c);
    }
#line 2212
    if (tmp != 0L) {
      {
#line 2213
      ngx_http_upstream_next(r, u, (ngx_uint_t )2);
      }
#line 2214
      return;
    }
  }
#line 2217
  if ((unsigned long )u->buffer.start == (unsigned long )((void *)0)) {
    {
#line 2218
    tmp___0 = ngx_palloc(r->pool, (u->conf)->buffer_size);
#line 2218
    u->buffer.start = (u_char *)tmp___0;
    }
#line 2219
    if ((unsigned long )u->buffer.start == (unsigned long )((void *)0)) {
      {
#line 2220
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 2222
      return;
    }
    {
#line 2225
    u->buffer.pos = u->buffer.start;
#line 2226
    u->buffer.last = u->buffer.start;
#line 2227
    u->buffer.end = u->buffer.start + (u->conf)->buffer_size;
#line 2228
    u->buffer.temporary = 1U;
#line 2230
    u->buffer.tag = u->output.tag;
#line 2232
    tmp___1 = ngx_list_init(& u->headers_in.headers, r->pool, (ngx_uint_t )8, sizeof(ngx_table_elt_t ));
    }
#line 2232
    if (tmp___1 != 0L) {
      {
#line 2236
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 2238
      return;
    }
#line 2243
    if (r->cache) {
#line 2244
      u->buffer.pos += (r->cache)->header_start;
#line 2245
      u->buffer.last = u->buffer.pos;
    }
  }
  {
#line 2250
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2252
    n = (*(c->recv))(c, u->buffer.last, (size_t )(u->buffer.end - u->buffer.last));
    }
#line 2254
    if (n == -2L) {
      {
#line 2259
      tmp___2 = ngx_handle_read_event(c->read, (ngx_uint_t )0);
      }
#line 2259
      if (tmp___2 != 0L) {
        {
#line 2260
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
        }
#line 2262
        return;
      }
#line 2265
      return;
    }
#line 2268
    if (n == 0L) {
#line 2269
      if ((c->log)->log_level >= 4UL) {
        {
#line 2269
        ngx_log_error_core((ngx_uint_t )4, c->log, 0, "upstream prematurely closed connection");
        }
      }
    }
#line 2273
    if (n == -1L) {
      {
#line 2274
      ngx_http_upstream_next(r, u, (ngx_uint_t )2);
      }
#line 2275
      return;
    } else
#line 2273
    if (n == 0L) {
      {
#line 2274
      ngx_http_upstream_next(r, u, (ngx_uint_t )2);
      }
#line 2275
      return;
    }
    {
#line 2278
    (u->state)->bytes_received += n;
#line 2280
    u->buffer.last += n;
#line 2288
    rc = (*(u->process_header))(r);
    }
#line 2290
    if (rc == -2L) {
#line 2292
      if ((unsigned long )u->buffer.last == (unsigned long )u->buffer.end) {
#line 2293
        if ((c->log)->log_level >= 4UL) {
          {
#line 2293
          ngx_log_error_core((ngx_uint_t )4, c->log, 0, "upstream sent too big header");
          }
        }
        {
#line 2296
        ngx_http_upstream_next(r, u, (ngx_uint_t )8);
        }
#line 2298
        return;
      }
#line 2301
      goto __Cont;
    }
#line 2304
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 2307
  if (rc == 40L) {
    {
#line 2308
    ngx_http_upstream_next(r, u, (ngx_uint_t )8);
    }
#line 2309
    return;
  }
#line 2312
  if (rc == -1L) {
    {
#line 2313
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
    }
#line 2315
    return;
  }
#line 2320
  (u->state)->header_time = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )(u->state)->response_time);
#line 2322
  if (u->headers_in.status_n >= 300UL) {
    {
#line 2324
    tmp___3 = ngx_http_upstream_test_next(r, u);
    }
#line 2324
    if (tmp___3 == 0L) {
#line 2325
      return;
    }
    {
#line 2328
    tmp___4 = ngx_http_upstream_intercept_errors(r, u);
    }
#line 2328
    if (tmp___4 == 0L) {
#line 2329
      return;
    }
  }
  {
#line 2333
  tmp___5 = ngx_http_upstream_process_headers(r, u);
  }
#line 2333
  if (tmp___5 != 0L) {
#line 2334
    return;
  }
#line 2337
  if (! r->subrequest_in_memory) {
    {
#line 2338
    ngx_http_upstream_send_response(r, u);
    }
#line 2339
    return;
  }
#line 2344
  if ((unsigned long )u->input_filter == (unsigned long )((void *)0)) {
#line 2345
    u->input_filter_init = & ngx_http_upstream_non_buffered_filter_init;
#line 2346
    u->input_filter = & ngx_http_upstream_non_buffered_filter;
#line 2347
    u->input_filter_ctx = (void *)r;
  }
  {
#line 2350
  tmp___6 = (*(u->input_filter_init))(u->input_filter_ctx);
  }
#line 2350
  if (tmp___6 == -1L) {
    {
#line 2351
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 2352
    return;
  }
#line 2355
  n = u->buffer.last - u->buffer.pos;
#line 2357
  if (n) {
    {
#line 2358
    u->buffer.last = u->buffer.pos;
#line 2360
    (u->state)->response_length += n;
#line 2362
    tmp___7 = (*(u->input_filter))(u->input_filter_ctx, n);
    }
#line 2362
    if (tmp___7 == -1L) {
      {
#line 2363
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2364
      return;
    }
  }
#line 2368
  if (u->length == 0L) {
    {
#line 2369
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
    }
#line 2370
    return;
  }
  {
#line 2373
  u->read_event_handler = & ngx_http_upstream_process_body_in_memory;
#line 2375
  ngx_http_upstream_process_body_in_memory(r, u);
  }
#line 2376
  return;
}
}
#line 2379 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_test_next(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_uint_t status ;
  ngx_http_upstream_next_t *un ;
  ngx_int_t rc ;
  time_t now ;
  time_t valid ;
  time_t updating ;
  time_t error ;
  ngx_int_t rc___0 ;

  {
#line 2385
  status = u->headers_in.status_n;
#line 2387
  un = ngx_http_upstream_next_errors;
  {
#line 2387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2387
    if (! un->status) {
#line 2387
      goto while_break;
    }
#line 2389
    if (status != un->status) {
#line 2390
      goto __Cont;
    }
#line 2393
    if (u->peer.tries > 1UL) {
#line 2393
      if ((u->conf)->next_upstream & un->mask) {
        {
#line 2394
        ngx_http_upstream_next(r, u, un->mask);
        }
#line 2395
        return ((ngx_int_t )0);
      }
    }
#line 2400
    if (u->cache_status == 3U) {
#line 2400
      if ((u->conf)->cache_use_stale & un->mask) {
#line 2400
        goto _L;
      } else
#line 2400
      if ((r->cache)->stale_error) {
        _L: /* CIL Label */ 
        {
#line 2405
        rc = (*(u->reinit_request))(r);
        }
#line 2407
        if (rc != 0L) {
          {
#line 2408
          ngx_http_upstream_finalize_request(r, u, rc);
          }
#line 2409
          return ((ngx_int_t )0);
        }
        {
#line 2412
        u->cache_status = 4U;
#line 2413
        rc = ngx_http_upstream_cache_send(r, u);
        }
#line 2415
        if (rc == -4L) {
#line 2416
          return ((ngx_int_t )0);
        }
#line 2419
        if (rc == 40L) {
#line 2420
          rc = (ngx_int_t )500;
        }
        {
#line 2423
        ngx_http_upstream_finalize_request(r, u, rc);
        }
#line 2424
        return ((ngx_int_t )0);
      }
    }
    __Cont: /* CIL Label */ 
#line 2387
    un ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2432
  if (status == 304UL) {
#line 2432
    if (u->cache_status == 3U) {
#line 2432
      if ((u->conf)->cache_revalidate) {
        {
#line 2442
        now = (time_t )ngx_cached_time->sec;
#line 2444
        valid = (r->cache)->valid_sec;
#line 2445
        updating = (r->cache)->updating_sec;
#line 2446
        error = (r->cache)->error_sec;
#line 2448
        rc___0 = (*(u->reinit_request))(r);
        }
#line 2450
        if (rc___0 != 0L) {
          {
#line 2451
          ngx_http_upstream_finalize_request(r, u, rc___0);
          }
#line 2452
          return ((ngx_int_t )0);
        }
        {
#line 2455
        u->cache_status = 6U;
#line 2456
        rc___0 = ngx_http_upstream_cache_send(r, u);
        }
#line 2458
        if (rc___0 == -4L) {
#line 2459
          return ((ngx_int_t )0);
        }
#line 2462
        if (rc___0 == 40L) {
#line 2463
          rc___0 = (ngx_int_t )500;
        }
#line 2466
        if (valid == 0L) {
#line 2467
          valid = (r->cache)->valid_sec;
#line 2468
          updating = (r->cache)->updating_sec;
#line 2469
          error = (r->cache)->error_sec;
        }
#line 2472
        if (valid == 0L) {
          {
#line 2473
          valid = ngx_http_file_cache_valid((u->conf)->cache_valid, u->headers_in.status_n);
          }
#line 2475
          if (valid) {
#line 2476
            valid = now + valid;
          }
        }
#line 2480
        if (valid) {
          {
#line 2481
          (r->cache)->valid_sec = valid;
#line 2482
          (r->cache)->updating_sec = updating;
#line 2483
          (r->cache)->error_sec = error;
#line 2485
          (r->cache)->date = now;
#line 2487
          ngx_http_file_cache_update_header(r);
          }
        }
        {
#line 2490
        ngx_http_upstream_finalize_request(r, u, rc___0);
        }
#line 2491
        return ((ngx_int_t )0);
      }
    }
  }
#line 2496
  return ((ngx_int_t )-5);
}
}
#line 2500 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_intercept_errors(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_int_t status ;
  ngx_uint_t i ;
  ngx_table_elt_t *h ;
  ngx_http_err_page_t *err_page ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  time_t valid ;

  {
#line 2510
  status = (ngx_int_t )u->headers_in.status_n;
#line 2512
  if (status == 404L) {
#line 2512
    if ((u->conf)->intercept_404) {
      {
#line 2513
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )404);
      }
#line 2514
      return ((ngx_int_t )0);
    }
  }
#line 2517
  if (! (u->conf)->intercept_errors) {
#line 2518
    return ((ngx_int_t )-5);
  }
#line 2521
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2523
  if ((unsigned long )clcf->error_pages == (unsigned long )((void *)0)) {
#line 2524
    return ((ngx_int_t )-5);
  }
#line 2527
  err_page = (ngx_http_err_page_t *)(clcf->error_pages)->elts;
#line 2528
  i = (ngx_uint_t )0;
  {
#line 2528
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2528
    if (! (i < (clcf->error_pages)->nelts)) {
#line 2528
      goto while_break;
    }
#line 2530
    if ((err_page + i)->status == status) {
#line 2532
      if (status == 401L) {
#line 2532
        if (u->headers_in.www_authenticate) {
          {
#line 2535
          tmp = ngx_list_push(& r->headers_out.headers);
#line 2535
          h = (ngx_table_elt_t *)tmp;
          }
#line 2537
          if ((unsigned long )h == (unsigned long )((void *)0)) {
            {
#line 2538
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
            }
#line 2540
            return ((ngx_int_t )0);
          }
#line 2543
          *h = *(u->headers_in.www_authenticate);
#line 2545
          r->headers_out.www_authenticate = h;
        }
      }
#line 2550
      if (r->cache) {
#line 2552
        if (u->cacheable) {
#line 2555
          valid = (r->cache)->valid_sec;
#line 2557
          if (valid == 0L) {
            {
#line 2558
            valid = ngx_http_file_cache_valid((u->conf)->cache_valid, (ngx_uint_t )status);
            }
#line 2560
            if (valid) {
#line 2561
              (r->cache)->valid_sec = (time_t )(ngx_cached_time->sec + (time_t volatile   )valid);
            }
          }
#line 2565
          if (valid) {
#line 2566
            (r->cache)->error = (ngx_uint_t )status;
          }
        }
        {
#line 2570
        ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
        }
      }
      {
#line 2573
      ngx_http_upstream_finalize_request(r, u, status);
      }
#line 2575
      return ((ngx_int_t )0);
    }
#line 2528
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2579
  return ((ngx_int_t )-5);
}
}
#line 2583 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_test_connect(ngx_connection_t *c ) 
{ 
  int err ;
  socklen_t len ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 2609
  err = 0;
#line 2610
  len = (socklen_t )sizeof(int );
#line 2617
  tmp___0 = getsockopt(c->fd, 1, 4, (void */* __restrict  */)((void *)(& err)), (socklen_t */* __restrict  */)(& len));
  }
#line 2617
  if (tmp___0 == -1) {
    {
#line 2620
    tmp = __errno_location();
#line 2620
    err = *tmp;
    }
  }
#line 2623
  if (err) {
    {
#line 2624
    (c->log)->action = (char *)"connecting to upstream";
#line 2625
    ngx_connection_error(c, err, (char *)"connect() failed");
    }
#line 2626
    return ((ngx_int_t )-1);
  }
#line 2630
  return ((ngx_int_t )0);
}
}
#line 2634 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_headers(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_str_t uri___0 ;
  ngx_str_t args___0 ;
  ngx_uint_t i ;
  ngx_uint_t flags ;
  ngx_list_part_t *part ;
  ngx_table_elt_t *h ;
  ngx_http_upstream_header_t *hh ;
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;

  {
#line 2644
  umcf = (ngx_http_upstream_main_conf_t *)*(r->main_conf + ngx_http_upstream_module.ctx_index);
#line 2646
  if (u->headers_in.x_accel_redirect) {
#line 2646
    if (! ((u->conf)->ignore_headers & 2UL)) {
      {
#line 2649
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-5);
#line 2651
      part = & u->headers_in.headers.part;
#line 2652
      h = (ngx_table_elt_t *)part->elts;
#line 2654
      i = (ngx_uint_t )0;
      }
      {
#line 2654
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2656
        if (i >= part->nelts) {
#line 2657
          if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 2658
            goto while_break;
          }
#line 2661
          part = part->next;
#line 2662
          h = (ngx_table_elt_t *)part->elts;
#line 2663
          i = (ngx_uint_t )0;
        }
        {
#line 2666
        tmp = ngx_hash_find(& umcf->headers_in_hash, (h + i)->hash, (h + i)->lowcase_key,
                            (h + i)->key.len);
#line 2666
        hh = (ngx_http_upstream_header_t *)tmp;
        }
#line 2669
        if (hh) {
#line 2669
          if (hh->redirect) {
            {
#line 2670
            tmp___0 = (*(hh->copy_handler))(r, h + i, hh->conf);
            }
#line 2670
            if (tmp___0 != 0L) {
              {
#line 2671
              ngx_http_finalize_request(r, (ngx_int_t )500);
              }
#line 2673
              return ((ngx_int_t )-4);
            }
          }
        }
#line 2654
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 2678
      uri___0 = (u->headers_in.x_accel_redirect)->value;
#line 2680
      if ((int )*(uri___0.data + 0) == 64) {
        {
#line 2681
        ngx_http_named_location(r, & uri___0);
        }
      } else {
        {
#line 2684
        args___0.len = (size_t )0;
#line 2684
        args___0.data = (u_char *)((void *)0);
#line 2685
        flags = (ngx_uint_t )1;
#line 2687
        tmp___1 = ngx_http_parse_unsafe_uri(r, & uri___0, & args___0, & flags);
        }
#line 2687
        if (tmp___1 != 0L) {
          {
#line 2688
          ngx_http_finalize_request(r, (ngx_int_t )404);
          }
#line 2689
          return ((ngx_int_t )-4);
        }
#line 2692
        if (r->method != 4UL) {
#line 2693
          r->method = (ngx_uint_t )2;
#line 2694
          r->method_name = ngx_http_core_get_method;
        }
        {
#line 2697
        ngx_http_internal_redirect(r, & uri___0, & args___0);
        }
      }
      {
#line 2700
      ngx_http_finalize_request(r, (ngx_int_t )-4);
      }
#line 2701
      return ((ngx_int_t )-4);
    }
  }
#line 2704
  part = & u->headers_in.headers.part;
#line 2705
  h = (ngx_table_elt_t *)part->elts;
#line 2707
  i = (ngx_uint_t )0;
  {
#line 2707
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2709
    if (i >= part->nelts) {
#line 2710
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 2711
        goto while_break___0;
      }
#line 2714
      part = part->next;
#line 2715
      h = (ngx_table_elt_t *)part->elts;
#line 2716
      i = (ngx_uint_t )0;
    }
    {
#line 2719
    tmp___2 = ngx_hash_find(& (u->conf)->hide_headers_hash, (h + i)->hash, (h + i)->lowcase_key,
                            (h + i)->key.len);
    }
#line 2719
    if (tmp___2) {
#line 2722
      goto __Cont;
    }
    {
#line 2725
    tmp___3 = ngx_hash_find(& umcf->headers_in_hash, (h + i)->hash, (h + i)->lowcase_key,
                            (h + i)->key.len);
#line 2725
    hh = (ngx_http_upstream_header_t *)tmp___3;
    }
#line 2728
    if (hh) {
      {
#line 2729
      tmp___4 = (*(hh->copy_handler))(r, h + i, hh->conf);
      }
#line 2729
      if (tmp___4 != 0L) {
        {
#line 2730
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
        }
#line 2732
        return ((ngx_int_t )-4);
      }
#line 2735
      goto __Cont;
    }
    {
#line 2738
    tmp___5 = ngx_http_upstream_copy_header_line(r, h + i, (ngx_uint_t )0);
    }
#line 2738
    if (tmp___5 != 0L) {
      {
#line 2739
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )500);
      }
#line 2741
      return ((ngx_int_t )-4);
    }
    __Cont: /* CIL Label */ 
#line 2707
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2745
  if (r->headers_out.server) {
#line 2745
    if ((unsigned long )(r->headers_out.server)->value.data == (unsigned long )((void *)0)) {
#line 2746
      (r->headers_out.server)->hash = (ngx_uint_t )0;
    }
  }
#line 2749
  if (r->headers_out.date) {
#line 2749
    if ((unsigned long )(r->headers_out.date)->value.data == (unsigned long )((void *)0)) {
#line 2750
      (r->headers_out.date)->hash = (ngx_uint_t )0;
    }
  }
#line 2753
  r->headers_out.status = u->headers_in.status_n;
#line 2754
  r->headers_out.status_line = u->headers_in.status_line;
#line 2756
  r->headers_out.content_length_n = u->headers_in.content_length_n;
#line 2758
  r->disable_not_modified = (unsigned int )(! u->cacheable);
#line 2760
  if ((u->conf)->force_ranges) {
#line 2761
    r->allow_ranges = 1U;
#line 2762
    r->single_range = 1U;
#line 2765
    if (r->cached) {
#line 2766
      r->single_range = 0U;
    }
  }
#line 2771
  u->length = (off_t )-1;
#line 2773
  return ((ngx_int_t )0);
}
}
#line 2777 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_body_in_memory(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  size_t size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_event_t *rev ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 2787
  c = u->peer.connection;
#line 2788
  rev = c->read;
#line 2793
  if (rev->timedout) {
    {
#line 2794
    ngx_connection_error(c, 110, (char *)"upstream timed out");
#line 2795
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )504);
    }
#line 2796
    return;
  }
#line 2799
  b = & u->buffer;
  {
#line 2801
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2803
    size = (size_t )(b->end - b->last);
#line 2805
    if (size == 0UL) {
#line 2806
      if ((c->log)->log_level >= 2UL) {
        {
#line 2806
        ngx_log_error_core((ngx_uint_t )2, c->log, 0, "upstream buffer is too small to read response");
        }
      }
      {
#line 2808
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2809
      return;
    }
    {
#line 2812
    n = (*(c->recv))(c, b->last, size);
    }
#line 2814
    if (n == -2L) {
#line 2815
      goto while_break;
    }
#line 2818
    if (n == 0L) {
      {
#line 2819
      ngx_http_upstream_finalize_request(r, u, n);
      }
#line 2820
      return;
    } else
#line 2818
    if (n == -1L) {
      {
#line 2819
      ngx_http_upstream_finalize_request(r, u, n);
      }
#line 2820
      return;
    }
    {
#line 2823
    (u->state)->bytes_received += n;
#line 2824
    (u->state)->response_length += n;
#line 2826
    tmp = (*(u->input_filter))(u->input_filter_ctx, n);
    }
#line 2826
    if (tmp == -1L) {
      {
#line 2827
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2828
      return;
    }
#line 2831
    if (! rev->ready) {
#line 2832
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2836
  if (u->length == 0L) {
    {
#line 2837
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
    }
#line 2838
    return;
  }
  {
#line 2841
  tmp___0 = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 2841
  if (tmp___0 != 0L) {
    {
#line 2842
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 2843
    return;
  }
#line 2846
  if (rev->active) {
    {
#line 2847
    ngx_event_add_timer(rev, (u->conf)->read_timeout);
    }
  } else
#line 2849
  if (rev->timer_set) {
    {
#line 2850
    ngx_event_del_timer(rev);
    }
  }
#line 2852
  return;
}
}
#line 2855 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_send_response(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ssize_t n ;
  ngx_int_t rc ;
  ngx_event_pipe_t *p ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  time_t now ;
  time_t valid ;
  ngx_int_t tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_int_t tmp___9 ;
  char *__cil_tmp21 ;

  {
  {
#line 2864
  rc = ngx_http_send_header(r);
  }
#line 2866
  if (rc == -1L) {
    {
#line 2867
    ngx_http_upstream_finalize_request(r, u, rc);
    }
#line 2868
    return;
  } else
#line 2866
  if (rc > 0L) {
    {
#line 2867
    ngx_http_upstream_finalize_request(r, u, rc);
    }
#line 2868
    return;
  } else
#line 2866
  if (r->post_action) {
    {
#line 2867
    ngx_http_upstream_finalize_request(r, u, rc);
    }
#line 2868
    return;
  }
#line 2871
  u->header_sent = 1U;
#line 2873
  if (u->upgrade) {
#line 2877
    if (r->cache) {
      {
#line 2878
      ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
      }
    }
    {
#line 2883
    ngx_http_upstream_upgrade(r, u);
    }
#line 2884
    return;
  }
#line 2887
  c = r->connection;
#line 2889
  if (r->header_only) {
#line 2891
    if (! u->buffering) {
      {
#line 2892
      ngx_http_upstream_finalize_request(r, u, rc);
      }
#line 2893
      return;
    }
#line 2896
    if (! u->cacheable) {
#line 2896
      if (! u->store) {
        {
#line 2897
        ngx_http_upstream_finalize_request(r, u, rc);
        }
#line 2898
        return;
      }
    }
#line 2901
    (u->pipe)->downstream_error = 1U;
  }
#line 2904
  if (r->request_body) {
#line 2904
    if ((r->request_body)->temp_file) {
#line 2904
      if ((unsigned long )r == (unsigned long )r->main) {
#line 2904
        if (! r->preserve_body) {
          {
#line 2907
          ngx_pool_run_cleanup_file(r->pool, ((r->request_body)->temp_file)->file.fd);
#line 2908
          ((r->request_body)->temp_file)->file.fd = -1;
          }
        }
      }
    }
  }
#line 2911
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2913
  if (! u->buffering) {
#line 2917
    if (r->cache) {
      {
#line 2918
      ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
      }
    }
#line 2923
    if ((unsigned long )u->input_filter == (unsigned long )((void *)0)) {
#line 2924
      u->input_filter_init = & ngx_http_upstream_non_buffered_filter_init;
#line 2925
      u->input_filter = & ngx_http_upstream_non_buffered_filter;
#line 2926
      u->input_filter_ctx = (void *)r;
    }
    {
#line 2929
    u->read_event_handler = & ngx_http_upstream_process_non_buffered_upstream;
#line 2930
    r->write_event_handler = & ngx_http_upstream_process_non_buffered_downstream;
#line 2933
    r->limit_rate = (size_t )0;
#line 2935
    tmp = (*(u->input_filter_init))(u->input_filter_ctx);
    }
#line 2935
    if (tmp == -1L) {
      {
#line 2936
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 2937
      return;
    }
#line 2940
    if (clcf->tcp_nodelay) {
      {
#line 2940
      tmp___0 = ngx_tcp_nodelay(c);
      }
#line 2940
      if (tmp___0 != 0L) {
        {
#line 2941
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 2942
        return;
      }
    }
#line 2945
    n = u->buffer.last - u->buffer.pos;
#line 2947
    if (n) {
      {
#line 2948
      u->buffer.last = u->buffer.pos;
#line 2950
      (u->state)->response_length += n;
#line 2952
      tmp___1 = (*(u->input_filter))(u->input_filter_ctx, n);
      }
#line 2952
      if (tmp___1 == -1L) {
        {
#line 2953
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 2954
        return;
      }
      {
#line 2957
      ngx_http_upstream_process_non_buffered_downstream(r);
      }
    } else {
      {
#line 2960
      u->buffer.pos = u->buffer.start;
#line 2961
      u->buffer.last = u->buffer.start;
#line 2963
      tmp___2 = ngx_http_send_special(r, (ngx_uint_t )2);
      }
#line 2963
      if (tmp___2 == -1L) {
        {
#line 2964
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 2965
        return;
      }
#line 2968
      if (((u->peer.connection)->read)->ready) {
        {
#line 2969
        ngx_http_upstream_process_non_buffered_upstream(r, u);
        }
      } else
#line 2968
      if (u->length == 0L) {
        {
#line 2969
        ngx_http_upstream_process_non_buffered_upstream(r, u);
        }
      }
    }
#line 2973
    return;
  }
#line 2980
  if (r->cache) {
#line 2980
    if ((r->cache)->file.fd != -1) {
      {
#line 2981
      ngx_pool_run_cleanup_file(r->pool, (r->cache)->file.fd);
#line 2982
      (r->cache)->file.fd = -1;
      }
    }
  }
  {
#line 2985
  tmp___3 = ngx_http_test_predicates(r, (u->conf)->no_cache);
  }
  {
#line 2987
  if (tmp___3 == -1L) {
#line 2987
    goto case_neg_1;
  }
#line 2991
  if (tmp___3 == -5L) {
#line 2991
    goto case_neg_5;
  }
#line 2995
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 2988
  ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
  }
#line 2989
  return;
  case_neg_5: /* CIL Label */ 
#line 2992
  u->cacheable = 0U;
#line 2993
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2997
  if (u->cache_status == 2U) {
    {
#line 3001
    tmp___4 = ngx_http_file_cache_create(r);
    }
#line 3001
    if (tmp___4 != 0L) {
      {
#line 3002
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3003
      return;
    }
  }
#line 3007
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 3010
  if (u->cacheable) {
#line 3013
    now = (time_t )ngx_cached_time->sec;
#line 3015
    valid = (r->cache)->valid_sec;
#line 3017
    if (valid == 0L) {
      {
#line 3018
      valid = ngx_http_file_cache_valid((u->conf)->cache_valid, u->headers_in.status_n);
      }
#line 3020
      if (valid) {
#line 3021
        (r->cache)->valid_sec = now + valid;
      }
    }
#line 3025
    if (valid) {
#line 3026
      (r->cache)->date = now;
#line 3027
      (r->cache)->body_start = (size_t )((u_short )(u->buffer.pos - u->buffer.start));
#line 3029
      if (u->headers_in.status_n == 200UL) {
#line 3029
        goto _L;
      } else
#line 3029
      if (u->headers_in.status_n == 206UL) {
        _L: /* CIL Label */ 
#line 3032
        (r->cache)->last_modified = u->headers_in.last_modified_time;
#line 3034
        if (u->headers_in.etag) {
#line 3035
          (r->cache)->etag = (u->headers_in.etag)->value;
        } else {
#line 3038
          (r->cache)->etag.len = (size_t )0;
#line 3038
          (r->cache)->etag.data = (u_char *)((void *)0);
        }
      } else {
#line 3042
        (r->cache)->last_modified = (time_t )-1;
#line 3043
        (r->cache)->etag.len = (size_t )0;
#line 3043
        (r->cache)->etag.data = (u_char *)((void *)0);
      }
      {
#line 3046
      tmp___5 = ngx_http_file_cache_set_header(r, u->buffer.start);
      }
#line 3046
      if (tmp___5 != 0L) {
        {
#line 3047
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 3048
        return;
      }
    } else {
#line 3052
      u->cacheable = 0U;
    }
  }
#line 3059
  if (u->cacheable == 0U) {
#line 3059
    if (r->cache) {
      {
#line 3060
      ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
      }
    }
  }
#line 3063
  if (r->header_only) {
#line 3063
    if (! u->cacheable) {
#line 3063
      if (! u->store) {
        {
#line 3064
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
        }
#line 3065
        return;
      }
    }
  }
#line 3070
  p = u->pipe;
#line 3072
  p->output_filter = & ngx_http_upstream_output_filter;
#line 3073
  p->output_ctx = (void *)r;
#line 3074
  p->tag = u->output.tag;
#line 3075
  p->bufs = (u->conf)->bufs;
#line 3076
  p->busy_size = (ssize_t )(u->conf)->busy_buffers_size;
#line 3077
  p->upstream = u->peer.connection;
#line 3078
  p->downstream = c;
#line 3079
  p->pool = r->pool;
#line 3080
  p->log = c->log;
#line 3081
  p->limit_rate = (u->conf)->limit_rate;
#line 3082
  p->start_sec = (time_t )ngx_cached_time->sec;
#line 3084
  if (u->cacheable) {
#line 3084
    tmp___6 = 1;
  } else
#line 3084
  if (u->store) {
#line 3084
    tmp___6 = 1;
  } else {
#line 3084
    tmp___6 = 0;
  }
  {
#line 3084
  p->cacheable = (unsigned int )tmp___6;
#line 3086
  tmp___7 = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t ));
#line 3086
  p->temp_file = (ngx_temp_file_t *)tmp___7;
  }
#line 3087
  if ((unsigned long )p->temp_file == (unsigned long )((void *)0)) {
    {
#line 3088
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3089
    return;
  }
#line 3092
  (p->temp_file)->file.fd = -1;
#line 3093
  (p->temp_file)->file.log = c->log;
#line 3094
  (p->temp_file)->path = (u->conf)->temp_path;
#line 3095
  (p->temp_file)->pool = r->pool;
#line 3097
  if (p->cacheable) {
#line 3098
    (p->temp_file)->persistent = 1U;
#line 3101
    if (r->cache) {
#line 3101
      if (! ((r->cache)->file_cache)->use_temp_path) {
#line 3102
        (p->temp_file)->path = ((r->cache)->file_cache)->path;
#line 3103
        (p->temp_file)->file.name = (r->cache)->file.name;
      }
    }
  } else {
#line 3108
    (p->temp_file)->log_level = 5U;
#line 3109
    (p->temp_file)->warn = (char *)"an upstream response is buffered to a temporary file";
  }
  {
#line 3113
  p->max_temp_file_size = (off_t )(u->conf)->max_temp_file_size;
#line 3114
  p->temp_file_write_size = (ssize_t )(u->conf)->temp_file_write_size;
#line 3123
  p->preread_bufs = ngx_alloc_chain_link(r->pool);
  }
#line 3124
  if ((unsigned long )p->preread_bufs == (unsigned long )((void *)0)) {
    {
#line 3125
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3126
    return;
  }
#line 3129
  (p->preread_bufs)->buf = & u->buffer;
#line 3130
  (p->preread_bufs)->next = (ngx_chain_t *)((void *)0);
#line 3131
  u->buffer.recycled = 1U;
#line 3133
  p->preread_size = (size_t )(u->buffer.last - u->buffer.pos);
#line 3135
  if (u->cacheable) {
    {
#line 3137
    tmp___8 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 3137
    p->buf_to_file = (ngx_buf_t *)tmp___8;
    }
#line 3138
    if ((unsigned long )p->buf_to_file == (unsigned long )((void *)0)) {
      {
#line 3139
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3140
      return;
    }
#line 3143
    (p->buf_to_file)->start = u->buffer.start;
#line 3144
    (p->buf_to_file)->pos = u->buffer.start;
#line 3145
    (p->buf_to_file)->last = u->buffer.pos;
#line 3146
    (p->buf_to_file)->temporary = 1U;
  }
#line 3149
  if (ngx_event_flags & 512UL) {
#line 3151
    p->single_buf = 1U;
  }
#line 3155
  p->free_bufs = 1U;
#line 3161
  u->buffer.last = u->buffer.pos;
#line 3163
  if ((u->conf)->cyclic_temp_file) {
#line 3171
    p->cyclic_temp_file = 1U;
#line 3172
    c->sendfile = 0U;
  } else {
#line 3175
    p->cyclic_temp_file = 0U;
  }
#line 3178
  p->read_timeout = (u->conf)->read_timeout;
#line 3179
  p->send_timeout = clcf->send_timeout;
#line 3180
  p->send_lowat = (ssize_t )clcf->send_lowat;
#line 3182
  p->length = (off_t )-1;
#line 3184
  if (u->input_filter_init) {
    {
#line 3184
    tmp___9 = (*(u->input_filter_init))(p->input_ctx);
    }
#line 3184
    if (tmp___9 != 0L) {
      {
#line 3187
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3188
      return;
    }
  }
  {
#line 3191
  u->read_event_handler = & ngx_http_upstream_process_upstream;
#line 3192
  r->write_event_handler = & ngx_http_upstream_process_downstream;
#line 3194
  ngx_http_upstream_process_upstream(r, u);
  }
#line 3195
  return;
}
}
#line 3198 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgrade(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3204
  c = r->connection;
#line 3205
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3209
  if ((unsigned long )r != (unsigned long )r->main) {
#line 3210
    if ((c->log)->log_level >= 4UL) {
      {
#line 3210
      ngx_log_error_core((ngx_uint_t )4, c->log, 0, "connection upgrade in subrequest");
      }
    }
    {
#line 3212
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3213
    return;
  }
#line 3216
  r->keepalive = 0U;
#line 3217
  (c->log)->action = (char *)"proxying upgraded connection";
#line 3219
  u->read_event_handler = & ngx_http_upstream_upgraded_read_upstream;
#line 3220
  u->write_event_handler = & ngx_http_upstream_upgraded_write_upstream;
#line 3221
  r->read_event_handler = & ngx_http_upstream_upgraded_read_downstream;
#line 3222
  r->write_event_handler = & ngx_http_upstream_upgraded_write_downstream;
#line 3224
  if (clcf->tcp_nodelay) {
    {
#line 3226
    tmp = ngx_tcp_nodelay(c);
    }
#line 3226
    if (tmp != 0L) {
      {
#line 3227
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3228
      return;
    }
    {
#line 3231
    tmp___0 = ngx_tcp_nodelay(u->peer.connection);
    }
#line 3231
    if (tmp___0 != 0L) {
      {
#line 3232
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3233
      return;
    }
  }
  {
#line 3237
  tmp___1 = ngx_http_send_special(r, (ngx_uint_t )2);
  }
#line 3237
  if (tmp___1 == -1L) {
    {
#line 3238
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3239
    return;
  }
#line 3242
  if (((u->peer.connection)->read)->ready) {
#line 3242
    goto _L;
  } else
#line 3242
  if ((unsigned long )u->buffer.pos != (unsigned long )u->buffer.last) {
    _L: /* CIL Label */ 
#line 3245
    if (! (c->read)->posted) {
#line 3245
      (c->read)->posted = 1U;
#line 3245
      (c->read)->queue.prev = ngx_posted_events.prev;
#line 3245
      ((c->read)->queue.prev)->next = & (c->read)->queue;
#line 3245
      (c->read)->queue.next = & ngx_posted_events;
#line 3245
      ngx_posted_events.prev = & (c->read)->queue;
    }
    {
#line 3246
    ngx_http_upstream_process_upgraded(r, (ngx_uint_t )1, (ngx_uint_t )1);
    }
#line 3247
    return;
  }
  {
#line 3250
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )0, (ngx_uint_t )1);
  }
#line 3251
  return;
}
}
#line 3254 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgraded_read_downstream(ngx_http_request_t *r ) 
{ 


  {
  {
#line 3257
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )0, (ngx_uint_t )0);
  }
#line 3258
  return;
}
}
#line 3261 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgraded_write_downstream(ngx_http_request_t *r ) 
{ 


  {
  {
#line 3264
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )1, (ngx_uint_t )1);
  }
#line 3265
  return;
}
}
#line 3268 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgraded_read_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 


  {
  {
#line 3272
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )1, (ngx_uint_t )0);
  }
#line 3273
  return;
}
}
#line 3276 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_upgraded_write_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 


  {
  {
#line 3280
  ngx_http_upstream_process_upgraded(r, (ngx_uint_t )0, (ngx_uint_t )1);
  }
#line 3281
  return;
}
}
#line 3284 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_upgraded(ngx_http_request_t *r , ngx_uint_t from_upstream ,
                                               ngx_uint_t do_write ) 
{ 
  size_t size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_connection_t *c ;
  ngx_connection_t *downstream ;
  ngx_connection_t *upstream ;
  ngx_connection_t *dst ;
  ngx_connection_t *src ;
  ngx_http_upstream_t *u ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 3295
  c = r->connection;
#line 3296
  u = r->upstream;
#line 3301
  downstream = c;
#line 3302
  upstream = u->peer.connection;
#line 3304
  if ((downstream->write)->timedout) {
    {
#line 3305
    c->timedout = 1U;
#line 3306
    ngx_connection_error(c, 110, (char *)"client timed out");
#line 3307
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )408);
    }
#line 3308
    return;
  }
#line 3311
  if ((upstream->read)->timedout) {
    {
#line 3312
    ngx_connection_error(c, 110, (char *)"upstream timed out");
#line 3313
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )504);
    }
#line 3314
    return;
  } else
#line 3311
  if ((upstream->write)->timedout) {
    {
#line 3312
    ngx_connection_error(c, 110, (char *)"upstream timed out");
#line 3313
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )504);
    }
#line 3314
    return;
  }
#line 3317
  if (from_upstream) {
#line 3318
    src = upstream;
#line 3319
    dst = downstream;
#line 3320
    b = & u->buffer;
  } else {
#line 3323
    src = downstream;
#line 3324
    dst = upstream;
#line 3325
    b = & u->from_client;
#line 3327
    if ((unsigned long )(r->header_in)->last > (unsigned long )(r->header_in)->pos) {
#line 3328
      b = r->header_in;
#line 3329
      b->end = b->last;
#line 3330
      do_write = (ngx_uint_t )1;
    }
#line 3333
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
      {
#line 3334
      tmp = ngx_palloc(r->pool, (u->conf)->buffer_size);
#line 3334
      b->start = (u_char *)tmp;
      }
#line 3335
      if ((unsigned long )b->start == (unsigned long )((void *)0)) {
        {
#line 3336
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
#line 3337
        return;
      }
#line 3340
      b->pos = b->start;
#line 3341
      b->last = b->start;
#line 3342
      b->end = b->start + (u->conf)->buffer_size;
#line 3343
      b->temporary = 1U;
#line 3344
      b->tag = u->output.tag;
    }
  }
  {
#line 3348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3350
    if (do_write) {
#line 3352
      size = (size_t )(b->last - b->pos);
#line 3354
      if (size) {
#line 3354
        if ((dst->write)->ready) {
          {
#line 3356
          n = (*(dst->send))(dst, b->pos, size);
          }
#line 3358
          if (n == -1L) {
            {
#line 3359
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
            }
#line 3360
            return;
          }
#line 3363
          if (n > 0L) {
#line 3364
            b->pos += n;
#line 3366
            if ((unsigned long )b->pos == (unsigned long )b->last) {
#line 3367
              b->pos = b->start;
#line 3368
              b->last = b->start;
            }
          }
        }
      }
    }
#line 3374
    size = (size_t )(b->end - b->last);
#line 3376
    if (size) {
#line 3376
      if ((src->read)->ready) {
        {
#line 3378
        n = (*(src->recv))(src, b->last, size);
        }
#line 3380
        if (n == -2L) {
#line 3381
          goto while_break;
        } else
#line 3380
        if (n == 0L) {
#line 3381
          goto while_break;
        }
#line 3384
        if (n > 0L) {
#line 3385
          do_write = (ngx_uint_t )1;
#line 3386
          b->last += n;
#line 3388
          if (from_upstream) {
#line 3389
            (u->state)->bytes_received += n;
          }
#line 3392
          goto __Cont;
        }
#line 3395
        if (n == -1L) {
#line 3396
          (src->read)->eof = 1U;
        }
      }
    }
#line 3400
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3403
  if ((upstream->read)->eof) {
#line 3403
    if ((unsigned long )u->buffer.pos == (unsigned long )u->buffer.last) {
      {
#line 3409
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
      }
#line 3410
      return;
    } else {
#line 3403
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3403
  if ((downstream->read)->eof) {
#line 3403
    if ((unsigned long )u->from_client.pos == (unsigned long )u->from_client.last) {
      {
#line 3409
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
      }
#line 3410
      return;
    } else {
#line 3403
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 3403
  if ((downstream->read)->eof) {
#line 3403
    if ((upstream->read)->eof) {
      {
#line 3409
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
      }
#line 3410
      return;
    }
  }
  {
#line 3413
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3415
  tmp___0 = ngx_handle_write_event(upstream->write, (u->conf)->send_lowat);
  }
#line 3415
  if (tmp___0 != 0L) {
    {
#line 3418
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3419
    return;
  }
#line 3422
  if ((upstream->write)->active) {
#line 3422
    if (! (upstream->write)->ready) {
      {
#line 3423
      ngx_event_add_timer(upstream->write, (u->conf)->send_timeout);
      }
    } else {
#line 3422
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3425
  if ((upstream->write)->timer_set) {
    {
#line 3426
    ngx_event_del_timer(upstream->write);
    }
  }
  {
#line 3429
  tmp___1 = ngx_handle_read_event(upstream->read, (ngx_uint_t )0);
  }
#line 3429
  if (tmp___1 != 0L) {
    {
#line 3430
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3431
    return;
  }
#line 3434
  if ((upstream->read)->active) {
#line 3434
    if (! (upstream->read)->ready) {
      {
#line 3435
      ngx_event_add_timer(upstream->read, (u->conf)->read_timeout);
      }
    } else {
#line 3434
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 3437
  if ((upstream->read)->timer_set) {
    {
#line 3438
    ngx_event_del_timer(upstream->read);
    }
  }
  {
#line 3441
  tmp___2 = ngx_handle_write_event(downstream->write, clcf->send_lowat);
  }
#line 3441
  if (tmp___2 != 0L) {
    {
#line 3444
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3445
    return;
  }
  {
#line 3448
  tmp___3 = ngx_handle_read_event(downstream->read, (ngx_uint_t )0);
  }
#line 3448
  if (tmp___3 != 0L) {
    {
#line 3449
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3450
    return;
  }
#line 3453
  if ((downstream->write)->active) {
#line 3453
    if (! (downstream->write)->ready) {
      {
#line 3454
      ngx_event_add_timer(downstream->write, clcf->send_timeout);
      }
    } else {
#line 3453
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 3456
  if ((downstream->write)->timer_set) {
    {
#line 3457
    ngx_event_del_timer(downstream->write);
    }
  }
#line 3459
  return;
}
}
#line 3462 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_non_buffered_downstream(ngx_http_request_t *r ) 
{ 
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_http_upstream_t *u ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 3469
  c = r->connection;
#line 3470
  u = r->upstream;
#line 3471
  wev = c->write;
#line 3476
  (c->log)->action = (char *)"sending to client";
#line 3478
  if (wev->timedout) {
    {
#line 3479
    c->timedout = 1U;
#line 3480
    ngx_connection_error(c, 110, (char *)"client timed out");
#line 3481
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )408);
    }
#line 3482
    return;
  }
  {
#line 3485
  ngx_http_upstream_process_non_buffered_request(r, (ngx_uint_t )1);
  }
#line 3486
  return;
}
}
#line 3489 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_non_buffered_upstream(ngx_http_request_t *r ,
                                                            ngx_http_upstream_t *u ) 
{ 
  ngx_connection_t *c ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 3495
  c = u->peer.connection;
#line 3500
  (c->log)->action = (char *)"reading upstream";
#line 3502
  if ((c->read)->timedout) {
    {
#line 3503
    ngx_connection_error(c, 110, (char *)"upstream timed out");
#line 3504
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )504);
    }
#line 3505
    return;
  }
  {
#line 3508
  ngx_http_upstream_process_non_buffered_request(r, (ngx_uint_t )0);
  }
#line 3509
  return;
}
}
#line 3512 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_non_buffered_request(ngx_http_request_t *r ,
                                                           ngx_uint_t do_write ) 
{ 
  size_t size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_int_t rc ;
  ngx_connection_t *downstream ;
  ngx_connection_t *upstream ;
  ngx_http_upstream_t *u ;
  ngx_http_core_loc_conf_t *clcf ;
  int tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp15 ;

  {
#line 3524
  u = r->upstream;
#line 3525
  downstream = r->connection;
#line 3526
  upstream = u->peer.connection;
#line 3528
  b = & u->buffer;
#line 3530
  if (do_write) {
#line 3530
    tmp = 1;
  } else
#line 3530
  if (u->length == 0L) {
#line 3530
    tmp = 1;
  } else {
#line 3530
    tmp = 0;
  }
#line 3530
  do_write = (ngx_uint_t )tmp;
  {
#line 3532
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3534
    if (do_write) {
#line 3536
      if (u->out_bufs) {
#line 3536
        goto _L;
      } else
#line 3536
      if (u->busy_bufs) {
#line 3536
        goto _L;
      } else
#line 3536
      if (downstream->buffered) {
        _L: /* CIL Label */ 
        {
#line 3537
        rc = ngx_http_output_filter(r, u->out_bufs);
        }
#line 3539
        if (rc == -1L) {
          {
#line 3540
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
          }
#line 3541
          return;
        }
        {
#line 3544
        ngx_chain_update_chains(r->pool, & u->free_bufs, & u->busy_bufs, & u->out_bufs,
                                u->output.tag);
        }
      }
#line 3548
      if ((unsigned long )u->busy_bufs == (unsigned long )((void *)0)) {
#line 3550
        if (u->length == 0L) {
          {
#line 3553
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
          }
#line 3554
          return;
        } else
#line 3550
        if ((upstream->read)->eof) {
#line 3550
          if (u->length == -1L) {
            {
#line 3553
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
            }
#line 3554
            return;
          }
        }
#line 3557
        if ((upstream->read)->eof) {
#line 3558
          if ((upstream->log)->log_level >= 4UL) {
            {
#line 3558
            ngx_log_error_core((ngx_uint_t )4, upstream->log, 0, "upstream prematurely closed connection");
            }
          }
          {
#line 3561
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
          }
#line 3563
          return;
        }
#line 3566
        if ((upstream->read)->error) {
          {
#line 3567
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
          }
#line 3569
          return;
        }
#line 3572
        b->pos = b->start;
#line 3573
        b->last = b->start;
      }
    }
#line 3577
    size = (size_t )(b->end - b->last);
#line 3579
    if (size) {
#line 3579
      if ((upstream->read)->ready) {
        {
#line 3581
        n = (*(upstream->recv))(upstream, b->last, size);
        }
#line 3583
        if (n == -2L) {
#line 3584
          goto while_break;
        }
#line 3587
        if (n > 0L) {
          {
#line 3588
          (u->state)->bytes_received += n;
#line 3589
          (u->state)->response_length += n;
#line 3591
          tmp___0 = (*(u->input_filter))(u->input_filter_ctx, n);
          }
#line 3591
          if (tmp___0 == -1L) {
            {
#line 3592
            ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
            }
#line 3593
            return;
          }
        }
#line 3597
        do_write = (ngx_uint_t )1;
#line 3599
        goto __Cont;
      }
    }
#line 3602
    goto while_break;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 3605
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3607
  if ((unsigned long )downstream->data == (unsigned long )r) {
    {
#line 3608
    tmp___1 = ngx_handle_write_event(downstream->write, clcf->send_lowat);
    }
#line 3608
    if (tmp___1 != 0L) {
      {
#line 3611
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3612
      return;
    }
  }
#line 3616
  if ((downstream->write)->active) {
#line 3616
    if (! (downstream->write)->ready) {
      {
#line 3617
      ngx_event_add_timer(downstream->write, clcf->send_timeout);
      }
    } else {
#line 3616
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 3619
  if ((downstream->write)->timer_set) {
    {
#line 3620
    ngx_event_del_timer(downstream->write);
    }
  }
  {
#line 3623
  tmp___2 = ngx_handle_read_event(upstream->read, (ngx_uint_t )0);
  }
#line 3623
  if (tmp___2 != 0L) {
    {
#line 3624
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
    }
#line 3625
    return;
  }
#line 3628
  if ((upstream->read)->active) {
#line 3628
    if (! (upstream->read)->ready) {
      {
#line 3629
      ngx_event_add_timer(upstream->read, (u->conf)->read_timeout);
      }
    } else {
#line 3628
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 3631
  if ((upstream->read)->timer_set) {
    {
#line 3632
    ngx_event_del_timer(upstream->read);
    }
  }
#line 3634
  return;
}
}
#line 3637 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_non_buffered_filter_init(void *data ) 
{ 


  {
#line 3640
  return ((ngx_int_t )0);
}
}
#line 3644 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_non_buffered_filter(void *data , ssize_t bytes ) 
{ 
  ngx_http_request_t *r ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  ngx_http_upstream_t *u ;

  {
#line 3647
  r = (ngx_http_request_t *)data;
#line 3653
  u = r->upstream;
#line 3655
  cl = u->out_bufs;
#line 3655
  ll = & u->out_bufs;
  {
#line 3655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3655
    if (! cl) {
#line 3655
      goto while_break;
    }
#line 3656
    ll = & cl->next;
#line 3655
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3659
  cl = ngx_chain_get_free_buf(r->pool, & u->free_bufs);
  }
#line 3660
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 3661
    return ((ngx_int_t )-1);
  }
#line 3664
  *ll = cl;
#line 3666
  (cl->buf)->flush = 1U;
#line 3667
  (cl->buf)->memory = 1U;
#line 3669
  b = & u->buffer;
#line 3671
  (cl->buf)->pos = b->last;
#line 3672
  b->last += bytes;
#line 3673
  (cl->buf)->last = b->last;
#line 3674
  (cl->buf)->tag = u->output.tag;
#line 3676
  if (u->length == -1L) {
#line 3677
    return ((ngx_int_t )0);
  }
#line 3680
  u->length -= bytes;
#line 3682
  return ((ngx_int_t )0);
}
}
#line 3769 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_output_filter(void *data , ngx_chain_t *chain ) 
{ 
  ngx_int_t rc ;
  ngx_event_pipe_t *p ;
  ngx_http_request_t *r ;

  {
  {
#line 3776
  r = (ngx_http_request_t *)data;
#line 3777
  p = (r->upstream)->pipe;
#line 3779
  rc = ngx_http_output_filter(r, chain);
#line 3781
  p->aio = r->aio;
  }
#line 3783
  return (rc);
}
}
#line 3787 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_downstream(ngx_http_request_t *r ) 
{ 
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_event_pipe_t *p ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3795
  c = r->connection;
#line 3796
  u = r->upstream;
#line 3797
  p = u->pipe;
#line 3798
  wev = c->write;
#line 3803
  (c->log)->action = (char *)"sending to client";
#line 3809
  if (wev->timedout) {
    {
#line 3811
    p->downstream_error = 1U;
#line 3812
    c->timedout = 1U;
#line 3813
    ngx_connection_error(c, 110, (char *)"client timed out");
    }
  } else {
#line 3817
    if (wev->delayed) {
      {
#line 3822
      tmp = ngx_handle_write_event(wev, (size_t )p->send_lowat);
      }
#line 3822
      if (tmp != 0L) {
        {
#line 3823
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
      }
#line 3826
      return;
    }
    {
#line 3829
    tmp___0 = ngx_event_pipe(p, (ngx_int_t )1);
    }
#line 3829
    if (tmp___0 == -6L) {
      {
#line 3830
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3831
      return;
    }
  }
  {
#line 3835
  ngx_http_upstream_process_request(r, u);
  }
#line 3836
  return;
}
}
#line 3839 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_upstream(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_event_t *rev ;
  ngx_event_pipe_t *p ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 3847
  c = u->peer.connection;
#line 3848
  p = u->pipe;
#line 3849
  rev = c->read;
#line 3854
  (c->log)->action = (char *)"reading upstream";
#line 3856
  if (rev->timedout) {
    {
#line 3858
    p->upstream_error = 1U;
#line 3859
    ngx_connection_error(c, 110, (char *)"upstream timed out");
    }
  } else {
#line 3863
    if (rev->delayed) {
      {
#line 3868
      tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
      }
#line 3868
      if (tmp != 0L) {
        {
#line 3869
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
        }
      }
#line 3872
      return;
    }
    {
#line 3875
    tmp___0 = ngx_event_pipe(p, (ngx_int_t )0);
    }
#line 3875
    if (tmp___0 == -6L) {
      {
#line 3876
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
      }
#line 3877
      return;
    }
  }
  {
#line 3881
  ngx_http_upstream_process_request(r, u);
  }
#line 3882
  return;
}
}
#line 3885 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_process_request(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  ngx_temp_file_t *tf ;
  ngx_event_pipe_t *p ;
  char *__cil_tmp5 ;

  {
#line 3892
  p = u->pipe;
#line 3915
  if (u->peer.connection) {
#line 3917
    if (u->store) {
#line 3919
      if (p->upstream_eof) {
#line 3919
        goto _L___0;
      } else
#line 3919
      if (p->upstream_done) {
        _L___0: /* CIL Label */ 
#line 3921
        tf = p->temp_file;
#line 3923
        if (u->headers_in.status_n == 200UL) {
#line 3923
          if (p->upstream_done) {
#line 3923
            goto _L;
          } else
#line 3923
          if (p->length == -1L) {
            _L: /* CIL Label */ 
#line 3923
            if (u->headers_in.content_length_n == -1L) {
              {
#line 3928
              ngx_http_upstream_store(r, u);
              }
            } else
#line 3923
            if (u->headers_in.content_length_n == tf->offset) {
              {
#line 3928
              ngx_http_upstream_store(r, u);
              }
            }
          }
        }
      }
    }
#line 3935
    if (u->cacheable) {
#line 3937
      if (p->upstream_done) {
        {
#line 3938
        ngx_http_file_cache_update(r, p->temp_file);
        }
      } else
#line 3940
      if (p->upstream_eof) {
#line 3942
        tf = p->temp_file;
#line 3944
        if (p->length == -1L) {
#line 3944
          if (u->headers_in.content_length_n == -1L) {
            {
#line 3949
            ngx_http_file_cache_update(r, tf);
            }
          } else
#line 3944
          if (u->headers_in.content_length_n == tf->offset - (off_t )(r->cache)->body_start) {
            {
#line 3949
            ngx_http_file_cache_update(r, tf);
            }
          } else {
            {
#line 3952
            ngx_http_file_cache_free(r->cache, tf);
            }
          }
        } else {
          {
#line 3952
          ngx_http_file_cache_free(r->cache, tf);
          }
        }
      } else
#line 3955
      if (p->upstream_error) {
        {
#line 3956
        ngx_http_file_cache_free(r->cache, p->temp_file);
        }
      }
    }
#line 3962
    if (p->upstream_done) {
#line 3962
      goto _L___1;
    } else
#line 3962
    if (p->upstream_eof) {
#line 3962
      goto _L___1;
    } else
#line 3962
    if (p->upstream_error) {
      _L___1: /* CIL Label */ 
#line 3966
      if (p->upstream_done) {
        {
#line 3969
        ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
        }
#line 3970
        return;
      } else
#line 3966
      if (p->upstream_eof) {
#line 3966
        if (p->length == -1L) {
          {
#line 3969
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )0);
          }
#line 3970
          return;
        }
      }
#line 3973
      if (p->upstream_eof) {
#line 3974
        if (((r->connection)->log)->log_level >= 4UL) {
          {
#line 3974
          ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "upstream prematurely closed connection");
          }
        }
      }
      {
#line 3978
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )502);
      }
#line 3979
      return;
    }
  }
#line 3983
  if (p->downstream_error) {
#line 3987
    if (! u->cacheable) {
#line 3987
      if (! u->store) {
#line 3987
        if (u->peer.connection) {
          {
#line 3988
          ngx_http_upstream_finalize_request(r, u, (ngx_int_t )-1);
          }
        }
      }
    }
  }
#line 3991
  return;
}
}
#line 3994 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_store(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 
  size_t root ;
  time_t lm ;
  ngx_str_t path ;
  ngx_temp_file_t *tf ;
  ngx_ext_rename_file_t ext ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 4003
  tf = (u->pipe)->temp_file;
#line 4005
  if (tf->file.fd == -1) {
    {
#line 4009
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t ));
#line 4009
    tf = (ngx_temp_file_t *)tmp;
    }
#line 4010
    if ((unsigned long )tf == (unsigned long )((void *)0)) {
#line 4011
      return;
    }
    {
#line 4014
    tf->file.fd = -1;
#line 4015
    tf->file.log = (r->connection)->log;
#line 4016
    tf->path = (u->conf)->temp_path;
#line 4017
    tf->pool = r->pool;
#line 4018
    tf->persistent = 1U;
#line 4020
    tmp___0 = ngx_create_temp_file(& tf->file, tf->path, tf->pool, (ngx_uint_t )tf->persistent,
                                   (ngx_uint_t )tf->clean, tf->access);
    }
#line 4020
    if (tmp___0 != 0L) {
#line 4024
      return;
    }
#line 4027
    (u->pipe)->temp_file = tf;
  }
#line 4030
  ext.access = (u->conf)->store_access;
#line 4031
  ext.path_access = (u->conf)->store_access;
#line 4032
  ext.time = (time_t )-1;
#line 4033
  ext.create_path = 1U;
#line 4034
  ext.delete_file = 1U;
#line 4035
  ext.log = (r->connection)->log;
#line 4037
  if (u->headers_in.last_modified) {
    {
#line 4039
    lm = ngx_parse_http_time((u->headers_in.last_modified)->value.data, (u->headers_in.last_modified)->value.len);
    }
#line 4042
    if (lm != -1L) {
#line 4043
      ext.time = lm;
#line 4044
      ext.fd = tf->file.fd;
    }
  }
#line 4048
  if ((unsigned long )(u->conf)->store_lengths == (unsigned long )((void *)0)) {
    {
#line 4050
    tmp___1 = ngx_http_map_uri_to_path(r, & path, & root, (size_t )0);
    }
#line 4050
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 4051
      return;
    }
  } else {
    {
#line 4055
    tmp___2 = ngx_http_script_run(r, & path, ((u->conf)->store_lengths)->elts, (size_t )0,
                                  ((u->conf)->store_values)->elts);
    }
#line 4055
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 4059
      return;
    }
  }
  {
#line 4063
  (path.len) --;
#line 4069
  ngx_ext_rename_file(& tf->file.name, & path, & ext);
#line 4071
  u->store = 0U;
  }
#line 4072
  return;
}
}
#line 4075 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_dummy_handler(ngx_http_request_t *r , ngx_http_upstream_t *u ) 
{ 


  {
#line 4080
  return;
}
}
#line 4083 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_next(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                   ngx_uint_t ft_type ) 
{ 
  ngx_msec_t timeout ;
  ngx_uint_t status ;
  ngx_uint_t state ;
  ngx_int_t rc ;
  char *__cil_tmp8 ;

  {
#line 4093
  if (u->peer.sockaddr) {
#line 4095
    if (ft_type == 256UL) {
#line 4098
      state = (ngx_uint_t )2;
    } else
#line 4095
    if (ft_type == 512UL) {
#line 4098
      state = (ngx_uint_t )2;
    } else {
#line 4101
      state = (ngx_uint_t )4;
    }
    {
#line 4104
    (*(u->peer.free))(& u->peer, u->peer.data, state);
#line 4105
    u->peer.sockaddr = (struct sockaddr *)((void *)0);
    }
  }
#line 4108
  if (ft_type == 4UL) {
#line 4109
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 4109
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 110, "upstream timed out");
      }
    }
  }
#line 4113
  if (u->peer.cached) {
#line 4113
    if (ft_type == 2UL) {
#line 4115
      (u->peer.tries) ++;
    }
  }
  {
#line 4121
  if (ft_type == 128UL) {
#line 4121
    goto case_128;
  }
#line 4121
  if (ft_type == 4UL) {
#line 4121
    goto case_128;
  }
#line 4125
  if (ft_type == 16UL) {
#line 4125
    goto case_16;
  }
#line 4129
  if (ft_type == 64UL) {
#line 4129
    goto case_64;
  }
#line 4133
  if (ft_type == 256UL) {
#line 4133
    goto case_256;
  }
#line 4137
  if (ft_type == 512UL) {
#line 4137
    goto case_512;
  }
#line 4141
  if (ft_type == 1024UL) {
#line 4141
    goto case_1024;
  }
#line 4150
  goto switch_default;
  case_128: /* CIL Label */ 
  case_4: /* CIL Label */ 
#line 4122
  status = (ngx_uint_t )504;
#line 4123
  goto switch_break;
  case_16: /* CIL Label */ 
#line 4126
  status = (ngx_uint_t )500;
#line 4127
  goto switch_break;
  case_64: /* CIL Label */ 
#line 4130
  status = (ngx_uint_t )503;
#line 4131
  goto switch_break;
  case_256: /* CIL Label */ 
#line 4134
  status = (ngx_uint_t )403;
#line 4135
  goto switch_break;
  case_512: /* CIL Label */ 
#line 4138
  status = (ngx_uint_t )404;
#line 4139
  goto switch_break;
  case_1024: /* CIL Label */ 
#line 4142
  status = (ngx_uint_t )429;
#line 4143
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 4151
  status = (ngx_uint_t )502;
  switch_break: /* CIL Label */ ;
  }
#line 4154
  if ((r->connection)->error) {
    {
#line 4155
    ngx_http_upstream_finalize_request(r, u, (ngx_int_t )499);
    }
#line 4157
    return;
  }
#line 4160
  (u->state)->status = status;
#line 4162
  timeout = (u->conf)->next_upstream_timeout;
#line 4164
  if (u->request_sent) {
#line 4164
    if (r->method & 20488UL) {
#line 4167
      ft_type |= 16384UL;
    }
  }
#line 4170
  if (u->peer.tries == 0UL) {
#line 4170
    goto _L___0;
  } else
#line 4170
  if (((u->conf)->next_upstream & ft_type) != ft_type) {
#line 4170
    goto _L___0;
  } else
#line 4170
  if (u->request_sent) {
#line 4170
    if (r->request_body_no_buffering) {
#line 4170
      goto _L___0;
    } else {
#line 4170
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 4170
  if (timeout) {
#line 4170
    if (ngx_current_msec - (ngx_msec_t volatile   )u->peer.start_time >= (ngx_msec_t volatile   )timeout) {
      _L___0: /* CIL Label */ 
#line 4177
      if (u->cache_status == 3U) {
#line 4177
        if ((u->conf)->cache_use_stale & ft_type) {
#line 4177
          goto _L;
        } else
#line 4177
        if ((r->cache)->stale_error) {
          _L: /* CIL Label */ 
          {
#line 4182
          rc = (*(u->reinit_request))(r);
          }
#line 4184
          if (rc != 0L) {
            {
#line 4185
            ngx_http_upstream_finalize_request(r, u, rc);
            }
#line 4186
            return;
          }
          {
#line 4189
          u->cache_status = 4U;
#line 4190
          rc = ngx_http_upstream_cache_send(r, u);
          }
#line 4192
          if (rc == -4L) {
#line 4193
            return;
          }
#line 4196
          if (rc == 40L) {
#line 4197
            rc = (ngx_int_t )500;
          }
          {
#line 4200
          ngx_http_upstream_finalize_request(r, u, rc);
          }
#line 4201
          return;
        }
      }
      {
#line 4205
      ngx_http_upstream_finalize_request(r, u, (ngx_int_t )status);
      }
#line 4206
      return;
    }
  }
#line 4209
  if (u->peer.connection) {
#line 4223
    if ((u->peer.connection)->pool) {
      {
#line 4224
      ngx_destroy_pool((u->peer.connection)->pool);
      }
    }
    {
#line 4227
    ngx_close_connection(u->peer.connection);
#line 4228
    u->peer.connection = (ngx_connection_t *)((void *)0);
    }
  }
  {
#line 4231
  ngx_http_upstream_connect(r, u);
  }
#line 4232
  return;
}
}
#line 4235 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_cleanup(void *data ) 
{ 
  ngx_http_request_t *r ;

  {
  {
#line 4238
  r = (ngx_http_request_t *)data;
#line 4243
  ngx_http_upstream_finalize_request(r, r->upstream, (ngx_int_t )-4);
  }
#line 4244
  return;
}
}
#line 4247 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void ngx_http_upstream_finalize_request(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                               ngx_int_t rc ) 
{ 
  ngx_uint_t flush ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  time_t valid ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 4256
  if ((unsigned long )u->cleanup == (unsigned long )((void *)0)) {
    {
#line 4258
    ngx_http_finalize_request(r, (ngx_int_t )-4);
    }
#line 4259
    return;
  }
#line 4262
  *(u->cleanup) = (ngx_http_cleanup_pt )((void *)0);
#line 4263
  u->cleanup = (ngx_http_cleanup_pt *)((void *)0);
#line 4265
  if (u->resolved) {
#line 4265
    if ((u->resolved)->ctx) {
      {
#line 4266
      ngx_resolve_name_done((u->resolved)->ctx);
#line 4267
      (u->resolved)->ctx = (ngx_resolver_ctx_t *)((void *)0);
      }
    }
  }
#line 4270
  if (u->state) {
#line 4270
    if ((u->state)->response_time) {
#line 4271
      (u->state)->response_time = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )(u->state)->response_time);
#line 4273
      if (u->pipe) {
#line 4273
        if ((u->pipe)->read_length) {
#line 4274
          (u->state)->bytes_received = (off_t )((size_t )(u->state)->bytes_received + ((size_t )(u->pipe)->read_length - (u->pipe)->preread_size));
#line 4276
          (u->state)->response_length = (u->pipe)->read_length;
        }
      }
    }
  }
  {
#line 4280
  (*(u->finalize_request))(r, rc);
  }
#line 4282
  if (u->peer.free) {
#line 4282
    if (u->peer.sockaddr) {
      {
#line 4283
      (*(u->peer.free))(& u->peer, u->peer.data, (ngx_uint_t )0);
#line 4284
      u->peer.sockaddr = (struct sockaddr *)((void *)0);
      }
    }
  }
#line 4287
  if (u->peer.connection) {
#line 4311
    if ((u->peer.connection)->pool) {
      {
#line 4312
      ngx_destroy_pool((u->peer.connection)->pool);
      }
    }
    {
#line 4315
    ngx_close_connection(u->peer.connection);
    }
  }
#line 4318
  u->peer.connection = (ngx_connection_t *)((void *)0);
#line 4320
  if (u->pipe) {
#line 4320
    if ((u->pipe)->temp_file) {
#line 4320
      tmp = 1;
    } else {
#line 4320
      tmp = 0;
    }
  } else {
#line 4320
    tmp = 0;
  }
#line 4326
  if (u->store) {
#line 4326
    if (u->pipe) {
#line 4326
      if ((u->pipe)->temp_file) {
#line 4326
        if (((u->pipe)->temp_file)->file.fd != -1) {
          {
#line 4329
          tmp___1 = unlink((char const   *)((u->pipe)->temp_file)->file.name.data);
          }
#line 4329
          if (tmp___1 == -1) {
#line 4332
            if (((r->connection)->log)->log_level >= 3UL) {
              {
#line 4332
              tmp___0 = __errno_location();
#line 4332
              ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___0, "unlink() \"%s\" failed",
                                 ((u->pipe)->temp_file)->file.name.data);
              }
            }
          }
        }
      }
    }
  }
#line 4340
  if (r->cache) {
#line 4342
    if (u->cacheable) {
#line 4344
      if (rc == 502L) {
#line 4344
        goto _L;
      } else
#line 4344
      if (rc == 504L) {
        _L: /* CIL Label */ 
        {
#line 4347
        valid = ngx_http_file_cache_valid((u->conf)->cache_valid, (ngx_uint_t )rc);
        }
#line 4349
        if (valid) {
#line 4350
          (r->cache)->valid_sec = (time_t )(ngx_cached_time->sec + (time_t volatile   )valid);
#line 4351
          (r->cache)->error = (ngx_uint_t )rc;
        }
      }
    }
    {
#line 4356
    ngx_http_file_cache_free(r->cache, (u->pipe)->temp_file);
    }
  }
#line 4361
  if (r->subrequest_in_memory) {
#line 4361
    if (u->headers_in.status_n >= 300UL) {
#line 4364
      u->buffer.last = u->buffer.pos;
    }
  }
#line 4367
  r->read_event_handler = & ngx_http_block_reading;
#line 4369
  if (rc == -5L) {
#line 4370
    return;
  }
#line 4373
  ((r->connection)->log)->action = (char *)"sending to client";
#line 4375
  if (! u->header_sent) {
    {
#line 4380
    ngx_http_finalize_request(r, rc);
    }
#line 4381
    return;
  } else
#line 4375
  if (rc == 408L) {
    {
#line 4380
    ngx_http_finalize_request(r, rc);
    }
#line 4381
    return;
  } else
#line 4375
  if (rc == 499L) {
    {
#line 4380
    ngx_http_finalize_request(r, rc);
    }
#line 4381
    return;
  } else
#line 4375
  if (u->pipe) {
#line 4375
    if ((u->pipe)->downstream_error) {
      {
#line 4380
      ngx_http_finalize_request(r, rc);
      }
#line 4381
      return;
    }
  }
#line 4384
  flush = (ngx_uint_t )0;
#line 4386
  if (rc >= 300L) {
#line 4387
    rc = (ngx_int_t )-1;
#line 4388
    flush = (ngx_uint_t )1;
  }
#line 4391
  if (r->header_only) {
    {
#line 4392
    ngx_http_finalize_request(r, rc);
    }
#line 4393
    return;
  }
#line 4396
  if (rc == 0L) {
    {
#line 4397
    rc = ngx_http_send_special(r, (ngx_uint_t )1);
    }
  } else
#line 4399
  if (flush) {
    {
#line 4400
    r->keepalive = 0U;
#line 4401
    rc = ngx_http_send_special(r, (ngx_uint_t )2);
    }
  }
  {
#line 4404
  ngx_http_finalize_request(r, rc);
  }
#line 4405
  return;
}
}
#line 4408 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                       ngx_uint_t offset ) 
{ 
  ngx_table_elt_t **ph ;

  {
#line 4414
  ph = (ngx_table_elt_t **)((char *)(& (r->upstream)->headers_in) + offset);
#line 4416
  if ((unsigned long )*ph == (unsigned long )((void *)0)) {
#line 4417
    *ph = h;
  }
#line 4420
  return ((ngx_int_t )0);
}
}
#line 4424 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_ignore_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 


  {
#line 4428
  return ((ngx_int_t )0);
}
}
#line 4432 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_content_length(ngx_http_request_t *r ,
                                                          ngx_table_elt_t *h , ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;

  {
  {
#line 4438
  u = r->upstream;
#line 4440
  u->headers_in.content_length = h;
#line 4441
  u->headers_in.content_length_n = ngx_atoof(h->value.data, h->value.len);
  }
#line 4443
  return ((ngx_int_t )0);
}
}
#line 4447 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_last_modified(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;

  {
  {
#line 4453
  u = r->upstream;
#line 4455
  u->headers_in.last_modified = h;
#line 4456
  u->headers_in.last_modified_time = ngx_parse_http_time(h->value.data, h->value.len);
  }
#line 4459
  return ((ngx_int_t )0);
}
}
#line 4463 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_set_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  ngx_array_t *pa ;
  ngx_table_elt_t **ph ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
#line 4471
  u = r->upstream;
#line 4472
  pa = & u->headers_in.cookies;
#line 4474
  if ((unsigned long )pa->elts == (unsigned long )((void *)0)) {
    {
#line 4475
    tmp = ngx_array_init(pa, r->pool, (ngx_uint_t )1, sizeof(ngx_table_elt_t *));
    }
#line 4475
    if (tmp != 0L) {
#line 4477
      return ((ngx_int_t )-1);
    }
  }
  {
#line 4481
  tmp___0 = ngx_array_push(pa);
#line 4481
  ph = (ngx_table_elt_t **)tmp___0;
  }
#line 4482
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 4483
    return ((ngx_int_t )-1);
  }
#line 4486
  *ph = h;
#line 4489
  if (! ((u->conf)->ignore_headers & 32UL)) {
#line 4490
    u->cacheable = 0U;
  }
#line 4494
  return ((ngx_int_t )0);
}
}
#line 4498 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_cache_control(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) 
{ 
  ngx_array_t *pa ;
  ngx_table_elt_t **ph ;
  ngx_http_upstream_t *u ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  u_char *p ;
  u_char *start ;
  u_char *last ;
  ngx_int_t n ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 4506
  u = r->upstream;
#line 4507
  pa = & u->headers_in.cache_control;
#line 4509
  if ((unsigned long )pa->elts == (unsigned long )((void *)0)) {
    {
#line 4510
    tmp = ngx_array_init(pa, r->pool, (ngx_uint_t )2, sizeof(ngx_table_elt_t *));
    }
#line 4510
    if (tmp != 0L) {
#line 4512
      return ((ngx_int_t )-1);
    }
  }
  {
#line 4516
  tmp___0 = ngx_array_push(pa);
#line 4516
  ph = (ngx_table_elt_t **)tmp___0;
  }
#line 4517
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 4518
    return ((ngx_int_t )-1);
  }
#line 4521
  *ph = h;
#line 4528
  if ((u->conf)->ignore_headers & 16UL) {
#line 4529
    return ((ngx_int_t )0);
  }
#line 4532
  if ((unsigned long )r->cache == (unsigned long )((void *)0)) {
#line 4533
    return ((ngx_int_t )0);
  }
#line 4536
  if ((r->cache)->valid_sec != 0L) {
#line 4536
    if ((unsigned long )u->headers_in.x_accel_expires != (unsigned long )((void *)0)) {
#line 4537
      return ((ngx_int_t )0);
    }
  }
  {
#line 4540
  start = h->value.data;
#line 4541
  last = start + h->value.len;
#line 4543
  tmp___1 = ngx_strlcasestrn(start, last, (u_char *)"no-cache", (size_t )7);
  }
#line 4543
  if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 4547
    u->cacheable = 0U;
#line 4548
    return ((ngx_int_t )0);
  } else {
    {
#line 4543
    tmp___2 = ngx_strlcasestrn(start, last, (u_char *)"no-store", (size_t )7);
    }
#line 4543
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 4547
      u->cacheable = 0U;
#line 4548
      return ((ngx_int_t )0);
    } else {
      {
#line 4543
      tmp___3 = ngx_strlcasestrn(start, last, (u_char *)"private", (size_t )6);
      }
#line 4543
      if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 4547
        u->cacheable = 0U;
#line 4548
        return ((ngx_int_t )0);
      }
    }
  }
  {
#line 4551
  p = ngx_strlcasestrn(start, last, (u_char *)"s-maxage=", (size_t )8);
#line 4552
  offset = (ngx_uint_t )9;
  }
#line 4554
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 4555
    p = ngx_strlcasestrn(start, last, (u_char *)"max-age=", (size_t )7);
#line 4556
    offset = (ngx_uint_t )8;
    }
  }
#line 4559
  if (p) {
#line 4560
    n = (ngx_int_t )0;
#line 4562
    p += offset;
    {
#line 4562
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4562
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 4562
        goto while_break;
      }
#line 4563
      if ((int )*p == 44) {
#line 4564
        goto while_break;
      } else
#line 4563
      if ((int )*p == 59) {
#line 4564
        goto while_break;
      } else
#line 4563
      if ((int )*p == 32) {
#line 4564
        goto while_break;
      }
#line 4567
      if ((int )*p >= 48) {
#line 4567
        if ((int )*p <= 57) {
#line 4568
          n = n * 10L + (ngx_int_t )((int )*p - 48);
#line 4569
          goto __Cont;
        }
      }
#line 4572
      u->cacheable = 0U;
#line 4573
      return ((ngx_int_t )0);
      __Cont: /* CIL Label */ 
#line 4562
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 4576
    if (n == 0L) {
#line 4577
      u->cacheable = 0U;
#line 4578
      return ((ngx_int_t )0);
    }
#line 4581
    (r->cache)->valid_sec = (time_t )(ngx_cached_time->sec + (time_t volatile   )n);
  }
  {
#line 4584
  p = ngx_strlcasestrn(start, last, (u_char *)"stale-while-revalidate=", (size_t )22);
  }
#line 4587
  if (p) {
#line 4588
    n = (ngx_int_t )0;
#line 4590
    p += 23;
    {
#line 4590
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4590
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 4590
        goto while_break___0;
      }
#line 4591
      if ((int )*p == 44) {
#line 4592
        goto while_break___0;
      } else
#line 4591
      if ((int )*p == 59) {
#line 4592
        goto while_break___0;
      } else
#line 4591
      if ((int )*p == 32) {
#line 4592
        goto while_break___0;
      }
#line 4595
      if ((int )*p >= 48) {
#line 4595
        if ((int )*p <= 57) {
#line 4596
          n = n * 10L + (ngx_int_t )((int )*p - 48);
#line 4597
          goto __Cont___0;
        }
      }
#line 4600
      u->cacheable = 0U;
#line 4601
      return ((ngx_int_t )0);
      __Cont___0: /* CIL Label */ 
#line 4590
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4604
    (r->cache)->updating_sec = n;
#line 4605
    (r->cache)->error_sec = n;
  }
  {
#line 4608
  p = ngx_strlcasestrn(start, last, (u_char *)"stale-if-error=", (size_t )14);
  }
#line 4610
  if (p) {
#line 4611
    n = (ngx_int_t )0;
#line 4613
    p += 15;
    {
#line 4613
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4613
      if (! ((unsigned long )p < (unsigned long )last)) {
#line 4613
        goto while_break___1;
      }
#line 4614
      if ((int )*p == 44) {
#line 4615
        goto while_break___1;
      } else
#line 4614
      if ((int )*p == 59) {
#line 4615
        goto while_break___1;
      } else
#line 4614
      if ((int )*p == 32) {
#line 4615
        goto while_break___1;
      }
#line 4618
      if ((int )*p >= 48) {
#line 4618
        if ((int )*p <= 57) {
#line 4619
          n = n * 10L + (ngx_int_t )((int )*p - 48);
#line 4620
          goto __Cont___1;
        }
      }
#line 4623
      u->cacheable = 0U;
#line 4624
      return ((ngx_int_t )0);
      __Cont___1: /* CIL Label */ 
#line 4613
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4627
    (r->cache)->error_sec = n;
  }
#line 4632
  return ((ngx_int_t )0);
}
}
#line 4636 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_expires(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;
  time_t expires___0 ;

  {
#line 4642
  u = r->upstream;
#line 4643
  u->headers_in.expires = h;
#line 4649
  if ((u->conf)->ignore_headers & 8UL) {
#line 4650
    return ((ngx_int_t )0);
  }
#line 4653
  if ((unsigned long )r->cache == (unsigned long )((void *)0)) {
#line 4654
    return ((ngx_int_t )0);
  }
#line 4657
  if ((r->cache)->valid_sec != 0L) {
#line 4658
    return ((ngx_int_t )0);
  }
  {
#line 4661
  expires___0 = ngx_parse_http_time(h->value.data, h->value.len);
  }
#line 4663
  if (expires___0 == -1L) {
#line 4664
    u->cacheable = 0U;
#line 4665
    return ((ngx_int_t )0);
  } else
#line 4663
  if (expires___0 < (time_t )ngx_cached_time->sec) {
#line 4664
    u->cacheable = 0U;
#line 4665
    return ((ngx_int_t )0);
  }
#line 4668
  (r->cache)->valid_sec = expires___0;
#line 4672
  return ((ngx_int_t )0);
}
}
#line 4676 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_accel_expires(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;
  u_char *p ;
  size_t len ;
  ngx_int_t n ;

  {
#line 4682
  u = r->upstream;
#line 4683
  u->headers_in.x_accel_expires = h;
#line 4691
  if ((u->conf)->ignore_headers & 4UL) {
#line 4692
    return ((ngx_int_t )0);
  }
#line 4695
  if ((unsigned long )r->cache == (unsigned long )((void *)0)) {
#line 4696
    return ((ngx_int_t )0);
  }
#line 4699
  len = h->value.len;
#line 4700
  p = h->value.data;
#line 4702
  if ((int )*(p + 0) != 64) {
    {
#line 4703
    n = ngx_atoi(p, len);
    }
    {
#line 4706
    if (n == 0L) {
#line 4706
      goto case_0;
    }
#line 4710
    if (n == -1L) {
#line 4710
      goto case_neg_1;
    }
#line 4713
    goto switch_default;
    case_0: /* CIL Label */ 
#line 4707
    u->cacheable = 0U;
    case_neg_1: /* CIL Label */ 
#line 4711
    return ((ngx_int_t )0);
    switch_default: /* CIL Label */ 
#line 4714
    (r->cache)->valid_sec = (time_t )(ngx_cached_time->sec + (time_t volatile   )n);
#line 4715
    return ((ngx_int_t )0);
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 4719
  p ++;
#line 4720
  len --;
#line 4722
  n = ngx_atoi(p, len);
  }
#line 4724
  if (n != -1L) {
#line 4725
    (r->cache)->valid_sec = n;
  }
#line 4730
  return ((ngx_int_t )0);
}
}
#line 4734 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_limit_rate(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  ngx_int_t n ;
  ngx_http_upstream_t *u ;

  {
#line 4741
  u = r->upstream;
#line 4742
  u->headers_in.x_accel_limit_rate = h;
#line 4744
  if ((u->conf)->ignore_headers & 64UL) {
#line 4745
    return ((ngx_int_t )0);
  }
  {
#line 4748
  n = ngx_atoi(h->value.data, h->value.len);
  }
#line 4750
  if (n != -1L) {
#line 4751
    r->limit_rate = (size_t )n;
  }
#line 4754
  return ((ngx_int_t )0);
}
}
#line 4758 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_buffering(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  u_char c0 ;
  u_char c1 ;
  u_char c2 ;
  ngx_http_upstream_t *u ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 4765
  u = r->upstream;
#line 4767
  if ((u->conf)->ignore_headers & 128UL) {
#line 4768
    return ((ngx_int_t )0);
  }
#line 4771
  if ((u->conf)->change_buffering) {
#line 4773
    if (h->value.len == 2UL) {
#line 4774
      if ((int )*(h->value.data + 0) >= 65) {
#line 4774
        if ((int )*(h->value.data + 0) <= 90) {
#line 4774
          tmp = (int )*(h->value.data + 0) | 32;
        } else {
#line 4774
          tmp = (int )*(h->value.data + 0);
        }
      } else {
#line 4774
        tmp = (int )*(h->value.data + 0);
      }
#line 4774
      c0 = (u_char )tmp;
#line 4775
      if ((int )*(h->value.data + 1) >= 65) {
#line 4775
        if ((int )*(h->value.data + 1) <= 90) {
#line 4775
          tmp___0 = (int )*(h->value.data + 1) | 32;
        } else {
#line 4775
          tmp___0 = (int )*(h->value.data + 1);
        }
      } else {
#line 4775
        tmp___0 = (int )*(h->value.data + 1);
      }
#line 4775
      c1 = (u_char )tmp___0;
#line 4777
      if ((int )c0 == 110) {
#line 4777
        if ((int )c1 == 111) {
#line 4778
          u->buffering = 0U;
        }
      }
    } else
#line 4781
    if (h->value.len == 3UL) {
#line 4782
      if ((int )*(h->value.data + 0) >= 65) {
#line 4782
        if ((int )*(h->value.data + 0) <= 90) {
#line 4782
          tmp___1 = (int )*(h->value.data + 0) | 32;
        } else {
#line 4782
          tmp___1 = (int )*(h->value.data + 0);
        }
      } else {
#line 4782
        tmp___1 = (int )*(h->value.data + 0);
      }
#line 4782
      c0 = (u_char )tmp___1;
#line 4783
      if ((int )*(h->value.data + 1) >= 65) {
#line 4783
        if ((int )*(h->value.data + 1) <= 90) {
#line 4783
          tmp___2 = (int )*(h->value.data + 1) | 32;
        } else {
#line 4783
          tmp___2 = (int )*(h->value.data + 1);
        }
      } else {
#line 4783
        tmp___2 = (int )*(h->value.data + 1);
      }
#line 4783
      c1 = (u_char )tmp___2;
#line 4784
      if ((int )*(h->value.data + 2) >= 65) {
#line 4784
        if ((int )*(h->value.data + 2) <= 90) {
#line 4784
          tmp___3 = (int )*(h->value.data + 2) | 32;
        } else {
#line 4784
          tmp___3 = (int )*(h->value.data + 2);
        }
      } else {
#line 4784
        tmp___3 = (int )*(h->value.data + 2);
      }
#line 4784
      c2 = (u_char )tmp___3;
#line 4786
      if ((int )c0 == 121) {
#line 4786
        if ((int )c1 == 101) {
#line 4786
          if ((int )c2 == 115) {
#line 4787
            u->buffering = 1U;
          }
        }
      }
    }
  }
#line 4792
  return ((ngx_int_t )0);
}
}
#line 4796 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_charset(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) 
{ 


  {
#line 4800
  if (((r->upstream)->conf)->ignore_headers & 256UL) {
#line 4801
    return ((ngx_int_t )0);
  }
#line 4804
  r->headers_out.override_charset = & h->value;
#line 4806
  return ((ngx_int_t )0);
}
}
#line 4810 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_connection(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  u_char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 4814
  (r->upstream)->headers_in.connection = h;
#line 4816
  tmp = ngx_strlcasestrn(h->value.data, h->value.data + h->value.len, (u_char *)"close",
                         (size_t )4);
  }
#line 4816
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 4820
    (r->upstream)->headers_in.connection_close = 1U;
  }
#line 4823
  return ((ngx_int_t )0);
}
}
#line 4827 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_transfer_encoding(ngx_http_request_t *r ,
                                                             ngx_table_elt_t *h ,
                                                             ngx_uint_t offset ) 
{ 
  u_char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 4831
  (r->upstream)->headers_in.transfer_encoding = h;
#line 4833
  tmp = ngx_strlcasestrn(h->value.data, h->value.data + h->value.len, (u_char *)"chunked",
                         (size_t )6);
  }
#line 4833
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 4837
    (r->upstream)->headers_in.chunked = 1U;
  }
#line 4840
  return ((ngx_int_t )0);
}
}
#line 4844 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_process_vary(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                ngx_uint_t offset ) 
{ 
  ngx_http_upstream_t *u ;

  {
#line 4850
  u = r->upstream;
#line 4851
  u->headers_in.vary = h;
#line 4855
  if ((u->conf)->ignore_headers & 512UL) {
#line 4856
    return ((ngx_int_t )0);
  }
#line 4859
  if ((unsigned long )r->cache == (unsigned long )((void *)0)) {
#line 4860
    return ((ngx_int_t )0);
  }
#line 4863
  if (h->value.len > 128UL) {
#line 4866
    u->cacheable = 0U;
  } else
#line 4863
  if (h->value.len == 1UL) {
#line 4863
    if ((int )*(h->value.data + 0) == 42) {
#line 4866
      u->cacheable = 0U;
    }
  }
#line 4869
  (r->cache)->vary = h->value;
#line 4873
  return ((ngx_int_t )0);
}
}
#line 4877 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                    ngx_uint_t offset ) 
{ 
  ngx_table_elt_t *ho ;
  ngx_table_elt_t **ph ;
  void *tmp ;

  {
  {
#line 4883
  tmp = ngx_list_push(& r->headers_out.headers);
#line 4883
  ho = (ngx_table_elt_t *)tmp;
  }
#line 4884
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 4885
    return ((ngx_int_t )-1);
  }
#line 4888
  *ho = *h;
#line 4890
  if (offset) {
#line 4891
    ph = (ngx_table_elt_t **)((char *)(& r->headers_out) + offset);
#line 4892
    *ph = ho;
  }
#line 4895
  return ((ngx_int_t )0);
}
}
#line 4899 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_multi_header_lines(ngx_http_request_t *r ,
                                                           ngx_table_elt_t *h , ngx_uint_t offset ) 
{ 
  ngx_array_t *pa ;
  ngx_table_elt_t *ho ;
  ngx_table_elt_t **ph ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 4906
  pa = (ngx_array_t *)((char *)(& r->headers_out) + offset);
#line 4908
  if ((unsigned long )pa->elts == (unsigned long )((void *)0)) {
    {
#line 4909
    tmp = ngx_array_init(pa, r->pool, (ngx_uint_t )2, sizeof(ngx_table_elt_t *));
    }
#line 4909
    if (tmp != 0L) {
#line 4911
      return ((ngx_int_t )-1);
    }
  }
  {
#line 4915
  tmp___0 = ngx_list_push(& r->headers_out.headers);
#line 4915
  ho = (ngx_table_elt_t *)tmp___0;
  }
#line 4916
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 4917
    return ((ngx_int_t )-1);
  }
  {
#line 4920
  *ho = *h;
#line 4922
  tmp___1 = ngx_array_push(pa);
#line 4922
  ph = (ngx_table_elt_t **)tmp___1;
  }
#line 4923
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 4924
    return ((ngx_int_t )-1);
  }
#line 4927
  *ph = ho;
#line 4929
  return ((ngx_int_t )0);
}
}
#line 4933 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_content_type(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  u_char *p ;
  u_char *last ;
  ngx_int_t tmp ;
  char *__cil_tmp7 ;

  {
#line 4939
  r->headers_out.content_type_len = h->value.len;
#line 4940
  r->headers_out.content_type = h->value;
#line 4941
  r->headers_out.content_type_lowcase = (u_char *)((void *)0);
#line 4943
  p = h->value.data;
  {
#line 4943
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4943
    if (! *p) {
#line 4943
      goto while_break;
    }
#line 4945
    if ((int )*p != 59) {
#line 4946
      goto __Cont;
    }
#line 4949
    last = p;
    {
#line 4951
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4951
      p ++;
#line 4951
      if (! ((int )*p == 32)) {
#line 4951
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 4953
    if ((int )*p == 0) {
#line 4954
      return ((ngx_int_t )0);
    }
    {
#line 4957
    tmp = ngx_strncasecmp(p, (u_char *)"charset=", (size_t )8);
    }
#line 4957
    if (tmp != 0L) {
#line 4958
      goto __Cont;
    }
#line 4961
    p += 8;
#line 4963
    r->headers_out.content_type_len = (size_t )(last - h->value.data);
#line 4965
    if ((int )*p == 34) {
#line 4966
      p ++;
    }
#line 4969
    last = h->value.data + h->value.len;
#line 4971
    if ((int )*(last - 1) == 34) {
#line 4972
      last --;
    }
#line 4975
    r->headers_out.charset.len = (size_t )(last - p);
#line 4976
    r->headers_out.charset.data = p;
#line 4978
    return ((ngx_int_t )0);
    __Cont: /* CIL Label */ 
#line 4943
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4981
  return ((ngx_int_t )0);
}
}
#line 4985 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_last_modified(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 4991
  tmp = ngx_list_push(& r->headers_out.headers);
#line 4991
  ho = (ngx_table_elt_t *)tmp;
  }
#line 4992
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 4993
    return ((ngx_int_t )-1);
  }
#line 4996
  *ho = *h;
#line 4998
  r->headers_out.last_modified = ho;
#line 4999
  r->headers_out.last_modified_time = (r->upstream)->headers_in.last_modified_time;
#line 5002
  return ((ngx_int_t )0);
}
}
#line 5006 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_rewrite_location(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                    ngx_uint_t offset ) 
{ 
  ngx_int_t rc ;
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 5013
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5013
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5014
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5015
    return ((ngx_int_t )-1);
  }
#line 5018
  *ho = *h;
#line 5020
  if ((r->upstream)->rewrite_redirect) {
    {
#line 5021
    rc = (*((r->upstream)->rewrite_redirect))(r, ho, (size_t )0);
    }
#line 5023
    if (rc == -5L) {
#line 5024
      return ((ngx_int_t )0);
    }
#line 5027
    if (rc == 0L) {
#line 5028
      r->headers_out.location = ho;
    }
#line 5034
    return (rc);
  }
#line 5037
  if ((int )*(ho->value.data + 0) != 47) {
#line 5038
    r->headers_out.location = ho;
  }
#line 5046
  return ((ngx_int_t )0);
}
}
#line 5050 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_rewrite_refresh(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                   ngx_uint_t offset ) 
{ 
  u_char *p ;
  ngx_int_t rc ;
  ngx_table_elt_t *ho ;
  void *tmp ;
  char *__cil_tmp8 ;

  {
  {
#line 5058
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5058
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5059
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5060
    return ((ngx_int_t )-1);
  }
#line 5063
  *ho = *h;
#line 5065
  if ((r->upstream)->rewrite_redirect) {
    {
#line 5067
    p = ngx_strcasestrn(ho->value.data, (char *)"url=", (size_t )3);
    }
#line 5069
    if (p) {
      {
#line 5070
      rc = (*((r->upstream)->rewrite_redirect))(r, ho, (size_t )((p + 4) - ho->value.data));
      }
    } else {
#line 5073
      return ((ngx_int_t )0);
    }
#line 5076
    if (rc == -5L) {
#line 5077
      return ((ngx_int_t )0);
    }
#line 5080
    if (rc == 0L) {
#line 5081
      r->headers_out.refresh = ho;
    }
#line 5087
    return (rc);
  }
#line 5090
  r->headers_out.refresh = ho;
#line 5092
  return ((ngx_int_t )0);
}
}
#line 5096 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_rewrite_set_cookie(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                      ngx_uint_t offset ) 
{ 
  ngx_int_t rc ;
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 5103
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5103
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5104
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5105
    return ((ngx_int_t )-1);
  }
#line 5108
  *ho = *h;
#line 5110
  if ((r->upstream)->rewrite_cookie) {
    {
#line 5111
    rc = (*((r->upstream)->rewrite_cookie))(r, ho);
    }
#line 5113
    if (rc == -5L) {
#line 5114
      return ((ngx_int_t )0);
    }
#line 5124
    return (rc);
  }
#line 5127
  return ((ngx_int_t )0);
}
}
#line 5131 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_allow_ranges(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
#line 5137
  if (((r->upstream)->conf)->force_ranges) {
#line 5138
    return ((ngx_int_t )0);
  }
#line 5143
  if (r->cached) {
#line 5144
    r->allow_ranges = 1U;
#line 5145
    return ((ngx_int_t )0);
  }
#line 5148
  if ((r->upstream)->cacheable) {
#line 5149
    r->allow_ranges = 1U;
#line 5150
    r->single_range = 1U;
#line 5151
    return ((ngx_int_t )0);
  }
  {
#line 5156
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5156
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5157
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5158
    return ((ngx_int_t )-1);
  }
#line 5161
  *ho = *h;
#line 5163
  r->headers_out.accept_ranges = ho;
#line 5165
  return ((ngx_int_t )0);
}
}
#line 5171 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_copy_content_encoding(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                         ngx_uint_t offset ) 
{ 
  ngx_table_elt_t *ho ;
  void *tmp ;

  {
  {
#line 5177
  tmp = ngx_list_push(& r->headers_out.headers);
#line 5177
  ho = (ngx_table_elt_t *)tmp;
  }
#line 5178
  if ((unsigned long )ho == (unsigned long )((void *)0)) {
#line 5179
    return ((ngx_int_t )-1);
  }
#line 5182
  *ho = *h;
#line 5184
  r->headers_out.content_encoding = ho;
#line 5186
  return ((ngx_int_t )0);
}
}
#line 5192 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_add_variables(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *var ;
  ngx_http_variable_t *v ;

  {
#line 5197
  v = ngx_http_upstream_vars;
  {
#line 5197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5197
    if (! v->name.len) {
#line 5197
      goto while_break;
    }
    {
#line 5198
    var = ngx_http_add_variable(cf, & v->name, v->flags);
    }
#line 5199
    if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 5200
      return ((ngx_int_t )-1);
    }
#line 5203
    var->get_handler = v->get_handler;
#line 5204
    var->data = v->data;
#line 5197
    v ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 5207
  return ((ngx_int_t )0);
}
}
#line 5211 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_addr_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_uint_t i ;
  ngx_http_upstream_state_t *state ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;

  {
#line 5220
  v->valid = 1U;
#line 5221
  v->no_cacheable = 0U;
#line 5222
  v->not_found = 0U;
#line 5224
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
#line 5225
    v->not_found = 1U;
#line 5226
    return ((ngx_int_t )0);
  } else
#line 5224
  if ((r->upstream_states)->nelts == 0UL) {
#line 5225
    v->not_found = 1U;
#line 5226
    return ((ngx_int_t )0);
  }
#line 5229
  len = (size_t )0;
#line 5230
  state = (ngx_http_upstream_state_t *)(r->upstream_states)->elts;
#line 5232
  i = (ngx_uint_t )0;
  {
#line 5232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5232
    if (! (i < (r->upstream_states)->nelts)) {
#line 5232
      goto while_break;
    }
#line 5233
    if ((state + i)->peer) {
#line 5234
      len += ((state + i)->peer)->len + 2UL;
    } else {
#line 5237
      len += 3UL;
    }
#line 5232
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5241
  tmp = ngx_pnalloc(r->pool, len);
#line 5241
  p = (u_char *)tmp;
  }
#line 5242
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5243
    return ((ngx_int_t )-1);
  }
#line 5246
  v->data = p;
#line 5248
  i = (ngx_uint_t )0;
  {
#line 5250
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 5251
    if ((state + i)->peer) {
      {
#line 5252
      tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)((state + i)->peer)->data,
                       ((state + i)->peer)->len);
#line 5252
      p = (u_char *)tmp___0 + ((state + i)->peer)->len;
      }
    }
#line 5255
    i ++;
#line 5255
    if (i == (r->upstream_states)->nelts) {
#line 5256
      goto while_break___0;
    }
#line 5259
    if ((state + i)->peer) {
#line 5260
      tmp___1 = p;
#line 5260
      p ++;
#line 5260
      *tmp___1 = (u_char )',';
#line 5261
      tmp___2 = p;
#line 5261
      p ++;
#line 5261
      *tmp___2 = (u_char )' ';
    } else {
#line 5264
      tmp___3 = p;
#line 5264
      p ++;
#line 5264
      *tmp___3 = (u_char )' ';
#line 5265
      tmp___4 = p;
#line 5265
      p ++;
#line 5265
      *tmp___4 = (u_char )':';
#line 5266
      tmp___5 = p;
#line 5266
      p ++;
#line 5266
      *tmp___5 = (u_char )' ';
#line 5268
      i ++;
#line 5268
      if (i == (r->upstream_states)->nelts) {
#line 5269
        goto while_break___0;
      }
#line 5272
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 5276
  v->len = (unsigned int )(p - v->data);
#line 5278
  return ((ngx_int_t )0);
}
}
#line 5282 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_status_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_uint_t i ;
  ngx_http_upstream_state_t *state ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  char *__cil_tmp15 ;

  {
#line 5291
  v->valid = 1U;
#line 5292
  v->no_cacheable = 0U;
#line 5293
  v->not_found = 0U;
#line 5295
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
#line 5296
    v->not_found = 1U;
#line 5297
    return ((ngx_int_t )0);
  } else
#line 5295
  if ((r->upstream_states)->nelts == 0UL) {
#line 5296
    v->not_found = 1U;
#line 5297
    return ((ngx_int_t )0);
  }
  {
#line 5300
  len = (r->upstream_states)->nelts * 5UL;
#line 5302
  tmp = ngx_pnalloc(r->pool, len);
#line 5302
  p = (u_char *)tmp;
  }
#line 5303
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5304
    return ((ngx_int_t )-1);
  }
#line 5307
  v->data = p;
#line 5309
  i = (ngx_uint_t )0;
#line 5310
  state = (ngx_http_upstream_state_t *)(r->upstream_states)->elts;
  {
#line 5312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5313
    if ((state + i)->status) {
      {
#line 5314
      p = ngx_sprintf(p, "%ui", (state + i)->status);
      }
    } else {
#line 5317
      tmp___0 = p;
#line 5317
      p ++;
#line 5317
      *tmp___0 = (u_char )'-';
    }
#line 5320
    i ++;
#line 5320
    if (i == (r->upstream_states)->nelts) {
#line 5321
      goto while_break;
    }
#line 5324
    if ((state + i)->peer) {
#line 5325
      tmp___1 = p;
#line 5325
      p ++;
#line 5325
      *tmp___1 = (u_char )',';
#line 5326
      tmp___2 = p;
#line 5326
      p ++;
#line 5326
      *tmp___2 = (u_char )' ';
    } else {
#line 5329
      tmp___3 = p;
#line 5329
      p ++;
#line 5329
      *tmp___3 = (u_char )' ';
#line 5330
      tmp___4 = p;
#line 5330
      p ++;
#line 5330
      *tmp___4 = (u_char )':';
#line 5331
      tmp___5 = p;
#line 5331
      p ++;
#line 5331
      *tmp___5 = (u_char )' ';
#line 5333
      i ++;
#line 5333
      if (i == (r->upstream_states)->nelts) {
#line 5334
        goto while_break;
      }
#line 5337
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 5341
  v->len = (unsigned int )(p - v->data);
#line 5343
  return ((ngx_int_t )0);
}
}
#line 5347 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_response_time_variable(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_uint_t i ;
  ngx_msec_int_t ms ;
  ngx_http_upstream_state_t *state ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 5357
  v->valid = 1U;
#line 5358
  v->no_cacheable = 0U;
#line 5359
  v->not_found = 0U;
#line 5361
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
#line 5362
    v->not_found = 1U;
#line 5363
    return ((ngx_int_t )0);
  } else
#line 5361
  if ((r->upstream_states)->nelts == 0UL) {
#line 5362
    v->not_found = 1U;
#line 5363
    return ((ngx_int_t )0);
  }
  {
#line 5366
  len = (r->upstream_states)->nelts * (((sizeof("-9223372036854775808") - 1UL) + 4UL) + 2UL);
#line 5368
  tmp = ngx_pnalloc(r->pool, len);
#line 5368
  p = (u_char *)tmp;
  }
#line 5369
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5370
    return ((ngx_int_t )-1);
  }
#line 5373
  v->data = p;
#line 5375
  i = (ngx_uint_t )0;
#line 5376
  state = (ngx_http_upstream_state_t *)(r->upstream_states)->elts;
  {
#line 5378
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5379
    if ((state + i)->status) {
#line 5381
      if (data == 1UL) {
#line 5381
        if ((state + i)->header_time != 0xffffffffffffffffUL) {
#line 5382
          ms = (ngx_msec_int_t )(state + i)->header_time;
        } else {
#line 5381
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 5384
      if (data == 2UL) {
#line 5384
        if ((state + i)->connect_time != 0xffffffffffffffffUL) {
#line 5385
          ms = (ngx_msec_int_t )(state + i)->connect_time;
        } else {
#line 5388
          ms = (ngx_msec_int_t )(state + i)->response_time;
        }
      } else {
#line 5388
        ms = (ngx_msec_int_t )(state + i)->response_time;
      }
#line 5391
      if (ms < 0L) {
#line 5391
        ms = (ngx_msec_int_t )0;
      } else {
#line 5391
        ms = ms;
      }
      {
#line 5392
      p = ngx_sprintf(p, "%T.%03M", ms / 1000L, ms % 1000L);
      }
    } else {
#line 5395
      tmp___0 = p;
#line 5395
      p ++;
#line 5395
      *tmp___0 = (u_char )'-';
    }
#line 5398
    i ++;
#line 5398
    if (i == (r->upstream_states)->nelts) {
#line 5399
      goto while_break;
    }
#line 5402
    if ((state + i)->peer) {
#line 5403
      tmp___1 = p;
#line 5403
      p ++;
#line 5403
      *tmp___1 = (u_char )',';
#line 5404
      tmp___2 = p;
#line 5404
      p ++;
#line 5404
      *tmp___2 = (u_char )' ';
    } else {
#line 5407
      tmp___3 = p;
#line 5407
      p ++;
#line 5407
      *tmp___3 = (u_char )' ';
#line 5408
      tmp___4 = p;
#line 5408
      p ++;
#line 5408
      *tmp___4 = (u_char )':';
#line 5409
      tmp___5 = p;
#line 5409
      p ++;
#line 5409
      *tmp___5 = (u_char )' ';
#line 5411
      i ++;
#line 5411
      if (i == (r->upstream_states)->nelts) {
#line 5412
        goto while_break;
      }
#line 5415
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 5419
  v->len = (unsigned int )(p - v->data);
#line 5421
  return ((ngx_int_t )0);
}
}
#line 5425 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_response_length_variable(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_uint_t i ;
  ngx_http_upstream_state_t *state ;
  void *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 5434
  v->valid = 1U;
#line 5435
  v->no_cacheable = 0U;
#line 5436
  v->not_found = 0U;
#line 5438
  if ((unsigned long )r->upstream_states == (unsigned long )((void *)0)) {
#line 5439
    v->not_found = 1U;
#line 5440
    return ((ngx_int_t )0);
  } else
#line 5438
  if ((r->upstream_states)->nelts == 0UL) {
#line 5439
    v->not_found = 1U;
#line 5440
    return ((ngx_int_t )0);
  }
  {
#line 5443
  len = (r->upstream_states)->nelts * ((sizeof("-9223372036854775808") - 1UL) + 2UL);
#line 5445
  tmp = ngx_pnalloc(r->pool, len);
#line 5445
  p = (u_char *)tmp;
  }
#line 5446
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5447
    return ((ngx_int_t )-1);
  }
#line 5450
  v->data = p;
#line 5452
  i = (ngx_uint_t )0;
#line 5453
  state = (ngx_http_upstream_state_t *)(r->upstream_states)->elts;
  {
#line 5455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5457
    if (data == 1UL) {
      {
#line 5458
      p = ngx_sprintf(p, "%O", (state + i)->bytes_received);
      }
    } else {
      {
#line 5461
      p = ngx_sprintf(p, "%O", (state + i)->response_length);
      }
    }
#line 5464
    i ++;
#line 5464
    if (i == (r->upstream_states)->nelts) {
#line 5465
      goto while_break;
    }
#line 5468
    if ((state + i)->peer) {
#line 5469
      tmp___0 = p;
#line 5469
      p ++;
#line 5469
      *tmp___0 = (u_char )',';
#line 5470
      tmp___1 = p;
#line 5470
      p ++;
#line 5470
      *tmp___1 = (u_char )' ';
    } else {
#line 5473
      tmp___2 = p;
#line 5473
      p ++;
#line 5473
      *tmp___2 = (u_char )' ';
#line 5474
      tmp___3 = p;
#line 5474
      p ++;
#line 5474
      *tmp___3 = (u_char )':';
#line 5475
      tmp___4 = p;
#line 5475
      p ++;
#line 5475
      *tmp___4 = (u_char )' ';
#line 5477
      i ++;
#line 5477
      if (i == (r->upstream_states)->nelts) {
#line 5478
        goto while_break;
      }
#line 5481
      goto __Cont;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 5485
  v->len = (unsigned int )(p - v->data);
#line 5487
  return ((ngx_int_t )0);
}
}
#line 5491 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_header_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  ngx_int_t tmp ;
  char *__cil_tmp5 ;

  {
#line 5495
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5496
    v->not_found = 1U;
#line 5497
    return ((ngx_int_t )0);
  }
  {
#line 5500
  tmp = ngx_http_variable_unknown_header(v, (ngx_str_t *)data, & (r->upstream)->headers_in.headers.part,
                                         sizeof("upstream_http_") - 1UL);
  }
#line 5500
  return (tmp);
}
}
#line 5506 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cookie_variable(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  ngx_str_t *name ;
  ngx_str_t cookie ;
  ngx_str_t s ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 5510
  name = (ngx_str_t *)data;
#line 5514
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5515
    v->not_found = 1U;
#line 5516
    return ((ngx_int_t )0);
  }
  {
#line 5519
  s.len = name->len - (sizeof("upstream_cookie_") - 1UL);
#line 5520
  s.data = (name->data + sizeof("upstream_cookie_")) - 1;
#line 5522
  tmp = ngx_http_parse_set_cookie_lines(& (r->upstream)->headers_in.cookies, & s,
                                        & cookie);
  }
#line 5522
  if (tmp == -5L) {
#line 5526
    v->not_found = 1U;
#line 5527
    return ((ngx_int_t )0);
  }
#line 5530
  v->len = (unsigned int )cookie.len;
#line 5531
  v->valid = 1U;
#line 5532
  v->no_cacheable = 0U;
#line 5533
  v->not_found = 0U;
#line 5534
  v->data = cookie.data;
#line 5536
  return ((ngx_int_t )0);
}
}
#line 5542 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_status(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  ngx_uint_t n ;

  {
#line 5548
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5549
    v->not_found = 1U;
#line 5550
    return ((ngx_int_t )0);
  } else
#line 5548
  if ((r->upstream)->cache_status == 0U) {
#line 5549
    v->not_found = 1U;
#line 5550
    return ((ngx_int_t )0);
  }
#line 5553
  n = (ngx_uint_t )((r->upstream)->cache_status - 1U);
#line 5555
  v->valid = 1U;
#line 5556
  v->no_cacheable = 0U;
#line 5557
  v->not_found = 0U;
#line 5558
  v->len = (unsigned int )ngx_http_cache_status[n].len;
#line 5559
  v->data = ngx_http_cache_status[n].data;
#line 5561
  return ((ngx_int_t )0);
}
}
#line 5565 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_last_modified(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 5571
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5576
    v->not_found = 1U;
#line 5577
    return ((ngx_int_t )0);
  } else
#line 5571
  if (! ((r->upstream)->conf)->cache_revalidate) {
#line 5576
    v->not_found = 1U;
#line 5577
    return ((ngx_int_t )0);
  } else
#line 5571
  if ((r->upstream)->cache_status != 3U) {
#line 5576
    v->not_found = 1U;
#line 5577
    return ((ngx_int_t )0);
  } else
#line 5571
  if ((r->cache)->last_modified == -1L) {
#line 5576
    v->not_found = 1U;
#line 5577
    return ((ngx_int_t )0);
  }
  {
#line 5580
  tmp = ngx_pnalloc(r->pool, sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1UL);
#line 5580
  p = (u_char *)tmp;
  }
#line 5581
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 5582
    return ((ngx_int_t )-1);
  }
  {
#line 5585
  tmp___0 = ngx_http_time(p, (r->cache)->last_modified);
#line 5585
  v->len = (unsigned int )(tmp___0 - p);
#line 5586
  v->valid = 1U;
#line 5587
  v->no_cacheable = 0U;
#line 5588
  v->not_found = 0U;
#line 5589
  v->data = p;
  }
#line 5591
  return ((ngx_int_t )0);
}
}
#line 5595 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_cache_etag(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 


  {
#line 5599
  if ((unsigned long )r->upstream == (unsigned long )((void *)0)) {
#line 5604
    v->not_found = 1U;
#line 5605
    return ((ngx_int_t )0);
  } else
#line 5599
  if (! ((r->upstream)->conf)->cache_revalidate) {
#line 5604
    v->not_found = 1U;
#line 5605
    return ((ngx_int_t )0);
  } else
#line 5599
  if ((r->upstream)->cache_status != 3U) {
#line 5604
    v->not_found = 1U;
#line 5605
    return ((ngx_int_t )0);
  } else
#line 5599
  if ((r->cache)->etag.len == 0UL) {
#line 5604
    v->not_found = 1U;
#line 5605
    return ((ngx_int_t )0);
  }
#line 5608
  v->valid = 1U;
#line 5609
  v->no_cacheable = 0U;
#line 5610
  v->not_found = 0U;
#line 5611
  v->len = (unsigned int )(r->cache)->etag.len;
#line 5612
  v->data = (r->cache)->etag.data;
#line 5614
  return ((ngx_int_t )0);
}
}
#line 5620 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static char *ngx_http_upstream(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) 
{ 
  char *rv ;
  void *mconf ;
  ngx_str_t *value ;
  ngx_url_t u ;
  ngx_uint_t m ;
  ngx_conf_t pcf ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *http_ctx ;
  ngx_http_upstream_srv_conf_t *uscf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 5633
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 5635
  value = (ngx_str_t *)(cf->args)->elts;
#line 5636
  u.host = *(value + 1);
#line 5637
  u.no_resolve = 1U;
#line 5638
  u.no_port = 1U;
#line 5640
  uscf = ngx_http_upstream_add(cf, & u, (ngx_uint_t )319);
  }
#line 5647
  if ((unsigned long )uscf == (unsigned long )((void *)0)) {
#line 5648
    return ((char *)((void *)-1));
  }
  {
#line 5652
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 5652
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 5653
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 5654
    return ((char *)((void *)-1));
  }
  {
#line 5657
  http_ctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 5658
  ctx->main_conf = http_ctx->main_conf;
#line 5662
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 5662
  ctx->srv_conf = (void **)tmp___0;
  }
#line 5663
  if ((unsigned long )ctx->srv_conf == (unsigned long )((void *)0)) {
#line 5664
    return ((char *)((void *)-1));
  }
  {
#line 5667
  *(ctx->srv_conf + ngx_http_upstream_module.ctx_index) = (void *)uscf;
#line 5669
  uscf->srv_conf = ctx->srv_conf;
#line 5674
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 5674
  ctx->loc_conf = (void **)tmp___1;
  }
#line 5675
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 5676
    return ((char *)((void *)-1));
  }
#line 5679
  m = (ngx_uint_t )0;
  {
#line 5679
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5679
    if (! *((cf->cycle)->modules + m)) {
#line 5679
      goto while_break;
    }
#line 5680
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 5681
      goto __Cont;
    }
#line 5684
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 5686
    if (module->create_srv_conf) {
      {
#line 5687
      mconf = (*(module->create_srv_conf))(cf);
      }
#line 5688
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 5689
        return ((char *)((void *)-1));
      }
#line 5692
      *(ctx->srv_conf + (*((cf->cycle)->modules + m))->ctx_index) = mconf;
    }
#line 5695
    if (module->create_loc_conf) {
      {
#line 5696
      mconf = (*(module->create_loc_conf))(cf);
      }
#line 5697
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 5698
        return ((char *)((void *)-1));
      }
#line 5701
      *(ctx->loc_conf + (*((cf->cycle)->modules + m))->ctx_index) = mconf;
    }
    __Cont: /* CIL Label */ 
#line 5679
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5705
  uscf->servers = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_server_t ));
  }
#line 5707
  if ((unsigned long )uscf->servers == (unsigned long )((void *)0)) {
#line 5708
    return ((char *)((void *)-1));
  }
  {
#line 5714
  pcf = *cf;
#line 5715
  cf->ctx = (void *)ctx;
#line 5716
  cf->cmd_type = (ngx_uint_t )268435456;
#line 5718
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 5720
  *cf = pcf;
  }
#line 5722
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 5723
    return (rv);
  }
#line 5726
  if ((uscf->servers)->nelts == 0UL) {
    {
#line 5727
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "no servers are inside upstream");
    }
#line 5729
    return ((char *)((void *)-1));
  }
#line 5732
  return (rv);
}
}
#line 5736 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static char *ngx_http_upstream_server(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_upstream_srv_conf_t *uscf ;
  time_t fail_timeout ;
  ngx_str_t *value ;
  ngx_str_t s ;
  ngx_url_t u ;
  ngx_int_t weight ;
  ngx_int_t max_conns ;
  ngx_int_t max_fails ;
  ngx_uint_t i ;
  ngx_http_upstream_server_t *us ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ngx_int_t tmp___6 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 5739
  uscf = (ngx_http_upstream_srv_conf_t *)conf;
#line 5748
  tmp = ngx_array_push(uscf->servers);
#line 5748
  us = (ngx_http_upstream_server_t *)tmp;
  }
#line 5749
  if ((unsigned long )us == (unsigned long )((void *)0)) {
#line 5750
    return ((char *)((void *)-1));
  }
  {
#line 5753
  memset((void *)us, 0, sizeof(ngx_http_upstream_server_t ));
#line 5755
  value = (ngx_str_t *)(cf->args)->elts;
#line 5757
  weight = (ngx_int_t )1;
#line 5758
  max_conns = (ngx_int_t )0;
#line 5759
  max_fails = (ngx_int_t )1;
#line 5760
  fail_timeout = (time_t )10;
#line 5762
  i = (ngx_uint_t )2;
  }
  {
#line 5762
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5762
    if (! (i < (cf->args)->nelts)) {
#line 5762
      goto while_break;
    }
    {
#line 5764
    tmp___0 = strncmp((char const   *)(value + i)->data, "weight=", (size_t )7);
    }
#line 5764
    if (tmp___0 == 0) {
#line 5766
      if (! (uscf->flags & 2UL)) {
#line 5767
        goto not_supported;
      }
      {
#line 5770
      weight = ngx_atoi((value + i)->data + 7, (value + i)->len - 7UL);
      }
#line 5772
      if (weight == -1L) {
#line 5773
        goto invalid;
      } else
#line 5772
      if (weight == 0L) {
#line 5773
        goto invalid;
      }
#line 5776
      goto __Cont;
    }
    {
#line 5779
    tmp___1 = strncmp((char const   *)(value + i)->data, "max_conns=", (size_t )10);
    }
#line 5779
    if (tmp___1 == 0) {
#line 5781
      if (! (uscf->flags & 256UL)) {
#line 5782
        goto not_supported;
      }
      {
#line 5785
      max_conns = ngx_atoi((value + i)->data + 10, (value + i)->len - 10UL);
      }
#line 5787
      if (max_conns == -1L) {
#line 5788
        goto invalid;
      }
#line 5791
      goto __Cont;
    }
    {
#line 5794
    tmp___2 = strncmp((char const   *)(value + i)->data, "max_fails=", (size_t )10);
    }
#line 5794
    if (tmp___2 == 0) {
#line 5796
      if (! (uscf->flags & 4UL)) {
#line 5797
        goto not_supported;
      }
      {
#line 5800
      max_fails = ngx_atoi((value + i)->data + 10, (value + i)->len - 10UL);
      }
#line 5802
      if (max_fails == -1L) {
#line 5803
        goto invalid;
      }
#line 5806
      goto __Cont;
    }
    {
#line 5809
    tmp___3 = strncmp((char const   *)(value + i)->data, "fail_timeout=", (size_t )13);
    }
#line 5809
    if (tmp___3 == 0) {
#line 5811
      if (! (uscf->flags & 8UL)) {
#line 5812
        goto not_supported;
      }
      {
#line 5815
      s.len = (value + i)->len - 13UL;
#line 5816
      s.data = (value + i)->data + 13;
#line 5818
      fail_timeout = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 5820
      if (fail_timeout == -1L) {
#line 5821
        goto invalid;
      }
#line 5824
      goto __Cont;
    }
    {
#line 5827
    tmp___4 = strcmp((char const   *)(value + i)->data, "backup");
    }
#line 5827
    if (tmp___4 == 0) {
#line 5829
      if (! (uscf->flags & 32UL)) {
#line 5830
        goto not_supported;
      }
#line 5833
      us->backup = 1U;
#line 5835
      goto __Cont;
    }
    {
#line 5838
    tmp___5 = strcmp((char const   *)(value + i)->data, "down");
    }
#line 5838
    if (tmp___5 == 0) {
#line 5840
      if (! (uscf->flags & 16UL)) {
#line 5841
        goto not_supported;
      }
#line 5844
      us->down = (ngx_uint_t )1;
#line 5846
      goto __Cont;
    }
#line 5849
    goto invalid;
    __Cont: /* CIL Label */ 
#line 5762
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5852
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 5854
  u.url = *(value + 1);
#line 5855
  u.default_port = (in_port_t )80;
#line 5857
  tmp___6 = ngx_parse_url(cf->pool, & u);
  }
#line 5857
  if (tmp___6 != 0L) {
#line 5858
    if (u.err) {
      {
#line 5859
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in upstream \"%V\"", u.err, & u.url);
      }
    }
#line 5863
    return ((char *)((void *)-1));
  }
#line 5866
  us->name = u.url;
#line 5867
  us->addrs = u.addrs;
#line 5868
  us->naddrs = u.naddrs;
#line 5869
  us->weight = (ngx_uint_t )weight;
#line 5870
  us->max_conns = (ngx_uint_t )max_conns;
#line 5871
  us->max_fails = (ngx_uint_t )max_fails;
#line 5872
  us->fail_timeout = fail_timeout;
#line 5874
  return ((char *)((void *)0));
  invalid: 
  {
#line 5878
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
  }
#line 5881
  return ((char *)((void *)-1));
  not_supported: 
  {
#line 5885
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "balancing method does not support parameter \"%V\"",
                     value + i);
  }
#line 5889
  return ((char *)((void *)-1));
}
}
#line 5893 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
ngx_http_upstream_srv_conf_t *ngx_http_upstream_add(ngx_conf_t *cf , ngx_url_t *u ,
                                                    ngx_uint_t flags ) 
{ 
  ngx_uint_t i ;
  ngx_http_upstream_server_t *us ;
  ngx_http_upstream_srv_conf_t *uscf ;
  ngx_http_upstream_srv_conf_t **uscfp ;
  ngx_http_upstream_main_conf_t *umcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 5901
  if (! (flags & 1UL)) {
    {
#line 5903
    tmp = ngx_parse_url(cf->pool, u);
    }
#line 5903
    if (tmp != 0L) {
#line 5904
      if (u->err) {
        {
#line 5905
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in upstream \"%V\"", u->err,
                           & u->url);
        }
      }
#line 5909
      return ((ngx_http_upstream_srv_conf_t *)((void *)0));
    }
  }
#line 5913
  umcf = (ngx_http_upstream_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_upstream_module.ctx_index);
#line 5915
  uscfp = (ngx_http_upstream_srv_conf_t **)umcf->upstreams.elts;
#line 5917
  i = (ngx_uint_t )0;
  {
#line 5917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 5917
    if (! (i < umcf->upstreams.nelts)) {
#line 5917
      goto while_break;
    }
#line 5919
    if ((*(uscfp + i))->host.len != u->host.len) {
#line 5923
      goto __Cont;
    } else {
      {
#line 5919
      tmp___0 = ngx_strncasecmp((*(uscfp + i))->host.data, u->host.data, u->host.len);
      }
#line 5919
      if (tmp___0 != 0L) {
#line 5923
        goto __Cont;
      }
    }
#line 5926
    if (flags & 1UL) {
#line 5926
      if ((*(uscfp + i))->flags & 1UL) {
        {
#line 5929
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate upstream \"%V\"", & u->host);
        }
#line 5931
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
    }
#line 5934
    if ((*(uscfp + i))->flags & 1UL) {
#line 5934
      if (! u->no_port) {
        {
#line 5935
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "upstream \"%V\" may not have port %d",
                           & u->host, (int )u->port);
        }
#line 5938
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
    }
#line 5941
    if (flags & 1UL) {
#line 5941
      if (! (*(uscfp + i))->no_port) {
#line 5942
        if ((cf->log)->log_level >= 1UL) {
          {
#line 5942
          ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "upstream \"%V\" may not have port %d in %s:%ui",
                             & u->host, (int )(*(uscfp + i))->port, (*(uscfp + i))->file_name,
                             (*(uscfp + i))->line);
          }
        }
#line 5946
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
    }
#line 5949
    if ((*(uscfp + i))->port) {
#line 5949
      if (u->port) {
#line 5949
        if ((int )(*(uscfp + i))->port != (int )u->port) {
#line 5952
          goto __Cont;
        }
      }
    }
#line 5955
    if (flags & 1UL) {
#line 5956
      (*(uscfp + i))->flags = flags;
#line 5957
      (*(uscfp + i))->port = (in_port_t )0;
    }
#line 5960
    return (*(uscfp + i));
    __Cont: /* CIL Label */ 
#line 5917
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 5963
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_srv_conf_t ));
#line 5963
  uscf = (ngx_http_upstream_srv_conf_t *)tmp___1;
  }
#line 5964
  if ((unsigned long )uscf == (unsigned long )((void *)0)) {
#line 5965
    return ((ngx_http_upstream_srv_conf_t *)((void *)0));
  }
#line 5968
  uscf->flags = flags;
#line 5969
  uscf->host = u->host;
#line 5970
  uscf->file_name = (cf->conf_file)->file.name.data;
#line 5971
  uscf->line = (cf->conf_file)->line;
#line 5972
  uscf->port = u->port;
#line 5973
  uscf->no_port = (ngx_uint_t )u->no_port;
#line 5975
  if (u->naddrs == 1UL) {
#line 5975
    if (u->port) {
#line 5975
      goto _L;
    } else
#line 5975
    if (u->family == 1) {
      _L: /* CIL Label */ 
      {
#line 5976
      uscf->servers = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_upstream_server_t ));
      }
#line 5978
      if ((unsigned long )uscf->servers == (unsigned long )((void *)0)) {
#line 5979
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
      {
#line 5982
      tmp___2 = ngx_array_push(uscf->servers);
#line 5982
      us = (ngx_http_upstream_server_t *)tmp___2;
      }
#line 5983
      if ((unsigned long )us == (unsigned long )((void *)0)) {
#line 5984
        return ((ngx_http_upstream_srv_conf_t *)((void *)0));
      }
      {
#line 5987
      memset((void *)us, 0, sizeof(ngx_http_upstream_server_t ));
#line 5989
      us->addrs = u->addrs;
#line 5990
      us->naddrs = (ngx_uint_t )1;
      }
    }
  }
  {
#line 5993
  tmp___3 = ngx_array_push(& umcf->upstreams);
#line 5993
  uscfp = (ngx_http_upstream_srv_conf_t **)tmp___3;
  }
#line 5994
  if ((unsigned long )uscfp == (unsigned long )((void *)0)) {
#line 5995
    return ((ngx_http_upstream_srv_conf_t *)((void *)0));
  }
#line 5998
  *uscfp = uscf;
#line 6000
  return (uscf);
}
}
#line 6004 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
char *ngx_http_upstream_bind_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_int_t rc ;
  ngx_str_t *value ;
  ngx_http_complex_value_t cv ;
  ngx_http_upstream_local_t **plocal ;
  ngx_http_upstream_local_t *local ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_core_conf_t *ccf ;
  int tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 6008
  p = (char *)conf;
#line 6016
  plocal = (ngx_http_upstream_local_t **)(p + cmd->offset);
#line 6018
  if ((unsigned long )*plocal != (unsigned long )((void *)-1)) {
#line 6019
    return ((char *)"is duplicate");
  }
#line 6022
  value = (ngx_str_t *)(cf->args)->elts;
#line 6024
  if ((cf->args)->nelts == 2UL) {
    {
#line 6024
    tmp = strcmp((char const   *)(value + 1)->data, "off");
    }
#line 6024
    if (tmp == 0) {
#line 6025
      *plocal = (ngx_http_upstream_local_t *)((void *)0);
#line 6026
      return ((char *)((void *)0));
    }
  }
  {
#line 6029
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 6031
  ccv.cf = cf;
#line 6032
  ccv.value = value + 1;
#line 6033
  ccv.complex_value = & cv;
#line 6035
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 6035
  if (tmp___0 != 0L) {
#line 6036
    return ((char *)((void *)-1));
  }
  {
#line 6039
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_local_t ));
#line 6039
  local = (ngx_http_upstream_local_t *)tmp___1;
  }
#line 6040
  if ((unsigned long )local == (unsigned long )((void *)0)) {
#line 6041
    return ((char *)((void *)-1));
  }
#line 6044
  *plocal = local;
#line 6046
  if (cv.lengths) {
    {
#line 6047
    tmp___2 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 6047
    local->value = (ngx_http_complex_value_t *)tmp___2;
    }
#line 6048
    if ((unsigned long )local->value == (unsigned long )((void *)0)) {
#line 6049
      return ((char *)((void *)-1));
    }
#line 6052
    *(local->value) = cv;
  } else {
    {
#line 6055
    tmp___3 = ngx_palloc(cf->pool, sizeof(ngx_addr_t ));
#line 6055
    local->addr = (ngx_addr_t *)tmp___3;
    }
#line 6056
    if ((unsigned long )local->addr == (unsigned long )((void *)0)) {
#line 6057
      return ((char *)((void *)-1));
    }
    {
#line 6060
    rc = ngx_parse_addr_port(cf->pool, local->addr, (value + 1)->data, (value + 1)->len);
    }
    {
#line 6064
    if (rc == 0L) {
#line 6064
      goto case_0;
    }
#line 6068
    if (rc == -5L) {
#line 6068
      goto case_neg_5;
    }
#line 6073
    goto switch_default;
    case_0: /* CIL Label */ 
#line 6065
    (local->addr)->name = *(value + 1);
#line 6066
    goto switch_break;
    case_neg_5: /* CIL Label */ 
    {
#line 6069
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid address \"%V\"", value + 1);
    }
    switch_default: /* CIL Label */ 
#line 6074
    return ((char *)((void *)-1));
    switch_break: /* CIL Label */ ;
    }
  }
#line 6078
  if ((cf->args)->nelts > 2UL) {
    {
#line 6079
    tmp___4 = strcmp((char const   *)(value + 2)->data, "transparent");
    }
#line 6079
    if (tmp___4 == 0) {
#line 6083
      ccf = (ngx_core_conf_t *)*((cf->cycle)->conf_ctx + ngx_core_module.index);
#line 6086
      ccf->transparent = (ngx_uint_t )1;
#line 6087
      local->transparent = (ngx_uint_t )1;
    } else {
      {
#line 6094
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 2);
      }
#line 6096
      return ((char *)((void *)-1));
    }
  }
#line 6100
  return ((char *)((void *)0));
}
}
#line 6104 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static ngx_int_t ngx_http_upstream_set_local(ngx_http_request_t *r , ngx_http_upstream_t *u ,
                                             ngx_http_upstream_local_t *local ) 
{ 
  ngx_int_t rc ;
  ngx_str_t val ;
  ngx_addr_t *addr ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 6112
  if ((unsigned long )local == (unsigned long )((void *)0)) {
#line 6113
    u->peer.local = (ngx_addr_t *)((void *)0);
#line 6114
    return ((ngx_int_t )0);
  }
#line 6118
  u->peer.transparent = (unsigned int )local->transparent;
#line 6121
  if ((unsigned long )local->value == (unsigned long )((void *)0)) {
#line 6122
    u->peer.local = local->addr;
#line 6123
    return ((ngx_int_t )0);
  }
  {
#line 6126
  tmp = ngx_http_complex_value(r, local->value, & val);
  }
#line 6126
  if (tmp != 0L) {
#line 6127
    return ((ngx_int_t )-1);
  }
#line 6130
  if (val.len == 0UL) {
#line 6131
    return ((ngx_int_t )0);
  }
  {
#line 6134
  tmp___0 = ngx_palloc(r->pool, sizeof(ngx_addr_t ));
#line 6134
  addr = (ngx_addr_t *)tmp___0;
  }
#line 6135
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 6136
    return ((ngx_int_t )-1);
  }
  {
#line 6139
  rc = ngx_parse_addr_port(r->pool, addr, val.data, val.len);
  }
#line 6140
  if (rc == -1L) {
#line 6141
    return ((ngx_int_t )-1);
  }
#line 6144
  if (rc != 0L) {
#line 6145
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 6145
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid local address \"%V\"",
                         & val);
      }
    }
#line 6147
    return ((ngx_int_t )0);
  }
#line 6150
  addr->name = val;
#line 6151
  u->peer.local = addr;
#line 6153
  return ((ngx_int_t )0);
}
}
#line 6157 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
char *ngx_http_upstream_param_set_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_array_t **a ;
  ngx_http_upstream_param_t *param ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;

  {
#line 6161
  p = (char *)conf;
#line 6167
  a = (ngx_array_t **)(p + cmd->offset);
#line 6169
  if ((unsigned long )*a == (unsigned long )((void *)0)) {
    {
#line 6170
    *a = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_param_t ));
    }
#line 6171
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 6172
      return ((char *)((void *)-1));
    }
  }
  {
#line 6176
  tmp = ngx_array_push(*a);
#line 6176
  param = (ngx_http_upstream_param_t *)tmp;
  }
#line 6177
  if ((unsigned long )param == (unsigned long )((void *)0)) {
#line 6178
    return ((char *)((void *)-1));
  }
#line 6181
  value = (ngx_str_t *)(cf->args)->elts;
#line 6183
  param->key = *(value + 1);
#line 6184
  param->value = *(value + 2);
#line 6185
  param->skip_empty = (ngx_uint_t )0;
#line 6187
  if ((cf->args)->nelts == 4UL) {
    {
#line 6188
    tmp___0 = strcmp((char const   *)(value + 3)->data, "if_not_empty");
    }
#line 6188
    if (tmp___0 != 0) {
      {
#line 6189
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 3);
      }
#line 6191
      return ((char *)((void *)-1));
    }
#line 6194
    param->skip_empty = (ngx_uint_t )1;
  }
#line 6197
  return ((char *)((void *)0));
}
}
#line 6201 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
ngx_int_t ngx_http_upstream_hide_headers_hash(ngx_conf_t *cf , ngx_http_upstream_conf_t *conf ,
                                              ngx_http_upstream_conf_t *prev , ngx_str_t *default_hide_headers ,
                                              ngx_hash_init_t *hash ) 
{ 
  ngx_str_t *h ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_array_t hide_headers ;
  ngx_hash_key_t *hk ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 6211
  if ((unsigned long )conf->hide_headers == (unsigned long )((void *)-1)) {
#line 6211
    if ((unsigned long )conf->pass_headers == (unsigned long )((void *)-1)) {
#line 6214
      conf->hide_headers = prev->hide_headers;
#line 6215
      conf->pass_headers = prev->pass_headers;
#line 6217
      conf->hide_headers_hash = prev->hide_headers_hash;
#line 6219
      if (conf->hide_headers_hash.buckets) {
#line 6220
        return ((ngx_int_t )0);
      }
    } else {
#line 6211
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 6224
    if ((unsigned long )conf->hide_headers == (unsigned long )((void *)-1)) {
#line 6225
      conf->hide_headers = prev->hide_headers;
    }
#line 6228
    if ((unsigned long )conf->pass_headers == (unsigned long )((void *)-1)) {
#line 6229
      conf->pass_headers = prev->pass_headers;
    }
  }
  {
#line 6233
  tmp = ngx_array_init(& hide_headers, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_hash_key_t ));
  }
#line 6233
  if (tmp != 0L) {
#line 6236
    return ((ngx_int_t )-1);
  }
#line 6239
  h = default_hide_headers;
  {
#line 6239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6239
    if (! h->len) {
#line 6239
      goto while_break;
    }
    {
#line 6240
    tmp___0 = ngx_array_push(& hide_headers);
#line 6240
    hk = (ngx_hash_key_t *)tmp___0;
    }
#line 6241
    if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 6242
      return ((ngx_int_t )-1);
    }
    {
#line 6245
    hk->key = *h;
#line 6246
    hk->key_hash = ngx_hash_key_lc(h->data, h->len);
#line 6247
    hk->value = (void *)1;
#line 6239
    h ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 6250
  if ((unsigned long )conf->hide_headers != (unsigned long )((void *)-1)) {
#line 6252
    h = (ngx_str_t *)(conf->hide_headers)->elts;
#line 6254
    i = (ngx_uint_t )0;
    {
#line 6254
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 6254
      if (! (i < (conf->hide_headers)->nelts)) {
#line 6254
        goto while_break___0;
      }
#line 6256
      hk = (ngx_hash_key_t *)hide_headers.elts;
#line 6258
      j = (ngx_uint_t )0;
      {
#line 6258
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 6258
        if (! (j < hide_headers.nelts)) {
#line 6258
          goto while_break___1;
        }
        {
#line 6259
        tmp___1 = ngx_strcasecmp((h + i)->data, (hk + j)->key.data);
        }
#line 6259
        if (tmp___1 == 0L) {
#line 6260
          goto exist;
        }
#line 6258
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 6264
      tmp___2 = ngx_array_push(& hide_headers);
#line 6264
      hk = (ngx_hash_key_t *)tmp___2;
      }
#line 6265
      if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 6266
        return ((ngx_int_t )-1);
      }
      {
#line 6269
      hk->key = *(h + i);
#line 6270
      hk->key_hash = ngx_hash_key_lc((h + i)->data, (h + i)->len);
#line 6271
      hk->value = (void *)1;
      }
      exist: 
#line 6275
      goto __Cont;
      __Cont: /* CIL Label */ 
#line 6254
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 6279
  if ((unsigned long )conf->pass_headers != (unsigned long )((void *)-1)) {
#line 6281
    h = (ngx_str_t *)(conf->pass_headers)->elts;
#line 6282
    hk = (ngx_hash_key_t *)hide_headers.elts;
#line 6284
    i = (ngx_uint_t )0;
    {
#line 6284
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 6284
      if (! (i < (conf->pass_headers)->nelts)) {
#line 6284
        goto while_break___2;
      }
#line 6285
      j = (ngx_uint_t )0;
      {
#line 6285
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 6285
        if (! (j < hide_headers.nelts)) {
#line 6285
          goto while_break___3;
        }
#line 6287
        if ((unsigned long )(hk + j)->key.data == (unsigned long )((void *)0)) {
#line 6288
          goto __Cont___0;
        }
        {
#line 6291
        tmp___3 = ngx_strcasecmp((h + i)->data, (hk + j)->key.data);
        }
#line 6291
        if (tmp___3 == 0L) {
#line 6292
          (hk + j)->key.data = (u_char *)((void *)0);
#line 6293
          goto while_break___3;
        }
        __Cont___0: /* CIL Label */ 
#line 6285
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 6284
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 6299
  hash->hash = & conf->hide_headers_hash;
#line 6300
  hash->key = & ngx_hash_key_lc;
#line 6301
  hash->pool = cf->pool;
#line 6302
  hash->temp_pool = (ngx_pool_t *)((void *)0);
#line 6304
  tmp___4 = ngx_hash_init(hash, (ngx_hash_key_t *)hide_headers.elts, hide_headers.nelts);
  }
#line 6304
  if (tmp___4 != 0L) {
#line 6305
    return ((ngx_int_t )-1);
  }
#line 6313
  if ((unsigned long )prev->hide_headers_hash.buckets == (unsigned long )((void *)0)) {
#line 6313
    if ((unsigned long )conf->hide_headers == (unsigned long )prev->hide_headers) {
#line 6313
      if ((unsigned long )conf->pass_headers == (unsigned long )prev->pass_headers) {
#line 6317
        prev->hide_headers_hash = conf->hide_headers_hash;
      }
    }
  }
#line 6320
  return ((ngx_int_t )0);
}
}
#line 6324 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static void *ngx_http_upstream_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_upstream_main_conf_t *umcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 6329
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_upstream_main_conf_t ));
#line 6329
  umcf = (ngx_http_upstream_main_conf_t *)tmp;
  }
#line 6330
  if ((unsigned long )umcf == (unsigned long )((void *)0)) {
#line 6331
    return ((void *)0);
  }
  {
#line 6334
  tmp___0 = ngx_array_init(& umcf->upstreams, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_upstream_srv_conf_t *));
  }
#line 6334
  if (tmp___0 != 0L) {
#line 6338
    return ((void *)0);
  }
#line 6341
  return ((void *)umcf);
}
}
#line 6345 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_upstream.c"
static char *ngx_http_upstream_init_main_conf(ngx_conf_t *cf , void *conf ) 
{ 
  ngx_http_upstream_main_conf_t *umcf ;
  ngx_uint_t i ;
  ngx_array_t headers_in ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_int_t (*init)(ngx_conf_t *cf , ngx_http_upstream_srv_conf_t *us ) ;
  ngx_http_upstream_header_t *header___0 ;
  ngx_http_upstream_srv_conf_t **uscfp ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp15 ;

  {
#line 6348
  umcf = (ngx_http_upstream_main_conf_t *)conf;
#line 6358
  uscfp = (ngx_http_upstream_srv_conf_t **)umcf->upstreams.elts;
#line 6360
  i = (ngx_uint_t )0;
  {
#line 6360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 6360
    if (! (i < umcf->upstreams.nelts)) {
#line 6360
      goto while_break;
    }
#line 6362
    if ((*(uscfp + i))->peer.init_upstream) {
#line 6362
      init = (*(uscfp + i))->peer.init_upstream;
    } else {
#line 6362
      init = & ngx_http_upstream_init_round_robin;
    }
    {
#line 6365
    tmp = (*init)(cf, *(uscfp + i));
    }
#line 6365
    if (tmp != 0L) {
#line 6366
      return ((char *)((void *)-1));
    }
#line 6360
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 6373
  tmp___0 = ngx_array_init(& headers_in, cf->temp_pool, (ngx_uint_t )32, sizeof(ngx_hash_key_t ));
  }
#line 6373
  if (tmp___0 != 0L) {
#line 6376
    return ((char *)((void *)-1));
  }
#line 6379
  header___0 = ngx_http_upstream_headers_in;
  {
#line 6379
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 6379
    if (! header___0->name.len) {
#line 6379
      goto while_break___0;
    }
    {
#line 6380
    tmp___1 = ngx_array_push(& headers_in);
#line 6380
    hk = (ngx_hash_key_t *)tmp___1;
    }
#line 6381
    if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 6382
      return ((char *)((void *)-1));
    }
    {
#line 6385
    hk->key = header___0->name;
#line 6386
    hk->key_hash = ngx_hash_key_lc(header___0->name.data, header___0->name.len);
#line 6387
    hk->value = (void *)header___0;
#line 6379
    header___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 6390
  hash.hash = & umcf->headers_in_hash;
#line 6391
  hash.key = & ngx_hash_key_lc;
#line 6392
  hash.max_size = (ngx_uint_t )512;
#line 6393
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 6394
  hash.name = (char *)"upstream_headers_in_hash";
#line 6395
  hash.pool = cf->pool;
#line 6396
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 6398
  tmp___2 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_in.elts, headers_in.nelts);
  }
#line 6398
  if (tmp___2 != 0L) {
#line 6399
    return ((char *)((void *)-1));
  }
#line 6402
  return ((char *)((void *)0));
}
}
#line 210 "src/core/ngx_string.h"
void ngx_unescape_uri(u_char **dst , u_char **src , size_t size , ngx_uint_t type ) ;
#line 135 "src/core/ngx_file.h"
ngx_int_t ngx_get_full_name(ngx_pool_t *pool , ngx_str_t *prefix , ngx_str_t *name ) ;
#line 206 "src/http/ngx_http_script.h"
void ngx_http_script_flush_complex_value(ngx_http_request_t *r , ngx_http_complex_value_t *val ) ;
#line 233
size_t ngx_http_script_copy_var_len_code(ngx_http_script_engine_t *e ) ;
#line 234
void ngx_http_script_copy_var_code(ngx_http_script_engine_t *e ) ;
#line 235
size_t ngx_http_script_copy_capture_len_code(ngx_http_script_engine_t *e ) ;
#line 236
void ngx_http_script_copy_capture_code(ngx_http_script_engine_t *e ) ;
#line 237
size_t ngx_http_script_mark_args_code(ngx_http_script_engine_t *e ) ;
#line 238
void ngx_http_script_start_args_code(ngx_http_script_engine_t *e ) ;
#line 254
void ngx_http_script_nop_code(ngx_http_script_engine_t *e ) ;
#line 118 "src/http/ngx_http.h"
void ngx_http_update_location_config(ngx_http_request_t *r ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_init_arrays(ngx_http_script_compile_t *sc ) ;
#line 14
static ngx_int_t ngx_http_script_done(ngx_http_script_compile_t *sc ) ;
#line 15
static ngx_int_t ngx_http_script_add_copy_code(ngx_http_script_compile_t *sc , ngx_str_t *value ,
                                               ngx_uint_t last ) ;
#line 17
static ngx_int_t ngx_http_script_add_var_code(ngx_http_script_compile_t *sc , ngx_str_t *name ) ;
#line 19
static ngx_int_t ngx_http_script_add_args_code(ngx_http_script_compile_t *sc ) ;
#line 21
static ngx_int_t ngx_http_script_add_capture_code(ngx_http_script_compile_t *sc ,
                                                  ngx_uint_t n ) ;
#line 24
static ngx_int_t ngx_http_script_add_full_name_code(ngx_http_script_compile_t *sc ) ;
#line 26
static size_t ngx_http_script_full_name_len_code(ngx_http_script_engine_t *e ) ;
#line 27
static void ngx_http_script_full_name_code(ngx_http_script_engine_t *e ) ;
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static uintptr_t ngx_http_script_exit_code  =    (uintptr_t )((void *)0);
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_flush_complex_value(ngx_http_request_t *r , ngx_http_complex_value_t *val ) 
{ 
  ngx_uint_t *index___0 ;

  {
#line 41
  index___0 = val->flushes;
#line 43
  if (index___0) {
    {
#line 44
    while (1) {
      while_continue: /* CIL Label */ ;
#line 44
      if (! (*index___0 != 0xffffffffffffffffUL)) {
#line 44
        goto while_break;
      }
#line 46
      if ((r->variables + *index___0)->no_cacheable) {
#line 47
        (r->variables + *index___0)->valid = 0U;
#line 48
        (r->variables + *index___0)->not_found = 0U;
      }
#line 51
      index___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 54
  return;
}
}
#line 57 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
ngx_int_t ngx_http_complex_value(ngx_http_request_t *r , ngx_http_complex_value_t *val ,
                                 ngx_str_t *value ) 
{ 
  size_t len ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 66
  if ((unsigned long )val->lengths == (unsigned long )((void *)0)) {
#line 67
    *value = val->value;
#line 68
    return ((ngx_int_t )0);
  }
  {
#line 71
  ngx_http_script_flush_complex_value(r, val);
#line 73
  memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 75
  e.ip = (u_char *)val->lengths;
#line 76
  e.request = r;
#line 77
  e.flushed = 1U;
#line 79
  len = (size_t )0;
  }
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! *((uintptr_t *)e.ip)) {
#line 81
      goto while_break;
    }
    {
#line 82
    lcode = *((ngx_http_script_len_code_pt *)e.ip);
#line 83
    tmp = (*lcode)(& e);
#line 83
    len += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  value->len = len;
#line 87
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 87
  value->data = (u_char *)tmp___0;
  }
#line 88
  if ((unsigned long )value->data == (unsigned long )((void *)0)) {
#line 89
    return ((ngx_int_t )-1);
  }
#line 92
  e.ip = (u_char *)val->values;
#line 93
  e.pos = value->data;
#line 94
  e.buf = *value;
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 96
    if (! *((uintptr_t *)e.ip)) {
#line 96
      goto while_break___0;
    }
    {
#line 97
    code = *((ngx_http_script_code_pt *)e.ip);
#line 98
    (*code)(& e);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 101
  *value = e.buf;
#line 103
  return ((ngx_int_t )0);
}
}
#line 107 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
ngx_int_t ngx_http_compile_complex_value(ngx_http_compile_complex_value_t *ccv ) 
{ 
  ngx_str_t *v ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t nv ;
  ngx_uint_t nc ;
  ngx_array_t flushes ;
  ngx_array_t lengths ;
  ngx_array_t values ;
  ngx_array_t *pf ;
  ngx_array_t *pl ;
  ngx_array_t *pv ;
  ngx_http_script_compile_t sc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 115
  v = ccv->value;
#line 117
  nv = (ngx_uint_t )0;
#line 118
  nc = (ngx_uint_t )0;
#line 120
  i = (ngx_uint_t )0;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < v->len)) {
#line 120
      goto while_break;
    }
#line 121
    if ((int )*(v->data + i) == 36) {
#line 122
      if ((int )*(v->data + (i + 1UL)) >= 49) {
#line 122
        if ((int )*(v->data + (i + 1UL)) <= 57) {
#line 123
          nc ++;
        } else {
#line 126
          nv ++;
        }
      } else {
#line 126
        nv ++;
      }
    }
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  if (v->len == 0UL) {
#line 131
    goto _L___0;
  } else
#line 131
  if ((int )*(v->data + 0) != 36) {
    _L___0: /* CIL Label */ 
#line 131
    if (ccv->conf_prefix) {
#line 131
      goto _L;
    } else
#line 131
    if (ccv->root_prefix) {
      _L: /* CIL Label */ 
      {
#line 134
      tmp = ngx_conf_full_name((ccv->cf)->cycle, v, (ngx_uint_t )ccv->conf_prefix);
      }
#line 134
      if (tmp != 0L) {
#line 135
        return ((ngx_int_t )-1);
      }
#line 138
      ccv->conf_prefix = 0U;
#line 139
      ccv->root_prefix = 0U;
    }
  }
#line 142
  (ccv->complex_value)->value = *v;
#line 143
  (ccv->complex_value)->flushes = (ngx_uint_t *)((void *)0);
#line 144
  (ccv->complex_value)->lengths = (void *)0;
#line 145
  (ccv->complex_value)->values = (void *)0;
#line 147
  if (nv == 0UL) {
#line 147
    if (nc == 0UL) {
#line 148
      return ((ngx_int_t )0);
    }
  }
  {
#line 151
  n = nv + 1UL;
#line 153
  tmp___0 = ngx_array_init(& flushes, (ccv->cf)->pool, n, sizeof(ngx_uint_t ));
  }
#line 153
  if (tmp___0 != 0L) {
#line 156
    return ((ngx_int_t )-1);
  }
  {
#line 159
  n = nv * (2UL * sizeof(ngx_http_script_copy_code_t ) + sizeof(ngx_http_script_var_code_t )) + sizeof(uintptr_t );
#line 163
  tmp___1 = ngx_array_init(& lengths, (ccv->cf)->pool, n, (size_t )1);
  }
#line 163
  if (tmp___1 != 0L) {
#line 164
    return ((ngx_int_t )-1);
  }
  {
#line 167
  n = ((((nv * (2UL * sizeof(ngx_http_script_copy_code_t ) + sizeof(ngx_http_script_var_code_t )) + sizeof(uintptr_t )) + v->len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 174
  tmp___2 = ngx_array_init(& values, (ccv->cf)->pool, n, (size_t )1);
  }
#line 174
  if (tmp___2 != 0L) {
#line 175
    return ((ngx_int_t )-1);
  }
  {
#line 178
  pf = & flushes;
#line 179
  pl = & lengths;
#line 180
  pv = & values;
#line 182
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 184
  sc.cf = ccv->cf;
#line 185
  sc.source = v;
#line 186
  sc.flushes = & pf;
#line 187
  sc.lengths = & pl;
#line 188
  sc.values = & pv;
#line 189
  sc.complete_lengths = 1U;
#line 190
  sc.complete_values = 1U;
#line 191
  sc.zero = ccv->zero;
#line 192
  sc.conf_prefix = ccv->conf_prefix;
#line 193
  sc.root_prefix = ccv->root_prefix;
#line 195
  tmp___3 = ngx_http_script_compile(& sc);
  }
#line 195
  if (tmp___3 != 0L) {
#line 196
    return ((ngx_int_t )-1);
  }
#line 199
  if (flushes.nelts) {
#line 200
    (ccv->complex_value)->flushes = (ngx_uint_t *)flushes.elts;
#line 201
    *((ccv->complex_value)->flushes + flushes.nelts) = (ngx_uint_t )-1;
  }
#line 204
  (ccv->complex_value)->lengths = lengths.elts;
#line 205
  (ccv->complex_value)->values = values.elts;
#line 207
  return ((ngx_int_t )0);
}
}
#line 211 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
char *ngx_http_set_complex_value_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_http_complex_value_t **cv ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp10 ;

  {
#line 214
  p = (char *)conf;
#line 220
  cv = (ngx_http_complex_value_t **)(p + cmd->offset);
#line 222
  if ((unsigned long )*cv != (unsigned long )((void *)0)) {
#line 223
    return ((char *)"is duplicate");
  }
  {
#line 226
  tmp = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 226
  *cv = (ngx_http_complex_value_t *)tmp;
  }
#line 227
  if ((unsigned long )*cv == (unsigned long )((void *)0)) {
#line 228
    return ((char *)((void *)-1));
  }
  {
#line 231
  value = (ngx_str_t *)(cf->args)->elts;
#line 233
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 235
  ccv.cf = cf;
#line 236
  ccv.value = value + 1;
#line 237
  ccv.complex_value = *cv;
#line 239
  tmp___0 = ngx_http_compile_complex_value(& ccv);
  }
#line 239
  if (tmp___0 != 0L) {
#line 240
    return ((char *)((void *)-1));
  }
#line 243
  return ((char *)((void *)0));
}
}
#line 247 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
ngx_int_t ngx_http_test_predicates(ngx_http_request_t *r , ngx_array_t *predicates ) 
{ 
  ngx_str_t val ;
  ngx_uint_t i ;
  ngx_http_complex_value_t *cv ;
  ngx_int_t tmp ;

  {
#line 254
  if ((unsigned long )predicates == (unsigned long )((void *)0)) {
#line 255
    return ((ngx_int_t )0);
  }
#line 258
  cv = (ngx_http_complex_value_t *)predicates->elts;
#line 260
  i = (ngx_uint_t )0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (i < predicates->nelts)) {
#line 260
      goto while_break;
    }
    {
#line 261
    tmp = ngx_http_complex_value(r, cv + i, & val);
    }
#line 261
    if (tmp != 0L) {
#line 262
      return ((ngx_int_t )-1);
    }
#line 265
    if (val.len) {
#line 265
      if (val.len != 1UL) {
#line 266
        return ((ngx_int_t )-5);
      } else
#line 265
      if ((int )*(val.data + 0) != 48) {
#line 266
        return ((ngx_int_t )-5);
      }
    }
#line 260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 270
  return ((ngx_int_t )0);
}
}
#line 274 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
char *ngx_http_set_predicate_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_array_t **a ;
  ngx_http_complex_value_t *cv ;
  ngx_http_compile_complex_value_t ccv ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 277
  p = (char *)conf;
#line 285
  a = (ngx_array_t **)(p + cmd->offset);
#line 287
  if ((unsigned long )*a == (unsigned long )((void *)-1)) {
    {
#line 288
    *a = ngx_array_create(cf->pool, (ngx_uint_t )1, sizeof(ngx_http_complex_value_t ));
    }
#line 289
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 290
      return ((char *)((void *)-1));
    }
  }
#line 294
  value = (ngx_str_t *)(cf->args)->elts;
#line 296
  i = (ngx_uint_t )1;
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < (cf->args)->nelts)) {
#line 296
      goto while_break;
    }
    {
#line 297
    tmp = ngx_array_push(*a);
#line 297
    cv = (ngx_http_complex_value_t *)tmp;
    }
#line 298
    if ((unsigned long )cv == (unsigned long )((void *)0)) {
#line 299
      return ((char *)((void *)-1));
    }
    {
#line 302
    memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 304
    ccv.cf = cf;
#line 305
    ccv.value = value + i;
#line 306
    ccv.complex_value = cv;
#line 308
    tmp___0 = ngx_http_compile_complex_value(& ccv);
    }
#line 308
    if (tmp___0 != 0L) {
#line 309
      return ((char *)((void *)-1));
    }
#line 296
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  return ((char *)((void *)0));
}
}
#line 317 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
ngx_uint_t ngx_http_script_variables_count(ngx_str_t *value ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;

  {
#line 322
  n = (ngx_uint_t )0;
#line 322
  i = (ngx_uint_t )0;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 322
    if (! (i < value->len)) {
#line 322
      goto while_break;
    }
#line 323
    if ((int )*(value->data + i) == 36) {
#line 324
      n ++;
    }
#line 322
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 328
  return (n);
}
}
#line 332 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
ngx_int_t ngx_http_script_compile(ngx_http_script_compile_t *sc ) 
{ 
  u_char ch ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_uint_t bracket ;
  ngx_int_t tmp ;
  ngx_uint_t n ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 339
  tmp = ngx_http_script_init_arrays(sc);
  }
#line 339
  if (tmp != 0L) {
#line 340
    return ((ngx_int_t )-1);
  }
#line 343
  i = (ngx_uint_t )0;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (! (i < (sc->source)->len)) {
#line 343
      goto while_break;
    }
#line 345
    name.len = (size_t )0;
#line 347
    if ((int )*((sc->source)->data + i) == 36) {
#line 349
      i ++;
#line 349
      if (i == (sc->source)->len) {
#line 350
        goto invalid_variable;
      }
#line 353
      if ((int )*((sc->source)->data + i) >= 49) {
#line 353
        if ((int )*((sc->source)->data + i) <= 57) {
#line 357
          n = (ngx_uint_t )((int )*((sc->source)->data + i) - 48);
#line 359
          if (sc->captures_mask & (1UL << n)) {
#line 360
            sc->dup_capture = 1U;
          }
          {
#line 363
          sc->captures_mask |= 1UL << n;
#line 365
          tmp___0 = ngx_http_script_add_capture_code(sc, n);
          }
#line 365
          if (tmp___0 != 0L) {
#line 366
            return ((ngx_int_t )-1);
          }
#line 369
          i ++;
#line 371
          goto __Cont;
        }
      }
#line 380
      if ((int )*((sc->source)->data + i) == 123) {
#line 381
        bracket = (ngx_uint_t )1;
#line 383
        i ++;
#line 383
        if (i == (sc->source)->len) {
#line 384
          goto invalid_variable;
        }
#line 387
        name.data = (sc->source)->data + i;
      } else {
#line 390
        bracket = (ngx_uint_t )0;
#line 391
        name.data = (sc->source)->data + i;
      }
      {
#line 394
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 394
        if (! (i < (sc->source)->len)) {
#line 394
          goto while_break___0;
        }
#line 395
        ch = *((sc->source)->data + i);
#line 397
        if ((int )ch == 125) {
#line 397
          if (bracket) {
#line 398
            i ++;
#line 399
            bracket = (ngx_uint_t )0;
#line 400
            goto while_break___0;
          }
        }
#line 403
        if ((int )ch >= 65) {
#line 403
          if ((int )ch <= 90) {
#line 408
            goto __Cont___0;
          } else {
#line 403
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 403
        if ((int )ch >= 97) {
#line 403
          if ((int )ch <= 122) {
#line 408
            goto __Cont___0;
          } else {
#line 403
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 403
        if ((int )ch >= 48) {
#line 403
          if ((int )ch <= 57) {
#line 408
            goto __Cont___0;
          } else {
#line 403
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 403
        if ((int )ch == 95) {
#line 408
          goto __Cont___0;
        }
#line 411
        goto while_break___0;
        __Cont___0: /* CIL Label */ 
#line 394
        i ++;
#line 394
        (name.len) ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 414
      if (bracket) {
        {
#line 415
        ngx_conf_log_error((ngx_uint_t )1, sc->cf, 0, "the closing bracket in \"%V\" variable is missing",
                           & name);
        }
#line 418
        return ((ngx_int_t )-1);
      }
#line 421
      if (name.len == 0UL) {
#line 422
        goto invalid_variable;
      }
      {
#line 425
      (sc->variables) ++;
#line 427
      tmp___1 = ngx_http_script_add_var_code(sc, & name);
      }
#line 427
      if (tmp___1 != 0L) {
#line 428
        return ((ngx_int_t )-1);
      }
#line 431
      goto __Cont;
    }
#line 434
    if ((int )*((sc->source)->data + i) == 63) {
#line 434
      if (sc->compile_args) {
        {
#line 435
        sc->args = 1U;
#line 436
        sc->compile_args = 0U;
#line 438
        tmp___2 = ngx_http_script_add_args_code(sc);
        }
#line 438
        if (tmp___2 != 0L) {
#line 439
          return ((ngx_int_t )-1);
        }
#line 442
        i ++;
#line 444
        goto __Cont;
      }
    }
#line 447
    name.data = (sc->source)->data + i;
    {
#line 449
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 449
      if (! (i < (sc->source)->len)) {
#line 449
        goto while_break___1;
      }
#line 451
      if ((int )*((sc->source)->data + i) == 36) {
#line 452
        goto while_break___1;
      }
#line 455
      if ((int )*((sc->source)->data + i) == 63) {
#line 457
        sc->args = 1U;
#line 459
        if (sc->compile_args) {
#line 460
          goto while_break___1;
        }
      }
#line 464
      i ++;
#line 465
      (name.len) ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 468
    sc->size += name.len;
#line 470
    tmp___3 = ngx_http_script_add_copy_code(sc, & name, (ngx_uint_t )(i == (sc->source)->len));
    }
#line 470
    if (tmp___3 != 0L) {
#line 473
      return ((ngx_int_t )-1);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 477
  tmp___4 = ngx_http_script_done(sc);
  }
#line 477
  return (tmp___4);
  invalid_variable: 
  {
#line 481
  ngx_conf_log_error((ngx_uint_t )1, sc->cf, 0, "invalid variable name");
  }
#line 483
  return ((ngx_int_t )-1);
}
}
#line 487 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
u_char *ngx_http_script_run(ngx_http_request_t *r , ngx_str_t *value , void *code_lengths ,
                            size_t len , void *code_values ) 
{ 
  ngx_uint_t i ;
  void (*code)(ngx_http_script_engine_t *e ) ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_engine_t e ;
  ngx_http_core_main_conf_t *cmcf ;
  size_t tmp ;
  void *tmp___0 ;

  {
#line 497
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 499
  i = (ngx_uint_t )0;
  {
#line 499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 499
    if (! (i < cmcf->variables.nelts)) {
#line 499
      goto while_break;
    }
#line 500
    if ((r->variables + i)->no_cacheable) {
#line 501
      (r->variables + i)->valid = 0U;
#line 502
      (r->variables + i)->not_found = 0U;
    }
#line 499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 506
  memset((void *)(& e), 0, sizeof(ngx_http_script_engine_t ));
#line 508
  e.ip = (u_char *)code_lengths;
#line 509
  e.request = r;
#line 510
  e.flushed = 1U;
  }
  {
#line 512
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 512
    if (! *((uintptr_t *)e.ip)) {
#line 512
      goto while_break___0;
    }
    {
#line 513
    lcode = *((ngx_http_script_len_code_pt *)e.ip);
#line 514
    tmp = (*lcode)(& e);
#line 514
    len += tmp;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 518
  value->len = len;
#line 519
  tmp___0 = ngx_pnalloc(r->pool, len);
#line 519
  value->data = (u_char *)tmp___0;
  }
#line 520
  if ((unsigned long )value->data == (unsigned long )((void *)0)) {
#line 521
    return ((u_char *)((void *)0));
  }
#line 524
  e.ip = (u_char *)code_values;
#line 525
  e.pos = value->data;
  {
#line 527
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 527
    if (! *((uintptr_t *)e.ip)) {
#line 527
      goto while_break___1;
    }
    {
#line 528
    code = *((ngx_http_script_code_pt *)e.ip);
#line 529
    (*code)(& e);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 532
  return (e.pos);
}
}
#line 536 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_flush_no_cacheable_variables(ngx_http_request_t *r , ngx_array_t *indices ) 
{ 
  ngx_uint_t n ;
  ngx_uint_t *index___0 ;

  {
#line 542
  if (indices) {
#line 543
    index___0 = (ngx_uint_t *)indices->elts;
#line 544
    n = (ngx_uint_t )0;
    {
#line 544
    while (1) {
      while_continue: /* CIL Label */ ;
#line 544
      if (! (n < indices->nelts)) {
#line 544
        goto while_break;
      }
#line 545
      if ((r->variables + *(index___0 + n))->no_cacheable) {
#line 546
        (r->variables + *(index___0 + n))->valid = 0U;
#line 547
        (r->variables + *(index___0 + n))->not_found = 0U;
      }
#line 544
      n ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 551
  return;
}
}
#line 554 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_init_arrays(ngx_http_script_compile_t *sc ) 
{ 
  ngx_uint_t n ;

  {
#line 559
  if (sc->flushes) {
#line 559
    if ((unsigned long )*(sc->flushes) == (unsigned long )((void *)0)) {
#line 560
      if (sc->variables) {
#line 560
        n = sc->variables;
      } else {
#line 560
        n = (ngx_uint_t )1;
      }
      {
#line 561
      *(sc->flushes) = ngx_array_create((sc->cf)->pool, n, sizeof(ngx_uint_t ));
      }
#line 562
      if ((unsigned long )*(sc->flushes) == (unsigned long )((void *)0)) {
#line 563
        return ((ngx_int_t )-1);
      }
    }
  }
#line 567
  if ((unsigned long )*(sc->lengths) == (unsigned long )((void *)0)) {
    {
#line 568
    n = sc->variables * (2UL * sizeof(ngx_http_script_copy_code_t ) + sizeof(ngx_http_script_var_code_t )) + sizeof(uintptr_t );
#line 572
    *(sc->lengths) = ngx_array_create((sc->cf)->pool, n, (size_t )1);
    }
#line 573
    if ((unsigned long )*(sc->lengths) == (unsigned long )((void *)0)) {
#line 574
      return ((ngx_int_t )-1);
    }
  }
#line 578
  if ((unsigned long )*(sc->values) == (unsigned long )((void *)0)) {
    {
#line 579
    n = ((((sc->variables * (2UL * sizeof(ngx_http_script_copy_code_t ) + sizeof(ngx_http_script_var_code_t )) + sizeof(uintptr_t )) + (sc->source)->len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 586
    *(sc->values) = ngx_array_create((sc->cf)->pool, n, (size_t )1);
    }
#line 587
    if ((unsigned long )*(sc->values) == (unsigned long )((void *)0)) {
#line 588
      return ((ngx_int_t )-1);
    }
  }
#line 592
  sc->variables = (ngx_uint_t )0;
#line 594
  return ((ngx_int_t )0);
}
}
#line 598 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_done(ngx_http_script_compile_t *sc ) 
{ 
  ngx_str_t zero___0 ;
  uintptr_t *code ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp8 ;

  {
#line 604
  if (sc->zero) {
    {
#line 606
    zero___0.len = (size_t )1;
#line 607
    zero___0.data = (u_char *)"\000";
#line 609
    tmp = ngx_http_script_add_copy_code(sc, & zero___0, (ngx_uint_t )0);
    }
#line 609
    if (tmp != 0L) {
#line 610
      return ((ngx_int_t )-1);
    }
  }
#line 614
  if (sc->conf_prefix) {
#line 614
    goto _L;
  } else
#line 614
  if (sc->root_prefix) {
    _L: /* CIL Label */ 
    {
#line 615
    tmp___0 = ngx_http_script_add_full_name_code(sc);
    }
#line 615
    if (tmp___0 != 0L) {
#line 616
      return ((ngx_int_t )-1);
    }
  }
#line 620
  if (sc->complete_lengths) {
    {
#line 621
    tmp___1 = ngx_http_script_add_code(*(sc->lengths), sizeof(uintptr_t ), (void *)0);
#line 621
    code = (uintptr_t *)tmp___1;
    }
#line 622
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 623
      return ((ngx_int_t )-1);
    }
#line 626
    *code = (uintptr_t )((void *)0);
  }
#line 629
  if (sc->complete_values) {
    {
#line 630
    tmp___2 = ngx_http_script_add_code(*(sc->values), sizeof(uintptr_t ), (void *)(& sc->main));
#line 630
    code = (uintptr_t *)tmp___2;
    }
#line 632
    if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 633
      return ((ngx_int_t )-1);
    }
#line 636
    *code = (uintptr_t )((void *)0);
  }
#line 639
  return ((ngx_int_t )0);
}
}
#line 643 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void *ngx_http_script_start_code(ngx_pool_t *pool , ngx_array_t **codes , size_t size ) 
{ 
  void *tmp ;

  {
#line 646
  if ((unsigned long )*codes == (unsigned long )((void *)0)) {
    {
#line 647
    *codes = ngx_array_create(pool, (ngx_uint_t )256, (size_t )1);
    }
#line 648
    if ((unsigned long )*codes == (unsigned long )((void *)0)) {
#line 649
      return ((void *)0);
    }
  }
  {
#line 653
  tmp = ngx_array_push_n(*codes, size);
  }
#line 653
  return (tmp);
}
}
#line 657 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void *ngx_http_script_add_code(ngx_array_t *codes , size_t size , void *code ) 
{ 
  u_char *elts ;
  u_char **p ;
  void *new ;

  {
  {
#line 663
  elts = (u_char *)codes->elts;
#line 665
  new = ngx_array_push_n(codes, size);
  }
#line 666
  if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 667
    return ((void *)0);
  }
#line 670
  if (code) {
#line 671
    if ((unsigned long )elts != (unsigned long )codes->elts) {
#line 672
      p = (u_char **)code;
#line 673
      *p += (u_char *)codes->elts - elts;
    }
  }
#line 677
  return (new);
}
}
#line 681 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_copy_code(ngx_http_script_compile_t *sc , ngx_str_t *value ,
                                               ngx_uint_t last ) 
{ 
  u_char *p ;
  size_t size ;
  size_t len ;
  size_t zero___0 ;
  ngx_http_script_copy_code_t *code ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 689
  if (sc->zero) {
#line 689
    if (last) {
#line 689
      tmp = 1;
    } else {
#line 689
      tmp = 0;
    }
  } else {
#line 689
    tmp = 0;
  }
  {
#line 689
  zero___0 = (size_t )tmp;
#line 690
  len = value->len + zero___0;
#line 692
  tmp___0 = ngx_http_script_add_code(*(sc->lengths), sizeof(ngx_http_script_copy_code_t ),
                                     (void *)0);
#line 692
  code = (ngx_http_script_copy_code_t *)tmp___0;
  }
#line 694
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 695
    return ((ngx_int_t )-1);
  }
  {
#line 698
  code->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_len_code);
#line 699
  code->len = len;
#line 701
  size = (((sizeof(ngx_http_script_copy_code_t ) + len) + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL);
#line 704
  tmp___1 = ngx_http_script_add_code(*(sc->values), size, (void *)(& sc->main));
#line 704
  code = (ngx_http_script_copy_code_t *)tmp___1;
  }
#line 705
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 706
    return ((ngx_int_t )-1);
  }
  {
#line 709
  code->code = & ngx_http_script_copy_code;
#line 710
  code->len = len;
#line 712
  tmp___2 = memcpy((void */* __restrict  */)((u_char *)code + sizeof(ngx_http_script_copy_code_t )),
                   (void const   */* __restrict  */)value->data, value->len);
#line 712
  p = (u_char *)tmp___2 + value->len;
  }
#line 715
  if (zero___0) {
#line 716
    *p = (u_char )'\000';
#line 717
    sc->zero = 0U;
  }
#line 720
  return ((ngx_int_t )0);
}
}
#line 724 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
size_t ngx_http_script_copy_len_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_copy_code_t *code ;

  {
#line 729
  code = (ngx_http_script_copy_code_t *)e->ip;
#line 731
  e->ip += sizeof(ngx_http_script_copy_code_t );
#line 733
  return (code->len);
}
}
#line 737 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_copy_code(ngx_http_script_engine_t *e ) 
{ 
  u_char *p ;
  ngx_http_script_copy_code_t *code ;
  void *tmp ;

  {
#line 743
  code = (ngx_http_script_copy_code_t *)e->ip;
#line 745
  p = e->pos;
#line 747
  if (! e->skip) {
    {
#line 748
    tmp = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(e->ip + sizeof(ngx_http_script_copy_code_t )),
                 code->len);
#line 748
    e->pos = (u_char *)tmp + code->len;
    }
  }
#line 752
  e->ip += sizeof(ngx_http_script_copy_code_t ) + (((code->len + sizeof(uintptr_t )) - 1UL) & ~ (sizeof(uintptr_t ) - 1UL));
#line 757
  return;
}
}
#line 760 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_var_code(ngx_http_script_compile_t *sc , ngx_str_t *name ) 
{ 
  ngx_int_t index___0 ;
  ngx_int_t *p ;
  ngx_http_script_var_code_t *code ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 766
  index___0 = ngx_http_get_variable_index(sc->cf, name);
  }
#line 768
  if (index___0 == -1L) {
#line 769
    return ((ngx_int_t )-1);
  }
#line 772
  if (sc->flushes) {
    {
#line 773
    tmp = ngx_array_push(*(sc->flushes));
#line 773
    p = (ngx_int_t *)tmp;
    }
#line 774
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 775
      return ((ngx_int_t )-1);
    }
#line 778
    *p = index___0;
  }
  {
#line 781
  tmp___0 = ngx_http_script_add_code(*(sc->lengths), sizeof(ngx_http_script_var_code_t ),
                                     (void *)0);
#line 781
  code = (ngx_http_script_var_code_t *)tmp___0;
  }
#line 783
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 784
    return ((ngx_int_t )-1);
  }
  {
#line 787
  code->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_var_len_code);
#line 788
  code->index = (uintptr_t )index___0;
#line 790
  tmp___1 = ngx_http_script_add_code(*(sc->values), sizeof(ngx_http_script_var_code_t ),
                                     (void *)(& sc->main));
#line 790
  code = (ngx_http_script_var_code_t *)tmp___1;
  }
#line 793
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 794
    return ((ngx_int_t )-1);
  }
#line 797
  code->code = & ngx_http_script_copy_var_code;
#line 798
  code->index = (uintptr_t )index___0;
#line 800
  return ((ngx_int_t )0);
}
}
#line 804 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
size_t ngx_http_script_copy_var_len_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_variable_value_t *value ;
  ngx_http_script_var_code_t *code ;

  {
#line 810
  code = (ngx_http_script_var_code_t *)e->ip;
#line 812
  e->ip += sizeof(ngx_http_script_var_code_t );
#line 814
  if (e->flushed) {
    {
#line 815
    value = ngx_http_get_indexed_variable(e->request, code->index);
    }
  } else {
    {
#line 818
    value = ngx_http_get_flushed_variable(e->request, code->index);
    }
  }
#line 821
  if (value) {
#line 821
    if (! value->not_found) {
#line 822
      return ((size_t )value->len);
    }
  }
#line 825
  return ((size_t )0);
}
}
#line 829 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_copy_var_code(ngx_http_script_engine_t *e ) 
{ 
  u_char *p ;
  ngx_http_variable_value_t *value ;
  ngx_http_script_var_code_t *code ;
  void *tmp ;

  {
#line 836
  code = (ngx_http_script_var_code_t *)e->ip;
#line 838
  e->ip += sizeof(ngx_http_script_var_code_t );
#line 840
  if (! e->skip) {
#line 842
    if (e->flushed) {
      {
#line 843
      value = ngx_http_get_indexed_variable(e->request, code->index);
      }
    } else {
      {
#line 846
      value = ngx_http_get_flushed_variable(e->request, code->index);
      }
    }
#line 849
    if (value) {
#line 849
      if (! value->not_found) {
        {
#line 850
        p = e->pos;
#line 851
        tmp = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)value->data,
                     (size_t )value->len);
#line 851
        e->pos = (u_char *)tmp + value->len;
        }
      }
    }
  }
#line 858
  return;
}
}
#line 861 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_args_code(ngx_http_script_compile_t *sc ) 
{ 
  uintptr_t *code ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 866
  tmp = ngx_http_script_add_code(*(sc->lengths), sizeof(uintptr_t ), (void *)0);
#line 866
  code = (uintptr_t *)tmp;
  }
#line 867
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 868
    return ((ngx_int_t )-1);
  }
  {
#line 871
  *code = (uintptr_t )(& ngx_http_script_mark_args_code);
#line 873
  tmp___0 = ngx_http_script_add_code(*(sc->values), sizeof(uintptr_t ), (void *)(& sc->main));
#line 873
  code = (uintptr_t *)tmp___0;
  }
#line 874
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 875
    return ((ngx_int_t )-1);
  }
#line 878
  *code = (uintptr_t )(& ngx_http_script_start_args_code);
#line 880
  return ((ngx_int_t )0);
}
}
#line 884 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
size_t ngx_http_script_mark_args_code(ngx_http_script_engine_t *e ) 
{ 


  {
#line 887
  e->is_args = 1U;
#line 888
  e->ip += sizeof(uintptr_t );
#line 890
  return ((size_t )1);
}
}
#line 894 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_start_args_code(ngx_http_script_engine_t *e ) 
{ 


  {
#line 900
  e->is_args = 1U;
#line 901
  e->args = e->pos;
#line 902
  e->ip += sizeof(uintptr_t );
#line 903
  return;
}
}
#line 908 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_regex_start_code(ngx_http_script_engine_t *e ) 
{ 
  size_t len ;
  ngx_int_t rc ;
  ngx_uint_t n ;
  ngx_http_request_t *r ;
  ngx_http_script_engine_t le ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_regex_code_t *code ;
  uintptr_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 919
  code = (ngx_http_script_regex_code_t *)e->ip;
#line 921
  r = e->request;
#line 926
  if (code->uri) {
#line 927
    e->line = r->uri;
  } else {
#line 929
    (e->sp) --;
#line 930
    e->line.len = (size_t )(e->sp)->len;
#line 931
    e->line.data = (e->sp)->data;
  }
  {
#line 934
  rc = ngx_http_regex_exec(r, code->regex, & e->line);
  }
#line 936
  if (rc == -5L) {
#line 937
    if (e->log) {
#line 937
      goto _L;
    } else
#line 937
    if (((r->connection)->log)->log_level & 256UL) {
      _L: /* CIL Label */ 
#line 938
      if (((r->connection)->log)->log_level >= 6UL) {
        {
#line 938
        ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "\"%V\" does not match \"%V\"",
                           & code->name, & e->line);
        }
      }
    }
#line 943
    r->ncaptures = (ngx_uint_t )0;
#line 945
    if (code->test) {
#line 946
      if (code->negative_test) {
#line 947
        (e->sp)->len = 1U;
#line 948
        (e->sp)->data = (u_char *)"1";
      } else {
#line 951
        (e->sp)->len = 0U;
#line 952
        (e->sp)->data = (u_char *)"";
      }
#line 955
      (e->sp) ++;
#line 957
      e->ip += sizeof(ngx_http_script_regex_code_t );
#line 958
      return;
    }
#line 961
    e->ip += code->next;
#line 962
    return;
  }
#line 965
  if (rc == -1L) {
#line 966
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 967
    e->status = (ngx_int_t )500;
#line 968
    return;
  }
#line 971
  if (e->log) {
#line 971
    goto _L___0;
  } else
#line 971
  if (((r->connection)->log)->log_level & 256UL) {
    _L___0: /* CIL Label */ 
#line 972
    if (((r->connection)->log)->log_level >= 6UL) {
      {
#line 972
      ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "\"%V\" matches \"%V\"",
                         & code->name, & e->line);
      }
    }
  }
#line 976
  if (code->test) {
#line 977
    if (code->negative_test) {
#line 978
      (e->sp)->len = 0U;
#line 979
      (e->sp)->data = (u_char *)"";
    } else {
#line 982
      (e->sp)->len = 1U;
#line 983
      (e->sp)->data = (u_char *)"1";
    }
#line 986
    (e->sp) ++;
#line 988
    e->ip += sizeof(ngx_http_script_regex_code_t );
#line 989
    return;
  }
#line 992
  if (code->status) {
#line 993
    e->status = (ngx_int_t )code->status;
#line 995
    if (! code->redirect) {
#line 996
      e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 997
      return;
    }
  }
#line 1001
  if (code->uri) {
#line 1002
    r->internal = 1U;
#line 1003
    r->valid_unparsed_uri = 0U;
#line 1005
    if (code->break_cycle) {
#line 1006
      r->valid_location = 0U;
#line 1007
      r->uri_changed = 0U;
    } else {
#line 1010
      r->uri_changed = 1U;
    }
  }
#line 1014
  if ((unsigned long )code->lengths == (unsigned long )((void *)0)) {
#line 1015
    e->buf.len = code->size;
#line 1017
    if (code->uri) {
#line 1018
      if (r->ncaptures) {
#line 1018
        if (r->quoted_uri) {
          {
#line 1019
          tmp = ngx_escape_uri((u_char *)((void *)0), r->uri.data, r->uri.len, (ngx_uint_t )1);
#line 1019
          e->buf.len += 2UL * tmp;
          }
        } else
#line 1018
        if (r->plus_in_uri) {
          {
#line 1019
          tmp = ngx_escape_uri((u_char *)((void *)0), r->uri.data, r->uri.len, (ngx_uint_t )1);
#line 1019
          e->buf.len += 2UL * tmp;
          }
        }
      }
    }
#line 1024
    n = (ngx_uint_t )2;
    {
#line 1024
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1024
      if (! (n < r->ncaptures)) {
#line 1024
        goto while_break;
      }
#line 1025
      e->buf.len += (size_t )(*(r->captures + (n + 1UL)) - *(r->captures + n));
#line 1024
      n += 2UL;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1029
    memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 1031
    le.ip = (u_char *)(code->lengths)->elts;
#line 1032
    le.line = e->line;
#line 1033
    le.request = r;
#line 1034
    le.quote = code->redirect;
#line 1036
    len = (size_t )0;
    }
    {
#line 1038
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1038
      if (! *((uintptr_t *)le.ip)) {
#line 1038
        goto while_break___0;
      }
      {
#line 1039
      lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1040
      tmp___0 = (*lcode)(& le);
#line 1040
      len += tmp___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1043
    e->buf.len = len;
  }
#line 1046
  if (code->add_args) {
#line 1046
    if (r->args.len) {
#line 1047
      e->buf.len += r->args.len + 1UL;
    }
  }
  {
#line 1050
  tmp___1 = ngx_pnalloc(r->pool, e->buf.len);
#line 1050
  e->buf.data = (u_char *)tmp___1;
  }
#line 1051
  if ((unsigned long )e->buf.data == (unsigned long )((void *)0)) {
#line 1052
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1053
    e->status = (ngx_int_t )500;
#line 1054
    return;
  }
#line 1057
  e->quote = code->redirect;
#line 1059
  e->pos = e->buf.data;
#line 1061
  e->ip += sizeof(ngx_http_script_regex_code_t );
#line 1062
  return;
}
}
#line 1065 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_regex_end_code(ngx_http_script_engine_t *e ) 
{ 
  u_char *dst ;
  u_char *src ;
  ngx_http_request_t *r ;
  ngx_http_script_regex_end_code_t *code ;
  void *tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1072
  code = (ngx_http_script_regex_end_code_t *)e->ip;
#line 1074
  r = e->request;
#line 1076
  e->quote = 0U;
#line 1081
  if (code->redirect) {
    {
#line 1083
    dst = e->buf.data;
#line 1084
    src = e->buf.data;
#line 1086
    ngx_unescape_uri(& dst, & src, (size_t )(e->pos - e->buf.data), (ngx_uint_t )2);
    }
#line 1089
    if ((unsigned long )src < (unsigned long )e->pos) {
      {
#line 1090
      tmp = memmove((void *)dst, (void const   *)src, (size_t )(e->pos - src));
#line 1090
      dst = (u_char *)tmp + (e->pos - src);
      }
    }
#line 1093
    e->pos = dst;
#line 1095
    if (code->add_args) {
#line 1095
      if (r->args.len) {
#line 1096
        tmp___0 = e->pos;
#line 1096
        (e->pos) ++;
#line 1096
        if (code->args) {
#line 1096
          tmp___1 = '&';
        } else {
#line 1096
          tmp___1 = '?';
        }
        {
#line 1096
        *tmp___0 = (u_char )tmp___1;
#line 1097
        tmp___2 = memcpy((void */* __restrict  */)e->pos, (void const   */* __restrict  */)r->args.data,
                         r->args.len);
#line 1097
        e->pos = (u_char *)tmp___2 + r->args.len;
        }
      }
    }
#line 1100
    e->buf.len = (size_t )(e->pos - e->buf.data);
#line 1102
    if (e->log) {
#line 1102
      goto _L;
    } else
#line 1102
    if (((r->connection)->log)->log_level & 256UL) {
      _L: /* CIL Label */ 
#line 1103
      if (((r->connection)->log)->log_level >= 6UL) {
        {
#line 1103
        ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "rewritten redirect: \"%V\"",
                           & e->buf);
        }
      }
    }
#line 1107
    if (r->headers_out.location) {
#line 1107
      (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 1107
      r->headers_out.location = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 1109
    tmp___3 = ngx_list_push(& r->headers_out.headers);
#line 1109
    r->headers_out.location = (ngx_table_elt_t *)tmp___3;
    }
#line 1110
    if ((unsigned long )r->headers_out.location == (unsigned long )((void *)0)) {
#line 1111
      e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1112
      e->status = (ngx_int_t )500;
#line 1113
      return;
    }
#line 1116
    (r->headers_out.location)->hash = (ngx_uint_t )1;
#line 1117
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 1117
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 1118
    (r->headers_out.location)->value = e->buf;
#line 1120
    e->ip += sizeof(ngx_http_script_regex_end_code_t );
#line 1121
    return;
  }
#line 1124
  if (e->args) {
#line 1125
    e->buf.len = (size_t )(e->args - e->buf.data);
#line 1127
    if (code->add_args) {
#line 1127
      if (r->args.len) {
        {
#line 1128
        tmp___4 = e->pos;
#line 1128
        (e->pos) ++;
#line 1128
        *tmp___4 = (u_char )'&';
#line 1129
        tmp___5 = memcpy((void */* __restrict  */)e->pos, (void const   */* __restrict  */)r->args.data,
                         r->args.len);
#line 1129
        e->pos = (u_char *)tmp___5 + r->args.len;
        }
      }
    }
#line 1132
    r->args.len = (size_t )(e->pos - e->args);
#line 1133
    r->args.data = e->args;
#line 1135
    e->args = (u_char *)((void *)0);
  } else {
#line 1138
    e->buf.len = (size_t )(e->pos - e->buf.data);
#line 1140
    if (! code->add_args) {
#line 1141
      r->args.len = (size_t )0;
    }
  }
#line 1145
  if (e->log) {
#line 1145
    goto _L___0;
  } else
#line 1145
  if (((r->connection)->log)->log_level & 256UL) {
    _L___0: /* CIL Label */ 
#line 1146
    if (((r->connection)->log)->log_level >= 6UL) {
      {
#line 1146
      ngx_log_error_core((ngx_uint_t )6, (r->connection)->log, 0, "rewritten data: \"%V\", args: \"%V\"",
                         & e->buf, & r->args);
      }
    }
  }
#line 1151
  if (code->uri) {
#line 1152
    r->uri = e->buf;
#line 1154
    if (r->uri.len == 0UL) {
#line 1155
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1155
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "the rewritten URI has a zero length");
        }
      }
#line 1157
      e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1158
      e->status = (ngx_int_t )500;
#line 1159
      return;
    }
    {
#line 1162
    ngx_http_set_exten(r);
    }
  }
#line 1165
  e->ip += sizeof(ngx_http_script_regex_end_code_t );
#line 1166
  return;
}
}
#line 1169 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_capture_code(ngx_http_script_compile_t *sc ,
                                                  ngx_uint_t n ) 
{ 
  ngx_http_script_copy_capture_code_t *code ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1174
  tmp = ngx_http_script_add_code(*(sc->lengths), sizeof(ngx_http_script_copy_capture_code_t ),
                                 (void *)0);
#line 1174
  code = (ngx_http_script_copy_capture_code_t *)tmp;
  }
#line 1177
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1178
    return ((ngx_int_t )-1);
  }
  {
#line 1181
  code->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_copy_capture_len_code);
#line 1183
  code->n = 2UL * n;
#line 1186
  tmp___0 = ngx_http_script_add_code(*(sc->values), sizeof(ngx_http_script_copy_capture_code_t ),
                                     (void *)(& sc->main));
#line 1186
  code = (ngx_http_script_copy_capture_code_t *)tmp___0;
  }
#line 1189
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1190
    return ((ngx_int_t )-1);
  }
#line 1193
  code->code = & ngx_http_script_copy_capture_code;
#line 1194
  code->n = 2UL * n;
#line 1196
  if (sc->ncaptures < n) {
#line 1197
    sc->ncaptures = n;
  }
#line 1200
  return ((ngx_int_t )0);
}
}
#line 1204 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
size_t ngx_http_script_copy_capture_len_code(ngx_http_script_engine_t *e ) 
{ 
  int *cap ;
  u_char *p ;
  ngx_uint_t n ;
  ngx_http_request_t *r ;
  ngx_http_script_copy_capture_code_t *code ;
  uintptr_t tmp ;

  {
#line 1213
  r = e->request;
#line 1215
  code = (ngx_http_script_copy_capture_code_t *)e->ip;
#line 1217
  e->ip += sizeof(ngx_http_script_copy_capture_code_t );
#line 1219
  n = code->n;
#line 1221
  if (n < r->ncaptures) {
#line 1223
    cap = r->captures;
#line 1225
    if (e->is_args) {
#line 1225
      goto _L;
    } else
#line 1225
    if (e->quote) {
      _L: /* CIL Label */ 
#line 1225
      if ((e->request)->quoted_uri) {
        {
#line 1228
        p = r->captures_data;
#line 1230
        tmp = ngx_escape_uri((u_char *)((void *)0), p + *(cap + n), (size_t )(*(cap + (n + 1UL)) - *(cap + n)),
                             (ngx_uint_t )1);
        }
#line 1230
        return ((uintptr_t )(*(cap + (n + 1UL)) - *(cap + n)) + 2UL * tmp);
      } else
#line 1225
      if ((e->request)->plus_in_uri) {
        {
#line 1228
        p = r->captures_data;
#line 1230
        tmp = ngx_escape_uri((u_char *)((void *)0), p + *(cap + n), (size_t )(*(cap + (n + 1UL)) - *(cap + n)),
                             (ngx_uint_t )1);
        }
#line 1230
        return ((uintptr_t )(*(cap + (n + 1UL)) - *(cap + n)) + 2UL * tmp);
      } else {
#line 1234
        return ((size_t )(*(cap + (n + 1UL)) - *(cap + n)));
      }
    } else {
#line 1234
      return ((size_t )(*(cap + (n + 1UL)) - *(cap + n)));
    }
  }
#line 1238
  return ((size_t )0);
}
}
#line 1242 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_copy_capture_code(ngx_http_script_engine_t *e ) 
{ 
  int *cap ;
  u_char *p ;
  u_char *pos ;
  ngx_uint_t n ;
  ngx_http_request_t *r ;
  ngx_http_script_copy_capture_code_t *code ;
  uintptr_t tmp ;
  void *tmp___0 ;

  {
#line 1251
  r = e->request;
#line 1253
  code = (ngx_http_script_copy_capture_code_t *)e->ip;
#line 1255
  e->ip += sizeof(ngx_http_script_copy_capture_code_t );
#line 1257
  n = code->n;
#line 1259
  pos = e->pos;
#line 1261
  if (n < r->ncaptures) {
#line 1263
    cap = r->captures;
#line 1264
    p = r->captures_data;
#line 1266
    if (e->is_args) {
#line 1266
      goto _L;
    } else
#line 1266
    if (e->quote) {
      _L: /* CIL Label */ 
#line 1266
      if ((e->request)->quoted_uri) {
        {
#line 1269
        tmp = ngx_escape_uri(pos, p + *(cap + n), (size_t )(*(cap + (n + 1UL)) - *(cap + n)),
                             (ngx_uint_t )1);
#line 1269
        e->pos = (u_char *)tmp;
        }
      } else
#line 1266
      if ((e->request)->plus_in_uri) {
        {
#line 1269
        tmp = ngx_escape_uri(pos, p + *(cap + n), (size_t )(*(cap + (n + 1UL)) - *(cap + n)),
                             (ngx_uint_t )1);
#line 1269
        e->pos = (u_char *)tmp;
        }
      } else {
        {
#line 1273
        tmp___0 = memcpy((void */* __restrict  */)pos, (void const   */* __restrict  */)(p + *(cap + n)),
                         (size_t )(*(cap + (n + 1UL)) - *(cap + n)));
#line 1273
        e->pos = (u_char *)tmp___0 + (*(cap + (n + 1UL)) - *(cap + n));
        }
      }
    } else {
      {
#line 1273
      tmp___0 = memcpy((void */* __restrict  */)pos, (void const   */* __restrict  */)(p + *(cap + n)),
                       (size_t )(*(cap + (n + 1UL)) - *(cap + n)));
#line 1273
      e->pos = (u_char *)tmp___0 + (*(cap + (n + 1UL)) - *(cap + n));
      }
    }
  }
#line 1279
  return;
}
}
#line 1284 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static ngx_int_t ngx_http_script_add_full_name_code(ngx_http_script_compile_t *sc ) 
{ 
  ngx_http_script_full_name_code_t *code ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1289
  tmp = ngx_http_script_add_code(*(sc->lengths), sizeof(ngx_http_script_full_name_code_t ),
                                 (void *)0);
#line 1289
  code = (ngx_http_script_full_name_code_t *)tmp;
  }
#line 1292
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1293
    return ((ngx_int_t )-1);
  }
  {
#line 1296
  code->code = (void (*)(ngx_http_script_engine_t *e ))(& ngx_http_script_full_name_len_code);
#line 1297
  code->conf_prefix = (uintptr_t )sc->conf_prefix;
#line 1299
  tmp___0 = ngx_http_script_add_code(*(sc->values), sizeof(ngx_http_script_full_name_code_t ),
                                     (void *)(& sc->main));
#line 1299
  code = (ngx_http_script_full_name_code_t *)tmp___0;
  }
#line 1302
  if ((unsigned long )code == (unsigned long )((void *)0)) {
#line 1303
    return ((ngx_int_t )-1);
  }
#line 1306
  code->code = & ngx_http_script_full_name_code;
#line 1307
  code->conf_prefix = (uintptr_t )sc->conf_prefix;
#line 1309
  return ((ngx_int_t )0);
}
}
#line 1313 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static size_t ngx_http_script_full_name_len_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_full_name_code_t *code ;
  size_t volatile   tmp ;

  {
#line 1318
  code = (ngx_http_script_full_name_code_t *)e->ip;
#line 1320
  e->ip += sizeof(ngx_http_script_full_name_code_t );
#line 1322
  if (code->conf_prefix) {
#line 1322
    tmp = ngx_cycle->conf_prefix.len;
  } else {
#line 1322
    tmp = ngx_cycle->prefix.len;
  }
#line 1322
  return ((size_t )tmp);
}
}
#line 1327 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
static void ngx_http_script_full_name_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_full_name_code_t *code ;
  ngx_str_t value ;
  ngx_str_t *prefix ;
  ngx_int_t tmp ;

  {
#line 1334
  code = (ngx_http_script_full_name_code_t *)e->ip;
#line 1336
  value.data = e->buf.data;
#line 1337
  value.len = (size_t )(e->pos - e->buf.data);
#line 1339
  if (code->conf_prefix) {
#line 1339
    prefix = (ngx_str_t *)(& ngx_cycle->conf_prefix);
  } else {
#line 1339
    prefix = (ngx_str_t *)(& ngx_cycle->prefix);
  }
  {
#line 1342
  tmp = ngx_get_full_name((e->request)->pool, prefix, & value);
  }
#line 1342
  if (tmp != 0L) {
#line 1343
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1344
    e->status = (ngx_int_t )500;
#line 1345
    return;
  }
#line 1348
  e->buf = value;
#line 1353
  e->ip += sizeof(ngx_http_script_full_name_code_t );
#line 1354
  return;
}
}
#line 1357 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_return_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_return_code_t *code ;

  {
#line 1362
  code = (ngx_http_script_return_code_t *)e->ip;
#line 1364
  if (code->status < 400UL) {
    {
#line 1368
    e->status = ngx_http_send_response(e->request, code->status, (ngx_str_t *)((void *)0),
                                       & code->text);
    }
  } else
#line 1364
  if (code->text.value.len) {
    {
#line 1368
    e->status = ngx_http_send_response(e->request, code->status, (ngx_str_t *)((void *)0),
                                       & code->text);
    }
  } else
#line 1364
  if (code->text.lengths) {
    {
#line 1368
    e->status = ngx_http_send_response(e->request, code->status, (ngx_str_t *)((void *)0),
                                       & code->text);
    }
  } else {
#line 1371
    e->status = (ngx_int_t )code->status;
  }
#line 1374
  e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1375
  return;
}
}
#line 1378 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_break_code(ngx_http_script_engine_t *e ) 
{ 


  {
#line 1381
  (e->request)->uri_changed = 0U;
#line 1383
  e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1384
  return;
}
}
#line 1387 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_if_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_if_code_t *code ;

  {
#line 1392
  code = (ngx_http_script_if_code_t *)e->ip;
#line 1397
  (e->sp) --;
#line 1399
  if ((e->sp)->len) {
#line 1399
    if ((e->sp)->len != 1U) {
#line 1399
      goto _L;
    } else
#line 1399
    if ((int )*((e->sp)->data + 0) != 48) {
      _L: /* CIL Label */ 
#line 1400
      if (code->loc_conf) {
        {
#line 1401
        (e->request)->loc_conf = code->loc_conf;
#line 1402
        ngx_http_update_location_config(e->request);
        }
      }
#line 1405
      e->ip += sizeof(ngx_http_script_if_code_t );
#line 1406
      return;
    }
  }
#line 1412
  e->ip += code->next;
#line 1413
  return;
}
}
#line 1416 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_equal_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_variable_value_t *val ;
  ngx_http_variable_value_t *res ;
  int tmp ;

  {
#line 1424
  (e->sp) --;
#line 1425
  val = e->sp;
#line 1426
  res = e->sp - 1;
#line 1428
  e->ip += sizeof(uintptr_t );
#line 1430
  if (val->len == res->len) {
    {
#line 1430
    tmp = strncmp((char const   *)val->data, (char const   *)res->data, (size_t )res->len);
    }
#line 1430
    if (tmp == 0) {
#line 1433
      *res = ngx_http_variable_true_value;
#line 1434
      return;
    }
  }
#line 1440
  *res = ngx_http_variable_null_value;
#line 1441
  return;
}
}
#line 1444 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_not_equal_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_variable_value_t *val ;
  ngx_http_variable_value_t *res ;
  int tmp ;

  {
#line 1452
  (e->sp) --;
#line 1453
  val = e->sp;
#line 1454
  res = e->sp - 1;
#line 1456
  e->ip += sizeof(uintptr_t );
#line 1458
  if (val->len == res->len) {
    {
#line 1458
    tmp = strncmp((char const   *)val->data, (char const   *)res->data, (size_t )res->len);
    }
#line 1458
    if (tmp == 0) {
#line 1464
      *res = ngx_http_variable_null_value;
#line 1465
      return;
    }
  }
#line 1468
  *res = ngx_http_variable_true_value;
#line 1469
  return;
}
}
#line 1472 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_file_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_str_t path ;
  ngx_http_request_t *r ;
  ngx_open_file_info_t of ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_variable_value_t *value ;
  ngx_http_script_file_code_t *code ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp10 ;

  {
  {
#line 1482
  value = e->sp - 1;
#line 1484
  code = (ngx_http_script_file_code_t *)e->ip;
#line 1485
  e->ip += sizeof(ngx_http_script_file_code_t );
#line 1487
  path.len = (size_t )(value->len - 1U);
#line 1488
  path.data = value->data;
#line 1490
  r = e->request;
#line 1495
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1497
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 1499
  of.read_ahead = clcf->read_ahead;
#line 1500
  of.directio = clcf->directio;
#line 1501
  of.valid = clcf->open_file_cache_valid;
#line 1502
  of.min_uses = clcf->open_file_cache_min_uses;
#line 1503
  of.test_only = 1U;
#line 1504
  of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 1505
  of.events = (unsigned int )clcf->open_file_cache_events;
#line 1507
  tmp = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
  }
#line 1507
  if (tmp != 0L) {
#line 1508
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1509
    e->status = (ngx_int_t )500;
#line 1510
    return;
  }
  {
#line 1513
  tmp___0 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
  }
#line 1513
  if (tmp___0 != 0L) {
#line 1516
    if (of.err == 0) {
#line 1517
      e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1518
      e->status = (ngx_int_t )500;
#line 1519
      return;
    }
#line 1522
    if (of.err != 2) {
#line 1522
      if (of.err != 20) {
#line 1522
        if (of.err != 36) {
#line 1526
          if (((r->connection)->log)->log_level >= 3UL) {
            {
#line 1526
            ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, of.err, "%s \"%s\" failed",
                               of.failed, value->data);
            }
          }
        }
      }
    }
    {
#line 1535
    if (code->op == 6UL) {
#line 1535
      goto case_6;
    }
#line 1535
    if (code->op == 4UL) {
#line 1535
      goto case_6;
    }
#line 1535
    if (code->op == 2UL) {
#line 1535
      goto case_6;
    }
#line 1535
    if (code->op == 0UL) {
#line 1535
      goto case_6;
    }
#line 1541
    if (code->op == 7UL) {
#line 1541
      goto case_7;
    }
#line 1541
    if (code->op == 5UL) {
#line 1541
      goto case_7;
    }
#line 1541
    if (code->op == 3UL) {
#line 1541
      goto case_7;
    }
#line 1541
    if (code->op == 1UL) {
#line 1541
      goto case_7;
    }
#line 1530
    goto switch_break;
    case_6: /* CIL Label */ 
    case_4: /* CIL Label */ 
    case_2: /* CIL Label */ 
    case_0: /* CIL Label */ 
#line 1536
    goto false_value;
    case_7: /* CIL Label */ 
    case_5: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 1542
    goto true_value;
    switch_break: /* CIL Label */ ;
    }
#line 1545
    goto false_value;
  }
  {
#line 1549
  if (code->op == 0UL) {
#line 1549
    goto case_0___0;
  }
#line 1555
  if (code->op == 1UL) {
#line 1555
    goto case_1___0;
  }
#line 1561
  if (code->op == 2UL) {
#line 1561
    goto case_2___0;
  }
#line 1567
  if (code->op == 3UL) {
#line 1567
    goto case_3___0;
  }
#line 1573
  if (code->op == 4UL) {
#line 1573
    goto case_4___0;
  }
#line 1579
  if (code->op == 5UL) {
#line 1579
    goto case_5___0;
  }
#line 1585
  if (code->op == 6UL) {
#line 1585
    goto case_6___0;
  }
#line 1591
  if (code->op == 7UL) {
#line 1591
    goto case_7___0;
  }
#line 1548
  goto switch_break___0;
  case_0___0: /* CIL Label */ 
#line 1550
  if (of.is_file) {
#line 1551
    goto true_value;
  }
#line 1553
  goto false_value;
  case_1___0: /* CIL Label */ 
#line 1556
  if (of.is_file) {
#line 1557
    goto false_value;
  }
#line 1559
  goto true_value;
  case_2___0: /* CIL Label */ 
#line 1562
  if (of.is_dir) {
#line 1563
    goto true_value;
  }
#line 1565
  goto false_value;
  case_3___0: /* CIL Label */ 
#line 1568
  if (of.is_dir) {
#line 1569
    goto false_value;
  }
#line 1571
  goto true_value;
  case_4___0: /* CIL Label */ 
#line 1574
  if (of.is_file) {
#line 1575
    goto true_value;
  } else
#line 1574
  if (of.is_dir) {
#line 1575
    goto true_value;
  } else
#line 1574
  if (of.is_link) {
#line 1575
    goto true_value;
  }
#line 1577
  goto false_value;
  case_5___0: /* CIL Label */ 
#line 1580
  if (of.is_file) {
#line 1581
    goto false_value;
  } else
#line 1580
  if (of.is_dir) {
#line 1581
    goto false_value;
  } else
#line 1580
  if (of.is_link) {
#line 1581
    goto false_value;
  }
#line 1583
  goto true_value;
  case_6___0: /* CIL Label */ 
#line 1586
  if (of.is_exec) {
#line 1587
    goto true_value;
  }
#line 1589
  goto false_value;
  case_7___0: /* CIL Label */ 
#line 1592
  if (of.is_exec) {
#line 1593
    goto false_value;
  }
#line 1595
  goto true_value;
  switch_break___0: /* CIL Label */ ;
  }
  false_value: 
#line 1603
  *value = ngx_http_variable_null_value;
#line 1604
  return;
  true_value: 
#line 1608
  *value = ngx_http_variable_true_value;
#line 1609
  return;
}
}
#line 1613 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_complex_value_code(ngx_http_script_engine_t *e ) 
{ 
  size_t len ;
  ngx_http_script_engine_t le ;
  size_t (*lcode)(ngx_http_script_engine_t *e ) ;
  ngx_http_script_complex_value_code_t *code ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 1621
  code = (ngx_http_script_complex_value_code_t *)e->ip;
#line 1623
  e->ip += sizeof(ngx_http_script_complex_value_code_t );
#line 1628
  memset((void *)(& le), 0, sizeof(ngx_http_script_engine_t ));
#line 1630
  le.ip = (u_char *)(code->lengths)->elts;
#line 1631
  le.line = e->line;
#line 1632
  le.request = e->request;
#line 1633
  le.quote = e->quote;
#line 1635
  len = (size_t )0;
  }
  {
#line 1635
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1635
    if (! *((uintptr_t *)le.ip)) {
#line 1635
      goto while_break;
    }
    {
#line 1636
    lcode = *((ngx_http_script_len_code_pt *)le.ip);
#line 1635
    tmp = (*lcode)(& le);
#line 1635
    len += tmp;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1639
  e->buf.len = len;
#line 1640
  tmp___0 = ngx_pnalloc((e->request)->pool, len);
#line 1640
  e->buf.data = (u_char *)tmp___0;
  }
#line 1641
  if ((unsigned long )e->buf.data == (unsigned long )((void *)0)) {
#line 1642
    e->ip = (u_char *)(& ngx_http_script_exit_code);
#line 1643
    e->status = (ngx_int_t )500;
#line 1644
    return;
  }
#line 1647
  e->pos = e->buf.data;
#line 1649
  (e->sp)->len = (unsigned int )e->buf.len;
#line 1650
  (e->sp)->data = e->buf.data;
#line 1651
  (e->sp) ++;
#line 1652
  return;
}
}
#line 1655 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_value_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_value_code_t *code ;

  {
#line 1660
  code = (ngx_http_script_value_code_t *)e->ip;
#line 1662
  e->ip += sizeof(ngx_http_script_value_code_t );
#line 1664
  (e->sp)->len = (unsigned int )code->text_len;
#line 1665
  (e->sp)->data = (u_char *)code->text_data;
#line 1670
  (e->sp) ++;
#line 1671
  return;
}
}
#line 1674 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_set_var_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_request_t *r ;
  ngx_http_script_var_code_t *code ;

  {
#line 1680
  code = (ngx_http_script_var_code_t *)e->ip;
#line 1682
  e->ip += sizeof(ngx_http_script_var_code_t );
#line 1684
  r = e->request;
#line 1686
  (e->sp) --;
#line 1688
  (r->variables + code->index)->len = (e->sp)->len;
#line 1689
  (r->variables + code->index)->valid = 1U;
#line 1690
  (r->variables + code->index)->no_cacheable = 0U;
#line 1691
  (r->variables + code->index)->not_found = 0U;
#line 1692
  (r->variables + code->index)->data = (e->sp)->data;
#line 1707
  return;
}
}
#line 1710 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_var_set_handler_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_script_var_handler_code_t *code ;

  {
  {
#line 1718
  code = (ngx_http_script_var_handler_code_t *)e->ip;
#line 1720
  e->ip += sizeof(ngx_http_script_var_handler_code_t );
#line 1722
  (e->sp) --;
#line 1724
  (*(code->handler))(e->request, e->sp, code->data);
  }
#line 1725
  return;
}
}
#line 1728 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_var_code(ngx_http_script_engine_t *e ) 
{ 
  ngx_http_variable_value_t *value ;
  ngx_http_script_var_code_t *code ;

  {
  {
#line 1737
  code = (ngx_http_script_var_code_t *)e->ip;
#line 1739
  e->ip += sizeof(ngx_http_script_var_code_t );
#line 1741
  value = ngx_http_get_flushed_variable(e->request, code->index);
  }
#line 1743
  if (value) {
#line 1743
    if (! value->not_found) {
#line 1747
      *(e->sp) = *value;
#line 1748
      (e->sp) ++;
#line 1750
      return;
    }
  }
#line 1753
  *(e->sp) = ngx_http_variable_null_value;
#line 1754
  (e->sp) ++;
#line 1755
  return;
}
}
#line 1758 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_script.c"
void ngx_http_script_nop_code(ngx_http_script_engine_t *e ) 
{ 


  {
#line 1761
  e->ip += sizeof(uintptr_t );
#line 1762
  return;
}
}
#line 321 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) random)(void) ;
#line 734
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) realpath)(char const   * __restrict  __name ,
                                                                                 char * __restrict  __resolved ) ;
#line 41 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_http_log_time ;
#line 42
ngx_str_t volatile   ngx_cached_http_log_iso8601 ;
#line 108 "src/http/ngx_http_variables.h"
ngx_int_t ngx_http_variables_add_core_vars(ngx_conf_t *cf ) ;
#line 109
ngx_int_t ngx_http_variables_init_vars(ngx_conf_t *cf ) ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_http_variable_t *ngx_http_add_prefix_variable(ngx_conf_t *cf , ngx_str_t *name ,
                                                         ngx_uint_t flags ) ;
#line 17
static ngx_int_t ngx_http_variable_request(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 23
static ngx_int_t ngx_http_variable_request_get_size(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ) ;
#line 25
static void ngx_http_variable_request_set_size(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 27
static ngx_int_t ngx_http_variable_header(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) ;
#line 30
static ngx_int_t ngx_http_variable_cookies(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 32
static ngx_int_t ngx_http_variable_headers(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 34
static ngx_int_t ngx_http_variable_headers_internal(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data , u_char sep ) ;
#line 37
static ngx_int_t ngx_http_variable_unknown_header_in(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) ;
#line 39
static ngx_int_t ngx_http_variable_unknown_header_out(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) ;
#line 41
static ngx_int_t ngx_http_variable_unknown_trailer_out(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 43
static ngx_int_t ngx_http_variable_request_line(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 45
static ngx_int_t ngx_http_variable_cookie(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) ;
#line 47
static ngx_int_t ngx_http_variable_argument(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) ;
#line 50
static ngx_int_t ngx_http_variable_tcpinfo(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 54
static ngx_int_t ngx_http_variable_content_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) ;
#line 56
static ngx_int_t ngx_http_variable_host(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) ;
#line 58
static ngx_int_t ngx_http_variable_binary_remote_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) ;
#line 60
static ngx_int_t ngx_http_variable_remote_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 62
static ngx_int_t ngx_http_variable_remote_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 64
static ngx_int_t ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 66
static ngx_int_t ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 68
static ngx_int_t ngx_http_variable_server_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 70
static ngx_int_t ngx_http_variable_server_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 72
static ngx_int_t ngx_http_variable_scheme(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) ;
#line 74
static ngx_int_t ngx_http_variable_https(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                         uintptr_t data ) ;
#line 76
static void ngx_http_variable_set_args(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) ;
#line 78
static ngx_int_t ngx_http_variable_is_args(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) ;
#line 80
static ngx_int_t ngx_http_variable_document_root(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 82
static ngx_int_t ngx_http_variable_realpath_root(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 84
static ngx_int_t ngx_http_variable_request_filename(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ) ;
#line 86
static ngx_int_t ngx_http_variable_server_name(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 88
static ngx_int_t ngx_http_variable_request_method(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) ;
#line 90
static ngx_int_t ngx_http_variable_remote_user(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) ;
#line 92
static ngx_int_t ngx_http_variable_bytes_sent(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 94
static ngx_int_t ngx_http_variable_body_bytes_sent(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 96
static ngx_int_t ngx_http_variable_pipe(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) ;
#line 98
static ngx_int_t ngx_http_variable_request_completion(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) ;
#line 100
static ngx_int_t ngx_http_variable_request_body(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 102
static ngx_int_t ngx_http_variable_request_body_file(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) ;
#line 104
static ngx_int_t ngx_http_variable_request_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) ;
#line 106
static ngx_int_t ngx_http_variable_request_time(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 108
static ngx_int_t ngx_http_variable_request_id(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 110
static ngx_int_t ngx_http_variable_status(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) ;
#line 113
static ngx_int_t ngx_http_variable_sent_content_type(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) ;
#line 115
static ngx_int_t ngx_http_variable_sent_content_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 117
static ngx_int_t ngx_http_variable_sent_location(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 119
static ngx_int_t ngx_http_variable_sent_last_modified(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) ;
#line 121
static ngx_int_t ngx_http_variable_sent_connection(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 123
static ngx_int_t ngx_http_variable_sent_keep_alive(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) ;
#line 125
static ngx_int_t ngx_http_variable_sent_transfer_encoding(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) ;
#line 128
static ngx_int_t ngx_http_variable_connection(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 130
static ngx_int_t ngx_http_variable_connection_requests(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) ;
#line 133
static ngx_int_t ngx_http_variable_nginx_version(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) ;
#line 135
static ngx_int_t ngx_http_variable_hostname(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) ;
#line 137
static ngx_int_t ngx_http_variable_pid(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) ;
#line 139
static ngx_int_t ngx_http_variable_msec(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) ;
#line 141
static ngx_int_t ngx_http_variable_time_iso8601(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) ;
#line 143
static ngx_int_t ngx_http_variable_time_local(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) ;
#line 162 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_http_variable_t ngx_http_core_variables[69]  = 
#line 162
  {      {{sizeof("http_host") - 1UL, (u_char *)"http_host"}, (void (*)(ngx_http_request_t *r ,
                                                                    ngx_http_variable_value_t *v ,
                                                                    uintptr_t data ))((void *)0),
      & ngx_http_variable_header, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.host),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_user_agent") - 1UL, (u_char *)"http_user_agent"}, (void (*)(ngx_http_request_t *r ,
                                                                                ngx_http_variable_value_t *v ,
                                                                                uintptr_t data ))((void *)0),
      & ngx_http_variable_header, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.user_agent),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_referer") - 1UL, (u_char *)"http_referer"}, (void (*)(ngx_http_request_t *r ,
                                                                          ngx_http_variable_value_t *v ,
                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_header, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.referer),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_via") - 1UL, (u_char *)"http_via"}, (void (*)(ngx_http_request_t *r ,
                                                                  ngx_http_variable_value_t *v ,
                                                                  uintptr_t data ))((void *)0),
      & ngx_http_variable_header, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.via),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_x_forwarded_for") - 1UL, (u_char *)"http_x_forwarded_for"}, (void (*)(ngx_http_request_t *r ,
                                                                                          ngx_http_variable_value_t *v ,
                                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_headers, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.x_forwarded_for),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("http_cookie") - 1UL, (u_char *)"http_cookie"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_cookies, (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.cookies),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("content_length") - 1UL, (u_char *)"content_length"}, (void (*)(ngx_http_request_t *r ,
                                                                              ngx_http_variable_value_t *v ,
                                                                              uintptr_t data ))((void *)0),
      & ngx_http_variable_content_length, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("content_type") - 1UL,
       (u_char *)"content_type"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ))((void *)0), & ngx_http_variable_header,
      (unsigned long )(& ((ngx_http_request_t *)0)->headers_in.content_type), (ngx_uint_t )0,
      (ngx_uint_t )0}, 
        {{sizeof("host") - 1UL, (u_char *)"host"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_host, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("binary_remote_addr") - 1UL, (u_char *)"binary_remote_addr"}, (void (*)(ngx_http_request_t *r ,
                                                                                      ngx_http_variable_value_t *v ,
                                                                                      uintptr_t data ))((void *)0),
      & ngx_http_variable_binary_remote_addr, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("remote_addr") - 1UL,
       (u_char *)"remote_addr"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ))((void *)0), & ngx_http_variable_remote_addr,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("remote_port") - 1UL, (u_char *)"remote_port"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_remote_port, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("proxy_protocol_addr") - 1UL,
       (u_char *)"proxy_protocol_addr"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ))((void *)0), & ngx_http_variable_proxy_protocol_addr,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("proxy_protocol_port") - 1UL, (u_char *)"proxy_protocol_port"}, (void (*)(ngx_http_request_t *r ,
                                                                                        ngx_http_variable_value_t *v ,
                                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_proxy_protocol_port, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("server_addr") - 1UL,
       (u_char *)"server_addr"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ))((void *)0), & ngx_http_variable_server_addr,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("server_port") - 1UL, (u_char *)"server_port"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_server_port, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("server_protocol") - 1UL,
       (u_char *)"server_protocol"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ))((void *)0), & ngx_http_variable_request,
      (unsigned long )(& ((ngx_http_request_t *)0)->http_protocol), (ngx_uint_t )0,
      (ngx_uint_t )0}, 
        {{sizeof("scheme") - 1UL, (u_char *)"scheme"}, (void (*)(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ))((void *)0),
      & ngx_http_variable_scheme, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("https") - 1UL, (u_char *)"https"}, (void (*)(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_https, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_uri") - 1UL, (u_char *)"request_uri"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_request, (unsigned long )(& ((ngx_http_request_t *)0)->unparsed_uri),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("uri") - 1UL, (u_char *)"uri"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_request, (unsigned long )(& ((ngx_http_request_t *)0)->uri),
      (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("document_uri") - 1UL, (u_char *)"document_uri"}, (void (*)(ngx_http_request_t *r ,
                                                                          ngx_http_variable_value_t *v ,
                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_request, (unsigned long )(& ((ngx_http_request_t *)0)->uri),
      (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("request") - 1UL, (u_char *)"request"}, (void (*)(ngx_http_request_t *r ,
                                                                ngx_http_variable_value_t *v ,
                                                                uintptr_t data ))((void *)0),
      & ngx_http_variable_request_line, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("document_root") - 1UL,
       (u_char *)"document_root"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                             uintptr_t data ))((void *)0), & ngx_http_variable_document_root,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("realpath_root") - 1UL, (u_char *)"realpath_root"}, (void (*)(ngx_http_request_t *r ,
                                                                            ngx_http_variable_value_t *v ,
                                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_realpath_root, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("query_string") - 1UL,
       (u_char *)"query_string"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ))((void *)0), & ngx_http_variable_request,
      (unsigned long )(& ((ngx_http_request_t *)0)->args), (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("args") - 1UL,
       (u_char *)"args"}, & ngx_http_variable_set_args, & ngx_http_variable_request,
      (unsigned long )(& ((ngx_http_request_t *)0)->args), (ngx_uint_t )3, (ngx_uint_t )0}, 
        {{sizeof("is_args") - 1UL,
       (u_char *)"is_args"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ))((void *)0), & ngx_http_variable_is_args,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("request_filename") - 1UL, (u_char *)"request_filename"}, (void (*)(ngx_http_request_t *r ,
                                                                                  ngx_http_variable_value_t *v ,
                                                                                  uintptr_t data ))((void *)0),
      & ngx_http_variable_request_filename, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("server_name") - 1UL,
       (u_char *)"server_name"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ))((void *)0), & ngx_http_variable_server_name,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_method") - 1UL, (u_char *)"request_method"}, (void (*)(ngx_http_request_t *r ,
                                                                              ngx_http_variable_value_t *v ,
                                                                              uintptr_t data ))((void *)0),
      & ngx_http_variable_request_method, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("remote_user") - 1UL,
       (u_char *)"remote_user"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ))((void *)0), & ngx_http_variable_remote_user,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("bytes_sent") - 1UL, (u_char *)"bytes_sent"}, (void (*)(ngx_http_request_t *r ,
                                                                      ngx_http_variable_value_t *v ,
                                                                      uintptr_t data ))((void *)0),
      & ngx_http_variable_bytes_sent, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("body_bytes_sent") - 1UL,
       (u_char *)"body_bytes_sent"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ))((void *)0), & ngx_http_variable_body_bytes_sent,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("pipe") - 1UL, (u_char *)"pipe"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_pipe, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_completion") - 1UL, (u_char *)"request_completion"}, (void (*)(ngx_http_request_t *r ,
                                                                                      ngx_http_variable_value_t *v ,
                                                                                      uintptr_t data ))((void *)0),
      & ngx_http_variable_request_completion, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_body") - 1UL,
       (u_char *)"request_body"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ))((void *)0), & ngx_http_variable_request_body,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_body_file") - 1UL, (u_char *)"request_body_file"}, (void (*)(ngx_http_request_t *r ,
                                                                                    ngx_http_variable_value_t *v ,
                                                                                    uintptr_t data ))((void *)0),
      & ngx_http_variable_request_body_file, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("request_length") - 1UL,
       (u_char *)"request_length"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ))((void *)0), & ngx_http_variable_request_length,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("request_time") - 1UL, (u_char *)"request_time"}, (void (*)(ngx_http_request_t *r ,
                                                                          ngx_http_variable_value_t *v ,
                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_request_time, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("request_id") - 1UL,
       (u_char *)"request_id"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ))((void *)0), & ngx_http_variable_request_id,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("status") - 1UL, (u_char *)"status"}, (void (*)(ngx_http_request_t *r ,
                                                              ngx_http_variable_value_t *v ,
                                                              uintptr_t data ))((void *)0),
      & ngx_http_variable_status, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("sent_http_content_type") - 1UL, (u_char *)"sent_http_content_type"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_content_type, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_content_length") - 1UL,
       (u_char *)"sent_http_content_length"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_content_length, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_location") - 1UL,
       (u_char *)"sent_http_location"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ))((void *)0), & ngx_http_variable_sent_location,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_last_modified") - 1UL, (u_char *)"sent_http_last_modified"},
      (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v , uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_last_modified, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_connection") - 1UL,
       (u_char *)"sent_http_connection"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_connection, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_keep_alive") - 1UL,
       (u_char *)"sent_http_keep_alive"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_keep_alive, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_transfer_encoding") - 1UL,
       (u_char *)"sent_http_transfer_encoding"}, (void (*)(ngx_http_request_t *r ,
                                                           ngx_http_variable_value_t *v ,
                                                           uintptr_t data ))((void *)0),
      & ngx_http_variable_sent_transfer_encoding, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("sent_http_cache_control") - 1UL,
       (u_char *)"sent_http_cache_control"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ))((void *)0),
      & ngx_http_variable_headers, (unsigned long )(& ((ngx_http_request_t *)0)->headers_out.cache_control),
      (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("limit_rate") - 1UL, (u_char *)"limit_rate"}, & ngx_http_variable_request_set_size,
      & ngx_http_variable_request_get_size, (unsigned long )(& ((ngx_http_request_t *)0)->limit_rate),
      (ngx_uint_t )3, (ngx_uint_t )0}, 
        {{sizeof("connection") - 1UL, (u_char *)"connection"}, (void (*)(ngx_http_request_t *r ,
                                                                      ngx_http_variable_value_t *v ,
                                                                      uintptr_t data ))((void *)0),
      & ngx_http_variable_connection, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("connection_requests") - 1UL,
       (u_char *)"connection_requests"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ))((void *)0), & ngx_http_variable_connection_requests,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("nginx_version") - 1UL, (u_char *)"nginx_version"}, (void (*)(ngx_http_request_t *r ,
                                                                            ngx_http_variable_value_t *v ,
                                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_nginx_version, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("hostname") - 1UL,
       (u_char *)"hostname"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ))((void *)0), & ngx_http_variable_hostname,
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("pid") - 1UL, (u_char *)"pid"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_pid, (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}, 
        {{sizeof("msec") - 1UL, (u_char *)"msec"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_msec, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("time_iso8601") - 1UL, (u_char *)"time_iso8601"}, (void (*)(ngx_http_request_t *r ,
                                                                          ngx_http_variable_value_t *v ,
                                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_time_iso8601, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("time_local") - 1UL,
       (u_char *)"time_local"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ))((void *)0), & ngx_http_variable_time_local,
      (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("tcpinfo_rtt") - 1UL, (u_char *)"tcpinfo_rtt"}, (void (*)(ngx_http_request_t *r ,
                                                                        ngx_http_variable_value_t *v ,
                                                                        uintptr_t data ))((void *)0),
      & ngx_http_variable_tcpinfo, (uintptr_t )0, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("tcpinfo_rttvar") - 1UL,
       (u_char *)"tcpinfo_rttvar"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ))((void *)0), & ngx_http_variable_tcpinfo,
      (uintptr_t )1, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("tcpinfo_snd_cwnd") - 1UL, (u_char *)"tcpinfo_snd_cwnd"}, (void (*)(ngx_http_request_t *r ,
                                                                                  ngx_http_variable_value_t *v ,
                                                                                  uintptr_t data ))((void *)0),
      & ngx_http_variable_tcpinfo, (uintptr_t )2, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("tcpinfo_rcv_space") - 1UL,
       (u_char *)"tcpinfo_rcv_space"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ))((void *)0), & ngx_http_variable_tcpinfo,
      (uintptr_t )3, (ngx_uint_t )2, (ngx_uint_t )0}, 
        {{sizeof("http_") - 1UL, (u_char *)"http_"}, (void (*)(ngx_http_request_t *r ,
                                                            ngx_http_variable_value_t *v ,
                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_unknown_header_in, (uintptr_t )0, (ngx_uint_t )32, (ngx_uint_t )0}, 
        {{sizeof("sent_http_") - 1UL,
       (u_char *)"sent_http_"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ))((void *)0), & ngx_http_variable_unknown_header_out,
      (uintptr_t )0, (ngx_uint_t )32, (ngx_uint_t )0}, 
        {{sizeof("sent_trailer_") - 1UL, (u_char *)"sent_trailer_"}, (void (*)(ngx_http_request_t *r ,
                                                                            ngx_http_variable_value_t *v ,
                                                                            uintptr_t data ))((void *)0),
      & ngx_http_variable_unknown_trailer_out, (uintptr_t )0, (ngx_uint_t )32, (ngx_uint_t )0}, 
        {{sizeof("cookie_") - 1UL,
       (u_char *)"cookie_"}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ))((void *)0), & ngx_http_variable_cookie,
      (uintptr_t )0, (ngx_uint_t )32, (ngx_uint_t )0}, 
        {{sizeof("arg_") - 1UL, (u_char *)"arg_"}, (void (*)(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ))((void *)0),
      & ngx_http_variable_argument, (uintptr_t )0, (ngx_uint_t )34, (ngx_uint_t )0}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                         uintptr_t data ))((void *)0), (ngx_int_t (*)(ngx_http_request_t *r ,
                                                                                      ngx_http_variable_value_t *v ,
                                                                                      uintptr_t data ))((void *)0),
      (uintptr_t )0, (ngx_uint_t )0, (ngx_uint_t )0}};
#line 383 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_http_variable_value_t ngx_http_variable_null_value  =    {(unsigned int )(sizeof("") - 1UL), 1U, 0U, 0U, 0U, (u_char *)""};
#line 385 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_http_variable_value_t ngx_http_variable_true_value  =    {(unsigned int )(sizeof("1") - 1UL), 1U, 0U, 0U, 0U, (u_char *)"1"};
#line 389 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_uint_t ngx_http_variable_depth  =    (ngx_uint_t )100;
#line 392 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_http_variable_t *ngx_http_add_variable(ngx_conf_t *cf , ngx_str_t *name , ngx_uint_t flags ) 
{ 
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_hash_key_t *key ;
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_http_variable_t *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 401
  if (name->len == 0UL) {
    {
#line 402
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"$\"");
    }
#line 404
    return ((ngx_http_variable_t *)((void *)0));
  }
#line 407
  if (flags & 32UL) {
    {
#line 408
    tmp = ngx_http_add_prefix_variable(cf, name, flags);
    }
#line 408
    return (tmp);
  }
#line 411
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 413
  key = (ngx_hash_key_t *)(cmcf->variables_keys)->keys.elts;
#line 414
  i = (ngx_uint_t )0;
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (! (i < (cmcf->variables_keys)->keys.nelts)) {
#line 414
      goto while_break;
    }
#line 415
    if (name->len != (key + i)->key.len) {
#line 418
      goto __Cont;
    } else {
      {
#line 415
      tmp___0 = ngx_strncasecmp(name->data, (key + i)->key.data, name->len);
      }
#line 415
      if (tmp___0 != 0L) {
#line 418
        goto __Cont;
      }
    }
#line 421
    v = (ngx_http_variable_t *)(key + i)->value;
#line 423
    if (! (v->flags & 1UL)) {
      {
#line 424
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the duplicate \"%V\" variable", name);
      }
#line 426
      return ((ngx_http_variable_t *)((void *)0));
    }
#line 429
    v->flags &= flags | 0xffffffffffffffefUL;
#line 431
    return (v);
    __Cont: /* CIL Label */ 
#line 414
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 434
  tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_http_variable_t ));
#line 434
  v = (ngx_http_variable_t *)tmp___1;
  }
#line 435
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 436
    return ((ngx_http_variable_t *)((void *)0));
  }
  {
#line 439
  v->name.len = name->len;
#line 440
  tmp___2 = ngx_pnalloc(cf->pool, name->len);
#line 440
  v->name.data = (u_char *)tmp___2;
  }
#line 441
  if ((unsigned long )v->name.data == (unsigned long )((void *)0)) {
#line 442
    return ((ngx_http_variable_t *)((void *)0));
  }
  {
#line 445
  ngx_strlow(v->name.data, name->data, name->len);
#line 447
  v->set_handler = (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                             uintptr_t data ))((void *)0);
#line 448
  v->get_handler = (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                  uintptr_t data ))((void *)0);
#line 449
  v->data = (uintptr_t )0;
#line 450
  v->flags = flags;
#line 451
  v->index = (ngx_uint_t )0;
#line 453
  rc = ngx_hash_add_key(cmcf->variables_keys, & v->name, (void *)v, (ngx_uint_t )0);
  }
#line 455
  if (rc == -1L) {
#line 456
    return ((ngx_http_variable_t *)((void *)0));
  }
#line 459
  if (rc == -3L) {
    {
#line 460
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "conflicting variable name \"%V\"",
                       name);
    }
#line 462
    return ((ngx_http_variable_t *)((void *)0));
  }
#line 465
  return (v);
}
}
#line 469 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_http_variable_t *ngx_http_add_prefix_variable(ngx_conf_t *cf , ngx_str_t *name ,
                                                         ngx_uint_t flags ) 
{ 
  ngx_uint_t i ;
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp10 ;

  {
#line 476
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 478
  v = (ngx_http_variable_t *)cmcf->prefix_variables.elts;
#line 479
  i = (ngx_uint_t )0;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (i < cmcf->prefix_variables.nelts)) {
#line 479
      goto while_break;
    }
#line 480
    if (name->len != (v + i)->name.len) {
#line 483
      goto __Cont;
    } else {
      {
#line 480
      tmp = ngx_strncasecmp(name->data, (v + i)->name.data, name->len);
      }
#line 480
      if (tmp != 0L) {
#line 483
        goto __Cont;
      }
    }
#line 486
    v += i;
#line 488
    if (! (v->flags & 1UL)) {
      {
#line 489
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the duplicate \"%V\" variable", name);
      }
#line 491
      return ((ngx_http_variable_t *)((void *)0));
    }
#line 494
    v->flags &= flags | 0xffffffffffffffefUL;
#line 496
    return (v);
    __Cont: /* CIL Label */ 
#line 479
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 499
  tmp___0 = ngx_array_push(& cmcf->prefix_variables);
#line 499
  v = (ngx_http_variable_t *)tmp___0;
  }
#line 500
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 501
    return ((ngx_http_variable_t *)((void *)0));
  }
  {
#line 504
  v->name.len = name->len;
#line 505
  tmp___1 = ngx_pnalloc(cf->pool, name->len);
#line 505
  v->name.data = (u_char *)tmp___1;
  }
#line 506
  if ((unsigned long )v->name.data == (unsigned long )((void *)0)) {
#line 507
    return ((ngx_http_variable_t *)((void *)0));
  }
  {
#line 510
  ngx_strlow(v->name.data, name->data, name->len);
#line 512
  v->set_handler = (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                             uintptr_t data ))((void *)0);
#line 513
  v->get_handler = (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                  uintptr_t data ))((void *)0);
#line 514
  v->data = (uintptr_t )0;
#line 515
  v->flags = flags;
#line 516
  v->index = (ngx_uint_t )0;
  }
#line 518
  return (v);
}
}
#line 522 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_get_variable_index(ngx_conf_t *cf , ngx_str_t *name ) 
{ 
  ngx_uint_t i ;
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp10 ;

  {
#line 529
  if (name->len == 0UL) {
    {
#line 530
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid variable name \"$\"");
    }
#line 532
    return ((ngx_int_t )-1);
  }
#line 535
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 537
  v = (ngx_http_variable_t *)cmcf->variables.elts;
#line 539
  if ((unsigned long )v == (unsigned long )((void *)0)) {
    {
#line 540
    tmp = ngx_array_init(& cmcf->variables, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_variable_t ));
    }
#line 540
    if (tmp != 0L) {
#line 544
      return ((ngx_int_t )-1);
    }
  } else {
#line 548
    i = (ngx_uint_t )0;
    {
#line 548
    while (1) {
      while_continue: /* CIL Label */ ;
#line 548
      if (! (i < cmcf->variables.nelts)) {
#line 548
        goto while_break;
      }
#line 549
      if (name->len != (v + i)->name.len) {
#line 552
        goto __Cont;
      } else {
        {
#line 549
        tmp___0 = ngx_strncasecmp(name->data, (v + i)->name.data, name->len);
        }
#line 549
        if (tmp___0 != 0L) {
#line 552
          goto __Cont;
        }
      }
#line 555
      return ((ngx_int_t )i);
      __Cont: /* CIL Label */ 
#line 548
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 559
  tmp___1 = ngx_array_push(& cmcf->variables);
#line 559
  v = (ngx_http_variable_t *)tmp___1;
  }
#line 560
  if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 561
    return ((ngx_int_t )-1);
  }
  {
#line 564
  v->name.len = name->len;
#line 565
  tmp___2 = ngx_pnalloc(cf->pool, name->len);
#line 565
  v->name.data = (u_char *)tmp___2;
  }
#line 566
  if ((unsigned long )v->name.data == (unsigned long )((void *)0)) {
#line 567
    return ((ngx_int_t )-1);
  }
  {
#line 570
  ngx_strlow(v->name.data, name->data, name->len);
#line 572
  v->set_handler = (void (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                             uintptr_t data ))((void *)0);
#line 573
  v->get_handler = (ngx_int_t (*)(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                  uintptr_t data ))((void *)0);
#line 574
  v->data = (uintptr_t )0;
#line 575
  v->flags = (ngx_uint_t )0;
#line 576
  v->index = cmcf->variables.nelts - 1UL;
  }
#line 578
  return ((ngx_int_t )v->index);
}
}
#line 582 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_http_variable_value_t *ngx_http_get_indexed_variable(ngx_http_request_t *r , ngx_uint_t index___0 ) 
{ 
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 588
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 590
  if (cmcf->variables.nelts <= index___0) {
#line 591
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 591
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "unknown variable index: %ui",
                         index___0);
      }
    }
#line 593
    return ((ngx_http_variable_value_t *)((void *)0));
  }
#line 596
  if ((r->variables + index___0)->not_found) {
#line 597
    return (r->variables + index___0);
  } else
#line 596
  if ((r->variables + index___0)->valid) {
#line 597
    return (r->variables + index___0);
  }
#line 600
  v = (ngx_http_variable_t *)cmcf->variables.elts;
#line 602
  if (ngx_http_variable_depth == 0UL) {
#line 603
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 603
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "cycle while evaluating variable \"%V\"",
                         & (v + index___0)->name);
      }
    }
#line 606
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 609
  ngx_http_variable_depth --;
#line 611
  tmp = (*((v + index___0)->get_handler))(r, r->variables + index___0, (v + index___0)->data);
  }
#line 611
  if (tmp == 0L) {
#line 614
    ngx_http_variable_depth ++;
#line 616
    if ((v + index___0)->flags & 2UL) {
#line 617
      (r->variables + index___0)->no_cacheable = 1U;
    }
#line 620
    return (r->variables + index___0);
  }
#line 623
  ngx_http_variable_depth ++;
#line 625
  (r->variables + index___0)->valid = 0U;
#line 626
  (r->variables + index___0)->not_found = 1U;
#line 628
  return ((ngx_http_variable_value_t *)((void *)0));
}
}
#line 632 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_http_variable_value_t *ngx_http_get_flushed_variable(ngx_http_request_t *r , ngx_uint_t index___0 ) 
{ 
  ngx_http_variable_value_t *v ;
  ngx_http_variable_value_t *tmp ;

  {
#line 637
  v = r->variables + index___0;
#line 639
  if (v->valid) {
#line 639
    goto _L;
  } else
#line 639
  if (v->not_found) {
    _L: /* CIL Label */ 
#line 640
    if (! v->no_cacheable) {
#line 641
      return (v);
    }
#line 644
    v->valid = 0U;
#line 645
    v->not_found = 0U;
  }
  {
#line 648
  tmp = ngx_http_get_indexed_variable(r, index___0);
  }
#line 648
  return (tmp);
}
}
#line 652 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_http_variable_value_t *ngx_http_get_variable(ngx_http_request_t *r , ngx_str_t *name ,
                                                 ngx_uint_t key ) 
{ 
  size_t len ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_variable_t *v ;
  ngx_http_variable_value_t *vv ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_http_variable_value_t *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  ngx_int_t tmp___5 ;
  char *__cil_tmp17 ;

  {
  {
#line 661
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 663
  tmp = ngx_hash_find(& cmcf->variables_hash, key, name->data, name->len);
#line 663
  v = (ngx_http_variable_t *)tmp;
  }
#line 665
  if (v) {
#line 666
    if (v->flags & 4UL) {
      {
#line 667
      tmp___0 = ngx_http_get_flushed_variable(r, v->index);
      }
#line 667
      return (tmp___0);
    }
#line 670
    if (ngx_http_variable_depth == 0UL) {
#line 671
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 671
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "cycle while evaluating variable \"%V\"",
                           name);
        }
      }
#line 673
      return ((ngx_http_variable_value_t *)((void *)0));
    }
    {
#line 676
    ngx_http_variable_depth --;
#line 678
    tmp___1 = ngx_palloc(r->pool, sizeof(ngx_http_variable_value_t ));
#line 678
    vv = (ngx_http_variable_value_t *)tmp___1;
    }
#line 680
    if (vv) {
      {
#line 680
      tmp___2 = (*(v->get_handler))(r, vv, v->data);
      }
#line 680
      if (tmp___2 == 0L) {
#line 681
        ngx_http_variable_depth ++;
#line 682
        return (vv);
      }
    }
#line 685
    ngx_http_variable_depth ++;
#line 686
    return ((ngx_http_variable_value_t *)((void *)0));
  }
  {
#line 689
  tmp___3 = ngx_palloc(r->pool, sizeof(ngx_http_variable_value_t ));
#line 689
  vv = (ngx_http_variable_value_t *)tmp___3;
  }
#line 690
  if ((unsigned long )vv == (unsigned long )((void *)0)) {
#line 691
    return ((ngx_http_variable_value_t *)((void *)0));
  }
#line 694
  len = (size_t )0;
#line 696
  v = (ngx_http_variable_t *)cmcf->prefix_variables.elts;
#line 697
  n = cmcf->prefix_variables.nelts;
#line 699
  i = (ngx_uint_t )0;
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! (i < cmcf->prefix_variables.nelts)) {
#line 699
      goto while_break;
    }
#line 700
    if (name->len >= (v + i)->name.len) {
#line 700
      if (name->len > len) {
        {
#line 700
        tmp___4 = strncmp((char const   *)name->data, (char const   *)(v + i)->name.data,
                          (v + i)->name.len);
        }
#line 700
        if (tmp___4 == 0) {
#line 703
          len = (v + i)->name.len;
#line 704
          n = i;
        }
      }
    }
#line 699
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 708
  if (n != cmcf->prefix_variables.nelts) {
    {
#line 709
    tmp___5 = (*((v + n)->get_handler))(r, vv, (uintptr_t )name);
    }
#line 709
    if (tmp___5 == 0L) {
#line 710
      return (vv);
    }
#line 713
    return ((ngx_http_variable_value_t *)((void *)0));
  }
#line 716
  vv->not_found = 1U;
#line 718
  return (vv);
}
}
#line 722 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  ngx_str_t *s ;

  {
#line 728
  s = (ngx_str_t *)((char *)r + data);
#line 730
  if (s->data) {
#line 731
    v->len = (unsigned int )s->len;
#line 732
    v->valid = 1U;
#line 733
    v->no_cacheable = 0U;
#line 734
    v->not_found = 0U;
#line 735
    v->data = s->data;
  } else {
#line 738
    v->not_found = 1U;
  }
#line 741
  return ((ngx_int_t )0);
}
}
#line 762 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_get_size(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ) 
{ 
  size_t *sp ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 768
  sp = (size_t *)((char *)r + data);
#line 770
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 770
  v->data = (u_char *)tmp;
  }
#line 771
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 772
    return ((ngx_int_t )-1);
  }
  {
#line 775
  tmp___0 = ngx_sprintf(v->data, "%uz", *sp);
#line 775
  v->len = (unsigned int )(tmp___0 - v->data);
#line 776
  v->valid = 1U;
#line 777
  v->no_cacheable = 0U;
#line 778
  v->not_found = 0U;
  }
#line 780
  return ((ngx_int_t )0);
}
}
#line 784 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static void ngx_http_variable_request_set_size(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ssize_t s ;
  ssize_t *sp ;
  ngx_str_t val ;
  char *__cil_tmp7 ;

  {
  {
#line 791
  val.len = (size_t )v->len;
#line 792
  val.data = v->data;
#line 794
  s = ngx_parse_size(& val);
  }
#line 796
  if (s == -1L) {
#line 797
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 797
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "invalid size \"%V\"",
                         & val);
      }
    }
#line 799
    return;
  }
#line 802
  sp = (ssize_t *)((char *)r + data);
#line 804
  *sp = s;
#line 806
  return;
}
}
#line 810 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_header(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) 
{ 
  ngx_table_elt_t *h ;

  {
#line 816
  h = *((ngx_table_elt_t **)((char *)r + data));
#line 818
  if (h) {
#line 819
    v->len = (unsigned int )h->value.len;
#line 820
    v->valid = 1U;
#line 821
    v->no_cacheable = 0U;
#line 822
    v->not_found = 0U;
#line 823
    v->data = h->value.data;
  } else {
#line 826
    v->not_found = 1U;
  }
#line 829
  return ((ngx_int_t )0);
}
}
#line 833 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_cookies(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 837
  tmp = ngx_http_variable_headers_internal(r, v, data, (u_char )';');
  }
#line 837
  return (tmp);
}
}
#line 841 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_headers(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 845
  tmp = ngx_http_variable_headers_internal(r, v, data, (u_char )',');
  }
#line 845
  return (tmp);
}
}
#line 849 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_headers_internal(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data , u_char sep ) 
{ 
  size_t len ;
  u_char *p ;
  u_char *end ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_array_t *a ;
  ngx_table_elt_t **h ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;

  {
#line 859
  a = (ngx_array_t *)((char *)r + data);
#line 861
  n = a->nelts;
#line 862
  h = (ngx_table_elt_t **)a->elts;
#line 864
  len = (size_t )0;
#line 866
  i = (ngx_uint_t )0;
  {
#line 866
  while (1) {
    while_continue: /* CIL Label */ ;
#line 866
    if (! (i < n)) {
#line 866
      goto while_break;
    }
#line 868
    if ((*(h + i))->hash == 0UL) {
#line 869
      goto __Cont;
    }
#line 872
    len += (*(h + i))->value.len + 2UL;
    __Cont: /* CIL Label */ 
#line 866
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 875
  if (len == 0UL) {
#line 876
    v->not_found = 1U;
#line 877
    return ((ngx_int_t )0);
  }
#line 880
  len -= 2UL;
#line 882
  v->valid = 1U;
#line 883
  v->no_cacheable = 0U;
#line 884
  v->not_found = 0U;
#line 886
  if (n == 1UL) {
#line 887
    v->len = (unsigned int )(*h)->value.len;
#line 888
    v->data = (*h)->value.data;
#line 890
    return ((ngx_int_t )0);
  }
  {
#line 893
  tmp = ngx_pnalloc(r->pool, len);
#line 893
  p = (u_char *)tmp;
  }
#line 894
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 895
    return ((ngx_int_t )-1);
  }
#line 898
  v->len = (unsigned int )len;
#line 899
  v->data = p;
#line 901
  end = p + len;
#line 903
  i = (ngx_uint_t )0;
  {
#line 903
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 905
    if ((*(h + i))->hash == 0UL) {
#line 906
      goto __Cont___0;
    }
    {
#line 909
    tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(*(h + i))->value.data,
                     (*(h + i))->value.len);
#line 909
    p = (u_char *)tmp___0 + (*(h + i))->value.len;
    }
#line 911
    if ((unsigned long )p == (unsigned long )end) {
#line 912
      goto while_break___0;
    }
#line 915
    tmp___1 = p;
#line 915
    p ++;
#line 915
    *tmp___1 = sep;
#line 915
    tmp___2 = p;
#line 915
    p ++;
#line 915
    *tmp___2 = (u_char )' ';
    __Cont___0: /* CIL Label */ 
#line 903
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 918
  return ((ngx_int_t )0);
}
}
#line 922 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_unknown_header_in(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) 
{ 
  ngx_int_t tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 926
  tmp = ngx_http_variable_unknown_header(v, (ngx_str_t *)data, & r->headers_in.headers.part,
                                         sizeof("http_") - 1UL);
  }
#line 926
  return (tmp);
}
}
#line 932 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_unknown_header_out(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) 
{ 
  ngx_int_t tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 936
  tmp = ngx_http_variable_unknown_header(v, (ngx_str_t *)data, & r->headers_out.headers.part,
                                         sizeof("sent_http_") - 1UL);
  }
#line 936
  return (tmp);
}
}
#line 942 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_unknown_trailer_out(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  ngx_int_t tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 946
  tmp = ngx_http_variable_unknown_header(v, (ngx_str_t *)data, & r->headers_out.trailers.part,
                                         sizeof("sent_trailer_") - 1UL);
  }
#line 946
  return (tmp);
}
}
#line 952 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_variable_unknown_header(ngx_http_variable_value_t *v , ngx_str_t *var ,
                                           ngx_list_part_t *part , size_t prefix ) 
{ 
  u_char ch ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_table_elt_t *header___0 ;

  {
#line 960
  header___0 = (ngx_table_elt_t *)part->elts;
#line 962
  i = (ngx_uint_t )0;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 964
    if (i >= part->nelts) {
#line 965
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 966
        goto while_break;
      }
#line 969
      part = part->next;
#line 970
      header___0 = (ngx_table_elt_t *)part->elts;
#line 971
      i = (ngx_uint_t )0;
    }
#line 974
    if ((header___0 + i)->hash == 0UL) {
#line 975
      goto __Cont;
    }
#line 978
    n = (ngx_uint_t )0;
    {
#line 978
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 978
      if (n + prefix < var->len) {
#line 978
        if (! (n < (header___0 + i)->key.len)) {
#line 978
          goto while_break___0;
        }
      } else {
#line 978
        goto while_break___0;
      }
#line 979
      ch = *((header___0 + i)->key.data + n);
#line 981
      if ((int )ch >= 65) {
#line 981
        if ((int )ch <= 90) {
#line 982
          ch = (u_char )((int )ch | 32);
        } else {
#line 981
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 984
      if ((int )ch == 45) {
#line 985
        ch = (u_char )'_';
      }
#line 988
      if ((int )*(var->data + (n + prefix)) != (int )ch) {
#line 989
        goto while_break___0;
      }
#line 978
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 993
    if (n + prefix == var->len) {
#line 993
      if (n == (header___0 + i)->key.len) {
#line 994
        v->len = (unsigned int )(header___0 + i)->value.len;
#line 995
        v->valid = 1U;
#line 996
        v->no_cacheable = 0U;
#line 997
        v->not_found = 0U;
#line 998
        v->data = (header___0 + i)->value.data;
#line 1000
        return ((ngx_int_t )0);
      }
    }
    __Cont: /* CIL Label */ 
#line 962
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1004
  v->not_found = 1U;
#line 1006
  return ((ngx_int_t )0);
}
}
#line 1010 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_line(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  u_char *p ;
  u_char *s ;

  {
#line 1016
  s = r->request_line.data;
#line 1018
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1019
    s = r->request_start;
#line 1021
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1022
      v->not_found = 1U;
#line 1023
      return ((ngx_int_t )0);
    }
#line 1026
    p = s;
    {
#line 1026
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1026
      if (! ((unsigned long )p < (unsigned long )(r->header_in)->last)) {
#line 1026
        goto while_break;
      }
#line 1027
      if ((int )*p == 13) {
#line 1028
        goto while_break;
      } else
#line 1027
      if ((int )*p == 10) {
#line 1028
        goto while_break;
      }
#line 1026
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1032
    r->request_line.len = (size_t )(p - s);
#line 1033
    r->request_line.data = s;
  }
#line 1036
  v->len = (unsigned int )r->request_line.len;
#line 1037
  v->valid = 1U;
#line 1038
  v->no_cacheable = 0U;
#line 1039
  v->not_found = 0U;
#line 1040
  v->data = s;
#line 1042
  return ((ngx_int_t )0);
}
}
#line 1046 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_cookie(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) 
{ 
  ngx_str_t *name ;
  ngx_str_t cookie ;
  ngx_str_t s ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1050
  name = (ngx_str_t *)data;
#line 1054
  s.len = name->len - (sizeof("cookie_") - 1UL);
#line 1055
  s.data = (name->data + sizeof("cookie_")) - 1;
#line 1057
  tmp = ngx_http_parse_multi_header_lines(& r->headers_in.cookies, & s, & cookie);
  }
#line 1057
  if (tmp == -5L) {
#line 1060
    v->not_found = 1U;
#line 1061
    return ((ngx_int_t )0);
  }
#line 1064
  v->len = (unsigned int )cookie.len;
#line 1065
  v->valid = 1U;
#line 1066
  v->no_cacheable = 0U;
#line 1067
  v->not_found = 0U;
#line 1068
  v->data = cookie.data;
#line 1070
  return ((ngx_int_t )0);
}
}
#line 1074 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_argument(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) 
{ 
  ngx_str_t *name ;
  u_char *arg ;
  size_t len ;
  ngx_str_t value ;
  ngx_int_t tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1078
  name = (ngx_str_t *)data;
#line 1084
  len = name->len - (sizeof("arg_") - 1UL);
#line 1085
  arg = (name->data + sizeof("arg_")) - 1;
#line 1087
  tmp = ngx_http_arg(r, arg, len, & value);
  }
#line 1087
  if (tmp != 0L) {
#line 1088
    v->not_found = 1U;
#line 1089
    return ((ngx_int_t )0);
  }
#line 1092
  v->data = value.data;
#line 1093
  v->len = (unsigned int )value.len;
#line 1094
  v->valid = 1U;
#line 1095
  v->no_cacheable = 0U;
#line 1096
  v->not_found = 0U;
#line 1098
  return ((ngx_int_t )0);
}
}
#line 1104 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_tcpinfo(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  struct tcp_info ti ;
  socklen_t len ;
  uint32_t value ;
  int tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 1112
  len = (socklen_t )sizeof(struct tcp_info );
#line 1113
  tmp = getsockopt((r->connection)->fd, 6, 11, (void */* __restrict  */)(& ti), (socklen_t */* __restrict  */)(& len));
  }
#line 1113
  if (tmp == -1) {
#line 1114
    v->not_found = 1U;
#line 1115
    return ((ngx_int_t )0);
  }
  {
#line 1118
  tmp___0 = ngx_pnalloc(r->pool, sizeof("-2147483648") - 1UL);
#line 1118
  v->data = (u_char *)tmp___0;
  }
#line 1119
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1120
    return ((ngx_int_t )-1);
  }
  {
#line 1124
  if (data == 0UL) {
#line 1124
    goto case_0;
  }
#line 1128
  if (data == 1UL) {
#line 1128
    goto case_1;
  }
#line 1132
  if (data == 2UL) {
#line 1132
    goto case_2;
  }
#line 1136
  if (data == 3UL) {
#line 1136
    goto case_3;
  }
#line 1141
  goto switch_default;
  case_0: /* CIL Label */ 
#line 1125
  value = ti.tcpi_rtt;
#line 1126
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1129
  value = ti.tcpi_rttvar;
#line 1130
  goto switch_break;
  case_2: /* CIL Label */ 
#line 1133
  value = ti.tcpi_snd_cwnd;
#line 1134
  goto switch_break;
  case_3: /* CIL Label */ 
#line 1137
  value = ti.tcpi_rcv_space;
#line 1138
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1142
  value = (uint32_t )0;
#line 1143
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1146
  tmp___1 = ngx_sprintf(v->data, "%uD", value);
#line 1146
  v->len = (unsigned int )(tmp___1 - v->data);
#line 1147
  v->valid = 1U;
#line 1148
  v->no_cacheable = 0U;
#line 1149
  v->not_found = 0U;
  }
#line 1151
  return ((ngx_int_t )0);
}
}
#line 1157 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_content_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1163
  if (r->headers_in.content_length) {
#line 1164
    v->len = (unsigned int )(r->headers_in.content_length)->value.len;
#line 1165
    v->data = (r->headers_in.content_length)->value.data;
#line 1166
    v->valid = 1U;
#line 1167
    v->no_cacheable = 0U;
#line 1168
    v->not_found = 0U;
  } else
#line 1170
  if (r->reading_body) {
#line 1171
    v->not_found = 1U;
#line 1172
    v->no_cacheable = 1U;
  } else
#line 1174
  if (r->headers_in.content_length_n >= 0L) {
    {
#line 1175
    tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1175
    p = (u_char *)tmp;
    }
#line 1176
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1177
      return ((ngx_int_t )-1);
    }
    {
#line 1180
    tmp___0 = ngx_sprintf(p, "%O", r->headers_in.content_length_n);
#line 1180
    v->len = (unsigned int )(tmp___0 - p);
#line 1181
    v->data = p;
#line 1182
    v->valid = 1U;
#line 1183
    v->no_cacheable = 0U;
#line 1184
    v->not_found = 0U;
    }
  } else {
#line 1187
    v->not_found = 1U;
  }
#line 1190
  return ((ngx_int_t )0);
}
}
#line 1194 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_host(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;

  {
#line 1200
  if (r->headers_in.server.len) {
#line 1201
    v->len = (unsigned int )r->headers_in.server.len;
#line 1202
    v->data = r->headers_in.server.data;
  } else {
#line 1205
    cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1207
    v->len = (unsigned int )cscf->server_name.len;
#line 1208
    v->data = cscf->server_name.data;
  }
#line 1211
  v->valid = 1U;
#line 1212
  v->no_cacheable = 0U;
#line 1213
  v->not_found = 0U;
#line 1215
  return ((ngx_int_t )0);
}
}
#line 1219 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_binary_remote_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;

  {
  {
#line 1231
  if ((int )((r->connection)->sockaddr)->sa_family == 10) {
#line 1231
    goto case_10;
  }
#line 1244
  if ((int )((r->connection)->sockaddr)->sa_family == 1) {
#line 1244
    goto case_1;
  }
#line 1255
  goto switch_default;
  case_10: /* CIL Label */ 
#line 1232
  sin6 = (struct sockaddr_in6 *)(r->connection)->sockaddr;
#line 1234
  v->len = (unsigned int )sizeof(struct in6_addr );
#line 1235
  v->valid = 1U;
#line 1236
  v->no_cacheable = 0U;
#line 1237
  v->not_found = 0U;
#line 1238
  v->data = sin6->sin6_addr.__in6_u.__u6_addr8;
#line 1240
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1246
  v->len = (unsigned int )(r->connection)->addr_text.len;
#line 1247
  v->valid = 1U;
#line 1248
  v->no_cacheable = 0U;
#line 1249
  v->not_found = 0U;
#line 1250
  v->data = (r->connection)->addr_text.data;
#line 1252
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1256
  sin = (struct sockaddr_in *)(r->connection)->sockaddr;
#line 1258
  v->len = (unsigned int )sizeof(in_addr_t );
#line 1259
  v->valid = 1U;
#line 1260
  v->no_cacheable = 0U;
#line 1261
  v->not_found = 0U;
#line 1262
  v->data = (u_char *)(& sin->sin_addr);
#line 1264
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1267
  return ((ngx_int_t )0);
}
}
#line 1271 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_remote_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 


  {
#line 1275
  v->len = (unsigned int )(r->connection)->addr_text.len;
#line 1276
  v->valid = 1U;
#line 1277
  v->no_cacheable = 0U;
#line 1278
  v->not_found = 0U;
#line 1279
  v->data = (r->connection)->addr_text.data;
#line 1281
  return ((ngx_int_t )0);
}
}
#line 1285 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_remote_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_uint_t port ;
  void *tmp ;
  in_port_t tmp___0 ;
  u_char *tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1291
  v->len = 0U;
#line 1292
  v->valid = 1U;
#line 1293
  v->no_cacheable = 0U;
#line 1294
  v->not_found = 0U;
#line 1296
  tmp = ngx_pnalloc(r->pool, sizeof("65535") - 1UL);
#line 1296
  v->data = (u_char *)tmp;
  }
#line 1297
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1298
    return ((ngx_int_t )-1);
  }
  {
#line 1301
  tmp___0 = ngx_inet_get_port((r->connection)->sockaddr);
#line 1301
  port = (ngx_uint_t )tmp___0;
  }
#line 1303
  if (port > 0UL) {
#line 1303
    if (port < 65536UL) {
      {
#line 1304
      tmp___1 = ngx_sprintf(v->data, "%ui", port);
#line 1304
      v->len = (unsigned int )(tmp___1 - v->data);
      }
    }
  }
#line 1307
  return ((ngx_int_t )0);
}
}
#line 1311 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_proxy_protocol_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 


  {
#line 1315
  v->len = (unsigned int )(r->connection)->proxy_protocol_addr.len;
#line 1316
  v->valid = 1U;
#line 1317
  v->no_cacheable = 0U;
#line 1318
  v->not_found = 0U;
#line 1319
  v->data = (r->connection)->proxy_protocol_addr.data;
#line 1321
  return ((ngx_int_t )0);
}
}
#line 1325 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_proxy_protocol_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  ngx_uint_t port ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1331
  v->len = 0U;
#line 1332
  v->valid = 1U;
#line 1333
  v->no_cacheable = 0U;
#line 1334
  v->not_found = 0U;
#line 1336
  tmp = ngx_pnalloc(r->pool, sizeof("65535") - 1UL);
#line 1336
  v->data = (u_char *)tmp;
  }
#line 1337
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1338
    return ((ngx_int_t )-1);
  }
#line 1341
  port = (ngx_uint_t )(r->connection)->proxy_protocol_port;
#line 1343
  if (port > 0UL) {
#line 1343
    if (port < 65536UL) {
      {
#line 1344
      tmp___0 = ngx_sprintf(v->data, "%ui", port);
#line 1344
      v->len = (unsigned int )(tmp___0 - v->data);
      }
    }
  }
#line 1347
  return ((ngx_int_t )0);
}
}
#line 1351 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_server_addr(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_str_t s ;
  u_char addr[((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)] ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 1358
  s.len = ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 1359
  s.data = addr;
#line 1361
  tmp = ngx_connection_local_sockaddr(r->connection, & s, (ngx_uint_t )0);
  }
#line 1361
  if (tmp != 0L) {
#line 1362
    return ((ngx_int_t )-1);
  }
  {
#line 1365
  tmp___0 = ngx_pnalloc(r->pool, s.len);
#line 1365
  s.data = (u_char *)tmp___0;
  }
#line 1366
  if ((unsigned long )s.data == (unsigned long )((void *)0)) {
#line 1367
    return ((ngx_int_t )-1);
  }
  {
#line 1370
  memcpy((void */* __restrict  */)s.data, (void const   */* __restrict  */)(addr),
         s.len);
#line 1372
  v->len = (unsigned int )s.len;
#line 1373
  v->valid = 1U;
#line 1374
  v->no_cacheable = 0U;
#line 1375
  v->not_found = 0U;
#line 1376
  v->data = s.data;
  }
#line 1378
  return ((ngx_int_t )0);
}
}
#line 1382 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_server_port(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_uint_t port ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  in_port_t tmp___1 ;
  u_char *tmp___2 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 1388
  v->len = 0U;
#line 1389
  v->valid = 1U;
#line 1390
  v->no_cacheable = 0U;
#line 1391
  v->not_found = 0U;
#line 1393
  tmp = ngx_connection_local_sockaddr(r->connection, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
  }
#line 1393
  if (tmp != 0L) {
#line 1394
    return ((ngx_int_t )-1);
  }
  {
#line 1397
  tmp___0 = ngx_pnalloc(r->pool, sizeof("65535") - 1UL);
#line 1397
  v->data = (u_char *)tmp___0;
  }
#line 1398
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1399
    return ((ngx_int_t )-1);
  }
  {
#line 1402
  tmp___1 = ngx_inet_get_port((r->connection)->local_sockaddr);
#line 1402
  port = (ngx_uint_t )tmp___1;
  }
#line 1404
  if (port > 0UL) {
#line 1404
    if (port < 65536UL) {
      {
#line 1405
      tmp___2 = ngx_sprintf(v->data, "%ui", port);
#line 1405
      v->len = (unsigned int )(tmp___2 - v->data);
      }
    }
  }
#line 1408
  return ((ngx_int_t )0);
}
}
#line 1412 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_scheme(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1430
  v->len = (unsigned int )(sizeof("http") - 1UL);
#line 1431
  v->valid = 1U;
#line 1432
  v->no_cacheable = 0U;
#line 1433
  v->not_found = 0U;
#line 1434
  v->data = (u_char *)"http";
#line 1436
  return ((ngx_int_t )0);
}
}
#line 1440 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_https(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                         uintptr_t data ) 
{ 


  {
#line 1458
  *v = ngx_http_variable_null_value;
#line 1460
  return ((ngx_int_t )0);
}
}
#line 1464 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static void ngx_http_variable_set_args(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) 
{ 


  {
#line 1468
  r->args.len = (size_t )v->len;
#line 1469
  r->args.data = v->data;
#line 1470
  r->valid_unparsed_uri = 0U;
#line 1471
  return;
}
}
#line 1474 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_is_args(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                           uintptr_t data ) 
{ 
  char *__cil_tmp4 ;

  {
#line 1478
  if (r->args.len == 0UL) {
#line 1479
    *v = ngx_http_variable_null_value;
#line 1480
    return ((ngx_int_t )0);
  }
#line 1483
  v->len = 1U;
#line 1484
  v->valid = 1U;
#line 1485
  v->no_cacheable = 0U;
#line 1486
  v->not_found = 0U;
#line 1487
  v->data = (u_char *)"?";
#line 1489
  return ((ngx_int_t )0);
}
}
#line 1493 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_document_root(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  ngx_str_t path ;
  ngx_http_core_loc_conf_t *clcf ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1500
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1502
  if ((unsigned long )clcf->root_lengths == (unsigned long )((void *)0)) {
#line 1503
    v->len = (unsigned int )clcf->root.len;
#line 1504
    v->valid = 1U;
#line 1505
    v->no_cacheable = 0U;
#line 1506
    v->not_found = 0U;
#line 1507
    v->data = clcf->root.data;
  } else {
    {
#line 1510
    tmp = ngx_http_script_run(r, & path, (clcf->root_lengths)->elts, (size_t )0, (clcf->root_values)->elts);
    }
#line 1510
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1514
      return ((ngx_int_t )-1);
    }
    {
#line 1517
    tmp___0 = ngx_get_full_name(r->pool, (ngx_str_t *)(& ngx_cycle->prefix), & path);
    }
#line 1517
    if (tmp___0 != 0L) {
#line 1520
      return ((ngx_int_t )-1);
    }
#line 1523
    v->len = (unsigned int )path.len;
#line 1524
    v->valid = 1U;
#line 1525
    v->no_cacheable = 0U;
#line 1526
    v->not_found = 0U;
#line 1527
    v->data = path.data;
  }
#line 1530
  return ((ngx_int_t )0);
}
}
#line 1534 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_realpath_root(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  u_char *real ;
  size_t len ;
  ngx_str_t path ;
  ngx_http_core_loc_conf_t *clcf ;
  u_char buffer___0[4096] ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 1546
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1548
  if ((unsigned long )clcf->root_lengths == (unsigned long )((void *)0)) {
#line 1549
    path = clcf->root;
  } else {
    {
#line 1552
    tmp = ngx_http_script_run(r, & path, (clcf->root_lengths)->elts, (size_t )1, (clcf->root_values)->elts);
    }
#line 1552
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1556
      return ((ngx_int_t )-1);
    }
    {
#line 1559
    *(path.data + (path.len - 1UL)) = (u_char )'\000';
#line 1561
    tmp___0 = ngx_get_full_name(r->pool, (ngx_str_t *)(& ngx_cycle->prefix), & path);
    }
#line 1561
    if (tmp___0 != 0L) {
#line 1564
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1569
  real = buffer___0;
#line 1574
  tmp___1 = realpath((char const   */* __restrict  */)((char *)path.data), (char */* __restrict  */)((char *)real));
#line 1574
  real = (u_char *)tmp___1;
  }
#line 1576
  if ((unsigned long )real == (unsigned long )((void *)0)) {
#line 1577
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 1577
      tmp___2 = __errno_location();
#line 1577
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___2, "realpath() \"%s\" failed",
                         path.data);
      }
    }
#line 1579
    return ((ngx_int_t )-1);
  }
  {
#line 1582
  len = strlen((char const   *)real);
#line 1584
  tmp___3 = ngx_pnalloc(r->pool, len);
#line 1584
  v->data = (u_char *)tmp___3;
  }
#line 1585
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1589
    return ((ngx_int_t )-1);
  }
  {
#line 1592
  v->len = (unsigned int )len;
#line 1593
  v->valid = 1U;
#line 1594
  v->no_cacheable = 0U;
#line 1595
  v->not_found = 0U;
#line 1597
  memcpy((void */* __restrict  */)v->data, (void const   */* __restrict  */)real,
         len);
  }
#line 1603
  return ((ngx_int_t )0);
}
}
#line 1607 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_filename(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                    uintptr_t data ) 
{ 
  size_t root ;
  ngx_str_t path ;
  u_char *tmp ;

  {
  {
#line 1614
  tmp = ngx_http_map_uri_to_path(r, & path, & root, (size_t )0);
  }
#line 1614
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1615
    return ((ngx_int_t )-1);
  }
#line 1620
  v->len = (unsigned int )(path.len - 1UL);
#line 1621
  v->valid = 1U;
#line 1622
  v->no_cacheable = 0U;
#line 1623
  v->not_found = 0U;
#line 1624
  v->data = path.data;
#line 1626
  return ((ngx_int_t )0);
}
}
#line 1630 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_server_name(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;

  {
#line 1636
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1638
  v->len = (unsigned int )cscf->server_name.len;
#line 1639
  v->valid = 1U;
#line 1640
  v->no_cacheable = 0U;
#line 1641
  v->not_found = 0U;
#line 1642
  v->data = cscf->server_name.data;
#line 1644
  return ((ngx_int_t )0);
}
}
#line 1648 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_method(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) 
{ 


  {
#line 1652
  if ((r->main)->method_name.data) {
#line 1653
    v->len = (unsigned int )(r->main)->method_name.len;
#line 1654
    v->valid = 1U;
#line 1655
    v->no_cacheable = 0U;
#line 1656
    v->not_found = 0U;
#line 1657
    v->data = (r->main)->method_name.data;
  } else {
#line 1660
    v->not_found = 1U;
  }
#line 1663
  return ((ngx_int_t )0);
}
}
#line 1667 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_remote_user(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                               uintptr_t data ) 
{ 
  ngx_int_t rc ;

  {
  {
#line 1673
  rc = ngx_http_auth_basic_user(r);
  }
#line 1675
  if (rc == -5L) {
#line 1676
    v->not_found = 1U;
#line 1677
    return ((ngx_int_t )0);
  }
#line 1680
  if (rc == -1L) {
#line 1681
    return ((ngx_int_t )-1);
  }
#line 1684
  v->len = (unsigned int )r->headers_in.user.len;
#line 1685
  v->valid = 1U;
#line 1686
  v->no_cacheable = 0U;
#line 1687
  v->not_found = 0U;
#line 1688
  v->data = r->headers_in.user.data;
#line 1690
  return ((ngx_int_t )0);
}
}
#line 1694 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_bytes_sent(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1700
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1700
  p = (u_char *)tmp;
  }
#line 1701
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1702
    return ((ngx_int_t )-1);
  }
  {
#line 1705
  tmp___0 = ngx_sprintf(p, "%O", (r->connection)->sent);
#line 1705
  v->len = (unsigned int )(tmp___0 - p);
#line 1706
  v->valid = 1U;
#line 1707
  v->no_cacheable = 0U;
#line 1708
  v->not_found = 0U;
#line 1709
  v->data = p;
  }
#line 1711
  return ((ngx_int_t )0);
}
}
#line 1715 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_body_bytes_sent(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  off_t sent ;
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1722
  sent = (off_t )((size_t )(r->connection)->sent - r->header_size);
#line 1724
  if (sent < 0L) {
#line 1725
    sent = (off_t )0;
  }
  {
#line 1728
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1728
  p = (u_char *)tmp;
  }
#line 1729
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1730
    return ((ngx_int_t )-1);
  }
  {
#line 1733
  tmp___0 = ngx_sprintf(p, "%O", sent);
#line 1733
  v->len = (unsigned int )(tmp___0 - p);
#line 1734
  v->valid = 1U;
#line 1735
  v->no_cacheable = 0U;
#line 1736
  v->not_found = 0U;
#line 1737
  v->data = p;
  }
#line 1739
  return ((ngx_int_t )0);
}
}
#line 1743 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_pipe(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) 
{ 
  char const   *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1747
  if (r->pipeline) {
#line 1747
    tmp = "p";
  } else {
#line 1747
    tmp = ".";
  }
#line 1747
  v->data = (u_char *)tmp;
#line 1748
  v->len = 1U;
#line 1749
  v->valid = 1U;
#line 1750
  v->no_cacheable = 0U;
#line 1751
  v->not_found = 0U;
#line 1753
  return ((ngx_int_t )0);
}
}
#line 1757 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_status(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                          uintptr_t data ) 
{ 
  ngx_uint_t status ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1763
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1763
  v->data = (u_char *)tmp;
  }
#line 1764
  if ((unsigned long )v->data == (unsigned long )((void *)0)) {
#line 1765
    return ((ngx_int_t )-1);
  }
#line 1768
  if (r->err_status) {
#line 1769
    status = r->err_status;
  } else
#line 1771
  if (r->headers_out.status) {
#line 1772
    status = r->headers_out.status;
  } else
#line 1774
  if (r->http_version == 9UL) {
#line 1775
    status = (ngx_uint_t )9;
  } else {
#line 1778
    status = (ngx_uint_t )0;
  }
  {
#line 1781
  tmp___0 = ngx_sprintf(v->data, "%03ui", status);
#line 1781
  v->len = (unsigned int )(tmp___0 - v->data);
#line 1782
  v->valid = 1U;
#line 1783
  v->no_cacheable = 0U;
#line 1784
  v->not_found = 0U;
  }
#line 1786
  return ((ngx_int_t )0);
}
}
#line 1790 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_content_type(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) 
{ 


  {
#line 1794
  if (r->headers_out.content_type.len) {
#line 1795
    v->len = (unsigned int )r->headers_out.content_type.len;
#line 1796
    v->valid = 1U;
#line 1797
    v->no_cacheable = 0U;
#line 1798
    v->not_found = 0U;
#line 1799
    v->data = r->headers_out.content_type.data;
  } else {
#line 1802
    v->not_found = 1U;
  }
#line 1805
  return ((ngx_int_t )0);
}
}
#line 1809 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_content_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1815
  if (r->headers_out.content_length) {
#line 1816
    v->len = (unsigned int )(r->headers_out.content_length)->value.len;
#line 1817
    v->valid = 1U;
#line 1818
    v->no_cacheable = 0U;
#line 1819
    v->not_found = 0U;
#line 1820
    v->data = (r->headers_out.content_length)->value.data;
#line 1822
    return ((ngx_int_t )0);
  }
#line 1825
  if (r->headers_out.content_length_n >= 0L) {
    {
#line 1826
    tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 1826
    p = (u_char *)tmp;
    }
#line 1827
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1828
      return ((ngx_int_t )-1);
    }
    {
#line 1831
    tmp___0 = ngx_sprintf(p, "%O", r->headers_out.content_length_n);
#line 1831
    v->len = (unsigned int )(tmp___0 - p);
#line 1832
    v->valid = 1U;
#line 1833
    v->no_cacheable = 0U;
#line 1834
    v->not_found = 0U;
#line 1835
    v->data = p;
    }
#line 1837
    return ((ngx_int_t )0);
  }
#line 1840
  v->not_found = 1U;
#line 1842
  return ((ngx_int_t )0);
}
}
#line 1846 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_location(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  ngx_str_t name ;
  ngx_int_t tmp ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1852
  if (r->headers_out.location) {
#line 1853
    v->len = (unsigned int )(r->headers_out.location)->value.len;
#line 1854
    v->valid = 1U;
#line 1855
    v->no_cacheable = 0U;
#line 1856
    v->not_found = 0U;
#line 1857
    v->data = (r->headers_out.location)->value.data;
#line 1859
    return ((ngx_int_t )0);
  }
  {
#line 1862
  name.len = sizeof("sent_http_location") - 1UL;
#line 1862
  name.data = (u_char *)"sent_http_location";
#line 1864
  tmp = ngx_http_variable_unknown_header(v, & name, & r->headers_out.headers.part,
                                         sizeof("sent_http_") - 1UL);
  }
#line 1864
  return (tmp);
}
}
#line 1870 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_last_modified(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 1876
  if (r->headers_out.last_modified) {
#line 1877
    v->len = (unsigned int )(r->headers_out.last_modified)->value.len;
#line 1878
    v->valid = 1U;
#line 1879
    v->no_cacheable = 0U;
#line 1880
    v->not_found = 0U;
#line 1881
    v->data = (r->headers_out.last_modified)->value.data;
#line 1883
    return ((ngx_int_t )0);
  }
#line 1886
  if (r->headers_out.last_modified_time >= 0L) {
    {
#line 1887
    tmp = ngx_pnalloc(r->pool, sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1UL);
#line 1887
    p = (u_char *)tmp;
    }
#line 1888
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1889
      return ((ngx_int_t )-1);
    }
    {
#line 1892
    tmp___0 = ngx_http_time(p, r->headers_out.last_modified_time);
#line 1892
    v->len = (unsigned int )(tmp___0 - p);
#line 1893
    v->valid = 1U;
#line 1894
    v->no_cacheable = 0U;
#line 1895
    v->not_found = 0U;
#line 1896
    v->data = p;
    }
#line 1898
    return ((ngx_int_t )0);
  }
#line 1901
  v->not_found = 1U;
#line 1903
  return ((ngx_int_t )0);
}
}
#line 1907 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_connection(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  size_t len ;
  char *p ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1914
  if (r->headers_out.status == 101UL) {
#line 1915
    len = sizeof("upgrade") - 1UL;
#line 1916
    p = (char *)"upgrade";
  } else
#line 1918
  if (r->keepalive) {
#line 1919
    len = sizeof("keep-alive") - 1UL;
#line 1920
    p = (char *)"keep-alive";
  } else {
#line 1923
    len = sizeof("close") - 1UL;
#line 1924
    p = (char *)"close";
  }
#line 1927
  v->len = (unsigned int )len;
#line 1928
  v->valid = 1U;
#line 1929
  v->no_cacheable = 0U;
#line 1930
  v->not_found = 0U;
#line 1931
  v->data = (u_char *)p;
#line 1933
  return ((ngx_int_t )0);
}
}
#line 1937 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_keep_alive(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                   uintptr_t data ) 
{ 
  u_char *p ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1944
  if (r->keepalive) {
#line 1945
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1947
    if (clcf->keepalive_header) {
      {
#line 1949
      tmp = ngx_pnalloc(r->pool, (sizeof("timeout=") - 1UL) + (sizeof("-9223372036854775808") - 1UL));
#line 1949
      p = (u_char *)tmp;
      }
#line 1950
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1951
        return ((ngx_int_t )-1);
      }
      {
#line 1954
      tmp___0 = ngx_sprintf(p, "timeout=%T", clcf->keepalive_header);
#line 1954
      v->len = (unsigned int )(tmp___0 - p);
#line 1955
      v->valid = 1U;
#line 1956
      v->no_cacheable = 0U;
#line 1957
      v->not_found = 0U;
#line 1958
      v->data = p;
      }
#line 1960
      return ((ngx_int_t )0);
    }
  }
#line 1964
  v->not_found = 1U;
#line 1966
  return ((ngx_int_t )0);
}
}
#line 1970 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_sent_transfer_encoding(ngx_http_request_t *r ,
                                                          ngx_http_variable_value_t *v ,
                                                          uintptr_t data ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 1974
  if (r->chunked) {
#line 1975
    v->len = (unsigned int )(sizeof("chunked") - 1UL);
#line 1976
    v->valid = 1U;
#line 1977
    v->no_cacheable = 0U;
#line 1978
    v->not_found = 0U;
#line 1979
    v->data = (u_char *)"chunked";
  } else {
#line 1982
    v->not_found = 1U;
  }
#line 1985
  return ((ngx_int_t )0);
}
}
#line 1989 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_completion(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                      uintptr_t data ) 
{ 
  char *__cil_tmp4 ;

  {
#line 1993
  if (r->request_complete) {
#line 1994
    v->len = 2U;
#line 1995
    v->valid = 1U;
#line 1996
    v->no_cacheable = 0U;
#line 1997
    v->not_found = 0U;
#line 1998
    v->data = (u_char *)"OK";
#line 2000
    return ((ngx_int_t )0);
  }
#line 2003
  *v = ngx_http_variable_null_value;
#line 2005
  return ((ngx_int_t )0);
}
}
#line 2009 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_body(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_buf_t *buf ;
  ngx_chain_t *cl ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2018
  if ((unsigned long )r->request_body == (unsigned long )((void *)0)) {
#line 2022
    v->not_found = 1U;
#line 2024
    return ((ngx_int_t )0);
  } else
#line 2018
  if ((unsigned long )(r->request_body)->bufs == (unsigned long )((void *)0)) {
#line 2022
    v->not_found = 1U;
#line 2024
    return ((ngx_int_t )0);
  } else
#line 2018
  if ((r->request_body)->temp_file) {
#line 2022
    v->not_found = 1U;
#line 2024
    return ((ngx_int_t )0);
  }
#line 2027
  cl = (r->request_body)->bufs;
#line 2028
  buf = cl->buf;
#line 2030
  if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
#line 2031
    v->len = (unsigned int )(buf->last - buf->pos);
#line 2032
    v->valid = 1U;
#line 2033
    v->no_cacheable = 0U;
#line 2034
    v->not_found = 0U;
#line 2035
    v->data = buf->pos;
#line 2037
    return ((ngx_int_t )0);
  }
#line 2040
  len = (size_t )(buf->last - buf->pos);
#line 2041
  cl = cl->next;
  {
#line 2043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2043
    if (! cl) {
#line 2043
      goto while_break;
    }
#line 2044
    buf = cl->buf;
#line 2045
    len += (size_t )(buf->last - buf->pos);
#line 2043
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2048
  tmp = ngx_pnalloc(r->pool, len);
#line 2048
  p = (u_char *)tmp;
  }
#line 2049
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2050
    return ((ngx_int_t )-1);
  }
#line 2053
  v->data = p;
#line 2054
  cl = (r->request_body)->bufs;
  {
#line 2056
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2056
    if (! cl) {
#line 2056
      goto while_break___0;
    }
    {
#line 2057
    buf = cl->buf;
#line 2058
    tmp___0 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)buf->pos,
                     (size_t )(buf->last - buf->pos));
#line 2058
    p = (u_char *)tmp___0 + (buf->last - buf->pos);
#line 2056
    cl = cl->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2061
  v->len = (unsigned int )len;
#line 2062
  v->valid = 1U;
#line 2063
  v->no_cacheable = 0U;
#line 2064
  v->not_found = 0U;
#line 2066
  return ((ngx_int_t )0);
}
}
#line 2070 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_body_file(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                     uintptr_t data ) 
{ 


  {
#line 2074
  if ((unsigned long )r->request_body == (unsigned long )((void *)0)) {
#line 2075
    v->not_found = 1U;
#line 2077
    return ((ngx_int_t )0);
  } else
#line 2074
  if ((unsigned long )(r->request_body)->temp_file == (unsigned long )((void *)0)) {
#line 2075
    v->not_found = 1U;
#line 2077
    return ((ngx_int_t )0);
  }
#line 2080
  v->len = (unsigned int )((r->request_body)->temp_file)->file.name.len;
#line 2081
  v->valid = 1U;
#line 2082
  v->no_cacheable = 0U;
#line 2083
  v->not_found = 0U;
#line 2084
  v->data = ((r->request_body)->temp_file)->file.name.data;
#line 2086
  return ((ngx_int_t )0);
}
}
#line 2090 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_length(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                  uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2096
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2096
  p = (u_char *)tmp;
  }
#line 2097
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2098
    return ((ngx_int_t )-1);
  }
  {
#line 2101
  tmp___0 = ngx_sprintf(p, "%O", r->request_length);
#line 2101
  v->len = (unsigned int )(tmp___0 - p);
#line 2102
  v->valid = 1U;
#line 2103
  v->no_cacheable = 0U;
#line 2104
  v->not_found = 0U;
#line 2105
  v->data = p;
  }
#line 2107
  return ((ngx_int_t )0);
}
}
#line 2111 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_time(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  u_char *p ;
  ngx_time_t *tp ;
  ngx_msec_int_t ms ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 2119
  tmp = ngx_pnalloc(r->pool, (sizeof("-9223372036854775808") - 1UL) + 4UL);
#line 2119
  p = (u_char *)tmp;
  }
#line 2120
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2121
    return ((ngx_int_t )-1);
  }
#line 2124
  tp = (ngx_time_t *)ngx_cached_time;
#line 2126
  ms = (ngx_msec_int_t )((ngx_uint_t )((tp->sec - r->start_sec) * 1000L) + (tp->msec - r->start_msec));
#line 2128
  if (ms < 0L) {
#line 2128
    ms = (ngx_msec_int_t )0;
  } else {
#line 2128
    ms = ms;
  }
  {
#line 2130
  tmp___0 = ngx_sprintf(p, "%T.%03M", ms / 1000L, ms % 1000L);
#line 2130
  v->len = (unsigned int )(tmp___0 - p);
#line 2131
  v->valid = 1U;
#line 2132
  v->no_cacheable = 0U;
#line 2133
  v->not_found = 0U;
#line 2134
  v->data = p;
  }
#line 2136
  return ((ngx_int_t )0);
}
}
#line 2140 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_request_id(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  u_char *id ;
  void *tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  char *__cil_tmp10 ;

  {
  {
#line 2150
  tmp = ngx_pnalloc(r->pool, (size_t )32);
#line 2150
  id = (u_char *)tmp;
  }
#line 2151
  if ((unsigned long )id == (unsigned long )((void *)0)) {
#line 2152
    return ((ngx_int_t )-1);
  }
  {
#line 2155
  v->valid = 1U;
#line 2156
  v->no_cacheable = 0U;
#line 2157
  v->not_found = 0U;
#line 2159
  v->len = 32U;
#line 2160
  v->data = id;
#line 2173
  tmp___0 = random();
#line 2173
  tmp___1 = random();
#line 2173
  tmp___2 = random();
#line 2173
  tmp___3 = random();
#line 2173
  ngx_sprintf(id, "%08xD%08xD%08xD%08xD", (uint32_t )tmp___3, (uint32_t )tmp___2,
              (uint32_t )tmp___1, (uint32_t )tmp___0);
  }
#line 2177
  return ((ngx_int_t )0);
}
}
#line 2181 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_connection(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2187
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2187
  p = (u_char *)tmp;
  }
#line 2188
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2189
    return ((ngx_int_t )-1);
  }
  {
#line 2192
  tmp___0 = ngx_sprintf(p, "%uA", (r->connection)->number);
#line 2192
  v->len = (unsigned int )(tmp___0 - p);
#line 2193
  v->valid = 1U;
#line 2194
  v->no_cacheable = 0U;
#line 2195
  v->not_found = 0U;
#line 2196
  v->data = p;
  }
#line 2198
  return ((ngx_int_t )0);
}
}
#line 2202 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_connection_requests(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                       uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2208
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2208
  p = (u_char *)tmp;
  }
#line 2209
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2210
    return ((ngx_int_t )-1);
  }
  {
#line 2213
  tmp___0 = ngx_sprintf(p, "%ui", (r->connection)->requests);
#line 2213
  v->len = (unsigned int )(tmp___0 - p);
#line 2214
  v->valid = 1U;
#line 2215
  v->no_cacheable = 0U;
#line 2216
  v->not_found = 0U;
#line 2217
  v->data = p;
  }
#line 2219
  return ((ngx_int_t )0);
}
}
#line 2223 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_nginx_version(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                 uintptr_t data ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 2227
  v->len = (unsigned int )(sizeof("1.13.8") - 1UL);
#line 2228
  v->valid = 1U;
#line 2229
  v->no_cacheable = 0U;
#line 2230
  v->not_found = 0U;
#line 2231
  v->data = (u_char *)"1.13.8";
#line 2233
  return ((ngx_int_t )0);
}
}
#line 2237 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_hostname(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                            uintptr_t data ) 
{ 


  {
#line 2241
  v->len = (unsigned int )ngx_cycle->hostname.len;
#line 2242
  v->valid = 1U;
#line 2243
  v->no_cacheable = 0U;
#line 2244
  v->not_found = 0U;
#line 2245
  v->data = (u_char *)ngx_cycle->hostname.data;
#line 2247
  return ((ngx_int_t )0);
}
}
#line 2251 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_pid(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                       uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 2257
  tmp = ngx_pnalloc(r->pool, sizeof("-9223372036854775808") - 1UL);
#line 2257
  p = (u_char *)tmp;
  }
#line 2258
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2259
    return ((ngx_int_t )-1);
  }
  {
#line 2262
  tmp___0 = ngx_sprintf(p, "%P", ngx_pid);
#line 2262
  v->len = (unsigned int )(tmp___0 - p);
#line 2263
  v->valid = 1U;
#line 2264
  v->no_cacheable = 0U;
#line 2265
  v->not_found = 0U;
#line 2266
  v->data = p;
  }
#line 2268
  return ((ngx_int_t )0);
}
}
#line 2272 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_msec(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                        uintptr_t data ) 
{ 
  u_char *p ;
  ngx_time_t *tp ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 2279
  tmp = ngx_pnalloc(r->pool, (sizeof("-9223372036854775808") - 1UL) + 4UL);
#line 2279
  p = (u_char *)tmp;
  }
#line 2280
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2281
    return ((ngx_int_t )-1);
  }
  {
#line 2284
  tp = (ngx_time_t *)ngx_cached_time;
#line 2286
  tmp___0 = ngx_sprintf(p, "%T.%03M", tp->sec, tp->msec);
#line 2286
  v->len = (unsigned int )(tmp___0 - p);
#line 2287
  v->valid = 1U;
#line 2288
  v->no_cacheable = 0U;
#line 2289
  v->not_found = 0U;
#line 2290
  v->data = p;
  }
#line 2292
  return ((ngx_int_t )0);
}
}
#line 2296 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_time_iso8601(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                                uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;

  {
  {
#line 2302
  tmp = ngx_pnalloc(r->pool, (size_t )ngx_cached_http_log_iso8601.len);
#line 2302
  p = (u_char *)tmp;
  }
#line 2303
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2304
    return ((ngx_int_t )-1);
  }
  {
#line 2307
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ngx_cached_http_log_iso8601.data,
         (size_t )ngx_cached_http_log_iso8601.len);
#line 2310
  v->len = (unsigned int )ngx_cached_http_log_iso8601.len;
#line 2311
  v->valid = 1U;
#line 2312
  v->no_cacheable = 0U;
#line 2313
  v->not_found = 0U;
#line 2314
  v->data = p;
  }
#line 2316
  return ((ngx_int_t )0);
}
}
#line 2320 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_time_local(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                              uintptr_t data ) 
{ 
  u_char *p ;
  void *tmp ;

  {
  {
#line 2326
  tmp = ngx_pnalloc(r->pool, (size_t )ngx_cached_http_log_time.len);
#line 2326
  p = (u_char *)tmp;
  }
#line 2327
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2328
    return ((ngx_int_t )-1);
  }
  {
#line 2331
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ngx_cached_http_log_time.data,
         (size_t )ngx_cached_http_log_time.len);
#line 2333
  v->len = (unsigned int )ngx_cached_http_log_time.len;
#line 2334
  v->valid = 1U;
#line 2335
  v->no_cacheable = 0U;
#line 2336
  v->not_found = 0U;
#line 2337
  v->data = p;
  }
#line 2339
  return ((ngx_int_t )0);
}
}
#line 2343 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
void *ngx_http_map_find(ngx_http_request_t *r , ngx_http_map_t *map___0 , ngx_str_t *match ) 
{ 
  void *value ;
  u_char *low ;
  size_t len ;
  ngx_uint_t key ;
  void *tmp ;
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_http_map_regex_t *reg ;

  {
#line 2351
  len = match->len;
#line 2353
  if (len) {
    {
#line 2354
    tmp = ngx_pnalloc(r->pool, len);
#line 2354
    low = (u_char *)tmp;
    }
#line 2355
    if ((unsigned long )low == (unsigned long )((void *)0)) {
#line 2356
      return ((void *)0);
    }
  } else {
#line 2360
    low = (u_char *)((void *)0);
  }
  {
#line 2363
  key = ngx_hash_strlow(low, match->data, len);
#line 2365
  value = ngx_hash_find_combined(& map___0->hash, key, low, len);
  }
#line 2366
  if (value) {
#line 2367
    return (value);
  }
#line 2372
  if (len) {
#line 2372
    if (map___0->nregex) {
#line 2377
      reg = map___0->regex;
#line 2379
      i = (ngx_uint_t )0;
      {
#line 2379
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2379
        if (! (i < map___0->nregex)) {
#line 2379
          goto while_break;
        }
        {
#line 2381
        n = ngx_http_regex_exec(r, (reg + i)->regex, match);
        }
#line 2383
        if (n == 0L) {
#line 2384
          return ((reg + i)->value);
        }
#line 2387
        if (n == -5L) {
#line 2388
          goto __Cont;
        }
#line 2393
        return ((void *)0);
        __Cont: /* CIL Label */ 
#line 2379
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2399
  return ((void *)0);
}
}
#line 2405 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
static ngx_int_t ngx_http_variable_not_found(ngx_http_request_t *r , ngx_http_variable_value_t *v ,
                                             uintptr_t data ) 
{ 


  {
#line 2409
  v->not_found = 1U;
#line 2410
  return ((ngx_int_t )0);
}
}
#line 2414 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_http_regex_t *ngx_http_regex_compile(ngx_conf_t *cf , ngx_regex_compile_t *rc ) 
{ 
  u_char *p ;
  size_t size ;
  ngx_str_t name ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_variable_t *v ;
  ngx_http_regex_t *re ;
  ngx_http_regex_variable_t *rv ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp15 ;

  {
  {
#line 2426
  rc->pool = cf->pool;
#line 2428
  tmp = ngx_regex_compile(rc);
  }
#line 2428
  if (tmp != 0L) {
    {
#line 2429
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V", & rc->err);
    }
#line 2430
    return ((ngx_http_regex_t *)((void *)0));
  }
  {
#line 2433
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_http_regex_t ));
#line 2433
  re = (ngx_http_regex_t *)tmp___0;
  }
#line 2434
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 2435
    return ((ngx_http_regex_t *)((void *)0));
  }
#line 2438
  re->regex = rc->regex;
#line 2439
  re->ncaptures = (ngx_uint_t )rc->captures;
#line 2440
  re->name = rc->pattern;
#line 2442
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 2443
  if (cmcf->ncaptures < re->ncaptures) {
#line 2443
    cmcf->ncaptures = re->ncaptures;
  } else {
#line 2443
    cmcf->ncaptures = cmcf->ncaptures;
  }
#line 2445
  n = (ngx_uint_t )rc->named_captures;
#line 2447
  if (n == 0UL) {
#line 2448
    return (re);
  }
  {
#line 2451
  tmp___1 = ngx_palloc(rc->pool, n * sizeof(ngx_http_regex_variable_t ));
#line 2451
  rv = (ngx_http_regex_variable_t *)tmp___1;
  }
#line 2452
  if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 2453
    return ((ngx_http_regex_t *)((void *)0));
  }
#line 2456
  re->variables = rv;
#line 2457
  re->nvariables = n;
#line 2459
  size = (size_t )rc->name_size;
#line 2460
  p = rc->names;
#line 2462
  i = (ngx_uint_t )0;
  {
#line 2462
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2462
    if (! (i < n)) {
#line 2462
      goto while_break;
    }
    {
#line 2463
    (rv + i)->capture = (ngx_uint_t )(2 * (((int )*(p + 0) << 8) + (int )*(p + 1)));
#line 2465
    name.data = p + 2;
#line 2466
    name.len = strlen((char const   *)name.data);
#line 2468
    v = ngx_http_add_variable(cf, & name, (ngx_uint_t )1);
    }
#line 2469
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 2470
      return ((ngx_http_regex_t *)((void *)0));
    }
    {
#line 2473
    (rv + i)->index = ngx_http_get_variable_index(cf, & name);
    }
#line 2474
    if ((rv + i)->index == -1L) {
#line 2475
      return ((ngx_http_regex_t *)((void *)0));
    }
#line 2478
    v->get_handler = & ngx_http_variable_not_found;
#line 2480
    p += size;
#line 2462
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2483
  return (re);
}
}
#line 2487 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_regex_exec(ngx_http_request_t *r , ngx_http_regex_t *re , ngx_str_t *s ) 
{ 
  ngx_int_t rc ;
  ngx_int_t index___0 ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t len ;
  ngx_http_variable_value_t *vv ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  int tmp___0 ;
  char *__cil_tmp13 ;

  {
#line 2495
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 2497
  if (re->ncaptures) {
#line 2498
    len = cmcf->ncaptures;
#line 2500
    if ((unsigned long )r->captures == (unsigned long )((void *)0)) {
      {
#line 2501
      tmp = ngx_palloc(r->pool, len * sizeof(int ));
#line 2501
      r->captures = (int *)tmp;
      }
#line 2502
      if ((unsigned long )r->captures == (unsigned long )((void *)0)) {
#line 2503
        return ((ngx_int_t )-1);
      }
    }
  } else {
#line 2508
    len = (ngx_uint_t )0;
  }
  {
#line 2511
  tmp___0 = pcre_exec((pcre const   *)(re->regex)->code, (pcre_extra const   *)(re->regex)->extra,
                      (char const   *)s->data, (int )s->len, 0, 0, r->captures, (int )len);
#line 2511
  rc = (ngx_int_t )tmp___0;
  }
#line 2513
  if (rc == -1L) {
#line 2514
    return ((ngx_int_t )-5);
  }
#line 2517
  if (rc < 0L) {
#line 2518
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 2518
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "pcre_exec() failed: %i on \"%V\" using \"%V\"",
                         rc, s, & re->name);
      }
    }
#line 2521
    return ((ngx_int_t )-1);
  }
#line 2524
  i = (ngx_uint_t )0;
  {
#line 2524
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2524
    if (! (i < re->nvariables)) {
#line 2524
      goto while_break;
    }
#line 2526
    n = (re->variables + i)->capture;
#line 2527
    index___0 = (re->variables + i)->index;
#line 2528
    vv = r->variables + index___0;
#line 2530
    vv->len = (unsigned int )(*(r->captures + (n + 1UL)) - *(r->captures + n));
#line 2531
    vv->valid = 1U;
#line 2532
    vv->no_cacheable = 0U;
#line 2533
    vv->not_found = 0U;
#line 2534
    vv->data = s->data + *(r->captures + n);
#line 2524
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2548
  r->ncaptures = (ngx_uint_t )(rc * 2L);
#line 2549
  r->captures_data = s->data;
#line 2551
  return ((ngx_int_t )0);
}
}
#line 2557 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_variables_add_core_vars(ngx_conf_t *cf ) 
{ 
  ngx_http_variable_t *cv ;
  ngx_http_variable_t *v ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 2563
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 2565
  tmp = ngx_pcalloc(cf->temp_pool, sizeof(ngx_hash_keys_arrays_t ));
#line 2565
  cmcf->variables_keys = (ngx_hash_keys_arrays_t *)tmp;
  }
#line 2567
  if ((unsigned long )cmcf->variables_keys == (unsigned long )((void *)0)) {
#line 2568
    return ((ngx_int_t )-1);
  }
  {
#line 2571
  (cmcf->variables_keys)->pool = cf->pool;
#line 2572
  (cmcf->variables_keys)->temp_pool = cf->pool;
#line 2574
  tmp___0 = ngx_hash_keys_array_init(cmcf->variables_keys, (ngx_uint_t )1);
  }
#line 2574
  if (tmp___0 != 0L) {
#line 2577
    return ((ngx_int_t )-1);
  }
  {
#line 2580
  tmp___1 = ngx_array_init(& cmcf->prefix_variables, cf->pool, (ngx_uint_t )8, sizeof(ngx_http_variable_t ));
  }
#line 2580
  if (tmp___1 != 0L) {
#line 2584
    return ((ngx_int_t )-1);
  }
#line 2587
  cv = ngx_http_core_variables;
  {
#line 2587
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2587
    if (! cv->name.len) {
#line 2587
      goto while_break;
    }
    {
#line 2588
    v = ngx_http_add_variable(cf, & cv->name, cv->flags);
    }
#line 2589
    if ((unsigned long )v == (unsigned long )((void *)0)) {
#line 2590
      return ((ngx_int_t )-1);
    }
#line 2593
    *v = *cv;
#line 2587
    cv ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2596
  return ((ngx_int_t )0);
}
}
#line 2600 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_variables.c"
ngx_int_t ngx_http_variables_init_vars(ngx_conf_t *cf ) 
{ 
  size_t len ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_hash_key_t *key ;
  ngx_hash_init_t hash ;
  ngx_http_variable_t *v ;
  ngx_http_variable_t *av ;
  ngx_http_variable_t *pv ;
  ngx_http_core_main_conf_t *cmcf ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 2612
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 2614
  v = (ngx_http_variable_t *)cmcf->variables.elts;
#line 2615
  pv = (ngx_http_variable_t *)cmcf->prefix_variables.elts;
#line 2616
  key = (ngx_hash_key_t *)(cmcf->variables_keys)->keys.elts;
#line 2618
  i = (ngx_uint_t )0;
  {
#line 2618
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2618
    if (! (i < cmcf->variables.nelts)) {
#line 2618
      goto while_break;
    }
#line 2620
    n = (ngx_uint_t )0;
    {
#line 2620
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2620
      if (! (n < (cmcf->variables_keys)->keys.nelts)) {
#line 2620
        goto while_break___0;
      }
#line 2622
      av = (ngx_http_variable_t *)(key + n)->value;
#line 2624
      if ((v + i)->name.len == (key + n)->key.len) {
        {
#line 2624
        tmp = strncmp((char const   *)(v + i)->name.data, (char const   *)(key + n)->key.data,
                      (v + i)->name.len);
        }
#line 2624
        if (tmp == 0) {
#line 2628
          (v + i)->get_handler = av->get_handler;
#line 2629
          (v + i)->data = av->data;
#line 2631
          av->flags |= 4UL;
#line 2632
          (v + i)->flags = av->flags;
#line 2634
          av->index = i;
#line 2636
          if ((unsigned long )av->get_handler == (unsigned long )((void *)0)) {
#line 2639
            goto while_break___0;
          } else
#line 2636
          if (av->flags & 16UL) {
#line 2639
            goto while_break___0;
          }
#line 2642
          goto next;
        }
      }
#line 2620
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2646
    len = (size_t )0;
#line 2647
    av = (ngx_http_variable_t *)((void *)0);
#line 2649
    n = (ngx_uint_t )0;
    {
#line 2649
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2649
      if (! (n < cmcf->prefix_variables.nelts)) {
#line 2649
        goto while_break___1;
      }
#line 2650
      if ((v + i)->name.len >= (pv + n)->name.len) {
#line 2650
        if ((v + i)->name.len > len) {
          {
#line 2650
          tmp___0 = strncmp((char const   *)(v + i)->name.data, (char const   *)(pv + n)->name.data,
                            (pv + n)->name.len);
          }
#line 2650
          if (tmp___0 == 0) {
#line 2654
            av = pv + n;
#line 2655
            len = (pv + n)->name.len;
          }
        }
      }
#line 2649
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2659
    if (av) {
#line 2660
      (v + i)->get_handler = av->get_handler;
#line 2661
      (v + i)->data = (uintptr_t )(& (v + i)->name);
#line 2662
      (v + i)->flags = av->flags;
#line 2664
      goto next;
    }
#line 2667
    if ((unsigned long )(v + i)->get_handler == (unsigned long )((void *)0)) {
#line 2668
      if ((cf->log)->log_level >= 1UL) {
        {
#line 2668
        ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "unknown \"%V\" variable",
                           & (v + i)->name);
        }
      }
#line 2671
      return ((ngx_int_t )-1);
    }
    next: 
#line 2675
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 2618
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2679
  n = (ngx_uint_t )0;
  {
#line 2679
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2679
    if (! (n < (cmcf->variables_keys)->keys.nelts)) {
#line 2679
      goto while_break___2;
    }
#line 2680
    av = (ngx_http_variable_t *)(key + n)->value;
#line 2682
    if (av->flags & 8UL) {
#line 2683
      (key + n)->key.data = (u_char *)((void *)0);
    }
#line 2679
    n ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2688
  hash.hash = & cmcf->variables_hash;
#line 2689
  hash.key = & ngx_hash_key;
#line 2690
  hash.max_size = cmcf->variables_hash_max_size;
#line 2691
  hash.bucket_size = cmcf->variables_hash_bucket_size;
#line 2692
  hash.name = (char *)"variables_hash";
#line 2693
  hash.pool = cf->pool;
#line 2694
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2696
  tmp___1 = ngx_hash_init(& hash, (ngx_hash_key_t *)(cmcf->variables_keys)->keys.elts,
                          (cmcf->variables_keys)->keys.nelts);
  }
#line 2696
  if (tmp___1 != 0L) {
#line 2700
    return ((ngx_int_t )-1);
  }
#line 2703
  cmcf->variables_keys = (ngx_hash_keys_arrays_t *)((void *)0);
#line 2705
  return ((ngx_int_t )0);
}
}
#line 138 "src/core/ngx_file.h"
ssize_t ngx_write_chain_to_temp_file(ngx_temp_file_t *tf , ngx_chain_t *chain ) ;
#line 516 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_request_body_save_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 149 "src/http/ngx_http.h"
void ngx_http_discarded_request_body_handler(ngx_http_request_t *r ) ;
#line 173
ngx_int_t (*ngx_http_top_request_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r ) ;
#line 14
static ngx_int_t ngx_http_do_read_client_request_body(ngx_http_request_t *r ) ;
#line 15
static ngx_int_t ngx_http_write_request_body(ngx_http_request_t *r ) ;
#line 16
static ngx_int_t ngx_http_read_discarded_request_body(ngx_http_request_t *r ) ;
#line 17
static ngx_int_t ngx_http_discard_request_body_filter(ngx_http_request_t *r , ngx_buf_t *b ) ;
#line 19
static ngx_int_t ngx_http_test_expect(ngx_http_request_t *r ) ;
#line 21
static ngx_int_t ngx_http_request_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 23
static ngx_int_t ngx_http_request_body_length_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 25
static ngx_int_t ngx_http_request_body_chunked_filter(ngx_http_request_t *r , ngx_chain_t *in ) ;
#line 29 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
ngx_int_t ngx_http_read_client_request_body(ngx_http_request_t *r , void (*post_handler)(ngx_http_request_t *r ) ) 
{ 
  size_t preread ;
  ssize_t size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  ngx_http_request_body_t *rb ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp14 ;

  {
#line 41
  ((r->main)->count) ++;
#line 43
  if ((unsigned long )r != (unsigned long )r->main) {
    {
#line 44
    r->request_body_no_buffering = 0U;
#line 45
    (*post_handler)(r);
    }
#line 46
    return ((ngx_int_t )0);
  } else
#line 43
  if (r->request_body) {
    {
#line 44
    r->request_body_no_buffering = 0U;
#line 45
    (*post_handler)(r);
    }
#line 46
    return ((ngx_int_t )0);
  } else
#line 43
  if (r->discard_body) {
    {
#line 44
    r->request_body_no_buffering = 0U;
#line 45
    (*post_handler)(r);
    }
#line 46
    return ((ngx_int_t )0);
  }
  {
#line 49
  tmp = ngx_http_test_expect(r);
  }
#line 49
  if (tmp != 0L) {
#line 50
    rc = (ngx_int_t )500;
#line 51
    goto done;
  }
  {
#line 54
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t ));
#line 54
  rb = (ngx_http_request_body_t *)tmp___0;
  }
#line 55
  if ((unsigned long )rb == (unsigned long )((void *)0)) {
#line 56
    rc = (ngx_int_t )500;
#line 57
    goto done;
  }
#line 70
  rb->rest = (off_t )-1;
#line 71
  rb->post_handler = post_handler;
#line 73
  r->request_body = rb;
#line 75
  if (r->headers_in.content_length_n < 0L) {
#line 75
    if (! r->headers_in.chunked) {
      {
#line 76
      r->request_body_no_buffering = 0U;
#line 77
      (*post_handler)(r);
      }
#line 78
      return ((ngx_int_t )0);
    }
  }
#line 88
  preread = (size_t )((r->header_in)->last - (r->header_in)->pos);
#line 90
  if (preread) {
    {
#line 97
    out.buf = r->header_in;
#line 98
    out.next = (ngx_chain_t *)((void *)0);
#line 100
    rc = ngx_http_request_body_filter(r, & out);
    }
#line 102
    if (rc != 0L) {
#line 103
      goto done;
    }
#line 106
    r->request_length = (off_t )((size_t )r->request_length + (preread - (size_t )((r->header_in)->last - (r->header_in)->pos)));
#line 108
    if (! r->headers_in.chunked) {
#line 108
      if (rb->rest > 0L) {
#line 108
        if (rb->rest <= (r->header_in)->end - (r->header_in)->last) {
          {
#line 114
          tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 114
          b = (ngx_buf_t *)tmp___1;
          }
#line 115
          if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 116
            rc = (ngx_int_t )500;
#line 117
            goto done;
          }
          {
#line 120
          b->temporary = 1U;
#line 121
          b->start = (r->header_in)->pos;
#line 122
          b->pos = (r->header_in)->pos;
#line 123
          b->last = (r->header_in)->last;
#line 124
          b->end = (r->header_in)->end;
#line 126
          rb->buf = b;
#line 128
          r->read_event_handler = & ngx_http_read_client_request_body_handler;
#line 129
          r->write_event_handler = & ngx_http_request_empty_handler;
#line 131
          rc = ngx_http_do_read_client_request_body(r);
          }
#line 132
          goto done;
        }
      }
    }
  } else {
    {
#line 138
    tmp___2 = ngx_http_request_body_filter(r, (ngx_chain_t *)((void *)0));
    }
#line 138
    if (tmp___2 != 0L) {
#line 139
      rc = (ngx_int_t )500;
#line 140
      goto done;
    }
  }
#line 144
  if (rb->rest == 0L) {
    {
#line 146
    r->request_body_no_buffering = 0U;
#line 147
    (*post_handler)(r);
    }
#line 148
    return ((ngx_int_t )0);
  }
#line 151
  if (rb->rest < 0L) {
#line 152
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 152
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "negative request body rest");
      }
    }
#line 154
    rc = (ngx_int_t )500;
#line 155
    goto done;
  }
#line 158
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 160
  size = (ssize_t )clcf->client_body_buffer_size;
#line 161
  size += size >> 2;
#line 165
  if (! r->headers_in.chunked) {
#line 165
    if (rb->rest < size) {
#line 166
      size = rb->rest;
#line 168
      if (r->request_body_in_single_buf) {
#line 169
        size = (ssize_t )((size_t )size + preread);
      }
    } else {
#line 173
      size = (ssize_t )clcf->client_body_buffer_size;
    }
  } else {
#line 173
    size = (ssize_t )clcf->client_body_buffer_size;
  }
  {
#line 176
  rb->buf = ngx_create_temp_buf(r->pool, (size_t )size);
  }
#line 177
  if ((unsigned long )rb->buf == (unsigned long )((void *)0)) {
#line 178
    rc = (ngx_int_t )500;
#line 179
    goto done;
  }
  {
#line 182
  r->read_event_handler = & ngx_http_read_client_request_body_handler;
#line 183
  r->write_event_handler = & ngx_http_request_empty_handler;
#line 185
  rc = ngx_http_do_read_client_request_body(r);
  }
  done: 
#line 189
  if (r->request_body_no_buffering) {
#line 189
    if (rc == 0L) {
#line 189
      goto _L;
    } else
#line 189
    if (rc == -2L) {
      _L: /* CIL Label */ 
#line 192
      if (rc == 0L) {
#line 193
        r->request_body_no_buffering = 0U;
      } else {
#line 197
        r->reading_body = 1U;
      }
      {
#line 200
      r->read_event_handler = & ngx_http_block_reading;
#line 201
      (*post_handler)(r);
      }
    }
  }
#line 204
  if (rc >= 300L) {
#line 205
    ((r->main)->count) --;
  }
#line 208
  return (rc);
}
}
#line 212 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
ngx_int_t ngx_http_read_unbuffered_request_body(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;

  {
#line 229
  if (((r->connection)->read)->timedout) {
#line 230
    (r->connection)->timedout = 1U;
#line 231
    return ((ngx_int_t )408);
  }
  {
#line 234
  rc = ngx_http_do_read_client_request_body(r);
  }
#line 236
  if (rc == 0L) {
#line 237
    r->reading_body = 0U;
  }
#line 240
  return (rc);
}
}
#line 244 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static void ngx_http_read_client_request_body_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;

  {
#line 249
  if (((r->connection)->read)->timedout) {
    {
#line 250
    (r->connection)->timedout = 1U;
#line 251
    ngx_http_finalize_request(r, (ngx_int_t )408);
    }
#line 252
    return;
  }
  {
#line 255
  rc = ngx_http_do_read_client_request_body(r);
  }
#line 257
  if (rc >= 300L) {
    {
#line 258
    ngx_http_finalize_request(r, rc);
    }
  }
#line 260
  return;
}
}
#line 263 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_do_read_client_request_body(ngx_http_request_t *r ) 
{ 
  off_t rest ;
  size_t size ;
  ssize_t n ;
  ngx_int_t rc ;
  ngx_chain_t out ;
  ngx_connection_t *c ;
  ngx_http_request_body_t *rb ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp12 ;

  {
#line 275
  c = r->connection;
#line 276
  rb = r->request_body;
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 282
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 283
      if ((unsigned long )(rb->buf)->last == (unsigned long )(rb->buf)->end) {
#line 285
        if ((unsigned long )(rb->buf)->pos != (unsigned long )(rb->buf)->last) {
          {
#line 289
          out.buf = rb->buf;
#line 290
          out.next = (ngx_chain_t *)((void *)0);
#line 292
          rc = ngx_http_request_body_filter(r, & out);
          }
#line 294
          if (rc != 0L) {
#line 295
            return (rc);
          }
        } else {
          {
#line 302
          rc = ngx_http_request_body_filter(r, (ngx_chain_t *)((void *)0));
          }
#line 304
          if (rc != 0L) {
#line 305
            return (rc);
          }
        }
#line 309
        if ((unsigned long )rb->busy != (unsigned long )((void *)0)) {
#line 310
          if (r->request_body_no_buffering) {
#line 311
            if ((c->read)->timer_set) {
              {
#line 312
              ngx_event_del_timer(c->read);
              }
            }
            {
#line 315
            tmp = ngx_handle_read_event(c->read, (ngx_uint_t )0);
            }
#line 315
            if (tmp != 0L) {
#line 316
              return ((ngx_int_t )500);
            }
#line 319
            return ((ngx_int_t )-2);
          }
#line 322
          return ((ngx_int_t )500);
        }
#line 325
        (rb->buf)->pos = (rb->buf)->start;
#line 326
        (rb->buf)->last = (rb->buf)->start;
      }
#line 329
      size = (size_t )((rb->buf)->end - (rb->buf)->last);
#line 330
      rest = rb->rest - ((rb->buf)->last - (rb->buf)->pos);
#line 332
      if ((off_t )size > rest) {
#line 333
        size = (size_t )rest;
      }
      {
#line 336
      n = (*(c->recv))(c, (rb->buf)->last, size);
      }
#line 341
      if (n == -2L) {
#line 342
        goto while_break___0;
      }
#line 345
      if (n == 0L) {
#line 346
        if ((c->log)->log_level >= 7UL) {
          {
#line 346
          ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client prematurely closed connection");
          }
        }
      }
#line 350
      if (n == 0L) {
#line 351
        c->error = 1U;
#line 352
        return ((ngx_int_t )400);
      } else
#line 350
      if (n == -1L) {
#line 351
        c->error = 1U;
#line 352
        return ((ngx_int_t )400);
      }
#line 355
      (rb->buf)->last += n;
#line 356
      r->request_length += n;
#line 358
      if (n == rest) {
        {
#line 361
        out.buf = rb->buf;
#line 362
        out.next = (ngx_chain_t *)((void *)0);
#line 364
        rc = ngx_http_request_body_filter(r, & out);
        }
#line 366
        if (rc != 0L) {
#line 367
          return (rc);
        }
      }
#line 371
      if (rb->rest == 0L) {
#line 372
        goto while_break___0;
      }
#line 375
      if ((unsigned long )(rb->buf)->last < (unsigned long )(rb->buf)->end) {
#line 376
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 383
    if (rb->rest == 0L) {
#line 384
      goto while_break;
    }
#line 387
    if (! (c->read)->ready) {
#line 389
      if (r->request_body_no_buffering) {
#line 389
        if ((unsigned long )(rb->buf)->pos != (unsigned long )(rb->buf)->last) {
          {
#line 394
          out.buf = rb->buf;
#line 395
          out.next = (ngx_chain_t *)((void *)0);
#line 397
          rc = ngx_http_request_body_filter(r, & out);
          }
#line 399
          if (rc != 0L) {
#line 400
            return (rc);
          }
        }
      }
      {
#line 404
      clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 405
      ngx_event_add_timer(c->read, clcf->client_body_timeout);
#line 407
      tmp___0 = ngx_handle_read_event(c->read, (ngx_uint_t )0);
      }
#line 407
      if (tmp___0 != 0L) {
#line 408
        return ((ngx_int_t )500);
      }
#line 411
      return ((ngx_int_t )-2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 415
  if ((c->read)->timer_set) {
    {
#line 416
    ngx_event_del_timer(c->read);
    }
  }
#line 419
  if (! r->request_body_no_buffering) {
    {
#line 420
    r->read_event_handler = & ngx_http_block_reading;
#line 421
    (*(rb->post_handler))(r);
    }
  }
#line 424
  return ((ngx_int_t )0);
}
}
#line 428 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_write_request_body(ngx_http_request_t *r ) 
{ 
  ssize_t n ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_temp_file_t *tf ;
  ngx_http_request_body_t *rb ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp10 ;

  {
#line 437
  rb = r->request_body;
#line 442
  if ((unsigned long )rb->temp_file == (unsigned long )((void *)0)) {
    {
#line 443
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_temp_file_t ));
#line 443
    tf = (ngx_temp_file_t *)tmp;
    }
#line 444
    if ((unsigned long )tf == (unsigned long )((void *)0)) {
#line 445
      return ((ngx_int_t )-1);
    }
#line 448
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 450
    tf->file.fd = -1;
#line 451
    tf->file.log = (r->connection)->log;
#line 452
    tf->path = clcf->client_body_temp_path;
#line 453
    tf->pool = r->pool;
#line 454
    tf->warn = (char *)"a client request body is buffered to a temporary file";
#line 455
    tf->log_level = r->request_body_file_log_level;
#line 456
    tf->persistent = r->request_body_in_persistent_file;
#line 457
    tf->clean = r->request_body_in_clean_file;
#line 459
    if (r->request_body_file_group_access) {
#line 460
      tf->access = (ngx_uint_t )432;
    }
#line 463
    rb->temp_file = tf;
#line 465
    if ((unsigned long )rb->bufs == (unsigned long )((void *)0)) {
      {
#line 468
      tmp___0 = ngx_create_temp_file(& tf->file, tf->path, tf->pool, (ngx_uint_t )tf->persistent,
                                     (ngx_uint_t )tf->clean, tf->access);
      }
#line 468
      if (tmp___0 != 0L) {
#line 472
        return ((ngx_int_t )-1);
      }
#line 475
      return ((ngx_int_t )0);
    }
  }
#line 479
  if ((unsigned long )rb->bufs == (unsigned long )((void *)0)) {
#line 480
    return ((ngx_int_t )0);
  }
  {
#line 483
  n = ngx_write_chain_to_temp_file(rb->temp_file, rb->bufs);
  }
#line 487
  if (n == -1L) {
#line 488
    return ((ngx_int_t )-1);
  }
#line 491
  (rb->temp_file)->offset += n;
#line 495
  cl = rb->bufs;
  {
#line 495
  while (1) {
    while_continue: /* CIL Label */ ;
#line 495
    if (! cl) {
#line 495
      goto while_break;
    }
#line 497
    (cl->buf)->pos = (cl->buf)->last;
#line 499
    ln = cl;
#line 500
    cl = cl->next;
#line 501
    ln->next = (r->pool)->chain;
#line 501
    (r->pool)->chain = ln;
  }
  while_break: /* CIL Label */ ;
  }
#line 504
  rb->bufs = (ngx_chain_t *)((void *)0);
#line 506
  return ((ngx_int_t )0);
}
}
#line 510 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
ngx_int_t ngx_http_discard_request_body(ngx_http_request_t *r ) 
{ 
  ssize_t size ;
  ngx_int_t rc ;
  ngx_event_t *rev ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 517
  if ((unsigned long )r != (unsigned long )r->main) {
#line 518
    return ((ngx_int_t )0);
  } else
#line 517
  if (r->discard_body) {
#line 518
    return ((ngx_int_t )0);
  } else
#line 517
  if (r->request_body) {
#line 518
    return ((ngx_int_t )0);
  }
  {
#line 528
  tmp = ngx_http_test_expect(r);
  }
#line 528
  if (tmp != 0L) {
#line 529
    return ((ngx_int_t )500);
  }
#line 532
  rev = (r->connection)->read;
#line 536
  if (rev->timer_set) {
    {
#line 537
    ngx_event_del_timer(rev);
    }
  }
#line 540
  if (r->headers_in.content_length_n <= 0L) {
#line 540
    if (! r->headers_in.chunked) {
#line 541
      return ((ngx_int_t )0);
    }
  }
#line 544
  size = (r->header_in)->last - (r->header_in)->pos;
#line 546
  if (size) {
#line 546
    goto _L;
  } else
#line 546
  if (r->headers_in.chunked) {
    _L: /* CIL Label */ 
    {
#line 547
    rc = ngx_http_discard_request_body_filter(r, r->header_in);
    }
#line 549
    if (rc != 0L) {
#line 550
      return (rc);
    }
#line 553
    if (r->headers_in.content_length_n == 0L) {
#line 554
      return ((ngx_int_t )0);
    }
  }
  {
#line 558
  rc = ngx_http_read_discarded_request_body(r);
  }
#line 560
  if (rc == 0L) {
#line 561
    r->lingering_close = 0U;
#line 562
    return ((ngx_int_t )0);
  }
#line 565
  if (rc >= 300L) {
#line 566
    return (rc);
  }
  {
#line 571
  r->read_event_handler = & ngx_http_discarded_request_body_handler;
#line 573
  tmp___0 = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 573
  if (tmp___0 != 0L) {
#line 574
    return ((ngx_int_t )500);
  }
#line 577
  (r->count) ++;
#line 578
  r->discard_body = 1U;
#line 580
  return ((ngx_int_t )0);
}
}
#line 584 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
void ngx_http_discarded_request_body_handler(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_msec_t timer ;
  ngx_event_t *rev ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;

  {
#line 593
  c = r->connection;
#line 594
  rev = c->read;
#line 596
  if (rev->timedout) {
    {
#line 597
    c->timedout = 1U;
#line 598
    c->error = 1U;
#line 599
    ngx_http_finalize_request(r, (ngx_int_t )-1);
    }
#line 600
    return;
  }
#line 603
  if (r->lingering_time) {
#line 604
    timer = (ngx_msec_t )r->lingering_time - (ngx_msec_t )ngx_cached_time->sec;
#line 606
    if ((ngx_msec_int_t )timer <= 0L) {
      {
#line 607
      r->discard_body = 0U;
#line 608
      r->lingering_close = 0U;
#line 609
      ngx_http_finalize_request(r, (ngx_int_t )-1);
      }
#line 610
      return;
    }
  } else {
#line 614
    timer = (ngx_msec_t )0;
  }
  {
#line 617
  rc = ngx_http_read_discarded_request_body(r);
  }
#line 619
  if (rc == 0L) {
    {
#line 620
    r->discard_body = 0U;
#line 621
    r->lingering_close = 0U;
#line 622
    ngx_http_finalize_request(r, (ngx_int_t )-4);
    }
#line 623
    return;
  }
#line 626
  if (rc >= 300L) {
    {
#line 627
    c->error = 1U;
#line 628
    ngx_http_finalize_request(r, (ngx_int_t )-1);
    }
#line 629
    return;
  }
  {
#line 634
  tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 634
  if (tmp != 0L) {
    {
#line 635
    c->error = 1U;
#line 636
    ngx_http_finalize_request(r, (ngx_int_t )-1);
    }
#line 637
    return;
  }
#line 640
  if (timer) {
#line 642
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 644
    timer *= 1000UL;
#line 646
    if (timer > clcf->lingering_timeout) {
#line 647
      timer = clcf->lingering_timeout;
    }
    {
#line 650
    ngx_event_add_timer(rev, timer);
    }
  }
#line 652
  return;
}
}
#line 655 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_read_discarded_request_body(ngx_http_request_t *r ) 
{ 
  size_t size ;
  ssize_t n ;
  ngx_int_t rc ;
  ngx_buf_t b ;
  u_char buffer___0[4096] ;
  off_t tmp ;
  void *__cil_tmp8 ;

  {
  {
#line 667
  memset((void *)(& b), 0, sizeof(ngx_buf_t ));
#line 669
  b.temporary = 1U;
  }
  {
#line 671
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (r->headers_in.content_length_n == 0L) {
#line 673
      r->read_event_handler = & ngx_http_block_reading;
#line 674
      return ((ngx_int_t )0);
    }
#line 677
    if (! ((r->connection)->read)->ready) {
#line 678
      return ((ngx_int_t )-2);
    }
#line 681
    if (r->headers_in.content_length_n > 4096L) {
#line 681
      tmp = (off_t )4096;
    } else {
#line 681
      tmp = r->headers_in.content_length_n;
    }
    {
#line 681
    size = (size_t )tmp;
#line 684
    n = (*((r->connection)->recv))(r->connection, buffer___0, size);
    }
#line 686
    if (n == -1L) {
#line 687
      (r->connection)->error = 1U;
#line 688
      return ((ngx_int_t )0);
    }
#line 691
    if (n == -2L) {
#line 692
      return ((ngx_int_t )-2);
    }
#line 695
    if (n == 0L) {
#line 696
      return ((ngx_int_t )0);
    }
    {
#line 699
    b.pos = buffer___0;
#line 700
    b.last = buffer___0 + n;
#line 702
    rc = ngx_http_discard_request_body_filter(r, & b);
    }
#line 704
    if (rc != 0L) {
#line 705
      return (rc);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 711 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_discard_request_body_filter(ngx_http_request_t *r , ngx_buf_t *b ) 
{ 
  size_t size ;
  ngx_int_t rc ;
  ngx_http_request_body_t *rb ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;

  {
#line 718
  if (r->headers_in.chunked) {
#line 720
    rb = r->request_body;
#line 722
    if ((unsigned long )rb == (unsigned long )((void *)0)) {
      {
#line 724
      tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t ));
#line 724
      rb = (ngx_http_request_body_t *)tmp;
      }
#line 725
      if ((unsigned long )rb == (unsigned long )((void *)0)) {
#line 726
        return ((ngx_int_t )500);
      }
      {
#line 729
      tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_t ));
#line 729
      rb->chunked = (ngx_http_chunked_t *)tmp___0;
      }
#line 730
      if ((unsigned long )rb->chunked == (unsigned long )((void *)0)) {
#line 731
        return ((ngx_int_t )500);
      }
#line 734
      r->request_body = rb;
    }
    {
#line 737
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 739
      rc = ngx_http_parse_chunked(r, b, rb->chunked);
      }
#line 741
      if (rc == 0L) {
#line 745
        size = (size_t )(b->last - b->pos);
#line 747
        if ((off_t )size > (rb->chunked)->size) {
#line 748
          b->pos += (size_t )(rb->chunked)->size;
#line 749
          (rb->chunked)->size = (off_t )0;
        } else {
#line 752
          (rb->chunked)->size = (off_t )((size_t )(rb->chunked)->size - size);
#line 753
          b->pos = b->last;
        }
#line 756
        goto __Cont;
      }
#line 759
      if (rc == -4L) {
#line 763
        r->headers_in.content_length_n = (off_t )0;
#line 764
        goto while_break;
      }
#line 767
      if (rc == -2L) {
#line 771
        r->headers_in.content_length_n = (rb->chunked)->length;
#line 772
        goto while_break;
      }
#line 777
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 777
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client sent invalid chunked body");
        }
      }
#line 780
      return ((ngx_int_t )400);
      __Cont: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 784
    size = (size_t )(b->last - b->pos);
#line 786
    if ((off_t )size > r->headers_in.content_length_n) {
#line 787
      b->pos += (size_t )r->headers_in.content_length_n;
#line 788
      r->headers_in.content_length_n = (off_t )0;
    } else {
#line 791
      b->pos = b->last;
#line 792
      r->headers_in.content_length_n = (off_t )((size_t )r->headers_in.content_length_n - size);
    }
  }
#line 796
  return ((ngx_int_t )0);
}
}
#line 800 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_test_expect(ngx_http_request_t *r ) 
{ 
  ngx_int_t n ;
  ngx_str_t *expect ;
  ngx_int_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 806
  if (r->expect_tested) {
#line 814
    return ((ngx_int_t )0);
  } else
#line 806
  if ((unsigned long )r->headers_in.expect == (unsigned long )((void *)0)) {
#line 814
    return ((ngx_int_t )0);
  } else
#line 806
  if (r->http_version < 1001UL) {
#line 814
    return ((ngx_int_t )0);
  }
#line 817
  r->expect_tested = 1U;
#line 819
  expect = & (r->headers_in.expect)->value;
#line 821
  if (expect->len != sizeof("100-continue") - 1UL) {
#line 826
    return ((ngx_int_t )0);
  } else {
    {
#line 821
    tmp = ngx_strncasecmp(expect->data, (u_char *)"100-continue", sizeof("100-continue") - 1UL);
    }
#line 821
    if (tmp != 0L) {
#line 826
      return ((ngx_int_t )0);
    }
  }
  {
#line 832
  n = (*((r->connection)->send))(r->connection, (u_char *)"HTTP/1.1 100 Continue\r\n\r\n",
                                 sizeof("HTTP/1.1 100 Continue\r\n\r\n") - 1UL);
  }
#line 836
  if ((unsigned long )n == sizeof("HTTP/1.1 100 Continue\r\n\r\n") - 1UL) {
#line 837
    return ((ngx_int_t )0);
  }
#line 842
  (r->connection)->error = 1U;
#line 844
  return ((ngx_int_t )-1);
}
}
#line 848 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_request_body_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 851
  if (r->headers_in.chunked) {
    {
#line 852
    tmp = ngx_http_request_body_chunked_filter(r, in);
    }
#line 852
    return (tmp);
  } else {
    {
#line 855
    tmp___0 = ngx_http_request_body_length_filter(r, in);
    }
#line 855
    return (tmp___0);
  }
}
}
#line 860 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_request_body_length_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  size_t size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_http_request_body_t *rb ;

  {
#line 869
  rb = r->request_body;
#line 871
  if (rb->rest == -1L) {
#line 875
    rb->rest = r->headers_in.content_length_n;
  }
#line 878
  out = (ngx_chain_t *)((void *)0);
#line 879
  ll = & out;
#line 881
  cl = in;
  {
#line 881
  while (1) {
    while_continue: /* CIL Label */ ;
#line 881
    if (! cl) {
#line 881
      goto while_break;
    }
#line 883
    if (rb->rest == 0L) {
#line 884
      goto while_break;
    }
    {
#line 887
    tl = ngx_chain_get_free_buf(r->pool, & rb->free);
    }
#line 888
    if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 889
      return ((ngx_int_t )500);
    }
    {
#line 892
    b = tl->buf;
#line 894
    memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 896
    b->temporary = 1U;
#line 897
    b->tag = (ngx_buf_tag_t )(& ngx_http_read_client_request_body);
#line 898
    b->start = (cl->buf)->pos;
#line 899
    b->pos = (cl->buf)->pos;
#line 900
    b->last = (cl->buf)->last;
#line 901
    b->end = (cl->buf)->end;
#line 902
    b->flush = r->request_body_no_buffering;
#line 904
    size = (size_t )((cl->buf)->last - (cl->buf)->pos);
    }
#line 906
    if ((off_t )size < rb->rest) {
#line 907
      (cl->buf)->pos = (cl->buf)->last;
#line 908
      rb->rest = (off_t )((size_t )rb->rest - size);
    } else {
#line 911
      (cl->buf)->pos += (size_t )rb->rest;
#line 912
      rb->rest = (off_t )0;
#line 913
      b->last = (cl->buf)->pos;
#line 914
      b->last_buf = 1U;
    }
#line 917
    *ll = tl;
#line 918
    ll = & tl->next;
#line 881
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 921
  rc = (*ngx_http_top_request_body_filter)(r, out);
#line 923
  ngx_chain_update_chains(r->pool, & rb->free, & rb->busy, & out, (ngx_buf_tag_t )(& ngx_http_read_client_request_body));
  }
#line 926
  return (rc);
}
}
#line 930 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
static ngx_int_t ngx_http_request_body_chunked_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  size_t size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_chain_t *out ;
  ngx_chain_t *tl ;
  ngx_chain_t **ll ;
  ngx_http_request_body_t *rb ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 940
  rb = r->request_body;
#line 942
  if (rb->rest == -1L) {
    {
#line 947
    tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_chunked_t ));
#line 947
    rb->chunked = (ngx_http_chunked_t *)tmp;
    }
#line 948
    if ((unsigned long )rb->chunked == (unsigned long )((void *)0)) {
#line 949
      return ((ngx_int_t )500);
    }
#line 952
    r->headers_in.content_length_n = (off_t )0;
#line 953
    rb->rest = (off_t )3;
  }
#line 956
  out = (ngx_chain_t *)((void *)0);
#line 957
  ll = & out;
#line 959
  cl = in;
  {
#line 959
  while (1) {
    while_continue: /* CIL Label */ ;
#line 959
    if (! cl) {
#line 959
      goto while_break;
    }
    {
#line 961
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 972
      rc = ngx_http_parse_chunked(r, cl->buf, rb->chunked);
      }
#line 974
      if (rc == 0L) {
#line 978
        clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 980
        if (clcf->client_max_body_size) {
#line 980
          if (clcf->client_max_body_size - r->headers_in.content_length_n < (rb->chunked)->size) {
#line 984
            if (((r->connection)->log)->log_level >= 4UL) {
              {
#line 984
              ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client intended to send too large chunked body: %O+%O bytes",
                                 r->headers_in.content_length_n, (rb->chunked)->size);
              }
            }
#line 990
            r->lingering_close = 1U;
#line 992
            return ((ngx_int_t )413);
          }
        }
        {
#line 995
        tl = ngx_chain_get_free_buf(r->pool, & rb->free);
        }
#line 996
        if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 997
          return ((ngx_int_t )500);
        }
        {
#line 1000
        b = tl->buf;
#line 1002
        memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 1004
        b->temporary = 1U;
#line 1005
        b->tag = (ngx_buf_tag_t )(& ngx_http_read_client_request_body);
#line 1006
        b->start = (cl->buf)->pos;
#line 1007
        b->pos = (cl->buf)->pos;
#line 1008
        b->last = (cl->buf)->last;
#line 1009
        b->end = (cl->buf)->end;
#line 1010
        b->flush = r->request_body_no_buffering;
#line 1012
        *ll = tl;
#line 1013
        ll = & tl->next;
#line 1015
        size = (size_t )((cl->buf)->last - (cl->buf)->pos);
        }
#line 1017
        if ((off_t )size > (rb->chunked)->size) {
#line 1018
          (cl->buf)->pos += (size_t )(rb->chunked)->size;
#line 1019
          r->headers_in.content_length_n += (rb->chunked)->size;
#line 1020
          (rb->chunked)->size = (off_t )0;
        } else {
#line 1023
          (rb->chunked)->size = (off_t )((size_t )(rb->chunked)->size - size);
#line 1024
          r->headers_in.content_length_n = (off_t )((size_t )r->headers_in.content_length_n + size);
#line 1025
          (cl->buf)->pos = (cl->buf)->last;
        }
#line 1028
        b->last = (cl->buf)->pos;
#line 1030
        goto __Cont;
      }
#line 1033
      if (rc == -4L) {
        {
#line 1037
        rb->rest = (off_t )0;
#line 1039
        tl = ngx_chain_get_free_buf(r->pool, & rb->free);
        }
#line 1040
        if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 1041
          return ((ngx_int_t )500);
        }
        {
#line 1044
        b = tl->buf;
#line 1046
        memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 1048
        b->last_buf = 1U;
#line 1050
        *ll = tl;
#line 1051
        ll = & tl->next;
        }
#line 1053
        goto while_break___0;
      }
#line 1056
      if (rc == -2L) {
#line 1060
        rb->rest = (rb->chunked)->length;
#line 1062
        goto while_break___0;
      }
#line 1067
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1067
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client sent invalid chunked body");
        }
      }
#line 1070
      return ((ngx_int_t )400);
      __Cont: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 959
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1074
  rc = (*ngx_http_top_request_body_filter)(r, out);
#line 1076
  ngx_chain_update_chains(r->pool, & rb->free, & rb->busy, & out, (ngx_buf_tag_t )(& ngx_http_read_client_request_body));
  }
#line 1079
  return (rc);
}
}
#line 1083 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request_body.c"
ngx_int_t ngx_http_request_body_save_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_request_body_t *rb ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 1090
  rb = r->request_body;
#line 1122
  tmp = ngx_chain_add_copy(r->pool, & rb->bufs, in);
  }
#line 1122
  if (tmp != 0L) {
#line 1123
    return ((ngx_int_t )500);
  }
#line 1126
  if (r->request_body_no_buffering) {
#line 1127
    return ((ngx_int_t )0);
  }
#line 1130
  if (rb->rest > 0L) {
#line 1132
    if (rb->buf) {
#line 1132
      if ((unsigned long )(rb->buf)->last == (unsigned long )(rb->buf)->end) {
        {
#line 1132
        tmp___0 = ngx_http_write_request_body(r);
        }
#line 1132
        if (tmp___0 != 0L) {
#line 1135
          return ((ngx_int_t )500);
        }
      }
    }
#line 1138
    return ((ngx_int_t )0);
  }
#line 1143
  if (rb->temp_file) {
#line 1143
    goto _L;
  } else
#line 1143
  if (r->request_body_in_file_only) {
    _L: /* CIL Label */ 
    {
#line 1145
    tmp___1 = ngx_http_write_request_body(r);
    }
#line 1145
    if (tmp___1 != 0L) {
#line 1146
      return ((ngx_int_t )500);
    }
#line 1149
    if ((rb->temp_file)->file.offset != 0L) {
      {
#line 1151
      cl = ngx_chain_get_free_buf(r->pool, & rb->free);
      }
#line 1152
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1153
        return ((ngx_int_t )500);
      }
      {
#line 1156
      b = cl->buf;
#line 1158
      memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 1160
      b->in_file = 1U;
#line 1161
      b->file_last = (rb->temp_file)->file.offset;
#line 1162
      b->file = & (rb->temp_file)->file;
#line 1164
      rb->bufs = cl;
      }
    }
  }
#line 1168
  return ((ngx_int_t )0);
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 144 "src/os/unix/ngx_files.h"
__inline static ssize_t ngx_write_fd(ngx_fd_t fd , void *buf , size_t n ) 
{ 
  ssize_t tmp ;

  {
  {
#line 147
  tmp = write(fd, (void const   *)buf, n);
  }
#line 147
  return (tmp);
}
}
#line 275 "src/core/ngx_conf_file.h"
ngx_open_file_t *ngx_conf_open_file(ngx_cycle_t *cycle , ngx_str_t *name ) ;
#line 123 "src/core/ngx_open_file_cache.h"
ngx_open_file_cache_t *ngx_open_file_cache_init(ngx_pool_t *pool , ngx_uint_t max ,
                                                time_t inactive ) ;
#line 24 "src/core/ngx_syslog.h"
char *ngx_syslog_process_conf(ngx_conf_t *cf , ngx_syslog_peer_t *peer ) ;
#line 25
u_char *ngx_syslog_add_header(ngx_syslog_peer_t *peer , u_char *buf ) ;
#line 28
ssize_t ngx_syslog_send(ngx_syslog_peer_t *peer , u_char *buf , size_t len ) ;
#line 93 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_write(ngx_http_request_t *r , ngx_http_log_t *log , u_char *buf ,
                               size_t len ) ;
#line 95
static ssize_t ngx_http_log_script_write(ngx_http_request_t *r , ngx_http_log_script_t *script ,
                                         u_char **name , u_char *buf , size_t len ) ;
#line 99
static ssize_t ngx_http_log_gzip(ngx_fd_t fd , u_char *buf , size_t len , ngx_int_t level ,
                                 ngx_log_t *log ) ;
#line 102
static void *ngx_http_log_gzip_alloc(void *opaque , u_int items , u_int size ) ;
#line 103
static void ngx_http_log_gzip_free(void *opaque , void *address ) ;
#line 106
static void ngx_http_log_flush(ngx_open_file_t *file , ngx_log_t *log ) ;
#line 107
static void ngx_http_log_flush_handler(ngx_event_t *ev ) ;
#line 109
static u_char *ngx_http_log_pipe(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 111
static u_char *ngx_http_log_time(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 113
static u_char *ngx_http_log_iso8601(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 115
static u_char *ngx_http_log_msec(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 117
static u_char *ngx_http_log_request_time(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 119
static u_char *ngx_http_log_status(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 121
static u_char *ngx_http_log_bytes_sent(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 123
static u_char *ngx_http_log_body_bytes_sent(ngx_http_request_t *r , u_char *buf ,
                                            ngx_http_log_op_t *op ) ;
#line 125
static u_char *ngx_http_log_request_length(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 128
static ngx_int_t ngx_http_log_variable_compile(ngx_conf_t *cf , ngx_http_log_op_t *op ,
                                               ngx_str_t *value , ngx_uint_t json ) ;
#line 130
static size_t ngx_http_log_variable_getlen(ngx_http_request_t *r , uintptr_t data ) ;
#line 132
static u_char *ngx_http_log_variable(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 134
static uintptr_t ngx_http_log_escape(u_char *dst , u_char *src , size_t size ) ;
#line 135
static size_t ngx_http_log_json_variable_getlen(ngx_http_request_t *r , uintptr_t data ) ;
#line 137
static u_char *ngx_http_log_json_variable(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) ;
#line 141
static void *ngx_http_log_create_main_conf(ngx_conf_t *cf ) ;
#line 142
static void *ngx_http_log_create_loc_conf(ngx_conf_t *cf ) ;
#line 143
static char *ngx_http_log_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 145
static char *ngx_http_log_set_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 147
static char *ngx_http_log_set_format(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 149
static char *ngx_http_log_compile_format(ngx_conf_t *cf , ngx_array_t *flushes , ngx_array_t *ops ,
                                         ngx_array_t *args___0 , ngx_uint_t s ) ;
#line 151
static char *ngx_http_log_open_file_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 153
static ngx_int_t ngx_http_log_init(ngx_conf_t *cf ) ;
#line 156 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ngx_command_t ngx_http_log_commands[4]  = {      {{sizeof("log_format") - 1UL, (u_char *)"log_format"}, (ngx_uint_t )33558528,
      & ngx_http_log_set_format, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("access_log") - 1UL, (u_char *)"access_log"}, (ngx_uint_t )3456108544U,
      & ngx_http_log_set_log, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("open_log_file_cache") - 1UL, (u_char *)"open_log_file_cache"}, (ngx_uint_t )234881054,
      & ngx_http_log_open_file_cache, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 184 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ngx_http_module_t ngx_http_log_module_ctx  = 
#line 184
     {(ngx_int_t (*)(ngx_conf_t *cf ))((void *)0), & ngx_http_log_init, & ngx_http_log_create_main_conf,
    (char *(*)(ngx_conf_t *cf , void *conf ))((void *)0), (void *(*)(ngx_conf_t *cf ))((void *)0),
    (char *(*)(ngx_conf_t *cf , void *prev , void *conf ))((void *)0), & ngx_http_log_create_loc_conf,
    & ngx_http_log_merge_loc_conf};
#line 199 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
ngx_module_t ngx_http_log_module  = 
#line 199
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_log_module_ctx),
    ngx_http_log_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 215 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ngx_str_t ngx_http_access_log  =    {sizeof("logs/access.log") - 1UL, (u_char *)"logs/access.log"};
#line 218 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ngx_str_t ngx_http_combined_fmt  =    {sizeof("$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\"") - 1UL,
    (u_char *)"$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\""};
#line 224 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ngx_http_log_var_t ngx_http_log_vars[10]  = 
#line 224
  {      {{sizeof("pipe") - 1UL, (u_char *)"pipe"}, (size_t )1, & ngx_http_log_pipe}, 
        {{sizeof("time_local") - 1UL, (u_char *)"time_local"}, sizeof("28/Sep/1970:12:00:00 +0600") - 1UL,
      & ngx_http_log_time}, 
        {{sizeof("time_iso8601") - 1UL, (u_char *)"time_iso8601"}, sizeof("1970-09-28T12:00:00+06:00") - 1UL,
      & ngx_http_log_iso8601}, 
        {{sizeof("msec") - 1UL, (u_char *)"msec"}, (sizeof("-9223372036854775808") - 1UL) + 4UL,
      & ngx_http_log_msec}, 
        {{sizeof("request_time") - 1UL, (u_char *)"request_time"}, (sizeof("-9223372036854775808") - 1UL) + 4UL,
      & ngx_http_log_request_time}, 
        {{sizeof("status") - 1UL, (u_char *)"status"}, sizeof("-9223372036854775808") - 1UL,
      & ngx_http_log_status}, 
        {{sizeof("bytes_sent") - 1UL, (u_char *)"bytes_sent"}, sizeof("-9223372036854775808") - 1UL,
      & ngx_http_log_bytes_sent}, 
        {{sizeof("body_bytes_sent") - 1UL, (u_char *)"body_bytes_sent"}, sizeof("-9223372036854775808") - 1UL,
      & ngx_http_log_body_bytes_sent}, 
        {{sizeof("request_length") - 1UL, (u_char *)"request_length"}, sizeof("-9223372036854775808") - 1UL,
      & ngx_http_log_request_length}, 
        {{(size_t )0, (u_char *)((void *)0)}, (size_t )0, (u_char *(*)(ngx_http_request_t *r ,
                                                                    u_char *buf ,
                                                                    ngx_http_log_op_t *op ))((void *)0)}};
#line 244 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ngx_int_t ngx_http_log_handler(ngx_http_request_t *r ) 
{ 
  u_char *line ;
  u_char *p ;
  size_t len ;
  size_t size ;
  ssize_t n ;
  ngx_str_t val ;
  ngx_uint_t i ;
  ngx_uint_t l ;
  ngx_http_log_t *log ;
  ngx_http_log_op_t *op ;
  ngx_http_log_buf_t *buffer___0 ;
  ngx_http_log_loc_conf_t *lcf ;
  ngx_int_t tmp ;
  size_t tmp___0 ;
  u_char *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 260
  lcf = (ngx_http_log_loc_conf_t *)*(r->loc_conf + ngx_http_log_module.ctx_index);
#line 262
  if (lcf->off) {
#line 263
    return ((ngx_int_t )0);
  }
#line 266
  log = (ngx_http_log_t *)(lcf->logs)->elts;
#line 267
  l = (ngx_uint_t )0;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (l < (lcf->logs)->nelts)) {
#line 267
      goto while_break;
    }
#line 269
    if ((log + l)->filter) {
      {
#line 270
      tmp = ngx_http_complex_value(r, (log + l)->filter, & val);
      }
#line 270
      if (tmp != 0L) {
#line 271
        return ((ngx_int_t )-1);
      }
#line 274
      if (val.len == 0UL) {
#line 275
        goto __Cont;
      } else
#line 274
      if (val.len == 1UL) {
#line 274
        if ((int )*(val.data + 0) == 48) {
#line 275
          goto __Cont;
        }
      }
    }
#line 279
    if (ngx_cached_time->sec == (time_t volatile   )(log + l)->disk_full_time) {
#line 287
      goto __Cont;
    }
    {
#line 290
    ngx_http_script_flush_no_cacheable_variables(r, ((log + l)->format)->flushes);
#line 292
    len = (size_t )0;
#line 293
    op = (ngx_http_log_op_t *)(((log + l)->format)->ops)->elts;
#line 294
    i = (ngx_uint_t )0;
    }
    {
#line 294
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 294
      if (! (i < (((log + l)->format)->ops)->nelts)) {
#line 294
        goto while_break___0;
      }
#line 295
      if ((op + i)->len == 0UL) {
        {
#line 296
        tmp___0 = (*((op + i)->getlen))(r, (op + i)->data);
#line 296
        len += tmp___0;
        }
      } else {
#line 299
        len += (op + i)->len;
      }
#line 294
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 303
    if ((log + l)->syslog_peer) {
#line 306
      len += ((((sizeof("<255>Jan 01 00:00:00 ") - 1UL) + (unsigned long )ngx_cycle->hostname.len) + 1UL) + ((log + l)->syslog_peer)->tag.len) + 2UL;
#line 310
      goto alloc_line;
    }
#line 313
    len ++;
#line 315
    if ((log + l)->file) {
#line 315
      buffer___0 = (ngx_http_log_buf_t *)((log + l)->file)->data;
    } else {
#line 315
      buffer___0 = (ngx_http_log_buf_t *)((void *)0);
    }
#line 317
    if (buffer___0) {
#line 319
      if (len > (size_t )(buffer___0->last - buffer___0->pos)) {
        {
#line 321
        ngx_http_log_write(r, log + l, buffer___0->start, (size_t )(buffer___0->pos - buffer___0->start));
#line 324
        buffer___0->pos = buffer___0->start;
        }
      }
#line 327
      if (len <= (size_t )(buffer___0->last - buffer___0->pos)) {
#line 329
        p = buffer___0->pos;
#line 331
        if (buffer___0->event) {
#line 331
          if ((unsigned long )p == (unsigned long )buffer___0->start) {
            {
#line 332
            ngx_event_add_timer(buffer___0->event, buffer___0->flush);
            }
          }
        }
#line 335
        i = (ngx_uint_t )0;
        {
#line 335
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 335
          if (! (i < (((log + l)->format)->ops)->nelts)) {
#line 335
            goto while_break___1;
          }
          {
#line 336
          p = (*((op + i)->run))(r, p, op + i);
#line 335
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 339
        tmp___1 = p;
#line 339
        p ++;
#line 339
        *tmp___1 = (u_char )'\n';
#line 341
        buffer___0->pos = p;
#line 343
        goto __Cont;
      }
#line 346
      if (buffer___0->event) {
#line 346
        if ((buffer___0->event)->timer_set) {
          {
#line 347
          ngx_event_del_timer(buffer___0->event);
          }
        }
      }
    }
    alloc_line: 
    {
#line 353
    tmp___2 = ngx_pnalloc(r->pool, len);
#line 353
    line = (u_char *)tmp___2;
    }
#line 354
    if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 355
      return ((ngx_int_t )-1);
    }
#line 358
    p = line;
#line 360
    if ((log + l)->syslog_peer) {
      {
#line 361
      p = ngx_syslog_add_header((log + l)->syslog_peer, line);
      }
    }
#line 364
    i = (ngx_uint_t )0;
    {
#line 364
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 364
      if (! (i < (((log + l)->format)->ops)->nelts)) {
#line 364
        goto while_break___2;
      }
      {
#line 365
      p = (*((op + i)->run))(r, p, op + i);
#line 364
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 368
    if ((log + l)->syslog_peer) {
      {
#line 370
      size = (size_t )(p - line);
#line 372
      n = ngx_syslog_send((log + l)->syslog_peer, line, size);
      }
#line 374
      if (n < 0L) {
#line 375
        if (((r->connection)->log)->log_level >= 5UL) {
          {
#line 375
          ngx_log_error_core((ngx_uint_t )5, (r->connection)->log, 0, "send() to syslog failed");
          }
        }
      } else
#line 378
      if ((size_t )n != size) {
#line 379
        if (((r->connection)->log)->log_level >= 5UL) {
          {
#line 379
          ngx_log_error_core((ngx_uint_t )5, (r->connection)->log, 0, "send() to syslog has written only %z of %uz",
                             n, size);
          }
        }
      }
#line 384
      goto __Cont;
    }
    {
#line 387
    tmp___3 = p;
#line 387
    p ++;
#line 387
    *tmp___3 = (u_char )'\n';
#line 389
    ngx_http_log_write(r, log + l, line, (size_t )(p - line));
    }
    __Cont: /* CIL Label */ 
#line 267
    l ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 392
  return ((ngx_int_t )0);
}
}
#line 396 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_write(ngx_http_request_t *r , ngx_http_log_t *log , u_char *buf ,
                               size_t len ) 
{ 
  u_char *name ;
  time_t now ;
  ssize_t n ;
  ngx_err_t err ;
  ngx_http_log_buf_t *buffer___0 ;
  int *tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 408
  if ((unsigned long )log->script == (unsigned long )((void *)0)) {
#line 409
    name = (log->file)->name.data;
#line 412
    buffer___0 = (ngx_http_log_buf_t *)(log->file)->data;
#line 414
    if (buffer___0) {
#line 414
      if (buffer___0->gzip) {
        {
#line 415
        n = ngx_http_log_gzip((log->file)->fd, buf, len, buffer___0->gzip, (r->connection)->log);
        }
      } else {
        {
#line 418
        n = ngx_write_fd((log->file)->fd, (void *)buf, len);
        }
      }
    } else {
      {
#line 418
      n = ngx_write_fd((log->file)->fd, (void *)buf, len);
      }
    }
  } else {
    {
#line 425
    name = (u_char *)((void *)0);
#line 426
    n = ngx_http_log_script_write(r, log->script, & name, buf, len);
    }
  }
#line 429
  if (n == (ssize_t )len) {
#line 430
    return;
  }
#line 433
  now = (time_t )ngx_cached_time->sec;
#line 435
  if (n == -1L) {
    {
#line 436
    tmp = __errno_location();
#line 436
    err = *tmp;
    }
#line 438
    if (err == 28) {
#line 439
      log->disk_full_time = now;
    }
#line 442
    if (now - log->error_log_time > 59L) {
#line 443
      if (((r->connection)->log)->log_level >= 2UL) {
        {
#line 443
        ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, err, "write() to \"%s\" failed",
                           name);
        }
      }
#line 446
      log->error_log_time = now;
    }
#line 449
    return;
  }
#line 452
  if (now - log->error_log_time > 59L) {
#line 453
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 453
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "write() to \"%s\" was incomplete: %z of %uz",
                         name, n, len);
      }
    }
#line 457
    log->error_log_time = now;
  }
#line 459
  return;
}
}
#line 462 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ssize_t ngx_http_log_script_write(ngx_http_request_t *r , ngx_http_log_script_t *script ,
                                         u_char **name , u_char *buf , size_t len ) 
{ 
  size_t root ;
  ssize_t n ;
  ngx_str_t log ;
  ngx_str_t path ;
  ngx_open_file_info_t of ;
  ngx_http_log_loc_conf_t *llcf ;
  ngx_http_core_loc_conf_t *clcf ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;
  int *tmp___4 ;
  ngx_int_t tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 473
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 475
  if (! r->root_tested) {
    {
#line 479
    tmp = ngx_http_map_uri_to_path(r, & path, & root, (size_t )0);
    }
#line 479
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 481
      return ((ssize_t )len);
    }
    {
#line 484
    *(path.data + root) = (u_char )'\000';
#line 486
    memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 488
    of.valid = clcf->open_file_cache_valid;
#line 489
    of.min_uses = clcf->open_file_cache_min_uses;
#line 490
    of.test_dir = 1U;
#line 491
    of.test_only = 1U;
#line 492
    of.errors = (unsigned int )clcf->open_file_cache_errors;
#line 493
    of.events = (unsigned int )clcf->open_file_cache_events;
#line 495
    tmp___0 = ngx_http_set_disable_symlinks(r, clcf, & path, & of);
    }
#line 495
    if (tmp___0 != 0L) {
#line 497
      return ((ssize_t )len);
    }
    {
#line 500
    tmp___1 = ngx_open_cached_file(clcf->open_file_cache, & path, & of, r->pool);
    }
#line 500
    if (tmp___1 != 0L) {
#line 503
      if (of.err == 0) {
#line 505
        return ((ssize_t )len);
      }
#line 508
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 508
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, of.err, "testing \"%s\" existence failed",
                           path.data);
        }
      }
#line 512
      return ((ssize_t )len);
    }
#line 515
    if (! of.is_dir) {
#line 516
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 516
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 20, "testing \"%s\" existence failed",
                           path.data);
        }
      }
#line 520
      return ((ssize_t )len);
    }
  }
  {
#line 524
  tmp___2 = ngx_http_script_run(r, & log, (script->lengths)->elts, (size_t )1, (script->values)->elts);
  }
#line 524
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 529
    return ((ssize_t )len);
  }
  {
#line 532
  *(log.data + (log.len - 1UL)) = (u_char )'\000';
#line 533
  *name = log.data;
#line 538
  llcf = (ngx_http_log_loc_conf_t *)*(r->loc_conf + ngx_http_log_module.ctx_index);
#line 540
  memset((void *)(& of), 0, sizeof(ngx_open_file_info_t ));
#line 542
  of.log = 1U;
#line 543
  of.valid = llcf->open_file_cache_valid;
#line 544
  of.min_uses = llcf->open_file_cache_min_uses;
#line 545
  of.directio = (off_t )9223372036854775807LL;
#line 547
  tmp___3 = ngx_http_set_disable_symlinks(r, clcf, & log, & of);
  }
#line 547
  if (tmp___3 != 0L) {
#line 549
    return ((ssize_t )len);
  }
  {
#line 552
  tmp___5 = ngx_open_cached_file(llcf->open_file_cache, & log, & of, r->pool);
  }
#line 552
  if (tmp___5 != 0L) {
#line 555
    if (of.err == 0) {
#line 557
      return ((ssize_t )len);
    }
#line 560
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 560
      tmp___4 = __errno_location();
#line 560
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, *tmp___4, "%s \"%s\" failed",
                         of.failed, log.data);
      }
    }
#line 563
    return ((ssize_t )len);
  }
  {
#line 569
  n = ngx_write_fd(of.fd, (void *)buf, len);
  }
#line 571
  return (n);
}
}
#line 577 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ssize_t ngx_http_log_gzip(ngx_fd_t fd , u_char *buf , size_t len , ngx_int_t level ,
                                 ngx_log_t *log ) 
{ 
  int rc ;
  int wbits ;
  int memlevel ;
  u_char *out ;
  size_t size ;
  ssize_t n ;
  z_stream zstream ;
  ngx_err_t err ;
  ngx_pool_t *pool ;
  void *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 589
  wbits = 15;
#line 590
  memlevel = 8;
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! ((ssize_t )len < (ssize_t )((1 << (wbits - 1)) - 262))) {
#line 592
      goto while_break;
    }
#line 593
    wbits --;
#line 594
    memlevel --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 602
  size = (((len + ((len + 7UL) >> 3)) + ((len + 63UL) >> 6)) + 5UL) + 18UL;
#line 604
  memset((void *)(& zstream), 0, sizeof(z_stream ));
#line 606
  pool = ngx_create_pool((size_t )256, log);
  }
#line 607
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 609
    return ((ssize_t )len);
  }
  {
#line 612
  pool->log = log;
#line 614
  zstream.zalloc = & ngx_http_log_gzip_alloc;
#line 615
  zstream.zfree = & ngx_http_log_gzip_free;
#line 616
  zstream.opaque = (voidpf )pool;
#line 618
  tmp = ngx_pnalloc(pool, size);
#line 618
  out = (u_char *)tmp;
  }
#line 619
  if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 620
    goto done;
  }
  {
#line 623
  zstream.next_in = buf;
#line 624
  zstream.avail_in = (uInt )len;
#line 625
  zstream.next_out = out;
#line 626
  zstream.avail_out = (uInt )size;
#line 628
  rc = deflateInit2_(& zstream, (int )level, 8, wbits + 16, memlevel, 0, "1.2.11",
                     (int )sizeof(z_stream ));
  }
#line 631
  if (rc != 0) {
#line 632
    if (log->log_level >= 2UL) {
      {
#line 632
      ngx_log_error_core((ngx_uint_t )2, log, 0, "deflateInit2() failed: %d", rc);
      }
    }
#line 633
    goto done;
  }
  {
#line 641
  rc = deflate(& zstream, 4);
  }
#line 643
  if (rc != 1) {
#line 644
    if (log->log_level >= 2UL) {
      {
#line 644
      ngx_log_error_core((ngx_uint_t )2, log, 0, "deflate(Z_FINISH) failed: %d", rc);
      }
    }
#line 646
    goto done;
  }
  {
#line 655
  size -= (size_t )zstream.avail_out;
#line 657
  rc = deflateEnd(& zstream);
  }
#line 659
  if (rc != 0) {
#line 660
    if (log->log_level >= 2UL) {
      {
#line 660
      ngx_log_error_core((ngx_uint_t )2, log, 0, "deflateEnd() failed: %d", rc);
      }
    }
#line 661
    goto done;
  }
  {
#line 664
  n = ngx_write_fd(fd, (void *)out, size);
  }
#line 666
  if (n != (ssize_t )size) {
#line 667
    if (n == -1L) {
      {
#line 667
      tmp___0 = __errno_location();
#line 667
      err = *tmp___0;
      }
    } else {
#line 667
      err = 0;
    }
    {
#line 669
    ngx_destroy_pool(pool);
#line 671
    tmp___1 = __errno_location();
#line 671
    *tmp___1 = err;
    }
#line 672
    return ((ssize_t )-1);
  }
  done: 
  {
#line 677
  ngx_destroy_pool(pool);
  }
#line 680
  return ((ssize_t )len);
}
}
#line 684 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static void *ngx_http_log_gzip_alloc(void *opaque , u_int items , u_int size ) 
{ 
  ngx_pool_t *pool ;
  void *tmp ;

  {
  {
#line 687
  pool = (ngx_pool_t *)opaque;
#line 692
  tmp = ngx_palloc(pool, (size_t )(items * size));
  }
#line 692
  return (tmp);
}
}
#line 696 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_gzip_free(void *opaque , void *address ) 
{ 


  {
#line 704
  return;
}
}
#line 709 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_flush(ngx_open_file_t *file , ngx_log_t *log ) 
{ 
  size_t len ;
  ssize_t n ;
  ngx_http_log_buf_t *buffer___0 ;
  int *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 716
  buffer___0 = (ngx_http_log_buf_t *)file->data;
#line 718
  len = (size_t )(buffer___0->pos - buffer___0->start);
#line 720
  if (len == 0UL) {
#line 721
    return;
  }
#line 725
  if (buffer___0->gzip) {
    {
#line 726
    n = ngx_http_log_gzip(file->fd, buffer___0->start, len, buffer___0->gzip, log);
    }
  } else {
    {
#line 728
    n = ngx_write_fd(file->fd, (void *)buffer___0->start, len);
    }
  }
#line 734
  if (n == -1L) {
#line 735
    if (log->log_level >= 2UL) {
      {
#line 735
      tmp = __errno_location();
#line 735
      ngx_log_error_core((ngx_uint_t )2, log, *tmp, "write() to \"%s\" failed", file->name.data);
      }
    }
  } else
#line 739
  if ((size_t )n != len) {
#line 740
    if (log->log_level >= 2UL) {
      {
#line 740
      ngx_log_error_core((ngx_uint_t )2, log, 0, "write() to \"%s\" was incomplete: %z of %uz",
                         file->name.data, n, len);
      }
    }
  }
#line 745
  buffer___0->pos = buffer___0->start;
#line 747
  if (buffer___0->event) {
#line 747
    if ((buffer___0->event)->timer_set) {
      {
#line 748
      ngx_event_del_timer(buffer___0->event);
      }
    }
  }
#line 750
  return;
}
}
#line 753 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static void ngx_http_log_flush_handler(ngx_event_t *ev ) 
{ 


  {
  {
#line 759
  ngx_http_log_flush((ngx_open_file_t *)ev->data, ev->log);
  }
#line 760
  return;
}
}
#line 763 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_copy_short(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  size_t len ;
  uintptr_t data ;
  u_char *tmp ;
  size_t tmp___0 ;

  {
#line 770
  len = op->len;
#line 771
  data = op->data;
  {
#line 773
  while (1) {
    while_continue: /* CIL Label */ ;
#line 773
    tmp___0 = len;
#line 773
    len --;
#line 773
    if (! tmp___0) {
#line 773
      goto while_break;
    }
#line 774
    tmp = buf;
#line 774
    buf ++;
#line 774
    *tmp = (u_char )(data & 255UL);
#line 775
    data >>= 8;
  }
  while_break: /* CIL Label */ ;
  }
#line 778
  return (buf);
}
}
#line 782 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_copy_long(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  void *tmp ;

  {
  {
#line 786
  tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)((u_char *)op->data),
               op->len);
  }
#line 786
  return ((u_char *)tmp + op->len);
}
}
#line 790 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_pipe(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 


  {
#line 793
  if (r->pipeline) {
#line 794
    *buf = (u_char )'p';
  } else {
#line 796
    *buf = (u_char )'.';
  }
#line 799
  return (buf + 1);
}
}
#line 803 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_time(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  void *tmp ;

  {
  {
#line 806
  tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)ngx_cached_http_log_time.data,
               (size_t )ngx_cached_http_log_time.len);
  }
#line 806
  return ((u_char *)tmp + ngx_cached_http_log_time.len);
}
}
#line 810 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_iso8601(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  void *tmp ;

  {
  {
#line 813
  tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)ngx_cached_http_log_iso8601.data,
               (size_t )ngx_cached_http_log_iso8601.len);
  }
#line 813
  return ((u_char *)tmp + ngx_cached_http_log_iso8601.len);
}
}
#line 817 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_msec(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_time_t *tp ;
  u_char *tmp ;
  char *__cil_tmp6 ;

  {
  {
#line 822
  tp = (ngx_time_t *)ngx_cached_time;
#line 824
  tmp = ngx_sprintf(buf, "%T.%03M", tp->sec, tp->msec);
  }
#line 824
  return (tmp);
}
}
#line 828 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_request_time(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_time_t *tp ;
  ngx_msec_int_t ms ;
  u_char *tmp ;
  char *__cil_tmp7 ;

  {
#line 835
  tp = (ngx_time_t *)ngx_cached_time;
#line 837
  ms = (ngx_msec_int_t )((ngx_uint_t )((tp->sec - r->start_sec) * 1000L) + (tp->msec - r->start_msec));
#line 839
  if (ms < 0L) {
#line 839
    ms = (ngx_msec_int_t )0;
  } else {
#line 839
    ms = ms;
  }
  {
#line 841
  tmp = ngx_sprintf(buf, "%T.%03M", ms / 1000L, ms % 1000L);
  }
#line 841
  return (tmp);
}
}
#line 845 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_status(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_uint_t status ;
  u_char *tmp ;
  char *__cil_tmp6 ;

  {
#line 850
  if (r->err_status) {
#line 851
    status = r->err_status;
  } else
#line 853
  if (r->headers_out.status) {
#line 854
    status = r->headers_out.status;
  } else
#line 856
  if (r->http_version == 9UL) {
#line 857
    status = (ngx_uint_t )9;
  } else {
#line 860
    status = (ngx_uint_t )0;
  }
  {
#line 863
  tmp = ngx_sprintf(buf, "%03ui", status);
  }
#line 863
  return (tmp);
}
}
#line 867 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_bytes_sent(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  u_char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 871
  tmp = ngx_sprintf(buf, "%O", (r->connection)->sent);
  }
#line 871
  return (tmp);
}
}
#line 880 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_body_bytes_sent(ngx_http_request_t *r , u_char *buf ,
                                            ngx_http_log_op_t *op ) 
{ 
  off_t length ;
  u_char *tmp ;
  char *__cil_tmp6 ;

  {
#line 886
  length = (off_t )((size_t )(r->connection)->sent - r->header_size);
#line 888
  if (length > 0L) {
    {
#line 889
    tmp = ngx_sprintf(buf, "%O", length);
    }
#line 889
    return (tmp);
  }
#line 892
  *buf = (u_char )'0';
#line 894
  return (buf + 1);
}
}
#line 898 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_request_length(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  u_char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 902
  tmp = ngx_sprintf(buf, "%O", r->request_length);
  }
#line 902
  return (tmp);
}
}
#line 906 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ngx_int_t ngx_http_log_variable_compile(ngx_conf_t *cf , ngx_http_log_op_t *op ,
                                               ngx_str_t *value , ngx_uint_t json ) 
{ 
  ngx_int_t index___0 ;

  {
  {
#line 912
  index___0 = ngx_http_get_variable_index(cf, value);
  }
#line 913
  if (index___0 == -1L) {
#line 914
    return ((ngx_int_t )-1);
  }
#line 917
  op->len = (size_t )0;
#line 919
  if (json) {
#line 920
    op->getlen = & ngx_http_log_json_variable_getlen;
#line 921
    op->run = & ngx_http_log_json_variable;
  } else {
#line 924
    op->getlen = & ngx_http_log_variable_getlen;
#line 925
    op->run = & ngx_http_log_variable;
  }
#line 928
  op->data = (uintptr_t )index___0;
#line 930
  return ((ngx_int_t )0);
}
}
#line 934 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static size_t ngx_http_log_variable_getlen(ngx_http_request_t *r , uintptr_t data ) 
{ 
  uintptr_t len ;
  ngx_http_variable_value_t *value ;

  {
  {
#line 940
  value = ngx_http_get_indexed_variable(r, data);
  }
#line 942
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 943
    return ((size_t )1);
  } else
#line 942
  if (value->not_found) {
#line 943
    return ((size_t )1);
  }
  {
#line 946
  len = ngx_http_log_escape((u_char *)((void *)0), value->data, (size_t )value->len);
  }
#line 948
  if (len) {
#line 948
    value->escape = 1U;
  } else {
#line 948
    value->escape = 0U;
  }
#line 950
  return ((uintptr_t )value->len + len * 3UL);
}
}
#line 954 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_variable(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_http_variable_value_t *value ;
  void *tmp ;
  uintptr_t tmp___0 ;

  {
  {
#line 959
  value = ngx_http_get_indexed_variable(r, op->data);
  }
#line 961
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 962
    *buf = (u_char )'-';
#line 963
    return (buf + 1);
  } else
#line 961
  if (value->not_found) {
#line 962
    *buf = (u_char )'-';
#line 963
    return (buf + 1);
  }
#line 966
  if (value->escape == 0U) {
    {
#line 967
    tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)value->data,
                 (size_t )value->len);
    }
#line 967
    return ((u_char *)tmp + value->len);
  } else {
    {
#line 970
    tmp___0 = ngx_http_log_escape(buf, value->data, (size_t )value->len);
    }
#line 970
    return ((u_char *)tmp___0);
  }
}
}
#line 979 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char hex[17]  = 
#line 979
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'A',      (u_char )'B', 
        (u_char )'C',      (u_char )'D',      (u_char )'E',      (u_char )'F', 
        (u_char )'\000'};
#line 981 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static uint32_t escape[8]  = 
#line 981
  {      4294967295U,      (uint32_t )4,      (uint32_t )268435456,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 975 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static uintptr_t ngx_http_log_escape(u_char *dst , u_char *src , size_t size ) 
{ 
  ngx_uint_t n ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;

  {
#line 1000
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1004
    n = (ngx_uint_t )0;
    {
#line 1006
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1006
      if (! size) {
#line 1006
        goto while_break;
      }
#line 1007
      if (escape[(int )*src >> 5] & (1U << ((int )*src & 31))) {
#line 1008
        n ++;
      }
#line 1010
      src ++;
#line 1011
      size --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1014
    return (n);
  }
  {
#line 1017
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1017
    if (! size) {
#line 1017
      goto while_break___0;
    }
#line 1018
    if (escape[(int )*src >> 5] & (1U << ((int )*src & 31))) {
#line 1019
      tmp = dst;
#line 1019
      dst ++;
#line 1019
      *tmp = (u_char )'\\';
#line 1020
      tmp___0 = dst;
#line 1020
      dst ++;
#line 1020
      *tmp___0 = (u_char )'x';
#line 1021
      tmp___1 = dst;
#line 1021
      dst ++;
#line 1021
      *tmp___1 = hex[(int )*src >> 4];
#line 1022
      tmp___2 = dst;
#line 1022
      dst ++;
#line 1022
      *tmp___2 = hex[(int )*src & 15];
#line 1023
      src ++;
    } else {
#line 1026
      tmp___3 = dst;
#line 1026
      dst ++;
#line 1026
      tmp___4 = src;
#line 1026
      src ++;
#line 1026
      *tmp___3 = *tmp___4;
    }
#line 1028
    size --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1031
  return ((uintptr_t )dst);
}
}
#line 1035 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static size_t ngx_http_log_json_variable_getlen(ngx_http_request_t *r , uintptr_t data ) 
{ 
  uintptr_t len ;
  ngx_http_variable_value_t *value ;

  {
  {
#line 1041
  value = ngx_http_get_indexed_variable(r, data);
  }
#line 1043
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1044
    return ((size_t )0);
  } else
#line 1043
  if (value->not_found) {
#line 1044
    return ((size_t )0);
  }
  {
#line 1047
  len = ngx_escape_json((u_char *)((void *)0), value->data, (size_t )value->len);
  }
#line 1049
  if (len) {
#line 1049
    value->escape = 1U;
  } else {
#line 1049
    value->escape = 0U;
  }
#line 1051
  return ((uintptr_t )value->len + len);
}
}
#line 1055 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static u_char *ngx_http_log_json_variable(ngx_http_request_t *r , u_char *buf , ngx_http_log_op_t *op ) 
{ 
  ngx_http_variable_value_t *value ;
  void *tmp ;
  uintptr_t tmp___0 ;

  {
  {
#line 1061
  value = ngx_http_get_indexed_variable(r, op->data);
  }
#line 1063
  if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1064
    return (buf);
  } else
#line 1063
  if (value->not_found) {
#line 1064
    return (buf);
  }
#line 1067
  if (value->escape == 0U) {
    {
#line 1068
    tmp = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)value->data,
                 (size_t )value->len);
    }
#line 1068
    return ((u_char *)tmp + value->len);
  } else {
    {
#line 1071
    tmp___0 = ngx_escape_json(buf, value->data, (size_t )value->len);
    }
#line 1071
    return ((u_char *)tmp___0);
  }
}
}
#line 1076 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static void *ngx_http_log_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_log_main_conf_t *conf ;
  ngx_http_log_fmt_t *fmt ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1083
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_main_conf_t ));
#line 1083
  conf = (ngx_http_log_main_conf_t *)tmp;
  }
#line 1084
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1085
    return ((void *)0);
  }
  {
#line 1088
  tmp___0 = ngx_array_init(& conf->formats, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_log_fmt_t ));
  }
#line 1088
  if (tmp___0 != 0L) {
#line 1091
    return ((void *)0);
  }
  {
#line 1094
  tmp___1 = ngx_array_push(& conf->formats);
#line 1094
  fmt = (ngx_http_log_fmt_t *)tmp___1;
  }
#line 1095
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 1096
    return ((void *)0);
  }
  {
#line 1099
  fmt->name.len = sizeof("combined") - 1UL;
#line 1099
  fmt->name.data = (u_char *)"combined";
#line 1101
  fmt->flushes = (ngx_array_t *)((void *)0);
#line 1103
  fmt->ops = ngx_array_create(cf->pool, (ngx_uint_t )16, sizeof(ngx_http_log_op_t ));
  }
#line 1104
  if ((unsigned long )fmt->ops == (unsigned long )((void *)0)) {
#line 1105
    return ((void *)0);
  }
#line 1108
  return ((void *)conf);
}
}
#line 1112 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static void *ngx_http_log_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_log_loc_conf_t *conf ;
  void *tmp ;

  {
  {
#line 1117
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_loc_conf_t ));
#line 1117
  conf = (ngx_http_log_loc_conf_t *)tmp;
  }
#line 1118
  if ((unsigned long )conf == (unsigned long )((void *)0)) {
#line 1119
    return ((void *)0);
  }
#line 1122
  conf->open_file_cache = (ngx_open_file_cache_t *)((void *)-1);
#line 1124
  return ((void *)conf);
}
}
#line 1128 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_log_loc_conf_t *prev ;
  ngx_http_log_loc_conf_t *conf ;
  ngx_http_log_t *log ;
  ngx_http_log_fmt_t *fmt ;
  ngx_http_log_main_conf_t *lmcf ;
  void *tmp ;

  {
#line 1131
  prev = (ngx_http_log_loc_conf_t *)parent;
#line 1132
  conf = (ngx_http_log_loc_conf_t *)child;
#line 1138
  if ((unsigned long )conf->open_file_cache == (unsigned long )((void *)-1)) {
#line 1140
    conf->open_file_cache = prev->open_file_cache;
#line 1141
    conf->open_file_cache_valid = prev->open_file_cache_valid;
#line 1142
    conf->open_file_cache_min_uses = prev->open_file_cache_min_uses;
#line 1144
    if ((unsigned long )conf->open_file_cache == (unsigned long )((void *)-1)) {
#line 1145
      conf->open_file_cache = (ngx_open_file_cache_t *)((void *)0);
    }
  }
#line 1149
  if (conf->logs) {
#line 1150
    return ((char *)((void *)0));
  } else
#line 1149
  if (conf->off) {
#line 1150
    return ((char *)((void *)0));
  }
#line 1153
  conf->logs = prev->logs;
#line 1154
  conf->off = prev->off;
#line 1156
  if (conf->logs) {
#line 1157
    return ((char *)((void *)0));
  } else
#line 1156
  if (conf->off) {
#line 1157
    return ((char *)((void *)0));
  }
  {
#line 1160
  conf->logs = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_http_log_t ));
  }
#line 1161
  if ((unsigned long )conf->logs == (unsigned long )((void *)0)) {
#line 1162
    return ((char *)((void *)-1));
  }
  {
#line 1165
  tmp = ngx_array_push(conf->logs);
#line 1165
  log = (ngx_http_log_t *)tmp;
  }
#line 1166
  if ((unsigned long )log == (unsigned long )((void *)0)) {
#line 1167
    return ((char *)((void *)-1));
  }
  {
#line 1170
  memset((void *)log, 0, sizeof(ngx_http_log_t ));
#line 1172
  log->file = ngx_conf_open_file(cf->cycle, & ngx_http_access_log);
  }
#line 1173
  if ((unsigned long )log->file == (unsigned long )((void *)0)) {
#line 1174
    return ((char *)((void *)-1));
  }
#line 1177
  lmcf = (ngx_http_log_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_log_module.ctx_index);
#line 1178
  fmt = (ngx_http_log_fmt_t *)lmcf->formats.elts;
#line 1181
  log->format = fmt + 0;
#line 1182
  lmcf->combined_used = (ngx_uint_t )1;
#line 1184
  return ((char *)((void *)0));
}
}
#line 1188 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_set_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_log_loc_conf_t *llcf ;
  ssize_t size ;
  ngx_int_t gzip ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_msec_t flush ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_str_t s ;
  ngx_http_log_t *log ;
  ngx_syslog_peer_t *peer ;
  ngx_http_log_buf_t *buffer___0 ;
  ngx_http_log_fmt_t *fmt ;
  ngx_http_log_main_conf_t *lmcf ;
  ngx_http_script_compile_t sc ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;
  int tmp___7 ;
  ngx_int_t tmp___8 ;
  int tmp___9 ;
  ngx_int_t tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  ngx_int_t tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  void *tmp___17 ;
  void *tmp___18 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 1191
  llcf = (ngx_http_log_loc_conf_t *)conf;
#line 1206
  value = (ngx_str_t *)(cf->args)->elts;
#line 1208
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 1208
  if (tmp == 0) {
#line 1209
    llcf->off = (ngx_uint_t )1;
#line 1210
    if ((cf->args)->nelts == 2UL) {
#line 1211
      return ((char *)((void *)0));
    }
    {
#line 1214
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + 2);
    }
#line 1216
    return ((char *)((void *)-1));
  }
#line 1219
  if ((unsigned long )llcf->logs == (unsigned long )((void *)0)) {
    {
#line 1220
    llcf->logs = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_http_log_t ));
    }
#line 1221
    if ((unsigned long )llcf->logs == (unsigned long )((void *)0)) {
#line 1222
      return ((char *)((void *)-1));
    }
  }
  {
#line 1226
  lmcf = (ngx_http_log_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_log_module.ctx_index);
#line 1228
  tmp___0 = ngx_array_push(llcf->logs);
#line 1228
  log = (ngx_http_log_t *)tmp___0;
  }
#line 1229
  if ((unsigned long )log == (unsigned long )((void *)0)) {
#line 1230
    return ((char *)((void *)-1));
  }
  {
#line 1233
  memset((void *)log, 0, sizeof(ngx_http_log_t ));
#line 1236
  tmp___3 = strncmp((char const   *)(value + 1)->data, "syslog:", (size_t )7);
  }
#line 1236
  if (tmp___3 == 0) {
    {
#line 1238
    tmp___1 = ngx_pcalloc(cf->pool, sizeof(ngx_syslog_peer_t ));
#line 1238
    peer = (ngx_syslog_peer_t *)tmp___1;
    }
#line 1239
    if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 1240
      return ((char *)((void *)-1));
    }
    {
#line 1243
    tmp___2 = ngx_syslog_process_conf(cf, peer);
    }
#line 1243
    if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 1244
      return ((char *)((void *)-1));
    }
#line 1247
    log->syslog_peer = peer;
#line 1249
    goto process_formats;
  }
  {
#line 1252
  n = ngx_http_script_variables_count(value + 1);
  }
#line 1254
  if (n == 0UL) {
    {
#line 1255
    log->file = ngx_conf_open_file(cf->cycle, value + 1);
    }
#line 1256
    if ((unsigned long )log->file == (unsigned long )((void *)0)) {
#line 1257
      return ((char *)((void *)-1));
    }
  } else {
    {
#line 1261
    tmp___4 = ngx_conf_full_name(cf->cycle, value + 1, (ngx_uint_t )0);
    }
#line 1261
    if (tmp___4 != 0L) {
#line 1262
      return ((char *)((void *)-1));
    }
    {
#line 1265
    tmp___5 = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_script_t ));
#line 1265
    log->script = (ngx_http_log_script_t *)tmp___5;
    }
#line 1266
    if ((unsigned long )log->script == (unsigned long )((void *)0)) {
#line 1267
      return ((char *)((void *)-1));
    }
    {
#line 1270
    memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 1272
    sc.cf = cf;
#line 1273
    sc.source = value + 1;
#line 1274
    sc.lengths = & (log->script)->lengths;
#line 1275
    sc.values = & (log->script)->values;
#line 1276
    sc.variables = n;
#line 1277
    sc.complete_lengths = 1U;
#line 1278
    sc.complete_values = 1U;
#line 1280
    tmp___6 = ngx_http_script_compile(& sc);
    }
#line 1280
    if (tmp___6 != 0L) {
#line 1281
      return ((char *)((void *)-1));
    }
  }
  process_formats: 
#line 1287
  if ((cf->args)->nelts >= 3UL) {
    {
#line 1288
    name = *(value + 2);
#line 1290
    tmp___7 = strcmp((char const   *)name.data, "combined");
    }
#line 1290
    if (tmp___7 == 0) {
#line 1291
      lmcf->combined_used = (ngx_uint_t )1;
    }
  } else {
#line 1295
    name.len = sizeof("combined") - 1UL;
#line 1295
    name.data = (u_char *)"combined";
#line 1296
    lmcf->combined_used = (ngx_uint_t )1;
  }
#line 1299
  fmt = (ngx_http_log_fmt_t *)lmcf->formats.elts;
#line 1300
  i = (ngx_uint_t )0;
  {
#line 1300
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1300
    if (! (i < lmcf->formats.nelts)) {
#line 1300
      goto while_break;
    }
#line 1301
    if ((fmt + i)->name.len == name.len) {
      {
#line 1301
      tmp___8 = ngx_strcasecmp((fmt + i)->name.data, name.data);
      }
#line 1301
      if (tmp___8 == 0L) {
#line 1304
        log->format = fmt + i;
#line 1305
        goto while_break;
      }
    }
#line 1300
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1309
  if ((unsigned long )log->format == (unsigned long )((void *)0)) {
    {
#line 1310
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown log format \"%V\"", & name);
    }
#line 1312
    return ((char *)((void *)-1));
  }
#line 1315
  size = (ssize_t )0;
#line 1316
  flush = (ngx_msec_t )0;
#line 1317
  gzip = (ngx_int_t )0;
#line 1319
  i = (ngx_uint_t )3;
  {
#line 1319
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1319
    if (! (i < (cf->args)->nelts)) {
#line 1319
      goto while_break___0;
    }
    {
#line 1321
    tmp___9 = strncmp((char const   *)(value + i)->data, "buffer=", (size_t )7);
    }
#line 1321
    if (tmp___9 == 0) {
      {
#line 1322
      s.len = (value + i)->len - 7UL;
#line 1323
      s.data = (value + i)->data + 7;
#line 1325
      size = ngx_parse_size(& s);
      }
#line 1327
      if (size == -1L) {
        {
#line 1328
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid buffer size \"%V\"", & s);
        }
#line 1330
        return ((char *)((void *)-1));
      } else
#line 1327
      if (size == 0L) {
        {
#line 1328
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid buffer size \"%V\"", & s);
        }
#line 1330
        return ((char *)((void *)-1));
      }
#line 1333
      goto __Cont;
    }
    {
#line 1336
    tmp___11 = strncmp((char const   *)(value + i)->data, "flush=", (size_t )6);
    }
#line 1336
    if (tmp___11 == 0) {
      {
#line 1337
      s.len = (value + i)->len - 6UL;
#line 1338
      s.data = (value + i)->data + 6;
#line 1340
      tmp___10 = ngx_parse_time(& s, (ngx_uint_t )0);
#line 1340
      flush = (ngx_msec_t )tmp___10;
      }
#line 1342
      if (flush == 0xffffffffffffffffUL) {
        {
#line 1343
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid flush time \"%V\"", & s);
        }
#line 1345
        return ((char *)((void *)-1));
      } else
#line 1342
      if (flush == 0UL) {
        {
#line 1343
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid flush time \"%V\"", & s);
        }
#line 1345
        return ((char *)((void *)-1));
      }
#line 1348
      goto __Cont;
    }
    {
#line 1351
    tmp___12 = strncmp((char const   *)(value + i)->data, "gzip", (size_t )4);
    }
#line 1351
    if (tmp___12 == 0) {
#line 1351
      if ((value + i)->len == 4UL) {
#line 1351
        goto _L;
      } else
#line 1351
      if ((int )*((value + i)->data + 4) == 61) {
        _L: /* CIL Label */ 
#line 1355
        if (size == 0L) {
#line 1356
          size = (ssize_t )65536;
        }
#line 1359
        if ((value + i)->len == 4UL) {
#line 1360
          gzip = (ngx_int_t )1;
#line 1361
          goto __Cont;
        }
        {
#line 1364
        s.len = (value + i)->len - 5UL;
#line 1365
        s.data = (value + i)->data + 5;
#line 1367
        gzip = ngx_atoi(s.data, s.len);
        }
#line 1369
        if (gzip < 1L) {
          {
#line 1370
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid compression level \"%V\"",
                             & s);
          }
#line 1372
          return ((char *)((void *)-1));
        } else
#line 1369
        if (gzip > 9L) {
          {
#line 1370
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid compression level \"%V\"",
                             & s);
          }
#line 1372
          return ((char *)((void *)-1));
        }
#line 1375
        goto __Cont;
      }
    }
    {
#line 1384
    tmp___15 = strncmp((char const   *)(value + i)->data, "if=", (size_t )3);
    }
#line 1384
    if (tmp___15 == 0) {
      {
#line 1385
      s.len = (value + i)->len - 3UL;
#line 1386
      s.data = (value + i)->data + 3;
#line 1388
      memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 1390
      ccv.cf = cf;
#line 1391
      ccv.value = & s;
#line 1392
      tmp___13 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 1392
      ccv.complex_value = (ngx_http_complex_value_t *)tmp___13;
      }
#line 1394
      if ((unsigned long )ccv.complex_value == (unsigned long )((void *)0)) {
#line 1395
        return ((char *)((void *)-1));
      }
      {
#line 1398
      tmp___14 = ngx_http_compile_complex_value(& ccv);
      }
#line 1398
      if (tmp___14 != 0L) {
#line 1399
        return ((char *)((void *)-1));
      }
#line 1402
      log->filter = ccv.complex_value;
#line 1404
      goto __Cont;
    }
    {
#line 1407
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 1409
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 1319
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1412
  if (flush) {
#line 1412
    if (size == 0L) {
      {
#line 1413
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "no buffer is defined for access_log \"%V\"",
                         value + 1);
      }
#line 1416
      return ((char *)((void *)-1));
    }
  }
#line 1419
  if (size) {
#line 1421
    if (log->script) {
      {
#line 1422
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "buffered logs cannot have variables in name");
      }
#line 1424
      return ((char *)((void *)-1));
    }
#line 1427
    if (log->syslog_peer) {
      {
#line 1428
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "logs to syslog cannot be buffered");
      }
#line 1430
      return ((char *)((void *)-1));
    }
#line 1433
    if ((log->file)->data) {
#line 1434
      buffer___0 = (ngx_http_log_buf_t *)(log->file)->data;
#line 1436
      if (buffer___0->last - buffer___0->start != size) {
        {
#line 1440
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "access_log \"%V\" already defined with conflicting parameters",
                           value + 1);
        }
#line 1444
        return ((char *)((void *)-1));
      } else
#line 1436
      if (buffer___0->flush != flush) {
        {
#line 1440
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "access_log \"%V\" already defined with conflicting parameters",
                           value + 1);
        }
#line 1444
        return ((char *)((void *)-1));
      } else
#line 1436
      if (buffer___0->gzip != gzip) {
        {
#line 1440
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "access_log \"%V\" already defined with conflicting parameters",
                           value + 1);
        }
#line 1444
        return ((char *)((void *)-1));
      }
#line 1447
      return ((char *)((void *)0));
    }
    {
#line 1450
    tmp___16 = ngx_pcalloc(cf->pool, sizeof(ngx_http_log_buf_t ));
#line 1450
    buffer___0 = (ngx_http_log_buf_t *)tmp___16;
    }
#line 1451
    if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
#line 1452
      return ((char *)((void *)-1));
    }
    {
#line 1455
    tmp___17 = ngx_pnalloc(cf->pool, (size_t )size);
#line 1455
    buffer___0->start = (u_char *)tmp___17;
    }
#line 1456
    if ((unsigned long )buffer___0->start == (unsigned long )((void *)0)) {
#line 1457
      return ((char *)((void *)-1));
    }
#line 1460
    buffer___0->pos = buffer___0->start;
#line 1461
    buffer___0->last = buffer___0->start + size;
#line 1463
    if (flush) {
      {
#line 1464
      tmp___18 = ngx_pcalloc(cf->pool, sizeof(ngx_event_t ));
#line 1464
      buffer___0->event = (ngx_event_t *)tmp___18;
      }
#line 1465
      if ((unsigned long )buffer___0->event == (unsigned long )((void *)0)) {
#line 1466
        return ((char *)((void *)-1));
      }
#line 1469
      (buffer___0->event)->data = (void *)log->file;
#line 1470
      (buffer___0->event)->handler = & ngx_http_log_flush_handler;
#line 1471
      (buffer___0->event)->log = & (cf->cycle)->new_log;
#line 1472
      (buffer___0->event)->cancelable = 1U;
#line 1474
      buffer___0->flush = flush;
    }
#line 1477
    buffer___0->gzip = gzip;
#line 1479
    (log->file)->flush = & ngx_http_log_flush;
#line 1480
    (log->file)->data = (void *)buffer___0;
  }
#line 1483
  return ((char *)((void *)0));
}
}
#line 1487 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_set_format(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_log_main_conf_t *lmcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_http_log_fmt_t *fmt ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp11 ;

  {
#line 1490
  lmcf = (ngx_http_log_main_conf_t *)conf;
#line 1496
  value = (ngx_str_t *)(cf->args)->elts;
#line 1498
  fmt = (ngx_http_log_fmt_t *)lmcf->formats.elts;
#line 1499
  i = (ngx_uint_t )0;
  {
#line 1499
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1499
    if (! (i < lmcf->formats.nelts)) {
#line 1499
      goto while_break;
    }
#line 1500
    if ((fmt + i)->name.len == (value + 1)->len) {
      {
#line 1500
      tmp = strcmp((char const   *)(fmt + i)->name.data, (char const   *)(value + 1)->data);
      }
#line 1500
      if (tmp == 0) {
        {
#line 1503
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate \"log_format\" name \"%V\"",
                           value + 1);
        }
#line 1506
        return ((char *)((void *)-1));
      }
    }
#line 1499
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1510
  tmp___0 = ngx_array_push(& lmcf->formats);
#line 1510
  fmt = (ngx_http_log_fmt_t *)tmp___0;
  }
#line 1511
  if ((unsigned long )fmt == (unsigned long )((void *)0)) {
#line 1512
    return ((char *)((void *)-1));
  }
  {
#line 1515
  fmt->name = *(value + 1);
#line 1517
  fmt->flushes = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_int_t ));
  }
#line 1518
  if ((unsigned long )fmt->flushes == (unsigned long )((void *)0)) {
#line 1519
    return ((char *)((void *)-1));
  }
  {
#line 1522
  fmt->ops = ngx_array_create(cf->pool, (ngx_uint_t )16, sizeof(ngx_http_log_op_t ));
  }
#line 1523
  if ((unsigned long )fmt->ops == (unsigned long )((void *)0)) {
#line 1524
    return ((char *)((void *)-1));
  }
  {
#line 1527
  tmp___1 = ngx_http_log_compile_format(cf, fmt->flushes, fmt->ops, cf->args, (ngx_uint_t )2);
  }
#line 1527
  return (tmp___1);
}
}
#line 1531 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_compile_format(ngx_conf_t *cf , ngx_array_t *flushes , ngx_array_t *ops ,
                                         ngx_array_t *args___0 , ngx_uint_t s ) 
{ 
  u_char *data ;
  u_char *p ;
  u_char ch ;
  size_t i ;
  size_t len ;
  ngx_str_t *value ;
  ngx_str_t var ;
  ngx_int_t *flush ;
  ngx_uint_t bracket ;
  ngx_uint_t json ;
  ngx_http_log_op_t *op ;
  ngx_http_log_var_t *v ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
#line 1543
  json = (ngx_uint_t )0;
#line 1544
  value = (ngx_str_t *)args___0->elts;
#line 1546
  if (s < args___0->nelts) {
    {
#line 1546
    tmp___1 = strncmp((char const   *)(value + s)->data, "escape=", (size_t )7);
    }
#line 1546
    if (tmp___1 == 0) {
      {
#line 1547
      data = (value + s)->data + 7;
#line 1549
      tmp___0 = strcmp((char const   *)data, "json");
      }
#line 1549
      if (tmp___0 == 0) {
#line 1550
        json = (ngx_uint_t )1;
      } else {
        {
#line 1552
        tmp = strcmp((char const   *)data, "default");
        }
#line 1552
        if (tmp != 0) {
          {
#line 1553
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown log format escaping \"%s\"",
                             data);
          }
#line 1555
          return ((char *)((void *)-1));
        }
      }
#line 1558
      s ++;
    }
  }
  {
#line 1561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1561
    if (! (s < args___0->nelts)) {
#line 1561
      goto while_break;
    }
#line 1563
    i = (size_t )0;
    {
#line 1565
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1565
      if (! (i < (value + s)->len)) {
#line 1565
        goto while_break___0;
      }
      {
#line 1567
      tmp___2 = ngx_array_push(ops);
#line 1567
      op = (ngx_http_log_op_t *)tmp___2;
      }
#line 1568
      if ((unsigned long )op == (unsigned long )((void *)0)) {
#line 1569
        return ((char *)((void *)-1));
      }
#line 1572
      data = (value + s)->data + i;
#line 1574
      if ((int )*((value + s)->data + i) == 36) {
#line 1576
        i ++;
#line 1576
        if (i == (value + s)->len) {
#line 1577
          goto invalid;
        }
#line 1580
        if ((int )*((value + s)->data + i) == 123) {
#line 1581
          bracket = (ngx_uint_t )1;
#line 1583
          i ++;
#line 1583
          if (i == (value + s)->len) {
#line 1584
            goto invalid;
          }
#line 1587
          var.data = (value + s)->data + i;
        } else {
#line 1590
          bracket = (ngx_uint_t )0;
#line 1591
          var.data = (value + s)->data + i;
        }
#line 1594
        var.len = (size_t )0;
        {
#line 1594
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1594
          if (! (i < (value + s)->len)) {
#line 1594
            goto while_break___1;
          }
#line 1595
          ch = *((value + s)->data + i);
#line 1597
          if ((int )ch == 125) {
#line 1597
            if (bracket) {
#line 1598
              i ++;
#line 1599
              bracket = (ngx_uint_t )0;
#line 1600
              goto while_break___1;
            }
          }
#line 1603
          if ((int )ch >= 65) {
#line 1603
            if ((int )ch <= 90) {
#line 1608
              goto __Cont;
            } else {
#line 1603
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 1603
          if ((int )ch >= 97) {
#line 1603
            if ((int )ch <= 122) {
#line 1608
              goto __Cont;
            } else {
#line 1603
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 1603
          if ((int )ch >= 48) {
#line 1603
            if ((int )ch <= 57) {
#line 1608
              goto __Cont;
            } else {
#line 1603
              goto _L;
            }
          } else
          _L: /* CIL Label */ 
#line 1603
          if ((int )ch == 95) {
#line 1608
            goto __Cont;
          }
#line 1611
          goto while_break___1;
          __Cont: /* CIL Label */ 
#line 1594
          i ++;
#line 1594
          (var.len) ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1614
        if (bracket) {
          {
#line 1615
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the closing bracket in \"%V\" variable is missing",
                             & var);
          }
#line 1618
          return ((char *)((void *)-1));
        }
#line 1621
        if (var.len == 0UL) {
#line 1622
          goto invalid;
        }
#line 1625
        v = ngx_http_log_vars;
        {
#line 1625
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1625
          if (! v->name.len) {
#line 1625
            goto while_break___2;
          }
#line 1627
          if (v->name.len == var.len) {
            {
#line 1627
            tmp___3 = strncmp((char const   *)v->name.data, (char const   *)var.data,
                              var.len);
            }
#line 1627
            if (tmp___3 == 0) {
#line 1630
              op->len = v->len;
#line 1631
              op->getlen = (size_t (*)(ngx_http_request_t *r , uintptr_t data ))((void *)0);
#line 1632
              op->run = v->run;
#line 1633
              op->data = (uintptr_t )0;
#line 1635
              goto found;
            }
          }
#line 1625
          v ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1639
        tmp___4 = ngx_http_log_variable_compile(cf, op, & var, json);
        }
#line 1639
        if (tmp___4 != 0L) {
#line 1642
          return ((char *)((void *)-1));
        }
#line 1645
        if (flushes) {
          {
#line 1647
          tmp___5 = ngx_array_push(flushes);
#line 1647
          flush = (ngx_int_t *)tmp___5;
          }
#line 1648
          if ((unsigned long )flush == (unsigned long )((void *)0)) {
#line 1649
            return ((char *)((void *)-1));
          }
#line 1652
          *flush = (ngx_int_t )op->data;
        }
        found: 
#line 1657
        goto while_continue___0;
      }
#line 1660
      i ++;
      {
#line 1662
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1662
        if (i < (value + s)->len) {
#line 1662
          if (! ((int )*((value + s)->data + i) != 36)) {
#line 1662
            goto while_break___3;
          }
        } else {
#line 1662
          goto while_break___3;
        }
#line 1663
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1666
      len = (size_t )(((value + s)->data + i) - data);
#line 1668
      if (len) {
#line 1670
        op->len = len;
#line 1671
        op->getlen = (size_t (*)(ngx_http_request_t *r , uintptr_t data ))((void *)0);
#line 1673
        if (len <= sizeof(uintptr_t )) {
#line 1674
          op->run = & ngx_http_log_copy_short;
#line 1675
          op->data = (uintptr_t )0;
          {
#line 1677
          while (1) {
            while_continue___4: /* CIL Label */ ;
#line 1677
            tmp___6 = len;
#line 1677
            len --;
#line 1677
            if (! tmp___6) {
#line 1677
              goto while_break___4;
            }
#line 1678
            op->data <<= 8;
#line 1679
            op->data |= (unsigned long )*(data + len);
          }
          while_break___4: /* CIL Label */ ;
          }
        } else {
          {
#line 1683
          op->run = & ngx_http_log_copy_long;
#line 1685
          tmp___7 = ngx_pnalloc(cf->pool, len);
#line 1685
          p = (u_char *)tmp___7;
          }
#line 1686
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1687
            return ((char *)((void *)-1));
          }
          {
#line 1690
          memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)data,
                 len);
#line 1691
          op->data = (uintptr_t )p;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1561
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1697
  return ((char *)((void *)0));
  invalid: 
  {
#line 1701
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%s\"", data);
  }
#line 1703
  return ((char *)((void *)-1));
}
}
#line 1707 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static char *ngx_http_log_open_file_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_log_loc_conf_t *llcf ;
  time_t inactive ;
  time_t valid ;
  ngx_str_t *value ;
  ngx_str_t s ;
  ngx_int_t max ;
  ngx_int_t min_uses ;
  ngx_uint_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1710
  llcf = (ngx_http_log_loc_conf_t *)conf;
#line 1717
  if ((unsigned long )llcf->open_file_cache != (unsigned long )((void *)-1)) {
#line 1718
    return ((char *)"is duplicate");
  }
#line 1721
  value = (ngx_str_t *)(cf->args)->elts;
#line 1723
  max = (ngx_int_t )0;
#line 1724
  inactive = (time_t )10;
#line 1725
  valid = (time_t )60;
#line 1726
  min_uses = (ngx_int_t )1;
#line 1728
  i = (ngx_uint_t )1;
  {
#line 1728
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1728
    if (! (i < (cf->args)->nelts)) {
#line 1728
      goto while_break;
    }
    {
#line 1730
    tmp = strncmp((char const   *)(value + i)->data, "max=", (size_t )4);
    }
#line 1730
    if (tmp == 0) {
      {
#line 1732
      max = ngx_atoi((value + i)->data + 4, (value + i)->len - 4UL);
      }
#line 1733
      if (max == -1L) {
#line 1734
        goto failed;
      }
#line 1737
      goto __Cont;
    }
    {
#line 1740
    tmp___0 = strncmp((char const   *)(value + i)->data, "inactive=", (size_t )9);
    }
#line 1740
    if (tmp___0 == 0) {
      {
#line 1742
      s.len = (value + i)->len - 9UL;
#line 1743
      s.data = (value + i)->data + 9;
#line 1745
      inactive = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 1746
      if (inactive == -1L) {
#line 1747
        goto failed;
      }
#line 1750
      goto __Cont;
    }
    {
#line 1753
    tmp___1 = strncmp((char const   *)(value + i)->data, "min_uses=", (size_t )9);
    }
#line 1753
    if (tmp___1 == 0) {
      {
#line 1755
      min_uses = ngx_atoi((value + i)->data + 9, (value + i)->len - 9UL);
      }
#line 1756
      if (min_uses == -1L) {
#line 1757
        goto failed;
      }
#line 1760
      goto __Cont;
    }
    {
#line 1763
    tmp___2 = strncmp((char const   *)(value + i)->data, "valid=", (size_t )6);
    }
#line 1763
    if (tmp___2 == 0) {
      {
#line 1765
      s.len = (value + i)->len - 6UL;
#line 1766
      s.data = (value + i)->data + 6;
#line 1768
      valid = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 1769
      if (valid == -1L) {
#line 1770
        goto failed;
      }
#line 1773
      goto __Cont;
    }
    {
#line 1776
    tmp___3 = strcmp((char const   *)(value + i)->data, "off");
    }
#line 1776
    if (tmp___3 == 0) {
#line 1778
      llcf->open_file_cache = (ngx_open_file_cache_t *)((void *)0);
#line 1780
      goto __Cont;
    }
    failed: 
    {
#line 1785
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid \"open_log_file_cache\" parameter \"%V\"",
                       value + i);
    }
#line 1788
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 1728
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1791
  if ((unsigned long )llcf->open_file_cache == (unsigned long )((void *)0)) {
#line 1792
    return ((char *)((void *)0));
  }
#line 1795
  if (max == 0L) {
    {
#line 1796
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"open_log_file_cache\" must have \"max\" parameter");
    }
#line 1798
    return ((char *)((void *)-1));
  }
  {
#line 1801
  llcf->open_file_cache = ngx_open_file_cache_init(cf->pool, (ngx_uint_t )max, inactive);
  }
#line 1803
  if (llcf->open_file_cache) {
#line 1805
    llcf->open_file_cache_valid = valid;
#line 1806
    llcf->open_file_cache_min_uses = (ngx_uint_t )min_uses;
#line 1808
    return ((char *)((void *)0));
  }
#line 1811
  return ((char *)((void *)-1));
}
}
#line 1815 "/home/khheo/project/nginx-release-1.13.8/src/http/modules/ngx_http_log_module.c"
static ngx_int_t ngx_http_log_init(ngx_conf_t *cf ) 
{ 
  ngx_str_t *value ;
  ngx_array_t a ;
  ngx_http_handler_pt *h ;
  ngx_http_log_fmt_t *fmt ;
  ngx_http_log_main_conf_t *lmcf ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 1825
  lmcf = (ngx_http_log_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_log_module.ctx_index);
#line 1827
  if (lmcf->combined_used) {
    {
#line 1828
    tmp = ngx_array_init(& a, cf->pool, (ngx_uint_t )1, sizeof(ngx_str_t ));
    }
#line 1828
    if (tmp != 0L) {
#line 1829
      return ((ngx_int_t )-1);
    }
    {
#line 1832
    tmp___0 = ngx_array_push(& a);
#line 1832
    value = (ngx_str_t *)tmp___0;
    }
#line 1833
    if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1834
      return ((ngx_int_t )-1);
    }
    {
#line 1837
    *value = ngx_http_combined_fmt;
#line 1838
    fmt = (ngx_http_log_fmt_t *)lmcf->formats.elts;
#line 1840
    tmp___1 = ngx_http_log_compile_format(cf, (ngx_array_t *)((void *)0), fmt->ops,
                                          & a, (ngx_uint_t )0);
    }
#line 1840
    if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 1843
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1847
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 1849
  tmp___2 = ngx_array_push(& cmcf->phases[10].handlers);
#line 1849
  h = (ngx_http_handler_pt *)tmp___2;
  }
#line 1850
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 1851
    return ((ngx_int_t )-1);
  }
#line 1854
  *h = & ngx_http_log_handler;
#line 1856
  return ((ngx_int_t )0);
}
}
#line 92 "src/http/ngx_http.h"
ngx_int_t ngx_http_parse_request_line(ngx_http_request_t *r , ngx_buf_t *b ) ;
#line 93
ngx_int_t ngx_http_parse_uri(ngx_http_request_t *r ) ;
#line 94
ngx_int_t ngx_http_parse_complex_uri(ngx_http_request_t *r , ngx_uint_t merge_slashes ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
static uint32_t usual[8]  = 
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
  {      4294958078U,      (uint32_t )2147432406,      4294967295U,      4294967295U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 103 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_request_line(ngx_http_request_t *r , ngx_buf_t *b ) 
{ 
  u_char c ;
  u_char ch ;
  u_char *p ;
  u_char *m ;
  enum __anonenum_state_242 state ;

  {
#line 137
  state = (enum __anonenum_state_242 )r->state;
#line 139
  p = b->pos;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )p < (unsigned long )b->last)) {
#line 139
      goto while_break;
    }
#line 140
    ch = *p;
    {
#line 145
    if ((unsigned int )state == 0U) {
#line 145
      goto case_0;
    }
#line 159
    if ((unsigned int )state == 1U) {
#line 159
      goto case_1;
    }
#line 280
    if ((unsigned int )state == 2U) {
#line 280
      goto case_2;
    }
#line 303
    if ((unsigned int )state == 3U) {
#line 303
      goto case_3___0;
    }
#line 320
    if ((unsigned int )state == 4U) {
#line 320
      goto case_4___0;
    }
#line 330
    if ((unsigned int )state == 5U) {
#line 330
      goto case_5___0;
    }
#line 340
    if ((unsigned int )state == 6U) {
#line 340
      goto case_6___0;
    }
#line 353
    if ((unsigned int )state == 7U) {
#line 353
      goto case_7___0;
    }
#line 366
    if ((unsigned int )state == 8U) {
#line 366
      goto case_8___0;
    }
#line 392
    if ((unsigned int )state == 9U) {
#line 392
      goto case_9___0;
    }
#line 433
    if ((unsigned int )state == 10U) {
#line 433
      goto case_10;
    }
#line 460
    if ((unsigned int )state == 11U) {
#line 460
      goto case_11;
    }
#line 482
    if ((unsigned int )state == 12U) {
#line 482
      goto case_12;
    }
#line 541
    if ((unsigned int )state == 13U) {
#line 541
      goto case_13___1;
    }
#line 602
    if ((unsigned int )state == 14U) {
#line 602
      goto case_14;
    }
#line 627
    if ((unsigned int )state == 15U) {
#line 627
      goto case_15;
    }
#line 656
    if ((unsigned int )state == 16U) {
#line 656
      goto case_16;
    }
#line 679
    if ((unsigned int )state == 17U) {
#line 679
      goto case_17;
    }
#line 689
    if ((unsigned int )state == 18U) {
#line 689
      goto case_18;
    }
#line 699
    if ((unsigned int )state == 19U) {
#line 699
      goto case_19;
    }
#line 709
    if ((unsigned int )state == 20U) {
#line 709
      goto case_20;
    }
#line 720
    if ((unsigned int )state == 21U) {
#line 720
      goto case_21;
    }
#line 735
    if ((unsigned int )state == 22U) {
#line 735
      goto case_22;
    }
#line 754
    if ((unsigned int )state == 23U) {
#line 754
      goto case_23;
    }
#line 764
    if ((unsigned int )state == 24U) {
#line 764
      goto case_24;
    }
#line 790
    if ((unsigned int )state == 25U) {
#line 790
      goto case_25;
    }
#line 805
    if ((unsigned int )state == 26U) {
#line 805
      goto case_26;
    }
#line 142
    goto switch_break;
    case_0: /* CIL Label */ 
#line 146
    r->request_start = p;
#line 148
    if ((int )ch == 13) {
#line 149
      goto switch_break;
    } else
#line 148
    if ((int )ch == 10) {
#line 149
      goto switch_break;
    }
#line 152
    if ((int )ch < 65) {
#line 152
      goto _L;
    } else
#line 152
    if ((int )ch > 90) {
      _L: /* CIL Label */ 
#line 152
      if ((int )ch != 95) {
#line 152
        if ((int )ch != 45) {
#line 153
          return ((ngx_int_t )10);
        }
      }
    }
#line 156
    state = (enum __anonenum_state_242 )1;
#line 157
    goto switch_break;
    case_1: /* CIL Label */ 
#line 160
    if ((int )ch == 32) {
#line 161
      r->method_end = p - 1;
#line 162
      m = r->request_start;
      {
#line 166
      if (p - m == 3L) {
#line 166
        goto case_3;
      }
#line 179
      if (p - m == 4L) {
#line 179
        goto case_4;
      }
#line 212
      if (p - m == 5L) {
#line 212
        goto case_5;
      }
#line 230
      if (p - m == 6L) {
#line 230
        goto case_6;
      }
#line 243
      if (p - m == 7L) {
#line 243
        goto case_7;
      }
#line 251
      if (p - m == 8L) {
#line 251
        goto case_8;
      }
#line 259
      if (p - m == 9L) {
#line 259
        goto case_9;
      }
#line 164
      goto switch_break___0;
      case_3: /* CIL Label */ 
#line 167
      if (*((uint32_t *)m) == (uint32_t )((((32 << 24) | (84 << 16)) | (69 << 8)) | 71)) {
#line 168
        r->method = (ngx_uint_t )2;
#line 169
        goto switch_break___0;
      }
#line 172
      if (*((uint32_t *)m) == (uint32_t )((((32 << 24) | (84 << 16)) | (85 << 8)) | 80)) {
#line 173
        r->method = (ngx_uint_t )16;
#line 174
        goto switch_break___0;
      }
#line 177
      goto switch_break___0;
      case_4: /* CIL Label */ 
#line 180
      if ((int )*(m + 1) == 79) {
#line 182
        if (*((uint32_t *)m) == (uint32_t )((((84 << 24) | (83 << 16)) | (79 << 8)) | 80)) {
#line 183
          r->method = (ngx_uint_t )8;
#line 184
          goto switch_break___0;
        }
#line 187
        if (*((uint32_t *)m) == (uint32_t )((((89 << 24) | (80 << 16)) | (79 << 8)) | 67)) {
#line 188
          r->method = (ngx_uint_t )128;
#line 189
          goto switch_break___0;
        }
#line 192
        if (*((uint32_t *)m) == (uint32_t )((((69 << 24) | (86 << 16)) | (79 << 8)) | 77)) {
#line 193
          r->method = (ngx_uint_t )256;
#line 194
          goto switch_break___0;
        }
#line 197
        if (*((uint32_t *)m) == (uint32_t )((((75 << 24) | (67 << 16)) | (79 << 8)) | 76)) {
#line 198
          r->method = (ngx_uint_t )4096;
#line 199
          goto switch_break___0;
        }
      } else
#line 204
      if (*((uint32_t *)m) == (uint32_t )((((68 << 24) | (65 << 16)) | (69 << 8)) | 72)) {
#line 205
        r->method = (ngx_uint_t )4;
#line 206
        goto switch_break___0;
      }
#line 210
      goto switch_break___0;
      case_5: /* CIL Label */ 
#line 213
      if (*((uint32_t *)m) == (uint32_t )((((79 << 24) | (67 << 16)) | (75 << 8)) | 77)) {
#line 213
        if ((int )*(m + 4) == 76) {
#line 214
          r->method = (ngx_uint_t )64;
#line 215
          goto switch_break___0;
        }
      }
#line 218
      if (*((uint32_t *)m) == (uint32_t )((((67 << 24) | (84 << 16)) | (65 << 8)) | 80)) {
#line 218
        if ((int )*(m + 4) == 72) {
#line 219
          r->method = (ngx_uint_t )16384;
#line 220
          goto switch_break___0;
        }
      }
#line 223
      if (*((uint32_t *)m) == (uint32_t )((((67 << 24) | (65 << 16)) | (82 << 8)) | 84)) {
#line 223
        if ((int )*(m + 4) == 69) {
#line 224
          r->method = (ngx_uint_t )32768;
#line 225
          goto switch_break___0;
        }
      }
#line 228
      goto switch_break___0;
      case_6: /* CIL Label */ 
#line 231
      if (*((uint32_t *)m) == (uint32_t )((((69 << 24) | (76 << 16)) | (69 << 8)) | 68)) {
#line 231
        if ((*((uint32_t *)m + 1) & 65535U) == (unsigned int )((69 << 8) | 84)) {
#line 232
          r->method = (ngx_uint_t )32;
#line 233
          goto switch_break___0;
        }
      }
#line 236
      if (*((uint32_t *)m) == (uint32_t )((((79 << 24) | (76 << 16)) | (78 << 8)) | 85)) {
#line 236
        if ((*((uint32_t *)m + 1) & 65535U) == (unsigned int )((75 << 8) | 67)) {
#line 237
          r->method = (ngx_uint_t )8192;
#line 238
          goto switch_break___0;
        }
      }
#line 241
      goto switch_break___0;
      case_7: /* CIL Label */ 
#line 244
      if (*((uint32_t *)m) == (uint32_t )((((73 << 24) | (84 << 16)) | (80 << 8)) | 79)) {
#line 244
        if (*((uint32_t *)m + 1) == (uint32_t )((((32 << 24) | (83 << 16)) | (78 << 8)) | 79)) {
#line 246
          r->method = (ngx_uint_t )512;
        }
      }
#line 249
      goto switch_break___0;
      case_8: /* CIL Label */ 
#line 252
      if (*((uint32_t *)m) == (uint32_t )((((80 << 24) | (79 << 16)) | (82 << 8)) | 80)) {
#line 252
        if (*((uint32_t *)m + 1) == (uint32_t )((((68 << 24) | (78 << 16)) | (73 << 8)) | 70)) {
#line 254
          r->method = (ngx_uint_t )1024;
        }
      }
#line 257
      goto switch_break___0;
      case_9: /* CIL Label */ 
#line 260
      if (*((uint32_t *)m) == (uint32_t )((((80 << 24) | (79 << 16)) | (82 << 8)) | 80)) {
#line 260
        if (*((uint32_t *)m + 1) == (uint32_t )((((67 << 24) | (84 << 16)) | (65 << 8)) | 80)) {
#line 260
          if ((int )*(m + 8) == 72) {
#line 263
            r->method = (ngx_uint_t )2048;
          }
        }
      }
#line 266
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 269
      state = (enum __anonenum_state_242 )2;
#line 270
      goto switch_break;
    }
#line 273
    if ((int )ch < 65) {
#line 273
      goto _L___0;
    } else
#line 273
    if ((int )ch > 90) {
      _L___0: /* CIL Label */ 
#line 273
      if ((int )ch != 95) {
#line 273
        if ((int )ch != 45) {
#line 274
          return ((ngx_int_t )10);
        }
      }
    }
#line 277
    goto switch_break;
    case_2: /* CIL Label */ 
#line 282
    if ((int )ch == 47) {
#line 283
      r->uri_start = p;
#line 284
      state = (enum __anonenum_state_242 )12;
#line 285
      goto switch_break;
    }
#line 288
    c = (u_char )((int )ch | 32);
#line 289
    if ((int )c >= 97) {
#line 289
      if ((int )c <= 122) {
#line 290
        r->schema_start = p;
#line 291
        state = (enum __anonenum_state_242 )3;
#line 292
        goto switch_break;
      }
    }
    {
#line 296
    if ((int )ch == 32) {
#line 296
      goto case_32;
    }
#line 298
    goto switch_default;
    case_32: /* CIL Label */ 
#line 297
    goto switch_break___1;
    switch_default: /* CIL Label */ 
#line 299
    return ((ngx_int_t )11);
    switch_break___1: /* CIL Label */ ;
    }
#line 301
    goto switch_break;
    case_3___0: /* CIL Label */ 
#line 305
    c = (u_char )((int )ch | 32);
#line 306
    if ((int )c >= 97) {
#line 306
      if ((int )c <= 122) {
#line 307
        goto switch_break;
      }
    }
    {
#line 311
    if ((int )ch == 58) {
#line 311
      goto case_58;
    }
#line 315
    goto switch_default___0;
    case_58: /* CIL Label */ 
#line 312
    r->schema_end = p;
#line 313
    state = (enum __anonenum_state_242 )4;
#line 314
    goto switch_break___2;
    switch_default___0: /* CIL Label */ 
#line 316
    return ((ngx_int_t )11);
    switch_break___2: /* CIL Label */ ;
    }
#line 318
    goto switch_break;
    case_4___0: /* CIL Label */ 
    {
#line 322
    if ((int )ch == 47) {
#line 322
      goto case_47;
    }
#line 325
    goto switch_default___1;
    case_47: /* CIL Label */ 
#line 323
    state = (enum __anonenum_state_242 )5;
#line 324
    goto switch_break___3;
    switch_default___1: /* CIL Label */ 
#line 326
    return ((ngx_int_t )11);
    switch_break___3: /* CIL Label */ ;
    }
#line 328
    goto switch_break;
    case_5___0: /* CIL Label */ 
    {
#line 332
    if ((int )ch == 47) {
#line 332
      goto case_47___0;
    }
#line 335
    goto switch_default___2;
    case_47___0: /* CIL Label */ 
#line 333
    state = (enum __anonenum_state_242 )6;
#line 334
    goto switch_break___4;
    switch_default___2: /* CIL Label */ 
#line 336
    return ((ngx_int_t )11);
    switch_break___4: /* CIL Label */ ;
    }
#line 338
    goto switch_break;
    case_6___0: /* CIL Label */ 
#line 342
    r->host_start = p;
#line 344
    if ((int )ch == 91) {
#line 345
      state = (enum __anonenum_state_242 )9;
#line 346
      goto switch_break;
    }
#line 349
    state = (enum __anonenum_state_242 )7;
    case_7___0: /* CIL Label */ 
#line 355
    c = (u_char )((int )ch | 32);
#line 356
    if ((int )c >= 97) {
#line 356
      if ((int )c <= 122) {
#line 357
        goto switch_break;
      }
    }
#line 360
    if ((int )ch >= 48) {
#line 360
      if ((int )ch <= 57) {
#line 361
        goto switch_break;
      } else {
#line 360
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 360
    if ((int )ch == 46) {
#line 361
      goto switch_break;
    } else
#line 360
    if ((int )ch == 45) {
#line 361
      goto switch_break;
    }
    case_8___0: /* CIL Label */ 
#line 368
    r->host_end = p;
    {
#line 371
    if ((int )ch == 58) {
#line 371
      goto case_58___0;
    }
#line 374
    if ((int )ch == 47) {
#line 374
      goto case_47___1;
    }
#line 378
    if ((int )ch == 32) {
#line 378
      goto case_32___0;
    }
#line 387
    goto switch_default___3;
    case_58___0: /* CIL Label */ 
#line 372
    state = (enum __anonenum_state_242 )10;
#line 373
    goto switch_break___5;
    case_47___1: /* CIL Label */ 
#line 375
    r->uri_start = p;
#line 376
    state = (enum __anonenum_state_242 )12;
#line 377
    goto switch_break___5;
    case_32___0: /* CIL Label */ 
#line 383
    r->uri_start = r->schema_end + 1;
#line 384
    r->uri_end = r->schema_end + 2;
#line 385
    state = (enum __anonenum_state_242 )11;
#line 386
    goto switch_break___5;
    switch_default___3: /* CIL Label */ 
#line 388
    return ((ngx_int_t )11);
    switch_break___5: /* CIL Label */ ;
    }
#line 390
    goto switch_break;
    case_9___0: /* CIL Label */ 
#line 394
    if ((int )ch >= 48) {
#line 394
      if ((int )ch <= 57) {
#line 395
        goto switch_break;
      }
    }
#line 398
    c = (u_char )((int )ch | 32);
#line 399
    if ((int )c >= 97) {
#line 399
      if ((int )c <= 122) {
#line 400
        goto switch_break;
      }
    }
    {
#line 404
    if ((int )ch == 58) {
#line 404
      goto case_58___1;
    }
#line 406
    if ((int )ch == 93) {
#line 406
      goto case_93;
    }
#line 412
    if ((int )ch == 126) {
#line 412
      goto case_126;
    }
#line 412
    if ((int )ch == 95) {
#line 412
      goto case_126;
    }
#line 412
    if ((int )ch == 46) {
#line 412
      goto case_126;
    }
#line 412
    if ((int )ch == 45) {
#line 412
      goto case_126;
    }
#line 425
    if ((int )ch == 61) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 59) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 44) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 43) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 42) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 41) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 40) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 39) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 38) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 36) {
#line 425
      goto case_61;
    }
#line 425
    if ((int )ch == 33) {
#line 425
      goto case_61;
    }
#line 428
    goto switch_default___4;
    case_58___1: /* CIL Label */ 
#line 405
    goto switch_break___6;
    case_93: /* CIL Label */ 
#line 407
    state = (enum __anonenum_state_242 )8;
#line 408
    goto switch_break___6;
    case_126: /* CIL Label */ 
    case_95: /* CIL Label */ 
    case_46: /* CIL Label */ 
    case_45: /* CIL Label */ 
#line 414
    goto switch_break___6;
    case_61: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_33: /* CIL Label */ 
#line 427
    goto switch_break___6;
    switch_default___4: /* CIL Label */ 
#line 429
    return ((ngx_int_t )11);
    switch_break___6: /* CIL Label */ ;
    }
#line 431
    goto switch_break;
    case_10: /* CIL Label */ 
#line 434
    if ((int )ch >= 48) {
#line 434
      if ((int )ch <= 57) {
#line 435
        goto switch_break;
      }
    }
    {
#line 439
    if ((int )ch == 47) {
#line 439
      goto case_47___2;
    }
#line 444
    if ((int )ch == 32) {
#line 444
      goto case_32___1;
    }
#line 454
    goto switch_default___5;
    case_47___2: /* CIL Label */ 
#line 440
    r->port_end = p;
#line 441
    r->uri_start = p;
#line 442
    state = (enum __anonenum_state_242 )12;
#line 443
    goto switch_break___7;
    case_32___1: /* CIL Label */ 
#line 445
    r->port_end = p;
#line 450
    r->uri_start = r->schema_end + 1;
#line 451
    r->uri_end = r->schema_end + 2;
#line 452
    state = (enum __anonenum_state_242 )11;
#line 453
    goto switch_break___7;
    switch_default___5: /* CIL Label */ 
#line 455
    return ((ngx_int_t )11);
    switch_break___7: /* CIL Label */ ;
    }
#line 457
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 462
    if ((int )ch == 32) {
#line 462
      goto case_32___2;
    }
#line 464
    if ((int )ch == 13) {
#line 464
      goto case_13;
    }
#line 468
    if ((int )ch == 10) {
#line 468
      goto case_10___0;
    }
#line 471
    if ((int )ch == 72) {
#line 471
      goto case_72;
    }
#line 475
    goto switch_default___6;
    case_32___2: /* CIL Label */ 
#line 463
    goto switch_break___8;
    case_13: /* CIL Label */ 
#line 465
    r->http_minor = 9U;
#line 466
    state = (enum __anonenum_state_242 )26;
#line 467
    goto switch_break___8;
    case_10___0: /* CIL Label */ 
#line 469
    r->http_minor = 9U;
#line 470
    goto done;
    case_72: /* CIL Label */ 
#line 472
    r->http_protocol.data = p;
#line 473
    state = (enum __anonenum_state_242 )17;
#line 474
    goto switch_break___8;
    switch_default___6: /* CIL Label */ 
#line 476
    return ((ngx_int_t )11);
    switch_break___8: /* CIL Label */ ;
    }
#line 478
    goto switch_break;
    case_12: /* CIL Label */ 
#line 484
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 485
      state = (enum __anonenum_state_242 )13;
#line 486
      goto switch_break;
    }
    {
#line 490
    if ((int )ch == 32) {
#line 490
      goto case_32___3;
    }
#line 494
    if ((int )ch == 13) {
#line 494
      goto case_13___0;
    }
#line 499
    if ((int )ch == 10) {
#line 499
      goto case_10___1;
    }
#line 503
    if ((int )ch == 46) {
#line 503
      goto case_46___0;
    }
#line 507
    if ((int )ch == 37) {
#line 507
      goto case_37;
    }
#line 511
    if ((int )ch == 47) {
#line 511
      goto case_47___3;
    }
#line 521
    if ((int )ch == 63) {
#line 521
      goto case_63;
    }
#line 525
    if ((int )ch == 35) {
#line 525
      goto case_35;
    }
#line 529
    if ((int )ch == 43) {
#line 529
      goto case_43___0;
    }
#line 532
    if ((int )ch == 0) {
#line 532
      goto case_0___0;
    }
#line 534
    goto switch_default___7;
    case_32___3: /* CIL Label */ 
#line 491
    r->uri_end = p;
#line 492
    state = (enum __anonenum_state_242 )14;
#line 493
    goto switch_break___9;
    case_13___0: /* CIL Label */ 
#line 495
    r->uri_end = p;
#line 496
    r->http_minor = 9U;
#line 497
    state = (enum __anonenum_state_242 )26;
#line 498
    goto switch_break___9;
    case_10___1: /* CIL Label */ 
#line 500
    r->uri_end = p;
#line 501
    r->http_minor = 9U;
#line 502
    goto done;
    case_46___0: /* CIL Label */ 
#line 504
    r->complex_uri = 1U;
#line 505
    state = (enum __anonenum_state_242 )15;
#line 506
    goto switch_break___9;
    case_37: /* CIL Label */ 
#line 508
    r->quoted_uri = 1U;
#line 509
    state = (enum __anonenum_state_242 )15;
#line 510
    goto switch_break___9;
    case_47___3: /* CIL Label */ 
#line 512
    r->complex_uri = 1U;
#line 513
    state = (enum __anonenum_state_242 )15;
#line 514
    goto switch_break___9;
    case_63: /* CIL Label */ 
#line 522
    r->args_start = p + 1;
#line 523
    state = (enum __anonenum_state_242 )15;
#line 524
    goto switch_break___9;
    case_35: /* CIL Label */ 
#line 526
    r->complex_uri = 1U;
#line 527
    state = (enum __anonenum_state_242 )15;
#line 528
    goto switch_break___9;
    case_43___0: /* CIL Label */ 
#line 530
    r->plus_in_uri = 1U;
#line 531
    goto switch_break___9;
    case_0___0: /* CIL Label */ 
#line 533
    return ((ngx_int_t )11);
    switch_default___7: /* CIL Label */ 
#line 535
    state = (enum __anonenum_state_242 )13;
#line 536
    goto switch_break___9;
    switch_break___9: /* CIL Label */ ;
    }
#line 538
    goto switch_break;
    case_13___1: /* CIL Label */ 
#line 543
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 544
      goto switch_break;
    }
    {
#line 548
    if ((int )ch == 47) {
#line 548
      goto case_47___4;
    }
#line 559
    if ((int )ch == 46) {
#line 559
      goto case_46___1;
    }
#line 562
    if ((int )ch == 32) {
#line 562
      goto case_32___4;
    }
#line 566
    if ((int )ch == 13) {
#line 566
      goto case_13___2;
    }
#line 571
    if ((int )ch == 10) {
#line 571
      goto case_10___2;
    }
#line 581
    if ((int )ch == 37) {
#line 581
      goto case_37___0;
    }
#line 585
    if ((int )ch == 63) {
#line 585
      goto case_63___0;
    }
#line 589
    if ((int )ch == 35) {
#line 589
      goto case_35___0;
    }
#line 593
    if ((int )ch == 43) {
#line 593
      goto case_43___1;
    }
#line 596
    if ((int )ch == 0) {
#line 596
      goto case_0___1;
    }
#line 547
    goto switch_break___10;
    case_47___4: /* CIL Label */ 
#line 556
    r->uri_ext = (u_char *)((void *)0);
#line 557
    state = (enum __anonenum_state_242 )12;
#line 558
    goto switch_break___10;
    case_46___1: /* CIL Label */ 
#line 560
    r->uri_ext = p + 1;
#line 561
    goto switch_break___10;
    case_32___4: /* CIL Label */ 
#line 563
    r->uri_end = p;
#line 564
    state = (enum __anonenum_state_242 )14;
#line 565
    goto switch_break___10;
    case_13___2: /* CIL Label */ 
#line 567
    r->uri_end = p;
#line 568
    r->http_minor = 9U;
#line 569
    state = (enum __anonenum_state_242 )26;
#line 570
    goto switch_break___10;
    case_10___2: /* CIL Label */ 
#line 572
    r->uri_end = p;
#line 573
    r->http_minor = 9U;
#line 574
    goto done;
    case_37___0: /* CIL Label */ 
#line 582
    r->quoted_uri = 1U;
#line 583
    state = (enum __anonenum_state_242 )15;
#line 584
    goto switch_break___10;
    case_63___0: /* CIL Label */ 
#line 586
    r->args_start = p + 1;
#line 587
    state = (enum __anonenum_state_242 )15;
#line 588
    goto switch_break___10;
    case_35___0: /* CIL Label */ 
#line 590
    r->complex_uri = 1U;
#line 591
    state = (enum __anonenum_state_242 )15;
#line 592
    goto switch_break___10;
    case_43___1: /* CIL Label */ 
#line 594
    r->plus_in_uri = 1U;
#line 595
    goto switch_break___10;
    case_0___1: /* CIL Label */ 
#line 597
    return ((ngx_int_t )11);
    switch_break___10: /* CIL Label */ ;
    }
#line 599
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 604
    if ((int )ch == 32) {
#line 604
      goto case_32___5;
    }
#line 606
    if ((int )ch == 13) {
#line 606
      goto case_13___3;
    }
#line 610
    if ((int )ch == 10) {
#line 610
      goto case_10___3;
    }
#line 613
    if ((int )ch == 72) {
#line 613
      goto case_72___0;
    }
#line 617
    goto switch_default___8;
    case_32___5: /* CIL Label */ 
#line 605
    goto switch_break___11;
    case_13___3: /* CIL Label */ 
#line 607
    r->http_minor = 9U;
#line 608
    state = (enum __anonenum_state_242 )26;
#line 609
    goto switch_break___11;
    case_10___3: /* CIL Label */ 
#line 611
    r->http_minor = 9U;
#line 612
    goto done;
    case_72___0: /* CIL Label */ 
#line 614
    r->http_protocol.data = p;
#line 615
    state = (enum __anonenum_state_242 )17;
#line 616
    goto switch_break___11;
    switch_default___8: /* CIL Label */ 
#line 618
    r->space_in_uri = 1U;
#line 619
    state = (enum __anonenum_state_242 )13;
#line 620
    p --;
#line 621
    goto switch_break___11;
    switch_break___11: /* CIL Label */ ;
    }
#line 623
    goto switch_break;
    case_15: /* CIL Label */ 
#line 629
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 630
      goto switch_break;
    }
    {
#line 634
    if ((int )ch == 32) {
#line 634
      goto case_32___6;
    }
#line 638
    if ((int )ch == 13) {
#line 638
      goto case_13___4;
    }
#line 643
    if ((int )ch == 10) {
#line 643
      goto case_10___4;
    }
#line 647
    if ((int )ch == 35) {
#line 647
      goto case_35___1;
    }
#line 650
    if ((int )ch == 0) {
#line 650
      goto case_0___2;
    }
#line 633
    goto switch_break___12;
    case_32___6: /* CIL Label */ 
#line 635
    r->uri_end = p;
#line 636
    state = (enum __anonenum_state_242 )16;
#line 637
    goto switch_break___12;
    case_13___4: /* CIL Label */ 
#line 639
    r->uri_end = p;
#line 640
    r->http_minor = 9U;
#line 641
    state = (enum __anonenum_state_242 )26;
#line 642
    goto switch_break___12;
    case_10___4: /* CIL Label */ 
#line 644
    r->uri_end = p;
#line 645
    r->http_minor = 9U;
#line 646
    goto done;
    case_35___1: /* CIL Label */ 
#line 648
    r->complex_uri = 1U;
#line 649
    goto switch_break___12;
    case_0___2: /* CIL Label */ 
#line 651
    return ((ngx_int_t )11);
    switch_break___12: /* CIL Label */ ;
    }
#line 653
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 658
    if ((int )ch == 32) {
#line 658
      goto case_32___7;
    }
#line 660
    if ((int )ch == 13) {
#line 660
      goto case_13___5;
    }
#line 664
    if ((int )ch == 10) {
#line 664
      goto case_10___5;
    }
#line 667
    if ((int )ch == 72) {
#line 667
      goto case_72___1;
    }
#line 671
    goto switch_default___9;
    case_32___7: /* CIL Label */ 
#line 659
    goto switch_break___13;
    case_13___5: /* CIL Label */ 
#line 661
    r->http_minor = 9U;
#line 662
    state = (enum __anonenum_state_242 )26;
#line 663
    goto switch_break___13;
    case_10___5: /* CIL Label */ 
#line 665
    r->http_minor = 9U;
#line 666
    goto done;
    case_72___1: /* CIL Label */ 
#line 668
    r->http_protocol.data = p;
#line 669
    state = (enum __anonenum_state_242 )17;
#line 670
    goto switch_break___13;
    switch_default___9: /* CIL Label */ 
#line 672
    r->space_in_uri = 1U;
#line 673
    state = (enum __anonenum_state_242 )15;
#line 674
    p --;
#line 675
    goto switch_break___13;
    switch_break___13: /* CIL Label */ ;
    }
#line 677
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 681
    if ((int )ch == 84) {
#line 681
      goto case_84;
    }
#line 684
    goto switch_default___10;
    case_84: /* CIL Label */ 
#line 682
    state = (enum __anonenum_state_242 )18;
#line 683
    goto switch_break___14;
    switch_default___10: /* CIL Label */ 
#line 685
    return ((ngx_int_t )11);
    switch_break___14: /* CIL Label */ ;
    }
#line 687
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 691
    if ((int )ch == 84) {
#line 691
      goto case_84___0;
    }
#line 694
    goto switch_default___11;
    case_84___0: /* CIL Label */ 
#line 692
    state = (enum __anonenum_state_242 )19;
#line 693
    goto switch_break___15;
    switch_default___11: /* CIL Label */ 
#line 695
    return ((ngx_int_t )11);
    switch_break___15: /* CIL Label */ ;
    }
#line 697
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 701
    if ((int )ch == 80) {
#line 701
      goto case_80;
    }
#line 704
    goto switch_default___12;
    case_80: /* CIL Label */ 
#line 702
    state = (enum __anonenum_state_242 )20;
#line 703
    goto switch_break___16;
    switch_default___12: /* CIL Label */ 
#line 705
    return ((ngx_int_t )11);
    switch_break___16: /* CIL Label */ ;
    }
#line 707
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 711
    if ((int )ch == 47) {
#line 711
      goto case_47___5;
    }
#line 714
    goto switch_default___13;
    case_47___5: /* CIL Label */ 
#line 712
    state = (enum __anonenum_state_242 )21;
#line 713
    goto switch_break___17;
    switch_default___13: /* CIL Label */ 
#line 715
    return ((ngx_int_t )11);
    switch_break___17: /* CIL Label */ ;
    }
#line 717
    goto switch_break;
    case_21: /* CIL Label */ 
#line 721
    if ((int )ch < 49) {
#line 722
      return ((ngx_int_t )11);
    } else
#line 721
    if ((int )ch > 57) {
#line 722
      return ((ngx_int_t )11);
    }
#line 725
    r->http_major = (unsigned int )((int )ch - 48);
#line 727
    if (r->http_major > 1U) {
#line 728
      return ((ngx_int_t )12);
    }
#line 731
    state = (enum __anonenum_state_242 )22;
#line 732
    goto switch_break;
    case_22: /* CIL Label */ 
#line 736
    if ((int )ch == 46) {
#line 737
      state = (enum __anonenum_state_242 )23;
#line 738
      goto switch_break;
    }
#line 741
    if ((int )ch < 48) {
#line 742
      return ((ngx_int_t )11);
    } else
#line 741
    if ((int )ch > 57) {
#line 742
      return ((ngx_int_t )11);
    }
#line 745
    r->http_major = r->http_major * 10U + (unsigned int )((int )ch - 48);
#line 747
    if (r->http_major > 1U) {
#line 748
      return ((ngx_int_t )12);
    }
#line 751
    goto switch_break;
    case_23: /* CIL Label */ 
#line 755
    if ((int )ch < 48) {
#line 756
      return ((ngx_int_t )11);
    } else
#line 755
    if ((int )ch > 57) {
#line 756
      return ((ngx_int_t )11);
    }
#line 759
    r->http_minor = (unsigned int )((int )ch - 48);
#line 760
    state = (enum __anonenum_state_242 )24;
#line 761
    goto switch_break;
    case_24: /* CIL Label */ 
#line 765
    if ((int )ch == 13) {
#line 766
      state = (enum __anonenum_state_242 )26;
#line 767
      goto switch_break;
    }
#line 770
    if ((int )ch == 10) {
#line 771
      goto done;
    }
#line 774
    if ((int )ch == 32) {
#line 775
      state = (enum __anonenum_state_242 )25;
#line 776
      goto switch_break;
    }
#line 779
    if ((int )ch < 48) {
#line 780
      return ((ngx_int_t )11);
    } else
#line 779
    if ((int )ch > 57) {
#line 780
      return ((ngx_int_t )11);
    }
#line 783
    if (r->http_minor > 99U) {
#line 784
      return ((ngx_int_t )11);
    }
#line 787
    r->http_minor = r->http_minor * 10U + (unsigned int )((int )ch - 48);
#line 788
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 792
    if ((int )ch == 32) {
#line 792
      goto case_32___8;
    }
#line 794
    if ((int )ch == 13) {
#line 794
      goto case_13___6;
    }
#line 797
    if ((int )ch == 10) {
#line 797
      goto case_10___6;
    }
#line 799
    goto switch_default___14;
    case_32___8: /* CIL Label */ 
#line 793
    goto switch_break___18;
    case_13___6: /* CIL Label */ 
#line 795
    state = (enum __anonenum_state_242 )26;
#line 796
    goto switch_break___18;
    case_10___6: /* CIL Label */ 
#line 798
    goto done;
    switch_default___14: /* CIL Label */ 
#line 800
    return ((ngx_int_t )11);
    switch_break___18: /* CIL Label */ ;
    }
#line 802
    goto switch_break;
    case_26: /* CIL Label */ 
#line 806
    r->request_end = p - 1;
    {
#line 808
    if ((int )ch == 10) {
#line 808
      goto case_10___7;
    }
#line 810
    goto switch_default___15;
    case_10___7: /* CIL Label */ 
#line 809
    goto done;
    switch_default___15: /* CIL Label */ 
#line 811
    return ((ngx_int_t )11);
    switch_break___19: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 139
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 816
  b->pos = p;
#line 817
  r->state = (ngx_uint_t )state;
#line 819
  return ((ngx_int_t )-2);
  done: 
#line 823
  b->pos = p + 1;
#line 825
  if ((unsigned long )r->request_end == (unsigned long )((void *)0)) {
#line 826
    r->request_end = p;
  }
#line 829
  r->http_version = (ngx_uint_t )(r->http_major * 1000U + r->http_minor);
#line 830
  r->state = (ngx_uint_t )0;
#line 832
  if (r->http_version == 9UL) {
#line 832
    if (r->method != 2UL) {
#line 833
      return ((ngx_int_t )13);
    }
  }
#line 836
  return ((ngx_int_t )0);
}
}
#line 859 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
static u_char lowcase[256]  = 
#line 859
  {      (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'-',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'a',      (u_char )'b',      (u_char )'c', 
        (u_char )'d',      (u_char )'e',      (u_char )'f',      (u_char )'g', 
        (u_char )'h',      (u_char )'i',      (u_char )'j',      (u_char )'k', 
        (u_char )'l',      (u_char )'m',      (u_char )'n',      (u_char )'o', 
        (u_char )'p',      (u_char )'q',      (u_char )'r',      (u_char )'s', 
        (u_char )'t',      (u_char )'u',      (u_char )'v',      (u_char )'w', 
        (u_char )'x',      (u_char )'y',      (u_char )'z',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'a',      (u_char )'b',      (u_char )'c', 
        (u_char )'d',      (u_char )'e',      (u_char )'f',      (u_char )'g', 
        (u_char )'h',      (u_char )'i',      (u_char )'j',      (u_char )'k', 
        (u_char )'l',      (u_char )'m',      (u_char )'n',      (u_char )'o', 
        (u_char )'p',      (u_char )'q',      (u_char )'r',      (u_char )'s', 
        (u_char )'t',      (u_char )'u',      (u_char )'v',      (u_char )'w', 
        (u_char )'x',      (u_char )'y',      (u_char )'z',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000', 
        (u_char )'\000',      (u_char )'\000',      (u_char )'\000',      (u_char )'\000'};
#line 840 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_header_line(ngx_http_request_t *r , ngx_buf_t *b , ngx_uint_t allow_underscores ) 
{ 
  u_char c ;
  u_char ch ;
  u_char *p ;
  ngx_uint_t hash ;
  ngx_uint_t i ;
  enum __anonenum_state_243___0 state ;
  ngx_uint_t tmp ;
  ngx_uint_t tmp___0 ;
  int tmp___1 ;

  {
#line 869
  state = (enum __anonenum_state_243___0 )r->state;
#line 870
  hash = r->header_hash;
#line 871
  i = r->lowcase_index;
#line 873
  p = b->pos;
  {
#line 873
  while (1) {
    while_continue: /* CIL Label */ ;
#line 873
    if (! ((unsigned long )p < (unsigned long )b->last)) {
#line 873
      goto while_break;
    }
#line 874
    ch = *p;
    {
#line 879
    if ((unsigned int )state == 0U) {
#line 879
      goto case_0;
    }
#line 928
    if ((unsigned int )state == 1U) {
#line 928
      goto case_1;
    }
#line 991
    if ((unsigned int )state == 2U) {
#line 991
      goto case_2;
    }
#line 1014
    if ((unsigned int )state == 3U) {
#line 1014
      goto case_3;
    }
#line 1033
    if ((unsigned int )state == 4U) {
#line 1033
      goto case_4;
    }
#line 1051
    if ((unsigned int )state == 5U) {
#line 1051
      goto case_5;
    }
#line 1062
    if ((unsigned int )state == 6U) {
#line 1062
      goto case_6;
    }
#line 1074
    if ((unsigned int )state == 7U) {
#line 1074
      goto case_7;
    }
#line 876
    goto switch_break;
    case_0: /* CIL Label */ 
#line 880
    r->header_name_start = p;
#line 881
    r->invalid_header = 0U;
    {
#line 884
    if ((int )ch == 13) {
#line 884
      goto case_13;
    }
#line 888
    if ((int )ch == 10) {
#line 888
      goto case_10;
    }
#line 891
    goto switch_default;
    case_13: /* CIL Label */ 
#line 885
    r->header_end = p;
#line 886
    state = (enum __anonenum_state_243___0 )7;
#line 887
    goto switch_break___0;
    case_10: /* CIL Label */ 
#line 889
    r->header_end = p;
#line 890
    goto header_done;
    switch_default: /* CIL Label */ 
#line 892
    state = (enum __anonenum_state_243___0 )1;
#line 894
    c = lowcase[ch];
#line 896
    if (c) {
#line 897
      hash = (ngx_uint_t )c;
#line 898
      r->lowcase_header[0] = c;
#line 899
      i = (ngx_uint_t )1;
#line 900
      goto switch_break___0;
    }
#line 903
    if ((int )ch == 95) {
#line 904
      if (allow_underscores) {
#line 905
        hash = (ngx_uint_t )ch;
#line 906
        r->lowcase_header[0] = ch;
#line 907
        i = (ngx_uint_t )1;
      } else {
#line 910
        r->invalid_header = 1U;
      }
#line 913
      goto switch_break___0;
    }
#line 916
    if ((int )ch == 0) {
#line 917
      return ((ngx_int_t )14);
    }
#line 920
    r->invalid_header = 1U;
#line 922
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 925
    goto switch_break;
    case_1: /* CIL Label */ 
#line 929
    c = lowcase[ch];
#line 931
    if (c) {
#line 932
      hash = hash * 31UL + (ngx_uint_t )c;
#line 933
      tmp = i;
#line 933
      i ++;
#line 933
      r->lowcase_header[tmp] = c;
#line 934
      i &= 31UL;
#line 935
      goto switch_break;
    }
#line 938
    if ((int )ch == 95) {
#line 939
      if (allow_underscores) {
#line 940
        hash = hash * 31UL + (ngx_uint_t )ch;
#line 941
        tmp___0 = i;
#line 941
        i ++;
#line 941
        r->lowcase_header[tmp___0] = ch;
#line 942
        i &= 31UL;
      } else {
#line 945
        r->invalid_header = 1U;
      }
#line 948
      goto switch_break;
    }
#line 951
    if ((int )ch == 58) {
#line 952
      r->header_name_end = p;
#line 953
      state = (enum __anonenum_state_243___0 )2;
#line 954
      goto switch_break;
    }
#line 957
    if ((int )ch == 13) {
#line 958
      r->header_name_end = p;
#line 959
      r->header_start = p;
#line 960
      r->header_end = p;
#line 961
      state = (enum __anonenum_state_243___0 )6;
#line 962
      goto switch_break;
    }
#line 965
    if ((int )ch == 10) {
#line 966
      r->header_name_end = p;
#line 967
      r->header_start = p;
#line 968
      r->header_end = p;
#line 969
      goto done;
    }
#line 973
    if ((int )ch == 47) {
#line 973
      if (r->upstream) {
#line 973
        if (p - r->header_name_start == 4L) {
          {
#line 973
          tmp___1 = strncmp((char const   *)r->header_name_start, "HTTP", (size_t )4);
          }
#line 973
          if (tmp___1 == 0) {
#line 978
            state = (enum __anonenum_state_243___0 )5;
#line 979
            goto switch_break;
          }
        }
      }
    }
#line 982
    if ((int )ch == 0) {
#line 983
      return ((ngx_int_t )14);
    }
#line 986
    r->invalid_header = 1U;
#line 988
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 993
    if ((int )ch == 32) {
#line 993
      goto case_32;
    }
#line 995
    if ((int )ch == 13) {
#line 995
      goto case_13___0;
    }
#line 1000
    if ((int )ch == 10) {
#line 1000
      goto case_10___0;
    }
#line 1004
    if ((int )ch == 0) {
#line 1004
      goto case_0___0;
    }
#line 1006
    goto switch_default___0;
    case_32: /* CIL Label */ 
#line 994
    goto switch_break___1;
    case_13___0: /* CIL Label */ 
#line 996
    r->header_start = p;
#line 997
    r->header_end = p;
#line 998
    state = (enum __anonenum_state_243___0 )6;
#line 999
    goto switch_break___1;
    case_10___0: /* CIL Label */ 
#line 1001
    r->header_start = p;
#line 1002
    r->header_end = p;
#line 1003
    goto done;
    case_0___0: /* CIL Label */ 
#line 1005
    return ((ngx_int_t )14);
    switch_default___0: /* CIL Label */ 
#line 1007
    r->header_start = p;
#line 1008
    state = (enum __anonenum_state_243___0 )3;
#line 1009
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1011
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1016
    if ((int )ch == 32) {
#line 1016
      goto case_32___0;
    }
#line 1020
    if ((int )ch == 13) {
#line 1020
      goto case_13___1;
    }
#line 1024
    if ((int )ch == 10) {
#line 1024
      goto case_10___1;
    }
#line 1027
    if ((int )ch == 0) {
#line 1027
      goto case_0___1;
    }
#line 1015
    goto switch_break___2;
    case_32___0: /* CIL Label */ 
#line 1017
    r->header_end = p;
#line 1018
    state = (enum __anonenum_state_243___0 )4;
#line 1019
    goto switch_break___2;
    case_13___1: /* CIL Label */ 
#line 1021
    r->header_end = p;
#line 1022
    state = (enum __anonenum_state_243___0 )6;
#line 1023
    goto switch_break___2;
    case_10___1: /* CIL Label */ 
#line 1025
    r->header_end = p;
#line 1026
    goto done;
    case_0___1: /* CIL Label */ 
#line 1028
    return ((ngx_int_t )14);
    switch_break___2: /* CIL Label */ ;
    }
#line 1030
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1035
    if ((int )ch == 32) {
#line 1035
      goto case_32___1;
    }
#line 1037
    if ((int )ch == 13) {
#line 1037
      goto case_13___2;
    }
#line 1040
    if ((int )ch == 10) {
#line 1040
      goto case_10___2;
    }
#line 1042
    if ((int )ch == 0) {
#line 1042
      goto case_0___2;
    }
#line 1044
    goto switch_default___1;
    case_32___1: /* CIL Label */ 
#line 1036
    goto switch_break___3;
    case_13___2: /* CIL Label */ 
#line 1038
    state = (enum __anonenum_state_243___0 )6;
#line 1039
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
#line 1041
    goto done;
    case_0___2: /* CIL Label */ 
#line 1043
    return ((ngx_int_t )14);
    switch_default___1: /* CIL Label */ 
#line 1045
    state = (enum __anonenum_state_243___0 )3;
#line 1046
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1048
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 1053
    if ((int )ch == 10) {
#line 1053
      goto case_10___3;
    }
#line 1056
    goto switch_default___2;
    case_10___3: /* CIL Label */ 
#line 1054
    state = (enum __anonenum_state_243___0 )0;
#line 1055
    goto switch_break___4;
    switch_default___2: /* CIL Label */ 
#line 1057
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 1059
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 1064
    if ((int )ch == 10) {
#line 1064
      goto case_10___4;
    }
#line 1066
    if ((int )ch == 13) {
#line 1066
      goto case_13___3;
    }
#line 1068
    goto switch_default___3;
    case_10___4: /* CIL Label */ 
#line 1065
    goto done;
    case_13___3: /* CIL Label */ 
#line 1067
    goto switch_break___5;
    switch_default___3: /* CIL Label */ 
#line 1069
    return ((ngx_int_t )14);
    switch_break___5: /* CIL Label */ ;
    }
#line 1071
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 1076
    if ((int )ch == 10) {
#line 1076
      goto case_10___5;
    }
#line 1078
    goto switch_default___4;
    case_10___5: /* CIL Label */ 
#line 1077
    goto header_done;
    switch_default___4: /* CIL Label */ 
#line 1079
    return ((ngx_int_t )14);
    switch_break___6: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 873
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1084
  b->pos = p;
#line 1085
  r->state = (ngx_uint_t )state;
#line 1086
  r->header_hash = hash;
#line 1087
  r->lowcase_index = i;
#line 1089
  return ((ngx_int_t )-2);
  done: 
#line 1093
  b->pos = p + 1;
#line 1094
  r->state = (ngx_uint_t )0;
#line 1095
  r->header_hash = hash;
#line 1096
  r->lowcase_index = i;
#line 1098
  return ((ngx_int_t )0);
  header_done: 
#line 1102
  b->pos = p + 1;
#line 1103
  r->state = (ngx_uint_t )0;
#line 1105
  return ((ngx_int_t )1);
}
}
#line 1109 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_uri(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char ch ;
  enum __anonenum_state_244 state ;

  {
#line 1120
  state = (enum __anonenum_state_244 )0;
#line 1122
  p = r->uri_start;
  {
#line 1122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1122
    if (! ((unsigned long )p != (unsigned long )r->uri_end)) {
#line 1122
      goto while_break;
    }
#line 1124
    ch = *p;
    {
#line 1128
    if ((unsigned int )state == 0U) {
#line 1128
      goto case_0;
    }
#line 1138
    if ((unsigned int )state == 1U) {
#line 1138
      goto case_1;
    }
#line 1186
    if ((unsigned int )state == 2U) {
#line 1186
      goto case_2;
    }
#line 1235
    if ((unsigned int )state == 3U) {
#line 1235
      goto case_3;
    }
#line 1126
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1130
    if ((int )ch != 47) {
#line 1131
      return ((ngx_int_t )-1);
    }
#line 1134
    state = (enum __anonenum_state_244 )1;
#line 1135
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1140
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1141
      state = (enum __anonenum_state_244 )2;
#line 1142
      goto switch_break;
    }
    {
#line 1146
    if ((int )ch == 32) {
#line 1146
      goto case_32;
    }
#line 1150
    if ((int )ch == 46) {
#line 1150
      goto case_46;
    }
#line 1154
    if ((int )ch == 37) {
#line 1154
      goto case_37;
    }
#line 1158
    if ((int )ch == 47) {
#line 1158
      goto case_47;
    }
#line 1168
    if ((int )ch == 63) {
#line 1168
      goto case_63;
    }
#line 1172
    if ((int )ch == 35) {
#line 1172
      goto case_35;
    }
#line 1176
    if ((int )ch == 43) {
#line 1176
      goto case_43;
    }
#line 1179
    goto switch_default;
    case_32: /* CIL Label */ 
#line 1147
    r->space_in_uri = 1U;
#line 1148
    state = (enum __anonenum_state_244 )2;
#line 1149
    goto switch_break___0;
    case_46: /* CIL Label */ 
#line 1151
    r->complex_uri = 1U;
#line 1152
    state = (enum __anonenum_state_244 )3;
#line 1153
    goto switch_break___0;
    case_37: /* CIL Label */ 
#line 1155
    r->quoted_uri = 1U;
#line 1156
    state = (enum __anonenum_state_244 )3;
#line 1157
    goto switch_break___0;
    case_47: /* CIL Label */ 
#line 1159
    r->complex_uri = 1U;
#line 1160
    state = (enum __anonenum_state_244 )3;
#line 1161
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 1169
    r->args_start = p + 1;
#line 1170
    state = (enum __anonenum_state_244 )3;
#line 1171
    goto switch_break___0;
    case_35: /* CIL Label */ 
#line 1173
    r->complex_uri = 1U;
#line 1174
    state = (enum __anonenum_state_244 )3;
#line 1175
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 1177
    r->plus_in_uri = 1U;
#line 1178
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1180
    state = (enum __anonenum_state_244 )2;
#line 1181
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1183
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1188
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1189
      goto switch_break;
    }
    {
#line 1193
    if ((int )ch == 47) {
#line 1193
      goto case_47___0;
    }
#line 1204
    if ((int )ch == 46) {
#line 1204
      goto case_46___0;
    }
#line 1207
    if ((int )ch == 32) {
#line 1207
      goto case_32___0;
    }
#line 1216
    if ((int )ch == 37) {
#line 1216
      goto case_37___0;
    }
#line 1220
    if ((int )ch == 63) {
#line 1220
      goto case_63___0;
    }
#line 1224
    if ((int )ch == 35) {
#line 1224
      goto case_35___0;
    }
#line 1228
    if ((int )ch == 43) {
#line 1228
      goto case_43___0;
    }
#line 1192
    goto switch_break___1;
    case_47___0: /* CIL Label */ 
#line 1201
    r->uri_ext = (u_char *)((void *)0);
#line 1202
    state = (enum __anonenum_state_244 )1;
#line 1203
    goto switch_break___1;
    case_46___0: /* CIL Label */ 
#line 1205
    r->uri_ext = p + 1;
#line 1206
    goto switch_break___1;
    case_32___0: /* CIL Label */ 
#line 1208
    r->space_in_uri = 1U;
#line 1209
    goto switch_break___1;
    case_37___0: /* CIL Label */ 
#line 1217
    r->quoted_uri = 1U;
#line 1218
    state = (enum __anonenum_state_244 )3;
#line 1219
    goto switch_break___1;
    case_63___0: /* CIL Label */ 
#line 1221
    r->args_start = p + 1;
#line 1222
    state = (enum __anonenum_state_244 )3;
#line 1223
    goto switch_break___1;
    case_35___0: /* CIL Label */ 
#line 1225
    r->complex_uri = 1U;
#line 1226
    state = (enum __anonenum_state_244 )3;
#line 1227
    goto switch_break___1;
    case_43___0: /* CIL Label */ 
#line 1229
    r->plus_in_uri = 1U;
#line 1230
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1232
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1237
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1238
      goto switch_break;
    }
    {
#line 1242
    if ((int )ch == 32) {
#line 1242
      goto case_32___1;
    }
#line 1245
    if ((int )ch == 35) {
#line 1245
      goto case_35___1;
    }
#line 1241
    goto switch_break___2;
    case_32___1: /* CIL Label */ 
#line 1243
    r->space_in_uri = 1U;
#line 1244
    goto switch_break___2;
    case_35___1: /* CIL Label */ 
#line 1246
    r->complex_uri = 1U;
#line 1247
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1249
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1122
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1253
  return ((ngx_int_t )0);
}
}
#line 1257 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_complex_uri(ngx_http_request_t *r , ngx_uint_t merge_slashes ) 
{ 
  u_char c ;
  u_char ch ;
  u_char decoded ;
  u_char *p ;
  u_char *u ;
  enum __anonenum_state_245 state ;
  enum __anonenum_state_245 quoted_state ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  u_char *tmp___20 ;
  u_char *tmp___21 ;
  u_char *tmp___22 ;
  u_char *tmp___23 ;
  u_char *tmp___24 ;
  u_char *tmp___25 ;
  u_char *tmp___26 ;
  u_char *tmp___27 ;

  {
#line 1271
  decoded = (u_char )'\000';
#line 1272
  quoted_state = (enum __anonenum_state_245 )0;
#line 1275
  state = (enum __anonenum_state_245 )0;
#line 1276
  p = r->uri_start;
#line 1277
  u = r->uri.data;
#line 1278
  r->uri_ext = (u_char *)((void *)0);
#line 1279
  r->args_start = (u_char *)((void *)0);
#line 1281
  tmp = p;
#line 1281
  p ++;
#line 1281
  ch = *tmp;
  {
#line 1283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1283
    if (! ((unsigned long )p <= (unsigned long )r->uri_end)) {
#line 1283
      goto while_break;
    }
    {
#line 1296
    if ((unsigned int )state == 0U) {
#line 1296
      goto case_0;
    }
#line 1365
    if ((unsigned int )state == 1U) {
#line 1365
      goto case_1;
    }
#line 1409
    if ((unsigned int )state == 2U) {
#line 1409
      goto case_2;
    }
#line 1451
    if ((unsigned int )state == 3U) {
#line 1451
      goto case_3;
    }
#line 1499
    if ((unsigned int )state == 4U) {
#line 1499
      goto case_4;
    }
#line 1519
    if ((unsigned int )state == 5U) {
#line 1519
      goto case_5;
    }
#line 1294
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1298
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1299
      tmp___0 = u;
#line 1299
      u ++;
#line 1299
      *tmp___0 = ch;
#line 1300
      tmp___1 = p;
#line 1300
      p ++;
#line 1300
      ch = *tmp___1;
#line 1301
      goto switch_break;
    }
    {
#line 1329
    if ((int )ch == 47) {
#line 1329
      goto case_47;
    }
#line 1341
    if ((int )ch == 37) {
#line 1341
      goto case_37;
    }
#line 1345
    if ((int )ch == 63) {
#line 1345
      goto case_63;
    }
#line 1348
    if ((int )ch == 35) {
#line 1348
      goto case_35;
    }
#line 1350
    if ((int )ch == 46) {
#line 1350
      goto case_46;
    }
#line 1354
    if ((int )ch == 43) {
#line 1354
      goto case_43;
    }
#line 1357
    goto switch_default;
    case_47: /* CIL Label */ 
#line 1337
    r->uri_ext = (u_char *)((void *)0);
#line 1338
    state = (enum __anonenum_state_245 )1;
#line 1339
    tmp___2 = u;
#line 1339
    u ++;
#line 1339
    *tmp___2 = ch;
#line 1340
    goto switch_break___0;
    case_37: /* CIL Label */ 
#line 1342
    quoted_state = state;
#line 1343
    state = (enum __anonenum_state_245 )4;
#line 1344
    goto switch_break___0;
    case_63: /* CIL Label */ 
#line 1346
    r->args_start = p;
#line 1347
    goto args;
    case_35: /* CIL Label */ 
#line 1349
    goto done;
    case_46: /* CIL Label */ 
#line 1351
    r->uri_ext = u + 1;
#line 1352
    tmp___3 = u;
#line 1352
    u ++;
#line 1352
    *tmp___3 = ch;
#line 1353
    goto switch_break___0;
    case_43: /* CIL Label */ 
#line 1355
    r->plus_in_uri = 1U;
    switch_default: /* CIL Label */ 
#line 1358
    tmp___4 = u;
#line 1358
    u ++;
#line 1358
    *tmp___4 = ch;
#line 1359
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1362
    tmp___5 = p;
#line 1362
    p ++;
#line 1362
    ch = *tmp___5;
#line 1363
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1367
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1368
      state = (enum __anonenum_state_245 )0;
#line 1369
      tmp___6 = u;
#line 1369
      u ++;
#line 1369
      *tmp___6 = ch;
#line 1370
      tmp___7 = p;
#line 1370
      p ++;
#line 1370
      ch = *tmp___7;
#line 1371
      goto switch_break;
    }
    {
#line 1379
    if ((int )ch == 47) {
#line 1379
      goto case_47___0;
    }
#line 1384
    if ((int )ch == 46) {
#line 1384
      goto case_46___0;
    }
#line 1388
    if ((int )ch == 37) {
#line 1388
      goto case_37___0;
    }
#line 1392
    if ((int )ch == 63) {
#line 1392
      goto case_63___0;
    }
#line 1395
    if ((int )ch == 35) {
#line 1395
      goto case_35___0;
    }
#line 1397
    if ((int )ch == 43) {
#line 1397
      goto case_43___0;
    }
#line 1400
    goto switch_default___0;
    case_47___0: /* CIL Label */ 
#line 1380
    if (! merge_slashes) {
#line 1381
      tmp___8 = u;
#line 1381
      u ++;
#line 1381
      *tmp___8 = ch;
    }
#line 1383
    goto switch_break___1;
    case_46___0: /* CIL Label */ 
#line 1385
    state = (enum __anonenum_state_245 )2;
#line 1386
    tmp___9 = u;
#line 1386
    u ++;
#line 1386
    *tmp___9 = ch;
#line 1387
    goto switch_break___1;
    case_37___0: /* CIL Label */ 
#line 1389
    quoted_state = state;
#line 1390
    state = (enum __anonenum_state_245 )4;
#line 1391
    goto switch_break___1;
    case_63___0: /* CIL Label */ 
#line 1393
    r->args_start = p;
#line 1394
    goto args;
    case_35___0: /* CIL Label */ 
#line 1396
    goto done;
    case_43___0: /* CIL Label */ 
#line 1398
    r->plus_in_uri = 1U;
    switch_default___0: /* CIL Label */ 
#line 1401
    state = (enum __anonenum_state_245 )0;
#line 1402
    tmp___10 = u;
#line 1402
    u ++;
#line 1402
    *tmp___10 = ch;
#line 1403
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
#line 1406
    tmp___11 = p;
#line 1406
    p ++;
#line 1406
    ch = *tmp___11;
#line 1407
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1411
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1412
      state = (enum __anonenum_state_245 )0;
#line 1413
      tmp___12 = u;
#line 1413
      u ++;
#line 1413
      *tmp___12 = ch;
#line 1414
      tmp___13 = p;
#line 1414
      p ++;
#line 1414
      ch = *tmp___13;
#line 1415
      goto switch_break;
    }
    {
#line 1422
    if ((int )ch == 47) {
#line 1422
      goto case_47___1;
    }
#line 1426
    if ((int )ch == 46) {
#line 1426
      goto case_46___1;
    }
#line 1430
    if ((int )ch == 37) {
#line 1430
      goto case_37___1;
    }
#line 1434
    if ((int )ch == 63) {
#line 1434
      goto case_63___1;
    }
#line 1437
    if ((int )ch == 35) {
#line 1437
      goto case_35___1;
    }
#line 1439
    if ((int )ch == 43) {
#line 1439
      goto case_43___1;
    }
#line 1442
    goto switch_default___1;
    case_47___1: /* CIL Label */ 
#line 1423
    state = (enum __anonenum_state_245 )1;
#line 1424
    u --;
#line 1425
    goto switch_break___2;
    case_46___1: /* CIL Label */ 
#line 1427
    state = (enum __anonenum_state_245 )3;
#line 1428
    tmp___14 = u;
#line 1428
    u ++;
#line 1428
    *tmp___14 = ch;
#line 1429
    goto switch_break___2;
    case_37___1: /* CIL Label */ 
#line 1431
    quoted_state = state;
#line 1432
    state = (enum __anonenum_state_245 )4;
#line 1433
    goto switch_break___2;
    case_63___1: /* CIL Label */ 
#line 1435
    r->args_start = p;
#line 1436
    goto args;
    case_35___1: /* CIL Label */ 
#line 1438
    goto done;
    case_43___1: /* CIL Label */ 
#line 1440
    r->plus_in_uri = 1U;
    switch_default___1: /* CIL Label */ 
#line 1443
    state = (enum __anonenum_state_245 )0;
#line 1444
    tmp___15 = u;
#line 1444
    u ++;
#line 1444
    *tmp___15 = ch;
#line 1445
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 1448
    tmp___16 = p;
#line 1448
    p ++;
#line 1448
    ch = *tmp___16;
#line 1449
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1453
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1454
      state = (enum __anonenum_state_245 )0;
#line 1455
      tmp___17 = u;
#line 1455
      u ++;
#line 1455
      *tmp___17 = ch;
#line 1456
      tmp___18 = p;
#line 1456
      p ++;
#line 1456
      ch = *tmp___18;
#line 1457
      goto switch_break;
    }
    {
#line 1464
    if ((int )ch == 47) {
#line 1464
      goto case_47___2;
    }
#line 1478
    if ((int )ch == 37) {
#line 1478
      goto case_37___2;
    }
#line 1482
    if ((int )ch == 63) {
#line 1482
      goto case_63___2;
    }
#line 1485
    if ((int )ch == 35) {
#line 1485
      goto case_35___2;
    }
#line 1487
    if ((int )ch == 43) {
#line 1487
      goto case_43___2;
    }
#line 1490
    goto switch_default___2;
    case_47___2: /* CIL Label */ 
#line 1465
    state = (enum __anonenum_state_245 )1;
#line 1466
    u -= 5;
    {
#line 1467
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1468
      if ((unsigned long )u < (unsigned long )r->uri.data) {
#line 1469
        return ((ngx_int_t )11);
      }
#line 1471
      if ((int )*u == 47) {
#line 1472
        u ++;
#line 1473
        goto while_break___0;
      }
#line 1475
      u --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1477
    goto switch_break___3;
    case_37___2: /* CIL Label */ 
#line 1479
    quoted_state = state;
#line 1480
    state = (enum __anonenum_state_245 )4;
#line 1481
    goto switch_break___3;
    case_63___2: /* CIL Label */ 
#line 1483
    r->args_start = p;
#line 1484
    goto args;
    case_35___2: /* CIL Label */ 
#line 1486
    goto done;
    case_43___2: /* CIL Label */ 
#line 1488
    r->plus_in_uri = 1U;
    switch_default___2: /* CIL Label */ 
#line 1491
    state = (enum __anonenum_state_245 )0;
#line 1492
    tmp___19 = u;
#line 1492
    u ++;
#line 1492
    *tmp___19 = ch;
#line 1493
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 1496
    tmp___20 = p;
#line 1496
    p ++;
#line 1496
    ch = *tmp___20;
#line 1497
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1500
    r->quoted_uri = 1U;
#line 1502
    if ((int )ch >= 48) {
#line 1502
      if ((int )ch <= 57) {
#line 1503
        decoded = (u_char )((int )ch - 48);
#line 1504
        state = (enum __anonenum_state_245 )5;
#line 1505
        tmp___21 = p;
#line 1505
        p ++;
#line 1505
        ch = *tmp___21;
#line 1506
        goto switch_break;
      }
    }
#line 1509
    c = (u_char )((int )ch | 32);
#line 1510
    if ((int )c >= 97) {
#line 1510
      if ((int )c <= 102) {
#line 1511
        decoded = (u_char )(((int )c - 97) + 10);
#line 1512
        state = (enum __anonenum_state_245 )5;
#line 1513
        tmp___22 = p;
#line 1513
        p ++;
#line 1513
        ch = *tmp___22;
#line 1514
        goto switch_break;
      }
    }
#line 1517
    return ((ngx_int_t )11);
    case_5: /* CIL Label */ 
#line 1520
    if ((int )ch >= 48) {
#line 1520
      if ((int )ch <= 57) {
#line 1521
        ch = (u_char )(((int )decoded << 4) + ((int )ch - 48));
#line 1523
        if ((int )ch == 37) {
#line 1523
          goto _L;
        } else
#line 1523
        if ((int )ch == 35) {
          _L: /* CIL Label */ 
#line 1524
          state = (enum __anonenum_state_245 )0;
#line 1525
          tmp___23 = u;
#line 1525
          u ++;
#line 1525
          *tmp___23 = ch;
#line 1526
          tmp___24 = p;
#line 1526
          p ++;
#line 1526
          ch = *tmp___24;
#line 1527
          goto switch_break;
        } else
#line 1529
        if ((int )ch == 0) {
#line 1530
          return ((ngx_int_t )11);
        }
#line 1533
        state = quoted_state;
#line 1534
        goto switch_break;
      }
    }
#line 1537
    c = (u_char )((int )ch | 32);
#line 1538
    if ((int )c >= 97) {
#line 1538
      if ((int )c <= 102) {
#line 1539
        ch = (u_char )((((int )decoded << 4) + ((int )c - 97)) + 10);
#line 1541
        if ((int )ch == 63) {
#line 1542
          state = (enum __anonenum_state_245 )0;
#line 1543
          tmp___25 = u;
#line 1543
          u ++;
#line 1543
          *tmp___25 = ch;
#line 1544
          tmp___26 = p;
#line 1544
          p ++;
#line 1544
          ch = *tmp___26;
#line 1545
          goto switch_break;
        } else
#line 1547
        if ((int )ch == 43) {
#line 1548
          r->plus_in_uri = 1U;
        }
#line 1551
        state = quoted_state;
#line 1552
        goto switch_break;
      }
    }
#line 1555
    return ((ngx_int_t )11);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1561
  r->uri.len = (size_t )(u - r->uri.data);
#line 1563
  if (r->uri_ext) {
#line 1564
    r->exten.len = (size_t )(u - r->uri_ext);
#line 1565
    r->exten.data = r->uri_ext;
  }
#line 1568
  r->uri_ext = (u_char *)((void *)0);
#line 1570
  return ((ngx_int_t )0);
  args: 
  {
#line 1574
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1574
    if (! ((unsigned long )p < (unsigned long )r->uri_end)) {
#line 1574
      goto while_break___1;
    }
#line 1575
    tmp___27 = p;
#line 1575
    p ++;
#line 1575
    if ((int )*tmp___27 != 35) {
#line 1576
      goto while_continue___1;
    }
#line 1579
    r->args.len = (size_t )((p - 1) - r->args_start);
#line 1580
    r->args.data = r->args_start;
#line 1581
    r->args_start = (u_char *)((void *)0);
#line 1583
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1586
  r->uri.len = (size_t )(u - r->uri.data);
#line 1588
  if (r->uri_ext) {
#line 1589
    r->exten.len = (size_t )(u - r->uri_ext);
#line 1590
    r->exten.data = r->uri_ext;
  }
#line 1593
  r->uri_ext = (u_char *)((void *)0);
#line 1595
  return ((ngx_int_t )0);
}
}
#line 1599 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_status_line(ngx_http_request_t *r , ngx_buf_t *b , ngx_http_status_t *status ) 
{ 
  u_char ch ;
  u_char *p ;
  enum __anonenum_state_246 state ;

  {
#line 1621
  state = (enum __anonenum_state_246 )r->state;
#line 1623
  p = b->pos;
  {
#line 1623
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1623
    if (! ((unsigned long )p < (unsigned long )b->last)) {
#line 1623
      goto while_break;
    }
#line 1624
    ch = *p;
    {
#line 1629
    if ((unsigned int )state == 0U) {
#line 1629
      goto case_0;
    }
#line 1639
    if ((unsigned int )state == 1U) {
#line 1639
      goto case_1;
    }
#line 1649
    if ((unsigned int )state == 2U) {
#line 1649
      goto case_2;
    }
#line 1659
    if ((unsigned int )state == 3U) {
#line 1659
      goto case_3;
    }
#line 1669
    if ((unsigned int )state == 4U) {
#line 1669
      goto case_4;
    }
#line 1680
    if ((unsigned int )state == 5U) {
#line 1680
      goto case_5;
    }
#line 1690
    if ((unsigned int )state == 6U) {
#line 1690
      goto case_6;
    }
#line 1708
    if ((unsigned int )state == 7U) {
#line 1708
      goto case_7;
    }
#line 1718
    if ((unsigned int )state == 8U) {
#line 1718
      goto case_8;
    }
#line 1736
    if ((unsigned int )state == 9U) {
#line 1736
      goto case_9;
    }
#line 1755
    if ((unsigned int )state == 10U) {
#line 1755
      goto case_10;
    }
#line 1774
    if ((unsigned int )state == 11U) {
#line 1774
      goto case_11;
    }
#line 1786
    if ((unsigned int )state == 12U) {
#line 1786
      goto case_12;
    }
#line 1626
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 1631
    if ((int )ch == 72) {
#line 1631
      goto case_72;
    }
#line 1634
    goto switch_default;
    case_72: /* CIL Label */ 
#line 1632
    state = (enum __anonenum_state_246 )1;
#line 1633
    goto switch_break___0;
    switch_default: /* CIL Label */ 
#line 1635
    return ((ngx_int_t )-1);
    switch_break___0: /* CIL Label */ ;
    }
#line 1637
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 1641
    if ((int )ch == 84) {
#line 1641
      goto case_84;
    }
#line 1644
    goto switch_default___0;
    case_84: /* CIL Label */ 
#line 1642
    state = (enum __anonenum_state_246 )2;
#line 1643
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 1645
    return ((ngx_int_t )-1);
    switch_break___1: /* CIL Label */ ;
    }
#line 1647
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1651
    if ((int )ch == 84) {
#line 1651
      goto case_84___0;
    }
#line 1654
    goto switch_default___1;
    case_84___0: /* CIL Label */ 
#line 1652
    state = (enum __anonenum_state_246 )3;
#line 1653
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
#line 1655
    return ((ngx_int_t )-1);
    switch_break___2: /* CIL Label */ ;
    }
#line 1657
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 1661
    if ((int )ch == 80) {
#line 1661
      goto case_80;
    }
#line 1664
    goto switch_default___2;
    case_80: /* CIL Label */ 
#line 1662
    state = (enum __anonenum_state_246 )4;
#line 1663
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 1665
    return ((ngx_int_t )-1);
    switch_break___3: /* CIL Label */ ;
    }
#line 1667
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 1671
    if ((int )ch == 47) {
#line 1671
      goto case_47;
    }
#line 1674
    goto switch_default___3;
    case_47: /* CIL Label */ 
#line 1672
    state = (enum __anonenum_state_246 )5;
#line 1673
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
#line 1675
    return ((ngx_int_t )-1);
    switch_break___4: /* CIL Label */ ;
    }
#line 1677
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1681
    if ((int )ch < 49) {
#line 1682
      return ((ngx_int_t )-1);
    } else
#line 1681
    if ((int )ch > 57) {
#line 1682
      return ((ngx_int_t )-1);
    }
#line 1685
    r->http_major = (unsigned int )((int )ch - 48);
#line 1686
    state = (enum __anonenum_state_246 )6;
#line 1687
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1691
    if ((int )ch == 46) {
#line 1692
      state = (enum __anonenum_state_246 )7;
#line 1693
      goto switch_break;
    }
#line 1696
    if ((int )ch < 48) {
#line 1697
      return ((ngx_int_t )-1);
    } else
#line 1696
    if ((int )ch > 57) {
#line 1697
      return ((ngx_int_t )-1);
    }
#line 1700
    if (r->http_major > 99U) {
#line 1701
      return ((ngx_int_t )-1);
    }
#line 1704
    r->http_major = r->http_major * 10U + (unsigned int )((int )ch - 48);
#line 1705
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1709
    if ((int )ch < 48) {
#line 1710
      return ((ngx_int_t )-1);
    } else
#line 1709
    if ((int )ch > 57) {
#line 1710
      return ((ngx_int_t )-1);
    }
#line 1713
    r->http_minor = (unsigned int )((int )ch - 48);
#line 1714
    state = (enum __anonenum_state_246 )8;
#line 1715
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1719
    if ((int )ch == 32) {
#line 1720
      state = (enum __anonenum_state_246 )9;
#line 1721
      goto switch_break;
    }
#line 1724
    if ((int )ch < 48) {
#line 1725
      return ((ngx_int_t )-1);
    } else
#line 1724
    if ((int )ch > 57) {
#line 1725
      return ((ngx_int_t )-1);
    }
#line 1728
    if (r->http_minor > 99U) {
#line 1729
      return ((ngx_int_t )-1);
    }
#line 1732
    r->http_minor = r->http_minor * 10U + (unsigned int )((int )ch - 48);
#line 1733
    goto switch_break;
    case_9: /* CIL Label */ 
#line 1737
    if ((int )ch == 32) {
#line 1738
      goto switch_break;
    }
#line 1741
    if ((int )ch < 48) {
#line 1742
      return ((ngx_int_t )-1);
    } else
#line 1741
    if ((int )ch > 57) {
#line 1742
      return ((ngx_int_t )-1);
    }
#line 1745
    status->code = status->code * 10UL + (ngx_uint_t )((int )ch - 48);
#line 1747
    (status->count) ++;
#line 1747
    if (status->count == 3UL) {
#line 1748
      state = (enum __anonenum_state_246 )10;
#line 1749
      status->start = p - 2;
    }
#line 1752
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 1757
    if ((int )ch == 32) {
#line 1757
      goto case_32;
    }
#line 1760
    if ((int )ch == 46) {
#line 1760
      goto case_46;
    }
#line 1763
    if ((int )ch == 13) {
#line 1763
      goto case_13;
    }
#line 1766
    if ((int )ch == 10) {
#line 1766
      goto case_10___0;
    }
#line 1768
    goto switch_default___4;
    case_32: /* CIL Label */ 
#line 1758
    state = (enum __anonenum_state_246 )11;
#line 1759
    goto switch_break___5;
    case_46: /* CIL Label */ 
#line 1761
    state = (enum __anonenum_state_246 )11;
#line 1762
    goto switch_break___5;
    case_13: /* CIL Label */ 
#line 1764
    state = (enum __anonenum_state_246 )12;
#line 1765
    goto switch_break___5;
    case_10___0: /* CIL Label */ 
#line 1767
    goto done;
    switch_default___4: /* CIL Label */ 
#line 1769
    return ((ngx_int_t )-1);
    switch_break___5: /* CIL Label */ ;
    }
#line 1771
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 1776
    if ((int )ch == 13) {
#line 1776
      goto case_13___0;
    }
#line 1780
    if ((int )ch == 10) {
#line 1780
      goto case_10___1;
    }
#line 1775
    goto switch_break___6;
    case_13___0: /* CIL Label */ 
#line 1777
    state = (enum __anonenum_state_246 )12;
#line 1779
    goto switch_break___6;
    case_10___1: /* CIL Label */ 
#line 1781
    goto done;
    switch_break___6: /* CIL Label */ ;
    }
#line 1783
    goto switch_break;
    case_12: /* CIL Label */ 
#line 1787
    status->end = p - 1;
    {
#line 1789
    if ((int )ch == 10) {
#line 1789
      goto case_10___2;
    }
#line 1791
    goto switch_default___5;
    case_10___2: /* CIL Label */ 
#line 1790
    goto done;
    switch_default___5: /* CIL Label */ 
#line 1792
    return ((ngx_int_t )-1);
    switch_break___7: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
#line 1623
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1797
  b->pos = p;
#line 1798
  r->state = (ngx_uint_t )state;
#line 1800
  return ((ngx_int_t )-2);
  done: 
#line 1804
  b->pos = p + 1;
#line 1806
  if ((unsigned long )status->end == (unsigned long )((void *)0)) {
#line 1807
    status->end = p;
  }
#line 1810
  status->http_version = (ngx_uint_t )(r->http_major * 1000U + r->http_minor);
#line 1811
  r->state = (ngx_uint_t )0;
#line 1813
  return ((ngx_int_t )0);
}
}
#line 1817 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_unsafe_uri(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ,
                                    ngx_uint_t *flags ) 
{ 
  u_char ch ;
  u_char *p ;
  u_char *src ;
  u_char *dst ;
  size_t len ;
  ngx_uint_t quoted ;
  u_char *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  char *__cil_tmp14 ;

  {
#line 1825
  len = uri___0->len;
#line 1826
  p = uri___0->data;
#line 1827
  quoted = (ngx_uint_t )0;
#line 1829
  if (len == 0UL) {
#line 1830
    goto unsafe;
  } else
#line 1829
  if ((int )*(p + 0) == 63) {
#line 1830
    goto unsafe;
  }
#line 1833
  if ((int )*(p + 0) == 46) {
#line 1833
    if (len > 1UL) {
#line 1833
      if ((int )*(p + 1) == 46) {
#line 1833
        if (len == 2UL) {
#line 1836
          goto unsafe;
        } else
#line 1833
        if ((int )*(p + 2) == 47) {
#line 1836
          goto unsafe;
        }
      }
    }
  }
  {
#line 1839
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1839
    if (! len) {
#line 1839
      goto while_break;
    }
#line 1841
    tmp = p;
#line 1841
    p ++;
#line 1841
    ch = *tmp;
#line 1843
    if ((int )ch == 37) {
#line 1844
      quoted = (ngx_uint_t )1;
#line 1845
      goto __Cont;
    }
#line 1848
    if (usual[(int )ch >> 5] & (1U << ((int )ch & 31))) {
#line 1849
      goto __Cont;
    }
#line 1852
    if ((int )ch == 63) {
#line 1853
      args___0->len = len - 1UL;
#line 1854
      args___0->data = p;
#line 1855
      uri___0->len -= len;
#line 1857
      goto while_break;
    }
#line 1860
    if ((int )ch == 0) {
#line 1861
      goto unsafe;
    }
#line 1864
    if ((int )ch == 47) {
#line 1864
      if (len > 2UL) {
#line 1868
        if ((int )*(p + 0) == 46) {
#line 1868
          if ((int )*(p + 1) == 46) {
#line 1868
            if (len == 3UL) {
#line 1871
              goto unsafe;
            } else
#line 1868
            if ((int )*(p + 2) == 47) {
#line 1871
              goto unsafe;
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1839
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1876
  if (quoted) {
    {
#line 1880
    src = uri___0->data;
#line 1882
    tmp___0 = ngx_pnalloc(r->pool, uri___0->len);
#line 1882
    dst = (u_char *)tmp___0;
    }
#line 1883
    if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1884
      return ((ngx_int_t )-1);
    }
    {
#line 1887
    uri___0->data = dst;
#line 1889
    ngx_unescape_uri(& dst, & src, uri___0->len, (ngx_uint_t )0);
#line 1891
    uri___0->len = (size_t )(dst - uri___0->data);
#line 1896
    len = uri___0->len;
#line 1897
    p = uri___0->data;
    }
#line 1899
    if ((int )*(p + 0) == 46) {
#line 1899
      if (len > 1UL) {
#line 1899
        if ((int )*(p + 1) == 46) {
#line 1899
          if (len == 2UL) {
#line 1902
            goto unsafe;
          } else
#line 1899
          if ((int )*(p + 2) == 47) {
#line 1902
            goto unsafe;
          }
        }
      }
    }
    {
#line 1905
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1905
      if (! len) {
#line 1905
        goto while_break___0;
      }
#line 1907
      tmp___1 = p;
#line 1907
      p ++;
#line 1907
      ch = *tmp___1;
#line 1909
      if ((int )ch == 0) {
#line 1910
        goto unsafe;
      }
#line 1913
      if ((int )ch == 47) {
#line 1913
        if (len > 2UL) {
#line 1917
          if ((int )*(p + 0) == 46) {
#line 1917
            if ((int )*(p + 1) == 46) {
#line 1917
              if (len == 3UL) {
#line 1920
                goto unsafe;
              } else
#line 1917
              if ((int )*(p + 2) == 47) {
#line 1920
                goto unsafe;
              }
            }
          }
        }
      }
#line 1905
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1926
  return ((ngx_int_t )0);
  unsafe: 
#line 1930
  if (*flags & 1UL) {
#line 1931
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1931
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "unsafe URI \"%V\" was detected",
                         uri___0);
      }
    }
  }
#line 1935
  return ((ngx_int_t )-1);
}
}
#line 1939 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_multi_header_lines(ngx_array_t *headers , ngx_str_t *name ,
                                            ngx_str_t *value ) 
{ 
  ngx_uint_t i ;
  u_char *start ;
  u_char *last ;
  u_char *end ;
  u_char ch ;
  ngx_table_elt_t **h ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;

  {
#line 1947
  h = (ngx_table_elt_t **)headers->elts;
#line 1949
  i = (ngx_uint_t )0;
  {
#line 1949
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1949
    if (! (i < headers->nelts)) {
#line 1949
      goto while_break;
    }
#line 1954
    if (name->len > (*(h + i))->value.len) {
#line 1955
      goto __Cont;
    }
#line 1958
    start = (*(h + i))->value.data;
#line 1959
    end = (*(h + i))->value.data + (*(h + i))->value.len;
    {
#line 1961
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1961
      if (! ((unsigned long )start < (unsigned long )end)) {
#line 1961
        goto while_break___0;
      }
      {
#line 1963
      tmp = ngx_strncasecmp(start, name->data, name->len);
      }
#line 1963
      if (tmp != 0L) {
#line 1964
        goto skip;
      }
#line 1967
      start += name->len;
      {
#line 1967
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1967
        if ((unsigned long )start < (unsigned long )end) {
#line 1967
          if (! ((int )*start == 32)) {
#line 1967
            goto while_break___1;
          }
        } else {
#line 1967
          goto while_break___1;
        }
#line 1967
        start ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1971
      if ((unsigned long )value == (unsigned long )((void *)0)) {
#line 1972
        if ((unsigned long )start == (unsigned long )end) {
#line 1973
          return ((ngx_int_t )i);
        } else
#line 1972
        if ((int )*start == 44) {
#line 1973
          return ((ngx_int_t )i);
        }
#line 1976
        goto skip;
      }
#line 1979
      if ((unsigned long )start == (unsigned long )end) {
#line 1981
        goto skip;
      } else {
#line 1979
        tmp___0 = start;
#line 1979
        start ++;
#line 1979
        if ((int )*tmp___0 != 61) {
#line 1981
          goto skip;
        }
      }
      {
#line 1984
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1984
        if ((unsigned long )start < (unsigned long )end) {
#line 1984
          if (! ((int )*start == 32)) {
#line 1984
            goto while_break___2;
          }
        } else {
#line 1984
          goto while_break___2;
        }
#line 1984
        start ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1986
      last = start;
      {
#line 1986
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1986
        if ((unsigned long )last < (unsigned long )end) {
#line 1986
          if (! ((int )*last != 59)) {
#line 1986
            goto while_break___3;
          }
        } else {
#line 1986
          goto while_break___3;
        }
#line 1986
        last ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1990
      value->len = (size_t )(last - start);
#line 1991
      value->data = start;
#line 1993
      return ((ngx_int_t )i);
      skip: 
      {
#line 1997
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1997
        if (! ((unsigned long )start < (unsigned long )end)) {
#line 1997
          goto while_break___4;
        }
#line 1998
        tmp___1 = start;
#line 1998
        start ++;
#line 1998
        ch = *tmp___1;
#line 1999
        if ((int )ch == 59) {
#line 2000
          goto while_break___4;
        } else
#line 1999
        if ((int )ch == 44) {
#line 2000
          goto while_break___4;
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 2004
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2004
        if ((unsigned long )start < (unsigned long )end) {
#line 2004
          if (! ((int )*start == 32)) {
#line 2004
            goto while_break___5;
          }
        } else {
#line 2004
          goto while_break___5;
        }
#line 2004
        start ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 1949
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2008
  return ((ngx_int_t )-5);
}
}
#line 2012 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_set_cookie_lines(ngx_array_t *headers , ngx_str_t *name ,
                                          ngx_str_t *value ) 
{ 
  ngx_uint_t i ;
  u_char *start ;
  u_char *last ;
  u_char *end ;
  ngx_table_elt_t **h ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;

  {
#line 2020
  h = (ngx_table_elt_t **)headers->elts;
#line 2022
  i = (ngx_uint_t )0;
  {
#line 2022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2022
    if (! (i < headers->nelts)) {
#line 2022
      goto while_break;
    }
#line 2027
    if (name->len >= (*(h + i))->value.len) {
#line 2028
      goto __Cont;
    }
    {
#line 2031
    start = (*(h + i))->value.data;
#line 2032
    end = (*(h + i))->value.data + (*(h + i))->value.len;
#line 2034
    tmp = ngx_strncasecmp(start, name->data, name->len);
    }
#line 2034
    if (tmp != 0L) {
#line 2035
      goto __Cont;
    }
#line 2038
    start += name->len;
    {
#line 2038
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2038
      if ((unsigned long )start < (unsigned long )end) {
#line 2038
        if (! ((int )*start == 32)) {
#line 2038
          goto while_break___0;
        }
      } else {
#line 2038
        goto while_break___0;
      }
#line 2038
      start ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2042
    if ((unsigned long )start == (unsigned long )end) {
#line 2044
      goto __Cont;
    } else {
#line 2042
      tmp___0 = start;
#line 2042
      start ++;
#line 2042
      if ((int )*tmp___0 != 61) {
#line 2044
        goto __Cont;
      }
    }
    {
#line 2047
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2047
      if ((unsigned long )start < (unsigned long )end) {
#line 2047
        if (! ((int )*start == 32)) {
#line 2047
          goto while_break___1;
        }
      } else {
#line 2047
        goto while_break___1;
      }
#line 2047
      start ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2049
    last = start;
    {
#line 2049
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2049
      if ((unsigned long )last < (unsigned long )end) {
#line 2049
        if (! ((int )*last != 59)) {
#line 2049
          goto while_break___2;
        }
      } else {
#line 2049
        goto while_break___2;
      }
#line 2049
      last ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2053
    value->len = (size_t )(last - start);
#line 2054
    value->data = start;
#line 2056
    return ((ngx_int_t )i);
    __Cont: /* CIL Label */ 
#line 2022
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2059
  return ((ngx_int_t )-5);
}
}
#line 2063 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_arg(ngx_http_request_t *r , u_char *name , size_t len , ngx_str_t *value ) 
{ 
  u_char *p ;
  u_char *last ;

  {
#line 2068
  if (r->args.len == 0UL) {
#line 2069
    return ((ngx_int_t )-5);
  }
#line 2072
  p = r->args.data;
#line 2073
  last = p + r->args.len;
  {
#line 2075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2075
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2075
      goto while_break;
    }
    {
#line 2079
    p = ngx_strlcasestrn(p, last - 1, name, len - 1UL);
    }
#line 2081
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2082
      return ((ngx_int_t )-5);
    }
#line 2085
    if ((unsigned long )p == (unsigned long )r->args.data) {
#line 2085
      goto _L;
    } else
#line 2085
    if ((int )*(p - 1) == 38) {
      _L: /* CIL Label */ 
#line 2085
      if ((int )*(p + len) == 61) {
        {
#line 2087
        value->data = (p + len) + 1;
#line 2089
        p = ngx_strlchr(p, last, (u_char )'&');
        }
#line 2091
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2092
          p = r->args.data + r->args.len;
        }
#line 2095
        value->len = (size_t )(p - value->data);
#line 2097
        return ((ngx_int_t )0);
      }
    }
#line 2075
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2101
  return ((ngx_int_t )-5);
}
}
#line 2105 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
void ngx_http_split_args(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ) 
{ 
  u_char *p ;
  u_char *last ;

  {
  {
#line 2110
  last = uri___0->data + uri___0->len;
#line 2112
  p = ngx_strlchr(uri___0->data, last, (u_char )'?');
  }
#line 2114
  if (p) {
#line 2115
    uri___0->len = (size_t )(p - uri___0->data);
#line 2116
    p ++;
#line 2117
    args___0->len = (size_t )(last - p);
#line 2118
    args___0->data = p;
  } else {
#line 2121
    args___0->len = (size_t )0;
  }
#line 2123
  return;
}
}
#line 2126 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_parse.c"
ngx_int_t ngx_http_parse_chunked(ngx_http_request_t *r , ngx_buf_t *b , ngx_http_chunked_t *ctx ) 
{ 
  u_char *pos ;
  u_char ch ;
  u_char c ;
  ngx_int_t rc ;
  enum __anonenum_state_247 state ;
  off_t tmp ;

  {
#line 2148
  state = (enum __anonenum_state_247 )ctx->state;
#line 2150
  if ((unsigned int )state == 4U) {
#line 2150
    if (ctx->size == 0L) {
#line 2151
      state = (enum __anonenum_state_247 )5;
    }
  }
#line 2154
  rc = (ngx_int_t )-2;
#line 2156
  pos = b->pos;
  {
#line 2156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2156
    if (! ((unsigned long )pos < (unsigned long )b->last)) {
#line 2156
      goto while_break;
    }
#line 2158
    ch = *pos;
    {
#line 2165
    if ((unsigned int )state == 0U) {
#line 2165
      goto case_0;
    }
#line 2182
    if ((unsigned int )state == 1U) {
#line 2182
      goto case_1;
    }
#line 2238
    if ((unsigned int )state == 2U) {
#line 2238
      goto case_2;
    }
#line 2248
    if ((unsigned int )state == 3U) {
#line 2248
      goto case_3;
    }
#line 2255
    if ((unsigned int )state == 4U) {
#line 2255
      goto case_4;
    }
#line 2259
    if ((unsigned int )state == 5U) {
#line 2259
      goto case_5;
    }
#line 2269
    if ((unsigned int )state == 6U) {
#line 2269
      goto case_6;
    }
#line 2276
    if ((unsigned int )state == 7U) {
#line 2276
      goto case_7;
    }
#line 2286
    if ((unsigned int )state == 8U) {
#line 2286
      goto case_8;
    }
#line 2293
    if ((unsigned int )state == 9U) {
#line 2293
      goto case_9___1;
    }
#line 2305
    if ((unsigned int )state == 10U) {
#line 2305
      goto case_10___5;
    }
#line 2311
    if ((unsigned int )state == 11U) {
#line 2311
      goto case_11;
    }
#line 2321
    if ((unsigned int )state == 12U) {
#line 2321
      goto case_12;
    }
#line 2163
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2166
    if ((int )ch >= 48) {
#line 2166
      if ((int )ch <= 57) {
#line 2167
        state = (enum __anonenum_state_247 )1;
#line 2168
        ctx->size = (off_t )((int )ch - 48);
#line 2169
        goto switch_break;
      }
    }
#line 2172
    c = (u_char )((int )ch | 32);
#line 2174
    if ((int )c >= 97) {
#line 2174
      if ((int )c <= 102) {
#line 2175
        state = (enum __anonenum_state_247 )1;
#line 2176
        ctx->size = (off_t )(((int )c - 97) + 10);
#line 2177
        goto switch_break;
      }
    }
#line 2180
    goto invalid;
    case_1: /* CIL Label */ 
#line 2183
    if ((long long )ctx->size > 576460752303423487LL) {
#line 2184
      goto invalid;
    }
#line 2187
    if ((int )ch >= 48) {
#line 2187
      if ((int )ch <= 57) {
#line 2188
        ctx->size = ctx->size * 16L + (off_t )((int )ch - 48);
#line 2189
        goto switch_break;
      }
    }
#line 2192
    c = (u_char )((int )ch | 32);
#line 2194
    if ((int )c >= 97) {
#line 2194
      if ((int )c <= 102) {
#line 2195
        ctx->size = ctx->size * 16L + (off_t )(((int )c - 97) + 10);
#line 2196
        goto switch_break;
      }
    }
#line 2199
    if (ctx->size == 0L) {
      {
#line 2202
      if ((int )ch == 13) {
#line 2202
        goto case_13;
      }
#line 2205
      if ((int )ch == 10) {
#line 2205
        goto case_10;
      }
#line 2210
      if ((int )ch == 9) {
#line 2210
        goto case_9;
      }
#line 2210
      if ((int )ch == 32) {
#line 2210
        goto case_9;
      }
#line 2210
      if ((int )ch == 59) {
#line 2210
        goto case_9;
      }
#line 2213
      goto switch_default;
      case_13: /* CIL Label */ 
#line 2203
      state = (enum __anonenum_state_247 )8;
#line 2204
      goto switch_break___0;
      case_10: /* CIL Label */ 
#line 2206
      state = (enum __anonenum_state_247 )9;
#line 2207
      goto switch_break___0;
      case_9: /* CIL Label */ 
      case_32: /* CIL Label */ 
      case_59: /* CIL Label */ 
#line 2211
      state = (enum __anonenum_state_247 )7;
#line 2212
      goto switch_break___0;
      switch_default: /* CIL Label */ 
#line 2214
      goto invalid;
      switch_break___0: /* CIL Label */ ;
      }
#line 2217
      goto switch_break;
    }
    {
#line 2221
    if ((int )ch == 13) {
#line 2221
      goto case_13___0;
    }
#line 2224
    if ((int )ch == 10) {
#line 2224
      goto case_10___0;
    }
#line 2229
    if ((int )ch == 9) {
#line 2229
      goto case_9___0;
    }
#line 2229
    if ((int )ch == 32) {
#line 2229
      goto case_9___0;
    }
#line 2229
    if ((int )ch == 59) {
#line 2229
      goto case_9___0;
    }
#line 2232
    goto switch_default___0;
    case_13___0: /* CIL Label */ 
#line 2222
    state = (enum __anonenum_state_247 )3;
#line 2223
    goto switch_break___1;
    case_10___0: /* CIL Label */ 
#line 2225
    state = (enum __anonenum_state_247 )4;
#line 2226
    goto switch_break___1;
    case_9___0: /* CIL Label */ 
    case_32___0: /* CIL Label */ 
    case_59___0: /* CIL Label */ 
#line 2230
    state = (enum __anonenum_state_247 )2;
#line 2231
    goto switch_break___1;
    switch_default___0: /* CIL Label */ 
#line 2233
    goto invalid;
    switch_break___1: /* CIL Label */ ;
    }
#line 2236
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2240
    if ((int )ch == 13) {
#line 2240
      goto case_13___1;
    }
#line 2243
    if ((int )ch == 10) {
#line 2243
      goto case_10___1;
    }
#line 2239
    goto switch_break___2;
    case_13___1: /* CIL Label */ 
#line 2241
    state = (enum __anonenum_state_247 )3;
#line 2242
    goto switch_break___2;
    case_10___1: /* CIL Label */ 
#line 2244
    state = (enum __anonenum_state_247 )4;
    switch_break___2: /* CIL Label */ ;
    }
#line 2246
    goto switch_break;
    case_3: /* CIL Label */ 
#line 2249
    if ((int )ch == 10) {
#line 2250
      state = (enum __anonenum_state_247 )4;
#line 2251
      goto switch_break;
    }
#line 2253
    goto invalid;
    case_4: /* CIL Label */ 
#line 2256
    rc = (ngx_int_t )0;
#line 2257
    goto data;
    case_5: /* CIL Label */ 
    {
#line 2261
    if ((int )ch == 13) {
#line 2261
      goto case_13___2;
    }
#line 2264
    if ((int )ch == 10) {
#line 2264
      goto case_10___2;
    }
#line 2260
    goto switch_break___3;
    case_13___2: /* CIL Label */ 
#line 2262
    state = (enum __anonenum_state_247 )6;
#line 2263
    goto switch_break___3;
    case_10___2: /* CIL Label */ 
#line 2265
    state = (enum __anonenum_state_247 )0;
    switch_break___3: /* CIL Label */ ;
    }
#line 2267
    goto switch_break;
    case_6: /* CIL Label */ 
#line 2270
    if ((int )ch == 10) {
#line 2271
      state = (enum __anonenum_state_247 )0;
#line 2272
      goto switch_break;
    }
#line 2274
    goto invalid;
    case_7: /* CIL Label */ 
    {
#line 2278
    if ((int )ch == 13) {
#line 2278
      goto case_13___3;
    }
#line 2281
    if ((int )ch == 10) {
#line 2281
      goto case_10___3;
    }
#line 2277
    goto switch_break___4;
    case_13___3: /* CIL Label */ 
#line 2279
    state = (enum __anonenum_state_247 )8;
#line 2280
    goto switch_break___4;
    case_10___3: /* CIL Label */ 
#line 2282
    state = (enum __anonenum_state_247 )9;
    switch_break___4: /* CIL Label */ ;
    }
#line 2284
    goto switch_break;
    case_8: /* CIL Label */ 
#line 2287
    if ((int )ch == 10) {
#line 2288
      state = (enum __anonenum_state_247 )9;
#line 2289
      goto switch_break;
    }
#line 2291
    goto invalid;
    case_9___1: /* CIL Label */ 
    {
#line 2295
    if ((int )ch == 13) {
#line 2295
      goto case_13___4;
    }
#line 2298
    if ((int )ch == 10) {
#line 2298
      goto case_10___4;
    }
#line 2300
    goto switch_default___1;
    case_13___4: /* CIL Label */ 
#line 2296
    state = (enum __anonenum_state_247 )10;
#line 2297
    goto switch_break___5;
    case_10___4: /* CIL Label */ 
#line 2299
    goto done;
    switch_default___1: /* CIL Label */ 
#line 2301
    state = (enum __anonenum_state_247 )11;
    switch_break___5: /* CIL Label */ ;
    }
#line 2303
    goto switch_break;
    case_10___5: /* CIL Label */ 
#line 2306
    if ((int )ch == 10) {
#line 2307
      goto done;
    }
#line 2309
    goto invalid;
    case_11: /* CIL Label */ 
    {
#line 2313
    if ((int )ch == 13) {
#line 2313
      goto case_13___5;
    }
#line 2316
    if ((int )ch == 10) {
#line 2316
      goto case_10___6;
    }
#line 2312
    goto switch_break___6;
    case_13___5: /* CIL Label */ 
#line 2314
    state = (enum __anonenum_state_247 )12;
#line 2315
    goto switch_break___6;
    case_10___6: /* CIL Label */ 
#line 2317
    state = (enum __anonenum_state_247 )9;
    switch_break___6: /* CIL Label */ ;
    }
#line 2319
    goto switch_break;
    case_12: /* CIL Label */ 
#line 2322
    if ((int )ch == 10) {
#line 2323
      state = (enum __anonenum_state_247 )9;
#line 2324
      goto switch_break;
    }
#line 2326
    goto invalid;
    switch_break: /* CIL Label */ ;
    }
#line 2156
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
  data: 
#line 2333
  ctx->state = (ngx_uint_t )state;
#line 2334
  b->pos = pos;
#line 2336
  if ((long long )ctx->size > 9223372036854775802LL) {
#line 2337
    goto invalid;
  }
  {
#line 2342
  if ((unsigned int )state == 0U) {
#line 2342
    goto case_0___0;
  }
#line 2345
  if ((unsigned int )state == 1U) {
#line 2345
    goto case_1___0;
  }
#line 2351
  if ((unsigned int )state == 3U) {
#line 2351
    goto case_3___0;
  }
#line 2351
  if ((unsigned int )state == 2U) {
#line 2351
    goto case_3___0;
  }
#line 2354
  if ((unsigned int )state == 4U) {
#line 2354
    goto case_4___0;
  }
#line 2358
  if ((unsigned int )state == 6U) {
#line 2358
    goto case_6___0;
  }
#line 2358
  if ((unsigned int )state == 5U) {
#line 2358
    goto case_6___0;
  }
#line 2362
  if ((unsigned int )state == 8U) {
#line 2362
    goto case_8___0;
  }
#line 2362
  if ((unsigned int )state == 7U) {
#line 2362
    goto case_8___0;
  }
#line 2366
  if ((unsigned int )state == 10U) {
#line 2366
    goto case_10___7;
  }
#line 2366
  if ((unsigned int )state == 9U) {
#line 2366
    goto case_10___7;
  }
#line 2370
  if ((unsigned int )state == 12U) {
#line 2370
    goto case_12___0;
  }
#line 2370
  if ((unsigned int )state == 11U) {
#line 2370
    goto case_12___0;
  }
#line 2340
  goto switch_break___7;
  case_0___0: /* CIL Label */ 
#line 2343
  ctx->length = (off_t )3;
#line 2344
  goto switch_break___7;
  case_1___0: /* CIL Label */ 
#line 2346
  if (ctx->size) {
#line 2346
    tmp = ctx->size + 4L;
  } else {
#line 2346
    tmp = (off_t )1;
  }
#line 2346
  ctx->length = 1L + tmp;
#line 2349
  goto switch_break___7;
  case_3___0: /* CIL Label */ 
  case_2___0: /* CIL Label */ 
#line 2352
  ctx->length = (1L + ctx->size) + 4L;
#line 2353
  goto switch_break___7;
  case_4___0: /* CIL Label */ 
#line 2355
  ctx->length = ctx->size + 4L;
#line 2356
  goto switch_break___7;
  case_6___0: /* CIL Label */ 
  case_5___0: /* CIL Label */ 
#line 2359
  ctx->length = (off_t )4;
#line 2360
  goto switch_break___7;
  case_8___0: /* CIL Label */ 
  case_7___0: /* CIL Label */ 
#line 2363
  ctx->length = (off_t )2;
#line 2364
  goto switch_break___7;
  case_10___7: /* CIL Label */ 
  case_9___2: /* CIL Label */ 
#line 2367
  ctx->length = (off_t )1;
#line 2368
  goto switch_break___7;
  case_12___0: /* CIL Label */ 
  case_11___0: /* CIL Label */ 
#line 2371
  ctx->length = (off_t )2;
#line 2372
  goto switch_break___7;
  switch_break___7: /* CIL Label */ ;
  }
#line 2376
  return (rc);
  done: 
#line 2380
  ctx->state = (ngx_uint_t )0;
#line 2381
  b->pos = pos + 1;
#line 2383
  return ((ngx_int_t )-4);
  invalid: 
#line 2387
  return ((ngx_int_t )-1);
}
}
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 152 "src/core/ngx_string.h"
u_char *ngx_snprintf(u_char *buf , size_t max , char const   *fmt  , ...) ;
#line 164
u_char *ngx_strstrn(u_char *s1 , char *s2 , size_t n ) ;
#line 178
time_t ngx_atotm(u_char *line , size_t n ) ;
#line 82 "src/os/unix/ngx_os.h"
ngx_uint_t ngx_tcp_nodelay_and_tcp_nopush ;
#line 223 "src/core/ngx_connection.h"
void ngx_reusable_connection(ngx_connection_t *c , ngx_uint_t reusable ) ;
#line 19 "src/core/ngx_proxy_protocol.h"
u_char *ngx_proxy_protocol_read(ngx_connection_t *c , u_char *buf , u_char *last ) ;
#line 597 "src/http/ngx_http_request.h"
ngx_http_header_t ngx_http_headers_in[23] ;
#line 471 "src/event/ngx_event.h"
ngx_uint_t ngx_use_accept_mutex ;
#line 85 "src/http/ngx_http.h"
void ngx_http_init_connection(ngx_connection_t *c ) ;
#line 86
void ngx_http_close_connection(ngx_connection_t *c ) ;
#line 114
ngx_http_request_t *ngx_http_create_request(ngx_connection_t *c ) ;
#line 115
ngx_int_t ngx_http_process_request_uri(ngx_http_request_t *r ) ;
#line 116
ngx_int_t ngx_http_process_request_header(ngx_http_request_t *r ) ;
#line 117
void ngx_http_process_request(ngx_http_request_t *r ) ;
#line 119
void ngx_http_handler(ngx_http_request_t *r ) ;
#line 124
void ngx_http_free_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 126
void ngx_http_empty_handler(ngx_event_t *wev ) ;
#line 141
ngx_int_t ngx_http_special_response_handler(ngx_http_request_t *r , ngx_int_t error ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_wait_request_handler(ngx_event_t *rev ) ;
#line 14
static void ngx_http_process_request_line(ngx_event_t *rev ) ;
#line 15
static void ngx_http_process_request_headers(ngx_event_t *rev ) ;
#line 16
static ssize_t ngx_http_read_request_header(ngx_http_request_t *r ) ;
#line 17
static ngx_int_t ngx_http_alloc_large_header_buffer(ngx_http_request_t *r , ngx_uint_t request_line ) ;
#line 20
static ngx_int_t ngx_http_process_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                              ngx_uint_t offset ) ;
#line 22
static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 24
static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) ;
#line 26
static ngx_int_t ngx_http_process_host(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                       ngx_uint_t offset ) ;
#line 28
static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                             ngx_uint_t offset ) ;
#line 30
static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                             ngx_uint_t offset ) ;
#line 33
static ngx_int_t ngx_http_validate_host(ngx_str_t *host , ngx_pool_t *pool , ngx_uint_t alloc ) ;
#line 35
static ngx_int_t ngx_http_set_virtual_server(ngx_http_request_t *r , ngx_str_t *host ) ;
#line 37
static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c , ngx_http_virtual_names_t *virtual_names ,
                                              ngx_str_t *host , ngx_http_request_t *r ,
                                              ngx_http_core_srv_conf_t **cscfp ) ;
#line 41
static void ngx_http_request_handler(ngx_event_t *ev ) ;
#line 42
static void ngx_http_terminate_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 43
static void ngx_http_terminate_handler(ngx_http_request_t *r ) ;
#line 44
static void ngx_http_finalize_connection(ngx_http_request_t *r ) ;
#line 45
static ngx_int_t ngx_http_set_write_handler(ngx_http_request_t *r ) ;
#line 46
static void ngx_http_writer(ngx_http_request_t *r ) ;
#line 47
static void ngx_http_request_finalizer(ngx_http_request_t *r ) ;
#line 49
static void ngx_http_set_keepalive(ngx_http_request_t *r ) ;
#line 50
static void ngx_http_keepalive_handler(ngx_event_t *rev ) ;
#line 51
static void ngx_http_set_lingering_close(ngx_http_request_t *r ) ;
#line 52
static void ngx_http_lingering_close_handler(ngx_event_t *rev ) ;
#line 53
static ngx_int_t ngx_http_post_action(ngx_http_request_t *r ) ;
#line 54
static void ngx_http_close_request(ngx_http_request_t *r , ngx_int_t rc ) ;
#line 55
static void ngx_http_log_request(ngx_http_request_t *r ) ;
#line 57
static u_char *ngx_http_log_error(ngx_log_t *log , u_char *buf , size_t len ) ;
#line 58
static u_char *ngx_http_log_error_handler(ngx_http_request_t *r , ngx_http_request_t *sr ,
                                          u_char *buf , size_t len ) ;
#line 67 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static char *ngx_http_client_errors[4]  = {      (char *)"client sent invalid method",      (char *)"client sent invalid request",      (char *)"client sent invalid version",      (char *)"client sent invalid method in HTTP/0.9 request"};
#line 83 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
ngx_http_header_t ngx_http_headers_in[23]  = 
#line 83
  {      {{sizeof("Host") - 1UL, (u_char *)"Host"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->host),
      & ngx_http_process_host}, 
        {{sizeof("Connection") - 1UL, (u_char *)"Connection"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->connection),
      & ngx_http_process_connection}, 
        {{sizeof("If-Modified-Since") - 1UL, (u_char *)"If-Modified-Since"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_modified_since),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("If-Unmodified-Since") - 1UL, (u_char *)"If-Unmodified-Since"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_unmodified_since),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("If-Match") - 1UL, (u_char *)"If-Match"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_match),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("If-None-Match") - 1UL, (u_char *)"If-None-Match"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_none_match),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("User-Agent") - 1UL, (u_char *)"User-Agent"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->user_agent),
      & ngx_http_process_user_agent}, 
        {{sizeof("Referer") - 1UL, (u_char *)"Referer"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->referer),
      & ngx_http_process_header_line}, 
        {{sizeof("Content-Length") - 1UL, (u_char *)"Content-Length"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->content_length),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Content-Range") - 1UL, (u_char *)"Content-Range"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->content_range),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Content-Type") - 1UL, (u_char *)"Content-Type"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->content_type),
      & ngx_http_process_header_line}, 
        {{sizeof("Range") - 1UL, (u_char *)"Range"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->range),
      & ngx_http_process_header_line}, 
        {{sizeof("If-Range") - 1UL, (u_char *)"If-Range"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->if_range),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Transfer-Encoding") - 1UL, (u_char *)"Transfer-Encoding"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->transfer_encoding),
      & ngx_http_process_header_line}, 
        {{sizeof("Expect") - 1UL, (u_char *)"Expect"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->expect),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Upgrade") - 1UL, (u_char *)"Upgrade"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->upgrade),
      & ngx_http_process_header_line}, 
        {{sizeof("Accept-Encoding") - 1UL, (u_char *)"Accept-Encoding"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->accept_encoding),
      & ngx_http_process_header_line}, 
        {{sizeof("Via") - 1UL, (u_char *)"Via"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->via),
      & ngx_http_process_header_line}, 
        {{sizeof("Authorization") - 1UL, (u_char *)"Authorization"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->authorization),
      & ngx_http_process_unique_header_line}, 
        {{sizeof("Keep-Alive") - 1UL, (u_char *)"Keep-Alive"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->keep_alive),
      & ngx_http_process_header_line}, 
        {{sizeof("X-Forwarded-For") - 1UL, (u_char *)"X-Forwarded-For"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->x_forwarded_for),
      & ngx_http_process_multi_header_lines}, 
        {{sizeof("Cookie") - 1UL, (u_char *)"Cookie"}, (unsigned long )(& ((ngx_http_headers_in_t *)0)->cookies),
      & ngx_http_process_multi_header_lines}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (ngx_int_t (*)(ngx_http_request_t *r ,
                                                                          ngx_table_elt_t *h ,
                                                                          ngx_uint_t offset ))((void *)0)}};
#line 201 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_init_connection(ngx_connection_t *c ) 
{ 
  ngx_uint_t i ;
  ngx_event_t *rev ;
  struct sockaddr_in *sin ;
  ngx_http_port_t *port ;
  ngx_http_in_addr_t *addr ;
  ngx_http_log_ctx_t *ctx ;
  ngx_http_connection_t *hc ;
  struct sockaddr_in6 *sin6 ;
  ngx_http_in6_addr_t *addr6 ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 216
  tmp = ngx_pcalloc(c->pool, sizeof(ngx_http_connection_t ));
#line 216
  hc = (ngx_http_connection_t *)tmp;
  }
#line 217
  if ((unsigned long )hc == (unsigned long )((void *)0)) {
    {
#line 218
    ngx_http_close_connection(c);
    }
#line 219
    return;
  }
#line 222
  c->data = (void *)hc;
#line 226
  port = (ngx_http_port_t *)(c->listening)->servers;
#line 228
  if (port->naddrs > 1UL) {
    {
#line 236
    tmp___0 = ngx_connection_local_sockaddr(c, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
    }
#line 236
    if (tmp___0 != 0L) {
      {
#line 237
      ngx_http_close_connection(c);
      }
#line 238
      return;
    }
    {
#line 244
    if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 244
      goto case_10;
    }
#line 262
    goto switch_default;
    case_10: /* CIL Label */ 
#line 245
    sin6 = (struct sockaddr_in6 *)c->local_sockaddr;
#line 247
    addr6 = (ngx_http_in6_addr_t *)port->addrs;
#line 251
    i = (ngx_uint_t )0;
    {
#line 251
    while (1) {
      while_continue: /* CIL Label */ ;
#line 251
      if (! (i < port->naddrs - 1UL)) {
#line 251
        goto while_break;
      }
      {
#line 252
      tmp___1 = memcmp((void const   *)((char const   *)(& (addr6 + i)->addr6)), (void const   *)((char const   *)(& sin6->sin6_addr)),
                       (size_t )16);
      }
#line 252
      if (tmp___1 == 0) {
#line 253
        goto while_break;
      }
#line 251
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 257
    hc->addr_conf = & (addr6 + i)->conf;
#line 259
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 263
    sin = (struct sockaddr_in *)c->local_sockaddr;
#line 265
    addr = (ngx_http_in_addr_t *)port->addrs;
#line 269
    i = (ngx_uint_t )0;
    {
#line 269
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 269
      if (! (i < port->naddrs - 1UL)) {
#line 269
        goto while_break___0;
      }
#line 270
      if ((addr + i)->addr == sin->sin_addr.s_addr) {
#line 271
        goto while_break___0;
      }
#line 269
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 275
    hc->addr_conf = & (addr + i)->conf;
#line 277
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 285
    if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 285
      goto case_10___0;
    }
#line 291
    goto switch_default___0;
    case_10___0: /* CIL Label */ 
#line 286
    addr6 = (ngx_http_in6_addr_t *)port->addrs;
#line 287
    hc->addr_conf = & (addr6 + 0)->conf;
#line 288
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 292
    addr = (ngx_http_in_addr_t *)port->addrs;
#line 293
    hc->addr_conf = & (addr + 0)->conf;
#line 294
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  }
  {
#line 299
  hc->conf_ctx = ((hc->addr_conf)->default_server)->ctx;
#line 301
  tmp___2 = ngx_palloc(c->pool, sizeof(ngx_http_log_ctx_t ));
#line 301
  ctx = (ngx_http_log_ctx_t *)tmp___2;
  }
#line 302
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
    {
#line 303
    ngx_http_close_connection(c);
    }
#line 304
    return;
  }
#line 307
  ctx->connection = c;
#line 308
  ctx->request = (ngx_http_request_t *)((void *)0);
#line 309
  ctx->current_request = (ngx_http_request_t *)((void *)0);
#line 311
  (c->log)->connection = c->number;
#line 312
  (c->log)->handler = & ngx_http_log_error;
#line 313
  (c->log)->data = (void *)ctx;
#line 314
  (c->log)->action = (char *)"waiting for request";
#line 316
  c->log_error = 2U;
#line 318
  rev = c->read;
#line 319
  rev->handler = & ngx_http_wait_request_handler;
#line 320
  (c->write)->handler = & ngx_http_empty_handler;
#line 353
  if ((hc->addr_conf)->proxy_protocol) {
#line 354
    hc->proxy_protocol = 1U;
#line 355
    (c->log)->action = (char *)"reading PROXY protocol";
  }
#line 358
  if (rev->ready) {
#line 361
    if (ngx_use_accept_mutex) {
#line 362
      if (! rev->posted) {
#line 362
        rev->posted = 1U;
#line 362
        rev->queue.prev = ngx_posted_events.prev;
#line 362
        (rev->queue.prev)->next = & rev->queue;
#line 362
        rev->queue.next = & ngx_posted_events;
#line 362
        ngx_posted_events.prev = & rev->queue;
      }
#line 363
      return;
    }
    {
#line 366
    (*(rev->handler))(rev);
    }
#line 367
    return;
  }
  {
#line 370
  ngx_event_add_timer(rev, (c->listening)->post_accept_timeout);
#line 371
  ngx_reusable_connection(c, (ngx_uint_t )1);
#line 373
  tmp___3 = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 373
  if (tmp___3 != 0L) {
    {
#line 374
    ngx_http_close_connection(c);
    }
#line 375
    return;
  }
#line 377
  return;
}
}
#line 380 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_wait_request_handler(ngx_event_t *rev ) 
{ 
  u_char *p ;
  size_t size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_connection_t *c ;
  ngx_http_connection_t *hc ;
  ngx_http_core_srv_conf_t *cscf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_http_request_t *tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 391
  c = (ngx_connection_t *)rev->data;
#line 395
  if (rev->timedout) {
#line 396
    if ((c->log)->log_level >= 7UL) {
      {
#line 396
      ngx_log_error_core((ngx_uint_t )7, c->log, 110, "client timed out");
      }
    }
    {
#line 397
    ngx_http_close_connection(c);
    }
#line 398
    return;
  }
#line 401
  if (c->close) {
    {
#line 402
    ngx_http_close_connection(c);
    }
#line 403
    return;
  }
#line 406
  hc = (ngx_http_connection_t *)c->data;
#line 407
  cscf = (ngx_http_core_srv_conf_t *)*((hc->conf_ctx)->srv_conf + ngx_http_core_module.ctx_index);
#line 409
  size = cscf->client_header_buffer_size;
#line 411
  b = c->buffer;
#line 413
  if ((unsigned long )b == (unsigned long )((void *)0)) {
    {
#line 414
    b = ngx_create_temp_buf(c->pool, size);
    }
#line 415
    if ((unsigned long )b == (unsigned long )((void *)0)) {
      {
#line 416
      ngx_http_close_connection(c);
      }
#line 417
      return;
    }
#line 420
    c->buffer = b;
  } else
#line 422
  if ((unsigned long )b->start == (unsigned long )((void *)0)) {
    {
#line 424
    tmp = ngx_palloc(c->pool, size);
#line 424
    b->start = (u_char *)tmp;
    }
#line 425
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
      {
#line 426
      ngx_http_close_connection(c);
      }
#line 427
      return;
    }
#line 430
    b->pos = b->start;
#line 431
    b->last = b->start;
#line 432
    b->end = b->last + size;
  }
  {
#line 435
  n = (*(c->recv))(c, b->last, size);
  }
#line 437
  if (n == -2L) {
#line 439
    if (! rev->timer_set) {
      {
#line 440
      ngx_event_add_timer(rev, (c->listening)->post_accept_timeout);
#line 441
      ngx_reusable_connection(c, (ngx_uint_t )1);
      }
    }
    {
#line 444
    tmp___0 = ngx_handle_read_event(rev, (ngx_uint_t )0);
    }
#line 444
    if (tmp___0 != 0L) {
      {
#line 445
      ngx_http_close_connection(c);
      }
#line 446
      return;
    }
    {
#line 453
    tmp___1 = ngx_pfree(c->pool, (void *)b->start);
    }
#line 453
    if (tmp___1 == 0L) {
#line 454
      b->start = (u_char *)((void *)0);
    }
#line 457
    return;
  }
#line 460
  if (n == -1L) {
    {
#line 461
    ngx_http_close_connection(c);
    }
#line 462
    return;
  }
#line 465
  if (n == 0L) {
#line 466
    if ((c->log)->log_level >= 7UL) {
      {
#line 466
      ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client closed connection");
      }
    }
    {
#line 468
    ngx_http_close_connection(c);
    }
#line 469
    return;
  }
#line 472
  b->last += n;
#line 474
  if (hc->proxy_protocol) {
    {
#line 475
    hc->proxy_protocol = 0U;
#line 477
    p = ngx_proxy_protocol_read(c, b->pos, b->last);
    }
#line 479
    if ((unsigned long )p == (unsigned long )((void *)0)) {
      {
#line 480
      ngx_http_close_connection(c);
      }
#line 481
      return;
    }
#line 484
    b->pos = p;
#line 486
    if ((unsigned long )b->pos == (unsigned long )b->last) {
#line 487
      (c->log)->action = (char *)"waiting for request";
#line 488
      b->pos = b->start;
#line 489
      b->last = b->start;
#line 490
      if (! rev->posted) {
#line 490
        rev->posted = 1U;
#line 490
        rev->queue.prev = ngx_posted_events.prev;
#line 490
        (rev->queue.prev)->next = & rev->queue;
#line 490
        rev->queue.next = & ngx_posted_events;
#line 490
        ngx_posted_events.prev = & rev->queue;
      }
#line 491
      return;
    }
  }
  {
#line 495
  (c->log)->action = (char *)"reading client request line";
#line 497
  ngx_reusable_connection(c, (ngx_uint_t )0);
#line 499
  tmp___2 = ngx_http_create_request(c);
#line 499
  c->data = (void *)tmp___2;
  }
#line 500
  if ((unsigned long )c->data == (unsigned long )((void *)0)) {
    {
#line 501
    ngx_http_close_connection(c);
    }
#line 502
    return;
  }
  {
#line 505
  rev->handler = & ngx_http_process_request_line;
#line 506
  ngx_http_process_request_line(rev);
  }
#line 507
  return;
}
}
#line 510 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
ngx_http_request_t *ngx_http_create_request(ngx_connection_t *c ) 
{ 
  ngx_pool_t *pool ;
  ngx_time_t *tp ;
  ngx_http_request_t *r ;
  ngx_http_log_ctx_t *ctx ;
  ngx_http_connection_t *hc ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 522
  (c->requests) ++;
#line 524
  hc = (ngx_http_connection_t *)c->data;
#line 526
  cscf = (ngx_http_core_srv_conf_t *)*((hc->conf_ctx)->srv_conf + ngx_http_core_module.ctx_index);
#line 528
  pool = ngx_create_pool(cscf->request_pool_size, c->log);
  }
#line 529
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 530
    return ((ngx_http_request_t *)((void *)0));
  }
  {
#line 533
  tmp = ngx_pcalloc(pool, sizeof(ngx_http_request_t ));
#line 533
  r = (ngx_http_request_t *)tmp;
  }
#line 534
  if ((unsigned long )r == (unsigned long )((void *)0)) {
    {
#line 535
    ngx_destroy_pool(pool);
    }
#line 536
    return ((ngx_http_request_t *)((void *)0));
  }
#line 539
  r->pool = pool;
#line 541
  r->http_connection = hc;
#line 542
  r->signature = (uint32_t )1347703880;
#line 543
  r->connection = c;
#line 545
  r->main_conf = (hc->conf_ctx)->main_conf;
#line 546
  r->srv_conf = (hc->conf_ctx)->srv_conf;
#line 547
  r->loc_conf = (hc->conf_ctx)->loc_conf;
#line 549
  r->read_event_handler = & ngx_http_block_reading;
#line 551
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 553
  ((r->connection)->log)->file = (clcf->error_log)->file;
#line 553
  ((r->connection)->log)->next = (clcf->error_log)->next;
#line 553
  ((r->connection)->log)->writer = (clcf->error_log)->writer;
#line 553
  ((r->connection)->log)->wdata = (clcf->error_log)->wdata;
#line 553
  if (! (((r->connection)->log)->log_level & 2147483648UL)) {
#line 553
    ((r->connection)->log)->log_level = (clcf->error_log)->log_level;
  }
#line 555
  if (hc->busy) {
#line 555
    r->header_in = (hc->busy)->buf;
  } else {
#line 555
    r->header_in = c->buffer;
  }
  {
#line 557
  tmp___0 = ngx_list_init(& r->headers_out.headers, r->pool, (ngx_uint_t )20, sizeof(ngx_table_elt_t ));
  }
#line 557
  if (tmp___0 != 0L) {
    {
#line 561
    ngx_destroy_pool(r->pool);
    }
#line 562
    return ((ngx_http_request_t *)((void *)0));
  }
  {
#line 565
  tmp___1 = ngx_list_init(& r->headers_out.trailers, r->pool, (ngx_uint_t )4, sizeof(ngx_table_elt_t ));
  }
#line 565
  if (tmp___1 != 0L) {
    {
#line 569
    ngx_destroy_pool(r->pool);
    }
#line 570
    return ((ngx_http_request_t *)((void *)0));
  }
  {
#line 573
  tmp___2 = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);
#line 573
  r->ctx = (void **)tmp___2;
  }
#line 574
  if ((unsigned long )r->ctx == (unsigned long )((void *)0)) {
    {
#line 575
    ngx_destroy_pool(r->pool);
    }
#line 576
    return ((ngx_http_request_t *)((void *)0));
  }
  {
#line 579
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 581
  tmp___3 = ngx_pcalloc(r->pool, cmcf->variables.nelts * sizeof(ngx_http_variable_value_t ));
#line 581
  r->variables = (ngx_http_variable_value_t *)tmp___3;
  }
#line 583
  if ((unsigned long )r->variables == (unsigned long )((void *)0)) {
    {
#line 584
    ngx_destroy_pool(r->pool);
    }
#line 585
    return ((ngx_http_request_t *)((void *)0));
  }
#line 594
  r->main = r;
#line 595
  r->count = 1U;
#line 597
  tp = (ngx_time_t *)ngx_cached_time;
#line 598
  r->start_sec = tp->sec;
#line 599
  r->start_msec = tp->msec;
#line 601
  r->method = (ngx_uint_t )1;
#line 602
  r->http_version = (ngx_uint_t )1000;
#line 604
  r->headers_in.content_length_n = (off_t )-1;
#line 605
  r->headers_in.keep_alive_n = (time_t )-1;
#line 606
  r->headers_out.content_length_n = (off_t )-1;
#line 607
  r->headers_out.last_modified_time = (time_t )-1;
#line 609
  r->uri_changes = 11U;
#line 610
  r->subrequests = 51U;
#line 612
  r->http_state = 1U;
#line 614
  ctx = (ngx_http_log_ctx_t *)(c->log)->data;
#line 615
  ctx->request = r;
#line 616
  ctx->current_request = r;
#line 617
  r->log_handler = & ngx_http_log_error_handler;
#line 625
  return (r);
}
}
#line 939 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_process_request_line(ngx_event_t *rev ) 
{ 
  ssize_t n ;
  ngx_int_t rc ;
  ngx_int_t rv ;
  ngx_str_t host ;
  ngx_connection_t *c ;
  ngx_http_request_t *r ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 948
  c = (ngx_connection_t *)rev->data;
#line 949
  r = (ngx_http_request_t *)c->data;
#line 954
  if (rev->timedout) {
#line 955
    if ((c->log)->log_level >= 7UL) {
      {
#line 955
      ngx_log_error_core((ngx_uint_t )7, c->log, 110, "client timed out");
      }
    }
    {
#line 956
    c->timedout = 1U;
#line 957
    ngx_http_close_request(r, (ngx_int_t )408);
    }
#line 958
    return;
  }
#line 961
  rc = (ngx_int_t )-2;
  {
#line 963
  while (1) {
    while_continue: /* CIL Label */ ;
#line 965
    if (rc == -2L) {
      {
#line 966
      n = ngx_http_read_request_header(r);
      }
#line 968
      if (n == -2L) {
#line 969
        return;
      } else
#line 968
      if (n == -1L) {
#line 969
        return;
      }
    }
    {
#line 973
    rc = ngx_http_parse_request_line(r, r->header_in);
    }
#line 975
    if (rc == 0L) {
#line 979
      r->request_line.len = (size_t )(r->request_end - r->request_start);
#line 980
      r->request_line.data = r->request_start;
#line 981
      r->request_length = (r->header_in)->pos - r->request_start;
#line 986
      r->method_name.len = (size_t )((r->method_end - r->request_start) + 1L);
#line 987
      r->method_name.data = r->request_line.data;
#line 989
      if (r->http_protocol.data) {
#line 990
        r->http_protocol.len = (size_t )(r->request_end - r->http_protocol.data);
      }
      {
#line 993
      tmp = ngx_http_process_request_uri(r);
      }
#line 993
      if (tmp != 0L) {
#line 994
        return;
      }
#line 997
      if (r->host_start) {
#line 997
        if (r->host_end) {
          {
#line 999
          host.len = (size_t )(r->host_end - r->host_start);
#line 1000
          host.data = r->host_start;
#line 1002
          rc = ngx_http_validate_host(& host, r->pool, (ngx_uint_t )0);
          }
#line 1004
          if (rc == -5L) {
#line 1005
            if ((c->log)->log_level >= 7UL) {
              {
#line 1005
              ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent invalid host in request line");
              }
            }
            {
#line 1007
            ngx_http_finalize_request(r, (ngx_int_t )400);
            }
#line 1008
            return;
          }
#line 1011
          if (rc == -1L) {
            {
#line 1012
            ngx_http_close_request(r, (ngx_int_t )500);
            }
#line 1013
            return;
          }
          {
#line 1016
          tmp___0 = ngx_http_set_virtual_server(r, & host);
          }
#line 1016
          if (tmp___0 == -1L) {
#line 1017
            return;
          }
#line 1020
          r->headers_in.server = host;
        }
      }
#line 1023
      if (r->http_version < 1000UL) {
#line 1025
        if (r->headers_in.server.len == 0UL) {
          {
#line 1025
          tmp___1 = ngx_http_set_virtual_server(r, & r->headers_in.server);
          }
#line 1025
          if (tmp___1 == -1L) {
#line 1029
            return;
          }
        }
        {
#line 1032
        ngx_http_process_request(r);
        }
#line 1033
        return;
      }
      {
#line 1037
      tmp___2 = ngx_list_init(& r->headers_in.headers, r->pool, (ngx_uint_t )20, sizeof(ngx_table_elt_t ));
      }
#line 1037
      if (tmp___2 != 0L) {
        {
#line 1041
        ngx_http_close_request(r, (ngx_int_t )500);
        }
#line 1042
        return;
      }
      {
#line 1045
      (c->log)->action = (char *)"reading client request headers";
#line 1047
      rev->handler = & ngx_http_process_request_headers;
#line 1048
      ngx_http_process_request_headers(rev);
      }
#line 1050
      return;
    }
#line 1053
    if (rc != -2L) {
#line 1057
      if ((c->log)->log_level >= 7UL) {
        {
#line 1057
        ngx_log_error_core((ngx_uint_t )7, c->log, 0, (char const   *)ngx_http_client_errors[rc - 10L]);
        }
      }
#line 1060
      if (rc == 12L) {
        {
#line 1061
        ngx_http_finalize_request(r, (ngx_int_t )505);
        }
      } else {
        {
#line 1064
        ngx_http_finalize_request(r, (ngx_int_t )400);
        }
      }
#line 1067
      return;
    }
#line 1072
    if ((unsigned long )(r->header_in)->pos == (unsigned long )(r->header_in)->end) {
      {
#line 1074
      rv = ngx_http_alloc_large_header_buffer(r, (ngx_uint_t )1);
      }
#line 1076
      if (rv == -1L) {
        {
#line 1077
        ngx_http_close_request(r, (ngx_int_t )500);
        }
#line 1078
        return;
      }
#line 1081
      if (rv == -5L) {
#line 1082
        r->request_line.len = (size_t )((r->header_in)->end - r->request_start);
#line 1083
        r->request_line.data = r->request_start;
#line 1085
        if ((c->log)->log_level >= 7UL) {
          {
#line 1085
          ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent too long URI");
          }
        }
        {
#line 1087
        ngx_http_finalize_request(r, (ngx_int_t )414);
        }
#line 1088
        return;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1095 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
ngx_int_t ngx_http_process_request_uri(ngx_http_request_t *r ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 1100
  if (r->args_start) {
#line 1101
    r->uri.len = (size_t )((r->args_start - 1) - r->uri_start);
  } else {
#line 1103
    r->uri.len = (size_t )(r->uri_end - r->uri_start);
  }
#line 1106
  if (r->complex_uri) {
#line 1106
    goto _L;
  } else
#line 1106
  if (r->quoted_uri) {
    _L: /* CIL Label */ 
    {
#line 1108
    tmp = ngx_pnalloc(r->pool, r->uri.len + 1UL);
#line 1108
    r->uri.data = (u_char *)tmp;
    }
#line 1109
    if ((unsigned long )r->uri.data == (unsigned long )((void *)0)) {
      {
#line 1110
      ngx_http_close_request(r, (ngx_int_t )500);
      }
#line 1111
      return ((ngx_int_t )-1);
    }
    {
#line 1114
    cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1116
    tmp___0 = ngx_http_parse_complex_uri(r, (ngx_uint_t )cscf->merge_slashes);
    }
#line 1116
    if (tmp___0 != 0L) {
#line 1117
      r->uri.len = (size_t )0;
#line 1119
      if (((r->connection)->log)->log_level >= 7UL) {
        {
#line 1119
        ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent invalid request");
        }
      }
      {
#line 1121
      ngx_http_finalize_request(r, (ngx_int_t )400);
      }
#line 1122
      return ((ngx_int_t )-1);
    }
  } else {
#line 1126
    r->uri.data = r->uri_start;
  }
#line 1129
  r->unparsed_uri.len = (size_t )(r->uri_end - r->uri_start);
#line 1130
  r->unparsed_uri.data = r->uri_start;
#line 1132
  if (r->space_in_uri) {
#line 1132
    r->valid_unparsed_uri = 0U;
  } else {
#line 1132
    r->valid_unparsed_uri = 1U;
  }
#line 1134
  if (r->uri_ext) {
#line 1135
    if (r->args_start) {
#line 1136
      r->exten.len = (size_t )((r->args_start - 1) - r->uri_ext);
    } else {
#line 1138
      r->exten.len = (size_t )(r->uri_end - r->uri_ext);
    }
#line 1141
    r->exten.data = r->uri_ext;
  }
#line 1144
  if (r->args_start) {
#line 1144
    if ((unsigned long )r->uri_end > (unsigned long )r->args_start) {
#line 1145
      r->args.len = (size_t )(r->uri_end - r->args_start);
#line 1146
      r->args.data = r->args_start;
    }
  }
#line 1208
  return ((ngx_int_t )0);
}
}
#line 1212 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_process_request_headers(ngx_event_t *rev ) 
{ 
  u_char *p ;
  size_t len ;
  ssize_t n ;
  ngx_int_t rc ;
  ngx_int_t rv ;
  ngx_table_elt_t *h ;
  ngx_connection_t *c ;
  ngx_http_header_t *hh ;
  ngx_http_request_t *r ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 1226
  c = (ngx_connection_t *)rev->data;
#line 1227
  r = (ngx_http_request_t *)c->data;
#line 1232
  if (rev->timedout) {
#line 1233
    if ((c->log)->log_level >= 7UL) {
      {
#line 1233
      ngx_log_error_core((ngx_uint_t )7, c->log, 110, "client timed out");
      }
    }
    {
#line 1234
    c->timedout = 1U;
#line 1235
    ngx_http_close_request(r, (ngx_int_t )408);
    }
#line 1236
    return;
  }
#line 1239
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 1241
  rc = (ngx_int_t )-2;
  {
#line 1243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1245
    if (rc == -2L) {
#line 1247
      if ((unsigned long )(r->header_in)->pos == (unsigned long )(r->header_in)->end) {
        {
#line 1249
        rv = ngx_http_alloc_large_header_buffer(r, (ngx_uint_t )0);
        }
#line 1251
        if (rv == -1L) {
          {
#line 1252
          ngx_http_close_request(r, (ngx_int_t )500);
          }
#line 1253
          return;
        }
#line 1256
        if (rv == -5L) {
#line 1257
          p = r->header_name_start;
#line 1259
          r->lingering_close = 1U;
#line 1261
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1262
            if ((c->log)->log_level >= 7UL) {
              {
#line 1262
              ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent too large request");
              }
            }
            {
#line 1264
            ngx_http_finalize_request(r, (ngx_int_t )494);
            }
#line 1266
            return;
          }
#line 1269
          len = (size_t )((r->header_in)->end - p);
#line 1271
          if (len > 1748UL) {
#line 1272
            len = (size_t )1748;
          }
#line 1275
          if ((c->log)->log_level >= 7UL) {
            {
#line 1275
            ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent too long header line: \"%*s...\"",
                               len, r->header_name_start);
            }
          }
          {
#line 1279
          ngx_http_finalize_request(r, (ngx_int_t )494);
          }
#line 1281
          return;
        }
      }
      {
#line 1285
      n = ngx_http_read_request_header(r);
      }
#line 1287
      if (n == -2L) {
#line 1288
        return;
      } else
#line 1287
      if (n == -1L) {
#line 1288
        return;
      }
    }
    {
#line 1293
    cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1295
    rc = ngx_http_parse_header_line(r, r->header_in, (ngx_uint_t )cscf->underscores_in_headers);
    }
#line 1298
    if (rc == 0L) {
#line 1300
      r->request_length += (r->header_in)->pos - r->header_name_start;
#line 1302
      if (r->invalid_header) {
#line 1302
        if (cscf->ignore_invalid_headers) {
#line 1306
          if ((c->log)->log_level >= 7UL) {
            {
#line 1306
            ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent invalid header line: \"%*s\"",
                               r->header_end - r->header_name_start, r->header_name_start);
            }
          }
#line 1310
          goto __Cont;
        }
      }
      {
#line 1315
      tmp = ngx_list_push(& r->headers_in.headers);
#line 1315
      h = (ngx_table_elt_t *)tmp;
      }
#line 1316
      if ((unsigned long )h == (unsigned long )((void *)0)) {
        {
#line 1317
        ngx_http_close_request(r, (ngx_int_t )500);
        }
#line 1318
        return;
      }
      {
#line 1321
      h->hash = r->header_hash;
#line 1323
      h->key.len = (size_t )(r->header_name_end - r->header_name_start);
#line 1324
      h->key.data = r->header_name_start;
#line 1325
      *(h->key.data + h->key.len) = (u_char )'\000';
#line 1327
      h->value.len = (size_t )(r->header_end - r->header_start);
#line 1328
      h->value.data = r->header_start;
#line 1329
      *(h->value.data + h->value.len) = (u_char )'\000';
#line 1331
      tmp___0 = ngx_pnalloc(r->pool, h->key.len);
#line 1331
      h->lowcase_key = (u_char *)tmp___0;
      }
#line 1332
      if ((unsigned long )h->lowcase_key == (unsigned long )((void *)0)) {
        {
#line 1333
        ngx_http_close_request(r, (ngx_int_t )500);
        }
#line 1334
        return;
      }
#line 1337
      if (h->key.len == r->lowcase_index) {
        {
#line 1338
        memcpy((void */* __restrict  */)h->lowcase_key, (void const   */* __restrict  */)(r->lowcase_header),
               h->key.len);
        }
      } else {
        {
#line 1341
        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
        }
      }
      {
#line 1344
      tmp___1 = ngx_hash_find(& cmcf->headers_in_hash, h->hash, h->lowcase_key, h->key.len);
#line 1344
      hh = (ngx_http_header_t *)tmp___1;
      }
#line 1347
      if (hh) {
        {
#line 1347
        tmp___2 = (*(hh->handler))(r, h, hh->offset);
        }
#line 1347
        if (tmp___2 != 0L) {
#line 1348
          return;
        }
      }
#line 1355
      goto __Cont;
    }
#line 1358
    if (rc == 1L) {
      {
#line 1365
      r->request_length += (r->header_in)->pos - r->header_name_start;
#line 1367
      r->http_state = 2U;
#line 1369
      rc = ngx_http_process_request_header(r);
      }
#line 1371
      if (rc != 0L) {
#line 1372
        return;
      }
      {
#line 1375
      ngx_http_process_request(r);
      }
#line 1377
      return;
    }
#line 1380
    if (rc == -2L) {
#line 1384
      goto __Cont;
    }
#line 1389
    if ((c->log)->log_level >= 7UL) {
      {
#line 1389
      ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client sent invalid header line");
      }
    }
    {
#line 1392
    ngx_http_finalize_request(r, (ngx_int_t )400);
    }
#line 1393
    return;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1398 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ssize_t ngx_http_read_request_header(ngx_http_request_t *r ) 
{ 
  ssize_t n ;
  ngx_event_t *rev ;
  ngx_connection_t *c ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_int_t tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1406
  c = r->connection;
#line 1407
  rev = c->read;
#line 1409
  n = (r->header_in)->last - (r->header_in)->pos;
#line 1411
  if (n > 0L) {
#line 1412
    return (n);
  }
#line 1415
  if (rev->ready) {
    {
#line 1416
    n = (*(c->recv))(c, (r->header_in)->last, (size_t )((r->header_in)->end - (r->header_in)->last));
    }
  } else {
#line 1419
    n = (ssize_t )-2;
  }
#line 1422
  if (n == -2L) {
#line 1423
    if (! rev->timer_set) {
      {
#line 1424
      cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1425
      ngx_event_add_timer(rev, cscf->client_header_timeout);
      }
    }
    {
#line 1428
    tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
    }
#line 1428
    if (tmp != 0L) {
      {
#line 1429
      ngx_http_close_request(r, (ngx_int_t )500);
      }
#line 1430
      return ((ssize_t )-1);
    }
#line 1433
    return ((ssize_t )-2);
  }
#line 1436
  if (n == 0L) {
#line 1437
    if ((c->log)->log_level >= 7UL) {
      {
#line 1437
      ngx_log_error_core((ngx_uint_t )7, c->log, 0, "client prematurely closed connection");
      }
    }
  }
#line 1441
  if (n == 0L) {
    {
#line 1442
    c->error = 1U;
#line 1443
    (c->log)->action = (char *)"reading client request headers";
#line 1445
    ngx_http_finalize_request(r, (ngx_int_t )400);
    }
#line 1446
    return ((ssize_t )-1);
  } else
#line 1441
  if (n == -1L) {
    {
#line 1442
    c->error = 1U;
#line 1443
    (c->log)->action = (char *)"reading client request headers";
#line 1445
    ngx_http_finalize_request(r, (ngx_int_t )400);
    }
#line 1446
    return ((ssize_t )-1);
  }
#line 1449
  (r->header_in)->last += n;
#line 1451
  return (n);
}
}
#line 1455 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_alloc_large_header_buffer(ngx_http_request_t *r , ngx_uint_t request_line ) 
{ 
  u_char *old ;
  u_char *new ;
  ngx_buf_t *b ;
  ngx_chain_t *cl ;
  ngx_http_connection_t *hc ;
  ngx_http_core_srv_conf_t *cscf ;

  {
#line 1468
  if (request_line) {
#line 1468
    if (r->state == 0UL) {
#line 1472
      (r->header_in)->pos = (r->header_in)->start;
#line 1473
      (r->header_in)->last = (r->header_in)->start;
#line 1475
      return ((ngx_int_t )0);
    }
  }
#line 1478
  if (request_line) {
#line 1478
    old = r->request_start;
  } else {
#line 1478
    old = r->header_name_start;
  }
#line 1480
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1482
  if (r->state != 0UL) {
#line 1482
    if ((size_t )((r->header_in)->pos - old) >= cscf->large_client_header_buffers.size) {
#line 1486
      return ((ngx_int_t )-5);
    }
  }
#line 1489
  hc = r->http_connection;
#line 1491
  if (hc->free) {
#line 1492
    cl = hc->free;
#line 1493
    hc->free = cl->next;
#line 1495
    b = cl->buf;
  } else
#line 1501
  if (hc->nbusy < cscf->large_client_header_buffers.num) {
    {
#line 1503
    b = ngx_create_temp_buf((r->connection)->pool, cscf->large_client_header_buffers.size);
    }
#line 1505
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1506
      return ((ngx_int_t )-1);
    }
    {
#line 1509
    cl = ngx_alloc_chain_link((r->connection)->pool);
    }
#line 1510
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1511
      return ((ngx_int_t )-1);
    }
#line 1514
    cl->buf = b;
  } else {
#line 1521
    return ((ngx_int_t )-5);
  }
#line 1524
  cl->next = hc->busy;
#line 1525
  hc->busy = cl;
#line 1526
  (hc->nbusy) ++;
#line 1528
  if (r->state == 0UL) {
#line 1535
    r->header_in = b;
#line 1537
    return ((ngx_int_t )0);
  }
  {
#line 1543
  new = b->start;
#line 1545
  memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)old, (size_t )((r->header_in)->pos - old));
#line 1547
  b->pos = new + ((r->header_in)->pos - old);
#line 1548
  b->last = new + ((r->header_in)->pos - old);
  }
#line 1550
  if (request_line) {
#line 1551
    r->request_start = new;
#line 1553
    if (r->request_end) {
#line 1554
      r->request_end = new + (r->request_end - old);
    }
#line 1557
    r->method_end = new + (r->method_end - old);
#line 1559
    r->uri_start = new + (r->uri_start - old);
#line 1560
    r->uri_end = new + (r->uri_end - old);
#line 1562
    if (r->schema_start) {
#line 1563
      r->schema_start = new + (r->schema_start - old);
#line 1564
      r->schema_end = new + (r->schema_end - old);
    }
#line 1567
    if (r->host_start) {
#line 1568
      r->host_start = new + (r->host_start - old);
#line 1569
      if (r->host_end) {
#line 1570
        r->host_end = new + (r->host_end - old);
      }
    }
#line 1574
    if (r->port_start) {
#line 1575
      r->port_start = new + (r->port_start - old);
#line 1576
      r->port_end = new + (r->port_end - old);
    }
#line 1579
    if (r->uri_ext) {
#line 1580
      r->uri_ext = new + (r->uri_ext - old);
    }
#line 1583
    if (r->args_start) {
#line 1584
      r->args_start = new + (r->args_start - old);
    }
#line 1587
    if (r->http_protocol.data) {
#line 1588
      r->http_protocol.data = new + (r->http_protocol.data - old);
    }
  } else {
#line 1592
    r->header_name_start = new;
#line 1593
    r->header_name_end = new + (r->header_name_end - old);
#line 1594
    r->header_start = new + (r->header_start - old);
#line 1595
    r->header_end = new + (r->header_end - old);
  }
#line 1598
  r->header_in = b;
#line 1600
  return ((ngx_int_t )0);
}
}
#line 1604 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                              ngx_uint_t offset ) 
{ 
  ngx_table_elt_t **ph ;

  {
#line 1610
  ph = (ngx_table_elt_t **)((char *)(& r->headers_in) + offset);
#line 1612
  if ((unsigned long )*ph == (unsigned long )((void *)0)) {
#line 1613
    *ph = h;
  }
#line 1616
  return ((ngx_int_t )0);
}
}
#line 1620 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_unique_header_line(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  ngx_table_elt_t **ph ;
  char *__cil_tmp5 ;

  {
#line 1626
  ph = (ngx_table_elt_t **)((char *)(& r->headers_in) + offset);
#line 1628
  if ((unsigned long )*ph == (unsigned long )((void *)0)) {
#line 1629
    *ph = h;
#line 1630
    return ((ngx_int_t )0);
  }
#line 1633
  if (((r->connection)->log)->log_level >= 7UL) {
    {
#line 1633
    ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent duplicate header line: \"%V: %V\", previous value: \"%V: %V\"",
                       & h->key, & h->value, & (*ph)->key, & (*ph)->value);
    }
  }
  {
#line 1638
  ngx_http_finalize_request(r, (ngx_int_t )400);
  }
#line 1640
  return ((ngx_int_t )-1);
}
}
#line 1644 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_host(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                       ngx_uint_t offset ) 
{ 
  ngx_int_t rc ;
  ngx_str_t host ;
  ngx_int_t tmp ;
  char *__cil_tmp7 ;

  {
#line 1651
  if ((unsigned long )r->headers_in.host == (unsigned long )((void *)0)) {
#line 1652
    r->headers_in.host = h;
  }
  {
#line 1655
  host = h->value;
#line 1657
  rc = ngx_http_validate_host(& host, r->pool, (ngx_uint_t )0);
  }
#line 1659
  if (rc == -5L) {
#line 1660
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 1660
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent invalid host header");
      }
    }
    {
#line 1662
    ngx_http_finalize_request(r, (ngx_int_t )400);
    }
#line 1663
    return ((ngx_int_t )-1);
  }
#line 1666
  if (rc == -1L) {
    {
#line 1667
    ngx_http_close_request(r, (ngx_int_t )500);
    }
#line 1668
    return ((ngx_int_t )-1);
  }
#line 1671
  if (r->headers_in.server.len) {
#line 1672
    return ((ngx_int_t )0);
  }
  {
#line 1675
  tmp = ngx_http_set_virtual_server(r, & host);
  }
#line 1675
  if (tmp == -1L) {
#line 1676
    return ((ngx_int_t )-1);
  }
#line 1679
  r->headers_in.server = host;
#line 1681
  return ((ngx_int_t )0);
}
}
#line 1685 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_connection(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                             ngx_uint_t offset ) 
{ 
  u_char *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 1689
  tmp___0 = ngx_strcasestrn(h->value.data, (char *)"close", (size_t )4);
  }
#line 1689
  if (tmp___0) {
#line 1690
    r->headers_in.connection_type = 1U;
  } else {
    {
#line 1692
    tmp = ngx_strcasestrn(h->value.data, (char *)"keep-alive", (size_t )9);
    }
#line 1692
    if (tmp) {
#line 1693
      r->headers_in.connection_type = 2U;
    }
  }
#line 1696
  return ((ngx_int_t )0);
}
}
#line 1700 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_user_agent(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                             ngx_uint_t offset ) 
{ 
  u_char *user_agent ;
  u_char *msie ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1706
  if (r->headers_in.user_agent) {
#line 1707
    return ((ngx_int_t )0);
  }
  {
#line 1710
  r->headers_in.user_agent = h;
#line 1714
  user_agent = h->value.data;
#line 1716
  msie = ngx_strstrn(user_agent, (char *)"MSIE ", (size_t )4);
  }
#line 1718
  if (msie) {
#line 1718
    if ((unsigned long )(msie + 7) < (unsigned long )(user_agent + h->value.len)) {
#line 1720
      r->headers_in.msie = 1U;
#line 1722
      if ((int )*(msie + 6) == 46) {
        {
#line 1726
        if ((int )*(msie + 5) == 53) {
#line 1726
          goto case_53;
        }
#line 1726
        if ((int )*(msie + 5) == 52) {
#line 1726
          goto case_53;
        }
#line 1729
        if ((int )*(msie + 5) == 54) {
#line 1729
          goto case_54;
        }
#line 1724
        goto switch_break;
        case_53: /* CIL Label */ 
        case_52: /* CIL Label */ 
#line 1727
        r->headers_in.msie6 = 1U;
#line 1728
        goto switch_break;
        case_54: /* CIL Label */ 
        {
#line 1730
        tmp = ngx_strstrn(msie + 8, (char *)"SV1", (size_t )2);
        }
#line 1730
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1731
          r->headers_in.msie6 = 1U;
        }
#line 1733
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 1745
  tmp___0 = ngx_strstrn(user_agent, (char *)"Opera", (size_t )4);
  }
#line 1745
  if (tmp___0) {
#line 1746
    r->headers_in.opera = 1U;
#line 1747
    r->headers_in.msie = 0U;
#line 1748
    r->headers_in.msie6 = 0U;
  }
#line 1751
  if (! r->headers_in.msie) {
#line 1751
    if (! r->headers_in.opera) {
      {
#line 1753
      tmp___5 = ngx_strstrn(user_agent, (char *)"Gecko/", (size_t )5);
      }
#line 1753
      if (tmp___5) {
#line 1754
        r->headers_in.gecko = 1U;
      } else {
        {
#line 1756
        tmp___4 = ngx_strstrn(user_agent, (char *)"Chrome/", (size_t )6);
        }
#line 1756
        if (tmp___4) {
#line 1757
          r->headers_in.chrome = 1U;
        } else {
          {
#line 1759
          tmp___2 = ngx_strstrn(user_agent, (char *)"Safari/", (size_t )6);
          }
#line 1759
          if (tmp___2) {
            {
#line 1759
            tmp___3 = ngx_strstrn(user_agent, (char *)"Mac OS X", (size_t )7);
            }
#line 1759
            if (tmp___3) {
#line 1762
              r->headers_in.safari = 1U;
            } else {
#line 1759
              goto _L;
            }
          } else {
            _L: /* CIL Label */ 
            {
#line 1764
            tmp___1 = ngx_strstrn(user_agent, (char *)"Konqueror", (size_t )8);
            }
#line 1764
            if (tmp___1) {
#line 1765
              r->headers_in.konqueror = 1U;
            }
          }
        }
      }
    }
  }
#line 1769
  return ((ngx_int_t )0);
}
}
#line 1773 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_process_multi_header_lines(ngx_http_request_t *r , ngx_table_elt_t *h ,
                                                     ngx_uint_t offset ) 
{ 
  ngx_array_t *headers ;
  ngx_table_elt_t **ph ;
  ngx_int_t tmp ;
  void *tmp___0 ;

  {
#line 1780
  headers = (ngx_array_t *)((char *)(& r->headers_in) + offset);
#line 1782
  if ((unsigned long )headers->elts == (unsigned long )((void *)0)) {
    {
#line 1783
    tmp = ngx_array_init(headers, r->pool, (ngx_uint_t )1, sizeof(ngx_table_elt_t *));
    }
#line 1783
    if (tmp != 0L) {
      {
#line 1786
      ngx_http_close_request(r, (ngx_int_t )500);
      }
#line 1787
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1791
  tmp___0 = ngx_array_push(headers);
#line 1791
  ph = (ngx_table_elt_t **)tmp___0;
  }
#line 1792
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
    {
#line 1793
    ngx_http_close_request(r, (ngx_int_t )500);
    }
#line 1794
    return ((ngx_int_t )-1);
  }
#line 1797
  *ph = h;
#line 1798
  return ((ngx_int_t )0);
}
}
#line 1802 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
ngx_int_t ngx_http_process_request_header(ngx_http_request_t *r ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1805
  if (r->headers_in.server.len == 0UL) {
    {
#line 1805
    tmp = ngx_http_set_virtual_server(r, & r->headers_in.server);
    }
#line 1805
    if (tmp == -1L) {
#line 1809
      return ((ngx_int_t )-1);
    }
  }
#line 1812
  if ((unsigned long )r->headers_in.host == (unsigned long )((void *)0)) {
#line 1812
    if (r->http_version > 1000UL) {
#line 1813
      if (((r->connection)->log)->log_level >= 7UL) {
        {
#line 1813
        ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent HTTP/1.1 request without \"Host\" header");
        }
      }
      {
#line 1815
      ngx_http_finalize_request(r, (ngx_int_t )400);
      }
#line 1816
      return ((ngx_int_t )-1);
    }
  }
#line 1819
  if (r->headers_in.content_length) {
    {
#line 1820
    r->headers_in.content_length_n = ngx_atoof((r->headers_in.content_length)->value.data,
                                               (r->headers_in.content_length)->value.len);
    }
#line 1824
    if (r->headers_in.content_length_n == -1L) {
#line 1825
      if (((r->connection)->log)->log_level >= 7UL) {
        {
#line 1825
        ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent invalid \"Content-Length\" header");
        }
      }
      {
#line 1827
      ngx_http_finalize_request(r, (ngx_int_t )400);
      }
#line 1828
      return ((ngx_int_t )-1);
    }
  }
#line 1832
  if (r->method == 32768UL) {
#line 1833
    if (((r->connection)->log)->log_level >= 7UL) {
      {
#line 1833
      ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent TRACE method");
      }
    }
    {
#line 1835
    ngx_http_finalize_request(r, (ngx_int_t )405);
    }
#line 1836
    return ((ngx_int_t )-1);
  }
#line 1839
  if (r->headers_in.transfer_encoding) {
#line 1840
    if ((r->headers_in.transfer_encoding)->value.len == 7UL) {
      {
#line 1840
      tmp___1 = ngx_strncasecmp((r->headers_in.transfer_encoding)->value.data, (u_char *)"chunked",
                                (size_t )7);
      }
#line 1840
      if (tmp___1 == 0L) {
#line 1844
        r->headers_in.content_length = (ngx_table_elt_t *)((void *)0);
#line 1845
        r->headers_in.content_length_n = (off_t )-1;
#line 1846
        r->headers_in.chunked = 1U;
      } else {
#line 1840
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1848
    if ((r->headers_in.transfer_encoding)->value.len != 8UL) {
#line 1848
      goto _L;
    } else {
      {
#line 1848
      tmp___0 = ngx_strncasecmp((r->headers_in.transfer_encoding)->value.data, (u_char *)"identity",
                                (size_t )8);
      }
#line 1848
      if (tmp___0 != 0L) {
        _L: /* CIL Label */ 
#line 1852
        if (((r->connection)->log)->log_level >= 7UL) {
          {
#line 1852
          ngx_log_error_core((ngx_uint_t )7, (r->connection)->log, 0, "client sent unknown \"Transfer-Encoding\": \"%V\"",
                             & (r->headers_in.transfer_encoding)->value);
          }
        }
        {
#line 1855
        ngx_http_finalize_request(r, (ngx_int_t )501);
        }
#line 1856
        return ((ngx_int_t )-1);
      }
    }
  }
#line 1860
  if (r->headers_in.connection_type == 2U) {
#line 1861
    if (r->headers_in.keep_alive) {
      {
#line 1862
      r->headers_in.keep_alive_n = ngx_atotm((r->headers_in.keep_alive)->value.data,
                                             (r->headers_in.keep_alive)->value.len);
      }
    }
  }
#line 1868
  return ((ngx_int_t )0);
}
}
#line 1872 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_process_request(ngx_http_request_t *r ) 
{ 
  ngx_connection_t *c ;

  {
#line 1877
  c = r->connection;
#line 1933
  if ((c->read)->timer_set) {
    {
#line 1934
    ngx_event_del_timer(c->read);
    }
  }
  {
#line 1944
  (c->read)->handler = & ngx_http_request_handler;
#line 1945
  (c->write)->handler = & ngx_http_request_handler;
#line 1946
  r->read_event_handler = & ngx_http_block_reading;
#line 1948
  ngx_http_handler(r);
#line 1950
  ngx_http_run_posted_requests(c);
  }
#line 1951
  return;
}
}
#line 1954 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_validate_host(ngx_str_t *host , ngx_pool_t *pool , ngx_uint_t alloc ) 
{ 
  u_char *h ;
  u_char ch ;
  size_t i ;
  size_t dot_pos ;
  size_t host_len ;
  enum __anonenum_state_242___0 state ;
  void *tmp ;

  {
#line 1966
  dot_pos = host->len;
#line 1967
  host_len = host->len;
#line 1969
  h = host->data;
#line 1971
  state = (enum __anonenum_state_242___0 )0;
#line 1973
  i = (size_t )0;
  {
#line 1973
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1973
    if (! (i < host->len)) {
#line 1973
      goto while_break;
    }
#line 1974
    ch = *(h + i);
    {
#line 1978
    if ((int )ch == 46) {
#line 1978
      goto case_46;
    }
#line 1985
    if ((int )ch == 58) {
#line 1985
      goto case_58;
    }
#line 1992
    if ((int )ch == 91) {
#line 1992
      goto case_91;
    }
#line 1998
    if ((int )ch == 93) {
#line 1998
      goto case_93;
    }
#line 2005
    if ((int )ch == 0) {
#line 2005
      goto case_0;
    }
#line 2008
    goto switch_default;
    case_46: /* CIL Label */ 
#line 1979
    if (dot_pos == i - 1UL) {
#line 1980
      return ((ngx_int_t )-5);
    }
#line 1982
    dot_pos = i;
#line 1983
    goto switch_break;
    case_58: /* CIL Label */ 
#line 1986
    if ((unsigned int )state == 0U) {
#line 1987
      host_len = i;
#line 1988
      state = (enum __anonenum_state_242___0 )2;
    }
#line 1990
    goto switch_break;
    case_91: /* CIL Label */ 
#line 1993
    if (i == 0UL) {
#line 1994
      state = (enum __anonenum_state_242___0 )1;
    }
#line 1996
    goto switch_break;
    case_93: /* CIL Label */ 
#line 1999
    if ((unsigned int )state == 1U) {
#line 2000
      host_len = i + 1UL;
#line 2001
      state = (enum __anonenum_state_242___0 )2;
    }
#line 2003
    goto switch_break;
    case_0: /* CIL Label */ 
#line 2006
    return ((ngx_int_t )-5);
    switch_default: /* CIL Label */ 
#line 2010
    if ((int )ch == 47) {
#line 2011
      return ((ngx_int_t )-5);
    }
#line 2014
    if ((int )ch >= 65) {
#line 2014
      if ((int )ch <= 90) {
#line 2015
        alloc = (ngx_uint_t )1;
      }
    }
#line 2018
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1973
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2022
  if (dot_pos == host_len - 1UL) {
#line 2023
    host_len --;
  }
#line 2026
  if (host_len == 0UL) {
#line 2027
    return ((ngx_int_t )-5);
  }
#line 2030
  if (alloc) {
    {
#line 2031
    tmp = ngx_pnalloc(pool, host_len);
#line 2031
    host->data = (u_char *)tmp;
    }
#line 2032
    if ((unsigned long )host->data == (unsigned long )((void *)0)) {
#line 2033
      return ((ngx_int_t )-1);
    }
    {
#line 2036
    ngx_strlow(host->data, h, host_len);
    }
  }
#line 2039
  host->len = host_len;
#line 2041
  return ((ngx_int_t )0);
}
}
#line 2045 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_set_virtual_server(ngx_http_request_t *r , ngx_str_t *host ) 
{ 
  ngx_int_t rc ;
  ngx_http_connection_t *hc ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t *cscf ;

  {
  {
#line 2054
  cscf = (ngx_http_core_srv_conf_t *)((void *)0);
#line 2057
  hc = r->http_connection;
#line 2081
  rc = ngx_http_find_virtual_server(r->connection, (hc->addr_conf)->virtual_names,
                                    host, r, & cscf);
  }
#line 2085
  if (rc == -1L) {
    {
#line 2086
    ngx_http_close_request(r, (ngx_int_t )500);
    }
#line 2087
    return ((ngx_int_t )-1);
  }
#line 2113
  if (rc == -5L) {
#line 2114
    return ((ngx_int_t )0);
  }
#line 2117
  r->srv_conf = (cscf->ctx)->srv_conf;
#line 2118
  r->loc_conf = (cscf->ctx)->loc_conf;
#line 2120
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2122
  ((r->connection)->log)->file = (clcf->error_log)->file;
#line 2122
  ((r->connection)->log)->next = (clcf->error_log)->next;
#line 2122
  ((r->connection)->log)->writer = (clcf->error_log)->writer;
#line 2122
  ((r->connection)->log)->wdata = (clcf->error_log)->wdata;
#line 2122
  if (! (((r->connection)->log)->log_level & 2147483648UL)) {
#line 2122
    ((r->connection)->log)->log_level = (clcf->error_log)->log_level;
  }
#line 2124
  return ((ngx_int_t )0);
}
}
#line 2128 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_find_virtual_server(ngx_connection_t *c , ngx_http_virtual_names_t *virtual_names ,
                                              ngx_str_t *host , ngx_http_request_t *r ,
                                              ngx_http_core_srv_conf_t **cscfp ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  ngx_uint_t tmp ;
  void *tmp___0 ;
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_http_server_name_t *sn ;

  {
#line 2135
  if ((unsigned long )virtual_names == (unsigned long )((void *)0)) {
#line 2136
    return ((ngx_int_t )-5);
  }
  {
#line 2139
  tmp = ngx_hash_key(host->data, host->len);
#line 2139
  tmp___0 = ngx_hash_find_combined(& virtual_names->names, tmp, host->data, host->len);
#line 2139
  cscf = (ngx_http_core_srv_conf_t *)tmp___0;
  }
#line 2143
  if (cscf) {
#line 2144
    *cscfp = cscf;
#line 2145
    return ((ngx_int_t )0);
  }
#line 2150
  if (host->len) {
#line 2150
    if (virtual_names->nregex) {
#line 2155
      sn = virtual_names->regex;
#line 2191
      i = (ngx_uint_t )0;
      {
#line 2191
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2191
        if (! (i < virtual_names->nregex)) {
#line 2191
          goto while_break;
        }
        {
#line 2193
        n = ngx_http_regex_exec(r, (sn + i)->regex, host);
        }
#line 2195
        if (n == -5L) {
#line 2196
          goto __Cont;
        }
#line 2199
        if (n == 0L) {
#line 2200
          *cscfp = (sn + i)->server;
#line 2201
          return ((ngx_int_t )0);
        }
#line 2204
        return ((ngx_int_t )-1);
        __Cont: /* CIL Label */ 
#line 2191
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 2210
  return ((ngx_int_t )-5);
}
}
#line 2214 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_request_handler(ngx_event_t *ev ) 
{ 
  ngx_connection_t *c ;
  ngx_http_request_t *r ;

  {
#line 2220
  c = (ngx_connection_t *)ev->data;
#line 2221
  r = (ngx_http_request_t *)c->data;
#line 2223
  ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 2228
  if (c->close) {
    {
#line 2229
    ((r->main)->count) ++;
#line 2230
    ngx_http_terminate_request(r, (ngx_int_t )0);
#line 2231
    ngx_http_run_posted_requests(c);
    }
#line 2232
    return;
  }
#line 2235
  if (ev->delayed) {
#line 2235
    if (ev->timedout) {
#line 2236
      ev->delayed = 0U;
#line 2237
      ev->timedout = 0U;
    }
  }
#line 2240
  if (ev->write) {
    {
#line 2241
    (*(r->write_event_handler))(r);
    }
  } else {
    {
#line 2244
    (*(r->read_event_handler))(r);
    }
  }
  {
#line 2247
  ngx_http_run_posted_requests(c);
  }
#line 2248
  return;
}
}
#line 2251 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_run_posted_requests(ngx_connection_t *c ) 
{ 
  ngx_http_request_t *r ;
  ngx_http_posted_request_t *pr ;

  {
  {
#line 2257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2259
    if (c->destroyed) {
#line 2260
      return;
    }
#line 2263
    r = (ngx_http_request_t *)c->data;
#line 2264
    pr = (r->main)->posted_requests;
#line 2266
    if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 2267
      return;
    }
    {
#line 2270
    (r->main)->posted_requests = pr->next;
#line 2272
    r = pr->request;
#line 2274
    ((ngx_http_log_ctx_t *)(c->log)->data)->current_request = r;
#line 2279
    (*(r->write_event_handler))(r);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 2284 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
ngx_int_t ngx_http_post_request(ngx_http_request_t *r , ngx_http_posted_request_t *pr ) 
{ 
  ngx_http_posted_request_t **p ;
  void *tmp ;

  {
#line 2289
  if ((unsigned long )pr == (unsigned long )((void *)0)) {
    {
#line 2290
    tmp = ngx_palloc(r->pool, sizeof(ngx_http_posted_request_t ));
#line 2290
    pr = (ngx_http_posted_request_t *)tmp;
    }
#line 2291
    if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 2292
      return ((ngx_int_t )-1);
    }
  }
#line 2296
  pr->request = r;
#line 2297
  pr->next = (ngx_http_posted_request_t *)((void *)0);
#line 2299
  p = & (r->main)->posted_requests;
  {
#line 2299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2299
    if (! *p) {
#line 2299
      goto while_break;
    }
#line 2299
    p = & (*p)->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2301
  *p = pr;
#line 2303
  return ((ngx_int_t )0);
}
}
#line 2307 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_finalize_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 
  ngx_connection_t *c ;
  ngx_http_request_t *pr ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 2314
  c = r->connection;
#line 2320
  if (rc == -4L) {
    {
#line 2321
    ngx_http_finalize_connection(r);
    }
#line 2322
    return;
  }
#line 2325
  if (rc == 0L) {
#line 2325
    if (r->filter_finalize) {
#line 2326
      c->error = 1U;
    }
  }
#line 2329
  if (rc == -5L) {
    {
#line 2330
    r->content_handler = (ngx_int_t (*)(ngx_http_request_t *r ))((void *)0);
#line 2331
    r->write_event_handler = & ngx_http_core_run_phases;
#line 2332
    ngx_http_core_run_phases(r);
    }
#line 2333
    return;
  }
#line 2336
  if ((unsigned long )r != (unsigned long )r->main) {
#line 2336
    if (r->post_subrequest) {
      {
#line 2337
      rc = (*((r->post_subrequest)->handler))(r, (r->post_subrequest)->data, rc);
      }
    }
  }
#line 2340
  if (rc == -1L) {
#line 2340
    goto _L;
  } else
#line 2340
  if (rc == 408L) {
#line 2340
    goto _L;
  } else
#line 2340
  if (rc == 499L) {
#line 2340
    goto _L;
  } else
#line 2340
  if (c->error) {
    _L: /* CIL Label */ 
    {
#line 2345
    tmp = ngx_http_post_action(r);
    }
#line 2345
    if (tmp == 0L) {
#line 2346
      return;
    }
    {
#line 2349
    ngx_http_terminate_request(r, rc);
    }
#line 2350
    return;
  }
#line 2353
  if (rc >= 300L) {
#line 2353
    goto _L___0;
  } else
#line 2353
  if (rc == 201L) {
#line 2353
    goto _L___0;
  } else
#line 2353
  if (rc == 204L) {
    _L___0: /* CIL Label */ 
#line 2357
    if (rc == 444L) {
      {
#line 2358
      ngx_http_terminate_request(r, rc);
      }
#line 2359
      return;
    }
#line 2362
    if ((unsigned long )r == (unsigned long )r->main) {
#line 2363
      if ((c->read)->timer_set) {
        {
#line 2364
        ngx_event_del_timer(c->read);
        }
      }
#line 2367
      if ((c->write)->timer_set) {
        {
#line 2368
        ngx_event_del_timer(c->write);
        }
      }
    }
    {
#line 2372
    (c->read)->handler = & ngx_http_request_handler;
#line 2373
    (c->write)->handler = & ngx_http_request_handler;
#line 2375
    tmp___0 = ngx_http_special_response_handler(r, rc);
#line 2375
    ngx_http_finalize_request(r, tmp___0);
    }
#line 2376
    return;
  }
#line 2379
  if ((unsigned long )r != (unsigned long )r->main) {
#line 2380
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2382
    if (r->background) {
#line 2383
      if (! r->logged) {
#line 2384
        if (clcf->log_subrequest) {
          {
#line 2385
          ngx_http_log_request(r);
          }
        }
#line 2388
        r->logged = 1U;
      } else
#line 2391
      if ((c->log)->log_level >= 2UL) {
        {
#line 2391
        ngx_log_error_core((ngx_uint_t )2, c->log, 0, "subrequest: \"%V?%V\" logged again",
                           & r->uri, & r->args);
        }
      }
      {
#line 2396
      r->done = 1U;
#line 2397
      ngx_http_finalize_connection(r);
      }
#line 2398
      return;
    }
#line 2401
    if (r->buffered) {
#line 2401
      goto _L___1;
    } else
#line 2401
    if (r->postponed) {
      _L___1: /* CIL Label */ 
      {
#line 2403
      tmp___1 = ngx_http_set_write_handler(r);
      }
#line 2403
      if (tmp___1 != 0L) {
        {
#line 2404
        ngx_http_terminate_request(r, (ngx_int_t )0);
        }
      }
#line 2407
      return;
    }
#line 2410
    pr = r->parent;
#line 2412
    if ((unsigned long )r == (unsigned long )c->data) {
#line 2414
      ((r->main)->count) --;
#line 2416
      if (! r->logged) {
#line 2417
        if (clcf->log_subrequest) {
          {
#line 2418
          ngx_http_log_request(r);
          }
        }
#line 2421
        r->logged = 1U;
      } else
#line 2424
      if ((c->log)->log_level >= 2UL) {
        {
#line 2424
        ngx_log_error_core((ngx_uint_t )2, c->log, 0, "subrequest: \"%V?%V\" logged again",
                           & r->uri, & r->args);
        }
      }
#line 2429
      r->done = 1U;
#line 2431
      if (pr->postponed) {
#line 2431
        if ((unsigned long )(pr->postponed)->request == (unsigned long )r) {
#line 2432
          pr->postponed = (pr->postponed)->next;
        }
      }
#line 2435
      c->data = (void *)pr;
    } else {
#line 2443
      r->write_event_handler = & ngx_http_request_finalizer;
#line 2445
      if (r->waited) {
#line 2446
        r->done = 1U;
      }
    }
    {
#line 2450
    tmp___2 = ngx_http_post_request(pr, (ngx_http_posted_request_t *)((void *)0));
    }
#line 2450
    if (tmp___2 != 0L) {
      {
#line 2451
      ((r->main)->count) ++;
#line 2452
      ngx_http_terminate_request(r, (ngx_int_t )0);
      }
#line 2453
      return;
    }
#line 2460
    return;
  }
#line 2463
  if (r->buffered) {
#line 2463
    goto _L___2;
  } else
#line 2463
  if (c->buffered) {
#line 2463
    goto _L___2;
  } else
#line 2463
  if (r->postponed) {
    _L___2: /* CIL Label */ 
    {
#line 2465
    tmp___3 = ngx_http_set_write_handler(r);
    }
#line 2465
    if (tmp___3 != 0L) {
      {
#line 2466
      ngx_http_terminate_request(r, (ngx_int_t )0);
      }
    }
#line 2469
    return;
  }
#line 2472
  if ((unsigned long )r != (unsigned long )c->data) {
#line 2473
    if ((c->log)->log_level >= 2UL) {
      {
#line 2473
      ngx_log_error_core((ngx_uint_t )2, c->log, 0, "http finalize non-active request: \"%V?%V\"",
                         & r->uri, & r->args);
      }
    }
#line 2476
    return;
  }
#line 2479
  r->done = 1U;
#line 2481
  r->read_event_handler = & ngx_http_block_reading;
#line 2482
  r->write_event_handler = & ngx_http_request_empty_handler;
#line 2484
  if (! r->post_action) {
#line 2485
    r->request_complete = 1U;
  }
  {
#line 2488
  tmp___4 = ngx_http_post_action(r);
  }
#line 2488
  if (tmp___4 == 0L) {
#line 2489
    return;
  }
#line 2492
  if ((c->read)->timer_set) {
    {
#line 2493
    ngx_event_del_timer(c->read);
    }
  }
#line 2496
  if ((c->write)->timer_set) {
    {
#line 2497
    (c->write)->delayed = 0U;
#line 2498
    ngx_event_del_timer(c->write);
    }
  }
#line 2501
  if ((c->read)->eof) {
    {
#line 2502
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 2503
    return;
  }
  {
#line 2506
  ngx_http_finalize_connection(r);
  }
#line 2507
  return;
}
}
#line 2510 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_terminate_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 
  ngx_http_cleanup_t *cln ;
  ngx_http_request_t *mr ;
  ngx_http_ephemeral_t *e ;

  {
#line 2517
  mr = r->main;
#line 2522
  if (rc > 0L) {
#line 2522
    if (mr->headers_out.status == 0UL) {
#line 2523
      mr->headers_out.status = (ngx_uint_t )rc;
    } else
#line 2522
    if ((mr->connection)->sent == 0L) {
#line 2523
      mr->headers_out.status = (ngx_uint_t )rc;
    }
  }
#line 2526
  cln = mr->cleanup;
#line 2527
  mr->cleanup = (ngx_http_cleanup_t *)((void *)0);
  {
#line 2529
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2529
    if (! cln) {
#line 2529
      goto while_break;
    }
#line 2530
    if (cln->handler) {
      {
#line 2531
      (*(cln->handler))(cln->data);
      }
    }
#line 2534
    cln = cln->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 2541
  if (mr->write_event_handler) {
#line 2543
    if (mr->blocked) {
#line 2544
      (r->connection)->error = 1U;
#line 2545
      r->write_event_handler = & ngx_http_request_finalizer;
#line 2546
      return;
    }
    {
#line 2549
    e = (ngx_http_ephemeral_t *)((void *)(& mr->uri_start));
#line 2550
    mr->posted_requests = (ngx_http_posted_request_t *)((void *)0);
#line 2551
    mr->write_event_handler = & ngx_http_terminate_handler;
#line 2552
    ngx_http_post_request(mr, & e->terminal_posted_request);
    }
#line 2553
    return;
  }
  {
#line 2556
  ngx_http_close_request(mr, rc);
  }
#line 2557
  return;
}
}
#line 2560 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_terminate_handler(ngx_http_request_t *r ) 
{ 


  {
  {
#line 2566
  r->count = 1U;
#line 2568
  ngx_http_close_request(r, (ngx_int_t )0);
  }
#line 2569
  return;
}
}
#line 2572 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_finalize_connection(ngx_http_request_t *r ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 2584
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2586
  if ((r->main)->count != 1U) {
#line 2588
    if (r->discard_body) {
      {
#line 2589
      r->read_event_handler = & ngx_http_discarded_request_body_handler;
#line 2590
      ngx_event_add_timer((r->connection)->read, clcf->lingering_timeout);
      }
#line 2592
      if (r->lingering_time == 0L) {
#line 2593
        r->lingering_time = (time_t )(ngx_cached_time->sec + (time_t volatile   )((time_t )(clcf->lingering_time / 1000UL)));
      }
    }
    {
#line 2598
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 2599
    return;
  }
#line 2602
  r = r->main;
#line 2604
  if (r->reading_body) {
#line 2605
    r->keepalive = 0U;
#line 2606
    r->lingering_close = 1U;
  }
#line 2609
  if (! ngx_terminate) {
#line 2609
    if (! ngx_exiting) {
#line 2609
      if (r->keepalive) {
#line 2609
        if (clcf->keepalive_timeout > 0UL) {
          {
#line 2614
          ngx_http_set_keepalive(r);
          }
#line 2615
          return;
        }
      }
    }
  }
#line 2618
  if (clcf->lingering_close == 2UL) {
    {
#line 2624
    ngx_http_set_lingering_close(r);
    }
#line 2625
    return;
  } else
#line 2618
  if (clcf->lingering_close == 1UL) {
#line 2618
    if (r->lingering_close) {
      {
#line 2624
      ngx_http_set_lingering_close(r);
      }
#line 2625
      return;
    } else
#line 2618
    if ((unsigned long )(r->header_in)->pos < (unsigned long )(r->header_in)->last) {
      {
#line 2624
      ngx_http_set_lingering_close(r);
      }
#line 2625
      return;
    } else
#line 2618
    if (((r->connection)->read)->ready) {
      {
#line 2624
      ngx_http_set_lingering_close(r);
      }
#line 2625
      return;
    }
  }
  {
#line 2628
  ngx_http_close_request(r, (ngx_int_t )0);
  }
#line 2629
  return;
}
}
#line 2632 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_set_write_handler(ngx_http_request_t *r ) 
{ 
  ngx_event_t *wev ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;

  {
#line 2638
  r->http_state = 6U;
#line 2640
  if (r->discard_body) {
#line 2640
    r->read_event_handler = & ngx_http_discarded_request_body_handler;
  } else {
#line 2640
    r->read_event_handler = & ngx_http_test_reading;
  }
#line 2643
  r->write_event_handler = & ngx_http_writer;
#line 2645
  wev = (r->connection)->write;
#line 2647
  if (wev->ready) {
#line 2647
    if (wev->delayed) {
#line 2648
      return ((ngx_int_t )0);
    }
  }
#line 2651
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2652
  if (! wev->delayed) {
    {
#line 2653
    ngx_event_add_timer(wev, clcf->send_timeout);
    }
  }
  {
#line 2656
  tmp = ngx_handle_write_event(wev, clcf->send_lowat);
  }
#line 2656
  if (tmp != 0L) {
    {
#line 2657
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 2658
    return ((ngx_int_t )-1);
  }
#line 2661
  return ((ngx_int_t )0);
}
}
#line 2665 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_writer(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp8 ;

  {
#line 2673
  c = r->connection;
#line 2674
  wev = c->write;
#line 2679
  clcf = (ngx_http_core_loc_conf_t *)*((r->main)->loc_conf + ngx_http_core_module.ctx_index);
#line 2681
  if (wev->timedout) {
#line 2682
    if ((c->log)->log_level >= 7UL) {
      {
#line 2682
      ngx_log_error_core((ngx_uint_t )7, c->log, 110, "client timed out");
      }
    }
    {
#line 2684
    c->timedout = 1U;
#line 2686
    ngx_http_finalize_request(r, (ngx_int_t )408);
    }
#line 2687
    return;
  }
#line 2690
  if (wev->delayed) {
#line 2690
    goto _L;
  } else
#line 2690
  if (r->aio) {
    _L: /* CIL Label */ 
#line 2694
    if (! wev->delayed) {
      {
#line 2695
      ngx_event_add_timer(wev, clcf->send_timeout);
      }
    }
    {
#line 2698
    tmp = ngx_handle_write_event(wev, clcf->send_lowat);
    }
#line 2698
    if (tmp != 0L) {
      {
#line 2699
      ngx_http_close_request(r, (ngx_int_t )0);
      }
    }
#line 2702
    return;
  }
  {
#line 2705
  rc = ngx_http_output_filter(r, (ngx_chain_t *)((void *)0));
  }
#line 2711
  if (rc == -1L) {
    {
#line 2712
    ngx_http_finalize_request(r, rc);
    }
#line 2713
    return;
  }
#line 2716
  if (r->buffered) {
#line 2716
    goto _L___0;
  } else
#line 2716
  if (r->postponed) {
#line 2716
    goto _L___0;
  } else
#line 2716
  if ((unsigned long )r == (unsigned long )r->main) {
#line 2716
    if (c->buffered) {
      _L___0: /* CIL Label */ 
#line 2718
      if (! wev->delayed) {
        {
#line 2719
        ngx_event_add_timer(wev, clcf->send_timeout);
        }
      }
      {
#line 2722
      tmp___0 = ngx_handle_write_event(wev, clcf->send_lowat);
      }
#line 2722
      if (tmp___0 != 0L) {
        {
#line 2723
        ngx_http_close_request(r, (ngx_int_t )0);
        }
      }
#line 2726
      return;
    }
  }
  {
#line 2732
  r->write_event_handler = & ngx_http_request_empty_handler;
#line 2734
  ngx_http_finalize_request(r, rc);
  }
#line 2735
  return;
}
}
#line 2738 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_request_finalizer(ngx_http_request_t *r ) 
{ 


  {
  {
#line 2744
  ngx_http_finalize_request(r, (ngx_int_t )0);
  }
#line 2745
  return;
}
}
#line 2748 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_block_reading(ngx_http_request_t *r ) 
{ 
  ngx_int_t tmp ;

  {
#line 2756
  if (ngx_event_flags & 1UL) {
#line 2756
    if (((r->connection)->read)->active) {
      {
#line 2759
      tmp = (*(ngx_event_actions.del))((r->connection)->read, (ngx_int_t )8193, (ngx_uint_t )0);
      }
#line 2759
      if (tmp != 0L) {
        {
#line 2760
        ngx_http_close_request(r, (ngx_int_t )0);
        }
      }
    }
  }
#line 2763
  return;
}
}
#line 2766 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_test_reading(ngx_http_request_t *r ) 
{ 
  int n ;
  char buf[1] ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  ngx_connection_t *c ;
  socklen_t len ;
  int *tmp ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  ngx_int_t tmp___3 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 2775
  c = r->connection;
#line 2776
  rev = c->read;
#line 2812
  if (ngx_event_flags & 64UL) {
#line 2812
    if (ngx_use_epoll_rdhup) {
#line 2815
      if (! rev->pending_eof) {
#line 2816
        return;
      }
      {
#line 2819
      rev->eof = 1U;
#line 2820
      c->error = 1U;
#line 2822
      err = 0;
#line 2823
      len = (socklen_t )sizeof(ngx_err_t );
#line 2830
      tmp___0 = getsockopt(c->fd, 1, 4, (void */* __restrict  */)((void *)(& err)),
                           (socklen_t */* __restrict  */)(& len));
      }
#line 2830
      if (tmp___0 == -1) {
        {
#line 2833
        tmp = __errno_location();
#line 2833
        err = *tmp;
        }
      }
#line 2836
      goto closed;
    }
  }
  {
#line 2841
  tmp___1 = recv(c->fd, (void *)(buf), (size_t )1, 2);
#line 2841
  n = (int )tmp___1;
  }
#line 2843
  if (n == 0) {
#line 2844
    rev->eof = 1U;
#line 2845
    c->error = 1U;
#line 2846
    err = 0;
#line 2848
    goto closed;
  } else
#line 2850
  if (n == -1) {
    {
#line 2851
    tmp___2 = __errno_location();
#line 2851
    err = *tmp___2;
    }
#line 2853
    if (err != 11) {
#line 2854
      rev->eof = 1U;
#line 2855
      c->error = 1U;
#line 2857
      goto closed;
    }
  }
#line 2863
  if (ngx_event_flags & 1UL) {
#line 2863
    if (rev->active) {
      {
#line 2865
      tmp___3 = (*(ngx_event_actions.del))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
      }
#line 2865
      if (tmp___3 != 0L) {
        {
#line 2866
        ngx_http_close_request(r, (ngx_int_t )0);
        }
      }
    }
  }
#line 2870
  return;
  closed: 
#line 2874
  if (err) {
#line 2875
    rev->error = 1U;
  }
#line 2878
  if ((c->log)->log_level >= 7UL) {
    {
#line 2878
    ngx_log_error_core((ngx_uint_t )7, c->log, err, "client prematurely closed connection");
    }
  }
  {
#line 2881
  ngx_http_finalize_request(r, (ngx_int_t )499);
  }
#line 2882
  return;
}
}
#line 2885 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_set_keepalive(ngx_http_request_t *r ) 
{ 
  int tcp_nodelay ;
  ngx_buf_t *b ;
  ngx_buf_t *f ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_http_connection_t *hc ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 2896
  c = r->connection;
#line 2897
  rev = c->read;
#line 2899
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 2903
  if (r->discard_body) {
    {
#line 2904
    r->write_event_handler = & ngx_http_request_empty_handler;
#line 2905
    r->lingering_time = (time_t )(ngx_cached_time->sec + (time_t volatile   )((time_t )(clcf->lingering_time / 1000UL)));
#line 2906
    ngx_event_add_timer(rev, clcf->lingering_timeout);
    }
#line 2907
    return;
  }
#line 2910
  (c->log)->action = (char *)"closing request";
#line 2912
  hc = r->http_connection;
#line 2913
  b = r->header_in;
#line 2915
  if ((unsigned long )b->pos < (unsigned long )b->last) {
#line 2919
    if ((unsigned long )b != (unsigned long )c->buffer) {
#line 2929
      cl = hc->busy;
      {
#line 2929
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2929
        if (! cl) {
#line 2929
          goto while_break;
        }
#line 2930
        ln = cl;
#line 2931
        cl = cl->next;
#line 2933
        if ((unsigned long )ln->buf == (unsigned long )b) {
#line 2934
          ln->next = (c->pool)->chain;
#line 2934
          (c->pool)->chain = ln;
#line 2935
          goto __Cont;
        }
#line 2938
        f = ln->buf;
#line 2939
        f->pos = f->start;
#line 2940
        f->last = f->start;
#line 2942
        ln->next = hc->free;
#line 2943
        hc->free = ln;
        __Cont: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 2946
      cl = ngx_alloc_chain_link(c->pool);
      }
#line 2947
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
        {
#line 2948
        ngx_http_close_request(r, (ngx_int_t )0);
        }
#line 2949
        return;
      }
#line 2952
      cl->buf = b;
#line 2953
      cl->next = (ngx_chain_t *)((void *)0);
#line 2955
      hc->busy = cl;
#line 2956
      hc->nbusy = (ngx_int_t )1;
    }
  }
  {
#line 2961
  r->keepalive = 0U;
#line 2963
  ngx_http_free_request(r, (ngx_int_t )0);
#line 2965
  c->data = (void *)hc;
#line 2967
  tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 2967
  if (tmp != 0L) {
    {
#line 2968
    ngx_http_close_connection(c);
    }
#line 2969
    return;
  }
#line 2972
  wev = c->write;
#line 2973
  wev->handler = & ngx_http_empty_handler;
#line 2975
  if ((unsigned long )b->pos < (unsigned long )b->last) {
    {
#line 2979
    (c->log)->action = (char *)"reading client pipelined request line";
#line 2981
    r = ngx_http_create_request(c);
    }
#line 2982
    if ((unsigned long )r == (unsigned long )((void *)0)) {
      {
#line 2983
      ngx_http_close_connection(c);
      }
#line 2984
      return;
    }
#line 2987
    r->pipeline = 1U;
#line 2989
    c->data = (void *)r;
#line 2991
    c->sent = (off_t )0;
#line 2992
    c->destroyed = 0U;
#line 2994
    if (rev->timer_set) {
      {
#line 2995
      ngx_event_del_timer(rev);
      }
    }
#line 2998
    rev->handler = & ngx_http_process_request_line;
#line 2999
    if (! rev->posted) {
#line 2999
      rev->posted = 1U;
#line 2999
      rev->queue.prev = ngx_posted_events.prev;
#line 2999
      (rev->queue.prev)->next = & rev->queue;
#line 2999
      rev->queue.next = & ngx_posted_events;
#line 2999
      ngx_posted_events.prev = & rev->queue;
    }
#line 3000
    return;
  }
  {
#line 3010
  b = c->buffer;
#line 3012
  tmp___0 = ngx_pfree(c->pool, (void *)b->start);
  }
#line 3012
  if (tmp___0 == 0L) {
#line 3019
    b->pos = (u_char *)((void *)0);
  } else {
#line 3022
    b->pos = b->start;
#line 3023
    b->last = b->start;
  }
#line 3029
  if (hc->free) {
#line 3030
    cl = hc->free;
    {
#line 3030
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3030
      if (! cl) {
#line 3030
        goto while_break___0;
      }
      {
#line 3031
      ln = cl;
#line 3032
      cl = cl->next;
#line 3033
      ngx_pfree(c->pool, (void *)(ln->buf)->start);
#line 3034
      ln->next = (c->pool)->chain;
#line 3034
      (c->pool)->chain = ln;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3037
    hc->free = (ngx_chain_t *)((void *)0);
  }
#line 3043
  if (hc->busy) {
#line 3044
    cl = hc->busy;
    {
#line 3044
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3044
      if (! cl) {
#line 3044
        goto while_break___1;
      }
      {
#line 3045
      ln = cl;
#line 3046
      cl = cl->next;
#line 3047
      ngx_pfree(c->pool, (void *)(ln->buf)->start);
#line 3048
      ln->next = (c->pool)->chain;
#line 3048
      (c->pool)->chain = ln;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 3051
    hc->busy = (ngx_chain_t *)((void *)0);
#line 3052
    hc->nbusy = (ngx_int_t )0;
  }
#line 3061
  rev->handler = & ngx_http_keepalive_handler;
#line 3063
  if (wev->active) {
#line 3063
    if (ngx_event_flags & 1UL) {
      {
#line 3064
      tmp___1 = (*(ngx_event_actions.del))(wev, (ngx_int_t )4, (ngx_uint_t )0);
      }
#line 3064
      if (tmp___1 != 0L) {
        {
#line 3065
        ngx_http_close_connection(c);
        }
#line 3066
        return;
      }
    }
  }
#line 3070
  (c->log)->action = (char *)"keepalive";
#line 3072
  if (c->tcp_nopush == 1U) {
    {
#line 3073
    tmp___3 = ngx_tcp_push(c->fd);
    }
#line 3073
    if (tmp___3 == -1) {
      {
#line 3074
      tmp___2 = __errno_location();
#line 3074
      ngx_connection_error(c, *tmp___2, (char *)"setsockopt(!TCP_CORK) failed");
#line 3075
      ngx_http_close_connection(c);
      }
#line 3076
      return;
    }
#line 3079
    c->tcp_nopush = 0U;
#line 3080
    if (ngx_tcp_nodelay_and_tcp_nopush) {
#line 3080
      tcp_nodelay = 1;
    } else {
#line 3080
      tcp_nodelay = 0;
    }
  } else {
#line 3083
    tcp_nodelay = 1;
  }
#line 3086
  if (tcp_nodelay) {
#line 3086
    if (clcf->tcp_nodelay) {
      {
#line 3086
      tmp___4 = ngx_tcp_nodelay(c);
      }
#line 3086
      if (tmp___4 != 0L) {
        {
#line 3087
        ngx_http_close_connection(c);
        }
#line 3088
        return;
      }
    }
  }
  {
#line 3096
  c->idle = 1U;
#line 3097
  ngx_reusable_connection(c, (ngx_uint_t )1);
#line 3099
  ngx_event_add_timer(rev, clcf->keepalive_timeout);
  }
#line 3101
  if (rev->ready) {
#line 3102
    if (! rev->posted) {
#line 3102
      rev->posted = 1U;
#line 3102
      rev->queue.prev = ngx_posted_events.prev;
#line 3102
      (rev->queue.prev)->next = & rev->queue;
#line 3102
      rev->queue.next = & ngx_posted_events;
#line 3102
      ngx_posted_events.prev = & rev->queue;
    }
  }
#line 3104
  return;
}
}
#line 3107 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_keepalive_handler(ngx_event_t *rev ) 
{ 
  size_t size ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_connection_t *c ;
  void *tmp ;
  int *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  int *tmp___3 ;
  ngx_http_request_t *tmp___4 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 3115
  c = (ngx_connection_t *)rev->data;
#line 3119
  if (rev->timedout) {
    {
#line 3120
    ngx_http_close_connection(c);
    }
#line 3121
    return;
  } else
#line 3119
  if (c->close) {
    {
#line 3120
    ngx_http_close_connection(c);
    }
#line 3121
    return;
  }
#line 3144
  b = c->buffer;
#line 3145
  size = (size_t )(b->end - b->start);
#line 3147
  if ((unsigned long )b->pos == (unsigned long )((void *)0)) {
    {
#line 3155
    tmp = ngx_palloc(c->pool, size);
#line 3155
    b->pos = (u_char *)tmp;
    }
#line 3156
    if ((unsigned long )b->pos == (unsigned long )((void *)0)) {
      {
#line 3157
      ngx_http_close_connection(c);
      }
#line 3158
      return;
    }
#line 3161
    b->start = b->pos;
#line 3162
    b->last = b->pos;
#line 3163
    b->end = b->pos + size;
  }
  {
#line 3171
  c->log_error = 3U;
#line 3172
  tmp___0 = __errno_location();
#line 3172
  *tmp___0 = 0;
#line 3174
  n = (*(c->recv))(c, b->last, size);
#line 3175
  c->log_error = 2U;
  }
#line 3177
  if (n == -2L) {
    {
#line 3178
    tmp___1 = ngx_handle_read_event(rev, (ngx_uint_t )0);
    }
#line 3178
    if (tmp___1 != 0L) {
      {
#line 3179
      ngx_http_close_connection(c);
      }
#line 3180
      return;
    }
    {
#line 3188
    tmp___2 = ngx_pfree(c->pool, (void *)b->start);
    }
#line 3188
    if (tmp___2 == 0L) {
#line 3194
      b->pos = (u_char *)((void *)0);
    }
#line 3197
    return;
  }
#line 3200
  if (n == -1L) {
    {
#line 3201
    ngx_http_close_connection(c);
    }
#line 3202
    return;
  }
#line 3205
  (c->log)->handler = (u_char *(*)(ngx_log_t *log , u_char *buf , size_t len ))((void *)0);
#line 3207
  if (n == 0L) {
#line 3208
    if ((c->log)->log_level >= 7UL) {
      {
#line 3208
      tmp___3 = __errno_location();
#line 3208
      ngx_log_error_core((ngx_uint_t )7, c->log, *tmp___3, "client %V closed keepalive connection",
                         & c->addr_text);
      }
    }
    {
#line 3210
    ngx_http_close_connection(c);
    }
#line 3211
    return;
  }
  {
#line 3214
  b->last += n;
#line 3216
  (c->log)->handler = & ngx_http_log_error;
#line 3217
  (c->log)->action = (char *)"reading client request line";
#line 3219
  c->idle = 0U;
#line 3220
  ngx_reusable_connection(c, (ngx_uint_t )0);
#line 3222
  tmp___4 = ngx_http_create_request(c);
#line 3222
  c->data = (void *)tmp___4;
  }
#line 3223
  if ((unsigned long )c->data == (unsigned long )((void *)0)) {
    {
#line 3224
    ngx_http_close_connection(c);
    }
#line 3225
    return;
  }
  {
#line 3228
  c->sent = (off_t )0;
#line 3229
  c->destroyed = 0U;
#line 3231
  ngx_event_del_timer(rev);
#line 3233
  rev->handler = & ngx_http_process_request_line;
#line 3234
  ngx_http_process_request_line(rev);
  }
#line 3235
  return;
}
}
#line 3238 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_set_lingering_close(ngx_http_request_t *r ) 
{ 
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;

  {
  {
#line 3245
  c = r->connection;
#line 3247
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3249
  rev = c->read;
#line 3250
  rev->handler = & ngx_http_lingering_close_handler;
#line 3252
  r->lingering_time = (time_t )(ngx_cached_time->sec + (time_t volatile   )((time_t )(clcf->lingering_time / 1000UL)));
#line 3253
  ngx_event_add_timer(rev, clcf->lingering_timeout);
#line 3255
  tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 3255
  if (tmp != 0L) {
    {
#line 3256
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3257
    return;
  }
#line 3260
  wev = c->write;
#line 3261
  wev->handler = & ngx_http_empty_handler;
#line 3263
  if (wev->active) {
#line 3263
    if (ngx_event_flags & 1UL) {
      {
#line 3264
      tmp___0 = (*(ngx_event_actions.del))(wev, (ngx_int_t )4, (ngx_uint_t )0);
      }
#line 3264
      if (tmp___0 != 0L) {
        {
#line 3265
        ngx_http_close_request(r, (ngx_int_t )0);
        }
#line 3266
        return;
      }
    }
  }
  {
#line 3270
  tmp___2 = shutdown(c->fd, 1);
  }
#line 3270
  if (tmp___2 == -1) {
    {
#line 3271
    tmp___1 = __errno_location();
#line 3271
    ngx_connection_error(c, *tmp___1, (char *)"shutdown() failed");
#line 3273
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3274
    return;
  }
#line 3277
  if (rev->ready) {
    {
#line 3278
    ngx_http_lingering_close_handler(rev);
    }
  }
#line 3280
  return;
}
}
#line 3283 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_lingering_close_handler(ngx_event_t *rev ) 
{ 
  ssize_t n ;
  ngx_msec_t timer ;
  ngx_connection_t *c ;
  ngx_http_request_t *r ;
  ngx_http_core_loc_conf_t *clcf ;
  u_char buffer___0[4096] ;
  ngx_int_t tmp ;
  void *__cil_tmp9 ;

  {
#line 3293
  c = (ngx_connection_t *)rev->data;
#line 3294
  r = (ngx_http_request_t *)c->data;
#line 3299
  if (rev->timedout) {
    {
#line 3300
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3301
    return;
  }
#line 3304
  timer = (ngx_msec_t )r->lingering_time - (ngx_msec_t )ngx_cached_time->sec;
#line 3305
  if ((ngx_msec_int_t )timer <= 0L) {
    {
#line 3306
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3307
    return;
  }
  {
#line 3310
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 3311
    n = (*(c->recv))(c, buffer___0, (size_t )4096);
    }
#line 3315
    if (n == -1L) {
      {
#line 3316
      ngx_http_close_request(r, (ngx_int_t )0);
      }
#line 3317
      return;
    } else
#line 3315
    if (n == 0L) {
      {
#line 3316
      ngx_http_close_request(r, (ngx_int_t )0);
      }
#line 3317
      return;
    }
#line 3310
    if (! rev->ready) {
#line 3310
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3322
  tmp = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 3322
  if (tmp != 0L) {
    {
#line 3323
    ngx_http_close_request(r, (ngx_int_t )0);
    }
#line 3324
    return;
  }
#line 3327
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3329
  timer *= 1000UL;
#line 3331
  if (timer > clcf->lingering_timeout) {
#line 3332
    timer = clcf->lingering_timeout;
  }
  {
#line 3335
  ngx_event_add_timer(rev, timer);
  }
#line 3336
  return;
}
}
#line 3339 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_empty_handler(ngx_event_t *wev ) 
{ 


  {
#line 3344
  return;
}
}
#line 3348 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_request_empty_handler(ngx_http_request_t *r ) 
{ 


  {
#line 3354
  return;
}
}
#line 3358 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
ngx_int_t ngx_http_send_special(ngx_http_request_t *r , ngx_uint_t flags ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t out ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 3364
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 3364
  b = (ngx_buf_t *)tmp;
  }
#line 3365
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 3366
    return ((ngx_int_t )-1);
  }
#line 3369
  if (flags & 1UL) {
#line 3371
    if ((unsigned long )r == (unsigned long )r->main) {
#line 3371
      if (! r->post_action) {
#line 3372
        b->last_buf = 1U;
      } else {
#line 3375
        b->sync = 1U;
#line 3376
        b->last_in_chain = 1U;
      }
    } else {
#line 3375
      b->sync = 1U;
#line 3376
      b->last_in_chain = 1U;
    }
  }
#line 3380
  if (flags & 2UL) {
#line 3381
    b->flush = 1U;
  }
  {
#line 3384
  out.buf = b;
#line 3385
  out.next = (ngx_chain_t *)((void *)0);
#line 3387
  tmp___0 = ngx_http_output_filter(r, & out);
  }
#line 3387
  return (tmp___0);
}
}
#line 3391 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static ngx_int_t ngx_http_post_action(ngx_http_request_t *r ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 3396
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3398
  if ((unsigned long )clcf->post_action.data == (unsigned long )((void *)0)) {
#line 3399
    return ((ngx_int_t )-5);
  }
#line 3402
  if (r->post_action) {
#line 3402
    if (r->uri_changes == 0U) {
#line 3403
      return ((ngx_int_t )-5);
    }
  }
#line 3409
  ((r->main)->count) --;
#line 3411
  r->http_version = (ngx_uint_t )9;
#line 3412
  r->header_only = 1U;
#line 3413
  r->post_action = 1U;
#line 3415
  r->read_event_handler = & ngx_http_block_reading;
#line 3417
  if ((int )*(clcf->post_action.data + 0) == 47) {
    {
#line 3418
    ngx_http_internal_redirect(r, & clcf->post_action, (ngx_str_t *)((void *)0));
    }
  } else {
    {
#line 3421
    ngx_http_named_location(r, & clcf->post_action);
    }
  }
#line 3424
  return ((ngx_int_t )0);
}
}
#line 3428 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_close_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 
  ngx_connection_t *c ;
  char *__cil_tmp4 ;

  {
#line 3433
  r = r->main;
#line 3434
  c = r->connection;
#line 3439
  if (r->count == 0U) {
#line 3440
    if ((c->log)->log_level >= 2UL) {
      {
#line 3440
      ngx_log_error_core((ngx_uint_t )2, c->log, 0, "http request count is zero");
      }
    }
  }
#line 3443
  (r->count) --;
#line 3445
  if (r->count) {
#line 3446
    return;
  } else
#line 3445
  if (r->blocked) {
#line 3446
    return;
  }
  {
#line 3456
  ngx_http_free_request(r, rc);
#line 3457
  ngx_http_close_connection(c);
  }
#line 3458
  return;
}
}
#line 3461 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_free_request(ngx_http_request_t *r , ngx_int_t rc ) 
{ 
  ngx_log_t *log ;
  ngx_pool_t *pool ;
  struct linger linger ;
  ngx_http_cleanup_t *cln ;
  ngx_http_log_ctx_t *ctx ;
  ngx_http_core_loc_conf_t *clcf ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 3471
  log = (r->connection)->log;
#line 3475
  if ((unsigned long )r->pool == (unsigned long )((void *)0)) {
#line 3476
    if (log->log_level >= 2UL) {
      {
#line 3476
      ngx_log_error_core((ngx_uint_t )2, log, 0, "http request already closed");
      }
    }
#line 3477
    return;
  }
#line 3480
  cln = r->cleanup;
#line 3481
  r->cleanup = (ngx_http_cleanup_t *)((void *)0);
  {
#line 3483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3483
    if (! cln) {
#line 3483
      goto while_break;
    }
#line 3484
    if (cln->handler) {
      {
#line 3485
      (*(cln->handler))(cln->data);
      }
    }
#line 3488
    cln = cln->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 3503
  if (rc > 0L) {
#line 3503
    if (r->headers_out.status == 0UL) {
#line 3504
      r->headers_out.status = (ngx_uint_t )rc;
    } else
#line 3503
    if ((r->connection)->sent == 0L) {
#line 3504
      r->headers_out.status = (ngx_uint_t )rc;
    }
  }
  {
#line 3507
  log->action = (char *)"logging request";
#line 3509
  ngx_http_log_request(r);
#line 3511
  log->action = (char *)"closing request";
  }
#line 3513
  if ((r->connection)->timedout) {
#line 3514
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 3516
    if (clcf->reset_timedout_connection) {
      {
#line 3517
      linger.l_onoff = 1;
#line 3518
      linger.l_linger = 0;
#line 3520
      tmp___0 = setsockopt((r->connection)->fd, 1, 13, (void const   *)(& linger),
                           (socklen_t )sizeof(struct linger ));
      }
#line 3520
      if (tmp___0 == -1) {
#line 3523
        if (log->log_level >= 2UL) {
          {
#line 3523
          tmp = __errno_location();
#line 3523
          ngx_log_error_core((ngx_uint_t )2, log, *tmp, "setsockopt(SO_LINGER) failed");
          }
        }
      }
    }
  }
  {
#line 3530
  ctx = (ngx_http_log_ctx_t *)log->data;
#line 3531
  ctx->request = (ngx_http_request_t *)((void *)0);
#line 3533
  r->request_line.len = (size_t )0;
#line 3535
  (r->connection)->destroyed = 1U;
#line 3542
  pool = r->pool;
#line 3543
  r->pool = (ngx_pool_t *)((void *)0);
#line 3545
  ngx_destroy_pool(pool);
  }
#line 3546
  return;
}
}
#line 3549 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static void ngx_http_log_request(ngx_http_request_t *r ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_handler_pt *log_handler ;
  ngx_http_core_main_conf_t *cmcf ;

  {
#line 3556
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 3558
  log_handler = (ngx_http_handler_pt *)cmcf->phases[10].handlers.elts;
#line 3559
  n = cmcf->phases[10].handlers.nelts;
#line 3561
  i = (ngx_uint_t )0;
  {
#line 3561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3561
    if (! (i < n)) {
#line 3561
      goto while_break;
    }
    {
#line 3562
    (*(*(log_handler + i)))(r);
#line 3561
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3564
  return;
}
}
#line 3567 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
void ngx_http_close_connection(ngx_connection_t *c ) 
{ 
  ngx_pool_t *pool ;

  {
  {
#line 3590
  c->destroyed = 1U;
#line 3592
  pool = c->pool;
#line 3594
  ngx_close_connection(c);
#line 3596
  ngx_destroy_pool(pool);
  }
#line 3597
  return;
}
}
#line 3600 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static u_char *ngx_http_log_error(ngx_log_t *log , u_char *buf , size_t len ) 
{ 
  u_char *p ;
  ngx_http_request_t *r ;
  ngx_http_log_ctx_t *ctx ;
  u_char *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 3607
  if (log->action) {
    {
#line 3608
    p = ngx_snprintf(buf, len, " while %s", log->action);
#line 3609
    len -= (size_t )(p - buf);
#line 3610
    buf = p;
    }
  }
  {
#line 3613
  ctx = (ngx_http_log_ctx_t *)log->data;
#line 3615
  p = ngx_snprintf(buf, len, ", client: %V", & (ctx->connection)->addr_text);
#line 3616
  len -= (size_t )(p - buf);
#line 3618
  r = ctx->request;
  }
#line 3620
  if (r) {
    {
#line 3621
    tmp = (*(r->log_handler))(r, ctx->current_request, p, len);
    }
#line 3621
    return (tmp);
  } else {
    {
#line 3624
    p = ngx_snprintf(p, len, ", server: %V", & ((ctx->connection)->listening)->addr_text);
    }
  }
#line 3628
  return (p);
}
}
#line 3632 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_request.c"
static u_char *ngx_http_log_error_handler(ngx_http_request_t *r , ngx_http_request_t *sr ,
                                          u_char *buf , size_t len ) 
{ 
  char *uri_separator ;
  u_char *p ;
  ngx_http_upstream_t *u ;
  ngx_http_core_srv_conf_t *cscf ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 3641
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 3643
  p = ngx_snprintf(buf, len, ", server: %V", & cscf->server_name);
#line 3644
  len -= (size_t )(p - buf);
#line 3645
  buf = p;
  }
#line 3647
  if ((unsigned long )r->request_line.data == (unsigned long )((void *)0)) {
#line 3647
    if (r->request_start) {
#line 3648
      p = r->request_start;
      {
#line 3648
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3648
        if (! ((unsigned long )p < (unsigned long )(r->header_in)->last)) {
#line 3648
          goto while_break;
        }
#line 3649
        if ((int )*p == 13) {
#line 3650
          goto while_break;
        } else
#line 3649
        if ((int )*p == 10) {
#line 3650
          goto while_break;
        }
#line 3648
        p ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 3654
      r->request_line.len = (size_t )(p - r->request_start);
#line 3655
      r->request_line.data = r->request_start;
    }
  }
#line 3658
  if (r->request_line.len) {
    {
#line 3659
    p = ngx_snprintf(buf, len, ", request: \"%V\"", & r->request_line);
#line 3660
    len -= (size_t )(p - buf);
#line 3661
    buf = p;
    }
  }
#line 3664
  if ((unsigned long )r != (unsigned long )sr) {
    {
#line 3665
    p = ngx_snprintf(buf, len, ", subrequest: \"%V\"", & sr->uri);
#line 3666
    len -= (size_t )(p - buf);
#line 3667
    buf = p;
    }
  }
#line 3670
  u = sr->upstream;
#line 3672
  if (u) {
#line 3672
    if (u->peer.name) {
#line 3674
      uri_separator = (char *)"";
#line 3677
      if (u->peer.sockaddr) {
#line 3677
        if ((int )(u->peer.sockaddr)->sa_family == 1) {
#line 3678
          uri_separator = (char *)":";
        }
      }
      {
#line 3682
      p = ngx_snprintf(buf, len, ", upstream: \"%V%V%s%V\"", & u->schema, u->peer.name,
                       uri_separator, & u->uri);
#line 3685
      len -= (size_t )(p - buf);
#line 3686
      buf = p;
      }
    }
  }
#line 3689
  if (r->headers_in.host) {
    {
#line 3690
    p = ngx_snprintf(buf, len, ", host: \"%V\"", & (r->headers_in.host)->value);
#line 3692
    len -= (size_t )(p - buf);
#line 3693
    buf = p;
    }
  }
#line 3696
  if (r->headers_in.referer) {
    {
#line 3697
    p = ngx_snprintf(buf, len, ", referrer: \"%V\"", & (r->headers_in.referer)->value);
#line 3699
    buf = p;
    }
  }
#line 3702
  return (buf);
}
}
#line 145 "src/http/ngx_http.h"
void ngx_http_clean_header(ngx_http_request_t *r ) ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static ngx_int_t ngx_http_send_error_page(ngx_http_request_t *r , ngx_http_err_page_t *err_page ) ;
#line 16
static ngx_int_t ngx_http_send_special_response(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                                ngx_uint_t err ) ;
#line 18
static ngx_int_t ngx_http_send_refresh(ngx_http_request_t *r ) ;
#line 21 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static u_char ngx_http_error_full_tail[54]  = 
#line 21
  {      (u_char )'<',      (u_char )'h',      (u_char )'r',      (u_char )'>', 
        (u_char )'<',      (u_char )'c',      (u_char )'e',      (u_char )'n', 
        (u_char )'t',      (u_char )'e',      (u_char )'r',      (u_char )'>', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'/',      (u_char )'1',      (u_char )'.', 
        (u_char )'1',      (u_char )'3',      (u_char )'.',      (u_char )'8', 
        (u_char )'<',      (u_char )'/',      (u_char )'c',      (u_char )'e', 
        (u_char )'n',      (u_char )'t',      (u_char )'e',      (u_char )'r', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'/',      (u_char )'b',      (u_char )'o',      (u_char )'d', 
        (u_char )'y',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'/',      (u_char )'h',      (u_char )'t', 
        (u_char )'m',      (u_char )'l',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'\000'};
#line 28 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static u_char ngx_http_error_build_tail[54]  = 
#line 28
  {      (u_char )'<',      (u_char )'h',      (u_char )'r',      (u_char )'>', 
        (u_char )'<',      (u_char )'c',      (u_char )'e',      (u_char )'n', 
        (u_char )'t',      (u_char )'e',      (u_char )'r',      (u_char )'>', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'/',      (u_char )'1',      (u_char )'.', 
        (u_char )'1',      (u_char )'3',      (u_char )'.',      (u_char )'8', 
        (u_char )'<',      (u_char )'/',      (u_char )'c',      (u_char )'e', 
        (u_char )'n',      (u_char )'t',      (u_char )'e',      (u_char )'r', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'/',      (u_char )'b',      (u_char )'o',      (u_char )'d', 
        (u_char )'y',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'/',      (u_char )'h',      (u_char )'t', 
        (u_char )'m',      (u_char )'l',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'\000'};
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static u_char ngx_http_error_tail[47]  = 
#line 35
  {      (u_char )'<',      (u_char )'h',      (u_char )'r',      (u_char )'>', 
        (u_char )'<',      (u_char )'c',      (u_char )'e',      (u_char )'n', 
        (u_char )'t',      (u_char )'e',      (u_char )'r',      (u_char )'>', 
        (u_char )'n',      (u_char )'g',      (u_char )'i',      (u_char )'n', 
        (u_char )'x',      (u_char )'<',      (u_char )'/',      (u_char )'c', 
        (u_char )'e',      (u_char )'n',      (u_char )'t',      (u_char )'e', 
        (u_char )'r',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'/',      (u_char )'b',      (u_char )'o', 
        (u_char )'d',      (u_char )'y',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'/',      (u_char )'h', 
        (u_char )'t',      (u_char )'m',      (u_char )'l',      (u_char )'>', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 42 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static u_char ngx_http_msie_padding[403]  = 
#line 42
  {      (u_char )'<',      (u_char )'!',      (u_char )'-',      (u_char )'-', 
        (u_char )' ',      (u_char )'a',      (u_char )' ',      (u_char )'p', 
        (u_char )'a',      (u_char )'d',      (u_char )'d',      (u_char )'i', 
        (u_char )'n',      (u_char )'g',      (u_char )' ',      (u_char )'t', 
        (u_char )'o',      (u_char )' ',      (u_char )'d',      (u_char )'i', 
        (u_char )'s',      (u_char )'a',      (u_char )'b',      (u_char )'l', 
        (u_char )'e',      (u_char )' ',      (u_char )'M',      (u_char )'S', 
        (u_char )'I',      (u_char )'E',      (u_char )' ',      (u_char )'a', 
        (u_char )'n',      (u_char )'d',      (u_char )' ',      (u_char )'C', 
        (u_char )'h',      (u_char )'r',      (u_char )'o',      (u_char )'m', 
        (u_char )'e',      (u_char )' ',      (u_char )'f',      (u_char )'r', 
        (u_char )'i',      (u_char )'e',      (u_char )'n',      (u_char )'d', 
        (u_char )'l',      (u_char )'y',      (u_char )' ',      (u_char )'e', 
        (u_char )'r',      (u_char )'r',      (u_char )'o',      (u_char )'r', 
        (u_char )' ',      (u_char )'p',      (u_char )'a',      (u_char )'g', 
        (u_char )'e',      (u_char )' ',      (u_char )'-',      (u_char )'-', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'!',      (u_char )'-',      (u_char )'-',      (u_char )' ', 
        (u_char )'a',      (u_char )' ',      (u_char )'p',      (u_char )'a', 
        (u_char )'d',      (u_char )'d',      (u_char )'i',      (u_char )'n', 
        (u_char )'g',      (u_char )' ',      (u_char )'t',      (u_char )'o', 
        (u_char )' ',      (u_char )'d',      (u_char )'i',      (u_char )'s', 
        (u_char )'a',      (u_char )'b',      (u_char )'l',      (u_char )'e', 
        (u_char )' ',      (u_char )'M',      (u_char )'S',      (u_char )'I', 
        (u_char )'E',      (u_char )' ',      (u_char )'a',      (u_char )'n', 
        (u_char )'d',      (u_char )' ',      (u_char )'C',      (u_char )'h', 
        (u_char )'r',      (u_char )'o',      (u_char )'m',      (u_char )'e', 
        (u_char )' ',      (u_char )'f',      (u_char )'r',      (u_char )'i', 
        (u_char )'e',      (u_char )'n',      (u_char )'d',      (u_char )'l', 
        (u_char )'y',      (u_char )' ',      (u_char )'e',      (u_char )'r', 
        (u_char )'r',      (u_char )'o',      (u_char )'r',      (u_char )' ', 
        (u_char )'p',      (u_char )'a',      (u_char )'g',      (u_char )'e', 
        (u_char )' ',      (u_char )'-',      (u_char )'-',      (u_char )'>', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'<',      (u_char )'!', 
        (u_char )'-',      (u_char )'-',      (u_char )' ',      (u_char )'a', 
        (u_char )' ',      (u_char )'p',      (u_char )'a',      (u_char )'d', 
        (u_char )'d',      (u_char )'i',      (u_char )'n',      (u_char )'g', 
        (u_char )' ',      (u_char )'t',      (u_char )'o',      (u_char )' ', 
        (u_char )'d',      (u_char )'i',      (u_char )'s',      (u_char )'a', 
        (u_char )'b',      (u_char )'l',      (u_char )'e',      (u_char )' ', 
        (u_char )'M',      (u_char )'S',      (u_char )'I',      (u_char )'E', 
        (u_char )' ',      (u_char )'a',      (u_char )'n',      (u_char )'d', 
        (u_char )' ',      (u_char )'C',      (u_char )'h',      (u_char )'r', 
        (u_char )'o',      (u_char )'m',      (u_char )'e',      (u_char )' ', 
        (u_char )'f',      (u_char )'r',      (u_char )'i',      (u_char )'e', 
        (u_char )'n',      (u_char )'d',      (u_char )'l',      (u_char )'y', 
        (u_char )' ',      (u_char )'e',      (u_char )'r',      (u_char )'r', 
        (u_char )'o',      (u_char )'r',      (u_char )' ',      (u_char )'p', 
        (u_char )'a',      (u_char )'g',      (u_char )'e',      (u_char )' ', 
        (u_char )'-',      (u_char )'-',      (u_char )'>',      (u_char )'\r', 
        (u_char )'\n',      (u_char )'<',      (u_char )'!',      (u_char )'-', 
        (u_char )'-',      (u_char )' ',      (u_char )'a',      (u_char )' ', 
        (u_char )'p',      (u_char )'a',      (u_char )'d',      (u_char )'d', 
        (u_char )'i',      (u_char )'n',      (u_char )'g',      (u_char )' ', 
        (u_char )'t',      (u_char )'o',      (u_char )' ',      (u_char )'d', 
        (u_char )'i',      (u_char )'s',      (u_char )'a',      (u_char )'b', 
        (u_char )'l',      (u_char )'e',      (u_char )' ',      (u_char )'M', 
        (u_char )'S',      (u_char )'I',      (u_char )'E',      (u_char )' ', 
        (u_char )'a',      (u_char )'n',      (u_char )'d',      (u_char )' ', 
        (u_char )'C',      (u_char )'h',      (u_char )'r',      (u_char )'o', 
        (u_char )'m',      (u_char )'e',      (u_char )' ',      (u_char )'f', 
        (u_char )'r',      (u_char )'i',      (u_char )'e',      (u_char )'n', 
        (u_char )'d',      (u_char )'l',      (u_char )'y',      (u_char )' ', 
        (u_char )'e',      (u_char )'r',      (u_char )'r',      (u_char )'o', 
        (u_char )'r',      (u_char )' ',      (u_char )'p',      (u_char )'a', 
        (u_char )'g',      (u_char )'e',      (u_char )' ',      (u_char )'-', 
        (u_char )'-',      (u_char )'>',      (u_char )'\r',      (u_char )'\n', 
        (u_char )'<',      (u_char )'!',      (u_char )'-',      (u_char )'-', 
        (u_char )' ',      (u_char )'a',      (u_char )' ',      (u_char )'p', 
        (u_char )'a',      (u_char )'d',      (u_char )'d',      (u_char )'i', 
        (u_char )'n',      (u_char )'g',      (u_char )' ',      (u_char )'t', 
        (u_char )'o',      (u_char )' ',      (u_char )'d',      (u_char )'i', 
        (u_char )'s',      (u_char )'a',      (u_char )'b',      (u_char )'l', 
        (u_char )'e',      (u_char )' ',      (u_char )'M',      (u_char )'S', 
        (u_char )'I',      (u_char )'E',      (u_char )' ',      (u_char )'a', 
        (u_char )'n',      (u_char )'d',      (u_char )' ',      (u_char )'C', 
        (u_char )'h',      (u_char )'r',      (u_char )'o',      (u_char )'m', 
        (u_char )'e',      (u_char )' ',      (u_char )'f',      (u_char )'r', 
        (u_char )'i',      (u_char )'e',      (u_char )'n',      (u_char )'d', 
        (u_char )'l',      (u_char )'y',      (u_char )' ',      (u_char )'e', 
        (u_char )'r',      (u_char )'r',      (u_char )'o',      (u_char )'r', 
        (u_char )' ',      (u_char )'p',      (u_char )'a',      (u_char )'g', 
        (u_char )'e',      (u_char )' ',      (u_char )'-',      (u_char )'-', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'<', 
        (u_char )'!',      (u_char )'-',      (u_char )'-',      (u_char )' ', 
        (u_char )'a',      (u_char )' ',      (u_char )'p',      (u_char )'a', 
        (u_char )'d',      (u_char )'d',      (u_char )'i',      (u_char )'n', 
        (u_char )'g',      (u_char )' ',      (u_char )'t',      (u_char )'o', 
        (u_char )' ',      (u_char )'d',      (u_char )'i',      (u_char )'s', 
        (u_char )'a',      (u_char )'b',      (u_char )'l',      (u_char )'e', 
        (u_char )' ',      (u_char )'M',      (u_char )'S',      (u_char )'I', 
        (u_char )'E',      (u_char )' ',      (u_char )'a',      (u_char )'n', 
        (u_char )'d',      (u_char )' ',      (u_char )'C',      (u_char )'h', 
        (u_char )'r',      (u_char )'o',      (u_char )'m',      (u_char )'e', 
        (u_char )' ',      (u_char )'f',      (u_char )'r',      (u_char )'i', 
        (u_char )'e',      (u_char )'n',      (u_char )'d',      (u_char )'l', 
        (u_char )'y',      (u_char )' ',      (u_char )'e',      (u_char )'r', 
        (u_char )'r',      (u_char )'o',      (u_char )'r',      (u_char )' ', 
        (u_char )'p',      (u_char )'a',      (u_char )'g',      (u_char )'e', 
        (u_char )' ',      (u_char )'-',      (u_char )'-',      (u_char )'>', 
        (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 52 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static u_char ngx_http_msie_refresh_head[56]  = 
#line 52
  {      (u_char )'<',      (u_char )'h',      (u_char )'t',      (u_char )'m', 
        (u_char )'l',      (u_char )'>',      (u_char )'<',      (u_char )'h', 
        (u_char )'e',      (u_char )'a',      (u_char )'d',      (u_char )'>', 
        (u_char )'<',      (u_char )'m',      (u_char )'e',      (u_char )'t', 
        (u_char )'a',      (u_char )' ',      (u_char )'h',      (u_char )'t', 
        (u_char )'t',      (u_char )'p',      (u_char )'-',      (u_char )'e', 
        (u_char )'q',      (u_char )'u',      (u_char )'i',      (u_char )'v', 
        (u_char )'=',      (u_char )'\"',      (u_char )'R',      (u_char )'e', 
        (u_char )'f',      (u_char )'r',      (u_char )'e',      (u_char )'s', 
        (u_char )'h',      (u_char )'\"',      (u_char )' ',      (u_char )'c', 
        (u_char )'o',      (u_char )'n',      (u_char )'t',      (u_char )'e', 
        (u_char )'n',      (u_char )'t',      (u_char )'=',      (u_char )'\"', 
        (u_char )'0',      (u_char )';',      (u_char )' ',      (u_char )'U', 
        (u_char )'R',      (u_char )'L',      (u_char )'=',      (u_char )'\000'};
#line 56 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static u_char ngx_http_msie_refresh_tail[32]  = 
#line 56
  {      (u_char )'\"',      (u_char )'>',      (u_char )'<',      (u_char )'/', 
        (u_char )'h',      (u_char )'e',      (u_char )'a',      (u_char )'d', 
        (u_char )'>',      (u_char )'<',      (u_char )'b',      (u_char )'o', 
        (u_char )'d',      (u_char )'y',      (u_char )'>',      (u_char )'<', 
        (u_char )'/',      (u_char )'b',      (u_char )'o',      (u_char )'d', 
        (u_char )'y',      (u_char )'>',      (u_char )'<',      (u_char )'/', 
        (u_char )'h',      (u_char )'t',      (u_char )'m',      (u_char )'l', 
        (u_char )'>',      (u_char )'\r',      (u_char )'\n',      (u_char )'\000'};
#line 60 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_301_page[133]  = 
#line 60
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'1', 
        (char )' ',      (char )'M',      (char )'o',      (char )'v', 
        (char )'e',      (char )'d',      (char )' ',      (char )'P', 
        (char )'e',      (char )'r',      (char )'m',      (char )'a', 
        (char )'n',      (char )'e',      (char )'n',      (char )'t', 
        (char )'l',      (char )'y',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'3', 
        (char )'0',      (char )'1',      (char )' ',      (char )'M', 
        (char )'o',      (char )'v',      (char )'e',      (char )'d', 
        (char )' ',      (char )'P',      (char )'e',      (char )'r', 
        (char )'m',      (char )'a',      (char )'n',      (char )'e', 
        (char )'n',      (char )'t',      (char )'l',      (char )'y', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 68 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_302_page[109]  = 
#line 68
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'2', 
        (char )' ',      (char )'F',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'3', 
        (char )'0',      (char )'2',      (char )' ',      (char )'F', 
        (char )'o',      (char )'u',      (char )'n',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 76 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_303_page[117]  = 
#line 76
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'3', 
        (char )' ',      (char )'S',      (char )'e',      (char )'e', 
        (char )' ',      (char )'O',      (char )'t',      (char )'h', 
        (char )'e',      (char )'r',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'3', 
        (char )'0',      (char )'3',      (char )' ',      (char )'S', 
        (char )'e',      (char )'e',      (char )' ',      (char )'O', 
        (char )'t',      (char )'h',      (char )'e',      (char )'r', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 84 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_307_page[135]  = 
#line 84
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'7', 
        (char )' ',      (char )'T',      (char )'e',      (char )'m', 
        (char )'p',      (char )'o',      (char )'r',      (char )'a', 
        (char )'r',      (char )'y',      (char )' ',      (char )'R', 
        (char )'e',      (char )'d',      (char )'i',      (char )'r', 
        (char )'e',      (char )'c',      (char )'t',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'3',      (char )'0',      (char )'7',      (char )' ', 
        (char )'T',      (char )'e',      (char )'m',      (char )'p', 
        (char )'o',      (char )'r',      (char )'a',      (char )'r', 
        (char )'y',      (char )' ',      (char )'R',      (char )'e', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 92 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_308_page[135]  = 
#line 92
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'3',      (char )'0',      (char )'8', 
        (char )' ',      (char )'P',      (char )'e',      (char )'r', 
        (char )'m',      (char )'a',      (char )'n',      (char )'e', 
        (char )'n',      (char )'t',      (char )' ',      (char )'R', 
        (char )'e',      (char )'d',      (char )'i',      (char )'r', 
        (char )'e',      (char )'c',      (char )'t',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'3',      (char )'0',      (char )'8',      (char )' ', 
        (char )'P',      (char )'e',      (char )'r',      (char )'m', 
        (char )'a',      (char )'n',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'R',      (char )'e', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 100 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_400_page[121]  = 
#line 100
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'B',      (char )'a',      (char )'d', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'B',      (char )'a',      (char )'d', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 108 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_401_page[143]  = 
#line 108
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'1', 
        (char )' ',      (char )'A',      (char )'u',      (char )'t', 
        (char )'h',      (char )'o',      (char )'r',      (char )'i', 
        (char )'z',      (char )'a',      (char )'t',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'i', 
        (char )'r',      (char )'e',      (char )'d',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'4',      (char )'0',      (char )'1',      (char )' ', 
        (char )'A',      (char )'u',      (char )'t',      (char )'h', 
        (char )'o',      (char )'r',      (char )'i',      (char )'z', 
        (char )'a',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'i',      (char )'r', 
        (char )'e',      (char )'d',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 116 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_402_page[131]  = 
#line 116
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'2', 
        (char )' ',      (char )'P',      (char )'a',      (char )'y', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'i',      (char )'r',      (char )'e', 
        (char )'d',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'0', 
        (char )'2',      (char )' ',      (char )'P',      (char )'a', 
        (char )'y',      (char )'m',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'i',      (char )'r', 
        (char )'e',      (char )'d',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 124 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_403_page[117]  = 
#line 124
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'3', 
        (char )' ',      (char )'F',      (char )'o',      (char )'r', 
        (char )'b',      (char )'i',      (char )'d',      (char )'d', 
        (char )'e',      (char )'n',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'0',      (char )'3',      (char )' ',      (char )'F', 
        (char )'o',      (char )'r',      (char )'b',      (char )'i', 
        (char )'d',      (char )'d',      (char )'e',      (char )'n', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 132 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_404_page[117]  = 
#line 132
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'4', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'F',      (char )'o',      (char )'u', 
        (char )'n',      (char )'d',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'0',      (char )'4',      (char )' ',      (char )'N', 
        (char )'o',      (char )'t',      (char )' ',      (char )'F', 
        (char )'o',      (char )'u',      (char )'n',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 140 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_405_page[121]  = 
#line 140
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'5', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'A',      (char )'l',      (char )'l', 
        (char )'o',      (char )'w',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'0',      (char )'5', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'A',      (char )'l',      (char )'l', 
        (char )'o',      (char )'w',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 148 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_406_page[127]  = 
#line 148
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'6', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'A',      (char )'c',      (char )'c', 
        (char )'e',      (char )'p',      (char )'t',      (char )'a', 
        (char )'b',      (char )'l',      (char )'e',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'4',      (char )'0',      (char )'6',      (char )' ', 
        (char )'N',      (char )'o',      (char )'t',      (char )' ', 
        (char )'A',      (char )'c',      (char )'c',      (char )'e', 
        (char )'p',      (char )'t',      (char )'a',      (char )'b', 
        (char )'l',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 156 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_408_page[131]  = 
#line 156
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'8', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'T',      (char )'i',      (char )'m', 
        (char )'e',      (char )'-',      (char )'o',      (char )'u', 
        (char )'t',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'0', 
        (char )'8',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'T',      (char )'i', 
        (char )'m',      (char )'e',      (char )'-',      (char )'o', 
        (char )'u',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 164 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_409_page[115]  = 
#line 164
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'9', 
        (char )' ',      (char )'C',      (char )'o',      (char )'n', 
        (char )'f',      (char )'l',      (char )'i',      (char )'c', 
        (char )'t',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'0', 
        (char )'9',      (char )' ',      (char )'C',      (char )'o', 
        (char )'n',      (char )'f',      (char )'l',      (char )'i', 
        (char )'c',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 172 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_410_page[107]  = 
#line 172
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'0', 
        (char )' ',      (char )'G',      (char )'o',      (char )'n', 
        (char )'e',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'1', 
        (char )'0',      (char )' ',      (char )'G',      (char )'o', 
        (char )'n',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 180 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_411_page[129]  = 
#line 180
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'1', 
        (char )' ',      (char )'L',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )' ', 
        (char )'R',      (char )'e',      (char )'q',      (char )'u', 
        (char )'i',      (char )'r',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'1',      (char )'1', 
        (char )' ',      (char )'L',      (char )'e',      (char )'n', 
        (char )'g',      (char )'t',      (char )'h',      (char )' ', 
        (char )'R',      (char )'e',      (char )'q',      (char )'u', 
        (char )'i',      (char )'r',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 188 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_412_page[137]  = 
#line 188
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'2', 
        (char )' ',      (char )'P',      (char )'r',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )'i',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'F',      (char )'a', 
        (char )'i',      (char )'l',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'1',      (char )'2', 
        (char )' ',      (char )'P',      (char )'r',      (char )'e', 
        (char )'c',      (char )'o',      (char )'n',      (char )'d', 
        (char )'i',      (char )'t',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'F',      (char )'a', 
        (char )'i',      (char )'l',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 196 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_413_page[147]  = 
#line 196
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'3', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'E',      (char )'n',      (char )'t', 
        (char )'i',      (char )'t',      (char )'y',      (char )' ', 
        (char )'T',      (char )'o',      (char )'o',      (char )' ', 
        (char )'L',      (char )'a',      (char )'r',      (char )'g', 
        (char )'e',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'1', 
        (char )'3',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )' ',      (char )'E',      (char )'n', 
        (char )'t',      (char )'i',      (char )'t',      (char )'y', 
        (char )' ',      (char )'T',      (char )'o',      (char )'o', 
        (char )' ',      (char )'L',      (char )'a',      (char )'r', 
        (char )'g',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 204 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_414_page[141]  = 
#line 204
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'4', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'-',      (char )'U',      (char )'R',      (char )'I', 
        (char )' ',      (char )'T',      (char )'o',      (char )'o', 
        (char )' ',      (char )'L',      (char )'a',      (char )'r', 
        (char )'g',      (char )'e',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'1',      (char )'4',      (char )' ',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )'-',      (char )'U', 
        (char )'R',      (char )'I',      (char )' ',      (char )'T', 
        (char )'o',      (char )'o',      (char )' ',      (char )'L', 
        (char )'a',      (char )'r',      (char )'g',      (char )'e', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 212 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_415_page[143]  = 
#line 212
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'5', 
        (char )' ',      (char )'U',      (char )'n',      (char )'s', 
        (char )'u',      (char )'p',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'M',      (char )'e',      (char )'d', 
        (char )'i',      (char )'a',      (char )' ',      (char )'T', 
        (char )'y',      (char )'p',      (char )'e',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'4',      (char )'1',      (char )'5',      (char )' ', 
        (char )'U',      (char )'n',      (char )'s',      (char )'u', 
        (char )'p',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'e',      (char )'d',      (char )' ', 
        (char )'M',      (char )'e',      (char )'d',      (char )'i', 
        (char )'a',      (char )' ',      (char )'T',      (char )'y', 
        (char )'p',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 220 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_416_page[161]  = 
#line 220
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'1',      (char )'6', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'e',      (char )'d',      (char )' ',      (char )'R', 
        (char )'a',      (char )'n',      (char )'g',      (char )'e', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'S',      (char )'a',      (char )'t', 
        (char )'i',      (char )'s',      (char )'f',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'1',      (char )'6', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'e',      (char )'d',      (char )' ',      (char )'R', 
        (char )'a',      (char )'n',      (char )'g',      (char )'e', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'S',      (char )'a',      (char )'t', 
        (char )'i',      (char )'s',      (char )'f',      (char )'i', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 228 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_421_page[137]  = 
#line 228
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'2',      (char )'1', 
        (char )' ',      (char )'M',      (char )'i',      (char )'s', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'4',      (char )'2',      (char )'1', 
        (char )' ',      (char )'M',      (char )'i',      (char )'s', 
        (char )'d',      (char )'i',      (char )'r',      (char )'e', 
        (char )'c',      (char )'t',      (char )'e',      (char )'d', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 236 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_429_page[133]  = 
#line 236
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'2',      (char )'9', 
        (char )' ',      (char )'T',      (char )'o',      (char )'o', 
        (char )' ',      (char )'M',      (char )'a',      (char )'n', 
        (char )'y',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )'s',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'2',      (char )'9',      (char )' ',      (char )'T', 
        (char )'o',      (char )'o',      (char )' ',      (char )'M', 
        (char )'a',      (char )'n',      (char )'y',      (char )' ', 
        (char )'R',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'s',      (char )'t',      (char )'s', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 244 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_494_page[197]  = 
#line 244
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'R',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'H',      (char )'e',      (char )'a', 
        (char )'d',      (char )'e',      (char )'r',      (char )' ', 
        (char )'O',      (char )'r',      (char )' ',      (char )'C', 
        (char )'o',      (char )'o',      (char )'k',      (char )'i', 
        (char )'e',      (char )' ',      (char )'T',      (char )'o', 
        (char )'o',      (char )' ',      (char )'L',      (char )'a', 
        (char )'r',      (char )'g',      (char )'e',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'4',      (char )'0',      (char )'0',      (char )' ', 
        (char )'B',      (char )'a',      (char )'d',      (char )' ', 
        (char )'R',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'s',      (char )'t',      (char )'<', 
        (char )'/',      (char )'h',      (char )'1',      (char )'>', 
        (char )'<',      (char )'/',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )' ',      (char )'H', 
        (char )'e',      (char )'a',      (char )'d',      (char )'e', 
        (char )'r',      (char )' ',      (char )'O',      (char )'r', 
        (char )' ',      (char )'C',      (char )'o',      (char )'o', 
        (char )'k',      (char )'i',      (char )'e',      (char )' ', 
        (char )'T',      (char )'o',      (char )'o',      (char )' ', 
        (char )'L',      (char )'a',      (char )'r',      (char )'g', 
        (char )'e',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 254 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_495_page[179]  = 
#line 254
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'S',      (char )'S',      (char )'L', 
        (char )' ',      (char )'c',      (char )'e',      (char )'r', 
        (char )'t',      (char )'i',      (char )'f',      (char )'i', 
        (char )'c',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'e',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'0',      (char )'0',      (char )' ',      (char )'B', 
        (char )'a',      (char )'d',      (char )' ',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'T',      (char )'h', 
        (char )'e',      (char )' ',      (char )'S',      (char )'S', 
        (char )'L',      (char )' ',      (char )'c',      (char )'e', 
        (char )'r',      (char )'t',      (char )'i',      (char )'f', 
        (char )'i',      (char )'c',      (char )'a',      (char )'t', 
        (char )'e',      (char )' ',      (char )'e',      (char )'r', 
        (char )'r',      (char )'o',      (char )'r',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 264 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_496_page[201]  = 
#line 264
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'N',      (char )'o',      (char )' ', 
        (char )'r',      (char )'e',      (char )'q',      (char )'u', 
        (char )'i',      (char )'r',      (char )'e',      (char )'d', 
        (char )' ',      (char )'S',      (char )'S',      (char )'L', 
        (char )' ',      (char )'c',      (char )'e',      (char )'r', 
        (char )'t',      (char )'i',      (char )'f',      (char )'i', 
        (char )'c',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'w',      (char )'a',      (char )'s', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'t',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'4',      (char )'0', 
        (char )'0',      (char )' ',      (char )'B',      (char )'a', 
        (char )'d',      (char )' ',      (char )'R',      (char )'e', 
        (char )'q',      (char )'u',      (char )'e',      (char )'s', 
        (char )'t',      (char )'<',      (char )'/',      (char )'h', 
        (char )'1',      (char )'>',      (char )'<',      (char )'/', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'N',      (char )'o',      (char )' ', 
        (char )'r',      (char )'e',      (char )'q',      (char )'u', 
        (char )'i',      (char )'r',      (char )'e',      (char )'d', 
        (char )' ',      (char )'S',      (char )'S',      (char )'L', 
        (char )' ',      (char )'c',      (char )'e',      (char )'r', 
        (char )'t',      (char )'i',      (char )'f',      (char )'i', 
        (char )'c',      (char )'a',      (char )'t',      (char )'e', 
        (char )' ',      (char )'w',      (char )'a',      (char )'s', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'t',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 274 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_497_page[219]  = 
#line 274
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'4',      (char )'0',      (char )'0', 
        (char )' ',      (char )'T',      (char )'h',      (char )'e', 
        (char )' ',      (char )'p',      (char )'l',      (char )'a', 
        (char )'i',      (char )'n',      (char )' ',      (char )'H', 
        (char )'T',      (char )'T',      (char )'P',      (char )' ', 
        (char )'r',      (char )'e',      (char )'q',      (char )'u', 
        (char )'e',      (char )'s',      (char )'t',      (char )' ', 
        (char )'w',      (char )'a',      (char )'s',      (char )' ', 
        (char )'s',      (char )'e',      (char )'n',      (char )'t', 
        (char )' ',      (char )'t',      (char )'o',      (char )' ', 
        (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )'S',      (char )' ',      (char )'p',      (char )'o', 
        (char )'r',      (char )'t',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'4', 
        (char )'0',      (char )'0',      (char )' ',      (char )'B', 
        (char )'a',      (char )'d',      (char )' ',      (char )'R', 
        (char )'e',      (char )'q',      (char )'u',      (char )'e', 
        (char )'s',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'T',      (char )'h', 
        (char )'e',      (char )' ',      (char )'p',      (char )'l', 
        (char )'a',      (char )'i',      (char )'n',      (char )' ', 
        (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )' ',      (char )'r',      (char )'e',      (char )'q', 
        (char )'u',      (char )'e',      (char )'s',      (char )'t', 
        (char )' ',      (char )'w',      (char )'a',      (char )'s', 
        (char )' ',      (char )'s',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'t',      (char )'o', 
        (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )'S',      (char )' ',      (char )'p', 
        (char )'o',      (char )'r',      (char )'t',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 284 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_500_page[141]  = 
#line 284
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'0', 
        (char )' ',      (char )'I',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'n',      (char )'a', 
        (char )'l',      (char )' ',      (char )'S',      (char )'e', 
        (char )'r',      (char )'v',      (char )'e',      (char )'r', 
        (char )' ',      (char )'E',      (char )'r',      (char )'r', 
        (char )'o',      (char )'r',      (char )'<',      (char )'/', 
        (char )'t',      (char )'i',      (char )'t',      (char )'l', 
        (char )'e',      (char )'>',      (char )'<',      (char )'/', 
        (char )'h',      (char )'e',      (char )'a',      (char )'d', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'b',      (char )'o',      (char )'d',      (char )'y', 
        (char )' ',      (char )'b',      (char )'g',      (char )'c', 
        (char )'o',      (char )'l',      (char )'o',      (char )'r', 
        (char )'=',      (char )'\"',      (char )'w',      (char )'h', 
        (char )'i',      (char )'t',      (char )'e',      (char )'\"', 
        (char )'>',      (char )'\r',      (char )'\n',      (char )'<', 
        (char )'c',      (char )'e',      (char )'n',      (char )'t', 
        (char )'e',      (char )'r',      (char )'>',      (char )'<', 
        (char )'h',      (char )'1',      (char )'>',      (char )'5', 
        (char )'0',      (char )'0',      (char )' ',      (char )'I', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'n',      (char )'a',      (char )'l',      (char )' ', 
        (char )'S',      (char )'e',      (char )'r',      (char )'v', 
        (char )'e',      (char )'r',      (char )' ',      (char )'E', 
        (char )'r',      (char )'r',      (char )'o',      (char )'r', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 292 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_501_page[129]  = 
#line 292
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'1', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'I',      (char )'m',      (char )'p', 
        (char )'l',      (char )'e',      (char )'m',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'5',      (char )'0',      (char )'1', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'I',      (char )'m',      (char )'p', 
        (char )'l',      (char )'e',      (char )'m',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'d', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 300 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_502_page[121]  = 
#line 300
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'2', 
        (char )' ',      (char )'B',      (char )'a',      (char )'d', 
        (char )' ',      (char )'G',      (char )'a',      (char )'t', 
        (char )'e',      (char )'w',      (char )'a',      (char )'y', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'5',      (char )'0',      (char )'2', 
        (char )' ',      (char )'B',      (char )'a',      (char )'d', 
        (char )' ',      (char )'G',      (char )'a',      (char )'t', 
        (char )'e',      (char )'w',      (char )'a',      (char )'y', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 308 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_503_page[161]  = 
#line 308
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'3', 
        (char )' ',      (char )'S',      (char )'e',      (char )'r', 
        (char )'v',      (char )'i',      (char )'c',      (char )'e', 
        (char )' ',      (char )'T',      (char )'e',      (char )'m', 
        (char )'p',      (char )'o',      (char )'r',      (char )'a', 
        (char )'r',      (char )'i',      (char )'l',      (char )'y', 
        (char )' ',      (char )'U',      (char )'n',      (char )'a', 
        (char )'v',      (char )'a',      (char )'i',      (char )'l', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'<',      (char )'/',      (char )'t',      (char )'i', 
        (char )'t',      (char )'l',      (char )'e',      (char )'>', 
        (char )'<',      (char )'/',      (char )'h',      (char )'e', 
        (char )'a',      (char )'d',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'b',      (char )'o', 
        (char )'d',      (char )'y',      (char )' ',      (char )'b', 
        (char )'g',      (char )'c',      (char )'o',      (char )'l', 
        (char )'o',      (char )'r',      (char )'=',      (char )'\"', 
        (char )'w',      (char )'h',      (char )'i',      (char )'t', 
        (char )'e',      (char )'\"',      (char )'>',      (char )'\r', 
        (char )'\n',      (char )'<',      (char )'c',      (char )'e', 
        (char )'n',      (char )'t',      (char )'e',      (char )'r', 
        (char )'>',      (char )'<',      (char )'h',      (char )'1', 
        (char )'>',      (char )'5',      (char )'0',      (char )'3', 
        (char )' ',      (char )'S',      (char )'e',      (char )'r', 
        (char )'v',      (char )'i',      (char )'c',      (char )'e', 
        (char )' ',      (char )'T',      (char )'e',      (char )'m', 
        (char )'p',      (char )'o',      (char )'r',      (char )'a', 
        (char )'r',      (char )'i',      (char )'l',      (char )'y', 
        (char )' ',      (char )'U',      (char )'n',      (char )'a', 
        (char )'v',      (char )'a',      (char )'i',      (char )'l', 
        (char )'a',      (char )'b',      (char )'l',      (char )'e', 
        (char )'<',      (char )'/',      (char )'h',      (char )'1', 
        (char )'>',      (char )'<',      (char )'/',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'\000'};
#line 316 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_504_page[131]  = 
#line 316
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'4', 
        (char )' ',      (char )'G',      (char )'a',      (char )'t', 
        (char )'e',      (char )'w',      (char )'a',      (char )'y', 
        (char )' ',      (char )'T',      (char )'i',      (char )'m', 
        (char )'e',      (char )'-',      (char )'o',      (char )'u', 
        (char )'t',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'5',      (char )'0', 
        (char )'4',      (char )' ',      (char )'G',      (char )'a', 
        (char )'t',      (char )'e',      (char )'w',      (char )'a', 
        (char )'y',      (char )' ',      (char )'T',      (char )'i', 
        (char )'m',      (char )'e',      (char )'-',      (char )'o', 
        (char )'u',      (char )'t',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 324 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_505_page[151]  = 
#line 324
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'5', 
        (char )' ',      (char )'H',      (char )'T',      (char )'T', 
        (char )'P',      (char )' ',      (char )'V',      (char )'e', 
        (char )'r',      (char )'s',      (char )'i',      (char )'o', 
        (char )'n',      (char )' ',      (char )'N',      (char )'o', 
        (char )'t',      (char )' ',      (char )'S',      (char )'u', 
        (char )'p',      (char )'p',      (char )'o',      (char )'r', 
        (char )'t',      (char )'e',      (char )'d',      (char )'<', 
        (char )'/',      (char )'t',      (char )'i',      (char )'t', 
        (char )'l',      (char )'e',      (char )'>',      (char )'<', 
        (char )'/',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'b',      (char )'o',      (char )'d', 
        (char )'y',      (char )' ',      (char )'b',      (char )'g', 
        (char )'c',      (char )'o',      (char )'l',      (char )'o', 
        (char )'r',      (char )'=',      (char )'\"',      (char )'w', 
        (char )'h',      (char )'i',      (char )'t',      (char )'e', 
        (char )'\"',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'<',      (char )'h',      (char )'1',      (char )'>', 
        (char )'5',      (char )'0',      (char )'5',      (char )' ', 
        (char )'H',      (char )'T',      (char )'T',      (char )'P', 
        (char )' ',      (char )'V',      (char )'e',      (char )'r', 
        (char )'s',      (char )'i',      (char )'o',      (char )'n', 
        (char )' ',      (char )'N',      (char )'o',      (char )'t', 
        (char )' ',      (char )'S',      (char )'u',      (char )'p', 
        (char )'p',      (char )'o',      (char )'r',      (char )'t', 
        (char )'e',      (char )'d',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 332 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static char ngx_http_error_507_page[139]  = 
#line 332
  {      (char )'<',      (char )'h',      (char )'t',      (char )'m', 
        (char )'l',      (char )'>',      (char )'\r',      (char )'\n', 
        (char )'<',      (char )'h',      (char )'e',      (char )'a', 
        (char )'d',      (char )'>',      (char )'<',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'5',      (char )'0',      (char )'7', 
        (char )' ',      (char )'I',      (char )'n',      (char )'s', 
        (char )'u',      (char )'f',      (char )'f',      (char )'i', 
        (char )'c',      (char )'i',      (char )'e',      (char )'n', 
        (char )'t',      (char )' ',      (char )'S',      (char )'t', 
        (char )'o',      (char )'r',      (char )'a',      (char )'g', 
        (char )'e',      (char )'<',      (char )'/',      (char )'t', 
        (char )'i',      (char )'t',      (char )'l',      (char )'e', 
        (char )'>',      (char )'<',      (char )'/',      (char )'h', 
        (char )'e',      (char )'a',      (char )'d',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'b', 
        (char )'o',      (char )'d',      (char )'y',      (char )' ', 
        (char )'b',      (char )'g',      (char )'c',      (char )'o', 
        (char )'l',      (char )'o',      (char )'r',      (char )'=', 
        (char )'\"',      (char )'w',      (char )'h',      (char )'i', 
        (char )'t',      (char )'e',      (char )'\"',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'<',      (char )'c', 
        (char )'e',      (char )'n',      (char )'t',      (char )'e', 
        (char )'r',      (char )'>',      (char )'<',      (char )'h', 
        (char )'1',      (char )'>',      (char )'5',      (char )'0', 
        (char )'7',      (char )' ',      (char )'I',      (char )'n', 
        (char )'s',      (char )'u',      (char )'f',      (char )'f', 
        (char )'i',      (char )'c',      (char )'i',      (char )'e', 
        (char )'n',      (char )'t',      (char )' ',      (char )'S', 
        (char )'t',      (char )'o',      (char )'r',      (char )'a', 
        (char )'g',      (char )'e',      (char )'<',      (char )'/', 
        (char )'h',      (char )'1',      (char )'>',      (char )'<', 
        (char )'/',      (char )'c',      (char )'e',      (char )'n', 
        (char )'t',      (char )'e',      (char )'r',      (char )'>', 
        (char )'\r',      (char )'\n',      (char )'\000'};
#line 340 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static ngx_str_t ngx_http_error_pages[53]  = 
#line 340
  {      {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_301_page) - 1UL, (u_char *)(ngx_http_error_301_page)}, 
        {sizeof(ngx_http_error_302_page) - 1UL,
      (u_char *)(ngx_http_error_302_page)}, 
        {sizeof(ngx_http_error_303_page) - 1UL, (u_char *)(ngx_http_error_303_page)}, 
        {(size_t )0,
      (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_307_page) - 1UL, (u_char *)(ngx_http_error_307_page)}, 
        {sizeof(ngx_http_error_308_page) - 1UL,
      (u_char *)(ngx_http_error_308_page)}, 
        {sizeof(ngx_http_error_400_page) - 1UL, (u_char *)(ngx_http_error_400_page)}, 
        {sizeof(ngx_http_error_401_page) - 1UL,
      (u_char *)(ngx_http_error_401_page)}, 
        {sizeof(ngx_http_error_402_page) - 1UL, (u_char *)(ngx_http_error_402_page)}, 
        {sizeof(ngx_http_error_403_page) - 1UL,
      (u_char *)(ngx_http_error_403_page)}, 
        {sizeof(ngx_http_error_404_page) - 1UL, (u_char *)(ngx_http_error_404_page)}, 
        {sizeof(ngx_http_error_405_page) - 1UL,
      (u_char *)(ngx_http_error_405_page)}, 
        {sizeof(ngx_http_error_406_page) - 1UL, (u_char *)(ngx_http_error_406_page)}, 
        {(size_t )0,
      (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_408_page) - 1UL, (u_char *)(ngx_http_error_408_page)}, 
        {sizeof(ngx_http_error_409_page) - 1UL,
      (u_char *)(ngx_http_error_409_page)}, 
        {sizeof(ngx_http_error_410_page) - 1UL, (u_char *)(ngx_http_error_410_page)}, 
        {sizeof(ngx_http_error_411_page) - 1UL,
      (u_char *)(ngx_http_error_411_page)}, 
        {sizeof(ngx_http_error_412_page) - 1UL, (u_char *)(ngx_http_error_412_page)}, 
        {sizeof(ngx_http_error_413_page) - 1UL,
      (u_char *)(ngx_http_error_413_page)}, 
        {sizeof(ngx_http_error_414_page) - 1UL, (u_char *)(ngx_http_error_414_page)}, 
        {sizeof(ngx_http_error_415_page) - 1UL,
      (u_char *)(ngx_http_error_415_page)}, 
        {sizeof(ngx_http_error_416_page) - 1UL, (u_char *)(ngx_http_error_416_page)}, 
        {(size_t )0,
      (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_421_page) - 1UL, (u_char *)(ngx_http_error_421_page)}, 
        {(size_t )0,
      (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_429_page) - 1UL, (u_char *)(ngx_http_error_429_page)}, 
        {sizeof(ngx_http_error_494_page) - 1UL,
      (u_char *)(ngx_http_error_494_page)}, 
        {sizeof(ngx_http_error_495_page) - 1UL, (u_char *)(ngx_http_error_495_page)}, 
        {sizeof(ngx_http_error_496_page) - 1UL,
      (u_char *)(ngx_http_error_496_page)}, 
        {sizeof(ngx_http_error_497_page) - 1UL, (u_char *)(ngx_http_error_497_page)}, 
        {sizeof(ngx_http_error_404_page) - 1UL,
      (u_char *)(ngx_http_error_404_page)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_500_page) - 1UL, (u_char *)(ngx_http_error_500_page)}, 
        {sizeof(ngx_http_error_501_page) - 1UL,
      (u_char *)(ngx_http_error_501_page)}, 
        {sizeof(ngx_http_error_502_page) - 1UL, (u_char *)(ngx_http_error_502_page)}, 
        {sizeof(ngx_http_error_503_page) - 1UL,
      (u_char *)(ngx_http_error_503_page)}, 
        {sizeof(ngx_http_error_504_page) - 1UL, (u_char *)(ngx_http_error_504_page)}, 
        {sizeof(ngx_http_error_505_page) - 1UL,
      (u_char *)(ngx_http_error_505_page)}, 
        {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof(ngx_http_error_507_page) - 1UL, (u_char *)(ngx_http_error_507_page)}};
#line 415 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
ngx_int_t ngx_http_special_response_handler(ngx_http_request_t *r , ngx_int_t error ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t err ;
  ngx_http_err_page_t *err_page ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 426
  r->err_status = (ngx_uint_t )error;
#line 428
  if (r->keepalive) {
    {
#line 437
    if (error == 501L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 500L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 496L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 495L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 497L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 414L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 413L) {
#line 437
      goto case_501;
    }
#line 437
    if (error == 400L) {
#line 437
      goto case_501;
    }
#line 429
    goto switch_break;
    case_501: /* CIL Label */ 
    case_500: /* CIL Label */ 
    case_496: /* CIL Label */ 
    case_495: /* CIL Label */ 
    case_497: /* CIL Label */ 
    case_414: /* CIL Label */ 
    case_413: /* CIL Label */ 
    case_400: /* CIL Label */ 
#line 438
    r->keepalive = 0U;
    switch_break: /* CIL Label */ ;
    }
  }
#line 442
  if (r->lingering_close) {
    {
#line 447
    if (error == 496L) {
#line 447
      goto case_496___0;
    }
#line 447
    if (error == 495L) {
#line 447
      goto case_496___0;
    }
#line 447
    if (error == 497L) {
#line 447
      goto case_496___0;
    }
#line 447
    if (error == 400L) {
#line 447
      goto case_496___0;
    }
#line 443
    goto switch_break___0;
    case_496___0: /* CIL Label */ 
    case_495___0: /* CIL Label */ 
    case_497___0: /* CIL Label */ 
    case_400___0: /* CIL Label */ 
#line 448
    r->lingering_close = 0U;
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 452
  r->headers_out.content_type.len = (size_t )0;
#line 454
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 456
  if (! r->error_page) {
#line 456
    if (clcf->error_pages) {
#line 456
      if (r->uri_changes != 0U) {
#line 458
        if (clcf->recursive_error_pages == 0L) {
#line 459
          r->error_page = 1U;
        }
#line 462
        err_page = (ngx_http_err_page_t *)(clcf->error_pages)->elts;
#line 464
        i = (ngx_uint_t )0;
        {
#line 464
        while (1) {
          while_continue: /* CIL Label */ ;
#line 464
          if (! (i < (clcf->error_pages)->nelts)) {
#line 464
            goto while_break;
          }
#line 465
          if ((err_page + i)->status == error) {
            {
#line 466
            tmp = ngx_http_send_error_page(r, err_page + i);
            }
#line 466
            return (tmp);
          }
#line 464
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
    }
  }
  {
#line 471
  r->expect_tested = 1U;
#line 473
  tmp___0 = ngx_http_discard_request_body(r);
  }
#line 473
  if (tmp___0 != 0L) {
#line 474
    r->keepalive = 0U;
  }
#line 477
  if (clcf->msie_refresh) {
#line 477
    if (r->headers_in.msie) {
#line 477
      if (error == 301L) {
        {
#line 482
        tmp___1 = ngx_http_send_refresh(r);
        }
#line 482
        return (tmp___1);
      } else
#line 477
      if (error == 302L) {
        {
#line 482
        tmp___1 = ngx_http_send_refresh(r);
        }
#line 482
        return (tmp___1);
      }
    }
  }
#line 485
  if (error == 201L) {
#line 487
    err = (ngx_uint_t )0;
  } else
#line 489
  if (error == 204L) {
#line 491
    err = (ngx_uint_t )0;
  } else
#line 493
  if (error >= 301L) {
#line 493
    if (error < 309L) {
#line 497
      err = (ngx_uint_t )((error - 301L) + 1L);
    } else {
#line 493
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 499
  if (error >= 400L) {
#line 499
    if (error < 430L) {
#line 503
      err = (ngx_uint_t )((error - 400L) + 9L);
    } else {
#line 499
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 505
  if (error >= 494L) {
#line 505
    if (error < 508L) {
#line 509
      err = (ngx_uint_t )((error - 494L) + 39L);
      {
#line 514
      if (error == 494L) {
#line 514
        goto case_494;
      }
#line 514
      if (error == 496L) {
#line 514
        goto case_494;
      }
#line 514
      if (error == 495L) {
#line 514
        goto case_494;
      }
#line 514
      if (error == 497L) {
#line 514
        goto case_494;
      }
#line 510
      goto switch_break___1;
      case_494: /* CIL Label */ 
      case_496___1: /* CIL Label */ 
      case_495___1: /* CIL Label */ 
      case_497___1: /* CIL Label */ 
#line 515
      r->err_status = (ngx_uint_t )400;
      switch_break___1: /* CIL Label */ ;
      }
    } else {
#line 520
      err = (ngx_uint_t )0;
    }
  } else {
#line 520
    err = (ngx_uint_t )0;
  }
  {
#line 523
  tmp___2 = ngx_http_send_special_response(r, clcf, err);
  }
#line 523
  return (tmp___2);
}
}
#line 527 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
ngx_int_t ngx_http_filter_finalize_request(ngx_http_request_t *r , ngx_module_t *m ,
                                           ngx_int_t error ) 
{ 
  void *ctx ;
  ngx_int_t rc ;

  {
  {
#line 534
  ngx_http_clean_header(r);
#line 536
  ctx = (void *)0;
  }
#line 538
  if (m) {
#line 539
    ctx = *(r->ctx + m->ctx_index);
  }
  {
#line 543
  memset((void *)r->ctx, 0, sizeof(void *) * ngx_http_max_module);
  }
#line 545
  if (m) {
#line 546
    *(r->ctx + m->ctx_index) = ctx;
  }
  {
#line 549
  r->filter_finalize = 1U;
#line 551
  rc = ngx_http_special_response_handler(r, error);
  }
  {
#line 558
  if (rc == -4L) {
#line 558
    goto case_neg_4;
  }
#line 558
  if (rc == 0L) {
#line 558
    goto case_neg_4;
  }
#line 561
  goto switch_default;
  case_neg_4: /* CIL Label */ 
  case_0: /* CIL Label */ 
#line 559
  return ((ngx_int_t )-1);
  switch_default: /* CIL Label */ 
#line 562
  return (rc);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 567 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
void ngx_http_clean_header(ngx_http_request_t *r ) 
{ 


  {
  {
#line 570
  memset((void *)(& r->headers_out.status), 0, sizeof(ngx_http_headers_out_t ) - (unsigned long )(& ((ngx_http_headers_out_t *)0)->status));
#line 574
  r->headers_out.headers.part.nelts = (ngx_uint_t )0;
#line 575
  r->headers_out.headers.part.next = (ngx_list_part_t *)((void *)0);
#line 576
  r->headers_out.headers.last = & r->headers_out.headers.part;
#line 578
  r->headers_out.content_length_n = (off_t )-1;
#line 579
  r->headers_out.last_modified_time = (time_t )-1;
  }
#line 580
  return;
}
}
#line 583 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static ngx_int_t ngx_http_send_error_page(ngx_http_request_t *r , ngx_http_err_page_t *err_page ) 
{ 
  ngx_int_t overwrite ;
  ngx_str_t uri___0 ;
  ngx_str_t args___0 ;
  ngx_table_elt_t *location ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 591
  overwrite = err_page->overwrite;
#line 593
  if (overwrite) {
#line 593
    if (overwrite != 200L) {
#line 594
      r->expect_tested = 1U;
    }
  }
#line 597
  if (overwrite >= 0L) {
#line 598
    r->err_status = (ngx_uint_t )overwrite;
  }
  {
#line 601
  tmp = ngx_http_complex_value(r, & err_page->value, & uri___0);
  }
#line 601
  if (tmp != 0L) {
#line 602
    return ((ngx_int_t )-1);
  }
#line 605
  if (uri___0.len) {
#line 605
    if ((int )*(uri___0.data + 0) == 47) {
#line 607
      if (err_page->value.lengths) {
        {
#line 608
        ngx_http_split_args(r, & uri___0, & args___0);
        }
      } else {
#line 611
        args___0 = err_page->args;
      }
#line 614
      if (r->method != 4UL) {
#line 615
        r->method = (ngx_uint_t )2;
#line 616
        r->method_name = ngx_http_core_get_method;
      }
      {
#line 619
      tmp___0 = ngx_http_internal_redirect(r, & uri___0, & args___0);
      }
#line 619
      return (tmp___0);
    }
  }
#line 622
  if (uri___0.len) {
#line 622
    if ((int )*(uri___0.data + 0) == 64) {
      {
#line 623
      tmp___1 = ngx_http_named_location(r, & uri___0);
      }
#line 623
      return (tmp___1);
    }
  }
  {
#line 626
  tmp___2 = ngx_list_push(& r->headers_out.headers);
#line 626
  location = (ngx_table_elt_t *)tmp___2;
  }
#line 628
  if ((unsigned long )location == (unsigned long )((void *)0)) {
#line 629
    return ((ngx_int_t )-1);
  }
#line 632
  if (overwrite != 301L) {
#line 632
    if (overwrite != 302L) {
#line 632
      if (overwrite != 303L) {
#line 632
        if (overwrite != 307L) {
#line 632
          if (overwrite != 308L) {
#line 638
            r->err_status = (ngx_uint_t )302;
          }
        }
      }
    }
  }
#line 641
  location->hash = (ngx_uint_t )1;
#line 642
  location->key.len = sizeof("Location") - 1UL;
#line 642
  location->key.data = (u_char *)"Location";
#line 643
  location->value = uri___0;
#line 645
  if (r->headers_out.location) {
#line 645
    (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 645
    r->headers_out.location = (ngx_table_elt_t *)((void *)0);
  }
#line 647
  r->headers_out.location = location;
#line 649
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 651
  if (clcf->msie_refresh) {
#line 651
    if (r->headers_in.msie) {
      {
#line 652
      tmp___3 = ngx_http_send_refresh(r);
      }
#line 652
      return (tmp___3);
    }
  }
  {
#line 655
  tmp___4 = ngx_http_send_special_response(r, clcf, (r->err_status - 301UL) + 1UL);
  }
#line 655
  return (tmp___4);
}
}
#line 661 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static ngx_int_t ngx_http_send_special_response(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                                ngx_uint_t err ) 
{ 
  u_char *tail___1 ;
  size_t len ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_uint_t msie_padding ;
  ngx_chain_t out[3] ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  void *__cil_tmp15 ;
  int __cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 672
  if (clcf->server_tokens == 1UL) {
#line 673
    len = sizeof(ngx_http_error_full_tail) - 1UL;
#line 674
    tail___1 = ngx_http_error_full_tail;
  } else
#line 676
  if (clcf->server_tokens == 2UL) {
#line 677
    len = sizeof(ngx_http_error_build_tail) - 1UL;
#line 678
    tail___1 = ngx_http_error_build_tail;
  } else {
#line 681
    len = sizeof(ngx_http_error_tail) - 1UL;
#line 682
    tail___1 = ngx_http_error_tail;
  }
#line 685
  msie_padding = (ngx_uint_t )0;
#line 687
  if (ngx_http_error_pages[err].len) {
#line 688
    r->headers_out.content_length_n = (off_t )(ngx_http_error_pages[err].len + len);
#line 689
    if (clcf->msie_padding) {
#line 689
      if (r->headers_in.msie) {
#line 689
        goto _L;
      } else
#line 689
      if (r->headers_in.chrome) {
        _L: /* CIL Label */ 
#line 689
        if (r->http_version >= 1000UL) {
#line 689
          if (err >= 9UL) {
#line 694
            r->headers_out.content_length_n = (off_t )((unsigned long )r->headers_out.content_length_n + (sizeof(ngx_http_msie_padding) - 1UL));
#line 696
            msie_padding = (ngx_uint_t )1;
          }
        }
      }
    }
#line 699
    r->headers_out.content_type_len = sizeof("text/html") - 1UL;
#line 700
    r->headers_out.content_type.len = sizeof("text/html") - 1UL;
#line 700
    r->headers_out.content_type.data = (u_char *)"text/html";
#line 701
    r->headers_out.content_type_lowcase = (u_char *)((void *)0);
  } else {
#line 704
    r->headers_out.content_length_n = (off_t )0;
  }
#line 707
  if (r->headers_out.content_length) {
#line 708
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 709
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 712
  r->allow_ranges = 0U;
#line 712
  if (r->headers_out.accept_ranges) {
#line 712
    (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 712
    r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
  }
#line 713
  r->headers_out.last_modified_time = (time_t )-1;
#line 713
  if (r->headers_out.last_modified) {
#line 713
    (r->headers_out.last_modified)->hash = (ngx_uint_t )0;
#line 713
    r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
  }
#line 714
  if (r->headers_out.etag) {
#line 714
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 714
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 716
  rc = ngx_http_send_header(r);
  }
#line 718
  if (rc == -1L) {
#line 719
    return (rc);
  } else
#line 718
  if (r->header_only) {
#line 719
    return (rc);
  }
#line 722
  if (ngx_http_error_pages[err].len == 0UL) {
    {
#line 723
    tmp = ngx_http_send_special(r, (ngx_uint_t )1);
    }
#line 723
    return (tmp);
  }
  {
#line 726
  tmp___0 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 726
  b = (ngx_buf_t *)tmp___0;
  }
#line 727
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 728
    return ((ngx_int_t )-1);
  }
  {
#line 731
  b->memory = 1U;
#line 732
  b->pos = ngx_http_error_pages[err].data;
#line 733
  b->last = ngx_http_error_pages[err].data + ngx_http_error_pages[err].len;
#line 735
  out[0].buf = b;
#line 736
  out[0].next = & out[1];
#line 738
  tmp___1 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 738
  b = (ngx_buf_t *)tmp___1;
  }
#line 739
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 740
    return ((ngx_int_t )-1);
  }
#line 743
  b->memory = 1U;
#line 745
  b->pos = tail___1;
#line 746
  b->last = tail___1 + len;
#line 748
  out[1].buf = b;
#line 749
  out[1].next = (ngx_chain_t *)((void *)0);
#line 751
  if (msie_padding) {
    {
#line 752
    tmp___2 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 752
    b = (ngx_buf_t *)tmp___2;
    }
#line 753
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 754
      return ((ngx_int_t )-1);
    }
#line 757
    b->memory = 1U;
#line 758
    b->pos = ngx_http_msie_padding;
#line 759
    b->last = (ngx_http_msie_padding + sizeof(ngx_http_msie_padding)) - 1;
#line 761
    out[1].next = & out[2];
#line 762
    out[2].buf = b;
#line 763
    out[2].next = (ngx_chain_t *)((void *)0);
  }
#line 766
  if ((unsigned long )r == (unsigned long )r->main) {
#line 767
    b->last_buf = 1U;
  }
  {
#line 770
  b->last_in_chain = 1U;
#line 772
  tmp___3 = ngx_http_output_filter(r, & out[0]);
  }
#line 772
  return (tmp___3);
}
}
#line 776 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_special_response.c"
static ngx_int_t ngx_http_send_refresh(ngx_http_request_t *r ) 
{ 
  u_char *p ;
  u_char *location ;
  size_t len ;
  size_t size ;
  uintptr_t escape___0 ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  uintptr_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  uintptr_t tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 786
  len = (r->headers_out.location)->value.len;
#line 787
  location = (r->headers_out.location)->value.data;
#line 789
  tmp = ngx_escape_uri((u_char *)((void *)0), location, len, (ngx_uint_t )4);
#line 789
  escape___0 = 2UL * tmp;
#line 791
  size = ((((sizeof(ngx_http_msie_refresh_head) - 1UL) + escape___0) + len) + sizeof(ngx_http_msie_refresh_tail)) - 1UL;
#line 795
  r->err_status = (ngx_uint_t )200;
#line 797
  r->headers_out.content_type_len = sizeof("text/html") - 1UL;
#line 798
  r->headers_out.content_type.len = sizeof("text/html") - 1UL;
#line 798
  r->headers_out.content_type.data = (u_char *)"text/html";
#line 799
  r->headers_out.content_type_lowcase = (u_char *)((void *)0);
#line 801
  (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 802
  r->headers_out.location = (ngx_table_elt_t *)((void *)0);
#line 804
  r->headers_out.content_length_n = (off_t )size;
  }
#line 806
  if (r->headers_out.content_length) {
#line 807
    (r->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 808
    r->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 811
  r->allow_ranges = 0U;
#line 811
  if (r->headers_out.accept_ranges) {
#line 811
    (r->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 811
    r->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
  }
#line 812
  r->headers_out.last_modified_time = (time_t )-1;
#line 812
  if (r->headers_out.last_modified) {
#line 812
    (r->headers_out.last_modified)->hash = (ngx_uint_t )0;
#line 812
    r->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
  }
#line 813
  if (r->headers_out.etag) {
#line 813
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 813
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
  }
  {
#line 815
  rc = ngx_http_send_header(r);
  }
#line 817
  if (rc == -1L) {
#line 818
    return (rc);
  } else
#line 817
  if (r->header_only) {
#line 818
    return (rc);
  }
  {
#line 821
  b = ngx_create_temp_buf(r->pool, size);
  }
#line 822
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 823
    return ((ngx_int_t )-1);
  }
  {
#line 826
  tmp___0 = memcpy((void */* __restrict  */)b->pos, (void const   */* __restrict  */)(ngx_http_msie_refresh_head),
                   sizeof(ngx_http_msie_refresh_head) - 1UL);
#line 826
  p = (u_char *)tmp___0 + (sizeof(ngx_http_msie_refresh_head) - 1UL);
  }
#line 829
  if (escape___0 == 0UL) {
    {
#line 830
    tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)location,
                     len);
#line 830
    p = (u_char *)tmp___1 + len;
    }
  } else {
    {
#line 833
    tmp___2 = ngx_escape_uri(p, location, len, (ngx_uint_t )4);
#line 833
    p = (u_char *)tmp___2;
    }
  }
  {
#line 836
  tmp___3 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ngx_http_msie_refresh_tail),
                   sizeof(ngx_http_msie_refresh_tail) - 1UL);
#line 836
  b->last = (u_char *)tmp___3 + (sizeof(ngx_http_msie_refresh_tail) - 1UL);
  }
#line 839
  if ((unsigned long )r == (unsigned long )r->main) {
#line 839
    b->last_buf = 1U;
  } else {
#line 839
    b->last_buf = 0U;
  }
  {
#line 840
  b->last_in_chain = 1U;
#line 842
  out.buf = b;
#line 843
  out.next = (ngx_chain_t *)((void *)0);
#line 845
  tmp___4 = ngx_http_output_filter(r, & out);
  }
#line 845
  return (tmp___4);
}
}
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 172 "src/core/ngx_string.h"
ngx_int_t ngx_filename_cmp(u_char *s1 , u_char *s2 , size_t n ) ;
#line 238 "src/core/ngx_log.h"
char *ngx_log_set_log(ngx_conf_t *cf , ngx_log_t **head___0 ) ;
#line 117 "src/core/ngx_inet.h"
ngx_int_t ngx_cidr_match(struct sockaddr *sa , ngx_array_t *cidrs ) ;
#line 229 "src/core/ngx_resolver.h"
ngx_resolver_t *ngx_resolver_create(ngx_conf_t *cf , ngx_str_t *names , ngx_uint_t n ) ;
#line 289 "src/core/ngx_conf_file.h"
char *ngx_conf_set_sec_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 425 "src/event/ngx_event.h"
ngx_os_io_t ngx_io ;
#line 465 "src/http/ngx_http_core_module.h"
ngx_int_t ngx_http_core_generic_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 467
ngx_int_t ngx_http_core_rewrite_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 469
ngx_int_t ngx_http_core_find_config_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 471
ngx_int_t ngx_http_core_post_rewrite_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 473
ngx_int_t ngx_http_core_access_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 475
ngx_int_t ngx_http_core_post_access_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 477
ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
#line 81 "src/http/ngx_http.h"
ngx_int_t ngx_http_add_listen(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf , ngx_http_listen_opt_t *lsopt ) ;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_find_location(ngx_http_request_t *r ) ;
#line 25
static ngx_int_t ngx_http_core_find_static_location(ngx_http_request_t *r , ngx_http_location_tree_node_t *node ) ;
#line 28
static ngx_int_t ngx_http_core_preconfiguration(ngx_conf_t *cf ) ;
#line 29
static ngx_int_t ngx_http_core_postconfiguration(ngx_conf_t *cf ) ;
#line 30
static void *ngx_http_core_create_main_conf(ngx_conf_t *cf ) ;
#line 31
static char *ngx_http_core_init_main_conf(ngx_conf_t *cf , void *conf ) ;
#line 32
static void *ngx_http_core_create_srv_conf(ngx_conf_t *cf ) ;
#line 33
static char *ngx_http_core_merge_srv_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 35
static void *ngx_http_core_create_loc_conf(ngx_conf_t *cf ) ;
#line 36
static char *ngx_http_core_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) ;
#line 39
static char *ngx_http_core_server(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) ;
#line 41
static char *ngx_http_core_location(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) ;
#line 43
static ngx_int_t ngx_http_core_regex_location(ngx_conf_t *cf , ngx_http_core_loc_conf_t *clcf ,
                                              ngx_str_t *regex , ngx_uint_t caseless ) ;
#line 46
static char *ngx_http_core_types(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 48
static char *ngx_http_core_type(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) ;
#line 51
static char *ngx_http_core_listen(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 53
static char *ngx_http_core_server_name(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 55
static char *ngx_http_core_root(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 56
static char *ngx_http_core_limit_except(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 58
static char *ngx_http_core_set_aio(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 60
static char *ngx_http_core_directio(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 62
static char *ngx_http_core_error_page(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 64
static char *ngx_http_core_open_file_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 66
static char *ngx_http_core_error_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 68
static char *ngx_http_core_keepalive(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 70
static char *ngx_http_core_internal(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 72
static char *ngx_http_core_resolver(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 75
static ngx_int_t ngx_http_gzip_accept_encoding(ngx_str_t *ae ) ;
#line 76
static ngx_uint_t ngx_http_gzip_quantity(u_char *p , u_char *last ) ;
#line 77
static char *ngx_http_gzip_disable(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 80
static ngx_int_t ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r , ngx_addr_t *addr ,
                                                      u_char *xff , size_t xfflen ,
                                                      ngx_array_t *proxies , int recursive ) ;
#line 84
static char *ngx_http_disable_symlinks(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 88
static char *ngx_http_core_lowat_check(ngx_conf_t *cf , void *post , void *data ) ;
#line 89
static char *ngx_http_core_pool_size(ngx_conf_t *cf , void *post , void *data ) ;
#line 91 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_post_t ngx_http_core_lowat_post  =    {& ngx_http_core_lowat_check};
#line 94 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *(*ngx_http_core_pool_size_p)(ngx_conf_t *cf , void *data , void *conf )  =    & ngx_http_core_pool_size;
#line 98 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_request_body_in_file[4]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("on") - 1UL, (u_char *)"on"}, (ngx_uint_t )1}, 
        {{sizeof("clean") - 1UL, (u_char *)"clean"}, (ngx_uint_t )2}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 106 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_satisfy[3]  = {      {{sizeof("all") - 1UL, (u_char *)"all"}, (ngx_uint_t )0}, 
        {{sizeof("any") - 1UL, (u_char *)"any"}, (ngx_uint_t )1}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 113 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_lingering_close[4]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("on") - 1UL, (u_char *)"on"}, (ngx_uint_t )1}, 
        {{sizeof("always") - 1UL, (u_char *)"always"}, (ngx_uint_t )2}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 121 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_server_tokens[4]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("on") - 1UL, (u_char *)"on"}, (ngx_uint_t )1}, 
        {{sizeof("build") - 1UL, (u_char *)"build"}, (ngx_uint_t )2}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 129 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_core_if_modified_since[4]  = {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )0}, 
        {{sizeof("exact") - 1UL, (u_char *)"exact"}, (ngx_uint_t )1}, 
        {{sizeof("before") - 1UL, (u_char *)"before"}, (ngx_uint_t )2}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 137 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_bitmask_t ngx_http_core_keepalive_disable[4]  = {      {{sizeof("none") - 1UL, (u_char *)"none"}, (ngx_uint_t )2}, 
        {{sizeof("msie6") - 1UL, (u_char *)"msie6"}, (ngx_uint_t )4}, 
        {{sizeof("safari") - 1UL, (u_char *)"safari"}, (ngx_uint_t )8}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 145 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_path_init_t ngx_http_client_temp_path  =    {{sizeof("client_body_temp") - 1UL, (u_char *)"client_body_temp"}, {(size_t )0,
                                                                       (size_t )0,
                                                                       (size_t )0}};
#line 152 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_enum_t ngx_http_gzip_http_version[3]  = {      {{sizeof("1.0") - 1UL, (u_char *)"1.0"}, (ngx_uint_t )1000}, 
        {{sizeof("1.1") - 1UL, (u_char *)"1.1"}, (ngx_uint_t )1001}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 159 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_conf_bitmask_t ngx_http_gzip_proxied_mask[10]  = 
#line 159
  {      {{sizeof("off") - 1UL, (u_char *)"off"}, (ngx_uint_t )2}, 
        {{sizeof("expired") - 1UL, (u_char *)"expired"}, (ngx_uint_t )4}, 
        {{sizeof("no-cache") - 1UL, (u_char *)"no-cache"}, (ngx_uint_t )8}, 
        {{sizeof("no-store") - 1UL, (u_char *)"no-store"}, (ngx_uint_t )16}, 
        {{sizeof("private") - 1UL, (u_char *)"private"}, (ngx_uint_t )32}, 
        {{sizeof("no_last_modified") - 1UL, (u_char *)"no_last_modified"}, (ngx_uint_t )64}, 
        {{sizeof("no_etag") - 1UL,
       (u_char *)"no_etag"}, (ngx_uint_t )128}, 
        {{sizeof("auth") - 1UL, (u_char *)"auth"}, (ngx_uint_t )256}, 
        {{sizeof("any") - 1UL, (u_char *)"any"}, (ngx_uint_t )512}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 173 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_gzip_no_cache  =    {sizeof("no-cache") - 1UL, (u_char *)"no-cache"};
#line 174 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_gzip_no_store  =    {sizeof("no-store") - 1UL, (u_char *)"no-store"};
#line 175 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_gzip_private  =    {sizeof("private") - 1UL, (u_char *)"private"};
#line 180 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_command_t ngx_http_core_commands[81]  = 
#line 180
  {      {{sizeof("variables_hash_max_size") - 1UL, (u_char *)"variables_hash_max_size"},
      (ngx_uint_t )33554434, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_core_main_conf_t *)0)->variables_hash_max_size),
      (void *)0}, 
        {{sizeof("variables_hash_bucket_size") - 1UL, (u_char *)"variables_hash_bucket_size"},
      (ngx_uint_t )33554434, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_core_main_conf_t *)0)->variables_hash_bucket_size),
      (void *)0}, 
        {{sizeof("server_names_hash_max_size") - 1UL, (u_char *)"server_names_hash_max_size"},
      (ngx_uint_t )33554434, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_core_main_conf_t *)0)->server_names_hash_max_size),
      (void *)0}, 
        {{sizeof("server_names_hash_bucket_size") - 1UL, (u_char *)"server_names_hash_bucket_size"},
      (ngx_uint_t )33554434, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->main_conf),
      (unsigned long )(& ((ngx_http_core_main_conf_t *)0)->server_names_hash_bucket_size),
      (void *)0}, 
        {{sizeof("server") - 1UL, (u_char *)"server"}, (ngx_uint_t )33554689, & ngx_http_core_server,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("connection_pool_size") - 1UL, (u_char *)"connection_pool_size"}, (ngx_uint_t )100663298,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->connection_pool_size), (void *)(& ngx_http_core_pool_size_p)}, 
        {{sizeof("request_pool_size") - 1UL,
       (u_char *)"request_pool_size"}, (ngx_uint_t )100663298, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->request_pool_size),
      (void *)(& ngx_http_core_pool_size_p)}, 
        {{sizeof("client_header_timeout") - 1UL, (u_char *)"client_header_timeout"},
      (ngx_uint_t )100663298, & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->client_header_timeout),
      (void *)0}, 
        {{sizeof("client_header_buffer_size") - 1UL, (u_char *)"client_header_buffer_size"},
      (ngx_uint_t )100663298, & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->client_header_buffer_size),
      (void *)0}, 
        {{sizeof("large_client_header_buffers") - 1UL, (u_char *)"large_client_header_buffers"},
      (ngx_uint_t )100663300, & ngx_conf_set_bufs_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->large_client_header_buffers),
      (void *)0}, 
        {{sizeof("ignore_invalid_headers") - 1UL, (u_char *)"ignore_invalid_headers"},
      (ngx_uint_t )100663808, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->ignore_invalid_headers),
      (void *)0}, 
        {{sizeof("merge_slashes") - 1UL, (u_char *)"merge_slashes"}, (ngx_uint_t )100663808,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->merge_slashes), (void *)0}, 
        {{sizeof("underscores_in_headers") - 1UL,
       (u_char *)"underscores_in_headers"}, (ngx_uint_t )100663808, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (unsigned long )(& ((ngx_http_core_srv_conf_t *)0)->underscores_in_headers),
      (void *)0}, 
        {{sizeof("location") - 1UL, (u_char *)"location"}, (ngx_uint_t )201326854, & ngx_http_core_location,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("listen") - 1UL,
       (u_char *)"listen"}, (ngx_uint_t )67110912, & ngx_http_core_listen, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("server_name") - 1UL, (u_char *)"server_name"}, (ngx_uint_t )67110912,
      & ngx_http_core_server_name, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->srv_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("types_hash_max_size") - 1UL, (u_char *)"types_hash_max_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->types_hash_max_size), (void *)0}, 
        {{sizeof("types_hash_bucket_size") - 1UL,
       (u_char *)"types_hash_bucket_size"}, (ngx_uint_t )234881026, & ngx_conf_set_num_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->types_hash_bucket_size),
      (void *)0}, 
        {{sizeof("types") - 1UL, (u_char *)"types"}, (ngx_uint_t )234881281, & ngx_http_core_types,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("default_type") - 1UL,
       (u_char *)"default_type"}, (ngx_uint_t )234881026, & ngx_conf_set_str_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->default_type),
      (void *)0}, 
        {{sizeof("root") - 1UL, (u_char *)"root"}, (ngx_uint_t )1308622850, & ngx_http_core_root,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("alias") - 1UL,
       (u_char *)"alias"}, (ngx_uint_t )134217730, & ngx_http_core_root, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("limit_except") - 1UL, (u_char *)"limit_except"}, (ngx_uint_t )134220032,
      & ngx_http_core_limit_except, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("client_max_body_size") - 1UL, (u_char *)"client_max_body_size"}, (ngx_uint_t )234881026,
      & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_max_body_size), (void *)0}, 
        {{sizeof("client_body_buffer_size") - 1UL,
       (u_char *)"client_body_buffer_size"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_buffer_size),
      (void *)0}, 
        {{sizeof("client_body_timeout") - 1UL, (u_char *)"client_body_timeout"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_timeout), (void *)0}, 
        {{sizeof("client_body_temp_path") - 1UL,
       (u_char *)"client_body_temp_path"}, (ngx_uint_t )234881054, & ngx_conf_set_path_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_temp_path),
      (void *)0}, 
        {{sizeof("client_body_in_file_only") - 1UL, (u_char *)"client_body_in_file_only"},
      (ngx_uint_t )234881026, & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_in_file_only),
      (void *)(& ngx_http_core_request_body_in_file)}, 
        {{sizeof("client_body_in_single_buffer") - 1UL, (u_char *)"client_body_in_single_buffer"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->client_body_in_single_buffer),
      (void *)0}, 
        {{sizeof("sendfile") - 1UL, (u_char *)"sendfile"}, (ngx_uint_t )1308623360, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->sendfile),
      (void *)0}, 
        {{sizeof("sendfile_max_chunk") - 1UL, (u_char *)"sendfile_max_chunk"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->sendfile_max_chunk), (void *)0}, 
        {{sizeof("aio") - 1UL,
       (u_char *)"aio"}, (ngx_uint_t )234881026, & ngx_http_core_set_aio, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("aio_write") - 1UL, (u_char *)"aio_write"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->aio_write), (void *)0}, 
        {{sizeof("read_ahead") - 1UL, (u_char *)"read_ahead"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->read_ahead), (void *)0}, 
        {{sizeof("directio") - 1UL,
       (u_char *)"directio"}, (ngx_uint_t )234881026, & ngx_http_core_directio, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("directio_alignment") - 1UL, (u_char *)"directio_alignment"}, (ngx_uint_t )234881026,
      & ngx_conf_set_off_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->directio_alignment), (void *)0}, 
        {{sizeof("tcp_nopush") - 1UL,
       (u_char *)"tcp_nopush"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->tcp_nopush),
      (void *)0}, 
        {{sizeof("tcp_nodelay") - 1UL, (u_char *)"tcp_nodelay"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->tcp_nodelay), (void *)0}, 
        {{sizeof("send_timeout") - 1UL,
       (u_char *)"send_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->send_timeout),
      (void *)0}, 
        {{sizeof("send_lowat") - 1UL, (u_char *)"send_lowat"}, (ngx_uint_t )234881026,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->send_lowat), (void *)(& ngx_http_core_lowat_post)}, 
        {{sizeof("postpone_output") - 1UL,
       (u_char *)"postpone_output"}, (ngx_uint_t )234881026, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->postpone_output),
      (void *)0}, 
        {{sizeof("limit_rate") - 1UL, (u_char *)"limit_rate"}, (ngx_uint_t )1308622850,
      & ngx_conf_set_size_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->limit_rate), (void *)0}, 
        {{sizeof("limit_rate_after") - 1UL,
       (u_char *)"limit_rate_after"}, (ngx_uint_t )1308622850, & ngx_conf_set_size_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->limit_rate_after),
      (void *)0}, 
        {{sizeof("keepalive_timeout") - 1UL, (u_char *)"keepalive_timeout"}, (ngx_uint_t )234881030,
      & ngx_http_core_keepalive, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("keepalive_requests") - 1UL, (u_char *)"keepalive_requests"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->keepalive_requests), (void *)0}, 
        {{sizeof("keepalive_disable") - 1UL,
       (u_char *)"keepalive_disable"}, (ngx_uint_t )234881030, & ngx_conf_set_bitmask_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->keepalive_disable),
      (void *)(& ngx_http_core_keepalive_disable)}, 
        {{sizeof("satisfy") - 1UL, (u_char *)"satisfy"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->satisfy),
      (void *)(& ngx_http_core_satisfy)}, 
        {{sizeof("internal") - 1UL, (u_char *)"internal"}, (ngx_uint_t )134217729, & ngx_http_core_internal,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("lingering_close") - 1UL,
       (u_char *)"lingering_close"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->lingering_close),
      (void *)(& ngx_http_core_lingering_close)}, 
        {{sizeof("lingering_time") - 1UL, (u_char *)"lingering_time"}, (ngx_uint_t )234881026,
      & ngx_conf_set_msec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->lingering_time), (void *)0}, 
        {{sizeof("lingering_timeout") - 1UL,
       (u_char *)"lingering_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->lingering_timeout),
      (void *)0}, 
        {{sizeof("reset_timedout_connection") - 1UL, (u_char *)"reset_timedout_connection"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->reset_timedout_connection),
      (void *)0}, 
        {{sizeof("absolute_redirect") - 1UL, (u_char *)"absolute_redirect"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->absolute_redirect), (void *)0}, 
        {{sizeof("server_name_in_redirect") - 1UL,
       (u_char *)"server_name_in_redirect"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->server_name_in_redirect),
      (void *)0}, 
        {{sizeof("port_in_redirect") - 1UL, (u_char *)"port_in_redirect"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->port_in_redirect), (void *)0}, 
        {{sizeof("msie_padding") - 1UL,
       (u_char *)"msie_padding"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->msie_padding),
      (void *)0}, 
        {{sizeof("msie_refresh") - 1UL, (u_char *)"msie_refresh"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->msie_refresh), (void *)0}, 
        {{sizeof("log_not_found") - 1UL,
       (u_char *)"log_not_found"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->log_not_found),
      (void *)0}, 
        {{sizeof("log_subrequest") - 1UL, (u_char *)"log_subrequest"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->log_subrequest), (void *)0}, 
        {{sizeof("recursive_error_pages") - 1UL,
       (u_char *)"recursive_error_pages"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->recursive_error_pages),
      (void *)0}, 
        {{sizeof("server_tokens") - 1UL, (u_char *)"server_tokens"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->server_tokens), (void *)(& ngx_http_core_server_tokens)}, 
        {{sizeof("if_modified_since") - 1UL,
       (u_char *)"if_modified_since"}, (ngx_uint_t )234881026, & ngx_conf_set_enum_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->if_modified_since),
      (void *)(& ngx_http_core_if_modified_since)}, 
        {{sizeof("max_ranges") - 1UL, (u_char *)"max_ranges"}, (ngx_uint_t )234881026,
      & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->max_ranges), (void *)0}, 
        {{sizeof("chunked_transfer_encoding") - 1UL,
       (u_char *)"chunked_transfer_encoding"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->chunked_transfer_encoding),
      (void *)0}, 
        {{sizeof("etag") - 1UL, (u_char *)"etag"}, (ngx_uint_t )234881536, & ngx_conf_set_flag_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->etag),
      (void *)0}, 
        {{sizeof("error_page") - 1UL, (u_char *)"error_page"}, (ngx_uint_t )1308626944,
      & ngx_http_core_error_page, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("post_action") - 1UL, (u_char *)"post_action"}, (ngx_uint_t )1308622850,
      & ngx_conf_set_str_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->post_action), (void *)0}, 
        {{sizeof("error_log") - 1UL,
       (u_char *)"error_log"}, (ngx_uint_t )234883072, & ngx_http_core_error_log,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("open_file_cache") - 1UL,
       (u_char *)"open_file_cache"}, (ngx_uint_t )234881030, & ngx_http_core_open_file_cache,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache),
      (void *)0}, 
        {{sizeof("open_file_cache_valid") - 1UL, (u_char *)"open_file_cache_valid"},
      (ngx_uint_t )234881026, & ngx_conf_set_sec_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache_valid),
      (void *)0}, 
        {{sizeof("open_file_cache_min_uses") - 1UL, (u_char *)"open_file_cache_min_uses"},
      (ngx_uint_t )234881026, & ngx_conf_set_num_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache_min_uses),
      (void *)0}, 
        {{sizeof("open_file_cache_errors") - 1UL, (u_char *)"open_file_cache_errors"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache_errors),
      (void *)0}, 
        {{sizeof("open_file_cache_events") - 1UL, (u_char *)"open_file_cache_events"},
      (ngx_uint_t )234881536, & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->open_file_cache_events),
      (void *)0}, 
        {{sizeof("resolver") - 1UL, (u_char *)"resolver"}, (ngx_uint_t )234883072, & ngx_http_core_resolver,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (ngx_uint_t )0, (void *)0}, 
        {{sizeof("resolver_timeout") - 1UL,
       (u_char *)"resolver_timeout"}, (ngx_uint_t )234881026, & ngx_conf_set_msec_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->resolver_timeout),
      (void *)0}, 
        {{sizeof("gzip_vary") - 1UL, (u_char *)"gzip_vary"}, (ngx_uint_t )234881536,
      & ngx_conf_set_flag_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->gzip_vary), (void *)0}, 
        {{sizeof("gzip_http_version") - 1UL, (u_char *)"gzip_http_version"}, (ngx_uint_t )234881026,
      & ngx_conf_set_enum_slot, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->gzip_http_version), (void *)(& ngx_http_gzip_http_version)}, 
        {{sizeof("gzip_proxied") - 1UL,
       (u_char *)"gzip_proxied"}, (ngx_uint_t )234883072, & ngx_conf_set_bitmask_slot,
      (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf), (unsigned long )(& ((ngx_http_core_loc_conf_t *)0)->gzip_proxied),
      (void *)(& ngx_http_gzip_proxied_mask)}, 
        {{sizeof("gzip_disable") - 1UL, (u_char *)"gzip_disable"}, (ngx_uint_t )234883072,
      & ngx_http_gzip_disable, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{sizeof("disable_symlinks") - 1UL, (u_char *)"disable_symlinks"}, (ngx_uint_t )234881030,
      & ngx_http_disable_symlinks, (unsigned long )(& ((ngx_http_conf_ctx_t *)0)->loc_conf),
      (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 761 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_http_module_t ngx_http_core_module_ctx  = 
#line 761
     {& ngx_http_core_preconfiguration, & ngx_http_core_postconfiguration, & ngx_http_core_create_main_conf,
    & ngx_http_core_init_main_conf, & ngx_http_core_create_srv_conf, & ngx_http_core_merge_srv_conf,
    & ngx_http_core_create_loc_conf, & ngx_http_core_merge_loc_conf};
#line 776 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_module_t ngx_http_core_module  = 
#line 776
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_core_module_ctx),
    ngx_http_core_commands, (ngx_uint_t )1347703880, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 792 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_str_t ngx_http_core_get_method  =    {(size_t )3, (u_char *)"GET"};
#line 795 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
void ngx_http_handler(ngx_http_request_t *r ) 
{ 
  ngx_http_core_main_conf_t *cmcf ;
  int tmp ;

  {
#line 800
  ((r->connection)->log)->action = (char *)((void *)0);
#line 802
  if (! r->internal) {
    {
#line 804
    if (r->headers_in.connection_type == 0U) {
#line 804
      goto case_0;
    }
#line 808
    if (r->headers_in.connection_type == 1U) {
#line 808
      goto case_1;
    }
#line 812
    if (r->headers_in.connection_type == 2U) {
#line 812
      goto case_2;
    }
#line 803
    goto switch_break;
    case_0: /* CIL Label */ 
#line 805
    r->keepalive = (unsigned int )(r->http_version > 1000UL);
#line 806
    goto switch_break;
    case_1: /* CIL Label */ 
#line 809
    r->keepalive = 0U;
#line 810
    goto switch_break;
    case_2: /* CIL Label */ 
#line 813
    r->keepalive = 1U;
#line 814
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 817
    if (r->headers_in.content_length_n > 0L) {
#line 817
      tmp = 1;
    } else
#line 817
    if (r->headers_in.chunked) {
#line 817
      tmp = 1;
    } else {
#line 817
      tmp = 0;
    }
#line 817
    r->lingering_close = (unsigned int )tmp;
#line 819
    r->phase_handler = (ngx_int_t )0;
  } else {
#line 822
    cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 823
    r->phase_handler = (ngx_int_t )cmcf->phase_engine.server_rewrite_index;
  }
  {
#line 826
  r->valid_location = 1U;
#line 828
  r->gzip_tested = 0U;
#line 829
  r->gzip_ok = 0U;
#line 830
  r->gzip_vary = 0U;
#line 833
  r->write_event_handler = & ngx_http_core_run_phases;
#line 834
  ngx_http_core_run_phases(r);
  }
#line 835
  return;
}
}
#line 838 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
void ngx_http_core_run_phases(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_phase_handler_t *ph ;
  ngx_http_core_main_conf_t *cmcf ;

  {
#line 845
  cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 847
  ph = cmcf->phase_engine.handlers;
  {
#line 849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 849
    if (! (ph + r->phase_handler)->checker) {
#line 849
      goto while_break;
    }
    {
#line 851
    rc = (*((ph + r->phase_handler)->checker))(r, ph + r->phase_handler);
    }
#line 853
    if (rc == 0L) {
#line 854
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  return;
}
}
#line 860 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_generic_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_int_t rc ;

  {
  {
#line 873
  rc = (*(ph->handler))(r);
  }
#line 875
  if (rc == 0L) {
#line 876
    r->phase_handler = (ngx_int_t )ph->next;
#line 877
    return ((ngx_int_t )-2);
  }
#line 880
  if (rc == -5L) {
#line 881
    (r->phase_handler) ++;
#line 882
    return ((ngx_int_t )-2);
  }
#line 885
  if (rc == -2L) {
#line 886
    return ((ngx_int_t )0);
  } else
#line 885
  if (rc == -4L) {
#line 886
    return ((ngx_int_t )0);
  }
  {
#line 891
  ngx_http_finalize_request(r, rc);
  }
#line 893
  return ((ngx_int_t )0);
}
}
#line 897 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_rewrite_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_int_t rc ;

  {
  {
#line 905
  rc = (*(ph->handler))(r);
  }
#line 907
  if (rc == -5L) {
#line 908
    (r->phase_handler) ++;
#line 909
    return ((ngx_int_t )-2);
  }
#line 912
  if (rc == -4L) {
#line 913
    return ((ngx_int_t )0);
  }
  {
#line 918
  ngx_http_finalize_request(r, rc);
  }
#line 920
  return ((ngx_int_t )0);
}
}
#line 924 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_find_config_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_int_t rc ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_char *tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 933
  r->content_handler = (ngx_int_t (*)(ngx_http_request_t *r ))((void *)0);
#line 934
  r->uri_changed = 0U;
#line 936
  rc = ngx_http_core_find_location(r);
  }
#line 938
  if (rc == -1L) {
    {
#line 939
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 940
    return ((ngx_int_t )0);
  }
#line 943
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 945
  if (! r->internal) {
#line 945
    if (clcf->internal) {
      {
#line 946
      ngx_http_finalize_request(r, (ngx_int_t )404);
      }
#line 947
      return ((ngx_int_t )0);
    }
  }
  {
#line 955
  ngx_http_update_location_config(r);
  }
#line 961
  if (r->headers_in.content_length_n != -1L) {
#line 961
    if (! r->discard_body) {
#line 961
      if (clcf->client_max_body_size) {
#line 961
        if (clcf->client_max_body_size < r->headers_in.content_length_n) {
#line 966
          if (((r->connection)->log)->log_level >= 4UL) {
            {
#line 966
            ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "client intended to send too large body: %O bytes",
                               r->headers_in.content_length_n);
            }
          }
          {
#line 970
          r->expect_tested = 1U;
#line 971
          ngx_http_discard_request_body(r);
#line 972
          ngx_http_finalize_request(r, (ngx_int_t )413);
          }
#line 973
          return ((ngx_int_t )0);
        }
      }
    }
  }
#line 976
  if (rc == -4L) {
#line 977
    if (r->headers_out.location) {
#line 977
      (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 977
      r->headers_out.location = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 979
    tmp = ngx_list_push(& r->headers_out.headers);
#line 979
    r->headers_out.location = (ngx_table_elt_t *)tmp;
    }
#line 980
    if ((unsigned long )r->headers_out.location == (unsigned long )((void *)0)) {
      {
#line 981
      ngx_http_finalize_request(r, (ngx_int_t )500);
      }
#line 982
      return ((ngx_int_t )0);
    }
#line 985
    (r->headers_out.location)->hash = (ngx_uint_t )1;
#line 986
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 986
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 988
    if (r->args.len == 0UL) {
#line 989
      (r->headers_out.location)->value = clcf->name;
    } else {
      {
#line 992
      len = (clcf->name.len + 1UL) + r->args.len;
#line 993
      tmp___0 = ngx_pnalloc(r->pool, len);
#line 993
      p = (u_char *)tmp___0;
      }
#line 995
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 996
        if (r->headers_out.location) {
#line 996
          (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 996
          r->headers_out.location = (ngx_table_elt_t *)((void *)0);
        }
        {
#line 997
        ngx_http_finalize_request(r, (ngx_int_t )500);
        }
#line 998
        return ((ngx_int_t )0);
      }
      {
#line 1001
      (r->headers_out.location)->value.len = len;
#line 1002
      (r->headers_out.location)->value.data = p;
#line 1004
      tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)clcf->name.data,
                       clcf->name.len);
#line 1004
      p = (u_char *)tmp___1 + clcf->name.len;
#line 1005
      tmp___2 = p;
#line 1005
      p ++;
#line 1005
      *tmp___2 = (u_char )'?';
#line 1006
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)r->args.data,
             r->args.len);
      }
    }
    {
#line 1009
    ngx_http_finalize_request(r, (ngx_int_t )301);
    }
#line 1010
    return ((ngx_int_t )0);
  }
#line 1013
  (r->phase_handler) ++;
#line 1014
  return ((ngx_int_t )-2);
}
}
#line 1018 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_post_rewrite_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  char *__cil_tmp4 ;

  {
#line 1027
  if (! r->uri_changed) {
#line 1028
    (r->phase_handler) ++;
#line 1029
    return ((ngx_int_t )-2);
  }
#line 1042
  (r->uri_changes) --;
#line 1044
  if (r->uri_changes == 0U) {
#line 1045
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 1045
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "rewrite or internal redirection cycle while processing \"%V\"",
                         & r->uri);
      }
    }
    {
#line 1049
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 1050
    return ((ngx_int_t )0);
  }
#line 1053
  r->phase_handler = (ngx_int_t )ph->next;
#line 1055
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 1056
  r->loc_conf = (cscf->ctx)->loc_conf;
#line 1058
  return ((ngx_int_t )-2);
}
}
#line 1062 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_access_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_int_t rc ;
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 1068
  if ((unsigned long )r != (unsigned long )r->main) {
#line 1069
    r->phase_handler = (ngx_int_t )ph->next;
#line 1070
    return ((ngx_int_t )-2);
  }
  {
#line 1076
  rc = (*(ph->handler))(r);
  }
#line 1078
  if (rc == -5L) {
#line 1079
    (r->phase_handler) ++;
#line 1080
    return ((ngx_int_t )-2);
  }
#line 1083
  if (rc == -2L) {
#line 1084
    return ((ngx_int_t )0);
  } else
#line 1083
  if (rc == -4L) {
#line 1084
    return ((ngx_int_t )0);
  }
#line 1087
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1089
  if (clcf->satisfy == 0UL) {
#line 1091
    if (rc == 0L) {
#line 1092
      (r->phase_handler) ++;
#line 1093
      return ((ngx_int_t )-2);
    }
  } else {
#line 1097
    if (rc == 0L) {
#line 1098
      r->access_code = (ngx_uint_t )0;
#line 1100
      if (r->headers_out.www_authenticate) {
#line 1101
        (r->headers_out.www_authenticate)->hash = (ngx_uint_t )0;
      }
#line 1104
      r->phase_handler = (ngx_int_t )ph->next;
#line 1105
      return ((ngx_int_t )-2);
    }
#line 1108
    if (rc == 403L) {
#line 1108
      goto _L;
    } else
#line 1108
    if (rc == 401L) {
      _L: /* CIL Label */ 
#line 1109
      if (r->access_code != 401UL) {
#line 1110
        r->access_code = (ngx_uint_t )rc;
      }
#line 1113
      (r->phase_handler) ++;
#line 1114
      return ((ngx_int_t )-2);
    }
  }
  {
#line 1120
  ngx_http_finalize_request(r, rc);
  }
#line 1121
  return ((ngx_int_t )0);
}
}
#line 1125 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_post_access_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  ngx_int_t access_code ;
  char *__cil_tmp4 ;

  {
#line 1134
  access_code = (ngx_int_t )r->access_code;
#line 1136
  if (access_code) {
#line 1137
    if (access_code == 403L) {
#line 1138
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1138
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "access forbidden by rule");
        }
      }
    }
    {
#line 1142
    r->access_code = (ngx_uint_t )0;
#line 1143
    ngx_http_finalize_request(r, access_code);
    }
#line 1144
    return ((ngx_int_t )0);
  }
#line 1147
  (r->phase_handler) ++;
#line 1148
  return ((ngx_int_t )-2);
}
}
#line 1152 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_core_content_phase(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) 
{ 
  size_t root ;
  ngx_int_t rc ;
  ngx_str_t path ;
  ngx_int_t tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1160
  if (r->content_handler) {
    {
#line 1161
    r->write_event_handler = & ngx_http_request_empty_handler;
#line 1162
    tmp = (*(r->content_handler))(r);
#line 1162
    ngx_http_finalize_request(r, tmp);
    }
#line 1163
    return ((ngx_int_t )0);
  }
  {
#line 1169
  rc = (*(ph->handler))(r);
  }
#line 1171
  if (rc != -5L) {
    {
#line 1172
    ngx_http_finalize_request(r, rc);
    }
#line 1173
    return ((ngx_int_t )0);
  }
#line 1178
  ph ++;
#line 1180
  if (ph->checker) {
#line 1181
    (r->phase_handler) ++;
#line 1182
    return ((ngx_int_t )-2);
  }
#line 1187
  if ((int )*(r->uri.data + (r->uri.len - 1UL)) == 47) {
    {
#line 1189
    tmp___0 = ngx_http_map_uri_to_path(r, & path, & root, (size_t )0);
    }
#line 1189
    if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
#line 1190
      if (((r->connection)->log)->log_level >= 4UL) {
        {
#line 1190
        ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "directory index of \"%s\" is forbidden",
                           path.data);
        }
      }
    }
    {
#line 1194
    ngx_http_finalize_request(r, (ngx_int_t )403);
    }
#line 1195
    return ((ngx_int_t )0);
  }
#line 1198
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 1198
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "no handler found");
    }
  }
  {
#line 1200
  ngx_http_finalize_request(r, (ngx_int_t )404);
  }
#line 1201
  return ((ngx_int_t )0);
}
}
#line 1205 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
void ngx_http_update_location_config(ngx_http_request_t *r ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;

  {
#line 1210
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1212
  if (r->method & (unsigned long )clcf->limit_except) {
#line 1213
    r->loc_conf = clcf->limit_except_loc_conf;
#line 1214
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
  }
#line 1217
  if ((unsigned long )r == (unsigned long )r->main) {
#line 1218
    ((r->connection)->log)->file = (clcf->error_log)->file;
#line 1218
    ((r->connection)->log)->next = (clcf->error_log)->next;
#line 1218
    ((r->connection)->log)->writer = (clcf->error_log)->writer;
#line 1218
    ((r->connection)->log)->wdata = (clcf->error_log)->wdata;
#line 1218
    if (! (((r->connection)->log)->log_level & 2147483648UL)) {
#line 1218
      ((r->connection)->log)->log_level = (clcf->error_log)->log_level;
    }
  }
#line 1221
  if (ngx_io.flags & 1UL) {
#line 1221
    if (clcf->sendfile) {
#line 1222
      (r->connection)->sendfile = 1U;
    } else {
#line 1225
      (r->connection)->sendfile = 0U;
    }
  } else {
#line 1225
    (r->connection)->sendfile = 0U;
  }
#line 1228
  if (clcf->client_body_in_file_only) {
#line 1229
    r->request_body_in_file_only = 1U;
#line 1230
    r->request_body_in_persistent_file = 1U;
#line 1231
    r->request_body_in_clean_file = (unsigned int )(clcf->client_body_in_file_only == 2UL);
#line 1233
    r->request_body_file_log_level = 6U;
  } else {
#line 1236
    r->request_body_file_log_level = 5U;
  }
#line 1239
  r->request_body_in_single_buf = (unsigned int )clcf->client_body_in_single_buffer;
#line 1241
  if (r->keepalive) {
#line 1242
    if (clcf->keepalive_timeout == 0UL) {
#line 1243
      r->keepalive = 0U;
    } else
#line 1245
    if ((r->connection)->requests >= clcf->keepalive_requests) {
#line 1246
      r->keepalive = 0U;
    } else
#line 1248
    if (r->headers_in.msie6) {
#line 1248
      if (r->method == 8UL) {
#line 1248
        if (clcf->keepalive_disable & 4UL) {
#line 1257
          r->keepalive = 0U;
        } else {
#line 1248
          goto _L___0;
        }
      } else {
#line 1248
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1259
    if (r->headers_in.safari) {
#line 1259
      if (clcf->keepalive_disable & 8UL) {
#line 1268
        r->keepalive = 0U;
      }
    }
  }
#line 1272
  if (! clcf->tcp_nopush) {
#line 1274
    (r->connection)->tcp_nopush = 2U;
  }
#line 1277
  if (r->limit_rate == 0UL) {
#line 1278
    r->limit_rate = clcf->limit_rate;
  }
#line 1281
  if (clcf->handler) {
#line 1282
    r->content_handler = clcf->handler;
  }
#line 1284
  return;
}
}
#line 1295 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_find_location(ngx_http_request_t *r ) 
{ 
  ngx_int_t rc ;
  ngx_http_core_loc_conf_t *pclcf ;
  ngx_int_t n ;
  ngx_uint_t noregex ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_loc_conf_t **clcfp ;
  ngx_int_t tmp ;

  {
  {
#line 1305
  noregex = (ngx_uint_t )0;
#line 1308
  pclcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1310
  rc = ngx_http_core_find_static_location(r, pclcf->static_locations);
  }
#line 1312
  if (rc == -2L) {
    {
#line 1315
    clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1317
    noregex = (ngx_uint_t )clcf->noregex;
#line 1322
    rc = ngx_http_core_find_location(r);
    }
  }
#line 1325
  if (rc == 0L) {
#line 1326
    return (rc);
  } else
#line 1325
  if (rc == -4L) {
#line 1326
    return (rc);
  }
#line 1333
  if (noregex == 0UL) {
#line 1333
    if (pclcf->regex_locations) {
#line 1335
      clcfp = pclcf->regex_locations;
      {
#line 1335
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1335
        if (! *clcfp) {
#line 1335
          goto while_break;
        }
        {
#line 1340
        n = ngx_http_regex_exec(r, (*clcfp)->regex, & r->uri);
        }
#line 1342
        if (n == 0L) {
          {
#line 1343
          r->loc_conf = (*clcfp)->loc_conf;
#line 1347
          rc = ngx_http_core_find_location(r);
          }
#line 1349
          if (rc == -1L) {
#line 1349
            tmp = rc;
          } else {
#line 1349
            tmp = (ngx_int_t )0;
          }
#line 1349
          return (tmp);
        }
#line 1352
        if (n == -5L) {
#line 1353
          goto __Cont;
        }
#line 1356
        return ((ngx_int_t )-1);
        __Cont: /* CIL Label */ 
#line 1335
        clcfp ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 1361
  return (rc);
}
}
#line 1372 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_find_static_location(ngx_http_request_t *r , ngx_http_location_tree_node_t *node ) 
{ 
  u_char *uri___0 ;
  size_t len ;
  size_t n ;
  ngx_int_t rc ;
  ngx_int_t rv ;

  {
#line 1380
  len = r->uri.len;
#line 1381
  uri___0 = r->uri.data;
#line 1383
  rv = (ngx_int_t )-5;
  {
#line 1385
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1387
    if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1388
      return (rv);
    }
#line 1395
    if (len <= (size_t )node->len) {
#line 1395
      n = len;
    } else {
#line 1395
      n = (size_t )node->len;
    }
    {
#line 1397
    rc = ngx_filename_cmp(uri___0, node->name, n);
    }
#line 1399
    if (rc != 0L) {
#line 1400
      if (rc < 0L) {
#line 1400
        node = node->left;
      } else {
#line 1400
        node = node->right;
      }
#line 1402
      goto __Cont;
    }
#line 1405
    if (len > (size_t )node->len) {
#line 1407
      if (node->inclusive) {
#line 1409
        r->loc_conf = (node->inclusive)->loc_conf;
#line 1410
        rv = (ngx_int_t )-2;
#line 1412
        node = node->tree;
#line 1413
        uri___0 += n;
#line 1414
        len -= n;
#line 1416
        goto __Cont;
      }
#line 1421
      node = node->right;
#line 1423
      goto __Cont;
    }
#line 1426
    if (len == (size_t )node->len) {
#line 1428
      if (node->exact) {
#line 1429
        r->loc_conf = (node->exact)->loc_conf;
#line 1430
        return ((ngx_int_t )0);
      } else {
#line 1433
        r->loc_conf = (node->inclusive)->loc_conf;
#line 1434
        return ((ngx_int_t )-2);
      }
    }
#line 1440
    if (len + 1UL == (size_t )node->len) {
#line 1440
      if (node->auto_redirect) {
#line 1442
        if (node->exact) {
#line 1442
          r->loc_conf = (node->exact)->loc_conf;
        } else {
#line 1442
          r->loc_conf = (node->inclusive)->loc_conf;
        }
#line 1444
        rv = (ngx_int_t )-4;
      }
    }
#line 1447
    node = node->left;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1452 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
void *ngx_http_test_content_type(ngx_http_request_t *r , ngx_hash_t *types_hash ) 
{ 
  u_char c ;
  u_char *lowcase___0 ;
  size_t len ;
  ngx_uint_t i ;
  ngx_uint_t hash ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 1459
  if (types_hash->size == 0UL) {
#line 1460
    return ((void *)4);
  }
#line 1463
  if (r->headers_out.content_type.len == 0UL) {
#line 1464
    return ((void *)0);
  }
#line 1467
  len = r->headers_out.content_type_len;
#line 1469
  if ((unsigned long )r->headers_out.content_type_lowcase == (unsigned long )((void *)0)) {
    {
#line 1471
    tmp = ngx_pnalloc(r->pool, len);
#line 1471
    lowcase___0 = (u_char *)tmp;
    }
#line 1472
    if ((unsigned long )lowcase___0 == (unsigned long )((void *)0)) {
#line 1473
      return ((void *)0);
    }
#line 1476
    r->headers_out.content_type_lowcase = lowcase___0;
#line 1478
    hash = (ngx_uint_t )0;
#line 1480
    i = (ngx_uint_t )0;
    {
#line 1480
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1480
      if (! (i < len)) {
#line 1480
        goto while_break;
      }
#line 1481
      if ((int )*(r->headers_out.content_type.data + i) >= 65) {
#line 1481
        if ((int )*(r->headers_out.content_type.data + i) <= 90) {
#line 1481
          tmp___0 = (int )*(r->headers_out.content_type.data + i) | 32;
        } else {
#line 1481
          tmp___0 = (int )*(r->headers_out.content_type.data + i);
        }
      } else {
#line 1481
        tmp___0 = (int )*(r->headers_out.content_type.data + i);
      }
#line 1481
      c = (u_char )tmp___0;
#line 1482
      hash = hash * 31UL + (ngx_uint_t )c;
#line 1483
      *(lowcase___0 + i) = c;
#line 1480
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1486
    r->headers_out.content_type_hash = hash;
  }
  {
#line 1489
  tmp___1 = ngx_hash_find(types_hash, r->headers_out.content_type_hash, r->headers_out.content_type_lowcase,
                          len);
  }
#line 1489
  return (tmp___1);
}
}
#line 1494 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_set_content_type(ngx_http_request_t *r ) 
{ 
  u_char c ;
  u_char *exten ;
  ngx_str_t *type ;
  ngx_uint_t i ;
  ngx_uint_t hash ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 1502
  if (r->headers_out.content_type.len) {
#line 1503
    return ((ngx_int_t )0);
  }
#line 1506
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1508
  if (r->exten.len) {
#line 1510
    hash = (ngx_uint_t )0;
#line 1512
    i = (ngx_uint_t )0;
    {
#line 1512
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1512
      if (! (i < r->exten.len)) {
#line 1512
        goto while_break;
      }
#line 1513
      c = *(r->exten.data + i);
#line 1515
      if ((int )c >= 65) {
#line 1515
        if ((int )c <= 90) {
          {
#line 1517
          tmp = ngx_pnalloc(r->pool, r->exten.len);
#line 1517
          exten = (u_char *)tmp;
          }
#line 1518
          if ((unsigned long )exten == (unsigned long )((void *)0)) {
#line 1519
            return ((ngx_int_t )-1);
          }
          {
#line 1522
          hash = ngx_hash_strlow(exten, r->exten.data, r->exten.len);
#line 1524
          r->exten.data = exten;
          }
#line 1526
          goto while_break;
        }
      }
#line 1529
      hash = hash * 31UL + (ngx_uint_t )c;
#line 1512
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1532
    tmp___0 = ngx_hash_find(& clcf->types_hash, hash, r->exten.data, r->exten.len);
#line 1532
    type = (ngx_str_t *)tmp___0;
    }
#line 1535
    if (type) {
#line 1536
      r->headers_out.content_type_len = type->len;
#line 1537
      r->headers_out.content_type = *type;
#line 1539
      return ((ngx_int_t )0);
    }
  }
#line 1543
  r->headers_out.content_type_len = clcf->default_type.len;
#line 1544
  r->headers_out.content_type = clcf->default_type;
#line 1546
  return ((ngx_int_t )0);
}
}
#line 1550 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
void ngx_http_set_exten(ngx_http_request_t *r ) 
{ 
  ngx_int_t i ;

  {
#line 1555
  r->exten.len = (size_t )0;
#line 1555
  r->exten.data = (u_char *)((void *)0);
#line 1557
  i = (ngx_int_t )(r->uri.len - 1UL);
  {
#line 1557
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1557
    if (! (i > 1L)) {
#line 1557
      goto while_break;
    }
#line 1558
    if ((int )*(r->uri.data + i) == 46) {
#line 1558
      if ((int )*(r->uri.data + (i - 1L)) != 47) {
#line 1560
        r->exten.len = (r->uri.len - (size_t )i) - 1UL;
#line 1561
        r->exten.data = r->uri.data + (i + 1L);
#line 1563
        return;
      } else {
#line 1558
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1565
    if ((int )*(r->uri.data + i) == 47) {
#line 1566
      return;
    }
#line 1557
    i --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1570
  return;
}
}
#line 1574 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_set_etag(ngx_http_request_t *r ) 
{ 
  ngx_table_elt_t *etag ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1580
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1582
  if (! clcf->etag) {
#line 1583
    return ((ngx_int_t )0);
  }
  {
#line 1586
  tmp = ngx_list_push(& r->headers_out.headers);
#line 1586
  etag = (ngx_table_elt_t *)tmp;
  }
#line 1587
  if ((unsigned long )etag == (unsigned long )((void *)0)) {
#line 1588
    return ((ngx_int_t )-1);
  }
  {
#line 1591
  etag->hash = (ngx_uint_t )1;
#line 1592
  etag->key.len = sizeof("ETag") - 1UL;
#line 1592
  etag->key.data = (u_char *)"ETag";
#line 1594
  tmp___0 = ngx_pnalloc(r->pool, ((sizeof("-9223372036854775808") - 1UL) + (sizeof("-9223372036854775808") - 1UL)) + 3UL);
#line 1594
  etag->value.data = (u_char *)tmp___0;
  }
#line 1595
  if ((unsigned long )etag->value.data == (unsigned long )((void *)0)) {
#line 1596
    etag->hash = (ngx_uint_t )0;
#line 1597
    return ((ngx_int_t )-1);
  }
  {
#line 1600
  tmp___1 = ngx_sprintf(etag->value.data, "\"%xT-%xO\"", r->headers_out.last_modified_time,
                        r->headers_out.content_length_n);
#line 1600
  etag->value.len = (size_t )(tmp___1 - etag->value.data);
#line 1605
  r->headers_out.etag = etag;
  }
#line 1607
  return ((ngx_int_t )0);
}
}
#line 1611 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
void ngx_http_weak_etag(ngx_http_request_t *r ) 
{ 
  size_t len ;
  u_char *p ;
  ngx_table_elt_t *etag ;
  void *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 1618
  etag = r->headers_out.etag;
#line 1620
  if ((unsigned long )etag == (unsigned long )((void *)0)) {
#line 1621
    return;
  }
#line 1624
  if (etag->value.len > 2UL) {
#line 1624
    if ((int )*(etag->value.data + 0) == 87) {
#line 1624
      if ((int )*(etag->value.data + 1) == 47) {
#line 1628
        return;
      }
    }
  }
#line 1631
  if (etag->value.len < 1UL) {
#line 1632
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 1633
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
#line 1634
    return;
  } else
#line 1631
  if ((int )*(etag->value.data + 0) != 34) {
#line 1632
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 1633
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
#line 1634
    return;
  }
  {
#line 1637
  tmp = ngx_pnalloc(r->pool, etag->value.len + 2UL);
#line 1637
  p = (u_char *)tmp;
  }
#line 1638
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1639
    (r->headers_out.etag)->hash = (ngx_uint_t )0;
#line 1640
    r->headers_out.etag = (ngx_table_elt_t *)((void *)0);
#line 1641
    return;
  }
  {
#line 1644
  tmp___0 = ngx_sprintf(p, "W/%V", & etag->value);
#line 1644
  len = (size_t )(tmp___0 - p);
#line 1646
  etag->value.data = p;
#line 1647
  etag->value.len = len;
  }
#line 1648
  return;
}
}
#line 1651 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_send_response(ngx_http_request_t *r , ngx_uint_t status , ngx_str_t *ct ,
                                 ngx_http_complex_value_t *cv ) 
{ 
  ngx_int_t rc ;
  ngx_str_t val ;
  ngx_buf_t *b ;
  ngx_chain_t out ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  ngx_int_t tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 1660
  tmp = ngx_http_discard_request_body(r);
  }
#line 1660
  if (tmp != 0L) {
#line 1661
    return ((ngx_int_t )500);
  }
  {
#line 1664
  r->headers_out.status = status;
#line 1666
  tmp___0 = ngx_http_complex_value(r, cv, & val);
  }
#line 1666
  if (tmp___0 != 0L) {
#line 1667
    return ((ngx_int_t )500);
  }
#line 1670
  if (status == 301UL) {
#line 1670
    goto _L;
  } else
#line 1670
  if (status == 302UL) {
#line 1670
    goto _L;
  } else
#line 1670
  if (status == 303UL) {
#line 1670
    goto _L;
  } else
#line 1670
  if (status == 307UL) {
#line 1670
    goto _L;
  } else
#line 1670
  if (status == 308UL) {
    _L: /* CIL Label */ 
#line 1676
    if (r->headers_out.location) {
#line 1676
      (r->headers_out.location)->hash = (ngx_uint_t )0;
#line 1676
      r->headers_out.location = (ngx_table_elt_t *)((void *)0);
    }
    {
#line 1678
    tmp___1 = ngx_list_push(& r->headers_out.headers);
#line 1678
    r->headers_out.location = (ngx_table_elt_t *)tmp___1;
    }
#line 1679
    if ((unsigned long )r->headers_out.location == (unsigned long )((void *)0)) {
#line 1680
      return ((ngx_int_t )500);
    }
#line 1683
    (r->headers_out.location)->hash = (ngx_uint_t )1;
#line 1684
    (r->headers_out.location)->key.len = sizeof("Location") - 1UL;
#line 1684
    (r->headers_out.location)->key.data = (u_char *)"Location";
#line 1685
    (r->headers_out.location)->value = val;
#line 1687
    return ((ngx_int_t )status);
  }
#line 1690
  r->headers_out.content_length_n = (off_t )val.len;
#line 1692
  if (ct) {
#line 1693
    r->headers_out.content_type_len = ct->len;
#line 1694
    r->headers_out.content_type = *ct;
  } else {
    {
#line 1697
    tmp___2 = ngx_http_set_content_type(r);
    }
#line 1697
    if (tmp___2 != 0L) {
#line 1698
      return ((ngx_int_t )500);
    }
  }
#line 1702
  if (r->method == 4UL) {
    {
#line 1703
    tmp___3 = ngx_http_send_header(r);
    }
#line 1703
    return (tmp___3);
  } else
#line 1702
  if ((unsigned long )r != (unsigned long )r->main) {
#line 1702
    if (val.len == 0UL) {
      {
#line 1703
      tmp___3 = ngx_http_send_header(r);
      }
#line 1703
      return (tmp___3);
    }
  }
  {
#line 1706
  tmp___4 = ngx_pcalloc(r->pool, sizeof(ngx_buf_t ));
#line 1706
  b = (ngx_buf_t *)tmp___4;
  }
#line 1707
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1708
    return ((ngx_int_t )500);
  }
#line 1711
  b->pos = val.data;
#line 1712
  b->last = val.data + val.len;
#line 1713
  if (val.len) {
#line 1713
    b->memory = 1U;
  } else {
#line 1713
    b->memory = 0U;
  }
#line 1714
  if ((unsigned long )r == (unsigned long )r->main) {
#line 1714
    b->last_buf = 1U;
  } else {
#line 1714
    b->last_buf = 0U;
  }
  {
#line 1715
  b->last_in_chain = 1U;
#line 1717
  out.buf = b;
#line 1718
  out.next = (ngx_chain_t *)((void *)0);
#line 1720
  rc = ngx_http_send_header(r);
  }
#line 1722
  if (rc == -1L) {
#line 1723
    return (rc);
  } else
#line 1722
  if (rc > 0L) {
#line 1723
    return (rc);
  } else
#line 1722
  if (r->header_only) {
#line 1723
    return (rc);
  }
  {
#line 1726
  tmp___5 = ngx_http_output_filter(r, & out);
  }
#line 1726
  return (tmp___5);
}
}
#line 1730 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_send_header(ngx_http_request_t *r ) 
{ 
  ngx_int_t tmp ;
  char *__cil_tmp3 ;

  {
#line 1733
  if (r->post_action) {
#line 1734
    return ((ngx_int_t )0);
  }
#line 1737
  if (r->header_sent) {
#line 1738
    if (((r->connection)->log)->log_level >= 2UL) {
      {
#line 1738
      ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "header already sent");
      }
    }
#line 1740
    return ((ngx_int_t )-1);
  }
#line 1743
  if (r->err_status) {
#line 1744
    r->headers_out.status = r->err_status;
#line 1745
    r->headers_out.status_line.len = (size_t )0;
  }
  {
#line 1748
  tmp = (*ngx_http_top_header_filter)(r);
  }
#line 1748
  return (tmp);
}
}
#line 1752 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_output_filter(ngx_http_request_t *r , ngx_chain_t *in ) 
{ 
  ngx_int_t rc ;
  ngx_connection_t *c ;

  {
  {
#line 1758
  c = r->connection;
#line 1763
  rc = (*ngx_http_top_body_filter)(r, in);
  }
#line 1765
  if (rc == -1L) {
#line 1767
    c->error = 1U;
  }
#line 1770
  return (rc);
}
}
#line 1774 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
u_char *ngx_http_map_uri_to_path(ngx_http_request_t *r , ngx_str_t *path , size_t *root_length ,
                                 size_t reserved ) 
{ 
  u_char *last ;
  size_t alias ;
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;
  char *__cil_tmp13 ;

  {
#line 1782
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1784
  alias = clcf->alias;
#line 1786
  if (alias) {
#line 1786
    if (! r->valid_location) {
#line 1787
      if (((r->connection)->log)->log_level >= 2UL) {
        {
#line 1787
        ngx_log_error_core((ngx_uint_t )2, (r->connection)->log, 0, "\"alias\" cannot be used in location \"%V\" where URI was rewritten",
                           & clcf->name);
        }
      }
#line 1790
      return ((u_char *)((void *)0));
    }
  }
#line 1793
  if ((unsigned long )clcf->root_lengths == (unsigned long )((void *)0)) {
    {
#line 1795
    *root_length = clcf->root.len;
#line 1797
    path->len = (((clcf->root.len + reserved) + r->uri.len) - alias) + 1UL;
#line 1799
    tmp = ngx_pnalloc(r->pool, path->len);
#line 1799
    path->data = (u_char *)tmp;
    }
#line 1800
    if ((unsigned long )path->data == (unsigned long )((void *)0)) {
#line 1801
      return ((u_char *)((void *)0));
    }
    {
#line 1804
    tmp___0 = memcpy((void */* __restrict  */)path->data, (void const   */* __restrict  */)clcf->root.data,
                     clcf->root.len);
#line 1804
    last = (u_char *)tmp___0 + clcf->root.len;
    }
  } else {
#line 1808
    if ((long long )alias == 9223372036854775807LL) {
#line 1809
      if (r->add_uri_to_alias) {
#line 1809
        tmp___1 = r->uri.len + 1UL;
      } else {
#line 1809
        tmp___1 = (size_t )1;
      }
#line 1809
      reserved += tmp___1;
    } else {
#line 1812
      reserved += (r->uri.len - alias) + 1UL;
    }
    {
#line 1815
    tmp___2 = ngx_http_script_run(r, path, (clcf->root_lengths)->elts, reserved, (clcf->root_values)->elts);
    }
#line 1815
    if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
#line 1819
      return ((u_char *)((void *)0));
    }
    {
#line 1822
    tmp___3 = ngx_get_full_name(r->pool, (ngx_str_t *)(& ngx_cycle->prefix), path);
    }
#line 1822
    if (tmp___3 != 0L) {
#line 1825
      return ((u_char *)((void *)0));
    }
#line 1828
    *root_length = path->len - reserved;
#line 1829
    last = path->data + *root_length;
#line 1831
    if ((long long )alias == 9223372036854775807LL) {
#line 1832
      if (! r->add_uri_to_alias) {
#line 1833
        *last = (u_char )'\000';
#line 1834
        return (last);
      }
#line 1837
      alias = (size_t )0;
    }
  }
  {
#line 1841
  last = ngx_cpystrn(last, r->uri.data + alias, (r->uri.len - alias) + 1UL);
  }
#line 1843
  return (last);
}
}
#line 1847 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_auth_basic_user(ngx_http_request_t *r ) 
{ 
  ngx_str_t auth ;
  ngx_str_t encoded ;
  ngx_uint_t len ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1853
  if (r->headers_in.user.len == 0UL) {
#line 1853
    if ((unsigned long )r->headers_in.user.data != (unsigned long )((void *)0)) {
#line 1854
      return ((ngx_int_t )-5);
    }
  }
#line 1857
  if ((unsigned long )r->headers_in.authorization == (unsigned long )((void *)0)) {
#line 1858
    r->headers_in.user.data = (u_char *)"";
#line 1859
    return ((ngx_int_t )-5);
  }
#line 1862
  encoded = (r->headers_in.authorization)->value;
#line 1864
  if (encoded.len < sizeof("Basic ") - 1UL) {
#line 1869
    r->headers_in.user.data = (u_char *)"";
#line 1870
    return ((ngx_int_t )-5);
  } else {
    {
#line 1864
    tmp = ngx_strncasecmp(encoded.data, (u_char *)"Basic ", sizeof("Basic ") - 1UL);
    }
#line 1864
    if (tmp != 0L) {
#line 1869
      r->headers_in.user.data = (u_char *)"";
#line 1870
      return ((ngx_int_t )-5);
    }
  }
#line 1873
  encoded.len -= sizeof("Basic ") - 1UL;
#line 1874
  encoded.data += sizeof("Basic ") - 1UL;
  {
#line 1876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1876
    if (encoded.len) {
#line 1876
      if (! ((int )*(encoded.data + 0) == 32)) {
#line 1876
        goto while_break;
      }
    } else {
#line 1876
      goto while_break;
    }
#line 1877
    (encoded.len) --;
#line 1878
    (encoded.data) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1881
  if (encoded.len == 0UL) {
#line 1882
    r->headers_in.user.data = (u_char *)"";
#line 1883
    return ((ngx_int_t )-5);
  }
  {
#line 1886
  auth.len = ((encoded.len + 3UL) / 4UL) * 3UL;
#line 1887
  tmp___0 = ngx_pnalloc(r->pool, auth.len + 1UL);
#line 1887
  auth.data = (u_char *)tmp___0;
  }
#line 1888
  if ((unsigned long )auth.data == (unsigned long )((void *)0)) {
#line 1889
    return ((ngx_int_t )-1);
  }
  {
#line 1892
  tmp___1 = ngx_decode_base64(& auth, & encoded);
  }
#line 1892
  if (tmp___1 != 0L) {
#line 1893
    r->headers_in.user.data = (u_char *)"";
#line 1894
    return ((ngx_int_t )-5);
  }
#line 1897
  *(auth.data + auth.len) = (u_char )'\000';
#line 1899
  len = (ngx_uint_t )0;
  {
#line 1899
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1899
    if (! (len < auth.len)) {
#line 1899
      goto while_break___0;
    }
#line 1900
    if ((int )*(auth.data + len) == 58) {
#line 1901
      goto while_break___0;
    }
#line 1899
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1905
  if (len == 0UL) {
#line 1906
    r->headers_in.user.data = (u_char *)"";
#line 1907
    return ((ngx_int_t )-5);
  } else
#line 1905
  if (len == auth.len) {
#line 1906
    r->headers_in.user.data = (u_char *)"";
#line 1907
    return ((ngx_int_t )-5);
  }
#line 1910
  r->headers_in.user.len = len;
#line 1911
  r->headers_in.user.data = auth.data;
#line 1912
  r->headers_in.passwd.len = (auth.len - len) - 1UL;
#line 1913
  r->headers_in.passwd.data = auth.data + (len + 1UL);
#line 1915
  return ((ngx_int_t )0);
}
}
#line 1921 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_gzip_ok(ngx_http_request_t *r ) 
{ 
  time_t date ;
  time_t expires___0 ;
  ngx_uint_t p ;
  ngx_array_t *cc ;
  ngx_table_elt_t *e ;
  ngx_table_elt_t *d ;
  ngx_table_elt_t *ae ;
  ngx_http_core_loc_conf_t *clcf ;
  int tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 1930
  r->gzip_tested = 1U;
#line 1932
  if ((unsigned long )r != (unsigned long )r->main) {
#line 1933
    return ((ngx_int_t )-5);
  }
#line 1936
  ae = r->headers_in.accept_encoding;
#line 1937
  if ((unsigned long )ae == (unsigned long )((void *)0)) {
#line 1938
    return ((ngx_int_t )-5);
  }
#line 1941
  if (ae->value.len < sizeof("gzip") - 1UL) {
#line 1942
    return ((ngx_int_t )-5);
  }
  {
#line 1954
  tmp = memcmp((void const   *)((char const   *)ae->value.data), (void const   *)"gzip,",
               (size_t )5);
  }
#line 1954
  if (tmp != 0) {
    {
#line 1954
    tmp___0 = ngx_http_gzip_accept_encoding(& ae->value);
    }
#line 1954
    if (tmp___0 != 0L) {
#line 1957
      return ((ngx_int_t )-5);
    }
  }
#line 1960
  clcf = (ngx_http_core_loc_conf_t *)*(r->loc_conf + ngx_http_core_module.ctx_index);
#line 1962
  if (r->headers_in.msie6) {
#line 1962
    if (clcf->gzip_disable_msie6) {
#line 1963
      return ((ngx_int_t )-5);
    }
  }
#line 1966
  if (r->http_version < clcf->gzip_http_version) {
#line 1967
    return ((ngx_int_t )-5);
  }
#line 1970
  if ((unsigned long )r->headers_in.via == (unsigned long )((void *)0)) {
#line 1971
    goto ok;
  }
#line 1974
  p = clcf->gzip_proxied;
#line 1976
  if (p & 2UL) {
#line 1977
    return ((ngx_int_t )-5);
  }
#line 1980
  if (p & 512UL) {
#line 1981
    goto ok;
  }
#line 1984
  if (r->headers_in.authorization) {
#line 1984
    if (p & 256UL) {
#line 1985
      goto ok;
    }
  }
#line 1988
  e = r->headers_out.expires;
#line 1990
  if (e) {
#line 1992
    if (! (p & 4UL)) {
#line 1993
      return ((ngx_int_t )-5);
    }
    {
#line 1996
    expires___0 = ngx_parse_http_time(e->value.data, e->value.len);
    }
#line 1997
    if (expires___0 == -1L) {
#line 1998
      return ((ngx_int_t )-5);
    }
#line 2001
    d = r->headers_out.date;
#line 2003
    if (d) {
      {
#line 2004
      date = ngx_parse_http_time(d->value.data, d->value.len);
      }
#line 2005
      if (date == -1L) {
#line 2006
        return ((ngx_int_t )-5);
      }
    } else {
#line 2010
      date = (time_t )ngx_cached_time->sec;
    }
#line 2013
    if (expires___0 < date) {
#line 2014
      goto ok;
    }
#line 2017
    return ((ngx_int_t )-5);
  }
#line 2020
  cc = & r->headers_out.cache_control;
#line 2022
  if (cc->elts) {
#line 2024
    if (p & 8UL) {
      {
#line 2024
      tmp___1 = ngx_http_parse_multi_header_lines(cc, & ngx_http_gzip_no_cache, (ngx_str_t *)((void *)0));
      }
#line 2024
      if (tmp___1 >= 0L) {
#line 2029
        goto ok;
      }
    }
#line 2032
    if (p & 16UL) {
      {
#line 2032
      tmp___2 = ngx_http_parse_multi_header_lines(cc, & ngx_http_gzip_no_store, (ngx_str_t *)((void *)0));
      }
#line 2032
      if (tmp___2 >= 0L) {
#line 2037
        goto ok;
      }
    }
#line 2040
    if (p & 32UL) {
      {
#line 2040
      tmp___3 = ngx_http_parse_multi_header_lines(cc, & ngx_http_gzip_private, (ngx_str_t *)((void *)0));
      }
#line 2040
      if (tmp___3 >= 0L) {
#line 2045
        goto ok;
      }
    }
#line 2048
    return ((ngx_int_t )-5);
  }
#line 2051
  if (p & 64UL) {
#line 2051
    if (r->headers_out.last_modified) {
#line 2052
      return ((ngx_int_t )-5);
    }
  }
#line 2055
  if (p & 128UL) {
#line 2055
    if (r->headers_out.etag) {
#line 2056
      return ((ngx_int_t )-5);
    }
  }
  ok: 
#line 2063
  if (clcf->gzip_disable) {
#line 2063
    if (r->headers_in.user_agent) {
      {
#line 2065
      tmp___4 = ngx_regex_exec_array(clcf->gzip_disable, & (r->headers_in.user_agent)->value,
                                     (r->connection)->log);
      }
#line 2065
      if (tmp___4 != -5L) {
#line 2070
        return ((ngx_int_t )-5);
      }
    }
  }
#line 2076
  r->gzip_ok = 1U;
#line 2078
  return ((ngx_int_t )0);
}
}
#line 2089 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_gzip_accept_encoding(ngx_str_t *ae ) 
{ 
  u_char *p ;
  u_char *start ;
  u_char *last ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  ngx_uint_t tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 2094
  start = ae->data;
#line 2095
  last = start + ae->len;
  {
#line 2097
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2098
    p = ngx_strcasestrn(start, (char *)"gzip", (size_t )3);
    }
#line 2099
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 2100
      return ((ngx_int_t )-5);
    }
#line 2103
    if ((unsigned long )p == (unsigned long )start) {
#line 2104
      goto while_break;
    } else
#line 2103
    if ((int )*(p - 1) == 44) {
#line 2104
      goto while_break;
    } else
#line 2103
    if ((int )*(p - 1) == 32) {
#line 2104
      goto while_break;
    }
#line 2107
    start = p + 4;
  }
  while_break: /* CIL Label */ ;
  }
#line 2110
  p += 4;
  {
#line 2112
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2112
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2112
      goto while_break___0;
    }
#line 2113
    tmp = p;
#line 2113
    p ++;
    {
#line 2114
    if ((int )*tmp == 44) {
#line 2114
      goto case_44;
    }
#line 2116
    if ((int )*tmp == 59) {
#line 2116
      goto case_59;
    }
#line 2118
    if ((int )*tmp == 32) {
#line 2118
      goto case_32;
    }
#line 2120
    goto switch_default;
    case_44: /* CIL Label */ 
#line 2115
    return ((ngx_int_t )0);
    case_59: /* CIL Label */ 
#line 2117
    goto quantity;
    case_32: /* CIL Label */ 
#line 2119
    goto while_continue___0;
    switch_default: /* CIL Label */ 
#line 2121
    return ((ngx_int_t )-5);
    switch_break: /* CIL Label */ ;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2125
  return ((ngx_int_t )0);
  quantity: 
  {
#line 2129
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2129
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2129
      goto while_break___1;
    }
#line 2130
    tmp___0 = p;
#line 2130
    p ++;
    {
#line 2132
    if ((int )*tmp___0 == 81) {
#line 2132
      goto case_81;
    }
#line 2132
    if ((int )*tmp___0 == 113) {
#line 2132
      goto case_81;
    }
#line 2134
    if ((int )*tmp___0 == 32) {
#line 2134
      goto case_32___0;
    }
#line 2136
    goto switch_default___0;
    case_81: /* CIL Label */ 
    case_113: /* CIL Label */ 
#line 2133
    goto equal;
    case_32___0: /* CIL Label */ 
#line 2135
    goto while_continue___1;
    switch_default___0: /* CIL Label */ 
#line 2137
    return ((ngx_int_t )-5);
    switch_break___0: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2141
  return ((ngx_int_t )0);
  equal: 
#line 2145
  if ((unsigned long )(p + 2) > (unsigned long )last) {
#line 2146
    return ((ngx_int_t )-5);
  } else {
#line 2145
    tmp___1 = p;
#line 2145
    p ++;
#line 2145
    if ((int )*tmp___1 != 61) {
#line 2146
      return ((ngx_int_t )-5);
    }
  }
  {
#line 2149
  tmp___2 = ngx_http_gzip_quantity(p, last);
  }
#line 2149
  if (tmp___2 == 0UL) {
#line 2150
    return ((ngx_int_t )-5);
  }
#line 2153
  return ((ngx_int_t )0);
}
}
#line 2157 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_uint_t ngx_http_gzip_quantity(u_char *p , u_char *last ) 
{ 
  u_char c ;
  ngx_uint_t n ;
  ngx_uint_t q ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;

  {
#line 2163
  tmp = p;
#line 2163
  p ++;
#line 2163
  c = *tmp;
#line 2165
  if ((int )c != 48) {
#line 2165
    if ((int )c != 49) {
#line 2166
      return ((ngx_uint_t )0);
    }
  }
#line 2169
  q = (ngx_uint_t )(((int )c - 48) * 100);
#line 2171
  if ((unsigned long )p == (unsigned long )last) {
#line 2172
    return (q);
  }
#line 2175
  tmp___0 = p;
#line 2175
  p ++;
#line 2175
  c = *tmp___0;
#line 2177
  if ((int )c == 44) {
#line 2178
    return (q);
  } else
#line 2177
  if ((int )c == 32) {
#line 2178
    return (q);
  }
#line 2181
  if ((int )c != 46) {
#line 2182
    return ((ngx_uint_t )0);
  }
#line 2185
  n = (ngx_uint_t )0;
  {
#line 2187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2187
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 2187
      goto while_break;
    }
#line 2188
    tmp___1 = p;
#line 2188
    p ++;
#line 2188
    c = *tmp___1;
#line 2190
    if ((int )c == 44) {
#line 2191
      goto while_break;
    } else
#line 2190
    if ((int )c == 32) {
#line 2191
      goto while_break;
    }
#line 2194
    if ((int )c >= 48) {
#line 2194
      if ((int )c <= 57) {
#line 2195
        q += (ngx_uint_t )((int )c - 48);
#line 2196
        n ++;
#line 2197
        goto while_continue;
      }
    }
#line 2200
    return ((ngx_uint_t )0);
  }
  while_break: /* CIL Label */ ;
  }
#line 2203
  if (q > 100UL) {
#line 2204
    return ((ngx_uint_t )0);
  } else
#line 2203
  if (n > 3UL) {
#line 2204
    return ((ngx_uint_t )0);
  }
#line 2207
  return (q);
}
}
#line 2213 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_subrequest(ngx_http_request_t *r , ngx_str_t *uri___0 , ngx_str_t *args___0 ,
                              ngx_http_request_t **psr , ngx_http_post_subrequest_t *ps ,
                              ngx_uint_t flags ) 
{ 
  ngx_time_t *tp ;
  ngx_connection_t *c ;
  ngx_http_request_t *sr ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_postponed_request_t *pr ;
  ngx_http_postponed_request_t *p ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 2224
  if (r->subrequests == 0U) {
#line 2225
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2225
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "subrequests cycle while processing \"%V\"",
                         uri___0);
      }
    }
#line 2227
    return ((ngx_int_t )-1);
  }
#line 2233
  if ((r->main)->count >= 64535U) {
#line 2234
    if (((r->connection)->log)->log_level >= 3UL) {
      {
#line 2234
      ngx_log_error_core((ngx_uint_t )3, (r->connection)->log, 0, "request reference counter overflow while processing \"%V\"",
                         uri___0);
      }
    }
#line 2237
    return ((ngx_int_t )-1);
  }
  {
#line 2240
  tmp = ngx_pcalloc(r->pool, sizeof(ngx_http_request_t ));
#line 2240
  sr = (ngx_http_request_t *)tmp;
  }
#line 2241
  if ((unsigned long )sr == (unsigned long )((void *)0)) {
#line 2242
    return ((ngx_int_t )-1);
  }
  {
#line 2245
  sr->signature = (uint32_t )1347703880;
#line 2247
  c = r->connection;
#line 2248
  sr->connection = c;
#line 2250
  tmp___0 = ngx_pcalloc(r->pool, sizeof(void *) * ngx_http_max_module);
#line 2250
  sr->ctx = (void **)tmp___0;
  }
#line 2251
  if ((unsigned long )sr->ctx == (unsigned long )((void *)0)) {
#line 2252
    return ((ngx_int_t )-1);
  }
  {
#line 2255
  tmp___1 = ngx_list_init(& sr->headers_out.headers, r->pool, (ngx_uint_t )20, sizeof(ngx_table_elt_t ));
  }
#line 2255
  if (tmp___1 != 0L) {
#line 2259
    return ((ngx_int_t )-1);
  }
  {
#line 2262
  tmp___2 = ngx_list_init(& sr->headers_out.trailers, r->pool, (ngx_uint_t )4, sizeof(ngx_table_elt_t ));
  }
#line 2262
  if (tmp___2 != 0L) {
#line 2266
    return ((ngx_int_t )-1);
  }
#line 2269
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 2270
  sr->main_conf = (cscf->ctx)->main_conf;
#line 2271
  sr->srv_conf = (cscf->ctx)->srv_conf;
#line 2272
  sr->loc_conf = (cscf->ctx)->loc_conf;
#line 2274
  sr->pool = r->pool;
#line 2276
  sr->headers_in = r->headers_in;
#line 2278
  sr->headers_out.content_length_n = (off_t )-1;
#line 2278
  if (sr->headers_out.content_length) {
#line 2278
    (sr->headers_out.content_length)->hash = (ngx_uint_t )0;
#line 2278
    sr->headers_out.content_length = (ngx_table_elt_t *)((void *)0);
  }
#line 2279
  sr->allow_ranges = 0U;
#line 2279
  if (sr->headers_out.accept_ranges) {
#line 2279
    (sr->headers_out.accept_ranges)->hash = (ngx_uint_t )0;
#line 2279
    sr->headers_out.accept_ranges = (ngx_table_elt_t *)((void *)0);
  }
#line 2280
  sr->headers_out.last_modified_time = (time_t )-1;
#line 2280
  if (sr->headers_out.last_modified) {
#line 2280
    (sr->headers_out.last_modified)->hash = (ngx_uint_t )0;
#line 2280
    sr->headers_out.last_modified = (ngx_table_elt_t *)((void *)0);
  }
#line 2282
  sr->request_body = r->request_body;
#line 2288
  sr->method = (ngx_uint_t )2;
#line 2289
  sr->http_version = r->http_version;
#line 2291
  sr->request_line = r->request_line;
#line 2292
  sr->uri = *uri___0;
#line 2294
  if (args___0) {
#line 2295
    sr->args = *args___0;
  }
  {
#line 2301
  sr->subrequest_in_memory = (unsigned int )((flags & 2UL) != 0UL);
#line 2302
  sr->waited = (unsigned int )((flags & 4UL) != 0UL);
#line 2303
  sr->background = (unsigned int )((flags & 16UL) != 0UL);
#line 2305
  sr->unparsed_uri = r->unparsed_uri;
#line 2306
  sr->method_name = ngx_http_core_get_method;
#line 2307
  sr->http_protocol = r->http_protocol;
#line 2309
  ngx_http_set_exten(sr);
#line 2311
  sr->main = r->main;
#line 2312
  sr->parent = r;
#line 2313
  sr->post_subrequest = ps;
#line 2314
  sr->read_event_handler = & ngx_http_request_empty_handler;
#line 2315
  sr->write_event_handler = & ngx_http_handler;
#line 2317
  sr->variables = r->variables;
#line 2319
  sr->log_handler = r->log_handler;
  }
#line 2321
  if (! sr->background) {
#line 2322
    if ((unsigned long )c->data == (unsigned long )r) {
#line 2322
      if ((unsigned long )r->postponed == (unsigned long )((void *)0)) {
#line 2323
        c->data = (void *)sr;
      }
    }
    {
#line 2326
    tmp___3 = ngx_palloc(r->pool, sizeof(ngx_http_postponed_request_t ));
#line 2326
    pr = (ngx_http_postponed_request_t *)tmp___3;
    }
#line 2327
    if ((unsigned long )pr == (unsigned long )((void *)0)) {
#line 2328
      return ((ngx_int_t )-1);
    }
#line 2331
    pr->request = sr;
#line 2332
    pr->out = (ngx_chain_t *)((void *)0);
#line 2333
    pr->next = (ngx_http_postponed_request_t *)((void *)0);
#line 2335
    if (r->postponed) {
#line 2336
      p = r->postponed;
      {
#line 2336
      while (1) {
        while_continue: /* CIL Label */ ;
#line 2336
        if (! p->next) {
#line 2336
          goto while_break;
        }
#line 2336
        p = p->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 2337
      p->next = pr;
    } else {
#line 2340
      r->postponed = pr;
    }
  }
#line 2344
  sr->internal = 1U;
#line 2346
  sr->discard_body = r->discard_body;
#line 2347
  sr->expect_tested = 1U;
#line 2348
  sr->main_filter_need_in_memory = r->main_filter_need_in_memory;
#line 2350
  sr->uri_changes = 11U;
#line 2351
  sr->subrequests = r->subrequests - 1U;
#line 2353
  tp = (ngx_time_t *)ngx_cached_time;
#line 2354
  sr->start_sec = tp->sec;
#line 2355
  sr->start_msec = tp->msec;
#line 2357
  ((r->main)->count) ++;
#line 2359
  *psr = sr;
#line 2361
  if (flags & 8UL) {
    {
#line 2362
    sr->method = r->method;
#line 2363
    sr->method_name = r->method_name;
#line 2364
    sr->loc_conf = r->loc_conf;
#line 2365
    sr->valid_location = r->valid_location;
#line 2366
    sr->valid_unparsed_uri = r->valid_unparsed_uri;
#line 2367
    sr->content_handler = r->content_handler;
#line 2368
    sr->phase_handler = r->phase_handler;
#line 2369
    sr->write_event_handler = & ngx_http_core_run_phases;
#line 2371
    ngx_http_update_location_config(sr);
    }
  }
  {
#line 2374
  tmp___4 = ngx_http_post_request(sr, (ngx_http_posted_request_t *)((void *)0));
  }
#line 2374
  return (tmp___4);
}
}
#line 2378 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_internal_redirect(ngx_http_request_t *r , ngx_str_t *uri___0 ,
                                     ngx_str_t *args___0 ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  char *__cil_tmp5 ;

  {
#line 2384
  (r->uri_changes) --;
#line 2386
  if (r->uri_changes == 0U) {
#line 2387
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2387
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "rewrite or internal redirection cycle while internally redirecting to \"%V\"",
                         uri___0);
      }
    }
    {
#line 2391
    ((r->main)->count) ++;
#line 2392
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 2393
    return ((ngx_int_t )-4);
  }
#line 2396
  r->uri = *uri___0;
#line 2398
  if (args___0) {
#line 2399
    r->args = *args___0;
  } else {
#line 2402
    r->args.len = (size_t )0;
#line 2402
    r->args.data = (u_char *)((void *)0);
  }
  {
#line 2408
  ngx_http_set_exten(r);
#line 2411
  memset((void *)r->ctx, 0, sizeof(void *) * ngx_http_max_module);
#line 2413
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 2414
  r->loc_conf = (cscf->ctx)->loc_conf;
#line 2416
  ngx_http_update_location_config(r);
#line 2419
  r->cache = (ngx_http_cache_t *)((void *)0);
#line 2422
  r->internal = 1U;
#line 2423
  r->valid_unparsed_uri = 0U;
#line 2424
  r->add_uri_to_alias = 0U;
#line 2425
  ((r->main)->count) ++;
#line 2427
  ngx_http_handler(r);
  }
#line 2429
  return ((ngx_int_t )-4);
}
}
#line 2433 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_named_location(ngx_http_request_t *r , ngx_str_t *name ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_loc_conf_t **clcfp ;
  ngx_http_core_main_conf_t *cmcf ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 2440
  ((r->main)->count) ++;
#line 2441
  (r->uri_changes) --;
#line 2443
  if (r->uri_changes == 0U) {
#line 2444
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2444
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "rewrite or internal redirection cycle while redirect to named location \"%V\"",
                         name);
      }
    }
    {
#line 2448
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 2449
    return ((ngx_int_t )-4);
  }
#line 2452
  if (r->uri.len == 0UL) {
#line 2453
    if (((r->connection)->log)->log_level >= 4UL) {
      {
#line 2453
      ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "empty URI in redirect to named location \"%V\"",
                         name);
      }
    }
    {
#line 2456
    ngx_http_finalize_request(r, (ngx_int_t )500);
    }
#line 2457
    return ((ngx_int_t )-4);
  }
#line 2460
  cscf = (ngx_http_core_srv_conf_t *)*(r->srv_conf + ngx_http_core_module.ctx_index);
#line 2462
  if (cscf->named_locations) {
#line 2464
    clcfp = cscf->named_locations;
    {
#line 2464
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2464
      if (! *clcfp) {
#line 2464
        goto while_break;
      }
#line 2469
      if (name->len != (*clcfp)->name.len) {
#line 2472
        goto __Cont;
      } else {
        {
#line 2469
        tmp = strncmp((char const   *)name->data, (char const   *)(*clcfp)->name.data,
                      name->len);
        }
#line 2469
        if (tmp != 0) {
#line 2472
          goto __Cont;
        }
      }
      {
#line 2479
      r->internal = 1U;
#line 2480
      r->content_handler = (ngx_int_t (*)(ngx_http_request_t *r ))((void *)0);
#line 2481
      r->uri_changed = 0U;
#line 2482
      r->loc_conf = (*clcfp)->loc_conf;
#line 2485
      memset((void *)r->ctx, 0, sizeof(void *) * ngx_http_max_module);
#line 2487
      ngx_http_update_location_config(r);
#line 2489
      cmcf = (ngx_http_core_main_conf_t *)*(r->main_conf + ngx_http_core_module.ctx_index);
#line 2491
      r->phase_handler = (ngx_int_t )cmcf->phase_engine.location_rewrite_index;
#line 2493
      r->write_event_handler = & ngx_http_core_run_phases;
#line 2494
      ngx_http_core_run_phases(r);
      }
#line 2496
      return ((ngx_int_t )-4);
      __Cont: /* CIL Label */ 
#line 2464
      clcfp ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 2500
  if (((r->connection)->log)->log_level >= 4UL) {
    {
#line 2500
    ngx_log_error_core((ngx_uint_t )4, (r->connection)->log, 0, "could not find named location \"%V\"",
                       name);
    }
  }
  {
#line 2503
  ngx_http_finalize_request(r, (ngx_int_t )500);
  }
#line 2505
  return ((ngx_int_t )-4);
}
}
#line 2509 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_http_cleanup_t *ngx_http_cleanup_add(ngx_http_request_t *r , size_t size ) 
{ 
  ngx_http_cleanup_t *cln ;
  void *tmp ;

  {
  {
#line 2514
  r = r->main;
#line 2516
  tmp = ngx_palloc(r->pool, sizeof(ngx_http_cleanup_t ));
#line 2516
  cln = (ngx_http_cleanup_t *)tmp;
  }
#line 2517
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 2518
    return ((ngx_http_cleanup_t *)((void *)0));
  }
#line 2521
  if (size) {
    {
#line 2522
    cln->data = ngx_palloc(r->pool, size);
    }
#line 2523
    if ((unsigned long )cln->data == (unsigned long )((void *)0)) {
#line 2524
      return ((ngx_http_cleanup_t *)((void *)0));
    }
  } else {
#line 2528
    cln->data = (void *)0;
  }
#line 2531
  cln->handler = (void (*)(void *data ))((void *)0);
#line 2532
  cln->next = r->cleanup;
#line 2534
  r->cleanup = cln;
#line 2539
  return (cln);
}
}
#line 2543 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_set_disable_symlinks(ngx_http_request_t *r , ngx_http_core_loc_conf_t *clcf ,
                                        ngx_str_t *path , ngx_open_file_info_t *of ) 
{ 
  u_char *p ;
  ngx_str_t from ;
  ngx_int_t tmp ;
  int tmp___0 ;

  {
#line 2551
  of->disable_symlinks = (unsigned int )clcf->disable_symlinks;
#line 2553
  if ((unsigned long )clcf->disable_symlinks_from == (unsigned long )((void *)0)) {
#line 2554
    return ((ngx_int_t )0);
  }
  {
#line 2557
  tmp = ngx_http_complex_value(r, clcf->disable_symlinks_from, & from);
  }
#line 2557
  if (tmp != 0L) {
#line 2560
    return ((ngx_int_t )-1);
  }
#line 2563
  if (from.len == 0UL) {
#line 2567
    return ((ngx_int_t )0);
  } else
#line 2563
  if (from.len > path->len) {
#line 2567
    return ((ngx_int_t )0);
  } else {
    {
#line 2563
    tmp___0 = memcmp((void const   *)((char const   *)path->data), (void const   *)((char const   *)from.data),
                     from.len);
    }
#line 2563
    if (tmp___0 != 0) {
#line 2567
      return ((ngx_int_t )0);
    }
  }
#line 2570
  if (from.len == path->len) {
#line 2571
    of->disable_symlinks = 0U;
#line 2572
    return ((ngx_int_t )0);
  }
#line 2575
  p = path->data + from.len;
#line 2577
  if ((int )*p == 47) {
#line 2578
    of->disable_symlinks_from = from.len;
#line 2579
    return ((ngx_int_t )0);
  }
#line 2582
  p --;
#line 2584
  if ((int )*p == 47) {
#line 2585
    of->disable_symlinks_from = from.len - 1UL;
  }
#line 2589
  return ((ngx_int_t )0);
}
}
#line 2593 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
ngx_int_t ngx_http_get_forwarded_addr(ngx_http_request_t *r , ngx_addr_t *addr , ngx_array_t *headers ,
                                      ngx_str_t *value , ngx_array_t *proxies , int recursive ) 
{ 
  ngx_int_t rc ;
  ngx_uint_t i ;
  ngx_uint_t found ;
  ngx_table_elt_t **h ;
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;

  {
#line 2602
  if ((unsigned long )headers == (unsigned long )((void *)0)) {
    {
#line 2603
    tmp = ngx_http_get_forwarded_addr_internal(r, addr, value->data, value->len, proxies,
                                               recursive);
    }
#line 2603
    return (tmp);
  }
#line 2608
  i = headers->nelts;
#line 2609
  h = (ngx_table_elt_t **)headers->elts;
#line 2611
  rc = (ngx_int_t )-5;
#line 2613
  found = (ngx_uint_t )0;
  {
#line 2615
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2615
    tmp___0 = i;
#line 2615
    i --;
#line 2615
    if (! (tmp___0 > 0UL)) {
#line 2615
      goto while_break;
    }
    {
#line 2616
    rc = ngx_http_get_forwarded_addr_internal(r, addr, (*(h + i))->value.data, (*(h + i))->value.len,
                                              proxies, recursive);
    }
#line 2620
    if (! recursive) {
#line 2621
      goto while_break;
    }
#line 2624
    if (rc == -5L) {
#line 2624
      if (found) {
#line 2625
        rc = (ngx_int_t )-4;
#line 2626
        goto while_break;
      }
    }
#line 2629
    if (rc != 0L) {
#line 2630
      goto while_break;
    }
#line 2633
    found = (ngx_uint_t )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2636
  return (rc);
}
}
#line 2640 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_get_forwarded_addr_internal(ngx_http_request_t *r , ngx_addr_t *addr ,
                                                      u_char *xff , size_t xfflen ,
                                                      ngx_array_t *proxies , int recursive ) 
{ 
  u_char *p ;
  ngx_int_t rc ;
  ngx_addr_t paddr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 2648
  tmp = ngx_cidr_match(addr->sockaddr, proxies);
  }
#line 2648
  if (tmp != 0L) {
#line 2649
    return ((ngx_int_t )-5);
  }
#line 2652
  p = (xff + xfflen) - 1;
  {
#line 2652
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2652
    if (! ((unsigned long )p > (unsigned long )xff)) {
#line 2652
      goto while_break;
    }
#line 2653
    if ((int )*p != 32) {
#line 2653
      if ((int )*p != 44) {
#line 2654
        goto while_break;
      }
    }
#line 2652
    p --;
#line 2652
    xfflen --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2658
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2658
    if (! ((unsigned long )p > (unsigned long )xff)) {
#line 2658
      goto while_break___0;
    }
#line 2659
    if ((int )*p == 32) {
#line 2660
      p ++;
#line 2661
      goto while_break___0;
    } else
#line 2659
    if ((int )*p == 44) {
#line 2660
      p ++;
#line 2661
      goto while_break___0;
    }
#line 2658
    p --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2665
  tmp___0 = ngx_parse_addr_port(r->pool, & paddr, p, xfflen - (size_t )(p - xff));
  }
#line 2665
  if (tmp___0 != 0L) {
#line 2666
    return ((ngx_int_t )-5);
  }
#line 2669
  *addr = paddr;
#line 2671
  if (recursive) {
#line 2671
    if ((unsigned long )p > (unsigned long )xff) {
      {
#line 2672
      rc = ngx_http_get_forwarded_addr_internal(r, addr, xff, (size_t )((p - 1) - xff),
                                                proxies, 1);
      }
#line 2675
      if (rc == -5L) {
#line 2676
        return ((ngx_int_t )-4);
      }
#line 2680
      return (rc);
    }
  }
#line 2683
  return ((ngx_int_t )0);
}
}
#line 2687 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_server(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) 
{ 
  char *rv ;
  void *mconf ;
  ngx_uint_t i ;
  ngx_conf_t pcf ;
  ngx_http_module_t *module ;
  struct sockaddr_in *sin ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *http_ctx ;
  ngx_http_listen_opt_t lsopt ;
  ngx_http_core_srv_conf_t *cscf ;
  ngx_http_core_srv_conf_t **cscfp ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___4 ;
  __uid_t tmp___5 ;
  ngx_int_t tmp___6 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  void *__cil_tmp26 ;
  void *__cil_tmp27 ;
  void *__cil_tmp28 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 2701
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 2701
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 2702
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2703
    return ((char *)((void *)-1));
  }
  {
#line 2706
  http_ctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 2707
  ctx->main_conf = http_ctx->main_conf;
#line 2711
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 2711
  ctx->srv_conf = (void **)tmp___0;
  }
#line 2712
  if ((unsigned long )ctx->srv_conf == (unsigned long )((void *)0)) {
#line 2713
    return ((char *)((void *)-1));
  }
  {
#line 2718
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 2718
  ctx->loc_conf = (void **)tmp___1;
  }
#line 2719
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 2720
    return ((char *)((void *)-1));
  }
#line 2723
  i = (ngx_uint_t )0;
  {
#line 2723
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2723
    if (! *((cf->cycle)->modules + i)) {
#line 2723
      goto while_break;
    }
#line 2724
    if ((*((cf->cycle)->modules + i))->type != 1347703880UL) {
#line 2725
      goto __Cont;
    }
#line 2728
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 2730
    if (module->create_srv_conf) {
      {
#line 2731
      mconf = (*(module->create_srv_conf))(cf);
      }
#line 2732
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 2733
        return ((char *)((void *)-1));
      }
#line 2736
      *(ctx->srv_conf + (*((cf->cycle)->modules + i))->ctx_index) = mconf;
    }
#line 2739
    if (module->create_loc_conf) {
      {
#line 2740
      mconf = (*(module->create_loc_conf))(cf);
      }
#line 2741
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 2742
        return ((char *)((void *)-1));
      }
#line 2745
      *(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) = mconf;
    }
    __Cont: /* CIL Label */ 
#line 2723
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2752
  cscf = (ngx_http_core_srv_conf_t *)*(ctx->srv_conf + ngx_http_core_module.ctx_index);
#line 2753
  cscf->ctx = ctx;
#line 2756
  cmcf = (ngx_http_core_main_conf_t *)*(ctx->main_conf + ngx_http_core_module.ctx_index);
#line 2758
  tmp___2 = ngx_array_push(& cmcf->servers);
#line 2758
  cscfp = (ngx_http_core_srv_conf_t **)tmp___2;
  }
#line 2759
  if ((unsigned long )cscfp == (unsigned long )((void *)0)) {
#line 2760
    return ((char *)((void *)-1));
  }
  {
#line 2763
  *cscfp = cscf;
#line 2768
  pcf = *cf;
#line 2769
  cf->ctx = (void *)ctx;
#line 2770
  cf->cmd_type = (ngx_uint_t )67108864;
#line 2772
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 2774
  *cf = pcf;
  }
#line 2776
  if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 2776
    if (! cscf->listen) {
      {
#line 2777
      memset((void *)(& lsopt), 0, sizeof(ngx_http_listen_opt_t ));
#line 2779
      sin = & lsopt.sockaddr.sockaddr_in;
#line 2781
      sin->sin_family = (sa_family_t )2;
#line 2785
      tmp___5 = getuid();
      }
#line 2785
      if (tmp___5 == 0U) {
#line 2785
        tmp___4 = 80;
      } else {
#line 2785
        tmp___4 = 8000;
      }
      {
#line 2785
      sin->sin_port = htons((uint16_t )tmp___4);
#line 2787
      sin->sin_addr.s_addr = (in_addr_t )0;
#line 2789
      lsopt.socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 2791
      lsopt.backlog = 511;
#line 2792
      lsopt.rcvbuf = -1;
#line 2793
      lsopt.sndbuf = -1;
#line 2798
      lsopt.fastopen = -1;
#line 2800
      lsopt.wildcard = 1U;
#line 2802
      ngx_sock_ntop(& lsopt.sockaddr.sockaddr, lsopt.socklen, lsopt.addr, ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path),
                    (ngx_uint_t )1);
#line 2805
      tmp___6 = ngx_http_add_listen(cf, cscf, & lsopt);
      }
#line 2805
      if (tmp___6 != 0L) {
#line 2806
        return ((char *)((void *)-1));
      }
    }
  }
#line 2810
  return (rv);
}
}
#line 2814 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_location(ngx_conf_t *cf , ngx_command_t *cmd , void *dummy ) 
{ 
  char *rv ;
  u_char *mod ;
  size_t len ;
  ngx_str_t *value ;
  ngx_str_t *name ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *pctx ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_loc_conf_t *pclcf ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 2827
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 2827
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 2828
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 2829
    return ((char *)((void *)-1));
  }
  {
#line 2832
  pctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 2833
  ctx->main_conf = pctx->main_conf;
#line 2834
  ctx->srv_conf = pctx->srv_conf;
#line 2836
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 2836
  ctx->loc_conf = (void **)tmp___0;
  }
#line 2837
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 2838
    return ((char *)((void *)-1));
  }
#line 2841
  i = (ngx_uint_t )0;
  {
#line 2841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2841
    if (! *((cf->cycle)->modules + i)) {
#line 2841
      goto while_break;
    }
#line 2842
    if ((*((cf->cycle)->modules + i))->type != 1347703880UL) {
#line 2843
      goto __Cont;
    }
#line 2846
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 2848
    if (module->create_loc_conf) {
      {
#line 2849
      *(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) = (*(module->create_loc_conf))(cf);
      }
#line 2851
      if ((unsigned long )*(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) == (unsigned long )((void *)0)) {
#line 2852
        return ((char *)((void *)-1));
      }
    }
    __Cont: /* CIL Label */ 
#line 2841
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2857
  clcf = (ngx_http_core_loc_conf_t *)*(ctx->loc_conf + ngx_http_core_module.ctx_index);
#line 2858
  clcf->loc_conf = ctx->loc_conf;
#line 2860
  value = (ngx_str_t *)(cf->args)->elts;
#line 2862
  if ((cf->args)->nelts == 3UL) {
#line 2864
    len = (value + 1)->len;
#line 2865
    mod = (value + 1)->data;
#line 2866
    name = value + 2;
#line 2868
    if (len == 1UL) {
#line 2868
      if ((int )*(mod + 0) == 61) {
#line 2870
        clcf->name = *name;
#line 2871
        clcf->exact_match = 1U;
      } else {
#line 2868
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 2873
    if (len == 2UL) {
#line 2873
      if ((int )*(mod + 0) == 94) {
#line 2873
        if ((int )*(mod + 1) == 126) {
#line 2875
          clcf->name = *name;
#line 2876
          clcf->noregex = 1U;
        } else {
#line 2873
          goto _L___1;
        }
      } else {
#line 2873
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 2878
    if (len == 1UL) {
#line 2878
      if ((int )*(mod + 0) == 126) {
        {
#line 2880
        tmp___1 = ngx_http_core_regex_location(cf, clcf, name, (ngx_uint_t )0);
        }
#line 2880
        if (tmp___1 != 0L) {
#line 2881
          return ((char *)((void *)-1));
        }
      } else {
#line 2878
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 2884
    if (len == 2UL) {
#line 2884
      if ((int )*(mod + 0) == 126) {
#line 2884
        if ((int )*(mod + 1) == 42) {
          {
#line 2886
          tmp___2 = ngx_http_core_regex_location(cf, clcf, name, (ngx_uint_t )1);
          }
#line 2886
          if (tmp___2 != 0L) {
#line 2887
            return ((char *)((void *)-1));
          }
        } else {
          {
#line 2891
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid location modifier \"%V\"",
                             value + 1);
          }
#line 2893
          return ((char *)((void *)-1));
        }
      } else {
        {
#line 2891
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid location modifier \"%V\"",
                           value + 1);
        }
#line 2893
        return ((char *)((void *)-1));
      }
    } else {
      {
#line 2891
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid location modifier \"%V\"",
                         value + 1);
      }
#line 2893
      return ((char *)((void *)-1));
    }
  } else {
#line 2898
    name = value + 1;
#line 2900
    if ((int )*(name->data + 0) == 61) {
#line 2902
      clcf->name.len = name->len - 1UL;
#line 2903
      clcf->name.data = name->data + 1;
#line 2904
      clcf->exact_match = 1U;
    } else
#line 2906
    if ((int )*(name->data + 0) == 94) {
#line 2906
      if ((int )*(name->data + 1) == 126) {
#line 2908
        clcf->name.len = name->len - 2UL;
#line 2909
        clcf->name.data = name->data + 2;
#line 2910
        clcf->noregex = 1U;
      } else {
#line 2906
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 2912
    if ((int )*(name->data + 0) == 126) {
#line 2914
      (name->len) --;
#line 2915
      (name->data) ++;
#line 2917
      if ((int )*(name->data + 0) == 42) {
        {
#line 2919
        (name->len) --;
#line 2920
        (name->data) ++;
#line 2922
        tmp___3 = ngx_http_core_regex_location(cf, clcf, name, (ngx_uint_t )1);
        }
#line 2922
        if (tmp___3 != 0L) {
#line 2923
          return ((char *)((void *)-1));
        }
      } else {
        {
#line 2927
        tmp___4 = ngx_http_core_regex_location(cf, clcf, name, (ngx_uint_t )0);
        }
#line 2927
        if (tmp___4 != 0L) {
#line 2928
          return ((char *)((void *)-1));
        }
      }
    } else {
#line 2934
      clcf->name = *name;
#line 2936
      if ((int )*(name->data + 0) == 64) {
#line 2937
        clcf->named = 1U;
      }
    }
  }
#line 2942
  pclcf = (ngx_http_core_loc_conf_t *)*(pctx->loc_conf + ngx_http_core_module.ctx_index);
#line 2944
  if (cf->cmd_type == 134217728UL) {
#line 2952
    if (pclcf->exact_match) {
      {
#line 2953
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "location \"%V\" cannot be inside the exact location \"%V\"",
                         & clcf->name, & pclcf->name);
      }
#line 2957
      return ((char *)((void *)-1));
    }
#line 2960
    if (pclcf->named) {
      {
#line 2961
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "location \"%V\" cannot be inside the named location \"%V\"",
                         & clcf->name, & pclcf->name);
      }
#line 2965
      return ((char *)((void *)-1));
    }
#line 2968
    if (clcf->named) {
      {
#line 2969
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "named location \"%V\" can be on the server level only",
                         & clcf->name);
      }
#line 2973
      return ((char *)((void *)-1));
    }
#line 2976
    len = pclcf->name.len;
#line 2979
    if ((unsigned long )clcf->regex == (unsigned long )((void *)0)) {
      {
#line 2979
      tmp___5 = ngx_filename_cmp(clcf->name.data, pclcf->name.data, len);
      }
#line 2979
      if (tmp___5 != 0L) {
        {
#line 2985
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "location \"%V\" is outside location \"%V\"",
                           & clcf->name, & pclcf->name);
        }
#line 2988
        return ((char *)((void *)-1));
      }
    }
  }
  {
#line 2992
  tmp___6 = ngx_http_add_location(cf, & pclcf->locations, clcf);
  }
#line 2992
  if (tmp___6 != 0L) {
#line 2993
    return ((char *)((void *)-1));
  }
  {
#line 2996
  save = *cf;
#line 2997
  cf->ctx = (void *)ctx;
#line 2998
  cf->cmd_type = (ngx_uint_t )134217728;
#line 3000
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 3002
  *cf = save;
  }
#line 3004
  return (rv);
}
}
#line 3008 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_regex_location(ngx_conf_t *cf , ngx_http_core_loc_conf_t *clcf ,
                                              ngx_str_t *regex , ngx_uint_t caseless ) 
{ 
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;
  void *__cil_tmp7 ;

  {
  {
#line 3016
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 3018
  rc.pattern = *regex;
#line 3019
  rc.err.len = (size_t )1024;
#line 3020
  rc.err.data = errstr;
  }
#line 3025
  if (caseless) {
#line 3025
    rc.options = (ngx_int_t )1;
  } else {
#line 3025
    rc.options = (ngx_int_t )0;
  }
  {
#line 3028
  clcf->regex = ngx_http_regex_compile(cf, & rc);
  }
#line 3029
  if ((unsigned long )clcf->regex == (unsigned long )((void *)0)) {
#line 3030
    return ((ngx_int_t )-1);
  }
#line 3033
  clcf->name = *regex;
#line 3035
  return ((ngx_int_t )0);
}
}
#line 3048 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_types(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  char *rv ;
  ngx_conf_t save ;

  {
#line 3051
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 3056
  if ((unsigned long )clcf->types == (unsigned long )((void *)0)) {
    {
#line 3057
    clcf->types = ngx_array_create(cf->pool, (ngx_uint_t )64, sizeof(ngx_hash_key_t ));
    }
#line 3058
    if ((unsigned long )clcf->types == (unsigned long )((void *)0)) {
#line 3059
      return ((char *)((void *)-1));
    }
  }
  {
#line 3063
  save = *cf;
#line 3064
  cf->handler = & ngx_http_core_type;
#line 3065
  cf->handler_conf = conf;
#line 3067
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 3069
  *cf = save;
  }
#line 3071
  return (rv);
}
}
#line 3075 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_type(ngx_conf_t *cf , ngx_command_t *dummy , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_str_t *content_type ;
  ngx_str_t *old ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t hash ;
  ngx_hash_key_t *type ;
  char *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 3078
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 3084
  value = (ngx_str_t *)(cf->args)->elts;
#line 3086
  tmp___0 = strcmp((char const   *)(value + 0)->data, "include");
  }
#line 3086
  if (tmp___0 == 0) {
#line 3087
    if ((cf->args)->nelts != 2UL) {
      {
#line 3088
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of arguments in \"include\" directive");
      }
#line 3091
      return ((char *)((void *)-1));
    }
    {
#line 3094
    tmp = ngx_conf_include(cf, dummy, conf);
    }
#line 3094
    return (tmp);
  }
  {
#line 3097
  tmp___1 = ngx_palloc(cf->pool, sizeof(ngx_str_t ));
#line 3097
  content_type = (ngx_str_t *)tmp___1;
  }
#line 3098
  if ((unsigned long )content_type == (unsigned long )((void *)0)) {
#line 3099
    return ((char *)((void *)-1));
  }
#line 3102
  *content_type = *(value + 0);
#line 3104
  i = (ngx_uint_t )1;
  {
#line 3104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3104
    if (! (i < (cf->args)->nelts)) {
#line 3104
      goto while_break;
    }
    {
#line 3106
    hash = ngx_hash_strlow((value + i)->data, (value + i)->data, (value + i)->len);
#line 3108
    type = (ngx_hash_key_t *)(clcf->types)->elts;
#line 3109
    n = (ngx_uint_t )0;
    }
    {
#line 3109
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3109
      if (! (n < (clcf->types)->nelts)) {
#line 3109
        goto while_break___0;
      }
      {
#line 3110
      tmp___2 = strcmp((char const   *)(value + i)->data, (char const   *)(type + n)->key.data);
      }
#line 3110
      if (tmp___2 == 0) {
        {
#line 3111
        old = (ngx_str_t *)(type + n)->value;
#line 3112
        (type + n)->value = (void *)content_type;
#line 3114
        ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate extension \"%V\", content type: \"%V\", previous content type: \"%V\"",
                           value + i, content_type, old);
        }
#line 3119
        goto next;
      }
#line 3109
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 3124
    tmp___3 = ngx_array_push(clcf->types);
#line 3124
    type = (ngx_hash_key_t *)tmp___3;
    }
#line 3125
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 3126
      return ((char *)((void *)-1));
    }
#line 3129
    type->key = *(value + i);
#line 3130
    type->key_hash = hash;
#line 3131
    type->value = (void *)content_type;
    next: 
#line 3134
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 3104
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3137
  return ((char *)((void *)0));
}
}
#line 3141 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_preconfiguration(ngx_conf_t *cf ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 3144
  tmp = ngx_http_variables_add_core_vars(cf);
  }
#line 3144
  return (tmp);
}
}
#line 3148 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_int_t ngx_http_core_postconfiguration(ngx_conf_t *cf ) 
{ 


  {
#line 3151
  ngx_http_top_request_body_filter = & ngx_http_request_body_save_filter;
#line 3153
  return ((ngx_int_t )0);
}
}
#line 3157 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static void *ngx_http_core_create_main_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 3162
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_main_conf_t ));
#line 3162
  cmcf = (ngx_http_core_main_conf_t *)tmp;
  }
#line 3163
  if ((unsigned long )cmcf == (unsigned long )((void *)0)) {
#line 3164
    return ((void *)0);
  }
  {
#line 3167
  tmp___0 = ngx_array_init(& cmcf->servers, cf->pool, (ngx_uint_t )4, sizeof(ngx_http_core_srv_conf_t *));
  }
#line 3167
  if (tmp___0 != 0L) {
#line 3171
    return ((void *)0);
  }
#line 3174
  cmcf->server_names_hash_max_size = (ngx_uint_t )-1;
#line 3175
  cmcf->server_names_hash_bucket_size = (ngx_uint_t )-1;
#line 3177
  cmcf->variables_hash_max_size = (ngx_uint_t )-1;
#line 3178
  cmcf->variables_hash_bucket_size = (ngx_uint_t )-1;
#line 3180
  return ((void *)cmcf);
}
}
#line 3184 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_init_main_conf(ngx_conf_t *cf , void *conf ) 
{ 
  ngx_http_core_main_conf_t *cmcf ;

  {
#line 3187
  cmcf = (ngx_http_core_main_conf_t *)conf;
#line 3189
  if (cmcf->server_names_hash_max_size == 0xffffffffffffffffUL) {
#line 3189
    cmcf->server_names_hash_max_size = (ngx_uint_t )512;
  }
#line 3190
  if (cmcf->server_names_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3190
    cmcf->server_names_hash_bucket_size = ngx_cacheline_size;
  }
#line 3193
  cmcf->server_names_hash_bucket_size = (cmcf->server_names_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3197
  if (cmcf->variables_hash_max_size == 0xffffffffffffffffUL) {
#line 3197
    cmcf->variables_hash_max_size = (ngx_uint_t )1024;
  }
#line 3198
  if (cmcf->variables_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3198
    cmcf->variables_hash_bucket_size = (ngx_uint_t )64;
  }
#line 3200
  cmcf->variables_hash_bucket_size = (cmcf->variables_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3203
  if (cmcf->ncaptures) {
#line 3204
    cmcf->ncaptures = (cmcf->ncaptures + 1UL) * 3UL;
  }
#line 3207
  return ((char *)((void *)0));
}
}
#line 3211 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static void *ngx_http_core_create_srv_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 3216
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_srv_conf_t ));
#line 3216
  cscf = (ngx_http_core_srv_conf_t *)tmp;
  }
#line 3217
  if ((unsigned long )cscf == (unsigned long )((void *)0)) {
#line 3218
    return ((void *)0);
  }
  {
#line 3227
  tmp___0 = ngx_array_init(& cscf->server_names, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_server_name_t ));
  }
#line 3227
  if (tmp___0 != 0L) {
#line 3231
    return ((void *)0);
  }
#line 3234
  cscf->connection_pool_size = (size_t )-1;
#line 3235
  cscf->request_pool_size = (size_t )-1;
#line 3236
  cscf->client_header_timeout = (ngx_msec_t )-1;
#line 3237
  cscf->client_header_buffer_size = (size_t )-1;
#line 3238
  cscf->ignore_invalid_headers = (ngx_flag_t )-1;
#line 3239
  cscf->merge_slashes = (ngx_flag_t )-1;
#line 3240
  cscf->underscores_in_headers = (ngx_flag_t )-1;
#line 3242
  return ((void *)cscf);
}
}
#line 3246 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_merge_srv_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_core_srv_conf_t *prev ;
  ngx_http_core_srv_conf_t *conf ;
  ngx_str_t name ;
  ngx_http_server_name_t *sn ;
  void *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 3249
  prev = (ngx_http_core_srv_conf_t *)parent;
#line 3250
  conf = (ngx_http_core_srv_conf_t *)child;
#line 3257
  if (conf->connection_pool_size == 0xffffffffffffffffUL) {
#line 3257
    if (prev->connection_pool_size == 0xffffffffffffffffUL) {
#line 3257
      conf->connection_pool_size = 64UL * sizeof(void *);
    } else {
#line 3257
      conf->connection_pool_size = prev->connection_pool_size;
    }
  }
#line 3259
  if (conf->request_pool_size == 0xffffffffffffffffUL) {
#line 3259
    if (prev->request_pool_size == 0xffffffffffffffffUL) {
#line 3259
      conf->request_pool_size = (size_t )4096;
    } else {
#line 3259
      conf->request_pool_size = prev->request_pool_size;
    }
  }
#line 3261
  if (conf->client_header_timeout == 0xffffffffffffffffUL) {
#line 3261
    if (prev->client_header_timeout == 0xffffffffffffffffUL) {
#line 3261
      conf->client_header_timeout = (ngx_msec_t )60000;
    } else {
#line 3261
      conf->client_header_timeout = prev->client_header_timeout;
    }
  }
#line 3263
  if (conf->client_header_buffer_size == 0xffffffffffffffffUL) {
#line 3263
    if (prev->client_header_buffer_size == 0xffffffffffffffffUL) {
#line 3263
      conf->client_header_buffer_size = (size_t )1024;
    } else {
#line 3263
      conf->client_header_buffer_size = prev->client_header_buffer_size;
    }
  }
#line 3265
  if (conf->large_client_header_buffers.num == 0L) {
#line 3265
    if (prev->large_client_header_buffers.num) {
#line 3265
      conf->large_client_header_buffers.num = prev->large_client_header_buffers.num;
#line 3265
      conf->large_client_header_buffers.size = prev->large_client_header_buffers.size;
    } else {
#line 3265
      conf->large_client_header_buffers.num = (ngx_int_t )4;
#line 3265
      conf->large_client_header_buffers.size = (size_t )8192;
    }
  }
#line 3269
  if (conf->large_client_header_buffers.size < conf->connection_pool_size) {
    {
#line 3270
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"large_client_header_buffers\" size must be equal to or greater than \"connection_pool_size\"");
    }
#line 3273
    return ((char *)((void *)-1));
  }
#line 3276
  if (conf->ignore_invalid_headers == -1L) {
#line 3276
    if (prev->ignore_invalid_headers == -1L) {
#line 3276
      conf->ignore_invalid_headers = (ngx_flag_t )1;
    } else {
#line 3276
      conf->ignore_invalid_headers = prev->ignore_invalid_headers;
    }
  }
#line 3279
  if (conf->merge_slashes == -1L) {
#line 3279
    if (prev->merge_slashes == -1L) {
#line 3279
      conf->merge_slashes = (ngx_flag_t )1;
    } else {
#line 3279
      conf->merge_slashes = prev->merge_slashes;
    }
  }
#line 3281
  if (conf->underscores_in_headers == -1L) {
#line 3281
    if (prev->underscores_in_headers == -1L) {
#line 3281
      conf->underscores_in_headers = (ngx_flag_t )0;
    } else {
#line 3281
      conf->underscores_in_headers = prev->underscores_in_headers;
    }
  }
#line 3284
  if (conf->server_names.nelts == 0UL) {
    {
#line 3286
    tmp = ngx_array_push(& conf->server_names);
#line 3286
    sn = (ngx_http_server_name_t *)tmp;
#line 3288
    sn->regex = (ngx_http_regex_t *)((void *)0);
#line 3290
    sn->server = conf;
#line 3291
    sn->name.len = sizeof("") - 1UL;
#line 3291
    sn->name.data = (u_char *)"";
    }
  }
#line 3294
  sn = (ngx_http_server_name_t *)conf->server_names.elts;
#line 3295
  name = (sn + 0)->name;
#line 3298
  if (sn->regex) {
#line 3299
    (name.len) ++;
#line 3300
    (name.data) --;
  } else
#line 3304
  if ((int )*(name.data + 0) == 46) {
#line 3305
    (name.len) --;
#line 3306
    (name.data) ++;
  }
  {
#line 3309
  conf->server_name.len = name.len;
#line 3310
  conf->server_name.data = ngx_pstrdup(cf->pool, & name);
  }
#line 3311
  if ((unsigned long )conf->server_name.data == (unsigned long )((void *)0)) {
#line 3312
    return ((char *)((void *)-1));
  }
#line 3315
  return ((char *)((void *)0));
}
}
#line 3319 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static void *ngx_http_core_create_loc_conf(ngx_conf_t *cf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  void *tmp ;

  {
  {
#line 3324
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_core_loc_conf_t ));
#line 3324
  clcf = (ngx_http_core_loc_conf_t *)tmp;
  }
#line 3325
  if ((unsigned long )clcf == (unsigned long )((void *)0)) {
#line 3326
    return ((void *)0);
  }
#line 3348
  clcf->client_max_body_size = (off_t )-1;
#line 3349
  clcf->client_body_buffer_size = (size_t )-1;
#line 3350
  clcf->client_body_timeout = (ngx_msec_t )-1;
#line 3351
  clcf->satisfy = (ngx_uint_t )-1;
#line 3352
  clcf->if_modified_since = (ngx_uint_t )-1;
#line 3353
  clcf->max_ranges = (ngx_uint_t )-1;
#line 3354
  clcf->client_body_in_file_only = (ngx_uint_t )-1;
#line 3355
  clcf->client_body_in_single_buffer = (ngx_flag_t )-1;
#line 3356
  clcf->internal = (ngx_flag_t )-1;
#line 3357
  clcf->sendfile = (ngx_flag_t )-1;
#line 3358
  clcf->sendfile_max_chunk = (size_t )-1;
#line 3359
  clcf->aio = (ngx_flag_t )-1;
#line 3360
  clcf->aio_write = (ngx_flag_t )-1;
#line 3365
  clcf->read_ahead = (size_t )-1;
#line 3366
  clcf->directio = (off_t )-1;
#line 3367
  clcf->directio_alignment = (off_t )-1;
#line 3368
  clcf->tcp_nopush = (ngx_flag_t )-1;
#line 3369
  clcf->tcp_nodelay = (ngx_flag_t )-1;
#line 3370
  clcf->send_timeout = (ngx_msec_t )-1;
#line 3371
  clcf->send_lowat = (size_t )-1;
#line 3372
  clcf->postpone_output = (size_t )-1;
#line 3373
  clcf->limit_rate = (size_t )-1;
#line 3374
  clcf->limit_rate_after = (size_t )-1;
#line 3375
  clcf->keepalive_timeout = (ngx_msec_t )-1;
#line 3376
  clcf->keepalive_header = (time_t )-1;
#line 3377
  clcf->keepalive_requests = (ngx_uint_t )-1;
#line 3378
  clcf->lingering_close = (ngx_uint_t )-1;
#line 3379
  clcf->lingering_time = (ngx_msec_t )-1;
#line 3380
  clcf->lingering_timeout = (ngx_msec_t )-1;
#line 3381
  clcf->resolver_timeout = (ngx_msec_t )-1;
#line 3382
  clcf->reset_timedout_connection = (ngx_flag_t )-1;
#line 3383
  clcf->absolute_redirect = (ngx_flag_t )-1;
#line 3384
  clcf->server_name_in_redirect = (ngx_flag_t )-1;
#line 3385
  clcf->port_in_redirect = (ngx_flag_t )-1;
#line 3386
  clcf->msie_padding = (ngx_flag_t )-1;
#line 3387
  clcf->msie_refresh = (ngx_flag_t )-1;
#line 3388
  clcf->log_not_found = (ngx_flag_t )-1;
#line 3389
  clcf->log_subrequest = (ngx_flag_t )-1;
#line 3390
  clcf->recursive_error_pages = (ngx_flag_t )-1;
#line 3391
  clcf->chunked_transfer_encoding = (ngx_flag_t )-1;
#line 3392
  clcf->etag = (ngx_flag_t )-1;
#line 3393
  clcf->server_tokens = (ngx_uint_t )-1;
#line 3394
  clcf->types_hash_max_size = (ngx_uint_t )-1;
#line 3395
  clcf->types_hash_bucket_size = (ngx_uint_t )-1;
#line 3397
  clcf->open_file_cache = (ngx_open_file_cache_t *)((void *)-1);
#line 3398
  clcf->open_file_cache_valid = (time_t )-1;
#line 3399
  clcf->open_file_cache_min_uses = (ngx_uint_t )-1;
#line 3400
  clcf->open_file_cache_errors = (ngx_flag_t )-1;
#line 3401
  clcf->open_file_cache_events = (ngx_flag_t )-1;
#line 3404
  clcf->gzip_vary = (ngx_flag_t )-1;
#line 3405
  clcf->gzip_http_version = (ngx_uint_t )-1;
#line 3407
  clcf->gzip_disable = (ngx_array_t *)((void *)-1);
#line 3409
  clcf->gzip_disable_msie6 = 3U;
#line 3416
  clcf->disable_symlinks = (ngx_uint_t )-1;
#line 3417
  clcf->disable_symlinks_from = (ngx_http_complex_value_t *)((void *)-1);
#line 3420
  return ((void *)clcf);
}
}
#line 3424 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_core_text_html_type  =    {sizeof("text/html") - 1UL, (u_char *)"text/html"};
#line 3425 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_core_image_gif_type  =    {sizeof("image/gif") - 1UL, (u_char *)"image/gif"};
#line 3426 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_str_t ngx_http_core_image_jpeg_type  =    {sizeof("image/jpeg") - 1UL, (u_char *)"image/jpeg"};
#line 3428 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_hash_key_t ngx_http_core_default_types[4]  = {      {{sizeof("html") - 1UL, (u_char *)"html"}, (ngx_uint_t )0, (void *)(& ngx_http_core_text_html_type)}, 
        {{sizeof("gif") - 1UL,
       (u_char *)"gif"}, (ngx_uint_t )0, (void *)(& ngx_http_core_image_gif_type)}, 
        {{sizeof("jpg") - 1UL,
       (u_char *)"jpg"}, (ngx_uint_t )0, (void *)(& ngx_http_core_image_jpeg_type)}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (void *)0}};
#line 3436 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_merge_loc_conf(ngx_conf_t *cf , void *parent , void *child ) 
{ 
  ngx_http_core_loc_conf_t *prev ;
  ngx_http_core_loc_conf_t *conf ;
  ngx_uint_t i ;
  ngx_hash_key_t *type ;
  ngx_hash_init_t types_hash ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 3439
  prev = (ngx_http_core_loc_conf_t *)parent;
#line 3440
  conf = (ngx_http_core_loc_conf_t *)child;
#line 3446
  if ((unsigned long )conf->root.data == (unsigned long )((void *)0)) {
#line 3448
    conf->alias = prev->alias;
#line 3449
    conf->root = prev->root;
#line 3450
    conf->root_lengths = prev->root_lengths;
#line 3451
    conf->root_values = prev->root_values;
#line 3453
    if ((unsigned long )prev->root.data == (unsigned long )((void *)0)) {
      {
#line 3454
      conf->root.len = sizeof("html") - 1UL;
#line 3454
      conf->root.data = (u_char *)"html";
#line 3456
      tmp = ngx_conf_full_name(cf->cycle, & conf->root, (ngx_uint_t )0);
      }
#line 3456
      if (tmp != 0L) {
#line 3457
        return ((char *)((void *)-1));
      }
    }
  }
#line 3462
  if ((unsigned long )conf->post_action.data == (unsigned long )((void *)0)) {
#line 3463
    conf->post_action = prev->post_action;
  }
#line 3466
  if (conf->types_hash_max_size == 0xffffffffffffffffUL) {
#line 3466
    if (prev->types_hash_max_size == 0xffffffffffffffffUL) {
#line 3466
      conf->types_hash_max_size = (ngx_uint_t )1024;
    } else {
#line 3466
      conf->types_hash_max_size = prev->types_hash_max_size;
    }
  }
#line 3469
  if (conf->types_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3469
    if (prev->types_hash_bucket_size == 0xffffffffffffffffUL) {
#line 3469
      conf->types_hash_bucket_size = (ngx_uint_t )64;
    } else {
#line 3469
      conf->types_hash_bucket_size = prev->types_hash_bucket_size;
    }
  }
#line 3472
  conf->types_hash_bucket_size = (conf->types_hash_bucket_size + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 3480
  if (prev->types) {
#line 3480
    if ((unsigned long )prev->types_hash.buckets == (unsigned long )((void *)0)) {
      {
#line 3482
      types_hash.hash = & prev->types_hash;
#line 3483
      types_hash.key = & ngx_hash_key_lc;
#line 3484
      types_hash.max_size = conf->types_hash_max_size;
#line 3485
      types_hash.bucket_size = conf->types_hash_bucket_size;
#line 3486
      types_hash.name = (char *)"types_hash";
#line 3487
      types_hash.pool = cf->pool;
#line 3488
      types_hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 3490
      tmp___0 = ngx_hash_init(& types_hash, (ngx_hash_key_t *)(prev->types)->elts,
                              (prev->types)->nelts);
      }
#line 3490
      if (tmp___0 != 0L) {
#line 3493
        return ((char *)((void *)-1));
      }
    }
  }
#line 3497
  if ((unsigned long )conf->types == (unsigned long )((void *)0)) {
#line 3498
    conf->types = prev->types;
#line 3499
    conf->types_hash = prev->types_hash;
  }
#line 3502
  if ((unsigned long )conf->types == (unsigned long )((void *)0)) {
    {
#line 3503
    conf->types = ngx_array_create(cf->pool, (ngx_uint_t )3, sizeof(ngx_hash_key_t ));
    }
#line 3504
    if ((unsigned long )conf->types == (unsigned long )((void *)0)) {
#line 3505
      return ((char *)((void *)-1));
    }
#line 3508
    i = (ngx_uint_t )0;
    {
#line 3508
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3508
      if (! ngx_http_core_default_types[i].key.len) {
#line 3508
        goto while_break;
      }
      {
#line 3509
      tmp___1 = ngx_array_push(conf->types);
#line 3509
      type = (ngx_hash_key_t *)tmp___1;
      }
#line 3510
      if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 3511
        return ((char *)((void *)-1));
      }
      {
#line 3514
      type->key = ngx_http_core_default_types[i].key;
#line 3515
      type->key_hash = ngx_hash_key_lc(ngx_http_core_default_types[i].key.data, ngx_http_core_default_types[i].key.len);
#line 3518
      type->value = ngx_http_core_default_types[i].value;
#line 3508
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3522
  if ((unsigned long )conf->types_hash.buckets == (unsigned long )((void *)0)) {
    {
#line 3524
    types_hash.hash = & conf->types_hash;
#line 3525
    types_hash.key = & ngx_hash_key_lc;
#line 3526
    types_hash.max_size = conf->types_hash_max_size;
#line 3527
    types_hash.bucket_size = conf->types_hash_bucket_size;
#line 3528
    types_hash.name = (char *)"types_hash";
#line 3529
    types_hash.pool = cf->pool;
#line 3530
    types_hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 3532
    tmp___2 = ngx_hash_init(& types_hash, (ngx_hash_key_t *)(conf->types)->elts, (conf->types)->nelts);
    }
#line 3532
    if (tmp___2 != 0L) {
#line 3535
      return ((char *)((void *)-1));
    }
  }
#line 3539
  if ((unsigned long )conf->error_log == (unsigned long )((void *)0)) {
#line 3540
    if (prev->error_log) {
#line 3541
      conf->error_log = prev->error_log;
    } else {
#line 3543
      conf->error_log = & (cf->cycle)->new_log;
    }
  }
#line 3547
  if ((unsigned long )conf->error_pages == (unsigned long )((void *)0)) {
#line 3547
    if (prev->error_pages) {
#line 3548
      conf->error_pages = prev->error_pages;
    }
  }
#line 3551
  if ((unsigned long )conf->default_type.data == (unsigned long )((void *)0)) {
#line 3551
    if (prev->default_type.data) {
#line 3551
      conf->default_type.len = prev->default_type.len;
#line 3551
      conf->default_type.data = prev->default_type.data;
    } else {
#line 3551
      conf->default_type.len = sizeof("text/plain") - 1UL;
#line 3551
      conf->default_type.data = (u_char *)"text/plain";
    }
  }
#line 3554
  if (conf->client_max_body_size == -1L) {
#line 3554
    if (prev->client_max_body_size == -1L) {
#line 3554
      conf->client_max_body_size = (off_t )1048576;
    } else {
#line 3554
      conf->client_max_body_size = prev->client_max_body_size;
    }
  }
#line 3556
  if (conf->client_body_buffer_size == 0xffffffffffffffffUL) {
#line 3556
    if (prev->client_body_buffer_size == 0xffffffffffffffffUL) {
#line 3556
      conf->client_body_buffer_size = 2UL * ngx_pagesize;
    } else {
#line 3556
      conf->client_body_buffer_size = prev->client_body_buffer_size;
    }
  }
#line 3559
  if (conf->client_body_timeout == 0xffffffffffffffffUL) {
#line 3559
    if (prev->client_body_timeout == 0xffffffffffffffffUL) {
#line 3559
      conf->client_body_timeout = (ngx_msec_t )60000;
    } else {
#line 3559
      conf->client_body_timeout = prev->client_body_timeout;
    }
  }
#line 3562
  if (conf->keepalive_disable == 0UL) {
#line 3562
    if (prev->keepalive_disable == 0UL) {
#line 3562
      conf->keepalive_disable = (ngx_uint_t )5;
    } else {
#line 3562
      conf->keepalive_disable = prev->keepalive_disable;
    }
  }
#line 3566
  if (conf->satisfy == 0xffffffffffffffffUL) {
#line 3566
    if (prev->satisfy == 0xffffffffffffffffUL) {
#line 3566
      conf->satisfy = (ngx_uint_t )0;
    } else {
#line 3566
      conf->satisfy = prev->satisfy;
    }
  }
#line 3568
  if (conf->if_modified_since == 0xffffffffffffffffUL) {
#line 3568
    if (prev->if_modified_since == 0xffffffffffffffffUL) {
#line 3568
      conf->if_modified_since = (ngx_uint_t )1;
    } else {
#line 3568
      conf->if_modified_since = prev->if_modified_since;
    }
  }
#line 3570
  if (conf->max_ranges == 0xffffffffffffffffUL) {
#line 3570
    if (prev->max_ranges == 0xffffffffffffffffUL) {
#line 3570
      conf->max_ranges = (ngx_uint_t )((uint32_t )2147483647);
    } else {
#line 3570
      conf->max_ranges = prev->max_ranges;
    }
  }
#line 3572
  if (conf->client_body_in_file_only == 0xffffffffffffffffUL) {
#line 3572
    if (prev->client_body_in_file_only == 0xffffffffffffffffUL) {
#line 3572
      conf->client_body_in_file_only = (ngx_uint_t )0;
    } else {
#line 3572
      conf->client_body_in_file_only = prev->client_body_in_file_only;
    }
  }
#line 3575
  if (conf->client_body_in_single_buffer == -1L) {
#line 3575
    if (prev->client_body_in_single_buffer == -1L) {
#line 3575
      conf->client_body_in_single_buffer = (ngx_flag_t )0;
    } else {
#line 3575
      conf->client_body_in_single_buffer = prev->client_body_in_single_buffer;
    }
  }
#line 3577
  if (conf->internal == -1L) {
#line 3577
    if (prev->internal == -1L) {
#line 3577
      conf->internal = (ngx_flag_t )0;
    } else {
#line 3577
      conf->internal = prev->internal;
    }
  }
#line 3578
  if (conf->sendfile == -1L) {
#line 3578
    if (prev->sendfile == -1L) {
#line 3578
      conf->sendfile = (ngx_flag_t )0;
    } else {
#line 3578
      conf->sendfile = prev->sendfile;
    }
  }
#line 3579
  if (conf->sendfile_max_chunk == 0xffffffffffffffffUL) {
#line 3579
    if (prev->sendfile_max_chunk == 0xffffffffffffffffUL) {
#line 3579
      conf->sendfile_max_chunk = (size_t )0;
    } else {
#line 3579
      conf->sendfile_max_chunk = prev->sendfile_max_chunk;
    }
  }
#line 3581
  if (conf->aio == -1L) {
#line 3581
    if (prev->aio == -1L) {
#line 3581
      conf->aio = (ngx_flag_t )0;
    } else {
#line 3581
      conf->aio = prev->aio;
    }
  }
#line 3582
  if (conf->aio_write == -1L) {
#line 3582
    if (prev->aio_write == -1L) {
#line 3582
      conf->aio_write = (ngx_flag_t )0;
    } else {
#line 3582
      conf->aio_write = prev->aio_write;
    }
  }
#line 3588
  if (conf->read_ahead == 0xffffffffffffffffUL) {
#line 3588
    if (prev->read_ahead == 0xffffffffffffffffUL) {
#line 3588
      conf->read_ahead = (size_t )0;
    } else {
#line 3588
      conf->read_ahead = prev->read_ahead;
    }
  }
#line 3589
  if (conf->directio == -1L) {
#line 3589
    if (prev->directio == -1L) {
#line 3589
      conf->directio = (off_t )9223372036854775807LL;
    } else {
#line 3589
      conf->directio = prev->directio;
    }
  }
#line 3591
  if (conf->directio_alignment == -1L) {
#line 3591
    if (prev->directio_alignment == -1L) {
#line 3591
      conf->directio_alignment = (off_t )512;
    } else {
#line 3591
      conf->directio_alignment = prev->directio_alignment;
    }
  }
#line 3593
  if (conf->tcp_nopush == -1L) {
#line 3593
    if (prev->tcp_nopush == -1L) {
#line 3593
      conf->tcp_nopush = (ngx_flag_t )0;
    } else {
#line 3593
      conf->tcp_nopush = prev->tcp_nopush;
    }
  }
#line 3594
  if (conf->tcp_nodelay == -1L) {
#line 3594
    if (prev->tcp_nodelay == -1L) {
#line 3594
      conf->tcp_nodelay = (ngx_flag_t )1;
    } else {
#line 3594
      conf->tcp_nodelay = prev->tcp_nodelay;
    }
  }
#line 3596
  if (conf->send_timeout == 0xffffffffffffffffUL) {
#line 3596
    if (prev->send_timeout == 0xffffffffffffffffUL) {
#line 3596
      conf->send_timeout = (ngx_msec_t )60000;
    } else {
#line 3596
      conf->send_timeout = prev->send_timeout;
    }
  }
#line 3597
  if (conf->send_lowat == 0xffffffffffffffffUL) {
#line 3597
    if (prev->send_lowat == 0xffffffffffffffffUL) {
#line 3597
      conf->send_lowat = (size_t )0;
    } else {
#line 3597
      conf->send_lowat = prev->send_lowat;
    }
  }
#line 3598
  if (conf->postpone_output == 0xffffffffffffffffUL) {
#line 3598
    if (prev->postpone_output == 0xffffffffffffffffUL) {
#line 3598
      conf->postpone_output = (size_t )1460;
    } else {
#line 3598
      conf->postpone_output = prev->postpone_output;
    }
  }
#line 3600
  if (conf->limit_rate == 0xffffffffffffffffUL) {
#line 3600
    if (prev->limit_rate == 0xffffffffffffffffUL) {
#line 3600
      conf->limit_rate = (size_t )0;
    } else {
#line 3600
      conf->limit_rate = prev->limit_rate;
    }
  }
#line 3601
  if (conf->limit_rate_after == 0xffffffffffffffffUL) {
#line 3601
    if (prev->limit_rate_after == 0xffffffffffffffffUL) {
#line 3601
      conf->limit_rate_after = (size_t )0;
    } else {
#line 3601
      conf->limit_rate_after = prev->limit_rate_after;
    }
  }
#line 3603
  if (conf->keepalive_timeout == 0xffffffffffffffffUL) {
#line 3603
    if (prev->keepalive_timeout == 0xffffffffffffffffUL) {
#line 3603
      conf->keepalive_timeout = (ngx_msec_t )75000;
    } else {
#line 3603
      conf->keepalive_timeout = prev->keepalive_timeout;
    }
  }
#line 3605
  if (conf->keepalive_header == -1L) {
#line 3605
    if (prev->keepalive_header == -1L) {
#line 3605
      conf->keepalive_header = (time_t )0;
    } else {
#line 3605
      conf->keepalive_header = prev->keepalive_header;
    }
  }
#line 3607
  if (conf->keepalive_requests == 0xffffffffffffffffUL) {
#line 3607
    if (prev->keepalive_requests == 0xffffffffffffffffUL) {
#line 3607
      conf->keepalive_requests = (ngx_uint_t )100;
    } else {
#line 3607
      conf->keepalive_requests = prev->keepalive_requests;
    }
  }
#line 3609
  if (conf->lingering_close == 0xffffffffffffffffUL) {
#line 3609
    if (prev->lingering_close == 0xffffffffffffffffUL) {
#line 3609
      conf->lingering_close = (ngx_uint_t )1;
    } else {
#line 3609
      conf->lingering_close = prev->lingering_close;
    }
  }
#line 3611
  if (conf->lingering_time == 0xffffffffffffffffUL) {
#line 3611
    if (prev->lingering_time == 0xffffffffffffffffUL) {
#line 3611
      conf->lingering_time = (ngx_msec_t )30000;
    } else {
#line 3611
      conf->lingering_time = prev->lingering_time;
    }
  }
#line 3613
  if (conf->lingering_timeout == 0xffffffffffffffffUL) {
#line 3613
    if (prev->lingering_timeout == 0xffffffffffffffffUL) {
#line 3613
      conf->lingering_timeout = (ngx_msec_t )5000;
    } else {
#line 3613
      conf->lingering_timeout = prev->lingering_timeout;
    }
  }
#line 3615
  if (conf->resolver_timeout == 0xffffffffffffffffUL) {
#line 3615
    if (prev->resolver_timeout == 0xffffffffffffffffUL) {
#line 3615
      conf->resolver_timeout = (ngx_msec_t )30000;
    } else {
#line 3615
      conf->resolver_timeout = prev->resolver_timeout;
    }
  }
#line 3618
  if ((unsigned long )conf->resolver == (unsigned long )((void *)0)) {
#line 3620
    if ((unsigned long )prev->resolver == (unsigned long )((void *)0)) {
      {
#line 3627
      prev->resolver = ngx_resolver_create(cf, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
      }
#line 3628
      if ((unsigned long )prev->resolver == (unsigned long )((void *)0)) {
#line 3629
        return ((char *)((void *)-1));
      }
    }
#line 3633
    conf->resolver = prev->resolver;
  }
  {
#line 3636
  tmp___3 = ngx_conf_merge_path_value(cf, & conf->client_body_temp_path, prev->client_body_temp_path,
                                      & ngx_http_client_temp_path);
  }
#line 3636
  if ((unsigned long )tmp___3 != (unsigned long )((char *)0)) {
#line 3641
    return ((char *)((void *)-1));
  }
#line 3644
  if (conf->reset_timedout_connection == -1L) {
#line 3644
    if (prev->reset_timedout_connection == -1L) {
#line 3644
      conf->reset_timedout_connection = (ngx_flag_t )0;
    } else {
#line 3644
      conf->reset_timedout_connection = prev->reset_timedout_connection;
    }
  }
#line 3646
  if (conf->absolute_redirect == -1L) {
#line 3646
    if (prev->absolute_redirect == -1L) {
#line 3646
      conf->absolute_redirect = (ngx_flag_t )1;
    } else {
#line 3646
      conf->absolute_redirect = prev->absolute_redirect;
    }
  }
#line 3648
  if (conf->server_name_in_redirect == -1L) {
#line 3648
    if (prev->server_name_in_redirect == -1L) {
#line 3648
      conf->server_name_in_redirect = (ngx_flag_t )0;
    } else {
#line 3648
      conf->server_name_in_redirect = prev->server_name_in_redirect;
    }
  }
#line 3650
  if (conf->port_in_redirect == -1L) {
#line 3650
    if (prev->port_in_redirect == -1L) {
#line 3650
      conf->port_in_redirect = (ngx_flag_t )1;
    } else {
#line 3650
      conf->port_in_redirect = prev->port_in_redirect;
    }
  }
#line 3651
  if (conf->msie_padding == -1L) {
#line 3651
    if (prev->msie_padding == -1L) {
#line 3651
      conf->msie_padding = (ngx_flag_t )1;
    } else {
#line 3651
      conf->msie_padding = prev->msie_padding;
    }
  }
#line 3652
  if (conf->msie_refresh == -1L) {
#line 3652
    if (prev->msie_refresh == -1L) {
#line 3652
      conf->msie_refresh = (ngx_flag_t )0;
    } else {
#line 3652
      conf->msie_refresh = prev->msie_refresh;
    }
  }
#line 3653
  if (conf->log_not_found == -1L) {
#line 3653
    if (prev->log_not_found == -1L) {
#line 3653
      conf->log_not_found = (ngx_flag_t )1;
    } else {
#line 3653
      conf->log_not_found = prev->log_not_found;
    }
  }
#line 3654
  if (conf->log_subrequest == -1L) {
#line 3654
    if (prev->log_subrequest == -1L) {
#line 3654
      conf->log_subrequest = (ngx_flag_t )0;
    } else {
#line 3654
      conf->log_subrequest = prev->log_subrequest;
    }
  }
#line 3655
  if (conf->recursive_error_pages == -1L) {
#line 3655
    if (prev->recursive_error_pages == -1L) {
#line 3655
      conf->recursive_error_pages = (ngx_flag_t )0;
    } else {
#line 3655
      conf->recursive_error_pages = prev->recursive_error_pages;
    }
  }
#line 3657
  if (conf->chunked_transfer_encoding == -1L) {
#line 3657
    if (prev->chunked_transfer_encoding == -1L) {
#line 3657
      conf->chunked_transfer_encoding = (ngx_flag_t )1;
    } else {
#line 3657
      conf->chunked_transfer_encoding = prev->chunked_transfer_encoding;
    }
  }
#line 3659
  if (conf->etag == -1L) {
#line 3659
    if (prev->etag == -1L) {
#line 3659
      conf->etag = (ngx_flag_t )1;
    } else {
#line 3659
      conf->etag = prev->etag;
    }
  }
#line 3661
  if (conf->server_tokens == 0xffffffffffffffffUL) {
#line 3661
    if (prev->server_tokens == 0xffffffffffffffffUL) {
#line 3661
      conf->server_tokens = (ngx_uint_t )1;
    } else {
#line 3661
      conf->server_tokens = prev->server_tokens;
    }
  }
#line 3664
  if ((unsigned long )conf->open_file_cache == (unsigned long )((void *)-1)) {
#line 3664
    if ((unsigned long )prev->open_file_cache == (unsigned long )((void *)-1)) {
#line 3664
      conf->open_file_cache = (ngx_open_file_cache_t *)((void *)0);
    } else {
#line 3664
      conf->open_file_cache = prev->open_file_cache;
    }
  }
#line 3667
  if (conf->open_file_cache_valid == -1L) {
#line 3667
    if (prev->open_file_cache_valid == -1L) {
#line 3667
      conf->open_file_cache_valid = (time_t )60;
    } else {
#line 3667
      conf->open_file_cache_valid = prev->open_file_cache_valid;
    }
  }
#line 3670
  if (conf->open_file_cache_min_uses == 0xffffffffffffffffUL) {
#line 3670
    if (prev->open_file_cache_min_uses == 0xffffffffffffffffUL) {
#line 3670
      conf->open_file_cache_min_uses = (ngx_uint_t )1;
    } else {
#line 3670
      conf->open_file_cache_min_uses = prev->open_file_cache_min_uses;
    }
  }
#line 3673
  if (conf->open_file_cache_errors == -1L) {
#line 3673
    if (prev->open_file_cache_errors == -1L) {
#line 3673
      conf->open_file_cache_errors = (ngx_flag_t )0;
    } else {
#line 3673
      conf->open_file_cache_errors = prev->open_file_cache_errors;
    }
  }
#line 3676
  if (conf->open_file_cache_events == -1L) {
#line 3676
    if (prev->open_file_cache_events == -1L) {
#line 3676
      conf->open_file_cache_events = (ngx_flag_t )0;
    } else {
#line 3676
      conf->open_file_cache_events = prev->open_file_cache_events;
    }
  }
#line 3680
  if (conf->gzip_vary == -1L) {
#line 3680
    if (prev->gzip_vary == -1L) {
#line 3680
      conf->gzip_vary = (ngx_flag_t )0;
    } else {
#line 3680
      conf->gzip_vary = prev->gzip_vary;
    }
  }
#line 3681
  if (conf->gzip_http_version == 0xffffffffffffffffUL) {
#line 3681
    if (prev->gzip_http_version == 0xffffffffffffffffUL) {
#line 3681
      conf->gzip_http_version = (ngx_uint_t )1001;
    } else {
#line 3681
      conf->gzip_http_version = prev->gzip_http_version;
    }
  }
#line 3683
  if (conf->gzip_proxied == 0UL) {
#line 3683
    if (prev->gzip_proxied == 0UL) {
#line 3683
      conf->gzip_proxied = (ngx_uint_t )3;
    } else {
#line 3683
      conf->gzip_proxied = prev->gzip_proxied;
    }
  }
#line 3687
  if ((unsigned long )conf->gzip_disable == (unsigned long )((void *)-1)) {
#line 3687
    if ((unsigned long )prev->gzip_disable == (unsigned long )((void *)-1)) {
#line 3687
      conf->gzip_disable = (ngx_array_t *)((void *)0);
    } else {
#line 3687
      conf->gzip_disable = prev->gzip_disable;
    }
  }
#line 3690
  if (conf->gzip_disable_msie6 == 3U) {
#line 3691
    if (prev->gzip_disable_msie6 == 3U) {
#line 3691
      conf->gzip_disable_msie6 = 0U;
    } else {
#line 3691
      conf->gzip_disable_msie6 = prev->gzip_disable_msie6;
    }
  }
#line 3707
  if (conf->disable_symlinks == 0xffffffffffffffffUL) {
#line 3707
    if (prev->disable_symlinks == 0xffffffffffffffffUL) {
#line 3707
      conf->disable_symlinks = (ngx_uint_t )0;
    } else {
#line 3707
      conf->disable_symlinks = prev->disable_symlinks;
    }
  }
#line 3709
  if ((unsigned long )conf->disable_symlinks_from == (unsigned long )((void *)-1)) {
#line 3709
    if ((unsigned long )prev->disable_symlinks_from == (unsigned long )((void *)-1)) {
#line 3709
      conf->disable_symlinks_from = (ngx_http_complex_value_t *)((void *)0);
    } else {
#line 3709
      conf->disable_symlinks_from = prev->disable_symlinks_from;
    }
  }
#line 3713
  return ((char *)((void *)0));
}
}
#line 3717 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_listen(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  ngx_str_t *value ;
  ngx_str_t size ;
  ngx_url_t u ;
  ngx_uint_t n ;
  ngx_http_listen_opt_t lsopt ;
  ngx_int_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  ngx_int_t tmp___3 ;
  int tmp___4 ;
  ngx_int_t tmp___5 ;
  int tmp___6 ;
  ssize_t tmp___7 ;
  int tmp___8 ;
  ssize_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  struct sockaddr *sa ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  u_char *p ;
  u_char *end ;
  ngx_str_t s ;
  ngx_int_t tmp___20 ;
  ngx_int_t tmp___21 ;
  ngx_int_t tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  ngx_int_t tmp___27 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  void *__cil_tmp45 ;
  void *__cil_tmp46 ;
  void *__cil_tmp47 ;
  void *__cil_tmp48 ;
  void *__cil_tmp49 ;
  void *__cil_tmp50 ;
  void *__cil_tmp51 ;
  void *__cil_tmp52 ;
  void *__cil_tmp53 ;
  void *__cil_tmp54 ;
  void *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;

  {
  {
#line 3720
  cscf = (ngx_http_core_srv_conf_t *)conf;
#line 3727
  cscf->listen = 1U;
#line 3729
  value = (ngx_str_t *)(cf->args)->elts;
#line 3731
  memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 3733
  u.url = *(value + 1);
#line 3734
  u.listen = 1U;
#line 3735
  u.default_port = (in_port_t )80;
#line 3737
  tmp = ngx_parse_url(cf->pool, & u);
  }
#line 3737
  if (tmp != 0L) {
#line 3738
    if (u.err) {
      {
#line 3739
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in \"%V\" of the \"listen\" directive",
                         u.err, & u.url);
      }
    }
#line 3744
    return ((char *)((void *)-1));
  }
  {
#line 3747
  memset((void *)(& lsopt), 0, sizeof(ngx_http_listen_opt_t ));
#line 3749
  memcpy((void */* __restrict  */)(& lsopt.sockaddr.sockaddr), (void const   */* __restrict  */)(& u.sockaddr),
         (size_t )u.socklen);
#line 3751
  lsopt.socklen = u.socklen;
#line 3752
  lsopt.backlog = 511;
#line 3753
  lsopt.rcvbuf = -1;
#line 3754
  lsopt.sndbuf = -1;
#line 3759
  lsopt.fastopen = -1;
#line 3761
  lsopt.wildcard = u.wildcard;
#line 3763
  lsopt.ipv6only = 1U;
#line 3766
  ngx_sock_ntop(& lsopt.sockaddr.sockaddr, lsopt.socklen, lsopt.addr, ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path),
                (ngx_uint_t )1);
#line 3769
  n = (ngx_uint_t )2;
  }
  {
#line 3769
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3769
    if (! (n < (cf->args)->nelts)) {
#line 3769
      goto while_break;
    }
    {
#line 3771
    tmp___0 = strcmp((char const   *)(value + n)->data, "default_server");
    }
#line 3771
    if (tmp___0 == 0) {
#line 3774
      lsopt.default_server = 1U;
#line 3775
      goto __Cont;
    } else {
      {
#line 3771
      tmp___1 = strcmp((char const   *)(value + n)->data, "default");
      }
#line 3771
      if (tmp___1 == 0) {
#line 3774
        lsopt.default_server = 1U;
#line 3775
        goto __Cont;
      }
    }
    {
#line 3778
    tmp___2 = strcmp((char const   *)(value + n)->data, "bind");
    }
#line 3778
    if (tmp___2 == 0) {
#line 3779
      lsopt.set = 1U;
#line 3780
      lsopt.bind = 1U;
#line 3781
      goto __Cont;
    }
    {
#line 3801
    tmp___4 = strncmp((char const   *)(value + n)->data, "fastopen=", (size_t )9);
    }
#line 3801
    if (tmp___4 == 0) {
      {
#line 3802
      tmp___3 = ngx_atoi((value + n)->data + 9, (value + n)->len - 9UL);
#line 3802
      lsopt.fastopen = (int )tmp___3;
#line 3803
      lsopt.set = 1U;
#line 3804
      lsopt.bind = 1U;
      }
#line 3806
      if (lsopt.fastopen == -1) {
        {
#line 3807
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid fastopen \"%V\"", value + n);
        }
#line 3809
        return ((char *)((void *)-1));
      }
#line 3812
      goto __Cont;
    }
    {
#line 3816
    tmp___6 = strncmp((char const   *)(value + n)->data, "backlog=", (size_t )8);
    }
#line 3816
    if (tmp___6 == 0) {
      {
#line 3817
      tmp___5 = ngx_atoi((value + n)->data + 8, (value + n)->len - 8UL);
#line 3817
      lsopt.backlog = (int )tmp___5;
#line 3818
      lsopt.set = 1U;
#line 3819
      lsopt.bind = 1U;
      }
#line 3821
      if (lsopt.backlog == -1) {
        {
#line 3822
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid backlog \"%V\"", value + n);
        }
#line 3824
        return ((char *)((void *)-1));
      } else
#line 3821
      if (lsopt.backlog == 0) {
        {
#line 3822
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid backlog \"%V\"", value + n);
        }
#line 3824
        return ((char *)((void *)-1));
      }
#line 3827
      goto __Cont;
    }
    {
#line 3830
    tmp___8 = strncmp((char const   *)(value + n)->data, "rcvbuf=", (size_t )7);
    }
#line 3830
    if (tmp___8 == 0) {
      {
#line 3831
      size.len = (value + n)->len - 7UL;
#line 3832
      size.data = (value + n)->data + 7;
#line 3834
      tmp___7 = ngx_parse_size(& size);
#line 3834
      lsopt.rcvbuf = (int )tmp___7;
#line 3835
      lsopt.set = 1U;
#line 3836
      lsopt.bind = 1U;
      }
#line 3838
      if (lsopt.rcvbuf == -1) {
        {
#line 3839
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid rcvbuf \"%V\"", value + n);
        }
#line 3841
        return ((char *)((void *)-1));
      }
#line 3844
      goto __Cont;
    }
    {
#line 3847
    tmp___10 = strncmp((char const   *)(value + n)->data, "sndbuf=", (size_t )7);
    }
#line 3847
    if (tmp___10 == 0) {
      {
#line 3848
      size.len = (value + n)->len - 7UL;
#line 3849
      size.data = (value + n)->data + 7;
#line 3851
      tmp___9 = ngx_parse_size(& size);
#line 3851
      lsopt.sndbuf = (int )tmp___9;
#line 3852
      lsopt.set = 1U;
#line 3853
      lsopt.bind = 1U;
      }
#line 3855
      if (lsopt.sndbuf == -1) {
        {
#line 3856
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid sndbuf \"%V\"", value + n);
        }
#line 3858
        return ((char *)((void *)-1));
      }
#line 3861
      goto __Cont;
    }
    {
#line 3864
    tmp___11 = strncmp((char const   *)(value + n)->data, "accept_filter=", (size_t )14);
    }
#line 3864
    if (tmp___11 == 0) {
      {
#line 3870
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "accept filters \"%V\" are not supported on this platform, ignored",
                         value + n);
      }
#line 3875
      goto __Cont;
    }
    {
#line 3878
    tmp___12 = strcmp((char const   *)(value + n)->data, "deferred");
    }
#line 3878
    if (tmp___12 == 0) {
#line 3880
      lsopt.deferred_accept = 1U;
#line 3881
      lsopt.set = 1U;
#line 3882
      lsopt.bind = 1U;
#line 3888
      goto __Cont;
    }
    {
#line 3891
    tmp___15 = strncmp((char const   *)(value + n)->data, "ipv6only=o", (size_t )10);
    }
#line 3891
    if (tmp___15 == 0) {
#line 3895
      sa = & lsopt.sockaddr.sockaddr;
#line 3897
      if ((int )sa->sa_family == 10) {
        {
#line 3899
        tmp___14 = strcmp((char const   *)((value + n)->data + 10), "n");
        }
#line 3899
        if (tmp___14 == 0) {
#line 3900
          lsopt.ipv6only = 1U;
        } else {
          {
#line 3902
          tmp___13 = strcmp((char const   *)((value + n)->data + 10), "ff");
          }
#line 3902
          if (tmp___13 == 0) {
#line 3903
            lsopt.ipv6only = 0U;
          } else {
            {
#line 3906
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid ipv6only flags \"%s\"",
                               (value + n)->data + 9);
            }
#line 3909
            return ((char *)((void *)-1));
          }
        }
#line 3912
        lsopt.set = 1U;
#line 3913
        lsopt.bind = 1U;
      } else {
        {
#line 3916
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "ipv6only is not supported on addr \"%s\", ignored",
                           lsopt.addr);
        }
      }
#line 3921
      goto __Cont;
    }
    {
#line 3930
    tmp___16 = strcmp((char const   *)(value + n)->data, "reuseport");
    }
#line 3930
    if (tmp___16 == 0) {
#line 3932
      lsopt.reuseport = 1U;
#line 3933
      lsopt.set = 1U;
#line 3934
      lsopt.bind = 1U;
#line 3940
      goto __Cont;
    }
    {
#line 3943
    tmp___17 = strcmp((char const   *)(value + n)->data, "ssl");
    }
#line 3943
    if (tmp___17 == 0) {
      {
#line 3948
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"ssl\" parameter requires ngx_http_ssl_module");
      }
#line 3951
      return ((char *)((void *)-1));
    }
    {
#line 3955
    tmp___18 = strcmp((char const   *)(value + n)->data, "http2");
    }
#line 3955
    if (tmp___18 == 0) {
      {
#line 3960
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"http2\" parameter requires ngx_http_v2_module");
      }
#line 3963
      return ((char *)((void *)-1));
    }
    {
#line 3967
    tmp___19 = strcmp((char const   *)(value + n)->data, "spdy");
    }
#line 3967
    if (tmp___19 == 0) {
      {
#line 3968
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "invalid parameter \"spdy\": ngx_http_spdy_module was superseded by ngx_http_v2_module");
      }
#line 3972
      goto __Cont;
    }
    {
#line 3975
    tmp___25 = strncmp((char const   *)(value + n)->data, "so_keepalive=", (size_t )13);
    }
#line 3975
    if (tmp___25 == 0) {
      {
#line 3977
      tmp___24 = strcmp((char const   *)((value + n)->data + 13), "on");
      }
#line 3977
      if (tmp___24 == 0) {
#line 3978
        lsopt.so_keepalive = 1U;
      } else {
        {
#line 3980
        tmp___23 = strcmp((char const   *)((value + n)->data + 13), "off");
        }
#line 3980
        if (tmp___23 == 0) {
#line 3981
          lsopt.so_keepalive = 2U;
        } else {
          {
#line 3989
          end = (value + n)->data + (value + n)->len;
#line 3990
          s.data = (value + n)->data + 13;
#line 3992
          p = ngx_strlchr(s.data, end, (u_char )':');
          }
#line 3993
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3994
            p = end;
          }
#line 3997
          if ((unsigned long )p > (unsigned long )s.data) {
            {
#line 3998
            s.len = (size_t )(p - s.data);
#line 4000
            tmp___20 = ngx_parse_time(& s, (ngx_uint_t )1);
#line 4000
            lsopt.tcp_keepidle = (int )tmp___20;
            }
#line 4001
            if ((time_t )lsopt.tcp_keepidle == -1L) {
#line 4002
              goto invalid_so_keepalive;
            }
          }
#line 4006
          if ((unsigned long )p < (unsigned long )end) {
#line 4006
            s.data = p + 1;
          } else {
#line 4006
            s.data = end;
          }
          {
#line 4008
          p = ngx_strlchr(s.data, end, (u_char )':');
          }
#line 4009
          if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 4010
            p = end;
          }
#line 4013
          if ((unsigned long )p > (unsigned long )s.data) {
            {
#line 4014
            s.len = (size_t )(p - s.data);
#line 4016
            tmp___21 = ngx_parse_time(& s, (ngx_uint_t )1);
#line 4016
            lsopt.tcp_keepintvl = (int )tmp___21;
            }
#line 4017
            if ((time_t )lsopt.tcp_keepintvl == -1L) {
#line 4018
              goto invalid_so_keepalive;
            }
          }
#line 4022
          if ((unsigned long )p < (unsigned long )end) {
#line 4022
            s.data = p + 1;
          } else {
#line 4022
            s.data = end;
          }
#line 4024
          if ((unsigned long )s.data < (unsigned long )end) {
            {
#line 4025
            s.len = (size_t )(end - s.data);
#line 4027
            tmp___22 = ngx_atoi(s.data, s.len);
#line 4027
            lsopt.tcp_keepcnt = (int )tmp___22;
            }
#line 4028
            if (lsopt.tcp_keepcnt == -1) {
#line 4029
              goto invalid_so_keepalive;
            }
          }
#line 4033
          if (lsopt.tcp_keepidle == 0) {
#line 4033
            if (lsopt.tcp_keepintvl == 0) {
#line 4033
              if (lsopt.tcp_keepcnt == 0) {
#line 4036
                goto invalid_so_keepalive;
              }
            }
          }
#line 4039
          lsopt.so_keepalive = 1U;
        }
      }
#line 4051
      lsopt.set = 1U;
#line 4052
      lsopt.bind = 1U;
#line 4054
      goto __Cont;
      invalid_so_keepalive: 
      {
#line 4059
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid so_keepalive value: \"%s\"",
                         (value + n)->data + 13);
      }
#line 4062
      return ((char *)((void *)-1));
    }
    {
#line 4066
    tmp___26 = strcmp((char const   *)(value + n)->data, "proxy_protocol");
    }
#line 4066
    if (tmp___26 == 0) {
#line 4067
      lsopt.proxy_protocol = 1U;
#line 4068
      goto __Cont;
    }
    {
#line 4071
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + n);
    }
#line 4073
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 3769
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4076
  tmp___27 = ngx_http_add_listen(cf, cscf, & lsopt);
  }
#line 4076
  if (tmp___27 == 0L) {
#line 4077
    return ((char *)((void *)0));
  }
#line 4080
  return ((char *)((void *)-1));
}
}
#line 4084 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_server_name(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_srv_conf_t *cscf ;
  u_char ch ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_http_server_name_t *sn ;
  char *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  u_char *p ;
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 4087
  cscf = (ngx_http_core_srv_conf_t *)conf;
#line 4094
  value = (ngx_str_t *)(cf->args)->elts;
#line 4096
  i = (ngx_uint_t )1;
  {
#line 4096
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4096
    if (! (i < (cf->args)->nelts)) {
#line 4096
      goto while_break;
    }
#line 4098
    ch = *((value + i)->data + 0);
#line 4100
    if ((int )ch == 42) {
#line 4100
      if ((value + i)->len < 3UL) {
        {
#line 4103
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "server name \"%V\" is invalid",
                           value + i);
        }
#line 4105
        return ((char *)((void *)-1));
      } else
#line 4100
      if ((int )*((value + i)->data + 1) != 46) {
        {
#line 4103
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "server name \"%V\" is invalid",
                           value + i);
        }
#line 4105
        return ((char *)((void *)-1));
      } else {
#line 4100
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 4100
    if ((int )ch == 46) {
#line 4100
      if ((value + i)->len < 2UL) {
        {
#line 4103
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "server name \"%V\" is invalid",
                           value + i);
        }
#line 4105
        return ((char *)((void *)-1));
      }
    }
    {
#line 4108
    tmp = strchr((char const   *)(value + i)->data, '/');
    }
#line 4108
    if (tmp) {
      {
#line 4109
      ngx_conf_log_error((ngx_uint_t )5, cf, 0, "server name \"%V\" has suspicious symbols",
                         value + i);
      }
    }
    {
#line 4114
    tmp___0 = ngx_array_push(& cscf->server_names);
#line 4114
    sn = (ngx_http_server_name_t *)tmp___0;
    }
#line 4115
    if ((unsigned long )sn == (unsigned long )((void *)0)) {
#line 4116
      return ((char *)((void *)-1));
    }
    {
#line 4120
    sn->regex = (ngx_http_regex_t *)((void *)0);
#line 4122
    sn->server = cscf;
#line 4124
    tmp___1 = ngx_strcasecmp((value + i)->data, (u_char *)"$hostname");
    }
#line 4124
    if (tmp___1 == 0L) {
#line 4125
      sn->name = (cf->cycle)->hostname;
    } else {
#line 4128
      sn->name = *(value + i);
    }
#line 4131
    if ((int )*((value + i)->data + 0) != 126) {
      {
#line 4132
      ngx_strlow(sn->name.data, sn->name.data, sn->name.len);
      }
#line 4133
      goto __Cont;
    }
#line 4142
    if ((value + i)->len == 1UL) {
      {
#line 4143
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "empty regex in server name \"%V\"",
                         value + i);
      }
#line 4145
      return ((char *)((void *)-1));
    }
    {
#line 4148
    ((value + i)->len) --;
#line 4149
    ((value + i)->data) ++;
#line 4151
    memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 4153
    rc.pattern = *(value + i);
#line 4154
    rc.err.len = (size_t )1024;
#line 4155
    rc.err.data = errstr;
#line 4157
    p = (value + i)->data;
    }
    {
#line 4157
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4157
      if (! ((unsigned long )p < (unsigned long )((value + i)->data + (value + i)->len))) {
#line 4157
        goto while_break___0;
      }
#line 4158
      if ((int )*p >= 65) {
#line 4158
        if ((int )*p <= 90) {
#line 4159
          rc.options = (ngx_int_t )1;
#line 4160
          goto while_break___0;
        }
      }
#line 4157
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4164
    sn->regex = ngx_http_regex_compile(cf, & rc);
    }
#line 4165
    if ((unsigned long )sn->regex == (unsigned long )((void *)0)) {
#line 4166
      return ((char *)((void *)-1));
    }
#line 4169
    sn->name = *(value + i);
#line 4170
    cscf->captures = (unsigned int )(rc.captures > 0);
    __Cont: /* CIL Label */ 
#line 4096
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4181
  return ((char *)((void *)0));
}
}
#line 4185 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_root(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_int_t alias ;
  ngx_uint_t n ;
  ngx_http_script_compile_t sc ;
  char const   *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 4188
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4195
  if (cmd->name.len == sizeof("alias") - 1UL) {
#line 4195
    alias = (ngx_int_t )1;
  } else {
#line 4195
    alias = (ngx_int_t )0;
  }
#line 4197
  if (clcf->root.data) {
#line 4199
    if ((ngx_int_t )(clcf->alias != 0UL) == alias) {
#line 4200
      return ((char *)"is duplicate");
    }
#line 4203
    if (clcf->alias) {
#line 4203
      tmp = "alias";
    } else {
#line 4203
      tmp = "root";
    }
    {
#line 4203
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" directive is duplicate, \"%s\" directive was specified earlier",
                       & cmd->name, tmp);
    }
#line 4208
    return ((char *)((void *)-1));
  }
#line 4211
  if (clcf->named) {
#line 4211
    if (alias) {
      {
#line 4212
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the \"alias\" directive cannot be used inside the named location");
      }
#line 4216
      return ((char *)((void *)-1));
    }
  }
  {
#line 4219
  value = (ngx_str_t *)(cf->args)->elts;
#line 4221
  tmp___0 = strstr((char const   *)(value + 1)->data, "$document_root");
  }
#line 4221
  if (tmp___0) {
    {
#line 4224
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the $document_root variable cannot be used in the \"%V\" directive",
                       & cmd->name);
    }
#line 4229
    return ((char *)((void *)-1));
  } else {
    {
#line 4221
    tmp___1 = strstr((char const   *)(value + 1)->data, "${document_root}");
    }
#line 4221
    if (tmp___1) {
      {
#line 4224
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the $document_root variable cannot be used in the \"%V\" directive",
                         & cmd->name);
      }
#line 4229
      return ((char *)((void *)-1));
    }
  }
  {
#line 4232
  tmp___2 = strstr((char const   *)(value + 1)->data, "$realpath_root");
  }
#line 4232
  if (tmp___2) {
    {
#line 4235
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the $realpath_root variable cannot be used in the \"%V\" directive",
                       & cmd->name);
    }
#line 4240
    return ((char *)((void *)-1));
  } else {
    {
#line 4232
    tmp___3 = strstr((char const   *)(value + 1)->data, "${realpath_root}");
    }
#line 4232
    if (tmp___3) {
      {
#line 4235
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the $realpath_root variable cannot be used in the \"%V\" directive",
                         & cmd->name);
      }
#line 4240
      return ((char *)((void *)-1));
    }
  }
#line 4243
  if (alias) {
#line 4243
    clcf->alias = clcf->name.len;
  } else {
#line 4243
    clcf->alias = (size_t )0;
  }
#line 4244
  clcf->root = *(value + 1);
#line 4246
  if (! alias) {
#line 4246
    if (clcf->root.len > 0UL) {
#line 4246
      if ((int )*(clcf->root.data + (clcf->root.len - 1UL)) == 47) {
#line 4249
        (clcf->root.len) --;
      }
    }
  }
#line 4252
  if ((int )*(clcf->root.data + 0) != 36) {
    {
#line 4253
    tmp___4 = ngx_conf_full_name(cf->cycle, & clcf->root, (ngx_uint_t )0);
    }
#line 4253
    if (tmp___4 != 0L) {
#line 4254
      return ((char *)((void *)-1));
    }
  }
  {
#line 4258
  n = ngx_http_script_variables_count(& clcf->root);
#line 4260
  memset((void *)(& sc), 0, sizeof(ngx_http_script_compile_t ));
#line 4261
  sc.variables = n;
  }
#line 4264
  if (alias) {
#line 4264
    if (clcf->regex) {
#line 4265
      clcf->alias = (size_t )9223372036854775807LL;
#line 4266
      n = (ngx_uint_t )1;
    }
  }
#line 4270
  if (n) {
    {
#line 4271
    sc.cf = cf;
#line 4272
    sc.source = & clcf->root;
#line 4273
    sc.lengths = & clcf->root_lengths;
#line 4274
    sc.values = & clcf->root_values;
#line 4275
    sc.complete_lengths = 1U;
#line 4276
    sc.complete_values = 1U;
#line 4278
    tmp___5 = ngx_http_script_compile(& sc);
    }
#line 4278
    if (tmp___5 != 0L) {
#line 4279
      return ((char *)((void *)-1));
    }
  }
#line 4283
  return ((char *)((void *)0));
}
}
#line 4287 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static ngx_http_method_name_t ngx_methods_names[15]  = 
#line 4287
  {      {(u_char *)"GET", (uint32_t )(~ 2)}, 
        {(u_char *)"HEAD", (uint32_t )(~ 4)}, 
        {(u_char *)"POST", (uint32_t )(~ 8)}, 
        {(u_char *)"PUT", (uint32_t )(~ 16)}, 
        {(u_char *)"DELETE", (uint32_t )(~ 32)}, 
        {(u_char *)"MKCOL", (uint32_t )(~ 64)}, 
        {(u_char *)"COPY", (uint32_t )(~ 128)}, 
        {(u_char *)"MOVE", (uint32_t )(~ 256)}, 
        {(u_char *)"OPTIONS", (uint32_t )(~ 512)}, 
        {(u_char *)"PROPFIND", (uint32_t )(~ 1024)}, 
        {(u_char *)"PROPPATCH", (uint32_t )(~ 2048)}, 
        {(u_char *)"LOCK", (uint32_t )(~ 4096)}, 
        {(u_char *)"UNLOCK", (uint32_t )(~ 8192)}, 
        {(u_char *)"PATCH", (uint32_t )(~ 16384)}, 
        {(u_char *)((void *)0), (uint32_t )0}};
#line 4306 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_limit_except(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *pclcf ;
  char *rv ;
  void *mconf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_conf_t save ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t *pctx ;
  ngx_http_method_name_t *name ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 4309
  pclcf = (ngx_http_core_loc_conf_t *)conf;
#line 4321
  if (pclcf->limit_except) {
#line 4322
    return ((char *)"is duplicate");
  }
#line 4325
  pclcf->limit_except = 4294967295U;
#line 4327
  value = (ngx_str_t *)(cf->args)->elts;
#line 4329
  i = (ngx_uint_t )1;
  {
#line 4329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4329
    if (! (i < (cf->args)->nelts)) {
#line 4329
      goto while_break;
    }
#line 4330
    name = ngx_methods_names;
    {
#line 4330
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 4330
      if (! name->name) {
#line 4330
        goto while_break___0;
      }
      {
#line 4332
      tmp = ngx_strcasecmp((value + i)->data, name->name);
      }
#line 4332
      if (tmp == 0L) {
#line 4333
        pclcf->limit_except &= name->method;
#line 4334
        goto next;
      }
#line 4330
      name ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 4338
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid method \"%V\"", value + i);
    }
#line 4340
    return ((char *)((void *)-1));
    next: 
#line 4343
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 4329
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4346
  if (! (pclcf->limit_except & 2U)) {
#line 4347
    pclcf->limit_except &= 4294967291U;
  }
  {
#line 4350
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 4350
  ctx = (ngx_http_conf_ctx_t *)tmp___0;
  }
#line 4351
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 4352
    return ((char *)((void *)-1));
  }
  {
#line 4355
  pctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 4356
  ctx->main_conf = pctx->main_conf;
#line 4357
  ctx->srv_conf = pctx->srv_conf;
#line 4359
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 4359
  ctx->loc_conf = (void **)tmp___1;
  }
#line 4360
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 4361
    return ((char *)((void *)-1));
  }
#line 4364
  i = (ngx_uint_t )0;
  {
#line 4364
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 4364
    if (! *((cf->cycle)->modules + i)) {
#line 4364
      goto while_break___1;
    }
#line 4365
    if ((*((cf->cycle)->modules + i))->type != 1347703880UL) {
#line 4366
      goto __Cont___0;
    }
#line 4369
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 4371
    if (module->create_loc_conf) {
      {
#line 4373
      mconf = (*(module->create_loc_conf))(cf);
      }
#line 4374
      if ((unsigned long )mconf == (unsigned long )((void *)0)) {
#line 4375
        return ((char *)((void *)-1));
      }
#line 4378
      *(ctx->loc_conf + (*((cf->cycle)->modules + i))->ctx_index) = mconf;
    }
    __Cont___0: /* CIL Label */ 
#line 4364
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 4383
  clcf = (ngx_http_core_loc_conf_t *)*(ctx->loc_conf + ngx_http_core_module.ctx_index);
#line 4384
  pclcf->limit_except_loc_conf = ctx->loc_conf;
#line 4385
  clcf->loc_conf = ctx->loc_conf;
#line 4386
  clcf->name = pclcf->name;
#line 4387
  clcf->noname = 1U;
#line 4388
  clcf->lmt_excpt = 1U;
#line 4390
  tmp___2 = ngx_http_add_location(cf, & pclcf->locations, clcf);
  }
#line 4390
  if (tmp___2 != 0L) {
#line 4391
    return ((char *)((void *)-1));
  }
  {
#line 4394
  save = *cf;
#line 4395
  cf->ctx = (void *)ctx;
#line 4396
  cf->cmd_type = (ngx_uint_t )2147483648U;
#line 4398
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 4400
  *cf = save;
  }
#line 4402
  return (rv);
}
}
#line 4406 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_set_aio(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 4409
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4413
  if (clcf->aio != -1L) {
#line 4414
    return ((char *)"is duplicate");
  }
  {
#line 4422
  value = (ngx_str_t *)(cf->args)->elts;
#line 4424
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 4424
  if (tmp == 0) {
#line 4425
    clcf->aio = (ngx_flag_t )0;
#line 4426
    return ((char *)((void *)0));
  }
  {
#line 4429
  tmp___0 = strcmp((char const   *)(value + 1)->data, "on");
  }
#line 4429
  if (tmp___0 == 0) {
    {
#line 4434
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"aio on\" is unsupported on this platform");
    }
#line 4437
    return ((char *)((void *)-1));
  }
  {
#line 4454
  tmp___1 = strncmp((char const   *)(value + 1)->data, "threads", (size_t )7);
  }
#line 4454
  if (tmp___1 == 0) {
#line 4454
    if ((value + 1)->len == 7UL) {
      {
#line 4505
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"aio threads\" is unsupported on this platform");
      }
#line 4508
      return ((char *)((void *)-1));
    } else
#line 4454
    if ((int )*((value + 1)->data + 7) == 61) {
      {
#line 4505
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"aio threads\" is unsupported on this platform");
      }
#line 4508
      return ((char *)((void *)-1));
    }
  }
#line 4512
  return ((char *)"invalid value");
}
}
#line 4516 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_directio(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 4519
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4523
  if (clcf->directio != -1L) {
#line 4524
    return ((char *)"is duplicate");
  }
  {
#line 4527
  value = (ngx_str_t *)(cf->args)->elts;
#line 4529
  tmp = strcmp((char const   *)(value + 1)->data, "off");
  }
#line 4529
  if (tmp == 0) {
#line 4530
    clcf->directio = (off_t )9223372036854775807LL;
#line 4531
    return ((char *)((void *)0));
  }
  {
#line 4534
  clcf->directio = ngx_parse_offset(value + 1);
  }
#line 4535
  if (clcf->directio == -1L) {
#line 4536
    return ((char *)"invalid value");
  }
#line 4539
  return ((char *)((void *)0));
}
}
#line 4543 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_error_page(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  u_char *p ;
  ngx_int_t overwrite ;
  ngx_str_t *value ;
  ngx_str_t uri___0 ;
  ngx_str_t args___0 ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_http_err_page_t *err ;
  ngx_http_complex_value_t cv ;
  ngx_http_compile_complex_value_t ccv ;
  ngx_int_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 4546
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4556
  if ((unsigned long )clcf->error_pages == (unsigned long )((void *)0)) {
    {
#line 4557
    clcf->error_pages = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_http_err_page_t ));
    }
#line 4559
    if ((unsigned long )clcf->error_pages == (unsigned long )((void *)0)) {
#line 4560
      return ((char *)((void *)-1));
    }
  }
#line 4564
  value = (ngx_str_t *)(cf->args)->elts;
#line 4566
  i = (cf->args)->nelts - 2UL;
#line 4568
  if ((int )*((value + i)->data + 0) == 61) {
#line 4569
    if (i == 1UL) {
      {
#line 4570
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
      }
#line 4572
      return ((char *)((void *)-1));
    }
#line 4575
    if ((value + i)->len > 1UL) {
      {
#line 4576
      overwrite = ngx_atoi((value + i)->data + 1, (value + i)->len - 1UL);
      }
#line 4578
      if (overwrite == -1L) {
        {
#line 4579
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
        }
#line 4581
        return ((char *)((void *)-1));
      }
    } else {
#line 4585
      overwrite = (ngx_int_t )0;
    }
#line 4588
    n = (ngx_uint_t )2;
  } else {
#line 4591
    overwrite = (ngx_int_t )-1;
#line 4592
    n = (ngx_uint_t )1;
  }
  {
#line 4595
  uri___0 = *(value + ((cf->args)->nelts - 1UL));
#line 4597
  memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4599
  ccv.cf = cf;
#line 4600
  ccv.value = & uri___0;
#line 4601
  ccv.complex_value = & cv;
#line 4603
  tmp = ngx_http_compile_complex_value(& ccv);
  }
#line 4603
  if (tmp != 0L) {
#line 4604
    return ((char *)((void *)-1));
  }
#line 4607
  args___0.len = (size_t )0;
#line 4607
  args___0.data = (u_char *)((void *)0);
#line 4609
  if ((unsigned long )cv.lengths == (unsigned long )((void *)0)) {
#line 4609
    if (uri___0.len) {
#line 4609
      if ((int )*(uri___0.data + 0) == 47) {
        {
#line 4610
        tmp___0 = strchr((char const   *)uri___0.data, '?');
#line 4610
        p = (u_char *)tmp___0;
        }
#line 4612
        if (p) {
#line 4613
          cv.value.len = (size_t )(p - uri___0.data);
#line 4614
          cv.value.data = uri___0.data;
#line 4615
          p ++;
#line 4616
          args___0.len = (size_t )((uri___0.data + uri___0.len) - p);
#line 4617
          args___0.data = p;
        }
      }
    }
  }
#line 4621
  i = (ngx_uint_t )1;
  {
#line 4621
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4621
    if (! (i < (cf->args)->nelts - n)) {
#line 4621
      goto while_break;
    }
    {
#line 4622
    tmp___1 = ngx_array_push(clcf->error_pages);
#line 4622
    err = (ngx_http_err_page_t *)tmp___1;
    }
#line 4623
    if ((unsigned long )err == (unsigned long )((void *)0)) {
#line 4624
      return ((char *)((void *)-1));
    }
    {
#line 4627
    err->status = ngx_atoi((value + i)->data, (value + i)->len);
    }
#line 4629
    if (err->status == -1L) {
      {
#line 4630
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
      }
#line 4632
      return ((char *)((void *)-1));
    } else
#line 4629
    if (err->status == 499L) {
      {
#line 4630
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
      }
#line 4632
      return ((char *)((void *)-1));
    }
#line 4635
    if (err->status < 300L) {
      {
#line 4636
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "value \"%V\" must be between 300 and 599",
                         value + i);
      }
#line 4639
      return ((char *)((void *)-1));
    } else
#line 4635
    if (err->status > 599L) {
      {
#line 4636
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "value \"%V\" must be between 300 and 599",
                         value + i);
      }
#line 4639
      return ((char *)((void *)-1));
    }
#line 4642
    err->overwrite = overwrite;
#line 4644
    if (overwrite == -1L) {
      {
#line 4648
      if (err->status == 496L) {
#line 4648
        goto case_496;
      }
#line 4648
      if (err->status == 495L) {
#line 4648
        goto case_496;
      }
#line 4648
      if (err->status == 497L) {
#line 4648
        goto case_496;
      }
#line 4645
      goto switch_break;
      case_496: /* CIL Label */ 
      case_495: /* CIL Label */ 
      case_497: /* CIL Label */ 
#line 4649
      err->overwrite = (ngx_int_t )400;
      switch_break: /* CIL Label */ ;
      }
    }
#line 4653
    err->value = cv;
#line 4654
    err->args = args___0;
#line 4621
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4657
  return ((char *)((void *)0));
}
}
#line 4661 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_open_file_cache(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  time_t inactive ;
  ngx_str_t *value ;
  ngx_str_t s ;
  ngx_int_t max ;
  ngx_uint_t i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 4664
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4671
  if ((unsigned long )clcf->open_file_cache != (unsigned long )((void *)-1)) {
#line 4672
    return ((char *)"is duplicate");
  }
#line 4675
  value = (ngx_str_t *)(cf->args)->elts;
#line 4677
  max = (ngx_int_t )0;
#line 4678
  inactive = (time_t )60;
#line 4680
  i = (ngx_uint_t )1;
  {
#line 4680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4680
    if (! (i < (cf->args)->nelts)) {
#line 4680
      goto while_break;
    }
    {
#line 4682
    tmp = strncmp((char const   *)(value + i)->data, "max=", (size_t )4);
    }
#line 4682
    if (tmp == 0) {
      {
#line 4684
      max = ngx_atoi((value + i)->data + 4, (value + i)->len - 4UL);
      }
#line 4685
      if (max <= 0L) {
#line 4686
        goto failed;
      }
#line 4689
      goto __Cont;
    }
    {
#line 4692
    tmp___0 = strncmp((char const   *)(value + i)->data, "inactive=", (size_t )9);
    }
#line 4692
    if (tmp___0 == 0) {
      {
#line 4694
      s.len = (value + i)->len - 9UL;
#line 4695
      s.data = (value + i)->data + 9;
#line 4697
      inactive = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 4698
      if (inactive == -1L) {
#line 4699
        goto failed;
      }
#line 4702
      goto __Cont;
    }
    {
#line 4705
    tmp___1 = strcmp((char const   *)(value + i)->data, "off");
    }
#line 4705
    if (tmp___1 == 0) {
#line 4707
      clcf->open_file_cache = (ngx_open_file_cache_t *)((void *)0);
#line 4709
      goto __Cont;
    }
    failed: 
    {
#line 4714
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid \"open_file_cache\" parameter \"%V\"",
                       value + i);
    }
#line 4717
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 4680
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4720
  if ((unsigned long )clcf->open_file_cache == (unsigned long )((void *)0)) {
#line 4721
    return ((char *)((void *)0));
  }
#line 4724
  if (max == 0L) {
    {
#line 4725
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"open_file_cache\" must have the \"max\" parameter");
    }
#line 4727
    return ((char *)((void *)-1));
  }
  {
#line 4730
  clcf->open_file_cache = ngx_open_file_cache_init(cf->pool, (ngx_uint_t )max, inactive);
  }
#line 4731
  if (clcf->open_file_cache) {
#line 4732
    return ((char *)((void *)0));
  }
#line 4735
  return ((char *)((void *)-1));
}
}
#line 4739 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_error_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  char *tmp ;

  {
  {
#line 4742
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4744
  tmp = ngx_log_set_log(cf, & clcf->error_log);
  }
#line 4744
  return (tmp);
}
}
#line 4748 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_keepalive(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_int_t tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 4751
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4755
  if (clcf->keepalive_timeout != 0xffffffffffffffffUL) {
#line 4756
    return ((char *)"is duplicate");
  }
  {
#line 4759
  value = (ngx_str_t *)(cf->args)->elts;
#line 4761
  tmp = ngx_parse_time(value + 1, (ngx_uint_t )0);
#line 4761
  clcf->keepalive_timeout = (ngx_msec_t )tmp;
  }
#line 4763
  if (clcf->keepalive_timeout == 0xffffffffffffffffUL) {
#line 4764
    return ((char *)"invalid value");
  }
#line 4767
  if ((cf->args)->nelts == 2UL) {
#line 4768
    return ((char *)((void *)0));
  }
  {
#line 4771
  clcf->keepalive_header = ngx_parse_time(value + 2, (ngx_uint_t )1);
  }
#line 4773
  if (clcf->keepalive_header == -1L) {
#line 4774
    return ((char *)"invalid value");
  }
#line 4777
  return ((char *)((void *)0));
}
}
#line 4781 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_internal(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  char *__cil_tmp5 ;

  {
#line 4784
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4786
  if (clcf->internal != -1L) {
#line 4787
    return ((char *)"is duplicate");
  }
#line 4790
  clcf->internal = (ngx_flag_t )1;
#line 4792
  return ((char *)((void *)0));
}
}
#line 4796 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_resolver(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  char *__cil_tmp6 ;

  {
#line 4799
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4803
  if (clcf->resolver) {
#line 4804
    return ((char *)"is duplicate");
  }
  {
#line 4807
  value = (ngx_str_t *)(cf->args)->elts;
#line 4809
  clcf->resolver = ngx_resolver_create(cf, value + 1, (cf->args)->nelts - 1UL);
  }
#line 4810
  if ((unsigned long )clcf->resolver == (unsigned long )((void *)0)) {
#line 4811
    return ((char *)((void *)-1));
  }
#line 4814
  return ((char *)((void *)0));
}
}
#line 4820 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_gzip_disable(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_regex_elt_t *re ;
  ngx_regex_compile_t rc ;
  u_char errstr[1024] ;
  int tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 4823
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4833
  if ((unsigned long )clcf->gzip_disable == (unsigned long )((void *)-1)) {
    {
#line 4834
    clcf->gzip_disable = ngx_array_create(cf->pool, (ngx_uint_t )2, sizeof(ngx_regex_elt_t ));
    }
#line 4836
    if ((unsigned long )clcf->gzip_disable == (unsigned long )((void *)0)) {
#line 4837
      return ((char *)((void *)-1));
    }
  }
  {
#line 4841
  value = (ngx_str_t *)(cf->args)->elts;
#line 4843
  memset((void *)(& rc), 0, sizeof(ngx_regex_compile_t ));
#line 4845
  rc.pool = cf->pool;
#line 4846
  rc.err.len = (size_t )1024;
#line 4847
  rc.err.data = errstr;
#line 4849
  i = (ngx_uint_t )1;
  }
  {
#line 4849
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4849
    if (! (i < (cf->args)->nelts)) {
#line 4849
      goto while_break;
    }
    {
#line 4851
    tmp = strcmp((char const   *)(value + i)->data, "msie6");
    }
#line 4851
    if (tmp == 0) {
#line 4852
      clcf->gzip_disable_msie6 = 1U;
#line 4853
      goto __Cont;
    }
    {
#line 4865
    tmp___0 = ngx_array_push(clcf->gzip_disable);
#line 4865
    re = (ngx_regex_elt_t *)tmp___0;
    }
#line 4866
    if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 4867
      return ((char *)((void *)-1));
    }
    {
#line 4870
    rc.pattern = *(value + i);
#line 4871
    rc.options = (ngx_int_t )1;
#line 4873
    tmp___1 = ngx_regex_compile(& rc);
    }
#line 4873
    if (tmp___1 != 0L) {
      {
#line 4874
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%V", & rc.err);
      }
#line 4875
      return ((char *)((void *)-1));
    }
#line 4878
    re->regex = rc.regex;
#line 4879
    re->name = (value + i)->data;
    __Cont: /* CIL Label */ 
#line 4849
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4882
  return ((char *)((void *)0));
}
}
#line 4922 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_disable_symlinks(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_http_core_loc_conf_t *clcf ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_http_compile_complex_value_t ccv ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 4925
  clcf = (ngx_http_core_loc_conf_t *)conf;
#line 4931
  if (clcf->disable_symlinks != 0xffffffffffffffffUL) {
#line 4932
    return ((char *)"is duplicate");
  }
#line 4935
  value = (ngx_str_t *)(cf->args)->elts;
#line 4937
  i = (ngx_uint_t )1;
  {
#line 4937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4937
    if (! (i < (cf->args)->nelts)) {
#line 4937
      goto while_break;
    }
    {
#line 4939
    tmp = strcmp((char const   *)(value + i)->data, "off");
    }
#line 4939
    if (tmp == 0) {
#line 4940
      clcf->disable_symlinks = (ngx_uint_t )0;
#line 4941
      goto __Cont;
    }
    {
#line 4944
    tmp___0 = strcmp((char const   *)(value + i)->data, "if_not_owner");
    }
#line 4944
    if (tmp___0 == 0) {
#line 4945
      clcf->disable_symlinks = (ngx_uint_t )2;
#line 4946
      goto __Cont;
    }
    {
#line 4949
    tmp___1 = strcmp((char const   *)(value + i)->data, "on");
    }
#line 4949
    if (tmp___1 == 0) {
#line 4950
      clcf->disable_symlinks = (ngx_uint_t )1;
#line 4951
      goto __Cont;
    }
    {
#line 4954
    tmp___4 = strncmp((char const   *)(value + i)->data, "from=", (size_t )5);
    }
#line 4954
    if (tmp___4 == 0) {
      {
#line 4955
      (value + i)->len -= 5UL;
#line 4956
      (value + i)->data += 5;
#line 4958
      memset((void *)(& ccv), 0, sizeof(ngx_http_compile_complex_value_t ));
#line 4960
      ccv.cf = cf;
#line 4961
      ccv.value = value + i;
#line 4962
      tmp___2 = ngx_palloc(cf->pool, sizeof(ngx_http_complex_value_t ));
#line 4962
      ccv.complex_value = (ngx_http_complex_value_t *)tmp___2;
      }
#line 4964
      if ((unsigned long )ccv.complex_value == (unsigned long )((void *)0)) {
#line 4965
        return ((char *)((void *)-1));
      }
      {
#line 4968
      tmp___3 = ngx_http_compile_complex_value(& ccv);
      }
#line 4968
      if (tmp___3 != 0L) {
#line 4969
        return ((char *)((void *)-1));
      }
#line 4972
      clcf->disable_symlinks_from = ccv.complex_value;
#line 4974
      goto __Cont;
    }
    {
#line 4977
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter \"%V\"", value + i);
    }
#line 4979
    return ((char *)((void *)-1));
    __Cont: /* CIL Label */ 
#line 4937
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4982
  if (clcf->disable_symlinks == 0xffffffffffffffffUL) {
    {
#line 4983
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%V\" must have \"off\", \"on\" or \"if_not_owner\" parameter",
                       & cmd->name);
    }
#line 4987
    return ((char *)((void *)-1));
  }
#line 4990
  if ((cf->args)->nelts == 2UL) {
#line 4991
    clcf->disable_symlinks_from = (ngx_http_complex_value_t *)((void *)0);
#line 4992
    return ((char *)((void *)0));
  }
#line 4995
  if ((unsigned long )clcf->disable_symlinks_from == (unsigned long )((void *)-1)) {
    {
#line 4996
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate parameters \"%V %V\"", value + 1,
                       value + 2);
    }
#line 4999
    return ((char *)((void *)-1));
  }
#line 5002
  if (clcf->disable_symlinks == 0UL) {
    {
#line 5003
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"from=\" cannot be used with \"off\" parameter");
    }
#line 5005
    return ((char *)((void *)-1));
  }
#line 5008
  return ((char *)((void *)0));
}
}
#line 5014 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_lowat_check(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ssize_t *np ;
  char *__cil_tmp5 ;

  {
  {
#line 5030
  np = (ssize_t *)data;
#line 5032
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "\"send_lowat\" is not supported, ignored");
#line 5035
  *np = (ssize_t )0;
  }
#line 5039
  return ((char *)((void *)0));
}
}
#line 5043 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http_core_module.c"
static char *ngx_http_core_pool_size(ngx_conf_t *cf , void *post , void *data ) 
{ 
  size_t *sp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 5046
  sp = (size_t *)data;
#line 5048
  if (*sp < (((sizeof(ngx_pool_t ) + 2UL * sizeof(ngx_pool_large_t )) + 15UL) & 0xfffffffffffffff0UL)) {
    {
#line 5049
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the pool size must be no less than %uz",
                       ((sizeof(ngx_pool_t ) + 2UL * sizeof(ngx_pool_large_t )) + 15UL) & 0xfffffffffffffff0UL);
    }
#line 5052
    return ((char *)((void *)-1));
  }
#line 5055
  if (*sp % 16UL) {
    {
#line 5056
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the pool size must be a multiple of %uz",
                       16);
    }
#line 5059
    return ((char *)((void *)-1));
  }
#line 5062
  return ((char *)((void *)0));
}
}
#line 227 "src/core/ngx_string.h"
void ngx_sort(void *base , size_t n , size_t size , ngx_int_t (*cmp)(void const   * ,
                                                                     void const   * ) ) ;
#line 107 "src/core/ngx_queue.h"
ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue ) ;
#line 108
void ngx_queue_sort(ngx_queue_t *queue , ngx_int_t (*cmp)(ngx_queue_t const   * ,
                                                          ngx_queue_t const   * ) ) ;
#line 124 "src/core/ngx_inet.h"
ngx_int_t ngx_cmp_sockaddr(struct sockaddr *sa1 , socklen_t slen1 , struct sockaddr *sa2 ,
                           socklen_t slen2 , ngx_uint_t cmp_port ) ;
#line 270 "src/core/ngx_module.h"
ngx_int_t ngx_count_modules(ngx_cycle_t *cycle , ngx_uint_t type ) ;
#line 206 "src/core/ngx_connection.h"
ngx_listening_t *ngx_create_listening(ngx_conf_t *cf , struct sockaddr *sockaddr ,
                                      socklen_t socklen ) ;
#line 208
ngx_int_t ngx_clone_listening(ngx_conf_t *cf , ngx_listening_t *ls ) ;
#line 511 "src/event/ngx_event.h"
u_char *ngx_accept_log_error(ngx_log_t *log , u_char *buf , size_t len ) ;
#line 530 "src/http/ngx_http_core_module.h"
ngx_uint_t ngx_http_max_module  ;
#line 158 "src/http/ngx_http.h"
ngx_int_t ngx_http_set_default_types(ngx_conf_t *cf , ngx_array_t **types , ngx_str_t *default_type ) ;
#line 171 "src/http/ngx_http.h"
ngx_int_t (*ngx_http_top_header_filter)(ngx_http_request_t *r )  ;
#line 172 "src/http/ngx_http.h"
ngx_int_t (*ngx_http_top_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 173 "src/http/ngx_http.h"
ngx_int_t (*ngx_http_top_request_body_filter)(ngx_http_request_t *r , ngx_chain_t *chain )  ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static char *ngx_http_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 14
static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) ;
#line 16
static ngx_int_t ngx_http_init_headers_in_hash(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) ;
#line 18
static ngx_int_t ngx_http_init_phase_handlers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) ;
#line 21
static ngx_int_t ngx_http_add_addresses(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                        ngx_http_conf_port_t *port , ngx_http_listen_opt_t *lsopt ) ;
#line 24
static ngx_int_t ngx_http_add_address(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                      ngx_http_conf_port_t *port , ngx_http_listen_opt_t *lsopt ) ;
#line 27
static ngx_int_t ngx_http_add_server(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                     ngx_http_conf_addr_t *addr ) ;
#line 30
static char *ngx_http_merge_servers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                    ngx_http_module_t *module , ngx_uint_t ctx_index ) ;
#line 33
static char *ngx_http_merge_locations(ngx_conf_t *cf , ngx_queue_t *locations , void **loc_conf ,
                                      ngx_http_module_t *module , ngx_uint_t ctx_index ) ;
#line 36
static ngx_int_t ngx_http_init_locations(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                         ngx_http_core_loc_conf_t *pclcf ) ;
#line 38
static ngx_int_t ngx_http_init_static_location_trees(ngx_conf_t *cf , ngx_http_core_loc_conf_t *pclcf ) ;
#line 40
static ngx_int_t ngx_http_cmp_locations(ngx_queue_t const   *one , ngx_queue_t const   *two ) ;
#line 42
static ngx_int_t ngx_http_join_exact_locations(ngx_conf_t *cf , ngx_queue_t *locations ) ;
#line 44
static void ngx_http_create_locations_list(ngx_queue_t *locations , ngx_queue_t *q ) ;
#line 46
static ngx_http_location_tree_node_t *ngx_http_create_locations_tree(ngx_conf_t *cf ,
                                                                     ngx_queue_t *locations ,
                                                                     size_t prefix ) ;
#line 50
static ngx_int_t ngx_http_optimize_servers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                           ngx_array_t *ports ) ;
#line 52
static ngx_int_t ngx_http_server_names(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                       ngx_http_conf_addr_t *addr ) ;
#line 54
static ngx_int_t ngx_http_cmp_conf_addrs(void const   *one , void const   *two ) ;
#line 55
static int ngx_http_cmp_dns_wildcards(void const   *one , void const   *two ) ;
#line 58
static ngx_int_t ngx_http_init_listening(ngx_conf_t *cf , ngx_http_conf_port_t *port ) ;
#line 60
static ngx_listening_t *ngx_http_add_listening(ngx_conf_t *cf , ngx_http_conf_addr_t *addr ) ;
#line 62
static ngx_int_t ngx_http_add_addrs(ngx_conf_t *cf , ngx_http_port_t *hport , ngx_http_conf_addr_t *addr ) ;
#line 65
static ngx_int_t ngx_http_add_addrs6(ngx_conf_t *cf , ngx_http_port_t *hport , ngx_http_conf_addr_t *addr ) ;
#line 77 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
ngx_str_t ngx_http_html_default_types[2]  = {      {sizeof("text/html") - 1UL, (u_char *)"text/html"}, 
        {(size_t )0, (u_char *)((void *)0)}};
#line 83 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_command_t ngx_http_commands[2]  = {      {{sizeof("http") - 1UL, (u_char *)"http"}, (ngx_uint_t )16777473, & ngx_http_block,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 96 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_core_module_t ngx_http_module_ctx  =    {{sizeof("http") - 1UL, (u_char *)"http"}, (void *(*)(ngx_cycle_t *cycle ))((void *)0),
    (char *(*)(ngx_cycle_t *cycle , void *conf ))((void *)0)};
#line 103 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
ngx_module_t ngx_http_module  = 
#line 103
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_http_module_ctx),
    ngx_http_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 119 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static char *ngx_http_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  ngx_uint_t mi ;
  ngx_uint_t m ;
  ngx_uint_t s ;
  ngx_conf_t pcf ;
  ngx_http_module_t *module ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t **cscfp ;
  ngx_http_core_main_conf_t *cmcf ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;
  ngx_int_t tmp___10 ;
  ngx_int_t tmp___11 ;
  ngx_int_t tmp___12 ;
  char *__cil_tmp28 ;

  {
#line 131
  if (*((ngx_http_conf_ctx_t **)conf)) {
#line 132
    return ((char *)"is duplicate");
  }
  {
#line 137
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_conf_ctx_t ));
#line 137
  ctx = (ngx_http_conf_ctx_t *)tmp;
  }
#line 138
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 139
    return ((char *)((void *)-1));
  }
  {
#line 142
  *((ngx_http_conf_ctx_t **)conf) = ctx;
#line 147
  tmp___0 = ngx_count_modules(cf->cycle, (ngx_uint_t )1347703880);
#line 147
  ngx_http_max_module = (ngx_uint_t )tmp___0;
#line 152
  tmp___1 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 152
  ctx->main_conf = (void **)tmp___1;
  }
#line 154
  if ((unsigned long )ctx->main_conf == (unsigned long )((void *)0)) {
#line 155
    return ((char *)((void *)-1));
  }
  {
#line 164
  tmp___2 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 164
  ctx->srv_conf = (void **)tmp___2;
  }
#line 165
  if ((unsigned long )ctx->srv_conf == (unsigned long )((void *)0)) {
#line 166
    return ((char *)((void *)-1));
  }
  {
#line 175
  tmp___3 = ngx_pcalloc(cf->pool, sizeof(void *) * ngx_http_max_module);
#line 175
  ctx->loc_conf = (void **)tmp___3;
  }
#line 176
  if ((unsigned long )ctx->loc_conf == (unsigned long )((void *)0)) {
#line 177
    return ((char *)((void *)-1));
  }
#line 186
  m = (ngx_uint_t )0;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 186
    if (! *((cf->cycle)->modules + m)) {
#line 186
      goto while_break;
    }
#line 187
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 188
      goto __Cont;
    }
#line 191
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 192
    mi = (*((cf->cycle)->modules + m))->ctx_index;
#line 194
    if (module->create_main_conf) {
      {
#line 195
      *(ctx->main_conf + mi) = (*(module->create_main_conf))(cf);
      }
#line 196
      if ((unsigned long )*(ctx->main_conf + mi) == (unsigned long )((void *)0)) {
#line 197
        return ((char *)((void *)-1));
      }
    }
#line 201
    if (module->create_srv_conf) {
      {
#line 202
      *(ctx->srv_conf + mi) = (*(module->create_srv_conf))(cf);
      }
#line 203
      if ((unsigned long )*(ctx->srv_conf + mi) == (unsigned long )((void *)0)) {
#line 204
        return ((char *)((void *)-1));
      }
    }
#line 208
    if (module->create_loc_conf) {
      {
#line 209
      *(ctx->loc_conf + mi) = (*(module->create_loc_conf))(cf);
      }
#line 210
      if ((unsigned long )*(ctx->loc_conf + mi) == (unsigned long )((void *)0)) {
#line 211
        return ((char *)((void *)-1));
      }
    }
    __Cont: /* CIL Label */ 
#line 186
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 216
  pcf = *cf;
#line 217
  cf->ctx = (void *)ctx;
#line 219
  m = (ngx_uint_t )0;
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    if (! *((cf->cycle)->modules + m)) {
#line 219
      goto while_break___0;
    }
#line 220
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 221
      goto __Cont___0;
    }
#line 224
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 226
    if (module->preconfiguration) {
      {
#line 227
      tmp___4 = (*(module->preconfiguration))(cf);
      }
#line 227
      if (tmp___4 != 0L) {
#line 228
        return ((char *)((void *)-1));
      }
    }
    __Cont___0: /* CIL Label */ 
#line 219
    m ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 235
  cf->module_type = (ngx_uint_t )1347703880;
#line 236
  cf->cmd_type = (ngx_uint_t )33554432;
#line 237
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
  }
#line 239
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 240
    goto failed;
  }
#line 248
  cmcf = (ngx_http_core_main_conf_t *)*(ctx->main_conf + ngx_http_core_module.ctx_index);
#line 249
  cscfp = (ngx_http_core_srv_conf_t **)cmcf->servers.elts;
#line 251
  m = (ngx_uint_t )0;
  {
#line 251
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 251
    if (! *((cf->cycle)->modules + m)) {
#line 251
      goto while_break___1;
    }
#line 252
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 253
      goto __Cont___1;
    }
#line 256
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 257
    mi = (*((cf->cycle)->modules + m))->ctx_index;
#line 261
    if (module->init_main_conf) {
      {
#line 262
      rv = (*(module->init_main_conf))(cf, *(ctx->main_conf + mi));
      }
#line 263
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 264
        goto failed;
      }
    }
    {
#line 268
    rv = ngx_http_merge_servers(cf, cmcf, module, mi);
    }
#line 269
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 270
      goto failed;
    }
    __Cont___1: /* CIL Label */ 
#line 251
    m ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 277
  s = (ngx_uint_t )0;
  {
#line 277
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 277
    if (! (s < cmcf->servers.nelts)) {
#line 277
      goto while_break___2;
    }
    {
#line 279
    clcf = (ngx_http_core_loc_conf_t *)*(((*(cscfp + s))->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 281
    tmp___5 = ngx_http_init_locations(cf, *(cscfp + s), clcf);
    }
#line 281
    if (tmp___5 != 0L) {
#line 282
      return ((char *)((void *)-1));
    }
    {
#line 285
    tmp___6 = ngx_http_init_static_location_trees(cf, clcf);
    }
#line 285
    if (tmp___6 != 0L) {
#line 286
      return ((char *)((void *)-1));
    }
#line 277
    s ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 291
  tmp___7 = ngx_http_init_phases(cf, cmcf);
  }
#line 291
  if (tmp___7 != 0L) {
#line 292
    return ((char *)((void *)-1));
  }
  {
#line 295
  tmp___8 = ngx_http_init_headers_in_hash(cf, cmcf);
  }
#line 295
  if (tmp___8 != 0L) {
#line 296
    return ((char *)((void *)-1));
  }
#line 300
  m = (ngx_uint_t )0;
  {
#line 300
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 300
    if (! *((cf->cycle)->modules + m)) {
#line 300
      goto while_break___3;
    }
#line 301
    if ((*((cf->cycle)->modules + m))->type != 1347703880UL) {
#line 302
      goto __Cont___2;
    }
#line 305
    module = (ngx_http_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 307
    if (module->postconfiguration) {
      {
#line 308
      tmp___9 = (*(module->postconfiguration))(cf);
      }
#line 308
      if (tmp___9 != 0L) {
#line 309
        return ((char *)((void *)-1));
      }
    }
    __Cont___2: /* CIL Label */ 
#line 300
    m ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 314
  tmp___10 = ngx_http_variables_init_vars(cf);
  }
#line 314
  if (tmp___10 != 0L) {
#line 315
    return ((char *)((void *)-1));
  }
  {
#line 323
  *cf = pcf;
#line 326
  tmp___11 = ngx_http_init_phase_handlers(cf, cmcf);
  }
#line 326
  if (tmp___11 != 0L) {
#line 327
    return ((char *)((void *)-1));
  }
  {
#line 333
  tmp___12 = ngx_http_optimize_servers(cf, cmcf, cmcf->ports);
  }
#line 333
  if (tmp___12 != 0L) {
#line 334
    return ((char *)((void *)-1));
  }
#line 337
  return ((char *)((void *)0));
  failed: 
#line 341
  *cf = pcf;
#line 343
  return (rv);
}
}
#line 347 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_phases(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;

  {
  {
#line 350
  tmp = ngx_array_init(& cmcf->phases[0].handlers, cf->pool, (ngx_uint_t )1, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 350
  if (tmp != 0L) {
#line 354
    return ((ngx_int_t )-1);
  }
  {
#line 357
  tmp___0 = ngx_array_init(& cmcf->phases[1].handlers, cf->pool, (ngx_uint_t )1, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 357
  if (tmp___0 != 0L) {
#line 361
    return ((ngx_int_t )-1);
  }
  {
#line 364
  tmp___1 = ngx_array_init(& cmcf->phases[3].handlers, cf->pool, (ngx_uint_t )1, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 364
  if (tmp___1 != 0L) {
#line 368
    return ((ngx_int_t )-1);
  }
  {
#line 371
  tmp___2 = ngx_array_init(& cmcf->phases[5].handlers, cf->pool, (ngx_uint_t )1, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 371
  if (tmp___2 != 0L) {
#line 375
    return ((ngx_int_t )-1);
  }
  {
#line 378
  tmp___3 = ngx_array_init(& cmcf->phases[6].handlers, cf->pool, (ngx_uint_t )2, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 378
  if (tmp___3 != 0L) {
#line 382
    return ((ngx_int_t )-1);
  }
  {
#line 385
  tmp___4 = ngx_array_init(& cmcf->phases[8].handlers, cf->pool, (ngx_uint_t )2, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 385
  if (tmp___4 != 0L) {
#line 389
    return ((ngx_int_t )-1);
  }
  {
#line 392
  tmp___5 = ngx_array_init(& cmcf->phases[9].handlers, cf->pool, (ngx_uint_t )4, sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 392
  if (tmp___5 != 0L) {
#line 396
    return ((ngx_int_t )-1);
  }
  {
#line 399
  tmp___6 = ngx_array_init(& cmcf->phases[10].handlers, cf->pool, (ngx_uint_t )1,
                           sizeof(ngx_int_t (*)(ngx_http_request_t *r )));
  }
#line 399
  if (tmp___6 != 0L) {
#line 403
    return ((ngx_int_t )-1);
  }
#line 406
  return ((ngx_int_t )0);
}
}
#line 410 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_headers_in_hash(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) 
{ 
  ngx_array_t headers_in ;
  ngx_hash_key_t *hk ;
  ngx_hash_init_t hash ;
  ngx_http_header_t *header___0 ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp10 ;

  {
  {
#line 418
  tmp = ngx_array_init(& headers_in, cf->temp_pool, (ngx_uint_t )32, sizeof(ngx_hash_key_t ));
  }
#line 418
  if (tmp != 0L) {
#line 421
    return ((ngx_int_t )-1);
  }
#line 424
  header___0 = ngx_http_headers_in;
  {
#line 424
  while (1) {
    while_continue: /* CIL Label */ ;
#line 424
    if (! header___0->name.len) {
#line 424
      goto while_break;
    }
    {
#line 425
    tmp___0 = ngx_array_push(& headers_in);
#line 425
    hk = (ngx_hash_key_t *)tmp___0;
    }
#line 426
    if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 427
      return ((ngx_int_t )-1);
    }
    {
#line 430
    hk->key = header___0->name;
#line 431
    hk->key_hash = ngx_hash_key_lc(header___0->name.data, header___0->name.len);
#line 432
    hk->value = (void *)header___0;
#line 424
    header___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 435
  hash.hash = & cmcf->headers_in_hash;
#line 436
  hash.key = & ngx_hash_key_lc;
#line 437
  hash.max_size = (ngx_uint_t )512;
#line 438
  hash.bucket_size = (64UL + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL);
#line 439
  hash.name = (char *)"headers_in_hash";
#line 440
  hash.pool = cf->pool;
#line 441
  hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 443
  tmp___1 = ngx_hash_init(& hash, (ngx_hash_key_t *)headers_in.elts, headers_in.nelts);
  }
#line 443
  if (tmp___1 != 0L) {
#line 444
    return ((ngx_int_t )-1);
  }
#line 447
  return ((ngx_int_t )0);
}
}
#line 451 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_phase_handlers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ) 
{ 
  ngx_int_t j ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t find_config_index ;
  ngx_uint_t use_rewrite ;
  ngx_uint_t use_access ;
  ngx_http_handler_pt *h ;
  ngx_http_phase_handler_t *ph ;
  ngx_int_t (*checker)(ngx_http_request_t *r , ngx_http_phase_handler_t *ph ) ;
  void *tmp ;

  {
#line 461
  cmcf->phase_engine.server_rewrite_index = (ngx_uint_t )-1;
#line 462
  cmcf->phase_engine.location_rewrite_index = (ngx_uint_t )-1;
#line 463
  find_config_index = (ngx_uint_t )0;
#line 464
  if (cmcf->phases[3].handlers.nelts) {
#line 464
    use_rewrite = (ngx_uint_t )1;
  } else {
#line 464
    use_rewrite = (ngx_uint_t )0;
  }
#line 465
  if (cmcf->phases[6].handlers.nelts) {
#line 465
    use_access = (ngx_uint_t )1;
  } else {
#line 465
    use_access = (ngx_uint_t )0;
  }
#line 467
  n = (1UL + use_rewrite) + use_access;
#line 471
  i = (ngx_uint_t )0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! (i < 10UL)) {
#line 471
      goto while_break;
    }
#line 472
    n += cmcf->phases[i].handlers.nelts;
#line 471
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 475
  tmp = ngx_pcalloc(cf->pool, n * sizeof(ngx_http_phase_handler_t ) + sizeof(void *));
#line 475
  ph = (ngx_http_phase_handler_t *)tmp;
  }
#line 477
  if ((unsigned long )ph == (unsigned long )((void *)0)) {
#line 478
    return ((ngx_int_t )-1);
  }
#line 481
  cmcf->phase_engine.handlers = ph;
#line 482
  n = (ngx_uint_t )0;
#line 484
  i = (ngx_uint_t )0;
  {
#line 484
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 484
    if (! (i < 10UL)) {
#line 484
      goto while_break___0;
    }
#line 485
    h = (ngx_http_handler_pt *)cmcf->phases[i].handlers.elts;
    {
#line 489
    if (i == 1UL) {
#line 489
      goto case_1;
    }
#line 497
    if (i == 2UL) {
#line 497
      goto case_2;
    }
#line 506
    if (i == 3UL) {
#line 506
      goto case_3;
    }
#line 514
    if (i == 4UL) {
#line 514
      goto case_4;
    }
#line 524
    if (i == 6UL) {
#line 524
      goto case_6;
    }
#line 529
    if (i == 7UL) {
#line 529
      goto case_7;
    }
#line 538
    if (i == 9UL) {
#line 538
      goto case_9;
    }
#line 542
    goto switch_default;
    case_1: /* CIL Label */ 
#line 490
    if (cmcf->phase_engine.server_rewrite_index == 0xffffffffffffffffUL) {
#line 491
      cmcf->phase_engine.server_rewrite_index = n;
    }
#line 493
    checker = & ngx_http_core_rewrite_phase;
#line 495
    goto switch_break;
    case_2: /* CIL Label */ 
#line 498
    find_config_index = n;
#line 500
    ph->checker = & ngx_http_core_find_config_phase;
#line 501
    n ++;
#line 502
    ph ++;
#line 504
    goto __Cont;
    case_3: /* CIL Label */ 
#line 507
    if (cmcf->phase_engine.location_rewrite_index == 0xffffffffffffffffUL) {
#line 508
      cmcf->phase_engine.location_rewrite_index = n;
    }
#line 510
    checker = & ngx_http_core_rewrite_phase;
#line 512
    goto switch_break;
    case_4: /* CIL Label */ 
#line 515
    if (use_rewrite) {
#line 516
      ph->checker = & ngx_http_core_post_rewrite_phase;
#line 517
      ph->next = find_config_index;
#line 518
      n ++;
#line 519
      ph ++;
    }
#line 522
    goto __Cont;
    case_6: /* CIL Label */ 
#line 525
    checker = & ngx_http_core_access_phase;
#line 526
    n ++;
#line 527
    goto switch_break;
    case_7: /* CIL Label */ 
#line 530
    if (use_access) {
#line 531
      ph->checker = & ngx_http_core_post_access_phase;
#line 532
      ph->next = n;
#line 533
      ph ++;
    }
#line 536
    goto __Cont;
    case_9: /* CIL Label */ 
#line 539
    checker = & ngx_http_core_content_phase;
#line 540
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 543
    checker = & ngx_http_core_generic_phase;
    switch_break: /* CIL Label */ ;
    }
#line 546
    n += cmcf->phases[i].handlers.nelts;
#line 548
    j = (ngx_int_t )(cmcf->phases[i].handlers.nelts - 1UL);
    {
#line 548
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 548
      if (! (j >= 0L)) {
#line 548
        goto while_break___1;
      }
#line 549
      ph->checker = checker;
#line 550
      ph->handler = *(h + j);
#line 551
      ph->next = n;
#line 552
      ph ++;
#line 548
      j --;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 484
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 556
  return ((ngx_int_t )0);
}
}
#line 560 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static char *ngx_http_merge_servers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                    ngx_http_module_t *module , ngx_uint_t ctx_index ) 
{ 
  char *rv ;
  ngx_uint_t s ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t saved ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t **cscfp ;

  {
#line 570
  cscfp = (ngx_http_core_srv_conf_t **)cmcf->servers.elts;
#line 571
  ctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 572
  saved = *ctx;
#line 573
  rv = (char *)((void *)0);
#line 575
  s = (ngx_uint_t )0;
  {
#line 575
  while (1) {
    while_continue: /* CIL Label */ ;
#line 575
    if (! (s < cmcf->servers.nelts)) {
#line 575
      goto while_break;
    }
#line 579
    ctx->srv_conf = ((*(cscfp + s))->ctx)->srv_conf;
#line 581
    if (module->merge_srv_conf) {
      {
#line 582
      rv = (*(module->merge_srv_conf))(cf, *(saved.srv_conf + ctx_index), *(((*(cscfp + s))->ctx)->srv_conf + ctx_index));
      }
#line 584
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 585
        goto failed;
      }
    }
#line 589
    if (module->merge_loc_conf) {
      {
#line 593
      ctx->loc_conf = ((*(cscfp + s))->ctx)->loc_conf;
#line 595
      rv = (*(module->merge_loc_conf))(cf, *(saved.loc_conf + ctx_index), *(((*(cscfp + s))->ctx)->loc_conf + ctx_index));
      }
#line 597
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 598
        goto failed;
      }
      {
#line 603
      clcf = (ngx_http_core_loc_conf_t *)*(((*(cscfp + s))->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 605
      rv = ngx_http_merge_locations(cf, clcf->locations, ((*(cscfp + s))->ctx)->loc_conf,
                                    module, ctx_index);
      }
#line 608
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 609
        goto failed;
      }
    }
#line 575
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
  failed: 
#line 616
  *ctx = saved;
#line 618
  return (rv);
}
}
#line 622 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static char *ngx_http_merge_locations(ngx_conf_t *cf , ngx_queue_t *locations , void **loc_conf ,
                                      ngx_http_module_t *module , ngx_uint_t ctx_index ) 
{ 
  char *rv ;
  ngx_queue_t *q ;
  ngx_http_conf_ctx_t *ctx ;
  ngx_http_conf_ctx_t saved ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_location_queue_t *lq ;

  {
#line 632
  if ((unsigned long )locations == (unsigned long )((void *)0)) {
#line 633
    return ((char *)((void *)0));
  }
#line 636
  ctx = (ngx_http_conf_ctx_t *)cf->ctx;
#line 637
  saved = *ctx;
#line 639
  q = locations->next;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    if (! ((unsigned long )q != (unsigned long )locations)) {
#line 639
      goto while_break;
    }
#line 643
    lq = (ngx_http_location_queue_t *)q;
#line 645
    if (lq->exact) {
#line 645
      clcf = lq->exact;
    } else {
#line 645
      clcf = lq->inclusive;
    }
    {
#line 646
    ctx->loc_conf = clcf->loc_conf;
#line 648
    rv = (*(module->merge_loc_conf))(cf, *(loc_conf + ctx_index), *(clcf->loc_conf + ctx_index));
    }
#line 650
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 651
      return (rv);
    }
    {
#line 654
    rv = ngx_http_merge_locations(cf, clcf->locations, clcf->loc_conf, module, ctx_index);
    }
#line 656
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 657
      return (rv);
    }
#line 639
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 661
  *ctx = saved;
#line 663
  return ((char *)((void *)0));
}
}
#line 667 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_locations(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                         ngx_http_core_loc_conf_t *pclcf ) 
{ 
  ngx_uint_t n ;
  ngx_queue_t *q ;
  ngx_queue_t *locations ;
  ngx_queue_t *named ;
  ngx_queue_t tail___1 ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_location_queue_t *lq ;
  ngx_http_core_loc_conf_t **clcfp ;
  ngx_uint_t r ;
  ngx_queue_t *regex ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_http_core_loc_conf_t **tmp___1 ;
  void *tmp___2 ;
  ngx_http_core_loc_conf_t **tmp___3 ;

  {
#line 681
  locations = pclcf->locations;
#line 683
  if ((unsigned long )locations == (unsigned long )((void *)0)) {
#line 684
    return ((ngx_int_t )0);
  }
  {
#line 687
  ngx_queue_sort(locations, & ngx_http_cmp_locations);
#line 689
  named = (ngx_queue_t *)((void *)0);
#line 690
  n = (ngx_uint_t )0;
#line 692
  regex = (ngx_queue_t *)((void *)0);
#line 693
  r = (ngx_uint_t )0;
#line 696
  q = locations->next;
  }
  {
#line 696
  while (1) {
    while_continue: /* CIL Label */ ;
#line 696
    if (! ((unsigned long )q != (unsigned long )locations)) {
#line 696
      goto while_break;
    }
#line 700
    lq = (ngx_http_location_queue_t *)q;
#line 702
    if (lq->exact) {
#line 702
      clcf = lq->exact;
    } else {
#line 702
      clcf = lq->inclusive;
    }
    {
#line 704
    tmp = ngx_http_init_locations(cf, (ngx_http_core_srv_conf_t *)((void *)0), clcf);
    }
#line 704
    if (tmp != 0L) {
#line 705
      return ((ngx_int_t )-1);
    }
#line 710
    if (clcf->regex) {
#line 711
      r ++;
#line 713
      if ((unsigned long )regex == (unsigned long )((void *)0)) {
#line 714
        regex = q;
      }
#line 717
      goto __Cont;
    }
#line 722
    if (clcf->named) {
#line 723
      n ++;
#line 725
      if ((unsigned long )named == (unsigned long )((void *)0)) {
#line 726
        named = q;
      }
#line 729
      goto __Cont;
    }
#line 732
    if (clcf->noname) {
#line 733
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 696
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  if ((unsigned long )q != (unsigned long )locations) {
#line 738
    tail___1.prev = locations->prev;
#line 738
    (tail___1.prev)->next = & tail___1;
#line 738
    tail___1.next = q;
#line 738
    locations->prev = q->prev;
#line 738
    (locations->prev)->next = locations;
#line 738
    q->prev = & tail___1;
  }
#line 741
  if (named) {
    {
#line 742
    tmp___0 = ngx_palloc(cf->pool, (n + 1UL) * sizeof(ngx_http_core_loc_conf_t *));
#line 742
    clcfp = (ngx_http_core_loc_conf_t **)tmp___0;
    }
#line 744
    if ((unsigned long )clcfp == (unsigned long )((void *)0)) {
#line 745
      return ((ngx_int_t )-1);
    }
#line 748
    cscf->named_locations = clcfp;
#line 750
    q = named;
    {
#line 750
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 750
      if (! ((unsigned long )q != (unsigned long )locations)) {
#line 750
        goto while_break___0;
      }
#line 754
      lq = (ngx_http_location_queue_t *)q;
#line 756
      tmp___1 = clcfp;
#line 756
      clcfp ++;
#line 756
      *tmp___1 = lq->exact;
#line 750
      q = q->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 759
    *clcfp = (ngx_http_core_loc_conf_t *)((void *)0);
#line 761
    tail___1.prev = locations->prev;
#line 761
    (tail___1.prev)->next = & tail___1;
#line 761
    tail___1.next = named;
#line 761
    locations->prev = named->prev;
#line 761
    (locations->prev)->next = locations;
#line 761
    named->prev = & tail___1;
  }
#line 766
  if (regex) {
    {
#line 768
    tmp___2 = ngx_palloc(cf->pool, (r + 1UL) * sizeof(ngx_http_core_loc_conf_t *));
#line 768
    clcfp = (ngx_http_core_loc_conf_t **)tmp___2;
    }
#line 770
    if ((unsigned long )clcfp == (unsigned long )((void *)0)) {
#line 771
      return ((ngx_int_t )-1);
    }
#line 774
    pclcf->regex_locations = clcfp;
#line 776
    q = regex;
    {
#line 776
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 776
      if (! ((unsigned long )q != (unsigned long )locations)) {
#line 776
        goto while_break___1;
      }
#line 780
      lq = (ngx_http_location_queue_t *)q;
#line 782
      tmp___3 = clcfp;
#line 782
      clcfp ++;
#line 782
      *tmp___3 = lq->exact;
#line 776
      q = q->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 785
    *clcfp = (ngx_http_core_loc_conf_t *)((void *)0);
#line 787
    tail___1.prev = locations->prev;
#line 787
    (tail___1.prev)->next = & tail___1;
#line 787
    tail___1.next = regex;
#line 787
    locations->prev = regex->prev;
#line 787
    (locations->prev)->next = locations;
#line 787
    regex->prev = & tail___1;
  }
#line 792
  return ((ngx_int_t )0);
}
}
#line 796 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_static_location_trees(ngx_conf_t *cf , ngx_http_core_loc_conf_t *pclcf ) 
{ 
  ngx_queue_t *q ;
  ngx_queue_t *locations ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_location_queue_t *lq ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 804
  locations = pclcf->locations;
#line 806
  if ((unsigned long )locations == (unsigned long )((void *)0)) {
#line 807
    return ((ngx_int_t )0);
  }
#line 810
  if ((unsigned long )locations == (unsigned long )locations->prev) {
#line 811
    return ((ngx_int_t )0);
  }
#line 814
  q = locations->next;
  {
#line 814
  while (1) {
    while_continue: /* CIL Label */ ;
#line 814
    if (! ((unsigned long )q != (unsigned long )locations)) {
#line 814
      goto while_break;
    }
#line 818
    lq = (ngx_http_location_queue_t *)q;
#line 820
    if (lq->exact) {
#line 820
      clcf = lq->exact;
    } else {
#line 820
      clcf = lq->inclusive;
    }
    {
#line 822
    tmp = ngx_http_init_static_location_trees(cf, clcf);
    }
#line 822
    if (tmp != 0L) {
#line 823
      return ((ngx_int_t )-1);
    }
#line 814
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 827
  tmp___0 = ngx_http_join_exact_locations(cf, locations);
  }
#line 827
  if (tmp___0 != 0L) {
#line 828
    return ((ngx_int_t )-1);
  }
  {
#line 831
  ngx_http_create_locations_list(locations, locations->next);
#line 833
  pclcf->static_locations = ngx_http_create_locations_tree(cf, locations, (size_t )0);
  }
#line 834
  if ((unsigned long )pclcf->static_locations == (unsigned long )((void *)0)) {
#line 835
    return ((ngx_int_t )-1);
  }
#line 838
  return ((ngx_int_t )0);
}
}
#line 842 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
ngx_int_t ngx_http_add_location(ngx_conf_t *cf , ngx_queue_t **locations , ngx_http_core_loc_conf_t *clcf ) 
{ 
  ngx_http_location_queue_t *lq ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 848
  if ((unsigned long )*locations == (unsigned long )((void *)0)) {
    {
#line 849
    tmp = ngx_palloc(cf->temp_pool, sizeof(ngx_http_location_queue_t ));
#line 849
    *locations = (ngx_queue_t *)tmp;
    }
#line 851
    if ((unsigned long )*locations == (unsigned long )((void *)0)) {
#line 852
      return ((ngx_int_t )-1);
    }
#line 855
    (*locations)->prev = *locations;
#line 855
    (*locations)->next = *locations;
  }
  {
#line 858
  tmp___0 = ngx_palloc(cf->temp_pool, sizeof(ngx_http_location_queue_t ));
#line 858
  lq = (ngx_http_location_queue_t *)tmp___0;
  }
#line 859
  if ((unsigned long )lq == (unsigned long )((void *)0)) {
#line 860
    return ((ngx_int_t )-1);
  }
#line 863
  if (clcf->exact_match) {
#line 869
    lq->exact = clcf;
#line 870
    lq->inclusive = (ngx_http_core_loc_conf_t *)((void *)0);
  } else
#line 863
  if (clcf->regex) {
#line 869
    lq->exact = clcf;
#line 870
    lq->inclusive = (ngx_http_core_loc_conf_t *)((void *)0);
  } else
#line 863
  if (clcf->named) {
#line 869
    lq->exact = clcf;
#line 870
    lq->inclusive = (ngx_http_core_loc_conf_t *)((void *)0);
  } else
#line 863
  if (clcf->noname) {
#line 869
    lq->exact = clcf;
#line 870
    lq->inclusive = (ngx_http_core_loc_conf_t *)((void *)0);
  } else {
#line 873
    lq->exact = (ngx_http_core_loc_conf_t *)((void *)0);
#line 874
    lq->inclusive = clcf;
  }
#line 877
  lq->name = & clcf->name;
#line 878
  lq->file_name = (cf->conf_file)->file.name.data;
#line 879
  lq->line = (cf->conf_file)->line;
#line 881
  lq->list.prev = & lq->list;
#line 881
  lq->list.next = & lq->list;
#line 883
  lq->queue.prev = (*locations)->prev;
#line 883
  (lq->queue.prev)->next = & lq->queue;
#line 883
  lq->queue.next = *locations;
#line 883
  (*locations)->prev = & lq->queue;
#line 885
  return ((ngx_int_t )0);
}
}
#line 889 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_cmp_locations(ngx_queue_t const   *one , ngx_queue_t const   *two ) 
{ 
  ngx_int_t rc ;
  ngx_http_core_loc_conf_t *first ;
  ngx_http_core_loc_conf_t *second ;
  ngx_http_location_queue_t *lq1 ;
  ngx_http_location_queue_t *lq2 ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 896
  lq1 = (ngx_http_location_queue_t *)one;
#line 897
  lq2 = (ngx_http_location_queue_t *)two;
#line 899
  if (lq1->exact) {
#line 899
    first = lq1->exact;
  } else {
#line 899
    first = lq1->inclusive;
  }
#line 900
  if (lq2->exact) {
#line 900
    second = lq2->exact;
  } else {
#line 900
    second = lq2->inclusive;
  }
#line 902
  if (first->noname) {
#line 902
    if (! second->noname) {
#line 904
      return ((ngx_int_t )1);
    }
  }
#line 907
  if (! first->noname) {
#line 907
    if (second->noname) {
#line 909
      return ((ngx_int_t )-1);
    }
  }
#line 912
  if (first->noname) {
#line 914
    return ((ngx_int_t )0);
  } else
#line 912
  if (second->noname) {
#line 914
    return ((ngx_int_t )0);
  }
#line 917
  if (first->named) {
#line 917
    if (! second->named) {
#line 919
      return ((ngx_int_t )1);
    }
  }
#line 922
  if (! first->named) {
#line 922
    if (second->named) {
#line 924
      return ((ngx_int_t )-1);
    }
  }
#line 927
  if (first->named) {
#line 927
    if (second->named) {
      {
#line 928
      tmp = strcmp((char const   *)first->name.data, (char const   *)second->name.data);
      }
#line 928
      return ((ngx_int_t )tmp);
    }
  }
#line 933
  if (first->regex) {
#line 933
    if (! second->regex) {
#line 935
      return ((ngx_int_t )1);
    }
  }
#line 938
  if (! first->regex) {
#line 938
    if (second->regex) {
#line 940
      return ((ngx_int_t )-1);
    }
  }
#line 943
  if (first->regex) {
#line 945
    return ((ngx_int_t )0);
  } else
#line 943
  if (second->regex) {
#line 945
    return ((ngx_int_t )0);
  }
#line 950
  if (first->name.len > second->name.len) {
#line 950
    tmp___0 = second->name.len;
  } else {
#line 950
    tmp___0 = first->name.len;
  }
  {
#line 950
  rc = ngx_filename_cmp(first->name.data, second->name.data, tmp___0 + 1UL);
  }
#line 953
  if (rc == 0L) {
#line 953
    if (! first->exact_match) {
#line 953
      if (second->exact_match) {
#line 955
        return ((ngx_int_t )1);
      }
    }
  }
#line 958
  return (rc);
}
}
#line 962 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_join_exact_locations(ngx_conf_t *cf , ngx_queue_t *locations ) 
{ 
  ngx_queue_t *q ;
  ngx_queue_t *x ;
  ngx_http_location_queue_t *lq ;
  ngx_http_location_queue_t *lx ;
  ngx_int_t tmp ;
  char *__cil_tmp8 ;

  {
#line 968
  q = locations->next;
  {
#line 970
  while (1) {
    while_continue: /* CIL Label */ ;
#line 970
    if (! ((unsigned long )q != (unsigned long )locations->prev)) {
#line 970
      goto while_break;
    }
#line 972
    x = q->next;
#line 974
    lq = (ngx_http_location_queue_t *)q;
#line 975
    lx = (ngx_http_location_queue_t *)x;
#line 977
    if ((lq->name)->len == (lx->name)->len) {
      {
#line 977
      tmp = ngx_filename_cmp((lq->name)->data, (lx->name)->data, (lx->name)->len);
      }
#line 977
      if (tmp == 0L) {
#line 981
        if (lq->exact) {
#line 981
          if (lx->exact) {
#line 981
            goto _L;
          } else {
#line 981
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 981
        if (lq->inclusive) {
#line 981
          if (lx->inclusive) {
            _L: /* CIL Label */ 
#line 982
            if ((cf->log)->log_level >= 1UL) {
              {
#line 982
              ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "duplicate location \"%V\" in %s:%ui",
                                 lx->name, lx->file_name, lx->line);
              }
            }
#line 986
            return ((ngx_int_t )-1);
          }
        }
#line 989
        lq->inclusive = lx->inclusive;
#line 991
        (x->next)->prev = x->prev;
#line 991
        (x->prev)->next = x->next;
#line 993
        goto while_continue;
      }
    }
#line 996
    q = q->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 999
  return ((ngx_int_t )0);
}
}
#line 1003 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static void ngx_http_create_locations_list(ngx_queue_t *locations , ngx_queue_t *q ) 
{ 
  u_char *name ;
  size_t len ;
  ngx_queue_t *x ;
  ngx_queue_t tail___1 ;
  ngx_http_location_queue_t *lq ;
  ngx_http_location_queue_t *lx ;
  ngx_int_t tmp ;

  {
#line 1011
  if ((unsigned long )q == (unsigned long )locations->prev) {
#line 1012
    return;
  }
#line 1015
  lq = (ngx_http_location_queue_t *)q;
#line 1017
  if ((unsigned long )lq->inclusive == (unsigned long )((void *)0)) {
    {
#line 1018
    ngx_http_create_locations_list(locations, q->next);
    }
#line 1019
    return;
  }
#line 1022
  len = (lq->name)->len;
#line 1023
  name = (lq->name)->data;
#line 1025
  x = q->next;
  {
#line 1025
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1025
    if (! ((unsigned long )x != (unsigned long )locations)) {
#line 1025
      goto while_break;
    }
#line 1029
    lx = (ngx_http_location_queue_t *)x;
#line 1031
    if (len > (lx->name)->len) {
#line 1034
      goto while_break;
    } else {
      {
#line 1031
      tmp = ngx_filename_cmp(name, (lx->name)->data, len);
      }
#line 1031
      if (tmp != 0L) {
#line 1034
        goto while_break;
      }
    }
#line 1025
    x = x->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1038
  q = q->next;
#line 1040
  if ((unsigned long )q == (unsigned long )x) {
    {
#line 1041
    ngx_http_create_locations_list(locations, x);
    }
#line 1042
    return;
  }
#line 1045
  tail___1.prev = locations->prev;
#line 1045
  (tail___1.prev)->next = & tail___1;
#line 1045
  tail___1.next = q;
#line 1045
  locations->prev = q->prev;
#line 1045
  (locations->prev)->next = locations;
#line 1045
  q->prev = & tail___1;
#line 1046
  (lq->list.prev)->next = tail___1.next;
#line 1046
  (tail___1.next)->prev = lq->list.prev;
#line 1046
  lq->list.prev = tail___1.prev;
#line 1046
  (lq->list.prev)->next = & lq->list;
#line 1048
  if ((unsigned long )x == (unsigned long )locations) {
    {
#line 1049
    ngx_http_create_locations_list(& lq->list, lq->list.next);
    }
#line 1050
    return;
  }
  {
#line 1053
  tail___1.prev = lq->list.prev;
#line 1053
  (tail___1.prev)->next = & tail___1;
#line 1053
  tail___1.next = x;
#line 1053
  lq->list.prev = x->prev;
#line 1053
  (lq->list.prev)->next = & lq->list;
#line 1053
  x->prev = & tail___1;
#line 1054
  (locations->prev)->next = tail___1.next;
#line 1054
  (tail___1.next)->prev = locations->prev;
#line 1054
  locations->prev = tail___1.prev;
#line 1054
  (locations->prev)->next = locations;
#line 1056
  ngx_http_create_locations_list(& lq->list, lq->list.next);
#line 1058
  ngx_http_create_locations_list(locations, x);
  }
#line 1059
  return;
}
}
#line 1067 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_http_location_tree_node_t *ngx_http_create_locations_tree(ngx_conf_t *cf ,
                                                                     ngx_queue_t *locations ,
                                                                     size_t prefix ) 
{ 
  size_t len ;
  ngx_queue_t *q ;
  ngx_queue_t tail___1 ;
  ngx_http_location_queue_t *lq ;
  ngx_http_location_tree_node_t *node ;
  void *tmp ;
  int tmp___0 ;

  {
  {
#line 1076
  q = ngx_queue_middle(locations);
#line 1078
  lq = (ngx_http_location_queue_t *)q;
#line 1079
  len = (lq->name)->len - prefix;
#line 1081
  tmp = ngx_palloc(cf->pool, (unsigned long )(& ((ngx_http_location_tree_node_t *)0)->name) + len);
#line 1081
  node = (ngx_http_location_tree_node_t *)tmp;
  }
#line 1083
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 1084
    return ((ngx_http_location_tree_node_t *)((void *)0));
  }
#line 1087
  node->left = (ngx_http_location_tree_node_t *)((void *)0);
#line 1088
  node->right = (ngx_http_location_tree_node_t *)((void *)0);
#line 1089
  node->tree = (ngx_http_location_tree_node_t *)((void *)0);
#line 1090
  node->exact = lq->exact;
#line 1091
  node->inclusive = lq->inclusive;
#line 1093
  if (lq->exact) {
#line 1093
    if ((lq->exact)->auto_redirect) {
#line 1093
      tmp___0 = 1;
    } else {
#line 1093
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1093
  if (lq->inclusive) {
#line 1093
    if ((lq->inclusive)->auto_redirect) {
#line 1093
      tmp___0 = 1;
    } else {
#line 1093
      tmp___0 = 0;
    }
  } else {
#line 1093
    tmp___0 = 0;
  }
  {
#line 1093
  node->auto_redirect = (u_char )tmp___0;
#line 1096
  node->len = (u_char )len;
#line 1097
  memcpy((void */* __restrict  */)(node->name), (void const   */* __restrict  */)((lq->name)->data + prefix),
         len);
#line 1099
  tail___1.prev = locations->prev;
#line 1099
  (tail___1.prev)->next = & tail___1;
#line 1099
  tail___1.next = q;
#line 1099
  locations->prev = q->prev;
#line 1099
  (locations->prev)->next = locations;
#line 1099
  q->prev = & tail___1;
  }
#line 1101
  if ((unsigned long )locations == (unsigned long )locations->prev) {
#line 1106
    goto inclusive;
  }
  {
#line 1109
  node->left = ngx_http_create_locations_tree(cf, locations, prefix);
  }
#line 1110
  if ((unsigned long )node->left == (unsigned long )((void *)0)) {
#line 1111
    return ((ngx_http_location_tree_node_t *)((void *)0));
  }
#line 1114
  (q->next)->prev = q->prev;
#line 1114
  (q->prev)->next = q->next;
#line 1116
  if ((unsigned long )(& tail___1) == (unsigned long )tail___1.prev) {
#line 1117
    goto inclusive;
  }
  {
#line 1120
  node->right = ngx_http_create_locations_tree(cf, & tail___1, prefix);
  }
#line 1121
  if ((unsigned long )node->right == (unsigned long )((void *)0)) {
#line 1122
    return ((ngx_http_location_tree_node_t *)((void *)0));
  }
  inclusive: 
#line 1127
  if ((unsigned long )(& lq->list) == (unsigned long )lq->list.prev) {
#line 1128
    return (node);
  }
  {
#line 1131
  node->tree = ngx_http_create_locations_tree(cf, & lq->list, prefix + len);
  }
#line 1132
  if ((unsigned long )node->tree == (unsigned long )((void *)0)) {
#line 1133
    return ((ngx_http_location_tree_node_t *)((void *)0));
  }
#line 1136
  return (node);
}
}
#line 1140 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
ngx_int_t ngx_http_add_listen(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf , ngx_http_listen_opt_t *lsopt ) 
{ 
  in_port_t p ;
  ngx_uint_t i ;
  struct sockaddr *sa ;
  ngx_http_conf_port_t *port ;
  ngx_http_core_main_conf_t *cmcf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1150
  cmcf = (ngx_http_core_main_conf_t *)*(((ngx_http_conf_ctx_t *)cf->ctx)->main_conf + ngx_http_core_module.ctx_index);
#line 1152
  if ((unsigned long )cmcf->ports == (unsigned long )((void *)0)) {
    {
#line 1153
    cmcf->ports = ngx_array_create(cf->temp_pool, (ngx_uint_t )2, sizeof(ngx_http_conf_port_t ));
    }
#line 1155
    if ((unsigned long )cmcf->ports == (unsigned long )((void *)0)) {
#line 1156
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1160
  sa = & lsopt->sockaddr.sockaddr;
#line 1161
  p = ngx_inet_get_port(sa);
#line 1163
  port = (ngx_http_conf_port_t *)(cmcf->ports)->elts;
#line 1164
  i = (ngx_uint_t )0;
  }
  {
#line 1164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1164
    if (! (i < (cmcf->ports)->nelts)) {
#line 1164
      goto while_break;
    }
#line 1166
    if ((int )p != (int )(port + i)->port) {
#line 1167
      goto __Cont;
    } else
#line 1166
    if ((ngx_int_t )sa->sa_family != (port + i)->family) {
#line 1167
      goto __Cont;
    }
    {
#line 1172
    tmp = ngx_http_add_addresses(cf, cscf, port + i, lsopt);
    }
#line 1172
    return (tmp);
    __Cont: /* CIL Label */ 
#line 1164
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1177
  tmp___0 = ngx_array_push(cmcf->ports);
#line 1177
  port = (ngx_http_conf_port_t *)tmp___0;
  }
#line 1178
  if ((unsigned long )port == (unsigned long )((void *)0)) {
#line 1179
    return ((ngx_int_t )-1);
  }
  {
#line 1182
  port->family = (ngx_int_t )sa->sa_family;
#line 1183
  port->port = p;
#line 1184
  port->addrs.elts = (void *)0;
#line 1186
  tmp___1 = ngx_http_add_address(cf, cscf, port, lsopt);
  }
#line 1186
  return (tmp___1);
}
}
#line 1190 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_addresses(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                        ngx_http_conf_port_t *port , ngx_http_listen_opt_t *lsopt ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t default_server ;
  ngx_uint_t proxy_protocol ;
  ngx_http_conf_addr_t *addr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1208
  addr = (ngx_http_conf_addr_t *)port->addrs.elts;
#line 1210
  i = (ngx_uint_t )0;
  {
#line 1210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1210
    if (! (i < port->addrs.nelts)) {
#line 1210
      goto while_break;
    }
    {
#line 1212
    tmp = ngx_cmp_sockaddr(& lsopt->sockaddr.sockaddr, lsopt->socklen, & (addr + i)->opt.sockaddr.sockaddr,
                           (addr + i)->opt.socklen, (ngx_uint_t )0);
    }
#line 1212
    if (tmp != 0L) {
#line 1217
      goto __Cont;
    }
    {
#line 1222
    tmp___0 = ngx_http_add_server(cf, cscf, addr + i);
    }
#line 1222
    if (tmp___0 != 0L) {
#line 1223
      return ((ngx_int_t )-1);
    }
#line 1227
    default_server = (ngx_uint_t )(addr + i)->opt.default_server;
#line 1229
    if (lsopt->proxy_protocol) {
#line 1229
      tmp___1 = 1;
    } else
#line 1229
    if ((addr + i)->opt.proxy_protocol) {
#line 1229
      tmp___1 = 1;
    } else {
#line 1229
      tmp___1 = 0;
    }
#line 1229
    proxy_protocol = (ngx_uint_t )tmp___1;
#line 1238
    if (lsopt->set) {
#line 1240
      if ((addr + i)->opt.set) {
        {
#line 1241
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate listen options for %s",
                           (addr + i)->opt.addr);
        }
#line 1243
        return ((ngx_int_t )-1);
      }
#line 1246
      (addr + i)->opt = *lsopt;
    }
#line 1251
    if (lsopt->default_server) {
#line 1253
      if (default_server) {
        {
#line 1254
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "a duplicate default server for %s",
                           (addr + i)->opt.addr);
        }
#line 1256
        return ((ngx_int_t )-1);
      }
#line 1259
      default_server = (ngx_uint_t )1;
#line 1260
      (addr + i)->default_server = cscf;
    }
#line 1263
    (addr + i)->opt.default_server = (unsigned int )default_server;
#line 1264
    (addr + i)->opt.proxy_protocol = (unsigned int )proxy_protocol;
#line 1272
    return ((ngx_int_t )0);
    __Cont: /* CIL Label */ 
#line 1210
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1277
  tmp___2 = ngx_http_add_address(cf, cscf, port, lsopt);
  }
#line 1277
  return (tmp___2);
}
}
#line 1286 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_address(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                      ngx_http_conf_port_t *port , ngx_http_listen_opt_t *lsopt ) 
{ 
  ngx_http_conf_addr_t *addr ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 1292
  if ((unsigned long )port->addrs.elts == (unsigned long )((void *)0)) {
    {
#line 1293
    tmp = ngx_array_init(& port->addrs, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_conf_addr_t ));
    }
#line 1293
    if (tmp != 0L) {
#line 1297
      return ((ngx_int_t )-1);
    }
  }
  {
#line 1314
  tmp___0 = ngx_array_push(& port->addrs);
#line 1314
  addr = (ngx_http_conf_addr_t *)tmp___0;
  }
#line 1315
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 1316
    return ((ngx_int_t )-1);
  }
  {
#line 1319
  addr->opt = *lsopt;
#line 1320
  addr->hash.buckets = (ngx_hash_elt_t **)((void *)0);
#line 1321
  addr->hash.size = (ngx_uint_t )0;
#line 1322
  addr->wc_head = (ngx_hash_wildcard_t *)((void *)0);
#line 1323
  addr->wc_tail = (ngx_hash_wildcard_t *)((void *)0);
#line 1325
  addr->nregex = (ngx_uint_t )0;
#line 1326
  addr->regex = (ngx_http_server_name_t *)((void *)0);
#line 1328
  addr->default_server = cscf;
#line 1329
  addr->servers.elts = (void *)0;
#line 1331
  tmp___1 = ngx_http_add_server(cf, cscf, addr);
  }
#line 1331
  return (tmp___1);
}
}
#line 1337 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_server(ngx_conf_t *cf , ngx_http_core_srv_conf_t *cscf ,
                                     ngx_http_conf_addr_t *addr ) 
{ 
  ngx_uint_t i ;
  ngx_http_core_srv_conf_t **server ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;

  {
#line 1344
  if ((unsigned long )addr->servers.elts == (unsigned long )((void *)0)) {
    {
#line 1345
    tmp = ngx_array_init(& addr->servers, cf->temp_pool, (ngx_uint_t )4, sizeof(ngx_http_core_srv_conf_t *));
    }
#line 1345
    if (tmp != 0L) {
#line 1349
      return ((ngx_int_t )-1);
    }
  } else {
#line 1353
    server = (ngx_http_core_srv_conf_t **)addr->servers.elts;
#line 1354
    i = (ngx_uint_t )0;
    {
#line 1354
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1354
      if (! (i < addr->servers.nelts)) {
#line 1354
        goto while_break;
      }
#line 1355
      if ((unsigned long )*(server + i) == (unsigned long )cscf) {
        {
#line 1356
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "a duplicate listen %s", addr->opt.addr);
        }
#line 1358
        return ((ngx_int_t )-1);
      }
#line 1354
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1363
  tmp___0 = ngx_array_push(& addr->servers);
#line 1363
  server = (ngx_http_core_srv_conf_t **)tmp___0;
  }
#line 1364
  if ((unsigned long )server == (unsigned long )((void *)0)) {
#line 1365
    return ((ngx_int_t )-1);
  }
#line 1368
  *server = cscf;
#line 1370
  return ((ngx_int_t )0);
}
}
#line 1374 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_optimize_servers(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                           ngx_array_t *ports ) 
{ 
  ngx_uint_t p ;
  ngx_uint_t a ;
  ngx_http_conf_port_t *port ;
  ngx_http_conf_addr_t *addr ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1382
  if ((unsigned long )ports == (unsigned long )((void *)0)) {
#line 1383
    return ((ngx_int_t )0);
  }
#line 1386
  port = (ngx_http_conf_port_t *)ports->elts;
#line 1387
  p = (ngx_uint_t )0;
  {
#line 1387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1387
    if (! (p < ports->nelts)) {
#line 1387
      goto while_break;
    }
    {
#line 1389
    ngx_sort((port + p)->addrs.elts, (port + p)->addrs.nelts, sizeof(ngx_http_conf_addr_t ),
             & ngx_http_cmp_conf_addrs);
#line 1397
    addr = (ngx_http_conf_addr_t *)(port + p)->addrs.elts;
#line 1398
    a = (ngx_uint_t )0;
    }
    {
#line 1398
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1398
      if (! (a < (port + p)->addrs.nelts)) {
#line 1398
        goto while_break___0;
      }
#line 1400
      if ((addr + a)->servers.nelts > 1UL) {
#line 1400
        goto _L;
      } else
#line 1400
      if (((addr + a)->default_server)->captures) {
        _L: /* CIL Label */ 
        {
#line 1406
        tmp = ngx_http_server_names(cf, cmcf, addr + a);
        }
#line 1406
        if (tmp != 0L) {
#line 1407
          return ((ngx_int_t )-1);
        }
      }
#line 1398
      a ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1412
    tmp___0 = ngx_http_init_listening(cf, port + p);
    }
#line 1412
    if (tmp___0 != 0L) {
#line 1413
      return ((ngx_int_t )-1);
    }
#line 1387
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1417
  return ((ngx_int_t )0);
}
}
#line 1421 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_server_names(ngx_conf_t *cf , ngx_http_core_main_conf_t *cmcf ,
                                       ngx_http_conf_addr_t *addr ) 
{ 
  ngx_int_t rc ;
  ngx_uint_t n ;
  ngx_uint_t s ;
  ngx_hash_init_t hash ;
  ngx_hash_keys_arrays_t ha ;
  ngx_http_server_name_t *name ;
  ngx_http_core_srv_conf_t **cscfp ;
  ngx_uint_t regex ;
  ngx_uint_t i ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  void *tmp___3 ;
  ngx_uint_t tmp___4 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 1434
  regex = (ngx_uint_t )0;
#line 1437
  memset((void *)(& ha), 0, sizeof(ngx_hash_keys_arrays_t ));
#line 1439
  ha.temp_pool = ngx_create_pool((size_t )16384, cf->log);
  }
#line 1440
  if ((unsigned long )ha.temp_pool == (unsigned long )((void *)0)) {
#line 1441
    return ((ngx_int_t )-1);
  }
  {
#line 1444
  ha.pool = cf->pool;
#line 1446
  tmp = ngx_hash_keys_array_init(& ha, (ngx_uint_t )2);
  }
#line 1446
  if (tmp != 0L) {
#line 1447
    goto failed;
  }
#line 1450
  cscfp = (ngx_http_core_srv_conf_t **)addr->servers.elts;
#line 1452
  s = (ngx_uint_t )0;
  {
#line 1452
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1452
    if (! (s < addr->servers.nelts)) {
#line 1452
      goto while_break;
    }
#line 1454
    name = (ngx_http_server_name_t *)(*(cscfp + s))->server_names.elts;
#line 1456
    n = (ngx_uint_t )0;
    {
#line 1456
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1456
      if (! (n < (*(cscfp + s))->server_names.nelts)) {
#line 1456
        goto while_break___0;
      }
#line 1459
      if ((name + n)->regex) {
#line 1460
        regex ++;
#line 1461
        goto __Cont;
      }
      {
#line 1465
      rc = ngx_hash_add_key(& ha, & (name + n)->name, (void *)(name + n)->server,
                            (ngx_uint_t )1);
      }
#line 1468
      if (rc == -1L) {
#line 1469
        return ((ngx_int_t )-1);
      }
#line 1472
      if (rc == -5L) {
#line 1473
        if ((cf->log)->log_level >= 1UL) {
          {
#line 1473
          ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "invalid server name or wildcard \"%V\" on %s",
                             & (name + n)->name, addr->opt.addr);
          }
        }
#line 1476
        return ((ngx_int_t )-1);
      }
#line 1479
      if (rc == -3L) {
#line 1480
        if ((cf->log)->log_level >= 5UL) {
          {
#line 1480
          ngx_log_error_core((ngx_uint_t )5, cf->log, 0, "conflicting server name \"%V\" on %s, ignored",
                             & (name + n)->name, addr->opt.addr);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1456
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1452
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1487
  hash.key = & ngx_hash_key_lc;
#line 1488
  hash.max_size = cmcf->server_names_hash_max_size;
#line 1489
  hash.bucket_size = cmcf->server_names_hash_bucket_size;
#line 1490
  hash.name = (char *)"server_names_hash";
#line 1491
  hash.pool = cf->pool;
#line 1493
  if (ha.keys.nelts) {
    {
#line 1494
    hash.hash = & addr->hash;
#line 1495
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 1497
    tmp___0 = ngx_hash_init(& hash, (ngx_hash_key_t *)ha.keys.elts, ha.keys.nelts);
    }
#line 1497
    if (tmp___0 != 0L) {
#line 1498
      goto failed;
    }
  }
#line 1502
  if (ha.dns_wc_head.nelts) {
    {
#line 1504
    qsort(ha.dns_wc_head.elts, ha.dns_wc_head.nelts, sizeof(ngx_hash_key_t ), & ngx_http_cmp_dns_wildcards);
#line 1507
    hash.hash = (ngx_hash_t *)((void *)0);
#line 1508
    hash.temp_pool = ha.temp_pool;
#line 1510
    tmp___1 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)ha.dns_wc_head.elts,
                                     ha.dns_wc_head.nelts);
    }
#line 1510
    if (tmp___1 != 0L) {
#line 1514
      goto failed;
    }
#line 1517
    addr->wc_head = (ngx_hash_wildcard_t *)hash.hash;
  }
#line 1520
  if (ha.dns_wc_tail.nelts) {
    {
#line 1522
    qsort(ha.dns_wc_tail.elts, ha.dns_wc_tail.nelts, sizeof(ngx_hash_key_t ), & ngx_http_cmp_dns_wildcards);
#line 1525
    hash.hash = (ngx_hash_t *)((void *)0);
#line 1526
    hash.temp_pool = ha.temp_pool;
#line 1528
    tmp___2 = ngx_hash_wildcard_init(& hash, (ngx_hash_key_t *)ha.dns_wc_tail.elts,
                                     ha.dns_wc_tail.nelts);
    }
#line 1528
    if (tmp___2 != 0L) {
#line 1532
      goto failed;
    }
#line 1535
    addr->wc_tail = (ngx_hash_wildcard_t *)hash.hash;
  }
  {
#line 1538
  ngx_destroy_pool(ha.temp_pool);
  }
#line 1542
  if (regex == 0UL) {
#line 1543
    return ((ngx_int_t )0);
  }
  {
#line 1546
  addr->nregex = regex;
#line 1547
  tmp___3 = ngx_palloc(cf->pool, regex * sizeof(ngx_http_server_name_t ));
#line 1547
  addr->regex = (ngx_http_server_name_t *)tmp___3;
  }
#line 1548
  if ((unsigned long )addr->regex == (unsigned long )((void *)0)) {
#line 1549
    return ((ngx_int_t )-1);
  }
#line 1552
  i = (ngx_uint_t )0;
#line 1554
  s = (ngx_uint_t )0;
  {
#line 1554
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1554
    if (! (s < addr->servers.nelts)) {
#line 1554
      goto while_break___1;
    }
#line 1556
    name = (ngx_http_server_name_t *)(*(cscfp + s))->server_names.elts;
#line 1558
    n = (ngx_uint_t )0;
    {
#line 1558
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1558
      if (! (n < (*(cscfp + s))->server_names.nelts)) {
#line 1558
        goto while_break___2;
      }
#line 1559
      if ((name + n)->regex) {
#line 1560
        tmp___4 = i;
#line 1560
        i ++;
#line 1560
        *(addr->regex + tmp___4) = *(name + n);
      }
#line 1558
      n ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1554
    s ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1567
  return ((ngx_int_t )0);
  failed: 
  {
#line 1571
  ngx_destroy_pool(ha.temp_pool);
  }
#line 1573
  return ((ngx_int_t )-1);
}
}
#line 1577 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_cmp_conf_addrs(void const   *one , void const   *two ) 
{ 
  ngx_http_conf_addr_t *first ;
  ngx_http_conf_addr_t *second ;

  {
#line 1582
  first = (ngx_http_conf_addr_t *)one;
#line 1583
  second = (ngx_http_conf_addr_t *)two;
#line 1585
  if (first->opt.wildcard) {
#line 1587
    return ((ngx_int_t )1);
  }
#line 1590
  if (second->opt.wildcard) {
#line 1592
    return ((ngx_int_t )-1);
  }
#line 1595
  if (first->opt.bind) {
#line 1595
    if (! second->opt.bind) {
#line 1597
      return ((ngx_int_t )-1);
    }
  }
#line 1600
  if (! first->opt.bind) {
#line 1600
    if (second->opt.bind) {
#line 1602
      return ((ngx_int_t )1);
    }
  }
#line 1607
  return ((ngx_int_t )0);
}
}
#line 1611 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static int ngx_http_cmp_dns_wildcards(void const   *one , void const   *two ) 
{ 
  ngx_hash_key_t *first ;
  ngx_hash_key_t *second ;
  ngx_int_t tmp ;

  {
  {
#line 1616
  first = (ngx_hash_key_t *)one;
#line 1617
  second = (ngx_hash_key_t *)two;
#line 1619
  tmp = ngx_dns_strcmp(first->key.data, second->key.data);
  }
#line 1619
  return ((int )tmp);
}
}
#line 1623 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_init_listening(ngx_conf_t *cf , ngx_http_conf_port_t *port ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t last ;
  ngx_uint_t bind_wildcard ;
  ngx_listening_t *ls ;
  ngx_http_port_t *hport ;
  ngx_http_conf_addr_t *addr ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1631
  addr = (ngx_http_conf_addr_t *)port->addrs.elts;
#line 1632
  last = port->addrs.nelts;
#line 1641
  if ((addr + (last - 1UL))->opt.wildcard) {
#line 1642
    (addr + (last - 1UL))->opt.bind = 1U;
#line 1643
    bind_wildcard = (ngx_uint_t )1;
  } else {
#line 1646
    bind_wildcard = (ngx_uint_t )0;
  }
#line 1649
  i = (ngx_uint_t )0;
  {
#line 1651
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1651
    if (! (i < last)) {
#line 1651
      goto while_break;
    }
#line 1653
    if (bind_wildcard) {
#line 1653
      if (! (addr + i)->opt.bind) {
#line 1654
        i ++;
#line 1655
        goto while_continue;
      }
    }
    {
#line 1658
    ls = ngx_http_add_listening(cf, addr + i);
    }
#line 1659
    if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 1660
      return ((ngx_int_t )-1);
    }
    {
#line 1663
    tmp = ngx_pcalloc(cf->pool, sizeof(ngx_http_port_t ));
#line 1663
    hport = (ngx_http_port_t *)tmp;
    }
#line 1664
    if ((unsigned long )hport == (unsigned long )((void *)0)) {
#line 1665
      return ((ngx_int_t )-1);
    }
#line 1668
    ls->servers = (void *)hport;
#line 1670
    hport->naddrs = i + 1UL;
    {
#line 1675
    if ((int )(ls->sockaddr)->sa_family == 10) {
#line 1675
      goto case_10;
    }
#line 1681
    goto switch_default;
    case_10: /* CIL Label */ 
    {
#line 1676
    tmp___0 = ngx_http_add_addrs6(cf, hport, addr);
    }
#line 1676
    if (tmp___0 != 0L) {
#line 1677
      return ((ngx_int_t )-1);
    }
#line 1679
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1682
    tmp___1 = ngx_http_add_addrs(cf, hport, addr);
    }
#line 1682
    if (tmp___1 != 0L) {
#line 1683
      return ((ngx_int_t )-1);
    }
#line 1685
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 1688
    tmp___2 = ngx_clone_listening(cf, ls);
    }
#line 1688
    if (tmp___2 != 0L) {
#line 1689
      return ((ngx_int_t )-1);
    }
#line 1692
    addr ++;
#line 1693
    last --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1696
  return ((ngx_int_t )0);
}
}
#line 1700 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_listening_t *ngx_http_add_listening(ngx_conf_t *cf , ngx_http_conf_addr_t *addr ) 
{ 
  ngx_listening_t *ls ;
  ngx_http_core_loc_conf_t *clcf ;
  ngx_http_core_srv_conf_t *cscf ;

  {
  {
#line 1707
  ls = ngx_create_listening(cf, & addr->opt.sockaddr.sockaddr, addr->opt.socklen);
  }
#line 1709
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 1710
    return ((ngx_listening_t *)((void *)0));
  }
#line 1713
  ls->addr_ntop = 1U;
#line 1715
  ls->handler = & ngx_http_init_connection;
#line 1717
  cscf = addr->default_server;
#line 1718
  ls->pool_size = cscf->connection_pool_size;
#line 1719
  ls->post_accept_timeout = cscf->client_header_timeout;
#line 1721
  clcf = (ngx_http_core_loc_conf_t *)*((cscf->ctx)->loc_conf + ngx_http_core_module.ctx_index);
#line 1723
  ls->logp = clcf->error_log;
#line 1724
  ls->log.data = (void *)(& ls->addr_text);
#line 1725
  ls->log.handler = & ngx_accept_log_error;
#line 1740
  ls->backlog = addr->opt.backlog;
#line 1741
  ls->rcvbuf = addr->opt.rcvbuf;
#line 1742
  ls->sndbuf = addr->opt.sndbuf;
#line 1744
  ls->keepalive = addr->opt.so_keepalive;
#line 1746
  ls->keepidle = addr->opt.tcp_keepidle;
#line 1747
  ls->keepintvl = addr->opt.tcp_keepintvl;
#line 1748
  ls->keepcnt = addr->opt.tcp_keepcnt;
#line 1756
  ls->deferred_accept = addr->opt.deferred_accept;
#line 1760
  ls->ipv6only = addr->opt.ipv6only;
#line 1768
  ls->fastopen = addr->opt.fastopen;
#line 1772
  ls->reuseport = addr->opt.reuseport;
#line 1775
  return (ls);
}
}
#line 1779 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_addrs(ngx_conf_t *cf , ngx_http_port_t *hport , ngx_http_conf_addr_t *addr ) 
{ 
  ngx_uint_t i ;
  ngx_http_in_addr_t *addrs ;
  struct sockaddr_in *sin ;
  ngx_http_virtual_names_t *vn ;
  void *tmp ;

  {
  {
#line 1788
  hport->addrs = ngx_pcalloc(cf->pool, hport->naddrs * sizeof(ngx_http_in_addr_t ));
  }
#line 1790
  if ((unsigned long )hport->addrs == (unsigned long )((void *)0)) {
#line 1791
    return ((ngx_int_t )-1);
  }
#line 1794
  addrs = (ngx_http_in_addr_t *)hport->addrs;
#line 1796
  i = (ngx_uint_t )0;
  {
#line 1796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1796
    if (! (i < hport->naddrs)) {
#line 1796
      goto while_break;
    }
#line 1798
    sin = & (addr + i)->opt.sockaddr.sockaddr_in;
#line 1799
    (addrs + i)->addr = sin->sin_addr.s_addr;
#line 1800
    (addrs + i)->conf.default_server = (addr + i)->default_server;
#line 1807
    (addrs + i)->conf.proxy_protocol = (addr + i)->opt.proxy_protocol;
#line 1809
    if ((unsigned long )(addr + i)->hash.buckets == (unsigned long )((void *)0)) {
#line 1809
      if ((unsigned long )(addr + i)->wc_head == (unsigned long )((void *)0)) {
#line 1809
        goto _L___0;
      } else
#line 1809
      if ((unsigned long )((addr + i)->wc_head)->hash.buckets == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1809
        if ((unsigned long )(addr + i)->wc_tail == (unsigned long )((void *)0)) {
#line 1809
          goto _L;
        } else
#line 1809
        if ((unsigned long )((addr + i)->wc_tail)->hash.buckets == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 1809
          if ((addr + i)->nregex == 0UL) {
#line 1819
            goto __Cont;
          }
        }
      }
    }
    {
#line 1822
    tmp = ngx_palloc(cf->pool, sizeof(ngx_http_virtual_names_t ));
#line 1822
    vn = (ngx_http_virtual_names_t *)tmp;
    }
#line 1823
    if ((unsigned long )vn == (unsigned long )((void *)0)) {
#line 1824
      return ((ngx_int_t )-1);
    }
#line 1827
    (addrs + i)->conf.virtual_names = vn;
#line 1829
    vn->names.hash = (addr + i)->hash;
#line 1830
    vn->names.wc_head = (addr + i)->wc_head;
#line 1831
    vn->names.wc_tail = (addr + i)->wc_tail;
#line 1833
    vn->nregex = (addr + i)->nregex;
#line 1834
    vn->regex = (addr + i)->regex;
    __Cont: /* CIL Label */ 
#line 1796
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1838
  return ((ngx_int_t )0);
}
}
#line 1844 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
static ngx_int_t ngx_http_add_addrs6(ngx_conf_t *cf , ngx_http_port_t *hport , ngx_http_conf_addr_t *addr ) 
{ 
  ngx_uint_t i ;
  ngx_http_in6_addr_t *addrs6 ;
  struct sockaddr_in6 *sin6 ;
  ngx_http_virtual_names_t *vn ;
  void *tmp ;

  {
  {
#line 1853
  hport->addrs = ngx_pcalloc(cf->pool, hport->naddrs * sizeof(ngx_http_in6_addr_t ));
  }
#line 1855
  if ((unsigned long )hport->addrs == (unsigned long )((void *)0)) {
#line 1856
    return ((ngx_int_t )-1);
  }
#line 1859
  addrs6 = (ngx_http_in6_addr_t *)hport->addrs;
#line 1861
  i = (ngx_uint_t )0;
  {
#line 1861
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1861
    if (! (i < hport->naddrs)) {
#line 1861
      goto while_break;
    }
#line 1863
    sin6 = & (addr + i)->opt.sockaddr.sockaddr_in6;
#line 1864
    (addrs6 + i)->addr6 = sin6->sin6_addr;
#line 1865
    (addrs6 + i)->conf.default_server = (addr + i)->default_server;
#line 1872
    (addrs6 + i)->conf.proxy_protocol = (addr + i)->opt.proxy_protocol;
#line 1874
    if ((unsigned long )(addr + i)->hash.buckets == (unsigned long )((void *)0)) {
#line 1874
      if ((unsigned long )(addr + i)->wc_head == (unsigned long )((void *)0)) {
#line 1874
        goto _L___0;
      } else
#line 1874
      if ((unsigned long )((addr + i)->wc_head)->hash.buckets == (unsigned long )((void *)0)) {
        _L___0: /* CIL Label */ 
#line 1874
        if ((unsigned long )(addr + i)->wc_tail == (unsigned long )((void *)0)) {
#line 1874
          goto _L;
        } else
#line 1874
        if ((unsigned long )((addr + i)->wc_tail)->hash.buckets == (unsigned long )((void *)0)) {
          _L: /* CIL Label */ 
#line 1874
          if ((addr + i)->nregex == 0UL) {
#line 1884
            goto __Cont;
          }
        }
      }
    }
    {
#line 1887
    tmp = ngx_palloc(cf->pool, sizeof(ngx_http_virtual_names_t ));
#line 1887
    vn = (ngx_http_virtual_names_t *)tmp;
    }
#line 1888
    if ((unsigned long )vn == (unsigned long )((void *)0)) {
#line 1889
      return ((ngx_int_t )-1);
    }
#line 1892
    (addrs6 + i)->conf.virtual_names = vn;
#line 1894
    vn->names.hash = (addr + i)->hash;
#line 1895
    vn->names.wc_head = (addr + i)->wc_head;
#line 1896
    vn->names.wc_tail = (addr + i)->wc_tail;
#line 1898
    vn->nregex = (addr + i)->nregex;
#line 1899
    vn->regex = (addr + i)->regex;
    __Cont: /* CIL Label */ 
#line 1861
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1903
  return ((ngx_int_t )0);
}
}
#line 1909 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
char *ngx_http_types_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_array_t **types ;
  ngx_str_t *value ;
  ngx_str_t *default_type ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t hash ;
  ngx_hash_key_t *type ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp15 ;

  {
#line 1912
  p = (char *)conf;
#line 1919
  types = (ngx_array_t **)(p + cmd->offset);
#line 1921
  if ((unsigned long )*types == (unsigned long )((void *)-1)) {
#line 1922
    return ((char *)((void *)0));
  }
#line 1925
  default_type = (ngx_str_t *)cmd->post;
#line 1927
  if ((unsigned long )*types == (unsigned long )((void *)0)) {
    {
#line 1928
    *types = ngx_array_create(cf->temp_pool, (ngx_uint_t )1, sizeof(ngx_hash_key_t ));
    }
#line 1929
    if ((unsigned long )*types == (unsigned long )((void *)0)) {
#line 1930
      return ((char *)((void *)-1));
    }
#line 1933
    if (default_type) {
      {
#line 1934
      tmp = ngx_array_push(*types);
#line 1934
      type = (ngx_hash_key_t *)tmp;
      }
#line 1935
      if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 1936
        return ((char *)((void *)-1));
      }
      {
#line 1939
      type->key = *default_type;
#line 1940
      type->key_hash = ngx_hash_key(default_type->data, default_type->len);
#line 1942
      type->value = (void *)4;
      }
    }
  }
#line 1946
  value = (ngx_str_t *)(cf->args)->elts;
#line 1948
  i = (ngx_uint_t )1;
  {
#line 1948
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1948
    if (! (i < (cf->args)->nelts)) {
#line 1948
      goto while_break;
    }
#line 1950
    if ((value + i)->len == 1UL) {
#line 1950
      if ((int )*((value + i)->data + 0) == 42) {
#line 1951
        *types = (ngx_array_t *)((void *)-1);
#line 1952
        return ((char *)((void *)0));
      }
    }
    {
#line 1955
    hash = ngx_hash_strlow((value + i)->data, (value + i)->data, (value + i)->len);
#line 1956
    *((value + i)->data + (value + i)->len) = (u_char )'\000';
#line 1958
    type = (ngx_hash_key_t *)(*types)->elts;
#line 1959
    n = (ngx_uint_t )0;
    }
    {
#line 1959
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1959
      if (! (n < (*types)->nelts)) {
#line 1959
        goto while_break___0;
      }
      {
#line 1961
      tmp___0 = strcmp((char const   *)(value + i)->data, (char const   *)(type + n)->key.data);
      }
#line 1961
      if (tmp___0 == 0) {
        {
#line 1962
        ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate MIME type \"%V\"", value + i);
        }
#line 1964
        goto next;
      }
#line 1959
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1968
    tmp___1 = ngx_array_push(*types);
#line 1968
    type = (ngx_hash_key_t *)tmp___1;
    }
#line 1969
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 1970
      return ((char *)((void *)-1));
    }
#line 1973
    type->key = *(value + i);
#line 1974
    type->key_hash = hash;
#line 1975
    type->value = (void *)4;
    next: 
#line 1979
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 1948
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1982
  return ((char *)((void *)0));
}
}
#line 1986 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
char *ngx_http_merge_types(ngx_conf_t *cf , ngx_array_t **keys , ngx_hash_t *types_hash ,
                           ngx_array_t **prev_keys , ngx_hash_t *prev_types_hash ,
                           ngx_str_t *default_types ) 
{ 
  ngx_hash_init_t hash ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1993
  if (*keys) {
#line 1995
    if ((unsigned long )*keys == (unsigned long )((void *)-1)) {
#line 1996
      return ((char *)((void *)0));
    }
    {
#line 1999
    hash.hash = types_hash;
#line 2000
    hash.key = (ngx_uint_t (*)(u_char *data , size_t len ))((void *)0);
#line 2001
    hash.max_size = (ngx_uint_t )2048;
#line 2002
    hash.bucket_size = (ngx_uint_t )64;
#line 2003
    hash.name = (char *)"test_types_hash";
#line 2004
    hash.pool = cf->pool;
#line 2005
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2007
    tmp = ngx_hash_init(& hash, (ngx_hash_key_t *)(*keys)->elts, (*keys)->nelts);
    }
#line 2007
    if (tmp != 0L) {
#line 2008
      return ((char *)((void *)-1));
    }
#line 2011
    return ((char *)((void *)0));
  }
#line 2014
  if ((unsigned long )prev_types_hash->buckets == (unsigned long )((void *)0)) {
#line 2016
    if ((unsigned long )*prev_keys == (unsigned long )((void *)0)) {
      {
#line 2018
      tmp___0 = ngx_http_set_default_types(cf, prev_keys, default_types);
      }
#line 2018
      if (tmp___0 != 0L) {
#line 2021
        return ((char *)((void *)-1));
      }
    } else
#line 2024
    if ((unsigned long )*prev_keys == (unsigned long )((void *)-1)) {
#line 2025
      *keys = *prev_keys;
#line 2026
      return ((char *)((void *)0));
    }
    {
#line 2029
    hash.hash = prev_types_hash;
#line 2030
    hash.key = (ngx_uint_t (*)(u_char *data , size_t len ))((void *)0);
#line 2031
    hash.max_size = (ngx_uint_t )2048;
#line 2032
    hash.bucket_size = (ngx_uint_t )64;
#line 2033
    hash.name = (char *)"test_types_hash";
#line 2034
    hash.pool = cf->pool;
#line 2035
    hash.temp_pool = (ngx_pool_t *)((void *)0);
#line 2037
    tmp___1 = ngx_hash_init(& hash, (ngx_hash_key_t *)(*prev_keys)->elts, (*prev_keys)->nelts);
    }
#line 2037
    if (tmp___1 != 0L) {
#line 2040
      return ((char *)((void *)-1));
    }
  }
#line 2044
  *types_hash = *prev_types_hash;
#line 2046
  return ((char *)((void *)0));
}
}
#line 2051 "/home/khheo/project/nginx-release-1.13.8/src/http/ngx_http.c"
ngx_int_t ngx_http_set_default_types(ngx_conf_t *cf , ngx_array_t **types , ngx_str_t *default_type ) 
{ 
  ngx_hash_key_t *type ;
  void *tmp ;

  {
  {
#line 2057
  *types = ngx_array_create(cf->temp_pool, (ngx_uint_t )1, sizeof(ngx_hash_key_t ));
  }
#line 2058
  if ((unsigned long )*types == (unsigned long )((void *)0)) {
#line 2059
    return ((ngx_int_t )-1);
  }
  {
#line 2062
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2062
    if (! default_type->len) {
#line 2062
      goto while_break;
    }
    {
#line 2064
    tmp = ngx_array_push(*types);
#line 2064
    type = (ngx_hash_key_t *)tmp;
    }
#line 2065
    if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 2066
      return ((ngx_int_t )-1);
    }
    {
#line 2069
    type->key = *default_type;
#line 2070
    type->key_hash = ngx_hash_key(default_type->data, default_type->len);
#line 2072
    type->value = (void *)4;
#line 2074
    default_type ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2077
  return ((ngx_int_t )0);
}
}
#line 489 "/home/khheo/.linuxbrew/include/pcre.h"
extern void *(*pcre_malloc)(size_t  ) ;
#line 490
extern void (*pcre_free)(void * ) ;
#line 540
extern pcre *pcre_compile(char const   * , int  , char const   ** , int * , unsigned char const   * ) ;
#line 552
extern int pcre_config(int  , void * ) ;
#line 594
extern int pcre_fullinfo(pcre const   * , pcre_extra const   * , int  , void * ) ;
#line 633
extern pcre_extra *pcre_study(pcre const   * , int  , char const   ** ) ;
#line 636
extern void pcre_free_study(pcre_extra * ) ;
#line 49 "src/core/ngx_regex.h"
void ngx_regex_init(void) ;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static void *ngx_regex_malloc(size_t size ) ;
#line 18
static void ngx_regex_free(void *p ) ;
#line 20
static void ngx_pcre_free_studies(void *data ) ;
#line 23
static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle ) ;
#line 25
static void *ngx_regex_create_conf(ngx_cycle_t *cycle ) ;
#line 26
static char *ngx_regex_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 28
static char *ngx_regex_pcre_jit(ngx_conf_t *cf , void *post , void *data ) ;
#line 29 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static ngx_conf_post_t ngx_regex_pcre_jit_post  =    {& ngx_regex_pcre_jit};
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static ngx_command_t ngx_regex_commands[2]  = {      {{sizeof("pcre_jit") - 1UL, (u_char *)"pcre_jit"}, (ngx_uint_t )16843264, & ngx_conf_set_flag_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_regex_conf_t *)0)->pcre_jit), (void *)(& ngx_regex_pcre_jit_post)}, 
        {{(size_t )0,
       (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf , ngx_command_t *cmd ,
                                                          void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 45 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static ngx_core_module_t ngx_regex_module_ctx  =    {{sizeof("regex") - 1UL, (u_char *)"regex"}, & ngx_regex_create_conf, & ngx_regex_init_conf};
#line 52 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
ngx_module_t ngx_regex_module  = 
#line 52
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_regex_module_ctx),
    ngx_regex_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    & ngx_regex_module_init, (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0};
#line 68 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static ngx_pool_t *ngx_pcre_pool  ;
#line 69 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static ngx_list_t *ngx_pcre_studies  ;
#line 72 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
void ngx_regex_init(void) 
{ 


  {
#line 75
  pcre_malloc = & ngx_regex_malloc;
#line 76
  pcre_free = & ngx_regex_free;
#line 77
  return;
}
}
#line 80 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
__inline static void ngx_regex_malloc_init(ngx_pool_t *pool ) 
{ 


  {
#line 83
  ngx_pcre_pool = pool;
#line 84
  return;
}
}
#line 87 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
__inline static void ngx_regex_malloc_done(void) 
{ 


  {
#line 90
  ngx_pcre_pool = (ngx_pool_t *)((void *)0);
#line 91
  return;
}
}
#line 94 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
ngx_int_t ngx_regex_compile(ngx_regex_compile_t *rc ) 
{ 
  int n ;
  int erroff ;
  char *p ;
  pcre *re ;
  char const   *errstr ;
  ngx_regex_elt_t *elt ;
  u_char *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 103
  ngx_regex_malloc_init(rc->pool);
#line 105
  re = pcre_compile((char const   *)rc->pattern.data, (int )rc->options, & errstr,
                    & erroff, (unsigned char const   *)((void *)0));
#line 109
  ngx_regex_malloc_done();
  }
#line 111
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 112
    if ((size_t )erroff == rc->pattern.len) {
      {
#line 113
      tmp = ngx_snprintf(rc->err.data, rc->err.len, "pcre_compile() failed: %s in \"%V\"",
                         errstr, & rc->pattern);
#line 113
      rc->err.len = (size_t )(tmp - rc->err.data);
      }
    } else {
      {
#line 119
      tmp___0 = ngx_snprintf(rc->err.data, rc->err.len, "pcre_compile() failed: %s in \"%V\" at \"%s\"",
                             errstr, & rc->pattern, rc->pattern.data + erroff);
#line 119
      rc->err.len = (size_t )(tmp___0 - rc->err.data);
      }
    }
#line 125
    return ((ngx_int_t )-1);
  }
  {
#line 128
  tmp___1 = ngx_pcalloc(rc->pool, sizeof(ngx_regex_t ));
#line 128
  rc->regex = (ngx_regex_t *)tmp___1;
  }
#line 129
  if ((unsigned long )rc->regex == (unsigned long )((void *)0)) {
#line 130
    goto nomem;
  }
#line 133
  (rc->regex)->code = re;
#line 137
  if ((unsigned long )ngx_pcre_studies != (unsigned long )((void *)0)) {
    {
#line 138
    tmp___2 = ngx_list_push(ngx_pcre_studies);
#line 138
    elt = (ngx_regex_elt_t *)tmp___2;
    }
#line 139
    if ((unsigned long )elt == (unsigned long )((void *)0)) {
#line 140
      goto nomem;
    }
#line 143
    elt->regex = rc->regex;
#line 144
    elt->name = rc->pattern.data;
  }
  {
#line 147
  n = pcre_fullinfo((pcre const   *)re, (pcre_extra const   *)((void *)0), 2, (void *)(& rc->captures));
  }
#line 148
  if (n < 0) {
#line 149
    p = (char *)"pcre_fullinfo(\"%V\", PCRE_INFO_CAPTURECOUNT) failed: %d";
#line 150
    goto failed;
  }
#line 153
  if (rc->captures == 0) {
#line 154
    return ((ngx_int_t )0);
  }
  {
#line 157
  n = pcre_fullinfo((pcre const   *)re, (pcre_extra const   *)((void *)0), 8, (void *)(& rc->named_captures));
  }
#line 158
  if (n < 0) {
#line 159
    p = (char *)"pcre_fullinfo(\"%V\", PCRE_INFO_NAMECOUNT) failed: %d";
#line 160
    goto failed;
  }
#line 163
  if (rc->named_captures == 0) {
#line 164
    return ((ngx_int_t )0);
  }
  {
#line 167
  n = pcre_fullinfo((pcre const   *)re, (pcre_extra const   *)((void *)0), 7, (void *)(& rc->name_size));
  }
#line 168
  if (n < 0) {
#line 169
    p = (char *)"pcre_fullinfo(\"%V\", PCRE_INFO_NAMEENTRYSIZE) failed: %d";
#line 170
    goto failed;
  }
  {
#line 173
  n = pcre_fullinfo((pcre const   *)re, (pcre_extra const   *)((void *)0), 9, (void *)(& rc->names));
  }
#line 174
  if (n < 0) {
#line 175
    p = (char *)"pcre_fullinfo(\"%V\", PCRE_INFO_NAMETABLE) failed: %d";
#line 176
    goto failed;
  }
#line 179
  return ((ngx_int_t )0);
  failed: 
  {
#line 183
  tmp___3 = ngx_snprintf(rc->err.data, rc->err.len, (char const   *)p, & rc->pattern,
                         n);
#line 183
  rc->err.len = (size_t )(tmp___3 - rc->err.data);
  }
#line 185
  return ((ngx_int_t )-1);
  nomem: 
  {
#line 189
  tmp___4 = ngx_snprintf(rc->err.data, rc->err.len, "regex \"%V\" compilation failed: no memory",
                         & rc->pattern);
#line 189
  rc->err.len = (size_t )(tmp___4 - rc->err.data);
  }
#line 193
  return ((ngx_int_t )-1);
}
}
#line 197 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
ngx_int_t ngx_regex_exec_array(ngx_array_t *a , ngx_str_t *s , ngx_log_t *log ) 
{ 
  ngx_int_t n ;
  ngx_uint_t i ;
  ngx_regex_elt_t *re ;
  int tmp ;
  char *__cil_tmp8 ;

  {
#line 204
  re = (ngx_regex_elt_t *)a->elts;
#line 206
  i = (ngx_uint_t )0;
  {
#line 206
  while (1) {
    while_continue: /* CIL Label */ ;
#line 206
    if (! (i < a->nelts)) {
#line 206
      goto while_break;
    }
    {
#line 208
    tmp = pcre_exec((pcre const   *)((re + i)->regex)->code, (pcre_extra const   *)((re + i)->regex)->extra,
                    (char const   *)s->data, (int )s->len, 0, 0, (int *)((void *)0),
                    0);
#line 208
    n = (ngx_int_t )tmp;
    }
#line 210
    if (n == -1L) {
#line 211
      goto __Cont;
    }
#line 214
    if (n < 0L) {
#line 215
      if (log->log_level >= 2UL) {
        {
#line 215
        ngx_log_error_core((ngx_uint_t )2, log, 0, "pcre_exec() failed: %i on \"%V\" using \"%s\"",
                           n, s, (re + i)->name);
        }
      }
#line 218
      return ((ngx_int_t )-1);
    }
#line 223
    return ((ngx_int_t )0);
    __Cont: /* CIL Label */ 
#line 206
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return ((ngx_int_t )-5);
}
}
#line 230 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static void *ngx_regex_malloc(size_t size ) 
{ 
  ngx_pool_t *pool ;
  void *tmp ;

  {
#line 234
  pool = ngx_pcre_pool;
#line 236
  if (pool) {
    {
#line 237
    tmp = ngx_palloc(pool, size);
    }
#line 237
    return (tmp);
  }
#line 240
  return ((void *)0);
}
}
#line 244 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static void ngx_regex_free(void *p ) 
{ 


  {
#line 247
  return;
}
}
#line 253 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static void ngx_pcre_free_studies(void *data ) 
{ 
  ngx_list_t *studies ;
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_regex_elt_t *elts ;

  {
#line 256
  studies = (ngx_list_t *)data;
#line 262
  part = & studies->part;
#line 263
  elts = (ngx_regex_elt_t *)part->elts;
#line 265
  i = (ngx_uint_t )0;
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (i >= part->nelts) {
#line 268
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 269
        goto while_break;
      }
#line 272
      part = part->next;
#line 273
      elts = (ngx_regex_elt_t *)part->elts;
#line 274
      i = (ngx_uint_t )0;
    }
#line 277
    if ((unsigned long )((elts + i)->regex)->extra != (unsigned long )((void *)0)) {
      {
#line 278
      pcre_free_study(((elts + i)->regex)->extra);
      }
    }
#line 265
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 281
  return;
}
}
#line 286 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static ngx_int_t ngx_regex_module_init(ngx_cycle_t *cycle ) 
{ 
  int opt ;
  char const   *errstr ;
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_regex_elt_t *elts ;
  ngx_regex_conf_t *rcf ;
  ngx_pool_cleanup_t *cln ;
  int jit ;
  int n ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 295
  opt = 0;
#line 302
  rcf = (ngx_regex_conf_t *)*(cycle->conf_ctx + ngx_regex_module.index);
#line 304
  if (rcf->pcre_jit) {
    {
#line 305
    opt = 1;
#line 313
    cln = ngx_pool_cleanup_add(cycle->pool, (size_t )0);
    }
#line 314
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 315
      return ((ngx_int_t )-1);
    }
#line 318
    cln->handler = & ngx_pcre_free_studies;
#line 319
    cln->data = (void *)ngx_pcre_studies;
  }
  {
#line 324
  ngx_regex_malloc_init(cycle->pool);
#line 326
  part = & ngx_pcre_studies->part;
#line 327
  elts = (ngx_regex_elt_t *)part->elts;
#line 329
  i = (ngx_uint_t )0;
  }
  {
#line 329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 331
    if (i >= part->nelts) {
#line 332
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 333
        goto while_break;
      }
#line 336
      part = part->next;
#line 337
      elts = (ngx_regex_elt_t *)part->elts;
#line 338
      i = (ngx_uint_t )0;
    }
    {
#line 341
    ((elts + i)->regex)->extra = pcre_study((pcre const   *)((elts + i)->regex)->code,
                                            opt, & errstr);
    }
#line 343
    if ((unsigned long )errstr != (unsigned long )((void *)0)) {
#line 344
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 344
        ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "pcre_study() failed: %s in \"%s\"",
                           errstr, (elts + i)->name);
        }
      }
    }
#line 350
    if (opt & 1) {
      {
#line 353
      jit = 0;
#line 354
      n = pcre_fullinfo((pcre const   *)((elts + i)->regex)->code, (pcre_extra const   *)((elts + i)->regex)->extra,
                        16, (void *)(& jit));
      }
#line 357
      if (n != 0) {
#line 357
        goto _L;
      } else
#line 357
      if (jit != 1) {
        _L: /* CIL Label */ 
#line 358
        if ((cycle->log)->log_level >= 7UL) {
          {
#line 358
          ngx_log_error_core((ngx_uint_t )7, cycle->log, 0, "JIT compiler does not support pattern: \"%s\"",
                             (elts + i)->name);
          }
        }
      }
    }
#line 329
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 366
  ngx_regex_malloc_done();
#line 368
  ngx_pcre_studies = (ngx_list_t *)((void *)0);
  }
#line 370
  return ((ngx_int_t )0);
}
}
#line 374 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static void *ngx_regex_create_conf(ngx_cycle_t *cycle ) 
{ 
  ngx_regex_conf_t *rcf ;
  void *tmp ;

  {
  {
#line 379
  tmp = ngx_pcalloc(cycle->pool, sizeof(ngx_regex_conf_t ));
#line 379
  rcf = (ngx_regex_conf_t *)tmp;
  }
#line 380
  if ((unsigned long )rcf == (unsigned long )((void *)0)) {
#line 381
    return ((void *)0);
  }
  {
#line 384
  rcf->pcre_jit = (ngx_flag_t )-1;
#line 386
  ngx_pcre_studies = ngx_list_create(cycle->pool, (ngx_uint_t )8, sizeof(ngx_regex_elt_t ));
  }
#line 387
  if ((unsigned long )ngx_pcre_studies == (unsigned long )((void *)0)) {
#line 388
    return ((void *)0);
  }
#line 391
  return ((void *)rcf);
}
}
#line 395 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static char *ngx_regex_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  ngx_regex_conf_t *rcf ;

  {
#line 398
  rcf = (ngx_regex_conf_t *)conf;
#line 400
  if (rcf->pcre_jit == -1L) {
#line 400
    rcf->pcre_jit = (ngx_flag_t )0;
  }
#line 402
  return ((char *)((void *)0));
}
}
#line 406 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_regex.c"
static char *ngx_regex_pcre_jit(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_flag_t *fp ;
  int jit ;
  int r ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 409
  fp = (ngx_flag_t *)data;
#line 411
  if (*fp == 0L) {
#line 412
    return ((char *)((void *)0));
  }
  {
#line 419
  jit = 0;
#line 420
  r = pcre_config(9, (void *)(& jit));
  }
#line 422
  if (r != 0) {
    {
#line 423
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "PCRE library does not support JIT");
#line 425
    *fp = (ngx_flag_t )0;
    }
  } else
#line 422
  if (jit != 1) {
    {
#line 423
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "PCRE library does not support JIT");
#line 425
    *fp = (ngx_flag_t )0;
    }
  }
#line 434
  return ((char *)((void *)0));
}
}
#line 37 "/usr/include/x86_64-linux-gnu/sys/sendfile.h"
extern  __attribute__((__nothrow__)) ssize_t ( __attribute__((__leaf__)) sendfile)(int __out_fd ,
                                                                                   int __in_fd ,
                                                                                   __off64_t *__offset ,
                                                                                   size_t __count )  __asm__("sendfile64")  ;
#line 41 "src/os/unix/ngx_socket.h"
int ngx_tcp_nopush(ngx_socket_t s ) ;
#line 166 "src/core/ngx_buf.h"
off_t ngx_chain_coalesce_file(ngx_chain_t **in , off_t limit ) ;
#line 168
ngx_chain_t *ngx_chain_update_sent(ngx_chain_t *in , off_t sent ) ;
#line 71 "src/os/unix/ngx_os.h"
ngx_chain_t *ngx_output_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *in , size_t limit ,
                                       ngx_log_t *log ) ;
#line 75
ssize_t ngx_writev(ngx_connection_t *c , ngx_iovec_t *vec ) ;
#line 12 "src/os/unix/ngx_linux.h"
ngx_chain_t *ngx_linux_sendfile_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_linux_sendfile_chain.c"
static ssize_t ngx_linux_sendfile(ngx_connection_t *c , ngx_buf_t *file , size_t size ) ;
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_linux_sendfile_chain.c"
ngx_chain_t *ngx_linux_sendfile_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) 
{ 
  int tcp_nodelay ;
  off_t send___0 ;
  off_t prev_send ;
  size_t file_size ;
  size_t sent ;
  ssize_t n ;
  ngx_err_t err ;
  ngx_buf_t *file ;
  ngx_event_t *wev ;
  ngx_chain_t *cl ;
  ngx_iovec_t header___0 ;
  struct iovec headers[64] ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  off_t tmp___3 ;
  void *__cil_tmp21 ;
  int __cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 60
  wev = c->write;
#line 62
  if (! wev->ready) {
#line 63
    return (in);
  }
#line 69
  if (limit == 0L) {
#line 70
    limit = (off_t )(2147483647UL - ngx_pagesize);
  } else
#line 69
  if (limit > (off_t )(2147483647UL - ngx_pagesize)) {
#line 70
    limit = (off_t )(2147483647UL - ngx_pagesize);
  }
#line 74
  send___0 = (off_t )0;
#line 76
  header___0.iovs = headers;
#line 77
  header___0.nalloc = (ngx_uint_t )64;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 80
    prev_send = send___0;
#line 84
    cl = ngx_output_chain_to_iovec(& header___0, in, (size_t )(limit - send___0),
                                   c->log);
    }
#line 86
    if ((unsigned long )cl == (unsigned long )((ngx_chain_t *)-1)) {
#line 87
      return ((ngx_chain_t *)-1);
    }
#line 90
    send___0 = (off_t )((size_t )send___0 + header___0.size);
#line 94
    if (c->tcp_nopush == 0U) {
#line 94
      if (header___0.count != 0UL) {
#line 94
        if (cl) {
#line 94
          if ((cl->buf)->in_file) {
#line 101
            if (c->tcp_nodelay == 1U) {
              {
#line 103
              tcp_nodelay = 0;
#line 105
              tmp___0 = setsockopt(c->fd, 6, 1, (void const   *)(& tcp_nodelay), (socklen_t )sizeof(int ));
              }
#line 105
              if (tmp___0 == -1) {
                {
#line 108
                tmp = __errno_location();
#line 108
                err = *tmp;
                }
#line 116
                if (err != 4) {
                  {
#line 117
                  wev->error = 1U;
#line 118
                  ngx_connection_error(c, err, (char *)"setsockopt(TCP_NODELAY) failed");
                  }
#line 120
                  return ((ngx_chain_t *)-1);
                }
              } else {
#line 124
                c->tcp_nodelay = 0U;
              }
            }
#line 131
            if (c->tcp_nodelay == 0U) {
              {
#line 133
              tmp___2 = ngx_tcp_nopush(c->fd);
              }
#line 133
              if (tmp___2 == -1) {
                {
#line 134
                tmp___1 = __errno_location();
#line 134
                err = *tmp___1;
                }
#line 141
                if (err != 4) {
                  {
#line 142
                  wev->error = 1U;
#line 143
                  ngx_connection_error(c, err, (char *)"setsockopt(TCP_CORK) failed");
                  }
#line 145
                  return ((ngx_chain_t *)-1);
                }
              } else {
#line 149
                c->tcp_nopush = 1U;
              }
            }
          }
        }
      }
    }
#line 159
    if (header___0.count == 0UL) {
#line 159
      if (cl) {
#line 159
        if ((cl->buf)->in_file) {
#line 159
          if (send___0 < limit) {
            {
#line 160
            file = cl->buf;
#line 164
            tmp___3 = ngx_chain_coalesce_file(& cl, limit - send___0);
#line 164
            file_size = (size_t )tmp___3;
#line 166
            send___0 = (off_t )((size_t )send___0 + file_size);
            }
#line 168
            if (file_size == 0UL) {
              {
#line 169
              ngx_debug_point();
              }
#line 170
              return ((ngx_chain_t *)-1);
            }
            {
#line 174
            n = ngx_linux_sendfile(c, file, file_size);
            }
#line 176
            if (n == -1L) {
#line 177
              return ((ngx_chain_t *)-1);
            }
#line 180
            if (n == -4L) {
#line 182
              return (in);
            }
#line 185
            if (n == -2L) {
#line 185
              sent = (size_t )0;
            } else {
#line 185
              sent = (size_t )n;
            }
          } else {
#line 159
            goto _L___1;
          }
        } else {
#line 159
          goto _L___1;
        }
      } else {
#line 159
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
      {
#line 188
      n = ngx_writev(c, & header___0);
      }
#line 190
      if (n == -1L) {
#line 191
        return ((ngx_chain_t *)-1);
      }
#line 194
      if (n == -2L) {
#line 194
        sent = (size_t )0;
      } else {
#line 194
        sent = (size_t )n;
      }
    }
    {
#line 197
    c->sent = (off_t )((size_t )c->sent + sent);
#line 199
    in = ngx_chain_update_sent(in, (off_t )sent);
    }
#line 201
    if (n == -2L) {
#line 202
      wev->ready = 0U;
#line 203
      return (in);
    }
#line 206
    if ((size_t )(send___0 - prev_send) != sent) {
#line 218
      send___0 = (off_t )((size_t )prev_send + sent);
#line 219
      goto __Cont;
    }
#line 222
    if (send___0 >= limit) {
#line 223
      return (in);
    } else
#line 222
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 223
      return (in);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 229 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_linux_sendfile_chain.c"
static ssize_t ngx_linux_sendfile(ngx_connection_t *c , ngx_buf_t *file , size_t size ) 
{ 
  off_t offset ;
  ssize_t n ;
  ngx_err_t err ;
  int *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 249
  offset = file->file_pos;
  eintr: 
  {
#line 259
  n = sendfile(c->fd, (file->file)->fd, & offset, size);
  }
#line 261
  if (n == -1L) {
    {
#line 262
    tmp = __errno_location();
#line 262
    err = *tmp;
    }
    {
#line 265
    if (err == 11) {
#line 265
      goto case_11;
    }
#line 270
    if (err == 4) {
#line 270
      goto case_4;
    }
#line 275
    goto switch_default;
    case_11: /* CIL Label */ ;
#line 268
    return ((ssize_t )-2);
    case_4: /* CIL Label */ ;
#line 273
    goto eintr;
    switch_default: /* CIL Label */ 
    {
#line 276
    (c->write)->error = 1U;
#line 277
    ngx_connection_error(c, err, (char *)"sendfile() failed");
    }
#line 278
    return ((ssize_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 282
  if (n == 0L) {
#line 288
    if ((c->log)->log_level >= 2UL) {
      {
#line 288
      ngx_log_error_core((ngx_uint_t )2, c->log, 0, "sendfile() reported that \"%s\" was truncated at %O",
                         (file->file)->name.data, file->file_pos);
      }
    }
#line 292
    return ((ssize_t )-1);
  }
#line 298
  return (n);
}
}
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 119 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socketpair)(int __domain ,
                                                                                 int __type ,
                                                                                 int __protocol ,
                                                                                 int *__fds ) ;
#line 100 "/usr/include/x86_64-linux-gnu/sys/epoll.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) epoll_create)(int __size ) ;
#line 113
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) epoll_ctl)(int __epfd ,
                                                                                int __op ,
                                                                                int __fd ,
                                                                                struct epoll_event *__event ) ;
#line 127
extern int epoll_wait(int __epfd , struct epoll_event *__events , int __maxevents ,
                      int __timeout ) ;
#line 34 "/usr/include/x86_64-linux-gnu/sys/eventfd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) eventfd)(int __count ,
                                                                              int __flags ) ;
#line 78 "src/os/unix/ngx_os.h"
ngx_os_io_t ngx_os_io ;
#line 199 "src/event/ngx_event.h"
ngx_uint_t ngx_use_epoll_rdhup  ;
#line 495
sig_atomic_t ngx_event_timer_alarm ;
#line 44 "src/event/ngx_event_posted.h"
ngx_queue_t ngx_posted_accept_events ;
#line 104 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_init(ngx_cycle_t *cycle , ngx_msec_t timer ) ;
#line 106
static ngx_int_t ngx_epoll_notify_init(ngx_log_t *log ) ;
#line 107
static void ngx_epoll_notify_handler(ngx_event_t *ev ) ;
#line 110
static void ngx_epoll_test_rdhup(ngx_cycle_t *cycle ) ;
#line 112
static void ngx_epoll_done(ngx_cycle_t *cycle ) ;
#line 113
static ngx_int_t ngx_epoll_add_event(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
#line 115
static ngx_int_t ngx_epoll_del_event(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) ;
#line 117
static ngx_int_t ngx_epoll_add_connection(ngx_connection_t *c ) ;
#line 118
static ngx_int_t ngx_epoll_del_connection(ngx_connection_t *c , ngx_uint_t flags ) ;
#line 121
static ngx_int_t ngx_epoll_notify(void (*handler)(ngx_event_t *ev ) ) ;
#line 123
static ngx_int_t ngx_epoll_process_events(ngx_cycle_t *cycle , ngx_msec_t timer ,
                                          ngx_uint_t flags ) ;
#line 130
static void *ngx_epoll_create_conf(ngx_cycle_t *cycle ) ;
#line 131
static char *ngx_epoll_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 133 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static int ep  =    -1;
#line 134 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static struct epoll_event *event_list  ;
#line 135 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_uint_t nevents  ;
#line 138 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static int notify_fd  =    -1;
#line 139 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_event_t notify_event  ;
#line 140 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_connection_t notify_conn  ;
#line 157 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_str_t epoll_name  =    {sizeof("epoll") - 1UL, (u_char *)"epoll"};
#line 159 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_command_t ngx_epoll_commands[3]  = {      {{sizeof("epoll_events") - 1UL, (u_char *)"epoll_events"}, (ngx_uint_t )33554434,
      & ngx_conf_set_num_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_epoll_conf_t *)0)->events),
      (void *)0}, 
        {{sizeof("worker_aio_requests") - 1UL, (u_char *)"worker_aio_requests"}, (ngx_uint_t )33554434,
      & ngx_conf_set_num_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_epoll_conf_t *)0)->aio_requests),
      (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 179 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_event_module_t ngx_epoll_module_ctx  =    {& epoll_name, & ngx_epoll_create_conf, & ngx_epoll_init_conf, {& ngx_epoll_add_event,
                                                                   & ngx_epoll_del_event,
                                                                   & ngx_epoll_add_event,
                                                                   & ngx_epoll_del_event,
                                                                   & ngx_epoll_add_connection,
                                                                   & ngx_epoll_del_connection,
                                                                   & ngx_epoll_notify,
                                                                   & ngx_epoll_process_events,
                                                                   & ngx_epoll_init,
                                                                   & ngx_epoll_done}};
#line 202 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
ngx_module_t ngx_epoll_module  = 
#line 202
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_epoll_module_ctx),
    ngx_epoll_commands, (ngx_uint_t )1414420037, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 322 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_init(ngx_cycle_t *cycle , ngx_msec_t timer ) 
{ 
  ngx_epoll_conf_t *epcf ;
  int *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 327
  epcf = (ngx_epoll_conf_t *)*(*(*(cycle->conf_ctx + ngx_events_module.index)) + ngx_epoll_module.ctx_index);
#line 329
  if (ep == -1) {
    {
#line 330
    ep = epoll_create((int )(cycle->connection_n / 2UL));
    }
#line 332
    if (ep == -1) {
#line 333
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 333
        tmp = __errno_location();
#line 333
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp, "epoll_create() failed");
        }
      }
#line 335
      return ((ngx_int_t )-1);
    }
    {
#line 339
    tmp___0 = ngx_epoll_notify_init(cycle->log);
    }
#line 339
    if (tmp___0 != 0L) {
#line 340
      ngx_epoll_module_ctx.actions.notify = (ngx_int_t (*)(void (*handler)(ngx_event_t *ev ) ))((void *)0);
    }
    {
#line 349
    ngx_epoll_test_rdhup(cycle);
    }
  }
#line 353
  if (nevents < epcf->events) {
#line 354
    if (event_list) {
      {
#line 355
      free((void *)event_list);
      }
    }
    {
#line 358
    tmp___1 = ngx_alloc(sizeof(struct epoll_event ) * epcf->events, cycle->log);
#line 358
    event_list = (struct epoll_event *)tmp___1;
    }
#line 360
    if ((unsigned long )event_list == (unsigned long )((void *)0)) {
#line 361
      return ((ngx_int_t )-1);
    }
  }
#line 365
  nevents = epcf->events;
#line 367
  ngx_io = ngx_os_io;
#line 369
  ngx_event_actions = ngx_epoll_module_ctx.actions;
#line 372
  ngx_event_flags = (ngx_uint_t )100;
#line 379
  return ((ngx_int_t )0);
}
}
#line 385 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_notify_init(ngx_log_t *log ) 
{ 
  struct epoll_event ee ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 391
  notify_fd = eventfd(0, 0);
  }
#line 396
  if (notify_fd == -1) {
#line 397
    if (log->log_level >= 1UL) {
      {
#line 397
      tmp = __errno_location();
#line 397
      ngx_log_error_core((ngx_uint_t )1, log, *tmp, "eventfd() failed");
      }
    }
#line 398
    return ((ngx_int_t )-1);
  }
  {
#line 404
  notify_event.handler = & ngx_epoll_notify_handler;
#line 405
  notify_event.log = log;
#line 406
  notify_event.active = 1U;
#line 408
  notify_conn.fd = notify_fd;
#line 409
  notify_conn.read = & notify_event;
#line 410
  notify_conn.log = log;
#line 412
  ee.events = 2147483649U;
#line 413
  ee.data.ptr = (void *)(& notify_conn);
#line 415
  tmp___3 = epoll_ctl(ep, 1, notify_fd, & ee);
  }
#line 415
  if (tmp___3 == -1) {
#line 416
    if (log->log_level >= 1UL) {
      {
#line 416
      tmp___0 = __errno_location();
#line 416
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___0, "epoll_ctl(EPOLL_CTL_ADD, eventfd) failed");
      }
    }
    {
#line 419
    tmp___2 = close(notify_fd);
    }
#line 419
    if (tmp___2 == -1) {
#line 420
      if (log->log_level >= 2UL) {
        {
#line 420
        tmp___1 = __errno_location();
#line 420
        ngx_log_error_core((ngx_uint_t )2, log, *tmp___1, "eventfd close() failed");
        }
      }
    }
#line 424
    return ((ngx_int_t )-1);
  }
#line 427
  return ((ngx_int_t )0);
}
}
#line 431 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static void ngx_epoll_notify_handler(ngx_event_t *ev ) 
{ 
  ssize_t n ;
  uint64_t count ;
  ngx_err_t err ;
  void (*handler)(ngx_event_t *ev ) ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
#line 439
  (ev->index) ++;
#line 439
  if (ev->index == 4294967295UL) {
    {
#line 440
    ev->index = (ngx_uint_t )0;
#line 442
    n = read(notify_fd, (void *)(& count), sizeof(uint64_t ));
#line 444
    tmp = __errno_location();
#line 444
    err = *tmp;
    }
#line 449
    if ((size_t )n != sizeof(uint64_t )) {
#line 450
      if ((ev->log)->log_level >= 2UL) {
        {
#line 450
        ngx_log_error_core((ngx_uint_t )2, ev->log, err, "read() eventfd %d failed",
                           notify_fd);
        }
      }
    }
  }
  {
#line 455
  handler = (void (*)(ngx_event_t *ev ))ev->data;
#line 456
  (*handler)(ev);
  }
#line 457
  return;
}
}
#line 464 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static void ngx_epoll_test_rdhup(ngx_cycle_t *cycle ) 
{ 
  int s[2] ;
  int events ;
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
  {
#line 470
  tmp___0 = socketpair(1, 1, 0, (int *)(s));
  }
#line 470
  if (tmp___0 == -1) {
#line 471
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 471
      tmp = __errno_location();
#line 471
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "socketpair() failed");
      }
    }
#line 473
    return;
  }
  {
#line 476
  ee.events = 2147491841U;
#line 478
  tmp___2 = epoll_ctl(ep, 1, s[0], & ee);
  }
#line 478
  if (tmp___2 == -1) {
#line 479
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 479
      tmp___1 = __errno_location();
#line 479
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "epoll_ctl() failed");
      }
    }
#line 481
    goto failed;
  }
  {
#line 484
  tmp___4 = close(s[1]);
  }
#line 484
  if (tmp___4 == -1) {
#line 485
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 485
      tmp___3 = __errno_location();
#line 485
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "close() failed");
      }
    }
#line 487
    s[1] = -1;
#line 488
    goto failed;
  }
  {
#line 491
  s[1] = -1;
#line 493
  events = epoll_wait(ep, & ee, 1, 5000);
  }
#line 495
  if (events == -1) {
#line 496
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 496
      tmp___5 = __errno_location();
#line 496
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "epoll_wait() failed");
      }
    }
#line 498
    goto failed;
  }
#line 501
  if (events) {
#line 502
    ngx_use_epoll_rdhup = (ngx_uint_t )(ee.events & 8192U);
  } else
#line 505
  if ((cycle->log)->log_level >= 2UL) {
    {
#line 505
    ngx_log_error_core((ngx_uint_t )2, cycle->log, 110, "epoll_wait() timed out");
    }
  }
  failed: 
#line 515
  if (s[1] != -1) {
    {
#line 515
    tmp___7 = close(s[1]);
    }
#line 515
    if (tmp___7 == -1) {
#line 516
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 516
        tmp___6 = __errno_location();
#line 516
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___6, "close() failed");
        }
      }
    }
  }
  {
#line 520
  tmp___9 = close(s[0]);
  }
#line 520
  if (tmp___9 == -1) {
#line 521
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 521
      tmp___8 = __errno_location();
#line 521
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___8, "close() failed");
      }
    }
  }
#line 524
  return;
}
}
#line 529 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static void ngx_epoll_done(ngx_cycle_t *cycle ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 532
  tmp___0 = close(ep);
  }
#line 532
  if (tmp___0 == -1) {
#line 533
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 533
      tmp = __errno_location();
#line 533
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "epoll close() failed");
      }
    }
  }
  {
#line 537
  ep = -1;
#line 541
  tmp___2 = close(notify_fd);
  }
#line 541
  if (tmp___2 == -1) {
#line 542
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 542
      tmp___1 = __errno_location();
#line 542
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "eventfd close() failed");
      }
    }
  }
  {
#line 546
  notify_fd = -1;
#line 571
  free((void *)event_list);
#line 573
  event_list = (struct epoll_event *)((void *)0);
#line 574
  nevents = (ngx_uint_t )0;
  }
#line 575
  return;
}
}
#line 578 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_add_event(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) 
{ 
  int op ;
  uint32_t events ;
  uint32_t prev ;
  ngx_event_t *e ;
  ngx_connection_t *c ;
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp12 ;

  {
#line 587
  c = (ngx_connection_t *)ev->data;
#line 589
  events = (uint32_t )event;
#line 591
  if (event == 8193L) {
#line 592
    e = c->write;
#line 593
    prev = (uint32_t )4;
  } else {
#line 599
    e = c->read;
#line 600
    prev = (uint32_t )8193;
  }
#line 606
  if (e->active) {
#line 607
    op = 3;
#line 608
    events |= prev;
  } else {
#line 611
    op = 1;
  }
  {
#line 620
  ee.events = events | (uint32_t )flags;
#line 621
  ee.data.ptr = (void *)((uintptr_t )c | (unsigned long )ev->instance);
#line 627
  tmp___0 = epoll_ctl(ep, op, c->fd, & ee);
  }
#line 627
  if (tmp___0 == -1) {
#line 628
    if ((ev->log)->log_level >= 2UL) {
      {
#line 628
      tmp = __errno_location();
#line 628
      ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp, "epoll_ctl(%d, %d) failed",
                         op, c->fd);
      }
    }
#line 630
    return ((ngx_int_t )-1);
  }
#line 633
  ev->active = 1U;
#line 638
  return ((ngx_int_t )0);
}
}
#line 642 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_del_event(ngx_event_t *ev , ngx_int_t event , ngx_uint_t flags ) 
{ 
  int op ;
  uint32_t prev ;
  ngx_event_t *e ;
  ngx_connection_t *c ;
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;

  {
#line 657
  if (flags & 1UL) {
#line 658
    ev->active = 0U;
#line 659
    return ((ngx_int_t )0);
  }
#line 662
  c = (ngx_connection_t *)ev->data;
#line 664
  if (event == 8193L) {
#line 665
    e = c->write;
#line 666
    prev = (uint32_t )4;
  } else {
#line 669
    e = c->read;
#line 670
    prev = (uint32_t )8193;
  }
#line 673
  if (e->active) {
#line 674
    op = 3;
#line 675
    ee.events = prev | (uint32_t )flags;
#line 676
    ee.data.ptr = (void *)((uintptr_t )c | (unsigned long )ev->instance);
  } else {
#line 679
    op = 2;
#line 680
    ee.events = (uint32_t )0;
#line 681
    ee.data.ptr = (void *)0;
  }
  {
#line 688
  tmp___0 = epoll_ctl(ep, op, c->fd, & ee);
  }
#line 688
  if (tmp___0 == -1) {
#line 689
    if ((ev->log)->log_level >= 2UL) {
      {
#line 689
      tmp = __errno_location();
#line 689
      ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp, "epoll_ctl(%d, %d) failed",
                         op, c->fd);
      }
    }
#line 691
    return ((ngx_int_t )-1);
  }
#line 694
  ev->active = 0U;
#line 696
  return ((ngx_int_t )0);
}
}
#line 700 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_add_connection(ngx_connection_t *c ) 
{ 
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 705
  ee.events = 2147491845U;
#line 706
  ee.data.ptr = (void *)((uintptr_t )c | (unsigned long )(c->read)->instance);
#line 711
  tmp___0 = epoll_ctl(ep, 1, c->fd, & ee);
  }
#line 711
  if (tmp___0 == -1) {
#line 712
    if ((c->log)->log_level >= 2UL) {
      {
#line 712
      tmp = __errno_location();
#line 712
      ngx_log_error_core((ngx_uint_t )2, c->log, *tmp, "epoll_ctl(EPOLL_CTL_ADD, %d) failed",
                         c->fd);
      }
    }
#line 714
    return ((ngx_int_t )-1);
  }
#line 717
  (c->read)->active = 1U;
#line 718
  (c->write)->active = 1U;
#line 720
  return ((ngx_int_t )0);
}
}
#line 724 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_del_connection(ngx_connection_t *c , ngx_uint_t flags ) 
{ 
  int op ;
  struct epoll_event ee ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 736
  if (flags & 1UL) {
#line 737
    (c->read)->active = 0U;
#line 738
    (c->write)->active = 0U;
#line 739
    return ((ngx_int_t )0);
  }
  {
#line 745
  op = 2;
#line 746
  ee.events = (uint32_t )0;
#line 747
  ee.data.ptr = (void *)0;
#line 749
  tmp___0 = epoll_ctl(ep, op, c->fd, & ee);
  }
#line 749
  if (tmp___0 == -1) {
#line 750
    if ((c->log)->log_level >= 2UL) {
      {
#line 750
      tmp = __errno_location();
#line 750
      ngx_log_error_core((ngx_uint_t )2, c->log, *tmp, "epoll_ctl(%d, %d) failed",
                         op, c->fd);
      }
    }
#line 752
    return ((ngx_int_t )-1);
  }
#line 755
  (c->read)->active = 0U;
#line 756
  (c->write)->active = 0U;
#line 758
  return ((ngx_int_t )0);
}
}
#line 767 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static uint64_t inc  =    (uint64_t )1;
#line 764 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_notify(void (*handler)(ngx_event_t *ev ) ) 
{ 
  int *tmp ;
  ssize_t tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 769
  notify_event.data = (void *)handler;
#line 771
  tmp___0 = write(notify_fd, (void const   *)(& inc), sizeof(uint64_t ));
  }
#line 771
  if ((size_t )tmp___0 != sizeof(uint64_t )) {
#line 772
    if ((notify_event.log)->log_level >= 2UL) {
      {
#line 772
      tmp = __errno_location();
#line 772
      ngx_log_error_core((ngx_uint_t )2, notify_event.log, *tmp, "write() to eventfd %d failed",
                         notify_fd);
      }
    }
#line 774
    return ((ngx_int_t )-1);
  }
#line 777
  return ((ngx_int_t )0);
}
}
#line 783 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static ngx_int_t ngx_epoll_process_events(ngx_cycle_t *cycle , ngx_msec_t timer ,
                                          ngx_uint_t flags ) 
{ 
  int events ;
  uint32_t revents ;
  ngx_int_t instance ;
  ngx_int_t i ;
  ngx_uint_t level ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_queue_t *queue ;
  ngx_connection_t *c ;
  int *tmp ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 800
  events = epoll_wait(ep, event_list, (int )nevents, (int )timer);
  }
#line 802
  if (events == -1) {
    {
#line 802
    tmp = __errno_location();
#line 802
    err = *tmp;
    }
  } else {
#line 802
    err = 0;
  }
#line 804
  if (flags & 1UL) {
    {
#line 805
    ngx_time_update();
    }
  } else
#line 804
  if (ngx_event_timer_alarm) {
    {
#line 805
    ngx_time_update();
    }
  }
#line 808
  if (err) {
#line 809
    if (err == 4) {
#line 811
      if (ngx_event_timer_alarm) {
#line 812
        ngx_event_timer_alarm = 0;
#line 813
        return ((ngx_int_t )0);
      }
#line 816
      level = (ngx_uint_t )7;
    } else {
#line 819
      level = (ngx_uint_t )2;
    }
#line 822
    if ((cycle->log)->log_level >= level) {
      {
#line 822
      ngx_log_error_core(level, cycle->log, err, "epoll_wait() failed");
      }
    }
#line 823
    return ((ngx_int_t )-1);
  }
#line 826
  if (events == 0) {
#line 827
    if (timer != 0xffffffffffffffffUL) {
#line 828
      return ((ngx_int_t )0);
    }
#line 831
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 831
      ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "epoll_wait() returned no events without timeout");
      }
    }
#line 833
    return ((ngx_int_t )-1);
  }
#line 836
  i = (ngx_int_t )0;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (! (i < (ngx_int_t )events)) {
#line 836
      goto while_break;
    }
#line 837
    c = (ngx_connection_t *)(event_list + i)->data.ptr;
#line 839
    instance = (ngx_int_t )((uintptr_t )c & 1UL);
#line 840
    c = (ngx_connection_t *)((uintptr_t )c & 0xfffffffffffffffeUL);
#line 842
    rev = c->read;
#line 844
    if (c->fd == -1) {
#line 853
      goto __Cont;
    } else
#line 844
    if ((ngx_int_t )rev->instance != instance) {
#line 853
      goto __Cont;
    }
#line 856
    revents = (event_list + i)->events;
#line 862
    if (revents & 24U) {
#line 872
      revents |= 5U;
    }
#line 883
    if (revents & 1U) {
#line 883
      if (rev->active) {
#line 886
        if (revents & 8192U) {
#line 887
          rev->pending_eof = 1U;
        }
#line 890
        rev->available = 1U;
#line 893
        rev->ready = 1U;
#line 895
        if (flags & 2UL) {
#line 896
          if (rev->accept) {
#line 896
            queue = & ngx_posted_accept_events;
          } else {
#line 896
            queue = & ngx_posted_events;
          }
#line 899
          if (! rev->posted) {
#line 899
            rev->posted = 1U;
#line 899
            rev->queue.prev = queue->prev;
#line 899
            (rev->queue.prev)->next = & rev->queue;
#line 899
            rev->queue.next = queue;
#line 899
            queue->prev = & rev->queue;
          }
        } else {
          {
#line 902
          (*(rev->handler))(rev);
          }
        }
      }
    }
#line 906
    wev = c->write;
#line 908
    if (revents & 4U) {
#line 908
      if (wev->active) {
#line 910
        if (c->fd == -1) {
#line 919
          goto __Cont;
        } else
#line 910
        if ((ngx_int_t )wev->instance != instance) {
#line 919
          goto __Cont;
        }
#line 922
        wev->ready = 1U;
#line 927
        if (flags & 2UL) {
#line 928
          if (! wev->posted) {
#line 928
            wev->posted = 1U;
#line 928
            wev->queue.prev = ngx_posted_events.prev;
#line 928
            (wev->queue.prev)->next = & wev->queue;
#line 928
            wev->queue.next = & ngx_posted_events;
#line 928
            ngx_posted_events.prev = & wev->queue;
          }
        } else {
          {
#line 931
          (*(wev->handler))(wev);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 836
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 936
  return ((ngx_int_t )0);
}
}
#line 1026 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static void *ngx_epoll_create_conf(ngx_cycle_t *cycle ) 
{ 
  ngx_epoll_conf_t *epcf ;
  void *tmp ;

  {
  {
#line 1031
  tmp = ngx_palloc(cycle->pool, sizeof(ngx_epoll_conf_t ));
#line 1031
  epcf = (ngx_epoll_conf_t *)tmp;
  }
#line 1032
  if ((unsigned long )epcf == (unsigned long )((void *)0)) {
#line 1033
    return ((void *)0);
  }
#line 1036
  epcf->events = (ngx_uint_t )-1;
#line 1037
  epcf->aio_requests = (ngx_uint_t )-1;
#line 1039
  return ((void *)epcf);
}
}
#line 1043 "/home/khheo/project/nginx-release-1.13.8/src/event/modules/ngx_epoll_module.c"
static char *ngx_epoll_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  ngx_epoll_conf_t *epcf ;

  {
#line 1046
  epcf = (ngx_epoll_conf_t *)conf;
#line 1048
  if (epcf->events == 0xffffffffffffffffUL) {
#line 1048
    epcf->events = (ngx_uint_t )512;
  }
#line 1049
  if (epcf->aio_requests == 0xffffffffffffffffUL) {
#line 1049
    epcf->aio_requests = (ngx_uint_t )32;
  }
#line 1051
  return ((char *)((void *)0));
}
}
#line 81 "/usr/include/x86_64-linux-gnu/sys/utsname.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) uname)(struct utsname *__name ) ;
#line 40 "src/os/unix/ngx_os.h"
ngx_int_t ngx_os_specific_init(ngx_log_t *log ) ;
#line 41
void ngx_os_specific_status(ngx_log_t *log ) ;
#line 46
ssize_t ngx_unix_recv(ngx_connection_t *c , u_char *buf , size_t size ) ;
#line 47
ssize_t ngx_readv_chain(ngx_connection_t *c , ngx_chain_t *chain , off_t limit ) ;
#line 48
ssize_t ngx_udp_unix_recv(ngx_connection_t *c , u_char *buf , size_t size ) ;
#line 49
ssize_t ngx_unix_send(ngx_connection_t *c , u_char *buf , size_t size ) ;
#line 52
ssize_t ngx_udp_unix_send(ngx_connection_t *c , u_char *buf , size_t size ) ;
#line 53
ngx_chain_t *ngx_udp_unix_sendmsg_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_linux_init.c"
u_char ngx_linux_kern_ostype[50]  ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_linux_init.c"
u_char ngx_linux_kern_osrelease[50]  ;
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_linux_init.c"
static ngx_os_io_t ngx_linux_io  = 
#line 16
     {& ngx_unix_recv, & ngx_readv_chain, & ngx_udp_unix_recv, & ngx_unix_send, & ngx_udp_unix_send,
    & ngx_udp_unix_sendmsg_chain, & ngx_linux_sendfile_chain, (ngx_uint_t )1};
#line 33 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_linux_init.c"
ngx_int_t ngx_os_specific_init(ngx_log_t *log ) 
{ 
  struct utsname u ;
  int *tmp ;
  int tmp___0 ;
  void *__cil_tmp5 ;
  void *__cil_tmp6 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;
  void *__cil_tmp9 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 38
  tmp___0 = uname(& u);
  }
#line 38
  if (tmp___0 == -1) {
#line 39
    if (log->log_level >= 2UL) {
      {
#line 39
      tmp = __errno_location();
#line 39
      ngx_log_error_core((ngx_uint_t )2, log, *tmp, "uname() failed");
      }
    }
#line 40
    return ((ngx_int_t )-1);
  }
  {
#line 43
  ngx_cpystrn(ngx_linux_kern_ostype, (u_char *)(u.sysname), sizeof(ngx_linux_kern_ostype));
#line 46
  ngx_cpystrn(ngx_linux_kern_osrelease, (u_char *)(u.release), sizeof(ngx_linux_kern_osrelease));
#line 49
  ngx_os_io = ngx_linux_io;
  }
#line 51
  return ((ngx_int_t )0);
}
}
#line 55 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_linux_init.c"
void ngx_os_specific_status(ngx_log_t *log ) 
{ 
  char *__cil_tmp2 ;

  {
#line 58
  if (log->log_level >= 6UL) {
    {
#line 58
    ngx_log_error_core((ngx_uint_t )6, log, 0, "OS: %s %s", ngx_linux_kern_ostype,
                       ngx_linux_kern_osrelease);
    }
  }
#line 60
  return;
}
}
#line 131 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setitimer)(__itimer_which_t __which ,
                                                                                struct itimerval  const  * __restrict  __new ,
                                                                                struct itimerval * __restrict  __old ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 1058
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) syscall)(long __sysno 
                                                                               , ...) ;
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 324 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srandom)(unsigned int __seed ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 215
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 256
extern int ( __attribute__((__nonnull__(1))) sigsuspend)(sigset_t const   *__set ) ;
#line 201 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 73 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits )  __asm__("setrlimit64")  ;
#line 97
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 27 "/usr/include/x86_64-linux-gnu/sys/prctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) prctl)(int __option 
                                                                            , ...) ;
#line 26 "src/os/unix/ngx_setaffinity.h"
void ngx_setaffinity(ngx_cpuset_t *cpu_affinity , ngx_log_t *log ) ;
#line 38 "src/os/unix/ngx_setproctitle.h"
void ngx_setproctitle(char *title___0 ) ;
#line 64 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle , void (*proc)(ngx_cycle_t *cycle ,
                                                              void *data ) , void *data ,
                            char *name , ngx_int_t respawn ) ;
#line 78
int ngx_argc ;
#line 79
char **ngx_argv ;
#line 82 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_pid  ;
#line 83 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_parent  ;
#line 84
ngx_socket_t ngx_channel ;
#line 85
ngx_int_t ngx_process_slot ;
#line 86
ngx_int_t ngx_last_process ;
#line 87
ngx_process_t ngx_processes[1024] ;
#line 237 "src/core/ngx_log.h"
ngx_log_t *ngx_log_get_file_log(ngx_log_t *head___0 ) ;
#line 125 "src/core/ngx_cycle.h"
ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle ) ;
#line 127
void ngx_delete_pidfile(ngx_cycle_t *cycle ) ;
#line 129
void ngx_reopen_files(ngx_cycle_t *cycle , ngx_uid_t user ) ;
#line 130
char **ngx_set_environment(ngx_cycle_t *cycle , ngx_uint_t *last ) ;
#line 131
ngx_pid_t ngx_exec_new_binary(ngx_cycle_t *cycle , char * const  *argv ) ;
#line 132
ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n ) ;
#line 135
void ngx_set_shutdown_timer(ngx_cycle_t *cycle ) ;
#line 37 "src/os/unix/ngx_process_cycle.h"
void ngx_master_process_cycle(ngx_cycle_t *cycle ) ;
#line 38
void ngx_single_process_cycle(ngx_cycle_t *cycle ) ;
#line 41 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_process  ;
#line 42 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_worker  ;
#line 44 "src/os/unix/ngx_process_cycle.h"
ngx_pid_t ngx_new_binary  ;
#line 45 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_inherited  ;
#line 46 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_daemonized  ;
#line 47 "src/os/unix/ngx_process_cycle.h"
ngx_uint_t ngx_exiting  ;
#line 49 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_reap  ;
#line 50 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_sigio  ;
#line 51 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_sigalrm  ;
#line 52 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_quit  ;
#line 53 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_debug_quit  ;
#line 54 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_terminate  ;
#line 55 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_noaccept  ;
#line 56 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_reconfigure  ;
#line 57 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_reopen  ;
#line 58 "src/os/unix/ngx_process_cycle.h"
sig_atomic_t ngx_change_binary  ;
#line 212 "src/core/ngx_connection.h"
void ngx_close_listening_sockets(ngx_cycle_t *cycle ) ;
#line 214
void ngx_close_idle_connections(ngx_cycle_t *cycle ) ;
#line 514 "src/event/ngx_event.h"
void ngx_process_events_and_timers(ngx_cycle_t *cycle ) ;
#line 25 "src/event/ngx_event_timer.h"
ngx_int_t ngx_event_no_timers_left(void) ;
#line 25 "src/os/unix/ngx_channel.h"
ngx_int_t ngx_write_channel(ngx_socket_t s , ngx_channel_t *ch , size_t size , ngx_log_t *log ) ;
#line 27
ngx_int_t ngx_read_channel(ngx_socket_t s , ngx_channel_t *ch , size_t size , ngx_log_t *log ) ;
#line 29
ngx_int_t ngx_add_channel_event(ngx_cycle_t *cycle , ngx_fd_t fd , ngx_int_t event ,
                                void (*handler)(ngx_event_t *ev ) ) ;
#line 31
void ngx_close_channel(ngx_fd_t *fd , ngx_log_t *log ) ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_start_worker_processes(ngx_cycle_t *cycle , ngx_int_t n , ngx_int_t type ) ;
#line 16
static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle , ngx_uint_t respawn ) ;
#line 18
static void ngx_pass_open_channel(ngx_cycle_t *cycle , ngx_channel_t *ch ) ;
#line 19
static void ngx_signal_worker_processes(ngx_cycle_t *cycle , int signo ) ;
#line 20
static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle ) ;
#line 21
static void ngx_master_process_exit(ngx_cycle_t *cycle ) ;
#line 22
static void ngx_worker_process_cycle(ngx_cycle_t *cycle , void *data ) ;
#line 23
static void ngx_worker_process_init(ngx_cycle_t *cycle , ngx_int_t worker ) ;
#line 24
static void ngx_worker_process_exit(ngx_cycle_t *cycle ) ;
#line 25
static void ngx_channel_handler(ngx_event_t *ev ) ;
#line 26
static void ngx_cache_manager_process_cycle(ngx_cycle_t *cycle , void *data ) ;
#line 27
static void ngx_cache_manager_process_handler(ngx_event_t *ev ) ;
#line 28
static void ngx_cache_loader_process_handler(ngx_event_t *ev ) ;
#line 52 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
ngx_uint_t ngx_noaccepting  ;
#line 53 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
ngx_uint_t ngx_restart  ;
#line 56 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static u_char master_process[15]  = 
#line 56
  {      (u_char )'m',      (u_char )'a',      (u_char )'s',      (u_char )'t', 
        (u_char )'e',      (u_char )'r',      (u_char )' ',      (u_char )'p', 
        (u_char )'r',      (u_char )'o',      (u_char )'c',      (u_char )'e', 
        (u_char )'s',      (u_char )'s',      (u_char )'\000'};
#line 59 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static ngx_cache_manager_ctx_t ngx_cache_manager_ctx  =    {& ngx_cache_manager_process_handler, (char *)"cache manager process", (ngx_msec_t )0};
#line 63 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static ngx_cache_manager_ctx_t ngx_cache_loader_ctx  =    {& ngx_cache_loader_process_handler, (char *)"cache loader process", (ngx_msec_t )60000};
#line 68 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static ngx_cycle_t ngx_exit_cycle  ;
#line 69 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static ngx_log_t ngx_exit_log  ;
#line 70 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static ngx_open_file_t ngx_exit_log_file  ;
#line 73 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
void ngx_master_process_cycle(ngx_cycle_t *cycle ) 
{ 
  char *title___0 ;
  u_char *p ;
  size_t size ;
  ngx_int_t i ;
  ngx_uint_t n ;
  ngx_uint_t sigio ;
  sigset_t set ;
  struct itimerval itv ;
  ngx_uint_t live ;
  ngx_msec_t delay ;
  ngx_listening_t *ls ;
  ngx_core_conf_t *ccf ;
  int *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 88
  sigemptyset(& set);
#line 89
  sigaddset(& set, 17);
#line 90
  sigaddset(& set, 14);
#line 91
  sigaddset(& set, 29);
#line 92
  sigaddset(& set, 2);
#line 93
  sigaddset(& set, 1);
#line 94
  sigaddset(& set, 10);
#line 95
  sigaddset(& set, 28);
#line 96
  sigaddset(& set, 15);
#line 97
  sigaddset(& set, 3);
#line 98
  sigaddset(& set, 12);
#line 100
  tmp___0 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 100
  if (tmp___0 == -1) {
#line 101
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 101
      tmp = __errno_location();
#line 101
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "sigprocmask() failed");
      }
    }
  }
  {
#line 105
  sigemptyset(& set);
#line 108
  size = sizeof(master_process);
#line 110
  i = (ngx_int_t )0;
  }
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! (i < (ngx_int_t )ngx_argc)) {
#line 110
      goto while_break;
    }
    {
#line 111
    tmp___1 = strlen((char const   *)*(ngx_argv + i));
#line 111
    size += tmp___1 + 1UL;
#line 110
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  tmp___2 = ngx_pnalloc(cycle->pool, size);
#line 114
  title___0 = (char *)tmp___2;
  }
#line 115
  if ((unsigned long )title___0 == (unsigned long )((void *)0)) {
    {
#line 117
    exit(2);
    }
  }
  {
#line 120
  tmp___3 = memcpy((void */* __restrict  */)title___0, (void const   */* __restrict  */)(master_process),
                   sizeof(master_process) - 1UL);
#line 120
  p = (u_char *)tmp___3 + (sizeof(master_process) - 1UL);
#line 121
  i = (ngx_int_t )0;
  }
  {
#line 121
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 121
    if (! (i < (ngx_int_t )ngx_argc)) {
#line 121
      goto while_break___0;
    }
    {
#line 122
    tmp___4 = p;
#line 122
    p ++;
#line 122
    *tmp___4 = (u_char )' ';
#line 123
    p = ngx_cpystrn(p, (u_char *)*(ngx_argv + i), size);
#line 121
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 126
  ngx_setproctitle(title___0);
#line 129
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 131
  ngx_start_worker_processes(cycle, ccf->worker_processes, (ngx_int_t )-3);
#line 133
  ngx_start_cache_manager_processes(cycle, (ngx_uint_t )0);
#line 135
  ngx_new_binary = 0;
#line 136
  delay = (ngx_msec_t )0;
#line 137
  sigio = (ngx_uint_t )0;
#line 138
  live = (ngx_uint_t )1;
  }
  {
#line 140
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 141
    if (delay) {
#line 142
      if (ngx_sigalrm) {
#line 143
        sigio = (ngx_uint_t )0;
#line 144
        delay *= 2UL;
#line 145
        ngx_sigalrm = 0;
      }
      {
#line 151
      itv.it_interval.tv_sec = (__time_t )0;
#line 152
      itv.it_interval.tv_usec = (__suseconds_t )0;
#line 153
      itv.it_value.tv_sec = (__time_t )(delay / 1000UL);
#line 154
      itv.it_value.tv_usec = (__suseconds_t )((delay % 1000UL) * 1000UL);
#line 156
      tmp___6 = setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& itv),
                          (struct itimerval */* __restrict  */)((void *)0));
      }
#line 156
      if (tmp___6 == -1) {
#line 157
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 157
          tmp___5 = __errno_location();
#line 157
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "setitimer() failed");
          }
        }
      }
    }
    {
#line 164
    sigsuspend((sigset_t const   *)(& set));
#line 166
    ngx_time_update();
    }
#line 171
    if (ngx_reap) {
      {
#line 172
      ngx_reap = 0;
#line 175
      live = ngx_reap_children(cycle);
      }
    }
#line 178
    if (! live) {
#line 178
      if (ngx_terminate) {
        {
#line 179
        ngx_master_process_exit(cycle);
        }
      } else
#line 178
      if (ngx_quit) {
        {
#line 179
        ngx_master_process_exit(cycle);
        }
      }
    }
#line 182
    if (ngx_terminate) {
#line 183
      if (delay == 0UL) {
#line 184
        delay = (ngx_msec_t )50;
      }
#line 187
      if (sigio) {
#line 188
        sigio --;
#line 189
        goto __Cont;
      }
#line 192
      sigio = (ngx_uint_t )(ccf->worker_processes + 2L);
#line 194
      if (delay > 1000UL) {
        {
#line 195
        ngx_signal_worker_processes(cycle, 9);
        }
      } else {
        {
#line 197
        ngx_signal_worker_processes(cycle, 15);
        }
      }
#line 201
      goto __Cont;
    }
#line 204
    if (ngx_quit) {
      {
#line 205
      ngx_signal_worker_processes(cycle, 3);
#line 208
      ls = (ngx_listening_t *)cycle->listening.elts;
#line 209
      n = (ngx_uint_t )0;
      }
      {
#line 209
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 209
        if (! (n < cycle->listening.nelts)) {
#line 209
          goto while_break___2;
        }
        {
#line 210
        tmp___8 = close((ls + n)->fd);
        }
#line 210
        if (tmp___8 == -1) {
#line 211
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 211
            tmp___7 = __errno_location();
#line 211
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___7, "close() socket %V failed",
                               & (ls + n)->addr_text);
            }
          }
        }
#line 209
        n ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 216
      cycle->listening.nelts = (ngx_uint_t )0;
#line 218
      goto __Cont;
    }
#line 221
    if (ngx_reconfigure) {
#line 222
      ngx_reconfigure = 0;
#line 224
      if (ngx_new_binary) {
        {
#line 225
        ngx_start_worker_processes(cycle, ccf->worker_processes, (ngx_int_t )-3);
#line 227
        ngx_start_cache_manager_processes(cycle, (ngx_uint_t )0);
#line 228
        ngx_noaccepting = (ngx_uint_t )0;
        }
#line 230
        goto __Cont;
      }
#line 233
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 233
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reconfiguring");
        }
      }
      {
#line 235
      cycle = ngx_init_cycle(cycle);
      }
#line 236
      if ((unsigned long )cycle == (unsigned long )((void *)0)) {
#line 237
        cycle = (ngx_cycle_t *)ngx_cycle;
#line 238
        goto __Cont;
      }
      {
#line 241
      ngx_cycle = (ngx_cycle_t volatile   *)cycle;
#line 242
      ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 244
      ngx_start_worker_processes(cycle, ccf->worker_processes, (ngx_int_t )-4);
#line 246
      ngx_start_cache_manager_processes(cycle, (ngx_uint_t )1);
#line 249
      usleep((__useconds_t )100000);
#line 251
      live = (ngx_uint_t )1;
#line 252
      ngx_signal_worker_processes(cycle, 3);
      }
    }
#line 256
    if (ngx_restart) {
      {
#line 257
      ngx_restart = (ngx_uint_t )0;
#line 258
      ngx_start_worker_processes(cycle, ccf->worker_processes, (ngx_int_t )-3);
#line 260
      ngx_start_cache_manager_processes(cycle, (ngx_uint_t )0);
#line 261
      live = (ngx_uint_t )1;
      }
    }
#line 264
    if (ngx_reopen) {
#line 265
      ngx_reopen = 0;
#line 266
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 266
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reopening logs");
        }
      }
      {
#line 267
      ngx_reopen_files(cycle, ccf->user);
#line 268
      ngx_signal_worker_processes(cycle, 10);
      }
    }
#line 272
    if (ngx_change_binary) {
#line 273
      ngx_change_binary = 0;
#line 274
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 274
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "changing binary");
        }
      }
      {
#line 275
      ngx_new_binary = ngx_exec_new_binary(cycle, (char * const  *)ngx_argv);
      }
    }
#line 278
    if (ngx_noaccept) {
      {
#line 279
      ngx_noaccept = 0;
#line 280
      ngx_noaccepting = (ngx_uint_t )1;
#line 281
      ngx_signal_worker_processes(cycle, 3);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
}
}
#line 288 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
void ngx_single_process_cycle(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  char **tmp ;
  ngx_int_t tmp___0 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 293
  tmp = ngx_set_environment(cycle, (ngx_uint_t *)((void *)0));
  }
#line 293
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 295
    exit(2);
    }
  }
#line 298
  i = (ngx_uint_t )0;
  {
#line 298
  while (1) {
    while_continue: /* CIL Label */ ;
#line 298
    if (! *(cycle->modules + i)) {
#line 298
      goto while_break;
    }
#line 299
    if ((*(cycle->modules + i))->init_process) {
      {
#line 300
      tmp___0 = (*((*(cycle->modules + i))->init_process))(cycle);
      }
#line 300
      if (tmp___0 == -1L) {
        {
#line 302
        exit(2);
        }
      }
    }
#line 298
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 310
    ngx_process_events_and_timers(cycle);
    }
#line 312
    if (ngx_terminate) {
#line 312
      goto _L;
    } else
#line 312
    if (ngx_quit) {
      _L: /* CIL Label */ 
#line 314
      i = (ngx_uint_t )0;
      {
#line 314
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 314
        if (! *(cycle->modules + i)) {
#line 314
          goto while_break___1;
        }
#line 315
        if ((*(cycle->modules + i))->exit_process) {
          {
#line 316
          (*((*(cycle->modules + i))->exit_process))(cycle);
          }
        }
#line 314
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 320
      ngx_master_process_exit(cycle);
      }
    }
#line 323
    if (ngx_reconfigure) {
#line 324
      ngx_reconfigure = 0;
#line 325
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 325
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reconfiguring");
        }
      }
      {
#line 327
      cycle = ngx_init_cycle(cycle);
      }
#line 328
      if ((unsigned long )cycle == (unsigned long )((void *)0)) {
#line 329
        cycle = (ngx_cycle_t *)ngx_cycle;
#line 330
        goto __Cont;
      }
#line 333
      ngx_cycle = (ngx_cycle_t volatile   *)cycle;
    }
#line 336
    if (ngx_reopen) {
#line 337
      ngx_reopen = 0;
#line 338
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 338
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reopening logs");
        }
      }
      {
#line 339
      ngx_reopen_files(cycle, (ngx_uid_t )-1);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 345 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_start_worker_processes(ngx_cycle_t *cycle , ngx_int_t n , ngx_int_t type ) 
{ 
  ngx_int_t i ;
  ngx_channel_t ch ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 351
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 351
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "start worker processes");
    }
  }
  {
#line 353
  memset((void *)(& ch), 0, sizeof(ngx_channel_t ));
#line 355
  ch.command = (ngx_uint_t )1;
#line 357
  i = (ngx_int_t )0;
  }
  {
#line 357
  while (1) {
    while_continue: /* CIL Label */ ;
#line 357
    if (! (i < n)) {
#line 357
      goto while_break;
    }
    {
#line 359
    ngx_spawn_process(cycle, & ngx_worker_process_cycle, (void *)i, (char *)"worker process",
                      type);
#line 362
    ch.pid = ngx_processes[ngx_process_slot].pid;
#line 363
    ch.slot = ngx_process_slot;
#line 364
    ch.fd = ngx_processes[ngx_process_slot].channel[0];
#line 366
    ngx_pass_open_channel(cycle, & ch);
#line 357
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  return;
}
}
#line 371 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle , ngx_uint_t respawn ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t manager ;
  ngx_uint_t loader ;
  ngx_path_t **path ;
  ngx_channel_t ch ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 378
  manager = (ngx_uint_t )0;
#line 379
  loader = (ngx_uint_t )0;
#line 381
  path = (ngx_path_t **)ngx_cycle->paths.elts;
#line 382
  i = (ngx_uint_t )0;
  {
#line 382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 382
    if (! (i < (ngx_uint_t )ngx_cycle->paths.nelts)) {
#line 382
      goto while_break;
    }
#line 384
    if ((*(path + i))->manager) {
#line 385
      manager = (ngx_uint_t )1;
    }
#line 388
    if ((*(path + i))->loader) {
#line 389
      loader = (ngx_uint_t )1;
    }
#line 382
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  if (manager == 0UL) {
#line 394
    return;
  }
#line 397
  if (respawn) {
#line 397
    tmp = -4;
  } else {
#line 397
    tmp = -3;
  }
  {
#line 397
  ngx_spawn_process(cycle, & ngx_cache_manager_process_cycle, (void *)(& ngx_cache_manager_ctx),
                    (char *)"cache manager process", (ngx_int_t )tmp);
#line 401
  memset((void *)(& ch), 0, sizeof(ngx_channel_t ));
#line 403
  ch.command = (ngx_uint_t )1;
#line 404
  ch.pid = ngx_processes[ngx_process_slot].pid;
#line 405
  ch.slot = ngx_process_slot;
#line 406
  ch.fd = ngx_processes[ngx_process_slot].channel[0];
#line 408
  ngx_pass_open_channel(cycle, & ch);
  }
#line 410
  if (loader == 0UL) {
#line 411
    return;
  }
#line 414
  if (respawn) {
#line 414
    tmp___0 = -2;
  } else {
#line 414
    tmp___0 = -1;
  }
  {
#line 414
  ngx_spawn_process(cycle, & ngx_cache_manager_process_cycle, (void *)(& ngx_cache_loader_ctx),
                    (char *)"cache loader process", (ngx_int_t )tmp___0);
#line 418
  ch.command = (ngx_uint_t )1;
#line 419
  ch.pid = ngx_processes[ngx_process_slot].pid;
#line 420
  ch.slot = ngx_process_slot;
#line 421
  ch.fd = ngx_processes[ngx_process_slot].channel[0];
#line 423
  ngx_pass_open_channel(cycle, & ch);
  }
#line 424
  return;
}
}
#line 427 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_pass_open_channel(ngx_cycle_t *cycle , ngx_channel_t *ch ) 
{ 
  ngx_int_t i ;

  {
#line 432
  i = (ngx_int_t )0;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (i < ngx_last_process)) {
#line 432
      goto while_break;
    }
#line 434
    if (i == ngx_process_slot) {
#line 438
      goto __Cont;
    } else
#line 434
    if (ngx_processes[i].pid == -1) {
#line 438
      goto __Cont;
    } else
#line 434
    if (ngx_processes[i].channel[0] == -1) {
#line 438
      goto __Cont;
    }
    {
#line 449
    ngx_write_channel(ngx_processes[i].channel[0], ch, sizeof(ngx_channel_t ), cycle->log);
    }
    __Cont: /* CIL Label */ 
#line 432
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 452
  return;
}
}
#line 455 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_signal_worker_processes(ngx_cycle_t *cycle , int signo ) 
{ 
  ngx_int_t i ;
  ngx_err_t err ;
  ngx_channel_t ch ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;

  {
  {
#line 462
  memset((void *)(& ch), 0, sizeof(ngx_channel_t ));
  }
  {
#line 472
  if (signo == 3) {
#line 472
    goto case_3;
  }
#line 476
  if (signo == 15) {
#line 476
    goto case_15;
  }
#line 480
  if (signo == 10) {
#line 480
    goto case_10;
  }
#line 484
  goto switch_default;
  case_3: /* CIL Label */ 
#line 473
  ch.command = (ngx_uint_t )3;
#line 474
  goto switch_break;
  case_15: /* CIL Label */ 
#line 477
  ch.command = (ngx_uint_t )4;
#line 478
  goto switch_break;
  case_10: /* CIL Label */ 
#line 481
  ch.command = (ngx_uint_t )5;
#line 482
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 485
  ch.command = (ngx_uint_t )0;
  switch_break: /* CIL Label */ ;
  }
#line 490
  ch.fd = -1;
#line 493
  i = (ngx_int_t )0;
  {
#line 493
  while (1) {
    while_continue: /* CIL Label */ ;
#line 493
    if (! (i < ngx_last_process)) {
#line 493
      goto while_break;
    }
#line 505
    if (ngx_processes[i].detached) {
#line 506
      goto __Cont;
    } else
#line 505
    if (ngx_processes[i].pid == -1) {
#line 506
      goto __Cont;
    }
#line 509
    if (ngx_processes[i].just_spawn) {
#line 510
      ngx_processes[i].just_spawn = 0U;
#line 511
      goto __Cont;
    }
#line 514
    if (ngx_processes[i].exiting) {
#line 514
      if (signo == 3) {
#line 517
        goto __Cont;
      }
    }
#line 520
    if (ch.command) {
      {
#line 521
      tmp = ngx_write_channel(ngx_processes[i].channel[0], & ch, sizeof(ngx_channel_t ),
                              cycle->log);
      }
#line 521
      if (tmp == 0L) {
#line 525
        if (signo != 10) {
#line 526
          ngx_processes[i].exiting = 1U;
        }
#line 529
        goto __Cont;
      }
    }
    {
#line 536
    tmp___1 = kill(ngx_processes[i].pid, signo);
    }
#line 536
    if (tmp___1 == -1) {
      {
#line 537
      tmp___0 = __errno_location();
#line 537
      err = *tmp___0;
      }
#line 538
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 538
        ngx_log_error_core((ngx_uint_t )2, cycle->log, err, "kill(%P, %d) failed",
                           ngx_processes[i].pid, signo);
        }
      }
#line 541
      if (err == 3) {
#line 542
        ngx_processes[i].exited = 1U;
#line 543
        ngx_processes[i].exiting = 0U;
#line 544
        ngx_reap = 1;
      }
#line 547
      goto __Cont;
    }
#line 550
    if (signo != 10) {
#line 551
      ngx_processes[i].exiting = 1U;
    }
    __Cont: /* CIL Label */ 
#line 493
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 554
  return;
}
}
#line 557 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static ngx_uint_t ngx_reap_children(ngx_cycle_t *cycle ) 
{ 
  ngx_int_t i ;
  ngx_int_t n ;
  ngx_uint_t live ;
  ngx_channel_t ch ;
  ngx_core_conf_t *ccf ;
  ngx_pid_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 565
  memset((void *)(& ch), 0, sizeof(ngx_channel_t ));
#line 567
  ch.command = (ngx_uint_t )2;
#line 568
  ch.fd = -1;
#line 570
  live = (ngx_uint_t )0;
#line 571
  i = (ngx_int_t )0;
  }
  {
#line 571
  while (1) {
    while_continue: /* CIL Label */ ;
#line 571
    if (! (i < ngx_last_process)) {
#line 571
      goto while_break;
    }
#line 583
    if (ngx_processes[i].pid == -1) {
#line 584
      goto __Cont;
    }
#line 587
    if (ngx_processes[i].exited) {
#line 589
      if (! ngx_processes[i].detached) {
        {
#line 590
        ngx_close_channel(ngx_processes[i].channel, cycle->log);
#line 592
        ngx_processes[i].channel[0] = -1;
#line 593
        ngx_processes[i].channel[1] = -1;
#line 595
        ch.pid = ngx_processes[i].pid;
#line 596
        ch.slot = i;
#line 598
        n = (ngx_int_t )0;
        }
        {
#line 598
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 598
          if (! (n < ngx_last_process)) {
#line 598
            goto while_break___0;
          }
#line 599
          if (ngx_processes[n].exited) {
#line 603
            goto __Cont___0;
          } else
#line 599
          if (ngx_processes[n].pid == -1) {
#line 603
            goto __Cont___0;
          } else
#line 599
          if (ngx_processes[n].channel[0] == -1) {
#line 603
            goto __Cont___0;
          }
          {
#line 612
          ngx_write_channel(ngx_processes[n].channel[0], & ch, sizeof(ngx_channel_t ),
                            cycle->log);
          }
          __Cont___0: /* CIL Label */ 
#line 598
          n ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
#line 617
      if (ngx_processes[i].respawn) {
#line 617
        if (! ngx_processes[i].exiting) {
#line 617
          if (! ngx_terminate) {
#line 617
            if (! ngx_quit) {
              {
#line 622
              tmp = ngx_spawn_process(cycle, ngx_processes[i].proc, ngx_processes[i].data,
                                      ngx_processes[i].name, i);
              }
#line 622
              if (tmp == -1) {
#line 627
                if ((cycle->log)->log_level >= 2UL) {
                  {
#line 627
                  ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "could not respawn %s",
                                     ngx_processes[i].name);
                  }
                }
#line 630
                goto __Cont;
              }
              {
#line 634
              ch.command = (ngx_uint_t )1;
#line 635
              ch.pid = ngx_processes[ngx_process_slot].pid;
#line 636
              ch.slot = ngx_process_slot;
#line 637
              ch.fd = ngx_processes[ngx_process_slot].channel[0];
#line 639
              ngx_pass_open_channel(cycle, & ch);
#line 641
              live = (ngx_uint_t )1;
              }
#line 643
              goto __Cont;
            }
          }
        }
      }
#line 646
      if (ngx_processes[i].pid == ngx_new_binary) {
        {
#line 648
        ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 651
        tmp___1 = rename((char const   *)((char *)ccf->oldpid.data), (char const   *)((char *)ccf->pid.data));
        }
#line 651
        if (tmp___1 == -1) {
#line 655
          if ((cycle->log)->log_level >= 2UL) {
            {
#line 655
            tmp___0 = __errno_location();
#line 655
            ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "rename() %s back to %s failed after the new binary process \"%s\" exited",
                               ccf->oldpid.data, ccf->pid.data, *(ngx_argv + 0));
            }
          }
        }
#line 661
        ngx_new_binary = 0;
#line 662
        if (ngx_noaccepting) {
#line 663
          ngx_restart = (ngx_uint_t )1;
#line 664
          ngx_noaccepting = (ngx_uint_t )0;
        }
      }
#line 668
      if (i == ngx_last_process - 1L) {
#line 669
        ngx_last_process --;
      } else {
#line 672
        ngx_processes[i].pid = -1;
      }
    } else
#line 675
    if (ngx_processes[i].exiting) {
#line 676
      live = (ngx_uint_t )1;
    } else
#line 675
    if (! ngx_processes[i].detached) {
#line 676
      live = (ngx_uint_t )1;
    }
    __Cont: /* CIL Label */ 
#line 571
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  return (live);
}
}
#line 684 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_master_process_exit(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_log_t *tmp ;
  char *__cil_tmp4 ;

  {
  {
#line 689
  ngx_delete_pidfile(cycle);
  }
#line 691
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 691
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "exit");
    }
  }
#line 693
  i = (ngx_uint_t )0;
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
#line 693
    if (! *(cycle->modules + i)) {
#line 693
      goto while_break;
    }
#line 694
    if ((*(cycle->modules + i))->exit_master) {
      {
#line 695
      (*((*(cycle->modules + i))->exit_master))(cycle);
      }
    }
#line 693
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 699
  ngx_close_listening_sockets(cycle);
#line 709
  tmp = ngx_log_get_file_log((ngx_log_t *)ngx_cycle->log);
#line 709
  ngx_exit_log = *tmp;
#line 711
  ngx_exit_log_file.fd = (ngx_exit_log.file)->fd;
#line 712
  ngx_exit_log.file = & ngx_exit_log_file;
#line 713
  ngx_exit_log.next = (ngx_log_t *)((void *)0);
#line 714
  ngx_exit_log.writer = (void (*)(ngx_log_t *log , ngx_uint_t level , u_char *buf ,
                                  size_t len ))((void *)0);
#line 716
  ngx_exit_cycle.log = & ngx_exit_log;
#line 717
  ngx_exit_cycle.files = (ngx_connection_t **)ngx_cycle->files;
#line 718
  ngx_exit_cycle.files_n = (ngx_uint_t )ngx_cycle->files_n;
#line 719
  ngx_cycle = (ngx_cycle_t volatile   *)(& ngx_exit_cycle);
#line 721
  ngx_destroy_pool(cycle->pool);
#line 723
  exit(0);
  }
}
}
#line 727 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_worker_process_cycle(ngx_cycle_t *cycle , void *data ) 
{ 
  ngx_int_t worker ;
  ngx_int_t tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 730
  worker = (intptr_t )data;
#line 732
  ngx_process = (ngx_uint_t )3;
#line 733
  ngx_worker = (ngx_uint_t )worker;
#line 735
  ngx_worker_process_init(cycle, worker);
#line 737
  ngx_setproctitle((char *)"worker process");
  }
  {
#line 739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (ngx_exiting) {
      {
#line 742
      tmp = ngx_event_no_timers_left();
      }
#line 742
      if (tmp == 0L) {
#line 743
        if ((cycle->log)->log_level >= 6UL) {
          {
#line 743
          ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "exiting");
          }
        }
        {
#line 744
        ngx_worker_process_exit(cycle);
        }
      }
    }
    {
#line 750
    ngx_process_events_and_timers(cycle);
    }
#line 752
    if (ngx_terminate) {
#line 753
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 753
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "exiting");
        }
      }
      {
#line 754
      ngx_worker_process_exit(cycle);
      }
    }
#line 757
    if (ngx_quit) {
#line 758
      ngx_quit = 0;
#line 759
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 759
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "gracefully shutting down");
        }
      }
      {
#line 761
      ngx_setproctitle((char *)"worker process is shutting down");
      }
#line 763
      if (! ngx_exiting) {
        {
#line 764
        ngx_exiting = (ngx_uint_t )1;
#line 765
        ngx_set_shutdown_timer(cycle);
#line 766
        ngx_close_listening_sockets(cycle);
#line 767
        ngx_close_idle_connections(cycle);
        }
      }
    }
#line 771
    if (ngx_reopen) {
#line 772
      ngx_reopen = 0;
#line 773
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 773
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reopening logs");
        }
      }
      {
#line 774
      ngx_reopen_files(cycle, (ngx_uid_t )-1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 780 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_worker_process_init(ngx_cycle_t *cycle , ngx_int_t worker ) 
{ 
  sigset_t set ;
  ngx_int_t n ;
  ngx_time_t *tp ;
  ngx_uint_t i ;
  ngx_cpuset_t *cpu_affinity ;
  struct rlimit rlmt___0 ;
  ngx_core_conf_t *ccf ;
  ngx_listening_t *ls ;
  char **tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  struct __user_cap_data_struct data ;
  struct __user_cap_header_struct header___0 ;
  int *tmp___14 ;
  long tmp___15 ;
  __uid_t tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  ngx_int_t tmp___23 ;
  int *tmp___24 ;
  int tmp___25 ;
  int *tmp___26 ;
  int tmp___27 ;
  ngx_int_t tmp___28 ;
  void *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 792
  tmp = ngx_set_environment(cycle, (ngx_uint_t *)((void *)0));
  }
#line 792
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 794
    exit(2);
    }
  }
#line 797
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 799
  if (worker >= 0L) {
#line 799
    if (ccf->priority != 0) {
      {
#line 800
      tmp___1 = setpriority((__priority_which_t )0, (id_t )0, ccf->priority);
      }
#line 800
      if (tmp___1 == -1) {
#line 801
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 801
          tmp___0 = __errno_location();
#line 801
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "setpriority(%d) failed",
                             ccf->priority);
          }
        }
      }
    }
  }
#line 806
  if (ccf->rlimit_nofile != -1L) {
    {
#line 807
    rlmt___0.rlim_cur = (rlim_t )ccf->rlimit_nofile;
#line 808
    rlmt___0.rlim_max = (rlim_t )ccf->rlimit_nofile;
#line 810
    tmp___3 = setrlimit((__rlimit_resource_t )7, (struct rlimit  const  *)(& rlmt___0));
    }
#line 810
    if (tmp___3 == -1) {
#line 811
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 811
        tmp___2 = __errno_location();
#line 811
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___2, "setrlimit(RLIMIT_NOFILE, %i) failed",
                           ccf->rlimit_nofile);
        }
      }
    }
  }
#line 817
  if (ccf->rlimit_core != -1L) {
    {
#line 818
    rlmt___0.rlim_cur = (rlim_t )ccf->rlimit_core;
#line 819
    rlmt___0.rlim_max = (rlim_t )ccf->rlimit_core;
#line 821
    tmp___5 = setrlimit((__rlimit_resource_t )4, (struct rlimit  const  *)(& rlmt___0));
    }
#line 821
    if (tmp___5 == -1) {
#line 822
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 822
        tmp___4 = __errno_location();
#line 822
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___4, "setrlimit(RLIMIT_CORE, %O) failed",
                           ccf->rlimit_core);
        }
      }
    }
  }
  {
#line 828
  tmp___16 = geteuid();
  }
#line 828
  if (tmp___16 == 0U) {
    {
#line 829
    tmp___7 = setgid(ccf->group);
    }
#line 829
    if (tmp___7 == -1) {
#line 830
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 830
        tmp___6 = __errno_location();
#line 830
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___6, "setgid(%d) failed",
                           ccf->group);
        }
      }
      {
#line 833
      exit(2);
      }
    }
    {
#line 836
    tmp___9 = initgroups((char const   *)ccf->username, ccf->group);
    }
#line 836
    if (tmp___9 == -1) {
#line 837
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 837
        tmp___8 = __errno_location();
#line 837
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___8, "initgroups(%s, %d) failed",
                           ccf->username, ccf->group);
        }
      }
    }
#line 843
    if (ccf->transparent) {
#line 843
      if (ccf->user) {
        {
#line 844
        tmp___11 = prctl(8, 1, 0, 0, 0);
        }
#line 844
        if (tmp___11 == -1) {
#line 845
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 845
            tmp___10 = __errno_location();
#line 845
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___10, "prctl(PR_SET_KEEPCAPS, 1) failed");
            }
          }
          {
#line 848
          exit(2);
          }
        }
      }
    }
    {
#line 853
    tmp___13 = setuid(ccf->user);
    }
#line 853
    if (tmp___13 == -1) {
#line 854
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 854
        tmp___12 = __errno_location();
#line 854
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___12, "setuid(%d) failed",
                           ccf->user);
        }
      }
      {
#line 857
      exit(2);
      }
    }
#line 861
    if (ccf->transparent) {
#line 861
      if (ccf->user) {
        {
#line 865
        memset((void *)(& header___0), 0, sizeof(struct __user_cap_header_struct ));
#line 866
        memset((void *)(& data), 0, sizeof(struct __user_cap_data_struct ));
#line 868
        header___0.version = (__u32 )429392688;
#line 869
        data.effective = (__u32 )(1 << 13);
#line 870
        data.permitted = data.effective;
#line 872
        tmp___15 = syscall(126L, & header___0, & data);
        }
#line 872
        if (tmp___15 == -1L) {
#line 873
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 873
            tmp___14 = __errno_location();
#line 873
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___14, "capset() failed");
            }
          }
          {
#line 876
          exit(2);
          }
        }
      }
    }
  }
#line 882
  if (worker >= 0L) {
    {
#line 883
    cpu_affinity = ngx_get_cpu_affinity((ngx_uint_t )worker);
    }
#line 885
    if (cpu_affinity) {
      {
#line 886
      ngx_setaffinity(cpu_affinity, cycle->log);
      }
    }
  }
  {
#line 894
  tmp___18 = prctl(4, 1, 0, 0, 0);
  }
#line 894
  if (tmp___18 == -1) {
#line 895
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 895
      tmp___17 = __errno_location();
#line 895
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___17, "prctl(PR_SET_DUMPABLE) failed");
      }
    }
  }
#line 901
  if (ccf->working_directory.len) {
    {
#line 902
    tmp___20 = chdir((char const   *)((char *)ccf->working_directory.data));
    }
#line 902
    if (tmp___20 == -1) {
#line 903
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 903
        tmp___19 = __errno_location();
#line 903
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___19, "chdir(\"%s\") failed",
                           ccf->working_directory.data);
        }
      }
      {
#line 906
      exit(2);
      }
    }
  }
  {
#line 910
  sigemptyset(& set);
#line 912
  tmp___22 = sigprocmask(2, (sigset_t const   */* __restrict  */)(& set), (sigset_t */* __restrict  */)((void *)0));
  }
#line 912
  if (tmp___22 == -1) {
#line 913
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 913
      tmp___21 = __errno_location();
#line 913
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___21, "sigprocmask() failed");
      }
    }
  }
  {
#line 917
  tp = (ngx_time_t *)ngx_cached_time;
#line 918
  srandom((unsigned int )((unsigned long )((long )((unsigned int )ngx_pid << 16) ^ tp->sec) ^ tp->msec));
#line 924
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 925
  i = (ngx_uint_t )0;
  }
  {
#line 925
  while (1) {
    while_continue: /* CIL Label */ ;
#line 925
    if (! (i < cycle->listening.nelts)) {
#line 925
      goto while_break;
    }
#line 926
    (ls + i)->previous = (ngx_listening_t *)((void *)0);
#line 925
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 929
  i = (ngx_uint_t )0;
  {
#line 929
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 929
    if (! *(cycle->modules + i)) {
#line 929
      goto while_break___0;
    }
#line 930
    if ((*(cycle->modules + i))->init_process) {
      {
#line 931
      tmp___23 = (*((*(cycle->modules + i))->init_process))(cycle);
      }
#line 931
      if (tmp___23 == -1L) {
        {
#line 933
        exit(2);
        }
      }
    }
#line 929
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 938
  n = (ngx_int_t )0;
  {
#line 938
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 938
    if (! (n < ngx_last_process)) {
#line 938
      goto while_break___1;
    }
#line 940
    if (ngx_processes[n].pid == -1) {
#line 941
      goto __Cont;
    }
#line 944
    if (n == ngx_process_slot) {
#line 945
      goto __Cont;
    }
#line 948
    if (ngx_processes[n].channel[1] == -1) {
#line 949
      goto __Cont;
    }
    {
#line 952
    tmp___25 = close(ngx_processes[n].channel[1]);
    }
#line 952
    if (tmp___25 == -1) {
#line 953
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 953
        tmp___24 = __errno_location();
#line 953
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___24, "close() channel failed");
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 938
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 958
  tmp___27 = close(ngx_processes[ngx_process_slot].channel[0]);
  }
#line 958
  if (tmp___27 == -1) {
#line 959
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 959
      tmp___26 = __errno_location();
#line 959
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___26, "close() channel failed");
      }
    }
  }
  {
#line 967
  tmp___28 = ngx_add_channel_event(cycle, ngx_channel, (ngx_int_t )8193, & ngx_channel_handler);
  }
#line 967
  if (tmp___28 == -1L) {
    {
#line 972
    exit(2);
    }
  }
#line 974
  return;
}
}
#line 977 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_worker_process_exit(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_connection_t *c ;
  ngx_log_t *tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 983
  i = (ngx_uint_t )0;
  {
#line 983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 983
    if (! *(cycle->modules + i)) {
#line 983
      goto while_break;
    }
#line 984
    if ((*(cycle->modules + i))->exit_process) {
      {
#line 985
      (*((*(cycle->modules + i))->exit_process))(cycle);
      }
    }
#line 983
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 989
  if (ngx_exiting) {
#line 990
    c = cycle->connections;
#line 991
    i = (ngx_uint_t )0;
    {
#line 991
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 991
      if (! (i < cycle->connection_n)) {
#line 991
        goto while_break___0;
      }
#line 992
      if ((c + i)->fd != -1) {
#line 992
        if ((c + i)->read) {
#line 992
          if (! ((c + i)->read)->accept) {
#line 992
            if (! ((c + i)->read)->channel) {
#line 992
              if (! ((c + i)->read)->resolver) {
#line 998
                if ((cycle->log)->log_level >= 2UL) {
                  {
#line 998
                  ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "*%uA open socket #%d left in connection %ui",
                                     (c + i)->number, (c + i)->fd, i);
                  }
                }
#line 1001
                ngx_debug_quit = 1;
              }
            }
          }
        }
      }
#line 991
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1005
    if (ngx_debug_quit) {
#line 1006
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 1006
        ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "aborting");
        }
      }
      {
#line 1007
      ngx_debug_point();
      }
    }
  }
  {
#line 1018
  tmp = ngx_log_get_file_log((ngx_log_t *)ngx_cycle->log);
#line 1018
  ngx_exit_log = *tmp;
#line 1020
  ngx_exit_log_file.fd = (ngx_exit_log.file)->fd;
#line 1021
  ngx_exit_log.file = & ngx_exit_log_file;
#line 1022
  ngx_exit_log.next = (ngx_log_t *)((void *)0);
#line 1023
  ngx_exit_log.writer = (void (*)(ngx_log_t *log , ngx_uint_t level , u_char *buf ,
                                  size_t len ))((void *)0);
#line 1025
  ngx_exit_cycle.log = & ngx_exit_log;
#line 1026
  ngx_exit_cycle.files = (ngx_connection_t **)ngx_cycle->files;
#line 1027
  ngx_exit_cycle.files_n = (ngx_uint_t )ngx_cycle->files_n;
#line 1028
  ngx_cycle = (ngx_cycle_t volatile   *)(& ngx_exit_cycle);
#line 1030
  ngx_destroy_pool(cycle->pool);
  }
#line 1032
  if ((ngx_cycle->log)->log_level >= 6UL) {
    {
#line 1032
    ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "exit");
    }
  }
  {
#line 1034
  exit(0);
  }
}
}
#line 1038 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_channel_handler(ngx_event_t *ev ) 
{ 
  ngx_int_t n ;
  ngx_channel_t ch ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 1045
  if (ev->timedout) {
#line 1046
    ev->timedout = 0U;
#line 1047
    return;
  }
#line 1050
  c = (ngx_connection_t *)ev->data;
  {
#line 1054
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1056
    n = ngx_read_channel(c->fd, & ch, sizeof(ngx_channel_t ), ev->log);
    }
#line 1060
    if (n == -1L) {
#line 1062
      if (ngx_event_flags & 64UL) {
        {
#line 1063
        (*(ngx_event_actions.del_conn))(c, (ngx_uint_t )0);
        }
      }
      {
#line 1066
      ngx_close_connection(c);
      }
#line 1067
      return;
    }
#line 1070
    if (ngx_event_flags & 4096UL) {
      {
#line 1071
      tmp = (*(ngx_event_actions.add))(ev, (ngx_int_t )8193, (ngx_uint_t )0);
      }
#line 1071
      if (tmp == -1L) {
#line 1072
        return;
      }
    }
#line 1076
    if (n == -2L) {
#line 1077
      return;
    }
    {
#line 1085
    if (ch.command == 3UL) {
#line 1085
      goto case_3;
    }
#line 1089
    if (ch.command == 4UL) {
#line 1089
      goto case_4;
    }
#line 1093
    if (ch.command == 5UL) {
#line 1093
      goto case_5;
    }
#line 1097
    if (ch.command == 1UL) {
#line 1097
      goto case_1;
    }
#line 1107
    if (ch.command == 2UL) {
#line 1107
      goto case_2;
    }
#line 1083
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1086
    ngx_quit = 1;
#line 1087
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1090
    ngx_terminate = 1;
#line 1091
    goto switch_break;
    case_5: /* CIL Label */ 
#line 1094
    ngx_reopen = 1;
#line 1095
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1103
    ngx_processes[ch.slot].pid = ch.pid;
#line 1104
    ngx_processes[ch.slot].channel[0] = ch.fd;
#line 1105
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 1114
    tmp___1 = close(ngx_processes[ch.slot].channel[0]);
    }
#line 1114
    if (tmp___1 == -1) {
#line 1115
      if ((ev->log)->log_level >= 2UL) {
        {
#line 1115
        tmp___0 = __errno_location();
#line 1115
        ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp___0, "close() channel failed");
        }
      }
    }
#line 1119
    ngx_processes[ch.slot].channel[0] = -1;
#line 1120
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1126 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_cache_manager_process_cycle(ngx_cycle_t *cycle , void *data ) 
{ 
  ngx_cache_manager_ctx_t *ctx ;
  void *ident[4] ;
  ngx_event_t ev ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 1129
  ctx = (ngx_cache_manager_ctx_t *)data;
#line 1138
  ngx_process = (ngx_uint_t )4;
#line 1140
  ngx_close_listening_sockets(cycle);
#line 1143
  cycle->connection_n = (ngx_uint_t )512;
#line 1145
  ngx_worker_process_init(cycle, (ngx_int_t )-1);
#line 1147
  memset((void *)(& ev), 0, sizeof(ngx_event_t ));
#line 1148
  ev.handler = ctx->handler;
#line 1149
  ev.data = (void *)(ident);
#line 1150
  ev.log = cycle->log;
#line 1151
  ident[3] = (void *)-1;
#line 1153
  ngx_use_accept_mutex = (ngx_uint_t )0;
#line 1155
  ngx_setproctitle(ctx->name);
#line 1157
  ngx_event_add_timer(& ev, ctx->delay);
  }
  {
#line 1159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1161
    if (ngx_terminate) {
#line 1161
      goto _L;
    } else
#line 1161
    if (ngx_quit) {
      _L: /* CIL Label */ 
#line 1162
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 1162
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "exiting");
        }
      }
      {
#line 1163
      exit(0);
      }
    }
#line 1166
    if (ngx_reopen) {
#line 1167
      ngx_reopen = 0;
#line 1168
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 1168
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "reopening logs");
        }
      }
      {
#line 1169
      ngx_reopen_files(cycle, (ngx_uid_t )-1);
      }
    }
    {
#line 1172
    ngx_process_events_and_timers(cycle);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1177 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_cache_manager_process_handler(ngx_event_t *ev ) 
{ 
  ngx_uint_t i ;
  ngx_msec_t next ;
  ngx_msec_t n ;
  ngx_path_t **path ;

  {
#line 1184
  next = (ngx_msec_t )3600000;
#line 1186
  path = (ngx_path_t **)ngx_cycle->paths.elts;
#line 1187
  i = (ngx_uint_t )0;
  {
#line 1187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1187
    if (! (i < (ngx_uint_t )ngx_cycle->paths.nelts)) {
#line 1187
      goto while_break;
    }
#line 1189
    if ((*(path + i))->manager) {
      {
#line 1190
      n = (*((*(path + i))->manager))((*(path + i))->data);
      }
#line 1192
      if (n <= next) {
#line 1192
        next = n;
      } else {
#line 1192
        next = next;
      }
      {
#line 1194
      ngx_time_update();
      }
    }
#line 1187
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1198
  if (next == 0UL) {
#line 1199
    next = (ngx_msec_t )1;
  }
  {
#line 1202
  ngx_event_add_timer(ev, next);
  }
#line 1203
  return;
}
}
#line 1206 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process_cycle.c"
static void ngx_cache_loader_process_handler(ngx_event_t *ev ) 
{ 
  ngx_uint_t i ;
  ngx_path_t **path ;
  ngx_cycle_t *cycle ;

  {
#line 1213
  cycle = (ngx_cycle_t *)ngx_cycle;
#line 1215
  path = (ngx_path_t **)cycle->paths.elts;
#line 1216
  i = (ngx_uint_t )0;
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    if (! (i < cycle->paths.nelts)) {
#line 1216
      goto while_break;
    }
#line 1218
    if (ngx_terminate) {
#line 1219
      goto while_break;
    } else
#line 1218
    if (ngx_quit) {
#line 1219
      goto while_break;
    }
#line 1222
    if ((*(path + i))->loader) {
      {
#line 1223
      (*((*(path + i))->loader))((*(path + i))->data);
#line 1224
      ngx_time_update();
      }
    }
#line 1216
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1228
  exit(0);
  }
}
}
#line 82 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 27 "src/os/unix/ngx_dlopen.h"
char *ngx_dlerror(void) ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_dlopen.c"
char *ngx_dlerror(void) 
{ 
  char *err ;
  char *tmp ;
  char *__cil_tmp3 ;

  {
  {
#line 19
  tmp = dlerror();
#line 19
  err = tmp;
  }
#line 21
  if ((unsigned long )err == (unsigned long )((void *)0)) {
#line 22
    return ((char *)"");
  }
#line 25
  return (err);
}
}
#line 60 "/usr/include/crypt.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2,3), __leaf__)) crypt_r)(char const   *__key ,
                                                                                                    char const   *__salt ,
                                                                                                    struct crypt_data * __restrict  __data ) ;
#line 20 "src/os/unix/ngx_user.h"
ngx_int_t ngx_libc_crypt(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_user.c"
ngx_int_t ngx_libc_crypt(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  char *value ;
  size_t len ;
  struct crypt_data cd ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp11 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 23
  cd.initialized = 0;
#line 26
  cd.current_salt[0] = (char )(~ ((int )*(salt + 0)));
#line 29
  value = crypt_r((char const   *)((char *)key), (char const   *)((char *)salt), (struct crypt_data */* __restrict  */)(& cd));
  }
#line 31
  if (value) {
    {
#line 32
    tmp = strlen((char const   *)value);
#line 32
    len = tmp + 1UL;
#line 34
    tmp___0 = ngx_pnalloc(pool, len);
#line 34
    *encrypted = (u_char *)tmp___0;
    }
#line 35
    if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 36
      return ((ngx_int_t )-1);
    }
    {
#line 39
    memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)value,
           len);
    }
#line 40
    return ((ngx_int_t )0);
  }
#line 43
  if ((pool->log)->log_level >= 3UL) {
    {
#line 43
    tmp___1 = __errno_location();
#line 43
    ngx_log_error_core((ngx_uint_t )3, pool->log, *tmp___1, "crypt_r() failed");
    }
  }
#line 45
  return ((ngx_int_t )-1);
}
}
#line 619 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 978
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getpagesize)(void)  __attribute__((__const__)) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits )  __asm__("getrlimit64")  ;
#line 37 "src/os/unix/ngx_setproctitle.h"
ngx_int_t ngx_init_setproctitle(ngx_log_t *log ) ;
#line 41 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_pagesize_shift ;
#line 38 "src/os/unix/ngx_os.h"
ngx_int_t ngx_os_init(ngx_log_t *log ) ;
#line 39
void ngx_os_status(ngx_log_t *log ) ;
#line 50
ngx_chain_t *ngx_writev_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) ;
#line 79 "src/os/unix/ngx_os.h"
ngx_int_t ngx_ncpu  ;
#line 80 "src/os/unix/ngx_os.h"
ngx_int_t ngx_max_sockets  ;
#line 81 "src/os/unix/ngx_os.h"
ngx_uint_t ngx_inherited_nonblocking  ;
#line 82 "src/os/unix/ngx_os.h"
ngx_uint_t ngx_tcp_nodelay_and_tcp_nopush  ;
#line 103 "src/core/ngx_core.h"
void ngx_cpuinfo(void) ;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_posix_init.c"
struct rlimit rlmt  ;
#line 22 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_posix_init.c"
ngx_os_io_t ngx_os_io  = 
#line 22
     {& ngx_unix_recv, & ngx_readv_chain, & ngx_udp_unix_recv, & ngx_unix_send, & ngx_udp_unix_send,
    & ngx_udp_unix_sendmsg_chain, & ngx_writev_chain, (ngx_uint_t )0};
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_posix_init.c"
ngx_int_t ngx_os_init(ngx_log_t *log ) 
{ 
  ngx_time_t *tp ;
  ngx_uint_t n ;
  long size ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;

  {
  {
#line 44
  tmp = ngx_os_specific_init(log);
  }
#line 44
  if (tmp != 0L) {
#line 45
    return ((ngx_int_t )-1);
  }
  {
#line 49
  tmp___0 = ngx_init_setproctitle(log);
  }
#line 49
  if (tmp___0 != 0L) {
#line 50
    return ((ngx_int_t )-1);
  }
  {
#line 53
  tmp___1 = getpagesize();
#line 53
  ngx_pagesize = (ngx_uint_t )tmp___1;
#line 54
  ngx_cacheline_size = (ngx_uint_t )64;
#line 56
  n = ngx_pagesize;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    n >>= 1;
#line 56
    if (! n) {
#line 56
      goto while_break;
    }
#line 56
    ngx_pagesize_shift ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  if (ngx_ncpu == 0L) {
    {
#line 60
    ngx_ncpu = sysconf(84);
    }
  }
#line 64
  if (ngx_ncpu < 1L) {
#line 65
    ngx_ncpu = (ngx_int_t )1;
  }
  {
#line 69
  size = sysconf(190);
  }
#line 70
  if (size > 0L) {
#line 71
    ngx_cacheline_size = (ngx_uint_t )size;
  }
  {
#line 75
  ngx_cpuinfo();
#line 77
  tmp___3 = getrlimit((__rlimit_resource_t )7, & rlmt);
  }
#line 77
  if (tmp___3 == -1) {
#line 78
    if (log->log_level >= 2UL) {
      {
#line 78
      tmp___2 = __errno_location();
#line 78
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___2, "getrlimit(RLIMIT_NOFILE) failed");
      }
    }
#line 80
    return ((ngx_int_t )-1);
  }
  {
#line 83
  ngx_max_sockets = (ngx_int_t )rlmt.rlim_cur;
#line 86
  ngx_inherited_nonblocking = (ngx_uint_t )1;
#line 91
  tp = (ngx_time_t *)ngx_cached_time;
#line 92
  srandom((unsigned int )((unsigned long )((long )((unsigned int )ngx_pid << 16) ^ tp->sec) ^ tp->msec));
  }
#line 94
  return ((ngx_int_t )0);
}
}
#line 98 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_posix_init.c"
void ngx_os_status(ngx_log_t *log ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 101
  if (log->log_level >= 6UL) {
    {
#line 101
    ngx_log_error_core((ngx_uint_t )6, log, 0, "nginx/1.13.8");
    }
  }
#line 104
  if (log->log_level >= 6UL) {
    {
#line 104
    ngx_log_error_core((ngx_uint_t )6, log, 0, "built by gcc 5.3.0 (Homebrew gcc 5.3.0) ");
    }
  }
  {
#line 108
  ngx_os_specific_status(log);
  }
#line 111
  if (log->log_level >= 6UL) {
    {
#line 111
    ngx_log_error_core((ngx_uint_t )6, log, 0, "getrlimit(RLIMIT_NOFILE): %r:%r",
                       rlmt.rlim_cur, rlmt.rlim_max);
    }
  }
#line 114
  return;
}
}
#line 545 "/usr/include/unistd.h"
extern char **environ ;
#line 80 "src/os/unix/ngx_process.h"
char **ngx_os_argv ;
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_setproctitle.c"
static char *ngx_os_argv_last  ;
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_setproctitle.c"
ngx_int_t ngx_init_setproctitle(ngx_log_t *log ) 
{ 
  u_char *p ;
  size_t size ;
  ngx_uint_t i ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 41
  size = (size_t )0;
#line 43
  i = (ngx_uint_t )0;
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
#line 43
    if (! *(environ + i)) {
#line 43
      goto while_break;
    }
    {
#line 44
    tmp = strlen((char const   *)*(environ + i));
#line 44
    size += tmp + 1UL;
#line 43
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tmp___0 = ngx_alloc(size, log);
#line 47
  p = (u_char *)tmp___0;
  }
#line 48
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 49
    return ((ngx_int_t )-1);
  }
#line 52
  ngx_os_argv_last = *(ngx_os_argv + 0);
#line 54
  i = (ngx_uint_t )0;
  {
#line 54
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! *(ngx_os_argv + i)) {
#line 54
      goto while_break___0;
    }
#line 55
    if ((unsigned long )ngx_os_argv_last == (unsigned long )*(ngx_os_argv + i)) {
      {
#line 56
      tmp___1 = strlen((char const   *)*(ngx_os_argv + i));
#line 56
      ngx_os_argv_last = (*(ngx_os_argv + i) + tmp___1) + 1;
      }
    }
#line 54
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 60
  i = (ngx_uint_t )0;
  {
#line 60
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 60
    if (! *(environ + i)) {
#line 60
      goto while_break___1;
    }
#line 61
    if ((unsigned long )ngx_os_argv_last == (unsigned long )*(environ + i)) {
      {
#line 63
      tmp___2 = strlen((char const   *)*(environ + i));
#line 63
      size = tmp___2 + 1UL;
#line 64
      ngx_os_argv_last = *(environ + i) + size;
#line 66
      ngx_cpystrn(p, (u_char *)*(environ + i), size);
#line 67
      *(environ + i) = (char *)p;
#line 68
      p += size;
      }
    }
#line 60
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 72
  ngx_os_argv_last --;
#line 74
  return ((ngx_int_t )0);
}
}
#line 78 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_setproctitle.c"
void ngx_setproctitle(char *title___0 ) 
{ 
  u_char *p ;
  char *__cil_tmp3 ;

  {
  {
#line 90
  *(ngx_os_argv + 1) = (char *)((void *)0);
#line 92
  p = ngx_cpystrn((u_char *)*(ngx_os_argv + 0), (u_char *)"nginx: ", (size_t )(ngx_os_argv_last - *(ngx_os_argv + 0)));
#line 95
  p = ngx_cpystrn(p, (u_char *)title___0, (size_t )(ngx_os_argv_last - (char *)p));
  }
#line 127
  if (ngx_os_argv_last - (char *)p) {
    {
#line 128
    memset((void *)p, '\000', (size_t )(ngx_os_argv_last - (char *)p));
    }
  }
#line 133
  return;
}
}
#line 116 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_setaffinity)(__pid_t __pid ,
                                                                                        size_t __cpusetsize ,
                                                                                        cpu_set_t const   *__cpuset ) ;
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_setaffinity.c"
void ngx_setaffinity(ngx_cpuset_t *cpu_affinity , ngx_log_t *log ) 
{ 
  ngx_uint_t i ;
  size_t __cpu ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 40
  i = (ngx_uint_t )0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < 1024UL)) {
#line 40
      goto while_break;
    }
#line 41
    __cpu = i;
#line 41
    if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 41
      tmp = (*((__cpu_mask const   *)(cpu_affinity->__bits) + __cpu / (8UL * sizeof(__cpu_mask ))) & (unsigned long const   )(1UL << __cpu % (8UL * sizeof(__cpu_mask )))) != 0UL;
    } else {
#line 41
      tmp = 0;
    }
#line 41
    if (tmp) {
#line 42
      if (log->log_level >= 6UL) {
        {
#line 42
        ngx_log_error_core((ngx_uint_t )6, log, 0, "sched_setaffinity(): using cpu #%ui",
                           i);
        }
      }
    }
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 47
  tmp___1 = sched_setaffinity(0, sizeof(cpu_set_t ), (cpu_set_t const   *)cpu_affinity);
  }
#line 47
  if (tmp___1 == -1) {
#line 48
    if (log->log_level >= 2UL) {
      {
#line 48
      tmp___0 = __errno_location();
#line 48
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___0, "sched_setaffinity() failed");
      }
    }
  }
#line 51
  return;
}
}
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 42 "src/os/unix/ngx_os.h"
ngx_int_t ngx_daemon(ngx_log_t *log ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_daemon.c"
ngx_int_t ngx_daemon(ngx_log_t *log ) 
{ 
  int fd ;
  __pid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  __pid_t tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 17
  tmp = fork();
  }
  {
#line 18
  if (tmp == -1) {
#line 18
    goto case_neg_1;
  }
#line 22
  if (tmp == 0) {
#line 22
    goto case_0;
  }
#line 25
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 19
  if (log->log_level >= 1UL) {
    {
#line 19
    tmp___0 = __errno_location();
#line 19
    ngx_log_error_core((ngx_uint_t )1, log, *tmp___0, "fork() failed");
    }
  }
#line 20
  return ((ngx_int_t )-1);
  case_0: /* CIL Label */ 
#line 23
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 26
  exit(0);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 29
  ngx_parent = ngx_pid;
#line 30
  ngx_pid = getpid();
#line 32
  tmp___2 = setsid();
  }
#line 32
  if (tmp___2 == -1) {
#line 33
    if (log->log_level >= 1UL) {
      {
#line 33
      tmp___1 = __errno_location();
#line 33
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___1, "setsid() failed");
      }
    }
#line 34
    return ((ngx_int_t )-1);
  }
  {
#line 37
  umask((__mode_t )0);
#line 39
  fd = open("/dev/null", 2);
  }
#line 40
  if (fd == -1) {
#line 41
    if (log->log_level >= 1UL) {
      {
#line 41
      tmp___3 = __errno_location();
#line 41
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___3, "open(\"/dev/null\") failed");
      }
    }
#line 43
    return ((ngx_int_t )-1);
  }
  {
#line 46
  tmp___5 = dup2(fd, 0);
  }
#line 46
  if (tmp___5 == -1) {
#line 47
    if (log->log_level >= 1UL) {
      {
#line 47
      tmp___4 = __errno_location();
#line 47
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___4, "dup2(STDIN) failed");
      }
    }
#line 48
    return ((ngx_int_t )-1);
  }
  {
#line 51
  tmp___7 = dup2(fd, 1);
  }
#line 51
  if (tmp___7 == -1) {
#line 52
    if (log->log_level >= 1UL) {
      {
#line 52
      tmp___6 = __errno_location();
#line 52
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___6, "dup2(STDOUT) failed");
      }
    }
#line 53
    return ((ngx_int_t )-1);
  }
#line 63
  if (fd > 2) {
    {
#line 64
    tmp___9 = close(fd);
    }
#line 64
    if (tmp___9 == -1) {
#line 65
      if (log->log_level >= 1UL) {
        {
#line 65
        tmp___8 = __errno_location();
#line 65
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___8, "close() failed");
        }
      }
#line 66
      return ((ngx_int_t )-1);
    }
  }
#line 70
  return ((ngx_int_t )0);
}
}
#line 551 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 139 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) raise)(int __sig ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 25 "src/os/unix/ngx_socket.h"
int ngx_nonblocking(ngx_socket_t s ) ;
#line 66 "src/os/unix/ngx_process.h"
ngx_pid_t ngx_execute(ngx_cycle_t *cycle , ngx_exec_ctx_t *ctx ) ;
#line 67
ngx_int_t ngx_init_signals(ngx_log_t *log ) ;
#line 78 "src/os/unix/ngx_process.h"
int ngx_argc  ;
#line 79 "src/os/unix/ngx_process.h"
char **ngx_argv  ;
#line 80 "src/os/unix/ngx_process.h"
char **ngx_os_argv  ;
#line 84 "src/os/unix/ngx_process.h"
ngx_socket_t ngx_channel  ;
#line 85 "src/os/unix/ngx_process.h"
ngx_int_t ngx_process_slot  ;
#line 86 "src/os/unix/ngx_process.h"
ngx_int_t ngx_last_process  ;
#line 87 "src/os/unix/ngx_process.h"
ngx_process_t ngx_processes[1024]  ;
#line 25 "src/core/ngx_times.h"
void ngx_time_sigsafe_update(void) ;
#line 46 "src/core/ngx_shmtx.h"
ngx_uint_t ngx_shmtx_force_unlock(ngx_shmtx_t *mtx , ngx_pid_t pid ) ;
#line 43 "src/os/unix/ngx_os.h"
ngx_int_t ngx_os_signal_process(ngx_cycle_t *cycle , char *name , ngx_pid_t pid ) ;
#line 469 "src/event/ngx_event.h"
ngx_atomic_t *ngx_accept_mutex_ptr ;
#line 470
ngx_shmtx_t ngx_accept_mutex ;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
static void ngx_execute_proc(ngx_cycle_t *cycle , void *data ) ;
#line 24
static void ngx_signal_handler(int signo , siginfo_t *siginfo , void *ucontext ) ;
#line 25
static void ngx_process_get_status(void) ;
#line 26
static void ngx_unlock_mutexes(ngx_pid_t pid ) ;
#line 39 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
ngx_signal_t signals[13]  = 
#line 39
  {      {1, (char *)"SIGHUP", (char *)"reload", & ngx_signal_handler}, 
        {10, (char *)"SIGUSR1", (char *)"reopen", & ngx_signal_handler}, 
        {28, (char *)"SIGWINCH", (char *)"", & ngx_signal_handler}, 
        {15, (char *)"SIGTERM", (char *)"stop", & ngx_signal_handler}, 
        {3, (char *)"SIGQUIT", (char *)"quit", & ngx_signal_handler}, 
        {12, (char *)"SIGUSR2", (char *)"", & ngx_signal_handler}, 
        {14, (char *)"SIGALRM", (char *)"", & ngx_signal_handler}, 
        {2, (char *)"SIGINT", (char *)"", & ngx_signal_handler}, 
        {29, (char *)"SIGIO", (char *)"", & ngx_signal_handler}, 
        {17, (char *)"SIGCHLD", (char *)"", & ngx_signal_handler}, 
        {31, (char *)"SIGSYS, SIG_IGN", (char *)"", (void (*)(int signo , siginfo_t *siginfo ,
                                                           void *ucontext ))((void *)0)}, 
        {13,
      (char *)"SIGPIPE, SIG_IGN", (char *)"", (void (*)(int signo , siginfo_t *siginfo ,
                                                        void *ucontext ))((void *)0)}, 
        {0,
      (char *)((void *)0), (char *)"", (void (*)(int signo , siginfo_t *siginfo ,
                                                 void *ucontext ))((void *)0)}};
#line 86 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
ngx_pid_t ngx_spawn_process(ngx_cycle_t *cycle , void (*proc)(ngx_cycle_t *cycle ,
                                                              void *data ) , void *data ,
                            char *name , ngx_int_t respawn ) 
{ 
  u_long on ;
  ngx_pid_t pid ;
  ngx_int_t s ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
#line 94
  if (respawn >= 0L) {
#line 95
    s = respawn;
  } else {
#line 98
    s = (ngx_int_t )0;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! (s < ngx_last_process)) {
#line 98
        goto while_break;
      }
#line 99
      if (ngx_processes[s].pid == -1) {
#line 100
        goto while_break;
      }
#line 98
      s ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 104
    if (s == 1024L) {
#line 105
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 105
        ngx_log_error_core((ngx_uint_t )2, cycle->log, 0, "no more than %d processes can be spawned",
                           1024);
        }
      }
#line 108
      return (-1);
    }
  }
#line 113
  if (respawn != -5L) {
    {
#line 117
    tmp___0 = socketpair(1, 1, 0, (int *)(ngx_processes[s].channel));
    }
#line 117
    if (tmp___0 == -1) {
#line 119
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 119
        tmp = __errno_location();
#line 119
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "socketpair() failed while spawning \"%s\"",
                           name);
        }
      }
#line 121
      return (-1);
    }
    {
#line 129
    tmp___2 = ngx_nonblocking(ngx_processes[s].channel[0]);
    }
#line 129
    if (tmp___2 == -1) {
#line 130
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 130
        tmp___1 = __errno_location();
#line 130
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "ioctl(FIONBIO) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 133
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 134
      return (-1);
    }
    {
#line 137
    tmp___4 = ngx_nonblocking(ngx_processes[s].channel[1]);
    }
#line 137
    if (tmp___4 == -1) {
#line 138
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 138
        tmp___3 = __errno_location();
#line 138
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "ioctl(FIONBIO) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 141
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 142
      return (-1);
    }
    {
#line 145
    on = (u_long )1;
#line 146
    tmp___6 = ioctl(ngx_processes[s].channel[0], 21586UL, & on);
    }
#line 146
    if (tmp___6 == -1) {
#line 147
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 147
        tmp___5 = __errno_location();
#line 147
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "ioctl(FIOASYNC) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 149
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 150
      return (-1);
    }
    {
#line 153
    tmp___8 = fcntl(ngx_processes[s].channel[0], 8, ngx_pid);
    }
#line 153
    if (tmp___8 == -1) {
#line 154
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 154
        tmp___7 = __errno_location();
#line 154
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___7, "fcntl(F_SETOWN) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 156
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 157
      return (-1);
    }
    {
#line 160
    tmp___10 = fcntl(ngx_processes[s].channel[0], 2, 1);
    }
#line 160
    if (tmp___10 == -1) {
#line 161
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 161
        tmp___9 = __errno_location();
#line 161
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___9, "fcntl(FD_CLOEXEC) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 164
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 165
      return (-1);
    }
    {
#line 168
    tmp___12 = fcntl(ngx_processes[s].channel[1], 2, 1);
    }
#line 168
    if (tmp___12 == -1) {
#line 169
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 169
        tmp___11 = __errno_location();
#line 169
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___11, "fcntl(FD_CLOEXEC) failed while spawning \"%s\"",
                           name);
        }
      }
      {
#line 172
      ngx_close_channel(ngx_processes[s].channel, cycle->log);
      }
#line 173
      return (-1);
    }
#line 176
    ngx_channel = ngx_processes[s].channel[1];
  } else {
#line 179
    ngx_processes[s].channel[0] = -1;
#line 180
    ngx_processes[s].channel[1] = -1;
  }
  {
#line 183
  ngx_process_slot = s;
#line 186
  pid = fork();
  }
  {
#line 190
  if (pid == -1) {
#line 190
    goto case_neg_1;
  }
#line 196
  if (pid == 0) {
#line 196
    goto case_0;
  }
#line 202
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 191
  if ((cycle->log)->log_level >= 2UL) {
    {
#line 191
    tmp___13 = __errno_location();
#line 191
    ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___13, "fork() failed while spawning \"%s\"",
                       name);
    }
  }
  {
#line 193
  ngx_close_channel(ngx_processes[s].channel, cycle->log);
  }
#line 194
  return (-1);
  case_0: /* CIL Label */ 
  {
#line 197
  ngx_parent = ngx_pid;
#line 198
  ngx_pid = getpid();
#line 199
  (*proc)(cycle, data);
  }
#line 200
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 203
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 206
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 206
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "start %s %P", name, pid);
    }
  }
#line 208
  ngx_processes[s].pid = pid;
#line 209
  ngx_processes[s].exited = 0U;
#line 211
  if (respawn >= 0L) {
#line 212
    return (pid);
  }
#line 215
  ngx_processes[s].proc = proc;
#line 216
  ngx_processes[s].data = data;
#line 217
  ngx_processes[s].name = name;
#line 218
  ngx_processes[s].exiting = 0U;
  {
#line 222
  if (respawn == -1L) {
#line 222
    goto case_neg_1___0;
  }
#line 228
  if (respawn == -2L) {
#line 228
    goto case_neg_2;
  }
#line 234
  if (respawn == -3L) {
#line 234
    goto case_neg_3;
  }
#line 240
  if (respawn == -4L) {
#line 240
    goto case_neg_4;
  }
#line 246
  if (respawn == -5L) {
#line 246
    goto case_neg_5;
  }
#line 220
  goto switch_break___0;
  case_neg_1___0: /* CIL Label */ 
#line 223
  ngx_processes[s].respawn = 0U;
#line 224
  ngx_processes[s].just_spawn = 0U;
#line 225
  ngx_processes[s].detached = 0U;
#line 226
  goto switch_break___0;
  case_neg_2: /* CIL Label */ 
#line 229
  ngx_processes[s].respawn = 0U;
#line 230
  ngx_processes[s].just_spawn = 1U;
#line 231
  ngx_processes[s].detached = 0U;
#line 232
  goto switch_break___0;
  case_neg_3: /* CIL Label */ 
#line 235
  ngx_processes[s].respawn = 1U;
#line 236
  ngx_processes[s].just_spawn = 0U;
#line 237
  ngx_processes[s].detached = 0U;
#line 238
  goto switch_break___0;
  case_neg_4: /* CIL Label */ 
#line 241
  ngx_processes[s].respawn = 1U;
#line 242
  ngx_processes[s].just_spawn = 1U;
#line 243
  ngx_processes[s].detached = 0U;
#line 244
  goto switch_break___0;
  case_neg_5: /* CIL Label */ 
#line 247
  ngx_processes[s].respawn = 0U;
#line 248
  ngx_processes[s].just_spawn = 0U;
#line 249
  ngx_processes[s].detached = 1U;
#line 250
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 253
  if (s == ngx_last_process) {
#line 254
    ngx_last_process ++;
  }
#line 257
  return (pid);
}
}
#line 261 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
ngx_pid_t ngx_execute(ngx_cycle_t *cycle , ngx_exec_ctx_t *ctx ) 
{ 
  ngx_pid_t tmp ;

  {
  {
#line 264
  tmp = ngx_spawn_process(cycle, & ngx_execute_proc, (void *)ctx, ctx->name, (ngx_int_t )-5);
  }
#line 264
  return (tmp);
}
}
#line 269 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
static void ngx_execute_proc(ngx_cycle_t *cycle , void *data ) 
{ 
  ngx_exec_ctx_t *ctx ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
  {
#line 272
  ctx = (ngx_exec_ctx_t *)data;
#line 274
  tmp___0 = execve((char const   *)ctx->path, ctx->argv, ctx->envp);
  }
#line 274
  if (tmp___0 == -1) {
#line 275
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 275
      tmp = __errno_location();
#line 275
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "execve() failed while executing %s \"%s\"",
                         ctx->name, ctx->path);
      }
    }
  }
  {
#line 280
  exit(1);
  }
}
}
#line 284 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
ngx_int_t ngx_init_signals(ngx_log_t *log ) 
{ 
  ngx_signal_t *sig ;
  struct sigaction sa ;
  int *tmp ;
  int tmp___0 ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 290
  sig = signals;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (sig->signo != 0)) {
#line 290
      goto while_break;
    }
    {
#line 291
    memset((void *)(& sa), 0, sizeof(struct sigaction ));
    }
#line 293
    if (sig->handler) {
#line 294
      sa.__sigaction_handler.sa_sigaction = sig->handler;
#line 295
      sa.sa_flags = 4;
    } else {
#line 298
      sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
    }
    {
#line 301
    sigemptyset(& sa.sa_mask);
#line 302
    tmp___0 = sigaction(sig->signo, (struct sigaction  const  */* __restrict  */)(& sa),
                        (struct sigaction */* __restrict  */)((void *)0));
    }
#line 302
    if (tmp___0 == -1) {
#line 307
      if (log->log_level >= 1UL) {
        {
#line 307
        tmp = __errno_location();
#line 307
        ngx_log_error_core((ngx_uint_t )1, log, *tmp, "sigaction(%s) failed", sig->signame);
        }
      }
#line 309
      return ((ngx_int_t )-1);
    }
#line 290
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 314
  return ((ngx_int_t )0);
}
}
#line 318 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
static void ngx_signal_handler(int signo , siginfo_t *siginfo , void *ucontext ) 
{ 
  char *action ;
  ngx_int_t ignore ;
  ngx_err_t err ;
  ngx_signal_t *sig ;
  int *tmp ;
  __pid_t tmp___0 ;
  int *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 326
  ignore = (ngx_int_t )0;
#line 328
  tmp = __errno_location();
#line 328
  err = *tmp;
#line 330
  sig = signals;
  }
  {
#line 330
  while (1) {
    while_continue: /* CIL Label */ ;
#line 330
    if (! (sig->signo != 0)) {
#line 330
      goto while_break;
    }
#line 331
    if (sig->signo == signo) {
#line 332
      goto while_break;
    }
#line 330
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  ngx_time_sigsafe_update();
#line 338
  action = (char *)"";
  }
  {
#line 343
  if (ngx_process == 0UL) {
#line 343
    goto case_0;
  }
#line 343
  if (ngx_process == 1UL) {
#line 343
    goto case_0;
  }
#line 409
  if (ngx_process == 4UL) {
#line 409
    goto case_4;
  }
#line 409
  if (ngx_process == 3UL) {
#line 409
    goto case_4;
  }
#line 340
  goto switch_break;
  case_0: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 346
  if (signo == 3) {
#line 346
    goto case_3;
  }
#line 352
  if (signo == 2) {
#line 352
    goto case_2;
  }
#line 352
  if (signo == 15) {
#line 352
    goto case_2;
  }
#line 357
  if (signo == 28) {
#line 357
    goto case_28;
  }
#line 364
  if (signo == 1) {
#line 364
    goto case_1___0;
  }
#line 369
  if (signo == 10) {
#line 369
    goto case_10;
  }
#line 374
  if (signo == 12) {
#line 374
    goto case_12;
  }
#line 393
  if (signo == 14) {
#line 393
    goto case_14;
  }
#line 397
  if (signo == 29) {
#line 397
    goto case_29;
  }
#line 401
  if (signo == 17) {
#line 401
    goto case_17;
  }
#line 344
  goto switch_break___0;
  case_3: /* CIL Label */ 
#line 347
  ngx_quit = 1;
#line 348
  action = (char *)", shutting down";
#line 349
  goto switch_break___0;
  case_2: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 353
  ngx_terminate = 1;
#line 354
  action = (char *)", exiting";
#line 355
  goto switch_break___0;
  case_28: /* CIL Label */ 
#line 358
  if (ngx_daemonized) {
#line 359
    ngx_noaccept = 1;
#line 360
    action = (char *)", stop accepting connections";
  }
#line 362
  goto switch_break___0;
  case_1___0: /* CIL Label */ 
#line 365
  ngx_reconfigure = 1;
#line 366
  action = (char *)", reconfiguring";
#line 367
  goto switch_break___0;
  case_10: /* CIL Label */ 
#line 370
  ngx_reopen = 1;
#line 371
  action = (char *)", reopening logs";
#line 372
  goto switch_break___0;
  case_12: /* CIL Label */ 
  {
#line 375
  tmp___0 = getppid();
  }
#line 375
  if (tmp___0 == ngx_parent) {
#line 384
    action = (char *)", ignoring";
#line 385
    ignore = (ngx_int_t )1;
#line 386
    goto switch_break___0;
  } else
#line 375
  if (ngx_new_binary > 0) {
#line 384
    action = (char *)", ignoring";
#line 385
    ignore = (ngx_int_t )1;
#line 386
    goto switch_break___0;
  }
#line 389
  ngx_change_binary = 1;
#line 390
  action = (char *)", changing binary";
#line 391
  goto switch_break___0;
  case_14: /* CIL Label */ 
#line 394
  ngx_sigalrm = 1;
#line 395
  goto switch_break___0;
  case_29: /* CIL Label */ 
#line 398
  ngx_sigio = 1;
#line 399
  goto switch_break___0;
  case_17: /* CIL Label */ 
#line 402
  ngx_reap = 1;
#line 403
  goto switch_break___0;
  switch_break___0: /* CIL Label */ ;
  }
#line 406
  goto switch_break;
  case_4: /* CIL Label */ 
  case_3___0: /* CIL Label */ 
  {
#line 412
  if (signo == 28) {
#line 412
    goto case_28___0;
  }
#line 418
  if (signo == 3) {
#line 418
    goto case_3___1;
  }
#line 424
  if (signo == 2) {
#line 424
    goto case_2___0;
  }
#line 424
  if (signo == 15) {
#line 424
    goto case_2___0;
  }
#line 429
  if (signo == 10) {
#line 429
    goto case_10___0;
  }
#line 436
  if (signo == 29) {
#line 436
    goto case_29___0;
  }
#line 436
  if (signo == 12) {
#line 436
    goto case_29___0;
  }
#line 436
  if (signo == 1) {
#line 436
    goto case_29___0;
  }
#line 410
  goto switch_break___1;
  case_28___0: /* CIL Label */ 
#line 413
  if (! ngx_daemonized) {
#line 414
    goto switch_break___1;
  }
#line 416
  ngx_debug_quit = 1;
  case_3___1: /* CIL Label */ 
#line 419
  ngx_quit = 1;
#line 420
  action = (char *)", shutting down";
#line 421
  goto switch_break___1;
  case_2___0: /* CIL Label */ 
  case_15___0: /* CIL Label */ 
#line 425
  ngx_terminate = 1;
#line 426
  action = (char *)", exiting";
#line 427
  goto switch_break___1;
  case_10___0: /* CIL Label */ 
#line 430
  ngx_reopen = 1;
#line 431
  action = (char *)", reopening logs";
#line 432
  goto switch_break___1;
  case_29___0: /* CIL Label */ 
  case_12___0: /* CIL Label */ 
  case_1___1: /* CIL Label */ 
#line 437
  action = (char *)", ignoring";
#line 438
  goto switch_break___1;
  switch_break___1: /* CIL Label */ ;
  }
#line 441
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 444
  if (siginfo) {
#line 444
    if (siginfo->_sifields._kill.si_pid) {
#line 445
      if ((ngx_cycle->log)->log_level >= 6UL) {
        {
#line 445
        ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "signal %d (%s) received from %P%s",
                           signo, sig->signame, siginfo->_sifields._kill.si_pid, action);
        }
      }
    } else {
#line 444
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 450
  if ((ngx_cycle->log)->log_level >= 6UL) {
    {
#line 450
    ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "signal %d (%s) received%s",
                       signo, sig->signame, action);
    }
  }
#line 455
  if (ignore) {
#line 456
    if ((ngx_cycle->log)->log_level >= 3UL) {
      {
#line 456
      ngx_log_error_core((ngx_uint_t )3, (ngx_log_t *)ngx_cycle->log, 0, "the changing binary signal is ignored: you should shutdown or terminate before either old or new binary\'s process");
      }
    }
  }
#line 462
  if (signo == 17) {
    {
#line 463
    ngx_process_get_status();
    }
  }
  {
#line 466
  tmp___1 = __errno_location();
#line 466
  *tmp___1 = err;
  }
#line 467
  return;
}
}
#line 470 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
static void ngx_process_get_status(void) 
{ 
  int status ;
  char *process ;
  ngx_pid_t pid ;
  ngx_err_t err ;
  ngx_int_t i ;
  ngx_uint_t one ;
  int *tmp ;
  char const   *tmp___0 ;
  union __anonunion_177 __constr_expr_1 ;
  union __anonunion_178 __constr_expr_2 ;
  union __anonunion_179 __constr_expr_3 ;
  union __anonunion_180 __constr_expr_4 ;
  union __anonunion_181 __constr_expr_5 ;
  union __anonunion_182 __constr_expr_6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 480
  one = (ngx_uint_t )0;
  {
#line 482
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 483
    pid = waitpid(-1, & status, 1);
    }
#line 485
    if (pid == 0) {
#line 486
      return;
    }
#line 489
    if (pid == -1) {
      {
#line 490
      tmp = __errno_location();
#line 490
      err = *tmp;
      }
#line 492
      if (err == 4) {
#line 493
        goto __Cont;
      }
#line 496
      if (err == 10) {
#line 496
        if (one) {
#line 497
          return;
        }
      }
#line 509
      if (err == 10) {
#line 510
        if ((ngx_cycle->log)->log_level >= 7UL) {
          {
#line 510
          ngx_log_error_core((ngx_uint_t )7, (ngx_log_t *)ngx_cycle->log, err, "waitpid() failed");
          }
        }
#line 512
        return;
      }
#line 515
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 515
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, err, "waitpid() failed");
        }
      }
#line 517
      return;
    }
#line 521
    one = (ngx_uint_t )1;
#line 522
    process = (char *)"unknown process";
#line 524
    i = (ngx_int_t )0;
    {
#line 524
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 524
      if (! (i < ngx_last_process)) {
#line 524
        goto while_break___0;
      }
#line 525
      if (ngx_processes[i].pid == pid) {
#line 526
        ngx_processes[i].status = status;
#line 527
        ngx_processes[i].exited = 1U;
#line 528
        process = ngx_processes[i].name;
#line 529
        goto while_break___0;
      }
#line 524
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 533
    __constr_expr_4.__in = status;
#line 533
    if (__constr_expr_4.__i & 127) {
#line 535
      if ((ngx_cycle->log)->log_level >= 2UL) {
#line 535
        __constr_expr_1.__in = status;
#line 535
        if (__constr_expr_1.__i & 128) {
#line 535
          tmp___0 = " (core dumped)";
        } else {
#line 535
          tmp___0 = "";
        }
        {
#line 535
        __constr_expr_2.__in = status;
#line 535
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "%s %P exited on signal %d%s",
                           process, pid, __constr_expr_2.__i & 127, tmp___0);
        }
      }
    } else
#line 546
    if ((ngx_cycle->log)->log_level >= 6UL) {
      {
#line 546
      __constr_expr_3.__in = status;
#line 546
      ngx_log_error_core((ngx_uint_t )6, (ngx_log_t *)ngx_cycle->log, 0, "%s %P exited with code %d",
                         process, pid, (__constr_expr_3.__i & 65280) >> 8);
      }
    }
#line 551
    __constr_expr_6.__in = status;
#line 551
    if ((__constr_expr_6.__i & 65280) >> 8 == 2) {
#line 551
      if (ngx_processes[i].respawn) {
#line 552
        if ((ngx_cycle->log)->log_level >= 2UL) {
          {
#line 552
          __constr_expr_5.__in = status;
#line 552
          ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "%s %P exited with fatal code %d and cannot be respawned",
                             process, pid, (__constr_expr_5.__i & 65280) >> 8);
          }
        }
#line 556
        ngx_processes[i].respawn = 0U;
      }
    }
    {
#line 559
    ngx_unlock_mutexes(pid);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 564 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
static void ngx_unlock_mutexes(ngx_pid_t pid ) 
{ 
  ngx_uint_t i ;
  ngx_shm_zone_t *shm_zone ;
  ngx_list_part_t *part ;
  ngx_slab_pool_t *sp ;
  ngx_uint_t tmp ;
  char *__cil_tmp7 ;

  {
#line 577
  if (ngx_accept_mutex_ptr) {
    {
#line 578
    ngx_shmtx_force_unlock(& ngx_accept_mutex, pid);
    }
  }
#line 586
  part = (ngx_list_part_t *)(& ngx_cycle->shared_memory.part);
#line 587
  shm_zone = (ngx_shm_zone_t *)part->elts;
#line 589
  i = (ngx_uint_t )0;
  {
#line 589
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    if (i >= part->nelts) {
#line 592
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 593
        goto while_break;
      }
#line 595
      part = part->next;
#line 596
      shm_zone = (ngx_shm_zone_t *)part->elts;
#line 597
      i = (ngx_uint_t )0;
    }
    {
#line 600
    sp = (ngx_slab_pool_t *)(shm_zone + i)->shm.addr;
#line 602
    tmp = ngx_shmtx_force_unlock(& sp->mutex, pid);
    }
#line 602
    if (tmp) {
#line 603
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 603
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "shared memory zone \"%V\" was locked by %P",
                           & (shm_zone + i)->shm.name, pid);
        }
      }
    }
#line 589
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  return;
}
}
#line 611 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
void ngx_debug_point(void) 
{ 
  ngx_core_conf_t *ccf ;

  {
#line 616
  ccf = (ngx_core_conf_t *)*(ngx_cycle->conf_ctx + ngx_core_module.index);
  {
#line 621
  if (ccf->debug_points == 1L) {
#line 621
    goto case_1;
  }
#line 625
  if (ccf->debug_points == 2L) {
#line 625
    goto case_2;
  }
#line 619
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 622
  raise(19);
  }
#line 623
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 626
  abort();
  }
  switch_break: /* CIL Label */ ;
  }
#line 628
  return;
}
}
#line 631 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_process.c"
ngx_int_t ngx_os_signal_process(ngx_cycle_t *cycle , char *name , ngx_pid_t pid ) 
{ 
  ngx_signal_t *sig ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 636
  sig = signals;
  {
#line 636
  while (1) {
    while_continue: /* CIL Label */ ;
#line 636
    if (! (sig->signo != 0)) {
#line 636
      goto while_break;
    }
    {
#line 637
    tmp___1 = strcmp((char const   *)name, (char const   *)sig->name);
    }
#line 637
    if (tmp___1 == 0) {
      {
#line 638
      tmp = kill(pid, sig->signo);
      }
#line 638
      if (tmp != -1) {
#line 639
        return ((ngx_int_t )0);
      }
#line 642
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 642
        tmp___0 = __errno_location();
#line 642
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "kill(%P, %d) failed",
                           pid, sig->signo);
        }
      }
    }
#line 636
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  return ((ngx_int_t )1);
}
}
#line 61 "/usr/include/x86_64-linux-gnu/sys/mman.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) mmap)(void *__addr ,
                                                                             size_t __len ,
                                                                             int __prot ,
                                                                             int __flags ,
                                                                             int __fd ,
                                                                             __off64_t __offset )  __asm__("mmap64")  ;
#line 76
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) munmap)(void *__addr ,
                                                                             size_t __len ) ;
#line 25 "src/os/unix/ngx_shmem.h"
ngx_int_t ngx_shm_alloc(ngx_shm_t *shm ) ;
#line 26
void ngx_shm_free(ngx_shm_t *shm ) ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_shmem.c"
ngx_int_t ngx_shm_alloc(ngx_shm_t *shm ) 
{ 
  void *tmp ;
  int *tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 17
  tmp = mmap((void *)0, shm->size, 3, 33, -1, (__off64_t )0);
#line 17
  shm->addr = (u_char *)tmp;
  }
#line 21
  if ((unsigned long )shm->addr == (unsigned long )((void *)-1)) {
#line 22
    if ((shm->log)->log_level >= 2UL) {
      {
#line 22
      tmp___0 = __errno_location();
#line 22
      ngx_log_error_core((ngx_uint_t )2, shm->log, *tmp___0, "mmap(MAP_ANON|MAP_SHARED, %uz) failed",
                         shm->size);
      }
    }
#line 24
    return ((ngx_int_t )-1);
  }
#line 27
  return ((ngx_int_t )0);
}
}
#line 31 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_shmem.c"
void ngx_shm_free(ngx_shm_t *shm ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
  {
#line 34
  tmp___0 = munmap((void *)shm->addr, shm->size);
  }
#line 34
  if (tmp___0 == -1) {
#line 35
    if ((shm->log)->log_level >= 2UL) {
      {
#line 35
      tmp = __errno_location();
#line 35
      ngx_log_error_core((ngx_uint_t )2, shm->log, *tmp, "munmap(%p, %uz) failed",
                         shm->addr, shm->size);
      }
    }
  }
#line 38
  return;
}
}
#line 184 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendmsg(int __fd , struct msghdr  const  *__message , int __flags ) ;
#line 202
extern ssize_t recvmsg(int __fd , struct msghdr *__message , int __flags ) ;
#line 220 "src/core/ngx_connection.h"
ngx_connection_t *ngx_get_connection(ngx_socket_t s , ngx_log_t *log ) ;
#line 221
void ngx_free_connection(ngx_connection_t *c ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_channel.c"
ngx_int_t ngx_write_channel(ngx_socket_t s , ngx_channel_t *ch , size_t size , ngx_log_t *log ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  struct iovec iov[1] ;
  struct msghdr msg ;
  union __anonunion_cmsg_175 cmsg ;
  int *tmp ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 29
  if (ch->fd == -1) {
#line 30
    msg.msg_control = (void *)0;
#line 31
    msg.msg_controllen = (size_t )0;
  } else {
    {
#line 34
    msg.msg_control = (void *)((caddr_t )(& cmsg));
#line 35
    msg.msg_controllen = sizeof(cmsg);
#line 37
    memset((void *)(& cmsg), 0, sizeof(cmsg));
#line 39
    cmsg.cm.cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(int );
#line 40
    cmsg.cm.cmsg_level = 1;
#line 41
    cmsg.cm.cmsg_type = 1;
#line 53
    memcpy((void */* __restrict  */)(cmsg.cm.__cmsg_data), (void const   */* __restrict  */)(& ch->fd),
           sizeof(int ));
    }
  }
  {
#line 56
  msg.msg_flags = 0;
#line 71
  iov[0].iov_base = (void *)((char *)ch);
#line 72
  iov[0].iov_len = size;
#line 74
  msg.msg_name = (void *)0;
#line 75
  msg.msg_namelen = (socklen_t )0;
#line 76
  msg.msg_iov = iov;
#line 77
  msg.msg_iovlen = (size_t )1;
#line 79
  n = sendmsg(s, (struct msghdr  const  *)(& msg), 0);
  }
#line 81
  if (n == -1L) {
    {
#line 82
    tmp = __errno_location();
#line 82
    err = *tmp;
    }
#line 83
    if (err == 11) {
#line 84
      return ((ngx_int_t )-2);
    }
#line 87
    if (log->log_level >= 2UL) {
      {
#line 87
      ngx_log_error_core((ngx_uint_t )2, log, err, "sendmsg() failed");
      }
    }
#line 88
    return ((ngx_int_t )-1);
  }
#line 91
  return ((ngx_int_t )0);
}
}
#line 95 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_channel.c"
ngx_int_t ngx_read_channel(ngx_socket_t s , ngx_channel_t *ch , size_t size , ngx_log_t *log ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  struct iovec iov[1] ;
  struct msghdr msg ;
  union __anonunion_cmsg_176 cmsg ;
  int *tmp ;
  void *__cil_tmp11 ;
  int __cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 112
  iov[0].iov_base = (void *)((char *)ch);
#line 113
  iov[0].iov_len = size;
#line 115
  msg.msg_name = (void *)0;
#line 116
  msg.msg_namelen = (socklen_t )0;
#line 117
  msg.msg_iov = iov;
#line 118
  msg.msg_iovlen = (size_t )1;
#line 121
  msg.msg_control = (void *)((caddr_t )(& cmsg));
#line 122
  msg.msg_controllen = sizeof(cmsg);
#line 128
  n = recvmsg(s, & msg, 0);
  }
#line 130
  if (n == -1L) {
    {
#line 131
    tmp = __errno_location();
#line 131
    err = *tmp;
    }
#line 132
    if (err == 11) {
#line 133
      return ((ngx_int_t )-2);
    }
#line 136
    if (log->log_level >= 2UL) {
      {
#line 136
      ngx_log_error_core((ngx_uint_t )2, log, err, "recvmsg() failed");
      }
    }
#line 137
    return ((ngx_int_t )-1);
  }
#line 140
  if (n == 0L) {
#line 142
    return ((ngx_int_t )-1);
  }
#line 145
  if ((size_t )n < sizeof(ngx_channel_t )) {
#line 146
    if (log->log_level >= 2UL) {
      {
#line 146
      ngx_log_error_core((ngx_uint_t )2, log, 0, "recvmsg() returned not enough data: %z",
                         n);
      }
    }
#line 148
    return ((ngx_int_t )-1);
  }
#line 153
  if (ch->command == 1UL) {
#line 155
    if (cmsg.cm.cmsg_len < (size_t )((socklen_t )((((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(int )))) {
#line 156
      if (log->log_level >= 2UL) {
        {
#line 156
        ngx_log_error_core((ngx_uint_t )2, log, 0, "recvmsg() returned too small ancillary data");
        }
      }
#line 158
      return ((ngx_int_t )-1);
    }
#line 161
    if (cmsg.cm.cmsg_level != 1) {
#line 161
      goto _L;
    } else
#line 161
    if (cmsg.cm.cmsg_type != 1) {
      _L: /* CIL Label */ 
#line 163
      if (log->log_level >= 2UL) {
        {
#line 163
        ngx_log_error_core((ngx_uint_t )2, log, 0, "recvmsg() returned invalid ancillary data level %d or type %d",
                           cmsg.cm.cmsg_level, cmsg.cm.cmsg_type);
        }
      }
#line 167
      return ((ngx_int_t )-1);
    }
    {
#line 172
    memcpy((void */* __restrict  */)(& ch->fd), (void const   */* __restrict  */)(cmsg.cm.__cmsg_data),
           sizeof(int ));
    }
  }
#line 175
  if (msg.msg_flags & 40) {
#line 176
    if (log->log_level >= 2UL) {
      {
#line 176
      ngx_log_error_core((ngx_uint_t )2, log, 0, "recvmsg() truncated data");
      }
    }
  }
#line 194
  return (n);
}
}
#line 198 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_channel.c"
ngx_int_t ngx_add_channel_event(ngx_cycle_t *cycle , ngx_fd_t fd , ngx_int_t event ,
                                void (*handler)(ngx_event_t *ev ) ) 
{ 
  ngx_event_t *ev ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 205
  c = ngx_get_connection(fd, cycle->log);
  }
#line 207
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 208
    return ((ngx_int_t )-1);
  }
#line 211
  c->pool = cycle->pool;
#line 213
  rev = c->read;
#line 214
  wev = c->write;
#line 216
  rev->log = cycle->log;
#line 217
  wev->log = cycle->log;
#line 219
  rev->channel = 1U;
#line 220
  wev->channel = 1U;
#line 222
  if (event == 8193L) {
#line 222
    ev = rev;
  } else {
#line 222
    ev = wev;
  }
#line 224
  ev->handler = handler;
#line 226
  if (ngx_event_actions.add_conn) {
#line 226
    if ((ngx_event_flags & 64UL) == 0UL) {
      {
#line 227
      tmp = (*(ngx_event_actions.add_conn))(c);
      }
#line 227
      if (tmp == -1L) {
        {
#line 228
        ngx_free_connection(c);
        }
#line 229
        return ((ngx_int_t )-1);
      }
    } else {
#line 226
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 233
    tmp___0 = (*(ngx_event_actions.add))(ev, event, (ngx_uint_t )0);
    }
#line 233
    if (tmp___0 == -1L) {
      {
#line 234
      ngx_free_connection(c);
      }
#line 235
      return ((ngx_int_t )-1);
    }
  }
#line 239
  return ((ngx_int_t )0);
}
}
#line 243 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_channel.c"
void ngx_close_channel(ngx_fd_t *fd , ngx_log_t *log ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 246
  tmp___0 = close(*(fd + 0));
  }
#line 246
  if (tmp___0 == -1) {
#line 247
    if (log->log_level >= 2UL) {
      {
#line 247
      tmp = __errno_location();
#line 247
      ngx_log_error_core((ngx_uint_t )2, log, *tmp, "close() channel failed");
      }
    }
  }
  {
#line 250
  tmp___2 = close(*(fd + 1));
  }
#line 250
  if (tmp___2 == -1) {
#line 251
    if (log->log_level >= 2UL) {
      {
#line 251
      tmp___1 = __errno_location();
#line 251
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___1, "close() channel failed");
      }
    }
  }
#line 253
  return;
}
}
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_udp_sendmsg_chain.c"
static ngx_chain_t *ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *in ,
                                                  ngx_log_t *log ) ;
#line 15
static ssize_t ngx_sendmsg(ngx_connection_t *c , ngx_iovec_t *vec ) ;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_udp_sendmsg_chain.c"
ngx_chain_t *ngx_udp_unix_sendmsg_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) 
{ 
  ssize_t n ;
  off_t send___0 ;
  ngx_chain_t *cl ;
  ngx_event_t *wev ;
  ngx_iovec_t vec ;
  struct iovec iovs[64] ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 28
  wev = c->write;
#line 30
  if (! wev->ready) {
#line 31
    return (in);
  }
#line 47
  if (limit == 0L) {
#line 48
    limit = (off_t )(9223372036854775807LL - (long long )ngx_pagesize);
  } else
#line 47
  if (limit > (off_t )(9223372036854775807LL - (long long )ngx_pagesize)) {
#line 48
    limit = (off_t )(9223372036854775807LL - (long long )ngx_pagesize);
  }
#line 51
  send___0 = (off_t )0;
#line 53
  vec.iovs = iovs;
#line 54
  vec.nalloc = (ngx_uint_t )64;
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 60
    cl = ngx_udp_output_chain_to_iovec(& vec, in, c->log);
    }
#line 62
    if ((unsigned long )cl == (unsigned long )((ngx_chain_t *)-1)) {
#line 63
      return ((ngx_chain_t *)-1);
    }
#line 66
    if (cl) {
#line 66
      if ((cl->buf)->in_file) {
#line 67
        if ((c->log)->log_level >= 2UL) {
          {
#line 67
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "file buf in sendmsg t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 80
        ngx_debug_point();
        }
#line 82
        return ((ngx_chain_t *)-1);
      }
    }
#line 85
    if ((unsigned long )cl == (unsigned long )in) {
#line 86
      return (in);
    }
    {
#line 89
    send___0 = (off_t )((size_t )send___0 + vec.size);
#line 91
    n = ngx_sendmsg(c, & vec);
    }
#line 93
    if (n == -1L) {
#line 94
      return ((ngx_chain_t *)-1);
    }
#line 97
    if (n == -2L) {
#line 98
      wev->ready = 0U;
#line 99
      return (in);
    }
    {
#line 102
    c->sent += n;
#line 104
    in = ngx_chain_update_sent(in, n);
    }
#line 106
    if (send___0 >= limit) {
#line 107
      return (in);
    } else
#line 106
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 107
      return (in);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 113 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_udp_sendmsg_chain.c"
static ngx_chain_t *ngx_udp_output_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *in ,
                                                  ngx_log_t *log ) 
{ 
  size_t total ;
  size_t size ;
  u_char *prev ;
  ngx_uint_t n ;
  ngx_uint_t flush ;
  ngx_chain_t *cl ;
  struct iovec *iov ;
  ngx_uint_t tmp ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 122
  cl = in;
#line 123
  iov = (struct iovec *)((void *)0);
#line 124
  prev = (u_char *)((void *)0);
#line 125
  total = (size_t )0;
#line 126
  n = (ngx_uint_t )0;
#line 127
  flush = (ngx_uint_t )0;
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 129
    if (in) {
#line 129
      if (! (! flush)) {
#line 129
        goto while_break;
      }
    } else {
#line 129
      goto while_break;
    }
#line 131
    if ((in->buf)->flush) {
#line 132
      flush = (ngx_uint_t )1;
    } else
#line 131
    if ((in->buf)->last_buf) {
#line 132
      flush = (ngx_uint_t )1;
    }
#line 135
    if ((in->buf)->flush) {
#line 135
      goto _L;
    } else
#line 135
    if ((in->buf)->last_buf) {
#line 135
      goto _L;
    } else
#line 135
    if ((in->buf)->sync) {
      _L: /* CIL Label */ 
#line 135
      if (! (in->buf)->temporary) {
#line 135
        if (! (in->buf)->memory) {
#line 135
          if (! (in->buf)->mmap) {
#line 135
            if (! (in->buf)->in_file) {
#line 136
              goto __Cont;
            }
          }
        }
      }
    }
#line 139
    if ((in->buf)->in_file) {
#line 140
      goto while_break;
    }
#line 143
    if (! (in->buf)->temporary) {
#line 143
      if (! (in->buf)->memory) {
#line 143
        if (! (in->buf)->mmap) {
#line 144
          if (log->log_level >= 2UL) {
            {
#line 144
            ngx_log_error_core((ngx_uint_t )2, log, 0, "bad buf in output chain t:%d r:%d f:%d %p %p-%p %p %O-%O",
                               (in->buf)->temporary, (in->buf)->recycled, (in->buf)->in_file,
                               (in->buf)->start, (in->buf)->pos, (in->buf)->last,
                               (in->buf)->file, (in->buf)->file_pos, (in->buf)->file_last);
            }
          }
          {
#line 157
          ngx_debug_point();
          }
#line 159
          return ((ngx_chain_t *)-1);
        }
      }
    }
#line 162
    size = (size_t )((in->buf)->last - (in->buf)->pos);
#line 164
    if ((unsigned long )prev == (unsigned long )(in->buf)->pos) {
#line 165
      iov->iov_len += size;
    } else {
#line 168
      if (n == vec->nalloc) {
#line 169
        if (log->log_level >= 2UL) {
          {
#line 169
          ngx_log_error_core((ngx_uint_t )2, log, 0, "too many parts in a datagram");
          }
        }
#line 171
        return ((ngx_chain_t *)-1);
      }
#line 174
      tmp = n;
#line 174
      n ++;
#line 174
      iov = vec->iovs + tmp;
#line 176
      iov->iov_base = (void *)(in->buf)->pos;
#line 177
      iov->iov_len = size;
    }
#line 180
    prev = (in->buf)->pos + size;
#line 181
    total += size;
    __Cont: /* CIL Label */ 
#line 129
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 184
  if (! flush) {
#line 186
    vec->size = (size_t )0;
#line 187
    vec->count = (ngx_uint_t )0;
#line 189
    return (cl);
  }
#line 192
  vec->count = n;
#line 193
  vec->size = total;
#line 195
  return (in);
}
}
#line 199 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_udp_sendmsg_chain.c"
static ssize_t ngx_sendmsg(ngx_connection_t *c , ngx_iovec_t *vec ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  struct msghdr msg ;
  u_char msg_control[(((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  u_char msg_control6[(((sizeof(struct in6_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  struct cmsghdr *cmsg ;
  struct in_pktinfo *pkt ;
  struct sockaddr_in *sin ;
  struct cmsghdr *cmsg___0 ;
  struct in6_pktinfo *pkt6 ;
  struct sockaddr_in6 *sin6 ;
  int *tmp ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
  {
#line 220
  memset((void *)(& msg), 0, sizeof(struct msghdr ));
  }
#line 222
  if (c->socklen) {
#line 223
    msg.msg_name = (void *)c->sockaddr;
#line 224
    msg.msg_namelen = c->socklen;
  }
#line 227
  msg.msg_iov = vec->iovs;
#line 228
  msg.msg_iovlen = vec->count;
#line 232
  if (c->listening) {
#line 232
    if ((c->listening)->wildcard) {
#line 232
      if (c->local_sockaddr) {
#line 257
        if ((int )(c->local_sockaddr)->sa_family == 2) {
#line 262
          msg.msg_control = (void *)(& msg_control);
#line 263
          msg.msg_controllen = sizeof(msg_control);
#line 265
          if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 265
            cmsg = (struct cmsghdr *)msg.msg_control;
          } else {
#line 265
            cmsg = (struct cmsghdr *)0;
          }
          {
#line 266
          cmsg->cmsg_level = 0;
#line 267
          cmsg->cmsg_type = 8;
#line 268
          cmsg->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(struct in_pktinfo );
#line 270
          sin = (struct sockaddr_in *)c->local_sockaddr;
#line 272
          pkt = (struct in_pktinfo *)(cmsg->__cmsg_data);
#line 273
          memset((void *)pkt, 0, sizeof(struct in_pktinfo ));
#line 274
          pkt->ipi_spec_dst = sin->sin_addr;
          }
        }
#line 281
        if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 286
          msg.msg_control = (void *)(& msg_control6);
#line 287
          msg.msg_controllen = sizeof(msg_control6);
#line 289
          if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 289
            cmsg___0 = (struct cmsghdr *)msg.msg_control;
          } else {
#line 289
            cmsg___0 = (struct cmsghdr *)0;
          }
          {
#line 290
          cmsg___0->cmsg_level = 41;
#line 291
          cmsg___0->cmsg_type = 50;
#line 292
          cmsg___0->cmsg_len = (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + sizeof(struct in6_pktinfo );
#line 294
          sin6 = (struct sockaddr_in6 *)c->local_sockaddr;
#line 296
          pkt6 = (struct in6_pktinfo *)(cmsg___0->__cmsg_data);
#line 297
          memset((void *)pkt6, 0, sizeof(struct in6_pktinfo ));
#line 298
          pkt6->ipi6_addr = sin6->sin6_addr;
          }
        }
      }
    }
  }
  eintr: 
  {
#line 308
  n = sendmsg(c->fd, (struct msghdr  const  *)(& msg), 0);
  }
#line 313
  if (n == -1L) {
    {
#line 314
    tmp = __errno_location();
#line 314
    err = *tmp;
    }
    {
#line 317
    if (err == 11) {
#line 317
      goto case_11;
    }
#line 322
    if (err == 4) {
#line 322
      goto case_4;
    }
#line 327
    goto switch_default;
    case_11: /* CIL Label */ ;
#line 320
    return ((ssize_t )-2);
    case_4: /* CIL Label */ ;
#line 325
    goto eintr;
    switch_default: /* CIL Label */ 
    {
#line 328
    (c->write)->error = 1U;
#line 329
    ngx_connection_error(c, err, (char *)"sendmsg() failed");
    }
#line 330
    return ((ssize_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 334
  return (n);
}
}
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  * __restrict  __addr , socklen_t __addr_len ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_udp_send.c"
ssize_t ngx_udp_unix_send(ngx_connection_t *c , u_char *buf , size_t size ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_event_t *wev ;
  int *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 20
  wev = c->write;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 23
    n = sendto(c->fd, (void const   *)buf, size, 0, (struct sockaddr  const  */* __restrict  */)c->sockaddr,
               c->socklen);
    }
#line 29
    if (n >= 0L) {
#line 30
      if ((size_t )n != size) {
        {
#line 31
        wev->error = 1U;
#line 32
        ngx_connection_error(c, 0, (char *)"sendto() incomplete");
        }
#line 33
        return ((ssize_t )-1);
      }
#line 36
      c->sent += n;
#line 38
      return (n);
    }
    {
#line 41
    tmp = __errno_location();
#line 41
    err = *tmp;
    }
#line 43
    if (err == 11) {
#line 44
      wev->ready = 0U;
#line 47
      return ((ssize_t )-2);
    }
#line 50
    if (err != 4) {
      {
#line 51
      wev->error = 1U;
#line 52
      ngx_connection_error(c, err, (char *)"sendto() failed");
      }
#line 53
      return ((ssize_t )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_writev_chain.c"
ngx_chain_t *ngx_writev_chain(ngx_connection_t *c , ngx_chain_t *in , off_t limit ) 
{ 
  ssize_t n ;
  ssize_t sent ;
  off_t send___0 ;
  off_t prev_send ;
  ngx_chain_t *cl ;
  ngx_event_t *wev ;
  ngx_iovec_t vec ;
  struct iovec iovs[64] ;
  void *__cil_tmp12 ;
  int __cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 23
  wev = c->write;
#line 25
  if (! wev->ready) {
#line 26
    return (in);
  }
#line 42
  if (limit == 0L) {
#line 43
    limit = (off_t )(9223372036854775807LL - (long long )ngx_pagesize);
  } else
#line 42
  if (limit > (off_t )(9223372036854775807LL - (long long )ngx_pagesize)) {
#line 43
    limit = (off_t )(9223372036854775807LL - (long long )ngx_pagesize);
  }
#line 46
  send___0 = (off_t )0;
#line 48
  vec.iovs = iovs;
#line 49
  vec.nalloc = (ngx_uint_t )64;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 52
    prev_send = send___0;
#line 56
    cl = ngx_output_chain_to_iovec(& vec, in, (size_t )(limit - send___0), c->log);
    }
#line 58
    if ((unsigned long )cl == (unsigned long )((ngx_chain_t *)-1)) {
#line 59
      return ((ngx_chain_t *)-1);
    }
#line 62
    if (cl) {
#line 62
      if ((cl->buf)->in_file) {
#line 63
        if ((c->log)->log_level >= 2UL) {
          {
#line 63
          ngx_log_error_core((ngx_uint_t )2, c->log, 0, "file buf in writev t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 76
        ngx_debug_point();
        }
#line 78
        return ((ngx_chain_t *)-1);
      }
    }
    {
#line 81
    send___0 = (off_t )((size_t )send___0 + vec.size);
#line 83
    n = ngx_writev(c, & vec);
    }
#line 85
    if (n == -1L) {
#line 86
      return ((ngx_chain_t *)-1);
    }
#line 89
    if (n == -2L) {
#line 89
      sent = (ssize_t )0;
    } else {
#line 89
      sent = n;
    }
    {
#line 91
    c->sent += sent;
#line 93
    in = ngx_chain_update_sent(in, sent);
    }
#line 95
    if (send___0 - prev_send != sent) {
#line 96
      wev->ready = 0U;
#line 97
      return (in);
    }
#line 100
    if (send___0 >= limit) {
#line 101
      return (in);
    } else
#line 100
    if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 101
      return (in);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 107 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_writev_chain.c"
ngx_chain_t *ngx_output_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *in , size_t limit ,
                                       ngx_log_t *log ) 
{ 
  size_t total ;
  size_t size ;
  u_char *prev ;
  ngx_uint_t n ;
  struct iovec *iov ;
  ngx_uint_t tmp ;
  char *__cil_tmp11 ;

  {
#line 116
  iov = (struct iovec *)((void *)0);
#line 117
  prev = (u_char *)((void *)0);
#line 118
  total = (size_t )0;
#line 119
  n = (ngx_uint_t )0;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (in) {
#line 121
      if (! (total < limit)) {
#line 121
        goto while_break;
      }
    } else {
#line 121
      goto while_break;
    }
#line 123
    if ((in->buf)->flush) {
#line 123
      goto _L;
    } else
#line 123
    if ((in->buf)->last_buf) {
#line 123
      goto _L;
    } else
#line 123
    if ((in->buf)->sync) {
      _L: /* CIL Label */ 
#line 123
      if (! (in->buf)->temporary) {
#line 123
        if (! (in->buf)->memory) {
#line 123
          if (! (in->buf)->mmap) {
#line 123
            if (! (in->buf)->in_file) {
#line 124
              goto __Cont;
            }
          }
        }
      }
    }
#line 127
    if ((in->buf)->in_file) {
#line 128
      goto while_break;
    }
#line 131
    if (! (in->buf)->temporary) {
#line 131
      if (! (in->buf)->memory) {
#line 131
        if (! (in->buf)->mmap) {
#line 132
          if (log->log_level >= 2UL) {
            {
#line 132
            ngx_log_error_core((ngx_uint_t )2, log, 0, "bad buf in output chain t:%d r:%d f:%d %p %p-%p %p %O-%O",
                               (in->buf)->temporary, (in->buf)->recycled, (in->buf)->in_file,
                               (in->buf)->start, (in->buf)->pos, (in->buf)->last,
                               (in->buf)->file, (in->buf)->file_pos, (in->buf)->file_last);
            }
          }
          {
#line 145
          ngx_debug_point();
          }
#line 147
          return ((ngx_chain_t *)-1);
        }
      }
    }
#line 150
    size = (size_t )((in->buf)->last - (in->buf)->pos);
#line 152
    if (size > limit - total) {
#line 153
      size = limit - total;
    }
#line 156
    if ((unsigned long )prev == (unsigned long )(in->buf)->pos) {
#line 157
      iov->iov_len += size;
    } else {
#line 160
      if (n == vec->nalloc) {
#line 161
        goto while_break;
      }
#line 164
      tmp = n;
#line 164
      n ++;
#line 164
      iov = vec->iovs + tmp;
#line 166
      iov->iov_base = (void *)(in->buf)->pos;
#line 167
      iov->iov_len = size;
    }
#line 170
    prev = (in->buf)->pos + size;
#line 171
    total += size;
    __Cont: /* CIL Label */ 
#line 121
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 174
  vec->count = n;
#line 175
  vec->size = total;
#line 177
  return (in);
}
}
#line 181 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_writev_chain.c"
ssize_t ngx_writev(ngx_connection_t *c , ngx_iovec_t *vec ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  int *tmp ;
  char *__cil_tmp6 ;

  {
  eintr: 
  {
#line 189
  n = writev(c->fd, (struct iovec  const  *)vec->iovs, (int )vec->count);
  }
#line 194
  if (n == -1L) {
    {
#line 195
    tmp = __errno_location();
#line 195
    err = *tmp;
    }
    {
#line 198
    if (err == 11) {
#line 198
      goto case_11;
    }
#line 203
    if (err == 4) {
#line 203
      goto case_4;
    }
#line 208
    goto switch_default;
    case_11: /* CIL Label */ ;
#line 201
    return ((ssize_t )-2);
    case_4: /* CIL Label */ ;
#line 206
    goto eintr;
    switch_default: /* CIL Label */ 
    {
#line 209
    (c->write)->error = 1U;
#line 210
    ngx_connection_error(c, err, (char *)"writev() failed");
    }
#line 211
    return ((ssize_t )-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 215
  return (n);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_send.c"
ssize_t ngx_unix_send(ngx_connection_t *c , u_char *buf , size_t size ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_event_t *wev ;
  int *tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 20
  wev = c->write;
  {
#line 33
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 34
    n = send(c->fd, (void const   *)buf, size, 0);
    }
#line 39
    if (n > 0L) {
#line 40
      if (n < (ssize_t )size) {
#line 41
        wev->ready = 0U;
      }
#line 44
      c->sent += n;
#line 46
      return (n);
    }
    {
#line 49
    tmp = __errno_location();
#line 49
    err = *tmp;
    }
#line 51
    if (n == 0L) {
#line 52
      if ((c->log)->log_level >= 2UL) {
        {
#line 52
        ngx_log_error_core((ngx_uint_t )2, c->log, err, "send() returned zero");
        }
      }
#line 53
      wev->ready = 0U;
#line 54
      return (n);
    }
#line 57
    if (err == 11) {
#line 57
      goto _L;
    } else
#line 57
    if (err == 4) {
      _L: /* CIL Label */ 
#line 58
      wev->ready = 0U;
#line 63
      if (err == 11) {
#line 64
        return ((ssize_t )-2);
      }
    } else {
      {
#line 68
      wev->error = 1U;
#line 69
      ngx_connection_error(c, err, (char *)"send() failed");
      }
#line 70
      return ((ssize_t )-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_udp_recv.c"
ssize_t ngx_udp_unix_recv(ngx_connection_t *c , u_char *buf , size_t size ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  int *tmp ;
  char *__cil_tmp8 ;

  {
#line 20
  rev = c->read;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 23
    n = recv(c->fd, (void *)buf, size, 0);
    }
#line 28
    if (n >= 0L) {
#line 48
      return (n);
    }
    {
#line 51
    tmp = __errno_location();
#line 51
    err = *tmp;
    }
#line 53
    if (err == 11) {
#line 56
      n = (ssize_t )-2;
    } else
#line 53
    if (err == 4) {
#line 56
      n = (ssize_t )-2;
    } else {
      {
#line 59
      n = ngx_connection_error(c, err, (char *)"recv() failed");
      }
#line 60
      goto while_break;
    }
#line 22
    if (! (err == 4)) {
#line 22
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 65
  rev->ready = 0U;
#line 67
  if (n == -1L) {
#line 68
    rev->error = 1U;
  }
#line 71
  return (n);
}
}
#line 39 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t readv(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_readv_chain.c"
ssize_t ngx_readv_chain(ngx_connection_t *c , ngx_chain_t *chain , off_t limit ) 
{ 
  u_char *prev ;
  ssize_t n ;
  ssize_t size ;
  ngx_err_t err ;
  ngx_array_t vec ;
  ngx_event_t *rev ;
  struct iovec *iov ;
  struct iovec iovs[64] ;
  void *tmp ;
  int *tmp___0 ;
  void *__cil_tmp14 ;
  int __cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 23
  rev = c->read;
#line 58
  if (ngx_event_flags & 64UL) {
#line 63
    if (! rev->available) {
#line 63
      if (! rev->pending_eof) {
#line 64
        return ((ssize_t )-2);
      }
    }
  }
#line 70
  prev = (u_char *)((void *)0);
#line 71
  iov = (struct iovec *)((void *)0);
#line 72
  size = (ssize_t )0;
#line 74
  vec.elts = (void *)(iovs);
#line 75
  vec.nelts = (ngx_uint_t )0;
#line 76
  vec.size = sizeof(struct iovec );
#line 77
  vec.nalloc = (ngx_uint_t )64;
#line 78
  vec.pool = c->pool;
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! chain) {
#line 82
      goto while_break;
    }
#line 83
    n = (chain->buf)->end - (chain->buf)->last;
#line 85
    if (limit) {
#line 86
      if (size >= limit) {
#line 87
        goto while_break;
      }
#line 90
      if (size + n > limit) {
#line 91
        n = limit - size;
      }
    }
#line 95
    if ((unsigned long )prev == (unsigned long )(chain->buf)->last) {
#line 96
      iov->iov_len += (size_t )n;
    } else {
#line 99
      if (vec.nelts >= 1024UL) {
#line 100
        goto while_break;
      }
      {
#line 103
      tmp = ngx_array_push(& vec);
#line 103
      iov = (struct iovec *)tmp;
      }
#line 104
      if ((unsigned long )iov == (unsigned long )((void *)0)) {
#line 105
        return ((ssize_t )-1);
      }
#line 108
      iov->iov_base = (void *)(chain->buf)->last;
#line 109
      iov->iov_len = (size_t )n;
    }
#line 112
    size += n;
#line 113
    prev = (chain->buf)->end;
#line 114
    chain = chain->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 120
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 121
    n = readv(c->fd, (struct iovec  const  *)((struct iovec *)vec.elts), (int )vec.nelts);
    }
#line 123
    if (n == 0L) {
#line 124
      rev->ready = 0U;
#line 125
      rev->eof = 1U;
#line 140
      return ((ssize_t )0);
    }
#line 143
    if (n > 0L) {
#line 170
      if (ngx_event_flags & 64UL) {
#line 170
        if (ngx_use_epoll_rdhup) {
#line 173
          if (n < size) {
#line 174
            if (! rev->pending_eof) {
#line 175
              rev->ready = 0U;
            }
#line 178
            rev->available = 0U;
          }
#line 181
          return (n);
        }
      }
#line 186
      if (n < size) {
#line 186
        if (! (ngx_event_flags & 32UL)) {
#line 187
          rev->ready = 0U;
        }
      }
#line 190
      return (n);
    }
    {
#line 193
    tmp___0 = __errno_location();
#line 193
    err = *tmp___0;
    }
#line 195
    if (err == 11) {
#line 198
      n = (ssize_t )-2;
    } else
#line 195
    if (err == 4) {
#line 198
      n = (ssize_t )-2;
    } else {
      {
#line 201
      n = ngx_connection_error(c, err, (char *)"readv() failed");
      }
#line 202
      goto while_break___0;
    }
#line 120
    if (! (err == 4)) {
#line 120
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 207
  rev->ready = 0U;
#line 209
  if (n == -1L) {
#line 210
    (c->read)->error = 1U;
  }
#line 213
  return (n);
}
}
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_recv.c"
ssize_t ngx_unix_recv(ngx_connection_t *c , u_char *buf , size_t size ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  int *tmp ;
  char *__cil_tmp8 ;

  {
#line 20
  rev = c->read;
#line 55
  if (ngx_event_flags & 64UL) {
#line 60
    if (! rev->available) {
#line 60
      if (! rev->pending_eof) {
#line 61
        rev->ready = 0U;
#line 62
        return ((ssize_t )-2);
      }
    }
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    n = recv(c->fd, (void *)buf, size, 0);
    }
#line 74
    if (n == 0L) {
#line 75
      rev->ready = 0U;
#line 76
      rev->eof = 1U;
#line 91
      return ((ssize_t )0);
    }
#line 94
    if (n > 0L) {
#line 121
      if (ngx_event_flags & 64UL) {
#line 121
        if (ngx_use_epoll_rdhup) {
#line 124
          if ((size_t )n < size) {
#line 125
            if (! rev->pending_eof) {
#line 126
              rev->ready = 0U;
            }
#line 129
            rev->available = 0U;
          }
#line 132
          return (n);
        }
      }
#line 137
      if ((size_t )n < size) {
#line 137
        if (! (ngx_event_flags & 32UL)) {
#line 140
          rev->ready = 0U;
        }
      }
#line 143
      return (n);
    }
    {
#line 146
    tmp = __errno_location();
#line 146
    err = *tmp;
    }
#line 148
    if (err == 11) {
#line 151
      n = (ssize_t )-2;
    } else
#line 148
    if (err == 4) {
#line 151
      n = (ssize_t )-2;
    } else {
      {
#line 154
      n = ngx_connection_error(c, err, (char *)"recv() failed");
      }
#line 155
      goto while_break;
    }
#line 68
    if (! (err == 4)) {
#line 68
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  rev->ready = 0U;
#line 162
  if (n == -1L) {
#line 163
    rev->error = 1U;
  }
#line 166
  return (n);
}
}
#line 26 "src/os/unix/ngx_socket.h"
int ngx_blocking(ngx_socket_t s ) ;
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_socket.c"
int ngx_nonblocking(ngx_socket_t s ) 
{ 
  int nb ;
  int tmp ;

  {
  {
#line 31
  nb = 1;
#line 33
  tmp = ioctl(s, 21537UL, & nb);
  }
#line 33
  return (tmp);
}
}
#line 37 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_socket.c"
int ngx_blocking(ngx_socket_t s ) 
{ 
  int nb ;
  int tmp ;

  {
  {
#line 42
  nb = 0;
#line 44
  tmp = ioctl(s, 21537UL, & nb);
  }
#line 44
  return (tmp);
}
}
#line 78 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_socket.c"
int ngx_tcp_nopush(ngx_socket_t s ) 
{ 
  int cork ;
  int tmp ;

  {
  {
#line 83
  cork = 1;
#line 85
  tmp = setsockopt(s, 6, 3, (void const   *)(& cork), (socklen_t )sizeof(int ));
  }
#line 85
  return (tmp);
}
}
#line 90 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_socket.c"
int ngx_tcp_push(ngx_socket_t s ) 
{ 
  int cork ;
  int tmp ;

  {
  {
#line 95
  cork = 0;
#line 97
  tmp = setsockopt(s, 6, 3, (void const   *)(& cork), (socklen_t )sizeof(int ));
  }
#line 97
  return (tmp);
}
}
#line 138 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utimes)(char const   *__file ,
                                                                                             struct timeval  const  *__tvp ) ;
#line 388 "/usr/include/unistd.h"
extern ssize_t pread(int __fd , void *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pread64")  ;
#line 391
extern ssize_t pwrite(int __fd , void const   *__buf , size_t __nbytes , __off64_t __offset )  __asm__("pwrite64")  ;
#line 1019
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off64_t __length )  __asm__("ftruncate64")  ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 165
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp )  __asm__("readdir64")  ;
#line 153 "/usr/include/glob.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) glob)(char const   * __restrict  __pattern ,
                                                                           int __flags ,
                                                                           int (*__errfunc)(char const   * ,
                                                                                            int  ) ,
                                                                           glob_t * __restrict  __pglob )  __asm__("glob64")  ;
#line 158
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) globfree)(glob_t *__pglob )  __asm__("globfree64")  ;
#line 35 "/usr/include/x86_64-linux-gnu/sys/statfs.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) statfs)(char const   *__file ,
                                                                                               struct statfs *__buf )  __asm__("statfs64")  ;
#line 84 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t pwritev(int __fd , struct iovec  const  *__iovec , int __count , __off64_t __offset )  __asm__("pwritev64")  ;
#line 242 "/usr/include/fcntl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) posix_fadvise)(int __fd ,
                                                                                    __off64_t __offset ,
                                                                                    __off64_t __len ,
                                                                                    int __advise )  __asm__("posix_fadvise64")  ;
#line 117 "src/os/unix/ngx_files.h"
ngx_fd_t ngx_open_tempfile(u_char *name , ngx_uint_t persistent , ngx_uint_t access___0 ) ;
#line 132
ssize_t ngx_write_chain_to_file(ngx_file_t *file , ngx_chain_t *cl , off_t offset ,
                                ngx_pool_t *pool ) ;
#line 169
ngx_int_t ngx_set_file_time(u_char *name , ngx_fd_t fd , time_t s ) ;
#line 289
ngx_int_t ngx_open_glob(ngx_glob_t *gl ) ;
#line 291
ngx_int_t ngx_read_glob(ngx_glob_t *gl , ngx_str_t *name ) ;
#line 292
void ngx_close_glob(ngx_glob_t *gl ) ;
#line 295
ngx_err_t ngx_trylock_fd(ngx_fd_t fd ) ;
#line 296
ngx_err_t ngx_lock_fd(ngx_fd_t fd ) ;
#line 297
ngx_err_t ngx_unlock_fd(ngx_fd_t fd ) ;
#line 315
ngx_int_t ngx_read_ahead(ngx_fd_t fd , size_t n ) ;
#line 328
ngx_int_t ngx_directio_on(ngx_fd_t fd ) ;
#line 331
ngx_int_t ngx_directio_off(ngx_fd_t fd ) ;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
static ngx_chain_t *ngx_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *cl ) ;
#line 19
static ssize_t ngx_writev_file(ngx_file_t *file , ngx_iovec_t *vec , off_t offset ) ;
#line 30 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ssize_t ngx_read_file(ngx_file_t *file , u_char *buf , size_t size , off_t offset ) 
{ 
  ssize_t n ;
  int *tmp ;
  char *__cil_tmp7 ;

  {
  {
#line 40
  n = pread(file->fd, (void *)buf, size, offset);
  }
#line 42
  if (n == -1L) {
#line 43
    if ((file->log)->log_level >= 3UL) {
      {
#line 43
      tmp = __errno_location();
#line 43
      ngx_log_error_core((ngx_uint_t )3, file->log, *tmp, "pread() \"%s\" failed",
                         file->name.data);
      }
    }
#line 45
    return ((ssize_t )-1);
  }
#line 72
  file->offset += n;
#line 74
  return (n);
}
}
#line 192 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ssize_t ngx_write_file(ngx_file_t *file , u_char *buf , size_t size , off_t offset ) 
{ 
  ssize_t n ;
  ssize_t written ;
  ngx_err_t err ;
  int *tmp ;
  char *__cil_tmp9 ;

  {
#line 201
  written = (ssize_t )0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    n = pwrite(file->fd, (void const   *)(buf + written), size, offset);
    }
#line 208
    if (n == -1L) {
      {
#line 209
      tmp = __errno_location();
#line 209
      err = *tmp;
      }
#line 211
      if (err == 4) {
#line 214
        goto __Cont;
      }
#line 217
      if ((file->log)->log_level >= 3UL) {
        {
#line 217
        ngx_log_error_core((ngx_uint_t )3, file->log, err, "pwrite() \"%s\" failed",
                           file->name.data);
        }
      }
#line 219
      return ((ssize_t )-1);
    }
#line 222
    file->offset += n;
#line 223
    written += n;
#line 225
    if ((size_t )n == size) {
#line 226
      return (written);
    }
#line 229
    offset += n;
#line 230
    size -= (size_t )n;
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 276 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_fd_t ngx_open_tempfile(u_char *name , ngx_uint_t persistent , ngx_uint_t access___0 ) 
{ 
  ngx_fd_t fd ;
  ngx_uint_t tmp ;

  {
#line 281
  if (access___0) {
#line 281
    tmp = access___0;
  } else {
#line 281
    tmp = (ngx_uint_t )384;
  }
  {
#line 281
  fd = open((char const   *)name, 194, tmp);
  }
#line 284
  if (fd != -1) {
#line 284
    if (! persistent) {
      {
#line 285
      unlink((char const   *)name);
      }
    }
  }
#line 288
  return (fd);
}
}
#line 292 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ssize_t ngx_write_chain_to_file(ngx_file_t *file , ngx_chain_t *cl , off_t offset ,
                                ngx_pool_t *pool ) 
{ 
  ssize_t total ;
  ssize_t n ;
  ngx_iovec_t vec ;
  struct iovec iovs[64] ;
  ssize_t tmp ;
  void *__cil_tmp10 ;
  int __cil_tmp11 ;

  {
#line 302
  if ((unsigned long )cl->next == (unsigned long )((void *)0)) {
    {
#line 303
    tmp = ngx_write_file(file, (cl->buf)->pos, (size_t )((cl->buf)->last - (cl->buf)->pos),
                         offset);
    }
#line 303
    return (tmp);
  }
#line 308
  total = (ssize_t )0;
#line 310
  vec.iovs = iovs;
#line 311
  vec.nalloc = (ngx_uint_t )64;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 315
    cl = ngx_chain_to_iovec(& vec, cl);
    }
#line 319
    if (vec.count == 1UL) {
      {
#line 320
      n = ngx_write_file(file, (u_char *)iovs[0].iov_base, iovs[0].iov_len, offset);
      }
#line 323
      if (n == -1L) {
#line 324
        return (n);
      }
#line 327
      return (total + n);
    }
    {
#line 330
    n = ngx_writev_file(file, & vec, offset);
    }
#line 332
    if (n == -1L) {
#line 333
      return (n);
    }
#line 336
    offset += n;
#line 337
    total += n;
#line 313
    if (! cl) {
#line 313
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 341
  return (total);
}
}
#line 345 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
static ngx_chain_t *ngx_chain_to_iovec(ngx_iovec_t *vec , ngx_chain_t *cl ) 
{ 
  size_t total ;
  size_t size ;
  u_char *prev ;
  ngx_uint_t n ;
  struct iovec *iov ;
  ngx_uint_t tmp ;

  {
#line 353
  iov = (struct iovec *)((void *)0);
#line 354
  prev = (u_char *)((void *)0);
#line 355
  total = (size_t )0;
#line 356
  n = (ngx_uint_t )0;
  {
#line 358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 358
    if (! cl) {
#line 358
      goto while_break;
    }
#line 360
    if ((cl->buf)->flush) {
#line 360
      goto _L;
    } else
#line 360
    if ((cl->buf)->last_buf) {
#line 360
      goto _L;
    } else
#line 360
    if ((cl->buf)->sync) {
      _L: /* CIL Label */ 
#line 360
      if (! (cl->buf)->temporary) {
#line 360
        if (! (cl->buf)->memory) {
#line 360
          if (! (cl->buf)->mmap) {
#line 360
            if (! (cl->buf)->in_file) {
#line 361
              goto __Cont;
            }
          }
        }
      }
    }
#line 364
    size = (size_t )((cl->buf)->last - (cl->buf)->pos);
#line 366
    if ((unsigned long )prev == (unsigned long )(cl->buf)->pos) {
#line 367
      iov->iov_len += size;
    } else {
#line 370
      if (n == vec->nalloc) {
#line 371
        goto while_break;
      }
#line 374
      tmp = n;
#line 374
      n ++;
#line 374
      iov = vec->iovs + tmp;
#line 376
      iov->iov_base = (void *)(cl->buf)->pos;
#line 377
      iov->iov_len = size;
    }
#line 380
    prev = (cl->buf)->pos + size;
#line 381
    total += size;
    __Cont: /* CIL Label */ 
#line 358
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  vec->count = n;
#line 385
  vec->size = total;
#line 387
  return (cl);
}
}
#line 391 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
static ssize_t ngx_writev_file(ngx_file_t *file , ngx_iovec_t *vec , off_t offset ) 
{ 
  ssize_t n ;
  ngx_err_t err ;
  int *tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  eintr: 
  {
#line 404
  n = pwritev(file->fd, (struct iovec  const  *)vec->iovs, (int )vec->count, offset);
  }
#line 406
  if (n == -1L) {
    {
#line 407
    tmp = __errno_location();
#line 407
    err = *tmp;
    }
#line 409
    if (err == 4) {
#line 412
      goto eintr;
    }
#line 415
    if ((file->log)->log_level >= 3UL) {
      {
#line 415
      ngx_log_error_core((ngx_uint_t )3, file->log, err, "pwritev() \"%s\" failed",
                         file->name.data);
      }
    }
#line 417
    return ((ssize_t )-1);
  }
#line 420
  if ((size_t )n != vec->size) {
#line 421
    if ((file->log)->log_level >= 3UL) {
      {
#line 421
      ngx_log_error_core((ngx_uint_t )3, file->log, 0, "pwritev() \"%s\" has written only %z of %uz",
                         file->name.data, n, vec->size);
      }
    }
#line 424
    return ((ssize_t )-1);
  }
#line 468
  file->offset += n;
#line 470
  return (n);
}
}
#line 600 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_set_file_time(u_char *name , ngx_fd_t fd , time_t s ) 
{ 
  struct timeval tv[2] ;
  int tmp ;
  void *__cil_tmp6 ;
  int __cil_tmp7 ;

  {
  {
#line 605
  tv[0].tv_sec = (__time_t )ngx_cached_time->sec;
#line 606
  tv[0].tv_usec = (__suseconds_t )0;
#line 607
  tv[1].tv_sec = s;
#line 608
  tv[1].tv_usec = (__suseconds_t )0;
#line 610
  tmp = utimes((char const   *)((char *)name), (struct timeval  const  *)(tv));
  }
#line 610
  if (tmp != -1) {
#line 611
    return ((ngx_int_t )0);
  }
#line 614
  return ((ngx_int_t )-1);
}
}
#line 618 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_create_file_mapping(ngx_file_mapping_t *fm ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 621
  fm->fd = open((char const   *)fm->name, 578, 420);
  }
#line 624
  if (fm->fd == -1) {
#line 625
    if ((fm->log)->log_level >= 3UL) {
      {
#line 625
      tmp = __errno_location();
#line 625
      ngx_log_error_core((ngx_uint_t )3, fm->log, *tmp, "open() \"%s\" failed", fm->name);
      }
    }
#line 627
    return ((ngx_int_t )-1);
  }
  {
#line 630
  tmp___1 = ftruncate(fm->fd, (__off64_t )fm->size);
  }
#line 630
  if (tmp___1 == -1) {
#line 631
    if ((fm->log)->log_level >= 3UL) {
      {
#line 631
      tmp___0 = __errno_location();
#line 631
      ngx_log_error_core((ngx_uint_t )3, fm->log, *tmp___0, "ftruncate() \"%s\" failed",
                         fm->name);
      }
    }
#line 633
    goto failed;
  }
  {
#line 636
  fm->addr = mmap((void *)0, fm->size, 3, 1, fm->fd, (__off64_t )0);
  }
#line 638
  if ((unsigned long )fm->addr != (unsigned long )((void *)-1)) {
#line 639
    return ((ngx_int_t )0);
  }
#line 642
  if ((fm->log)->log_level >= 3UL) {
    {
#line 642
    tmp___2 = __errno_location();
#line 642
    ngx_log_error_core((ngx_uint_t )3, fm->log, *tmp___2, "mmap(%uz) \"%s\" failed",
                       fm->size, fm->name);
    }
  }
  failed: 
  {
#line 647
  tmp___4 = close(fm->fd);
  }
#line 647
  if (tmp___4 == -1) {
#line 648
    if ((fm->log)->log_level >= 2UL) {
      {
#line 648
      tmp___3 = __errno_location();
#line 648
      ngx_log_error_core((ngx_uint_t )2, fm->log, *tmp___3, "close() \"%s\" failed",
                         fm->name);
      }
    }
  }
#line 652
  return ((ngx_int_t )-1);
}
}
#line 656 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
void ngx_close_file_mapping(ngx_file_mapping_t *fm ) 
{ 
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 659
  tmp___0 = munmap(fm->addr, fm->size);
  }
#line 659
  if (tmp___0 == -1) {
#line 660
    if ((fm->log)->log_level >= 3UL) {
      {
#line 660
      tmp = __errno_location();
#line 660
      ngx_log_error_core((ngx_uint_t )3, fm->log, *tmp, "munmap(%uz) \"%s\" failed",
                         fm->size, fm->name);
      }
    }
  }
  {
#line 664
  tmp___2 = close(fm->fd);
  }
#line 664
  if (tmp___2 == -1) {
#line 665
    if ((fm->log)->log_level >= 2UL) {
      {
#line 665
      tmp___1 = __errno_location();
#line 665
      ngx_log_error_core((ngx_uint_t )2, fm->log, *tmp___1, "close() \"%s\" failed",
                         fm->name);
      }
    }
  }
#line 668
  return;
}
}
#line 671 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_open_dir(ngx_str_t *name , ngx_dir_t *dir ) 
{ 


  {
  {
#line 674
  dir->dir = opendir((char const   *)name->data);
  }
#line 676
  if ((unsigned long )dir->dir == (unsigned long )((void *)0)) {
#line 677
    return ((ngx_int_t )-1);
  }
#line 680
  dir->valid_info = 0U;
#line 682
  return ((ngx_int_t )0);
}
}
#line 686 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_read_dir(ngx_dir_t *dir ) 
{ 


  {
  {
#line 689
  dir->de = readdir(dir->dir);
  }
#line 691
  if (dir->de) {
#line 693
    dir->type = (unsigned int )(dir->de)->d_type;
#line 697
    return ((ngx_int_t )0);
  }
#line 700
  return ((ngx_int_t )-1);
}
}
#line 704 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_open_glob(ngx_glob_t *gl ) 
{ 
  int n ;

  {
  {
#line 709
  n = glob((char const   */* __restrict  */)((char *)gl->pattern), 0, (int (*)(char const   * ,
                                                                               int  ))((void *)0),
           (glob_t */* __restrict  */)(& gl->pglob));
  }
#line 711
  if (n == 0) {
#line 712
    return ((ngx_int_t )0);
  }
#line 717
  if (n == 3) {
#line 717
    if (gl->test) {
#line 718
      return ((ngx_int_t )0);
    }
  }
#line 723
  return ((ngx_int_t )-1);
}
}
#line 727 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_read_glob(ngx_glob_t *gl , ngx_str_t *name ) 
{ 
  size_t count ;
  size_t tmp ;

  {
#line 733
  count = gl->pglob.gl_pathc;
#line 738
  if (gl->n < count) {
    {
#line 740
    tmp = strlen((char const   *)*(gl->pglob.gl_pathv + gl->n));
#line 740
    name->len = tmp;
#line 741
    name->data = (u_char *)*(gl->pglob.gl_pathv + gl->n);
#line 742
    (gl->n) ++;
    }
#line 744
    return ((ngx_int_t )0);
  }
#line 747
  return ((ngx_int_t )-4);
}
}
#line 751 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
void ngx_close_glob(ngx_glob_t *gl ) 
{ 


  {
  {
#line 754
  globfree(& gl->pglob);
  }
#line 755
  return;
}
}
#line 758 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_err_t ngx_trylock_fd(ngx_fd_t fd ) 
{ 
  struct flock fl ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 763
  memset((void *)(& fl), 0, sizeof(struct flock ));
#line 764
  fl.l_type = (short)1;
#line 765
  fl.l_whence = (short)0;
#line 767
  tmp___0 = fcntl(fd, 6, & fl);
  }
#line 767
  if (tmp___0 == -1) {
    {
#line 768
    tmp = __errno_location();
    }
#line 768
    return (*tmp);
  }
#line 771
  return (0);
}
}
#line 775 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_err_t ngx_lock_fd(ngx_fd_t fd ) 
{ 
  struct flock fl ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 780
  memset((void *)(& fl), 0, sizeof(struct flock ));
#line 781
  fl.l_type = (short)1;
#line 782
  fl.l_whence = (short)0;
#line 784
  tmp___0 = fcntl(fd, 7, & fl);
  }
#line 784
  if (tmp___0 == -1) {
    {
#line 785
    tmp = __errno_location();
    }
#line 785
    return (*tmp);
  }
#line 788
  return (0);
}
}
#line 792 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_err_t ngx_unlock_fd(ngx_fd_t fd ) 
{ 
  struct flock fl ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 797
  memset((void *)(& fl), 0, sizeof(struct flock ));
#line 798
  fl.l_type = (short)2;
#line 799
  fl.l_whence = (short)0;
#line 801
  tmp___0 = fcntl(fd, 6, & fl);
  }
#line 801
  if (tmp___0 == -1) {
    {
#line 802
    tmp = __errno_location();
    }
#line 802
    return (*tmp);
  }
#line 805
  return (0);
}
}
#line 811 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_read_ahead(ngx_fd_t fd , size_t n ) 
{ 
  int err ;
  int *tmp ;

  {
  {
#line 816
  err = posix_fadvise(fd, (__off64_t )0, (__off64_t )0, 2);
  }
#line 818
  if (err == 0) {
#line 819
    return ((ngx_int_t )0);
  }
  {
#line 822
  tmp = __errno_location();
#line 822
  *tmp = err;
  }
#line 823
  return ((ngx_int_t )-1);
}
}
#line 831 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_directio_on(ngx_fd_t fd ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 836
  flags = fcntl(fd, 3);
  }
#line 838
  if (flags == -1) {
#line 839
    return ((ngx_int_t )-1);
  }
  {
#line 842
  tmp = fcntl(fd, 4, flags | 16384);
  }
#line 842
  return ((ngx_int_t )tmp);
}
}
#line 846 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
ngx_int_t ngx_directio_off(ngx_fd_t fd ) 
{ 
  int flags ;
  int tmp ;

  {
  {
#line 851
  flags = fcntl(fd, 3);
  }
#line 853
  if (flags == -1) {
#line 854
    return ((ngx_int_t )-1);
  }
  {
#line 857
  tmp = fcntl(fd, 4, flags & -16385);
  }
#line 857
  return ((ngx_int_t )tmp);
}
}
#line 865 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_files.c"
size_t ngx_fs_bsize(u_char *name ) 
{ 
  struct statfs fs ;
  int tmp ;
  void *__cil_tmp4 ;
  void *__cil_tmp5 ;

  {
  {
#line 870
  tmp = statfs((char const   *)((char *)name), & fs);
  }
#line 870
  if (tmp == -1) {
#line 871
    return ((size_t )512);
  }
#line 874
  if (fs.f_bsize % 512L != 0L) {
#line 875
    return ((size_t )512);
  }
#line 878
  return ((size_t )fs.f_bsize);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 503
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) posix_memalign)(void **__memptr ,
                                                                                                     size_t __alignment ,
                                                                                                     size_t __size ) ;
#line 17 "src/os/unix/ngx_alloc.h"
void *ngx_calloc(size_t size , ngx_log_t *log ) ;
#line 31
void *ngx_memalign(size_t alignment , size_t size , ngx_log_t *log ) ;
#line 40 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_pagesize  ;
#line 41 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_pagesize_shift  ;
#line 42 "src/os/unix/ngx_alloc.h"
ngx_uint_t ngx_cacheline_size  ;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_alloc.c"
void *ngx_alloc(size_t size , ngx_log_t *log ) 
{ 
  void *p ;
  int *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 22
  p = malloc(size);
  }
#line 23
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 24
    if (log->log_level >= 1UL) {
      {
#line 24
      tmp = __errno_location();
#line 24
      ngx_log_error_core((ngx_uint_t )1, log, *tmp, "malloc(%uz) failed", size);
      }
    }
  }
#line 30
  return (p);
}
}
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_alloc.c"
void *ngx_calloc(size_t size , ngx_log_t *log ) 
{ 
  void *p ;

  {
  {
#line 39
  p = ngx_alloc(size, log);
  }
#line 41
  if (p) {
    {
#line 42
    memset(p, 0, size);
    }
  }
#line 45
  return (p);
}
}
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_alloc.c"
void *ngx_memalign(size_t alignment , size_t size , ngx_log_t *log ) 
{ 
  void *p ;
  int err ;
  char *__cil_tmp6 ;

  {
  {
#line 57
  err = posix_memalign(& p, alignment, size);
  }
#line 59
  if (err) {
#line 60
    if (log->log_level >= 1UL) {
      {
#line 60
      ngx_log_error_core((ngx_uint_t )1, log, err, "posix_memalign(%uz, %uz) failed",
                         alignment, size);
      }
    }
#line 62
    p = (void *)0;
  }
#line 68
  return (p);
}
}
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 75 "src/os/unix/ngx_errno.h"
u_char *ngx_strerror(ngx_err_t err , u_char *errstr , size_t size ) ;
#line 76
ngx_int_t ngx_strerror_init(void) ;
#line 233 "src/core/ngx_log.h"
void ngx_log_stderr(ngx_err_t err , char const   *fmt  , ...) ;
#line 28 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_errno.c"
static ngx_str_t *ngx_sys_errlist  ;
#line 29 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_errno.c"
static ngx_str_t ngx_unknown_error  =    {sizeof("Unknown error") - 1UL, (u_char *)"Unknown error"};
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_errno.c"
u_char *ngx_strerror(ngx_err_t err , u_char *errstr , size_t size ) 
{ 
  ngx_str_t *msg ;
  void *tmp ;

  {
#line 37
  if ((ngx_uint_t )err < 135UL) {
#line 37
    msg = ngx_sys_errlist + err;
  } else {
#line 37
    msg = & ngx_unknown_error;
  }
#line 39
  if (size > msg->len) {
#line 39
    size = msg->len;
  } else {
#line 39
    size = size;
  }
  {
#line 41
  tmp = memcpy((void */* __restrict  */)errstr, (void const   */* __restrict  */)msg->data,
               size);
  }
#line 41
  return ((u_char *)tmp + size);
}
}
#line 45 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_errno.c"
ngx_int_t ngx_strerror_init(void) 
{ 
  char *msg ;
  u_char *p ;
  size_t len ;
  ngx_err_t err ;
  void *tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
#line 58
  len = 135UL * sizeof(ngx_str_t );
#line 60
  tmp = malloc(len);
#line 60
  ngx_sys_errlist = (ngx_str_t *)tmp;
  }
#line 61
  if ((unsigned long )ngx_sys_errlist == (unsigned long )((void *)0)) {
#line 62
    goto failed;
  }
#line 65
  err = 0;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! (err < 135)) {
#line 65
      goto while_break;
    }
    {
#line 66
    msg = strerror(err);
#line 67
    len = strlen((char const   *)msg);
#line 69
    tmp___0 = malloc(len);
#line 69
    p = (u_char *)tmp___0;
    }
#line 70
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 71
      goto failed;
    }
    {
#line 74
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)msg, len);
#line 75
    (ngx_sys_errlist + err)->len = len;
#line 76
    (ngx_sys_errlist + err)->data = p;
#line 65
    err ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  return ((ngx_int_t )0);
  failed: 
  {
#line 83
  tmp___1 = __errno_location();
#line 83
  err = *tmp___1;
#line 84
  tmp___2 = strerror(err);
#line 84
  ngx_log_stderr(0, "malloc(%uz) failed (%d: %s)", len, err, tmp___2);
  }
#line 86
  return ((ngx_int_t )-1);
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 249
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime_r)(time_t const   * __restrict  __timer ,
                                                                                      struct tm * __restrict  __tp ) ;
#line 254
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime_r)(time_t const   * __restrict  __timer ,
                                                                                         struct tm * __restrict  __tp ) ;
#line 56 "src/os/unix/ngx_time.h"
void ngx_timezone_update(void) ;
#line 57
void ngx_localtime(time_t s , ngx_tm_t *tm ) ;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_time.c"
void ngx_timezone_update(void) 
{ 
  time_t s ;
  struct tm *t ;
  char buf[4] ;
  void *__cil_tmp4 ;

  {
  {
#line 46
  s = time((time_t *)0);
#line 48
  t = localtime((time_t const   *)(& s));
#line 50
  strftime((char */* __restrict  */)(buf), (size_t )4, (char const   */* __restrict  */)"%H",
           (struct tm  const  */* __restrict  */)t);
  }
#line 53
  return;
}
}
#line 56 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_time.c"
void ngx_localtime(time_t s , ngx_tm_t *tm ) 
{ 


  {
  {
#line 60
  localtime_r((time_t const   */* __restrict  */)(& s), (struct tm */* __restrict  */)tm);
#line 70
  (tm->tm_mon) ++;
#line 71
  tm->tm_year += 1900;
  }
#line 72
  return;
}
}
#line 75 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_time.c"
void ngx_libc_localtime(time_t s , struct tm *tm ) 
{ 


  {
  {
#line 79
  localtime_r((time_t const   */* __restrict  */)(& s), (struct tm */* __restrict  */)tm);
  }
#line 88
  return;
}
}
#line 91 "/home/khheo/project/nginx-release-1.13.8/src/os/unix/ngx_time.c"
void ngx_libc_gmtime(time_t s , struct tm *tm ) 
{ 


  {
  {
#line 95
  gmtime_r((time_t const   */* __restrict  */)(& s), (struct tm */* __restrict  */)tm);
  }
#line 104
  return;
}
}
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_read_upstream(ngx_event_pipe_t *p ) ;
#line 15
static ngx_int_t ngx_event_pipe_write_to_downstream(ngx_event_pipe_t *p ) ;
#line 17
static ngx_int_t ngx_event_pipe_write_chain_to_temp_file(ngx_event_pipe_t *p ) ;
#line 18
__inline static void ngx_event_pipe_remove_shadow_links(ngx_buf_t *buf ) ;
#line 19
static ngx_int_t ngx_event_pipe_drain_chains(ngx_event_pipe_t *p ) ;
#line 22 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
ngx_int_t ngx_event_pipe(ngx_event_pipe_t *p , ngx_int_t do_write ) 
{ 
  ngx_int_t rc ;
  ngx_uint_t flags ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (do_write) {
      {
#line 31
      (p->log)->action = (char *)"sending to client";
#line 33
      rc = ngx_event_pipe_write_to_downstream(p);
      }
#line 35
      if (rc == -6L) {
#line 36
        return ((ngx_int_t )-6);
      }
#line 39
      if (rc == -3L) {
#line 40
        return ((ngx_int_t )0);
      }
    }
    {
#line 44
    p->read = 0U;
#line 45
    p->upstream_blocked = 0U;
#line 47
    (p->log)->action = (char *)"reading upstream";
#line 49
    tmp = ngx_event_pipe_read_upstream(p);
    }
#line 49
    if (tmp == -6L) {
#line 50
      return ((ngx_int_t )-6);
    }
#line 53
    if (! p->read) {
#line 53
      if (! p->upstream_blocked) {
#line 54
        goto while_break;
      }
    }
#line 57
    do_write = (ngx_int_t )1;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  if ((p->upstream)->fd != -1) {
#line 61
    rev = (p->upstream)->read;
#line 63
    if (rev->eof) {
#line 63
      flags = (ngx_uint_t )1;
    } else
#line 63
    if (rev->error) {
#line 63
      flags = (ngx_uint_t )1;
    } else {
#line 63
      flags = (ngx_uint_t )0;
    }
    {
#line 65
    tmp___0 = ngx_handle_read_event(rev, flags);
    }
#line 65
    if (tmp___0 != 0L) {
#line 66
      return ((ngx_int_t )-6);
    }
#line 69
    if (! rev->delayed) {
#line 70
      if (rev->active) {
#line 70
        if (! rev->ready) {
          {
#line 71
          ngx_event_add_timer(rev, p->read_timeout);
          }
        } else {
#line 70
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 73
      if (rev->timer_set) {
        {
#line 74
        ngx_event_del_timer(rev);
        }
      }
    }
  }
#line 79
  if ((p->downstream)->fd != -1) {
#line 79
    if ((unsigned long )(p->downstream)->data == (unsigned long )p->output_ctx) {
      {
#line 82
      wev = (p->downstream)->write;
#line 83
      tmp___1 = ngx_handle_write_event(wev, (size_t )p->send_lowat);
      }
#line 83
      if (tmp___1 != 0L) {
#line 84
        return ((ngx_int_t )-6);
      }
#line 87
      if (! wev->delayed) {
#line 88
        if (wev->active) {
#line 88
          if (! wev->ready) {
            {
#line 89
            ngx_event_add_timer(wev, p->send_timeout);
            }
          } else {
#line 88
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 91
        if (wev->timer_set) {
          {
#line 92
          ngx_event_del_timer(wev);
          }
        }
      }
    }
  }
#line 97
  return ((ngx_int_t )0);
}
}
#line 101 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_read_upstream(ngx_event_pipe_t *p ) 
{ 
  off_t limit ;
  ssize_t n ;
  ssize_t size ;
  ngx_int_t rc ;
  ngx_buf_t *b ;
  ngx_msec_t delay ;
  ngx_chain_t *chain ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  int tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;
  int tmp___3 ;
  ngx_int_t tmp___4 ;

  {
#line 111
  if (p->upstream_eof) {
#line 112
    return ((ngx_int_t )0);
  } else
#line 111
  if (p->upstream_error) {
#line 112
    return ((ngx_int_t )0);
  } else
#line 111
  if (p->upstream_done) {
#line 112
    return ((ngx_int_t )0);
  }
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (p->upstream_eof) {
#line 142
      goto while_break;
    } else
#line 141
    if (p->upstream_error) {
#line 142
      goto while_break;
    } else
#line 141
    if (p->upstream_done) {
#line 142
      goto while_break;
    }
#line 145
    if ((unsigned long )p->preread_bufs == (unsigned long )((void *)0)) {
#line 145
      if (! ((p->upstream)->read)->ready) {
#line 146
        goto while_break;
      }
    }
#line 149
    if (p->preread_bufs) {
#line 153
      chain = p->preread_bufs;
#line 154
      p->preread_bufs = (ngx_chain_t *)((void *)0);
#line 155
      n = (ssize_t )p->preread_size;
#line 160
      if (n) {
#line 161
        p->read = 1U;
      }
    } else {
#line 197
      if (p->limit_rate) {
#line 198
        if (((p->upstream)->read)->delayed) {
#line 199
          goto while_break;
        }
#line 202
        limit = (off_t )p->limit_rate * (off_t )((ngx_cached_time->sec - (time_t volatile   )p->start_sec) + (time_t volatile   )1) - p->read_length;
#line 205
        if (limit <= 0L) {
          {
#line 206
          ((p->upstream)->read)->delayed = 1U;
#line 207
          delay = (size_t )(- limit * 1000L) / p->limit_rate + 1UL;
#line 208
          ngx_event_add_timer((p->upstream)->read, delay);
          }
#line 209
          goto while_break;
        }
      } else {
#line 213
        limit = (off_t )0;
      }
#line 216
      if (p->free_raw_bufs) {
#line 220
        chain = p->free_raw_bufs;
#line 221
        if (p->single_buf) {
#line 222
          p->free_raw_bufs = (p->free_raw_bufs)->next;
#line 223
          chain->next = (ngx_chain_t *)((void *)0);
        } else {
#line 225
          p->free_raw_bufs = (ngx_chain_t *)((void *)0);
        }
      } else
#line 228
      if (p->allocated < p->bufs.num) {
        {
#line 232
        b = ngx_create_temp_buf(p->pool, p->bufs.size);
        }
#line 233
        if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 234
          return ((ngx_int_t )-6);
        }
        {
#line 237
        (p->allocated) ++;
#line 239
        chain = ngx_alloc_chain_link(p->pool);
        }
#line 240
        if ((unsigned long )chain == (unsigned long )((void *)0)) {
#line 241
          return ((ngx_int_t )-6);
        }
#line 244
        chain->buf = b;
#line 245
        chain->next = (ngx_chain_t *)((void *)0);
      } else
#line 247
      if (! p->cacheable) {
#line 247
        if ((unsigned long )(p->downstream)->data == (unsigned long )p->output_ctx) {
#line 247
          if (((p->downstream)->write)->ready) {
#line 247
            if (! ((p->downstream)->write)->delayed) {
#line 257
              p->upstream_blocked = 1U;
#line 262
              goto while_break;
            } else {
#line 247
              goto _L___2;
            }
          } else {
#line 247
            goto _L___2;
          }
        } else {
#line 247
          goto _L___2;
        }
      } else
      _L___2: /* CIL Label */ 
#line 264
      if (p->cacheable) {
#line 264
        goto _L;
      } else
#line 264
      if ((p->temp_file)->offset < p->max_temp_file_size) {
        _L: /* CIL Label */ 
        {
#line 273
        rc = ngx_event_pipe_write_chain_to_temp_file(p);
        }
#line 278
        if (rc == -3L) {
#line 279
          goto while_break;
        }
#line 282
        if (rc != 0L) {
#line 283
          return (rc);
        }
#line 286
        chain = p->free_raw_bufs;
#line 287
        if (p->single_buf) {
#line 288
          p->free_raw_bufs = (p->free_raw_bufs)->next;
#line 289
          chain->next = (ngx_chain_t *)((void *)0);
        } else {
#line 291
          p->free_raw_bufs = (ngx_chain_t *)((void *)0);
        }
      } else {
#line 301
        goto while_break;
      }
      {
#line 304
      n = (*((p->upstream)->recv_chain))(p->upstream, chain, limit);
      }
#line 309
      if (p->free_raw_bufs) {
#line 310
        chain->next = p->free_raw_bufs;
      }
#line 312
      p->free_raw_bufs = chain;
#line 314
      if (n == -1L) {
#line 315
        p->upstream_error = 1U;
#line 316
        goto while_break;
      }
#line 319
      if (n == -2L) {
#line 320
        if (p->single_buf) {
          {
#line 321
          ngx_event_pipe_remove_shadow_links(chain->buf);
          }
        }
#line 324
        goto while_break;
      }
#line 327
      p->read = 1U;
#line 329
      if (n == 0L) {
#line 330
        p->upstream_eof = 1U;
#line 331
        goto while_break;
      }
    }
#line 335
    if (p->limit_rate) {
#line 335
      delay = ((ngx_msec_t )n * 1000UL) / p->limit_rate;
    } else {
#line 335
      delay = (ngx_msec_t )0;
    }
#line 337
    p->read_length += n;
#line 338
    cl = chain;
#line 339
    p->free_raw_bufs = (ngx_chain_t *)((void *)0);
    {
#line 341
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 341
      if (cl) {
#line 341
        if (! (n > 0L)) {
#line 341
          goto while_break___0;
        }
      } else {
#line 341
        goto while_break___0;
      }
      {
#line 343
      ngx_event_pipe_remove_shadow_links(cl->buf);
#line 345
      size = (cl->buf)->end - (cl->buf)->last;
      }
#line 347
      if (n >= size) {
        {
#line 348
        (cl->buf)->last = (cl->buf)->end;
#line 350
        tmp = p->num;
#line 350
        (p->num) ++;
#line 350
        (cl->buf)->num = tmp;
#line 352
        tmp___0 = (*(p->input_filter))(p, cl->buf);
        }
#line 352
        if (tmp___0 == -1L) {
#line 353
          return ((ngx_int_t )-6);
        }
#line 356
        n -= size;
#line 357
        ln = cl;
#line 358
        cl = cl->next;
#line 359
        ln->next = (p->pool)->chain;
#line 359
        (p->pool)->chain = ln;
      } else {
#line 362
        (cl->buf)->last += n;
#line 363
        n = (ssize_t )0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 367
    if (cl) {
#line 368
      ln = cl;
      {
#line 368
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 368
        if (! ln->next) {
#line 368
          goto while_break___1;
        }
#line 368
        ln = ln->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 370
      ln->next = p->free_raw_bufs;
#line 371
      p->free_raw_bufs = cl;
    }
#line 374
    if (delay > 0UL) {
      {
#line 375
      ((p->upstream)->read)->delayed = 1U;
#line 376
      ngx_event_add_timer((p->upstream)->read, delay);
      }
#line 377
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 440
  if (p->free_raw_bufs) {
#line 440
    if (p->length != -1L) {
#line 441
      cl = p->free_raw_bufs;
#line 443
      if ((cl->buf)->last - (cl->buf)->pos >= p->length) {
        {
#line 445
        p->free_raw_bufs = cl->next;
#line 447
        tmp___1 = p->num;
#line 447
        (p->num) ++;
#line 447
        (cl->buf)->num = tmp___1;
#line 449
        tmp___2 = (*(p->input_filter))(p, cl->buf);
        }
#line 449
        if (tmp___2 == -1L) {
#line 450
          return ((ngx_int_t )-6);
        }
#line 453
        cl->next = (p->pool)->chain;
#line 453
        (p->pool)->chain = cl;
      }
    }
  }
#line 457
  if (p->length == 0L) {
#line 458
    p->upstream_done = 1U;
#line 459
    p->read = 1U;
  }
#line 462
  if (p->upstream_eof) {
#line 462
    goto _L___3;
  } else
#line 462
  if (p->upstream_error) {
    _L___3: /* CIL Label */ 
#line 462
    if (p->free_raw_bufs) {
      {
#line 464
      tmp___3 = p->num;
#line 464
      (p->num) ++;
#line 464
      ((p->free_raw_bufs)->buf)->num = tmp___3;
#line 466
      tmp___4 = (*(p->input_filter))(p, (p->free_raw_bufs)->buf);
      }
#line 466
      if (tmp___4 == -1L) {
#line 467
        return ((ngx_int_t )-6);
      }
#line 470
      p->free_raw_bufs = (p->free_raw_bufs)->next;
#line 472
      if (p->free_bufs) {
#line 472
        if ((unsigned long )p->buf_to_file == (unsigned long )((void *)0)) {
#line 473
          cl = p->free_raw_bufs;
          {
#line 473
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 473
            if (! cl) {
#line 473
              goto while_break___2;
            }
#line 474
            if ((unsigned long )(cl->buf)->shadow == (unsigned long )((void *)0)) {
              {
#line 475
              ngx_pfree(p->pool, (void *)(cl->buf)->start);
              }
            }
#line 473
            cl = cl->next;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
    }
  }
#line 481
  if (p->cacheable) {
#line 481
    if (p->in) {
#line 481
      goto _L___4;
    } else
#line 481
    if (p->buf_to_file) {
      _L___4: /* CIL Label */ 
      {
#line 486
      rc = ngx_event_pipe_write_chain_to_temp_file(p);
      }
#line 488
      if (rc != 0L) {
#line 489
        return (rc);
      }
    }
  }
#line 493
  return ((ngx_int_t )0);
}
}
#line 497 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_write_to_downstream(ngx_event_pipe_t *p ) 
{ 
  u_char *prev ;
  size_t bsize ;
  ngx_int_t rc ;
  ngx_uint_t flush ;
  ngx_uint_t flushed ;
  ngx_uint_t prev_last_shadow ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_chain_t *cl ;
  ngx_connection_t *downstream ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_uint_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp18 ;

  {
#line 507
  downstream = p->downstream;
#line 524
  flushed = (ngx_uint_t )0;
  {
#line 526
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (p->downstream_error) {
      {
#line 528
      tmp = ngx_event_pipe_drain_chains(p);
      }
#line 528
      return (tmp);
    }
#line 531
    if (p->upstream_eof) {
#line 531
      goto _L;
    } else
#line 531
    if (p->upstream_error) {
#line 531
      goto _L;
    } else
#line 531
    if (p->upstream_done) {
      _L: /* CIL Label */ 
#line 535
      cl = p->busy;
      {
#line 535
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 535
        if (! cl) {
#line 535
          goto while_break___0;
        }
#line 536
        (cl->buf)->recycled = 0U;
#line 535
        cl = cl->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 539
      if (p->out) {
#line 543
        cl = p->out;
        {
#line 543
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 543
          if (! cl) {
#line 543
            goto while_break___1;
          }
#line 544
          (cl->buf)->recycled = 0U;
#line 543
          cl = cl->next;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 547
        rc = (*(p->output_filter))(p->output_ctx, p->out);
        }
#line 549
        if (rc == -1L) {
          {
#line 550
          p->downstream_error = 1U;
#line 551
          tmp___0 = ngx_event_pipe_drain_chains(p);
          }
#line 551
          return (tmp___0);
        }
#line 554
        p->out = (ngx_chain_t *)((void *)0);
      }
#line 557
      if (p->writing) {
#line 558
        goto while_break;
      }
#line 561
      if (p->in) {
#line 565
        cl = p->in;
        {
#line 565
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 565
          if (! cl) {
#line 565
            goto while_break___2;
          }
#line 566
          (cl->buf)->recycled = 0U;
#line 565
          cl = cl->next;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 569
        rc = (*(p->output_filter))(p->output_ctx, p->in);
        }
#line 571
        if (rc == -1L) {
          {
#line 572
          p->downstream_error = 1U;
#line 573
          tmp___1 = ngx_event_pipe_drain_chains(p);
          }
#line 573
          return (tmp___1);
        }
#line 576
        p->in = (ngx_chain_t *)((void *)0);
      }
#line 584
      p->downstream_done = 1U;
#line 585
      goto while_break;
    }
#line 588
    if ((unsigned long )downstream->data != (unsigned long )p->output_ctx) {
#line 592
      goto while_break;
    } else
#line 588
    if (! (downstream->write)->ready) {
#line 592
      goto while_break;
    } else
#line 588
    if ((downstream->write)->delayed) {
#line 592
      goto while_break;
    }
#line 597
    prev = (u_char *)((void *)0);
#line 598
    bsize = (size_t )0;
#line 600
    cl = p->busy;
    {
#line 600
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 600
      if (! cl) {
#line 600
        goto while_break___3;
      }
#line 602
      if ((cl->buf)->recycled) {
#line 603
        if ((unsigned long )prev == (unsigned long )(cl->buf)->start) {
#line 604
          goto __Cont;
        }
#line 607
        bsize += (size_t )((cl->buf)->end - (cl->buf)->start);
#line 608
        prev = (cl->buf)->start;
      }
      __Cont: /* CIL Label */ 
#line 600
      cl = cl->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 615
    out = (ngx_chain_t *)((void *)0);
#line 617
    if (bsize >= (size_t )p->busy_size) {
#line 618
      flush = (ngx_uint_t )1;
#line 619
      goto flush;
    }
#line 622
    flush = (ngx_uint_t )0;
#line 623
    ll = (ngx_chain_t **)((void *)0);
#line 624
    prev_last_shadow = (ngx_uint_t )1;
    {
#line 626
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 627
      if (p->out) {
#line 628
        cl = p->out;
#line 630
        if ((cl->buf)->recycled) {
#line 631
          if ((p->log)->log_level >= 2UL) {
            {
#line 631
            ngx_log_error_core((ngx_uint_t )2, p->log, 0, "recycled buffer in pipe out chain");
            }
          }
        }
#line 635
        p->out = (p->out)->next;
      } else
#line 637
      if (! p->cacheable) {
#line 637
        if (! p->writing) {
#line 637
          if (p->in) {
#line 638
            cl = p->in;
#line 646
            if ((cl->buf)->recycled) {
#line 646
              if (prev_last_shadow) {
#line 647
                if (((cl->buf)->end + bsize) - (cl->buf)->start > p->busy_size) {
#line 648
                  flush = (ngx_uint_t )1;
#line 649
                  goto while_break___4;
                }
#line 652
                bsize += (size_t )((cl->buf)->end - (cl->buf)->start);
              }
            }
#line 655
            prev_last_shadow = (ngx_uint_t )(cl->buf)->last_shadow;
#line 657
            p->in = (p->in)->next;
          } else {
#line 660
            goto while_break___4;
          }
        } else {
#line 660
          goto while_break___4;
        }
      } else {
#line 660
        goto while_break___4;
      }
#line 663
      cl->next = (ngx_chain_t *)((void *)0);
#line 665
      if (out) {
#line 666
        *ll = cl;
      } else {
#line 668
        out = cl;
      }
#line 670
      ll = & cl->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    flush: ;
#line 678
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 680
      if (! flush) {
#line 681
        goto while_break;
      }
#line 685
      tmp___2 = flushed;
#line 685
      flushed ++;
#line 685
      if (tmp___2 > 10UL) {
#line 686
        return ((ngx_int_t )-3);
      }
    }
    {
#line 690
    rc = (*(p->output_filter))(p->output_ctx, out);
#line 692
    ngx_chain_update_chains(p->pool, & p->free, & p->busy, & out, p->tag);
    }
#line 694
    if (rc == -1L) {
      {
#line 695
      p->downstream_error = 1U;
#line 696
      tmp___3 = ngx_event_pipe_drain_chains(p);
      }
#line 696
      return (tmp___3);
    }
#line 699
    cl = p->free;
    {
#line 699
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 699
      if (! cl) {
#line 699
        goto while_break___5;
      }
#line 701
      if ((cl->buf)->temp_file) {
#line 702
        if (p->cacheable) {
#line 703
          goto __Cont___0;
        } else
#line 702
        if (! p->cyclic_temp_file) {
#line 703
          goto __Cont___0;
        }
#line 708
        if ((cl->buf)->file_last == (p->temp_file)->offset) {
#line 709
          (p->temp_file)->offset = (off_t )0;
        }
      }
#line 717
      if ((cl->buf)->last_shadow) {
        {
#line 718
        tmp___4 = ngx_event_pipe_add_free_buf(p, (cl->buf)->shadow);
        }
#line 718
        if (tmp___4 != 0L) {
#line 719
          return ((ngx_int_t )-6);
        }
#line 722
        (cl->buf)->last_shadow = 0U;
      }
#line 725
      (cl->buf)->shadow = (ngx_buf_t *)((void *)0);
      __Cont___0: /* CIL Label */ 
#line 699
      cl = cl->next;
    }
    while_break___5: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 729
  return ((ngx_int_t )0);
}
}
#line 733 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_write_chain_to_temp_file(ngx_event_pipe_t *p ) 
{ 
  ssize_t size ;
  ssize_t bsize ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_uint_t prev_last_shadow ;
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_chain_t *next ;
  ngx_chain_t *out ;
  ngx_chain_t **ll ;
  ngx_chain_t **last_out ;
  ngx_chain_t **last_free ;

  {
#line 763
  if (p->buf_to_file) {
    {
#line 764
    out = ngx_alloc_chain_link(p->pool);
    }
#line 765
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 766
      return ((ngx_int_t )-6);
    }
#line 769
    out->buf = p->buf_to_file;
#line 770
    out->next = p->in;
  } else {
#line 773
    out = p->in;
  }
#line 776
  if (! p->cacheable) {
#line 778
    size = (ssize_t )0;
#line 779
    cl = out;
#line 780
    ll = (ngx_chain_t **)((void *)0);
#line 781
    prev_last_shadow = (ngx_uint_t )1;
    {
#line 786
    while (1) {
      while_continue: /* CIL Label */ ;
#line 787
      bsize = (cl->buf)->last - (cl->buf)->pos;
#line 794
      if (prev_last_shadow) {
#line 794
        if (size + bsize > p->temp_file_write_size) {
#line 799
          goto while_break;
        } else
#line 794
        if (((p->temp_file)->offset + size) + bsize > p->max_temp_file_size) {
#line 799
          goto while_break;
        }
      }
#line 802
      prev_last_shadow = (ngx_uint_t )(cl->buf)->last_shadow;
#line 804
      size += bsize;
#line 805
      ll = & cl->next;
#line 806
      cl = cl->next;
#line 786
      if (! cl) {
#line 786
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 812
    if ((unsigned long )ll == (unsigned long )((void *)0)) {
#line 813
      return ((ngx_int_t )-3);
    }
#line 816
    if (cl) {
#line 817
      p->in = cl;
#line 818
      *ll = (ngx_chain_t *)((void *)0);
    } else {
#line 821
      p->in = (ngx_chain_t *)((void *)0);
#line 822
      p->last_in = & p->in;
    }
  } else {
#line 826
    p->in = (ngx_chain_t *)((void *)0);
#line 827
    p->last_in = & p->in;
  }
  {
#line 839
  n = ngx_write_chain_to_temp_file(p->temp_file, out);
  }
#line 841
  if (n == -1L) {
#line 842
    return ((ngx_int_t )-6);
  }
#line 857
  if (p->buf_to_file) {
#line 858
    (p->temp_file)->offset = (p->buf_to_file)->last - (p->buf_to_file)->pos;
#line 859
    n -= (p->buf_to_file)->last - (p->buf_to_file)->pos;
#line 860
    p->buf_to_file = (ngx_buf_t *)((void *)0);
#line 861
    out = out->next;
  }
#line 864
  if (n > 0L) {
#line 867
    if (p->out) {
#line 868
      cl = p->out;
      {
#line 868
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 868
        if (! cl->next) {
#line 868
          goto while_break___0;
        }
#line 868
        cl = cl->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 870
      b = cl->buf;
#line 872
      if (b->file_last == (p->temp_file)->offset) {
#line 873
        (p->temp_file)->offset += n;
#line 874
        b->file_last = (p->temp_file)->offset;
#line 875
        goto free;
      }
#line 878
      last_out = & cl->next;
    } else {
#line 881
      last_out = & p->out;
    }
    {
#line 884
    cl = ngx_chain_get_free_buf(p->pool, & p->free);
    }
#line 885
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 886
      return ((ngx_int_t )-6);
    }
    {
#line 889
    b = cl->buf;
#line 891
    memset((void *)b, 0, sizeof(ngx_buf_t ));
#line 893
    b->tag = p->tag;
#line 895
    b->file = & (p->temp_file)->file;
#line 896
    b->file_pos = (p->temp_file)->offset;
#line 897
    (p->temp_file)->offset += n;
#line 898
    b->file_last = (p->temp_file)->offset;
#line 900
    b->in_file = 1U;
#line 901
    b->temp_file = 1U;
#line 903
    *last_out = cl;
    }
  }
  free: 
#line 908
  last_free = & p->free_raw_bufs;
  {
#line 908
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 908
    if (! ((unsigned long )*last_free != (unsigned long )((void *)0))) {
#line 908
      goto while_break___1;
    }
#line 908
    last_free = & (*last_free)->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 915
  cl = out;
  {
#line 915
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 915
    if (! cl) {
#line 915
      goto while_break___2;
    }
#line 916
    next = cl->next;
#line 918
    cl->next = p->free;
#line 919
    p->free = cl;
#line 921
    b = cl->buf;
#line 923
    if (b->last_shadow) {
      {
#line 925
      tl = ngx_alloc_chain_link(p->pool);
      }
#line 926
      if ((unsigned long )tl == (unsigned long )((void *)0)) {
#line 927
        return ((ngx_int_t )-6);
      }
      {
#line 930
      tl->buf = b->shadow;
#line 931
      tl->next = (ngx_chain_t *)((void *)0);
#line 933
      *last_free = tl;
#line 934
      last_free = & tl->next;
#line 936
      (b->shadow)->pos = (b->shadow)->start;
#line 937
      (b->shadow)->last = (b->shadow)->start;
#line 939
      ngx_event_pipe_remove_shadow_links(b->shadow);
      }
    }
#line 915
    cl = next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 943
  return ((ngx_int_t )0);
}
}
#line 949 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
ngx_int_t ngx_event_pipe_copy_input_filter(ngx_event_pipe_t *p , ngx_buf_t *buf ) 
{ 
  ngx_buf_t *b ;
  ngx_chain_t *cl ;

  {
#line 955
  if ((unsigned long )buf->pos == (unsigned long )buf->last) {
#line 956
    return ((ngx_int_t )0);
  }
  {
#line 959
  cl = ngx_chain_get_free_buf(p->pool, & p->free);
  }
#line 960
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 961
    return ((ngx_int_t )-1);
  }
  {
#line 964
  b = cl->buf;
#line 966
  memcpy((void */* __restrict  */)b, (void const   */* __restrict  */)buf, sizeof(ngx_buf_t ));
#line 967
  b->shadow = buf;
#line 968
  b->tag = p->tag;
#line 969
  b->last_shadow = 1U;
#line 970
  b->recycled = 1U;
#line 971
  buf->shadow = b;
  }
#line 975
  if (p->in) {
#line 976
    *(p->last_in) = cl;
  } else {
#line 978
    p->in = cl;
  }
#line 980
  p->last_in = & cl->next;
#line 982
  if (p->length == -1L) {
#line 983
    return ((ngx_int_t )0);
  }
#line 986
  p->length -= b->last - b->pos;
#line 988
  return ((ngx_int_t )0);
}
}
#line 992 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
__inline static void ngx_event_pipe_remove_shadow_links(ngx_buf_t *buf ) 
{ 
  ngx_buf_t *b ;
  ngx_buf_t *next ;

  {
#line 997
  b = buf->shadow;
#line 999
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1000
    return;
  }
  {
#line 1003
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1003
    if (! (! b->last_shadow)) {
#line 1003
      goto while_break;
    }
#line 1004
    next = b->shadow;
#line 1006
    b->temporary = 0U;
#line 1007
    b->recycled = 0U;
#line 1009
    b->shadow = (ngx_buf_t *)((void *)0);
#line 1010
    b = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  b->temporary = 0U;
#line 1014
  b->recycled = 0U;
#line 1015
  b->last_shadow = 0U;
#line 1017
  b->shadow = (ngx_buf_t *)((void *)0);
#line 1019
  buf->shadow = (ngx_buf_t *)((void *)0);
#line 1020
  return;
}
}
#line 1023 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
ngx_int_t ngx_event_pipe_add_free_buf(ngx_event_pipe_t *p , ngx_buf_t *b ) 
{ 
  ngx_chain_t *cl ;

  {
  {
#line 1028
  cl = ngx_alloc_chain_link(p->pool);
  }
#line 1029
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 1030
    return ((ngx_int_t )-1);
  }
#line 1033
  if (p->buf_to_file) {
#line 1033
    if ((unsigned long )b->start == (unsigned long )(p->buf_to_file)->start) {
#line 1034
      b->pos = (p->buf_to_file)->last;
#line 1035
      b->last = (p->buf_to_file)->last;
    } else {
#line 1038
      b->pos = b->start;
#line 1039
      b->last = b->start;
    }
  } else {
#line 1038
    b->pos = b->start;
#line 1039
    b->last = b->start;
  }
#line 1042
  b->shadow = (ngx_buf_t *)((void *)0);
#line 1044
  cl->buf = b;
#line 1046
  if ((unsigned long )p->free_raw_bufs == (unsigned long )((void *)0)) {
#line 1047
    p->free_raw_bufs = cl;
#line 1048
    cl->next = (ngx_chain_t *)((void *)0);
#line 1050
    return ((ngx_int_t )0);
  }
#line 1053
  if ((unsigned long )((p->free_raw_bufs)->buf)->pos == (unsigned long )((p->free_raw_bufs)->buf)->last) {
#line 1057
    cl->next = p->free_raw_bufs;
#line 1058
    p->free_raw_bufs = cl;
#line 1060
    return ((ngx_int_t )0);
  }
#line 1065
  cl->next = (p->free_raw_bufs)->next;
#line 1066
  (p->free_raw_bufs)->next = cl;
#line 1068
  return ((ngx_int_t )0);
}
}
#line 1072 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_pipe.c"
static ngx_int_t ngx_event_pipe_drain_chains(ngx_event_pipe_t *p ) 
{ 
  ngx_chain_t *cl ;
  ngx_chain_t *tl ;
  ngx_int_t tmp ;

  {
  {
#line 1077
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1078
    if (p->busy) {
#line 1079
      cl = p->busy;
#line 1080
      p->busy = (ngx_chain_t *)((void *)0);
    } else
#line 1082
    if (p->out) {
#line 1083
      cl = p->out;
#line 1084
      p->out = (ngx_chain_t *)((void *)0);
    } else
#line 1086
    if (p->in) {
#line 1087
      cl = p->in;
#line 1088
      p->in = (ngx_chain_t *)((void *)0);
    } else {
#line 1091
      return ((ngx_int_t )0);
    }
    {
#line 1094
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1094
      if (! cl) {
#line 1094
        goto while_break___0;
      }
#line 1095
      if ((cl->buf)->last_shadow) {
        {
#line 1096
        tmp = ngx_event_pipe_add_free_buf(p, (cl->buf)->shadow);
        }
#line 1096
        if (tmp != 0L) {
#line 1097
          return ((ngx_int_t )-6);
        }
#line 1100
        (cl->buf)->last_shadow = 0U;
      }
#line 1103
      (cl->buf)->shadow = (ngx_buf_t *)((void *)0);
#line 1104
      tl = cl->next;
#line 1105
      cl->next = p->free;
#line 1106
      p->free = cl;
#line 1107
      cl = tl;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
/* compiler builtin: 
   void __attribute__((__overloaded__))  __sync_fetch_and_add(...) ;  */
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  * __restrict  __addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  * __restrict  __addr , socklen_t __len ) ;
#line 467 "src/event/ngx_event.h"
ngx_atomic_t *ngx_connection_counter ;
#line 75 "src/event/ngx_event_connect.h"
ngx_int_t ngx_event_get_peer(ngx_peer_connection_t *pc , void *data ) ;
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_connect.c"
static ngx_int_t ngx_event_connect_set_transparent(ngx_peer_connection_t *pc , ngx_socket_t s ) ;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_connect.c"
ngx_int_t ngx_event_connect_peer(ngx_peer_connection_t *pc ) 
{ 
  int rc ;
  int type ;
  in_port_t port ;
  ngx_int_t event ;
  ngx_err_t err ;
  ngx_uint_t level ;
  ngx_socket_t s ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  ngx_int_t tmp___7 ;
  int reuse_addr ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  ngx_atomic_t tmp___12 ;
  ngx_int_t tmp___13 ;
  int *tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  ngx_int_t tmp___17 ;
  ngx_int_t tmp___18 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;

  {
  {
#line 34
  tmp = (*(pc->get))(pc, pc->data);
#line 34
  rc = (int )tmp;
  }
#line 35
  if (rc != 0) {
#line 36
    return ((ngx_int_t )rc);
  }
#line 39
  if (pc->type) {
#line 39
    type = pc->type;
  } else {
#line 39
    type = 1;
  }
  {
#line 41
  s = socket((int )(pc->sockaddr)->sa_family, type, 0);
  }
#line 46
  if (s == -1) {
#line 47
    if ((pc->log)->log_level >= 2UL) {
      {
#line 47
      tmp___0 = __errno_location();
#line 47
      ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___0, "socket() failed");
      }
    }
#line 49
    return ((ngx_int_t )-1);
  }
  {
#line 53
  c = ngx_get_connection(s, pc->log);
  }
#line 55
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 56
    tmp___2 = close(s);
    }
#line 56
    if (tmp___2 == -1) {
#line 57
      if ((pc->log)->log_level >= 2UL) {
        {
#line 57
        tmp___1 = __errno_location();
#line 57
        ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___1, "close() socketfailed");
        }
      }
    }
#line 61
    return ((ngx_int_t )-1);
  }
#line 64
  c->type = type;
#line 66
  if (pc->rcvbuf) {
    {
#line 67
    tmp___4 = setsockopt(s, 1, 8, (void const   *)(& pc->rcvbuf), (socklen_t )sizeof(int ));
    }
#line 67
    if (tmp___4 == -1) {
#line 70
      if ((pc->log)->log_level >= 2UL) {
        {
#line 70
        tmp___3 = __errno_location();
#line 70
        ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___3, "setsockopt(SO_RCVBUF) failed");
        }
      }
#line 72
      goto failed;
    }
  }
  {
#line 76
  tmp___6 = ngx_nonblocking(s);
  }
#line 76
  if (tmp___6 == -1) {
#line 77
    if ((pc->log)->log_level >= 2UL) {
      {
#line 77
      tmp___5 = __errno_location();
#line 77
      ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___5, "ioctl(FIONBIO) failed");
      }
    }
#line 80
    goto failed;
  }
#line 83
  if (pc->local) {
#line 86
    if (pc->transparent) {
      {
#line 87
      tmp___7 = ngx_event_connect_set_transparent(pc, s);
      }
#line 87
      if (tmp___7 != 0L) {
#line 88
        goto failed;
      }
    }
    {
#line 94
    port = ngx_inet_get_port((pc->local)->sockaddr);
    }
#line 125
    if (pc->type == 2) {
#line 125
      if ((int )port != 0) {
        {
#line 126
        reuse_addr = 1;
#line 128
        tmp___9 = setsockopt(s, 1, 2, (void const   *)(& reuse_addr), (socklen_t )sizeof(int ));
        }
#line 128
        if (tmp___9 == -1) {
#line 132
          if ((pc->log)->log_level >= 2UL) {
            {
#line 132
            tmp___8 = __errno_location();
#line 132
            ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___8, "setsockopt(SO_REUSEADDR) failed");
            }
          }
#line 134
          goto failed;
        }
      }
    }
    {
#line 140
    tmp___11 = bind(s, (struct sockaddr  const  */* __restrict  */)(pc->local)->sockaddr,
                    (pc->local)->socklen);
    }
#line 140
    if (tmp___11 == -1) {
#line 141
      if ((pc->log)->log_level >= 3UL) {
        {
#line 141
        tmp___10 = __errno_location();
#line 141
        ngx_log_error_core((ngx_uint_t )3, pc->log, *tmp___10, "bind(%V) failed",
                           & (pc->local)->name);
        }
      }
#line 144
      goto failed;
    }
  }
#line 148
  if (type == 1) {
#line 149
    c->recv = ngx_io.recv;
#line 150
    c->send = ngx_io.send;
#line 151
    c->recv_chain = ngx_io.recv_chain;
#line 152
    c->send_chain = ngx_io.send_chain;
#line 154
    c->sendfile = 1U;
#line 156
    if ((int )(pc->sockaddr)->sa_family == 1) {
#line 157
      c->tcp_nopush = 2U;
#line 158
      c->tcp_nodelay = 2U;
    }
  } else {
#line 167
    c->recv = ngx_io.udp_recv;
#line 168
    c->send = ngx_io.send;
#line 169
    c->send_chain = ngx_io.udp_send_chain;
  }
  {
#line 172
  c->log_error = pc->log_error;
#line 174
  rev = c->read;
#line 175
  wev = c->write;
#line 177
  rev->log = pc->log;
#line 178
  wev->log = pc->log;
#line 180
  pc->connection = c;
#line 182
  tmp___12 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, (ngx_atomic_t )1);
#line 182
  c->number = (ngx_atomic_uint_t )tmp___12;
  }
#line 184
  if (ngx_event_actions.add_conn) {
    {
#line 185
    tmp___13 = (*(ngx_event_actions.add_conn))(c);
    }
#line 185
    if (tmp___13 == -1L) {
#line 186
      goto failed;
    }
  }
  {
#line 193
  rc = connect(s, (struct sockaddr  const  */* __restrict  */)pc->sockaddr, pc->socklen);
  }
#line 195
  if (rc == -1) {
    {
#line 196
    tmp___14 = __errno_location();
#line 196
    err = *tmp___14;
    }
#line 199
    if (err != 115) {
#line 206
      if (err == 111) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 11) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 104) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 100) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 101) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 112) {
#line 220
        level = (ngx_uint_t )4;
      } else
#line 206
      if (err == 113) {
#line 220
        level = (ngx_uint_t )4;
      } else {
#line 223
        level = (ngx_uint_t )3;
      }
#line 226
      if ((c->log)->log_level >= level) {
        {
#line 226
        ngx_log_error_core(level, c->log, err, "connect() to %V failed", pc->name);
        }
      }
      {
#line 229
      ngx_close_connection(c);
#line 230
      pc->connection = (ngx_connection_t *)((void *)0);
      }
#line 232
      return ((ngx_int_t )-5);
    }
  }
#line 236
  if (ngx_event_actions.add_conn) {
#line 237
    if (rc == -1) {
#line 241
      return ((ngx_int_t )-2);
    }
#line 246
    wev->ready = 1U;
#line 248
    return ((ngx_int_t )0);
  }
#line 251
  if (ngx_event_flags & 512UL) {
    {
#line 256
    tmp___16 = ngx_blocking(s);
    }
#line 256
    if (tmp___16 == -1) {
#line 257
      if ((pc->log)->log_level >= 2UL) {
        {
#line 257
        tmp___15 = __errno_location();
#line 257
        ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp___15, "ioctl(!FIONBIO) failed");
        }
      }
#line 259
      goto failed;
    }
#line 269
    rev->ready = 1U;
#line 270
    wev->ready = 1U;
#line 272
    return ((ngx_int_t )0);
  }
#line 275
  if (ngx_event_flags & 4UL) {
#line 279
    event = (ngx_int_t )2147483648U;
  } else {
#line 285
    event = (ngx_int_t )0;
  }
  {
#line 288
  tmp___17 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )event);
  }
#line 288
  if (tmp___17 != 0L) {
#line 289
    goto failed;
  }
#line 292
  if (rc == -1) {
    {
#line 296
    tmp___18 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )event);
    }
#line 296
    if (tmp___18 != 0L) {
#line 297
      goto failed;
    }
#line 300
    return ((ngx_int_t )-2);
  }
#line 305
  wev->ready = 1U;
#line 307
  return ((ngx_int_t )0);
  failed: 
  {
#line 311
  ngx_close_connection(c);
#line 312
  pc->connection = (ngx_connection_t *)((void *)0);
  }
#line 314
  return ((ngx_int_t )-1);
}
}
#line 320 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_connect.c"
static ngx_int_t ngx_event_connect_set_transparent(ngx_peer_connection_t *pc , ngx_socket_t s ) 
{ 
  int value ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 325
  value = 1;
  {
#line 341
  if ((int )((pc->local)->sockaddr)->sa_family == 2) {
#line 341
    goto case_2;
  }
#line 369
  if ((int )((pc->local)->sockaddr)->sa_family == 10) {
#line 369
    goto case_10;
  }
#line 339
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 345
  tmp___0 = setsockopt(s, 0, 19, (void const   *)(& value), (socklen_t )sizeof(int ));
  }
#line 345
  if (tmp___0 == -1) {
#line 348
    if ((pc->log)->log_level >= 2UL) {
      {
#line 348
      tmp = __errno_location();
#line 348
      ngx_log_error_core((ngx_uint_t )2, pc->log, *tmp, "setsockopt(IP_TRANSPARENT) failed");
      }
    }
#line 350
    return ((ngx_int_t )-1);
  }
#line 365
  goto switch_break;
  case_10: /* CIL Label */ 
#line 392
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 400
  return ((ngx_int_t )0);
}
}
#line 406 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_connect.c"
ngx_int_t ngx_event_get_peer(ngx_peer_connection_t *pc , void *data ) 
{ 


  {
#line 409
  return ((ngx_int_t )0);
}
}
#line 272 "/usr/include/x86_64-linux-gnu/bits/socket.h"
extern  __attribute__((__nothrow__)) struct cmsghdr *( __attribute__((__leaf__)) __cmsg_nxthdr)(struct msghdr *__mhdr ,
                                                                                                struct cmsghdr *__cmsg ) ;
#line 243 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 251
extern int accept4(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ,
                   int __flags ) ;
#line 43 "src/core/ngx_shmtx.h"
ngx_uint_t ngx_shmtx_trylock(ngx_shmtx_t *mtx ) ;
#line 472 "src/event/ngx_event.h"
ngx_uint_t ngx_accept_events ;
#line 473
ngx_uint_t ngx_accept_mutex_held ;
#line 475
ngx_int_t ngx_accept_disabled ;
#line 506
void ngx_event_accept(ngx_event_t *ev ) ;
#line 508
void ngx_event_recvmsg(ngx_event_t *ev ) ;
#line 510
ngx_int_t ngx_trylock_accept_mutex(ngx_cycle_t *cycle ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
static ngx_int_t ngx_enable_accept_events(ngx_cycle_t *cycle ) ;
#line 14
static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle , ngx_uint_t all ) ;
#line 15
static void ngx_close_accepted_connection(ngx_connection_t *c ) ;
#line 36 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
static ngx_uint_t use_accept4  =    (ngx_uint_t )1;
#line 22 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
void ngx_event_accept(ngx_event_t *ev ) 
{ 
  socklen_t socklen ;
  ngx_err_t err ;
  ngx_log_t *log ;
  ngx_uint_t level ;
  ngx_socket_t s ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_sockaddr_t sa ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  ngx_connection_t *lc ;
  ngx_event_conf_t *ecf ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  char const   *tmp___1 ;
  ngx_int_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  ngx_atomic_t tmp___11 ;
  void *tmp___12 ;
  ngx_int_t tmp___13 ;
  void *__cil_tmp29 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 39
  if (ev->timedout) {
    {
#line 40
    tmp = ngx_enable_accept_events((ngx_cycle_t *)ngx_cycle);
    }
#line 40
    if (tmp != 0L) {
#line 41
      return;
    }
#line 44
    ev->timedout = 0U;
  }
#line 47
  ecf = (ngx_event_conf_t *)*(*(*(ngx_cycle->conf_ctx + ngx_events_module.index)) + ngx_event_core_module.ctx_index);
#line 49
  if (! (ngx_event_flags & 8UL)) {
#line 50
    ev->available = (unsigned int )ecf->multi_accept;
  }
#line 53
  lc = (ngx_connection_t *)ev->data;
#line 54
  ls = lc->listening;
#line 55
  ev->ready = 0U;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 61
    socklen = (socklen_t )sizeof(ngx_sockaddr_t );
#line 64
    if (use_accept4) {
      {
#line 65
      s = accept4(lc->fd, (struct sockaddr */* __restrict  */)(& sa.sockaddr), (socklen_t */* __restrict  */)(& socklen),
                  2048);
      }
    } else {
      {
#line 67
      s = accept(lc->fd, (struct sockaddr */* __restrict  */)(& sa.sockaddr), (socklen_t */* __restrict  */)(& socklen));
      }
    }
#line 73
    if (s == -1) {
      {
#line 74
      tmp___0 = __errno_location();
#line 74
      err = *tmp___0;
      }
#line 76
      if (err == 11) {
#line 79
        return;
      }
#line 82
      level = (ngx_uint_t )2;
#line 84
      if (err == 103) {
#line 85
        level = (ngx_uint_t )4;
      } else
#line 87
      if (err == 24) {
#line 88
        level = (ngx_uint_t )3;
      } else
#line 87
      if (err == 23) {
#line 88
        level = (ngx_uint_t )3;
      }
#line 92
      if ((ev->log)->log_level >= level) {
#line 92
        if (use_accept4) {
#line 92
          tmp___1 = "accept4() failed";
        } else {
#line 92
          tmp___1 = "accept() failed";
        }
        {
#line 92
        ngx_log_error_core(level, ev->log, err, tmp___1);
        }
      }
#line 95
      if (use_accept4) {
#line 95
        if (err == 38) {
#line 96
          use_accept4 = (ngx_uint_t )0;
#line 97
          ngx_inherited_nonblocking = (ngx_uint_t )0;
#line 98
          goto __Cont;
        }
      }
#line 104
      if (err == 103) {
#line 105
        if (ngx_event_flags & 8UL) {
#line 106
          (ev->available) --;
        }
#line 109
        if (ev->available) {
#line 110
          goto __Cont;
        }
      }
#line 114
      if (err == 24) {
#line 114
        goto _L;
      } else
#line 114
      if (err == 23) {
        _L: /* CIL Label */ 
        {
#line 115
        tmp___2 = ngx_disable_accept_events((ngx_cycle_t *)ngx_cycle, (ngx_uint_t )1);
        }
#line 115
        if (tmp___2 != 0L) {
#line 118
          return;
        }
#line 121
        if (ngx_use_accept_mutex) {
#line 122
          if (ngx_accept_mutex_held) {
            {
#line 123
            ngx_shmtx_unlock(& ngx_accept_mutex);
#line 124
            ngx_accept_mutex_held = (ngx_uint_t )0;
            }
          }
#line 127
          ngx_accept_disabled = (ngx_int_t )1;
        } else {
          {
#line 130
          ngx_event_add_timer(ev, ecf->accept_mutex_delay);
          }
        }
      }
#line 134
      return;
    }
    {
#line 141
    ngx_accept_disabled = (ngx_int_t )(ngx_cycle->connection_n / (ngx_uint_t volatile   )8 - ngx_cycle->free_connection_n);
#line 144
    c = ngx_get_connection(s, ev->log);
    }
#line 146
    if ((unsigned long )c == (unsigned long )((void *)0)) {
      {
#line 147
      tmp___4 = close(s);
      }
#line 147
      if (tmp___4 == -1) {
#line 148
        if ((ev->log)->log_level >= 2UL) {
          {
#line 148
          tmp___3 = __errno_location();
#line 148
          ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp___3, "close() socket failed");
          }
        }
      }
#line 152
      return;
    }
    {
#line 155
    c->type = 1;
#line 161
    c->pool = ngx_create_pool(ls->pool_size, ev->log);
    }
#line 162
    if ((unsigned long )c->pool == (unsigned long )((void *)0)) {
      {
#line 163
      ngx_close_accepted_connection(c);
      }
#line 164
      return;
    }
#line 167
    if (socklen > (socklen_t )sizeof(ngx_sockaddr_t )) {
#line 168
      socklen = (socklen_t )sizeof(ngx_sockaddr_t );
    }
    {
#line 171
    tmp___5 = ngx_palloc(c->pool, (size_t )socklen);
#line 171
    c->sockaddr = (struct sockaddr *)tmp___5;
    }
#line 172
    if ((unsigned long )c->sockaddr == (unsigned long )((void *)0)) {
      {
#line 173
      ngx_close_accepted_connection(c);
      }
#line 174
      return;
    }
    {
#line 177
    memcpy((void */* __restrict  */)c->sockaddr, (void const   */* __restrict  */)(& sa),
           (size_t )socklen);
#line 179
    tmp___6 = ngx_palloc(c->pool, sizeof(ngx_log_t ));
#line 179
    log = (ngx_log_t *)tmp___6;
    }
#line 180
    if ((unsigned long )log == (unsigned long )((void *)0)) {
      {
#line 181
      ngx_close_accepted_connection(c);
      }
#line 182
      return;
    }
#line 187
    if (ngx_inherited_nonblocking) {
#line 188
      if (ngx_event_flags & 512UL) {
        {
#line 189
        tmp___8 = ngx_blocking(s);
        }
#line 189
        if (tmp___8 == -1) {
#line 190
          if ((ev->log)->log_level >= 2UL) {
            {
#line 190
            tmp___7 = __errno_location();
#line 190
            ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp___7, "ioctl(!FIONBIO) failed");
            }
          }
          {
#line 192
          ngx_close_accepted_connection(c);
          }
#line 193
          return;
        }
      }
    } else
#line 198
    if (! (ngx_event_flags & 512UL)) {
      {
#line 199
      tmp___10 = ngx_nonblocking(s);
      }
#line 199
      if (tmp___10 == -1) {
#line 200
        if ((ev->log)->log_level >= 2UL) {
          {
#line 200
          tmp___9 = __errno_location();
#line 200
          ngx_log_error_core((ngx_uint_t )2, ev->log, *tmp___9, "ioctl(FIONBIO) failed");
          }
        }
        {
#line 202
        ngx_close_accepted_connection(c);
        }
#line 203
        return;
      }
    }
#line 208
    *log = ls->log;
#line 210
    c->recv = ngx_io.recv;
#line 211
    c->send = ngx_io.send;
#line 212
    c->recv_chain = ngx_io.recv_chain;
#line 213
    c->send_chain = ngx_io.send_chain;
#line 215
    c->log = log;
#line 216
    (c->pool)->log = log;
#line 218
    c->socklen = socklen;
#line 219
    c->listening = ls;
#line 220
    c->local_sockaddr = ls->sockaddr;
#line 221
    c->local_socklen = ls->socklen;
#line 224
    if ((int )(c->sockaddr)->sa_family == 1) {
#line 225
      c->tcp_nopush = 2U;
#line 226
      c->tcp_nodelay = 2U;
    }
#line 234
    rev = c->read;
#line 235
    wev = c->write;
#line 237
    wev->ready = 1U;
#line 239
    if (ngx_event_flags & 512UL) {
#line 240
      rev->ready = 1U;
    }
#line 243
    if (ev->deferred_accept) {
#line 244
      rev->ready = 1U;
#line 246
      rev->available = 1U;
    }
    {
#line 250
    rev->log = log;
#line 251
    wev->log = log;
#line 262
    tmp___11 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, (ngx_atomic_t )1);
#line 262
    c->number = (ngx_atomic_uint_t )tmp___11;
    }
#line 268
    if (ls->addr_ntop) {
      {
#line 269
      tmp___12 = ngx_pnalloc(c->pool, ls->addr_text_max_len);
#line 269
      c->addr_text.data = (u_char *)tmp___12;
      }
#line 270
      if ((unsigned long )c->addr_text.data == (unsigned long )((void *)0)) {
        {
#line 271
        ngx_close_accepted_connection(c);
        }
#line 272
        return;
      }
      {
#line 275
      c->addr_text.len = ngx_sock_ntop(c->sockaddr, c->socklen, c->addr_text.data,
                                       ls->addr_text_max_len, (ngx_uint_t )0);
      }
#line 278
      if (c->addr_text.len == 0UL) {
        {
#line 279
        ngx_close_accepted_connection(c);
        }
#line 280
        return;
      }
    }
#line 303
    if (ngx_event_actions.add_conn) {
#line 303
      if ((ngx_event_flags & 64UL) == 0UL) {
        {
#line 304
        tmp___13 = (*(ngx_event_actions.add_conn))(c);
        }
#line 304
        if (tmp___13 == -1L) {
          {
#line 305
          ngx_close_accepted_connection(c);
          }
#line 306
          return;
        }
      }
    }
    {
#line 310
    log->data = (void *)0;
#line 311
    log->handler = (u_char *(*)(ngx_log_t *log , u_char *buf , size_t len ))((void *)0);
#line 313
    (*(ls->handler))(c);
    }
#line 315
    if (ngx_event_flags & 8UL) {
#line 316
      (ev->available) --;
    }
    __Cont: /* CIL Label */ 
#line 60
    if (! ev->available) {
#line 60
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 320
  return;
}
}
#line 338 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
static u_char buffer[65535]  ;
#line 325 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
void ngx_event_recvmsg(ngx_event_t *ev ) 
{ 
  ssize_t n ;
  ngx_log_t *log ;
  ngx_err_t err ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  struct iovec iov[1] ;
  struct msghdr msg ;
  ngx_sockaddr_t sa ;
  ngx_listening_t *ls ;
  ngx_event_conf_t *ecf ;
  ngx_connection_t *c ;
  ngx_connection_t *lc ;
  u_char msg_control[(((sizeof(struct in_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  u_char msg_control6[(((sizeof(struct in6_pktinfo ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL)) + (((sizeof(struct cmsghdr ) + sizeof(size_t )) - 1UL) & ~ (sizeof(size_t ) - 1UL))] ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  struct cmsghdr *cmsg ;
  struct sockaddr *sockaddr ;
  void *tmp___3 ;
  struct in_pktinfo *pkt ;
  struct sockaddr_in *sin ;
  struct in6_pktinfo *pkt6 ;
  struct sockaddr_in6 *sin6 ;
  void *tmp___4 ;
  ngx_atomic_t tmp___5 ;
  void *tmp___6 ;
  void *__cil_tmp30 ;
  int __cil_tmp31 ;
  void *__cil_tmp32 ;
  void *__cil_tmp33 ;
  void *__cil_tmp34 ;
  void *__cil_tmp35 ;
  void *__cil_tmp36 ;
  void *__cil_tmp37 ;
  void *__cil_tmp38 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 354
  if (ev->timedout) {
    {
#line 355
    tmp = ngx_enable_accept_events((ngx_cycle_t *)ngx_cycle);
    }
#line 355
    if (tmp != 0L) {
#line 356
      return;
    }
#line 359
    ev->timedout = 0U;
  }
#line 362
  ecf = (ngx_event_conf_t *)*(*(*(ngx_cycle->conf_ctx + ngx_events_module.index)) + ngx_event_core_module.ctx_index);
#line 364
  if (! (ngx_event_flags & 8UL)) {
#line 365
    ev->available = (unsigned int )ecf->multi_accept;
  }
#line 368
  lc = (ngx_connection_t *)ev->data;
#line 369
  ls = lc->listening;
#line 370
  ev->ready = 0U;
  {
#line 375
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 376
    memset((void *)(& msg), 0, sizeof(struct msghdr ));
#line 378
    iov[0].iov_base = (void *)(buffer);
#line 379
    iov[0].iov_len = sizeof(buffer);
#line 381
    msg.msg_name = (void *)(& sa);
#line 382
    msg.msg_namelen = (socklen_t )sizeof(ngx_sockaddr_t );
#line 383
    msg.msg_iov = iov;
#line 384
    msg.msg_iovlen = (size_t )1;
    }
#line 388
    if (ls->wildcard) {
#line 391
      if ((int )(ls->sockaddr)->sa_family == 2) {
#line 392
        msg.msg_control = (void *)(& msg_control);
#line 393
        msg.msg_controllen = sizeof(msg_control);
      }
#line 398
      if ((int )(ls->sockaddr)->sa_family == 10) {
#line 399
        msg.msg_control = (void *)(& msg_control6);
#line 400
        msg.msg_controllen = sizeof(msg_control6);
      }
    }
    {
#line 407
    n = recvmsg(lc->fd, & msg, 0);
    }
#line 409
    if (n == -1L) {
      {
#line 410
      tmp___0 = __errno_location();
#line 410
      err = *tmp___0;
      }
#line 412
      if (err == 11) {
#line 415
        return;
      }
#line 418
      if ((ev->log)->log_level >= 2UL) {
        {
#line 418
        ngx_log_error_core((ngx_uint_t )2, ev->log, err, "recvmsg() failed");
        }
      }
#line 420
      return;
    }
#line 428
    if (msg.msg_flags & 40) {
#line 429
      if ((ev->log)->log_level >= 2UL) {
        {
#line 429
        ngx_log_error_core((ngx_uint_t )2, ev->log, 0, "recvmsg() truncated data");
        }
      }
#line 431
      goto __Cont;
    }
    {
#line 435
    ngx_accept_disabled = (ngx_int_t )(ngx_cycle->connection_n / (ngx_uint_t volatile   )8 - ngx_cycle->free_connection_n);
#line 438
    c = ngx_get_connection(lc->fd, ev->log);
    }
#line 439
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 440
      return;
    }
#line 443
    c->shared = 1U;
#line 444
    c->type = 2;
#line 445
    c->socklen = msg.msg_namelen;
#line 447
    if (c->socklen > (socklen_t )sizeof(ngx_sockaddr_t )) {
#line 448
      c->socklen = (socklen_t )sizeof(ngx_sockaddr_t );
    }
    {
#line 455
    c->pool = ngx_create_pool(ls->pool_size, ev->log);
    }
#line 456
    if ((unsigned long )c->pool == (unsigned long )((void *)0)) {
      {
#line 457
      ngx_close_accepted_connection(c);
      }
#line 458
      return;
    }
    {
#line 461
    tmp___1 = ngx_palloc(c->pool, (size_t )c->socklen);
#line 461
    c->sockaddr = (struct sockaddr *)tmp___1;
    }
#line 462
    if ((unsigned long )c->sockaddr == (unsigned long )((void *)0)) {
      {
#line 463
      ngx_close_accepted_connection(c);
      }
#line 464
      return;
    }
    {
#line 467
    memcpy((void */* __restrict  */)c->sockaddr, (void const   */* __restrict  */)msg.msg_name,
           (size_t )c->socklen);
#line 469
    tmp___2 = ngx_palloc(c->pool, sizeof(ngx_log_t ));
#line 469
    log = (ngx_log_t *)tmp___2;
    }
#line 470
    if ((unsigned long )log == (unsigned long )((void *)0)) {
      {
#line 471
      ngx_close_accepted_connection(c);
      }
#line 472
      return;
    }
#line 475
    *log = ls->log;
#line 477
    c->send = ngx_io.udp_send;
#line 478
    c->send_chain = ngx_io.udp_send_chain;
#line 480
    c->log = log;
#line 481
    (c->pool)->log = log;
#line 483
    c->listening = ls;
#line 484
    c->local_sockaddr = ls->sockaddr;
#line 485
    c->local_socklen = ls->socklen;
#line 489
    if (ls->wildcard) {
      {
#line 493
      tmp___3 = ngx_palloc(c->pool, (size_t )c->local_socklen);
#line 493
      sockaddr = (struct sockaddr *)tmp___3;
      }
#line 494
      if ((unsigned long )sockaddr == (unsigned long )((void *)0)) {
        {
#line 495
        ngx_close_accepted_connection(c);
        }
#line 496
        return;
      }
      {
#line 499
      memcpy((void */* __restrict  */)sockaddr, (void const   */* __restrict  */)c->local_sockaddr,
             (size_t )c->local_socklen);
#line 500
      c->local_sockaddr = sockaddr;
      }
#line 502
      if (msg.msg_controllen >= sizeof(struct cmsghdr )) {
#line 502
        cmsg = (struct cmsghdr *)msg.msg_control;
      } else {
#line 502
        cmsg = (struct cmsghdr *)0;
      }
      {
#line 502
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 502
        if (! ((unsigned long )cmsg != (unsigned long )((void *)0))) {
#line 502
          goto while_break___0;
        }
#line 525
        if (cmsg->cmsg_level == 0) {
#line 525
          if (cmsg->cmsg_type == 8) {
#line 525
            if ((int )sockaddr->sa_family == 2) {
#line 532
              pkt = (struct in_pktinfo *)(cmsg->__cmsg_data);
#line 533
              sin = (struct sockaddr_in *)sockaddr;
#line 534
              sin->sin_addr = pkt->ipi_addr;
#line 536
              goto while_break___0;
            }
          }
        }
#line 543
        if (cmsg->cmsg_level == 41) {
#line 543
          if (cmsg->cmsg_type == 50) {
#line 543
            if ((int )sockaddr->sa_family == 10) {
#line 550
              pkt6 = (struct in6_pktinfo *)(cmsg->__cmsg_data);
#line 551
              sin6 = (struct sockaddr_in6 *)sockaddr;
#line 552
              sin6->sin6_addr = pkt6->ipi6_addr;
#line 554
              goto while_break___0;
            }
          }
        }
        {
#line 502
        cmsg = __cmsg_nxthdr(& msg, cmsg);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 564
    c->buffer = ngx_create_temp_buf(c->pool, (size_t )n);
    }
#line 565
    if ((unsigned long )c->buffer == (unsigned long )((void *)0)) {
      {
#line 566
      ngx_close_accepted_connection(c);
      }
#line 567
      return;
    }
    {
#line 570
    tmp___4 = memcpy((void */* __restrict  */)(c->buffer)->last, (void const   */* __restrict  */)(buffer),
                     (size_t )n);
#line 570
    (c->buffer)->last = (u_char *)tmp___4 + n;
#line 572
    rev = c->read;
#line 573
    wev = c->write;
#line 575
    wev->ready = 1U;
#line 577
    rev->log = log;
#line 578
    wev->log = log;
#line 589
    tmp___5 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, (ngx_atomic_t )1);
#line 589
    c->number = (ngx_atomic_uint_t )tmp___5;
    }
#line 595
    if (ls->addr_ntop) {
      {
#line 596
      tmp___6 = ngx_pnalloc(c->pool, ls->addr_text_max_len);
#line 596
      c->addr_text.data = (u_char *)tmp___6;
      }
#line 597
      if ((unsigned long )c->addr_text.data == (unsigned long )((void *)0)) {
        {
#line 598
        ngx_close_accepted_connection(c);
        }
#line 599
        return;
      }
      {
#line 602
      c->addr_text.len = ngx_sock_ntop(c->sockaddr, c->socklen, c->addr_text.data,
                                       ls->addr_text_max_len, (ngx_uint_t )0);
      }
#line 605
      if (c->addr_text.len == 0UL) {
        {
#line 606
        ngx_close_accepted_connection(c);
        }
#line 607
        return;
      }
    }
    {
#line 631
    log->data = (void *)0;
#line 632
    log->handler = (u_char *(*)(ngx_log_t *log , u_char *buf , size_t len ))((void *)0);
#line 634
    (*(ls->handler))(c);
    }
#line 636
    if (ngx_event_flags & 8UL) {
#line 637
      ev->available = (unsigned int )((ssize_t )ev->available - n);
    }
    __Cont: /* CIL Label */ 
#line 375
    if (! ev->available) {
#line 375
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  return;
}
}
#line 646 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
ngx_int_t ngx_trylock_accept_mutex(ngx_cycle_t *cycle ) 
{ 
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 649
  tmp___0 = ngx_shmtx_trylock(& ngx_accept_mutex);
  }
#line 649
  if (tmp___0) {
#line 654
    if (ngx_accept_mutex_held) {
#line 654
      if (ngx_accept_events == 0UL) {
#line 655
        return ((ngx_int_t )0);
      }
    }
    {
#line 658
    tmp = ngx_enable_accept_events(cycle);
    }
#line 658
    if (tmp == -1L) {
      {
#line 659
      ngx_shmtx_unlock(& ngx_accept_mutex);
      }
#line 660
      return ((ngx_int_t )-1);
    }
#line 663
    ngx_accept_events = (ngx_uint_t )0;
#line 664
    ngx_accept_mutex_held = (ngx_uint_t )1;
#line 666
    return ((ngx_int_t )0);
  }
#line 672
  if (ngx_accept_mutex_held) {
    {
#line 673
    tmp___1 = ngx_disable_accept_events(cycle, (ngx_uint_t )0);
    }
#line 673
    if (tmp___1 == -1L) {
#line 674
      return ((ngx_int_t )-1);
    }
#line 677
    ngx_accept_mutex_held = (ngx_uint_t )0;
  }
#line 680
  return ((ngx_int_t )0);
}
}
#line 684 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
static ngx_int_t ngx_enable_accept_events(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;

  {
#line 691
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 692
  i = (ngx_uint_t )0;
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
#line 692
    if (! (i < cycle->listening.nelts)) {
#line 692
      goto while_break;
    }
#line 694
    c = (ls + i)->connection;
#line 696
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 697
      goto __Cont;
    } else
#line 696
    if ((c->read)->active) {
#line 697
      goto __Cont;
    }
    {
#line 700
    tmp = (*(ngx_event_actions.add))(c->read, (ngx_int_t )8193, (ngx_uint_t )0);
    }
#line 700
    if (tmp == -1L) {
#line 701
      return ((ngx_int_t )-1);
    }
    __Cont: /* CIL Label */ 
#line 692
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  return ((ngx_int_t )0);
}
}
#line 709 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
static ngx_int_t ngx_disable_accept_events(ngx_cycle_t *cycle , ngx_uint_t all ) 
{ 
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  ngx_int_t tmp ;

  {
#line 716
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 717
  i = (ngx_uint_t )0;
  {
#line 717
  while (1) {
    while_continue: /* CIL Label */ ;
#line 717
    if (! (i < cycle->listening.nelts)) {
#line 717
      goto while_break;
    }
#line 719
    c = (ls + i)->connection;
#line 721
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 722
      goto __Cont;
    } else
#line 721
    if (! (c->read)->active) {
#line 722
      goto __Cont;
    }
#line 732
    if ((ls + i)->reuseport) {
#line 732
      if (! all) {
#line 733
        goto __Cont;
      }
    }
    {
#line 738
    tmp = (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )2);
    }
#line 738
    if (tmp == -1L) {
#line 741
      return ((ngx_int_t )-1);
    }
    __Cont: /* CIL Label */ 
#line 717
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 745
  return ((ngx_int_t )0);
}
}
#line 749 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
static void ngx_close_accepted_connection(ngx_connection_t *c ) 
{ 
  ngx_socket_t fd ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 754
  ngx_free_connection(c);
#line 756
  fd = c->fd;
#line 757
  c->fd = -1;
  }
#line 759
  if (! c->shared) {
    {
#line 759
    tmp___0 = close(fd);
    }
#line 759
    if (tmp___0 == -1) {
#line 760
      if ((c->log)->log_level >= 2UL) {
        {
#line 760
        tmp = __errno_location();
#line 760
        ngx_log_error_core((ngx_uint_t )2, c->log, *tmp, "close() socket failed");
        }
      }
    }
  }
#line 764
  if (c->pool) {
    {
#line 765
    ngx_destroy_pool(c->pool);
    }
  }
#line 771
  return;
}
}
#line 774 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_accept.c"
u_char *ngx_accept_log_error(ngx_log_t *log , u_char *buf , size_t len ) 
{ 
  u_char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 777
  tmp = ngx_snprintf(buf, len, " while accepting new connection on %V", log->data);
  }
#line 777
  return (tmp);
}
}
#line 41 "src/event/ngx_event_posted.h"
void ngx_event_process_posted(ngx_cycle_t *cycle , ngx_queue_t *posted ) ;
#line 44 "src/event/ngx_event_posted.h"
ngx_queue_t ngx_posted_accept_events  ;
#line 45 "src/event/ngx_event_posted.h"
ngx_queue_t ngx_posted_events  ;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_posted.c"
void ngx_event_process_posted(ngx_cycle_t *cycle , ngx_queue_t *posted ) 
{ 
  ngx_queue_t *q ;
  ngx_event_t *ev ;

  {
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! (! ((unsigned long )posted == (unsigned long )posted->prev))) {
#line 23
      goto while_break;
    }
    {
#line 25
    q = posted->next;
#line 26
    ev = (ngx_event_t *)((u_char *)q - (unsigned long )(& ((ngx_event_t *)0)->queue));
#line 31
    ev->posted = 0U;
#line 31
    (ev->queue.next)->prev = ev->queue.prev;
#line 31
    (ev->queue.prev)->next = ev->queue.next;
#line 33
    (*(ev->handler))(ev);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  return;
}
}
#line 55 "src/core/ngx_rbtree.h"
void ngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                   ngx_rbtree_node_t *sentinel ) ;
#line 57
ngx_rbtree_node_t *ngx_rbtree_next(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) ;
#line 73 "src/core/ngx_rbtree.h"
__inline static ngx_rbtree_node_t *ngx_rbtree_min(ngx_rbtree_node_t *node , ngx_rbtree_node_t *sentinel ) 
{ 


  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! ((unsigned long )node->left != (unsigned long )sentinel)) {
#line 76
      goto while_break;
    }
#line 77
    node = node->left;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return (node);
}
}
#line 22 "src/event/ngx_event_timer.h"
ngx_int_t ngx_event_timer_init(ngx_log_t *log ) ;
#line 23
ngx_msec_t ngx_event_find_timer(void) ;
#line 24
void ngx_event_expire_timers(void) ;
#line 28 "src/event/ngx_event_timer.h"
ngx_rbtree_t ngx_event_timer_rbtree  ;
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_timer.c"
static ngx_rbtree_node_t ngx_event_timer_sentinel  ;
#line 22 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_timer.c"
ngx_int_t ngx_event_timer_init(ngx_log_t *log ) 
{ 


  {
#line 25
  ngx_event_timer_sentinel.color = (u_char )0;
#line 25
  ngx_event_timer_rbtree.root = & ngx_event_timer_sentinel;
#line 25
  ngx_event_timer_rbtree.sentinel = & ngx_event_timer_sentinel;
#line 25
  ngx_event_timer_rbtree.insert = & ngx_rbtree_insert_timer_value;
#line 28
  return ((ngx_int_t )0);
}
}
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_timer.c"
ngx_msec_t ngx_event_find_timer(void) 
{ 
  ngx_msec_int_t timer ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *root ;
  ngx_rbtree_node_t *sentinel ;
  ngx_msec_int_t tmp ;

  {
#line 38
  if ((unsigned long )ngx_event_timer_rbtree.root == (unsigned long )(& ngx_event_timer_sentinel)) {
#line 39
    return ((ngx_msec_t )-1);
  }
  {
#line 42
  root = ngx_event_timer_rbtree.root;
#line 43
  sentinel = ngx_event_timer_rbtree.sentinel;
#line 45
  node = ngx_rbtree_min(root, sentinel);
#line 47
  timer = (ngx_msec_int_t )(node->key - (ngx_rbtree_key_t )ngx_current_msec);
  }
#line 49
  if (timer > 0L) {
#line 49
    tmp = timer;
  } else {
#line 49
    tmp = (ngx_msec_int_t )0;
  }
#line 49
  return ((ngx_msec_t )tmp);
}
}
#line 53 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_timer.c"
void ngx_event_expire_timers(void) 
{ 
  ngx_event_t *ev ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *root ;
  ngx_rbtree_node_t *sentinel ;

  {
#line 59
  sentinel = ngx_event_timer_rbtree.sentinel;
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    root = ngx_event_timer_rbtree.root;
#line 64
    if ((unsigned long )root == (unsigned long )sentinel) {
#line 65
      return;
    }
    {
#line 68
    node = ngx_rbtree_min(root, sentinel);
    }
#line 72
    if ((ngx_msec_int_t )(node->key - (ngx_rbtree_key_t )ngx_current_msec) > 0L) {
#line 73
      return;
    }
    {
#line 76
    ev = (ngx_event_t *)((char *)node - (unsigned long )(& ((ngx_event_t *)0)->timer));
#line 82
    ngx_rbtree_delete(& ngx_event_timer_rbtree, & ev->timer);
#line 90
    ev->timer_set = 0U;
#line 92
    ev->timedout = 1U;
#line 94
    (*(ev->handler))(ev);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 99 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event_timer.c"
ngx_int_t ngx_event_no_timers_left(void) 
{ 
  ngx_event_t *ev ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *root ;
  ngx_rbtree_node_t *sentinel ;

  {
#line 105
  sentinel = ngx_event_timer_rbtree.sentinel;
#line 106
  root = ngx_event_timer_rbtree.root;
#line 108
  if ((unsigned long )root == (unsigned long )sentinel) {
#line 109
    return ((ngx_int_t )0);
  }
  {
#line 112
  node = ngx_rbtree_min(root, sentinel);
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! node) {
#line 112
      goto while_break;
    }
#line 116
    ev = (ngx_event_t *)((char *)node - (unsigned long )(& ((ngx_event_t *)0)->timer));
#line 118
    if (! ev->cancelable) {
#line 119
      return ((ngx_int_t )-2);
    }
    {
#line 112
    node = ngx_rbtree_next(& ngx_event_timer_rbtree, node);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return ((ngx_int_t )0);
}
}
#line 160 "src/core/ngx_file.h"
ngx_atomic_t *ngx_temp_number ;
#line 161
ngx_atomic_int_t ngx_random_number ;
#line 40 "src/core/ngx_shmtx.h"
ngx_int_t ngx_shmtx_create(ngx_shmtx_t *mtx , ngx_shmtx_sh_t *addr , u_char *name ) ;
#line 141 "src/core/ngx_cycle.h"
ngx_uint_t ngx_test_config ;
#line 197 "src/event/ngx_event.h"
ngx_event_actions_t ngx_event_actions  ;
#line 469 "src/event/ngx_event.h"
ngx_atomic_t *ngx_accept_mutex_ptr  ;
#line 470 "src/event/ngx_event.h"
ngx_shmtx_t ngx_accept_mutex  ;
#line 471 "src/event/ngx_event.h"
ngx_uint_t ngx_use_accept_mutex  ;
#line 472 "src/event/ngx_event.h"
ngx_uint_t ngx_accept_events  ;
#line 473 "src/event/ngx_event.h"
ngx_uint_t ngx_accept_mutex_held  ;
#line 474 "src/event/ngx_event.h"
ngx_msec_t ngx_accept_mutex_delay  ;
#line 475 "src/event/ngx_event.h"
ngx_int_t ngx_accept_disabled  ;
#line 495 "src/event/ngx_event.h"
sig_atomic_t ngx_event_timer_alarm  ;
#line 496 "src/event/ngx_event.h"
ngx_uint_t ngx_event_flags  ;
#line 526
ngx_int_t ngx_send_lowat(ngx_connection_t *c , size_t lowat ) ;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static char *ngx_event_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 24
static ngx_int_t ngx_event_module_init(ngx_cycle_t *cycle ) ;
#line 25
static ngx_int_t ngx_event_process_init(ngx_cycle_t *cycle ) ;
#line 26
static char *ngx_events_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 28
static char *ngx_event_connections(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 30
static char *ngx_event_use(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 31
static char *ngx_event_debug_connection(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 34
static void *ngx_event_core_create_conf(ngx_cycle_t *cycle ) ;
#line 35
static char *ngx_event_core_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 38 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_uint_t ngx_timer_resolution  ;
#line 41 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_uint_t ngx_event_max_module  ;
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static unsigned long volatile   connection_counter  =    (ngx_atomic_t )1;
#line 48 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
ngx_atomic_t *ngx_connection_counter  =    & connection_counter;
#line 81 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_command_t ngx_events_commands[2]  = {      {{sizeof("events") - 1UL, (u_char *)"events"}, (ngx_uint_t )16777473, & ngx_events_block,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 94 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_core_module_t ngx_events_module_ctx  =    {{sizeof("events") - 1UL, (u_char *)"events"}, (void *(*)(ngx_cycle_t *cycle ))((void *)0),
    & ngx_event_init_conf};
#line 101 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
ngx_module_t ngx_events_module  = 
#line 101
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_events_module_ctx),
    ngx_events_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 117 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_str_t event_core_name  =    {sizeof("event_core") - 1UL, (u_char *)"event_core"};
#line 120 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_command_t ngx_event_core_commands[7]  = {      {{sizeof("worker_connections") - 1UL, (u_char *)"worker_connections"}, (ngx_uint_t )33554434,
      & ngx_event_connections, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("use") - 1UL, (u_char *)"use"}, (ngx_uint_t )33554434, & ngx_event_use,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("multi_accept") - 1UL, (u_char *)"multi_accept"}, (ngx_uint_t )33554944,
      & ngx_conf_set_flag_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_event_conf_t *)0)->multi_accept),
      (void *)0}, 
        {{sizeof("accept_mutex") - 1UL, (u_char *)"accept_mutex"}, (ngx_uint_t )33554944,
      & ngx_conf_set_flag_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_event_conf_t *)0)->accept_mutex),
      (void *)0}, 
        {{sizeof("accept_mutex_delay") - 1UL, (u_char *)"accept_mutex_delay"}, (ngx_uint_t )33554434,
      & ngx_conf_set_msec_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_event_conf_t *)0)->accept_mutex_delay),
      (void *)0}, 
        {{sizeof("debug_connection") - 1UL, (u_char *)"debug_connection"}, (ngx_uint_t )33554434,
      & ngx_event_debug_connection, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 168 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_event_module_t ngx_event_core_module_ctx  =    {& event_core_name, & ngx_event_core_create_conf, & ngx_event_core_init_conf, {(ngx_int_t (*)(ngx_event_t *ev ,
                                                                                                 ngx_int_t event ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_event_t *ev ,
                                                                                                 ngx_int_t event ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_event_t *ev ,
                                                                                                 ngx_int_t event ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_event_t *ev ,
                                                                                                 ngx_int_t event ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_connection_t *c ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_connection_t *c ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(void (*handler)(ngx_event_t *ev ) ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_cycle_t *cycle ,
                                                                                                 ngx_msec_t timer ,
                                                                                                 ngx_uint_t flags ))((void *)0),
                                                                                  (ngx_int_t (*)(ngx_cycle_t *cycle ,
                                                                                                 ngx_msec_t timer ))((void *)0),
                                                                                  (void (*)(ngx_cycle_t *cycle ))((void *)0)}};
#line 177 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
ngx_module_t ngx_event_core_module  = 
#line 177
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_event_core_module_ctx),
    ngx_event_core_commands, (ngx_uint_t )1414420037, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    & ngx_event_module_init, & ngx_event_process_init, (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0};
#line 193 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
void ngx_process_events_and_timers(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t flags ;
  ngx_msec_t timer ;
  ngx_msec_t delta ;
  ngx_int_t tmp ;

  {
#line 199
  if (ngx_timer_resolution) {
#line 200
    timer = (ngx_msec_t )-1;
#line 201
    flags = (ngx_uint_t )0;
  } else {
    {
#line 204
    timer = ngx_event_find_timer();
#line 205
    flags = (ngx_uint_t )1;
    }
  }
#line 218
  if (ngx_use_accept_mutex) {
#line 219
    if (ngx_accept_disabled > 0L) {
#line 220
      ngx_accept_disabled --;
    } else {
      {
#line 223
      tmp = ngx_trylock_accept_mutex(cycle);
      }
#line 223
      if (tmp == -1L) {
#line 224
        return;
      }
#line 227
      if (ngx_accept_mutex_held) {
#line 228
        flags |= 2UL;
      } else
#line 231
      if (timer == 0xffffffffffffffffUL) {
#line 234
        timer = ngx_accept_mutex_delay;
      } else
#line 231
      if (timer > ngx_accept_mutex_delay) {
#line 234
        timer = ngx_accept_mutex_delay;
      }
    }
  }
  {
#line 240
  delta = (ngx_msec_t )ngx_current_msec;
#line 242
  (*(ngx_event_actions.process_events))(cycle, timer, flags);
#line 244
  delta = (ngx_msec_t )(ngx_current_msec - (ngx_msec_t volatile   )delta);
#line 249
  ngx_event_process_posted(cycle, & ngx_posted_accept_events);
  }
#line 251
  if (ngx_accept_mutex_held) {
    {
#line 252
    ngx_shmtx_unlock(& ngx_accept_mutex);
    }
  }
#line 255
  if (delta) {
    {
#line 256
    ngx_event_expire_timers();
    }
  }
  {
#line 259
  ngx_event_process_posted(cycle, & ngx_posted_events);
  }
#line 260
  return;
}
}
#line 263 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
ngx_int_t ngx_handle_read_event(ngx_event_t *rev , ngx_uint_t flags ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;

  {
#line 266
  if (ngx_event_flags & 4UL) {
#line 270
    if (! rev->active) {
#line 270
      if (! rev->ready) {
        {
#line 271
        tmp = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )2147483648U);
        }
#line 271
        if (tmp == -1L) {
#line 274
          return ((ngx_int_t )-1);
        }
      }
    }
#line 278
    return ((ngx_int_t )0);
  } else
#line 280
  if (ngx_event_flags & 1UL) {
#line 284
    if (! rev->active) {
#line 284
      if (! rev->ready) {
        {
#line 285
        tmp___0 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
        }
#line 285
        if (tmp___0 == -1L) {
#line 288
          return ((ngx_int_t )-1);
        }
#line 291
        return ((ngx_int_t )0);
      }
    }
#line 294
    if (rev->active) {
#line 294
      if (rev->ready) {
#line 294
        goto _L;
      } else
#line 294
      if (flags & 1UL) {
        _L: /* CIL Label */ 
        {
#line 295
        tmp___1 = (*(ngx_event_actions.del))(rev, (ngx_int_t )8193, flags);
        }
#line 295
        if (tmp___1 == -1L) {
#line 298
          return ((ngx_int_t )-1);
        }
#line 301
        return ((ngx_int_t )0);
      }
    }
  } else
#line 304
  if (ngx_event_flags & 4096UL) {
#line 308
    if (! rev->active) {
#line 308
      if (! rev->ready) {
        {
#line 309
        tmp___2 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
        }
#line 309
        if (tmp___2 == -1L) {
#line 310
          return ((ngx_int_t )-1);
        }
#line 313
        return ((ngx_int_t )0);
      }
    }
#line 316
    if (rev->oneshot) {
#line 316
      if (! rev->ready) {
        {
#line 317
        tmp___3 = (*(ngx_event_actions.del))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
        }
#line 317
        if (tmp___3 == -1L) {
#line 318
          return ((ngx_int_t )-1);
        }
#line 321
        return ((ngx_int_t )0);
      }
    }
  }
#line 327
  return ((ngx_int_t )0);
}
}
#line 331 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
ngx_int_t ngx_handle_write_event(ngx_event_t *wev , size_t lowat ) 
{ 
  ngx_connection_t *c ;
  ngx_int_t tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;

  {
#line 336
  if (lowat) {
    {
#line 337
    c = (ngx_connection_t *)wev->data;
#line 339
    tmp = ngx_send_lowat(c, lowat);
    }
#line 339
    if (tmp == -1L) {
#line 340
      return ((ngx_int_t )-1);
    }
  }
#line 344
  if (ngx_event_flags & 4UL) {
#line 348
    if (! wev->active) {
#line 348
      if (! wev->ready) {
#line 349
        if (lowat) {
#line 349
          tmp___0 = 0;
        } else {
#line 349
          tmp___0 = 0;
        }
        {
#line 349
        tmp___1 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )(2147483648U | (unsigned int )tmp___0));
        }
#line 349
        if (tmp___1 == -1L) {
#line 353
          return ((ngx_int_t )-1);
        }
      }
    }
#line 357
    return ((ngx_int_t )0);
  } else
#line 359
  if (ngx_event_flags & 1UL) {
#line 363
    if (! wev->active) {
#line 363
      if (! wev->ready) {
        {
#line 364
        tmp___2 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )0);
        }
#line 364
        if (tmp___2 == -1L) {
#line 367
          return ((ngx_int_t )-1);
        }
#line 370
        return ((ngx_int_t )0);
      }
    }
#line 373
    if (wev->active) {
#line 373
      if (wev->ready) {
        {
#line 374
        tmp___3 = (*(ngx_event_actions.del))(wev, (ngx_int_t )4, (ngx_uint_t )0);
        }
#line 374
        if (tmp___3 == -1L) {
#line 377
          return ((ngx_int_t )-1);
        }
#line 380
        return ((ngx_int_t )0);
      }
    }
  } else
#line 383
  if (ngx_event_flags & 4096UL) {
#line 387
    if (! wev->active) {
#line 387
      if (! wev->ready) {
        {
#line 388
        tmp___4 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )0);
        }
#line 388
        if (tmp___4 == -1L) {
#line 389
          return ((ngx_int_t )-1);
        }
#line 392
        return ((ngx_int_t )0);
      }
    }
#line 395
    if (wev->oneshot) {
#line 395
      if (wev->ready) {
        {
#line 396
        tmp___5 = (*(ngx_event_actions.del))(wev, (ngx_int_t )4, (ngx_uint_t )0);
        }
#line 396
        if (tmp___5 == -1L) {
#line 397
          return ((ngx_int_t )-1);
        }
#line 400
        return ((ngx_int_t )0);
      }
    }
  }
#line 406
  return ((ngx_int_t )0);
}
}
#line 410 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static char *ngx_event_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  char *__cil_tmp3 ;

  {
#line 413
  if ((unsigned long )*(cycle->conf_ctx + ngx_events_module.index) == (unsigned long )((void *)0)) {
#line 414
    if ((cycle->log)->log_level >= 1UL) {
      {
#line 414
      ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "no \"events\" section in configuration");
      }
    }
#line 416
    return ((char *)((void *)-1));
  }
#line 419
  return ((char *)((void *)0));
}
}
#line 423 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_int_t ngx_event_module_init(ngx_cycle_t *cycle ) 
{ 
  void ***cf ;
  u_char *shared ;
  size_t size ;
  size_t cl ;
  ngx_shm_t shm ;
  ngx_time_t *tp ;
  ngx_core_conf_t *ccf ;
  ngx_event_conf_t *ecf ;
  ngx_int_t limit ;
  struct rlimit rlmt___0 ;
  int *tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 434
  cf = *(cycle->conf_ctx + ngx_events_module.index);
#line 435
  ecf = (ngx_event_conf_t *)*(*cf + ngx_event_core_module.ctx_index);
#line 437
  if (! ngx_test_config) {
#line 437
    if (ngx_process <= 1UL) {
#line 438
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 438
        ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "using the \"%s\" event method",
                           ecf->name);
        }
      }
    }
  }
  {
#line 442
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 444
  ngx_timer_resolution = ccf->timer_resolution;
#line 451
  tmp___0 = getrlimit((__rlimit_resource_t )7, & rlmt___0);
  }
#line 451
  if (tmp___0 == -1) {
#line 452
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 452
      tmp = __errno_location();
#line 452
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "getrlimit(RLIMIT_NOFILE) failed, ignored");
      }
    }
  } else
#line 456
  if (ecf->connections > rlmt___0.rlim_cur) {
#line 456
    if (ccf->rlimit_nofile == -1L) {
#line 456
      goto _L;
    } else
#line 456
    if (ecf->connections > (ngx_uint_t )ccf->rlimit_nofile) {
      _L: /* CIL Label */ 
#line 460
      if (ccf->rlimit_nofile == -1L) {
#line 460
        limit = (ngx_int_t )rlmt___0.rlim_cur;
      } else {
#line 460
        limit = ccf->rlimit_nofile;
      }
#line 463
      if ((cycle->log)->log_level >= 5UL) {
        {
#line 463
        ngx_log_error_core((ngx_uint_t )5, cycle->log, 0, "%ui worker_connections exceed open file resource limit: %i",
                           ecf->connections, limit);
        }
      }
    }
  }
#line 473
  if (ccf->master == 0L) {
#line 474
    return ((ngx_int_t )0);
  }
#line 477
  if (ngx_accept_mutex_ptr) {
#line 478
    return ((ngx_int_t )0);
  }
  {
#line 484
  cl = (size_t )128;
#line 486
  size = (cl + cl) + cl;
#line 502
  shm.size = size;
#line 503
  shm.name.len = sizeof("nginx_shared_zone") - 1UL;
#line 503
  shm.name.data = (u_char *)"nginx_shared_zone";
#line 504
  shm.log = cycle->log;
#line 506
  tmp___1 = ngx_shm_alloc(& shm);
  }
#line 506
  if (tmp___1 != 0L) {
#line 507
    return ((ngx_int_t )-1);
  }
  {
#line 510
  shared = shm.addr;
#line 512
  ngx_accept_mutex_ptr = (ngx_atomic_t *)shared;
#line 513
  ngx_accept_mutex.spin = (ngx_uint_t )-1;
#line 515
  tmp___2 = ngx_shmtx_create(& ngx_accept_mutex, (ngx_shmtx_sh_t *)shared, cycle->lock_file.data);
  }
#line 515
  if (tmp___2 != 0L) {
#line 519
    return ((ngx_int_t )-1);
  }
  {
#line 522
  ngx_connection_counter = (ngx_atomic_t *)(shared + cl);
#line 524
  __sync_bool_compare_and_swap(ngx_connection_counter, 0, 1);
#line 530
  ngx_temp_number = (ngx_atomic_t *)(shared + 2UL * cl);
#line 532
  tp = (ngx_time_t *)ngx_cached_time;
#line 534
  ngx_random_number = (ngx_atomic_int_t )((tp->msec << 16) + (ngx_uint_t )ngx_pid);
  }
#line 548
  return ((ngx_int_t )0);
}
}
#line 554 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static void ngx_timer_signal_handler(int signo ) 
{ 


  {
#line 557
  ngx_event_timer_alarm = 1;
#line 562
  return;
}
}
#line 567 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static ngx_int_t ngx_event_process_init(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t m ;
  ngx_uint_t i ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  ngx_connection_t *next ;
  ngx_connection_t *old ;
  ngx_core_conf_t *ccf ;
  ngx_event_conf_t *ecf ;
  ngx_event_module_t *module ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  struct sigaction sa ;
  struct itimerval itv ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  struct rlimit rlmt___0 ;
  int *tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  ngx_int_t tmp___11 ;
  ngx_int_t tmp___12 ;
  ngx_int_t tmp___13 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 578
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 579
  ecf = (ngx_event_conf_t *)*(*(*(cycle->conf_ctx + ngx_events_module.index)) + ngx_event_core_module.ctx_index);
#line 581
  if (ccf->master) {
#line 581
    if (ccf->worker_processes > 1L) {
#line 581
      if (ecf->accept_mutex) {
#line 582
        ngx_use_accept_mutex = (ngx_uint_t )1;
#line 583
        ngx_accept_mutex_held = (ngx_uint_t )0;
#line 584
        ngx_accept_mutex_delay = ecf->accept_mutex_delay;
      } else {
#line 587
        ngx_use_accept_mutex = (ngx_uint_t )0;
      }
    } else {
#line 587
      ngx_use_accept_mutex = (ngx_uint_t )0;
    }
  } else {
#line 587
    ngx_use_accept_mutex = (ngx_uint_t )0;
  }
  {
#line 601
  ngx_posted_accept_events.prev = & ngx_posted_accept_events;
#line 601
  ngx_posted_accept_events.next = & ngx_posted_accept_events;
#line 602
  ngx_posted_events.prev = & ngx_posted_events;
#line 602
  ngx_posted_events.next = & ngx_posted_events;
#line 604
  tmp = ngx_event_timer_init(cycle->log);
  }
#line 604
  if (tmp == -1L) {
#line 605
    return ((ngx_int_t )-1);
  }
#line 608
  m = (ngx_uint_t )0;
  {
#line 608
  while (1) {
    while_continue: /* CIL Label */ ;
#line 608
    if (! *(cycle->modules + m)) {
#line 608
      goto while_break;
    }
#line 609
    if ((*(cycle->modules + m))->type != 1414420037UL) {
#line 610
      goto __Cont;
    }
#line 613
    if ((*(cycle->modules + m))->ctx_index != ecf->use) {
#line 614
      goto __Cont;
    }
    {
#line 617
    module = (ngx_event_module_t *)(*(cycle->modules + m))->ctx;
#line 619
    tmp___0 = (*(module->actions.init))(cycle, ngx_timer_resolution);
    }
#line 619
    if (tmp___0 != 0L) {
      {
#line 621
      exit(2);
      }
    }
#line 624
    goto while_break;
    __Cont: /* CIL Label */ 
#line 608
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 629
  if (ngx_timer_resolution) {
#line 629
    if (! (ngx_event_flags & 2048UL)) {
      {
#line 633
      memset((void *)(& sa), 0, sizeof(struct sigaction ));
#line 634
      sa.__sigaction_handler.sa_handler = & ngx_timer_signal_handler;
#line 635
      sigemptyset(& sa.sa_mask);
#line 637
      tmp___2 = sigaction(14, (struct sigaction  const  */* __restrict  */)(& sa),
                          (struct sigaction */* __restrict  */)((void *)0));
      }
#line 637
      if (tmp___2 == -1) {
#line 638
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 638
          tmp___1 = __errno_location();
#line 638
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "sigaction(SIGALRM) failed");
          }
        }
#line 640
        return ((ngx_int_t )-1);
      }
      {
#line 643
      itv.it_interval.tv_sec = (__time_t )(ngx_timer_resolution / 1000UL);
#line 644
      itv.it_interval.tv_usec = (__suseconds_t )((ngx_timer_resolution % 1000UL) * 1000UL);
#line 645
      itv.it_value.tv_sec = (__time_t )(ngx_timer_resolution / 1000UL);
#line 646
      itv.it_value.tv_usec = (__suseconds_t )((ngx_timer_resolution % 1000UL) * 1000UL);
#line 648
      tmp___4 = setitimer((__itimer_which_t )0, (struct itimerval  const  */* __restrict  */)(& itv),
                          (struct itimerval */* __restrict  */)((void *)0));
      }
#line 648
      if (tmp___4 == -1) {
#line 649
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 649
          tmp___3 = __errno_location();
#line 649
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "setitimer() failed");
          }
        }
      }
    }
  }
#line 654
  if (ngx_event_flags & 1024UL) {
    {
#line 657
    tmp___6 = getrlimit((__rlimit_resource_t )7, & rlmt___0);
    }
#line 657
    if (tmp___6 == -1) {
#line 658
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 658
        tmp___5 = __errno_location();
#line 658
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "getrlimit(RLIMIT_NOFILE) failed");
        }
      }
#line 660
      return ((ngx_int_t )-1);
    }
    {
#line 663
    cycle->files_n = rlmt___0.rlim_cur;
#line 665
    tmp___7 = ngx_calloc(sizeof(ngx_connection_t *) * cycle->files_n, cycle->log);
#line 665
    cycle->files = (ngx_connection_t **)tmp___7;
    }
#line 667
    if ((unsigned long )cycle->files == (unsigned long )((void *)0)) {
#line 668
      return ((ngx_int_t )-1);
    }
  }
  {
#line 683
  tmp___8 = ngx_alloc(sizeof(ngx_connection_t ) * cycle->connection_n, cycle->log);
#line 683
  cycle->connections = (ngx_connection_t *)tmp___8;
  }
#line 685
  if ((unsigned long )cycle->connections == (unsigned long )((void *)0)) {
#line 686
    return ((ngx_int_t )-1);
  }
  {
#line 689
  c = cycle->connections;
#line 691
  tmp___9 = ngx_alloc(sizeof(ngx_event_t ) * cycle->connection_n, cycle->log);
#line 691
  cycle->read_events = (ngx_event_t *)tmp___9;
  }
#line 693
  if ((unsigned long )cycle->read_events == (unsigned long )((void *)0)) {
#line 694
    return ((ngx_int_t )-1);
  }
#line 697
  rev = cycle->read_events;
#line 698
  i = (ngx_uint_t )0;
  {
#line 698
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 698
    if (! (i < cycle->connection_n)) {
#line 698
      goto while_break___0;
    }
#line 699
    (rev + i)->closed = 1U;
#line 700
    (rev + i)->instance = 1U;
#line 698
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 703
  tmp___10 = ngx_alloc(sizeof(ngx_event_t ) * cycle->connection_n, cycle->log);
#line 703
  cycle->write_events = (ngx_event_t *)tmp___10;
  }
#line 705
  if ((unsigned long )cycle->write_events == (unsigned long )((void *)0)) {
#line 706
    return ((ngx_int_t )-1);
  }
#line 709
  wev = cycle->write_events;
#line 710
  i = (ngx_uint_t )0;
  {
#line 710
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 710
    if (! (i < cycle->connection_n)) {
#line 710
      goto while_break___1;
    }
#line 711
    (wev + i)->closed = 1U;
#line 710
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 714
  i = cycle->connection_n;
#line 715
  next = (ngx_connection_t *)((void *)0);
  {
#line 717
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 718
    i --;
#line 720
    (c + i)->data = (void *)next;
#line 721
    (c + i)->read = cycle->read_events + i;
#line 722
    (c + i)->write = cycle->write_events + i;
#line 723
    (c + i)->fd = -1;
#line 725
    next = c + i;
#line 717
    if (! i) {
#line 717
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 728
  cycle->free_connections = next;
#line 729
  cycle->free_connection_n = cycle->connection_n;
#line 733
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 734
  i = (ngx_uint_t )0;
  {
#line 734
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 734
    if (! (i < cycle->listening.nelts)) {
#line 734
      goto while_break___3;
    }
#line 737
    if ((ls + i)->reuseport) {
#line 737
      if ((ls + i)->worker != ngx_worker) {
#line 738
        goto __Cont___0;
      }
    }
    {
#line 742
    c = ngx_get_connection((ls + i)->fd, cycle->log);
    }
#line 744
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 745
      return ((ngx_int_t )-1);
    }
#line 748
    c->type = (ls + i)->type;
#line 749
    c->log = & (ls + i)->log;
#line 751
    c->listening = ls + i;
#line 752
    (ls + i)->connection = c;
#line 754
    rev = c->read;
#line 756
    rev->log = c->log;
#line 757
    rev->accept = 1U;
#line 760
    rev->deferred_accept = (ls + i)->deferred_accept;
#line 763
    if (! (ngx_event_flags & 512UL)) {
#line 764
      if ((ls + i)->previous) {
        {
#line 771
        old = ((ls + i)->previous)->connection;
#line 773
        tmp___11 = (*(ngx_event_actions.del))(old->read, (ngx_int_t )8193, (ngx_uint_t )1);
        }
#line 773
        if (tmp___11 == -1L) {
#line 776
          return ((ngx_int_t )-1);
        }
#line 779
        old->fd = -1;
      }
    }
#line 821
    if (c->type == 1) {
#line 821
      rev->handler = & ngx_event_accept;
    } else {
#line 821
      rev->handler = & ngx_event_recvmsg;
    }
#line 826
    if ((ls + i)->reuseport) {
      {
#line 827
      tmp___12 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
      }
#line 827
      if (tmp___12 == -1L) {
#line 828
        return ((ngx_int_t )-1);
      }
#line 831
      goto __Cont___0;
    }
#line 836
    if (ngx_use_accept_mutex) {
#line 837
      goto __Cont___0;
    }
    {
#line 856
    tmp___13 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )0);
    }
#line 856
    if (tmp___13 == -1L) {
#line 857
      return ((ngx_int_t )-1);
    }
    __Cont___0: /* CIL Label */ 
#line 734
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 864
  return ((ngx_int_t )0);
}
}
#line 868 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
ngx_int_t ngx_send_lowat(ngx_connection_t *c , size_t lowat ) 
{ 
  int sndlowat ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 882
  if (lowat == 0UL) {
#line 883
    return ((ngx_int_t )0);
  } else
#line 882
  if (c->sndlowat) {
#line 883
    return ((ngx_int_t )0);
  }
  {
#line 886
  sndlowat = (int )lowat;
#line 888
  tmp___0 = setsockopt(c->fd, 1, 19, (void const   *)(& sndlowat), (socklen_t )sizeof(int ));
  }
#line 888
  if (tmp___0 == -1) {
    {
#line 892
    tmp = __errno_location();
#line 892
    ngx_connection_error(c, *tmp, (char *)"setsockopt(SO_SNDLOWAT) failed");
    }
#line 894
    return ((ngx_int_t )-1);
  }
#line 897
  c->sndlowat = 1U;
#line 899
  return ((ngx_int_t )0);
}
}
#line 903 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static char *ngx_events_block(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  void ***ctx ;
  ngx_uint_t i ;
  ngx_conf_t pcf ;
  ngx_event_module_t *m ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp12 ;

  {
#line 912
  if (*((void **)conf)) {
#line 913
    return ((char *)"is duplicate");
  }
  {
#line 918
  tmp = ngx_count_modules(cf->cycle, (ngx_uint_t )1414420037);
#line 918
  ngx_event_max_module = (ngx_uint_t )tmp;
#line 920
  tmp___0 = ngx_pcalloc(cf->pool, sizeof(void *));
#line 920
  ctx = (void ***)tmp___0;
  }
#line 921
  if ((unsigned long )ctx == (unsigned long )((void *)0)) {
#line 922
    return ((char *)((void *)-1));
  }
  {
#line 925
  tmp___1 = ngx_pcalloc(cf->pool, ngx_event_max_module * sizeof(void *));
#line 925
  *ctx = (void **)tmp___1;
  }
#line 926
  if ((unsigned long )*ctx == (unsigned long )((void *)0)) {
#line 927
    return ((char *)((void *)-1));
  }
#line 930
  *((void **)conf) = (void *)ctx;
#line 932
  i = (ngx_uint_t )0;
  {
#line 932
  while (1) {
    while_continue: /* CIL Label */ ;
#line 932
    if (! *((cf->cycle)->modules + i)) {
#line 932
      goto while_break;
    }
#line 933
    if ((*((cf->cycle)->modules + i))->type != 1414420037UL) {
#line 934
      goto __Cont;
    }
#line 937
    m = (ngx_event_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 939
    if (m->create_conf) {
      {
#line 940
      *(*ctx + (*((cf->cycle)->modules + i))->ctx_index) = (*(m->create_conf))(cf->cycle);
      }
#line 942
      if ((unsigned long )*(*ctx + (*((cf->cycle)->modules + i))->ctx_index) == (unsigned long )((void *)0)) {
#line 943
        return ((char *)((void *)-1));
      }
    }
    __Cont: /* CIL Label */ 
#line 932
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 948
  pcf = *cf;
#line 949
  cf->ctx = (void *)ctx;
#line 950
  cf->module_type = (ngx_uint_t )1414420037;
#line 951
  cf->cmd_type = (ngx_uint_t )33554432;
#line 953
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 955
  *cf = pcf;
  }
#line 957
  if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 958
    return (rv);
  }
#line 961
  i = (ngx_uint_t )0;
  {
#line 961
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 961
    if (! *((cf->cycle)->modules + i)) {
#line 961
      goto while_break___0;
    }
#line 962
    if ((*((cf->cycle)->modules + i))->type != 1414420037UL) {
#line 963
      goto __Cont___0;
    }
#line 966
    m = (ngx_event_module_t *)(*((cf->cycle)->modules + i))->ctx;
#line 968
    if (m->init_conf) {
      {
#line 969
      rv = (*(m->init_conf))(cf->cycle, *(*ctx + (*((cf->cycle)->modules + i))->ctx_index));
      }
#line 971
      if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 972
        return (rv);
      }
    }
    __Cont___0: /* CIL Label */ 
#line 961
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 977
  return ((char *)((void *)0));
}
}
#line 981 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static char *ngx_event_connections(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_event_conf_t *ecf ;
  ngx_str_t *value ;
  ngx_int_t tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 984
  ecf = (ngx_event_conf_t *)conf;
#line 988
  if (ecf->connections != 0xffffffffffffffffUL) {
#line 989
    return ((char *)"is duplicate");
  }
  {
#line 992
  value = (ngx_str_t *)(cf->args)->elts;
#line 993
  tmp = ngx_atoi((value + 1)->data, (value + 1)->len);
#line 993
  ecf->connections = (ngx_uint_t )tmp;
  }
#line 994
  if (ecf->connections == 0xffffffffffffffffUL) {
    {
#line 995
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number \"%V\"", value + 1);
    }
#line 998
    return ((char *)((void *)-1));
  }
#line 1001
  (cf->cycle)->connection_n = ecf->connections;
#line 1003
  return ((char *)((void *)0));
}
}
#line 1007 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static char *ngx_event_use(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_event_conf_t *ecf ;
  ngx_int_t m ;
  ngx_str_t *value ;
  ngx_event_conf_t *old_ecf ;
  ngx_event_module_t *module ;
  int tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1010
  ecf = (ngx_event_conf_t *)conf;
#line 1017
  if (ecf->use != 0xffffffffffffffffUL) {
#line 1018
    return ((char *)"is duplicate");
  }
#line 1021
  value = (ngx_str_t *)(cf->args)->elts;
#line 1023
  if (((cf->cycle)->old_cycle)->conf_ctx) {
#line 1024
    old_ecf = (ngx_event_conf_t *)*(*(*(((cf->cycle)->old_cycle)->conf_ctx + ngx_events_module.index)) + ngx_event_core_module.ctx_index);
  } else {
#line 1027
    old_ecf = (ngx_event_conf_t *)((void *)0);
  }
#line 1031
  m = (ngx_int_t )0;
  {
#line 1031
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1031
    if (! *((cf->cycle)->modules + m)) {
#line 1031
      goto while_break;
    }
#line 1032
    if ((*((cf->cycle)->modules + m))->type != 1414420037UL) {
#line 1033
      goto __Cont;
    }
#line 1036
    module = (ngx_event_module_t *)(*((cf->cycle)->modules + m))->ctx;
#line 1037
    if ((module->name)->len == (value + 1)->len) {
      {
#line 1038
      tmp = strcmp((char const   *)(module->name)->data, (char const   *)(value + 1)->data);
      }
#line 1038
      if (tmp == 0) {
#line 1039
        ecf->use = (*((cf->cycle)->modules + m))->ctx_index;
#line 1040
        ecf->name = (module->name)->data;
#line 1042
        if (ngx_process == 0UL) {
#line 1042
          if (old_ecf) {
#line 1042
            if (old_ecf->use != ecf->use) {
              {
#line 1046
              ngx_conf_log_error((ngx_uint_t )1, cf, 0, "when the server runs without a master process the \"%V\" event type must be the same as in previous configuration - \"%s\" and it cannot be changed on the fly, to change it you need to stop server and start it again",
                                 value + 1, old_ecf->name);
              }
#line 1055
              return ((char *)((void *)-1));
            }
          }
        }
#line 1058
        return ((char *)((void *)0));
      }
    }
    __Cont: /* CIL Label */ 
#line 1031
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1063
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid event type \"%V\"", value + 1);
  }
#line 1066
  return ((char *)((void *)-1));
}
}
#line 1070 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static char *ngx_event_debug_connection(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 1164
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "\"debug_connection\" is ignored, you need to rebuild nginx using --with-debug option to enable it");
  }
#line 1170
  return ((char *)((void *)0));
}
}
#line 1174 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static void *ngx_event_core_create_conf(ngx_cycle_t *cycle ) 
{ 
  ngx_event_conf_t *ecf ;
  void *tmp ;

  {
  {
#line 1179
  tmp = ngx_palloc(cycle->pool, sizeof(ngx_event_conf_t ));
#line 1179
  ecf = (ngx_event_conf_t *)tmp;
  }
#line 1180
  if ((unsigned long )ecf == (unsigned long )((void *)0)) {
#line 1181
    return ((void *)0);
  }
#line 1184
  ecf->connections = (ngx_uint_t )-1;
#line 1185
  ecf->use = (ngx_uint_t )-1;
#line 1186
  ecf->multi_accept = (ngx_flag_t )-1;
#line 1187
  ecf->accept_mutex = (ngx_flag_t )-1;
#line 1188
  ecf->accept_mutex_delay = (ngx_msec_t )-1;
#line 1189
  ecf->name = (u_char *)((void *)-1);
#line 1201
  return ((void *)ecf);
}
}
#line 1205 "/home/khheo/project/nginx-release-1.13.8/src/event/ngx_event.c"
static char *ngx_event_core_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  ngx_event_conf_t *ecf ;
  int fd ;
  ngx_int_t i ;
  ngx_module_t *module ;
  ngx_event_module_t *event_module ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp10 ;

  {
  {
#line 1208
  ecf = (ngx_event_conf_t *)conf;
#line 1217
  module = (ngx_module_t *)((void *)0);
#line 1221
  fd = epoll_create(100);
  }
#line 1223
  if (fd != -1) {
    {
#line 1224
    close(fd);
#line 1225
    module = & ngx_epoll_module;
    }
  } else {
    {
#line 1227
    tmp = __errno_location();
    }
#line 1227
    if (*tmp != 38) {
#line 1228
      module = & ngx_epoll_module;
    }
  }
#line 1253
  if ((unsigned long )module == (unsigned long )((void *)0)) {
#line 1254
    i = (ngx_int_t )0;
    {
#line 1254
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1254
      if (! *(cycle->modules + i)) {
#line 1254
        goto while_break;
      }
#line 1256
      if ((*(cycle->modules + i))->type != 1414420037UL) {
#line 1257
        goto __Cont;
      }
      {
#line 1260
      event_module = (ngx_event_module_t *)(*(cycle->modules + i))->ctx;
#line 1262
      tmp___0 = strcmp((char const   *)(event_module->name)->data, (char const   *)event_core_name.data);
      }
#line 1262
      if (tmp___0 == 0) {
#line 1264
        goto __Cont;
      }
#line 1267
      module = *(cycle->modules + i);
#line 1268
      goto while_break;
      __Cont: /* CIL Label */ 
#line 1254
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1272
  if ((unsigned long )module == (unsigned long )((void *)0)) {
#line 1273
    if ((cycle->log)->log_level >= 1UL) {
      {
#line 1273
      ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "no events module found");
      }
    }
#line 1274
    return ((char *)((void *)-1));
  }
#line 1277
  if (ecf->connections == 0xffffffffffffffffUL) {
#line 1277
    ecf->connections = (ngx_uint_t )512;
  }
#line 1278
  cycle->connection_n = ecf->connections;
#line 1280
  if (ecf->use == 0xffffffffffffffffUL) {
#line 1280
    ecf->use = module->ctx_index;
  }
#line 1282
  event_module = (ngx_event_module_t *)module->ctx;
#line 1283
  if ((unsigned long )ecf->name == (unsigned long )((void *)-1)) {
#line 1283
    ecf->name = (event_module->name)->data;
  }
#line 1285
  if (ecf->multi_accept == -1L) {
#line 1285
    ecf->multi_accept = (ngx_flag_t )0;
  }
#line 1286
  if (ecf->accept_mutex == -1L) {
#line 1286
    ecf->accept_mutex = (ngx_flag_t )0;
  }
#line 1287
  if (ecf->accept_mutex_delay == 0xffffffffffffffffUL) {
#line 1287
    ecf->accept_mutex_delay = (ngx_msec_t )500;
  }
#line 1289
  return ((char *)((void *)0));
}
}
#line 43 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_syslog_time ;
#line 26 "src/core/ngx_syslog.h"
void ngx_syslog_writer(ngx_log_t *log , ngx_uint_t level , u_char *buf , size_t len ) ;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
static char *ngx_syslog_parse_args(ngx_conf_t *cf , ngx_syslog_peer_t *peer ) ;
#line 19
static ngx_int_t ngx_syslog_init_peer(ngx_syslog_peer_t *peer ) ;
#line 20
static void ngx_syslog_cleanup(void *data ) ;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
static char *facilities[25]  = 
#line 23
  {      (char *)"kern",      (char *)"user",      (char *)"mail",      (char *)"daemon", 
        (char *)"auth",      (char *)"intern",      (char *)"lpr",      (char *)"news", 
        (char *)"uucp",      (char *)"clock",      (char *)"authpriv",      (char *)"ftp", 
        (char *)"ntp",      (char *)"audit",      (char *)"alert",      (char *)"cron", 
        (char *)"local0",      (char *)"local1",      (char *)"local2",      (char *)"local3", 
        (char *)"local4",      (char *)"local5",      (char *)"local6",      (char *)"local7", 
        (char *)((void *)0)};
#line 31 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
static char *severities[9]  = 
#line 31
  {      (char *)"emerg",      (char *)"alert",      (char *)"crit",      (char *)"error", 
        (char *)"warn",      (char *)"notice",      (char *)"info",      (char *)"debug", 
        (char *)((void *)0)};
#line 35 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
static ngx_log_t ngx_syslog_dummy_log  ;
#line 36 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
static ngx_event_t ngx_syslog_dummy_event  ;
#line 39 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
char *ngx_syslog_process_conf(ngx_conf_t *cf , ngx_syslog_peer_t *peer ) 
{ 
  char *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
#line 42
  peer->pool = cf->pool;
#line 43
  peer->facility = (ngx_uint_t )-1;
#line 44
  peer->severity = (ngx_uint_t )-1;
#line 46
  tmp = ngx_syslog_parse_args(cf, peer);
  }
#line 46
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 47
    return ((char *)((void *)-1));
  }
#line 50
  if ((unsigned long )peer->server.sockaddr == (unsigned long )((void *)0)) {
    {
#line 51
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "no syslog server specified");
    }
#line 53
    return ((char *)((void *)-1));
  }
#line 56
  if (peer->facility == 0xffffffffffffffffUL) {
#line 57
    peer->facility = (ngx_uint_t )23;
  }
#line 60
  if (peer->severity == 0xffffffffffffffffUL) {
#line 61
    peer->severity = (ngx_uint_t )6;
  }
#line 64
  if ((unsigned long )peer->tag.data == (unsigned long )((void *)0)) {
#line 65
    peer->tag.len = sizeof("nginx") - 1UL;
#line 65
    peer->tag.data = (u_char *)"nginx";
  }
#line 68
  peer->conn.fd = -1;
#line 70
  return ((char *)((void *)0));
}
}
#line 74 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
static char *ngx_syslog_parse_args(ngx_conf_t *cf , ngx_syslog_peer_t *peer ) 
{ 
  u_char *p ;
  u_char *comma ;
  u_char c ;
  size_t len ;
  ngx_str_t *value ;
  ngx_url_t u ;
  ngx_uint_t i ;
  char *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;

  {
#line 83
  value = (ngx_str_t *)(cf->args)->elts;
#line 85
  p = ((value + 1)->data + sizeof("syslog:")) - 1;
  {
#line 87
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 88
    tmp = strchr((char const   *)p, ',');
#line 88
    comma = (u_char *)tmp;
    }
#line 90
    if ((unsigned long )comma != (unsigned long )((void *)0)) {
#line 91
      len = (size_t )(comma - p);
#line 92
      *comma = (u_char )'\000';
    } else {
#line 95
      len = (size_t )(((value + 1)->data + (value + 1)->len) - p);
    }
    {
#line 98
    tmp___8 = strncmp((char const   *)p, "server=", (size_t )7);
    }
#line 98
    if (tmp___8 == 0) {
#line 100
      if ((unsigned long )peer->server.sockaddr != (unsigned long )((void *)0)) {
        {
#line 101
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate syslog \"server\"");
        }
#line 103
        return ((char *)((void *)-1));
      }
      {
#line 106
      memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 108
      u.url.data = p + 7;
#line 109
      u.url.len = len - 7UL;
#line 110
      u.default_port = (in_port_t )514;
#line 112
      tmp___0 = ngx_parse_url(cf->pool, & u);
      }
#line 112
      if (tmp___0 != 0L) {
#line 113
        if (u.err) {
          {
#line 114
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in syslog server \"%V\"",
                             u.err, & u.url);
          }
        }
#line 119
        return ((char *)((void *)-1));
      }
#line 122
      peer->server = *(u.addrs + 0);
    } else {
      {
#line 124
      tmp___7 = strncmp((char const   *)p, "facility=", (size_t )9);
      }
#line 124
      if (tmp___7 == 0) {
#line 126
        if (peer->facility != 0xffffffffffffffffUL) {
          {
#line 127
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate syslog \"facility\"");
          }
#line 129
          return ((char *)((void *)-1));
        }
#line 132
        i = (ngx_uint_t )0;
        {
#line 132
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 132
          if (! ((unsigned long )facilities[i] != (unsigned long )((void *)0))) {
#line 132
            goto while_break___0;
          }
          {
#line 134
          tmp___1 = strcmp((char const   *)p + 9, (char const   *)facilities[i]);
          }
#line 134
          if (tmp___1 == 0) {
#line 135
            peer->facility = i;
#line 136
            goto next;
          }
#line 132
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 140
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown syslog facility \"%s\"",
                           p + 9);
        }
#line 142
        return ((char *)((void *)-1));
      } else {
        {
#line 144
        tmp___6 = strncmp((char const   *)p, "severity=", (size_t )9);
        }
#line 144
        if (tmp___6 == 0) {
#line 146
          if (peer->severity != 0xffffffffffffffffUL) {
            {
#line 147
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate syslog \"severity\"");
            }
#line 149
            return ((char *)((void *)-1));
          }
#line 152
          i = (ngx_uint_t )0;
          {
#line 152
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 152
            if (! ((unsigned long )severities[i] != (unsigned long )((void *)0))) {
#line 152
              goto while_break___1;
            }
            {
#line 154
            tmp___2 = strcmp((char const   *)p + 9, (char const   *)severities[i]);
            }
#line 154
            if (tmp___2 == 0) {
#line 155
              peer->severity = i;
#line 156
              goto next;
            }
#line 152
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 160
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown syslog severity \"%s\"",
                             p + 9);
          }
#line 162
          return ((char *)((void *)-1));
        } else {
          {
#line 164
          tmp___5 = strncmp((char const   *)p, "tag=", (size_t )4);
          }
#line 164
          if (tmp___5 == 0) {
#line 166
            if ((unsigned long )peer->tag.data != (unsigned long )((void *)0)) {
              {
#line 167
              ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate syslog \"tag\"");
              }
#line 169
              return ((char *)((void *)-1));
            }
#line 176
            if (len - 4UL > 32UL) {
              {
#line 177
              ngx_conf_log_error((ngx_uint_t )1, cf, 0, "syslog tag length exceeds 32");
              }
#line 179
              return ((char *)((void *)-1));
            }
#line 182
            i = (ngx_uint_t )4;
            {
#line 182
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 182
              if (! (i < len)) {
#line 182
                goto while_break___2;
              }
#line 183
              if ((int )*(p + i) >= 65) {
#line 183
                if ((int )*(p + i) <= 90) {
#line 183
                  tmp___3 = (int )*(p + i) | 32;
                } else {
#line 183
                  tmp___3 = (int )*(p + i);
                }
              } else {
#line 183
                tmp___3 = (int )*(p + i);
              }
#line 183
              c = (u_char )tmp___3;
#line 185
              if ((int )c < 48) {
                {
#line 186
                ngx_conf_log_error((ngx_uint_t )1, cf, 0, "syslog \"tag\" only allows alphanumeric characters and underscore");
                }
#line 190
                return ((char *)((void *)-1));
              } else
#line 185
              if ((int )c > 57) {
#line 185
                if ((int )c < 97) {
#line 185
                  if ((int )c != 95) {
                    {
#line 186
                    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "syslog \"tag\" only allows alphanumeric characters and underscore");
                    }
#line 190
                    return ((char *)((void *)-1));
                  } else {
#line 185
                    goto _L___0;
                  }
                } else {
#line 185
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 185
              if ((int )c > 122) {
                {
#line 186
                ngx_conf_log_error((ngx_uint_t )1, cf, 0, "syslog \"tag\" only allows alphanumeric characters and underscore");
                }
#line 190
                return ((char *)((void *)-1));
              }
#line 182
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 194
            peer->tag.data = p + 4;
#line 195
            peer->tag.len = len - 4UL;
          } else
#line 197
          if (len == 10UL) {
            {
#line 197
            tmp___4 = strncmp((char const   *)p, "nohostname", (size_t )10);
            }
#line 197
            if (tmp___4 == 0) {
#line 198
              peer->nohostname = 1U;
            } else {
              {
#line 201
              ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown syslog parameter \"%s\"",
                                 p);
              }
#line 203
              return ((char *)((void *)-1));
            }
          } else {
            {
#line 201
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown syslog parameter \"%s\"",
                               p);
            }
#line 203
            return ((char *)((void *)-1));
          }
        }
      }
    }
    next: 
#line 208
    if ((unsigned long )comma == (unsigned long )((void *)0)) {
#line 209
      goto while_break;
    }
#line 212
    p = comma + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return ((char *)((void *)0));
}
}
#line 219 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
u_char *ngx_syslog_add_header(ngx_syslog_peer_t *peer , u_char *buf ) 
{ 
  ngx_uint_t pri ;
  u_char *tmp ;
  u_char *tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 224
  pri = peer->facility * 8UL + peer->severity;
#line 226
  if (peer->nohostname) {
    {
#line 227
    tmp = ngx_sprintf(buf, "<%ui>%V %V: ", pri, & ngx_cached_syslog_time, & peer->tag);
    }
#line 227
    return (tmp);
  }
  {
#line 231
  tmp___0 = ngx_sprintf(buf, "<%ui>%V %V %V: ", pri, & ngx_cached_syslog_time, & ngx_cycle->hostname,
                        & peer->tag);
  }
#line 231
  return (tmp___0);
}
}
#line 236 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
void ngx_syslog_writer(ngx_log_t *log , ngx_uint_t level , u_char *buf , size_t len ) 
{ 
  u_char *p ;
  u_char msg[(((((2048UL + sizeof("<255>Jan 01 00:00:00 ")) - 1UL) + 255UL) + 1UL) + 32UL) + 2UL] ;
  ngx_uint_t head_len ;
  ngx_syslog_peer_t *peer ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 244
  peer = (ngx_syslog_peer_t *)log->wdata;
#line 246
  if (peer->busy) {
#line 247
    return;
  }
  {
#line 250
  peer->busy = 1U;
#line 251
  peer->severity = level - 1UL;
#line 253
  p = ngx_syslog_add_header(peer, msg);
#line 254
  head_len = (ngx_uint_t )(p - msg);
#line 256
  len --;
  }
#line 258
  if (len > ((((((2048UL + sizeof("<255>Jan 01 00:00:00 ")) - 1UL) + 255UL) + 1UL) + 32UL) + 2UL) - head_len) {
#line 259
    len = ((((((2048UL + sizeof("<255>Jan 01 00:00:00 ")) - 1UL) + 255UL) + 1UL) + 32UL) + 2UL) - head_len;
  }
  {
#line 262
  p = ngx_snprintf(p, len, "%s", buf);
#line 264
  ngx_syslog_send(peer, msg, (size_t )(p - msg));
#line 266
  peer->busy = 0U;
  }
#line 267
  return;
}
}
#line 270 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
ssize_t ngx_syslog_send(ngx_syslog_peer_t *peer , u_char *buf , size_t len ) 
{ 
  ssize_t n ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp8 ;

  {
#line 275
  if (peer->conn.fd == -1) {
    {
#line 276
    tmp = ngx_syslog_init_peer(peer);
    }
#line 276
    if (tmp != 0L) {
#line 277
      return ((ssize_t )-1);
    }
  }
#line 282
  peer->conn.log = (ngx_log_t *)ngx_cycle->log;
#line 284
  if (ngx_io.send) {
    {
#line 285
    n = (*(ngx_io.send))(& peer->conn, buf, len);
    }
  } else {
    {
#line 289
    n = (*(ngx_os_io.send))(& peer->conn, buf, len);
    }
  }
#line 294
  if (n == -1L) {
#line 294
    if ((int )(peer->server.sockaddr)->sa_family == 1) {
      {
#line 296
      tmp___1 = close(peer->conn.fd);
      }
#line 296
      if (tmp___1 == -1) {
#line 297
        if ((ngx_cycle->log)->log_level >= 2UL) {
          {
#line 297
          tmp___0 = __errno_location();
#line 297
          ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___0,
                             "close() socket failed");
          }
        }
      }
#line 301
      peer->conn.fd = -1;
    }
  }
#line 306
  return (n);
}
}
#line 310 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
static ngx_int_t ngx_syslog_init_peer(ngx_syslog_peer_t *peer ) 
{ 
  ngx_socket_t fd ;
  ngx_pool_cleanup_t *cln ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 316
  peer->conn.read = & ngx_syslog_dummy_event;
#line 317
  peer->conn.write = & ngx_syslog_dummy_event;
#line 319
  ngx_syslog_dummy_event.log = & ngx_syslog_dummy_log;
#line 321
  fd = socket((int )(peer->server.sockaddr)->sa_family, 2, 0);
  }
#line 322
  if (fd == -1) {
#line 323
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 323
      tmp = __errno_location();
#line 323
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp, "socket() failed");
      }
    }
#line 325
    return ((ngx_int_t )-1);
  }
  {
#line 328
  tmp___1 = ngx_nonblocking(fd);
  }
#line 328
  if (tmp___1 == -1) {
#line 329
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 329
      tmp___0 = __errno_location();
#line 329
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___0, "ioctl(FIONBIO) failed");
      }
    }
#line 331
    goto failed;
  }
  {
#line 334
  tmp___3 = connect(fd, (struct sockaddr  const  */* __restrict  */)peer->server.sockaddr,
                    peer->server.socklen);
  }
#line 334
  if (tmp___3 == -1) {
#line 335
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 335
      tmp___2 = __errno_location();
#line 335
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___2, "connect() failed");
      }
    }
#line 337
    goto failed;
  }
  {
#line 340
  cln = ngx_pool_cleanup_add(peer->pool, (size_t )0);
  }
#line 341
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 342
    goto failed;
  }
#line 345
  cln->data = (void *)peer;
#line 346
  cln->handler = & ngx_syslog_cleanup;
#line 348
  peer->conn.fd = fd;
#line 351
  (peer->conn.write)->ready = 1U;
#line 353
  return ((ngx_int_t )0);
  failed: 
  {
#line 357
  tmp___5 = close(fd);
  }
#line 357
  if (tmp___5 == -1) {
#line 358
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 358
      tmp___4 = __errno_location();
#line 358
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___4, "close() socket failed");
      }
    }
  }
#line 362
  return ((ngx_int_t )-1);
}
}
#line 366 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_syslog.c"
static void ngx_syslog_cleanup(void *data ) 
{ 
  ngx_syslog_peer_t *peer ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 369
  peer = (ngx_syslog_peer_t *)data;
#line 372
  peer->busy = 1U;
#line 374
  if (peer->conn.fd == -1) {
#line 375
    return;
  }
  {
#line 378
  tmp___0 = close(peer->conn.fd);
  }
#line 378
  if (tmp___0 == -1) {
#line 379
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 379
      tmp = __errno_location();
#line 379
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp, "close() socket failed");
      }
    }
  }
#line 382
  return;
}
}
#line 153 "src/core/ngx_string.h"
u_char *ngx_slprintf(u_char *buf , u_char *last , char const   *fmt  , ...) ;
#line 21 "src/core/ngx_proxy_protocol.h"
u_char *ngx_proxy_protocol_write(ngx_connection_t *c , u_char *buf , u_char *last ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_proxy_protocol.c"
u_char *ngx_proxy_protocol_read(ngx_connection_t *c , u_char *buf , u_char *last ) 
{ 
  size_t len ;
  u_char ch ;
  u_char *p ;
  u_char *addr ;
  u_char *port ;
  ngx_int_t n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  u_char *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  char *__cil_tmp17 ;

  {
#line 19
  p = buf;
#line 20
  len = (size_t )(last - buf);
#line 22
  if (len < 8UL) {
#line 23
    goto invalid;
  } else {
    {
#line 22
    tmp = strncmp((char const   *)p, "PROXY ", (size_t )6);
    }
#line 22
    if (tmp != 0) {
#line 23
      goto invalid;
    }
  }
#line 26
  p += 6;
#line 27
  len -= 6UL;
#line 29
  if (len >= 7UL) {
    {
#line 29
    tmp___0 = strncmp((char const   *)p, "UNKNOWN", (size_t )7);
    }
#line 29
    if (tmp___0 == 0) {
#line 32
      p += 7;
#line 33
      goto skip;
    }
  }
#line 36
  if (len < 5UL) {
#line 39
    goto invalid;
  } else {
    {
#line 36
    tmp___1 = strncmp((char const   *)p, "TCP", (size_t )3);
    }
#line 36
    if (tmp___1 != 0) {
#line 39
      goto invalid;
    } else
#line 36
    if ((int )*(p + 3) != 52) {
#line 36
      if ((int )*(p + 3) != 54) {
#line 39
        goto invalid;
      } else {
#line 36
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 36
    if ((int )*(p + 4) != 32) {
#line 39
      goto invalid;
    }
  }
#line 42
  p += 5;
#line 43
  addr = p;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if ((unsigned long )p == (unsigned long )last) {
#line 47
      goto invalid;
    }
#line 50
    tmp___2 = p;
#line 50
    p ++;
#line 50
    ch = *tmp___2;
#line 52
    if ((int )ch == 32) {
#line 53
      goto while_break;
    }
#line 56
    if ((int )ch != 58) {
#line 56
      if ((int )ch != 46) {
#line 56
        if ((int )ch < 97) {
#line 56
          goto _L___1;
        } else
#line 56
        if ((int )ch > 102) {
          _L___1: /* CIL Label */ 
#line 56
          if ((int )ch < 65) {
#line 56
            goto _L___0;
          } else
#line 56
          if ((int )ch > 70) {
            _L___0: /* CIL Label */ 
#line 56
            if ((int )ch < 48) {
#line 61
              goto invalid;
            } else
#line 56
            if ((int )ch > 57) {
#line 61
              goto invalid;
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 65
  len = (size_t )((p - addr) - 1L);
#line 66
  tmp___3 = ngx_pnalloc(c->pool, len);
#line 66
  c->proxy_protocol_addr.data = (u_char *)tmp___3;
  }
#line 68
  if ((unsigned long )c->proxy_protocol_addr.data == (unsigned long )((void *)0)) {
#line 69
    return ((u_char *)((void *)0));
  }
  {
#line 72
  memcpy((void */* __restrict  */)c->proxy_protocol_addr.data, (void const   */* __restrict  */)addr,
         len);
#line 73
  c->proxy_protocol_addr.len = len;
  }
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 76
    if ((unsigned long )p == (unsigned long )last) {
#line 77
      goto invalid;
    }
#line 80
    tmp___4 = p;
#line 80
    p ++;
#line 80
    if ((int )*tmp___4 == 32) {
#line 81
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 85
  port = p;
  {
#line 87
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 88
    if ((unsigned long )p == (unsigned long )last) {
#line 89
      goto invalid;
    }
#line 92
    tmp___5 = p;
#line 92
    p ++;
#line 92
    if ((int )*tmp___5 == 32) {
#line 93
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  len = (size_t )((p - port) - 1L);
#line 99
  n = ngx_atoi(port, len);
  }
#line 101
  if (n < 0L) {
#line 102
    goto invalid;
  } else
#line 101
  if (n > 65535L) {
#line 102
    goto invalid;
  }
#line 105
  c->proxy_protocol_port = (in_port_t )n;
  skip: 
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )p < (unsigned long )(last - 1))) {
#line 112
      goto while_break___2;
    }
#line 113
    if ((int )*(p + 0) == 13) {
#line 113
      if ((int )*(p + 1) == 10) {
#line 114
        return (p + 2);
      }
    }
#line 112
    p ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  invalid: 
#line 120
  if ((c->log)->log_level >= 4UL) {
    {
#line 120
    ngx_log_error_core((ngx_uint_t )4, c->log, 0, "broken header: \"%*s\"", (size_t )(last - buf),
                       buf);
    }
  }
#line 123
  return ((u_char *)((void *)0));
}
}
#line 127 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_proxy_protocol.c"
u_char *ngx_proxy_protocol_write(ngx_connection_t *c , u_char *buf , u_char *last ) 
{ 
  ngx_uint_t port ;
  ngx_uint_t lport ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  u_char *tmp___4 ;
  size_t tmp___5 ;
  in_port_t tmp___6 ;
  in_port_t tmp___7 ;
  u_char *tmp___8 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 132
  if (last - buf < 107L) {
#line 133
    return ((u_char *)((void *)0));
  }
  {
#line 136
  tmp = ngx_connection_local_sockaddr(c, (ngx_str_t *)((void *)0), (ngx_uint_t )0);
  }
#line 136
  if (tmp != 0L) {
#line 137
    return ((u_char *)((void *)0));
  }
  {
#line 142
  if ((int )(c->sockaddr)->sa_family == 2) {
#line 142
    goto case_2;
  }
#line 147
  if ((int )(c->sockaddr)->sa_family == 10) {
#line 147
    goto case_10;
  }
#line 152
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 143
  tmp___0 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"PROXY TCP4 ",
                   sizeof("PROXY TCP4 ") - 1UL);
#line 143
  buf = (u_char *)tmp___0 + (sizeof("PROXY TCP4 ") - 1UL);
  }
#line 144
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 148
  tmp___1 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"PROXY TCP6 ",
                   sizeof("PROXY TCP6 ") - 1UL);
#line 148
  buf = (u_char *)tmp___1 + (sizeof("PROXY TCP6 ") - 1UL);
  }
#line 149
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 153
  tmp___2 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)"PROXY UNKNOWN\r\n",
                   sizeof("PROXY UNKNOWN\r\n") - 1UL);
  }
#line 153
  return ((u_char *)tmp___2 + (sizeof("PROXY UNKNOWN\r\n") - 1UL));
  switch_break: /* CIL Label */ ;
  }
  {
#line 157
  tmp___3 = ngx_sock_ntop(c->sockaddr, c->socklen, buf, (size_t )(last - buf), (ngx_uint_t )0);
#line 157
  buf += tmp___3;
#line 159
  tmp___4 = buf;
#line 159
  buf ++;
#line 159
  *tmp___4 = (u_char )' ';
#line 161
  tmp___5 = ngx_sock_ntop(c->local_sockaddr, c->local_socklen, buf, (size_t )(last - buf),
                          (ngx_uint_t )0);
#line 161
  buf += tmp___5;
#line 164
  tmp___6 = ngx_inet_get_port(c->sockaddr);
#line 164
  port = (ngx_uint_t )tmp___6;
#line 165
  tmp___7 = ngx_inet_get_port(c->local_sockaddr);
#line 165
  lport = (ngx_uint_t )tmp___7;
#line 167
  tmp___8 = ngx_slprintf(buf, last, " %ui %ui\r\n", port, lport);
  }
#line 167
  return (tmp___8);
}
}
#line 23 "src/core/ngx_sha1.h"
void ngx_sha1_init(ngx_sha1_t *ctx ) ;
#line 24
void ngx_sha1_update(ngx_sha1_t *ctx , void const   *data , size_t size ) ;
#line 25
void ngx_sha1_final(u_char *result___0 , ngx_sha1_t *ctx ) ;
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_apr1(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 18
static ngx_int_t ngx_crypt_plain(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 20
static ngx_int_t ngx_crypt_ssha(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 22
static ngx_int_t ngx_crypt_sha(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) ;
#line 26
static u_char *ngx_crypt_to64(u_char *p , uint32_t v , size_t n ) ;
#line 29 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crypt.c"
ngx_int_t ngx_crypt(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  ngx_int_t tmp___7 ;

  {
  {
#line 32
  tmp___6 = strncmp((char const   *)salt, "$apr1$", sizeof("$apr1$") - 1UL);
  }
#line 32
  if (tmp___6 == 0) {
    {
#line 33
    tmp = ngx_crypt_apr1(pool, key, salt, encrypted);
    }
#line 33
    return (tmp);
  } else {
    {
#line 35
    tmp___5 = strncmp((char const   *)salt, "{PLAIN}", sizeof("{PLAIN}") - 1UL);
    }
#line 35
    if (tmp___5 == 0) {
      {
#line 36
      tmp___0 = ngx_crypt_plain(pool, key, salt, encrypted);
      }
#line 36
      return (tmp___0);
    } else {
      {
#line 38
      tmp___4 = strncmp((char const   *)salt, "{SSHA}", sizeof("{SSHA}") - 1UL);
      }
#line 38
      if (tmp___4 == 0) {
        {
#line 39
        tmp___1 = ngx_crypt_ssha(pool, key, salt, encrypted);
        }
#line 39
        return (tmp___1);
      } else {
        {
#line 41
        tmp___3 = strncmp((char const   *)salt, "{SHA}", sizeof("{SHA}") - 1UL);
        }
#line 41
        if (tmp___3 == 0) {
          {
#line 42
          tmp___2 = ngx_crypt_sha(pool, key, salt, encrypted);
          }
#line 42
          return (tmp___2);
        }
      }
    }
  }
  {
#line 47
  tmp___7 = ngx_libc_crypt(pool, key, salt, encrypted);
  }
#line 47
  return (tmp___7);
}
}
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_apr1(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  ngx_int_t n ;
  ngx_uint_t i ;
  u_char *p ;
  u_char *last ;
  u_char final[16] ;
  size_t saltlen ;
  size_t keylen ;
  ngx_md5_t md5 ;
  ngx_md5_t ctx1 ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  void *__cil_tmp19 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 62
  keylen = strlen((char const   *)key);
#line 66
  salt += sizeof("$apr1$") - 1UL;
#line 67
  last = salt + 8;
#line 68
  p = salt;
  }
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (*p) {
#line 68
      if ((int )*p != 36) {
#line 68
        if (! ((unsigned long )p < (unsigned long )last)) {
#line 68
          goto while_break;
        }
      } else {
#line 68
        goto while_break;
      }
    } else {
#line 68
      goto while_break;
    }
#line 68
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  saltlen = (size_t )(p - salt);
#line 73
  ngx_md5_init(& md5);
#line 74
  ngx_md5_update(& md5, (void const   *)key, keylen);
#line 75
  ngx_md5_update(& md5, (void const   *)((u_char *)"$apr1$"), sizeof("$apr1$") - 1UL);
#line 76
  ngx_md5_update(& md5, (void const   *)salt, saltlen);
#line 78
  ngx_md5_init(& ctx1);
#line 79
  ngx_md5_update(& ctx1, (void const   *)key, keylen);
#line 80
  ngx_md5_update(& ctx1, (void const   *)salt, saltlen);
#line 81
  ngx_md5_update(& ctx1, (void const   *)key, keylen);
#line 82
  ngx_md5_final((u_char *)(final), & ctx1);
#line 84
  n = (ngx_int_t )keylen;
  }
  {
#line 84
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 84
    if (! (n > 0L)) {
#line 84
      goto while_break___0;
    }
#line 85
    if (n > 16L) {
#line 85
      tmp = (ngx_int_t )16;
    } else {
#line 85
      tmp = n;
    }
    {
#line 85
    ngx_md5_update(& md5, (void const   *)(final), (size_t )tmp);
#line 84
    n -= 16L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 88
  memset((void *)(final), 0, sizeof(final));
#line 90
  i = keylen;
  }
  {
#line 90
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 90
    if (! i) {
#line 90
      goto while_break___1;
    }
#line 91
    if (i & 1UL) {
      {
#line 92
      ngx_md5_update(& md5, (void const   *)(final), (size_t )1);
      }
    } else {
      {
#line 95
      ngx_md5_update(& md5, (void const   *)key, (size_t )1);
      }
    }
#line 90
    i >>= 1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 99
  ngx_md5_final((u_char *)(final), & md5);
#line 101
  i = (ngx_uint_t )0;
  }
  {
#line 101
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 101
    if (! (i < 1000UL)) {
#line 101
      goto while_break___2;
    }
    {
#line 102
    ngx_md5_init(& ctx1);
    }
#line 104
    if (i & 1UL) {
      {
#line 105
      ngx_md5_update(& ctx1, (void const   *)key, keylen);
      }
    } else {
      {
#line 108
      ngx_md5_update(& ctx1, (void const   *)(final), (size_t )16);
      }
    }
#line 111
    if (i % 3UL) {
      {
#line 112
      ngx_md5_update(& ctx1, (void const   *)salt, saltlen);
      }
    }
#line 115
    if (i % 7UL) {
      {
#line 116
      ngx_md5_update(& ctx1, (void const   *)key, keylen);
      }
    }
#line 119
    if (i & 1UL) {
      {
#line 120
      ngx_md5_update(& ctx1, (void const   *)(final), (size_t )16);
      }
    } else {
      {
#line 123
      ngx_md5_update(& ctx1, (void const   *)key, keylen);
      }
    }
    {
#line 126
    ngx_md5_final((u_char *)(final), & ctx1);
#line 101
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 131
  tmp___0 = ngx_pnalloc(pool, ((((sizeof("$apr1$") - 1UL) + saltlen) + 1UL) + 22UL) + 1UL);
#line 131
  *encrypted = (u_char *)tmp___0;
  }
#line 132
  if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 133
    return ((ngx_int_t )-1);
  }
  {
#line 136
  tmp___1 = memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)"$apr1$",
                   sizeof("$apr1$") - 1UL);
#line 136
  p = (u_char *)tmp___1 + (sizeof("$apr1$") - 1UL);
#line 137
  tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)salt,
                   saltlen);
#line 137
  p = (u_char *)tmp___2 + saltlen;
#line 138
  tmp___3 = p;
#line 138
  p ++;
#line 138
  *tmp___3 = (u_char )'$';
#line 140
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[0] << 16) | ((int )final[6] << 8)) | (int )final[12]),
                     (size_t )4);
#line 141
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[1] << 16) | ((int )final[7] << 8)) | (int )final[13]),
                     (size_t )4);
#line 142
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[2] << 16) | ((int )final[8] << 8)) | (int )final[14]),
                     (size_t )4);
#line 143
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[3] << 16) | ((int )final[9] << 8)) | (int )final[15]),
                     (size_t )4);
#line 144
  p = ngx_crypt_to64(p, (uint32_t )((((int )final[4] << 16) | ((int )final[10] << 8)) | (int )final[5]),
                     (size_t )4);
#line 145
  p = ngx_crypt_to64(p, (uint32_t )final[11], (size_t )2);
#line 146
  *p = (u_char )'\000';
  }
#line 148
  return ((ngx_int_t )0);
}
}
#line 155 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crypt.c"
static u_char itoa64[65]  = 
#line 155
  {      (u_char )'.',      (u_char )'/',      (u_char )'0',      (u_char )'1', 
        (u_char )'2',      (u_char )'3',      (u_char )'4',      (u_char )'5', 
        (u_char )'6',      (u_char )'7',      (u_char )'8',      (u_char )'9', 
        (u_char )'A',      (u_char )'B',      (u_char )'C',      (u_char )'D', 
        (u_char )'E',      (u_char )'F',      (u_char )'G',      (u_char )'H', 
        (u_char )'I',      (u_char )'J',      (u_char )'K',      (u_char )'L', 
        (u_char )'M',      (u_char )'N',      (u_char )'O',      (u_char )'P', 
        (u_char )'Q',      (u_char )'R',      (u_char )'S',      (u_char )'T', 
        (u_char )'U',      (u_char )'V',      (u_char )'W',      (u_char )'X', 
        (u_char )'Y',      (u_char )'Z',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'g',      (u_char )'h',      (u_char )'i',      (u_char )'j', 
        (u_char )'k',      (u_char )'l',      (u_char )'m',      (u_char )'n', 
        (u_char )'o',      (u_char )'p',      (u_char )'q',      (u_char )'r', 
        (u_char )'s',      (u_char )'t',      (u_char )'u',      (u_char )'v', 
        (u_char )'w',      (u_char )'x',      (u_char )'y',      (u_char )'z', 
        (u_char )'\000'};
#line 152 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crypt.c"
static u_char *ngx_crypt_to64(u_char *p , uint32_t v , size_t n ) 
{ 
  u_char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    tmp___0 = n;
#line 158
    n --;
#line 158
    if (! tmp___0) {
#line 158
      goto while_break;
    }
#line 159
    tmp = p;
#line 159
    p ++;
#line 159
    *tmp = itoa64[v & 63U];
#line 160
    v >>= 6;
  }
  while_break: /* CIL Label */ ;
  }
#line 163
  return (p);
}
}
#line 167 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_plain(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  size_t len ;
  u_char *p ;
  void *tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 173
  len = strlen((char const   *)key);
#line 175
  tmp = ngx_pnalloc(pool, ((sizeof("{PLAIN}") - 1UL) + len) + 1UL);
#line 175
  *encrypted = (u_char *)tmp;
  }
#line 176
  if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 177
    return ((ngx_int_t )-1);
  }
  {
#line 180
  tmp___0 = memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)"{PLAIN}",
                   sizeof("{PLAIN}") - 1UL);
#line 180
  p = (u_char *)tmp___0 + (sizeof("{PLAIN}") - 1UL);
#line 181
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)key, len + 1UL);
  }
#line 183
  return ((ngx_int_t )0);
}
}
#line 187 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_ssha(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  size_t len ;
  ngx_int_t rc ;
  ngx_str_t encoded ;
  ngx_str_t decoded ;
  ngx_sha1_t sha1 ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 199
  encoded.data = (salt + sizeof("{SSHA}")) - 1;
#line 200
  encoded.len = strlen((char const   *)encoded.data);
  }
#line 202
  if (((encoded.len + 3UL) / 4UL) * 3UL < 20UL) {
#line 202
    len = (size_t )20;
  } else {
#line 202
    len = ((encoded.len + 3UL) / 4UL) * 3UL;
  }
  {
#line 204
  tmp = ngx_pnalloc(pool, len);
#line 204
  decoded.data = (u_char *)tmp;
  }
#line 205
  if ((unsigned long )decoded.data == (unsigned long )((void *)0)) {
#line 206
    return ((ngx_int_t )-1);
  }
  {
#line 209
  rc = ngx_decode_base64(& decoded, & encoded);
  }
#line 211
  if (rc != 0L) {
#line 212
    decoded.len = (size_t )20;
  } else
#line 211
  if (decoded.len < 20UL) {
#line 212
    decoded.len = (size_t )20;
  }
  {
#line 217
  ngx_sha1_init(& sha1);
#line 218
  tmp___0 = strlen((char const   *)key);
#line 218
  ngx_sha1_update(& sha1, (void const   *)key, tmp___0);
#line 219
  ngx_sha1_update(& sha1, (void const   *)(decoded.data + 20), decoded.len - 20UL);
#line 220
  ngx_sha1_final((u_char *)decoded.data, & sha1);
#line 224
  len = ((sizeof("{SSHA}") - 1UL) + ((decoded.len + 2UL) / 3UL) * 4UL) + 1UL;
#line 226
  tmp___1 = ngx_pnalloc(pool, len);
#line 226
  *encrypted = (u_char *)tmp___1;
  }
#line 227
  if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 228
    return ((ngx_int_t )-1);
  }
  {
#line 231
  tmp___2 = memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)"{SSHA}",
                   sizeof("{SSHA}") - 1UL);
#line 231
  encoded.data = (u_char *)tmp___2 + (sizeof("{SSHA}") - 1UL);
#line 232
  ngx_encode_base64(& encoded, & decoded);
#line 233
  *(encoded.data + encoded.len) = (u_char )'\000';
  }
#line 235
  return ((ngx_int_t )0);
}
}
#line 239 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crypt.c"
static ngx_int_t ngx_crypt_sha(ngx_pool_t *pool , u_char *key , u_char *salt , u_char **encrypted ) 
{ 
  size_t len ;
  ngx_str_t encoded ;
  ngx_str_t decoded ;
  ngx_sha1_t sha1 ;
  u_char digest[20] ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
  {
#line 249
  decoded.len = sizeof(digest);
#line 250
  decoded.data = digest;
#line 252
  ngx_sha1_init(& sha1);
#line 253
  tmp = strlen((char const   *)key);
#line 253
  ngx_sha1_update(& sha1, (void const   *)key, tmp);
#line 254
  ngx_sha1_final((u_char *)(digest), & sha1);
#line 256
  len = ((sizeof("{SHA}") - 1UL) + ((decoded.len + 2UL) / 3UL) * 4UL) + 1UL;
#line 258
  tmp___0 = ngx_pnalloc(pool, len);
#line 258
  *encrypted = (u_char *)tmp___0;
  }
#line 259
  if ((unsigned long )*encrypted == (unsigned long )((void *)0)) {
#line 260
    return ((ngx_int_t )-1);
  }
  {
#line 263
  tmp___1 = memcpy((void */* __restrict  */)*encrypted, (void const   */* __restrict  */)"{SHA}",
                   sizeof("{SHA}") - 1UL);
#line 263
  encoded.data = (u_char *)tmp___1 + (sizeof("{SHA}") - 1UL);
#line 264
  ngx_encode_base64(& encoded, & decoded);
#line 265
  *(encoded.data + encoded.len) = (u_char )'\000';
  }
#line 267
  return ((ngx_int_t )0);
}
}
#line 243 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2,3), __leaf__)) fstatat)(int __fd ,
                                                                                                char const   * __restrict  __file ,
                                                                                                struct stat * __restrict  __buf ,
                                                                                                int __flag )  __asm__("fstatat64")  ;
#line 174 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(2))) openat)(int __fd , char const   *__file ,
                                                     int __oflag  , ...)  __asm__("openat64")  ;
#line 88 "src/core/ngx_palloc.h"
void ngx_pool_cleanup_file(void *data ) ;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cache_cleanup(void *data ) ;
#line 26
static ngx_fd_t ngx_openat_file_owner(ngx_fd_t at_fd , u_char const   *name , ngx_int_t mode ,
                                      ngx_int_t create , ngx_int_t access___0 , ngx_log_t *log ) ;
#line 29
static ngx_int_t ngx_file_o_path_info(ngx_fd_t fd , ngx_file_info_t *fi , ngx_log_t *log ) ;
#line 33
static ngx_fd_t ngx_open_file_wrapper(ngx_str_t *name , ngx_open_file_info_t *of ,
                                      ngx_int_t mode , ngx_int_t create , ngx_int_t access___0 ,
                                      ngx_log_t *log ) ;
#line 36
static ngx_int_t ngx_file_info_wrapper(ngx_str_t *name , ngx_open_file_info_t *of ,
                                       ngx_file_info_t *fi , ngx_log_t *log ) ;
#line 38
static ngx_int_t ngx_open_and_stat_file(ngx_str_t *name , ngx_open_file_info_t *of ,
                                        ngx_log_t *log ) ;
#line 40
static void ngx_open_file_add_event(ngx_open_file_cache_t *cache , ngx_cached_open_file_t *file ,
                                    ngx_open_file_info_t *of , ngx_log_t *log ) ;
#line 42
static void ngx_open_file_cleanup(void *data ) ;
#line 43
static void ngx_close_cached_file(ngx_open_file_cache_t *cache , ngx_cached_open_file_t *file ,
                                  ngx_uint_t min_uses , ngx_log_t *log ) ;
#line 45
static void ngx_open_file_del_event(ngx_cached_open_file_t *file ) ;
#line 46
static void ngx_expire_old_cached_files(ngx_open_file_cache_t *cache , ngx_uint_t n ,
                                        ngx_log_t *log ) ;
#line 48
static void ngx_open_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) ;
#line 50
static ngx_cached_open_file_t *ngx_open_file_lookup(ngx_open_file_cache_t *cache ,
                                                    ngx_str_t *name , uint32_t hash ) ;
#line 53
static void ngx_open_file_cache_remove(ngx_event_t *ev ) ;
#line 56 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
ngx_open_file_cache_t *ngx_open_file_cache_init(ngx_pool_t *pool , ngx_uint_t max ,
                                                time_t inactive ) 
{ 
  ngx_pool_cleanup_t *cln ;
  ngx_open_file_cache_t *cache ;
  void *tmp ;

  {
  {
#line 62
  tmp = ngx_palloc(pool, sizeof(ngx_open_file_cache_t ));
#line 62
  cache = (ngx_open_file_cache_t *)tmp;
  }
#line 63
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 64
    return ((ngx_open_file_cache_t *)((void *)0));
  }
  {
#line 67
  cache->sentinel.color = (u_char )0;
#line 67
  cache->rbtree.root = & cache->sentinel;
#line 67
  cache->rbtree.sentinel = & cache->sentinel;
#line 67
  cache->rbtree.insert = & ngx_open_file_cache_rbtree_insert_value;
#line 70
  cache->expire_queue.prev = & cache->expire_queue;
#line 70
  cache->expire_queue.next = & cache->expire_queue;
#line 72
  cache->current = (ngx_uint_t )0;
#line 73
  cache->max = max;
#line 74
  cache->inactive = inactive;
#line 76
  cln = ngx_pool_cleanup_add(pool, (size_t )0);
  }
#line 77
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 78
    return ((ngx_open_file_cache_t *)((void *)0));
  }
#line 81
  cln->handler = & ngx_open_file_cache_cleanup;
#line 82
  cln->data = (void *)cache;
#line 84
  return (cache);
}
}
#line 88 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cache_cleanup(void *data ) 
{ 
  ngx_open_file_cache_t *cache ;
  ngx_queue_t *q ;
  ngx_cached_open_file_t *file ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 91
  cache = (ngx_open_file_cache_t *)data;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 101
    if ((unsigned long )(& cache->expire_queue) == (unsigned long )cache->expire_queue.prev) {
#line 102
      goto while_break;
    }
    {
#line 105
    q = cache->expire_queue.prev;
#line 107
    file = (ngx_cached_open_file_t *)((u_char *)q - (unsigned long )(& ((ngx_cached_open_file_t *)0)->queue));
#line 109
    (q->next)->prev = q->prev;
#line 109
    (q->prev)->next = q->next;
#line 111
    ngx_rbtree_delete(& cache->rbtree, & file->node);
#line 113
    (cache->current) --;
    }
#line 118
    if (! file->err) {
#line 118
      if (! file->is_dir) {
        {
#line 119
        file->close = 1U;
#line 120
        file->count = 0U;
#line 121
        ngx_close_cached_file(cache, file, (ngx_uint_t )0, (ngx_log_t *)ngx_cycle->log);
        }
      } else {
        {
#line 124
        free((void *)file->name);
#line 125
        free((void *)file);
        }
      }
    } else {
      {
#line 124
      free((void *)file->name);
#line 125
      free((void *)file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 129
  if (cache->current) {
#line 130
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 130
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "%ui items still left in open file cache",
                         cache->current);
      }
    }
  }
#line 135
  if ((unsigned long )cache->rbtree.root != (unsigned long )cache->rbtree.sentinel) {
#line 136
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 136
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "rbtree still is not empty in open file cache");
      }
    }
  }
#line 140
  return;
}
}
#line 143 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
ngx_int_t ngx_open_cached_file(ngx_open_file_cache_t *cache , ngx_str_t *name , ngx_open_file_info_t *of ,
                               ngx_pool_t *pool ) 
{ 
  time_t now ;
  uint32_t hash ;
  ngx_int_t rc ;
  ngx_file_info_t fi ;
  ngx_pool_cleanup_t *cln ;
  ngx_cached_open_file_t *file ;
  ngx_pool_cleanup_file_t *clnf ;
  ngx_open_file_cache_cleanup_t *ofcln ;
  ngx_int_t tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  void *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 156
  of->fd = -1;
#line 157
  of->err = 0;
#line 159
  if ((unsigned long )cache == (unsigned long )((void *)0)) {
#line 161
    if (of->test_only) {
      {
#line 163
      tmp = ngx_file_info_wrapper(name, of, & fi, pool->log);
      }
#line 163
      if (tmp == -1L) {
#line 166
        return ((ngx_int_t )-1);
      }
#line 169
      of->uniq = fi.st_ino;
#line 170
      of->mtime = fi.st_mtim.tv_sec;
#line 171
      of->size = fi.st_size;
#line 172
      if (fi.st_size < fi.st_blocks * 512L) {
#line 172
        of->fs_size = fi.st_blocks * 512L;
      } else {
#line 172
        of->fs_size = fi.st_size;
      }
#line 173
      of->is_dir = (unsigned int )((fi.st_mode & 61440U) == 16384U);
#line 174
      of->is_file = (unsigned int )((fi.st_mode & 61440U) == 32768U);
#line 175
      of->is_link = (unsigned int )((fi.st_mode & 61440U) == 40960U);
#line 176
      of->is_exec = (unsigned int )((fi.st_mode & 64U) == 64U);
#line 178
      return ((ngx_int_t )0);
    }
    {
#line 181
    cln = ngx_pool_cleanup_add(pool, sizeof(ngx_pool_cleanup_file_t ));
    }
#line 182
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 183
      return ((ngx_int_t )-1);
    }
    {
#line 186
    rc = ngx_open_and_stat_file(name, of, pool->log);
    }
#line 188
    if (rc == 0L) {
#line 188
      if (! of->is_dir) {
#line 189
        cln->handler = & ngx_pool_cleanup_file;
#line 190
        clnf = (ngx_pool_cleanup_file_t *)cln->data;
#line 192
        clnf->fd = of->fd;
#line 193
        clnf->name = name->data;
#line 194
        clnf->log = pool->log;
      }
    }
#line 197
    return (rc);
  }
  {
#line 200
  cln = ngx_pool_cleanup_add(pool, sizeof(ngx_open_file_cache_cleanup_t ));
  }
#line 201
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 202
    return ((ngx_int_t )-1);
  }
  {
#line 205
  now = (time_t )ngx_cached_time->sec;
#line 207
  hash = ngx_crc32_long(name->data, name->len);
#line 209
  file = ngx_open_file_lookup(cache, name, hash);
  }
#line 211
  if (file) {
#line 213
    (file->uses) ++;
#line 215
    (file->queue.next)->prev = file->queue.prev;
#line 215
    (file->queue.prev)->next = file->queue.next;
#line 217
    if (file->fd == -1) {
#line 217
      if (file->err == 0) {
#line 217
        if (! file->is_dir) {
          {
#line 221
          rc = ngx_open_and_stat_file(name, of, pool->log);
          }
#line 223
          if (rc != 0L) {
#line 223
            if (of->err == 0) {
#line 224
              goto failed;
            } else
#line 223
            if (! of->errors) {
#line 224
              goto failed;
            }
          }
#line 227
          goto add_event;
        }
      }
    }
#line 230
    if (file->use_event) {
#line 230
      goto _L;
    } else
#line 230
    if ((unsigned long )file->event == (unsigned long )((void *)0)) {
#line 230
      if (of->uniq == 0UL) {
#line 230
        goto _L___0;
      } else
#line 230
      if (of->uniq == file->uniq) {
        _L___0: /* CIL Label */ 
#line 230
        if (now - file->created < of->valid) {
#line 230
          if (of->disable_symlinks == file->disable_symlinks) {
#line 230
            if (of->disable_symlinks_from == file->disable_symlinks_from) {
              _L: /* CIL Label */ 
#line 240
              if (file->err == 0) {
#line 242
                of->fd = file->fd;
#line 243
                of->uniq = file->uniq;
#line 244
                of->mtime = file->mtime;
#line 245
                of->size = file->size;
#line 247
                of->is_dir = file->is_dir;
#line 248
                of->is_file = file->is_file;
#line 249
                of->is_link = file->is_link;
#line 250
                of->is_exec = file->is_exec;
#line 251
                of->is_directio = file->is_directio;
#line 253
                if (! file->is_dir) {
                  {
#line 254
                  (file->count) ++;
#line 255
                  ngx_open_file_add_event(cache, file, of, pool->log);
                  }
                }
              } else {
#line 259
                of->err = file->err;
#line 261
                if (file->disable_symlinks) {
#line 261
                  of->failed = (char *)"openat()";
                } else {
#line 261
                  of->failed = (char *)"open()";
                }
              }
#line 268
              goto found;
            }
          }
        }
      }
    }
#line 275
    if (file->is_dir) {
#line 283
      of->test_dir = 1U;
    }
    {
#line 286
    of->fd = file->fd;
#line 287
    of->uniq = file->uniq;
#line 289
    rc = ngx_open_and_stat_file(name, of, pool->log);
    }
#line 291
    if (rc != 0L) {
#line 291
      if (of->err == 0) {
#line 292
        goto failed;
      } else
#line 291
      if (! of->errors) {
#line 292
        goto failed;
      }
    }
#line 295
    if (of->is_dir) {
#line 297
      if (file->is_dir) {
#line 298
        goto update;
      } else
#line 297
      if (file->err) {
#line 298
        goto update;
      }
    } else
#line 303
    if (of->err == 0) {
#line 305
      if (file->is_dir) {
#line 306
        goto add_event;
      } else
#line 305
      if (file->err) {
#line 306
        goto add_event;
      }
#line 309
      if (of->uniq == file->uniq) {
#line 311
        if (file->event) {
#line 312
          file->use_event = 1U;
        }
#line 315
        of->is_directio = file->is_directio;
#line 317
        goto update;
      }
    } else
#line 324
    if (file->err) {
#line 325
      goto update;
    } else
#line 324
    if (file->is_dir) {
#line 325
      goto update;
    }
#line 331
    if (file->count == 0U) {
      {
#line 333
      ngx_open_file_del_event(file);
#line 335
      tmp___1 = close(file->fd);
      }
#line 335
      if (tmp___1 == -1) {
#line 336
        if ((pool->log)->log_level >= 2UL) {
          {
#line 336
          tmp___0 = __errno_location();
#line 336
          ngx_log_error_core((ngx_uint_t )2, pool->log, *tmp___0, "close() \"%V\" failed",
                             name);
          }
        }
      }
#line 340
      goto add_event;
    }
    {
#line 343
    ngx_rbtree_delete(& cache->rbtree, & file->node);
#line 345
    (cache->current) --;
#line 347
    file->close = 1U;
    }
#line 349
    goto create;
  }
  {
#line 354
  rc = ngx_open_and_stat_file(name, of, pool->log);
  }
#line 356
  if (rc != 0L) {
#line 356
    if (of->err == 0) {
#line 357
      goto failed;
    } else
#line 356
    if (! of->errors) {
#line 357
      goto failed;
    }
  }
  create: 
#line 362
  if (cache->current >= cache->max) {
    {
#line 363
    ngx_expire_old_cached_files(cache, (ngx_uint_t )0, pool->log);
    }
  }
  {
#line 366
  tmp___2 = ngx_alloc(sizeof(ngx_cached_open_file_t ), pool->log);
#line 366
  file = (ngx_cached_open_file_t *)tmp___2;
  }
#line 368
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 369
    goto failed;
  }
  {
#line 372
  tmp___3 = ngx_alloc(name->len + 1UL, pool->log);
#line 372
  file->name = (u_char *)tmp___3;
  }
#line 374
  if ((unsigned long )file->name == (unsigned long )((void *)0)) {
    {
#line 375
    free((void *)file);
#line 376
    file = (ngx_cached_open_file_t *)((void *)0);
    }
#line 377
    goto failed;
  }
  {
#line 380
  ngx_cpystrn(file->name, name->data, name->len + 1UL);
#line 382
  file->node.key = (ngx_rbtree_key_t )hash;
#line 384
  ngx_rbtree_insert(& cache->rbtree, & file->node);
#line 386
  (cache->current) ++;
#line 388
  file->uses = (uint32_t )1;
#line 389
  file->count = 0U;
#line 390
  file->use_event = 0U;
#line 391
  file->event = (ngx_event_t *)((void *)0);
  }
  add_event: 
  {
#line 395
  ngx_open_file_add_event(cache, file, of, pool->log);
  }
  update: 
#line 399
  file->fd = of->fd;
#line 400
  file->err = of->err;
#line 402
  file->disable_symlinks = of->disable_symlinks;
#line 403
  file->disable_symlinks_from = of->disable_symlinks_from;
#line 406
  if (of->err == 0) {
#line 407
    file->uniq = of->uniq;
#line 408
    file->mtime = of->mtime;
#line 409
    file->size = of->size;
#line 411
    file->close = 0U;
#line 413
    file->is_dir = of->is_dir;
#line 414
    file->is_file = of->is_file;
#line 415
    file->is_link = of->is_link;
#line 416
    file->is_exec = of->is_exec;
#line 417
    file->is_directio = of->is_directio;
#line 419
    if (! of->is_dir) {
#line 420
      (file->count) ++;
    }
  }
#line 424
  file->created = now;
  found: 
#line 428
  file->accessed = now;
#line 430
  file->queue.next = cache->expire_queue.next;
#line 430
  (file->queue.next)->prev = & file->queue;
#line 430
  file->queue.prev = & cache->expire_queue;
#line 430
  cache->expire_queue.next = & file->queue;
#line 436
  if (of->err == 0) {
#line 438
    if (! of->is_dir) {
#line 439
      cln->handler = & ngx_open_file_cleanup;
#line 440
      ofcln = (ngx_open_file_cache_cleanup_t *)cln->data;
#line 442
      ofcln->cache = cache;
#line 443
      ofcln->file = file;
#line 444
      ofcln->min_uses = of->min_uses;
#line 445
      ofcln->log = pool->log;
    }
#line 448
    return ((ngx_int_t )0);
  }
#line 451
  return ((ngx_int_t )-1);
  failed: 
#line 455
  if (file) {
    {
#line 456
    ngx_rbtree_delete(& cache->rbtree, & file->node);
#line 458
    (cache->current) --;
    }
#line 460
    if (file->count == 0U) {
#line 462
      if (file->fd != -1) {
        {
#line 463
        tmp___5 = close(file->fd);
        }
#line 463
        if (tmp___5 == -1) {
#line 464
          if ((pool->log)->log_level >= 2UL) {
            {
#line 464
            tmp___4 = __errno_location();
#line 464
            ngx_log_error_core((ngx_uint_t )2, pool->log, *tmp___4, "close() \"%s\" failed",
                               file->name);
            }
          }
        }
      }
      {
#line 470
      free((void *)file->name);
#line 471
      free((void *)file);
      }
    } else {
#line 474
      file->close = 1U;
    }
  }
#line 478
  if (of->fd != -1) {
    {
#line 479
    tmp___7 = close(of->fd);
    }
#line 479
    if (tmp___7 == -1) {
#line 480
      if ((pool->log)->log_level >= 2UL) {
        {
#line 480
        tmp___6 = __errno_location();
#line 480
        ngx_log_error_core((ngx_uint_t )2, pool->log, *tmp___6, "close() \"%V\" failed",
                           name);
        }
      }
    }
  }
#line 485
  return ((ngx_int_t )-1);
}
}
#line 491 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static ngx_fd_t ngx_openat_file_owner(ngx_fd_t at_fd , u_char const   *name , ngx_int_t mode ,
                                      ngx_int_t create , ngx_int_t access___0 , ngx_log_t *log ) 
{ 
  ngx_fd_t fd ;
  ngx_err_t err ;
  ngx_file_info_t fi ;
  ngx_file_info_t atfi ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  ngx_int_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  void *__cil_tmp18 ;
  void *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 511
  fd = openat(at_fd, (char const   *)name, (int )(mode | create), access___0);
  }
#line 513
  if (fd == -1) {
#line 514
    return (-1);
  }
  {
#line 517
  tmp___0 = fstatat(at_fd, (char const   */* __restrict  */)((char const   *)name),
                    (struct stat */* __restrict  */)(& atfi), 256);
  }
#line 517
  if (tmp___0 == -1) {
    {
#line 520
    tmp = __errno_location();
#line 520
    err = *tmp;
    }
#line 521
    goto failed;
  }
  {
#line 525
  tmp___2 = ngx_file_o_path_info(fd, & fi, log);
  }
#line 525
  if (tmp___2 == -1L) {
    {
#line 526
    tmp___1 = __errno_location();
#line 526
    err = *tmp___1;
    }
#line 527
    goto failed;
  }
#line 536
  if (fi.st_uid != atfi.st_uid) {
#line 537
    err = 40;
#line 538
    goto failed;
  }
#line 541
  return (fd);
  failed: 
  {
#line 545
  tmp___4 = close(fd);
  }
#line 545
  if (tmp___4 == -1) {
#line 546
    if (log->log_level >= 2UL) {
      {
#line 546
      tmp___3 = __errno_location();
#line 546
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___3, "close() \"%s\" failed", name);
      }
    }
  }
  {
#line 550
  tmp___5 = __errno_location();
#line 550
  *tmp___5 = err;
  }
#line 552
  return (-1);
}
}
#line 561 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static ngx_uint_t use_fstat  =    (ngx_uint_t )1;
#line 558 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static ngx_int_t ngx_file_o_path_info(ngx_fd_t fd , ngx_file_info_t *fi , ngx_log_t *log ) 
{ 
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp7 ;

  {
#line 585
  if (use_fstat) {
    {
#line 586
    tmp = fstat(fd, fi);
    }
#line 586
    if (tmp != -1) {
#line 587
      return ((ngx_int_t )0);
    }
    {
#line 590
    tmp___0 = __errno_location();
    }
#line 590
    if (*tmp___0 != 9) {
#line 591
      return ((ngx_int_t )-1);
    }
#line 594
    if (log->log_level >= 6UL) {
      {
#line 594
      ngx_log_error_core((ngx_uint_t )6, log, 0, "fstat(O_PATH) failed with EBADF, switching to fstatat(AT_EMPTY_PATH)");
      }
    }
#line 598
    use_fstat = (ngx_uint_t )0;
  }
  {
#line 601
  tmp___1 = fstatat(fd, (char const   */* __restrict  */)"", (struct stat */* __restrict  */)fi,
                    4096);
  }
#line 601
  if (tmp___1 != -1) {
#line 602
    return ((ngx_int_t )0);
  }
#line 605
  return ((ngx_int_t )-1);
}
}
#line 613 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static ngx_fd_t ngx_open_file_wrapper(ngx_str_t *name , ngx_open_file_info_t *of ,
                                      ngx_int_t mode , ngx_int_t create , ngx_int_t access___0 ,
                                      ngx_log_t *log ) 
{ 
  ngx_fd_t fd ;
  u_char *p ;
  u_char *cp ;
  u_char *end ;
  ngx_fd_t at_fd ;
  ngx_str_t at_name ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
#line 637
  if (of->disable_symlinks == 0U) {
    {
#line 638
    fd = open((char const   *)name->data, (int )(mode | create), access___0);
    }
#line 640
    if (fd == -1) {
      {
#line 641
      tmp = __errno_location();
#line 641
      of->err = *tmp;
#line 642
      of->failed = (char *)"open()";
      }
#line 643
      return (-1);
    }
#line 646
    return (fd);
  }
#line 649
  p = name->data;
#line 650
  end = p + name->len;
#line 652
  at_name = *name;
#line 654
  if (of->disable_symlinks_from) {
    {
#line 656
    cp = p + of->disable_symlinks_from;
#line 658
    *cp = (u_char )'\000';
#line 660
    at_fd = open((char const   *)p, 2164736, 0);
#line 663
    *cp = (u_char )'/';
    }
#line 665
    if (at_fd == -1) {
      {
#line 666
      tmp___0 = __errno_location();
#line 666
      of->err = *tmp___0;
#line 667
      of->failed = (char *)"open()";
      }
#line 668
      return (-1);
    }
#line 671
    at_name.len = of->disable_symlinks_from;
#line 672
    p = cp + 1;
  } else
#line 674
  if ((int )*p == 47) {
    {
#line 676
    at_fd = open("/", 2164736, 0);
    }
#line 680
    if (at_fd == -1) {
      {
#line 681
      tmp___1 = __errno_location();
#line 681
      of->err = *tmp___1;
#line 682
      of->failed = (char *)"openat()";
      }
#line 683
      return (-1);
    }
#line 686
    at_name.len = (size_t )1;
#line 687
    p ++;
  } else {
#line 690
    at_fd = -100;
  }
  {
#line 693
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 694
    cp = ngx_strlchr(p, end, (u_char )'/');
    }
#line 695
    if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 696
      goto while_break;
    }
#line 699
    if ((unsigned long )cp == (unsigned long )p) {
#line 700
      p ++;
#line 701
      goto __Cont;
    }
#line 704
    *cp = (u_char )'\000';
#line 706
    if (of->disable_symlinks == 2U) {
      {
#line 707
      fd = ngx_openat_file_owner(at_fd, (u_char const   *)p, (ngx_int_t )2164736,
                                 (ngx_int_t )0, (ngx_int_t )0, log);
      }
    } else {
      {
#line 712
      fd = openat(at_fd, (char const   *)p, 2295808, 0);
      }
    }
#line 717
    *cp = (u_char )'/';
#line 719
    if (fd == -1) {
      {
#line 720
      tmp___2 = __errno_location();
#line 720
      of->err = *tmp___2;
#line 721
      of->failed = (char *)"openat()";
      }
#line 722
      goto failed;
    }
#line 725
    if (at_fd != -100) {
      {
#line 725
      tmp___4 = close(at_fd);
      }
#line 725
      if (tmp___4 == -1) {
#line 726
        if (log->log_level >= 2UL) {
          {
#line 726
          tmp___3 = __errno_location();
#line 726
          ngx_log_error_core((ngx_uint_t )2, log, *tmp___3, "close() \"%V\" failed",
                             & at_name);
          }
        }
      }
    }
#line 730
    p = cp + 1;
#line 731
    at_fd = fd;
#line 732
    at_name.len = (size_t )(cp - at_name.data);
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 735
  if ((unsigned long )p == (unsigned long )end) {
    {
#line 748
    fd = openat(at_fd, ".", (int )(mode | create), access___0);
    }
#line 749
    goto done;
  }
#line 752
  if (of->disable_symlinks == 2U) {
#line 752
    if (! (create & 576L)) {
      {
#line 755
      fd = ngx_openat_file_owner(at_fd, (u_char const   *)p, mode, create, access___0,
                                 log);
      }
    } else {
      {
#line 758
      fd = openat(at_fd, (char const   *)p, (int )((mode | 131072L) | create), access___0);
      }
    }
  } else {
    {
#line 758
    fd = openat(at_fd, (char const   *)p, (int )((mode | 131072L) | create), access___0);
    }
  }
  done: 
#line 763
  if (fd == -1) {
    {
#line 764
    tmp___5 = __errno_location();
#line 764
    of->err = *tmp___5;
#line 765
    of->failed = (char *)"openat()";
    }
  }
  failed: 
#line 770
  if (at_fd != -100) {
    {
#line 770
    tmp___7 = close(at_fd);
    }
#line 770
    if (tmp___7 == -1) {
#line 771
      if (log->log_level >= 2UL) {
        {
#line 771
        tmp___6 = __errno_location();
#line 771
        ngx_log_error_core((ngx_uint_t )2, log, *tmp___6, "close() \"%V\" failed",
                           & at_name);
        }
      }
    }
  }
#line 775
  return (fd);
}
}
#line 780 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static ngx_int_t ngx_file_info_wrapper(ngx_str_t *name , ngx_open_file_info_t *of ,
                                       ngx_file_info_t *fi , ngx_log_t *log ) 
{ 
  ngx_int_t rc ;
  ngx_fd_t fd ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;

  {
#line 802
  if (of->disable_symlinks == 0U) {
    {
#line 804
    tmp = stat((char const   */* __restrict  */)((char const   *)name->data), (struct stat */* __restrict  */)fi);
#line 804
    rc = (ngx_int_t )tmp;
    }
#line 806
    if (rc == -1L) {
      {
#line 807
      tmp___0 = __errno_location();
#line 807
      of->err = *tmp___0;
#line 808
      of->failed = (char *)"stat()";
      }
#line 809
      return ((ngx_int_t )-1);
    }
#line 812
    return (rc);
  }
  {
#line 815
  fd = ngx_open_file_wrapper(name, of, (ngx_int_t )2048, (ngx_int_t )0, (ngx_int_t )0,
                             log);
  }
#line 818
  if (fd == -1) {
#line 819
    return ((ngx_int_t )-1);
  }
  {
#line 822
  tmp___1 = fstat(fd, fi);
#line 822
  rc = (ngx_int_t )tmp___1;
  }
#line 824
  if (rc == -1L) {
    {
#line 825
    tmp___2 = __errno_location();
#line 825
    of->err = *tmp___2;
#line 826
    of->failed = (char *)"fstat()";
    }
  }
  {
#line 829
  tmp___4 = close(fd);
  }
#line 829
  if (tmp___4 == -1) {
#line 830
    if (log->log_level >= 2UL) {
      {
#line 830
      tmp___3 = __errno_location();
#line 830
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___3, "close() \"%V\" failed", name);
      }
    }
  }
#line 834
  return (rc);
}
}
#line 839 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static ngx_int_t ngx_open_and_stat_file(ngx_str_t *name , ngx_open_file_info_t *of ,
                                        ngx_log_t *log ) 
{ 
  ngx_fd_t fd ;
  ngx_file_info_t fi ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  ngx_int_t tmp___8 ;
  int *tmp___9 ;
  ngx_int_t tmp___10 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 846
  if (of->fd != -1) {
    {
#line 848
    tmp = ngx_file_info_wrapper(name, of, & fi, log);
    }
#line 848
    if (tmp == -1L) {
#line 849
      of->fd = -1;
#line 850
      return ((ngx_int_t )-1);
    }
#line 853
    if (of->uniq == fi.st_ino) {
#line 854
      goto done;
    }
  } else
#line 857
  if (of->test_dir) {
    {
#line 859
    tmp___0 = ngx_file_info_wrapper(name, of, & fi, log);
    }
#line 859
    if (tmp___0 == -1L) {
#line 860
      of->fd = -1;
#line 861
      return ((ngx_int_t )-1);
    }
#line 864
    if ((fi.st_mode & 61440U) == 16384U) {
#line 865
      goto done;
    }
  }
#line 869
  if (! of->log) {
    {
#line 876
    fd = ngx_open_file_wrapper(name, of, (ngx_int_t )2048, (ngx_int_t )0, (ngx_int_t )0,
                               log);
    }
  } else {
    {
#line 880
    fd = ngx_open_file_wrapper(name, of, (ngx_int_t )1025, (ngx_int_t )64, (ngx_int_t )420,
                               log);
    }
  }
#line 885
  if (fd == -1) {
#line 886
    of->fd = -1;
#line 887
    return ((ngx_int_t )-1);
  }
  {
#line 890
  tmp___4 = fstat(fd, & fi);
  }
#line 890
  if (tmp___4 == -1) {
#line 891
    if (log->log_level >= 3UL) {
      {
#line 891
      tmp___1 = __errno_location();
#line 891
      ngx_log_error_core((ngx_uint_t )3, log, *tmp___1, "fstat() \"%V\" failed", name);
      }
    }
    {
#line 894
    tmp___3 = close(fd);
    }
#line 894
    if (tmp___3 == -1) {
#line 895
      if (log->log_level >= 2UL) {
        {
#line 895
        tmp___2 = __errno_location();
#line 895
        ngx_log_error_core((ngx_uint_t )2, log, *tmp___2, "close() \"%V\" failed",
                           name);
        }
      }
    }
#line 899
    of->fd = -1;
#line 901
    return ((ngx_int_t )-1);
  }
#line 904
  if ((fi.st_mode & 61440U) == 16384U) {
    {
#line 905
    tmp___6 = close(fd);
    }
#line 905
    if (tmp___6 == -1) {
#line 906
      if (log->log_level >= 2UL) {
        {
#line 906
        tmp___5 = __errno_location();
#line 906
        ngx_log_error_core((ngx_uint_t )2, log, *tmp___5, "close() \"%V\" failed",
                           name);
        }
      }
    }
#line 910
    of->fd = -1;
  } else {
#line 913
    of->fd = fd;
#line 915
    if (of->read_ahead) {
#line 915
      if (fi.st_size > 131072L) {
        {
#line 916
        tmp___8 = ngx_read_ahead(fd, of->read_ahead);
        }
#line 916
        if (tmp___8 == -1L) {
#line 917
          if (log->log_level >= 2UL) {
            {
#line 917
            tmp___7 = __errno_location();
#line 917
            ngx_log_error_core((ngx_uint_t )2, log, *tmp___7, "posix_fadvise(POSIX_FADV_SEQUENTIAL) \"%V\" failed",
                               name);
            }
          }
        }
      }
    }
#line 922
    if (of->directio <= fi.st_size) {
      {
#line 923
      tmp___10 = ngx_directio_on(fd);
      }
#line 923
      if (tmp___10 == -1L) {
#line 924
        if (log->log_level >= 2UL) {
          {
#line 924
          tmp___9 = __errno_location();
#line 924
          ngx_log_error_core((ngx_uint_t )2, log, *tmp___9, "fcntl(O_DIRECT) \"%V\" failed",
                             name);
          }
        }
      } else {
#line 928
        of->is_directio = 1U;
      }
    }
  }
  done: 
#line 935
  of->uniq = fi.st_ino;
#line 936
  of->mtime = fi.st_mtim.tv_sec;
#line 937
  of->size = fi.st_size;
#line 938
  if (fi.st_size < fi.st_blocks * 512L) {
#line 938
    of->fs_size = fi.st_blocks * 512L;
  } else {
#line 938
    of->fs_size = fi.st_size;
  }
#line 939
  of->is_dir = (unsigned int )((fi.st_mode & 61440U) == 16384U);
#line 940
  of->is_file = (unsigned int )((fi.st_mode & 61440U) == 32768U);
#line 941
  of->is_link = (unsigned int )((fi.st_mode & 61440U) == 40960U);
#line 942
  of->is_exec = (unsigned int )((fi.st_mode & 64U) == 64U);
#line 944
  return ((ngx_int_t )0);
}
}
#line 953 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_open_file_add_event(ngx_open_file_cache_t *cache , ngx_cached_open_file_t *file ,
                                    ngx_open_file_info_t *of , ngx_log_t *log ) 
{ 
  ngx_open_file_cache_event_t *fev ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 959
  if (! (ngx_event_flags & 8192UL)) {
#line 965
    return;
  } else
#line 959
  if (! of->events) {
#line 965
    return;
  } else
#line 959
  if (file->event) {
#line 965
    return;
  } else
#line 959
  if (of->fd == -1) {
#line 965
    return;
  } else
#line 959
  if ((ngx_uint_t )file->uses < of->min_uses) {
#line 965
    return;
  }
  {
#line 968
  file->use_event = 0U;
#line 970
  tmp = ngx_calloc(sizeof(ngx_event_t ), log);
#line 970
  file->event = (ngx_event_t *)tmp;
  }
#line 971
  if ((unsigned long )file->event == (unsigned long )((void *)0)) {
#line 972
    return;
  }
  {
#line 975
  tmp___0 = ngx_alloc(sizeof(ngx_open_file_cache_event_t ), log);
#line 975
  fev = (ngx_open_file_cache_event_t *)tmp___0;
  }
#line 976
  if ((unsigned long )fev == (unsigned long )((void *)0)) {
    {
#line 977
    free((void *)file->event);
#line 978
    file->event = (ngx_event_t *)((void *)0);
    }
#line 979
    return;
  }
  {
#line 982
  fev->fd = of->fd;
#line 983
  fev->file = file;
#line 984
  fev->cache = cache;
#line 986
  (file->event)->handler = & ngx_open_file_cache_remove;
#line 987
  (file->event)->data = (void *)fev;
#line 995
  (file->event)->log = (ngx_log_t *)ngx_cycle->log;
#line 997
  tmp___1 = (*(ngx_event_actions.add))(file->event, (ngx_int_t )0, (ngx_uint_t )1879048192);
  }
#line 997
  if (tmp___1 != 0L) {
    {
#line 1000
    free((file->event)->data);
#line 1001
    free((void *)file->event);
#line 1002
    file->event = (ngx_event_t *)((void *)0);
    }
#line 1003
    return;
  }
#line 1013
  return;
}
}
#line 1017 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cleanup(void *data ) 
{ 
  ngx_open_file_cache_cleanup_t *c ;

  {
  {
#line 1020
  c = (ngx_open_file_cache_cleanup_t *)data;
#line 1022
  ((c->file)->count) --;
#line 1024
  ngx_close_cached_file(c->cache, c->file, c->min_uses, c->log);
#line 1027
  ngx_expire_old_cached_files(c->cache, (ngx_uint_t )1, c->log);
  }
#line 1028
  return;
}
}
#line 1031 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_close_cached_file(ngx_open_file_cache_t *cache , ngx_cached_open_file_t *file ,
                                  ngx_uint_t min_uses , ngx_log_t *log ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp7 ;

  {
#line 1039
  if (! file->close) {
#line 1041
    file->accessed = (time_t )ngx_cached_time->sec;
#line 1043
    (file->queue.next)->prev = file->queue.prev;
#line 1043
    (file->queue.prev)->next = file->queue.next;
#line 1045
    file->queue.next = cache->expire_queue.next;
#line 1045
    (file->queue.next)->prev = & file->queue;
#line 1045
    file->queue.prev = & cache->expire_queue;
#line 1045
    cache->expire_queue.next = & file->queue;
#line 1047
    if ((ngx_uint_t )file->uses >= min_uses) {
#line 1048
      return;
    } else
#line 1047
    if (file->count) {
#line 1048
      return;
    }
  }
  {
#line 1052
  ngx_open_file_del_event(file);
  }
#line 1054
  if (file->count) {
#line 1055
    return;
  }
#line 1058
  if (file->fd != -1) {
    {
#line 1060
    tmp___0 = close(file->fd);
    }
#line 1060
    if (tmp___0 == -1) {
#line 1061
      if (log->log_level >= 2UL) {
        {
#line 1061
        tmp = __errno_location();
#line 1061
        ngx_log_error_core((ngx_uint_t )2, log, *tmp, "close() \"%s\" failed", file->name);
        }
      }
    }
#line 1065
    file->fd = -1;
  }
#line 1068
  if (! file->close) {
#line 1069
    return;
  }
  {
#line 1072
  free((void *)file->name);
#line 1073
  free((void *)file);
  }
#line 1074
  return;
}
}
#line 1077 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_open_file_del_event(ngx_cached_open_file_t *file ) 
{ 
  int tmp ;

  {
#line 1080
  if ((unsigned long )file->event == (unsigned long )((void *)0)) {
#line 1081
    return;
  }
#line 1084
  if (file->count) {
#line 1084
    tmp = 4;
  } else {
#line 1084
    tmp = 1;
  }
  {
#line 1084
  (*(ngx_event_actions.del))(file->event, (ngx_int_t )0, (ngx_uint_t )tmp);
#line 1087
  free((file->event)->data);
#line 1088
  free((void *)file->event);
#line 1089
  file->event = (ngx_event_t *)((void *)0);
#line 1090
  file->use_event = 0U;
  }
#line 1091
  return;
}
}
#line 1094 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_expire_old_cached_files(ngx_open_file_cache_t *cache , ngx_uint_t n ,
                                        ngx_log_t *log ) 
{ 
  time_t now ;
  ngx_queue_t *q ;
  ngx_cached_open_file_t *file ;
  ngx_uint_t tmp ;

  {
#line 1102
  now = (time_t )ngx_cached_time->sec;
  {
#line 1110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1110
    if (! (n < 3UL)) {
#line 1110
      goto while_break;
    }
#line 1112
    if ((unsigned long )(& cache->expire_queue) == (unsigned long )cache->expire_queue.prev) {
#line 1113
      return;
    }
#line 1116
    q = cache->expire_queue.prev;
#line 1118
    file = (ngx_cached_open_file_t *)((u_char *)q - (unsigned long )(& ((ngx_cached_open_file_t *)0)->queue));
#line 1120
    tmp = n;
#line 1120
    n ++;
#line 1120
    if (tmp != 0UL) {
#line 1120
      if (now - file->accessed <= cache->inactive) {
#line 1121
        return;
      }
    }
    {
#line 1124
    (q->next)->prev = q->prev;
#line 1124
    (q->prev)->next = q->next;
#line 1126
    ngx_rbtree_delete(& cache->rbtree, & file->node);
#line 1128
    (cache->current) --;
    }
#line 1133
    if (! file->err) {
#line 1133
      if (! file->is_dir) {
        {
#line 1134
        file->close = 1U;
#line 1135
        ngx_close_cached_file(cache, file, (ngx_uint_t )0, log);
        }
      } else {
        {
#line 1138
        free((void *)file->name);
#line 1139
        free((void *)file);
        }
      }
    } else {
      {
#line 1138
      free((void *)file->name);
#line 1139
      free((void *)file);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1142
  return;
}
}
#line 1145 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cache_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                    ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_cached_open_file_t *file ;
  ngx_cached_open_file_t *file_temp ;
  int tmp___0 ;

  {
  {
#line 1152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1154
    if (node->key < temp->key) {
#line 1156
      p = & temp->left;
    } else
#line 1158
    if (node->key > temp->key) {
#line 1160
      p = & temp->right;
    } else {
      {
#line 1164
      file = (ngx_cached_open_file_t *)node;
#line 1165
      file_temp = (ngx_cached_open_file_t *)temp;
#line 1167
      tmp___0 = strcmp((char const   *)file->name, (char const   *)file_temp->name);
      }
#line 1167
      if (tmp___0 < 0) {
#line 1167
        p = & temp->left;
      } else {
#line 1167
        p = & temp->right;
      }
    }
#line 1171
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 1172
      goto while_break;
    }
#line 1175
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  *p = node;
#line 1179
  node->parent = temp;
#line 1180
  node->left = sentinel;
#line 1181
  node->right = sentinel;
#line 1182
  node->color = (u_char )1;
#line 1183
  return;
}
}
#line 1186 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static ngx_cached_open_file_t *ngx_open_file_lookup(ngx_open_file_cache_t *cache ,
                                                    ngx_str_t *name , uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_cached_open_file_t *file ;
  int tmp ;

  {
#line 1194
  node = cache->rbtree.root;
#line 1195
  sentinel = cache->rbtree.sentinel;
  {
#line 1197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1197
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 1197
      goto while_break;
    }
#line 1199
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 1200
      node = node->left;
#line 1201
      goto while_continue;
    }
#line 1204
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 1205
      node = node->right;
#line 1206
      goto while_continue;
    }
    {
#line 1211
    file = (ngx_cached_open_file_t *)node;
#line 1213
    tmp = strcmp((char const   *)name->data, (char const   *)file->name);
#line 1213
    rc = (ngx_int_t )tmp;
    }
#line 1215
    if (rc == 0L) {
#line 1216
      return (file);
    }
#line 1219
    if (rc < 0L) {
#line 1219
      node = node->left;
    } else {
#line 1219
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1222
  return ((ngx_cached_open_file_t *)((void *)0));
}
}
#line 1226 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_open_file_cache.c"
static void ngx_open_file_cache_remove(ngx_event_t *ev ) 
{ 
  ngx_cached_open_file_t *file ;
  ngx_open_file_cache_event_t *fev ;

  {
  {
#line 1232
  fev = (ngx_open_file_cache_event_t *)ev->data;
#line 1233
  file = fev->file;
#line 1235
  (file->queue.next)->prev = file->queue.prev;
#line 1235
  (file->queue.prev)->next = file->queue.next;
#line 1237
  ngx_rbtree_delete(& (fev->cache)->rbtree, & file->node);
#line 1239
  ((fev->cache)->current) --;
#line 1242
  file->event = (ngx_event_t *)((void *)0);
#line 1243
  file->use_event = 0U;
#line 1245
  file->close = 1U;
#line 1247
  ngx_close_cached_file(fev->cache, file, (ngx_uint_t )0, ev->log);
#line 1251
  free(ev->data);
#line 1252
  free((void *)ev);
  }
#line 1253
  return;
}
}
#line 53 "src/core/ngx_rbtree.h"
void ngx_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node , ngx_rbtree_node_t *sentinel ) ;
#line 235 "src/core/ngx_resolver.h"
ngx_int_t ngx_resolve_addr(ngx_resolver_ctx_t *ctx ) ;
#line 236
void ngx_resolve_addr_done(ngx_resolver_ctx_t *ctx ) ;
#line 59 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_udp_connect(ngx_resolver_connection_t *rec ) ;
#line 60
static ngx_int_t ngx_tcp_connect(ngx_resolver_connection_t *rec ) ;
#line 63
static void ngx_resolver_cleanup(void *data ) ;
#line 64
static void ngx_resolver_cleanup_tree(ngx_resolver_t *r , ngx_rbtree_t *tree ) ;
#line 65
static ngx_int_t ngx_resolve_name_locked(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ,
                                         ngx_str_t *name ) ;
#line 67
static void ngx_resolver_expire(ngx_resolver_t *r , ngx_rbtree_t *tree , ngx_queue_t *queue ) ;
#line 69
static ngx_int_t ngx_resolver_send_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ) ;
#line 71
static ngx_int_t ngx_resolver_send_udp_query(ngx_resolver_t *r , ngx_resolver_connection_t *rec ,
                                             u_char *query , u_short qlen ) ;
#line 73
static ngx_int_t ngx_resolver_send_tcp_query(ngx_resolver_t *r , ngx_resolver_connection_t *rec ,
                                             u_char *query , u_short qlen ) ;
#line 75
static ngx_int_t ngx_resolver_create_name_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_str_t *name ) ;
#line 77
static ngx_int_t ngx_resolver_create_srv_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                               ngx_str_t *name ) ;
#line 79
static ngx_int_t ngx_resolver_create_addr_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_resolver_addr_t *addr ) ;
#line 81
static void ngx_resolver_resend_handler(ngx_event_t *ev ) ;
#line 82
static time_t ngx_resolver_resend(ngx_resolver_t *r , ngx_rbtree_t *tree , ngx_queue_t *queue ) ;
#line 84
static ngx_uint_t ngx_resolver_resend_empty(ngx_resolver_t *r ) ;
#line 85
static void ngx_resolver_udp_read(ngx_event_t *rev ) ;
#line 86
static void ngx_resolver_tcp_write(ngx_event_t *wev ) ;
#line 87
static void ngx_resolver_tcp_read(ngx_event_t *rev ) ;
#line 88
static void ngx_resolver_process_response(ngx_resolver_t *r , u_char *buf , size_t n ,
                                          ngx_uint_t tcp ) ;
#line 90
static void ngx_resolver_process_a(ngx_resolver_t *r , u_char *buf , size_t n , ngx_uint_t ident ,
                                   ngx_uint_t code , ngx_uint_t qtype , ngx_uint_t nan ,
                                   ngx_uint_t trunc , ngx_uint_t ans ) ;
#line 93
static void ngx_resolver_process_srv(ngx_resolver_t *r , u_char *buf , size_t n ,
                                     ngx_uint_t ident , ngx_uint_t code , ngx_uint_t nan ,
                                     ngx_uint_t trunc , ngx_uint_t ans ) ;
#line 96
static void ngx_resolver_process_ptr(ngx_resolver_t *r , u_char *buf , size_t n ,
                                     ngx_uint_t ident , ngx_uint_t code , ngx_uint_t nan ) ;
#line 98
static ngx_resolver_node_t *ngx_resolver_lookup_name(ngx_resolver_t *r , ngx_str_t *name ,
                                                     uint32_t hash ) ;
#line 100
static ngx_resolver_node_t *ngx_resolver_lookup_srv(ngx_resolver_t *r , ngx_str_t *name ,
                                                    uint32_t hash ) ;
#line 102
static ngx_resolver_node_t *ngx_resolver_lookup_addr(ngx_resolver_t *r , in_addr_t addr ) ;
#line 104
static void ngx_resolver_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                             ngx_rbtree_node_t *sentinel ) ;
#line 106
static ngx_int_t ngx_resolver_copy(ngx_resolver_t *r , ngx_str_t *name , u_char *buf ,
                                   u_char *src , u_char *last ) ;
#line 108
static ngx_int_t ngx_resolver_set_timeout(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ) ;
#line 110
static void ngx_resolver_timeout_handler(ngx_event_t *ev ) ;
#line 111
static void ngx_resolver_free_node(ngx_resolver_t *r , ngx_resolver_node_t *rn ) ;
#line 112
static void *ngx_resolver_alloc(ngx_resolver_t *r , size_t size ) ;
#line 113
static void *ngx_resolver_calloc(ngx_resolver_t *r , size_t size ) ;
#line 114
static void ngx_resolver_free(ngx_resolver_t *r , void *p ) ;
#line 115
static void ngx_resolver_free_locked(ngx_resolver_t *r , void *p ) ;
#line 116
static void *ngx_resolver_dup(ngx_resolver_t *r , void *src , size_t size ) ;
#line 117
static ngx_resolver_addr_t *ngx_resolver_export(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_uint_t rotate ) ;
#line 119
static void ngx_resolver_report_srv(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ) ;
#line 120
static u_char *ngx_resolver_log_error(ngx_log_t *log , u_char *buf , size_t len ) ;
#line 121
static void ngx_resolver_resolve_srv_names(ngx_resolver_ctx_t *ctx , ngx_resolver_node_t *rn ) ;
#line 123
static void ngx_resolver_srv_names_handler(ngx_resolver_ctx_t *cctx ) ;
#line 124
static ngx_int_t ngx_resolver_cmp_srvs(void const   *one , void const   *two ) ;
#line 127
static void ngx_resolver_rbtree_insert_addr6_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                   ngx_rbtree_node_t *sentinel ) ;
#line 129
static ngx_resolver_node_t *ngx_resolver_lookup_addr6(ngx_resolver_t *r , struct in6_addr *addr ,
                                                      uint32_t hash ) ;
#line 134 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
ngx_resolver_t *ngx_resolver_create(ngx_conf_t *cf , ngx_str_t *names , ngx_uint_t n ) 
{ 
  ngx_str_t s ;
  ngx_url_t u ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_resolver_t *r ;
  ngx_pool_cleanup_t *cln ;
  ngx_resolver_connection_t *rec ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  ngx_int_t tmp___6 ;
  void *tmp___7 ;
  void *__cil_tmp20 ;
  void *__cil_tmp21 ;
  void *__cil_tmp22 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 144
  cln = ngx_pool_cleanup_add(cf->pool, (size_t )0);
  }
#line 145
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 146
    return ((ngx_resolver_t *)((void *)0));
  }
  {
#line 149
  cln->handler = & ngx_resolver_cleanup;
#line 151
  tmp = ngx_calloc(sizeof(ngx_resolver_t ), cf->log);
#line 151
  r = (ngx_resolver_t *)tmp;
  }
#line 152
  if ((unsigned long )r == (unsigned long )((void *)0)) {
#line 153
    return ((ngx_resolver_t *)((void *)0));
  }
  {
#line 156
  cln->data = (void *)r;
#line 158
  tmp___0 = ngx_calloc(sizeof(ngx_event_t ), cf->log);
#line 158
  r->event = (ngx_event_t *)tmp___0;
  }
#line 159
  if ((unsigned long )r->event == (unsigned long )((void *)0)) {
#line 160
    return ((ngx_resolver_t *)((void *)0));
  }
#line 163
  r->name_sentinel.color = (u_char )0;
#line 163
  r->name_rbtree.root = & r->name_sentinel;
#line 163
  r->name_rbtree.sentinel = & r->name_sentinel;
#line 163
  r->name_rbtree.insert = & ngx_resolver_rbtree_insert_value;
#line 166
  r->srv_sentinel.color = (u_char )0;
#line 166
  r->srv_rbtree.root = & r->srv_sentinel;
#line 166
  r->srv_rbtree.sentinel = & r->srv_sentinel;
#line 166
  r->srv_rbtree.insert = & ngx_resolver_rbtree_insert_value;
#line 169
  r->addr_sentinel.color = (u_char )0;
#line 169
  r->addr_rbtree.root = & r->addr_sentinel;
#line 169
  r->addr_rbtree.sentinel = & r->addr_sentinel;
#line 169
  r->addr_rbtree.insert = & ngx_rbtree_insert_value;
#line 172
  r->name_resend_queue.prev = & r->name_resend_queue;
#line 172
  r->name_resend_queue.next = & r->name_resend_queue;
#line 173
  r->srv_resend_queue.prev = & r->srv_resend_queue;
#line 173
  r->srv_resend_queue.next = & r->srv_resend_queue;
#line 174
  r->addr_resend_queue.prev = & r->addr_resend_queue;
#line 174
  r->addr_resend_queue.next = & r->addr_resend_queue;
#line 176
  r->name_expire_queue.prev = & r->name_expire_queue;
#line 176
  r->name_expire_queue.next = & r->name_expire_queue;
#line 177
  r->srv_expire_queue.prev = & r->srv_expire_queue;
#line 177
  r->srv_expire_queue.next = & r->srv_expire_queue;
#line 178
  r->addr_expire_queue.prev = & r->addr_expire_queue;
#line 178
  r->addr_expire_queue.next = & r->addr_expire_queue;
#line 181
  r->ipv6 = (ngx_uint_t )1;
#line 183
  r->addr6_sentinel.color = (u_char )0;
#line 183
  r->addr6_rbtree.root = & r->addr6_sentinel;
#line 183
  r->addr6_rbtree.sentinel = & r->addr6_sentinel;
#line 183
  r->addr6_rbtree.insert = & ngx_resolver_rbtree_insert_addr6_value;
#line 186
  r->addr6_resend_queue.prev = & r->addr6_resend_queue;
#line 186
  r->addr6_resend_queue.next = & r->addr6_resend_queue;
#line 188
  r->addr6_expire_queue.prev = & r->addr6_expire_queue;
#line 188
  r->addr6_expire_queue.next = & r->addr6_expire_queue;
#line 191
  (r->event)->handler = & ngx_resolver_resend_handler;
#line 192
  (r->event)->data = (void *)r;
#line 193
  (r->event)->log = & (cf->cycle)->new_log;
#line 194
  (r->event)->cancelable = 1U;
#line 195
  r->ident = (ngx_int_t )-1;
#line 197
  r->resend_timeout = (time_t )5;
#line 198
  r->tcp_timeout = (time_t )5;
#line 199
  r->expire = (time_t )30;
#line 200
  r->valid = (time_t )0;
#line 202
  r->log = & (cf->cycle)->new_log;
#line 203
  r->log_level = (ngx_uint_t )4;
#line 205
  if (n) {
    {
#line 206
    tmp___1 = ngx_array_init(& r->connections, cf->pool, n, sizeof(ngx_resolver_connection_t ));
    }
#line 206
    if (tmp___1 != 0L) {
#line 210
      return ((ngx_resolver_t *)((void *)0));
    }
  }
#line 214
  i = (ngx_uint_t )0;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (i < n)) {
#line 214
      goto while_break;
    }
    {
#line 215
    tmp___2 = strncmp((char const   *)(names + i)->data, "valid=", (size_t )6);
    }
#line 215
    if (tmp___2 == 0) {
      {
#line 216
      s.len = (names + i)->len - 6UL;
#line 217
      s.data = (names + i)->data + 6;
#line 219
      r->valid = ngx_parse_time(& s, (ngx_uint_t )1);
      }
#line 221
      if (r->valid == -1L) {
        {
#line 222
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter: %V", names + i);
        }
#line 224
        return ((ngx_resolver_t *)((void *)0));
      }
#line 227
      goto __Cont;
    }
    {
#line 231
    tmp___5 = strncmp((char const   *)(names + i)->data, "ipv6=", (size_t )5);
    }
#line 231
    if (tmp___5 == 0) {
      {
#line 233
      tmp___4 = strcmp((char const   *)((names + i)->data + 5), "on");
      }
#line 233
      if (tmp___4 == 0) {
#line 234
        r->ipv6 = (ngx_uint_t )1;
      } else {
        {
#line 236
        tmp___3 = strcmp((char const   *)((names + i)->data + 5), "off");
        }
#line 236
        if (tmp___3 == 0) {
#line 237
          r->ipv6 = (ngx_uint_t )0;
        } else {
          {
#line 240
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid parameter: %V", names + i);
          }
#line 242
          return ((ngx_resolver_t *)((void *)0));
        }
      }
#line 245
      goto __Cont;
    }
    {
#line 249
    memset((void *)(& u), 0, sizeof(ngx_url_t ));
#line 251
    u.url = *(names + i);
#line 252
    u.default_port = (in_port_t )53;
#line 254
    tmp___6 = ngx_parse_url(cf->pool, & u);
    }
#line 254
    if (tmp___6 != 0L) {
#line 255
      if (u.err) {
        {
#line 256
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "%s in resolver \"%V\"", u.err,
                           & u.url);
        }
      }
#line 261
      return ((ngx_resolver_t *)((void *)0));
    }
    {
#line 264
    tmp___7 = ngx_array_push_n(& r->connections, u.naddrs);
#line 264
    rec = (ngx_resolver_connection_t *)tmp___7;
    }
#line 265
    if ((unsigned long )rec == (unsigned long )((void *)0)) {
#line 266
      return ((ngx_resolver_t *)((void *)0));
    }
    {
#line 269
    memset((void *)rec, 0, u.naddrs * sizeof(ngx_resolver_connection_t ));
#line 271
    j = (ngx_uint_t )0;
    }
    {
#line 271
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 271
      if (! (j < u.naddrs)) {
#line 271
        goto while_break___0;
      }
#line 272
      (rec + j)->sockaddr = (u.addrs + j)->sockaddr;
#line 273
      (rec + j)->socklen = (u.addrs + j)->socklen;
#line 274
      (rec + j)->server = (u.addrs + j)->name;
#line 275
      (rec + j)->resolver = r;
#line 271
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 214
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return (r);
}
}
#line 283 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_cleanup(void *data ) 
{ 
  ngx_resolver_t *r ;
  ngx_uint_t i ;
  ngx_resolver_connection_t *rec ;

  {
#line 286
  r = (ngx_resolver_t *)data;
#line 291
  if (r) {
    {
#line 295
    ngx_resolver_cleanup_tree(r, & r->name_rbtree);
#line 297
    ngx_resolver_cleanup_tree(r, & r->srv_rbtree);
#line 299
    ngx_resolver_cleanup_tree(r, & r->addr_rbtree);
#line 302
    ngx_resolver_cleanup_tree(r, & r->addr6_rbtree);
    }
#line 305
    if (r->event) {
#line 306
      if ((r->event)->timer_set) {
        {
#line 307
        ngx_event_del_timer(r->event);
        }
      }
      {
#line 310
      free((void *)r->event);
      }
    }
#line 314
    rec = (ngx_resolver_connection_t *)r->connections.elts;
#line 316
    i = (ngx_uint_t )0;
    {
#line 316
    while (1) {
      while_continue: /* CIL Label */ ;
#line 316
      if (! (i < r->connections.nelts)) {
#line 316
        goto while_break;
      }
#line 317
      if ((rec + i)->udp) {
        {
#line 318
        ngx_close_connection((rec + i)->udp);
        }
      }
#line 321
      if ((rec + i)->tcp) {
        {
#line 322
        ngx_close_connection((rec + i)->tcp);
        }
      }
#line 325
      if ((rec + i)->read_buf) {
        {
#line 326
        ngx_resolver_free(r, (void *)((rec + i)->read_buf)->start);
#line 327
        ngx_resolver_free(r, (void *)(rec + i)->read_buf);
        }
      }
#line 330
      if ((rec + i)->write_buf) {
        {
#line 331
        ngx_resolver_free(r, (void *)((rec + i)->write_buf)->start);
#line 332
        ngx_resolver_free(r, (void *)(rec + i)->write_buf);
        }
      }
#line 316
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 336
    free((void *)r);
    }
  }
#line 338
  return;
}
}
#line 341 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_cleanup_tree(ngx_resolver_t *r , ngx_rbtree_t *tree ) 
{ 
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_node_t *rn ;
  ngx_rbtree_node_t *tmp ;

  {
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! ((unsigned long )tree->root != (unsigned long )tree->sentinel)) {
#line 347
      goto while_break;
    }
    {
#line 349
    tmp = ngx_rbtree_min(tree->root, tree->sentinel);
#line 349
    rn = (ngx_resolver_node_t *)((u_char *)tmp - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 351
    (rn->queue.next)->prev = rn->queue.prev;
#line 351
    (rn->queue.prev)->next = rn->queue.next;
#line 353
    ctx = rn->waiting;
    }
    {
#line 353
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 353
      if (! ctx) {
#line 353
        goto while_break___0;
      }
#line 354
      next = ctx->next;
#line 356
      if (ctx->event) {
#line 357
        if ((ctx->event)->timer_set) {
          {
#line 358
          ngx_event_del_timer(ctx->event);
          }
        }
        {
#line 361
        ngx_resolver_free(r, (void *)ctx->event);
        }
      }
      {
#line 364
      ngx_resolver_free(r, (void *)ctx);
#line 353
      ctx = next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 367
    ngx_rbtree_delete(tree, & rn->node);
#line 369
    ngx_resolver_free_node(r, rn);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  return;
}
}
#line 374 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
ngx_resolver_ctx_t *ngx_resolve_start(ngx_resolver_t *r , ngx_resolver_ctx_t *temp ) 
{ 
  in_addr_t addr ;
  ngx_resolver_ctx_t *ctx ;
  void *tmp ;

  {
#line 380
  if (temp) {
    {
#line 381
    addr = ngx_inet_addr(temp->name.data, temp->name.len);
    }
#line 383
    if (addr != 4294967295U) {
      {
#line 384
      temp->resolver = r;
#line 385
      temp->state = (ngx_int_t )0;
#line 386
      temp->naddrs = (ngx_uint_t )1;
#line 387
      temp->addrs = & temp->addr;
#line 388
      temp->addr.sockaddr = (struct sockaddr *)(& temp->sin);
#line 389
      temp->addr.socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 390
      memset((void *)(& temp->sin), 0, sizeof(struct sockaddr_in ));
#line 391
      temp->sin.sin_family = (sa_family_t )2;
#line 392
      temp->sin.sin_addr.s_addr = addr;
#line 393
      temp->quick = 1U;
      }
#line 395
      return (temp);
    }
  }
#line 399
  if (r->connections.nelts == 0UL) {
#line 400
    return ((ngx_resolver_ctx_t *)((void *)-1));
  }
  {
#line 403
  tmp = ngx_resolver_calloc(r, sizeof(ngx_resolver_ctx_t ));
#line 403
  ctx = (ngx_resolver_ctx_t *)tmp;
  }
#line 405
  if (ctx) {
#line 406
    ctx->resolver = r;
  }
#line 409
  return (ctx);
}
}
#line 413 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
ngx_int_t ngx_resolve_name(ngx_resolver_ctx_t *ctx ) 
{ 
  size_t slen ;
  ngx_int_t rc ;
  ngx_str_t name ;
  ngx_resolver_t *r ;
  u_char *tmp ;
  void *tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 421
  r = ctx->resolver;
#line 423
  if (ctx->name.len > 0UL) {
#line 423
    if ((int )*(ctx->name.data + (ctx->name.len - 1UL)) == 46) {
#line 424
      (ctx->name.len) --;
    }
  }
#line 430
  if (ctx->quick) {
    {
#line 431
    (*(ctx->handler))(ctx);
    }
#line 432
    return ((ngx_int_t )0);
  }
#line 435
  if (ctx->service.len) {
    {
#line 436
    slen = ctx->service.len;
#line 438
    tmp = ngx_strlchr(ctx->service.data, ctx->service.data + ctx->service.len, (u_char )'.');
    }
#line 438
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 442
      slen += sizeof("_._tcp") - 1UL;
    }
    {
#line 445
    name.len = (slen + 1UL) + ctx->name.len;
#line 447
    tmp___0 = ngx_resolver_alloc(r, name.len);
#line 447
    name.data = (u_char *)tmp___0;
    }
#line 448
    if ((unsigned long )name.data == (unsigned long )((void *)0)) {
#line 449
      goto failed;
    }
#line 452
    if (slen == ctx->service.len) {
      {
#line 453
      ngx_sprintf(name.data, "%V.%V", & ctx->service, & ctx->name);
      }
    } else {
      {
#line 456
      ngx_sprintf(name.data, "_%V._tcp.%V", & ctx->service, & ctx->name);
      }
    }
    {
#line 461
    rc = ngx_resolve_name_locked(r, ctx, & name);
#line 463
    ngx_resolver_free(r, (void *)name.data);
    }
  } else {
    {
#line 468
    rc = ngx_resolve_name_locked(r, ctx, & ctx->name);
    }
  }
#line 471
  if (rc == 0L) {
#line 472
    return ((ngx_int_t )0);
  }
#line 477
  if (rc == -2L) {
#line 478
    return ((ngx_int_t )0);
  }
#line 483
  if (ctx->event) {
    {
#line 484
    ngx_resolver_free(r, (void *)ctx->event);
    }
  }
  failed: 
  {
#line 489
  ngx_resolver_free(r, (void *)ctx);
  }
#line 491
  return ((ngx_int_t )-1);
}
}
#line 495 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
void ngx_resolve_name_done(ngx_resolver_ctx_t *ctx ) 
{ 
  ngx_uint_t i ;
  ngx_resolver_t *r ;
  ngx_resolver_ctx_t *w ;
  ngx_resolver_ctx_t **p ;
  ngx_resolver_node_t *rn ;
  ngx_uint_t tmp ;
  char *__cil_tmp8 ;

  {
#line 503
  r = ctx->resolver;
#line 508
  if (ctx->quick) {
#line 509
    return;
  }
#line 512
  if (ctx->event) {
#line 512
    if ((ctx->event)->timer_set) {
      {
#line 513
      ngx_event_del_timer(ctx->event);
      }
    }
  }
#line 518
  if (ctx->nsrvs) {
#line 519
    i = (ngx_uint_t )0;
    {
#line 519
    while (1) {
      while_continue: /* CIL Label */ ;
#line 519
      if (! (i < ctx->nsrvs)) {
#line 519
        goto while_break;
      }
#line 520
      if ((ctx->srvs + i)->ctx) {
        {
#line 521
        ngx_resolve_name_done((ctx->srvs + i)->ctx);
        }
      }
#line 524
      if ((ctx->srvs + i)->addrs) {
        {
#line 525
        ngx_resolver_free(r, (void *)((ctx->srvs + i)->addrs)->sockaddr);
#line 526
        ngx_resolver_free(r, (void *)(ctx->srvs + i)->addrs);
        }
      }
      {
#line 529
      ngx_resolver_free(r, (void *)(ctx->srvs + i)->name.data);
#line 519
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 532
    ngx_resolver_free(r, (void *)ctx->srvs);
    }
  }
#line 535
  if (ctx->state == -2L) {
#line 535
    goto _L;
  } else
#line 535
  if (ctx->state == 110L) {
    _L: /* CIL Label */ 
#line 537
    rn = ctx->node;
#line 539
    if (rn) {
#line 540
      p = & rn->waiting;
#line 541
      w = rn->waiting;
      {
#line 543
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 543
        if (! w) {
#line 543
          goto while_break___0;
        }
#line 544
        if ((unsigned long )w == (unsigned long )ctx) {
#line 545
          *p = w->next;
#line 547
          goto done;
        }
#line 550
        p = & w->next;
#line 551
        w = w->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 554
      if ((r->log)->log_level >= 2UL) {
        {
#line 554
        ngx_log_error_core((ngx_uint_t )2, r->log, 0, "could not cancel %V resolving",
                           & ctx->name);
        }
      }
    }
  }
  done: 
#line 561
  if (ctx->service.len) {
    {
#line 562
    ngx_resolver_expire(r, & r->srv_rbtree, & r->srv_expire_queue);
    }
  } else {
    {
#line 565
    ngx_resolver_expire(r, & r->name_rbtree, & r->name_expire_queue);
    }
  }
#line 572
  if (ctx->event) {
    {
#line 573
    ngx_resolver_free_locked(r, (void *)ctx->event);
    }
  }
  {
#line 576
  ngx_resolver_free_locked(r, (void *)ctx);
  }
#line 580
  if ((r->event)->timer_set) {
    {
#line 580
    tmp = ngx_resolver_resend_empty(r);
    }
#line 580
    if (tmp) {
      {
#line 581
      ngx_event_del_timer(r->event);
      }
    }
  }
#line 583
  return;
}
}
#line 586 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolve_name_locked(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ,
                                         ngx_str_t *name ) 
{ 
  uint32_t hash ;
  ngx_int_t rc ;
  ngx_str_t cname ;
  ngx_uint_t i ;
  ngx_uint_t naddrs ;
  ngx_queue_t *resend_queue ;
  ngx_queue_t *expire_queue ;
  ngx_rbtree_t *tree ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_ctx_t *last ;
  ngx_resolver_addr_t *addrs ;
  ngx_resolver_node_t *rn ;
  int tmp ;
  ngx_int_t tmp___0 ;
  ngx_uint_t tmp___1 ;
  time_t tmp___2 ;
  ngx_int_t tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  ngx_uint_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_uint_t tmp___9 ;

  {
  {
#line 600
  ngx_strlow(name->data, name->data, name->len);
#line 602
  hash = ngx_crc32_short(name->data, name->len);
  }
#line 604
  if (ctx->service.len) {
    {
#line 605
    rn = ngx_resolver_lookup_srv(r, name, hash);
#line 607
    tree = & r->srv_rbtree;
#line 608
    resend_queue = & r->srv_resend_queue;
#line 609
    expire_queue = & r->srv_expire_queue;
    }
  } else {
    {
#line 612
    rn = ngx_resolver_lookup_name(r, name, hash);
#line 614
    tree = & r->name_rbtree;
#line 615
    resend_queue = & r->name_resend_queue;
#line 616
    expire_queue = & r->name_expire_queue;
    }
  }
#line 619
  if (rn) {
#line 622
    last = ctx;
    {
#line 622
    while (1) {
      while_continue: /* CIL Label */ ;
#line 622
      if (! last->next) {
#line 622
        goto while_break;
      }
#line 622
      last = last->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 624
    if (rn->valid >= (time_t )ngx_cached_time->sec) {
#line 628
      (rn->queue.next)->prev = rn->queue.prev;
#line 628
      (rn->queue.prev)->next = rn->queue.next;
#line 630
      rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 632
      rn->queue.next = expire_queue->next;
#line 632
      (rn->queue.next)->prev = & rn->queue;
#line 632
      rn->queue.prev = expire_queue;
#line 632
      expire_queue->next = & rn->queue;
#line 634
      if ((int )rn->naddrs == 65535) {
#line 634
        naddrs = (ngx_uint_t )0;
      } else {
#line 634
        naddrs = (ngx_uint_t )rn->naddrs;
      }
#line 636
      if ((int )rn->naddrs6 == 65535) {
#line 636
        tmp = 0;
      } else {
#line 636
        tmp = (int )rn->naddrs6;
      }
#line 636
      naddrs += (ngx_uint_t )tmp;
#line 639
      if (naddrs) {
#line 641
        if (naddrs == 1UL) {
#line 641
          if ((int )rn->naddrs == 1) {
#line 642
            addrs = (ngx_resolver_addr_t *)((void *)0);
          } else {
#line 641
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 645
          addrs = ngx_resolver_export(r, rn, (ngx_uint_t )1);
          }
#line 646
          if ((unsigned long )addrs == (unsigned long )((void *)0)) {
#line 647
            return ((ngx_int_t )-1);
          }
        }
#line 651
        last->next = rn->waiting;
#line 652
        rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
        {
#line 656
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 657
          ctx->state = (ngx_int_t )0;
#line 658
          ctx->valid = rn->valid;
#line 659
          ctx->naddrs = naddrs;
#line 661
          if ((unsigned long )addrs == (unsigned long )((void *)0)) {
            {
#line 662
            ctx->addrs = & ctx->addr;
#line 663
            ctx->addr.sockaddr = (struct sockaddr *)(& ctx->sin);
#line 664
            ctx->addr.socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 665
            memset((void *)(& ctx->sin), 0, sizeof(struct sockaddr_in ));
#line 666
            ctx->sin.sin_family = (sa_family_t )2;
#line 667
            ctx->sin.sin_addr.s_addr = rn->u.addr;
            }
          } else {
#line 670
            ctx->addrs = addrs;
          }
          {
#line 673
          next = ctx->next;
#line 675
          (*(ctx->handler))(ctx);
#line 677
          ctx = next;
          }
#line 656
          if (! ctx) {
#line 656
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 680
        if ((unsigned long )addrs != (unsigned long )((void *)0)) {
          {
#line 681
          ngx_resolver_free(r, (void *)addrs->sockaddr);
#line 682
          ngx_resolver_free(r, (void *)addrs);
          }
        }
#line 685
        return ((ngx_int_t )0);
      }
#line 688
      if (rn->nsrvs) {
#line 689
        last->next = rn->waiting;
#line 690
        rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
        {
#line 694
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 695
          next = ctx->next;
#line 697
          ngx_resolver_resolve_srv_names(ctx, rn);
#line 699
          ctx = next;
          }
#line 694
          if (! ctx) {
#line 694
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 702
        return ((ngx_int_t )0);
      }
#line 707
      tmp___1 = ctx->recursion;
#line 707
      (ctx->recursion) ++;
#line 707
      if (tmp___1 < 50UL) {
        {
#line 709
        cname.len = (size_t )rn->cnlen;
#line 710
        cname.data = rn->u.cname;
#line 712
        tmp___0 = ngx_resolve_name_locked(r, ctx, & cname);
        }
#line 712
        return (tmp___0);
      }
#line 715
      last->next = rn->waiting;
#line 716
      rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
      {
#line 720
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 721
        ctx->state = (ngx_int_t )3;
#line 722
        if (r->valid) {
#line 722
          tmp___2 = r->valid;
        } else {
#line 722
          tmp___2 = (time_t )10;
        }
        {
#line 722
        ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___2);
#line 723
        next = ctx->next;
#line 725
        (*(ctx->handler))(ctx);
#line 727
        ctx = next;
        }
#line 720
        if (! ctx) {
#line 720
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 730
      return ((ngx_int_t )0);
    }
#line 733
    if (rn->waiting) {
      {
#line 734
      tmp___3 = ngx_resolver_set_timeout(r, ctx);
      }
#line 734
      if (tmp___3 != 0L) {
#line 735
        return ((ngx_int_t )-1);
      }
#line 738
      last->next = rn->waiting;
#line 739
      rn->waiting = ctx;
#line 740
      ctx->state = (ngx_int_t )-2;
#line 741
      ctx->async = 1U;
      {
#line 743
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 744
        ctx->node = rn;
#line 745
        ctx = ctx->next;
#line 743
        if (! ctx) {
#line 743
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 748
      return ((ngx_int_t )-2);
    }
#line 751
    (rn->queue.next)->prev = rn->queue.prev;
#line 751
    (rn->queue.prev)->next = rn->queue.next;
#line 755
    if (rn->query) {
      {
#line 756
      ngx_resolver_free_locked(r, (void *)rn->query);
#line 757
      rn->query = (u_char *)((void *)0);
#line 759
      rn->query6 = (u_char *)((void *)0);
      }
    }
#line 763
    if (rn->cnlen) {
      {
#line 764
      ngx_resolver_free_locked(r, (void *)rn->u.cname);
      }
    }
#line 767
    if ((int )rn->naddrs > 1) {
#line 767
      if ((int )rn->naddrs != 65535) {
        {
#line 768
        ngx_resolver_free_locked(r, (void *)rn->u.addrs);
        }
      }
    }
#line 772
    if ((int )rn->naddrs6 > 1) {
#line 772
      if ((int )rn->naddrs6 != 65535) {
        {
#line 773
        ngx_resolver_free_locked(r, (void *)rn->u6.addrs6);
        }
      }
    }
#line 777
    if (rn->nsrvs) {
#line 778
      i = (ngx_uint_t )0;
      {
#line 778
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 778
        if (! (i < (ngx_uint_t )rn->nsrvs)) {
#line 778
          goto while_break___4;
        }
#line 779
        if ((rn->u.srvs + i)->name.data) {
          {
#line 780
          ngx_resolver_free_locked(r, (void *)(rn->u.srvs + i)->name.data);
          }
        }
#line 778
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 784
      ngx_resolver_free_locked(r, (void *)rn->u.srvs);
      }
    }
  } else {
    {
#line 791
    tmp___4 = ngx_resolver_alloc(r, sizeof(ngx_resolver_node_t ));
#line 791
    rn = (ngx_resolver_node_t *)tmp___4;
    }
#line 792
    if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 793
      return ((ngx_int_t )-1);
    }
    {
#line 796
    tmp___5 = ngx_resolver_dup(r, (void *)name->data, name->len);
#line 796
    rn->name = (u_char *)tmp___5;
    }
#line 797
    if ((unsigned long )rn->name == (unsigned long )((void *)0)) {
      {
#line 798
      ngx_resolver_free(r, (void *)rn);
      }
#line 799
      return ((ngx_int_t )-1);
    }
    {
#line 802
    rn->node.key = (ngx_rbtree_key_t )hash;
#line 803
    rn->nlen = (u_short )name->len;
#line 804
    rn->query = (u_char *)((void *)0);
#line 806
    rn->query6 = (u_char *)((void *)0);
#line 809
    ngx_rbtree_insert(tree, & rn->node);
    }
  }
#line 812
  if (ctx->service.len) {
    {
#line 813
    rc = ngx_resolver_create_srv_query(r, rn, name);
    }
  } else {
    {
#line 816
    rc = ngx_resolver_create_name_query(r, rn, name);
    }
  }
#line 819
  if (rc == -1L) {
#line 820
    goto failed;
  }
#line 823
  if (rc == -5L) {
    {
#line 824
    ngx_rbtree_delete(tree, & rn->node);
#line 826
    ngx_resolver_free(r, (void *)rn->query);
#line 827
    ngx_resolver_free(r, (void *)rn->name);
#line 828
    ngx_resolver_free(r, (void *)rn);
    }
    {
#line 830
    while (1) {
      while_continue___5: /* CIL Label */ ;
      {
#line 831
      ctx->state = (ngx_int_t )3;
#line 832
      next = ctx->next;
#line 834
      (*(ctx->handler))(ctx);
#line 836
      ctx = next;
      }
#line 830
      if (! ctx) {
#line 830
        goto while_break___5;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 839
    return ((ngx_int_t )0);
  }
#line 842
  tmp___6 = r->last_connection;
#line 842
  (r->last_connection) ++;
#line 842
  rn->last_connection = tmp___6;
#line 843
  if (r->last_connection == r->connections.nelts) {
#line 844
    r->last_connection = (ngx_uint_t )0;
  }
#line 847
  rn->naddrs = (u_short )-1;
#line 848
  rn->tcp = 0U;
#line 850
  if (r->ipv6) {
#line 850
    rn->naddrs6 = (u_short )-1;
  } else {
#line 850
    rn->naddrs6 = (u_short )0;
  }
  {
#line 851
  rn->tcp6 = 0U;
#line 853
  rn->nsrvs = (u_short )0;
#line 855
  tmp___7 = ngx_resolver_send_query(r, rn);
  }
#line 855
  if (tmp___7 != 0L) {
#line 856
    goto failed;
  }
  {
#line 859
  tmp___8 = ngx_resolver_set_timeout(r, ctx);
  }
#line 859
  if (tmp___8 != 0L) {
#line 860
    goto failed;
  }
  {
#line 863
  tmp___9 = ngx_resolver_resend_empty(r);
  }
#line 863
  if (tmp___9) {
    {
#line 864
    ngx_event_add_timer(r->event, (ngx_msec_t )(r->resend_timeout * 1000L));
    }
  }
#line 867
  rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->resend_timeout);
#line 869
  rn->queue.next = resend_queue->next;
#line 869
  (rn->queue.next)->prev = & rn->queue;
#line 869
  rn->queue.prev = resend_queue;
#line 869
  resend_queue->next = & rn->queue;
#line 871
  rn->code = (u_char )0;
#line 872
  rn->cnlen = (u_short )0;
#line 873
  rn->valid = (time_t )0;
#line 874
  rn->ttl = 4294967295U;
#line 875
  rn->waiting = ctx;
#line 877
  ctx->state = (ngx_int_t )-2;
#line 878
  ctx->async = 1U;
  {
#line 880
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 881
    ctx->node = rn;
#line 882
    ctx = ctx->next;
#line 880
    if (! ctx) {
#line 880
      goto while_break___6;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 885
  return ((ngx_int_t )-2);
  failed: 
  {
#line 889
  ngx_rbtree_delete(tree, & rn->node);
  }
#line 891
  if (rn->query) {
    {
#line 892
    ngx_resolver_free(r, (void *)rn->query);
    }
  }
  {
#line 895
  ngx_resolver_free(r, (void *)rn->name);
#line 897
  ngx_resolver_free(r, (void *)rn);
  }
#line 899
  return ((ngx_int_t )-1);
}
}
#line 903 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
ngx_int_t ngx_resolve_addr(ngx_resolver_ctx_t *ctx ) 
{ 
  u_char *name ;
  in_addr_t addr ;
  ngx_queue_t *resend_queue ;
  ngx_queue_t *expire_queue ;
  ngx_rbtree_t *tree ;
  ngx_resolver_t *r ;
  struct sockaddr_in *sin ;
  ngx_resolver_node_t *rn ;
  uint32_t hash ;
  struct sockaddr_in6 *sin6 ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_uint_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_uint_t tmp___6 ;

  {
#line 919
  addr = (in_addr_t )0;
#line 921
  hash = (uint32_t )0;
#line 922
  sin6 = (struct sockaddr_in6 *)((void *)0);
#line 926
  r = ctx->resolver;
  {
#line 931
  if ((int )(ctx->addr.sockaddr)->sa_family == 10) {
#line 931
    goto case_10;
  }
#line 946
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 932
  sin6 = (struct sockaddr_in6 *)ctx->addr.sockaddr;
#line 933
  hash = ngx_crc32_short(sin6->sin6_addr.__in6_u.__u6_addr8, (size_t )16);
#line 937
  rn = ngx_resolver_lookup_addr6(r, & sin6->sin6_addr, hash);
#line 939
  tree = & r->addr6_rbtree;
#line 940
  resend_queue = & r->addr6_resend_queue;
#line 941
  expire_queue = & r->addr6_expire_queue;
  }
#line 943
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 947
  sin = (struct sockaddr_in *)ctx->addr.sockaddr;
#line 948
  addr = ntohl(sin->sin_addr.s_addr);
#line 952
  rn = ngx_resolver_lookup_addr(r, addr);
#line 954
  tree = & r->addr_rbtree;
#line 955
  resend_queue = & r->addr_resend_queue;
#line 956
  expire_queue = & r->addr_expire_queue;
  }
  switch_break: /* CIL Label */ ;
  }
#line 959
  if (rn) {
#line 961
    if (rn->valid >= (time_t )ngx_cached_time->sec) {
      {
#line 965
      (rn->queue.next)->prev = rn->queue.prev;
#line 965
      (rn->queue.prev)->next = rn->queue.next;
#line 967
      rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 969
      rn->queue.next = expire_queue->next;
#line 969
      (rn->queue.next)->prev = & rn->queue;
#line 969
      rn->queue.prev = expire_queue;
#line 969
      expire_queue->next = & rn->queue;
#line 971
      tmp = ngx_resolver_dup(r, (void *)rn->name, (size_t )rn->nlen);
#line 971
      name = (u_char *)tmp;
      }
#line 972
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 973
        goto failed;
      }
      {
#line 976
      ctx->name.len = (size_t )rn->nlen;
#line 977
      ctx->name.data = name;
#line 981
      ctx->state = (ngx_int_t )0;
#line 982
      ctx->valid = rn->valid;
#line 984
      (*(ctx->handler))(ctx);
#line 986
      ngx_resolver_free(r, (void *)name);
      }
#line 988
      return ((ngx_int_t )0);
    }
#line 991
    if (rn->waiting) {
      {
#line 992
      tmp___0 = ngx_resolver_set_timeout(r, ctx);
      }
#line 992
      if (tmp___0 != 0L) {
#line 993
        return ((ngx_int_t )-1);
      }
#line 996
      ctx->next = rn->waiting;
#line 997
      rn->waiting = ctx;
#line 998
      ctx->state = (ngx_int_t )-2;
#line 999
      ctx->async = 1U;
#line 1000
      ctx->node = rn;
#line 1004
      return ((ngx_int_t )0);
    }
    {
#line 1007
    (rn->queue.next)->prev = rn->queue.prev;
#line 1007
    (rn->queue.prev)->next = rn->queue.next;
#line 1009
    ngx_resolver_free(r, (void *)rn->query);
#line 1010
    rn->query = (u_char *)((void *)0);
#line 1012
    rn->query6 = (u_char *)((void *)0);
    }
  } else {
    {
#line 1016
    tmp___1 = ngx_resolver_alloc(r, sizeof(ngx_resolver_node_t ));
#line 1016
    rn = (ngx_resolver_node_t *)tmp___1;
    }
#line 1017
    if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 1018
      goto failed;
    }
    {
#line 1024
    if ((int )(ctx->addr.sockaddr)->sa_family == 10) {
#line 1024
      goto case_10___0;
    }
#line 1030
    goto switch_default___0;
    case_10___0: /* CIL Label */ 
#line 1025
    rn->addr6 = sin6->sin6_addr;
#line 1026
    rn->node.key = (ngx_rbtree_key_t )hash;
#line 1027
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1031
    rn->node.key = (ngx_rbtree_key_t )addr;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 1034
    rn->query = (u_char *)((void *)0);
#line 1036
    rn->query6 = (u_char *)((void *)0);
#line 1039
    ngx_rbtree_insert(tree, & rn->node);
    }
  }
  {
#line 1042
  tmp___2 = ngx_resolver_create_addr_query(r, rn, & ctx->addr);
  }
#line 1042
  if (tmp___2 != 0L) {
#line 1043
    goto failed;
  }
#line 1046
  tmp___3 = r->last_connection;
#line 1046
  (r->last_connection) ++;
#line 1046
  rn->last_connection = tmp___3;
#line 1047
  if (r->last_connection == r->connections.nelts) {
#line 1048
    r->last_connection = (ngx_uint_t )0;
  }
  {
#line 1051
  rn->naddrs = (u_short )-1;
#line 1052
  rn->tcp = 0U;
#line 1054
  rn->naddrs6 = (u_short )-1;
#line 1055
  rn->tcp6 = 0U;
#line 1057
  rn->nsrvs = (u_short )0;
#line 1059
  tmp___4 = ngx_resolver_send_query(r, rn);
  }
#line 1059
  if (tmp___4 != 0L) {
#line 1060
    goto failed;
  }
  {
#line 1063
  tmp___5 = ngx_resolver_set_timeout(r, ctx);
  }
#line 1063
  if (tmp___5 != 0L) {
#line 1064
    goto failed;
  }
  {
#line 1067
  tmp___6 = ngx_resolver_resend_empty(r);
  }
#line 1067
  if (tmp___6) {
    {
#line 1068
    ngx_event_add_timer(r->event, (ngx_msec_t )(r->resend_timeout * 1000L));
    }
  }
#line 1071
  rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->resend_timeout);
#line 1073
  rn->queue.next = resend_queue->next;
#line 1073
  (rn->queue.next)->prev = & rn->queue;
#line 1073
  rn->queue.prev = resend_queue;
#line 1073
  resend_queue->next = & rn->queue;
#line 1075
  rn->code = (u_char )0;
#line 1076
  rn->cnlen = (u_short )0;
#line 1077
  rn->name = (u_char *)((void *)0);
#line 1078
  rn->nlen = (u_short )0;
#line 1079
  rn->valid = (time_t )0;
#line 1080
  rn->ttl = 4294967295U;
#line 1081
  rn->waiting = ctx;
#line 1085
  ctx->state = (ngx_int_t )-2;
#line 1086
  ctx->async = 1U;
#line 1087
  ctx->node = rn;
#line 1089
  return ((ngx_int_t )0);
  failed: 
#line 1093
  if (rn) {
    {
#line 1094
    ngx_rbtree_delete(tree, & rn->node);
    }
#line 1096
    if (rn->query) {
      {
#line 1097
      ngx_resolver_free(r, (void *)rn->query);
      }
    }
    {
#line 1100
    ngx_resolver_free(r, (void *)rn);
    }
  }
#line 1105
  if (ctx->event) {
    {
#line 1106
    ngx_resolver_free(r, (void *)ctx->event);
    }
  }
  {
#line 1109
  ngx_resolver_free(r, (void *)ctx);
  }
#line 1111
  return ((ngx_int_t )-1);
}
}
#line 1115 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
void ngx_resolve_addr_done(ngx_resolver_ctx_t *ctx ) 
{ 
  ngx_queue_t *expire_queue ;
  ngx_rbtree_t *tree ;
  ngx_resolver_t *r ;
  ngx_resolver_ctx_t *w ;
  ngx_resolver_ctx_t **p ;
  ngx_resolver_node_t *rn ;
  u_char text[((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)] ;
  ngx_str_t addrtext ;
  ngx_uint_t tmp ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 1124
  r = ctx->resolver;
  {
#line 1129
  if ((int )(ctx->addr.sockaddr)->sa_family == 10) {
#line 1129
    goto case_10;
  }
#line 1135
  goto switch_default;
  case_10: /* CIL Label */ 
#line 1130
  tree = & r->addr6_rbtree;
#line 1131
  expire_queue = & r->addr6_expire_queue;
#line 1132
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1136
  tree = & r->addr_rbtree;
#line 1137
  expire_queue = & r->addr_expire_queue;
  switch_break: /* CIL Label */ ;
  }
#line 1143
  if (ctx->event) {
#line 1143
    if ((ctx->event)->timer_set) {
      {
#line 1144
      ngx_event_del_timer(ctx->event);
      }
    }
  }
#line 1149
  if (ctx->state == -2L) {
#line 1149
    goto _L;
  } else
#line 1149
  if (ctx->state == 110L) {
    _L: /* CIL Label */ 
#line 1151
    rn = ctx->node;
#line 1153
    if (rn) {
#line 1154
      p = & rn->waiting;
#line 1155
      w = rn->waiting;
      {
#line 1157
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1157
        if (! w) {
#line 1157
          goto while_break;
        }
#line 1158
        if ((unsigned long )w == (unsigned long )ctx) {
#line 1159
          *p = w->next;
#line 1161
          goto done;
        }
#line 1164
        p = & w->next;
#line 1165
        w = w->next;
      }
      while_break: /* CIL Label */ ;
      }
    }
    {
#line 1173
    addrtext.data = text;
#line 1174
    addrtext.len = ngx_sock_ntop(ctx->addr.sockaddr, ctx->addr.socklen, text, ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path),
                                 (ngx_uint_t )0);
    }
#line 1177
    if ((r->log)->log_level >= 2UL) {
      {
#line 1177
      ngx_log_error_core((ngx_uint_t )2, r->log, 0, "could not cancel %V resolving",
                         & addrtext);
      }
    }
  }
  done: 
  {
#line 1184
  ngx_resolver_expire(r, tree, expire_queue);
  }
#line 1190
  if (ctx->event) {
    {
#line 1191
    ngx_resolver_free_locked(r, (void *)ctx->event);
    }
  }
  {
#line 1194
  ngx_resolver_free_locked(r, (void *)ctx);
  }
#line 1198
  if ((r->event)->timer_set) {
    {
#line 1198
    tmp = ngx_resolver_resend_empty(r);
    }
#line 1198
    if (tmp) {
      {
#line 1199
      ngx_event_del_timer(r->event);
      }
    }
  }
#line 1201
  return;
}
}
#line 1204 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_expire(ngx_resolver_t *r , ngx_rbtree_t *tree , ngx_queue_t *queue ) 
{ 
  time_t now ;
  ngx_uint_t i ;
  ngx_queue_t *q ;
  ngx_resolver_node_t *rn ;

  {
#line 1214
  now = (time_t )ngx_cached_time->sec;
#line 1216
  i = (ngx_uint_t )0;
  {
#line 1216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1216
    if (! (i < 2UL)) {
#line 1216
      goto while_break;
    }
#line 1217
    if ((unsigned long )queue == (unsigned long )queue->prev) {
#line 1218
      return;
    }
#line 1221
    q = queue->prev;
#line 1223
    rn = (ngx_resolver_node_t *)((u_char *)q - (unsigned long )(& ((ngx_resolver_node_t *)0)->queue));
#line 1225
    if (now <= rn->expire) {
#line 1226
      return;
    }
    {
#line 1232
    (q->next)->prev = q->prev;
#line 1232
    (q->prev)->next = q->next;
#line 1234
    ngx_rbtree_delete(tree, & rn->node);
#line 1236
    ngx_resolver_free_node(r, rn);
#line 1216
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1238
  return;
}
}
#line 1241 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_send_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ) 
{ 
  ngx_int_t rc ;
  ngx_resolver_connection_t *rec ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 1247
  rec = (ngx_resolver_connection_t *)r->connections.elts;
#line 1248
  rec += rn->last_connection;
#line 1250
  if ((unsigned long )rec->log.handler == (unsigned long )((void *)0)) {
#line 1251
    rec->log = *(r->log);
#line 1252
    rec->log.handler = & ngx_resolver_log_error;
#line 1253
    rec->log.data = (void *)rec;
#line 1254
    rec->log.action = (char *)"resolving";
  }
#line 1257
  if ((int )rn->naddrs == 65535) {
#line 1258
    if (rn->tcp) {
      {
#line 1258
      tmp = ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen);
#line 1258
      rc = tmp;
      }
    } else {
      {
#line 1258
      tmp___0 = ngx_resolver_send_udp_query(r, rec, rn->query, rn->qlen);
#line 1258
      rc = tmp___0;
      }
    }
#line 1261
    if (rc != 0L) {
#line 1262
      return (rc);
    }
  }
#line 1268
  if (rn->query6) {
#line 1268
    if ((int )rn->naddrs6 == 65535) {
#line 1269
      if (rn->tcp6) {
        {
#line 1269
        tmp___1 = ngx_resolver_send_tcp_query(r, rec, rn->query6, rn->qlen);
#line 1269
        rc = tmp___1;
        }
      } else {
        {
#line 1269
        tmp___2 = ngx_resolver_send_udp_query(r, rec, rn->query6, rn->qlen);
#line 1269
        rc = tmp___2;
        }
      }
#line 1273
      if (rc != 0L) {
#line 1274
        return (rc);
      }
    }
  }
#line 1280
  return ((ngx_int_t )0);
}
}
#line 1284 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_send_udp_query(ngx_resolver_t *r , ngx_resolver_connection_t *rec ,
                                             u_char *query , u_short qlen ) 
{ 
  ssize_t n ;
  ngx_int_t tmp ;
  char *__cil_tmp7 ;

  {
#line 1290
  if ((unsigned long )rec->udp == (unsigned long )((void *)0)) {
    {
#line 1291
    tmp = ngx_udp_connect(rec);
    }
#line 1291
    if (tmp != 0L) {
#line 1292
      return ((ngx_int_t )-1);
    }
#line 1295
    (rec->udp)->data = (void *)rec;
#line 1296
    ((rec->udp)->read)->handler = & ngx_resolver_udp_read;
#line 1297
    ((rec->udp)->read)->resolver = 1U;
  }
  {
#line 1300
  n = (*(ngx_io.send))(rec->udp, query, (size_t )qlen);
  }
#line 1302
  if (n == -1L) {
#line 1303
    return ((ngx_int_t )-1);
  }
#line 1306
  if ((size_t )n != (size_t )qlen) {
#line 1307
    if (rec->log.log_level >= 3UL) {
      {
#line 1307
      ngx_log_error_core((ngx_uint_t )3, & rec->log, 0, "send() incomplete");
      }
    }
#line 1308
    return ((ngx_int_t )-1);
  }
#line 1311
  return ((ngx_int_t )0);
}
}
#line 1315 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_send_tcp_query(ngx_resolver_t *r , ngx_resolver_connection_t *rec ,
                                             u_char *query , u_short qlen ) 
{ 
  ngx_buf_t *b ;
  ngx_int_t rc ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp14 ;

  {
#line 1322
  rc = (ngx_int_t )0;
#line 1324
  if ((unsigned long )rec->tcp == (unsigned long )((void *)0)) {
#line 1325
    b = rec->read_buf;
#line 1327
    if ((unsigned long )b == (unsigned long )((void *)0)) {
      {
#line 1328
      tmp = ngx_resolver_calloc(r, sizeof(ngx_buf_t ));
#line 1328
      b = (ngx_buf_t *)tmp;
      }
#line 1329
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1330
        return ((ngx_int_t )-1);
      }
      {
#line 1333
      tmp___0 = ngx_resolver_alloc(r, (size_t )65537);
#line 1333
      b->start = (u_char *)tmp___0;
      }
#line 1334
      if ((unsigned long )b->start == (unsigned long )((void *)0)) {
        {
#line 1335
        ngx_resolver_free(r, (void *)b);
        }
#line 1336
        return ((ngx_int_t )-1);
      }
#line 1339
      b->end = b->start + 65537;
#line 1341
      rec->read_buf = b;
    }
#line 1344
    b->pos = b->start;
#line 1345
    b->last = b->start;
#line 1347
    b = rec->write_buf;
#line 1349
    if ((unsigned long )b == (unsigned long )((void *)0)) {
      {
#line 1350
      tmp___1 = ngx_resolver_calloc(r, sizeof(ngx_buf_t ));
#line 1350
      b = (ngx_buf_t *)tmp___1;
      }
#line 1351
      if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 1352
        return ((ngx_int_t )-1);
      }
      {
#line 1355
      tmp___2 = ngx_resolver_alloc(r, (size_t )8192);
#line 1355
      b->start = (u_char *)tmp___2;
      }
#line 1356
      if ((unsigned long )b->start == (unsigned long )((void *)0)) {
        {
#line 1357
        ngx_resolver_free(r, (void *)b);
        }
#line 1358
        return ((ngx_int_t )-1);
      }
#line 1361
      b->end = b->start + 8192;
#line 1363
      rec->write_buf = b;
    }
    {
#line 1366
    b->pos = b->start;
#line 1367
    b->last = b->start;
#line 1369
    rc = ngx_tcp_connect(rec);
    }
#line 1370
    if (rc == -1L) {
#line 1371
      return ((ngx_int_t )-1);
    }
    {
#line 1374
    (rec->tcp)->data = (void *)rec;
#line 1375
    ((rec->tcp)->write)->handler = & ngx_resolver_tcp_write;
#line 1376
    ((rec->tcp)->read)->handler = & ngx_resolver_tcp_read;
#line 1377
    ((rec->tcp)->read)->resolver = 1U;
#line 1379
    ngx_event_add_timer((rec->tcp)->write, (ngx_msec_t )(r->tcp_timeout * 1000L));
    }
  }
#line 1382
  b = rec->write_buf;
#line 1384
  if (b->end - b->last < (long )(2 + (int )qlen)) {
#line 1385
    if (rec->log.log_level >= 3UL) {
      {
#line 1385
      ngx_log_error_core((ngx_uint_t )3, & rec->log, 0, "buffer overflow");
      }
    }
#line 1386
    return ((ngx_int_t )-1);
  }
  {
#line 1389
  tmp___3 = b->last;
#line 1389
  (b->last) ++;
#line 1389
  *tmp___3 = (u_char )((int )qlen >> 8);
#line 1390
  tmp___4 = b->last;
#line 1390
  (b->last) ++;
#line 1390
  *tmp___4 = (u_char )qlen;
#line 1391
  tmp___5 = memcpy((void */* __restrict  */)b->last, (void const   */* __restrict  */)query,
                   (size_t )qlen);
#line 1391
  b->last = (u_char *)tmp___5 + (int )qlen;
  }
#line 1393
  if (rc == 0L) {
    {
#line 1394
    ngx_resolver_tcp_write((rec->tcp)->write);
    }
  }
#line 1397
  return ((ngx_int_t )0);
}
}
#line 1401 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_resend_handler(ngx_event_t *ev ) 
{ 
  time_t timer ;
  time_t atimer ;
  time_t stimer ;
  time_t ntimer ;
  time_t a6timer ;
  ngx_resolver_t *r ;

  {
  {
#line 1410
  r = (ngx_resolver_t *)ev->data;
#line 1417
  ntimer = ngx_resolver_resend(r, & r->name_rbtree, & r->name_resend_queue);
#line 1419
  stimer = ngx_resolver_resend(r, & r->srv_rbtree, & r->srv_resend_queue);
#line 1425
  atimer = ngx_resolver_resend(r, & r->addr_rbtree, & r->addr_resend_queue);
#line 1433
  a6timer = ngx_resolver_resend(r, & r->addr6_rbtree, & r->addr6_resend_queue);
#line 1439
  timer = ntimer;
  }
#line 1441
  if (timer == 0L) {
#line 1442
    timer = atimer;
  } else
#line 1444
  if (atimer) {
#line 1445
    if (timer > atimer) {
#line 1445
      timer = atimer;
    } else {
#line 1445
      timer = timer;
    }
  }
#line 1448
  if (timer == 0L) {
#line 1449
    timer = stimer;
  } else
#line 1451
  if (stimer) {
#line 1452
    if (timer > stimer) {
#line 1452
      timer = stimer;
    } else {
#line 1452
      timer = timer;
    }
  }
#line 1457
  if (timer == 0L) {
#line 1458
    timer = a6timer;
  } else
#line 1460
  if (a6timer) {
#line 1461
    if (timer > a6timer) {
#line 1461
      timer = a6timer;
    } else {
#line 1461
      timer = timer;
    }
  }
#line 1466
  if (timer) {
    {
#line 1467
    ngx_event_add_timer(r->event, (ngx_msec_t )(timer * 1000L));
    }
  }
#line 1469
  return;
}
}
#line 1472 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static time_t ngx_resolver_resend(ngx_resolver_t *r , ngx_rbtree_t *tree , ngx_queue_t *queue ) 
{ 
  time_t now ;
  ngx_queue_t *q ;
  ngx_resolver_node_t *rn ;

  {
#line 1479
  now = (time_t )ngx_cached_time->sec;
  {
#line 1481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1482
    if ((unsigned long )queue == (unsigned long )queue->prev) {
#line 1483
      return ((time_t )0);
    }
#line 1486
    q = queue->prev;
#line 1488
    rn = (ngx_resolver_node_t *)((u_char *)q - (unsigned long )(& ((ngx_resolver_node_t *)0)->queue));
#line 1490
    if (now < rn->expire) {
#line 1491
      return (rn->expire - now);
    }
#line 1498
    (q->next)->prev = q->prev;
#line 1498
    (q->prev)->next = q->next;
#line 1500
    if (rn->waiting) {
#line 1502
      (rn->last_connection) ++;
#line 1502
      if (rn->last_connection == r->connections.nelts) {
#line 1503
        rn->last_connection = (ngx_uint_t )0;
      }
      {
#line 1506
      ngx_resolver_send_query(r, rn);
#line 1508
      rn->expire = now + r->resend_timeout;
#line 1510
      q->next = queue->next;
#line 1510
      (q->next)->prev = q;
#line 1510
      q->prev = queue;
#line 1510
      queue->next = q;
      }
#line 1512
      goto __Cont;
    }
    {
#line 1515
    ngx_rbtree_delete(tree, & rn->node);
#line 1517
    ngx_resolver_free_node(r, rn);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1522 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_uint_t ngx_resolver_resend_empty(ngx_resolver_t *r ) 
{ 
  int tmp ;

  {
#line 1525
  if ((unsigned long )(& r->name_resend_queue) == (unsigned long )r->name_resend_queue.prev) {
#line 1525
    if ((unsigned long )(& r->srv_resend_queue) == (unsigned long )r->srv_resend_queue.prev) {
#line 1525
      if ((unsigned long )(& r->addr6_resend_queue) == (unsigned long )r->addr6_resend_queue.prev) {
#line 1525
        if ((unsigned long )(& r->addr_resend_queue) == (unsigned long )r->addr_resend_queue.prev) {
#line 1525
          tmp = 1;
        } else {
#line 1525
          tmp = 0;
        }
      } else {
#line 1525
        tmp = 0;
      }
    } else {
#line 1525
      tmp = 0;
    }
  } else {
#line 1525
    tmp = 0;
  }
#line 1525
  return ((ngx_uint_t )tmp);
}
}
#line 1534 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_udp_read(ngx_event_t *rev ) 
{ 
  ssize_t n ;
  ngx_connection_t *c ;
  ngx_resolver_connection_t *rec ;
  u_char buf[4096] ;
  void *__cil_tmp6 ;

  {
#line 1542
  c = (ngx_connection_t *)rev->data;
#line 1543
  rec = (ngx_resolver_connection_t *)c->data;
  {
#line 1545
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1546
    n = (*(ngx_io.udp_recv))(c, buf, (size_t )4096);
    }
#line 1548
    if (n < 0L) {
#line 1549
      return;
    }
    {
#line 1552
    ngx_resolver_process_response(rec->resolver, buf, (size_t )n, (ngx_uint_t )0);
    }
#line 1545
    if (! rev->ready) {
#line 1545
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1555
  return;
}
}
#line 1558 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_tcp_write(ngx_event_t *wev ) 
{ 
  off_t sent ;
  ssize_t n ;
  ngx_buf_t *b ;
  ngx_resolver_t *r ;
  ngx_connection_t *c ;
  ngx_resolver_connection_t *rec ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
#line 1568
  c = (ngx_connection_t *)wev->data;
#line 1569
  rec = (ngx_resolver_connection_t *)c->data;
#line 1570
  b = rec->write_buf;
#line 1571
  r = rec->resolver;
#line 1573
  if (wev->timedout) {
#line 1574
    goto failed;
  }
#line 1577
  sent = c->sent;
  {
#line 1579
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1579
    if (wev->ready) {
#line 1579
      if (! ((unsigned long )b->pos < (unsigned long )b->last)) {
#line 1579
        goto while_break;
      }
    } else {
#line 1579
      goto while_break;
    }
    {
#line 1580
    n = (*(ngx_io.send))(c, b->pos, (size_t )(b->last - b->pos));
    }
#line 1582
    if (n == -2L) {
#line 1583
      goto while_break;
    }
#line 1586
    if (n == -1L) {
#line 1587
      goto failed;
    }
#line 1590
    b->pos += n;
  }
  while_break: /* CIL Label */ ;
  }
#line 1593
  if ((unsigned long )b->pos != (unsigned long )b->start) {
    {
#line 1594
    tmp = memmove((void *)b->start, (void const   *)b->pos, (size_t )(b->last - b->pos));
#line 1594
    b->last = (u_char *)tmp + (b->last - b->pos);
#line 1595
    b->pos = b->start;
    }
  }
#line 1598
  if (c->sent != sent) {
    {
#line 1599
    ngx_event_add_timer(wev, (ngx_msec_t )(r->tcp_timeout * 1000L));
    }
  }
  {
#line 1602
  tmp___0 = ngx_handle_write_event(wev, (size_t )0);
  }
#line 1602
  if (tmp___0 != 0L) {
#line 1603
    goto failed;
  }
#line 1606
  return;
  failed: 
  {
#line 1610
  ngx_close_connection(c);
#line 1611
  rec->tcp = (ngx_connection_t *)((void *)0);
  }
#line 1612
  return;
}
}
#line 1615 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_tcp_read(ngx_event_t *rev ) 
{ 
  u_char *p ;
  size_t size ;
  ssize_t n ;
  u_short qlen ;
  ngx_buf_t *b ;
  ngx_resolver_t *r ;
  ngx_connection_t *c ;
  ngx_resolver_connection_t *rec ;
  u_char *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 1627
  c = (ngx_connection_t *)rev->data;
#line 1628
  rec = (ngx_resolver_connection_t *)c->data;
#line 1629
  b = rec->read_buf;
#line 1630
  r = rec->resolver;
  {
#line 1632
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1632
    if (! rev->ready) {
#line 1632
      goto while_break;
    }
    {
#line 1633
    n = (*(ngx_io.recv))(c, b->last, (size_t )(b->end - b->last));
    }
#line 1635
    if (n == -2L) {
#line 1636
      goto while_break;
    }
#line 1639
    if (n == -1L) {
#line 1640
      goto failed;
    } else
#line 1639
    if (n == 0L) {
#line 1640
      goto failed;
    }
#line 1643
    b->last += n;
    {
#line 1645
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1646
      p = b->pos;
#line 1647
      size = (size_t )(b->last - p);
#line 1649
      if (size < 2UL) {
#line 1650
        goto while_break___0;
      }
#line 1653
      tmp = p;
#line 1653
      p ++;
#line 1653
      qlen = (u_short )((int )((u_short )*tmp) << 8);
#line 1654
      tmp___0 = p;
#line 1654
      p ++;
#line 1654
      qlen = (u_short )((int )qlen + (int )*tmp___0);
#line 1656
      if (size < (size_t )(2 + (int )qlen)) {
#line 1657
        goto while_break___0;
      }
      {
#line 1660
      ngx_resolver_process_response(r, p, (size_t )qlen, (ngx_uint_t )1);
#line 1662
      b->pos += 2 + (int )qlen;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1665
    if ((unsigned long )b->pos != (unsigned long )b->start) {
      {
#line 1666
      tmp___1 = memmove((void *)b->start, (void const   *)b->pos, (size_t )(b->last - b->pos));
#line 1666
      b->last = (u_char *)tmp___1 + (b->last - b->pos);
#line 1667
      b->pos = b->start;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1671
  tmp___2 = ngx_handle_read_event(rev, (ngx_uint_t )0);
  }
#line 1671
  if (tmp___2 != 0L) {
#line 1672
    goto failed;
  }
#line 1675
  return;
  failed: 
  {
#line 1679
  ngx_close_connection(c);
#line 1680
  rec->tcp = (ngx_connection_t *)((void *)0);
  }
#line 1681
  return;
}
}
#line 1684 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_process_response(ngx_resolver_t *r , u_char *buf , size_t n ,
                                          ngx_uint_t tcp ) 
{ 
  char *err ;
  ngx_uint_t i ;
  ngx_uint_t times ;
  ngx_uint_t ident ;
  ngx_uint_t qident ;
  ngx_uint_t flags ;
  ngx_uint_t code ;
  ngx_uint_t nqs ;
  ngx_uint_t nan ;
  ngx_uint_t trunc ;
  ngx_uint_t qtype ;
  ngx_uint_t qclass ;
  ngx_uint_t qident6 ;
  ngx_queue_t *q ;
  ngx_resolver_qs_t *qs ;
  ngx_resolver_hdr_t *response ;
  ngx_resolver_node_t *rn ;
  char const   *tmp ;
  ngx_uint_t tmp___0 ;
  ngx_uint_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 1699
  if (n < sizeof(ngx_resolver_hdr_t )) {
#line 1700
    goto short_response;
  }
#line 1703
  response = (ngx_resolver_hdr_t *)buf;
#line 1705
  ident = (ngx_uint_t )(((int )response->ident_hi << 8) + (int )response->ident_lo);
#line 1706
  flags = (ngx_uint_t )(((int )response->flags_hi << 8) + (int )response->flags_lo);
#line 1707
  nqs = (ngx_uint_t )(((int )response->nqs_hi << 8) + (int )response->nqs_lo);
#line 1708
  nan = (ngx_uint_t )(((int )response->nan_hi << 8) + (int )response->nan_lo);
#line 1709
  trunc = flags & 512UL;
#line 1718
  if ((flags & 63600UL) != 32768UL) {
#line 1718
    goto _L;
  } else
#line 1718
  if (trunc) {
#line 1718
    if (tcp) {
      _L: /* CIL Label */ 
#line 1719
      if ((r->log)->log_level >= r->log_level) {
#line 1719
        if (tcp) {
#line 1719
          tmp = "TCP";
        } else {
#line 1719
          tmp = "UDP";
        }
        {
#line 1719
        ngx_log_error_core(r->log_level, r->log, 0, "invalid %s DNS response %ui fl:%04Xi",
                           tmp, ident, flags);
        }
      }
#line 1722
      return;
    }
  }
#line 1725
  code = flags & 15UL;
#line 1727
  if (code == 1UL) {
#line 1729
    times = (ngx_uint_t )0;
#line 1731
    q = r->name_resend_queue.next;
    {
#line 1731
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1731
      if ((unsigned long )q != (unsigned long )(& r->name_resend_queue)) {
#line 1731
        tmp___0 = times;
#line 1731
        times ++;
#line 1731
        if (! (tmp___0 < 100UL)) {
#line 1731
          goto while_break;
        }
      } else {
#line 1731
        goto while_break;
      }
#line 1735
      rn = (ngx_resolver_node_t *)((u_char *)q - (unsigned long )(& ((ngx_resolver_node_t *)0)->queue));
#line 1736
      qident = (ngx_uint_t )(((int )*(rn->query + 0) << 8) + (int )*(rn->query + 1));
#line 1738
      if (qident == ident) {
#line 1739
        goto dns_error_name;
      }
#line 1743
      if (rn->query6) {
#line 1744
        qident6 = (ngx_uint_t )(((int )*(rn->query6 + 0) << 8) + (int )*(rn->query6 + 1));
#line 1746
        if (qident6 == ident) {
#line 1747
          goto dns_error_name;
        }
      }
#line 1731
      q = q->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 1753
    goto dns_error;
  }
#line 1756
  if (code > 5UL) {
#line 1757
    goto dns_error;
  }
#line 1760
  if (nqs != 1UL) {
#line 1761
    err = (char *)"invalid number of questions in DNS response";
#line 1762
    goto done;
  }
#line 1765
  i = sizeof(ngx_resolver_hdr_t );
  {
#line 1767
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1767
    if (! (i < n)) {
#line 1767
      goto while_break___0;
    }
#line 1768
    if ((int )*(buf + i) == 0) {
#line 1769
      goto found;
    }
#line 1772
    i += (ngx_uint_t )(1 + (int )*(buf + i));
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1775
  goto short_response;
  found: 
#line 1779
  tmp___1 = i;
#line 1779
  i ++;
#line 1779
  if (tmp___1 == sizeof(ngx_resolver_hdr_t )) {
#line 1780
    err = (char *)"zero-length domain name in DNS response";
#line 1781
    goto done;
  }
#line 1784
  if ((i + sizeof(ngx_resolver_qs_t )) + nan * (2UL + sizeof(ngx_resolver_an_t )) > n) {
#line 1787
    goto short_response;
  }
#line 1790
  qs = (ngx_resolver_qs_t *)(buf + i);
#line 1792
  qtype = (ngx_uint_t )(((int )qs->type_hi << 8) + (int )qs->type_lo);
#line 1793
  qclass = (ngx_uint_t )(((int )qs->class_hi << 8) + (int )qs->class_lo);
#line 1798
  if (qclass != 1UL) {
#line 1799
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1799
      ngx_log_error_core(r->log_level, r->log, 0, "unknown query class %ui in DNS response",
                         qclass);
      }
    }
#line 1801
    return;
  }
  {
#line 1808
  if (qtype == 28UL) {
#line 1808
    goto case_28;
  }
#line 1808
  if (qtype == 1UL) {
#line 1808
    goto case_28;
  }
#line 1816
  if (qtype == 33UL) {
#line 1816
    goto case_33;
  }
#line 1823
  if (qtype == 12UL) {
#line 1823
    goto case_12;
  }
#line 1829
  goto switch_default;
  case_28: /* CIL Label */ 
  case_1: /* CIL Label */ 
  {
#line 1811
  ngx_resolver_process_a(r, buf, n, ident, code, qtype, nan, trunc, i + sizeof(ngx_resolver_qs_t ));
  }
#line 1814
  goto switch_break;
  case_33: /* CIL Label */ 
  {
#line 1818
  ngx_resolver_process_srv(r, buf, n, ident, code, nan, trunc, i + sizeof(ngx_resolver_qs_t ));
  }
#line 1821
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 1825
  ngx_resolver_process_ptr(r, buf, n, ident, code, nan);
  }
#line 1827
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1830
  if ((r->log)->log_level >= r->log_level) {
    {
#line 1830
    ngx_log_error_core(r->log_level, r->log, 0, "unknown query type %ui in DNS response",
                       qtype);
    }
  }
#line 1832
  return;
  switch_break: /* CIL Label */ ;
  }
#line 1835
  return;
  short_response: 
#line 1839
  err = (char *)"short DNS response";
  done: 
#line 1843
  if ((r->log)->log_level >= r->log_level) {
    {
#line 1843
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 1845
  return;
  dns_error_name: 
#line 1849
  if ((r->log)->log_level >= r->log_level) {
    {
#line 1849
    tmp___2 = ngx_resolver_strerror((ngx_int_t )code);
#line 1849
    ngx_log_error_core(r->log_level, r->log, 0, "DNS error (%ui: %s), query id:%ui, name:\"%*s\"",
                       code, tmp___2, ident, (size_t )rn->nlen, rn->name);
    }
  }
#line 1853
  return;
  dns_error: 
#line 1857
  if ((r->log)->log_level >= r->log_level) {
    {
#line 1857
    tmp___3 = ngx_resolver_strerror((ngx_int_t )code);
#line 1857
    ngx_log_error_core(r->log_level, r->log, 0, "DNS error (%ui: %s), query id:%ui",
                       code, tmp___3, ident);
    }
  }
#line 1860
  return;
}
}
#line 1864 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_process_a(ngx_resolver_t *r , u_char *buf , size_t n , ngx_uint_t ident ,
                                   ngx_uint_t code , ngx_uint_t qtype , ngx_uint_t nan ,
                                   ngx_uint_t trunc , ngx_uint_t ans ) 
{ 
  char *err ;
  u_char *cname ;
  size_t len ;
  int32_t ttl ;
  uint32_t hash ;
  in_addr_t *addr ;
  ngx_str_t name ;
  ngx_uint_t type ;
  ngx_uint_t class ;
  ngx_uint_t qident ;
  ngx_uint_t naddrs ;
  ngx_uint_t a ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t start ;
  struct in6_addr *addr6 ;
  ngx_resolver_an_t *an ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_node_t *rn ;
  ngx_resolver_addr_t *addrs ;
  ngx_resolver_connection_t *rec ;
  ngx_int_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  time_t tmp___3 ;
  ngx_int_t tmp___4 ;
  time_t tmp___5 ;
  ngx_uint_t tmp___6 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;

  {
  {
#line 1886
  tmp = ngx_resolver_copy(r, & name, buf, buf + sizeof(ngx_resolver_hdr_t ), buf + n);
  }
#line 1886
  if (tmp != 0L) {
#line 1890
    return;
  }
  {
#line 1895
  hash = ngx_crc32_short(name.data, name.len);
#line 1899
  rn = ngx_resolver_lookup_name(r, & name, hash);
  }
#line 1901
  if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 1902
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1902
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 1904
    ngx_resolver_free(r, (void *)name.data);
    }
#line 1905
    goto failed;
  }
  {
#line 1911
  if (qtype == 28UL) {
#line 1911
    goto case_28;
  }
#line 1930
  goto switch_default;
  case_28: /* CIL Label */ 
#line 1913
  if ((unsigned long )rn->query6 == (unsigned long )((void *)0)) {
#line 1913
    goto _L;
  } else
#line 1913
  if ((int )rn->naddrs6 != 65535) {
    _L: /* CIL Label */ 
#line 1914
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1914
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 1916
    ngx_resolver_free(r, (void *)name.data);
    }
#line 1917
    goto failed;
  }
#line 1920
  if (trunc) {
#line 1920
    if (rn->tcp6) {
      {
#line 1921
      ngx_resolver_free(r, (void *)name.data);
      }
#line 1922
      goto failed;
    }
  }
#line 1925
  qident = (ngx_uint_t )(((int )*(rn->query6 + 0) << 8) + (int )*(rn->query6 + 1));
#line 1927
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1932
  if ((unsigned long )rn->query == (unsigned long )((void *)0)) {
#line 1932
    goto _L___0;
  } else
#line 1932
  if ((int )rn->naddrs != 65535) {
    _L___0: /* CIL Label */ 
#line 1933
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1933
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 1935
    ngx_resolver_free(r, (void *)name.data);
    }
#line 1936
    goto failed;
  }
#line 1939
  if (trunc) {
#line 1939
    if (rn->tcp) {
      {
#line 1940
      ngx_resolver_free(r, (void *)name.data);
      }
#line 1941
      goto failed;
    }
  }
#line 1944
  qident = (ngx_uint_t )(((int )*(rn->query + 0) << 8) + (int )*(rn->query + 1));
  switch_break: /* CIL Label */ ;
  }
#line 1947
  if (ident != qident) {
#line 1948
    if ((r->log)->log_level >= r->log_level) {
      {
#line 1948
      ngx_log_error_core(r->log_level, r->log, 0, "wrong ident %ui response for %V, expect %ui",
                         ident, & name, qident);
      }
    }
    {
#line 1951
    ngx_resolver_free(r, (void *)name.data);
    }
#line 1952
    goto failed;
  }
  {
#line 1955
  ngx_resolver_free(r, (void *)name.data);
  }
#line 1957
  if (trunc) {
#line 1959
    (rn->queue.next)->prev = rn->queue.prev;
#line 1959
    (rn->queue.prev)->next = rn->queue.next;
#line 1961
    if ((unsigned long )rn->waiting == (unsigned long )((void *)0)) {
      {
#line 1962
      ngx_rbtree_delete(& r->name_rbtree, & rn->node);
#line 1963
      ngx_resolver_free_node(r, rn);
      }
#line 1964
      goto failed;
    }
#line 1967
    rec = (ngx_resolver_connection_t *)r->connections.elts;
#line 1968
    rec += rn->last_connection;
    {
#line 1973
    if (qtype == 28UL) {
#line 1973
      goto case_28___0;
    }
#line 1982
    goto switch_default___0;
    case_28___0: /* CIL Label */ 
    {
#line 1975
    rn->tcp6 = 1U;
#line 1977
    ngx_resolver_send_tcp_query(r, rec, rn->query6, rn->qlen);
    }
#line 1979
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 1984
    rn->tcp = 1U;
#line 1986
    ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen);
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 1989
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->resend_timeout);
#line 1991
    rn->queue.next = r->name_resend_queue.next;
#line 1991
    (rn->queue.next)->prev = & rn->queue;
#line 1991
    rn->queue.prev = & r->name_resend_queue;
#line 1991
    r->name_resend_queue.next = & rn->queue;
#line 1993
    goto failed;
  }
#line 1996
  if (code == 0UL) {
#line 1996
    if (rn->code) {
#line 1997
      code = (ngx_uint_t )rn->code;
    }
  }
#line 2000
  if (code == 0UL) {
#line 2000
    if (nan == 0UL) {
      {
#line 2005
      if (qtype == 28UL) {
#line 2005
        goto case_28___1;
      }
#line 2019
      goto switch_default___1;
      case_28___1: /* CIL Label */ 
#line 2007
      rn->naddrs6 = (u_short )0;
#line 2009
      if ((int )rn->naddrs == 65535) {
#line 2010
        goto failed;
      }
#line 2013
      if (rn->naddrs) {
#line 2014
        goto export;
      }
#line 2017
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 2021
      rn->naddrs = (u_short )0;
#line 2023
      if ((int )rn->naddrs6 == 65535) {
#line 2024
        goto failed;
      }
#line 2027
      if (rn->naddrs6) {
#line 2028
        goto export;
      }
      switch_break___1: /* CIL Label */ ;
      }
#line 2033
      code = (ngx_uint_t )3;
    }
  }
#line 2036
  if (code) {
    {
#line 2041
    if (qtype == 28UL) {
#line 2041
      goto case_28___2;
    }
#line 2052
    goto switch_default___2;
    case_28___2: /* CIL Label */ 
#line 2043
    rn->naddrs6 = (u_short )0;
#line 2045
    if ((int )rn->naddrs == 65535) {
#line 2046
      rn->code = (u_char )code;
#line 2047
      goto failed;
    }
#line 2050
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 2054
    rn->naddrs = (u_short )0;
#line 2056
    if ((int )rn->naddrs6 == 65535) {
#line 2057
      rn->code = (u_char )code;
#line 2058
      goto failed;
    }
    switch_break___2: /* CIL Label */ ;
    }
    {
#line 2063
    next = rn->waiting;
#line 2064
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
#line 2066
    (rn->queue.next)->prev = rn->queue.prev;
#line 2066
    (rn->queue.prev)->next = rn->queue.next;
#line 2068
    ngx_rbtree_delete(& r->name_rbtree, & rn->node);
    }
    {
#line 2072
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2072
      if (! next) {
#line 2072
        goto while_break;
      }
#line 2073
      ctx = next;
#line 2074
      ctx->state = (ngx_int_t )code;
#line 2075
      if (r->valid) {
#line 2075
        tmp___0 = r->valid;
      } else {
#line 2075
        tmp___0 = (time_t )10;
      }
      {
#line 2075
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___0);
#line 2076
      next = ctx->next;
#line 2078
      (*(ctx->handler))(ctx);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2081
    ngx_resolver_free_node(r, rn);
    }
#line 2083
    return;
  }
#line 2086
  i = ans;
#line 2087
  naddrs = (ngx_uint_t )0;
#line 2088
  cname = (u_char *)((void *)0);
#line 2090
  a = (ngx_uint_t )0;
  {
#line 2090
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2090
    if (! (a < nan)) {
#line 2090
      goto while_break___0;
    }
#line 2092
    start = i;
    {
#line 2094
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2094
      if (! (i < n)) {
#line 2094
        goto while_break___1;
      }
#line 2096
      if ((int )*(buf + i) & 192) {
#line 2097
        i += 2UL;
#line 2098
        goto found;
      }
#line 2101
      if ((int )*(buf + i) == 0) {
#line 2102
        i ++;
#line 2103
        goto test_length;
      }
#line 2106
      i += (ngx_uint_t )(1 + (int )*(buf + i));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2109
    goto short_response;
    test_length: 
#line 2113
    if (i - start < 2UL) {
#line 2114
      err = (char *)"invalid name in DNS response";
#line 2115
      goto invalid;
    }
    found: 
#line 2120
    if (i + sizeof(ngx_resolver_an_t ) >= n) {
#line 2121
      goto short_response;
    }
#line 2124
    an = (ngx_resolver_an_t *)(buf + i);
#line 2126
    type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 2127
    class = (ngx_uint_t )(((int )an->class_hi << 8) + (int )an->class_lo);
#line 2128
    len = (size_t )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 2129
    ttl = ((((int )an->ttl[0] << 24) + ((int )an->ttl[1] << 16)) + ((int )an->ttl[2] << 8)) + (int )an->ttl[3];
#line 2132
    if (class != 1UL) {
#line 2133
      if ((r->log)->log_level >= r->log_level) {
        {
#line 2133
        ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR class %ui", class);
        }
      }
#line 2135
      goto failed;
    }
#line 2138
    if (ttl < 0) {
#line 2139
      ttl = 0;
    }
#line 2142
    if (rn->ttl > (uint32_t )ttl) {
#line 2142
      rn->ttl = (uint32_t )ttl;
    } else {
#line 2142
      rn->ttl = rn->ttl;
    }
#line 2144
    i += sizeof(ngx_resolver_an_t );
    {
#line 2148
    if (type == 1UL) {
#line 2148
      goto case_1;
    }
#line 2169
    if (type == 28UL) {
#line 2169
      goto case_28___3;
    }
#line 2190
    if (type == 5UL) {
#line 2190
      goto case_5;
    }
#line 2196
    if (type == 39UL) {
#line 2196
      goto case_39;
    }
#line 2200
    goto switch_default___3;
    case_1: /* CIL Label */ 
#line 2150
    if (qtype != 1UL) {
#line 2151
      err = (char *)"unexpected A record in DNS response";
#line 2152
      goto invalid;
    }
#line 2155
    if (len != 4UL) {
#line 2156
      err = (char *)"invalid A record in DNS response";
#line 2157
      goto invalid;
    }
#line 2160
    if (i + 4UL > n) {
#line 2161
      goto short_response;
    }
#line 2164
    naddrs ++;
#line 2166
    goto switch_break___3;
    case_28___3: /* CIL Label */ 
#line 2171
    if (qtype != 28UL) {
#line 2172
      err = (char *)"unexpected AAAA record in DNS response";
#line 2173
      goto invalid;
    }
#line 2176
    if (len != 16UL) {
#line 2177
      err = (char *)"invalid AAAA record in DNS response";
#line 2178
      goto invalid;
    }
#line 2181
    if (i + 16UL > n) {
#line 2182
      goto short_response;
    }
#line 2185
    naddrs ++;
#line 2187
    goto switch_break___3;
    case_5: /* CIL Label */ 
#line 2192
    cname = buf + i;
#line 2194
    goto switch_break___3;
    case_39: /* CIL Label */ 
#line 2198
    goto switch_break___3;
    switch_default___3: /* CIL Label */ 
#line 2202
    if ((r->log)->log_level >= r->log_level) {
      {
#line 2202
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR type %ui", type);
      }
    }
    switch_break___3: /* CIL Label */ ;
    }
#line 2206
    i += len;
#line 2090
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2213
  if (naddrs) {
    {
#line 2218
    if (qtype == 28UL) {
#line 2218
      goto case_28___4;
    }
#line 2241
    goto switch_default___4;
    case_28___4: /* CIL Label */ 
#line 2220
    if (naddrs == 1UL) {
#line 2221
      addr6 = & rn->u6.addr6;
#line 2222
      rn->naddrs6 = (u_short )1;
    } else {
      {
#line 2225
      tmp___1 = ngx_resolver_alloc(r, naddrs * sizeof(struct in6_addr ));
#line 2225
      addr6 = (struct in6_addr *)tmp___1;
      }
#line 2226
      if ((unsigned long )addr6 == (unsigned long )((void *)0)) {
#line 2227
        goto failed;
      }
#line 2230
      rn->u6.addrs6 = addr6;
#line 2231
      rn->naddrs6 = (u_short )naddrs;
    }
#line 2235
    addr = (in_addr_t *)((void *)0);
#line 2238
    goto switch_break___4;
    switch_default___4: /* CIL Label */ 
#line 2243
    if (naddrs == 1UL) {
#line 2244
      addr = & rn->u.addr;
#line 2245
      rn->naddrs = (u_short )1;
    } else {
      {
#line 2248
      tmp___2 = ngx_resolver_alloc(r, naddrs * sizeof(in_addr_t ));
#line 2248
      addr = (in_addr_t *)tmp___2;
      }
#line 2249
      if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 2250
        goto failed;
      }
#line 2253
      rn->u.addrs = addr;
#line 2254
      rn->naddrs = (u_short )naddrs;
    }
#line 2258
    addr6 = (struct in6_addr *)((void *)0);
    switch_break___4: /* CIL Label */ ;
    }
#line 2262
    j = (ngx_uint_t )0;
#line 2263
    i = ans;
#line 2265
    a = (ngx_uint_t )0;
    {
#line 2265
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2265
      if (! (a < nan)) {
#line 2265
        goto while_break___2;
      }
      {
#line 2267
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2269
        if ((int )*(buf + i) & 192) {
#line 2270
          i += 2UL;
#line 2271
          goto while_break___3;
        }
#line 2274
        if ((int )*(buf + i) == 0) {
#line 2275
          i ++;
#line 2276
          goto while_break___3;
        }
#line 2279
        i += (ngx_uint_t )(1 + (int )*(buf + i));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2282
      an = (ngx_resolver_an_t *)(buf + i);
#line 2284
      type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 2285
      len = (size_t )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 2287
      i += sizeof(ngx_resolver_an_t );
#line 2289
      if (type == 1UL) {
        {
#line 2291
        *(addr + j) = htonl((uint32_t )(((((int )*(buf + i) << 24) + ((int )*(buf + (i + 1UL)) << 16)) + ((int )*(buf + (i + 2UL)) << 8)) + (int )*(buf + (i + 3UL))));
#line 2294
        j ++;
        }
#line 2294
        if (j == naddrs) {
#line 2297
          if ((int )rn->naddrs6 == 65535) {
#line 2298
            goto failed;
          }
#line 2302
          goto while_break___2;
        }
      } else
#line 2307
      if (type == 28UL) {
        {
#line 2309
        memcpy((void */* __restrict  */)((addr6 + j)->__in6_u.__u6_addr8), (void const   */* __restrict  */)(buf + i),
               (size_t )16);
#line 2311
        j ++;
        }
#line 2311
        if (j == naddrs) {
#line 2313
          if ((int )rn->naddrs == 65535) {
#line 2314
            goto failed;
          }
#line 2317
          goto while_break___2;
        }
      }
#line 2322
      i += len;
#line 2265
      a ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 2329
  if (qtype == 28UL) {
#line 2329
    goto case_28___5;
  }
#line 2338
  goto switch_default___5;
  case_28___5: /* CIL Label */ 
#line 2331
  if ((int )rn->naddrs6 == 65535) {
#line 2332
    rn->naddrs6 = (u_short )0;
  }
#line 2335
  goto switch_break___5;
  switch_default___5: /* CIL Label */ 
#line 2340
  if ((int )rn->naddrs == 65535) {
#line 2341
    rn->naddrs = (u_short )0;
  }
  switch_break___5: /* CIL Label */ ;
  }
#line 2345
  if ((int )rn->naddrs != 65535) {
#line 2345
    if ((int )rn->naddrs6 != 65535) {
#line 2345
      if ((int )rn->naddrs + (int )rn->naddrs6 > 0) {
        export: 
#line 2360
        naddrs = (ngx_uint_t )rn->naddrs;
#line 2362
        naddrs += (ngx_uint_t )rn->naddrs6;
#line 2365
        if (naddrs == 1UL) {
#line 2365
          if ((int )rn->naddrs == 1) {
#line 2366
            addrs = (ngx_resolver_addr_t *)((void *)0);
          } else {
#line 2365
            goto _L___1;
          }
        } else {
          _L___1: /* CIL Label */ 
          {
#line 2369
          addrs = ngx_resolver_export(r, rn, (ngx_uint_t )0);
          }
#line 2370
          if ((unsigned long )addrs == (unsigned long )((void *)0)) {
#line 2371
            goto failed;
          }
        }
#line 2375
        (rn->queue.next)->prev = rn->queue.prev;
#line 2375
        (rn->queue.prev)->next = rn->queue.next;
#line 2377
        if (r->valid) {
#line 2377
          tmp___3 = r->valid;
        } else {
#line 2377
          tmp___3 = (time_t )rn->ttl;
        }
#line 2377
        rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___3);
#line 2378
        rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 2380
        rn->queue.next = r->name_expire_queue.next;
#line 2380
        (rn->queue.next)->prev = & rn->queue;
#line 2380
        rn->queue.prev = & r->name_expire_queue;
#line 2380
        r->name_expire_queue.next = & rn->queue;
#line 2382
        next = rn->waiting;
#line 2383
        rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
        {
#line 2387
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 2387
          if (! next) {
#line 2387
            goto while_break___4;
          }
#line 2388
          ctx = next;
#line 2389
          ctx->state = (ngx_int_t )0;
#line 2390
          ctx->valid = rn->valid;
#line 2391
          ctx->naddrs = naddrs;
#line 2393
          if ((unsigned long )addrs == (unsigned long )((void *)0)) {
            {
#line 2394
            ctx->addrs = & ctx->addr;
#line 2395
            ctx->addr.sockaddr = (struct sockaddr *)(& ctx->sin);
#line 2396
            ctx->addr.socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 2397
            memset((void *)(& ctx->sin), 0, sizeof(struct sockaddr_in ));
#line 2398
            ctx->sin.sin_family = (sa_family_t )2;
#line 2399
            ctx->sin.sin_addr.s_addr = rn->u.addr;
            }
          } else {
#line 2402
            ctx->addrs = addrs;
          }
          {
#line 2405
          next = ctx->next;
#line 2407
          (*(ctx->handler))(ctx);
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 2410
        if ((unsigned long )addrs != (unsigned long )((void *)0)) {
          {
#line 2411
          ngx_resolver_free(r, (void *)addrs->sockaddr);
#line 2412
          ngx_resolver_free(r, (void *)addrs);
          }
        }
        {
#line 2415
        ngx_resolver_free(r, (void *)rn->query);
#line 2416
        rn->query = (u_char *)((void *)0);
#line 2418
        rn->query6 = (u_char *)((void *)0);
        }
#line 2421
        return;
      }
    }
  }
#line 2424
  if (cname) {
#line 2428
    if ((int )rn->naddrs == 65535) {
#line 2434
      goto failed;
    } else
#line 2428
    if ((int )rn->naddrs6 == 65535) {
#line 2434
      goto failed;
    }
    {
#line 2437
    tmp___4 = ngx_resolver_copy(r, & name, buf, cname, buf + n);
    }
#line 2437
    if (tmp___4 != 0L) {
#line 2438
      goto failed;
    }
#line 2444
    (rn->queue.next)->prev = rn->queue.prev;
#line 2444
    (rn->queue.prev)->next = rn->queue.next;
#line 2446
    rn->cnlen = (u_short )name.len;
#line 2447
    rn->u.cname = name.data;
#line 2449
    if (r->valid) {
#line 2449
      tmp___5 = r->valid;
    } else {
#line 2449
      tmp___5 = (time_t )rn->ttl;
    }
    {
#line 2449
    rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___5);
#line 2450
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 2452
    rn->queue.next = r->name_expire_queue.next;
#line 2452
    (rn->queue.next)->prev = & rn->queue;
#line 2452
    rn->queue.prev = & r->name_expire_queue;
#line 2452
    r->name_expire_queue.next = & rn->queue;
#line 2454
    ngx_resolver_free(r, (void *)rn->query);
#line 2455
    rn->query = (u_char *)((void *)0);
#line 2457
    rn->query6 = (u_char *)((void *)0);
#line 2460
    ctx = rn->waiting;
#line 2461
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
    }
#line 2463
    if (ctx) {
#line 2465
      tmp___6 = ctx->recursion;
#line 2465
      (ctx->recursion) ++;
#line 2465
      if (tmp___6 >= 50UL) {
        {
#line 2469
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 2470
          ctx->state = (ngx_int_t )3;
#line 2471
          next = ctx->next;
#line 2473
          (*(ctx->handler))(ctx);
#line 2475
          ctx = next;
          }
#line 2469
          if (! ctx) {
#line 2469
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2478
        return;
      }
#line 2481
      next = ctx;
      {
#line 2481
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2481
        if (! next) {
#line 2481
          goto while_break___6;
        }
#line 2482
        next->node = (ngx_resolver_node_t *)((void *)0);
#line 2481
        next = next->next;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2485
      ngx_resolve_name_locked(r, ctx, & name);
      }
    }
#line 2490
    return;
  }
#line 2493
  if ((r->log)->log_level >= r->log_level) {
    {
#line 2493
    ngx_log_error_core(r->log_level, r->log, 0, "no A or CNAME types in DNS response");
    }
  }
#line 2495
  return;
  short_response: 
#line 2499
  err = (char *)"short DNS response";
  invalid: 
#line 2505
  if ((r->log)->log_level >= r->log_level) {
    {
#line 2505
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 2507
  return;
  failed: 
#line 2515
  return;
}
}
#line 2519 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_process_srv(ngx_resolver_t *r , u_char *buf , size_t n ,
                                     ngx_uint_t ident , ngx_uint_t code , ngx_uint_t nan ,
                                     ngx_uint_t trunc , ngx_uint_t ans ) 
{ 
  char *err ;
  u_char *cname ;
  size_t len ;
  int32_t ttl ;
  uint32_t hash ;
  ngx_str_t name ;
  ngx_uint_t type ;
  ngx_uint_t qident ;
  ngx_uint_t class ;
  ngx_uint_t start ;
  ngx_uint_t nsrvs ;
  ngx_uint_t a ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_resolver_an_t *an ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_srv_t *srvs ;
  ngx_resolver_node_t *rn ;
  ngx_resolver_connection_t *rec ;
  ngx_int_t tmp ;
  time_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  time_t tmp___4 ;
  ngx_int_t tmp___5 ;
  time_t tmp___6 ;
  ngx_uint_t tmp___7 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
  {
#line 2537
  tmp = ngx_resolver_copy(r, & name, buf, buf + sizeof(ngx_resolver_hdr_t ), buf + n);
  }
#line 2537
  if (tmp != 0L) {
#line 2541
    return;
  }
  {
#line 2546
  hash = ngx_crc32_short(name.data, name.len);
#line 2548
  rn = ngx_resolver_lookup_srv(r, & name, hash);
  }
#line 2550
  if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 2550
    goto _L;
  } else
#line 2550
  if ((unsigned long )rn->query == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 2551
    if ((r->log)->log_level >= r->log_level) {
      {
#line 2551
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 2553
    ngx_resolver_free(r, (void *)name.data);
    }
#line 2554
    goto failed;
  }
#line 2557
  if (trunc) {
#line 2557
    if (rn->tcp) {
      {
#line 2558
      ngx_resolver_free(r, (void *)name.data);
      }
#line 2559
      goto failed;
    }
  }
#line 2562
  qident = (ngx_uint_t )(((int )*(rn->query + 0) << 8) + (int )*(rn->query + 1));
#line 2564
  if (ident != qident) {
#line 2565
    if ((r->log)->log_level >= r->log_level) {
      {
#line 2565
      ngx_log_error_core(r->log_level, r->log, 0, "wrong ident %ui response for %V, expect %ui",
                         ident, & name, qident);
      }
    }
    {
#line 2568
    ngx_resolver_free(r, (void *)name.data);
    }
#line 2569
    goto failed;
  }
  {
#line 2572
  ngx_resolver_free(r, (void *)name.data);
  }
#line 2574
  if (trunc) {
#line 2576
    (rn->queue.next)->prev = rn->queue.prev;
#line 2576
    (rn->queue.prev)->next = rn->queue.next;
#line 2578
    if ((unsigned long )rn->waiting == (unsigned long )((void *)0)) {
      {
#line 2579
      ngx_rbtree_delete(& r->srv_rbtree, & rn->node);
#line 2580
      ngx_resolver_free_node(r, rn);
      }
#line 2581
      return;
    }
    {
#line 2584
    rec = (ngx_resolver_connection_t *)r->connections.elts;
#line 2585
    rec += rn->last_connection;
#line 2587
    rn->tcp = 1U;
#line 2589
    ngx_resolver_send_tcp_query(r, rec, rn->query, rn->qlen);
#line 2591
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->resend_timeout);
#line 2593
    rn->queue.next = r->srv_resend_queue.next;
#line 2593
    (rn->queue.next)->prev = & rn->queue;
#line 2593
    rn->queue.prev = & r->srv_resend_queue;
#line 2593
    r->srv_resend_queue.next = & rn->queue;
    }
#line 2595
    return;
  }
#line 2598
  if (code == 0UL) {
#line 2598
    if (rn->code) {
#line 2599
      code = (ngx_uint_t )rn->code;
    }
  }
#line 2602
  if (code == 0UL) {
#line 2602
    if (nan == 0UL) {
#line 2603
      code = (ngx_uint_t )3;
    }
  }
#line 2606
  if (code) {
    {
#line 2607
    next = rn->waiting;
#line 2608
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
#line 2610
    (rn->queue.next)->prev = rn->queue.prev;
#line 2610
    (rn->queue.prev)->next = rn->queue.next;
#line 2612
    ngx_rbtree_delete(& r->srv_rbtree, & rn->node);
    }
    {
#line 2614
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2614
      if (! next) {
#line 2614
        goto while_break;
      }
#line 2615
      ctx = next;
#line 2616
      ctx->state = (ngx_int_t )code;
#line 2617
      if (r->valid) {
#line 2617
        tmp___0 = r->valid;
      } else {
#line 2617
        tmp___0 = (time_t )10;
      }
      {
#line 2617
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___0);
#line 2618
      next = ctx->next;
#line 2620
      (*(ctx->handler))(ctx);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 2623
    ngx_resolver_free_node(r, rn);
    }
#line 2625
    return;
  }
#line 2628
  i = ans;
#line 2629
  nsrvs = (ngx_uint_t )0;
#line 2630
  cname = (u_char *)((void *)0);
#line 2632
  a = (ngx_uint_t )0;
  {
#line 2632
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2632
    if (! (a < nan)) {
#line 2632
      goto while_break___0;
    }
#line 2634
    start = i;
    {
#line 2636
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2636
      if (! (i < n)) {
#line 2636
        goto while_break___1;
      }
#line 2638
      if ((int )*(buf + i) & 192) {
#line 2639
        i += 2UL;
#line 2640
        goto found;
      }
#line 2643
      if ((int )*(buf + i) == 0) {
#line 2644
        i ++;
#line 2645
        goto test_length;
      }
#line 2648
      i += (ngx_uint_t )(1 + (int )*(buf + i));
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2651
    goto short_response;
    test_length: 
#line 2655
    if (i - start < 2UL) {
#line 2656
      err = (char *)"invalid name DNS response";
#line 2657
      goto invalid;
    }
    found: 
#line 2662
    if (i + sizeof(ngx_resolver_an_t ) >= n) {
#line 2663
      goto short_response;
    }
#line 2666
    an = (ngx_resolver_an_t *)(buf + i);
#line 2668
    type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 2669
    class = (ngx_uint_t )(((int )an->class_hi << 8) + (int )an->class_lo);
#line 2670
    len = (size_t )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 2671
    ttl = ((((int )an->ttl[0] << 24) + ((int )an->ttl[1] << 16)) + ((int )an->ttl[2] << 8)) + (int )an->ttl[3];
#line 2674
    if (class != 1UL) {
#line 2675
      if ((r->log)->log_level >= r->log_level) {
        {
#line 2675
        ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR class %ui", class);
        }
      }
#line 2677
      goto failed;
    }
#line 2680
    if (ttl < 0) {
#line 2681
      ttl = 0;
    }
#line 2684
    if (rn->ttl > (uint32_t )ttl) {
#line 2684
      rn->ttl = (uint32_t )ttl;
    } else {
#line 2684
      rn->ttl = rn->ttl;
    }
#line 2686
    i += sizeof(ngx_resolver_an_t );
    {
#line 2690
    if (type == 33UL) {
#line 2690
      goto case_33;
    }
#line 2706
    if (type == 5UL) {
#line 2706
      goto case_5;
    }
#line 2712
    if (type == 39UL) {
#line 2712
      goto case_39;
    }
#line 2716
    goto switch_default;
    case_33: /* CIL Label */ 
#line 2692
    if (i + 6UL > n) {
#line 2693
      goto short_response;
    }
    {
#line 2696
    tmp___1 = ngx_resolver_copy(r, (ngx_str_t *)((void *)0), buf, buf + (i + 6UL),
                                buf + n);
    }
#line 2696
    if (tmp___1 != 0L) {
#line 2699
      goto failed;
    }
#line 2702
    nsrvs ++;
#line 2704
    goto switch_break;
    case_5: /* CIL Label */ 
#line 2708
    cname = buf + i;
#line 2710
    goto switch_break;
    case_39: /* CIL Label */ 
#line 2714
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2718
    if ((r->log)->log_level >= r->log_level) {
      {
#line 2718
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR type %ui", type);
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 2722
    i += len;
#line 2632
    a ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2729
  if (nsrvs) {
    {
#line 2731
    tmp___2 = ngx_resolver_calloc(r, nsrvs * sizeof(ngx_resolver_srv_t ));
#line 2731
    srvs = (ngx_resolver_srv_t *)tmp___2;
    }
#line 2732
    if ((unsigned long )srvs == (unsigned long )((void *)0)) {
#line 2733
      goto failed;
    }
#line 2736
    rn->u.srvs = srvs;
#line 2737
    rn->nsrvs = (u_short )nsrvs;
#line 2739
    j = (ngx_uint_t )0;
#line 2740
    i = ans;
#line 2742
    a = (ngx_uint_t )0;
    {
#line 2742
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2742
      if (! (a < nan)) {
#line 2742
        goto while_break___2;
      }
      {
#line 2744
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2746
        if ((int )*(buf + i) & 192) {
#line 2747
          i += 2UL;
#line 2748
          goto while_break___3;
        }
#line 2751
        if ((int )*(buf + i) == 0) {
#line 2752
          i ++;
#line 2753
          goto while_break___3;
        }
#line 2756
        i += (ngx_uint_t )(1 + (int )*(buf + i));
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2759
      an = (ngx_resolver_an_t *)(buf + i);
#line 2761
      type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 2762
      len = (size_t )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 2764
      i += sizeof(ngx_resolver_an_t );
#line 2766
      if (type == 33UL) {
#line 2768
        (srvs + j)->priority = (u_short )(((int )*(buf + i) << 8) + (int )*(buf + (i + 1UL)));
#line 2769
        (srvs + j)->weight = (u_short )(((int )*(buf + (i + 2UL)) << 8) + (int )*(buf + (i + 3UL)));
#line 2771
        if ((int )(srvs + j)->weight == 0) {
#line 2772
          (srvs + j)->weight = (u_short )1;
        }
        {
#line 2775
        (srvs + j)->port = (u_short )(((int )*(buf + (i + 4UL)) << 8) + (int )*(buf + (i + 5UL)));
#line 2777
        tmp___3 = ngx_resolver_copy(r, & (srvs + j)->name, buf, buf + (i + 6UL), buf + n);
        }
#line 2777
        if (tmp___3 != 0L) {
#line 2781
          goto failed;
        }
#line 2784
        j ++;
      }
#line 2787
      i += len;
#line 2742
      a ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2790
    ngx_sort((void *)srvs, nsrvs, sizeof(ngx_resolver_srv_t ), & ngx_resolver_cmp_srvs);
#line 2793
    ngx_resolver_free(r, (void *)rn->query);
#line 2794
    rn->query = (u_char *)((void *)0);
#line 2796
    (rn->queue.next)->prev = rn->queue.prev;
#line 2796
    (rn->queue.prev)->next = rn->queue.next;
    }
#line 2798
    if (r->valid) {
#line 2798
      tmp___4 = r->valid;
    } else {
#line 2798
      tmp___4 = (time_t )rn->ttl;
    }
#line 2798
    rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___4);
#line 2799
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 2801
    rn->queue.next = r->srv_expire_queue.next;
#line 2801
    (rn->queue.next)->prev = & rn->queue;
#line 2801
    rn->queue.prev = & r->srv_expire_queue;
#line 2801
    r->srv_expire_queue.next = & rn->queue;
#line 2803
    next = rn->waiting;
#line 2804
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
    {
#line 2806
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2806
      if (! next) {
#line 2806
        goto while_break___4;
      }
      {
#line 2807
      ctx = next;
#line 2808
      next = ctx->next;
#line 2810
      ngx_resolver_resolve_srv_names(ctx, rn);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2813
    return;
  }
#line 2816
  rn->nsrvs = (u_short )0;
#line 2818
  if (cname) {
    {
#line 2822
    tmp___5 = ngx_resolver_copy(r, & name, buf, cname, buf + n);
    }
#line 2822
    if (tmp___5 != 0L) {
#line 2823
      goto failed;
    }
#line 2829
    (rn->queue.next)->prev = rn->queue.prev;
#line 2829
    (rn->queue.prev)->next = rn->queue.next;
#line 2831
    rn->cnlen = (u_short )name.len;
#line 2832
    rn->u.cname = name.data;
#line 2834
    if (r->valid) {
#line 2834
      tmp___6 = r->valid;
    } else {
#line 2834
      tmp___6 = (time_t )rn->ttl;
    }
    {
#line 2834
    rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___6);
#line 2835
    rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 2837
    rn->queue.next = r->srv_expire_queue.next;
#line 2837
    (rn->queue.next)->prev = & rn->queue;
#line 2837
    rn->queue.prev = & r->srv_expire_queue;
#line 2837
    r->srv_expire_queue.next = & rn->queue;
#line 2839
    ngx_resolver_free(r, (void *)rn->query);
#line 2840
    rn->query = (u_char *)((void *)0);
#line 2842
    rn->query6 = (u_char *)((void *)0);
#line 2845
    ctx = rn->waiting;
#line 2846
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
    }
#line 2848
    if (ctx) {
#line 2850
      tmp___7 = ctx->recursion;
#line 2850
      (ctx->recursion) ++;
#line 2850
      if (tmp___7 >= 50UL) {
        {
#line 2854
        while (1) {
          while_continue___5: /* CIL Label */ ;
          {
#line 2855
          ctx->state = (ngx_int_t )3;
#line 2856
          next = ctx->next;
#line 2858
          (*(ctx->handler))(ctx);
#line 2860
          ctx = next;
          }
#line 2854
          if (! ctx) {
#line 2854
            goto while_break___5;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 2863
        return;
      }
#line 2866
      next = ctx;
      {
#line 2866
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2866
        if (! next) {
#line 2866
          goto while_break___6;
        }
#line 2867
        next->node = (ngx_resolver_node_t *)((void *)0);
#line 2866
        next = next->next;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2870
      ngx_resolve_name_locked(r, ctx, & name);
      }
    }
#line 2875
    return;
  }
#line 2878
  if ((r->log)->log_level >= r->log_level) {
    {
#line 2878
    ngx_log_error_core(r->log_level, r->log, 0, "no SRV type in DNS response");
    }
  }
#line 2880
  return;
  short_response: 
#line 2884
  err = (char *)"short DNS response";
  invalid: 
#line 2890
  if ((r->log)->log_level >= r->log_level) {
    {
#line 2890
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 2892
  return;
  failed: 
#line 2898
  return;
}
}
#line 2902 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_resolve_srv_names(ngx_resolver_ctx_t *ctx , ngx_resolver_node_t *rn ) 
{ 
  ngx_uint_t i ;
  ngx_resolver_t *r ;
  ngx_resolver_ctx_t *cctx ;
  ngx_resolver_srv_name_t *srvs ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  time_t tmp___2 ;

  {
  {
#line 2910
  r = ctx->resolver;
#line 2912
  ctx->node = (ngx_resolver_node_t *)((void *)0);
#line 2913
  ctx->state = (ngx_int_t )0;
#line 2914
  ctx->valid = rn->valid;
#line 2915
  ctx->count = (ngx_uint_t )rn->nsrvs;
#line 2917
  tmp = ngx_resolver_calloc(r, (unsigned long )rn->nsrvs * sizeof(ngx_resolver_srv_name_t ));
#line 2917
  srvs = (ngx_resolver_srv_name_t *)tmp;
  }
#line 2918
  if ((unsigned long )srvs == (unsigned long )((void *)0)) {
#line 2919
    goto failed;
  }
#line 2922
  ctx->srvs = srvs;
#line 2923
  ctx->nsrvs = (ngx_uint_t )rn->nsrvs;
#line 2925
  if (ctx->event) {
#line 2925
    if ((ctx->event)->timer_set) {
      {
#line 2926
      ngx_event_del_timer(ctx->event);
      }
    }
  }
#line 2929
  i = (ngx_uint_t )0;
  {
#line 2929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2929
    if (! (i < (ngx_uint_t )rn->nsrvs)) {
#line 2929
      goto while_break;
    }
    {
#line 2930
    tmp___0 = ngx_resolver_alloc(r, (rn->u.srvs + i)->name.len);
#line 2930
    (srvs + i)->name.data = (u_char *)tmp___0;
    }
#line 2931
    if ((unsigned long )(srvs + i)->name.data == (unsigned long )((void *)0)) {
#line 2932
      goto failed;
    }
    {
#line 2935
    (srvs + i)->name.len = (rn->u.srvs + i)->name.len;
#line 2936
    memcpy((void */* __restrict  */)(srvs + i)->name.data, (void const   */* __restrict  */)(rn->u.srvs + i)->name.data,
           (srvs + i)->name.len);
#line 2939
    cctx = ngx_resolve_start(r, (ngx_resolver_ctx_t *)((void *)0));
    }
#line 2940
    if ((unsigned long )cctx == (unsigned long )((void *)0)) {
#line 2941
      goto failed;
    }
    {
#line 2944
    cctx->name = (srvs + i)->name;
#line 2945
    cctx->handler = & ngx_resolver_srv_names_handler;
#line 2946
    cctx->data = (void *)ctx;
#line 2947
    cctx->srvs = srvs + i;
#line 2948
    cctx->timeout = ctx->timeout;
#line 2950
    (srvs + i)->priority = (rn->u.srvs + i)->priority;
#line 2951
    (srvs + i)->weight = (rn->u.srvs + i)->weight;
#line 2952
    (srvs + i)->port = (rn->u.srvs + i)->port;
#line 2953
    (srvs + i)->ctx = cctx;
#line 2955
    tmp___1 = ngx_resolve_name(cctx);
    }
#line 2955
    if (tmp___1 == -1L) {
#line 2956
      (srvs + i)->ctx = (ngx_resolver_ctx_t *)((void *)0);
#line 2957
      goto failed;
    }
#line 2929
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2961
  return;
  failed: 
#line 2965
  ctx->state = (ngx_int_t )-1;
#line 2966
  if (r->valid) {
#line 2966
    tmp___2 = r->valid;
  } else {
#line 2966
    tmp___2 = (time_t )10;
  }
  {
#line 2966
  ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___2);
#line 2968
  (*(ctx->handler))(ctx);
  }
#line 2969
  return;
}
}
#line 2972 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_srv_names_handler(ngx_resolver_ctx_t *cctx ) 
{ 
  ngx_uint_t i ;
  ngx_addr_t *addrs ;
  ngx_resolver_t *r ;
  ngx_sockaddr_t *sockaddr ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_srv_name_t *srv ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 2982
  r = cctx->resolver;
#line 2983
  ctx = (ngx_resolver_ctx_t *)cctx->data;
#line 2984
  srv = cctx->srvs;
#line 2986
  (ctx->count) --;
#line 2987
  ctx->async |= cctx->async;
#line 2989
  srv->ctx = (ngx_resolver_ctx_t *)((void *)0);
#line 2990
  srv->state = cctx->state;
#line 2992
  if (cctx->naddrs) {
#line 2994
    if (ctx->valid > cctx->valid) {
#line 2994
      ctx->valid = cctx->valid;
    } else {
#line 2994
      ctx->valid = ctx->valid;
    }
    {
#line 2996
    tmp = ngx_resolver_calloc(r, cctx->naddrs * sizeof(ngx_addr_t ));
#line 2996
    addrs = (ngx_addr_t *)tmp;
    }
#line 2997
    if ((unsigned long )addrs == (unsigned long )((void *)0)) {
#line 2998
      srv->state = (ngx_int_t )-1;
#line 2999
      goto done;
    }
    {
#line 3002
    tmp___0 = ngx_resolver_alloc(r, cctx->naddrs * sizeof(ngx_sockaddr_t ));
#line 3002
    sockaddr = (ngx_sockaddr_t *)tmp___0;
    }
#line 3003
    if ((unsigned long )sockaddr == (unsigned long )((void *)0)) {
      {
#line 3004
      ngx_resolver_free(r, (void *)addrs);
#line 3005
      srv->state = (ngx_int_t )-1;
      }
#line 3006
      goto done;
    }
#line 3009
    i = (ngx_uint_t )0;
    {
#line 3009
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3009
      if (! (i < cctx->naddrs)) {
#line 3009
        goto while_break;
      }
      {
#line 3010
      (addrs + i)->sockaddr = & (sockaddr + i)->sockaddr;
#line 3011
      (addrs + i)->socklen = (cctx->addrs + i)->socklen;
#line 3013
      memcpy((void */* __restrict  */)(sockaddr + i), (void const   */* __restrict  */)(cctx->addrs + i)->sockaddr,
             (size_t )(addrs + i)->socklen);
#line 3016
      ngx_inet_set_port((addrs + i)->sockaddr, srv->port);
#line 3009
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 3019
    srv->addrs = addrs;
#line 3020
    srv->naddrs = cctx->naddrs;
  }
  done: 
  {
#line 3025
  ngx_resolve_name_done(cctx);
  }
#line 3027
  if (ctx->count == 0UL) {
    {
#line 3028
    ngx_resolver_report_srv(r, ctx);
    }
  }
#line 3030
  return;
}
}
#line 3033 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_process_ptr(ngx_resolver_t *r , u_char *buf , size_t n ,
                                     ngx_uint_t ident , ngx_uint_t code , ngx_uint_t nan ) 
{ 
  char *err ;
  size_t len ;
  in_addr_t addr ;
  int32_t ttl ;
  ngx_int_t octet ;
  ngx_str_t name ;
  ngx_uint_t mask ;
  ngx_uint_t type ;
  ngx_uint_t class ;
  ngx_uint_t qident ;
  ngx_uint_t a ;
  ngx_uint_t i ;
  ngx_uint_t start ;
  ngx_queue_t *expire_queue ;
  ngx_rbtree_t *tree ;
  ngx_resolver_an_t *an ;
  ngx_resolver_ctx_t *ctx ;
  ngx_resolver_ctx_t *next ;
  ngx_resolver_node_t *rn ;
  uint32_t hash ;
  ngx_int_t digit ;
  struct in6_addr addr6 ;
  ngx_int_t tmp ;
  ngx_uint_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_uint_t tmp___2 ;
  ngx_uint_t tmp___3 ;
  ngx_uint_t tmp___4 ;
  ngx_uint_t tmp___5 ;
  ngx_int_t tmp___6 ;
  time_t tmp___7 ;
  ngx_int_t tmp___8 ;
  void *tmp___9 ;
  int tmp___10 ;
  time_t tmp___11 ;
  void *__cil_tmp42 ;
  void *__cil_tmp43 ;
  void *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;

  {
  {
#line 3055
  tmp = ngx_resolver_copy(r, & name, buf, buf + sizeof(ngx_resolver_hdr_t ), buf + n);
  }
#line 3055
  if (tmp != 0L) {
#line 3059
    return;
  }
#line 3066
  addr = (in_addr_t )0;
#line 3067
  i = sizeof(ngx_resolver_hdr_t );
#line 3069
  mask = (ngx_uint_t )0;
  {
#line 3069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3069
    if (! (mask < 32UL)) {
#line 3069
      goto while_break;
    }
    {
#line 3070
    tmp___0 = i;
#line 3070
    i ++;
#line 3070
    len = (size_t )*(buf + tmp___0);
#line 3072
    octet = ngx_atoi(buf + i, len);
    }
#line 3073
    if (octet == -1L) {
#line 3074
      goto invalid_in_addr_arpa;
    } else
#line 3073
    if (octet > 255L) {
#line 3074
      goto invalid_in_addr_arpa;
    }
#line 3077
    addr = (in_addr_t )((ngx_int_t )addr + (octet << mask));
#line 3078
    i += len;
#line 3069
    mask += 8UL;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3081
  tmp___1 = ngx_strcasecmp(buf + i, (u_char *)"\ain-addr\004arpa");
  }
#line 3081
  if (tmp___1 == 0L) {
    {
#line 3082
    i += sizeof("\ain-addr\004arpa");
#line 3086
    rn = ngx_resolver_lookup_addr(r, addr);
#line 3088
    tree = & r->addr_rbtree;
#line 3089
    expire_queue = & r->addr_expire_queue;
    }
#line 3091
    goto valid;
  }
  invalid_in_addr_arpa: 
#line 3098
  i = sizeof(ngx_resolver_hdr_t );
#line 3100
  octet = (ngx_int_t )15;
  {
#line 3100
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3100
    if (! (octet >= 0L)) {
#line 3100
      goto while_break___0;
    }
#line 3101
    tmp___2 = i;
#line 3101
    i ++;
#line 3101
    if ((int )*(buf + tmp___2) != 1) {
#line 3102
      goto invalid_ip6_arpa;
    }
    {
#line 3105
    tmp___3 = i;
#line 3105
    i ++;
#line 3105
    digit = ngx_hextoi(buf + tmp___3, (size_t )1);
    }
#line 3106
    if (digit == -1L) {
#line 3107
      goto invalid_ip6_arpa;
    }
#line 3110
    addr6.__in6_u.__u6_addr8[octet] = (u_char )digit;
#line 3112
    tmp___4 = i;
#line 3112
    i ++;
#line 3112
    if ((int )*(buf + tmp___4) != 1) {
#line 3113
      goto invalid_ip6_arpa;
    }
    {
#line 3116
    tmp___5 = i;
#line 3116
    i ++;
#line 3116
    digit = ngx_hextoi(buf + tmp___5, (size_t )1);
    }
#line 3117
    if (digit == -1L) {
#line 3118
      goto invalid_ip6_arpa;
    }
#line 3121
    addr6.__in6_u.__u6_addr8[octet] = (uint8_t )((int )addr6.__in6_u.__u6_addr8[octet] + (int )((u_char )(digit * 16L)));
#line 3100
    octet --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3124
  tmp___6 = ngx_strcasecmp(buf + i, (u_char *)"\003ip6\004arpa");
  }
#line 3124
  if (tmp___6 == 0L) {
    {
#line 3125
    i += sizeof("\003ip6\004arpa");
#line 3129
    hash = ngx_crc32_short(addr6.__in6_u.__u6_addr8, (size_t )16);
#line 3130
    rn = ngx_resolver_lookup_addr6(r, & addr6, hash);
#line 3132
    tree = & r->addr6_rbtree;
#line 3133
    expire_queue = & r->addr6_expire_queue;
    }
#line 3135
    goto valid;
  }
  invalid_ip6_arpa: 
#line 3141
  if ((r->log)->log_level >= r->log_level) {
    {
#line 3141
    ngx_log_error_core(r->log_level, r->log, 0, "invalid in-addr.arpa or ip6.arpa name in DNS response");
    }
  }
  {
#line 3143
  ngx_resolver_free(r, (void *)name.data);
  }
#line 3144
  return;
  valid: 
#line 3148
  if ((unsigned long )rn == (unsigned long )((void *)0)) {
#line 3148
    goto _L;
  } else
#line 3148
  if ((unsigned long )rn->query == (unsigned long )((void *)0)) {
    _L: /* CIL Label */ 
#line 3149
    if ((r->log)->log_level >= r->log_level) {
      {
#line 3149
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected response for %V", & name);
      }
    }
    {
#line 3151
    ngx_resolver_free(r, (void *)name.data);
    }
#line 3152
    goto failed;
  }
#line 3155
  qident = (ngx_uint_t )(((int )*(rn->query + 0) << 8) + (int )*(rn->query + 1));
#line 3157
  if (ident != qident) {
#line 3158
    if ((r->log)->log_level >= r->log_level) {
      {
#line 3158
      ngx_log_error_core(r->log_level, r->log, 0, "wrong ident %ui response for %V, expect %ui",
                         ident, & name, qident);
      }
    }
    {
#line 3161
    ngx_resolver_free(r, (void *)name.data);
    }
#line 3162
    goto failed;
  }
  {
#line 3165
  ngx_resolver_free(r, (void *)name.data);
  }
#line 3167
  if (code == 0UL) {
#line 3167
    if (nan == 0UL) {
#line 3168
      code = (ngx_uint_t )3;
    }
  }
#line 3171
  if (code) {
    {
#line 3172
    next = rn->waiting;
#line 3173
    rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
#line 3175
    (rn->queue.next)->prev = rn->queue.prev;
#line 3175
    (rn->queue.prev)->next = rn->queue.next;
#line 3177
    ngx_rbtree_delete(tree, & rn->node);
    }
    {
#line 3181
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 3181
      if (! next) {
#line 3181
        goto while_break___1;
      }
#line 3182
      ctx = next;
#line 3183
      ctx->state = (ngx_int_t )code;
#line 3184
      if (r->valid) {
#line 3184
        tmp___7 = r->valid;
      } else {
#line 3184
        tmp___7 = (time_t )10;
      }
      {
#line 3184
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___7);
#line 3185
      next = ctx->next;
#line 3187
      (*(ctx->handler))(ctx);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 3190
    ngx_resolver_free_node(r, rn);
    }
#line 3192
    return;
  }
#line 3195
  i += sizeof(ngx_resolver_qs_t );
#line 3197
  a = (ngx_uint_t )0;
  {
#line 3197
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3197
    if (! (a < nan)) {
#line 3197
      goto while_break___2;
    }
#line 3199
    start = i;
    {
#line 3201
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 3201
      if (! (i < n)) {
#line 3201
        goto while_break___3;
      }
#line 3203
      if ((int )*(buf + i) & 192) {
#line 3204
        i += 2UL;
#line 3205
        goto found;
      }
#line 3208
      if ((int )*(buf + i) == 0) {
#line 3209
        i ++;
#line 3210
        goto test_length;
      }
#line 3213
      i += (ngx_uint_t )(1 + (int )*(buf + i));
    }
    while_break___3: /* CIL Label */ ;
    }
#line 3216
    goto short_response;
    test_length: 
#line 3220
    if (i - start < 2UL) {
#line 3221
      err = (char *)"invalid name in DNS response";
#line 3222
      goto invalid;
    }
    found: 
#line 3227
    if (i + sizeof(ngx_resolver_an_t ) >= n) {
#line 3228
      goto short_response;
    }
#line 3231
    an = (ngx_resolver_an_t *)(buf + i);
#line 3233
    type = (ngx_uint_t )(((int )an->type_hi << 8) + (int )an->type_lo);
#line 3234
    class = (ngx_uint_t )(((int )an->class_hi << 8) + (int )an->class_lo);
#line 3235
    len = (size_t )(((int )an->len_hi << 8) + (int )an->len_lo);
#line 3236
    ttl = ((((int )an->ttl[0] << 24) + ((int )an->ttl[1] << 16)) + ((int )an->ttl[2] << 8)) + (int )an->ttl[3];
#line 3239
    if (class != 1UL) {
#line 3240
      if ((r->log)->log_level >= r->log_level) {
        {
#line 3240
        ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR class %ui", class);
        }
      }
#line 3242
      goto failed;
    }
#line 3245
    if (ttl < 0) {
#line 3246
      ttl = 0;
    }
#line 3253
    i += sizeof(ngx_resolver_an_t );
    {
#line 3257
    if (type == 12UL) {
#line 3257
      goto case_12;
    }
#line 3261
    if (type == 5UL) {
#line 3261
      goto case_5;
    }
#line 3265
    goto switch_default;
    case_12: /* CIL Label */ 
#line 3259
    goto ptr;
    case_5: /* CIL Label */ 
#line 3263
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 3267
    if ((r->log)->log_level >= r->log_level) {
      {
#line 3267
      ngx_log_error_core(r->log_level, r->log, 0, "unexpected RR type %ui", type);
      }
    }
    switch_break: /* CIL Label */ ;
    }
#line 3271
    i += len;
#line 3197
    a ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3276
  if ((r->log)->log_level >= r->log_level) {
    {
#line 3276
    ngx_log_error_core(r->log_level, r->log, 0, "no PTR type in DNS response");
    }
  }
#line 3278
  return;
  ptr: 
  {
#line 3282
  tmp___8 = ngx_resolver_copy(r, & name, buf, buf + i, buf + n);
  }
#line 3282
  if (tmp___8 != 0L) {
#line 3283
    goto failed;
  }
#line 3288
  if (name.len != (size_t )rn->nlen) {
#line 3288
    goto _L___0;
  } else {
    {
#line 3288
    tmp___10 = strncmp((char const   *)name.data, (char const   *)rn->name, name.len);
    }
#line 3288
    if (tmp___10 != 0) {
      _L___0: /* CIL Label */ 
#line 3291
      if (rn->nlen) {
        {
#line 3292
        ngx_resolver_free(r, (void *)rn->name);
        }
      }
      {
#line 3295
      rn->nlen = (u_short )name.len;
#line 3296
      rn->name = name.data;
#line 3298
      tmp___9 = ngx_resolver_dup(r, (void *)rn->name, name.len);
#line 3298
      name.data = (u_char *)tmp___9;
      }
#line 3299
      if ((unsigned long )name.data == (unsigned long )((void *)0)) {
#line 3300
        goto failed;
      }
    }
  }
#line 3304
  (rn->queue.next)->prev = rn->queue.prev;
#line 3304
  (rn->queue.prev)->next = rn->queue.next;
#line 3306
  if (r->valid) {
#line 3306
    tmp___11 = r->valid;
  } else {
#line 3306
    tmp___11 = (time_t )ttl;
  }
#line 3306
  rn->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___11);
#line 3307
  rn->expire = (time_t )(ngx_cached_time->sec + (time_t volatile   )r->expire);
#line 3309
  rn->queue.next = expire_queue->next;
#line 3309
  (rn->queue.next)->prev = & rn->queue;
#line 3309
  rn->queue.prev = expire_queue;
#line 3309
  expire_queue->next = & rn->queue;
#line 3311
  next = rn->waiting;
#line 3312
  rn->waiting = (ngx_resolver_ctx_t *)((void *)0);
  {
#line 3316
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3316
    if (! next) {
#line 3316
      goto while_break___4;
    }
    {
#line 3317
    ctx = next;
#line 3318
    ctx->state = (ngx_int_t )0;
#line 3319
    ctx->valid = rn->valid;
#line 3320
    ctx->name = name;
#line 3321
    next = ctx->next;
#line 3323
    (*(ctx->handler))(ctx);
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 3326
  ngx_resolver_free(r, (void *)name.data);
  }
#line 3328
  return;
  short_response: 
#line 3332
  err = (char *)"short DNS response";
  invalid: 
#line 3338
  if ((r->log)->log_level >= r->log_level) {
    {
#line 3338
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 3340
  return;
  failed: 
#line 3346
  return;
}
}
#line 3350 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_resolver_node_t *ngx_resolver_lookup_name(ngx_resolver_t *r , ngx_str_t *name ,
                                                     uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_resolver_node_t *rn ;

  {
#line 3357
  node = r->name_rbtree.root;
#line 3358
  sentinel = r->name_rbtree.sentinel;
  {
#line 3360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3360
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 3360
      goto while_break;
    }
#line 3362
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 3363
      node = node->left;
#line 3364
      goto while_continue;
    }
#line 3367
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 3368
      node = node->right;
#line 3369
      goto while_continue;
    }
    {
#line 3374
    rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3376
    rc = ngx_memn2cmp(name->data, rn->name, name->len, (size_t )rn->nlen);
    }
#line 3378
    if (rc == 0L) {
#line 3379
      return (rn);
    }
#line 3382
    if (rc < 0L) {
#line 3382
      node = node->left;
    } else {
#line 3382
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3387
  return ((ngx_resolver_node_t *)((void *)0));
}
}
#line 3391 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_resolver_node_t *ngx_resolver_lookup_srv(ngx_resolver_t *r , ngx_str_t *name ,
                                                    uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_resolver_node_t *rn ;

  {
#line 3398
  node = r->srv_rbtree.root;
#line 3399
  sentinel = r->srv_rbtree.sentinel;
  {
#line 3401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3401
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 3401
      goto while_break;
    }
#line 3403
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 3404
      node = node->left;
#line 3405
      goto while_continue;
    }
#line 3408
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 3409
      node = node->right;
#line 3410
      goto while_continue;
    }
    {
#line 3415
    rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3417
    rc = ngx_memn2cmp(name->data, rn->name, name->len, (size_t )rn->nlen);
    }
#line 3419
    if (rc == 0L) {
#line 3420
      return (rn);
    }
#line 3423
    if (rc < 0L) {
#line 3423
      node = node->left;
    } else {
#line 3423
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3428
  return ((ngx_resolver_node_t *)((void *)0));
}
}
#line 3432 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_resolver_node_t *ngx_resolver_lookup_addr(ngx_resolver_t *r , in_addr_t addr ) 
{ 
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;

  {
#line 3437
  node = r->addr_rbtree.root;
#line 3438
  sentinel = r->addr_rbtree.sentinel;
  {
#line 3440
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3440
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 3440
      goto while_break;
    }
#line 3442
    if ((ngx_rbtree_key_t )addr < node->key) {
#line 3443
      node = node->left;
#line 3444
      goto while_continue;
    }
#line 3447
    if ((ngx_rbtree_key_t )addr > node->key) {
#line 3448
      node = node->right;
#line 3449
      goto while_continue;
    }
#line 3454
    return ((ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node)));
  }
  while_break: /* CIL Label */ ;
  }
#line 3459
  return ((ngx_resolver_node_t *)((void *)0));
}
}
#line 3465 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_resolver_node_t *ngx_resolver_lookup_addr6(ngx_resolver_t *r , struct in6_addr *addr ,
                                                      uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  ngx_resolver_node_t *rn ;
  int tmp ;

  {
#line 3473
  node = r->addr6_rbtree.root;
#line 3474
  sentinel = r->addr6_rbtree.sentinel;
  {
#line 3476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3476
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 3476
      goto while_break;
    }
#line 3478
    if ((ngx_rbtree_key_t )hash < node->key) {
#line 3479
      node = node->left;
#line 3480
      goto while_continue;
    }
#line 3483
    if ((ngx_rbtree_key_t )hash > node->key) {
#line 3484
      node = node->right;
#line 3485
      goto while_continue;
    }
    {
#line 3490
    rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3492
    tmp = memcmp((void const   *)((char const   *)addr), (void const   *)((char const   *)(& rn->addr6)),
                 (size_t )16);
#line 3492
    rc = (ngx_int_t )tmp;
    }
#line 3494
    if (rc == 0L) {
#line 3495
      return (rn);
    }
#line 3498
    if (rc < 0L) {
#line 3498
      node = node->left;
    } else {
#line 3498
      node = node->right;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3503
  return ((ngx_resolver_node_t *)((void *)0));
}
}
#line 3509 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                             ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_resolver_node_t *rn ;
  ngx_resolver_node_t *rn_temp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 3516
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3518
    if (node->key < temp->key) {
#line 3520
      p = & temp->left;
    } else
#line 3522
    if (node->key > temp->key) {
#line 3524
      p = & temp->right;
    } else {
      {
#line 3528
      rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3529
      rn_temp = (ngx_resolver_node_t *)((u_char *)temp - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3531
      tmp___0 = ngx_memn2cmp(rn->name, rn_temp->name, (size_t )rn->nlen, (size_t )rn_temp->nlen);
      }
#line 3531
      if (tmp___0 < 0L) {
#line 3531
        p = & temp->left;
      } else {
#line 3531
        p = & temp->right;
      }
    }
#line 3535
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 3536
      goto while_break;
    }
#line 3539
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 3542
  *p = node;
#line 3543
  node->parent = temp;
#line 3544
  node->left = sentinel;
#line 3545
  node->right = sentinel;
#line 3546
  node->color = (u_char )1;
#line 3547
  return;
}
}
#line 3552 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_rbtree_insert_addr6_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                                   ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;
  ngx_resolver_node_t *rn ;
  ngx_resolver_node_t *rn_temp ;
  int tmp___0 ;

  {
  {
#line 3559
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3561
    if (node->key < temp->key) {
#line 3563
      p = & temp->left;
    } else
#line 3565
    if (node->key > temp->key) {
#line 3567
      p = & temp->right;
    } else {
      {
#line 3571
      rn = (ngx_resolver_node_t *)((u_char *)node - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3572
      rn_temp = (ngx_resolver_node_t *)((u_char *)temp - (unsigned long )(& ((ngx_resolver_node_t *)0)->node));
#line 3574
      tmp___0 = memcmp((void const   *)((char const   *)(& rn->addr6)), (void const   *)((char const   *)(& rn_temp->addr6)),
                       (size_t )16);
      }
#line 3574
      if (tmp___0 < 0) {
#line 3574
        p = & temp->left;
      } else {
#line 3574
        p = & temp->right;
      }
    }
#line 3578
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 3579
      goto while_break;
    }
#line 3582
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 3585
  *p = node;
#line 3586
  node->parent = temp;
#line 3587
  node->left = sentinel;
#line 3588
  node->right = sentinel;
#line 3589
  node->color = (u_char )1;
#line 3590
  return;
}
}
#line 3595 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_create_name_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_str_t *name ) 
{ 
  u_char *p ;
  u_char *s ;
  size_t len ;
  size_t nlen ;
  ngx_uint_t ident ;
  ngx_resolver_qs_t *qs ;
  ngx_resolver_hdr_t *query ;
  size_t tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  u_char *tmp___2 ;
  long tmp___3 ;

  {
#line 3605
  if (name->len) {
#line 3605
    nlen = (1UL + name->len) + 1UL;
  } else {
#line 3605
    nlen = (size_t )1;
  }
#line 3607
  len = (sizeof(ngx_resolver_hdr_t ) + nlen) + sizeof(ngx_resolver_qs_t );
#line 3610
  if (r->ipv6) {
#line 3610
    tmp = len * 2UL;
  } else {
#line 3610
    tmp = len;
  }
  {
#line 3610
  tmp___0 = ngx_resolver_alloc(r, tmp);
#line 3610
  p = (u_char *)tmp___0;
  }
#line 3614
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3615
    return ((ngx_int_t )-1);
  }
#line 3618
  rn->qlen = (u_short )len;
#line 3619
  rn->query = p;
#line 3622
  if (r->ipv6) {
#line 3623
    rn->query6 = p + len;
  }
  {
#line 3627
  query = (ngx_resolver_hdr_t *)p;
#line 3629
  tmp___1 = random();
#line 3629
  ident = (ngx_uint_t )tmp___1;
#line 3634
  query->ident_hi = (u_char )((ident >> 8) & 255UL);
#line 3635
  query->ident_lo = (u_char )(ident & 255UL);
#line 3638
  query->flags_hi = (u_char )1;
#line 3638
  query->flags_lo = (u_char )0;
#line 3641
  query->nqs_hi = (u_char )0;
#line 3641
  query->nqs_lo = (u_char )1;
#line 3642
  query->nan_hi = (u_char )0;
#line 3642
  query->nan_lo = (u_char )0;
#line 3643
  query->nns_hi = (u_char )0;
#line 3643
  query->nns_lo = (u_char )0;
#line 3644
  query->nar_hi = (u_char )0;
#line 3644
  query->nar_lo = (u_char )0;
#line 3646
  p += sizeof(ngx_resolver_hdr_t ) + nlen;
#line 3648
  qs = (ngx_resolver_qs_t *)p;
#line 3651
  qs->type_hi = (u_char )0;
#line 3651
  qs->type_lo = (u_char )1;
#line 3654
  qs->class_hi = (u_char )0;
#line 3654
  qs->class_lo = (u_char )1;
#line 3658
  len = (size_t )0;
#line 3659
  p --;
#line 3660
  tmp___2 = p;
#line 3660
  p --;
#line 3660
  *tmp___2 = (u_char )'\000';
  }
#line 3662
  if (name->len == 0UL) {
#line 3663
    return ((ngx_int_t )-5);
  }
#line 3666
  s = (name->data + name->len) - 1;
  {
#line 3666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3666
    if (! ((unsigned long )s >= (unsigned long )name->data)) {
#line 3666
      goto while_break;
    }
#line 3667
    if ((int )*s != 46) {
#line 3668
      *p = *s;
#line 3669
      len ++;
    } else {
#line 3672
      if (len == 0UL) {
#line 3673
        return ((ngx_int_t )-5);
      } else
#line 3672
      if (len > 255UL) {
#line 3673
        return ((ngx_int_t )-5);
      }
#line 3676
      *p = (u_char )len;
#line 3677
      len = (size_t )0;
    }
#line 3680
    p --;
#line 3666
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3683
  if (len == 0UL) {
#line 3684
    return ((ngx_int_t )-5);
  } else
#line 3683
  if (len > 255UL) {
#line 3684
    return ((ngx_int_t )-5);
  }
#line 3687
  *p = (u_char )len;
#line 3690
  if (! r->ipv6) {
#line 3691
    return ((ngx_int_t )0);
  }
  {
#line 3694
  p = rn->query6;
#line 3696
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)rn->query, (size_t )rn->qlen);
#line 3698
  query = (ngx_resolver_hdr_t *)p;
#line 3700
  tmp___3 = random();
#line 3700
  ident = (ngx_uint_t )tmp___3;
#line 3705
  query->ident_hi = (u_char )((ident >> 8) & 255UL);
#line 3706
  query->ident_lo = (u_char )(ident & 255UL);
#line 3708
  p += sizeof(ngx_resolver_hdr_t ) + nlen;
#line 3710
  qs = (ngx_resolver_qs_t *)p;
#line 3712
  qs->type_lo = (u_char )28;
  }
#line 3715
  return ((ngx_int_t )0);
}
}
#line 3719 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_create_srv_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                               ngx_str_t *name ) 
{ 
  u_char *p ;
  u_char *s ;
  size_t len ;
  size_t nlen ;
  ngx_uint_t ident ;
  ngx_resolver_qs_t *qs ;
  ngx_resolver_hdr_t *query ;
  void *tmp ;
  long tmp___0 ;
  u_char *tmp___1 ;

  {
#line 3729
  if (name->len) {
#line 3729
    nlen = (1UL + name->len) + 1UL;
  } else {
#line 3729
    nlen = (size_t )1;
  }
  {
#line 3731
  len = (sizeof(ngx_resolver_hdr_t ) + nlen) + sizeof(ngx_resolver_qs_t );
#line 3733
  tmp = ngx_resolver_alloc(r, len);
#line 3733
  p = (u_char *)tmp;
  }
#line 3734
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3735
    return ((ngx_int_t )-1);
  }
  {
#line 3738
  rn->qlen = (u_short )len;
#line 3739
  rn->query = p;
#line 3741
  query = (ngx_resolver_hdr_t *)p;
#line 3743
  tmp___0 = random();
#line 3743
  ident = (ngx_uint_t )tmp___0;
#line 3748
  query->ident_hi = (u_char )((ident >> 8) & 255UL);
#line 3749
  query->ident_lo = (u_char )(ident & 255UL);
#line 3752
  query->flags_hi = (u_char )1;
#line 3752
  query->flags_lo = (u_char )0;
#line 3755
  query->nqs_hi = (u_char )0;
#line 3755
  query->nqs_lo = (u_char )1;
#line 3756
  query->nan_hi = (u_char )0;
#line 3756
  query->nan_lo = (u_char )0;
#line 3757
  query->nns_hi = (u_char )0;
#line 3757
  query->nns_lo = (u_char )0;
#line 3758
  query->nar_hi = (u_char )0;
#line 3758
  query->nar_lo = (u_char )0;
#line 3760
  p += sizeof(ngx_resolver_hdr_t ) + nlen;
#line 3762
  qs = (ngx_resolver_qs_t *)p;
#line 3765
  qs->type_hi = (u_char )0;
#line 3765
  qs->type_lo = (u_char )33;
#line 3768
  qs->class_hi = (u_char )0;
#line 3768
  qs->class_lo = (u_char )1;
#line 3772
  len = (size_t )0;
#line 3773
  p --;
#line 3774
  tmp___1 = p;
#line 3774
  p --;
#line 3774
  *tmp___1 = (u_char )'\000';
  }
#line 3776
  if (name->len == 0UL) {
#line 3777
    return ((ngx_int_t )-5);
  }
#line 3780
  s = (name->data + name->len) - 1;
  {
#line 3780
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3780
    if (! ((unsigned long )s >= (unsigned long )name->data)) {
#line 3780
      goto while_break;
    }
#line 3781
    if ((int )*s != 46) {
#line 3782
      *p = *s;
#line 3783
      len ++;
    } else {
#line 3786
      if (len == 0UL) {
#line 3787
        return ((ngx_int_t )-5);
      } else
#line 3786
      if (len > 255UL) {
#line 3787
        return ((ngx_int_t )-5);
      }
#line 3790
      *p = (u_char )len;
#line 3791
      len = (size_t )0;
    }
#line 3794
    p --;
#line 3780
    s --;
  }
  while_break: /* CIL Label */ ;
  }
#line 3797
  if (len == 0UL) {
#line 3798
    return ((ngx_int_t )-5);
  } else
#line 3797
  if (len > 255UL) {
#line 3798
    return ((ngx_int_t )-5);
  }
#line 3801
  *p = (u_char )len;
#line 3803
  return ((ngx_int_t )0);
}
}
#line 3807 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_create_addr_query(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_resolver_addr_t *addr ) 
{ 
  u_char *p ;
  u_char *d ;
  size_t len ;
  in_addr_t inaddr ;
  ngx_int_t n ;
  ngx_uint_t ident ;
  ngx_resolver_hdr_t *query ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  void *tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
  {
#line 3825
  if ((int )(addr->sockaddr)->sa_family == 10) {
#line 3825
    goto case_10;
  }
#line 3833
  goto switch_default;
  case_10: /* CIL Label */ 
#line 3826
  len = (((sizeof(ngx_resolver_hdr_t ) + 64UL) + sizeof(".ip6.arpa.")) - 1UL) + sizeof(ngx_resolver_qs_t );
#line 3830
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 3834
  len = ((sizeof(ngx_resolver_hdr_t ) + sizeof(".255.255.255.255.in-addr.arpa.")) - 1UL) + sizeof(ngx_resolver_qs_t );
  switch_break: /* CIL Label */ ;
  }
  {
#line 3839
  tmp = ngx_resolver_alloc(r, len);
#line 3839
  p = (u_char *)tmp;
  }
#line 3840
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3841
    return ((ngx_int_t )-1);
  }
  {
#line 3844
  rn->query = p;
#line 3845
  query = (ngx_resolver_hdr_t *)p;
#line 3847
  tmp___0 = random();
#line 3847
  ident = (ngx_uint_t )tmp___0;
#line 3849
  query->ident_hi = (u_char )((ident >> 8) & 255UL);
#line 3850
  query->ident_lo = (u_char )(ident & 255UL);
#line 3853
  query->flags_hi = (u_char )1;
#line 3853
  query->flags_lo = (u_char )0;
#line 3856
  query->nqs_hi = (u_char )0;
#line 3856
  query->nqs_lo = (u_char )1;
#line 3857
  query->nan_hi = (u_char )0;
#line 3857
  query->nan_lo = (u_char )0;
#line 3858
  query->nns_hi = (u_char )0;
#line 3858
  query->nns_lo = (u_char )0;
#line 3859
  query->nar_hi = (u_char )0;
#line 3859
  query->nar_lo = (u_char )0;
#line 3861
  p += sizeof(ngx_resolver_hdr_t );
  }
  {
#line 3866
  if ((int )(addr->sockaddr)->sa_family == 10) {
#line 3866
    goto case_10___0;
  }
#line 3880
  goto switch_default___0;
  case_10___0: /* CIL Label */ 
#line 3867
  sin6 = (struct sockaddr_in6 *)addr->sockaddr;
#line 3869
  n = (ngx_int_t )15;
  {
#line 3869
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3869
    if (! (n >= 0L)) {
#line 3869
      goto while_break;
    }
    {
#line 3870
    p = ngx_sprintf(p, "\001%xd\001%xd", (int )sin6->sin6_addr.__in6_u.__u6_addr8[n] & 15,
                    ((int )sin6->sin6_addr.__in6_u.__u6_addr8[n] >> 4) & 15);
#line 3869
    n --;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3875
  tmp___1 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"\003ip6\004arpa\000",
                   (size_t )10);
#line 3875
  p = (u_char *)tmp___1 + 10;
  }
#line 3877
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 3882
  sin = (struct sockaddr_in *)addr->sockaddr;
#line 3883
  inaddr = ntohl(sin->sin_addr.s_addr);
#line 3885
  n = (ngx_int_t )0;
  }
  {
#line 3885
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3885
    if (! (n < 32L)) {
#line 3885
      goto while_break___0;
    }
    {
#line 3886
    d = ngx_sprintf(p + 1, "%ud", (inaddr >> n) & 255U);
#line 3887
    *p = (u_char )(d - (p + 1));
#line 3888
    p = d;
#line 3885
    n += 8L;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 3891
  tmp___2 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"\ain-addr\004arpa\000",
                   (size_t )14);
#line 3891
  p = (u_char *)tmp___2 + 14;
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 3895
  tmp___3 = memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)"\000\f\000\001",
                   (size_t )4);
#line 3895
  p = (u_char *)tmp___3 + 4;
#line 3897
  rn->qlen = (u_short )(p - rn->query);
  }
#line 3899
  return ((ngx_int_t )0);
}
}
#line 3903 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_copy(ngx_resolver_t *r , ngx_str_t *name , u_char *buf ,
                                   u_char *src , u_char *last ) 
{ 
  char *err ;
  u_char *p ;
  u_char *dst ;
  ssize_t len ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  u_char *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 3912
  p = src;
#line 3913
  len = (ssize_t )-1;
#line 3920
  i = (ngx_uint_t )0;
  {
#line 3920
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3920
    if (! (i < 128UL)) {
#line 3920
      goto while_break;
    }
#line 3921
    tmp = p;
#line 3921
    p ++;
#line 3921
    n = (ngx_uint_t )*tmp;
#line 3923
    if (n == 0UL) {
#line 3924
      goto done;
    }
#line 3927
    if (n & 192UL) {
#line 3928
      n = ((n & 63UL) << 8) + (unsigned long )*p;
#line 3929
      p = buf + n;
    } else {
#line 3932
      len = (ssize_t )((ngx_uint_t )len + (1UL + n));
#line 3933
      p += n;
    }
#line 3936
    if ((unsigned long )p >= (unsigned long )last) {
#line 3937
      err = (char *)"name is out of response";
#line 3938
      goto invalid;
    }
#line 3920
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3942
  err = (char *)"compression pointers loop";
  invalid: 
#line 3946
  if ((r->log)->log_level >= r->log_level) {
    {
#line 3946
    ngx_log_error_core(r->log_level, r->log, 0, (char const   *)err);
    }
  }
#line 3948
  return ((ngx_int_t )-1);
  done: 
#line 3952
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 3953
    return ((ngx_int_t )0);
  }
#line 3956
  if (len == -1L) {
#line 3957
    name->len = (size_t )0;
#line 3957
    name->data = (u_char *)((void *)0);
#line 3958
    return ((ngx_int_t )0);
  }
  {
#line 3961
  tmp___0 = ngx_resolver_alloc(r, (size_t )len);
#line 3961
  dst = (u_char *)tmp___0;
  }
#line 3962
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 3963
    return ((ngx_int_t )-1);
  }
#line 3966
  name->data = dst;
#line 3968
  tmp___1 = src;
#line 3968
  src ++;
#line 3968
  n = (ngx_uint_t )*tmp___1;
  {
#line 3970
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3971
    if (n & 192UL) {
#line 3972
      n = ((n & 63UL) << 8) + (unsigned long )*src;
#line 3973
      src = buf + n;
#line 3975
      tmp___2 = src;
#line 3975
      src ++;
#line 3975
      n = (ngx_uint_t )*tmp___2;
    } else {
      {
#line 3978
      ngx_strlow(dst, src, n);
#line 3979
      dst += n;
#line 3980
      src += n;
#line 3982
      tmp___3 = src;
#line 3982
      src ++;
#line 3982
      n = (ngx_uint_t )*tmp___3;
      }
#line 3984
      if (n != 0UL) {
#line 3985
        tmp___4 = dst;
#line 3985
        dst ++;
#line 3985
        *tmp___4 = (u_char )'.';
      }
    }
#line 3989
    if (n == 0UL) {
#line 3990
      name->len = (size_t )(dst - name->data);
#line 3991
      return ((ngx_int_t )0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 3997 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_set_timeout(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ) 
{ 
  void *tmp ;

  {
#line 4000
  if (ctx->event) {
#line 4001
    return ((ngx_int_t )0);
  } else
#line 4000
  if (ctx->timeout == 0UL) {
#line 4001
    return ((ngx_int_t )0);
  }
  {
#line 4004
  tmp = ngx_resolver_calloc(r, sizeof(ngx_event_t ));
#line 4004
  ctx->event = (ngx_event_t *)tmp;
  }
#line 4005
  if ((unsigned long )ctx->event == (unsigned long )((void *)0)) {
#line 4006
    return ((ngx_int_t )-1);
  }
  {
#line 4009
  (ctx->event)->handler = & ngx_resolver_timeout_handler;
#line 4010
  (ctx->event)->data = (void *)ctx;
#line 4011
  (ctx->event)->log = r->log;
#line 4012
  (ctx->event)->cancelable = ctx->cancelable;
#line 4013
  ctx->ident = (ngx_int_t )-1;
#line 4015
  ngx_event_add_timer(ctx->event, ctx->timeout);
  }
#line 4017
  return ((ngx_int_t )0);
}
}
#line 4021 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_timeout_handler(ngx_event_t *ev ) 
{ 
  ngx_resolver_ctx_t *ctx ;

  {
  {
#line 4026
  ctx = (ngx_resolver_ctx_t *)ev->data;
#line 4028
  ctx->state = (ngx_int_t )110;
#line 4030
  (*(ctx->handler))(ctx);
  }
#line 4031
  return;
}
}
#line 4034 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_free_node(ngx_resolver_t *r , ngx_resolver_node_t *rn ) 
{ 
  ngx_uint_t i ;

  {
#line 4041
  if (rn->query) {
    {
#line 4042
    ngx_resolver_free_locked(r, (void *)rn->query);
    }
  }
#line 4045
  if (rn->name) {
    {
#line 4046
    ngx_resolver_free_locked(r, (void *)rn->name);
    }
  }
#line 4049
  if (rn->cnlen) {
    {
#line 4050
    ngx_resolver_free_locked(r, (void *)rn->u.cname);
    }
  }
#line 4053
  if ((int )rn->naddrs > 1) {
#line 4053
    if ((int )rn->naddrs != 65535) {
      {
#line 4054
      ngx_resolver_free_locked(r, (void *)rn->u.addrs);
      }
    }
  }
#line 4058
  if ((int )rn->naddrs6 > 1) {
#line 4058
    if ((int )rn->naddrs6 != 65535) {
      {
#line 4059
      ngx_resolver_free_locked(r, (void *)rn->u6.addrs6);
      }
    }
  }
#line 4063
  if (rn->nsrvs) {
#line 4064
    i = (ngx_uint_t )0;
    {
#line 4064
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4064
      if (! (i < (ngx_uint_t )rn->nsrvs)) {
#line 4064
        goto while_break;
      }
#line 4065
      if ((rn->u.srvs + i)->name.data) {
        {
#line 4066
        ngx_resolver_free_locked(r, (void *)(rn->u.srvs + i)->name.data);
        }
      }
#line 4064
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 4070
    ngx_resolver_free_locked(r, (void *)rn->u.srvs);
    }
  }
  {
#line 4073
  ngx_resolver_free_locked(r, (void *)rn);
  }
#line 4076
  return;
}
}
#line 4079 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void *ngx_resolver_alloc(ngx_resolver_t *r , size_t size ) 
{ 
  u_char *p ;
  void *tmp ;

  {
  {
#line 4086
  tmp = ngx_alloc(size, r->log);
#line 4086
  p = (u_char *)tmp;
  }
#line 4090
  return ((void *)p);
}
}
#line 4094 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void *ngx_resolver_calloc(ngx_resolver_t *r , size_t size ) 
{ 
  u_char *p ;
  void *tmp ;

  {
  {
#line 4099
  tmp = ngx_resolver_alloc(r, size);
#line 4099
  p = (u_char *)tmp;
  }
#line 4101
  if (p) {
    {
#line 4102
    memset((void *)p, 0, size);
    }
  }
#line 4105
  return ((void *)p);
}
}
#line 4109 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_free(ngx_resolver_t *r , void *p ) 
{ 


  {
  {
#line 4114
  free(p);
  }
#line 4117
  return;
}
}
#line 4120 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_free_locked(ngx_resolver_t *r , void *p ) 
{ 


  {
  {
#line 4123
  free(p);
  }
#line 4124
  return;
}
}
#line 4127 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void *ngx_resolver_dup(ngx_resolver_t *r , void *src , size_t size ) 
{ 
  void *dst ;

  {
  {
#line 4132
  dst = ngx_resolver_alloc(r, size);
  }
#line 4134
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 4135
    return (dst);
  }
  {
#line 4138
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src, size);
  }
#line 4140
  return (dst);
}
}
#line 4144 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_resolver_addr_t *ngx_resolver_export(ngx_resolver_t *r , ngx_resolver_node_t *rn ,
                                                ngx_uint_t rotate ) 
{ 
  ngx_uint_t d ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t n ;
  in_addr_t *addr ;
  ngx_sockaddr_t *sockaddr ;
  struct sockaddr_in *sin ;
  ngx_resolver_addr_t *dst ;
  struct in6_addr *addr6 ;
  struct sockaddr_in6 *sin6 ;
  void *tmp ;
  void *tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  ngx_uint_t tmp___3 ;
  ngx_uint_t tmp___4 ;
  long tmp___5 ;
  ngx_uint_t tmp___6 ;
  ngx_uint_t tmp___7 ;

  {
  {
#line 4158
  n = (ngx_uint_t )rn->naddrs;
#line 4160
  n += (ngx_uint_t )rn->naddrs6;
#line 4163
  tmp = ngx_resolver_calloc(r, n * sizeof(ngx_resolver_addr_t ));
#line 4163
  dst = (ngx_resolver_addr_t *)tmp;
  }
#line 4164
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 4165
    return ((ngx_resolver_addr_t *)((void *)0));
  }
  {
#line 4168
  tmp___0 = ngx_resolver_calloc(r, n * sizeof(ngx_sockaddr_t ));
#line 4168
  sockaddr = (ngx_sockaddr_t *)tmp___0;
  }
#line 4169
  if ((unsigned long )sockaddr == (unsigned long )((void *)0)) {
    {
#line 4170
    ngx_resolver_free(r, (void *)dst);
    }
#line 4171
    return ((ngx_resolver_addr_t *)((void *)0));
  }
#line 4174
  i = (ngx_uint_t )0;
#line 4175
  if (rotate) {
    {
#line 4175
    tmp___1 = random();
#line 4175
    d = (unsigned long )tmp___1 % n;
    }
  } else {
#line 4175
    d = (ngx_uint_t )0;
  }
#line 4177
  if (rn->naddrs) {
#line 4178
    if (rotate) {
      {
#line 4178
      tmp___2 = random();
#line 4178
      j = (ngx_uint_t )(tmp___2 % (long )rn->naddrs);
      }
    } else {
#line 4178
      j = (ngx_uint_t )0;
    }
#line 4180
    if ((int )rn->naddrs == 1) {
#line 4180
      addr = & rn->u.addr;
    } else {
#line 4180
      addr = rn->u.addrs;
    }
    {
#line 4182
    while (1) {
      while_continue: /* CIL Label */ ;
#line 4183
      sin = & (sockaddr + d)->sockaddr_in;
#line 4184
      sin->sin_family = (sa_family_t )2;
#line 4185
      tmp___3 = j;
#line 4185
      j ++;
#line 4185
      sin->sin_addr.s_addr = *(addr + tmp___3);
#line 4186
      (dst + d)->sockaddr = (struct sockaddr *)sin;
#line 4187
      tmp___4 = d;
#line 4187
      d ++;
#line 4187
      (dst + tmp___4)->socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 4189
      if (d == n) {
#line 4190
        d = (ngx_uint_t )0;
      }
#line 4193
      if (j == (ngx_uint_t )rn->naddrs) {
#line 4194
        j = (ngx_uint_t )0;
      }
#line 4182
      i ++;
#line 4182
      if (! (i < (ngx_uint_t )rn->naddrs)) {
#line 4182
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 4200
  if (rn->naddrs6) {
#line 4201
    if (rotate) {
      {
#line 4201
      tmp___5 = random();
#line 4201
      j = (ngx_uint_t )(tmp___5 % (long )rn->naddrs6);
      }
    } else {
#line 4201
      j = (ngx_uint_t )0;
    }
#line 4203
    if ((int )rn->naddrs6 == 1) {
#line 4203
      addr6 = & rn->u6.addr6;
    } else {
#line 4203
      addr6 = rn->u6.addrs6;
    }
    {
#line 4205
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 4206
      sin6 = & (sockaddr + d)->sockaddr_in6;
#line 4207
      sin6->sin6_family = (sa_family_t )10;
#line 4208
      tmp___6 = j;
#line 4208
      j ++;
#line 4208
      memcpy((void */* __restrict  */)(sin6->sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)((addr6 + tmp___6)->__in6_u.__u6_addr8),
             (size_t )16);
#line 4209
      (dst + d)->sockaddr = (struct sockaddr *)sin6;
#line 4210
      tmp___7 = d;
#line 4210
      d ++;
#line 4210
      (dst + tmp___7)->socklen = (socklen_t )sizeof(struct sockaddr_in6 );
      }
#line 4212
      if (d == n) {
#line 4213
        d = (ngx_uint_t )0;
      }
#line 4216
      if (j == (ngx_uint_t )rn->naddrs6) {
#line 4217
        j = (ngx_uint_t )0;
      }
#line 4205
      i ++;
#line 4205
      if (! (i < n)) {
#line 4205
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 4223
  return (dst);
}
}
#line 4227 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static void ngx_resolver_report_srv(ngx_resolver_t *r , ngx_resolver_ctx_t *ctx ) 
{ 
  ngx_uint_t naddrs ;
  ngx_uint_t nsrvs ;
  ngx_uint_t nw ;
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_uint_t k ;
  ngx_uint_t l ;
  ngx_uint_t m ;
  ngx_uint_t n ;
  ngx_uint_t w ;
  ngx_resolver_addr_t *addrs ;
  ngx_resolver_srv_name_t *srvs ;
  time_t tmp ;
  time_t tmp___0 ;
  void *tmp___1 ;
  time_t tmp___2 ;
  long tmp___3 ;

  {
#line 4234
  srvs = ctx->srvs;
#line 4235
  nsrvs = ctx->nsrvs;
#line 4237
  naddrs = (ngx_uint_t )0;
#line 4239
  i = (ngx_uint_t )0;
  {
#line 4239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4239
    if (! (i < nsrvs)) {
#line 4239
      goto while_break;
    }
#line 4240
    if ((srvs + i)->state == -1L) {
#line 4241
      ctx->state = (ngx_int_t )-1;
#line 4242
      if (r->valid) {
#line 4242
        tmp = r->valid;
      } else {
#line 4242
        tmp = (time_t )10;
      }
      {
#line 4242
      ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp);
#line 4244
      (*(ctx->handler))(ctx);
      }
#line 4245
      return;
    }
#line 4248
    naddrs += (srvs + i)->naddrs;
#line 4239
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4251
  if (naddrs == 0UL) {
#line 4252
    ctx->state = (ngx_int_t )3;
#line 4253
    if (r->valid) {
#line 4253
      tmp___0 = r->valid;
    } else {
#line 4253
      tmp___0 = (time_t )10;
    }
    {
#line 4253
    ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___0);
#line 4255
    (*(ctx->handler))(ctx);
    }
#line 4256
    return;
  }
  {
#line 4259
  tmp___1 = ngx_resolver_calloc(r, naddrs * sizeof(ngx_resolver_addr_t ));
#line 4259
  addrs = (ngx_resolver_addr_t *)tmp___1;
  }
#line 4260
  if ((unsigned long )addrs == (unsigned long )((void *)0)) {
#line 4261
    ctx->state = (ngx_int_t )-1;
#line 4262
    if (r->valid) {
#line 4262
      tmp___2 = r->valid;
    } else {
#line 4262
      tmp___2 = (time_t )10;
    }
    {
#line 4262
    ctx->valid = (time_t )(ngx_cached_time->sec + (time_t volatile   )tmp___2);
#line 4264
    (*(ctx->handler))(ctx);
    }
#line 4265
    return;
  }
#line 4268
  i = (ngx_uint_t )0;
#line 4269
  n = (ngx_uint_t )0;
  {
#line 4271
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 4272
    nw = (ngx_uint_t )0;
#line 4274
    j = i;
    {
#line 4274
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 4274
      if (! (j < nsrvs)) {
#line 4274
        goto while_break___1;
      }
#line 4275
      if ((int )(srvs + j)->priority != (int )(srvs + i)->priority) {
#line 4276
        goto while_break___1;
      }
#line 4279
      nw += (srvs + j)->naddrs * (ngx_uint_t )(srvs + j)->weight;
#line 4274
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 4282
    if (nw == 0UL) {
#line 4283
      goto next_srv;
    }
    {
#line 4286
    tmp___3 = random();
#line 4286
    w = (unsigned long )tmp___3 % nw;
#line 4288
    k = i;
    }
    {
#line 4288
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 4288
      if (! (k < j)) {
#line 4288
        goto while_break___2;
      }
#line 4289
      if (w < (srvs + k)->naddrs * (ngx_uint_t )(srvs + k)->weight) {
#line 4290
        goto while_break___2;
      }
#line 4293
      w -= (srvs + k)->naddrs * (ngx_uint_t )(srvs + k)->weight;
#line 4288
      k ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 4296
    l = i;
    {
#line 4296
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 4296
      if (! (l < j)) {
#line 4296
        goto while_break___3;
      }
#line 4298
      m = (ngx_uint_t )0;
      {
#line 4298
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 4298
        if (! (m < (srvs + k)->naddrs)) {
#line 4298
          goto while_break___4;
        }
#line 4299
        (addrs + n)->socklen = ((srvs + k)->addrs + m)->socklen;
#line 4300
        (addrs + n)->sockaddr = ((srvs + k)->addrs + m)->sockaddr;
#line 4301
        (addrs + n)->name = (srvs + k)->name;
#line 4302
        (addrs + n)->priority = (srvs + k)->priority;
#line 4303
        (addrs + n)->weight = (srvs + k)->weight;
#line 4304
        n ++;
#line 4298
        m ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 4307
      k ++;
#line 4307
      if (k == j) {
#line 4308
        k = i;
      }
#line 4296
      l ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    next_srv: 
#line 4314
    i = j;
#line 4271
    if (! (i < ctx->nsrvs)) {
#line 4271
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 4318
  ctx->state = (ngx_int_t )0;
#line 4319
  ctx->addrs = addrs;
#line 4320
  ctx->naddrs = naddrs;
#line 4322
  (*(ctx->handler))(ctx);
#line 4324
  ngx_resolver_free(r, (void *)addrs);
  }
#line 4325
  return;
}
}
#line 4331 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static char *errors[5]  = {      (char *)"Format error",      (char *)"Server failure",      (char *)"Host not found",      (char *)"Unimplemented", 
        (char *)"Operation refused"};
#line 4328 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
char *ngx_resolver_strerror(ngx_int_t err ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 4339
  if (err > 0L) {
#line 4339
    if (err < 6L) {
#line 4340
      return (errors[err - 1L]);
    }
  }
#line 4343
  if (err == 110L) {
#line 4344
    return ((char *)"Operation timed out");
  }
#line 4347
  return ((char *)"Unknown error");
}
}
#line 4351 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static u_char *ngx_resolver_log_error(ngx_log_t *log , u_char *buf , size_t len ) 
{ 
  u_char *p ;
  ngx_resolver_connection_t *rec ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 4357
  p = buf;
#line 4359
  if (log->action) {
    {
#line 4360
    p = ngx_snprintf(buf, len, " while %s", log->action);
#line 4361
    len -= (size_t )(p - buf);
    }
  }
#line 4364
  rec = (ngx_resolver_connection_t *)log->data;
#line 4366
  if (rec) {
    {
#line 4367
    p = ngx_snprintf(p, len, ", resolver: %V", & rec->server);
    }
  }
#line 4370
  return (p);
}
}
#line 4374 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_udp_connect(ngx_resolver_connection_t *rec ) 
{ 
  int rc ;
  ngx_int_t event ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_socket_t s ;
  ngx_connection_t *c ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  ngx_atomic_t tmp___4 ;
  int *tmp___5 ;
  ngx_int_t tmp___6 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 4383
  s = socket((int )(rec->sockaddr)->sa_family, 2, 0);
  }
#line 4387
  if (s == -1) {
#line 4388
    if (rec->log.log_level >= 2UL) {
      {
#line 4388
      tmp = __errno_location();
#line 4388
      ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp, "socket() failed");
      }
    }
#line 4390
    return ((ngx_int_t )-1);
  }
  {
#line 4393
  c = ngx_get_connection(s, & rec->log);
  }
#line 4395
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 4396
    tmp___1 = close(s);
    }
#line 4396
    if (tmp___1 == -1) {
#line 4397
      if (rec->log.log_level >= 2UL) {
        {
#line 4397
        tmp___0 = __errno_location();
#line 4397
        ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___0, "close() socketfailed");
        }
      }
    }
#line 4401
    return ((ngx_int_t )-1);
  }
  {
#line 4404
  tmp___3 = ngx_nonblocking(s);
  }
#line 4404
  if (tmp___3 == -1) {
#line 4405
    if (rec->log.log_level >= 2UL) {
      {
#line 4405
      tmp___2 = __errno_location();
#line 4405
      ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___2, "ioctl(FIONBIO) failed");
      }
    }
#line 4408
    goto failed;
  }
  {
#line 4411
  rev = c->read;
#line 4412
  wev = c->write;
#line 4414
  rev->log = & rec->log;
#line 4415
  wev->log = & rec->log;
#line 4417
  rec->udp = c;
#line 4419
  tmp___4 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, (ngx_atomic_t )1);
#line 4419
  c->number = (ngx_atomic_uint_t )tmp___4;
#line 4424
  rc = connect(s, (struct sockaddr  const  */* __restrict  */)rec->sockaddr, rec->socklen);
  }
#line 4428
  if (rc == -1) {
#line 4429
    if (rec->log.log_level >= 3UL) {
      {
#line 4429
      tmp___5 = __errno_location();
#line 4429
      ngx_log_error_core((ngx_uint_t )3, & rec->log, *tmp___5, "connect() failed");
      }
    }
#line 4432
    goto failed;
  }
#line 4436
  wev->ready = 1U;
#line 4438
  if (ngx_event_flags & 4UL) {
#line 4438
    event = (ngx_int_t )2147483648U;
  } else {
#line 4438
    event = (ngx_int_t )0;
  }
  {
#line 4443
  tmp___6 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )event);
  }
#line 4443
  if (tmp___6 != 0L) {
#line 4444
    goto failed;
  }
#line 4447
  return ((ngx_int_t )0);
  failed: 
  {
#line 4451
  ngx_close_connection(c);
#line 4452
  rec->udp = (ngx_connection_t *)((void *)0);
  }
#line 4454
  return ((ngx_int_t )-1);
}
}
#line 4458 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_tcp_connect(ngx_resolver_connection_t *rec ) 
{ 
  int rc ;
  ngx_int_t event ;
  ngx_err_t err ;
  ngx_uint_t level ;
  ngx_socket_t s ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  ngx_atomic_t tmp___4 ;
  ngx_int_t tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  ngx_int_t tmp___9 ;
  ngx_int_t tmp___10 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
  {
#line 4469
  s = socket((int )(rec->sockaddr)->sa_family, 1, 0);
  }
#line 4473
  if (s == -1) {
#line 4474
    if (rec->log.log_level >= 2UL) {
      {
#line 4474
      tmp = __errno_location();
#line 4474
      ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp, "socket() failed");
      }
    }
#line 4476
    return ((ngx_int_t )-1);
  }
  {
#line 4479
  c = ngx_get_connection(s, & rec->log);
  }
#line 4481
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 4482
    tmp___1 = close(s);
    }
#line 4482
    if (tmp___1 == -1) {
#line 4483
      if (rec->log.log_level >= 2UL) {
        {
#line 4483
        tmp___0 = __errno_location();
#line 4483
        ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___0, "close() socketfailed");
        }
      }
    }
#line 4487
    return ((ngx_int_t )-1);
  }
  {
#line 4490
  tmp___3 = ngx_nonblocking(s);
  }
#line 4490
  if (tmp___3 == -1) {
#line 4491
    if (rec->log.log_level >= 2UL) {
      {
#line 4491
      tmp___2 = __errno_location();
#line 4491
      ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___2, "ioctl(FIONBIO) failed");
      }
    }
#line 4494
    goto failed;
  }
  {
#line 4497
  rev = c->read;
#line 4498
  wev = c->write;
#line 4500
  rev->log = & rec->log;
#line 4501
  wev->log = & rec->log;
#line 4503
  rec->tcp = c;
#line 4505
  tmp___4 = (ngx_atomic_t )__sync_fetch_and_add(ngx_connection_counter, (ngx_atomic_t )1);
#line 4505
  c->number = (ngx_atomic_uint_t )tmp___4;
  }
#line 4507
  if (ngx_event_actions.add_conn) {
    {
#line 4508
    tmp___5 = (*(ngx_event_actions.add_conn))(c);
    }
#line 4508
    if (tmp___5 == -1L) {
#line 4509
      goto failed;
    }
  }
  {
#line 4516
  rc = connect(s, (struct sockaddr  const  */* __restrict  */)rec->sockaddr, rec->socklen);
  }
#line 4518
  if (rc == -1) {
    {
#line 4519
    tmp___6 = __errno_location();
#line 4519
    err = *tmp___6;
    }
#line 4522
    if (err != 115) {
#line 4529
      if (err == 111) {
#line 4543
        level = (ngx_uint_t )4;
      } else
#line 4529
      if (err == 11) {
#line 4543
        level = (ngx_uint_t )4;
      } else
#line 4529
      if (err == 104) {
#line 4543
        level = (ngx_uint_t )4;
      } else
#line 4529
      if (err == 100) {
#line 4543
        level = (ngx_uint_t )4;
      } else
#line 4529
      if (err == 101) {
#line 4543
        level = (ngx_uint_t )4;
      } else
#line 4529
      if (err == 112) {
#line 4543
        level = (ngx_uint_t )4;
      } else
#line 4529
      if (err == 113) {
#line 4543
        level = (ngx_uint_t )4;
      } else {
#line 4546
        level = (ngx_uint_t )3;
      }
#line 4549
      if ((c->log)->log_level >= level) {
        {
#line 4549
        ngx_log_error_core(level, c->log, err, "connect() to %V failed", & rec->server);
        }
      }
      {
#line 4552
      ngx_close_connection(c);
#line 4553
      rec->tcp = (ngx_connection_t *)((void *)0);
      }
#line 4555
      return ((ngx_int_t )-1);
    }
  }
#line 4559
  if (ngx_event_actions.add_conn) {
#line 4560
    if (rc == -1) {
#line 4564
      return ((ngx_int_t )-2);
    }
#line 4569
    wev->ready = 1U;
#line 4571
    return ((ngx_int_t )0);
  }
#line 4574
  if (ngx_event_flags & 512UL) {
    {
#line 4579
    tmp___8 = ngx_blocking(s);
    }
#line 4579
    if (tmp___8 == -1) {
#line 4580
      if (rec->log.log_level >= 2UL) {
        {
#line 4580
        tmp___7 = __errno_location();
#line 4580
        ngx_log_error_core((ngx_uint_t )2, & rec->log, *tmp___7, "ioctl(!FIONBIO) failed");
        }
      }
#line 4582
      goto failed;
    }
#line 4592
    rev->ready = 1U;
#line 4593
    wev->ready = 1U;
#line 4595
    return ((ngx_int_t )0);
  }
#line 4598
  if (ngx_event_flags & 4UL) {
#line 4602
    event = (ngx_int_t )2147483648U;
  } else {
#line 4608
    event = (ngx_int_t )0;
  }
  {
#line 4611
  tmp___9 = (*(ngx_event_actions.add))(rev, (ngx_int_t )8193, (ngx_uint_t )event);
  }
#line 4611
  if (tmp___9 != 0L) {
#line 4612
    goto failed;
  }
#line 4615
  if (rc == -1) {
    {
#line 4619
    tmp___10 = (*(ngx_event_actions.add))(wev, (ngx_int_t )4, (ngx_uint_t )event);
    }
#line 4619
    if (tmp___10 != 0L) {
#line 4620
      goto failed;
    }
#line 4623
    return ((ngx_int_t )-2);
  }
#line 4628
  wev->ready = 1U;
#line 4630
  return ((ngx_int_t )0);
  failed: 
  {
#line 4634
  ngx_close_connection(c);
#line 4635
  rec->tcp = (ngx_connection_t *)((void *)0);
  }
#line 4637
  return ((ngx_int_t )-1);
}
}
#line 4641 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_resolver.c"
static ngx_int_t ngx_resolver_cmp_srvs(void const   *one , void const   *two ) 
{ 
  ngx_int_t p1 ;
  ngx_int_t p2 ;
  ngx_resolver_srv_t *first ;
  ngx_resolver_srv_t *second ;

  {
#line 4647
  first = (ngx_resolver_srv_t *)one;
#line 4648
  second = (ngx_resolver_srv_t *)two;
#line 4650
  p1 = (ngx_int_t )first->priority;
#line 4651
  p2 = (ngx_int_t )second->priority;
#line 4653
  return (p1 - p2);
}
}
#line 267 "src/core/ngx_module.h"
ngx_int_t ngx_preinit_modules(void) ;
#line 268
ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle ) ;
#line 269
ngx_int_t ngx_init_modules(ngx_cycle_t *cycle ) ;
#line 273
ngx_int_t ngx_add_module(ngx_conf_t *cf , ngx_str_t *file , ngx_module_t *module ,
                         char **order ) ;
#line 278 "src/core/ngx_module.h"
ngx_uint_t ngx_max_module  ;
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
static ngx_uint_t ngx_module_index(ngx_cycle_t *cycle ) ;
#line 17
static ngx_uint_t ngx_module_ctx_index(ngx_cycle_t *cycle , ngx_uint_t type , ngx_uint_t index___0 ) ;
#line 22 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
static ngx_uint_t ngx_modules_n  ;
#line 25 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
ngx_int_t ngx_preinit_modules(void) 
{ 
  ngx_uint_t i ;

  {
#line 30
  i = (ngx_uint_t )0;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! ngx_modules[i]) {
#line 30
      goto while_break;
    }
#line 31
    (ngx_modules[i])->index = i;
#line 32
    (ngx_modules[i])->name = ngx_module_names[i];
#line 30
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 35
  ngx_modules_n = i;
#line 36
  ngx_max_module = ngx_modules_n + 128UL;
#line 38
  return ((ngx_int_t )0);
}
}
#line 42 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
ngx_int_t ngx_cycle_modules(ngx_cycle_t *cycle ) 
{ 
  void *tmp ;

  {
  {
#line 50
  tmp = ngx_pcalloc(cycle->pool, (ngx_max_module + 1UL) * sizeof(ngx_module_t *));
#line 50
  cycle->modules = (ngx_module_t **)tmp;
  }
#line 52
  if ((unsigned long )cycle->modules == (unsigned long )((void *)0)) {
#line 53
    return ((ngx_int_t )-1);
  }
  {
#line 56
  memcpy((void */* __restrict  */)cycle->modules, (void const   */* __restrict  */)(ngx_modules),
         ngx_modules_n * sizeof(ngx_module_t *));
#line 59
  cycle->modules_n = ngx_modules_n;
  }
#line 61
  return ((ngx_int_t )0);
}
}
#line 65 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
ngx_int_t ngx_init_modules(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_int_t tmp ;

  {
#line 70
  i = (ngx_uint_t )0;
  {
#line 70
  while (1) {
    while_continue: /* CIL Label */ ;
#line 70
    if (! *(cycle->modules + i)) {
#line 70
      goto while_break;
    }
#line 71
    if ((*(cycle->modules + i))->init_module) {
      {
#line 72
      tmp = (*((*(cycle->modules + i))->init_module))(cycle);
      }
#line 72
      if (tmp != 0L) {
#line 73
        return ((ngx_int_t )-1);
      }
    }
#line 70
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return ((ngx_int_t )0);
}
}
#line 82 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
ngx_int_t ngx_count_modules(ngx_cycle_t *cycle , ngx_uint_t type ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t next ;
  ngx_uint_t max ;
  ngx_module_t *module ;

  {
#line 88
  next = (ngx_uint_t )0;
#line 89
  max = (ngx_uint_t )0;
#line 93
  i = (ngx_uint_t )0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! *(cycle->modules + i)) {
#line 93
      goto while_break;
    }
#line 94
    module = *(cycle->modules + i);
#line 96
    if (module->type != type) {
#line 97
      goto __Cont;
    }
#line 100
    if (module->ctx_index != 0xffffffffffffffffUL) {
#line 104
      if (module->ctx_index > max) {
#line 105
        max = module->ctx_index;
      }
#line 108
      if (module->ctx_index == next) {
#line 109
        next ++;
      }
#line 112
      goto __Cont;
    }
    {
#line 117
    module->ctx_index = ngx_module_ctx_index(cycle, type, next);
    }
#line 119
    if (module->ctx_index > max) {
#line 120
      max = module->ctx_index;
    }
#line 123
    next = module->ctx_index + 1UL;
    __Cont: /* CIL Label */ 
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (cycle->old_cycle) {
#line 133
    if ((cycle->old_cycle)->modules) {
#line 135
      i = (ngx_uint_t )0;
      {
#line 135
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 135
        if (! *((cycle->old_cycle)->modules + i)) {
#line 135
          goto while_break___0;
        }
#line 136
        module = *((cycle->old_cycle)->modules + i);
#line 138
        if (module->type != type) {
#line 139
          goto __Cont___0;
        }
#line 142
        if (module->ctx_index > max) {
#line 143
          max = module->ctx_index;
        }
        __Cont___0: /* CIL Label */ 
#line 135
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 150
  cycle->modules_used = (ngx_uint_t )1;
#line 152
  return ((ngx_int_t )(max + 1UL));
}
}
#line 156 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
ngx_int_t ngx_add_module(ngx_conf_t *cf , ngx_str_t *file , ngx_module_t *module ,
                         char **order ) 
{ 
  void *rv ;
  ngx_uint_t i ;
  ngx_uint_t m ;
  ngx_uint_t before ;
  ngx_core_module_t *core_module ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 164
  if ((cf->cycle)->modules_n >= ngx_max_module) {
    {
#line 165
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "too many modules loaded");
    }
#line 167
    return ((ngx_int_t )-1);
  }
#line 170
  if (module->version != 1013008UL) {
    {
#line 171
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "module \"%V\" version %ui instead of %ui",
                       file, module->version, (ngx_uint_t )1013008);
    }
#line 174
    return ((ngx_int_t )-1);
  }
  {
#line 177
  tmp = strcmp(module->signature, "8,4,8,0000111111010111001110101111000110");
  }
#line 177
  if (tmp != 0) {
    {
#line 178
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "module \"%V\" is not binary compatible",
                       file);
    }
#line 181
    return ((ngx_int_t )-1);
  }
#line 184
  m = (ngx_uint_t )0;
  {
#line 184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 184
    if (! *((cf->cycle)->modules + m)) {
#line 184
      goto while_break;
    }
    {
#line 185
    tmp___0 = strcmp((char const   *)(*((cf->cycle)->modules + m))->name, (char const   *)module->name);
    }
#line 185
    if (tmp___0 == 0) {
      {
#line 186
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "module \"%s\" is already loaded",
                         module->name);
      }
#line 189
      return ((ngx_int_t )-1);
    }
#line 184
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  if (module->index == 0xffffffffffffffffUL) {
    {
#line 198
    module->index = ngx_module_index(cf->cycle);
    }
#line 200
    if (module->index >= ngx_max_module) {
      {
#line 201
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "too many modules loaded");
      }
#line 203
      return ((ngx_int_t )-1);
    }
  }
#line 211
  before = (cf->cycle)->modules_n;
#line 213
  if (order) {
#line 214
    i = (ngx_uint_t )0;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! *(order + i)) {
#line 214
        goto while_break___0;
      }
      {
#line 215
      tmp___1 = strcmp((char const   *)*(order + i), (char const   *)module->name);
      }
#line 215
      if (tmp___1 == 0) {
#line 216
        i ++;
#line 217
        goto while_break___0;
      }
#line 214
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 221
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 221
      if (! *(order + i)) {
#line 221
        goto while_break___1;
      }
#line 229
      m = (ngx_uint_t )0;
      {
#line 229
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 229
        if (! (m < before)) {
#line 229
          goto while_break___2;
        }
        {
#line 230
        tmp___2 = strcmp((char const   *)(*((cf->cycle)->modules + m))->name, (char const   *)*(order + i));
        }
#line 230
        if (tmp___2 == 0) {
#line 236
          before = m;
#line 237
          goto while_break___2;
        }
#line 229
        m ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 221
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 245
  if (before != (cf->cycle)->modules_n) {
    {
#line 246
    memmove((void *)((cf->cycle)->modules + (before + 1UL)), (void const   *)((cf->cycle)->modules + before),
            ((cf->cycle)->modules_n - before) * sizeof(ngx_module_t *));
    }
  }
#line 251
  *((cf->cycle)->modules + before) = module;
#line 252
  ((cf->cycle)->modules_n) ++;
#line 254
  if (module->type == 1163022147UL) {
#line 263
    core_module = (ngx_core_module_t *)module->ctx;
#line 265
    if (core_module->create_conf) {
      {
#line 266
      rv = (*(core_module->create_conf))(cf->cycle);
      }
#line 267
      if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 268
        return ((ngx_int_t )-1);
      }
#line 271
      *((cf->cycle)->conf_ctx + module->index) = (void ***)rv;
    }
  }
#line 275
  return ((ngx_int_t )0);
}
}
#line 279 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
static ngx_uint_t ngx_module_index(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t index___0 ;
  ngx_module_t *module ;

  {
#line 285
  index___0 = (ngx_uint_t )0;
  again: 
#line 291
  i = (ngx_uint_t )0;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! *(cycle->modules + i)) {
#line 291
      goto while_break;
    }
#line 292
    module = *(cycle->modules + i);
#line 294
    if (module->index == index___0) {
#line 295
      index___0 ++;
#line 296
      goto again;
    }
#line 291
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  if (cycle->old_cycle) {
#line 302
    if ((cycle->old_cycle)->modules) {
#line 304
      i = (ngx_uint_t )0;
      {
#line 304
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 304
        if (! *((cycle->old_cycle)->modules + i)) {
#line 304
          goto while_break___0;
        }
#line 305
        module = *((cycle->old_cycle)->modules + i);
#line 307
        if (module->index == index___0) {
#line 308
          index___0 ++;
#line 309
          goto again;
        }
#line 304
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 314
  return (index___0);
}
}
#line 318 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_module.c"
static ngx_uint_t ngx_module_ctx_index(ngx_cycle_t *cycle , ngx_uint_t type , ngx_uint_t index___0 ) 
{ 
  ngx_uint_t i ;
  ngx_module_t *module ;

  {
  again: 
#line 328
  i = (ngx_uint_t )0;
  {
#line 328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    if (! *(cycle->modules + i)) {
#line 328
      goto while_break;
    }
#line 329
    module = *(cycle->modules + i);
#line 331
    if (module->type != type) {
#line 332
      goto __Cont;
    }
#line 335
    if (module->ctx_index == index___0) {
#line 336
      index___0 ++;
#line 337
      goto again;
    }
    __Cont: /* CIL Label */ 
#line 328
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  if (cycle->old_cycle) {
#line 343
    if ((cycle->old_cycle)->modules) {
#line 345
      i = (ngx_uint_t )0;
      {
#line 345
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 345
        if (! *((cycle->old_cycle)->modules + i)) {
#line 345
          goto while_break___0;
        }
#line 346
        module = *((cycle->old_cycle)->modules + i);
#line 348
        if (module->type != type) {
#line 349
          goto __Cont___0;
        }
#line 352
        if (module->ctx_index == index___0) {
#line 353
          index___0 ++;
#line 354
          goto again;
        }
        __Cont___0: /* CIL Label */ 
#line 345
        i ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
#line 359
  return (index___0);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 315 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strpbrk)(char const   *__s ,
                                                                                                  char const   *__accept )  __attribute__((__pure__)) ;
#line 155 "src/core/ngx_string.h"
u_char *ngx_vslprintf(u_char *buf , u_char *last , char const   *fmt , va_list args___0 ) ;
#line 234 "src/core/ngx_log.h"
u_char *ngx_log_errno(u_char *buf , u_char *last , ngx_err_t err ) ;
#line 142 "src/core/ngx_cycle.h"
ngx_uint_t ngx_dump_config ;
#line 172 "src/core/ngx_conf_file.h"
char *ngx_conf_deprecated(ngx_conf_t *cf , void *post , void *data ) ;
#line 268
char *ngx_conf_param(ngx_conf_t *cf ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
static ngx_int_t ngx_conf_add_dump(ngx_conf_t *cf , ngx_str_t *filename ) ;
#line 14
static ngx_int_t ngx_conf_handler(ngx_conf_t *cf , ngx_int_t last ) ;
#line 15
static ngx_int_t ngx_conf_read_token(ngx_conf_t *cf ) ;
#line 16
static void ngx_conf_flush_files(ngx_cycle_t *cycle ) ;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
static ngx_command_t ngx_conf_commands[2]  = {      {{sizeof("include") - 1UL, (u_char *)"include"}, (ngx_uint_t )520093698, & ngx_conf_include,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
ngx_module_t ngx_conf_module  = 
#line 32
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)0, ngx_conf_commands,
    (ngx_uint_t )1179537219, (ngx_int_t (*)(ngx_log_t *log ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), & ngx_conf_flush_files, (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 50 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
static ngx_uint_t argument_number[8]  = 
#line 50
  {      (ngx_uint_t )1,      (ngx_uint_t )2,      (ngx_uint_t )4,      (ngx_uint_t )8, 
        (ngx_uint_t )16,      (ngx_uint_t )32,      (ngx_uint_t )64,      (ngx_uint_t )128};
#line 62 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_param(ngx_conf_t *cf ) 
{ 
  char *rv ;
  ngx_str_t *param ;
  ngx_buf_t b ;
  ngx_conf_file_t conf_file ;
  void *__cil_tmp6 ;

  {
#line 70
  param = & (cf->cycle)->conf_param;
#line 72
  if (param->len == 0UL) {
#line 73
    return ((char *)((void *)0));
  }
  {
#line 76
  memset((void *)(& conf_file), 0, sizeof(ngx_conf_file_t ));
#line 78
  memset((void *)(& b), 0, sizeof(ngx_buf_t ));
#line 80
  b.start = param->data;
#line 81
  b.pos = param->data;
#line 82
  b.last = param->data + param->len;
#line 83
  b.end = b.last;
#line 84
  b.temporary = 1U;
#line 86
  conf_file.file.fd = -1;
#line 87
  conf_file.file.name.data = (u_char *)((void *)0);
#line 88
  conf_file.line = (ngx_uint_t )0;
#line 90
  cf->conf_file = & conf_file;
#line 91
  (cf->conf_file)->buffer = & b;
#line 93
  rv = ngx_conf_parse(cf, (ngx_str_t *)((void *)0));
#line 95
  cf->conf_file = (ngx_conf_file_t *)((void *)0);
  }
#line 97
  return (rv);
}
}
#line 101 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
static ngx_int_t ngx_conf_add_dump(ngx_conf_t *cf , ngx_str_t *filename ) 
{ 
  off_t size ;
  u_char *p ;
  uint32_t hash ;
  ngx_buf_t *buf ;
  ngx_str_node_t *sn ;
  ngx_conf_dump_t *cd ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 111
  hash = ngx_crc32_long(filename->data, filename->len);
#line 113
  sn = ngx_str_rbtree_lookup(& (cf->cycle)->config_dump_rbtree, filename, hash);
  }
#line 115
  if (sn) {
#line 116
    (cf->conf_file)->dump = (ngx_buf_t *)((void *)0);
#line 117
    return ((ngx_int_t )0);
  }
  {
#line 120
  p = ngx_pstrdup((cf->cycle)->pool, filename);
  }
#line 121
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 122
    return ((ngx_int_t )-1);
  }
  {
#line 125
  tmp = ngx_array_push(& (cf->cycle)->config_dump);
#line 125
  cd = (ngx_conf_dump_t *)tmp;
  }
#line 126
  if ((unsigned long )cd == (unsigned long )((void *)0)) {
#line 127
    return ((ngx_int_t )-1);
  }
  {
#line 130
  size = (cf->conf_file)->file.info.st_size;
#line 132
  buf = ngx_create_temp_buf((cf->cycle)->pool, (size_t )size);
  }
#line 133
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 134
    return ((ngx_int_t )-1);
  }
  {
#line 137
  cd->name.data = p;
#line 138
  cd->name.len = filename->len;
#line 139
  cd->buffer = buf;
#line 141
  (cf->conf_file)->dump = buf;
#line 143
  tmp___0 = ngx_palloc(cf->temp_pool, sizeof(ngx_str_node_t ));
#line 143
  sn = (ngx_str_node_t *)tmp___0;
  }
#line 144
  if ((unsigned long )sn == (unsigned long )((void *)0)) {
#line 145
    return ((ngx_int_t )-1);
  }
  {
#line 148
  sn->node.key = (ngx_rbtree_key_t )hash;
#line 149
  sn->str = cd->name;
#line 151
  ngx_rbtree_insert(& (cf->cycle)->config_dump_rbtree, & sn->node);
  }
#line 153
  return ((ngx_int_t )0);
}
}
#line 157 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_parse(ngx_conf_t *cf , ngx_str_t *filename ) 
{ 
  char *rv ;
  ngx_fd_t fd ;
  ngx_int_t rc ;
  ngx_buf_t buf ;
  ngx_conf_file_t *prev ;
  ngx_conf_file_t conf_file ;
  enum __anonenum_type_171 type ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  ngx_int_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  void *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;

  {
#line 172
  fd = -1;
#line 173
  prev = (ngx_conf_file_t *)((void *)0);
#line 176
  if (filename) {
    {
#line 180
    fd = open((char const   *)filename->data, 0, 0);
    }
#line 182
    if (fd == -1) {
      {
#line 183
      tmp = __errno_location();
#line 183
      ngx_conf_log_error((ngx_uint_t )1, cf, *tmp, "open() \"%s\" failed", filename->data);
      }
#line 186
      return ((char *)((void *)-1));
    }
    {
#line 189
    prev = cf->conf_file;
#line 191
    cf->conf_file = & conf_file;
#line 193
    tmp___1 = fstat(fd, & (cf->conf_file)->file.info);
    }
#line 193
    if (tmp___1 == -1) {
#line 194
      if ((cf->log)->log_level >= 1UL) {
        {
#line 194
        tmp___0 = __errno_location();
#line 194
        ngx_log_error_core((ngx_uint_t )1, cf->log, *tmp___0, "fstat() \"%s\" failed",
                           filename->data);
        }
      }
    }
    {
#line 198
    (cf->conf_file)->buffer = & buf;
#line 200
    tmp___2 = ngx_alloc((size_t )4096, cf->log);
#line 200
    buf.start = (u_char *)tmp___2;
    }
#line 201
    if ((unsigned long )buf.start == (unsigned long )((void *)0)) {
#line 202
      goto failed;
    }
#line 205
    buf.pos = buf.start;
#line 206
    buf.last = buf.start;
#line 207
    buf.end = buf.last + 4096;
#line 208
    buf.temporary = 1U;
#line 210
    (cf->conf_file)->file.fd = fd;
#line 211
    (cf->conf_file)->file.name.len = filename->len;
#line 212
    (cf->conf_file)->file.name.data = filename->data;
#line 213
    (cf->conf_file)->file.offset = (off_t )0;
#line 214
    (cf->conf_file)->file.log = cf->log;
#line 215
    (cf->conf_file)->line = (ngx_uint_t )1;
#line 217
    type = (enum __anonenum_type_171 )0;
#line 219
    if (ngx_dump_config) {
      {
#line 225
      tmp___3 = ngx_conf_add_dump(cf, filename);
      }
#line 225
      if (tmp___3 != 0L) {
#line 226
        goto failed;
      }
    } else {
#line 230
      (cf->conf_file)->dump = (ngx_buf_t *)((void *)0);
    }
  } else
#line 233
  if ((cf->conf_file)->file.fd != -1) {
#line 235
    type = (enum __anonenum_type_171 )1;
  } else {
#line 238
    type = (enum __anonenum_type_171 )2;
  }
  {
#line 242
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    rc = ngx_conf_read_token(cf);
    }
#line 255
    if (rc == -1L) {
#line 256
      goto done;
    }
#line 259
    if (rc == 2L) {
#line 261
      if ((unsigned int )type != 1U) {
        {
#line 262
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"}\"");
        }
#line 263
        goto failed;
      }
#line 266
      goto done;
    }
#line 269
    if (rc == 3L) {
#line 271
      if ((unsigned int )type == 1U) {
        {
#line 272
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected end of file, expecting \"}\"");
        }
#line 274
        goto failed;
      }
#line 277
      goto done;
    }
#line 280
    if (rc == 1L) {
#line 282
      if ((unsigned int )type == 2U) {
        {
#line 283
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "block directives are not supported in -g option");
        }
#line 286
        goto failed;
      }
    }
#line 292
    if (cf->handler) {
#line 299
      if (rc == 1L) {
        {
#line 300
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"{\"");
        }
#line 301
        goto failed;
      }
      {
#line 304
      rv = (*(cf->handler))(cf, (ngx_command_t *)((void *)0), cf->handler_conf);
      }
#line 305
      if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 306
        goto __Cont;
      }
#line 309
      if ((unsigned long )rv == (unsigned long )((void *)-1)) {
#line 310
        goto failed;
      }
      {
#line 313
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, (char const   *)rv);
      }
#line 315
      goto failed;
    }
    {
#line 319
    rc = ngx_conf_handler(cf, rc);
    }
#line 321
    if (rc == -1L) {
#line 322
      goto failed;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  failed: 
#line 328
  rc = (ngx_int_t )-1;
  done: 
#line 332
  if (filename) {
#line 333
    if (((cf->conf_file)->buffer)->start) {
      {
#line 334
      free((void *)((cf->conf_file)->buffer)->start);
      }
    }
    {
#line 337
    tmp___5 = close(fd);
    }
#line 337
    if (tmp___5 == -1) {
#line 338
      if ((cf->log)->log_level >= 2UL) {
        {
#line 338
        tmp___4 = __errno_location();
#line 338
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___4, "close() %s failed",
                           filename->data);
        }
      }
#line 341
      rc = (ngx_int_t )-1;
    }
#line 344
    cf->conf_file = prev;
  }
#line 347
  if (rc == -1L) {
#line 348
    return ((char *)((void *)-1));
  }
#line 351
  return ((char *)((void *)0));
}
}
#line 355 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
static ngx_int_t ngx_conf_handler(ngx_conf_t *cf , ngx_int_t last ) 
{ 
  char *rv ;
  void *conf ;
  void **confp ;
  ngx_uint_t i ;
  ngx_uint_t found ;
  ngx_str_t *name ;
  ngx_command_t *cmd ;
  int tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 364
  name = (ngx_str_t *)(cf->args)->elts;
#line 366
  found = (ngx_uint_t )0;
#line 368
  i = (ngx_uint_t )0;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! *((cf->cycle)->modules + i)) {
#line 368
      goto while_break;
    }
#line 370
    cmd = (*((cf->cycle)->modules + i))->commands;
#line 371
    if ((unsigned long )cmd == (unsigned long )((void *)0)) {
#line 372
      goto __Cont;
    }
    {
#line 375
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 375
      if (! cmd->name.len) {
#line 375
        goto while_break___0;
      }
#line 377
      if (name->len != cmd->name.len) {
#line 378
        goto __Cont___0;
      }
      {
#line 381
      tmp = strcmp((char const   *)name->data, (char const   *)cmd->name.data);
      }
#line 381
      if (tmp != 0) {
#line 382
        goto __Cont___0;
      }
#line 385
      found = (ngx_uint_t )1;
#line 387
      if ((*((cf->cycle)->modules + i))->type != 1179537219UL) {
#line 387
        if ((*((cf->cycle)->modules + i))->type != cf->module_type) {
#line 390
          goto __Cont___0;
        }
      }
#line 395
      if (! (cmd->type & cf->cmd_type)) {
#line 396
        goto __Cont___0;
      }
#line 399
      if (! (cmd->type & 256UL)) {
#line 399
        if (last != 0L) {
          {
#line 400
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "directive \"%s\" is not terminated by \";\"",
                             name->data);
          }
#line 403
          return ((ngx_int_t )-1);
        }
      }
#line 406
      if (cmd->type & 256UL) {
#line 406
        if (last != 1L) {
          {
#line 407
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "directive \"%s\" has no opening \"{\"",
                             name->data);
          }
#line 410
          return ((ngx_int_t )-1);
        }
      }
#line 415
      if (! (cmd->type & 1024UL)) {
#line 417
        if (cmd->type & 512UL) {
#line 419
          if ((cf->args)->nelts != 2UL) {
#line 420
            goto invalid;
          }
        } else
#line 423
        if (cmd->type & 2048UL) {
#line 425
          if ((cf->args)->nelts < 2UL) {
#line 426
            goto invalid;
          }
        } else
#line 429
        if (cmd->type & 4096UL) {
#line 431
          if ((cf->args)->nelts < 3UL) {
#line 432
            goto invalid;
          }
        } else
#line 435
        if ((cf->args)->nelts > 8UL) {
#line 437
          goto invalid;
        } else
#line 439
        if (! (cmd->type & argument_number[(cf->args)->nelts - 1UL])) {
#line 441
          goto invalid;
        }
      }
#line 447
      conf = (void *)0;
#line 449
      if (cmd->type & 65536UL) {
#line 450
        conf = *((void **)cf->ctx + (*((cf->cycle)->modules + i))->index);
      } else
#line 452
      if (cmd->type & 16777216UL) {
#line 453
        conf = (void *)((void **)cf->ctx + (*((cf->cycle)->modules + i))->index);
      } else
#line 455
      if (cf->ctx) {
#line 456
        confp = (void **)*((void **)((char *)cf->ctx + cmd->conf));
#line 458
        if (confp) {
#line 459
          conf = *(confp + (*((cf->cycle)->modules + i))->ctx_index);
        }
      }
      {
#line 463
      rv = (*(cmd->set))(cf, cmd, conf);
      }
#line 465
      if ((unsigned long )rv == (unsigned long )((void *)0)) {
#line 466
        return ((ngx_int_t )0);
      }
#line 469
      if ((unsigned long )rv == (unsigned long )((void *)-1)) {
#line 470
        return ((ngx_int_t )-1);
      }
      {
#line 473
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%s\" directive %s", name->data,
                         rv);
      }
#line 476
      return ((ngx_int_t )-1);
      __Cont___0: /* CIL Label */ 
#line 375
      cmd ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 480
  if (found) {
    {
#line 481
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"%s\" directive is not allowed here",
                       name->data);
    }
#line 484
    return ((ngx_int_t )-1);
  }
  {
#line 487
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unknown directive \"%s\"", name->data);
  }
#line 490
  return ((ngx_int_t )-1);
  invalid: 
  {
#line 494
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of arguments in \"%s\" directive",
                     name->data);
  }
#line 498
  return ((ngx_int_t )-1);
}
}
#line 502 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
static ngx_int_t ngx_conf_read_token(ngx_conf_t *cf ) 
{ 
  u_char *start ;
  u_char ch ;
  u_char *src ;
  u_char *dst ;
  off_t file_size ;
  size_t len ;
  ssize_t n ;
  ssize_t size ;
  ngx_uint_t found ;
  ngx_uint_t need_space ;
  ngx_uint_t last_space ;
  ngx_uint_t sharp_comment ;
  ngx_uint_t variable ;
  ngx_uint_t quoted ;
  ngx_uint_t s_quoted ;
  ngx_uint_t d_quoted ;
  ngx_uint_t start_line ;
  ngx_str_t *word ;
  ngx_buf_t *b ;
  ngx_buf_t *dump ;
  void *tmp ;
  u_char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;

  {
#line 514
  found = (ngx_uint_t )0;
#line 515
  need_space = (ngx_uint_t )0;
#line 516
  last_space = (ngx_uint_t )1;
#line 517
  sharp_comment = (ngx_uint_t )0;
#line 518
  variable = (ngx_uint_t )0;
#line 519
  quoted = (ngx_uint_t )0;
#line 520
  s_quoted = (ngx_uint_t )0;
#line 521
  d_quoted = (ngx_uint_t )0;
#line 523
  (cf->args)->nelts = (ngx_uint_t )0;
#line 524
  b = (cf->conf_file)->buffer;
#line 525
  dump = (cf->conf_file)->dump;
#line 526
  start = b->pos;
#line 527
  start_line = (cf->conf_file)->line;
#line 529
  file_size = (cf->conf_file)->file.info.st_size;
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if ((unsigned long )b->pos >= (unsigned long )b->last) {
#line 535
      if ((cf->conf_file)->file.offset >= file_size) {
#line 537
        if ((cf->args)->nelts > 0UL) {
#line 537
          goto _L;
        } else
#line 537
        if (! last_space) {
          _L: /* CIL Label */ 
#line 539
          if ((cf->conf_file)->file.fd == -1) {
            {
#line 540
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected end of parameter, expecting \";\"");
            }
#line 543
            return ((ngx_int_t )-1);
          }
          {
#line 546
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected end of file, expecting \";\" or \"}\"");
          }
#line 549
          return ((ngx_int_t )-1);
        }
#line 552
        return ((ngx_int_t )3);
      }
#line 555
      len = (size_t )(b->pos - start);
#line 557
      if (len == 4096UL) {
#line 558
        (cf->conf_file)->line = start_line;
#line 560
        if (d_quoted) {
#line 561
          ch = (u_char )'\"';
        } else
#line 563
        if (s_quoted) {
#line 564
          ch = (u_char )'\'';
        } else {
          {
#line 567
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "too long parameter \"%*s...\" started",
                             10, start);
          }
#line 570
          return ((ngx_int_t )-1);
        }
        {
#line 573
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "too long parameter, probably missing terminating \"%c\" character",
                           (int )ch);
        }
#line 576
        return ((ngx_int_t )-1);
      }
#line 579
      if (len) {
        {
#line 580
        memmove((void *)b->start, (void const   *)start, len);
        }
      }
#line 583
      size = file_size - (cf->conf_file)->file.offset;
#line 585
      if (size > b->end - (b->start + len)) {
#line 586
        size = b->end - (b->start + len);
      }
      {
#line 589
      n = ngx_read_file(& (cf->conf_file)->file, b->start + len, (size_t )size, (cf->conf_file)->file.offset);
      }
#line 592
      if (n == -1L) {
#line 593
        return ((ngx_int_t )-1);
      }
#line 596
      if (n != size) {
        {
#line 597
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "pread() returned only %z bytes instead of %z",
                           n, size);
        }
#line 601
        return ((ngx_int_t )-1);
      }
#line 604
      b->pos = b->start + len;
#line 605
      b->last = b->pos + n;
#line 606
      start = b->start;
#line 608
      if (dump) {
        {
#line 609
        tmp = memcpy((void */* __restrict  */)dump->last, (void const   */* __restrict  */)b->pos,
                     (size_t )size);
#line 609
        dump->last = (u_char *)tmp + size;
        }
      }
    }
#line 613
    tmp___0 = b->pos;
#line 613
    (b->pos) ++;
#line 613
    ch = *tmp___0;
#line 615
    if ((int )ch == 10) {
#line 616
      ((cf->conf_file)->line) ++;
#line 618
      if (sharp_comment) {
#line 619
        sharp_comment = (ngx_uint_t )0;
      }
    }
#line 623
    if (sharp_comment) {
#line 624
      goto __Cont;
    }
#line 627
    if (quoted) {
#line 628
      quoted = (ngx_uint_t )0;
#line 629
      goto __Cont;
    }
#line 632
    if (need_space) {
#line 633
      if ((int )ch == 32) {
#line 634
        last_space = (ngx_uint_t )1;
#line 635
        need_space = (ngx_uint_t )0;
#line 636
        goto __Cont;
      } else
#line 633
      if ((int )ch == 9) {
#line 634
        last_space = (ngx_uint_t )1;
#line 635
        need_space = (ngx_uint_t )0;
#line 636
        goto __Cont;
      } else
#line 633
      if ((int )ch == 13) {
#line 634
        last_space = (ngx_uint_t )1;
#line 635
        need_space = (ngx_uint_t )0;
#line 636
        goto __Cont;
      } else
#line 633
      if ((int )ch == 10) {
#line 634
        last_space = (ngx_uint_t )1;
#line 635
        need_space = (ngx_uint_t )0;
#line 636
        goto __Cont;
      }
#line 639
      if ((int )ch == 59) {
#line 640
        return ((ngx_int_t )0);
      }
#line 643
      if ((int )ch == 123) {
#line 644
        return ((ngx_int_t )1);
      }
#line 647
      if ((int )ch == 41) {
#line 648
        last_space = (ngx_uint_t )1;
#line 649
        need_space = (ngx_uint_t )0;
      } else {
        {
#line 652
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"%c\"", (int )ch);
        }
#line 654
        return ((ngx_int_t )-1);
      }
    }
#line 658
    if (last_space) {
#line 659
      if ((int )ch == 32) {
#line 660
        goto __Cont;
      } else
#line 659
      if ((int )ch == 9) {
#line 660
        goto __Cont;
      } else
#line 659
      if ((int )ch == 13) {
#line 660
        goto __Cont;
      } else
#line 659
      if ((int )ch == 10) {
#line 660
        goto __Cont;
      }
#line 663
      start = b->pos - 1;
#line 664
      start_line = (cf->conf_file)->line;
      {
#line 669
      if ((int )ch == 123) {
#line 669
        goto case_123;
      }
#line 669
      if ((int )ch == 59) {
#line 669
        goto case_123;
      }
#line 682
      if ((int )ch == 125) {
#line 682
        goto case_125;
      }
#line 691
      if ((int )ch == 35) {
#line 691
        goto case_35;
      }
#line 695
      if ((int )ch == 92) {
#line 695
        goto case_92;
      }
#line 700
      if ((int )ch == 34) {
#line 700
        goto case_34;
      }
#line 706
      if ((int )ch == 39) {
#line 706
        goto case_39;
      }
#line 712
      if ((int )ch == 36) {
#line 712
        goto case_36;
      }
#line 717
      goto switch_default;
      case_123: /* CIL Label */ 
      case_59: /* CIL Label */ 
#line 670
      if ((cf->args)->nelts == 0UL) {
        {
#line 671
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"%c\"", (int )ch);
        }
#line 673
        return ((ngx_int_t )-1);
      }
#line 676
      if ((int )ch == 123) {
#line 677
        return ((ngx_int_t )1);
      }
#line 680
      return ((ngx_int_t )0);
      case_125: /* CIL Label */ 
#line 683
      if ((cf->args)->nelts != 0UL) {
        {
#line 684
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "unexpected \"}\"");
        }
#line 686
        return ((ngx_int_t )-1);
      }
#line 689
      return ((ngx_int_t )2);
      case_35: /* CIL Label */ 
#line 692
      sharp_comment = (ngx_uint_t )1;
#line 693
      goto __Cont;
      case_92: /* CIL Label */ 
#line 696
      quoted = (ngx_uint_t )1;
#line 697
      last_space = (ngx_uint_t )0;
#line 698
      goto __Cont;
      case_34: /* CIL Label */ 
#line 701
      start ++;
#line 702
      d_quoted = (ngx_uint_t )1;
#line 703
      last_space = (ngx_uint_t )0;
#line 704
      goto __Cont;
      case_39: /* CIL Label */ 
#line 707
      start ++;
#line 708
      s_quoted = (ngx_uint_t )1;
#line 709
      last_space = (ngx_uint_t )0;
#line 710
      goto __Cont;
      case_36: /* CIL Label */ 
#line 713
      variable = (ngx_uint_t )1;
#line 714
      last_space = (ngx_uint_t )0;
#line 715
      goto __Cont;
      switch_default: /* CIL Label */ 
#line 718
      last_space = (ngx_uint_t )0;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 722
      if ((int )ch == 123) {
#line 722
        if (variable) {
#line 723
          goto __Cont;
        }
      }
#line 726
      variable = (ngx_uint_t )0;
#line 728
      if ((int )ch == 92) {
#line 729
        quoted = (ngx_uint_t )1;
#line 730
        goto __Cont;
      }
#line 733
      if ((int )ch == 36) {
#line 734
        variable = (ngx_uint_t )1;
#line 735
        goto __Cont;
      }
#line 738
      if (d_quoted) {
#line 739
        if ((int )ch == 34) {
#line 740
          d_quoted = (ngx_uint_t )0;
#line 741
          need_space = (ngx_uint_t )1;
#line 742
          found = (ngx_uint_t )1;
        }
      } else
#line 745
      if (s_quoted) {
#line 746
        if ((int )ch == 39) {
#line 747
          s_quoted = (ngx_uint_t )0;
#line 748
          need_space = (ngx_uint_t )1;
#line 749
          found = (ngx_uint_t )1;
        }
      } else
#line 752
      if ((int )ch == 32) {
#line 755
        last_space = (ngx_uint_t )1;
#line 756
        found = (ngx_uint_t )1;
      } else
#line 752
      if ((int )ch == 9) {
#line 755
        last_space = (ngx_uint_t )1;
#line 756
        found = (ngx_uint_t )1;
      } else
#line 752
      if ((int )ch == 13) {
#line 755
        last_space = (ngx_uint_t )1;
#line 756
        found = (ngx_uint_t )1;
      } else
#line 752
      if ((int )ch == 10) {
#line 755
        last_space = (ngx_uint_t )1;
#line 756
        found = (ngx_uint_t )1;
      } else
#line 752
      if ((int )ch == 59) {
#line 755
        last_space = (ngx_uint_t )1;
#line 756
        found = (ngx_uint_t )1;
      } else
#line 752
      if ((int )ch == 123) {
#line 755
        last_space = (ngx_uint_t )1;
#line 756
        found = (ngx_uint_t )1;
      }
#line 759
      if (found) {
        {
#line 760
        tmp___1 = ngx_array_push(cf->args);
#line 760
        word = (ngx_str_t *)tmp___1;
        }
#line 761
        if ((unsigned long )word == (unsigned long )((void *)0)) {
#line 762
          return ((ngx_int_t )-1);
        }
        {
#line 765
        tmp___2 = ngx_pnalloc(cf->pool, (size_t )(((b->pos - 1) - start) + 1L));
#line 765
        word->data = (u_char *)tmp___2;
        }
#line 766
        if ((unsigned long )word->data == (unsigned long )((void *)0)) {
#line 767
          return ((ngx_int_t )-1);
        }
#line 770
        dst = word->data;
#line 770
        src = start;
#line 770
        len = (size_t )0;
        {
#line 770
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 770
          if (! ((unsigned long )src < (unsigned long )(b->pos - 1))) {
#line 770
            goto while_break___0;
          }
#line 774
          if ((int )*src == 92) {
            {
#line 778
            if ((int )*(src + 1) == 92) {
#line 778
              goto case_92___0;
            }
#line 778
            if ((int )*(src + 1) == 39) {
#line 778
              goto case_92___0;
            }
#line 778
            if ((int )*(src + 1) == 34) {
#line 778
              goto case_92___0;
            }
#line 782
            if ((int )*(src + 1) == 116) {
#line 782
              goto case_116;
            }
#line 787
            if ((int )*(src + 1) == 114) {
#line 787
              goto case_114;
            }
#line 792
            if ((int )*(src + 1) == 110) {
#line 792
              goto case_110;
            }
#line 775
            goto switch_break___0;
            case_92___0: /* CIL Label */ 
            case_39___0: /* CIL Label */ 
            case_34___0: /* CIL Label */ 
#line 779
            src ++;
#line 780
            goto switch_break___0;
            case_116: /* CIL Label */ 
#line 783
            tmp___3 = dst;
#line 783
            dst ++;
#line 783
            *tmp___3 = (u_char )'\t';
#line 784
            src += 2;
#line 785
            goto __Cont___0;
            case_114: /* CIL Label */ 
#line 788
            tmp___4 = dst;
#line 788
            dst ++;
#line 788
            *tmp___4 = (u_char )'\r';
#line 789
            src += 2;
#line 790
            goto __Cont___0;
            case_110: /* CIL Label */ 
#line 793
            tmp___5 = dst;
#line 793
            dst ++;
#line 793
            *tmp___5 = (u_char )'\n';
#line 794
            src += 2;
#line 795
            goto __Cont___0;
            switch_break___0: /* CIL Label */ ;
            }
          }
#line 799
          tmp___6 = dst;
#line 799
          dst ++;
#line 799
          tmp___7 = src;
#line 799
          src ++;
#line 799
          *tmp___6 = *tmp___7;
          __Cont___0: /* CIL Label */ 
#line 770
          len ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 801
        *dst = (u_char )'\000';
#line 802
        word->len = len;
#line 804
        if ((int )ch == 59) {
#line 805
          return ((ngx_int_t )0);
        }
#line 808
        if ((int )ch == 123) {
#line 809
          return ((ngx_int_t )1);
        }
#line 812
        found = (ngx_uint_t )0;
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 819 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_include(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *rv ;
  ngx_int_t n ;
  ngx_str_t *value ;
  ngx_str_t file ;
  ngx_str_t name ;
  ngx_glob_t gl ;
  ngx_int_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  ngx_int_t tmp___3 ;
  size_t tmp___4 ;
  char *__cil_tmp16 ;

  {
  {
#line 827
  value = (ngx_str_t *)(cf->args)->elts;
#line 828
  file = *(value + 1);
#line 832
  tmp = ngx_conf_full_name(cf->cycle, & file, (ngx_uint_t )1);
  }
#line 832
  if (tmp != 0L) {
#line 833
    return ((char *)((void *)-1));
  }
  {
#line 836
  tmp___1 = strpbrk((char const   *)((char *)file.data), "*?[");
  }
#line 836
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 840
    tmp___0 = ngx_conf_parse(cf, & file);
    }
#line 840
    return (tmp___0);
  }
  {
#line 843
  memset((void *)(& gl), 0, sizeof(ngx_glob_t ));
#line 845
  gl.pattern = file.data;
#line 846
  gl.log = cf->log;
#line 847
  gl.test = (ngx_uint_t )1;
#line 849
  tmp___3 = ngx_open_glob(& gl);
  }
#line 849
  if (tmp___3 != 0L) {
    {
#line 850
    tmp___2 = __errno_location();
#line 850
    ngx_conf_log_error((ngx_uint_t )1, cf, *tmp___2, "glob() \"%s\" failed", file.data);
    }
#line 852
    return ((char *)((void *)-1));
  }
#line 855
  rv = (char *)((void *)0);
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 858
    n = ngx_read_glob(& gl, & name);
    }
#line 860
    if (n != 0L) {
#line 861
      goto while_break;
    }
    {
#line 864
    tmp___4 = name.len;
#line 864
    (name.len) ++;
#line 864
    file.len = tmp___4;
#line 865
    file.data = ngx_pstrdup(cf->pool, & name);
    }
#line 866
    if ((unsigned long )file.data == (unsigned long )((void *)0)) {
#line 867
      return ((char *)((void *)-1));
    }
    {
#line 872
    rv = ngx_conf_parse(cf, & file);
    }
#line 874
    if ((unsigned long )rv != (unsigned long )((void *)0)) {
#line 875
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 879
  ngx_close_glob(& gl);
  }
#line 881
  return (rv);
}
}
#line 885 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
ngx_int_t ngx_conf_full_name(ngx_cycle_t *cycle , ngx_str_t *name , ngx_uint_t conf_prefix ) 
{ 
  ngx_str_t *prefix ;
  ngx_int_t tmp ;

  {
#line 890
  if (conf_prefix) {
#line 890
    prefix = & cycle->conf_prefix;
  } else {
#line 890
    prefix = & cycle->prefix;
  }
  {
#line 892
  tmp = ngx_get_full_name(cycle->pool, prefix, name);
  }
#line 892
  return (tmp);
}
}
#line 896 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
ngx_open_file_t *ngx_conf_open_file(ngx_cycle_t *cycle , ngx_str_t *name ) 
{ 
  ngx_str_t full ;
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_open_file_t *file ;
  ngx_int_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;

  {
#line 905
  full.len = (size_t )0;
#line 905
  full.data = (u_char *)((void *)0);
#line 908
  if (name->len) {
    {
#line 909
    full = *name;
#line 911
    tmp = ngx_conf_full_name(cycle, & full, (ngx_uint_t )0);
    }
#line 911
    if (tmp != 0L) {
#line 912
      return ((ngx_open_file_t *)((void *)0));
    }
#line 915
    part = & cycle->open_files.part;
#line 916
    file = (ngx_open_file_t *)part->elts;
#line 918
    i = (ngx_uint_t )0;
    {
#line 918
    while (1) {
      while_continue: /* CIL Label */ ;
#line 920
      if (i >= part->nelts) {
#line 921
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 922
          goto while_break;
        }
#line 924
        part = part->next;
#line 925
        file = (ngx_open_file_t *)part->elts;
#line 926
        i = (ngx_uint_t )0;
      }
#line 929
      if (full.len != (file + i)->name.len) {
#line 930
        goto __Cont;
      }
      {
#line 933
      tmp___0 = strcmp((char const   *)full.data, (char const   *)(file + i)->name.data);
      }
#line 933
      if (tmp___0 == 0) {
#line 934
        return (file + i);
      }
      __Cont: /* CIL Label */ 
#line 918
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 939
  tmp___1 = ngx_list_push(& cycle->open_files);
#line 939
  file = (ngx_open_file_t *)tmp___1;
  }
#line 940
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 941
    return ((ngx_open_file_t *)((void *)0));
  }
#line 944
  if (name->len) {
#line 945
    file->fd = -1;
#line 946
    file->name = full;
  } else {
#line 949
    file->fd = 2;
#line 950
    file->name = *name;
  }
#line 953
  file->flush = (void (*)(ngx_open_file_t *file , ngx_log_t *log ))((void *)0);
#line 954
  file->data = (void *)0;
#line 956
  return (file);
}
}
#line 960 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
static void ngx_conf_flush_files(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_open_file_t *file ;

  {
#line 969
  part = & cycle->open_files.part;
#line 970
  file = (ngx_open_file_t *)part->elts;
#line 972
  i = (ngx_uint_t )0;
  {
#line 972
  while (1) {
    while_continue: /* CIL Label */ ;
#line 974
    if (i >= part->nelts) {
#line 975
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 976
        goto while_break;
      }
#line 978
      part = part->next;
#line 979
      file = (ngx_open_file_t *)part->elts;
#line 980
      i = (ngx_uint_t )0;
    }
#line 983
    if ((file + i)->flush) {
      {
#line 984
      (*((file + i)->flush))(file + i, cycle->log);
      }
    }
#line 972
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 987
  return;
}
}
#line 990 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
void ngx_conf_log_error(ngx_uint_t level , ngx_conf_t *cf , ngx_err_t err , char const   *fmt 
                        , ...) 
{ 
  u_char errstr[1024] ;
  u_char *p ;
  u_char *last ;
  va_list args___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
#line 997
  last = errstr + 1024;
#line 999
  __builtin_va_start(args___0, fmt);
#line 1000
  p = ngx_vslprintf(errstr, last, fmt, args___0);
#line 1001
  __builtin_va_end(args___0);
  }
#line 1003
  if (err) {
    {
#line 1004
    p = ngx_log_errno(p, last, err);
    }
  }
#line 1007
  if ((unsigned long )cf->conf_file == (unsigned long )((void *)0)) {
#line 1008
    if ((cf->log)->log_level >= level) {
      {
#line 1008
      ngx_log_error_core(level, cf->log, 0, "%*s", p - errstr, errstr);
      }
    }
#line 1009
    return;
  }
#line 1012
  if ((cf->conf_file)->file.fd == -1) {
#line 1013
    if ((cf->log)->log_level >= level) {
      {
#line 1013
      ngx_log_error_core(level, cf->log, 0, "%*s in command line", p - errstr, errstr);
      }
    }
#line 1015
    return;
  }
#line 1018
  if ((cf->log)->log_level >= level) {
    {
#line 1018
    ngx_log_error_core(level, cf->log, 0, "%*s in %s:%ui", p - errstr, errstr, (cf->conf_file)->file.name.data,
                       (cf->conf_file)->line);
    }
  }
#line 1021
  return;
}
}
#line 1024 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_flag_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_flag_t *fp ;
  ngx_conf_post_t *post ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  char *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1027
  p = (char *)conf;
#line 1033
  fp = (ngx_flag_t *)(p + cmd->offset);
#line 1035
  if (*fp != -1L) {
#line 1036
    return ((char *)"is duplicate");
  }
  {
#line 1039
  value = (ngx_str_t *)(cf->args)->elts;
#line 1041
  tmp___0 = ngx_strcasecmp((value + 1)->data, (u_char *)"on");
  }
#line 1041
  if (tmp___0 == 0L) {
#line 1042
    *fp = (ngx_flag_t )1;
  } else {
    {
#line 1044
    tmp = ngx_strcasecmp((value + 1)->data, (u_char *)"off");
    }
#line 1044
    if (tmp == 0L) {
#line 1045
      *fp = (ngx_flag_t )0;
    } else {
      {
#line 1048
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%s\" in \"%s\" directive, it must be \"on\" or \"off\"",
                         (value + 1)->data, cmd->name.data);
      }
#line 1052
      return ((char *)((void *)-1));
    }
  }
#line 1055
  if (cmd->post) {
    {
#line 1056
    post = (ngx_conf_post_t *)cmd->post;
#line 1057
    tmp___1 = (*(post->post_handler))(cf, (void *)post, (void *)fp);
    }
#line 1057
    return (tmp___1);
  }
#line 1060
  return ((char *)((void *)0));
}
}
#line 1064 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_str_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *field ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  char *tmp ;
  char *__cil_tmp9 ;

  {
#line 1067
  p = (char *)conf;
#line 1072
  field = (ngx_str_t *)(p + cmd->offset);
#line 1074
  if (field->data) {
#line 1075
    return ((char *)"is duplicate");
  }
#line 1078
  value = (ngx_str_t *)(cf->args)->elts;
#line 1080
  *field = *(value + 1);
#line 1082
  if (cmd->post) {
    {
#line 1083
    post = (ngx_conf_post_t *)cmd->post;
#line 1084
    tmp = (*(post->post_handler))(cf, (void *)post, (void *)field);
    }
#line 1084
    return (tmp);
  }
#line 1087
  return ((char *)((void *)0));
}
}
#line 1091 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_str_array_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_str_t *s ;
  ngx_array_t **a ;
  ngx_conf_post_t *post ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1094
  p = (char *)conf;
#line 1100
  a = (ngx_array_t **)(p + cmd->offset);
#line 1102
  if ((unsigned long )*a == (unsigned long )((void *)-1)) {
    {
#line 1103
    *a = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
    }
#line 1104
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 1105
      return ((char *)((void *)-1));
    }
  }
  {
#line 1109
  tmp = ngx_array_push(*a);
#line 1109
  s = (ngx_str_t *)tmp;
  }
#line 1110
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1111
    return ((char *)((void *)-1));
  }
#line 1114
  value = (ngx_str_t *)(cf->args)->elts;
#line 1116
  *s = *(value + 1);
#line 1118
  if (cmd->post) {
    {
#line 1119
    post = (ngx_conf_post_t *)cmd->post;
#line 1120
    tmp___0 = (*(post->post_handler))(cf, (void *)post, (void *)s);
    }
#line 1120
    return (tmp___0);
  }
#line 1123
  return ((char *)((void *)0));
}
}
#line 1127 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_keyval_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_array_t **a ;
  ngx_keyval_t *kv ;
  ngx_conf_post_t *post ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 1130
  p = (char *)conf;
#line 1137
  a = (ngx_array_t **)(p + cmd->offset);
#line 1139
  if ((unsigned long )*a == (unsigned long )((void *)0)) {
    {
#line 1140
    *a = ngx_array_create(cf->pool, (ngx_uint_t )4, sizeof(ngx_keyval_t ));
    }
#line 1141
    if ((unsigned long )*a == (unsigned long )((void *)0)) {
#line 1142
      return ((char *)((void *)-1));
    }
  }
  {
#line 1146
  tmp = ngx_array_push(*a);
#line 1146
  kv = (ngx_keyval_t *)tmp;
  }
#line 1147
  if ((unsigned long )kv == (unsigned long )((void *)0)) {
#line 1148
    return ((char *)((void *)-1));
  }
#line 1151
  value = (ngx_str_t *)(cf->args)->elts;
#line 1153
  kv->key = *(value + 1);
#line 1154
  kv->value = *(value + 2);
#line 1156
  if (cmd->post) {
    {
#line 1157
    post = (ngx_conf_post_t *)cmd->post;
#line 1158
    tmp___0 = (*(post->post_handler))(cf, (void *)post, (void *)kv);
    }
#line 1158
    return (tmp___0);
  }
#line 1161
  return ((char *)((void *)0));
}
}
#line 1165 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_num_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_int_t *np ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1168
  p = (char *)conf;
#line 1175
  np = (ngx_int_t *)(p + cmd->offset);
#line 1177
  if (*np != -1L) {
#line 1178
    return ((char *)"is duplicate");
  }
  {
#line 1181
  value = (ngx_str_t *)(cf->args)->elts;
#line 1182
  *np = ngx_atoi((value + 1)->data, (value + 1)->len);
  }
#line 1183
  if (*np == -1L) {
#line 1184
    return ((char *)"invalid number");
  }
#line 1187
  if (cmd->post) {
    {
#line 1188
    post = (ngx_conf_post_t *)cmd->post;
#line 1189
    tmp = (*(post->post_handler))(cf, (void *)post, (void *)np);
    }
#line 1189
    return (tmp);
  }
#line 1192
  return ((char *)((void *)0));
}
}
#line 1196 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_size_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  size_t *sp ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  ssize_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1199
  p = (char *)conf;
#line 1206
  sp = (size_t *)(p + cmd->offset);
#line 1207
  if (*sp != 0xffffffffffffffffUL) {
#line 1208
    return ((char *)"is duplicate");
  }
  {
#line 1211
  value = (ngx_str_t *)(cf->args)->elts;
#line 1213
  tmp = ngx_parse_size(value + 1);
#line 1213
  *sp = (size_t )tmp;
  }
#line 1214
  if (*sp == 0xffffffffffffffffUL) {
#line 1215
    return ((char *)"invalid value");
  }
#line 1218
  if (cmd->post) {
    {
#line 1219
    post = (ngx_conf_post_t *)cmd->post;
#line 1220
    tmp___0 = (*(post->post_handler))(cf, (void *)post, (void *)sp);
    }
#line 1220
    return (tmp___0);
  }
#line 1223
  return ((char *)((void *)0));
}
}
#line 1227 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_off_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  off_t *op ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1230
  p = (char *)conf;
#line 1237
  op = (off_t *)(p + cmd->offset);
#line 1238
  if (*op != -1L) {
#line 1239
    return ((char *)"is duplicate");
  }
  {
#line 1242
  value = (ngx_str_t *)(cf->args)->elts;
#line 1244
  *op = ngx_parse_offset(value + 1);
  }
#line 1245
  if (*op == -1L) {
#line 1246
    return ((char *)"invalid value");
  }
#line 1249
  if (cmd->post) {
    {
#line 1250
    post = (ngx_conf_post_t *)cmd->post;
#line 1251
    tmp = (*(post->post_handler))(cf, (void *)post, (void *)op);
    }
#line 1251
    return (tmp);
  }
#line 1254
  return ((char *)((void *)0));
}
}
#line 1258 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_msec_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_msec_t *msp ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  ngx_int_t tmp ;
  char *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1261
  p = (char *)conf;
#line 1268
  msp = (ngx_msec_t *)(p + cmd->offset);
#line 1269
  if (*msp != 0xffffffffffffffffUL) {
#line 1270
    return ((char *)"is duplicate");
  }
  {
#line 1273
  value = (ngx_str_t *)(cf->args)->elts;
#line 1275
  tmp = ngx_parse_time(value + 1, (ngx_uint_t )0);
#line 1275
  *msp = (ngx_msec_t )tmp;
  }
#line 1276
  if (*msp == 0xffffffffffffffffUL) {
#line 1277
    return ((char *)"invalid value");
  }
#line 1280
  if (cmd->post) {
    {
#line 1281
    post = (ngx_conf_post_t *)cmd->post;
#line 1282
    tmp___0 = (*(post->post_handler))(cf, (void *)post, (void *)msp);
    }
#line 1282
    return (tmp___0);
  }
#line 1285
  return ((char *)((void *)0));
}
}
#line 1289 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_sec_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  time_t *sp ;
  ngx_str_t *value ;
  ngx_conf_post_t *post ;
  char *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1292
  p = (char *)conf;
#line 1299
  sp = (time_t *)(p + cmd->offset);
#line 1300
  if (*sp != -1L) {
#line 1301
    return ((char *)"is duplicate");
  }
  {
#line 1304
  value = (ngx_str_t *)(cf->args)->elts;
#line 1306
  *sp = ngx_parse_time(value + 1, (ngx_uint_t )1);
  }
#line 1307
  if (*sp == -1L) {
#line 1308
    return ((char *)"invalid value");
  }
#line 1311
  if (cmd->post) {
    {
#line 1312
    post = (ngx_conf_post_t *)cmd->post;
#line 1313
    tmp = (*(post->post_handler))(cf, (void *)post, (void *)sp);
    }
#line 1313
    return (tmp);
  }
#line 1316
  return ((char *)((void *)0));
}
}
#line 1320 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_bufs_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_str_t *value ;
  ngx_bufs_t *bufs ;
  ssize_t tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1323
  p = (char *)conf;
#line 1329
  bufs = (ngx_bufs_t *)(p + cmd->offset);
#line 1330
  if (bufs->num) {
#line 1331
    return ((char *)"is duplicate");
  }
  {
#line 1334
  value = (ngx_str_t *)(cf->args)->elts;
#line 1336
  bufs->num = ngx_atoi((value + 1)->data, (value + 1)->len);
  }
#line 1337
  if (bufs->num == -1L) {
#line 1338
    return ((char *)"invalid value");
  } else
#line 1337
  if (bufs->num == 0L) {
#line 1338
    return ((char *)"invalid value");
  }
  {
#line 1341
  tmp = ngx_parse_size(value + 2);
#line 1341
  bufs->size = (size_t )tmp;
  }
#line 1342
  if (bufs->size == 0xffffffffffffffffUL) {
#line 1343
    return ((char *)"invalid value");
  } else
#line 1342
  if (bufs->size == 0UL) {
#line 1343
    return ((char *)"invalid value");
  }
#line 1346
  return ((char *)((void *)0));
}
}
#line 1350 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_enum_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_uint_t *np ;
  ngx_uint_t i ;
  ngx_str_t *value ;
  ngx_conf_enum_t *e ;
  ngx_int_t tmp ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1353
  p = (char *)conf;
#line 1359
  np = (ngx_uint_t *)(p + cmd->offset);
#line 1361
  if (*np != 0xffffffffffffffffUL) {
#line 1362
    return ((char *)"is duplicate");
  }
#line 1365
  value = (ngx_str_t *)(cf->args)->elts;
#line 1366
  e = (ngx_conf_enum_t *)cmd->post;
#line 1368
  i = (ngx_uint_t )0;
  {
#line 1368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1368
    if (! ((e + i)->name.len != 0UL)) {
#line 1368
      goto while_break;
    }
#line 1369
    if ((e + i)->name.len != (value + 1)->len) {
#line 1372
      goto __Cont;
    } else {
      {
#line 1369
      tmp = ngx_strcasecmp((e + i)->name.data, (value + 1)->data);
      }
#line 1369
      if (tmp != 0L) {
#line 1372
        goto __Cont;
      }
    }
#line 1375
    *np = (e + i)->value;
#line 1377
    return ((char *)((void *)0));
    __Cont: /* CIL Label */ 
#line 1368
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1380
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%s\"", (value + 1)->data);
  }
#line 1383
  return ((char *)((void *)-1));
}
}
#line 1387 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_set_bitmask_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ngx_uint_t *np ;
  ngx_uint_t i ;
  ngx_uint_t m ;
  ngx_str_t *value ;
  ngx_conf_bitmask_t *mask ;
  ngx_int_t tmp ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 1390
  p = (char *)conf;
#line 1397
  np = (ngx_uint_t *)(p + cmd->offset);
#line 1398
  value = (ngx_str_t *)(cf->args)->elts;
#line 1399
  mask = (ngx_conf_bitmask_t *)cmd->post;
#line 1401
  i = (ngx_uint_t )1;
  {
#line 1401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1401
    if (! (i < (cf->args)->nelts)) {
#line 1401
      goto while_break;
    }
#line 1402
    m = (ngx_uint_t )0;
    {
#line 1402
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1402
      if (! ((mask + m)->name.len != 0UL)) {
#line 1402
        goto while_break___0;
      }
#line 1404
      if ((mask + m)->name.len != (value + i)->len) {
#line 1407
        goto __Cont;
      } else {
        {
#line 1404
        tmp = ngx_strcasecmp((mask + m)->name.data, (value + i)->data);
        }
#line 1404
        if (tmp != 0L) {
#line 1407
          goto __Cont;
        }
      }
#line 1410
      if (*np & (mask + m)->mask) {
        {
#line 1411
        ngx_conf_log_error((ngx_uint_t )5, cf, 0, "duplicate value \"%s\"", (value + i)->data);
        }
      } else {
#line 1415
        *np |= (mask + m)->mask;
      }
#line 1418
      goto while_break___0;
      __Cont: /* CIL Label */ 
#line 1402
      m ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1421
    if ((mask + m)->name.len == 0UL) {
      {
#line 1422
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%s\"", (value + i)->data);
      }
#line 1425
      return ((char *)((void *)-1));
    }
#line 1401
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1429
  return ((char *)((void *)0));
}
}
#line 1444 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_deprecated(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_conf_deprecated_t *d ;
  char *__cil_tmp5 ;

  {
  {
#line 1447
  d = (ngx_conf_deprecated_t *)post;
#line 1449
  ngx_conf_log_error((ngx_uint_t )5, cf, 0, "the \"%s\" directive is deprecated, use the \"%s\" directive instead",
                     d->old_name, d->new_name);
  }
#line 1454
  return ((char *)((void *)0));
}
}
#line 1458 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_conf_file.c"
char *ngx_conf_check_num_bounds(ngx_conf_t *cf , void *post , void *data ) 
{ 
  ngx_conf_num_bounds_t *bounds ;
  ngx_int_t *np ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1461
  bounds = (ngx_conf_num_bounds_t *)post;
#line 1462
  np = (ngx_int_t *)data;
#line 1464
  if (bounds->high == -1L) {
#line 1465
    if (*np >= bounds->low) {
#line 1466
      return ((char *)((void *)0));
    }
    {
#line 1469
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "value must be equal to or greater than %i",
                       bounds->low);
    }
#line 1473
    return ((char *)((void *)-1));
  }
#line 1476
  if (*np >= bounds->low) {
#line 1476
    if (*np <= bounds->high) {
#line 1477
      return ((char *)((void *)0));
    }
  }
  {
#line 1480
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "value must be between %i and %i", bounds->low,
                     bounds->high);
  }
#line 1484
  return ((char *)((void *)-1));
}
}
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cpuinfo.c"
__inline static void ngx_cpuid(uint32_t i , uint32_t *buf ) ;
#line 49 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cpuinfo.c"
__inline static void ngx_cpuid(uint32_t i , uint32_t *buf ) 
{ 
  uint32_t eax ;
  uint32_t ebx ;
  uint32_t ecx ;
  uint32_t edx ;

  {
#line 54
  __asm__  ("cpuid": "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx): "a" (i));
#line 60
  *(buf + 0) = eax;
#line 61
  *(buf + 1) = ebx;
#line 62
  *(buf + 2) = edx;
#line 63
  *(buf + 3) = ecx;
#line 64
  return;
}
}
#line 72 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cpuinfo.c"
void ngx_cpuinfo(void) 
{ 
  u_char *vendor ;
  uint32_t vbuf[5] ;
  uint32_t cpu[4] ;
  uint32_t model ;
  int tmp ;
  int tmp___0 ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
  {
#line 78
  vbuf[0] = (uint32_t )0;
#line 79
  vbuf[1] = (uint32_t )0;
#line 80
  vbuf[2] = (uint32_t )0;
#line 81
  vbuf[3] = (uint32_t )0;
#line 82
  vbuf[4] = (uint32_t )0;
#line 84
  ngx_cpuid((uint32_t )0, vbuf);
#line 86
  vendor = (u_char *)(& vbuf[1]);
  }
#line 88
  if (vbuf[0] == 0U) {
#line 89
    return;
  }
  {
#line 92
  ngx_cpuid((uint32_t )1, cpu);
#line 94
  tmp___0 = strcmp((char const   *)vendor, "GenuineIntel");
  }
#line 94
  if (tmp___0 == 0) {
    {
#line 99
    if ((cpu[0] & 3840U) >> 8 == 5U) {
#line 99
      goto case_5;
    }
#line 104
    if ((cpu[0] & 3840U) >> 8 == 6U) {
#line 104
      goto case_6;
    }
#line 120
    if ((cpu[0] & 3840U) >> 8 == 15U) {
#line 120
      goto case_15;
    }
#line 96
    goto switch_break;
    case_5: /* CIL Label */ 
#line 100
    ngx_cacheline_size = (ngx_uint_t )32;
#line 101
    goto switch_break;
    case_6: /* CIL Label */ 
#line 105
    ngx_cacheline_size = (ngx_uint_t )32;
#line 107
    model = ((cpu[0] & 983040U) >> 8) | (cpu[0] & 240U);
#line 109
    if (model >= 208U) {
#line 111
      ngx_cacheline_size = (ngx_uint_t )64;
    }
#line 114
    goto switch_break;
    case_15: /* CIL Label */ 
#line 121
    ngx_cacheline_size = (ngx_uint_t )128;
#line 122
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else {
    {
#line 125
    tmp = strcmp((char const   *)vendor, "AuthenticAMD");
    }
#line 125
    if (tmp == 0) {
#line 126
      ngx_cacheline_size = (ngx_uint_t )64;
    }
  }
#line 128
  return;
}
}
#line 63 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_yield)(void) ;
#line 19 "src/core/ngx_rwlock.h"
void ngx_rwlock_downgrade(ngx_atomic_t *lock ) ;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rwlock.c"
void ngx_rwlock_wlock(ngx_atomic_t *lock ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 24
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (*lock == (ngx_atomic_t )0) {
      {
#line 26
      tmp = __sync_bool_compare_and_swap(lock, 0, (ngx_atomic_uint_t )-1);
      }
#line 26
      if (tmp) {
#line 27
        return;
      }
    }
#line 30
    if (ngx_ncpu > 1L) {
#line 32
      n = (ngx_uint_t )1;
      {
#line 32
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 32
        if (! (n < 2048UL)) {
#line 32
          goto while_break___0;
        }
#line 34
        i = (ngx_uint_t )0;
        {
#line 34
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 34
          if (! (i < n)) {
#line 34
            goto while_break___1;
          }
#line 35
          __asm__  ("pause":);
#line 34
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 38
        if (*lock == (ngx_atomic_t )0) {
          {
#line 38
          tmp___0 = __sync_bool_compare_and_swap(lock, 0, (ngx_atomic_uint_t )-1);
          }
#line 38
          if (tmp___0) {
#line 41
            return;
          }
        }
#line 32
        n <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 46
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 51 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rwlock.c"
void ngx_rwlock_rlock(ngx_atomic_t *lock ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_atomic_uint_t readers ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    readers = (ngx_atomic_uint_t )*lock;
#line 60
    if (readers != 0xffffffffffffffffUL) {
      {
#line 60
      tmp = __sync_bool_compare_and_swap(lock, readers, readers + 1UL);
      }
#line 60
      if (tmp) {
#line 63
        return;
      }
    }
#line 66
    if (ngx_ncpu > 1L) {
#line 68
      n = (ngx_uint_t )1;
      {
#line 68
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 68
        if (! (n < 2048UL)) {
#line 68
          goto while_break___0;
        }
#line 70
        i = (ngx_uint_t )0;
        {
#line 70
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 70
          if (! (i < n)) {
#line 70
            goto while_break___1;
          }
#line 71
          __asm__  ("pause":);
#line 70
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 74
        readers = (ngx_atomic_uint_t )*lock;
#line 76
        if (readers != 0xffffffffffffffffUL) {
          {
#line 76
          tmp___0 = __sync_bool_compare_and_swap(lock, readers, readers + 1UL);
          }
#line 76
          if (tmp___0) {
#line 79
            return;
          }
        }
#line 68
        n <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 84
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 89 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rwlock.c"
void ngx_rwlock_unlock(ngx_atomic_t *lock ) 
{ 
  ngx_atomic_uint_t readers ;
  _Bool tmp ;

  {
#line 94
  readers = (ngx_atomic_uint_t )*lock;
#line 96
  if (readers == 0xffffffffffffffffUL) {
    {
#line 97
    __sync_bool_compare_and_swap(lock, (ngx_atomic_uint_t )-1, 0);
    }
#line 98
    return;
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 103
    tmp = __sync_bool_compare_and_swap(lock, readers, readers - 1UL);
    }
#line 103
    if (tmp) {
#line 104
      return;
    }
#line 107
    readers = (ngx_atomic_uint_t )*lock;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 112 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rwlock.c"
void ngx_rwlock_downgrade(ngx_atomic_t *lock ) 
{ 


  {
#line 115
  if (*lock == (ngx_atomic_t )0xffffffffffffffffUL) {
#line 116
    *lock = (ngx_atomic_t )1;
  }
#line 118
  return;
}
}
#line 307 "src/os/unix/ngx_atomic.h"
void ngx_spinlock(ngx_atomic_t *lock , ngx_atomic_int_t value , ngx_uint_t spin ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_spinlock.c"
void ngx_spinlock(ngx_atomic_t *lock , ngx_atomic_int_t value , ngx_uint_t spin ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  _Bool tmp ;
  _Bool tmp___0 ;

  {
  {
#line 20
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (*lock == (ngx_atomic_t )0) {
      {
#line 22
      tmp = __sync_bool_compare_and_swap(lock, 0, value);
      }
#line 22
      if (tmp) {
#line 23
        return;
      }
    }
#line 26
    if (ngx_ncpu > 1L) {
#line 28
      n = (ngx_uint_t )1;
      {
#line 28
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 28
        if (! (n < spin)) {
#line 28
          goto while_break___0;
        }
#line 30
        i = (ngx_uint_t )0;
        {
#line 30
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 30
          if (! (i < n)) {
#line 30
            goto while_break___1;
          }
#line 31
          __asm__  ("pause":);
#line 30
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 34
        if (*lock == (ngx_atomic_t )0) {
          {
#line 34
          tmp___0 = __sync_bool_compare_and_swap(lock, 0, value);
          }
#line 34
          if (tmp___0) {
#line 35
            return;
          }
        }
#line 28
        n <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 40
    sched_yield();
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 473 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 284 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chmod)(char const   *__file ,
                                                                                            __mode_t __mode ) ;
#line 235 "src/core/ngx_log.h"
ngx_int_t ngx_log_open_default(ngx_cycle_t *cycle ) ;
#line 236
ngx_int_t ngx_log_redirect_stderr(ngx_cycle_t *cycle ) ;
#line 265
ngx_uint_t ngx_use_stderr ;
#line 146 "src/core/ngx_file.h"
ngx_int_t ngx_create_paths(ngx_cycle_t *cycle , ngx_uid_t user ) ;
#line 63 "src/core/ngx_slab.h"
void ngx_slab_init(ngx_slab_pool_t *pool ) ;
#line 126 "src/core/ngx_cycle.h"
ngx_int_t ngx_create_pidfile(ngx_str_t *name , ngx_log_t *log ) ;
#line 128
ngx_int_t ngx_signal_process(ngx_cycle_t *cycle , char *sig ) ;
#line 138 "src/core/ngx_cycle.h"
ngx_cycle_t volatile   *ngx_cycle  ;
#line 139 "src/core/ngx_cycle.h"
ngx_array_t ngx_old_cycles  ;
#line 141 "src/core/ngx_cycle.h"
ngx_uint_t ngx_test_config  ;
#line 142 "src/core/ngx_cycle.h"
ngx_uint_t ngx_dump_config  ;
#line 143 "src/core/ngx_cycle.h"
ngx_uint_t ngx_quiet_mode  ;
#line 210 "src/core/ngx_connection.h"
ngx_int_t ngx_open_listening_sockets(ngx_cycle_t *cycle ) ;
#line 211
void ngx_configure_listening_sockets(ngx_cycle_t *cycle ) ;
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static void ngx_destroy_cycle_pools(ngx_conf_t *conf ) ;
#line 14
static ngx_int_t ngx_init_zone_pool(ngx_cycle_t *cycle , ngx_shm_zone_t *zn ) ;
#line 16
static ngx_int_t ngx_test_lockfile(u_char *file , ngx_log_t *log ) ;
#line 17
static void ngx_clean_old_cycles(ngx_event_t *ev ) ;
#line 18
static void ngx_shutdown_timer_handler(ngx_event_t *ev ) ;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static ngx_pool_t *ngx_temp_pool  ;
#line 25 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static ngx_event_t ngx_cleaner_event  ;
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static ngx_event_t ngx_shutdown_event  ;
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static ngx_connection_t dumb  ;
#line 38 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
ngx_cycle_t *ngx_init_cycle(ngx_cycle_t *old_cycle ) 
{ 
  void *rv ;
  char **senv ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_log_t *log ;
  ngx_time_t *tp ;
  ngx_conf_t conf ;
  ngx_pool_t *pool ;
  ngx_cycle_t *cycle ;
  ngx_cycle_t **old ;
  ngx_shm_zone_t *shm_zone ;
  ngx_shm_zone_t *oshm_zone ;
  ngx_list_part_t *part ;
  ngx_list_part_t *opart ;
  ngx_open_file_t *file ;
  ngx_listening_t *ls ;
  ngx_listening_t *nls ;
  ngx_core_conf_t *ccf ;
  ngx_core_conf_t *old_ccf ;
  ngx_core_module_t *module ;
  char hostname[256] ;
  void *tmp ;
  void *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  void *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  ngx_int_t tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  ngx_int_t tmp___14 ;
  ngx_int_t tmp___15 ;
  int tmp___16 ;
  ngx_int_t tmp___17 ;
  ngx_int_t tmp___18 ;
  ngx_int_t tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  ngx_int_t tmp___24 ;
  ngx_int_t tmp___25 ;
  ngx_int_t tmp___26 ;
  ngx_int_t tmp___27 ;
  ngx_int_t tmp___28 ;
  ngx_int_t tmp___29 ;
  ngx_int_t tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  int tmp___33 ;
  u_char *name ;
  int *tmp___34 ;
  int tmp___35 ;
  int *tmp___36 ;
  int tmp___37 ;
  ngx_int_t tmp___38 ;
  void *tmp___39 ;
  int *tmp___40 ;
  int tmp___41 ;
  int *tmp___42 ;
  int tmp___43 ;
  void *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;

  {
  {
#line 57
  ngx_timezone_update();
#line 61
  tp = (ngx_time_t *)ngx_cached_time;
#line 62
  tp->sec = (time_t )0;
#line 64
  ngx_time_update();
#line 67
  log = old_cycle->log;
#line 69
  pool = ngx_create_pool((size_t )16384, log);
  }
#line 70
  if ((unsigned long )pool == (unsigned long )((void *)0)) {
#line 71
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 73
  pool->log = log;
#line 75
  tmp = ngx_pcalloc(pool, sizeof(ngx_cycle_t ));
#line 75
  cycle = (ngx_cycle_t *)tmp;
  }
#line 76
  if ((unsigned long )cycle == (unsigned long )((void *)0)) {
    {
#line 77
    ngx_destroy_pool(pool);
    }
#line 78
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 81
  cycle->pool = pool;
#line 82
  cycle->log = log;
#line 83
  cycle->old_cycle = old_cycle;
#line 85
  cycle->conf_prefix.len = old_cycle->conf_prefix.len;
#line 86
  cycle->conf_prefix.data = ngx_pstrdup(pool, & old_cycle->conf_prefix);
  }
#line 87
  if ((unsigned long )cycle->conf_prefix.data == (unsigned long )((void *)0)) {
    {
#line 88
    ngx_destroy_pool(pool);
    }
#line 89
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 92
  cycle->prefix.len = old_cycle->prefix.len;
#line 93
  cycle->prefix.data = ngx_pstrdup(pool, & old_cycle->prefix);
  }
#line 94
  if ((unsigned long )cycle->prefix.data == (unsigned long )((void *)0)) {
    {
#line 95
    ngx_destroy_pool(pool);
    }
#line 96
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 99
  cycle->conf_file.len = old_cycle->conf_file.len;
#line 100
  tmp___0 = ngx_pnalloc(pool, old_cycle->conf_file.len + 1UL);
#line 100
  cycle->conf_file.data = (u_char *)tmp___0;
  }
#line 101
  if ((unsigned long )cycle->conf_file.data == (unsigned long )((void *)0)) {
    {
#line 102
    ngx_destroy_pool(pool);
    }
#line 103
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 105
  ngx_cpystrn(cycle->conf_file.data, old_cycle->conf_file.data, old_cycle->conf_file.len + 1UL);
#line 108
  cycle->conf_param.len = old_cycle->conf_param.len;
#line 109
  cycle->conf_param.data = ngx_pstrdup(pool, & old_cycle->conf_param);
  }
#line 110
  if ((unsigned long )cycle->conf_param.data == (unsigned long )((void *)0)) {
    {
#line 111
    ngx_destroy_pool(pool);
    }
#line 112
    return ((ngx_cycle_t *)((void *)0));
  }
#line 116
  if (old_cycle->paths.nelts) {
#line 116
    n = old_cycle->paths.nelts;
  } else {
#line 116
    n = (ngx_uint_t )10;
  }
  {
#line 118
  tmp___1 = ngx_array_init(& cycle->paths, pool, n, sizeof(ngx_path_t *));
  }
#line 118
  if (tmp___1 != 0L) {
    {
#line 121
    ngx_destroy_pool(pool);
    }
#line 122
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 125
  memset(cycle->paths.elts, 0, n * sizeof(ngx_path_t *));
#line 128
  tmp___2 = ngx_array_init(& cycle->config_dump, pool, (ngx_uint_t )1, sizeof(ngx_conf_dump_t ));
  }
#line 128
  if (tmp___2 != 0L) {
    {
#line 131
    ngx_destroy_pool(pool);
    }
#line 132
    return ((ngx_cycle_t *)((void *)0));
  }
#line 135
  cycle->config_dump_sentinel.color = (u_char )0;
#line 135
  cycle->config_dump_rbtree.root = & cycle->config_dump_sentinel;
#line 135
  cycle->config_dump_rbtree.sentinel = & cycle->config_dump_sentinel;
#line 135
  cycle->config_dump_rbtree.insert = & ngx_str_rbtree_insert_value;
#line 138
  if (old_cycle->open_files.part.nelts) {
#line 139
    n = old_cycle->open_files.part.nelts;
#line 140
    part = old_cycle->open_files.part.next;
    {
#line 140
    while (1) {
      while_continue: /* CIL Label */ ;
#line 140
      if (! part) {
#line 140
        goto while_break;
      }
#line 141
      n += part->nelts;
#line 140
      part = part->next;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 145
    n = (ngx_uint_t )20;
  }
  {
#line 148
  tmp___3 = ngx_list_init(& cycle->open_files, pool, n, sizeof(ngx_open_file_t ));
  }
#line 148
  if (tmp___3 != 0L) {
    {
#line 151
    ngx_destroy_pool(pool);
    }
#line 152
    return ((ngx_cycle_t *)((void *)0));
  }
#line 156
  if (old_cycle->shared_memory.part.nelts) {
#line 157
    n = old_cycle->shared_memory.part.nelts;
#line 158
    part = old_cycle->shared_memory.part.next;
    {
#line 158
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 158
      if (! part) {
#line 158
        goto while_break___0;
      }
#line 160
      n += part->nelts;
#line 158
      part = part->next;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 164
    n = (ngx_uint_t )1;
  }
  {
#line 167
  tmp___4 = ngx_list_init(& cycle->shared_memory, pool, n, sizeof(ngx_shm_zone_t ));
  }
#line 167
  if (tmp___4 != 0L) {
    {
#line 170
    ngx_destroy_pool(pool);
    }
#line 171
    return ((ngx_cycle_t *)((void *)0));
  }
#line 174
  if (old_cycle->listening.nelts) {
#line 174
    n = old_cycle->listening.nelts;
  } else {
#line 174
    n = (ngx_uint_t )10;
  }
  {
#line 176
  tmp___5 = ngx_array_init(& cycle->listening, pool, n, sizeof(ngx_listening_t ));
  }
#line 176
  if (tmp___5 != 0L) {
    {
#line 179
    ngx_destroy_pool(pool);
    }
#line 180
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 183
  memset(cycle->listening.elts, 0, n * sizeof(ngx_listening_t ));
#line 186
  cycle->reusable_connections_queue.prev = & cycle->reusable_connections_queue;
#line 186
  cycle->reusable_connections_queue.next = & cycle->reusable_connections_queue;
#line 189
  tmp___6 = ngx_pcalloc(pool, ngx_max_module * sizeof(void *));
#line 189
  cycle->conf_ctx = (void ****)tmp___6;
  }
#line 190
  if ((unsigned long )cycle->conf_ctx == (unsigned long )((void *)0)) {
    {
#line 191
    ngx_destroy_pool(pool);
    }
#line 192
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 196
  tmp___8 = gethostname(hostname, (size_t )256);
  }
#line 196
  if (tmp___8 == -1) {
#line 197
    if (log->log_level >= 1UL) {
      {
#line 197
      tmp___7 = __errno_location();
#line 197
      ngx_log_error_core((ngx_uint_t )1, log, *tmp___7, "gethostname() failed");
      }
    }
    {
#line 198
    ngx_destroy_pool(pool);
    }
#line 199
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 204
  hostname[255] = (char )'\000';
#line 205
  cycle->hostname.len = strlen((char const   *)(hostname));
#line 207
  tmp___9 = ngx_pnalloc(pool, cycle->hostname.len);
#line 207
  cycle->hostname.data = (u_char *)tmp___9;
  }
#line 208
  if ((unsigned long )cycle->hostname.data == (unsigned long )((void *)0)) {
    {
#line 209
    ngx_destroy_pool(pool);
    }
#line 210
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 213
  ngx_strlow(cycle->hostname.data, (u_char *)(hostname), cycle->hostname.len);
#line 216
  tmp___10 = ngx_cycle_modules(cycle);
  }
#line 216
  if (tmp___10 != 0L) {
    {
#line 217
    ngx_destroy_pool(pool);
    }
#line 218
    return ((ngx_cycle_t *)((void *)0));
  }
#line 222
  i = (ngx_uint_t )0;
  {
#line 222
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 222
    if (! *(cycle->modules + i)) {
#line 222
      goto while_break___1;
    }
#line 223
    if ((*(cycle->modules + i))->type != 1163022147UL) {
#line 224
      goto __Cont;
    }
#line 227
    module = (ngx_core_module_t *)(*(cycle->modules + i))->ctx;
#line 229
    if (module->create_conf) {
      {
#line 230
      rv = (*(module->create_conf))(cycle);
      }
#line 231
      if ((unsigned long )rv == (unsigned long )((void *)0)) {
        {
#line 232
        ngx_destroy_pool(pool);
        }
#line 233
        return ((ngx_cycle_t *)((void *)0));
      }
#line 235
      *(cycle->conf_ctx + (*(cycle->modules + i))->index) = (void ***)rv;
    }
    __Cont: /* CIL Label */ 
#line 222
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 240
  senv = environ;
#line 243
  memset((void *)(& conf), 0, sizeof(ngx_conf_t ));
#line 245
  conf.args = ngx_array_create(pool, (ngx_uint_t )10, sizeof(ngx_str_t ));
  }
#line 246
  if ((unsigned long )conf.args == (unsigned long )((void *)0)) {
    {
#line 247
    ngx_destroy_pool(pool);
    }
#line 248
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 251
  conf.temp_pool = ngx_create_pool((size_t )16384, log);
  }
#line 252
  if ((unsigned long )conf.temp_pool == (unsigned long )((void *)0)) {
    {
#line 253
    ngx_destroy_pool(pool);
    }
#line 254
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 258
  conf.ctx = (void *)cycle->conf_ctx;
#line 259
  conf.cycle = cycle;
#line 260
  conf.pool = pool;
#line 261
  conf.log = log;
#line 262
  conf.module_type = (ngx_uint_t )1163022147;
#line 263
  conf.cmd_type = (ngx_uint_t )16777216;
#line 269
  tmp___11 = ngx_conf_param(& conf);
  }
#line 269
  if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
    {
#line 270
    environ = senv;
#line 271
    ngx_destroy_cycle_pools(& conf);
    }
#line 272
    return ((ngx_cycle_t *)((void *)0));
  }
  {
#line 275
  tmp___12 = ngx_conf_parse(& conf, & cycle->conf_file);
  }
#line 275
  if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
    {
#line 276
    environ = senv;
#line 277
    ngx_destroy_cycle_pools(& conf);
    }
#line 278
    return ((ngx_cycle_t *)((void *)0));
  }
#line 281
  if (ngx_test_config) {
#line 281
    if (! ngx_quiet_mode) {
      {
#line 282
      ngx_log_stderr(0, "the configuration file %s syntax is ok", cycle->conf_file.data);
      }
    }
  }
#line 286
  i = (ngx_uint_t )0;
  {
#line 286
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 286
    if (! *(cycle->modules + i)) {
#line 286
      goto while_break___2;
    }
#line 287
    if ((*(cycle->modules + i))->type != 1163022147UL) {
#line 288
      goto __Cont___0;
    }
#line 291
    module = (ngx_core_module_t *)(*(cycle->modules + i))->ctx;
#line 293
    if (module->init_conf) {
      {
#line 294
      tmp___13 = (*(module->init_conf))(cycle, (void *)*(cycle->conf_ctx + (*(cycle->modules + i))->index));
      }
#line 294
      if ((unsigned long )tmp___13 == (unsigned long )((void *)-1)) {
        {
#line 298
        environ = senv;
#line 299
        ngx_destroy_cycle_pools(& conf);
        }
#line 300
        return ((ngx_cycle_t *)((void *)0));
      }
    }
    __Cont___0: /* CIL Label */ 
#line 286
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 305
  if (ngx_process == 2UL) {
#line 306
    return (cycle);
  }
#line 309
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 311
  if (ngx_test_config) {
    {
#line 313
    tmp___14 = ngx_create_pidfile(& ccf->pid, log);
    }
#line 313
    if (tmp___14 != 0L) {
#line 314
      goto failed;
    }
  } else
#line 317
  if (! ((unsigned long )old_cycle->conf_ctx == (unsigned long )((void *)0))) {
#line 324
    old_ccf = (ngx_core_conf_t *)*(old_cycle->conf_ctx + ngx_core_module.index);
#line 326
    if (ccf->pid.len != old_ccf->pid.len) {
#line 326
      goto _L;
    } else {
      {
#line 326
      tmp___16 = strcmp((char const   *)ccf->pid.data, (char const   *)old_ccf->pid.data);
      }
#line 326
      if (tmp___16 != 0) {
        _L: /* CIL Label */ 
        {
#line 331
        tmp___15 = ngx_create_pidfile(& ccf->pid, log);
        }
#line 331
        if (tmp___15 != 0L) {
#line 332
          goto failed;
        }
        {
#line 335
        ngx_delete_pidfile(old_cycle);
        }
      }
    }
  }
  {
#line 340
  tmp___17 = ngx_test_lockfile(cycle->lock_file.data, log);
  }
#line 340
  if (tmp___17 != 0L) {
#line 341
    goto failed;
  }
  {
#line 345
  tmp___18 = ngx_create_paths(cycle, ccf->user);
  }
#line 345
  if (tmp___18 != 0L) {
#line 346
    goto failed;
  }
  {
#line 350
  tmp___19 = ngx_log_open_default(cycle);
  }
#line 350
  if (tmp___19 != 0L) {
#line 351
    goto failed;
  }
#line 356
  part = & cycle->open_files.part;
#line 357
  file = (ngx_open_file_t *)part->elts;
#line 359
  i = (ngx_uint_t )0;
  {
#line 359
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 361
    if (i >= part->nelts) {
#line 362
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 363
        goto while_break___3;
      }
#line 365
      part = part->next;
#line 366
      file = (ngx_open_file_t *)part->elts;
#line 367
      i = (ngx_uint_t )0;
    }
#line 370
    if ((file + i)->name.len == 0UL) {
#line 371
      goto __Cont___1;
    }
    {
#line 374
    (file + i)->fd = open((char const   *)(file + i)->name.data, 1089, 420);
    }
#line 383
    if ((file + i)->fd == -1) {
#line 384
      if (log->log_level >= 1UL) {
        {
#line 384
        tmp___20 = __errno_location();
#line 384
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___20, "open() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
#line 387
      goto failed;
    }
    {
#line 391
    tmp___22 = fcntl((file + i)->fd, 2, 1);
    }
#line 391
    if (tmp___22 == -1) {
#line 392
      if (log->log_level >= 1UL) {
        {
#line 392
        tmp___21 = __errno_location();
#line 392
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___21, "fcntl(FD_CLOEXEC) \"%s\" failed",
                           (file + i)->name.data);
        }
      }
#line 395
      goto failed;
    }
    __Cont___1: /* CIL Label */ 
#line 359
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 400
  cycle->log = & cycle->new_log;
#line 401
  pool->log = & cycle->new_log;
#line 406
  part = & cycle->shared_memory.part;
#line 407
  shm_zone = (ngx_shm_zone_t *)part->elts;
#line 409
  i = (ngx_uint_t )0;
  {
#line 409
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 411
    if (i >= part->nelts) {
#line 412
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 413
        goto while_break___4;
      }
#line 415
      part = part->next;
#line 416
      shm_zone = (ngx_shm_zone_t *)part->elts;
#line 417
      i = (ngx_uint_t )0;
    }
#line 420
    if ((shm_zone + i)->shm.size == 0UL) {
#line 421
      if (log->log_level >= 1UL) {
        {
#line 421
        ngx_log_error_core((ngx_uint_t )1, log, 0, "zero size shared memory zone \"%V\"",
                           & (shm_zone + i)->shm.name);
        }
      }
#line 424
      goto failed;
    }
#line 427
    (shm_zone + i)->shm.log = cycle->log;
#line 429
    opart = & old_cycle->shared_memory.part;
#line 430
    oshm_zone = (ngx_shm_zone_t *)opart->elts;
#line 432
    n = (ngx_uint_t )0;
    {
#line 432
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 434
      if (n >= opart->nelts) {
#line 435
        if ((unsigned long )opart->next == (unsigned long )((void *)0)) {
#line 436
          goto while_break___5;
        }
#line 438
        opart = opart->next;
#line 439
        oshm_zone = (ngx_shm_zone_t *)opart->elts;
#line 440
        n = (ngx_uint_t )0;
      }
#line 443
      if ((shm_zone + i)->shm.name.len != (oshm_zone + n)->shm.name.len) {
#line 444
        goto __Cont___2;
      }
      {
#line 447
      tmp___23 = strncmp((char const   *)(shm_zone + i)->shm.name.data, (char const   *)(oshm_zone + n)->shm.name.data,
                         (shm_zone + i)->shm.name.len);
      }
#line 447
      if (tmp___23 != 0) {
#line 452
        goto __Cont___2;
      }
#line 455
      if ((unsigned long )(shm_zone + i)->tag == (unsigned long )(oshm_zone + n)->tag) {
#line 455
        if ((shm_zone + i)->shm.size == (oshm_zone + n)->shm.size) {
#line 455
          if (! (shm_zone + i)->noreuse) {
            {
#line 459
            (shm_zone + i)->shm.addr = (oshm_zone + n)->shm.addr;
#line 464
            tmp___24 = (*((shm_zone + i)->init))(shm_zone + i, (oshm_zone + n)->data);
            }
#line 464
            if (tmp___24 != 0L) {
#line 467
              goto failed;
            }
#line 470
            goto shm_zone_found;
          }
        }
      }
#line 473
      goto while_break___5;
      __Cont___2: /* CIL Label */ 
#line 432
      n ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 476
    tmp___25 = ngx_shm_alloc(& (shm_zone + i)->shm);
    }
#line 476
    if (tmp___25 != 0L) {
#line 477
      goto failed;
    }
    {
#line 480
    tmp___26 = ngx_init_zone_pool(cycle, shm_zone + i);
    }
#line 480
    if (tmp___26 != 0L) {
#line 481
      goto failed;
    }
    {
#line 484
    tmp___27 = (*((shm_zone + i)->init))(shm_zone + i, (void *)0);
    }
#line 484
    if (tmp___27 != 0L) {
#line 485
      goto failed;
    }
    shm_zone_found: 
#line 490
    goto __Cont___3;
    __Cont___3: /* CIL Label */ 
#line 409
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 496
  if (old_cycle->listening.nelts) {
#line 497
    ls = (ngx_listening_t *)old_cycle->listening.elts;
#line 498
    i = (ngx_uint_t )0;
    {
#line 498
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 498
      if (! (i < old_cycle->listening.nelts)) {
#line 498
        goto while_break___6;
      }
#line 499
      (ls + i)->remain = 0U;
#line 498
      i ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 502
    nls = (ngx_listening_t *)cycle->listening.elts;
#line 503
    n = (ngx_uint_t )0;
    {
#line 503
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 503
      if (! (n < cycle->listening.nelts)) {
#line 503
        goto while_break___7;
      }
#line 505
      i = (ngx_uint_t )0;
      {
#line 505
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 505
        if (! (i < old_cycle->listening.nelts)) {
#line 505
          goto while_break___8;
        }
#line 506
        if ((ls + i)->ignore) {
#line 507
          goto __Cont___4;
        }
#line 510
        if ((ls + i)->remain) {
#line 511
          goto __Cont___4;
        }
#line 514
        if ((ls + i)->type != (nls + n)->type) {
#line 515
          goto __Cont___4;
        }
        {
#line 518
        tmp___28 = ngx_cmp_sockaddr((nls + n)->sockaddr, (nls + n)->socklen, (ls + i)->sockaddr,
                                    (ls + i)->socklen, (ngx_uint_t )1);
        }
#line 518
        if (tmp___28 == 0L) {
#line 522
          (nls + n)->fd = (ls + i)->fd;
#line 523
          (nls + n)->previous = ls + i;
#line 524
          (ls + i)->remain = 1U;
#line 526
          if ((ls + i)->backlog != (nls + n)->backlog) {
#line 527
            (nls + n)->listen = 1U;
          }
#line 557
          if ((ls + i)->deferred_accept) {
#line 557
            if (! (nls + n)->deferred_accept) {
#line 558
              (nls + n)->delete_deferred = 1U;
            } else {
#line 557
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 560
          if ((ls + i)->deferred_accept != (nls + n)->deferred_accept) {
#line 562
            (nls + n)->add_deferred = 1U;
          }
#line 567
          if ((nls + n)->reuseport) {
#line 567
            if (! (ls + i)->reuseport) {
#line 568
              (nls + n)->add_reuseport = 1U;
            }
          }
#line 572
          goto while_break___8;
        }
        __Cont___4: /* CIL Label */ 
#line 505
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 576
      if ((nls + n)->fd == -1) {
#line 577
        (nls + n)->open = 1U;
#line 584
        if ((nls + n)->deferred_accept) {
#line 585
          (nls + n)->add_deferred = 1U;
        }
      }
#line 503
      n ++;
    }
    while_break___7: /* CIL Label */ ;
    }
  } else {
#line 592
    ls = (ngx_listening_t *)cycle->listening.elts;
#line 593
    i = (ngx_uint_t )0;
    {
#line 593
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 593
      if (! (i < cycle->listening.nelts)) {
#line 593
        goto while_break___9;
      }
#line 594
      (ls + i)->open = 1U;
#line 601
      if ((ls + i)->deferred_accept) {
#line 602
        (ls + i)->add_deferred = 1U;
      }
#line 593
      i ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  {
#line 608
  tmp___29 = ngx_open_listening_sockets(cycle);
  }
#line 608
  if (tmp___29 != 0L) {
#line 609
    goto failed;
  }
#line 612
  if (! ngx_test_config) {
    {
#line 613
    ngx_configure_listening_sockets(cycle);
    }
  }
#line 619
  if (! ngx_use_stderr) {
    {
#line 620
    ngx_log_redirect_stderr(cycle);
    }
  }
  {
#line 623
  pool->log = cycle->log;
#line 625
  tmp___30 = ngx_init_modules(cycle);
  }
#line 625
  if (tmp___30 != 0L) {
    {
#line 627
    exit(1);
    }
  }
#line 635
  opart = & old_cycle->shared_memory.part;
#line 636
  oshm_zone = (ngx_shm_zone_t *)opart->elts;
#line 638
  i = (ngx_uint_t )0;
  {
#line 638
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 640
    if (i >= opart->nelts) {
#line 641
      if ((unsigned long )opart->next == (unsigned long )((void *)0)) {
#line 642
        goto old_shm_zone_done;
      }
#line 644
      opart = opart->next;
#line 645
      oshm_zone = (ngx_shm_zone_t *)opart->elts;
#line 646
      i = (ngx_uint_t )0;
    }
#line 649
    part = & cycle->shared_memory.part;
#line 650
    shm_zone = (ngx_shm_zone_t *)part->elts;
#line 652
    n = (ngx_uint_t )0;
    {
#line 652
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 654
      if (n >= part->nelts) {
#line 655
        if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 656
          goto while_break___11;
        }
#line 658
        part = part->next;
#line 659
        shm_zone = (ngx_shm_zone_t *)part->elts;
#line 660
        n = (ngx_uint_t )0;
      }
#line 663
      if ((oshm_zone + i)->shm.name.len != (shm_zone + n)->shm.name.len) {
#line 664
        goto __Cont___5;
      }
      {
#line 667
      tmp___31 = strncmp((char const   *)(oshm_zone + i)->shm.name.data, (char const   *)(shm_zone + n)->shm.name.data,
                         (oshm_zone + i)->shm.name.len);
      }
#line 667
      if (tmp___31 != 0) {
#line 672
        goto __Cont___5;
      }
#line 675
      if ((unsigned long )(oshm_zone + i)->tag == (unsigned long )(shm_zone + n)->tag) {
#line 675
        if ((oshm_zone + i)->shm.size == (shm_zone + n)->shm.size) {
#line 675
          if (! (oshm_zone + i)->noreuse) {
#line 679
            goto live_shm_zone;
          }
        }
      }
#line 682
      goto while_break___11;
      __Cont___5: /* CIL Label */ 
#line 652
      n ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 685
    ngx_shm_free(& (oshm_zone + i)->shm);
    }
    live_shm_zone: 
#line 689
    goto __Cont___6;
    __Cont___6: /* CIL Label */ 
#line 638
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  old_shm_zone_done: 
#line 697
  ls = (ngx_listening_t *)old_cycle->listening.elts;
#line 698
  i = (ngx_uint_t )0;
  {
#line 698
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 698
    if (! (i < old_cycle->listening.nelts)) {
#line 698
      goto while_break___12;
    }
#line 700
    if ((ls + i)->remain) {
#line 701
      goto __Cont___7;
    } else
#line 700
    if ((ls + i)->fd == -1) {
#line 701
      goto __Cont___7;
    }
    {
#line 704
    tmp___33 = close((ls + i)->fd);
    }
#line 704
    if (tmp___33 == -1) {
#line 705
      if (log->log_level >= 1UL) {
        {
#line 705
        tmp___32 = __errno_location();
#line 705
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___32, "close() socket listening socket on %V failed",
                           & (ls + i)->addr_text);
        }
      }
    }
#line 712
    if ((int )((ls + i)->sockaddr)->sa_family == 1) {
#line 715
      name = ((ls + i)->addr_text.data + sizeof("unix:")) - 1;
#line 717
      if ((cycle->log)->log_level >= 5UL) {
        {
#line 717
        ngx_log_error_core((ngx_uint_t )5, cycle->log, 0, "deleting socket %s", name);
        }
      }
      {
#line 720
      tmp___35 = unlink((char const   *)name);
      }
#line 720
      if (tmp___35 == -1) {
#line 721
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 721
          tmp___34 = __errno_location();
#line 721
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___34, "unlink() %s failed",
                             name);
          }
        }
      }
    }
    __Cont___7: /* CIL Label */ 
#line 698
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 732
  part = & old_cycle->open_files.part;
#line 733
  file = (ngx_open_file_t *)part->elts;
#line 735
  i = (ngx_uint_t )0;
  {
#line 735
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 737
    if (i >= part->nelts) {
#line 738
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 739
        goto while_break___13;
      }
#line 741
      part = part->next;
#line 742
      file = (ngx_open_file_t *)part->elts;
#line 743
      i = (ngx_uint_t )0;
    }
#line 746
    if ((file + i)->fd == -1) {
#line 747
      goto __Cont___8;
    } else
#line 746
    if ((file + i)->fd == 2) {
#line 747
      goto __Cont___8;
    }
    {
#line 750
    tmp___37 = close((file + i)->fd);
    }
#line 750
    if (tmp___37 == -1) {
#line 751
      if (log->log_level >= 1UL) {
        {
#line 751
        tmp___36 = __errno_location();
#line 751
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___36, "close() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
    }
    __Cont___8: /* CIL Label */ 
#line 735
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 757
  ngx_destroy_pool(conf.temp_pool);
  }
#line 759
  if (ngx_process == 1UL) {
    {
#line 761
    ngx_destroy_pool(old_cycle->pool);
#line 762
    cycle->old_cycle = (ngx_cycle_t *)((void *)0);
    }
#line 764
    return (cycle);
  } else
#line 759
  if ((unsigned long )old_cycle->conf_ctx == (unsigned long )((void *)0)) {
    {
#line 761
    ngx_destroy_pool(old_cycle->pool);
#line 762
    cycle->old_cycle = (ngx_cycle_t *)((void *)0);
    }
#line 764
    return (cycle);
  }
#line 768
  if ((unsigned long )ngx_temp_pool == (unsigned long )((void *)0)) {
    {
#line 769
    ngx_temp_pool = ngx_create_pool((size_t )128, cycle->log);
    }
#line 770
    if ((unsigned long )ngx_temp_pool == (unsigned long )((void *)0)) {
#line 771
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 771
        ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "could not create ngx_temp_pool");
        }
      }
      {
#line 773
      exit(1);
      }
    }
    {
#line 776
    n = (ngx_uint_t )10;
#line 778
    tmp___38 = ngx_array_init(& ngx_old_cycles, ngx_temp_pool, n, sizeof(ngx_cycle_t *));
    }
#line 778
    if (tmp___38 != 0L) {
      {
#line 782
      exit(1);
      }
    }
    {
#line 785
    memset(ngx_old_cycles.elts, 0, n * sizeof(ngx_cycle_t *));
#line 787
    ngx_cleaner_event.handler = & ngx_clean_old_cycles;
#line 788
    ngx_cleaner_event.log = cycle->log;
#line 789
    ngx_cleaner_event.data = (void *)(& dumb);
#line 790
    dumb.fd = -1;
    }
  }
  {
#line 793
  ngx_temp_pool->log = cycle->log;
#line 795
  tmp___39 = ngx_array_push(& ngx_old_cycles);
#line 795
  old = (ngx_cycle_t **)tmp___39;
  }
#line 796
  if ((unsigned long )old == (unsigned long )((void *)0)) {
    {
#line 797
    exit(1);
    }
  }
#line 799
  *old = old_cycle;
#line 801
  if (! ngx_cleaner_event.timer_set) {
    {
#line 802
    ngx_event_add_timer(& ngx_cleaner_event, (ngx_msec_t )30000);
#line 803
    ngx_cleaner_event.timer_set = 1U;
    }
  }
#line 806
  return (cycle);
  failed: 
#line 811
  if (! ((unsigned long )old_cycle->conf_ctx == (unsigned long )((void *)0))) {
#line 812
    old_ccf = (ngx_core_conf_t *)*(old_cycle->conf_ctx + ngx_core_module.index);
#line 814
    if (old_ccf->environment) {
#line 815
      environ = old_ccf->environment;
    }
  }
#line 821
  part = & cycle->open_files.part;
#line 822
  file = (ngx_open_file_t *)part->elts;
#line 824
  i = (ngx_uint_t )0;
  {
#line 824
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 826
    if (i >= part->nelts) {
#line 827
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 828
        goto while_break___14;
      }
#line 830
      part = part->next;
#line 831
      file = (ngx_open_file_t *)part->elts;
#line 832
      i = (ngx_uint_t )0;
    }
#line 835
    if ((file + i)->fd == -1) {
#line 836
      goto __Cont___9;
    } else
#line 835
    if ((file + i)->fd == 2) {
#line 836
      goto __Cont___9;
    }
    {
#line 839
    tmp___41 = close((file + i)->fd);
    }
#line 839
    if (tmp___41 == -1) {
#line 840
      if (log->log_level >= 1UL) {
        {
#line 840
        tmp___40 = __errno_location();
#line 840
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___40, "close() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
    }
    __Cont___9: /* CIL Label */ 
#line 824
    i ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 846
  if (ngx_test_config) {
    {
#line 847
    ngx_destroy_cycle_pools(& conf);
    }
#line 848
    return ((ngx_cycle_t *)((void *)0));
  }
#line 851
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 852
  i = (ngx_uint_t )0;
  {
#line 852
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 852
    if (! (i < cycle->listening.nelts)) {
#line 852
      goto while_break___15;
    }
#line 853
    if ((ls + i)->fd == -1) {
#line 854
      goto __Cont___10;
    } else
#line 853
    if (! (ls + i)->open) {
#line 854
      goto __Cont___10;
    }
    {
#line 857
    tmp___43 = close((ls + i)->fd);
    }
#line 857
    if (tmp___43 == -1) {
#line 858
      if (log->log_level >= 1UL) {
        {
#line 858
        tmp___42 = __errno_location();
#line 858
        ngx_log_error_core((ngx_uint_t )1, log, *tmp___42, "close() socket %V failed",
                           & (ls + i)->addr_text);
        }
      }
    }
    __Cont___10: /* CIL Label */ 
#line 852
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 864
  ngx_destroy_cycle_pools(& conf);
  }
#line 866
  return ((ngx_cycle_t *)((void *)0));
}
}
#line 870 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static void ngx_destroy_cycle_pools(ngx_conf_t *conf ) 
{ 


  {
  {
#line 873
  ngx_destroy_pool(conf->temp_pool);
#line 874
  ngx_destroy_pool(conf->pool);
  }
#line 875
  return;
}
}
#line 878 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static ngx_int_t ngx_init_zone_pool(ngx_cycle_t *cycle , ngx_shm_zone_t *zn ) 
{ 
  u_char *file ;
  ngx_slab_pool_t *sp ;
  ngx_int_t tmp ;
  char *__cil_tmp6 ;

  {
#line 884
  sp = (ngx_slab_pool_t *)zn->shm.addr;
#line 886
  if (zn->shm.exists) {
#line 888
    if ((unsigned long )sp == (unsigned long )sp->addr) {
#line 889
      return ((ngx_int_t )0);
    }
#line 908
    if ((cycle->log)->log_level >= 1UL) {
      {
#line 908
      ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "shared zone \"%V\" has no equal addresses: %p vs %p",
                         & zn->shm.name, sp->addr, sp);
      }
    }
#line 911
    return ((ngx_int_t )-1);
  }
  {
#line 914
  sp->end = zn->shm.addr + zn->shm.size;
#line 915
  sp->min_shift = (size_t )3;
#line 916
  sp->addr = (void *)zn->shm.addr;
#line 920
  file = (u_char *)((void *)0);
#line 933
  tmp = ngx_shmtx_create(& sp->mutex, & sp->lock, file);
  }
#line 933
  if (tmp != 0L) {
#line 934
    return ((ngx_int_t )-1);
  }
  {
#line 937
  ngx_slab_init(sp);
  }
#line 939
  return ((ngx_int_t )0);
}
}
#line 943 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
ngx_int_t ngx_create_pidfile(ngx_str_t *name , ngx_log_t *log ) 
{ 
  size_t len ;
  ngx_uint_t create ;
  ngx_file_t file ;
  u_char pid[(sizeof("-9223372036854775808") - 1UL) + 2UL] ;
  int *tmp ;
  u_char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 951
  if (ngx_process > 1UL) {
#line 952
    return ((ngx_int_t )0);
  }
  {
#line 955
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 957
  file.name = *name;
#line 958
  file.log = log;
  }
#line 960
  if (ngx_test_config) {
#line 960
    create = (ngx_uint_t )64;
  } else {
#line 960
    create = (ngx_uint_t )576;
  }
  {
#line 962
  file.fd = open((char const   *)file.name.data, (int )(2UL | create), 420);
  }
#line 965
  if (file.fd == -1) {
#line 966
    if (log->log_level >= 1UL) {
      {
#line 966
      tmp = __errno_location();
#line 966
      ngx_log_error_core((ngx_uint_t )1, log, *tmp, "open() \"%s\" failed", file.name.data);
      }
    }
#line 968
    return ((ngx_int_t )-1);
  }
#line 971
  if (! ngx_test_config) {
    {
#line 972
    tmp___0 = ngx_snprintf(pid, (sizeof("-9223372036854775808") - 1UL) + 2UL, "%P%N",
                           ngx_pid);
#line 972
    len = (size_t )(tmp___0 - pid);
#line 974
    tmp___1 = ngx_write_file(& file, pid, len, (off_t )0);
    }
#line 974
    if (tmp___1 == -1L) {
#line 975
      return ((ngx_int_t )-1);
    }
  }
  {
#line 979
  tmp___3 = close(file.fd);
  }
#line 979
  if (tmp___3 == -1) {
#line 980
    if (log->log_level >= 2UL) {
      {
#line 980
      tmp___2 = __errno_location();
#line 980
      ngx_log_error_core((ngx_uint_t )2, log, *tmp___2, "close() \"%s\" failed", file.name.data);
      }
    }
  }
#line 984
  return ((ngx_int_t )0);
}
}
#line 988 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
void ngx_delete_pidfile(ngx_cycle_t *cycle ) 
{ 
  u_char *name ;
  ngx_core_conf_t *ccf ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 994
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 996
  if (ngx_new_binary) {
#line 996
    name = ccf->oldpid.data;
  } else {
#line 996
    name = ccf->pid.data;
  }
  {
#line 998
  tmp___0 = unlink((char const   *)name);
  }
#line 998
  if (tmp___0 == -1) {
#line 999
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 999
      tmp = __errno_location();
#line 999
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "unlink() \"%s\" failed",
                         name);
      }
    }
  }
#line 1002
  return;
}
}
#line 1005 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
ngx_int_t ngx_signal_process(ngx_cycle_t *cycle , char *sig ) 
{ 
  ssize_t n ;
  ngx_pid_t pid ;
  ngx_file_t file ;
  ngx_core_conf_t *ccf ;
  u_char buf[(sizeof("-9223372036854775808") - 1UL) + 2UL] ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 1014
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 1014
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "signal process started");
    }
  }
  {
#line 1016
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 1018
  memset((void *)(& file), 0, sizeof(ngx_file_t ));
#line 1020
  file.name = ccf->pid;
#line 1021
  file.log = cycle->log;
#line 1023
  file.fd = open((char const   *)file.name.data, 0, 420);
  }
#line 1026
  if (file.fd == -1) {
#line 1027
    if ((cycle->log)->log_level >= 4UL) {
      {
#line 1027
      tmp = __errno_location();
#line 1027
      ngx_log_error_core((ngx_uint_t )4, cycle->log, *tmp, "open() \"%s\" failed",
                         file.name.data);
      }
    }
#line 1029
    return ((ngx_int_t )1);
  }
  {
#line 1032
  n = ngx_read_file(& file, buf, (sizeof("-9223372036854775808") - 1UL) + 2UL, (off_t )0);
#line 1034
  tmp___1 = close(file.fd);
  }
#line 1034
  if (tmp___1 == -1) {
#line 1035
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 1035
      tmp___0 = __errno_location();
#line 1035
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "close() \"%s\" failed",
                         file.name.data);
      }
    }
  }
#line 1039
  if (n == -1L) {
#line 1040
    return ((ngx_int_t )1);
  }
  {
#line 1043
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1043
    tmp___2 = n;
#line 1043
    n --;
#line 1043
    if (tmp___2) {
#line 1043
      if (! ((int )buf[n] == 13)) {
#line 1043
        if (! ((int )buf[n] == 10)) {
#line 1043
          goto while_break;
        }
      }
    } else {
#line 1043
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1045
  n ++;
#line 1045
  tmp___3 = ngx_atoi(buf, (size_t )n);
#line 1045
  pid = (ngx_pid_t )tmp___3;
  }
#line 1047
  if (pid == -1) {
#line 1048
    if ((cycle->log)->log_level >= 4UL) {
      {
#line 1048
      ngx_log_error_core((ngx_uint_t )4, cycle->log, 0, "invalid PID number \"%*s\" in \"%s\"",
                         n, buf, file.name.data);
      }
    }
#line 1051
    return ((ngx_int_t )1);
  }
  {
#line 1054
  tmp___4 = ngx_os_signal_process(cycle, sig, pid);
  }
#line 1054
  return (tmp___4);
}
}
#line 1059 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static ngx_int_t ngx_test_lockfile(u_char *file , ngx_log_t *log ) 
{ 


  {
#line 1086
  return ((ngx_int_t )0);
}
}
#line 1090 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
void ngx_reopen_files(ngx_cycle_t *cycle , ngx_uid_t user ) 
{ 
  ngx_fd_t fd ;
  ngx_uint_t i ;
  ngx_list_part_t *part ;
  ngx_open_file_t *file ;
  int *tmp ;
  ngx_file_info_t fi ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 1098
  part = & cycle->open_files.part;
#line 1099
  file = (ngx_open_file_t *)part->elts;
#line 1101
  i = (ngx_uint_t )0;
  {
#line 1101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1103
    if (i >= part->nelts) {
#line 1104
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1105
        goto while_break;
      }
#line 1107
      part = part->next;
#line 1108
      file = (ngx_open_file_t *)part->elts;
#line 1109
      i = (ngx_uint_t )0;
    }
#line 1112
    if ((file + i)->name.len == 0UL) {
#line 1113
      goto __Cont;
    }
#line 1116
    if ((file + i)->flush) {
      {
#line 1117
      (*((file + i)->flush))(file + i, cycle->log);
      }
    }
    {
#line 1120
    fd = open((char const   *)(file + i)->name.data, 1089, 420);
    }
#line 1127
    if (fd == -1) {
#line 1128
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 1128
        tmp = __errno_location();
#line 1128
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp, "open() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
#line 1130
      goto __Cont;
    }
#line 1134
    if (user != 4294967295U) {
      {
#line 1137
      tmp___3 = stat((char const   */* __restrict  */)((char const   *)(file + i)->name.data),
                     (struct stat */* __restrict  */)(& fi));
      }
#line 1137
      if (tmp___3 == -1) {
#line 1138
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1138
          tmp___0 = __errno_location();
#line 1138
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___0, "stat() \"%s\" failed",
                             (file + i)->name.data);
          }
        }
        {
#line 1142
        tmp___2 = close(fd);
        }
#line 1142
        if (tmp___2 == -1) {
#line 1143
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 1143
            tmp___1 = __errno_location();
#line 1143
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___1, "close() \"%s\" failed",
                               (file + i)->name.data);
            }
          }
        }
#line 1148
        goto __Cont;
      }
#line 1151
      if (fi.st_uid != user) {
        {
#line 1152
        tmp___7 = chown((char const   *)(file + i)->name.data, user, (__gid_t )-1);
        }
#line 1152
        if (tmp___7 == -1) {
#line 1153
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 1153
            tmp___4 = __errno_location();
#line 1153
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___4, "chown(\"%s\", %d) failed",
                               (file + i)->name.data, user);
            }
          }
          {
#line 1157
          tmp___6 = close(fd);
          }
#line 1157
          if (tmp___6 == -1) {
#line 1158
            if ((cycle->log)->log_level >= 1UL) {
              {
#line 1158
              tmp___5 = __errno_location();
#line 1158
              ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___5, "close() \"%s\" failed",
                                 (file + i)->name.data);
              }
            }
          }
#line 1163
          goto __Cont;
        }
      }
#line 1167
      if ((fi.st_mode & 384U) != 384U) {
        {
#line 1169
        fi.st_mode |= 384U;
#line 1171
        tmp___11 = chmod((char const   *)(file + i)->name.data, fi.st_mode);
        }
#line 1171
        if (tmp___11 == -1) {
#line 1172
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 1172
            tmp___8 = __errno_location();
#line 1172
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___8, "chmod() \"%s\" failed",
                               (file + i)->name.data);
            }
          }
          {
#line 1175
          tmp___10 = close(fd);
          }
#line 1175
          if (tmp___10 == -1) {
#line 1176
            if ((cycle->log)->log_level >= 1UL) {
              {
#line 1176
              tmp___9 = __errno_location();
#line 1176
              ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___9, "close() \"%s\" failed",
                                 (file + i)->name.data);
              }
            }
          }
#line 1181
          goto __Cont;
        }
      }
    }
    {
#line 1186
    tmp___15 = fcntl(fd, 2, 1);
    }
#line 1186
    if (tmp___15 == -1) {
#line 1187
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 1187
        tmp___12 = __errno_location();
#line 1187
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___12, "fcntl(FD_CLOEXEC) \"%s\" failed",
                           (file + i)->name.data);
        }
      }
      {
#line 1191
      tmp___14 = close(fd);
      }
#line 1191
      if (tmp___14 == -1) {
#line 1192
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1192
          tmp___13 = __errno_location();
#line 1192
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___13, "close() \"%s\" failed",
                             (file + i)->name.data);
          }
        }
      }
#line 1197
      goto __Cont;
    }
    {
#line 1201
    tmp___17 = close((file + i)->fd);
    }
#line 1201
    if (tmp___17 == -1) {
#line 1202
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 1202
        tmp___16 = __errno_location();
#line 1202
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___16, "close() \"%s\" failed",
                           (file + i)->name.data);
        }
      }
    }
#line 1207
    (file + i)->fd = fd;
    __Cont: /* CIL Label */ 
#line 1101
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1210
  ngx_log_redirect_stderr(cycle);
  }
#line 1211
  return;
}
}
#line 1214 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
ngx_shm_zone_t *ngx_shared_memory_add(ngx_conf_t *cf , ngx_str_t *name , size_t size ,
                                      void *tag ) 
{ 
  ngx_uint_t i ;
  ngx_shm_zone_t *shm_zone ;
  ngx_list_part_t *part ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 1221
  part = & (cf->cycle)->shared_memory.part;
#line 1222
  shm_zone = (ngx_shm_zone_t *)part->elts;
#line 1224
  i = (ngx_uint_t )0;
  {
#line 1224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1226
    if (i >= part->nelts) {
#line 1227
      if ((unsigned long )part->next == (unsigned long )((void *)0)) {
#line 1228
        goto while_break;
      }
#line 1230
      part = part->next;
#line 1231
      shm_zone = (ngx_shm_zone_t *)part->elts;
#line 1232
      i = (ngx_uint_t )0;
    }
#line 1235
    if (name->len != (shm_zone + i)->shm.name.len) {
#line 1236
      goto __Cont;
    }
    {
#line 1239
    tmp = strncmp((char const   *)name->data, (char const   *)(shm_zone + i)->shm.name.data,
                  name->len);
    }
#line 1239
    if (tmp != 0) {
#line 1242
      goto __Cont;
    }
#line 1245
    if ((unsigned long )tag != (unsigned long )(shm_zone + i)->tag) {
      {
#line 1246
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the shared memory zone \"%V\" is already declared for a different use",
                         & (shm_zone + i)->shm.name);
      }
#line 1250
      return ((ngx_shm_zone_t *)((void *)0));
    }
#line 1253
    if ((shm_zone + i)->shm.size == 0UL) {
#line 1254
      (shm_zone + i)->shm.size = size;
    }
#line 1257
    if (size) {
#line 1257
      if (size != (shm_zone + i)->shm.size) {
        {
#line 1258
        ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the size %uz of shared memory zone \"%V\" conflicts with already declared size %uz",
                           size, & (shm_zone + i)->shm.name, (shm_zone + i)->shm.size);
        }
#line 1262
        return ((ngx_shm_zone_t *)((void *)0));
      }
    }
#line 1265
    return (shm_zone + i);
    __Cont: /* CIL Label */ 
#line 1224
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1268
  tmp___0 = ngx_list_push(& (cf->cycle)->shared_memory);
#line 1268
  shm_zone = (ngx_shm_zone_t *)tmp___0;
  }
#line 1270
  if ((unsigned long )shm_zone == (unsigned long )((void *)0)) {
#line 1271
    return ((ngx_shm_zone_t *)((void *)0));
  }
#line 1274
  shm_zone->data = (void *)0;
#line 1275
  shm_zone->shm.log = (cf->cycle)->log;
#line 1276
  shm_zone->shm.size = size;
#line 1277
  shm_zone->shm.name = *name;
#line 1278
  shm_zone->shm.exists = (ngx_uint_t )0;
#line 1279
  shm_zone->init = (ngx_int_t (*)(ngx_shm_zone_t *zone , void *data ))((void *)0);
#line 1280
  shm_zone->tag = tag;
#line 1281
  shm_zone->noreuse = (ngx_uint_t )0;
#line 1283
  return (shm_zone);
}
}
#line 1287 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static void ngx_clean_old_cycles(ngx_event_t *ev ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t found ;
  ngx_uint_t live ;
  ngx_log_t *log ;
  ngx_cycle_t **cycle ;

  {
#line 1294
  log = (ngx_log_t *)ngx_cycle->log;
#line 1295
  ngx_temp_pool->log = log;
#line 1299
  live = (ngx_uint_t )0;
#line 1301
  cycle = (ngx_cycle_t **)ngx_old_cycles.elts;
#line 1302
  i = (ngx_uint_t )0;
  {
#line 1302
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1302
    if (! (i < ngx_old_cycles.nelts)) {
#line 1302
      goto while_break;
    }
#line 1304
    if ((unsigned long )*(cycle + i) == (unsigned long )((void *)0)) {
#line 1305
      goto __Cont;
    }
#line 1308
    found = (ngx_uint_t )0;
#line 1310
    n = (ngx_uint_t )0;
    {
#line 1310
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1310
      if (! (n < (*(cycle + i))->connection_n)) {
#line 1310
        goto while_break___0;
      }
#line 1311
      if (((*(cycle + i))->connections + n)->fd != -1) {
#line 1312
        found = (ngx_uint_t )1;
#line 1316
        goto while_break___0;
      }
#line 1310
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1320
    if (found) {
#line 1321
      live = (ngx_uint_t )1;
#line 1322
      goto __Cont;
    }
    {
#line 1327
    ngx_destroy_pool((*(cycle + i))->pool);
#line 1328
    *(cycle + i) = (ngx_cycle_t *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 1302
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1333
  if (live) {
    {
#line 1334
    ngx_event_add_timer(ev, (ngx_msec_t )30000);
    }
  } else {
    {
#line 1337
    ngx_destroy_pool(ngx_temp_pool);
#line 1338
    ngx_temp_pool = (ngx_pool_t *)((void *)0);
#line 1339
    ngx_old_cycles.nelts = (ngx_uint_t )0;
    }
  }
#line 1341
  return;
}
}
#line 1344 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
void ngx_set_shutdown_timer(ngx_cycle_t *cycle ) 
{ 
  ngx_core_conf_t *ccf ;

  {
#line 1349
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 1351
  if (ccf->shutdown_timeout) {
    {
#line 1352
    ngx_shutdown_event.handler = & ngx_shutdown_timer_handler;
#line 1353
    ngx_shutdown_event.data = (void *)cycle;
#line 1354
    ngx_shutdown_event.log = cycle->log;
#line 1355
    ngx_shutdown_event.cancelable = 1U;
#line 1357
    ngx_event_add_timer(& ngx_shutdown_event, ccf->shutdown_timeout);
    }
  }
#line 1359
  return;
}
}
#line 1362 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_cycle.c"
static void ngx_shutdown_timer_handler(ngx_event_t *ev ) 
{ 
  ngx_uint_t i ;
  ngx_cycle_t *cycle ;
  ngx_connection_t *c ;

  {
#line 1369
  cycle = (ngx_cycle_t *)ev->data;
#line 1371
  c = cycle->connections;
#line 1373
  i = (ngx_uint_t )0;
  {
#line 1373
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1373
    if (! (i < cycle->connection_n)) {
#line 1373
      goto while_break;
    }
#line 1375
    if ((c + i)->fd == -1) {
#line 1381
      goto __Cont;
    } else
#line 1375
    if ((unsigned long )(c + i)->read == (unsigned long )((void *)0)) {
#line 1381
      goto __Cont;
    } else
#line 1375
    if (((c + i)->read)->accept) {
#line 1381
      goto __Cont;
    } else
#line 1375
    if (((c + i)->read)->channel) {
#line 1381
      goto __Cont;
    } else
#line 1375
    if (((c + i)->read)->resolver) {
#line 1381
      goto __Cont;
    }
    {
#line 1387
    (c + i)->close = 1U;
#line 1388
    (c + i)->error = 1U;
#line 1390
    (*(((c + i)->read)->handler))((c + i)->read);
    }
    __Cont: /* CIL Label */ 
#line 1373
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1392
  return;
}
}
#line 127 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 209 "src/core/ngx_connection.h"
ngx_int_t ngx_set_inherited_sockets(ngx_cycle_t *cycle ) ;
#line 425 "src/event/ngx_event.h"
ngx_os_io_t ngx_io  ;
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
static void ngx_drain_connections(ngx_cycle_t *cycle ) ;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
ngx_listening_t *ngx_create_listening(ngx_conf_t *cf , struct sockaddr *sockaddr ,
                                      socklen_t socklen ) 
{ 
  size_t len ;
  ngx_listening_t *ls ;
  struct sockaddr *sa ;
  u_char text[((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path)] ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
  {
#line 28
  tmp = ngx_array_push(& (cf->cycle)->listening);
#line 28
  ls = (ngx_listening_t *)tmp;
  }
#line 29
  if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 30
    return ((ngx_listening_t *)((void *)0));
  }
  {
#line 33
  memset((void *)ls, 0, sizeof(ngx_listening_t ));
#line 35
  tmp___0 = ngx_palloc(cf->pool, (size_t )socklen);
#line 35
  sa = (struct sockaddr *)tmp___0;
  }
#line 36
  if ((unsigned long )sa == (unsigned long )((void *)0)) {
#line 37
    return ((ngx_listening_t *)((void *)0));
  }
  {
#line 40
  memcpy((void */* __restrict  */)sa, (void const   */* __restrict  */)sockaddr, (size_t )socklen);
#line 42
  ls->sockaddr = sa;
#line 43
  ls->socklen = socklen;
#line 45
  len = ngx_sock_ntop(sa, socklen, text, ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path),
                      (ngx_uint_t )1);
#line 46
  ls->addr_text.len = len;
  }
  {
#line 50
  if ((int )(ls->sockaddr)->sa_family == 10) {
#line 50
    goto case_10;
  }
#line 55
  if ((int )(ls->sockaddr)->sa_family == 1) {
#line 55
    goto case_1;
  }
#line 60
  if ((int )(ls->sockaddr)->sa_family == 2) {
#line 60
    goto case_2;
  }
#line 63
  goto switch_default;
  case_10: /* CIL Label */ 
#line 51
  ls->addr_text_max_len = sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL;
#line 52
  goto switch_break;
  case_1: /* CIL Label */ 
#line 56
  ls->addr_text_max_len = ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 57
  len ++;
#line 58
  goto switch_break;
  case_2: /* CIL Label */ 
#line 61
  ls->addr_text_max_len = sizeof("255.255.255.255") - 1UL;
#line 62
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 64
  ls->addr_text_max_len = ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 65
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 68
  tmp___1 = ngx_pnalloc(cf->pool, len);
#line 68
  ls->addr_text.data = (u_char *)tmp___1;
  }
#line 69
  if ((unsigned long )ls->addr_text.data == (unsigned long )((void *)0)) {
#line 70
    return ((ngx_listening_t *)((void *)0));
  }
  {
#line 73
  memcpy((void */* __restrict  */)ls->addr_text.data, (void const   */* __restrict  */)(text),
         len);
#line 75
  ls->fd = -1;
#line 76
  ls->type = 1;
#line 78
  ls->backlog = 511;
#line 79
  ls->rcvbuf = -1;
#line 80
  ls->sndbuf = -1;
#line 87
  ls->fastopen = -1;
  }
#line 90
  return (ls);
}
}
#line 94 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
ngx_int_t ngx_clone_listening(ngx_conf_t *cf , ngx_listening_t *ls ) 
{ 
  ngx_int_t n ;
  ngx_core_conf_t *ccf ;
  ngx_listening_t ols ;
  void *tmp ;

  {
#line 103
  if (! ls->reuseport) {
#line 104
    return ((ngx_int_t )0);
  }
#line 107
  ols = *ls;
#line 109
  ccf = (ngx_core_conf_t *)*((cf->cycle)->conf_ctx + ngx_core_module.index);
#line 112
  n = (ngx_int_t )1;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! (n < ccf->worker_processes)) {
#line 112
      goto while_break;
    }
    {
#line 116
    tmp = ngx_array_push(& (cf->cycle)->listening);
#line 116
    ls = (ngx_listening_t *)tmp;
    }
#line 117
    if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 118
      return ((ngx_int_t )-1);
    }
#line 121
    *ls = ols;
#line 122
    ls->worker = (ngx_uint_t )n;
#line 112
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return ((ngx_int_t )0);
}
}
#line 131 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
ngx_int_t ngx_set_inherited_sockets(ngx_cycle_t *cycle ) 
{ 
  size_t len ;
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  socklen_t olen ;
  ngx_err_t err ;
  int timeout ;
  int reuseport ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  void *tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  int tmp___15 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;

  {
#line 151
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 152
  i = (ngx_uint_t )0;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (i < cycle->listening.nelts)) {
#line 152
      goto while_break;
    }
    {
#line 154
    tmp = ngx_palloc(cycle->pool, sizeof(ngx_sockaddr_t ));
#line 154
    (ls + i)->sockaddr = (struct sockaddr *)tmp;
    }
#line 155
    if ((unsigned long )(ls + i)->sockaddr == (unsigned long )((void *)0)) {
#line 156
      return ((ngx_int_t )-1);
    }
    {
#line 159
    (ls + i)->socklen = (socklen_t )sizeof(ngx_sockaddr_t );
#line 160
    tmp___1 = getsockname((ls + i)->fd, (struct sockaddr */* __restrict  */)(ls + i)->sockaddr,
                          (socklen_t */* __restrict  */)(& (ls + i)->socklen));
    }
#line 160
    if (tmp___1 == -1) {
#line 161
      if ((cycle->log)->log_level >= 3UL) {
        {
#line 161
        tmp___0 = __errno_location();
#line 161
        ngx_log_error_core((ngx_uint_t )3, cycle->log, *tmp___0, "getsockname() of the inherited socket #%d failed",
                           (ls + i)->fd);
        }
      }
#line 164
      (ls + i)->ignore = 1U;
#line 165
      goto __Cont;
    }
#line 168
    if ((ls + i)->socklen > (socklen_t )sizeof(ngx_sockaddr_t )) {
#line 169
      (ls + i)->socklen = (socklen_t )sizeof(ngx_sockaddr_t );
    }
    {
#line 175
    if ((int )((ls + i)->sockaddr)->sa_family == 10) {
#line 175
      goto case_10;
    }
#line 182
    if ((int )((ls + i)->sockaddr)->sa_family == 1) {
#line 182
      goto case_1;
    }
#line 188
    if ((int )((ls + i)->sockaddr)->sa_family == 2) {
#line 188
      goto case_2;
    }
#line 193
    goto switch_default;
    case_10: /* CIL Label */ 
#line 176
    (ls + i)->addr_text_max_len = sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL;
#line 177
    len = ((sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL) + sizeof("[]:65535")) - 1UL;
#line 178
    goto switch_break;
    case_1: /* CIL Label */ 
#line 183
    (ls + i)->addr_text_max_len = ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 184
    len = ((sizeof("unix:") - 1UL) + sizeof(struct sockaddr_un )) - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
#line 185
    goto switch_break;
    case_2: /* CIL Label */ 
#line 189
    (ls + i)->addr_text_max_len = sizeof("255.255.255.255") - 1UL;
#line 190
    len = ((sizeof("255.255.255.255") - 1UL) + sizeof(":65535")) - 1UL;
#line 191
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 194
    if ((cycle->log)->log_level >= 3UL) {
      {
#line 194
      tmp___2 = __errno_location();
#line 194
      ngx_log_error_core((ngx_uint_t )3, cycle->log, *tmp___2, "the inherited socket #%d has an unsupported protocol family",
                         (ls + i)->fd);
      }
    }
#line 197
    (ls + i)->ignore = 1U;
#line 198
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    {
#line 201
    tmp___3 = ngx_pnalloc(cycle->pool, len);
#line 201
    (ls + i)->addr_text.data = (u_char *)tmp___3;
    }
#line 202
    if ((unsigned long )(ls + i)->addr_text.data == (unsigned long )((void *)0)) {
#line 203
      return ((ngx_int_t )-1);
    }
    {
#line 206
    len = ngx_sock_ntop((ls + i)->sockaddr, (ls + i)->socklen, (ls + i)->addr_text.data,
                        len, (ngx_uint_t )1);
    }
#line 208
    if (len == 0UL) {
#line 209
      return ((ngx_int_t )-1);
    }
    {
#line 212
    (ls + i)->addr_text.len = len;
#line 214
    (ls + i)->backlog = 511;
#line 216
    olen = (socklen_t )sizeof(int );
#line 218
    tmp___5 = getsockopt((ls + i)->fd, 1, 3, (void */* __restrict  */)((void *)(& (ls + i)->type)),
                         (socklen_t */* __restrict  */)(& olen));
    }
#line 218
    if (tmp___5 == -1) {
#line 222
      if ((cycle->log)->log_level >= 3UL) {
        {
#line 222
        tmp___4 = __errno_location();
#line 222
        ngx_log_error_core((ngx_uint_t )3, cycle->log, *tmp___4, "getsockopt(SO_TYPE) %V failed",
                           & (ls + i)->addr_text);
        }
      }
#line 224
      (ls + i)->ignore = 1U;
#line 225
      goto __Cont;
    }
    {
#line 228
    olen = (socklen_t )sizeof(int );
#line 230
    tmp___7 = getsockopt((ls + i)->fd, 1, 8, (void */* __restrict  */)((void *)(& (ls + i)->rcvbuf)),
                         (socklen_t */* __restrict  */)(& olen));
    }
#line 230
    if (tmp___7 == -1) {
#line 234
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 234
        tmp___6 = __errno_location();
#line 234
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___6, "getsockopt(SO_RCVBUF) %V failed, ignored",
                           & (ls + i)->addr_text);
        }
      }
#line 238
      (ls + i)->rcvbuf = -1;
    }
    {
#line 241
    olen = (socklen_t )sizeof(int );
#line 243
    tmp___9 = getsockopt((ls + i)->fd, 1, 7, (void */* __restrict  */)((void *)(& (ls + i)->sndbuf)),
                         (socklen_t */* __restrict  */)(& olen));
    }
#line 243
    if (tmp___9 == -1) {
#line 247
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 247
        tmp___8 = __errno_location();
#line 247
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___8, "getsockopt(SO_SNDBUF) %V failed, ignored",
                           & (ls + i)->addr_text);
        }
      }
#line 251
      (ls + i)->sndbuf = -1;
    }
    {
#line 277
    reuseport = 0;
#line 278
    olen = (socklen_t )sizeof(int );
#line 280
    tmp___11 = getsockopt((ls + i)->fd, 1, 15, (void */* __restrict  */)((void *)(& reuseport)),
                          (socklen_t */* __restrict  */)(& olen));
    }
#line 280
    if (tmp___11 == -1) {
#line 284
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 284
        tmp___10 = __errno_location();
#line 284
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___10, "getsockopt(SO_REUSEPORT) %V failed, ignored",
                           & (ls + i)->addr_text);
        }
      }
    } else
#line 289
    if (reuseport) {
#line 289
      (ls + i)->reuseport = 1U;
    } else {
#line 289
      (ls + i)->reuseport = 0U;
    }
#line 294
    if ((ls + i)->type != 1) {
#line 295
      goto __Cont;
    }
    {
#line 300
    olen = (socklen_t )sizeof(int );
#line 302
    tmp___13 = getsockopt((ls + i)->fd, 6, 23, (void */* __restrict  */)((void *)(& (ls + i)->fastopen)),
                          (socklen_t */* __restrict  */)(& olen));
    }
#line 302
    if (tmp___13 == -1) {
      {
#line 306
      tmp___12 = __errno_location();
#line 306
      err = *tmp___12;
      }
#line 308
      if (err != 95) {
#line 308
        if (err != 92) {
#line 309
          if ((cycle->log)->log_level >= 6UL) {
            {
#line 309
            ngx_log_error_core((ngx_uint_t )6, cycle->log, err, "getsockopt(TCP_FASTOPEN) %V failed, ignored",
                               & (ls + i)->addr_text);
            }
          }
        }
      }
#line 314
      (ls + i)->fastopen = -1;
    }
    {
#line 354
    timeout = 0;
#line 355
    olen = (socklen_t )sizeof(int );
#line 357
    tmp___15 = getsockopt((ls + i)->fd, 6, 9, (void */* __restrict  */)(& timeout),
                          (socklen_t */* __restrict  */)(& olen));
    }
#line 357
    if (tmp___15 == -1) {
      {
#line 360
      tmp___14 = __errno_location();
#line 360
      err = *tmp___14;
      }
#line 362
      if (err == 95) {
#line 363
        goto __Cont;
      }
#line 366
      if ((cycle->log)->log_level >= 6UL) {
        {
#line 366
        ngx_log_error_core((ngx_uint_t )6, cycle->log, err, "getsockopt(TCP_DEFER_ACCEPT) for %V failed, ignored",
                           & (ls + i)->addr_text);
        }
      }
#line 369
      goto __Cont;
    }
#line 372
    if ((unsigned long )olen < sizeof(int )) {
#line 373
      goto __Cont;
    } else
#line 372
    if (timeout == 0) {
#line 373
      goto __Cont;
    }
#line 376
    (ls + i)->deferred_accept = 1U;
    __Cont: /* CIL Label */ 
#line 152
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 380
  return ((ngx_int_t )0);
}
}
#line 384 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
ngx_int_t ngx_open_listening_sockets(ngx_cycle_t *cycle ) 
{ 
  int reuseaddr ;
  ngx_uint_t i ;
  ngx_uint_t tries ;
  ngx_uint_t failed ;
  ngx_err_t err ;
  ngx_log_t *log ;
  ngx_socket_t s ;
  ngx_listening_t *ls ;
  int reuseport ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int reuseport___0 ;
  int *tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int ipv6only ;
  int *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  mode_t mode ;
  u_char *name ;
  int *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  int tmp___23 ;
  int *tmp___24 ;
  int *tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;

  {
#line 394
  reuseaddr = 1;
#line 396
  failed = (ngx_uint_t )0;
#line 399
  log = cycle->log;
#line 403
  tries = (ngx_uint_t )5;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! tries) {
#line 403
      goto while_break;
    }
#line 404
    failed = (ngx_uint_t )0;
#line 408
    ls = (ngx_listening_t *)cycle->listening.elts;
#line 409
    i = (ngx_uint_t )0;
    {
#line 409
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 409
      if (! (i < cycle->listening.nelts)) {
#line 409
        goto while_break___0;
      }
#line 411
      if ((ls + i)->ignore) {
#line 412
        goto __Cont;
      }
#line 417
      if ((ls + i)->add_reuseport) {
        {
#line 425
        reuseport = 1;
#line 427
        tmp___0 = setsockopt((ls + i)->fd, 1, 15, (void const   *)(& reuseport), (socklen_t )sizeof(int ));
        }
#line 427
        if (tmp___0 == -1) {
#line 431
          if ((cycle->log)->log_level >= 2UL) {
            {
#line 431
            tmp = __errno_location();
#line 431
            ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "setsockopt(SO_REUSEPORT) %V failed, ignored",
                               & (ls + i)->addr_text);
            }
          }
        }
#line 436
        (ls + i)->add_reuseport = 0U;
      }
#line 440
      if ((ls + i)->fd != -1) {
#line 441
        goto __Cont;
      }
#line 444
      if ((ls + i)->inherited) {
#line 450
        goto __Cont;
      }
      {
#line 453
      s = socket((int )((ls + i)->sockaddr)->sa_family, (ls + i)->type, 0);
      }
#line 455
      if (s == -1) {
#line 456
        if (log->log_level >= 1UL) {
          {
#line 456
          tmp___1 = __errno_location();
#line 456
          ngx_log_error_core((ngx_uint_t )1, log, *tmp___1, "socket() %V failed",
                             & (ls + i)->addr_text);
          }
        }
#line 458
        return ((ngx_int_t )-1);
      }
      {
#line 461
      tmp___5 = setsockopt(s, 1, 2, (void const   *)(& reuseaddr), (socklen_t )sizeof(int ));
      }
#line 461
      if (tmp___5 == -1) {
#line 465
        if (log->log_level >= 1UL) {
          {
#line 465
          tmp___2 = __errno_location();
#line 465
          ngx_log_error_core((ngx_uint_t )1, log, *tmp___2, "setsockopt(SO_REUSEADDR) %V failed",
                             & (ls + i)->addr_text);
          }
        }
        {
#line 469
        tmp___4 = close(s);
        }
#line 469
        if (tmp___4 == -1) {
#line 470
          if (log->log_level >= 1UL) {
            {
#line 470
            tmp___3 = __errno_location();
#line 470
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___3, "close() socket %V failed",
                               & (ls + i)->addr_text);
            }
          }
        }
#line 475
        return ((ngx_int_t )-1);
      }
#line 480
      if ((ls + i)->reuseport) {
#line 480
        if (! ngx_test_config) {
          {
#line 483
          reuseport___0 = 1;
#line 485
          tmp___9 = setsockopt(s, 1, 15, (void const   *)(& reuseport___0), (socklen_t )sizeof(int ));
          }
#line 485
          if (tmp___9 == -1) {
#line 489
            if (log->log_level >= 1UL) {
              {
#line 489
              tmp___6 = __errno_location();
#line 489
              ngx_log_error_core((ngx_uint_t )1, log, *tmp___6, "setsockopt(SO_REUSEPORT) %V failed",
                                 & (ls + i)->addr_text);
              }
            }
            {
#line 493
            tmp___8 = close(s);
            }
#line 493
            if (tmp___8 == -1) {
#line 494
              if (log->log_level >= 1UL) {
                {
#line 494
                tmp___7 = __errno_location();
#line 494
                ngx_log_error_core((ngx_uint_t )1, log, *tmp___7, "close() socket %V failed",
                                   & (ls + i)->addr_text);
                }
              }
            }
#line 499
            return ((ngx_int_t )-1);
          }
        }
      }
#line 506
      if ((int )((ls + i)->sockaddr)->sa_family == 10) {
        {
#line 509
        ipv6only = (int )(ls + i)->ipv6only;
#line 511
        tmp___11 = setsockopt(s, 41, 26, (void const   *)(& ipv6only), (socklen_t )sizeof(int ));
        }
#line 511
        if (tmp___11 == -1) {
#line 515
          if (log->log_level >= 1UL) {
            {
#line 515
            tmp___10 = __errno_location();
#line 515
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___10, "setsockopt(IPV6_V6ONLY) %V failed, ignored",
                               & (ls + i)->addr_text);
            }
          }
        }
      }
#line 523
      if (! (ngx_event_flags & 512UL)) {
        {
#line 524
        tmp___15 = ngx_nonblocking(s);
        }
#line 524
        if (tmp___15 == -1) {
#line 525
          if (log->log_level >= 1UL) {
            {
#line 525
            tmp___12 = __errno_location();
#line 525
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___12, "ioctl(FIONBIO) %V failed",
                               & (ls + i)->addr_text);
            }
          }
          {
#line 529
          tmp___14 = close(s);
          }
#line 529
          if (tmp___14 == -1) {
#line 530
            if (log->log_level >= 1UL) {
              {
#line 530
              tmp___13 = __errno_location();
#line 530
              ngx_log_error_core((ngx_uint_t )1, log, *tmp___13, "close() socket %V failed",
                                 & (ls + i)->addr_text);
              }
            }
          }
#line 535
          return ((ngx_int_t )-1);
        }
      }
      {
#line 542
      tmp___19 = bind(s, (struct sockaddr  const  */* __restrict  */)(ls + i)->sockaddr,
                      (ls + i)->socklen);
      }
#line 542
      if (tmp___19 == -1) {
        {
#line 543
        tmp___16 = __errno_location();
#line 543
        err = *tmp___16;
        }
#line 545
        if (err != 98) {
#line 545
          goto _L;
        } else
#line 545
        if (! ngx_test_config) {
          _L: /* CIL Label */ 
#line 546
          if (log->log_level >= 1UL) {
            {
#line 546
            ngx_log_error_core((ngx_uint_t )1, log, err, "bind() to %V failed", & (ls + i)->addr_text);
            }
          }
        }
        {
#line 550
        tmp___18 = close(s);
        }
#line 550
        if (tmp___18 == -1) {
#line 551
          if (log->log_level >= 1UL) {
            {
#line 551
            tmp___17 = __errno_location();
#line 551
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___17, "close() socket %V failed",
                               & (ls + i)->addr_text);
            }
          }
        }
#line 556
        if (err != 98) {
#line 557
          return ((ngx_int_t )-1);
        }
#line 560
        if (! ngx_test_config) {
#line 561
          failed = (ngx_uint_t )1;
        }
#line 564
        goto __Cont;
      }
#line 569
      if ((int )((ls + i)->sockaddr)->sa_family == 1) {
        {
#line 573
        name = ((ls + i)->addr_text.data + sizeof("unix:")) - 1;
#line 574
        mode = (mode_t )((((384 | (256 >> 3)) | (128 >> 3)) | ((256 >> 3) >> 3)) | ((128 >> 3) >> 3));
#line 576
        tmp___21 = chmod((char const   *)((char *)name), mode);
        }
#line 576
        if (tmp___21 == -1) {
#line 577
          if ((cycle->log)->log_level >= 1UL) {
            {
#line 577
            tmp___20 = __errno_location();
#line 577
            ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___20, "chmod() \"%s\" failed",
                               name);
            }
          }
        }
#line 581
        if (ngx_test_config) {
          {
#line 582
          tmp___23 = unlink((char const   *)name);
          }
#line 582
          if (tmp___23 == -1) {
#line 583
            if ((cycle->log)->log_level >= 1UL) {
              {
#line 583
              tmp___22 = __errno_location();
#line 583
              ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___22, "unlink() %s failed",
                                 name);
              }
            }
          }
        }
      }
#line 590
      if ((ls + i)->type != 1) {
#line 591
        (ls + i)->fd = s;
#line 592
        goto __Cont;
      }
      {
#line 595
      tmp___27 = listen(s, (ls + i)->backlog);
      }
#line 595
      if (tmp___27 == -1) {
        {
#line 596
        tmp___24 = __errno_location();
#line 596
        err = *tmp___24;
        }
#line 604
        if (err != 98) {
#line 604
          goto _L___0;
        } else
#line 604
        if (! ngx_test_config) {
          _L___0: /* CIL Label */ 
#line 605
          if (log->log_level >= 1UL) {
            {
#line 605
            ngx_log_error_core((ngx_uint_t )1, log, err, "listen() to %V, backlog %d failed",
                               & (ls + i)->addr_text, (ls + i)->backlog);
            }
          }
        }
        {
#line 610
        tmp___26 = close(s);
        }
#line 610
        if (tmp___26 == -1) {
#line 611
          if (log->log_level >= 1UL) {
            {
#line 611
            tmp___25 = __errno_location();
#line 611
            ngx_log_error_core((ngx_uint_t )1, log, *tmp___25, "close() socket %V failed",
                               & (ls + i)->addr_text);
            }
          }
        }
#line 616
        if (err != 98) {
#line 617
          return ((ngx_int_t )-1);
        }
#line 620
        if (! ngx_test_config) {
#line 621
          failed = (ngx_uint_t )1;
        }
#line 624
        goto __Cont;
      }
#line 627
      (ls + i)->listen = 1U;
#line 629
      (ls + i)->fd = s;
      __Cont: /* CIL Label */ 
#line 409
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 632
    if (! failed) {
#line 633
      goto while_break;
    }
#line 638
    if (log->log_level >= 6UL) {
      {
#line 638
      ngx_log_error_core((ngx_uint_t )6, log, 0, "try again to bind() after 500ms");
      }
    }
    {
#line 641
    usleep((__useconds_t )500000);
#line 403
    tries --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 644
  if (failed) {
#line 645
    if (log->log_level >= 1UL) {
      {
#line 645
      ngx_log_error_core((ngx_uint_t )1, log, 0, "still could not bind()");
      }
    }
#line 646
    return ((ngx_int_t )-1);
  }
#line 649
  return ((ngx_int_t )0);
}
}
#line 653 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
void ngx_configure_listening_sockets(ngx_cycle_t *cycle ) 
{ 
  int value ;
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  int tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  int tmp___20 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;

  {
#line 664
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 665
  i = (ngx_uint_t )0;
  {
#line 665
  while (1) {
    while_continue: /* CIL Label */ ;
#line 665
    if (! (i < cycle->listening.nelts)) {
#line 665
      goto while_break;
    }
#line 667
    (ls + i)->log = *((ls + i)->logp);
#line 669
    if ((ls + i)->rcvbuf != -1) {
      {
#line 670
      tmp___0 = setsockopt((ls + i)->fd, 1, 8, (void const   *)(& (ls + i)->rcvbuf),
                           (socklen_t )sizeof(int ));
      }
#line 670
      if (tmp___0 == -1) {
#line 674
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 674
          tmp = __errno_location();
#line 674
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp, "setsockopt(SO_RCVBUF, %d) %V failed, ignored",
                             (ls + i)->rcvbuf, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 680
    if ((ls + i)->sndbuf != -1) {
      {
#line 681
      tmp___2 = setsockopt((ls + i)->fd, 1, 7, (void const   *)(& (ls + i)->sndbuf),
                           (socklen_t )sizeof(int ));
      }
#line 681
      if (tmp___2 == -1) {
#line 685
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 685
          tmp___1 = __errno_location();
#line 685
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___1, "setsockopt(SO_SNDBUF, %d) %V failed, ignored",
                             (ls + i)->sndbuf, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 691
    if ((ls + i)->keepalive) {
#line 692
      if ((ls + i)->keepalive == 1U) {
#line 692
        value = 1;
      } else {
#line 692
        value = 0;
      }
      {
#line 694
      tmp___4 = setsockopt((ls + i)->fd, 1, 9, (void const   *)(& value), (socklen_t )sizeof(int ));
      }
#line 694
      if (tmp___4 == -1) {
#line 698
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 698
          tmp___3 = __errno_location();
#line 698
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "setsockopt(SO_KEEPALIVE, %d) %V failed, ignored",
                             value, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 706
    if ((ls + i)->keepidle) {
      {
#line 707
      value = (ls + i)->keepidle;
#line 713
      tmp___6 = setsockopt((ls + i)->fd, 6, 4, (void const   *)(& value), (socklen_t )sizeof(int ));
      }
#line 713
      if (tmp___6 == -1) {
#line 717
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 717
          tmp___5 = __errno_location();
#line 717
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "setsockopt(TCP_KEEPIDLE, %d) %V failed, ignored",
                             value, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 723
    if ((ls + i)->keepintvl) {
      {
#line 724
      value = (ls + i)->keepintvl;
#line 730
      tmp___8 = setsockopt((ls + i)->fd, 6, 5, (void const   *)(& value), (socklen_t )sizeof(int ));
      }
#line 730
      if (tmp___8 == -1) {
#line 734
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 734
          tmp___7 = __errno_location();
#line 734
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___7, "setsockopt(TCP_KEEPINTVL, %d) %V failed, ignored",
                             value, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 740
    if ((ls + i)->keepcnt) {
      {
#line 741
      tmp___10 = setsockopt((ls + i)->fd, 6, 6, (void const   *)(& (ls + i)->keepcnt),
                            (socklen_t )sizeof(int ));
      }
#line 741
      if (tmp___10 == -1) {
#line 745
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 745
          tmp___9 = __errno_location();
#line 745
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___9, "setsockopt(TCP_KEEPCNT, %d) %V failed, ignored",
                             (ls + i)->keepcnt, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 767
    if ((ls + i)->fastopen != -1) {
      {
#line 768
      tmp___12 = setsockopt((ls + i)->fd, 6, 23, (void const   *)(& (ls + i)->fastopen),
                            (socklen_t )sizeof(int ));
      }
#line 768
      if (tmp___12 == -1) {
#line 772
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 772
          tmp___11 = __errno_location();
#line 772
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___11, "setsockopt(TCP_FASTOPEN, %d) %V failed, ignored",
                             (ls + i)->fastopen, & (ls + i)->addr_text);
          }
        }
      }
    }
#line 794
    if ((ls + i)->listen) {
      {
#line 798
      tmp___14 = listen((ls + i)->fd, (ls + i)->backlog);
      }
#line 798
      if (tmp___14 == -1) {
#line 799
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 799
          tmp___13 = __errno_location();
#line 799
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___13, "listen() to %V, backlog %d failed, ignored",
                             & (ls + i)->addr_text, (ls + i)->backlog);
          }
        }
      }
    }
#line 859
    if ((ls + i)->add_deferred) {
#line 859
      goto _L;
    } else
#line 859
    if ((ls + i)->delete_deferred) {
      _L: /* CIL Label */ 
#line 861
      if ((ls + i)->add_deferred) {
#line 868
        value = 1;
      } else {
#line 871
        value = 0;
      }
      {
#line 874
      tmp___16 = setsockopt((ls + i)->fd, 6, 9, (void const   *)(& value), (socklen_t )sizeof(int ));
      }
#line 874
      if (tmp___16 == -1) {
#line 878
        if ((cycle->log)->log_level >= 2UL) {
          {
#line 878
          tmp___15 = __errno_location();
#line 878
          ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___15, "setsockopt(TCP_DEFER_ACCEPT, %d) for %V failed, ignored",
                             value, & (ls + i)->addr_text);
          }
        }
#line 883
        goto __Cont;
      }
    }
#line 887
    if ((ls + i)->add_deferred) {
#line 888
      (ls + i)->deferred_accept = 1U;
    }
#line 916
    if ((ls + i)->wildcard) {
#line 916
      if ((ls + i)->type == 2) {
#line 916
        if ((int )((ls + i)->sockaddr)->sa_family == 2) {
          {
#line 920
          value = 1;
#line 922
          tmp___18 = setsockopt((ls + i)->fd, 0, 8, (void const   *)(& value), (socklen_t )sizeof(int ));
          }
#line 922
          if (tmp___18 == -1) {
#line 926
            if ((cycle->log)->log_level >= 2UL) {
              {
#line 926
              tmp___17 = __errno_location();
#line 926
              ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___17, "setsockopt(IP_PKTINFO) for %V failed, ignored",
                                 & (ls + i)->addr_text);
              }
            }
          }
        }
      }
    }
#line 937
    if ((ls + i)->wildcard) {
#line 937
      if ((ls + i)->type == 2) {
#line 937
        if ((int )((ls + i)->sockaddr)->sa_family == 10) {
          {
#line 941
          value = 1;
#line 943
          tmp___20 = setsockopt((ls + i)->fd, 41, 49, (void const   *)(& value), (socklen_t )sizeof(int ));
          }
#line 943
          if (tmp___20 == -1) {
#line 947
            if ((cycle->log)->log_level >= 2UL) {
              {
#line 947
              tmp___19 = __errno_location();
#line 947
              ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___19, "setsockopt(IPV6_RECVPKTINFO) for %V failed, ignored",
                                 & (ls + i)->addr_text);
              }
            }
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 665
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 957
  return;
}
}
#line 961 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
void ngx_close_listening_sockets(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_listening_t *ls ;
  ngx_connection_t *c ;
  int *tmp ;
  int tmp___0 ;
  u_char *name ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 968
  if (ngx_event_flags & 512UL) {
#line 969
    return;
  }
#line 972
  ngx_accept_mutex_held = (ngx_uint_t )0;
#line 973
  ngx_use_accept_mutex = (ngx_uint_t )0;
#line 975
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 976
  i = (ngx_uint_t )0;
  {
#line 976
  while (1) {
    while_continue: /* CIL Label */ ;
#line 976
    if (! (i < cycle->listening.nelts)) {
#line 976
      goto while_break;
    }
#line 978
    c = (ls + i)->connection;
#line 980
    if (c) {
#line 981
      if ((c->read)->active) {
#line 982
        if (ngx_event_flags & 64UL) {
          {
#line 990
          (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )0);
          }
        } else {
          {
#line 993
          (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )1);
          }
        }
      }
      {
#line 997
      ngx_free_connection(c);
#line 999
      c->fd = -1;
      }
    }
    {
#line 1005
    tmp___0 = close((ls + i)->fd);
    }
#line 1005
    if (tmp___0 == -1) {
#line 1006
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 1006
        tmp = __errno_location();
#line 1006
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp, "close() socket %V failed",
                           & (ls + i)->addr_text);
        }
      }
    }
#line 1012
    if ((int )((ls + i)->sockaddr)->sa_family == 1) {
#line 1012
      if (ngx_process <= 1UL) {
#line 1012
        if (ngx_new_binary == 0) {
          {
#line 1016
          name = ((ls + i)->addr_text.data + sizeof("unix:")) - 1;
#line 1018
          tmp___2 = unlink((char const   *)name);
          }
#line 1018
          if (tmp___2 == -1) {
#line 1019
            if ((cycle->log)->log_level >= 1UL) {
              {
#line 1019
              tmp___1 = __errno_location();
#line 1019
              ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___1, "unlink() %s failed",
                                 name);
              }
            }
          }
        }
      }
    }
#line 1026
    (ls + i)->fd = -1;
#line 976
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1029
  cycle->listening.nelts = (ngx_uint_t )0;
#line 1030
  return;
}
}
#line 1033 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
ngx_connection_t *ngx_get_connection(ngx_socket_t s , ngx_log_t *log ) 
{ 
  ngx_uint_t instance ;
  ngx_event_t *rev ;
  ngx_event_t *wev ;
  ngx_connection_t *c ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1042
  if (ngx_cycle->files) {
#line 1042
    if ((ngx_uint_t )s >= (ngx_uint_t )ngx_cycle->files_n) {
#line 1043
      if (log->log_level >= 2UL) {
        {
#line 1043
        ngx_log_error_core((ngx_uint_t )2, log, 0, "the new socket has number %d, but only %ui files are available",
                           s, ngx_cycle->files_n);
        }
      }
#line 1047
      return ((ngx_connection_t *)((void *)0));
    }
  }
#line 1050
  c = (ngx_connection_t *)ngx_cycle->free_connections;
#line 1052
  if ((unsigned long )c == (unsigned long )((void *)0)) {
    {
#line 1053
    ngx_drain_connections((ngx_cycle_t *)ngx_cycle);
#line 1054
    c = (ngx_connection_t *)ngx_cycle->free_connections;
    }
  }
#line 1057
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1058
    if (log->log_level >= 2UL) {
      {
#line 1058
      ngx_log_error_core((ngx_uint_t )2, log, 0, "%ui worker_connections are not enough",
                         ngx_cycle->connection_n);
      }
    }
#line 1062
    return ((ngx_connection_t *)((void *)0));
  }
#line 1065
  ngx_cycle->free_connections = (ngx_connection_t */* volatile  */)c->data;
#line 1066
  ngx_cycle->free_connection_n -= (ngx_uint_t volatile   )1;
#line 1068
  if (ngx_cycle->files) {
#line 1068
    if ((unsigned long )*(ngx_cycle->files + s) == (unsigned long )((void *)0)) {
#line 1069
      *(ngx_cycle->files + s) = c;
    }
  }
  {
#line 1072
  rev = c->read;
#line 1073
  wev = c->write;
#line 1075
  memset((void *)c, 0, sizeof(ngx_connection_t ));
#line 1077
  c->read = rev;
#line 1078
  c->write = wev;
#line 1079
  c->fd = s;
#line 1080
  c->log = log;
#line 1082
  instance = (ngx_uint_t )rev->instance;
#line 1084
  memset((void *)rev, 0, sizeof(ngx_event_t ));
#line 1085
  memset((void *)wev, 0, sizeof(ngx_event_t ));
#line 1087
  rev->instance = (unsigned int )(! instance);
#line 1088
  wev->instance = (unsigned int )(! instance);
#line 1090
  rev->index = (ngx_uint_t )3503345872U;
#line 1091
  wev->index = (ngx_uint_t )3503345872U;
#line 1093
  rev->data = (void *)c;
#line 1094
  wev->data = (void *)c;
#line 1096
  wev->write = 1U;
  }
#line 1098
  return (c);
}
}
#line 1102 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
void ngx_free_connection(ngx_connection_t *c ) 
{ 


  {
#line 1105
  c->data = (void *)ngx_cycle->free_connections;
#line 1106
  ngx_cycle->free_connections = (ngx_connection_t */* volatile  */)c;
#line 1107
  ngx_cycle->free_connection_n += (ngx_uint_t volatile   )1;
#line 1109
  if (ngx_cycle->files) {
#line 1109
    if ((unsigned long )*(ngx_cycle->files + c->fd) == (unsigned long )c) {
#line 1110
      *(ngx_cycle->files + c->fd) = (ngx_connection_t *)((void *)0);
    }
  }
#line 1112
  return;
}
}
#line 1115 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
void ngx_close_connection(ngx_connection_t *c ) 
{ 
  ngx_err_t err ;
  ngx_uint_t log_error ;
  ngx_uint_t level ;
  ngx_socket_t fd ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1122
  if (c->fd == -1) {
#line 1123
    if ((c->log)->log_level >= 2UL) {
      {
#line 1123
      ngx_log_error_core((ngx_uint_t )2, c->log, 0, "connection already closed");
      }
    }
#line 1124
    return;
  }
#line 1127
  if ((c->read)->timer_set) {
    {
#line 1128
    ngx_event_del_timer(c->read);
    }
  }
#line 1131
  if ((c->write)->timer_set) {
    {
#line 1132
    ngx_event_del_timer(c->write);
    }
  }
#line 1135
  if (! c->shared) {
#line 1136
    if (ngx_event_actions.del_conn) {
      {
#line 1137
      (*(ngx_event_actions.del_conn))(c, (ngx_uint_t )1);
      }
    } else {
#line 1140
      if ((c->read)->active) {
        {
#line 1141
        (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )1);
        }
      } else
#line 1140
      if ((c->read)->disabled) {
        {
#line 1141
        (*(ngx_event_actions.del))(c->read, (ngx_int_t )8193, (ngx_uint_t )1);
        }
      }
#line 1144
      if ((c->write)->active) {
        {
#line 1145
        (*(ngx_event_actions.del))(c->write, (ngx_int_t )4, (ngx_uint_t )1);
        }
      } else
#line 1144
      if ((c->write)->disabled) {
        {
#line 1145
        (*(ngx_event_actions.del))(c->write, (ngx_int_t )4, (ngx_uint_t )1);
        }
      }
    }
  }
#line 1150
  if ((c->read)->posted) {
#line 1151
    (c->read)->posted = 0U;
#line 1151
    ((c->read)->queue.next)->prev = (c->read)->queue.prev;
#line 1151
    ((c->read)->queue.prev)->next = (c->read)->queue.next;
  }
#line 1154
  if ((c->write)->posted) {
#line 1155
    (c->write)->posted = 0U;
#line 1155
    ((c->write)->queue.next)->prev = (c->write)->queue.prev;
#line 1155
    ((c->write)->queue.prev)->next = (c->write)->queue.next;
  }
  {
#line 1158
  (c->read)->closed = 1U;
#line 1159
  (c->write)->closed = 1U;
#line 1161
  ngx_reusable_connection(c, (ngx_uint_t )0);
#line 1163
  log_error = (ngx_uint_t )c->log_error;
#line 1165
  ngx_free_connection(c);
#line 1167
  fd = c->fd;
#line 1168
  c->fd = -1;
  }
#line 1170
  if (c->shared) {
#line 1171
    return;
  }
  {
#line 1174
  tmp___0 = close(fd);
  }
#line 1174
  if (tmp___0 == -1) {
    {
#line 1176
    tmp = __errno_location();
#line 1176
    err = *tmp;
    }
#line 1178
    if (err == 104) {
#line 1178
      goto _L;
    } else
#line 1178
    if (err == 107) {
      _L: /* CIL Label */ 
      {
#line 1182
      if (log_error == 2UL) {
#line 1182
        goto case_2;
      }
#line 1186
      if (log_error == 1UL) {
#line 1186
        goto case_1;
      }
#line 1190
      goto switch_default;
      case_2: /* CIL Label */ 
#line 1183
      level = (ngx_uint_t )7;
#line 1184
      goto switch_break;
      case_1: /* CIL Label */ 
#line 1187
      level = (ngx_uint_t )4;
#line 1188
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1191
      level = (ngx_uint_t )3;
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 1195
      level = (ngx_uint_t )3;
    }
#line 1198
    if ((c->log)->log_level >= level) {
      {
#line 1198
      ngx_log_error_core(level, c->log, err, "close() socket %d failed", fd);
      }
    }
  }
#line 1200
  return;
}
}
#line 1203 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
void ngx_reusable_connection(ngx_connection_t *c , ngx_uint_t reusable ) 
{ 


  {
#line 1209
  if (c->reusable) {
#line 1210
    (c->queue.next)->prev = c->queue.prev;
#line 1210
    (c->queue.prev)->next = c->queue.next;
#line 1211
    ngx_cycle->reusable_connections_n -= (ngx_uint_t volatile   )1;
  }
#line 1218
  c->reusable = (unsigned int )reusable;
#line 1220
  if (reusable) {
#line 1223
    c->queue.next = ((ngx_queue_t *)(& ngx_cycle->reusable_connections_queue))->next;
#line 1223
    (c->queue.next)->prev = & c->queue;
#line 1223
    c->queue.prev = (ngx_queue_t *)(& ngx_cycle->reusable_connections_queue);
#line 1223
    ((ngx_queue_t *)(& ngx_cycle->reusable_connections_queue))->next = & c->queue;
#line 1225
    ngx_cycle->reusable_connections_n += (ngx_uint_t volatile   )1;
  }
#line 1231
  return;
}
}
#line 1234 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
static void ngx_drain_connections(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_queue_t *q ;
  ngx_connection_t *c ;
  ngx_uint_t tmp___0 ;
  ngx_uint_t tmp___1 ;

  {
#line 1241
  if (32UL > cycle->reusable_connections_n / 8UL) {
#line 1241
    tmp___1 = cycle->reusable_connections_n / 8UL;
  } else {
#line 1241
    tmp___1 = (ngx_uint_t )32;
  }
#line 1241
  if (tmp___1 < 1UL) {
#line 1241
    n = (ngx_uint_t )1;
  } else {
#line 1241
    if (32UL > cycle->reusable_connections_n / 8UL) {
#line 1241
      tmp___0 = cycle->reusable_connections_n / 8UL;
    } else {
#line 1241
      tmp___0 = (ngx_uint_t )32;
    }
#line 1241
    n = tmp___0;
  }
#line 1243
  i = (ngx_uint_t )0;
  {
#line 1243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1243
    if (! (i < n)) {
#line 1243
      goto while_break;
    }
#line 1244
    if ((unsigned long )(& cycle->reusable_connections_queue) == (unsigned long )cycle->reusable_connections_queue.prev) {
#line 1245
      goto while_break;
    }
    {
#line 1248
    q = cycle->reusable_connections_queue.prev;
#line 1249
    c = (ngx_connection_t *)((u_char *)q - (unsigned long )(& ((ngx_connection_t *)0)->queue));
#line 1254
    c->close = 1U;
#line 1255
    (*((c->read)->handler))(c->read);
#line 1243
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1257
  return;
}
}
#line 1260 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
void ngx_close_idle_connections(ngx_cycle_t *cycle ) 
{ 
  ngx_uint_t i ;
  ngx_connection_t *c ;

  {
#line 1266
  c = cycle->connections;
#line 1268
  i = (ngx_uint_t )0;
  {
#line 1268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1268
    if (! (i < cycle->connection_n)) {
#line 1268
      goto while_break;
    }
#line 1272
    if ((c + i)->fd != -1) {
#line 1272
      if ((c + i)->idle) {
        {
#line 1273
        (c + i)->close = 1U;
#line 1274
        (*(((c + i)->read)->handler))((c + i)->read);
        }
      }
    }
#line 1268
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1277
  return;
}
}
#line 1280 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
ngx_int_t ngx_connection_local_sockaddr(ngx_connection_t *c , ngx_str_t *s , ngx_uint_t port ) 
{ 
  socklen_t len ;
  ngx_uint_t addr ;
  ngx_sockaddr_t sa ;
  struct sockaddr_in *sin ;
  ngx_uint_t i ;
  struct sockaddr_in6 *sin6 ;
  int *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;
  void *__cil_tmp15 ;
  void *__cil_tmp16 ;
  void *__cil_tmp17 ;
  void *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1293
  addr = (ngx_uint_t )0;
#line 1295
  if (c->local_socklen) {
    {
#line 1299
    if ((int )(c->local_sockaddr)->sa_family == 10) {
#line 1299
      goto case_10;
    }
#line 1310
    if ((int )(c->local_sockaddr)->sa_family == 1) {
#line 1310
      goto case_1;
    }
#line 1315
    goto switch_default;
    case_10: /* CIL Label */ 
#line 1300
    sin6 = (struct sockaddr_in6 *)c->local_sockaddr;
#line 1302
    i = (ngx_uint_t )0;
    {
#line 1302
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1302
      if (addr == 0UL) {
#line 1302
        if (! (i < 16UL)) {
#line 1302
          goto while_break;
        }
      } else {
#line 1302
        goto while_break;
      }
#line 1303
      addr |= (unsigned long )sin6->sin6_addr.__in6_u.__u6_addr8[i];
#line 1302
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 1306
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1311
    addr = (ngx_uint_t )1;
#line 1312
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1316
    sin = (struct sockaddr_in *)c->local_sockaddr;
#line 1317
    addr = (ngx_uint_t )sin->sin_addr.s_addr;
#line 1318
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 1322
  if (addr == 0UL) {
    {
#line 1324
    len = (socklen_t )sizeof(ngx_sockaddr_t );
#line 1326
    tmp___0 = getsockname(c->fd, (struct sockaddr */* __restrict  */)(& sa.sockaddr),
                          (socklen_t */* __restrict  */)(& len));
    }
#line 1326
    if (tmp___0 == -1) {
      {
#line 1327
      tmp = __errno_location();
#line 1327
      ngx_connection_error(c, *tmp, (char *)"getsockname() failed");
      }
#line 1328
      return ((ngx_int_t )-1);
    }
    {
#line 1331
    tmp___1 = ngx_palloc(c->pool, (size_t )len);
#line 1331
    c->local_sockaddr = (struct sockaddr *)tmp___1;
    }
#line 1332
    if ((unsigned long )c->local_sockaddr == (unsigned long )((void *)0)) {
#line 1333
      return ((ngx_int_t )-1);
    }
    {
#line 1336
    memcpy((void */* __restrict  */)c->local_sockaddr, (void const   */* __restrict  */)(& sa),
           (size_t )len);
#line 1338
    c->local_socklen = len;
    }
  }
#line 1341
  if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 1342
    return ((ngx_int_t )0);
  }
  {
#line 1345
  s->len = ngx_sock_ntop(c->local_sockaddr, c->local_socklen, s->data, s->len, port);
  }
#line 1348
  return ((ngx_int_t )0);
}
}
#line 1352 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
ngx_int_t ngx_tcp_nodelay(ngx_connection_t *c ) 
{ 
  int tcp_nodelay ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
#line 1357
  if (c->tcp_nodelay != 0U) {
#line 1358
    return ((ngx_int_t )0);
  }
  {
#line 1363
  tcp_nodelay = 1;
#line 1365
  tmp___0 = setsockopt(c->fd, 6, 1, (void const   *)(& tcp_nodelay), (socklen_t )sizeof(int ));
  }
#line 1365
  if (tmp___0 == -1) {
    {
#line 1384
    tmp = __errno_location();
#line 1384
    ngx_connection_error(c, *tmp, (char *)"setsockopt(TCP_NODELAY) failed");
    }
#line 1386
    return ((ngx_int_t )-1);
  }
#line 1389
  c->tcp_nodelay = 1U;
#line 1391
  return ((ngx_int_t )0);
}
}
#line 1395 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_connection.c"
ngx_int_t ngx_connection_error(ngx_connection_t *c , ngx_err_t err , char *text ) 
{ 
  ngx_uint_t level ;

  {
#line 1402
  if (err == 104) {
#line 1402
    if (c->log_error == 3U) {
#line 1408
      return ((ngx_int_t )0);
    }
  }
#line 1417
  if (err == 0) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 104) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 32) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 107) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 110) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 111) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 100) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 101) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 112) {
#line 1417
    goto _L;
  } else
#line 1417
  if (err == 113) {
    _L: /* CIL Label */ 
    {
#line 1436
    if (c->log_error == 2U) {
#line 1436
      goto case_2;
    }
#line 1436
    if (c->log_error == 3U) {
#line 1436
      goto case_2;
    }
#line 1436
    if (c->log_error == 4U) {
#line 1436
      goto case_2;
    }
#line 1440
    goto switch_default;
    case_2: /* CIL Label */ 
    case_3: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 1437
    level = (ngx_uint_t )7;
#line 1438
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1441
    level = (ngx_uint_t )4;
    switch_break: /* CIL Label */ ;
    }
  } else {
#line 1445
    level = (ngx_uint_t )2;
  }
#line 1448
  if ((c->log)->log_level >= level) {
    {
#line 1448
    ngx_log_error_core(level, c->log, err, (char const   *)text);
    }
  }
#line 1450
  return ((ngx_int_t )-1);
}
}
#line 36 "/usr/include/semaphore.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sem_init)(sem_t *__sem ,
                                                                               int __pshared ,
                                                                               unsigned int __value ) ;
#line 39
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sem_destroy)(sem_t *__sem ) ;
#line 54
extern int sem_wait(sem_t *__sem ) ;
#line 69
extern  __attribute__((__nothrow__)) int sem_post(sem_t *__sem ) ;
#line 42 "src/core/ngx_shmtx.h"
void ngx_shmtx_destroy(ngx_shmtx_t *mtx ) ;
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_shmtx.c"
static void ngx_shmtx_wakeup(ngx_shmtx_t *mtx ) ;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_shmtx.c"
ngx_int_t ngx_shmtx_create(ngx_shmtx_t *mtx , ngx_shmtx_sh_t *addr , u_char *name ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 21
  mtx->lock = & addr->lock;
#line 23
  if (mtx->spin == 0xffffffffffffffffUL) {
#line 24
    return ((ngx_int_t )0);
  }
  {
#line 27
  mtx->spin = (ngx_uint_t )2048;
#line 31
  mtx->wait = & addr->wait;
#line 33
  tmp___0 = sem_init(& mtx->sem, 1, 0U);
  }
#line 33
  if (tmp___0 == -1) {
#line 34
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 34
      tmp = __errno_location();
#line 34
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp, "sem_init() failed");
      }
    }
  } else {
#line 37
    mtx->semaphore = (ngx_uint_t )1;
  }
#line 42
  return ((ngx_int_t )0);
}
}
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_shmtx.c"
void ngx_shmtx_destroy(ngx_shmtx_t *mtx ) 
{ 
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;

  {
#line 51
  if (mtx->semaphore) {
    {
#line 52
    tmp___0 = sem_destroy(& mtx->sem);
    }
#line 52
    if (tmp___0 == -1) {
#line 53
      if ((ngx_cycle->log)->log_level >= 2UL) {
        {
#line 53
        tmp = __errno_location();
#line 53
        ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp, "sem_destroy() failed");
        }
      }
    }
  }
#line 59
  return;
}
}
#line 62 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_shmtx.c"
ngx_uint_t ngx_shmtx_trylock(ngx_shmtx_t *mtx ) 
{ 
  _Bool tmp ;
  int tmp___0 ;

  {
#line 65
  if (*(mtx->lock) == (ngx_atomic_t )0) {
    {
#line 65
    tmp = __sync_bool_compare_and_swap(mtx->lock, 0, ngx_pid);
    }
#line 65
    if (tmp) {
#line 65
      tmp___0 = 1;
    } else {
#line 65
      tmp___0 = 0;
    }
  } else {
#line 65
    tmp___0 = 0;
  }
#line 65
  return ((ngx_uint_t )tmp___0);
}
}
#line 69 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_shmtx.c"
void ngx_shmtx_lock(ngx_shmtx_t *mtx ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  _Bool tmp ;
  _Bool tmp___0 ;
  _Bool tmp___1 ;
  ngx_err_t err ;
  int *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;

  {
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (*(mtx->lock) == (ngx_atomic_t )0) {
      {
#line 78
      tmp = __sync_bool_compare_and_swap(mtx->lock, 0, ngx_pid);
      }
#line 78
      if (tmp) {
#line 79
        return;
      }
    }
#line 82
    if (ngx_ncpu > 1L) {
#line 84
      n = (ngx_uint_t )1;
      {
#line 84
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 84
        if (! (n < mtx->spin)) {
#line 84
          goto while_break___0;
        }
#line 86
        i = (ngx_uint_t )0;
        {
#line 86
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 86
          if (! (i < n)) {
#line 86
            goto while_break___1;
          }
#line 87
          __asm__  ("pause":);
#line 86
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 90
        if (*(mtx->lock) == (ngx_atomic_t )0) {
          {
#line 90
          tmp___0 = __sync_bool_compare_and_swap(mtx->lock, 0, ngx_pid);
          }
#line 90
          if (tmp___0) {
#line 93
            return;
          }
        }
#line 84
        n <<= 1;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 100
    if (mtx->semaphore) {
      {
#line 101
      __sync_fetch_and_add(mtx->wait, (ngx_atomic_t )1);
      }
#line 103
      if (*(mtx->lock) == (ngx_atomic_t )0) {
        {
#line 103
        tmp___1 = __sync_bool_compare_and_swap(mtx->lock, 0, ngx_pid);
        }
#line 103
        if (tmp___1) {
          {
#line 104
          __sync_fetch_and_add(mtx->wait, (ngx_atomic_t )-1);
          }
#line 105
          return;
        }
      }
      {
#line 111
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 111
        tmp___3 = sem_wait(& mtx->sem);
        }
#line 111
        if (! (tmp___3 == -1)) {
#line 111
          goto while_break___2;
        }
        {
#line 114
        tmp___2 = __errno_location();
#line 114
        err = *tmp___2;
        }
#line 116
        if (err != 4) {
#line 117
          if ((ngx_cycle->log)->log_level >= 2UL) {
            {
#line 117
            ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, err, "sem_wait() failed while waiting on shmtx");
            }
          }
#line 119
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 126
      goto __Cont;
    }
    {
#line 131
    sched_yield();
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 136 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_shmtx.c"
void ngx_shmtx_unlock(ngx_shmtx_t *mtx ) 
{ 
  _Bool tmp ;

  {
  {
#line 143
  tmp = __sync_bool_compare_and_swap(mtx->lock, ngx_pid, 0);
  }
#line 143
  if (tmp) {
    {
#line 144
    ngx_shmtx_wakeup(mtx);
    }
  }
#line 146
  return;
}
}
#line 149 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_shmtx.c"
ngx_uint_t ngx_shmtx_force_unlock(ngx_shmtx_t *mtx , ngx_pid_t pid ) 
{ 
  _Bool tmp ;

  {
  {
#line 155
  tmp = __sync_bool_compare_and_swap(mtx->lock, pid, 0);
  }
#line 155
  if (tmp) {
    {
#line 156
    ngx_shmtx_wakeup(mtx);
    }
#line 157
    return ((ngx_uint_t )1);
  }
#line 160
  return ((ngx_uint_t )0);
}
}
#line 164 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_shmtx.c"
static void ngx_shmtx_wakeup(ngx_shmtx_t *mtx ) 
{ 
  ngx_atomic_uint_t wait___0 ;
  _Bool tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 170
  if (! mtx->semaphore) {
#line 171
    return;
  }
  {
#line 174
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    wait___0 = (ngx_atomic_uint_t )*(mtx->wait);
#line 178
    if ((ngx_atomic_int_t )wait___0 <= 0L) {
#line 179
      return;
    }
    {
#line 182
    tmp = __sync_bool_compare_and_swap(mtx->wait, wait___0, wait___0 - 1UL);
    }
#line 182
    if (tmp) {
#line 183
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 190
  tmp___1 = sem_post(& mtx->sem);
  }
#line 190
  if (tmp___1 == -1) {
#line 191
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 191
      tmp___0 = __errno_location();
#line 191
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, *tmp___0, "sem_post() failed while wake shmtx");
      }
    }
  }
#line 196
  return;
}
}
/* compiler builtin: 
   void __sync_synchronize(...) ;  */
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 23 "src/core/ngx_times.h"
void ngx_time_init(void) ;
#line 34 "src/core/ngx_times.h"
ngx_time_t volatile   *ngx_cached_time  ;
#line 39 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_err_log_time  ;
#line 40 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_http_time  ;
#line 41 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_http_log_time  ;
#line 42 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_http_log_iso8601  ;
#line 43 "src/core/ngx_times.h"
ngx_str_t volatile   ngx_cached_syslog_time  ;
#line 49 "src/core/ngx_times.h"
ngx_msec_t volatile   ngx_current_msec  ;
#line 23 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static ngx_uint_t slot  ;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static ngx_atomic_t ngx_time_lock  ;
#line 42 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static ngx_int_t cached_gmtoff  ;
#line 45 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static ngx_time_t cached_time[64]  ;
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static u_char cached_err_log_time[64][sizeof("1970/09/28 12:00:00")]  ;
#line 48 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static u_char cached_http_time[64][sizeof("Mon, 28 Sep 1970 06:00:00 GMT")]  ;
#line 50 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static u_char cached_http_log_time[64][sizeof("28/Sep/1970:12:00:00 +0600")]  ;
#line 52 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static u_char cached_http_log_iso8601[64][sizeof("1970-09-28T12:00:00+06:00")]  ;
#line 54 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static u_char cached_syslog_time[64][sizeof("Sep 28 12:00:00")]  ;
#line 58 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static char *week[7]  = {      (char *)"Sun",      (char *)"Mon",      (char *)"Tue",      (char *)"Wed", 
        (char *)"Thu",      (char *)"Fri",      (char *)"Sat"};
#line 59 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
static char *months___0[12]  = 
#line 59
  {      (char *)"Jan",      (char *)"Feb",      (char *)"Mar",      (char *)"Apr", 
        (char *)"May",      (char *)"Jun",      (char *)"Jul",      (char *)"Aug", 
        (char *)"Sep",      (char *)"Oct",      (char *)"Nov",      (char *)"Dec"};
#line 62 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
void ngx_time_init(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
#line 65
  ngx_cached_err_log_time.len = (size_t volatile   )(sizeof("1970/09/28 12:00:00") - 1UL);
#line 66
  ngx_cached_http_time.len = (size_t volatile   )(sizeof("Mon, 28 Sep 1970 06:00:00 GMT") - 1UL);
#line 67
  ngx_cached_http_log_time.len = (size_t volatile   )(sizeof("28/Sep/1970:12:00:00 +0600") - 1UL);
#line 68
  ngx_cached_http_log_iso8601.len = (size_t volatile   )(sizeof("1970-09-28T12:00:00+06:00") - 1UL);
#line 69
  ngx_cached_syslog_time.len = (size_t volatile   )(sizeof("Sep 28 12:00:00") - 1UL);
#line 71
  ngx_cached_time = (ngx_time_t volatile   *)(& cached_time[0]);
#line 73
  ngx_time_update();
  }
#line 74
  return;
}
}
#line 77 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
void ngx_time_update(void) 
{ 
  u_char *p0 ;
  u_char *p1 ;
  u_char *p2 ;
  u_char *p3 ;
  u_char *p4 ;
  ngx_tm_t tm ;
  ngx_tm_t gmt ;
  time_t sec ;
  ngx_uint_t msec ;
  ngx_time_t *tp ;
  struct timeval tv ;
  _Bool tmp ;
  long tmp___0 ;
  ngx_int_t tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  ngx_int_t tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 87
  if (ngx_time_lock == (ngx_atomic_t )0) {
    {
#line 87
    tmp = __sync_bool_compare_and_swap(& ngx_time_lock, 0, 1);
    }
#line 87
    if (! tmp) {
#line 88
      return;
    }
  } else {
#line 88
    return;
  }
  {
#line 91
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 93
  sec = tv.tv_sec;
#line 94
  msec = (ngx_uint_t )(tv.tv_usec / 1000L);
#line 96
  ngx_current_msec = (ngx_msec_t volatile   )((ngx_msec_t )sec * 1000UL + msec);
#line 98
  tp = & cached_time[slot];
  }
#line 100
  if (tp->sec == sec) {
#line 101
    tp->msec = msec;
#line 102
    ngx_time_lock = (ngx_atomic_t )0;
#line 103
    return;
  }
#line 106
  if (slot == 63UL) {
#line 107
    slot = (ngx_uint_t )0;
  } else {
#line 109
    slot ++;
  }
  {
#line 112
  tp = & cached_time[slot];
#line 114
  tp->sec = sec;
#line 115
  tp->msec = msec;
#line 117
  ngx_gmtime(sec, & gmt);
#line 120
  p0 = & cached_http_time[slot][0];
#line 122
  ngx_sprintf(p0, "%s, %02d %s %4d %02d:%02d:%02d GMT", week[gmt.tm_wday], gmt.tm_mday,
              months___0[gmt.tm_mon - 1], gmt.tm_year, gmt.tm_hour, gmt.tm_min, gmt.tm_sec);
#line 134
  ngx_localtime(sec, & tm);
#line 135
  cached_gmtoff = tm.tm_gmtoff / 60L;
#line 136
  tp->gmtoff = cached_gmtoff;
#line 147
  p1 = & cached_err_log_time[slot][0];
#line 149
  ngx_sprintf(p1, "%4d/%02d/%02d %02d:%02d:%02d", tm.tm_year, tm.tm_mon, tm.tm_mday,
              tm.tm_hour, tm.tm_min, tm.tm_sec);
#line 155
  p2 = & cached_http_log_time[slot][0];
  }
#line 157
  if (tp->gmtoff % 60L >= 0L) {
#line 157
    tmp___0 = tp->gmtoff % 60L;
  } else {
#line 157
    tmp___0 = - (tp->gmtoff % 60L);
  }
#line 157
  if (tp->gmtoff / 60L >= 0L) {
#line 157
    tmp___1 = tp->gmtoff / 60L;
  } else {
#line 157
    tmp___1 = - (tp->gmtoff / 60L);
  }
#line 157
  if (tp->gmtoff < 0L) {
#line 157
    tmp___2 = '-';
  } else {
#line 157
    tmp___2 = '+';
  }
  {
#line 157
  ngx_sprintf(p2, "%02d/%s/%d:%02d:%02d:%02d %c%02i%02i", tm.tm_mday, months___0[tm.tm_mon - 1],
              tm.tm_year, tm.tm_hour, tm.tm_min, tm.tm_sec, tmp___2, tmp___1, tmp___0);
#line 164
  p3 = & cached_http_log_iso8601[slot][0];
  }
#line 166
  if (tp->gmtoff % 60L >= 0L) {
#line 166
    tmp___3 = tp->gmtoff % 60L;
  } else {
#line 166
    tmp___3 = - (tp->gmtoff % 60L);
  }
#line 166
  if (tp->gmtoff / 60L >= 0L) {
#line 166
    tmp___4 = tp->gmtoff / 60L;
  } else {
#line 166
    tmp___4 = - (tp->gmtoff / 60L);
  }
#line 166
  if (tp->gmtoff < 0L) {
#line 166
    tmp___5 = '-';
  } else {
#line 166
    tmp___5 = '+';
  }
  {
#line 166
  ngx_sprintf(p3, "%4d-%02d-%02dT%02d:%02d:%02d%c%02i:%02i", tm.tm_year, tm.tm_mon,
              tm.tm_mday, tm.tm_hour, tm.tm_min, tm.tm_sec, tmp___5, tmp___4, tmp___3);
#line 173
  p4 = & cached_syslog_time[slot][0];
#line 175
  ngx_sprintf(p4, "%s %2d %02d:%02d:%02d", months___0[tm.tm_mon - 1], tm.tm_mday,
              tm.tm_hour, tm.tm_min, tm.tm_sec);
#line 179
  __sync_synchronize();
#line 181
  ngx_cached_time = (ngx_time_t volatile   *)tp;
#line 182
  ngx_cached_http_time.data = (u_char */* volatile  */)p0;
#line 183
  ngx_cached_err_log_time.data = (u_char */* volatile  */)p1;
#line 184
  ngx_cached_http_log_time.data = (u_char */* volatile  */)p2;
#line 185
  ngx_cached_http_log_iso8601.data = (u_char */* volatile  */)p3;
#line 186
  ngx_cached_syslog_time.data = (u_char */* volatile  */)p4;
#line 188
  ngx_time_lock = (ngx_atomic_t )0;
  }
#line 189
  return;
}
}
#line 194 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
void ngx_time_sigsafe_update(void) 
{ 
  u_char *p ;
  u_char *p2 ;
  ngx_tm_t tm ;
  time_t sec ;
  ngx_time_t *tp ;
  struct timeval tv ;
  _Bool tmp ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 203
  if (ngx_time_lock == (ngx_atomic_t )0) {
    {
#line 203
    tmp = __sync_bool_compare_and_swap(& ngx_time_lock, 0, 1);
    }
#line 203
    if (! tmp) {
#line 204
      return;
    }
  } else {
#line 204
    return;
  }
  {
#line 207
  gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )((void *)0));
#line 209
  sec = tv.tv_sec;
#line 211
  tp = & cached_time[slot];
  }
#line 213
  if (tp->sec == sec) {
#line 214
    ngx_time_lock = (ngx_atomic_t )0;
#line 215
    return;
  }
#line 218
  if (slot == 63UL) {
#line 219
    slot = (ngx_uint_t )0;
  } else {
#line 221
    slot ++;
  }
  {
#line 224
  tp = & cached_time[slot];
#line 226
  tp->sec = (time_t )0;
#line 228
  ngx_gmtime(sec + cached_gmtoff * 60L, & tm);
#line 230
  p = & cached_err_log_time[slot][0];
#line 232
  ngx_sprintf(p, "%4d/%02d/%02d %02d:%02d:%02d", tm.tm_year, tm.tm_mon, tm.tm_mday,
              tm.tm_hour, tm.tm_min, tm.tm_sec);
#line 237
  p2 = & cached_syslog_time[slot][0];
#line 239
  ngx_sprintf(p2, "%s %2d %02d:%02d:%02d", months___0[tm.tm_mon - 1], tm.tm_mday,
              tm.tm_hour, tm.tm_min, tm.tm_sec);
#line 243
  __sync_synchronize();
#line 245
  ngx_cached_err_log_time.data = (u_char */* volatile  */)p;
#line 246
  ngx_cached_syslog_time.data = (u_char */* volatile  */)p2;
#line 248
  ngx_time_lock = (ngx_atomic_t )0;
  }
#line 249
  return;
}
}
#line 254 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
u_char *ngx_http_time(u_char *buf , time_t t ) 
{ 
  ngx_tm_t tm ;
  u_char *tmp ;
  char *__cil_tmp5 ;

  {
  {
#line 259
  ngx_gmtime(t, & tm);
#line 261
  tmp = ngx_sprintf(buf, "%s, %02d %s %4d %02d:%02d:%02d GMT", week[tm.tm_wday], tm.tm_mday,
                    months___0[tm.tm_mon - 1], tm.tm_year, tm.tm_hour, tm.tm_min,
                    tm.tm_sec);
  }
#line 261
  return (tmp);
}
}
#line 272 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
u_char *ngx_http_cookie_time(u_char *buf , time_t t ) 
{ 
  ngx_tm_t tm ;
  int tmp ;
  char const   *tmp___0 ;
  u_char *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
#line 277
  ngx_gmtime(t, & tm);
  }
#line 284
  if (tm.tm_year > 2037) {
#line 284
    tmp = tm.tm_year;
  } else {
#line 284
    tmp = tm.tm_year % 100;
  }
#line 284
  if (tm.tm_year > 2037) {
#line 284
    tmp___0 = "%s, %02d-%s-%d %02d:%02d:%02d GMT";
  } else {
#line 284
    tmp___0 = "%s, %02d-%s-%02d %02d:%02d:%02d GMT";
  }
  {
#line 284
  tmp___1 = ngx_sprintf(buf, tmp___0, week[tm.tm_wday], tm.tm_mday, months___0[tm.tm_mon - 1],
                        tmp, tm.tm_hour, tm.tm_min, tm.tm_sec);
  }
#line 284
  return (tmp___1);
}
}
#line 299 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
void ngx_gmtime(time_t t , ngx_tm_t *tp ) 
{ 
  ngx_int_t yday ;
  ngx_uint_t sec ;
  ngx_uint_t min ;
  ngx_uint_t hour ;
  ngx_uint_t mday___0 ;
  ngx_uint_t mon ;
  ngx_uint_t year ;
  ngx_uint_t wday ;
  ngx_uint_t days ;
  ngx_uint_t leap ;
  int tmp ;

  {
#line 307
  if (t < 0L) {
#line 308
    t = (time_t )0;
  }
#line 311
  days = (ngx_uint_t )(t / 86400L);
#line 312
  sec = (ngx_uint_t )(t % 86400L);
#line 319
  if (days > 2932896UL) {
#line 320
    days = (ngx_uint_t )2932896;
#line 321
    sec = (ngx_uint_t )86399;
  }
#line 326
  wday = (4UL + days) % 7UL;
#line 328
  hour = sec / 3600UL;
#line 329
  sec %= 3600UL;
#line 330
  min = sec / 60UL;
#line 331
  sec %= 60UL;
#line 339
  days = (days - 59UL) + 719527UL;
#line 348
  year = ((days + 2UL) * 400UL) / 146097UL;
#line 350
  yday = (ngx_int_t )(days - (((365UL * year + year / 4UL) - year / 100UL) + year / 400UL));
#line 352
  if (yday < 0L) {
#line 353
    if (year % 4UL == 0UL) {
#line 353
      if (year % 100UL) {
#line 353
        tmp = 1;
      } else
#line 353
      if (year % 400UL == 0UL) {
#line 353
        tmp = 1;
      } else {
#line 353
        tmp = 0;
      }
    } else {
#line 353
      tmp = 0;
    }
#line 353
    leap = (ngx_uint_t )tmp;
#line 354
    yday = (ngx_int_t )((365UL + leap) + (ngx_uint_t )yday);
#line 355
    year --;
  }
#line 366
  mon = (ngx_uint_t )(((yday + 31L) * 10L) / 306L);
#line 370
  mday___0 = ((ngx_uint_t )yday - ((367UL * mon) / 12UL - 30UL)) + 1UL;
#line 372
  if (yday >= 306L) {
#line 374
    year ++;
#line 375
    mon -= 10UL;
  } else {
#line 385
    mon += 2UL;
  }
#line 394
  tp->tm_sec = (int )sec;
#line 395
  tp->tm_min = (int )min;
#line 396
  tp->tm_hour = (int )hour;
#line 397
  tp->tm_mday = (int )mday___0;
#line 398
  tp->tm_mon = (int )mon;
#line 399
  tp->tm_year = (int )year;
#line 400
  tp->tm_wday = (int )wday;
#line 401
  return;
}
}
#line 404 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_times.c"
time_t ngx_next_time(time_t when ) 
{ 
  time_t now ;
  time_t next ;
  struct tm tm ;

  {
  {
#line 410
  now = (time_t )ngx_cached_time->sec;
#line 412
  ngx_libc_localtime(now, & tm);
#line 414
  tm.tm_hour = (int )(when / 3600L);
#line 415
  when %= 3600L;
#line 416
  tm.tm_min = (int )(when / 60L);
#line 417
  tm.tm_sec = (int )(when % 60L);
#line 419
  next = mktime(& tm);
  }
#line 421
  if (next == -1L) {
#line 422
    return ((time_t )-1);
  }
#line 425
  if (next - now > 0L) {
#line 426
    return (next);
  }
  {
#line 429
  (tm.tm_mday) ++;
#line 433
  next = mktime(& tm);
  }
#line 435
  if (next != -1L) {
#line 436
    return (next);
  }
#line 439
  return ((time_t )-1);
}
}
#line 62 "src/core/ngx_slab.h"
void ngx_slab_sizes_init(void) ;
#line 66
void *ngx_slab_calloc(ngx_slab_pool_t *pool , size_t size ) ;
#line 68
void ngx_slab_free(ngx_slab_pool_t *pool , void *p ) ;
#line 72 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
static ngx_slab_page_t *ngx_slab_alloc_pages(ngx_slab_pool_t *pool , ngx_uint_t pages ) ;
#line 74
static void ngx_slab_free_pages(ngx_slab_pool_t *pool , ngx_slab_page_t *page , ngx_uint_t pages ) ;
#line 76
static void ngx_slab_error(ngx_slab_pool_t *pool , ngx_uint_t level , char *text ) ;
#line 80 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
static ngx_uint_t ngx_slab_max_size  ;
#line 81 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
static ngx_uint_t ngx_slab_exact_size  ;
#line 82 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
static ngx_uint_t ngx_slab_exact_shift  ;
#line 85 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
void ngx_slab_sizes_init(void) 
{ 
  ngx_uint_t n ;

  {
#line 90
  ngx_slab_max_size = ngx_pagesize / 2UL;
#line 91
  ngx_slab_exact_size = ngx_pagesize / (8UL * sizeof(uintptr_t ));
#line 92
  n = ngx_slab_exact_size;
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    n >>= 1;
#line 92
    if (! n) {
#line 92
      goto while_break;
    }
#line 92
    ngx_slab_exact_shift ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return;
}
}
#line 98 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
void ngx_slab_init(ngx_slab_pool_t *pool ) 
{ 
  u_char *p ;
  size_t size ;
  ngx_int_t m ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t pages ;
  ngx_slab_page_t *slots ;
  ngx_slab_page_t *page ;

  {
#line 107
  pool->min_size = 1UL << pool->min_shift;
#line 109
  slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 111
  p = (u_char *)slots;
#line 112
  size = (size_t )(pool->end - p);
#line 116
  n = ngx_pagesize_shift - pool->min_shift;
#line 118
  i = (ngx_uint_t )0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < n)) {
#line 118
      goto while_break;
    }
#line 120
    (slots + i)->slab = (uintptr_t )0;
#line 121
    (slots + i)->next = slots + i;
#line 122
    (slots + i)->prev = (uintptr_t )0;
#line 118
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 125
  p += n * sizeof(ngx_slab_page_t );
#line 127
  pool->stats = (ngx_slab_stat_t *)p;
#line 128
  memset((void *)pool->stats, 0, n * sizeof(ngx_slab_stat_t ));
#line 130
  p += n * sizeof(ngx_slab_stat_t );
#line 132
  size -= n * (sizeof(ngx_slab_page_t ) + sizeof(ngx_slab_stat_t ));
#line 134
  pages = size / (ngx_pagesize + sizeof(ngx_slab_page_t ));
#line 136
  pool->pages = (ngx_slab_page_t *)p;
#line 137
  memset((void *)pool->pages, 0, pages * sizeof(ngx_slab_page_t ));
#line 139
  page = pool->pages;
#line 142
  pool->free.slab = (uintptr_t )0;
#line 143
  pool->free.next = page;
#line 144
  pool->free.prev = (uintptr_t )0;
#line 146
  page->slab = pages;
#line 147
  page->next = & pool->free;
#line 148
  page->prev = (uintptr_t )(& pool->free);
#line 150
  pool->start = (u_char *)(((uintptr_t )(p + pages * sizeof(ngx_slab_page_t )) + (ngx_pagesize - 1UL)) & ~ (ngx_pagesize - 1UL));
#line 153
  m = (ngx_int_t )(pages - (ngx_uint_t )(pool->end - pool->start) / ngx_pagesize);
  }
#line 154
  if (m > 0L) {
#line 155
    pages -= (ngx_uint_t )m;
#line 156
    page->slab = pages;
  }
#line 159
  pool->last = pool->pages + pages;
#line 160
  pool->pfree = pages;
#line 162
  pool->log_nomem = 1U;
#line 163
  pool->log_ctx = & pool->zero;
#line 164
  pool->zero = (u_char )'\000';
#line 165
  return;
}
}
#line 168 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
void *ngx_slab_alloc(ngx_slab_pool_t *pool , size_t size ) 
{ 
  void *p ;

  {
  {
#line 173
  ngx_shmtx_lock(& pool->mutex);
#line 175
  p = ngx_slab_alloc_locked(pool, size);
#line 177
  ngx_shmtx_unlock(& pool->mutex);
  }
#line 179
  return (p);
}
}
#line 183 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
void *ngx_slab_alloc_locked(ngx_slab_pool_t *pool , size_t size ) 
{ 
  size_t s ;
  uintptr_t p ;
  uintptr_t m ;
  uintptr_t mask ;
  uintptr_t *bitmap ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t slot___0 ;
  ngx_uint_t shift ;
  ngx_uint_t map___0 ;
  ngx_slab_page_t *page ;
  ngx_slab_page_t *prev ;
  ngx_slab_page_t *slots ;
  int tmp ;
  char *__cil_tmp17 ;

  {
#line 191
  if (size > ngx_slab_max_size) {
#line 196
    if (size % ngx_pagesize) {
#line 196
      tmp = 1;
    } else {
#line 196
      tmp = 0;
    }
    {
#line 196
    page = ngx_slab_alloc_pages(pool, (size >> ngx_pagesize_shift) + (size_t )tmp);
    }
#line 198
    if (page) {
#line 199
      p = (uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start;
    } else {
#line 202
      p = (uintptr_t )0;
    }
#line 205
    goto done;
  }
#line 208
  if (size > pool->min_size) {
#line 209
    shift = (ngx_uint_t )1;
#line 210
    s = size - 1UL;
    {
#line 210
    while (1) {
      while_continue: /* CIL Label */ ;
#line 210
      s >>= 1;
#line 210
      if (! s) {
#line 210
        goto while_break;
      }
#line 210
      shift ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 211
    slot___0 = shift - pool->min_shift;
  } else {
#line 214
    shift = pool->min_shift;
#line 215
    slot___0 = (ngx_uint_t )0;
  }
#line 218
  ((pool->stats + slot___0)->reqs) ++;
#line 223
  slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 224
  page = (slots + slot___0)->next;
#line 226
  if ((unsigned long )page->next != (unsigned long )page) {
#line 228
    if (shift < ngx_slab_exact_shift) {
#line 230
      bitmap = (uintptr_t *)((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start);
#line 232
      map___0 = (ngx_pagesize >> shift) / (8UL * sizeof(uintptr_t ));
#line 234
      n = (ngx_uint_t )0;
      {
#line 234
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 234
        if (! (n < map___0)) {
#line 234
          goto while_break___0;
        }
#line 236
        if (*(bitmap + n) != 0xffffffffffffffffUL) {
#line 238
          m = (uintptr_t )1;
#line 238
          i = (ngx_uint_t )0;
          {
#line 238
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 238
            if (! m) {
#line 238
              goto while_break___1;
            }
#line 239
            if (*(bitmap + n) & m) {
#line 240
              goto __Cont;
            }
#line 243
            *(bitmap + n) |= m;
#line 245
            i = ((n * 8UL) * sizeof(uintptr_t ) + i) << shift;
#line 247
            p = (uintptr_t )bitmap + i;
#line 249
            ((pool->stats + slot___0)->used) ++;
#line 251
            if (*(bitmap + n) == 0xffffffffffffffffUL) {
#line 252
              n ++;
              {
#line 252
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 252
                if (! (n < map___0)) {
#line 252
                  goto while_break___2;
                }
#line 253
                if (*(bitmap + n) != 0xffffffffffffffffUL) {
#line 254
                  goto done;
                }
#line 252
                n ++;
              }
              while_break___2: /* CIL Label */ ;
              }
#line 258
              prev = (ngx_slab_page_t *)(page->prev & 0xfffffffffffffffcUL);
#line 259
              prev->next = page->next;
#line 260
              (page->next)->prev = page->prev;
#line 262
              page->next = (ngx_slab_page_t *)((void *)0);
#line 263
              page->prev = (uintptr_t )3;
            }
#line 266
            goto done;
            __Cont: /* CIL Label */ 
#line 238
            m <<= 1;
#line 238
            i ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
#line 234
        n ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else
#line 271
    if (shift == ngx_slab_exact_shift) {
#line 273
      m = (uintptr_t )1;
#line 273
      i = (ngx_uint_t )0;
      {
#line 273
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 273
        if (! m) {
#line 273
          goto while_break___3;
        }
#line 274
        if (page->slab & m) {
#line 275
          goto __Cont___0;
        }
#line 278
        page->slab |= m;
#line 280
        if (page->slab == 0xffffffffffffffffUL) {
#line 281
          prev = (ngx_slab_page_t *)(page->prev & 0xfffffffffffffffcUL);
#line 282
          prev->next = page->next;
#line 283
          (page->next)->prev = page->prev;
#line 285
          page->next = (ngx_slab_page_t *)((void *)0);
#line 286
          page->prev = (uintptr_t )2;
        }
#line 289
        p = ((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start) + (i << shift);
#line 291
        ((pool->stats + slot___0)->used) ++;
#line 293
        goto done;
        __Cont___0: /* CIL Label */ 
#line 273
        m <<= 1;
#line 273
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
    } else {
#line 298
      mask = (1UL << (ngx_pagesize >> shift)) - 1UL;
#line 299
      mask <<= 32;
#line 301
      m = 1UL << 32;
#line 301
      i = (ngx_uint_t )0;
      {
#line 301
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 301
        if (! (m & mask)) {
#line 301
          goto while_break___4;
        }
#line 305
        if (page->slab & m) {
#line 306
          goto __Cont___1;
        }
#line 309
        page->slab |= m;
#line 311
        if ((page->slab & 0xffffffff00000000UL) == mask) {
#line 312
          prev = (ngx_slab_page_t *)(page->prev & 0xfffffffffffffffcUL);
#line 313
          prev->next = page->next;
#line 314
          (page->next)->prev = page->prev;
#line 316
          page->next = (ngx_slab_page_t *)((void *)0);
#line 317
          page->prev = (uintptr_t )1;
        }
#line 320
        p = ((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start) + (i << shift);
#line 322
        ((pool->stats + slot___0)->used) ++;
#line 324
        goto done;
        __Cont___1: /* CIL Label */ 
#line 301
        m <<= 1;
#line 301
        i ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
    {
#line 328
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_alloc(): page is busy");
#line 329
    ngx_debug_point();
    }
  }
  {
#line 332
  page = ngx_slab_alloc_pages(pool, (ngx_uint_t )1);
  }
#line 334
  if (page) {
#line 335
    if (shift < ngx_slab_exact_shift) {
#line 336
      bitmap = (uintptr_t *)((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start);
#line 338
      n = (ngx_pagesize >> shift) / (ngx_uint_t )((1 << shift) * 8);
#line 340
      if (n == 0UL) {
#line 341
        n = (ngx_uint_t )1;
      }
#line 346
      i = (ngx_uint_t )0;
      {
#line 346
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 346
        if (! (i < (n + 1UL) / (8UL * sizeof(uintptr_t )))) {
#line 346
          goto while_break___5;
        }
#line 347
        *(bitmap + i) = 0xffffffffffffffffUL;
#line 346
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 350
      m = (1UL << (n + 1UL) % (8UL * sizeof(uintptr_t ))) - 1UL;
#line 351
      *(bitmap + i) = m;
#line 353
      map___0 = (ngx_pagesize >> shift) / (8UL * sizeof(uintptr_t ));
#line 355
      i ++;
      {
#line 355
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 355
        if (! (i < map___0)) {
#line 355
          goto while_break___6;
        }
#line 356
        *(bitmap + i) = (uintptr_t )0;
#line 355
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 359
      page->slab = shift;
#line 360
      page->next = slots + slot___0;
#line 361
      page->prev = (uintptr_t )(slots + slot___0) | 3UL;
#line 363
      (slots + slot___0)->next = page;
#line 365
      (pool->stats + slot___0)->total += (ngx_pagesize >> shift) - n;
#line 367
      p = ((uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start) + (n << shift);
#line 369
      ((pool->stats + slot___0)->used) ++;
#line 371
      goto done;
    } else
#line 373
    if (shift == ngx_slab_exact_shift) {
#line 375
      page->slab = (uintptr_t )1;
#line 376
      page->next = slots + slot___0;
#line 377
      page->prev = (uintptr_t )(slots + slot___0) | 2UL;
#line 379
      (slots + slot___0)->next = page;
#line 381
      (pool->stats + slot___0)->total += 8UL * sizeof(uintptr_t );
#line 383
      p = (uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start;
#line 385
      ((pool->stats + slot___0)->used) ++;
#line 387
      goto done;
    } else {
#line 391
      page->slab = (1UL << 32) | shift;
#line 392
      page->next = slots + slot___0;
#line 393
      page->prev = (uintptr_t )(slots + slot___0) | 1UL;
#line 395
      (slots + slot___0)->next = page;
#line 397
      (pool->stats + slot___0)->total += ngx_pagesize >> shift;
#line 399
      p = (uintptr_t )((page - pool->pages) << ngx_pagesize_shift) + (uintptr_t )pool->start;
#line 401
      ((pool->stats + slot___0)->used) ++;
#line 403
      goto done;
    }
  }
#line 407
  p = (uintptr_t )0;
#line 409
  ((pool->stats + slot___0)->fails) ++;
  done: ;
#line 416
  return ((void *)p);
}
}
#line 420 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
void *ngx_slab_calloc(ngx_slab_pool_t *pool , size_t size ) 
{ 
  void *p ;

  {
  {
#line 425
  ngx_shmtx_lock(& pool->mutex);
#line 427
  p = ngx_slab_calloc_locked(pool, size);
#line 429
  ngx_shmtx_unlock(& pool->mutex);
  }
#line 431
  return (p);
}
}
#line 435 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
void *ngx_slab_calloc_locked(ngx_slab_pool_t *pool , size_t size ) 
{ 
  void *p ;

  {
  {
#line 440
  p = ngx_slab_alloc_locked(pool, size);
  }
#line 441
  if (p) {
    {
#line 442
    memset(p, 0, size);
    }
  }
#line 445
  return (p);
}
}
#line 449 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
void ngx_slab_free(ngx_slab_pool_t *pool , void *p ) 
{ 


  {
  {
#line 452
  ngx_shmtx_lock(& pool->mutex);
#line 454
  ngx_slab_free_locked(pool, p);
#line 456
  ngx_shmtx_unlock(& pool->mutex);
  }
#line 457
  return;
}
}
#line 460 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
void ngx_slab_free_locked(ngx_slab_pool_t *pool , void *p ) 
{ 
  size_t size ;
  uintptr_t slab ;
  uintptr_t m ;
  uintptr_t *bitmap ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t type ;
  ngx_uint_t slot___0 ;
  ngx_uint_t shift ;
  ngx_uint_t map___0 ;
  ngx_slab_page_t *slots ;
  ngx_slab_page_t *page ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 470
  if ((unsigned long )((u_char *)p) < (unsigned long )pool->start) {
    {
#line 471
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): outside of pool");
    }
#line 472
    goto fail;
  } else
#line 470
  if ((unsigned long )((u_char *)p) > (unsigned long )pool->end) {
    {
#line 471
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): outside of pool");
    }
#line 472
    goto fail;
  }
#line 475
  n = (ngx_uint_t )(((u_char *)p - pool->start) >> ngx_pagesize_shift);
#line 476
  page = pool->pages + n;
#line 477
  slab = page->slab;
#line 478
  type = page->prev & 3UL;
  {
#line 482
  if (type == 3UL) {
#line 482
    goto case_3;
  }
#line 542
  if (type == 2UL) {
#line 542
    goto case_2;
  }
#line 580
  if (type == 1UL) {
#line 580
    goto case_1;
  }
#line 620
  if (type == 0UL) {
#line 620
    goto case_0;
  }
#line 480
  goto switch_break;
  case_3: /* CIL Label */ 
#line 484
  shift = slab & 15UL;
#line 485
  size = 1UL << shift;
#line 487
  if ((uintptr_t )p & (size - 1UL)) {
#line 488
    goto wrong_chunk;
  }
#line 491
  n = ((uintptr_t )p & (ngx_pagesize - 1UL)) >> shift;
#line 492
  m = 1UL << n % (8UL * sizeof(uintptr_t ));
#line 493
  n /= 8UL * sizeof(uintptr_t );
#line 494
  bitmap = (uintptr_t *)((uintptr_t )p & ~ (ngx_pagesize - 1UL));
#line 497
  if (*(bitmap + n) & m) {
#line 498
    slot___0 = shift - pool->min_shift;
#line 500
    if ((unsigned long )page->next == (unsigned long )((void *)0)) {
#line 501
      slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 503
      page->next = (slots + slot___0)->next;
#line 504
      (slots + slot___0)->next = page;
#line 506
      page->prev = (uintptr_t )(slots + slot___0) | 3UL;
#line 507
      (page->next)->prev = (uintptr_t )page | 3UL;
    }
#line 510
    *(bitmap + n) &= ~ m;
#line 512
    n = (ngx_pagesize >> shift) / (ngx_uint_t )((1 << shift) * 8);
#line 514
    if (n == 0UL) {
#line 515
      n = (ngx_uint_t )1;
    }
#line 518
    i = n / (8UL * sizeof(uintptr_t ));
#line 519
    m = (1UL << n % (8UL * sizeof(uintptr_t ))) - 1UL;
#line 521
    if (*(bitmap + i) & ~ m) {
#line 522
      goto done;
    }
#line 525
    map___0 = (ngx_pagesize >> shift) / (8UL * sizeof(uintptr_t ));
#line 527
    i ++;
    {
#line 527
    while (1) {
      while_continue: /* CIL Label */ ;
#line 527
      if (! (i < map___0)) {
#line 527
        goto while_break;
      }
#line 528
      if (*(bitmap + i)) {
#line 529
        goto done;
      }
#line 527
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 533
    ngx_slab_free_pages(pool, page, (ngx_uint_t )1);
#line 535
    (pool->stats + slot___0)->total -= (ngx_pagesize >> shift) - n;
    }
#line 537
    goto done;
  }
#line 540
  goto chunk_already_free;
  case_2: /* CIL Label */ 
#line 544
  m = 1UL << (((uintptr_t )p & (ngx_pagesize - 1UL)) >> ngx_slab_exact_shift);
#line 546
  size = ngx_slab_exact_size;
#line 548
  if ((uintptr_t )p & (size - 1UL)) {
#line 549
    goto wrong_chunk;
  }
#line 552
  if (slab & m) {
#line 553
    slot___0 = ngx_slab_exact_shift - pool->min_shift;
#line 555
    if (slab == 0xffffffffffffffffUL) {
#line 556
      slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 558
      page->next = (slots + slot___0)->next;
#line 559
      (slots + slot___0)->next = page;
#line 561
      page->prev = (uintptr_t )(slots + slot___0) | 2UL;
#line 562
      (page->next)->prev = (uintptr_t )page | 2UL;
    }
#line 565
    page->slab &= ~ m;
#line 567
    if (page->slab) {
#line 568
      goto done;
    }
    {
#line 571
    ngx_slab_free_pages(pool, page, (ngx_uint_t )1);
#line 573
    (pool->stats + slot___0)->total -= 8UL * sizeof(uintptr_t );
    }
#line 575
    goto done;
  }
#line 578
  goto chunk_already_free;
  case_1: /* CIL Label */ 
#line 582
  shift = slab & 15UL;
#line 583
  size = 1UL << shift;
#line 585
  if ((uintptr_t )p & (size - 1UL)) {
#line 586
    goto wrong_chunk;
  }
#line 589
  m = 1UL << ((((uintptr_t )p & (ngx_pagesize - 1UL)) >> shift) + 32UL);
#line 592
  if (slab & m) {
#line 593
    slot___0 = shift - pool->min_shift;
#line 595
    if ((unsigned long )page->next == (unsigned long )((void *)0)) {
#line 596
      slots = (ngx_slab_page_t *)((u_char *)pool + sizeof(ngx_slab_pool_t ));
#line 598
      page->next = (slots + slot___0)->next;
#line 599
      (slots + slot___0)->next = page;
#line 601
      page->prev = (uintptr_t )(slots + slot___0) | 1UL;
#line 602
      (page->next)->prev = (uintptr_t )page | 1UL;
    }
#line 605
    page->slab &= ~ m;
#line 607
    if (page->slab & 0xffffffff00000000UL) {
#line 608
      goto done;
    }
    {
#line 611
    ngx_slab_free_pages(pool, page, (ngx_uint_t )1);
#line 613
    (pool->stats + slot___0)->total -= ngx_pagesize >> shift;
    }
#line 615
    goto done;
  }
#line 618
  goto chunk_already_free;
  case_0: /* CIL Label */ 
#line 622
  if ((uintptr_t )p & (ngx_pagesize - 1UL)) {
#line 623
    goto wrong_chunk;
  }
#line 626
  if (! (slab & 0x8000000000000000UL)) {
    {
#line 627
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): page is already free");
    }
#line 629
    goto fail;
  }
#line 632
  if (slab == 0xffffffffffffffffUL) {
    {
#line 633
    ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): pointer to wrong page");
    }
#line 635
    goto fail;
  }
  {
#line 638
  n = (ngx_uint_t )(((u_char *)p - pool->start) >> ngx_pagesize_shift);
#line 639
  size = slab & 9223372036854775807UL;
#line 641
  ngx_slab_free_pages(pool, pool->pages + n, size);
  }
#line 645
  return;
  switch_break: /* CIL Label */ ;
  }
#line 650
  return;
  done: 
#line 654
  ((pool->stats + slot___0)->used) --;
#line 658
  return;
  wrong_chunk: 
  {
#line 662
  ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): pointer to wrong chunk");
  }
#line 665
  goto fail;
  chunk_already_free: 
  {
#line 669
  ngx_slab_error(pool, (ngx_uint_t )2, (char *)"ngx_slab_free(): chunk is already free");
  }
  fail: 
#line 674
  return;
}
}
#line 678 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
static ngx_slab_page_t *ngx_slab_alloc_pages(ngx_slab_pool_t *pool , ngx_uint_t pages ) 
{ 
  ngx_slab_page_t *page ;
  ngx_slab_page_t *p ;
  char *__cil_tmp5 ;

  {
#line 683
  page = pool->free.next;
  {
#line 683
  while (1) {
    while_continue: /* CIL Label */ ;
#line 683
    if (! ((unsigned long )page != (unsigned long )(& pool->free))) {
#line 683
      goto while_break;
    }
#line 685
    if (page->slab >= pages) {
#line 687
      if (page->slab > pages) {
#line 688
        (page + (page->slab - 1UL))->prev = (uintptr_t )(page + pages);
#line 690
        (page + pages)->slab = page->slab - pages;
#line 691
        (page + pages)->next = page->next;
#line 692
        (page + pages)->prev = page->prev;
#line 694
        p = (ngx_slab_page_t *)page->prev;
#line 695
        p->next = page + pages;
#line 696
        (page->next)->prev = (uintptr_t )(page + pages);
      } else {
#line 699
        p = (ngx_slab_page_t *)page->prev;
#line 700
        p->next = page->next;
#line 701
        (page->next)->prev = page->prev;
      }
#line 704
      page->slab = pages | 0x8000000000000000UL;
#line 705
      page->next = (ngx_slab_page_t *)((void *)0);
#line 706
      page->prev = (uintptr_t )0;
#line 708
      pool->pfree -= pages;
#line 710
      pages --;
#line 710
      if (pages == 0UL) {
#line 711
        return (page);
      }
#line 714
      p = page + 1;
      {
#line 714
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 714
        if (! pages) {
#line 714
          goto while_break___0;
        }
#line 715
        p->slab = 0xffffffffffffffffUL;
#line 716
        p->next = (ngx_slab_page_t *)((void *)0);
#line 717
        p->prev = (uintptr_t )0;
#line 718
        p ++;
#line 714
        pages --;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 721
      return (page);
    }
#line 683
    page = page->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 725
  if (pool->log_nomem) {
    {
#line 726
    ngx_slab_error(pool, (ngx_uint_t )3, (char *)"ngx_slab_alloc() failed: no memory");
    }
  }
#line 730
  return ((ngx_slab_page_t *)((void *)0));
}
}
#line 734 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
static void ngx_slab_free_pages(ngx_slab_pool_t *pool , ngx_slab_page_t *page , ngx_uint_t pages ) 
{ 
  ngx_slab_page_t *prev ;
  ngx_slab_page_t *join ;
  ngx_uint_t tmp ;

  {
#line 740
  pool->pfree += pages;
#line 742
  tmp = pages;
#line 742
  pages --;
#line 742
  page->slab = tmp;
#line 744
  if (pages) {
    {
#line 745
    memset((void *)(page + 1), 0, pages * sizeof(ngx_slab_page_t ));
    }
  }
#line 748
  if (page->next) {
#line 749
    prev = (ngx_slab_page_t *)(page->prev & 0xfffffffffffffffcUL);
#line 750
    prev->next = page->next;
#line 751
    (page->next)->prev = page->prev;
  }
#line 754
  join = page + page->slab;
#line 756
  if ((unsigned long )join < (unsigned long )pool->last) {
#line 758
    if ((join->prev & 3UL) == 0UL) {
#line 760
      if ((unsigned long )join->next != (unsigned long )((void *)0)) {
#line 761
        pages += join->slab;
#line 762
        page->slab += join->slab;
#line 764
        prev = (ngx_slab_page_t *)(join->prev & 0xfffffffffffffffcUL);
#line 765
        prev->next = join->next;
#line 766
        (join->next)->prev = join->prev;
#line 768
        join->slab = (uintptr_t )0;
#line 769
        join->next = (ngx_slab_page_t *)((void *)0);
#line 770
        join->prev = (uintptr_t )0;
      }
    }
  }
#line 775
  if ((unsigned long )page > (unsigned long )pool->pages) {
#line 776
    join = page - 1;
#line 778
    if ((join->prev & 3UL) == 0UL) {
#line 780
      if (join->slab == 0UL) {
#line 781
        join = (ngx_slab_page_t *)(join->prev & 0xfffffffffffffffcUL);
      }
#line 784
      if ((unsigned long )join->next != (unsigned long )((void *)0)) {
#line 785
        pages += join->slab;
#line 786
        join->slab += page->slab;
#line 788
        prev = (ngx_slab_page_t *)(join->prev & 0xfffffffffffffffcUL);
#line 789
        prev->next = join->next;
#line 790
        (join->next)->prev = join->prev;
#line 792
        page->slab = (uintptr_t )0;
#line 793
        page->next = (ngx_slab_page_t *)((void *)0);
#line 794
        page->prev = (uintptr_t )0;
#line 796
        page = join;
      }
    }
  }
#line 801
  if (pages) {
#line 802
    (page + pages)->prev = (uintptr_t )page;
  }
#line 805
  page->prev = (uintptr_t )(& pool->free);
#line 806
  page->next = pool->free.next;
#line 808
  (page->next)->prev = (uintptr_t )page;
#line 810
  pool->free.next = page;
#line 811
  return;
}
}
#line 814 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_slab.c"
static void ngx_slab_error(ngx_slab_pool_t *pool , ngx_uint_t level , char *text ) 
{ 
  char *__cil_tmp4 ;

  {
#line 817
  if ((ngx_cycle->log)->log_level >= level) {
    {
#line 817
    ngx_log_error_core(level, (ngx_log_t *)ngx_cycle->log, 0, "%s%s", text, pool->log_ctx);
    }
  }
#line 818
  return;
}
}
#line 82 "src/core/ngx_palloc.h"
void *ngx_pmemalign(ngx_pool_t *pool , size_t size , size_t alignment ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
static ngx_radix_node_t *ngx_radix_alloc(ngx_radix_tree_t *tree ) ;
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
ngx_radix_tree_t *ngx_radix_tree_create(ngx_pool_t *pool , ngx_int_t preallocate ) 
{ 
  uint32_t key ;
  uint32_t mask ;
  uint32_t inc___0 ;
  ngx_radix_tree_t *tree ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;

  {
  {
#line 21
  tmp = ngx_palloc(pool, sizeof(ngx_radix_tree_t ));
#line 21
  tree = (ngx_radix_tree_t *)tmp;
  }
#line 22
  if ((unsigned long )tree == (unsigned long )((void *)0)) {
#line 23
    return ((ngx_radix_tree_t *)((void *)0));
  }
  {
#line 26
  tree->pool = pool;
#line 27
  tree->free = (ngx_radix_node_t *)((void *)0);
#line 28
  tree->start = (char *)((void *)0);
#line 29
  tree->size = (size_t )0;
#line 31
  tree->root = ngx_radix_alloc(tree);
  }
#line 32
  if ((unsigned long )tree->root == (unsigned long )((void *)0)) {
#line 33
    return ((ngx_radix_tree_t *)((void *)0));
  }
#line 36
  (tree->root)->right = (ngx_radix_node_t *)((void *)0);
#line 37
  (tree->root)->left = (ngx_radix_node_t *)((void *)0);
#line 38
  (tree->root)->parent = (ngx_radix_node_t *)((void *)0);
#line 39
  (tree->root)->value = (uintptr_t )-1;
#line 41
  if (preallocate == 0L) {
#line 42
    return (tree);
  }
#line 62
  if (preallocate == -1L) {
    {
#line 66
    if (ngx_pagesize / sizeof(ngx_radix_node_t ) == 128UL) {
#line 66
      goto case_128;
    }
#line 71
    if (ngx_pagesize / sizeof(ngx_radix_node_t ) == 256UL) {
#line 71
      goto case_256;
    }
#line 76
    goto switch_default;
    case_128: /* CIL Label */ 
#line 67
    preallocate = (ngx_int_t )6;
#line 68
    goto switch_break;
    case_256: /* CIL Label */ 
#line 72
    preallocate = (ngx_int_t )7;
#line 73
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 77
    preallocate = (ngx_int_t )8;
    switch_break: /* CIL Label */ ;
    }
  }
#line 81
  mask = (uint32_t )0;
#line 82
  inc___0 = 2147483648U;
  {
#line 84
  while (1) {
    while_continue: /* CIL Label */ ;
#line 84
    tmp___1 = preallocate;
#line 84
    preallocate --;
#line 84
    if (! tmp___1) {
#line 84
      goto while_break;
    }
#line 86
    key = (uint32_t )0;
#line 87
    mask >>= 1;
#line 88
    mask |= 2147483648U;
    {
#line 90
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 91
      tmp___0 = ngx_radix32tree_insert(tree, key, mask, (uintptr_t )-1);
      }
#line 91
      if (tmp___0 != 0L) {
#line 94
        return ((ngx_radix_tree_t *)((void *)0));
      }
#line 97
      key += inc___0;
#line 90
      if (! key) {
#line 90
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 101
    inc___0 >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (tree);
}
}
#line 108 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
ngx_int_t ngx_radix32tree_insert(ngx_radix_tree_t *tree , uint32_t key , uint32_t mask ,
                                 uintptr_t value ) 
{ 
  uint32_t bit ;
  ngx_radix_node_t *node ;
  ngx_radix_node_t *next ;

  {
#line 115
  bit = 2147483648U;
#line 117
  node = tree->root;
#line 118
  next = tree->root;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (bit & mask)) {
#line 120
      goto while_break;
    }
#line 121
    if (key & bit) {
#line 122
      next = node->right;
    } else {
#line 125
      next = node->left;
    }
#line 128
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 129
      goto while_break;
    }
#line 132
    bit >>= 1;
#line 133
    node = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  if (next) {
#line 137
    if (node->value != 0xffffffffffffffffUL) {
#line 138
      return ((ngx_int_t )-3);
    }
#line 141
    node->value = value;
#line 142
    return ((ngx_int_t )0);
  }
  {
#line 145
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 145
    if (! (bit & mask)) {
#line 145
      goto while_break___0;
    }
    {
#line 146
    next = ngx_radix_alloc(tree);
    }
#line 147
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 148
      return ((ngx_int_t )-1);
    }
#line 151
    next->right = (ngx_radix_node_t *)((void *)0);
#line 152
    next->left = (ngx_radix_node_t *)((void *)0);
#line 153
    next->parent = node;
#line 154
    next->value = (uintptr_t )-1;
#line 156
    if (key & bit) {
#line 157
      node->right = next;
    } else {
#line 160
      node->left = next;
    }
#line 163
    bit >>= 1;
#line 164
    node = next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 167
  node->value = value;
#line 169
  return ((ngx_int_t )0);
}
}
#line 173 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
ngx_int_t ngx_radix32tree_delete(ngx_radix_tree_t *tree , uint32_t key , uint32_t mask ) 
{ 
  uint32_t bit ;
  ngx_radix_node_t *node ;

  {
#line 179
  bit = 2147483648U;
#line 180
  node = tree->root;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (node) {
#line 182
      if (! (bit & mask)) {
#line 182
        goto while_break;
      }
    } else {
#line 182
      goto while_break;
    }
#line 183
    if (key & bit) {
#line 184
      node = node->right;
    } else {
#line 187
      node = node->left;
    }
#line 190
    bit >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 193
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 194
    return ((ngx_int_t )-1);
  }
#line 197
  if (node->right) {
#line 197
    goto _L;
  } else
#line 197
  if (node->left) {
    _L: /* CIL Label */ 
#line 198
    if (node->value != 0xffffffffffffffffUL) {
#line 199
      node->value = (uintptr_t )-1;
#line 200
      return ((ngx_int_t )0);
    }
#line 203
    return ((ngx_int_t )-1);
  }
  {
#line 206
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 207
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 208
      (node->parent)->right = (ngx_radix_node_t *)((void *)0);
    } else {
#line 211
      (node->parent)->left = (ngx_radix_node_t *)((void *)0);
    }
#line 214
    node->right = tree->free;
#line 215
    tree->free = node;
#line 217
    node = node->parent;
#line 219
    if (node->right) {
#line 220
      goto while_break___0;
    } else
#line 219
    if (node->left) {
#line 220
      goto while_break___0;
    }
#line 223
    if (node->value != 0xffffffffffffffffUL) {
#line 224
      goto while_break___0;
    }
#line 227
    if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 228
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  return ((ngx_int_t )0);
}
}
#line 236 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
uintptr_t ngx_radix32tree_find(ngx_radix_tree_t *tree , uint32_t key ) 
{ 
  uint32_t bit ;
  uintptr_t value ;
  ngx_radix_node_t *node ;

  {
#line 243
  bit = 2147483648U;
#line 244
  value = (uintptr_t )-1;
#line 245
  node = tree->root;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! node) {
#line 247
      goto while_break;
    }
#line 248
    if (node->value != 0xffffffffffffffffUL) {
#line 249
      value = node->value;
    }
#line 252
    if (key & bit) {
#line 253
      node = node->right;
    } else {
#line 256
      node = node->left;
    }
#line 259
    bit >>= 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return (value);
}
}
#line 268 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
ngx_int_t ngx_radix128tree_insert(ngx_radix_tree_t *tree , u_char *key , u_char *mask ,
                                  uintptr_t value ) 
{ 
  u_char bit ;
  ngx_uint_t i ;
  ngx_radix_node_t *node ;
  ngx_radix_node_t *next ;

  {
#line 276
  i = (ngx_uint_t )0;
#line 277
  bit = (u_char )128;
#line 279
  node = tree->root;
#line 280
  next = tree->root;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! ((int )bit & (int )*(mask + i))) {
#line 282
      goto while_break;
    }
#line 283
    if ((int )*(key + i) & (int )bit) {
#line 284
      next = node->right;
    } else {
#line 287
      next = node->left;
    }
#line 290
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 291
      goto while_break;
    }
#line 294
    bit = (u_char )((int )bit >> 1);
#line 295
    node = next;
#line 297
    if ((int )bit == 0) {
#line 298
      i ++;
#line 298
      if (i == 16UL) {
#line 299
        goto while_break;
      }
#line 302
      bit = (u_char )128;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  if (next) {
#line 307
    if (node->value != 0xffffffffffffffffUL) {
#line 308
      return ((ngx_int_t )-3);
    }
#line 311
    node->value = value;
#line 312
    return ((ngx_int_t )0);
  }
  {
#line 315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 315
    if (! ((int )bit & (int )*(mask + i))) {
#line 315
      goto while_break___0;
    }
    {
#line 316
    next = ngx_radix_alloc(tree);
    }
#line 317
    if ((unsigned long )next == (unsigned long )((void *)0)) {
#line 318
      return ((ngx_int_t )-1);
    }
#line 321
    next->right = (ngx_radix_node_t *)((void *)0);
#line 322
    next->left = (ngx_radix_node_t *)((void *)0);
#line 323
    next->parent = node;
#line 324
    next->value = (uintptr_t )-1;
#line 326
    if ((int )*(key + i) & (int )bit) {
#line 327
      node->right = next;
    } else {
#line 330
      node->left = next;
    }
#line 333
    bit = (u_char )((int )bit >> 1);
#line 334
    node = next;
#line 336
    if ((int )bit == 0) {
#line 337
      i ++;
#line 337
      if (i == 16UL) {
#line 338
        goto while_break___0;
      }
#line 341
      bit = (u_char )128;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 345
  node->value = value;
#line 347
  return ((ngx_int_t )0);
}
}
#line 351 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
ngx_int_t ngx_radix128tree_delete(ngx_radix_tree_t *tree , u_char *key , u_char *mask ) 
{ 
  u_char bit ;
  ngx_uint_t i ;
  ngx_radix_node_t *node ;

  {
#line 358
  i = (ngx_uint_t )0;
#line 359
  bit = (u_char )128;
#line 360
  node = tree->root;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (node) {
#line 362
      if (! ((int )bit & (int )*(mask + i))) {
#line 362
        goto while_break;
      }
    } else {
#line 362
      goto while_break;
    }
#line 363
    if ((int )*(key + i) & (int )bit) {
#line 364
      node = node->right;
    } else {
#line 367
      node = node->left;
    }
#line 370
    bit = (u_char )((int )bit >> 1);
#line 372
    if ((int )bit == 0) {
#line 373
      i ++;
#line 373
      if (i == 16UL) {
#line 374
        goto while_break;
      }
#line 377
      bit = (u_char )128;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  if ((unsigned long )node == (unsigned long )((void *)0)) {
#line 382
    return ((ngx_int_t )-1);
  }
#line 385
  if (node->right) {
#line 385
    goto _L;
  } else
#line 385
  if (node->left) {
    _L: /* CIL Label */ 
#line 386
    if (node->value != 0xffffffffffffffffUL) {
#line 387
      node->value = (uintptr_t )-1;
#line 388
      return ((ngx_int_t )0);
    }
#line 391
    return ((ngx_int_t )-1);
  }
  {
#line 394
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 395
    if ((unsigned long )(node->parent)->right == (unsigned long )node) {
#line 396
      (node->parent)->right = (ngx_radix_node_t *)((void *)0);
    } else {
#line 399
      (node->parent)->left = (ngx_radix_node_t *)((void *)0);
    }
#line 402
    node->right = tree->free;
#line 403
    tree->free = node;
#line 405
    node = node->parent;
#line 407
    if (node->right) {
#line 408
      goto while_break___0;
    } else
#line 407
    if (node->left) {
#line 408
      goto while_break___0;
    }
#line 411
    if (node->value != 0xffffffffffffffffUL) {
#line 412
      goto while_break___0;
    }
#line 415
    if ((unsigned long )node->parent == (unsigned long )((void *)0)) {
#line 416
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 420
  return ((ngx_int_t )0);
}
}
#line 424 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
uintptr_t ngx_radix128tree_find(ngx_radix_tree_t *tree , u_char *key ) 
{ 
  u_char bit ;
  uintptr_t value ;
  ngx_uint_t i ;
  ngx_radix_node_t *node ;

  {
#line 432
  i = (ngx_uint_t )0;
#line 433
  bit = (u_char )128;
#line 434
  value = (uintptr_t )-1;
#line 435
  node = tree->root;
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
#line 437
    if (! node) {
#line 437
      goto while_break;
    }
#line 438
    if (node->value != 0xffffffffffffffffUL) {
#line 439
      value = node->value;
    }
#line 442
    if ((int )*(key + i) & (int )bit) {
#line 443
      node = node->right;
    } else {
#line 446
      node = node->left;
    }
#line 449
    bit = (u_char )((int )bit >> 1);
#line 451
    if ((int )bit == 0) {
#line 452
      i ++;
#line 453
      bit = (u_char )128;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  return (value);
}
}
#line 463 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_radix_tree.c"
static ngx_radix_node_t *ngx_radix_alloc(ngx_radix_tree_t *tree ) 
{ 
  ngx_radix_node_t *p ;
  void *tmp ;

  {
#line 468
  if (tree->free) {
#line 469
    p = tree->free;
#line 470
    tree->free = (tree->free)->right;
#line 471
    return (p);
  }
#line 474
  if (tree->size < sizeof(ngx_radix_node_t )) {
    {
#line 475
    tmp = ngx_pmemalign(tree->pool, ngx_pagesize, ngx_pagesize);
#line 475
    tree->start = (char *)tmp;
    }
#line 476
    if ((unsigned long )tree->start == (unsigned long )((void *)0)) {
#line 477
      return ((ngx_radix_node_t *)((void *)0));
    }
#line 480
    tree->size = ngx_pagesize;
  }
#line 483
  p = (ngx_radix_node_t *)tree->start;
#line 484
  tree->start += sizeof(ngx_radix_node_t );
#line 485
  tree->size -= sizeof(ngx_radix_node_t );
#line 487
  return (p);
}
}
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rbtree.c"
__inline static void ngx_rbtree_left_rotate(ngx_rbtree_node_t **root , ngx_rbtree_node_t *sentinel ,
                                            ngx_rbtree_node_t *node ) ;
#line 20
__inline static void ngx_rbtree_right_rotate(ngx_rbtree_node_t **root , ngx_rbtree_node_t *sentinel ,
                                             ngx_rbtree_node_t *node ) ;
#line 24 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rbtree.c"
void ngx_rbtree_insert(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) 
{ 
  ngx_rbtree_node_t **root ;
  ngx_rbtree_node_t *temp ;
  ngx_rbtree_node_t *sentinel ;

  {
#line 31
  root = & tree->root;
#line 32
  sentinel = tree->sentinel;
#line 34
  if ((unsigned long )*root == (unsigned long )sentinel) {
#line 35
    node->parent = (ngx_rbtree_node_t *)((void *)0);
#line 36
    node->left = sentinel;
#line 37
    node->right = sentinel;
#line 38
    node->color = (u_char )0;
#line 39
    *root = node;
#line 41
    return;
  }
  {
#line 44
  (*(tree->insert))(*root, node, sentinel);
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if ((unsigned long )node != (unsigned long )*root) {
#line 48
      if (! (node->parent)->color) {
#line 48
        goto while_break;
      }
    } else {
#line 48
      goto while_break;
    }
#line 50
    if ((unsigned long )node->parent == (unsigned long )((node->parent)->parent)->left) {
#line 51
      temp = ((node->parent)->parent)->right;
#line 53
      if (temp->color) {
#line 54
        (node->parent)->color = (u_char )0;
#line 55
        temp->color = (u_char )0;
#line 56
        ((node->parent)->parent)->color = (u_char )1;
#line 57
        node = (node->parent)->parent;
      } else {
#line 60
        if ((unsigned long )node == (unsigned long )(node->parent)->right) {
          {
#line 61
          node = node->parent;
#line 62
          ngx_rbtree_left_rotate(root, sentinel, node);
          }
        }
        {
#line 65
        (node->parent)->color = (u_char )0;
#line 66
        ((node->parent)->parent)->color = (u_char )1;
#line 67
        ngx_rbtree_right_rotate(root, sentinel, (node->parent)->parent);
        }
      }
    } else {
#line 71
      temp = ((node->parent)->parent)->left;
#line 73
      if (temp->color) {
#line 74
        (node->parent)->color = (u_char )0;
#line 75
        temp->color = (u_char )0;
#line 76
        ((node->parent)->parent)->color = (u_char )1;
#line 77
        node = (node->parent)->parent;
      } else {
#line 80
        if ((unsigned long )node == (unsigned long )(node->parent)->left) {
          {
#line 81
          node = node->parent;
#line 82
          ngx_rbtree_right_rotate(root, sentinel, node);
          }
        }
        {
#line 85
        (node->parent)->color = (u_char )0;
#line 86
        ((node->parent)->parent)->color = (u_char )1;
#line 87
        ngx_rbtree_left_rotate(root, sentinel, (node->parent)->parent);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  (*root)->color = (u_char )0;
#line 93
  return;
}
}
#line 96 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rbtree.c"
void ngx_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node , ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (node->key < temp->key) {
#line 104
      p = & temp->left;
    } else {
#line 104
      p = & temp->right;
    }
#line 106
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 107
      goto while_break;
    }
#line 110
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 113
  *p = node;
#line 114
  node->parent = temp;
#line 115
  node->left = sentinel;
#line 116
  node->right = sentinel;
#line 117
  node->color = (u_char )1;
#line 118
  return;
}
}
#line 121 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rbtree.c"
void ngx_rbtree_insert_timer_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                   ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_rbtree_node_t **p ;

  {
  {
#line 127
  while (1) {
    while_continue: /* CIL Label */ ;
#line 138
    if ((ngx_rbtree_key_int_t )(node->key - temp->key) < 0L) {
#line 138
      p = & temp->left;
    } else {
#line 138
      p = & temp->right;
    }
#line 141
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 142
      goto while_break;
    }
#line 145
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  *p = node;
#line 149
  node->parent = temp;
#line 150
  node->left = sentinel;
#line 151
  node->right = sentinel;
#line 152
  node->color = (u_char )1;
#line 153
  return;
}
}
#line 156 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rbtree.c"
void ngx_rbtree_delete(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) 
{ 
  ngx_uint_t red ;
  ngx_rbtree_node_t **root ;
  ngx_rbtree_node_t *sentinel ;
  ngx_rbtree_node_t *subst ;
  ngx_rbtree_node_t *temp ;
  ngx_rbtree_node_t *w ;

  {
#line 164
  root = & tree->root;
#line 165
  sentinel = tree->sentinel;
#line 167
  if ((unsigned long )node->left == (unsigned long )sentinel) {
#line 168
    temp = node->right;
#line 169
    subst = node;
  } else
#line 171
  if ((unsigned long )node->right == (unsigned long )sentinel) {
#line 172
    temp = node->left;
#line 173
    subst = node;
  } else {
    {
#line 176
    subst = ngx_rbtree_min(node->right, sentinel);
    }
#line 178
    if ((unsigned long )subst->left != (unsigned long )sentinel) {
#line 179
      temp = subst->left;
    } else {
#line 181
      temp = subst->right;
    }
  }
#line 185
  if ((unsigned long )subst == (unsigned long )*root) {
#line 186
    *root = temp;
#line 187
    temp->color = (u_char )0;
#line 190
    node->left = (ngx_rbtree_node_t *)((void *)0);
#line 191
    node->right = (ngx_rbtree_node_t *)((void *)0);
#line 192
    node->parent = (ngx_rbtree_node_t *)((void *)0);
#line 193
    node->key = (ngx_rbtree_key_t )0;
#line 195
    return;
  }
#line 198
  red = (ngx_uint_t )subst->color;
#line 200
  if ((unsigned long )subst == (unsigned long )(subst->parent)->left) {
#line 201
    (subst->parent)->left = temp;
  } else {
#line 204
    (subst->parent)->right = temp;
  }
#line 207
  if ((unsigned long )subst == (unsigned long )node) {
#line 209
    temp->parent = subst->parent;
  } else {
#line 213
    if ((unsigned long )subst->parent == (unsigned long )node) {
#line 214
      temp->parent = subst;
    } else {
#line 217
      temp->parent = subst->parent;
    }
#line 220
    subst->left = node->left;
#line 221
    subst->right = node->right;
#line 222
    subst->parent = node->parent;
#line 223
    subst->color = node->color;
#line 225
    if ((unsigned long )node == (unsigned long )*root) {
#line 226
      *root = subst;
    } else
#line 229
    if ((unsigned long )node == (unsigned long )(node->parent)->left) {
#line 230
      (node->parent)->left = subst;
    } else {
#line 232
      (node->parent)->right = subst;
    }
#line 236
    if ((unsigned long )subst->left != (unsigned long )sentinel) {
#line 237
      (subst->left)->parent = subst;
    }
#line 240
    if ((unsigned long )subst->right != (unsigned long )sentinel) {
#line 241
      (subst->right)->parent = subst;
    }
  }
#line 246
  node->left = (ngx_rbtree_node_t *)((void *)0);
#line 247
  node->right = (ngx_rbtree_node_t *)((void *)0);
#line 248
  node->parent = (ngx_rbtree_node_t *)((void *)0);
#line 249
  node->key = (ngx_rbtree_key_t )0;
#line 251
  if (red) {
#line 252
    return;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if ((unsigned long )temp != (unsigned long )*root) {
#line 257
      if (! (! temp->color)) {
#line 257
        goto while_break;
      }
    } else {
#line 257
      goto while_break;
    }
#line 259
    if ((unsigned long )temp == (unsigned long )(temp->parent)->left) {
#line 260
      w = (temp->parent)->right;
#line 262
      if (w->color) {
        {
#line 263
        w->color = (u_char )0;
#line 264
        (temp->parent)->color = (u_char )1;
#line 265
        ngx_rbtree_left_rotate(root, sentinel, temp->parent);
#line 266
        w = (temp->parent)->right;
        }
      }
#line 269
      if (! (w->left)->color) {
#line 269
        if (! (w->right)->color) {
#line 270
          w->color = (u_char )1;
#line 271
          temp = temp->parent;
        } else {
#line 269
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 274
        if (! (w->right)->color) {
          {
#line 275
          (w->left)->color = (u_char )0;
#line 276
          w->color = (u_char )1;
#line 277
          ngx_rbtree_right_rotate(root, sentinel, w);
#line 278
          w = (temp->parent)->right;
          }
        }
        {
#line 281
        w->color = (temp->parent)->color;
#line 282
        (temp->parent)->color = (u_char )0;
#line 283
        (w->right)->color = (u_char )0;
#line 284
        ngx_rbtree_left_rotate(root, sentinel, temp->parent);
#line 285
        temp = *root;
        }
      }
    } else {
#line 289
      w = (temp->parent)->left;
#line 291
      if (w->color) {
        {
#line 292
        w->color = (u_char )0;
#line 293
        (temp->parent)->color = (u_char )1;
#line 294
        ngx_rbtree_right_rotate(root, sentinel, temp->parent);
#line 295
        w = (temp->parent)->left;
        }
      }
#line 298
      if (! (w->left)->color) {
#line 298
        if (! (w->right)->color) {
#line 299
          w->color = (u_char )1;
#line 300
          temp = temp->parent;
        } else {
#line 298
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 303
        if (! (w->left)->color) {
          {
#line 304
          (w->right)->color = (u_char )0;
#line 305
          w->color = (u_char )1;
#line 306
          ngx_rbtree_left_rotate(root, sentinel, w);
#line 307
          w = (temp->parent)->left;
          }
        }
        {
#line 310
        w->color = (temp->parent)->color;
#line 311
        (temp->parent)->color = (u_char )0;
#line 312
        (w->left)->color = (u_char )0;
#line 313
        ngx_rbtree_right_rotate(root, sentinel, temp->parent);
#line 314
        temp = *root;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 319
  temp->color = (u_char )0;
#line 320
  return;
}
}
#line 323 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rbtree.c"
__inline static void ngx_rbtree_left_rotate(ngx_rbtree_node_t **root , ngx_rbtree_node_t *sentinel ,
                                            ngx_rbtree_node_t *node ) 
{ 
  ngx_rbtree_node_t *temp ;

  {
#line 329
  temp = node->right;
#line 330
  node->right = temp->left;
#line 332
  if ((unsigned long )temp->left != (unsigned long )sentinel) {
#line 333
    (temp->left)->parent = node;
  }
#line 336
  temp->parent = node->parent;
#line 338
  if ((unsigned long )node == (unsigned long )*root) {
#line 339
    *root = temp;
  } else
#line 341
  if ((unsigned long )node == (unsigned long )(node->parent)->left) {
#line 342
    (node->parent)->left = temp;
  } else {
#line 345
    (node->parent)->right = temp;
  }
#line 348
  temp->left = node;
#line 349
  node->parent = temp;
#line 350
  return;
}
}
#line 353 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rbtree.c"
__inline static void ngx_rbtree_right_rotate(ngx_rbtree_node_t **root , ngx_rbtree_node_t *sentinel ,
                                             ngx_rbtree_node_t *node ) 
{ 
  ngx_rbtree_node_t *temp ;

  {
#line 359
  temp = node->left;
#line 360
  node->left = temp->right;
#line 362
  if ((unsigned long )temp->right != (unsigned long )sentinel) {
#line 363
    (temp->right)->parent = node;
  }
#line 366
  temp->parent = node->parent;
#line 368
  if ((unsigned long )node == (unsigned long )*root) {
#line 369
    *root = temp;
  } else
#line 371
  if ((unsigned long )node == (unsigned long )(node->parent)->right) {
#line 372
    (node->parent)->right = temp;
  } else {
#line 375
    (node->parent)->left = temp;
  }
#line 378
  temp->right = node;
#line 379
  node->parent = temp;
#line 380
  return;
}
}
#line 383 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_rbtree.c"
ngx_rbtree_node_t *ngx_rbtree_next(ngx_rbtree_t *tree , ngx_rbtree_node_t *node ) 
{ 
  ngx_rbtree_node_t *root ;
  ngx_rbtree_node_t *sentinel ;
  ngx_rbtree_node_t *parent ;
  ngx_rbtree_node_t *tmp ;

  {
#line 388
  sentinel = tree->sentinel;
#line 390
  if ((unsigned long )node->right != (unsigned long )sentinel) {
    {
#line 391
    tmp = ngx_rbtree_min(node->right, sentinel);
    }
#line 391
    return (tmp);
  }
#line 394
  root = tree->root;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 397
    parent = node->parent;
#line 399
    if ((unsigned long )node == (unsigned long )root) {
#line 400
      return ((ngx_rbtree_node_t *)((void *)0));
    }
#line 403
    if ((unsigned long )node == (unsigned long )parent->left) {
#line 404
      return (parent);
    }
#line 407
    node = parent;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_sha1.c"
static u_char const   *ngx_sha1_body(ngx_sha1_t *ctx , u_char const   *data , size_t size ) ;
#line 19 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_sha1.c"
void ngx_sha1_init(ngx_sha1_t *ctx ) 
{ 


  {
#line 22
  ctx->a = (uint32_t )1732584193;
#line 23
  ctx->b = 4023233417U;
#line 24
  ctx->c = 2562383102U;
#line 25
  ctx->d = (uint32_t )271733878;
#line 26
  ctx->e = 3285377520U;
#line 28
  ctx->bytes = (uint64_t )0;
#line 29
  return;
}
}
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_sha1.c"
void ngx_sha1_update(ngx_sha1_t *ctx , void const   *data , size_t size ) 
{ 
  size_t used ;
  size_t free___0 ;
  u_char const   *tmp ;

  {
#line 37
  used = ctx->bytes & 63UL;
#line 38
  ctx->bytes += size;
#line 40
  if (used) {
#line 41
    free___0 = 64UL - used;
#line 43
    if (size < free___0) {
      {
#line 44
      memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
             size);
      }
#line 45
      return;
    }
    {
#line 48
    memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
           free___0);
#line 49
    data = (void const   *)((u_char *)data + free___0);
#line 50
    size -= free___0;
#line 51
    ngx_sha1_body(ctx, (u_char const   *)(ctx->buffer), (size_t )64);
    }
  }
#line 54
  if (size >= 64UL) {
    {
#line 55
    tmp = ngx_sha1_body(ctx, (u_char const   *)data, size & 0xffffffffffffffc0UL);
#line 55
    data = (void const   *)tmp;
#line 56
    size &= 63UL;
    }
  }
  {
#line 59
  memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)data,
         size);
  }
#line 60
  return;
}
}
#line 63 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_sha1.c"
void ngx_sha1_final(u_char *result___0 , ngx_sha1_t *ctx ) 
{ 
  size_t used ;
  size_t free___0 ;
  size_t tmp ;

  {
#line 68
  used = ctx->bytes & 63UL;
#line 70
  tmp = used;
#line 70
  used ++;
#line 70
  ctx->buffer[tmp] = (u_char )128;
#line 72
  free___0 = 64UL - used;
#line 74
  if (free___0 < 8UL) {
    {
#line 75
    memset((void *)(& ctx->buffer[used]), 0, free___0);
#line 76
    ngx_sha1_body(ctx, (u_char const   *)(ctx->buffer), (size_t )64);
#line 77
    used = (size_t )0;
#line 78
    free___0 = (size_t )64;
    }
  }
  {
#line 81
  memset((void *)(& ctx->buffer[used]), 0, free___0 - 8UL);
#line 83
  ctx->bytes <<= 3;
#line 84
  ctx->buffer[56] = (u_char )(ctx->bytes >> 56);
#line 85
  ctx->buffer[57] = (u_char )(ctx->bytes >> 48);
#line 86
  ctx->buffer[58] = (u_char )(ctx->bytes >> 40);
#line 87
  ctx->buffer[59] = (u_char )(ctx->bytes >> 32);
#line 88
  ctx->buffer[60] = (u_char )(ctx->bytes >> 24);
#line 89
  ctx->buffer[61] = (u_char )(ctx->bytes >> 16);
#line 90
  ctx->buffer[62] = (u_char )(ctx->bytes >> 8);
#line 91
  ctx->buffer[63] = (u_char )ctx->bytes;
#line 93
  ngx_sha1_body(ctx, (u_char const   *)(ctx->buffer), (size_t )64);
#line 95
  *(result___0 + 0) = (u_char )(ctx->a >> 24);
#line 96
  *(result___0 + 1) = (u_char )(ctx->a >> 16);
#line 97
  *(result___0 + 2) = (u_char )(ctx->a >> 8);
#line 98
  *(result___0 + 3) = (u_char )ctx->a;
#line 99
  *(result___0 + 4) = (u_char )(ctx->b >> 24);
#line 100
  *(result___0 + 5) = (u_char )(ctx->b >> 16);
#line 101
  *(result___0 + 6) = (u_char )(ctx->b >> 8);
#line 102
  *(result___0 + 7) = (u_char )ctx->b;
#line 103
  *(result___0 + 8) = (u_char )(ctx->c >> 24);
#line 104
  *(result___0 + 9) = (u_char )(ctx->c >> 16);
#line 105
  *(result___0 + 10) = (u_char )(ctx->c >> 8);
#line 106
  *(result___0 + 11) = (u_char )ctx->c;
#line 107
  *(result___0 + 12) = (u_char )(ctx->d >> 24);
#line 108
  *(result___0 + 13) = (u_char )(ctx->d >> 16);
#line 109
  *(result___0 + 14) = (u_char )(ctx->d >> 8);
#line 110
  *(result___0 + 15) = (u_char )ctx->d;
#line 111
  *(result___0 + 16) = (u_char )(ctx->e >> 24);
#line 112
  *(result___0 + 17) = (u_char )(ctx->e >> 16);
#line 113
  *(result___0 + 18) = (u_char )(ctx->e >> 8);
#line 114
  *(result___0 + 19) = (u_char )ctx->e;
#line 116
  memset((void *)ctx, 0, sizeof(*ctx));
  }
#line 117
  return;
}
}
#line 156 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_sha1.c"
static u_char const   *ngx_sha1_body(ngx_sha1_t *ctx , u_char const   *data , size_t size ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t e ;
  uint32_t temp ;
  uint32_t saved_a ;
  uint32_t saved_b ;
  uint32_t saved_c ;
  uint32_t saved_d ;
  uint32_t saved_e ;
  uint32_t words[80] ;
  ngx_uint_t i ;
  u_char const   *p ;
  void *__cil_tmp18 ;

  {
#line 165
  p = data;
#line 167
  a = ctx->a;
#line 168
  b = ctx->b;
#line 169
  c = ctx->c;
#line 170
  d = ctx->d;
#line 171
  e = ctx->e;
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 174
    saved_a = a;
#line 175
    saved_b = b;
#line 176
    saved_c = c;
#line 177
    saved_d = d;
#line 178
    saved_e = e;
#line 182
    i = (ngx_uint_t )0;
    {
#line 182
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 182
      if (! (i < 16UL)) {
#line 182
        goto while_break___0;
      }
#line 183
      words[i] = (((uint32_t )*(p + (i * 4UL + 3UL)) | ((uint32_t )*(p + (i * 4UL + 2UL)) << 8)) | ((uint32_t )*(p + (i * 4UL + 1UL)) << 16)) | ((uint32_t )*(p + i * 4UL) << 24);
#line 182
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 186
    i = (ngx_uint_t )16;
    {
#line 186
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 186
      if (! (i < 80UL)) {
#line 186
        goto while_break___1;
      }
#line 187
      words[i] = ((((words[i - 3UL] ^ words[i - 8UL]) ^ words[i - 14UL]) ^ words[i - 16UL]) << 1) | ((((words[i - 3UL] ^ words[i - 8UL]) ^ words[i - 14UL]) ^ words[i - 16UL]) >> 31);
#line 186
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 193
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[0]) + 1518500249U;
#line 193
    e = d;
#line 193
    d = c;
#line 193
    c = (b << 30) | (b >> 2);
#line 193
    b = a;
#line 193
    a = temp;
#line 194
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[1]) + 1518500249U;
#line 194
    e = d;
#line 194
    d = c;
#line 194
    c = (b << 30) | (b >> 2);
#line 194
    b = a;
#line 194
    a = temp;
#line 195
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[2]) + 1518500249U;
#line 195
    e = d;
#line 195
    d = c;
#line 195
    c = (b << 30) | (b >> 2);
#line 195
    b = a;
#line 195
    a = temp;
#line 196
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[3]) + 1518500249U;
#line 196
    e = d;
#line 196
    d = c;
#line 196
    c = (b << 30) | (b >> 2);
#line 196
    b = a;
#line 196
    a = temp;
#line 197
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[4]) + 1518500249U;
#line 197
    e = d;
#line 197
    d = c;
#line 197
    c = (b << 30) | (b >> 2);
#line 197
    b = a;
#line 197
    a = temp;
#line 198
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[5]) + 1518500249U;
#line 198
    e = d;
#line 198
    d = c;
#line 198
    c = (b << 30) | (b >> 2);
#line 198
    b = a;
#line 198
    a = temp;
#line 199
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[6]) + 1518500249U;
#line 199
    e = d;
#line 199
    d = c;
#line 199
    c = (b << 30) | (b >> 2);
#line 199
    b = a;
#line 199
    a = temp;
#line 200
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[7]) + 1518500249U;
#line 200
    e = d;
#line 200
    d = c;
#line 200
    c = (b << 30) | (b >> 2);
#line 200
    b = a;
#line 200
    a = temp;
#line 201
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[8]) + 1518500249U;
#line 201
    e = d;
#line 201
    d = c;
#line 201
    c = (b << 30) | (b >> 2);
#line 201
    b = a;
#line 201
    a = temp;
#line 202
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[9]) + 1518500249U;
#line 202
    e = d;
#line 202
    d = c;
#line 202
    c = (b << 30) | (b >> 2);
#line 202
    b = a;
#line 202
    a = temp;
#line 203
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[10]) + 1518500249U;
#line 203
    e = d;
#line 203
    d = c;
#line 203
    c = (b << 30) | (b >> 2);
#line 203
    b = a;
#line 203
    a = temp;
#line 204
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[11]) + 1518500249U;
#line 204
    e = d;
#line 204
    d = c;
#line 204
    c = (b << 30) | (b >> 2);
#line 204
    b = a;
#line 204
    a = temp;
#line 205
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[12]) + 1518500249U;
#line 205
    e = d;
#line 205
    d = c;
#line 205
    c = (b << 30) | (b >> 2);
#line 205
    b = a;
#line 205
    a = temp;
#line 206
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[13]) + 1518500249U;
#line 206
    e = d;
#line 206
    d = c;
#line 206
    c = (b << 30) | (b >> 2);
#line 206
    b = a;
#line 206
    a = temp;
#line 207
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[14]) + 1518500249U;
#line 207
    e = d;
#line 207
    d = c;
#line 207
    c = (b << 30) | (b >> 2);
#line 207
    b = a;
#line 207
    a = temp;
#line 208
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[15]) + 1518500249U;
#line 208
    e = d;
#line 208
    d = c;
#line 208
    c = (b << 30) | (b >> 2);
#line 208
    b = a;
#line 208
    a = temp;
#line 209
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[16]) + 1518500249U;
#line 209
    e = d;
#line 209
    d = c;
#line 209
    c = (b << 30) | (b >> 2);
#line 209
    b = a;
#line 209
    a = temp;
#line 210
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[17]) + 1518500249U;
#line 210
    e = d;
#line 210
    d = c;
#line 210
    c = (b << 30) | (b >> 2);
#line 210
    b = a;
#line 210
    a = temp;
#line 211
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[18]) + 1518500249U;
#line 211
    e = d;
#line 211
    d = c;
#line 211
    c = (b << 30) | (b >> 2);
#line 211
    b = a;
#line 211
    a = temp;
#line 212
    temp = (((((a << 5) | (a >> 27)) + ((b & c) | (~ b & d))) + e) + words[19]) + 1518500249U;
#line 212
    e = d;
#line 212
    d = c;
#line 212
    c = (b << 30) | (b >> 2);
#line 212
    b = a;
#line 212
    a = temp;
#line 214
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[20]) + 1859775393U;
#line 214
    e = d;
#line 214
    d = c;
#line 214
    c = (b << 30) | (b >> 2);
#line 214
    b = a;
#line 214
    a = temp;
#line 215
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[21]) + 1859775393U;
#line 215
    e = d;
#line 215
    d = c;
#line 215
    c = (b << 30) | (b >> 2);
#line 215
    b = a;
#line 215
    a = temp;
#line 216
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[22]) + 1859775393U;
#line 216
    e = d;
#line 216
    d = c;
#line 216
    c = (b << 30) | (b >> 2);
#line 216
    b = a;
#line 216
    a = temp;
#line 217
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[23]) + 1859775393U;
#line 217
    e = d;
#line 217
    d = c;
#line 217
    c = (b << 30) | (b >> 2);
#line 217
    b = a;
#line 217
    a = temp;
#line 218
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[24]) + 1859775393U;
#line 218
    e = d;
#line 218
    d = c;
#line 218
    c = (b << 30) | (b >> 2);
#line 218
    b = a;
#line 218
    a = temp;
#line 219
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[25]) + 1859775393U;
#line 219
    e = d;
#line 219
    d = c;
#line 219
    c = (b << 30) | (b >> 2);
#line 219
    b = a;
#line 219
    a = temp;
#line 220
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[26]) + 1859775393U;
#line 220
    e = d;
#line 220
    d = c;
#line 220
    c = (b << 30) | (b >> 2);
#line 220
    b = a;
#line 220
    a = temp;
#line 221
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[27]) + 1859775393U;
#line 221
    e = d;
#line 221
    d = c;
#line 221
    c = (b << 30) | (b >> 2);
#line 221
    b = a;
#line 221
    a = temp;
#line 222
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[28]) + 1859775393U;
#line 222
    e = d;
#line 222
    d = c;
#line 222
    c = (b << 30) | (b >> 2);
#line 222
    b = a;
#line 222
    a = temp;
#line 223
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[29]) + 1859775393U;
#line 223
    e = d;
#line 223
    d = c;
#line 223
    c = (b << 30) | (b >> 2);
#line 223
    b = a;
#line 223
    a = temp;
#line 224
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[30]) + 1859775393U;
#line 224
    e = d;
#line 224
    d = c;
#line 224
    c = (b << 30) | (b >> 2);
#line 224
    b = a;
#line 224
    a = temp;
#line 225
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[31]) + 1859775393U;
#line 225
    e = d;
#line 225
    d = c;
#line 225
    c = (b << 30) | (b >> 2);
#line 225
    b = a;
#line 225
    a = temp;
#line 226
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[32]) + 1859775393U;
#line 226
    e = d;
#line 226
    d = c;
#line 226
    c = (b << 30) | (b >> 2);
#line 226
    b = a;
#line 226
    a = temp;
#line 227
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[33]) + 1859775393U;
#line 227
    e = d;
#line 227
    d = c;
#line 227
    c = (b << 30) | (b >> 2);
#line 227
    b = a;
#line 227
    a = temp;
#line 228
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[34]) + 1859775393U;
#line 228
    e = d;
#line 228
    d = c;
#line 228
    c = (b << 30) | (b >> 2);
#line 228
    b = a;
#line 228
    a = temp;
#line 229
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[35]) + 1859775393U;
#line 229
    e = d;
#line 229
    d = c;
#line 229
    c = (b << 30) | (b >> 2);
#line 229
    b = a;
#line 229
    a = temp;
#line 230
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[36]) + 1859775393U;
#line 230
    e = d;
#line 230
    d = c;
#line 230
    c = (b << 30) | (b >> 2);
#line 230
    b = a;
#line 230
    a = temp;
#line 231
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[37]) + 1859775393U;
#line 231
    e = d;
#line 231
    d = c;
#line 231
    c = (b << 30) | (b >> 2);
#line 231
    b = a;
#line 231
    a = temp;
#line 232
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[38]) + 1859775393U;
#line 232
    e = d;
#line 232
    d = c;
#line 232
    c = (b << 30) | (b >> 2);
#line 232
    b = a;
#line 232
    a = temp;
#line 233
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[39]) + 1859775393U;
#line 233
    e = d;
#line 233
    d = c;
#line 233
    c = (b << 30) | (b >> 2);
#line 233
    b = a;
#line 233
    a = temp;
#line 235
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[40]) + 2400959708U;
#line 235
    e = d;
#line 235
    d = c;
#line 235
    c = (b << 30) | (b >> 2);
#line 235
    b = a;
#line 235
    a = temp;
#line 236
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[41]) + 2400959708U;
#line 236
    e = d;
#line 236
    d = c;
#line 236
    c = (b << 30) | (b >> 2);
#line 236
    b = a;
#line 236
    a = temp;
#line 237
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[42]) + 2400959708U;
#line 237
    e = d;
#line 237
    d = c;
#line 237
    c = (b << 30) | (b >> 2);
#line 237
    b = a;
#line 237
    a = temp;
#line 238
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[43]) + 2400959708U;
#line 238
    e = d;
#line 238
    d = c;
#line 238
    c = (b << 30) | (b >> 2);
#line 238
    b = a;
#line 238
    a = temp;
#line 239
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[44]) + 2400959708U;
#line 239
    e = d;
#line 239
    d = c;
#line 239
    c = (b << 30) | (b >> 2);
#line 239
    b = a;
#line 239
    a = temp;
#line 240
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[45]) + 2400959708U;
#line 240
    e = d;
#line 240
    d = c;
#line 240
    c = (b << 30) | (b >> 2);
#line 240
    b = a;
#line 240
    a = temp;
#line 241
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[46]) + 2400959708U;
#line 241
    e = d;
#line 241
    d = c;
#line 241
    c = (b << 30) | (b >> 2);
#line 241
    b = a;
#line 241
    a = temp;
#line 242
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[47]) + 2400959708U;
#line 242
    e = d;
#line 242
    d = c;
#line 242
    c = (b << 30) | (b >> 2);
#line 242
    b = a;
#line 242
    a = temp;
#line 243
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[48]) + 2400959708U;
#line 243
    e = d;
#line 243
    d = c;
#line 243
    c = (b << 30) | (b >> 2);
#line 243
    b = a;
#line 243
    a = temp;
#line 244
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[49]) + 2400959708U;
#line 244
    e = d;
#line 244
    d = c;
#line 244
    c = (b << 30) | (b >> 2);
#line 244
    b = a;
#line 244
    a = temp;
#line 245
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[50]) + 2400959708U;
#line 245
    e = d;
#line 245
    d = c;
#line 245
    c = (b << 30) | (b >> 2);
#line 245
    b = a;
#line 245
    a = temp;
#line 246
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[51]) + 2400959708U;
#line 246
    e = d;
#line 246
    d = c;
#line 246
    c = (b << 30) | (b >> 2);
#line 246
    b = a;
#line 246
    a = temp;
#line 247
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[52]) + 2400959708U;
#line 247
    e = d;
#line 247
    d = c;
#line 247
    c = (b << 30) | (b >> 2);
#line 247
    b = a;
#line 247
    a = temp;
#line 248
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[53]) + 2400959708U;
#line 248
    e = d;
#line 248
    d = c;
#line 248
    c = (b << 30) | (b >> 2);
#line 248
    b = a;
#line 248
    a = temp;
#line 249
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[54]) + 2400959708U;
#line 249
    e = d;
#line 249
    d = c;
#line 249
    c = (b << 30) | (b >> 2);
#line 249
    b = a;
#line 249
    a = temp;
#line 250
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[55]) + 2400959708U;
#line 250
    e = d;
#line 250
    d = c;
#line 250
    c = (b << 30) | (b >> 2);
#line 250
    b = a;
#line 250
    a = temp;
#line 251
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[56]) + 2400959708U;
#line 251
    e = d;
#line 251
    d = c;
#line 251
    c = (b << 30) | (b >> 2);
#line 251
    b = a;
#line 251
    a = temp;
#line 252
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[57]) + 2400959708U;
#line 252
    e = d;
#line 252
    d = c;
#line 252
    c = (b << 30) | (b >> 2);
#line 252
    b = a;
#line 252
    a = temp;
#line 253
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[58]) + 2400959708U;
#line 253
    e = d;
#line 253
    d = c;
#line 253
    c = (b << 30) | (b >> 2);
#line 253
    b = a;
#line 253
    a = temp;
#line 254
    temp = (((((a << 5) | (a >> 27)) + (((b & c) | (b & d)) | (c & d))) + e) + words[59]) + 2400959708U;
#line 254
    e = d;
#line 254
    d = c;
#line 254
    c = (b << 30) | (b >> 2);
#line 254
    b = a;
#line 254
    a = temp;
#line 256
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[60]) + 3395469782U;
#line 256
    e = d;
#line 256
    d = c;
#line 256
    c = (b << 30) | (b >> 2);
#line 256
    b = a;
#line 256
    a = temp;
#line 257
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[61]) + 3395469782U;
#line 257
    e = d;
#line 257
    d = c;
#line 257
    c = (b << 30) | (b >> 2);
#line 257
    b = a;
#line 257
    a = temp;
#line 258
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[62]) + 3395469782U;
#line 258
    e = d;
#line 258
    d = c;
#line 258
    c = (b << 30) | (b >> 2);
#line 258
    b = a;
#line 258
    a = temp;
#line 259
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[63]) + 3395469782U;
#line 259
    e = d;
#line 259
    d = c;
#line 259
    c = (b << 30) | (b >> 2);
#line 259
    b = a;
#line 259
    a = temp;
#line 260
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[64]) + 3395469782U;
#line 260
    e = d;
#line 260
    d = c;
#line 260
    c = (b << 30) | (b >> 2);
#line 260
    b = a;
#line 260
    a = temp;
#line 261
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[65]) + 3395469782U;
#line 261
    e = d;
#line 261
    d = c;
#line 261
    c = (b << 30) | (b >> 2);
#line 261
    b = a;
#line 261
    a = temp;
#line 262
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[66]) + 3395469782U;
#line 262
    e = d;
#line 262
    d = c;
#line 262
    c = (b << 30) | (b >> 2);
#line 262
    b = a;
#line 262
    a = temp;
#line 263
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[67]) + 3395469782U;
#line 263
    e = d;
#line 263
    d = c;
#line 263
    c = (b << 30) | (b >> 2);
#line 263
    b = a;
#line 263
    a = temp;
#line 264
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[68]) + 3395469782U;
#line 264
    e = d;
#line 264
    d = c;
#line 264
    c = (b << 30) | (b >> 2);
#line 264
    b = a;
#line 264
    a = temp;
#line 265
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[69]) + 3395469782U;
#line 265
    e = d;
#line 265
    d = c;
#line 265
    c = (b << 30) | (b >> 2);
#line 265
    b = a;
#line 265
    a = temp;
#line 266
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[70]) + 3395469782U;
#line 266
    e = d;
#line 266
    d = c;
#line 266
    c = (b << 30) | (b >> 2);
#line 266
    b = a;
#line 266
    a = temp;
#line 267
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[71]) + 3395469782U;
#line 267
    e = d;
#line 267
    d = c;
#line 267
    c = (b << 30) | (b >> 2);
#line 267
    b = a;
#line 267
    a = temp;
#line 268
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[72]) + 3395469782U;
#line 268
    e = d;
#line 268
    d = c;
#line 268
    c = (b << 30) | (b >> 2);
#line 268
    b = a;
#line 268
    a = temp;
#line 269
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[73]) + 3395469782U;
#line 269
    e = d;
#line 269
    d = c;
#line 269
    c = (b << 30) | (b >> 2);
#line 269
    b = a;
#line 269
    a = temp;
#line 270
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[74]) + 3395469782U;
#line 270
    e = d;
#line 270
    d = c;
#line 270
    c = (b << 30) | (b >> 2);
#line 270
    b = a;
#line 270
    a = temp;
#line 271
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[75]) + 3395469782U;
#line 271
    e = d;
#line 271
    d = c;
#line 271
    c = (b << 30) | (b >> 2);
#line 271
    b = a;
#line 271
    a = temp;
#line 272
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[76]) + 3395469782U;
#line 272
    e = d;
#line 272
    d = c;
#line 272
    c = (b << 30) | (b >> 2);
#line 272
    b = a;
#line 272
    a = temp;
#line 273
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[77]) + 3395469782U;
#line 273
    e = d;
#line 273
    d = c;
#line 273
    c = (b << 30) | (b >> 2);
#line 273
    b = a;
#line 273
    a = temp;
#line 274
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[78]) + 3395469782U;
#line 274
    e = d;
#line 274
    d = c;
#line 274
    c = (b << 30) | (b >> 2);
#line 274
    b = a;
#line 274
    a = temp;
#line 275
    temp = (((((a << 5) | (a >> 27)) + ((b ^ c) ^ d)) + e) + words[79]) + 3395469782U;
#line 275
    e = d;
#line 275
    d = c;
#line 275
    c = (b << 30) | (b >> 2);
#line 275
    b = a;
#line 275
    a = temp;
#line 277
    a += saved_a;
#line 278
    b += saved_b;
#line 279
    c += saved_c;
#line 280
    d += saved_d;
#line 281
    e += saved_e;
#line 283
    p += 64;
#line 173
    size -= 64UL;
#line 173
    if (! size) {
#line 173
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 287
  ctx->a = a;
#line 288
  ctx->b = b;
#line 289
  ctx->c = c;
#line 290
  ctx->d = d;
#line 291
  ctx->e = e;
#line 293
  return (p);
}
}
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_md5.c"
static u_char const   *ngx_md5_body(ngx_md5_t *ctx , u_char const   *data , size_t size ) ;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_md5.c"
void ngx_md5_init(ngx_md5_t *ctx ) 
{ 


  {
#line 21
  ctx->a = (uint32_t )1732584193;
#line 22
  ctx->b = 4023233417U;
#line 23
  ctx->c = 2562383102U;
#line 24
  ctx->d = (uint32_t )271733878;
#line 26
  ctx->bytes = (uint64_t )0;
#line 27
  return;
}
}
#line 30 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_md5.c"
void ngx_md5_update(ngx_md5_t *ctx , void const   *data , size_t size ) 
{ 
  size_t used ;
  size_t free___0 ;
  u_char const   *tmp ;

  {
#line 35
  used = ctx->bytes & 63UL;
#line 36
  ctx->bytes += size;
#line 38
  if (used) {
#line 39
    free___0 = 64UL - used;
#line 41
    if (size < free___0) {
      {
#line 42
      memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
             size);
      }
#line 43
      return;
    }
    {
#line 46
    memcpy((void */* __restrict  */)(& ctx->buffer[used]), (void const   */* __restrict  */)data,
           free___0);
#line 47
    data = (void const   *)((u_char *)data + free___0);
#line 48
    size -= free___0;
#line 49
    ngx_md5_body(ctx, (u_char const   *)(ctx->buffer), (size_t )64);
    }
  }
#line 52
  if (size >= 64UL) {
    {
#line 53
    tmp = ngx_md5_body(ctx, (u_char const   *)data, size & 0xffffffffffffffc0UL);
#line 53
    data = (void const   *)tmp;
#line 54
    size &= 63UL;
    }
  }
  {
#line 57
  memcpy((void */* __restrict  */)(ctx->buffer), (void const   */* __restrict  */)data,
         size);
  }
#line 58
  return;
}
}
#line 61 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_md5.c"
void ngx_md5_final(u_char *result___0 , ngx_md5_t *ctx ) 
{ 
  size_t used ;
  size_t free___0 ;
  size_t tmp ;

  {
#line 66
  used = ctx->bytes & 63UL;
#line 68
  tmp = used;
#line 68
  used ++;
#line 68
  ctx->buffer[tmp] = (u_char )128;
#line 70
  free___0 = 64UL - used;
#line 72
  if (free___0 < 8UL) {
    {
#line 73
    memset((void *)(& ctx->buffer[used]), 0, free___0);
#line 74
    ngx_md5_body(ctx, (u_char const   *)(ctx->buffer), (size_t )64);
#line 75
    used = (size_t )0;
#line 76
    free___0 = (size_t )64;
    }
  }
  {
#line 79
  memset((void *)(& ctx->buffer[used]), 0, free___0 - 8UL);
#line 81
  ctx->bytes <<= 3;
#line 82
  ctx->buffer[56] = (u_char )ctx->bytes;
#line 83
  ctx->buffer[57] = (u_char )(ctx->bytes >> 8);
#line 84
  ctx->buffer[58] = (u_char )(ctx->bytes >> 16);
#line 85
  ctx->buffer[59] = (u_char )(ctx->bytes >> 24);
#line 86
  ctx->buffer[60] = (u_char )(ctx->bytes >> 32);
#line 87
  ctx->buffer[61] = (u_char )(ctx->bytes >> 40);
#line 88
  ctx->buffer[62] = (u_char )(ctx->bytes >> 48);
#line 89
  ctx->buffer[63] = (u_char )(ctx->bytes >> 56);
#line 91
  ngx_md5_body(ctx, (u_char const   *)(ctx->buffer), (size_t )64);
#line 93
  *(result___0 + 0) = (u_char )ctx->a;
#line 94
  *(result___0 + 1) = (u_char )(ctx->a >> 8);
#line 95
  *(result___0 + 2) = (u_char )(ctx->a >> 16);
#line 96
  *(result___0 + 3) = (u_char )(ctx->a >> 24);
#line 97
  *(result___0 + 4) = (u_char )ctx->b;
#line 98
  *(result___0 + 5) = (u_char )(ctx->b >> 8);
#line 99
  *(result___0 + 6) = (u_char )(ctx->b >> 16);
#line 100
  *(result___0 + 7) = (u_char )(ctx->b >> 24);
#line 101
  *(result___0 + 8) = (u_char )ctx->c;
#line 102
  *(result___0 + 9) = (u_char )(ctx->c >> 8);
#line 103
  *(result___0 + 10) = (u_char )(ctx->c >> 16);
#line 104
  *(result___0 + 11) = (u_char )(ctx->c >> 24);
#line 105
  *(result___0 + 12) = (u_char )ctx->d;
#line 106
  *(result___0 + 13) = (u_char )(ctx->d >> 8);
#line 107
  *(result___0 + 14) = (u_char )(ctx->d >> 16);
#line 108
  *(result___0 + 15) = (u_char )(ctx->d >> 24);
#line 110
  memset((void *)ctx, 0, sizeof(*ctx));
  }
#line 111
  return;
}
}
#line 169 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_md5.c"
static u_char const   *ngx_md5_body(ngx_md5_t *ctx , u_char const   *data , size_t size ) 
{ 
  uint32_t a ;
  uint32_t b ;
  uint32_t c ;
  uint32_t d ;
  uint32_t saved_a ;
  uint32_t saved_b ;
  uint32_t saved_c ;
  uint32_t saved_d ;
  u_char const   *p ;

  {
#line 179
  p = data;
#line 181
  a = ctx->a;
#line 182
  b = ctx->b;
#line 183
  c = ctx->c;
#line 184
  d = ctx->d;
  {
#line 186
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    saved_a = a;
#line 188
    saved_b = b;
#line 189
    saved_c = c;
#line 190
    saved_d = d;
#line 194
    a += ((d ^ (b & (c ^ d))) + *((uint32_t *)(p + 0))) + 3614090360U;
#line 194
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 194
    a += b;
#line 195
    d += ((c ^ (a & (b ^ c))) + *((uint32_t *)(p + 4))) + 3905402710U;
#line 195
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 195
    d += a;
#line 196
    c += ((b ^ (d & (a ^ b))) + *((uint32_t *)(p + 8))) + 606105819U;
#line 196
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 196
    c += d;
#line 197
    b += ((a ^ (c & (d ^ a))) + *((uint32_t *)(p + 12))) + 3250441966U;
#line 197
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 197
    b += c;
#line 198
    a += ((d ^ (b & (c ^ d))) + *((uint32_t *)(p + 16))) + 4118548399U;
#line 198
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 198
    a += b;
#line 199
    d += ((c ^ (a & (b ^ c))) + *((uint32_t *)(p + 20))) + 1200080426U;
#line 199
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 199
    d += a;
#line 200
    c += ((b ^ (d & (a ^ b))) + *((uint32_t *)(p + 24))) + 2821735955U;
#line 200
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 200
    c += d;
#line 201
    b += ((a ^ (c & (d ^ a))) + *((uint32_t *)(p + 28))) + 4249261313U;
#line 201
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 201
    b += c;
#line 202
    a += ((d ^ (b & (c ^ d))) + *((uint32_t *)(p + 32))) + 1770035416U;
#line 202
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 202
    a += b;
#line 203
    d += ((c ^ (a & (b ^ c))) + *((uint32_t *)(p + 36))) + 2336552879U;
#line 203
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 203
    d += a;
#line 204
    c += ((b ^ (d & (a ^ b))) + *((uint32_t *)(p + 40))) + 4294925233U;
#line 204
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 204
    c += d;
#line 205
    b += ((a ^ (c & (d ^ a))) + *((uint32_t *)(p + 44))) + 2304563134U;
#line 205
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 205
    b += c;
#line 206
    a += ((d ^ (b & (c ^ d))) + *((uint32_t *)(p + 48))) + 1804603682U;
#line 206
    a = (a << 7) | ((a & 4294967295U) >> 25);
#line 206
    a += b;
#line 207
    d += ((c ^ (a & (b ^ c))) + *((uint32_t *)(p + 52))) + 4254626195U;
#line 207
    d = (d << 12) | ((d & 4294967295U) >> 20);
#line 207
    d += a;
#line 208
    c += ((b ^ (d & (a ^ b))) + *((uint32_t *)(p + 56))) + 2792965006U;
#line 208
    c = (c << 17) | ((c & 4294967295U) >> 15);
#line 208
    c += d;
#line 209
    b += ((a ^ (c & (d ^ a))) + *((uint32_t *)(p + 60))) + 1236535329U;
#line 209
    b = (b << 22) | ((b & 4294967295U) >> 10);
#line 209
    b += c;
#line 213
    a += ((c ^ (d & (b ^ c))) + *((uint32_t *)(p + 4))) + 4129170786U;
#line 213
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 213
    a += b;
#line 214
    d += ((b ^ (c & (a ^ b))) + *((uint32_t *)(p + 24))) + 3225465664U;
#line 214
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 214
    d += a;
#line 215
    c += ((a ^ (b & (d ^ a))) + *((uint32_t *)(p + 44))) + 643717713U;
#line 215
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 215
    c += d;
#line 216
    b += ((d ^ (a & (c ^ d))) + *((uint32_t *)(p + 0))) + 3921069994U;
#line 216
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 216
    b += c;
#line 217
    a += ((c ^ (d & (b ^ c))) + *((uint32_t *)(p + 20))) + 3593408605U;
#line 217
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 217
    a += b;
#line 218
    d += ((b ^ (c & (a ^ b))) + *((uint32_t *)(p + 40))) + 38016083U;
#line 218
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 218
    d += a;
#line 219
    c += ((a ^ (b & (d ^ a))) + *((uint32_t *)(p + 60))) + 3634488961U;
#line 219
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 219
    c += d;
#line 220
    b += ((d ^ (a & (c ^ d))) + *((uint32_t *)(p + 16))) + 3889429448U;
#line 220
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 220
    b += c;
#line 221
    a += ((c ^ (d & (b ^ c))) + *((uint32_t *)(p + 36))) + 568446438U;
#line 221
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 221
    a += b;
#line 222
    d += ((b ^ (c & (a ^ b))) + *((uint32_t *)(p + 56))) + 3275163606U;
#line 222
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 222
    d += a;
#line 223
    c += ((a ^ (b & (d ^ a))) + *((uint32_t *)(p + 12))) + 4107603335U;
#line 223
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 223
    c += d;
#line 224
    b += ((d ^ (a & (c ^ d))) + *((uint32_t *)(p + 32))) + 1163531501U;
#line 224
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 224
    b += c;
#line 225
    a += ((c ^ (d & (b ^ c))) + *((uint32_t *)(p + 52))) + 2850285829U;
#line 225
    a = (a << 5) | ((a & 4294967295U) >> 27);
#line 225
    a += b;
#line 226
    d += ((b ^ (c & (a ^ b))) + *((uint32_t *)(p + 8))) + 4243563512U;
#line 226
    d = (d << 9) | ((d & 4294967295U) >> 23);
#line 226
    d += a;
#line 227
    c += ((a ^ (b & (d ^ a))) + *((uint32_t *)(p + 28))) + 1735328473U;
#line 227
    c = (c << 14) | ((c & 4294967295U) >> 18);
#line 227
    c += d;
#line 228
    b += ((d ^ (a & (c ^ d))) + *((uint32_t *)(p + 48))) + 2368359562U;
#line 228
    b = (b << 20) | ((b & 4294967295U) >> 12);
#line 228
    b += c;
#line 232
    a += (((b ^ c) ^ d) + *((uint32_t *)(p + 20))) + 4294588738U;
#line 232
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 232
    a += b;
#line 233
    d += (((a ^ b) ^ c) + *((uint32_t *)(p + 32))) + 2272392833U;
#line 233
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 233
    d += a;
#line 234
    c += (((d ^ a) ^ b) + *((uint32_t *)(p + 44))) + 1839030562U;
#line 234
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 234
    c += d;
#line 235
    b += (((c ^ d) ^ a) + *((uint32_t *)(p + 56))) + 4259657740U;
#line 235
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 235
    b += c;
#line 236
    a += (((b ^ c) ^ d) + *((uint32_t *)(p + 4))) + 2763975236U;
#line 236
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 236
    a += b;
#line 237
    d += (((a ^ b) ^ c) + *((uint32_t *)(p + 16))) + 1272893353U;
#line 237
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 237
    d += a;
#line 238
    c += (((d ^ a) ^ b) + *((uint32_t *)(p + 28))) + 4139469664U;
#line 238
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 238
    c += d;
#line 239
    b += (((c ^ d) ^ a) + *((uint32_t *)(p + 40))) + 3200236656U;
#line 239
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 239
    b += c;
#line 240
    a += (((b ^ c) ^ d) + *((uint32_t *)(p + 52))) + 681279174U;
#line 240
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 240
    a += b;
#line 241
    d += (((a ^ b) ^ c) + *((uint32_t *)(p + 0))) + 3936430074U;
#line 241
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 241
    d += a;
#line 242
    c += (((d ^ a) ^ b) + *((uint32_t *)(p + 12))) + 3572445317U;
#line 242
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 242
    c += d;
#line 243
    b += (((c ^ d) ^ a) + *((uint32_t *)(p + 24))) + 76029189U;
#line 243
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 243
    b += c;
#line 244
    a += (((b ^ c) ^ d) + *((uint32_t *)(p + 36))) + 3654602809U;
#line 244
    a = (a << 4) | ((a & 4294967295U) >> 28);
#line 244
    a += b;
#line 245
    d += (((a ^ b) ^ c) + *((uint32_t *)(p + 48))) + 3873151461U;
#line 245
    d = (d << 11) | ((d & 4294967295U) >> 21);
#line 245
    d += a;
#line 246
    c += (((d ^ a) ^ b) + *((uint32_t *)(p + 60))) + 530742520U;
#line 246
    c = (c << 16) | ((c & 4294967295U) >> 16);
#line 246
    c += d;
#line 247
    b += (((c ^ d) ^ a) + *((uint32_t *)(p + 8))) + 3299628645U;
#line 247
    b = (b << 23) | ((b & 4294967295U) >> 9);
#line 247
    b += c;
#line 251
    a += ((c ^ (b | ~ d)) + *((uint32_t *)(p + 0))) + 4096336452U;
#line 251
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 251
    a += b;
#line 252
    d += ((b ^ (a | ~ c)) + *((uint32_t *)(p + 28))) + 1126891415U;
#line 252
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 252
    d += a;
#line 253
    c += ((a ^ (d | ~ b)) + *((uint32_t *)(p + 56))) + 2878612391U;
#line 253
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 253
    c += d;
#line 254
    b += ((d ^ (c | ~ a)) + *((uint32_t *)(p + 20))) + 4237533241U;
#line 254
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 254
    b += c;
#line 255
    a += ((c ^ (b | ~ d)) + *((uint32_t *)(p + 48))) + 1700485571U;
#line 255
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 255
    a += b;
#line 256
    d += ((b ^ (a | ~ c)) + *((uint32_t *)(p + 12))) + 2399980690U;
#line 256
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 256
    d += a;
#line 257
    c += ((a ^ (d | ~ b)) + *((uint32_t *)(p + 40))) + 4293915773U;
#line 257
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 257
    c += d;
#line 258
    b += ((d ^ (c | ~ a)) + *((uint32_t *)(p + 4))) + 2240044497U;
#line 258
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 258
    b += c;
#line 259
    a += ((c ^ (b | ~ d)) + *((uint32_t *)(p + 32))) + 1873313359U;
#line 259
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 259
    a += b;
#line 260
    d += ((b ^ (a | ~ c)) + *((uint32_t *)(p + 60))) + 4264355552U;
#line 260
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 260
    d += a;
#line 261
    c += ((a ^ (d | ~ b)) + *((uint32_t *)(p + 24))) + 2734768916U;
#line 261
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 261
    c += d;
#line 262
    b += ((d ^ (c | ~ a)) + *((uint32_t *)(p + 52))) + 1309151649U;
#line 262
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 262
    b += c;
#line 263
    a += ((c ^ (b | ~ d)) + *((uint32_t *)(p + 16))) + 4149444226U;
#line 263
    a = (a << 6) | ((a & 4294967295U) >> 26);
#line 263
    a += b;
#line 264
    d += ((b ^ (a | ~ c)) + *((uint32_t *)(p + 44))) + 3174756917U;
#line 264
    d = (d << 10) | ((d & 4294967295U) >> 22);
#line 264
    d += a;
#line 265
    c += ((a ^ (d | ~ b)) + *((uint32_t *)(p + 8))) + 718787259U;
#line 265
    c = (c << 15) | ((c & 4294967295U) >> 17);
#line 265
    c += d;
#line 266
    b += ((d ^ (c | ~ a)) + *((uint32_t *)(p + 36))) + 3951481745U;
#line 266
    b = (b << 21) | ((b & 4294967295U) >> 11);
#line 266
    b += c;
#line 268
    a += saved_a;
#line 269
    b += saved_b;
#line 270
    c += saved_c;
#line 271
    d += saved_d;
#line 273
    p += 64;
#line 186
    size -= 64UL;
#line 186
    if (! size) {
#line 186
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  ctx->a = a;
#line 278
  ctx->b = b;
#line 279
  ctx->c = c;
#line 280
  ctx->d = d;
#line 282
  return (p);
}
}
#line 11 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_murmurhash.c"
uint32_t ngx_murmur_hash2(u_char *data , size_t len ) 
{ 
  uint32_t h ;
  uint32_t k ;

  {
#line 16
  h = (uint32_t )len;
  {
#line 18
  while (1) {
    while_continue: /* CIL Label */ ;
#line 18
    if (! (len >= 4UL)) {
#line 18
      goto while_break;
    }
#line 19
    k = (uint32_t )*(data + 0);
#line 20
    k |= (unsigned int )((int )*(data + 1) << 8);
#line 21
    k |= (unsigned int )((int )*(data + 2) << 16);
#line 22
    k |= (unsigned int )((int )*(data + 3) << 24);
#line 24
    k *= 1540483477U;
#line 25
    k ^= k >> 24;
#line 26
    k *= 1540483477U;
#line 28
    h *= 1540483477U;
#line 29
    h ^= k;
#line 31
    data += 4;
#line 32
    len -= 4UL;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 36
  if (len == 3UL) {
#line 36
    goto case_3;
  }
#line 39
  if (len == 2UL) {
#line 39
    goto case_2;
  }
#line 42
  if (len == 1UL) {
#line 42
    goto case_1;
  }
#line 35
  goto switch_break;
  case_3: /* CIL Label */ 
#line 37
  h ^= (unsigned int )((int )*(data + 2) << 16);
  case_2: /* CIL Label */ 
#line 40
  h ^= (unsigned int )((int )*(data + 1) << 8);
  case_1: /* CIL Label */ 
#line 43
  h ^= (unsigned int )*(data + 0);
#line 44
  h *= 1540483477U;
  switch_break: /* CIL Label */ ;
  }
#line 47
  h ^= h >> 13;
#line 48
  h *= 1540483477U;
#line 49
  h ^= h >> 15;
#line 51
  return (h);
}
}
#line 76 "src/core/ngx_crc32.h"
ngx_int_t ngx_crc32_table_init(void) ;
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crc32.c"
static uint32_t ngx_crc32_table16[16]  = 
#line 26 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crc32.c"
  {      (uint32_t )0,      (uint32_t )498536548,      (uint32_t )997073096,      (uint32_t )651767980, 
        (uint32_t )1994146192,      (uint32_t )1802195444,      (uint32_t )1303535960,      (uint32_t )1342533948, 
        3988292384U,      4027552580U,      3604390888U,      3412177804U, 
        2607071920U,      2262029012U,      2685067896U,      3183342108U};
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crc32.c"
uint32_t ngx_crc32_table256[256]  = 
#line 34
  {      (uint32_t )0,      (uint32_t )1996959894,      3993919788U,      2567524794U, 
        (uint32_t )124634137,      (uint32_t )1886057615,      3915621685U,      2657392035U, 
        (uint32_t )249268274,      (uint32_t )2044508324,      3772115230U,      2547177864U, 
        (uint32_t )162941995,      (uint32_t )2125561021,      3887607047U,      2428444049U, 
        (uint32_t )498536548,      (uint32_t )1789927666,      4089016648U,      2227061214U, 
        (uint32_t )450548861,      (uint32_t )1843258603,      4107580753U,      2211677639U, 
        (uint32_t )325883990,      (uint32_t )1684777152,      4251122042U,      2321926636U, 
        (uint32_t )335633487,      (uint32_t )1661365465,      4195302755U,      2366115317U, 
        (uint32_t )997073096,      (uint32_t )1281953886,      3579855332U,      2724688242U, 
        (uint32_t )1006888145,      (uint32_t )1258607687,      3524101629U,      2768942443U, 
        (uint32_t )901097722,      (uint32_t )1119000684,      3686517206U,      2898065728U, 
        (uint32_t )853044451,      (uint32_t )1172266101,      3705015759U,      2882616665U, 
        (uint32_t )651767980,      (uint32_t )1373503546,      3369554304U,      3218104598U, 
        (uint32_t )565507253,      (uint32_t )1454621731,      3485111705U,      3099436303U, 
        (uint32_t )671266974,      (uint32_t )1594198024,      3322730930U,      2970347812U, 
        (uint32_t )795835527,      (uint32_t )1483230225,      3244367275U,      3060149565U, 
        (uint32_t )1994146192,      (uint32_t )31158534,      2563907772U,      4023717930U, 
        (uint32_t )1907459465,      (uint32_t )112637215,      2680153253U,      3904427059U, 
        (uint32_t )2013776290,      (uint32_t )251722036,      2517215374U,      3775830040U, 
        (uint32_t )2137656763,      (uint32_t )141376813,      2439277719U,      3865271297U, 
        (uint32_t )1802195444,      (uint32_t )476864866,      2238001368U,      4066508878U, 
        (uint32_t )1812370925,      (uint32_t )453092731,      2181625025U,      4111451223U, 
        (uint32_t )1706088902,      (uint32_t )314042704,      2344532202U,      4240017532U, 
        (uint32_t )1658658271,      (uint32_t )366619977,      2362670323U,      4224994405U, 
        (uint32_t )1303535960,      (uint32_t )984961486,      2747007092U,      3569037538U, 
        (uint32_t )1256170817,      (uint32_t )1037604311,      2765210733U,      3554079995U, 
        (uint32_t )1131014506,      (uint32_t )879679996,      2909243462U,      3663771856U, 
        (uint32_t )1141124467,      (uint32_t )855842277,      2852801631U,      3708648649U, 
        (uint32_t )1342533948,      (uint32_t )654459306,      3188396048U,      3373015174U, 
        (uint32_t )1466479909,      (uint32_t )544179635,      3110523913U,      3462522015U, 
        (uint32_t )1591671054,      (uint32_t )702138776,      2966460450U,      3352799412U, 
        (uint32_t )1504918807,      (uint32_t )783551873,      3082640443U,      3233442989U, 
        3988292384U,      2596254646U,      (uint32_t )62317068,      (uint32_t )1957810842, 
        3939845945U,      2647816111U,      (uint32_t )81470997,      (uint32_t )1943803523, 
        3814918930U,      2489596804U,      (uint32_t )225274430,      (uint32_t )2053790376, 
        3826175755U,      2466906013U,      (uint32_t )167816743,      (uint32_t )2097651377, 
        4027552580U,      2265490386U,      (uint32_t )503444072,      (uint32_t )1762050814, 
        4150417245U,      2154129355U,      (uint32_t )426522225,      (uint32_t )1852507879, 
        4275313526U,      2312317920U,      (uint32_t )282753626,      (uint32_t )1742555852, 
        4189708143U,      2394877945U,      (uint32_t )397917763,      (uint32_t )1622183637, 
        3604390888U,      2714866558U,      (uint32_t )953729732,      (uint32_t )1340076626, 
        3518719985U,      2797360999U,      (uint32_t )1068828381,      (uint32_t )1219638859, 
        3624741850U,      2936675148U,      (uint32_t )906185462,      (uint32_t )1090812512, 
        3747672003U,      2825379669U,      (uint32_t )829329135,      (uint32_t )1181335161, 
        3412177804U,      3160834842U,      (uint32_t )628085408,      (uint32_t )1382605366, 
        3423369109U,      3138078467U,      (uint32_t )570562233,      (uint32_t )1426400815, 
        3317316542U,      2998733608U,      (uint32_t )733239954,      (uint32_t )1555261956, 
        3268935591U,      3050360625U,      (uint32_t )752459403,      (uint32_t )1541320221, 
        2607071920U,      3965973030U,      (uint32_t )1969922972,      (uint32_t )40735498, 
        2617837225U,      3943577151U,      (uint32_t )1913087877,      (uint32_t )83908371, 
        2512341634U,      3803740692U,      (uint32_t )2075208622,      (uint32_t )213261112, 
        2463272603U,      3855990285U,      (uint32_t )2094854071,      (uint32_t )198958881, 
        2262029012U,      4057260610U,      (uint32_t )1759359992,      (uint32_t )534414190, 
        2176718541U,      4139329115U,      (uint32_t )1873836001,      (uint32_t )414664567, 
        2282248934U,      4279200368U,      (uint32_t )1711684554,      (uint32_t )285281116, 
        2405801727U,      4167216745U,      (uint32_t )1634467795,      (uint32_t )376229701, 
        2685067896U,      3608007406U,      (uint32_t )1308918612,      (uint32_t )956543938, 
        2808555105U,      3495958263U,      (uint32_t )1231636301,      (uint32_t )1047427035, 
        2932959818U,      3654703836U,      (uint32_t )1088359270,      (uint32_t )936918000, 
        2847714899U,      3736837829U,      (uint32_t )1202900863,      (uint32_t )817233897, 
        3183342108U,      3401237130U,      (uint32_t )1404277552,      (uint32_t )615818150, 
        3134207493U,      3453421203U,      (uint32_t )1423857449,      (uint32_t )601450431, 
        3009837614U,      3294710456U,      (uint32_t )1567103746,      (uint32_t )711928724, 
        3020668471U,      3272380065U,      (uint32_t )1510334235,      (uint32_t )755167117};
#line 102 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crc32.c"
uint32_t *ngx_crc32_table_short  =    ngx_crc32_table16;
#line 105 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_crc32.c"
ngx_int_t ngx_crc32_table_init(void) 
{ 
  void *p ;

  {
#line 110
  if (((uintptr_t )ngx_crc32_table_short & ~ (ngx_cacheline_size - 1UL)) == (uintptr_t )ngx_crc32_table_short) {
#line 114
    return ((ngx_int_t )0);
  }
  {
#line 117
  p = ngx_alloc(16UL * sizeof(uint32_t ) + ngx_cacheline_size, (ngx_log_t *)ngx_cycle->log);
  }
#line 118
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 119
    return ((ngx_int_t )-1);
  }
  {
#line 122
  p = (void *)((u_char *)(((uintptr_t )p + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL)));
#line 124
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(ngx_crc32_table16),
         16UL * sizeof(uint32_t ));
#line 126
  ngx_crc32_table_short = (uint32_t *)p;
  }
#line 128
  return ((ngx_int_t )0);
}
}
#line 321 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 89 "src/core/ngx_palloc.h"
void ngx_pool_delete_file(void *data ) ;
#line 143 "src/core/ngx_file.h"
ngx_int_t ngx_create_path(ngx_file_t *file , ngx_path_t *path ) ;
#line 144
ngx_err_t ngx_create_full_path(u_char *dir , ngx_uint_t access___0 ) ;
#line 149
ngx_int_t ngx_copy_file(u_char *from , u_char *to , ngx_copy_file_t *cf ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
static ngx_int_t ngx_test_full_name(ngx_str_t *name ) ;
#line 15 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
static unsigned long volatile   temp_number  =    (ngx_atomic_t )0;
#line 16 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_atomic_t *ngx_temp_number  =    & temp_number;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_atomic_int_t ngx_random_number  =    (ngx_atomic_int_t )123456;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_int_t ngx_get_full_name(ngx_pool_t *pool , ngx_str_t *prefix , ngx_str_t *name ) 
{ 
  size_t len ;
  u_char *p ;
  u_char *n ;
  ngx_int_t rc ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 27
  rc = ngx_test_full_name(name);
  }
#line 29
  if (rc == 0L) {
#line 30
    return (rc);
  }
  {
#line 33
  len = prefix->len;
#line 43
  tmp = ngx_pnalloc(pool, (len + name->len) + 1UL);
#line 43
  n = (u_char *)tmp;
  }
#line 44
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 45
    return ((ngx_int_t )-1);
  }
  {
#line 48
  tmp___0 = memcpy((void */* __restrict  */)n, (void const   */* __restrict  */)prefix->data,
                   len);
#line 48
  p = (u_char *)tmp___0 + len;
#line 49
  ngx_cpystrn(p, name->data, name->len + 1UL);
#line 51
  name->len += len;
#line 52
  name->data = n;
  }
#line 54
  return ((ngx_int_t )0);
}
}
#line 58 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
static ngx_int_t ngx_test_full_name(ngx_str_t *name ) 
{ 


  {
#line 98
  if ((int )*(name->data + 0) == 47) {
#line 99
    return ((ngx_int_t )0);
  }
#line 102
  return ((ngx_int_t )-5);
}
}
#line 108 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ssize_t ngx_write_chain_to_temp_file(ngx_temp_file_t *tf , ngx_chain_t *chain ) 
{ 
  ngx_int_t rc ;
  ssize_t tmp ;
  char *__cil_tmp5 ;

  {
#line 113
  if (tf->file.fd == -1) {
    {
#line 114
    rc = ngx_create_temp_file(& tf->file, tf->path, tf->pool, (ngx_uint_t )tf->persistent,
                              (ngx_uint_t )tf->clean, tf->access);
    }
#line 117
    if (rc != 0L) {
#line 118
      return (rc);
    }
#line 121
    if (tf->log_level) {
#line 122
      if ((tf->file.log)->log_level >= (ngx_uint_t )tf->log_level) {
        {
#line 122
        ngx_log_error_core((ngx_uint_t )tf->log_level, tf->file.log, 0, "%s %V", tf->warn,
                           & tf->file.name);
        }
      }
    }
  }
  {
#line 136
  tmp = ngx_write_chain_to_file(& tf->file, chain, tf->offset, tf->pool);
  }
#line 136
  return (tmp);
}
}
#line 140 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_int_t ngx_create_temp_file(ngx_file_t *file , ngx_path_t *path , ngx_pool_t *pool ,
                               ngx_uint_t persistent , ngx_uint_t clean , ngx_uint_t access___0 ) 
{ 
  size_t levels ;
  u_char *p ;
  uint32_t n ;
  ngx_err_t err ;
  ngx_str_t name ;
  ngx_uint_t prefix ;
  ngx_pool_cleanup_t *cln ;
  ngx_pool_cleanup_file_t *clnf ;
  void *tmp ;
  void *tmp___0 ;
  ngx_atomic_uint_t tmp___1 ;
  int *tmp___2 ;
  ngx_atomic_uint_t tmp___3 ;
  ngx_int_t tmp___4 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 153
  if (file->name.len) {
#line 154
    name = file->name;
#line 155
    levels = (size_t )0;
#line 156
    prefix = (ngx_uint_t )1;
  } else {
#line 159
    name = path->name;
#line 160
    levels = path->len;
#line 161
    prefix = (ngx_uint_t )0;
  }
  {
#line 164
  file->name.len = ((name.len + 1UL) + levels) + 10UL;
#line 166
  tmp = ngx_pnalloc(pool, file->name.len + 1UL);
#line 166
  file->name.data = (u_char *)tmp;
  }
#line 167
  if ((unsigned long )file->name.data == (unsigned long )((void *)0)) {
#line 168
    return ((ngx_int_t )-1);
  }
  {
#line 177
  tmp___0 = memcpy((void */* __restrict  */)file->name.data, (void const   */* __restrict  */)name.data,
                   name.len);
#line 177
  p = (u_char *)tmp___0 + name.len;
  }
#line 179
  if (prefix) {
#line 180
    *p = (u_char )'.';
  }
  {
#line 183
  p += 1UL + levels;
#line 185
  tmp___1 = ngx_next_temp_number((ngx_uint_t )0);
#line 185
  n = (uint32_t )tmp___1;
#line 187
  cln = ngx_pool_cleanup_add(pool, sizeof(ngx_pool_cleanup_file_t ));
  }
#line 188
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 189
    return ((ngx_int_t )-1);
  }
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 193
    ngx_sprintf(p, "%010uD%Z", n);
    }
#line 195
    if (! prefix) {
      {
#line 196
      ngx_create_hashed_filename(path, file->name.data, file->name.len);
      }
    }
    {
#line 202
    file->fd = ngx_open_tempfile(file->name.data, persistent, access___0);
    }
#line 207
    if (file->fd != -1) {
#line 209
      if (clean) {
#line 209
        cln->handler = & ngx_pool_delete_file;
      } else {
#line 209
        cln->handler = & ngx_pool_cleanup_file;
      }
#line 210
      clnf = (ngx_pool_cleanup_file_t *)cln->data;
#line 212
      clnf->fd = file->fd;
#line 213
      clnf->name = file->name.data;
#line 214
      clnf->log = pool->log;
#line 216
      return ((ngx_int_t )0);
    }
    {
#line 219
    tmp___2 = __errno_location();
#line 219
    err = *tmp___2;
    }
#line 221
    if (err == 17) {
      {
#line 222
      tmp___3 = ngx_next_temp_number((ngx_uint_t )1);
#line 222
      n = (uint32_t )tmp___3;
      }
#line 223
      goto __Cont;
    }
#line 226
    if (path->level[0] == 0UL) {
#line 226
      goto _L;
    } else
#line 226
    if (err != 2) {
      _L: /* CIL Label */ 
#line 227
      if ((file->log)->log_level >= 3UL) {
        {
#line 227
        ngx_log_error_core((ngx_uint_t )3, file->log, err, "open() \"%s\" failed",
                           file->name.data);
        }
      }
#line 230
      return ((ngx_int_t )-1);
    }
    {
#line 233
    tmp___4 = ngx_create_path(file, path);
    }
#line 233
    if (tmp___4 == -1L) {
#line 234
      return ((ngx_int_t )-1);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 240 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
void ngx_create_hashed_filename(ngx_path_t *path , u_char *file , size_t len ) 
{ 
  size_t i ;
  size_t level ;
  ngx_uint_t n ;

  {
#line 246
  i = path->name.len + 1UL;
#line 248
  *(file + (path->name.len + path->len)) = (u_char )'/';
#line 250
  n = (ngx_uint_t )0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (n < 3UL)) {
#line 250
      goto while_break;
    }
#line 251
    level = path->level[n];
#line 253
    if (level == 0UL) {
#line 254
      goto while_break;
    }
    {
#line 257
    len -= level;
#line 258
    *(file + (i - 1UL)) = (u_char )'/';
#line 259
    memcpy((void */* __restrict  */)(file + i), (void const   */* __restrict  */)(file + len),
           level);
#line 260
    i += level + 1UL;
#line 250
    n ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  return;
}
}
#line 265 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_int_t ngx_create_path(ngx_file_t *file , ngx_path_t *path ) 
{ 
  size_t pos ;
  ngx_err_t err ;
  ngx_uint_t i ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;

  {
#line 272
  pos = path->name.len;
#line 274
  i = (ngx_uint_t )0;
  {
#line 274
  while (1) {
    while_continue: /* CIL Label */ ;
#line 274
    if (! (i < 3UL)) {
#line 274
      goto while_break;
    }
#line 275
    if (path->level[i] == 0UL) {
#line 276
      goto while_break;
    }
    {
#line 279
    pos += path->level[i] + 1UL;
#line 281
    *(file->name.data + pos) = (u_char )'\000';
#line 286
    tmp___0 = mkdir((char const   *)file->name.data, (__mode_t )448);
    }
#line 286
    if (tmp___0 == -1) {
      {
#line 287
      tmp = __errno_location();
#line 287
      err = *tmp;
      }
#line 288
      if (err != 17) {
#line 289
        if ((file->log)->log_level >= 3UL) {
          {
#line 289
          ngx_log_error_core((ngx_uint_t )3, file->log, err, "mkdir() \"%s\" failed",
                             file->name.data);
          }
        }
#line 292
        return ((ngx_int_t )-1);
      }
    }
#line 296
    *(file->name.data + pos) = (u_char )'/';
#line 274
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  return ((ngx_int_t )0);
}
}
#line 303 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_err_t ngx_create_full_path(u_char *dir , ngx_uint_t access___0 ) 
{ 
  u_char *p ;
  u_char ch ;
  ngx_err_t err ;
  int *tmp ;
  int tmp___0 ;

  {
#line 309
  err = 0;
#line 314
  p = dir + 1;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! *p) {
#line 317
      goto while_break;
    }
#line 318
    ch = *p;
#line 320
    if ((int )ch != 47) {
#line 321
      goto __Cont;
    }
    {
#line 324
    *p = (u_char )'\000';
#line 326
    tmp___0 = mkdir((char const   *)dir, (__mode_t )access___0);
    }
#line 326
    if (tmp___0 == -1) {
      {
#line 327
      tmp = __errno_location();
#line 327
      err = *tmp;
      }
      {
#line 330
      if (err == 17) {
#line 330
        goto case_17;
      }
#line 332
      if (err == 13) {
#line 332
        goto case_13;
      }
#line 335
      goto switch_default;
      case_17: /* CIL Label */ 
#line 331
      err = 0;
      case_13: /* CIL Label */ 
#line 333
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 336
      return (err);
      switch_break: /* CIL Label */ ;
      }
    }
#line 340
    *p = (u_char )'/';
    __Cont: /* CIL Label */ 
#line 317
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  return (err);
}
}
#line 347 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_atomic_uint_t ngx_next_temp_number(ngx_uint_t collision ) 
{ 
  ngx_atomic_uint_t n ;
  ngx_atomic_uint_t add ;
  ngx_atomic_t tmp ;

  {
#line 352
  if (collision) {
#line 352
    add = (ngx_atomic_uint_t )ngx_random_number;
  } else {
#line 352
    add = (ngx_atomic_uint_t )1;
  }
  {
#line 354
  tmp = (ngx_atomic_t )__sync_fetch_and_add(ngx_temp_number, (ngx_atomic_t )add);
#line 354
  n = (ngx_atomic_uint_t )tmp;
  }
#line 356
  return (n + add);
}
}
#line 360 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
char *ngx_conf_set_path_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *p ;
  ssize_t level ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_path_t *path ;
  ngx_path_t **slot___0 ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 363
  p = (char *)conf;
#line 370
  slot___0 = (ngx_path_t **)(p + cmd->offset);
#line 372
  if (*slot___0) {
#line 373
    return ((char *)"is duplicate");
  }
  {
#line 376
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_path_t ));
#line 376
  path = (ngx_path_t *)tmp;
  }
#line 377
  if ((unsigned long )path == (unsigned long )((void *)0)) {
#line 378
    return ((char *)((void *)-1));
  }
#line 381
  value = (ngx_str_t *)(cf->args)->elts;
#line 383
  path->name = *(value + 1);
#line 385
  if ((int )*(path->name.data + (path->name.len - 1UL)) == 47) {
#line 386
    (path->name.len) --;
  }
  {
#line 389
  tmp___0 = ngx_conf_full_name(cf->cycle, & path->name, (ngx_uint_t )0);
  }
#line 389
  if (tmp___0 != 0L) {
#line 390
    return ((char *)((void *)-1));
  }
#line 393
  path->conf_file = (cf->conf_file)->file.name.data;
#line 394
  path->line = (cf->conf_file)->line;
#line 396
  i = (ngx_uint_t )0;
#line 396
  n = (ngx_uint_t )2;
  {
#line 396
  while (1) {
    while_continue: /* CIL Label */ ;
#line 396
    if (! (n < (cf->args)->nelts)) {
#line 396
      goto while_break;
    }
    {
#line 397
    level = ngx_atoi((value + n)->data, (value + n)->len);
    }
#line 398
    if (level == -1L) {
#line 399
      return ((char *)"invalid value");
    } else
#line 398
    if (level == 0L) {
#line 399
      return ((char *)"invalid value");
    }
#line 402
    path->level[i] = (size_t )level;
#line 403
    path->len += (size_t )(level + 1L);
#line 396
    i ++;
#line 396
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 406
  if (path->len > 10UL + i) {
#line 407
    return ((char *)"invalid value");
  }
  {
#line 410
  *slot___0 = path;
#line 412
  tmp___1 = ngx_add_path(cf, slot___0);
  }
#line 412
  if (tmp___1 == -1L) {
#line 413
    return ((char *)((void *)-1));
  }
#line 416
  return ((char *)((void *)0));
}
}
#line 420 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
char *ngx_conf_merge_path_value(ngx_conf_t *cf , ngx_path_t **path , ngx_path_t *prev ,
                                ngx_path_init_t *init ) 
{ 
  ngx_uint_t i ;
  void *tmp ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  ngx_int_t tmp___2 ;

  {
#line 426
  if (*path) {
#line 427
    return ((char *)((void *)0));
  }
#line 430
  if (prev) {
#line 431
    *path = prev;
#line 432
    return ((char *)((void *)0));
  }
  {
#line 435
  tmp = ngx_pcalloc(cf->pool, sizeof(ngx_path_t ));
#line 435
  *path = (ngx_path_t *)tmp;
  }
#line 436
  if ((unsigned long )*path == (unsigned long )((void *)0)) {
#line 437
    return ((char *)((void *)-1));
  }
  {
#line 440
  (*path)->name = init->name;
#line 442
  tmp___0 = ngx_conf_full_name(cf->cycle, & (*path)->name, (ngx_uint_t )0);
  }
#line 442
  if (tmp___0 != 0L) {
#line 443
    return ((char *)((void *)-1));
  }
#line 446
  i = (ngx_uint_t )0;
  {
#line 446
  while (1) {
    while_continue: /* CIL Label */ ;
#line 446
    if (! (i < 3UL)) {
#line 446
      goto while_break;
    }
#line 447
    (*path)->level[i] = init->level[i];
#line 448
    if (init->level[i]) {
#line 448
      tmp___1 = 1;
    } else {
#line 448
      tmp___1 = 0;
    }
#line 448
    (*path)->len += init->level[i] + (size_t )tmp___1;
#line 446
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 451
  tmp___2 = ngx_add_path(cf, path);
  }
#line 451
  if (tmp___2 != 0L) {
#line 452
    return ((char *)((void *)-1));
  }
#line 455
  return ((char *)((void *)0));
}
}
#line 459 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
char *ngx_conf_set_access_slot(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  char *confp ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t right ;
  ngx_uint_t shift ;
  ngx_uint_t *access___0 ;
  ngx_uint_t user ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 462
  confp = (char *)conf;
#line 468
  access___0 = (ngx_uint_t *)(confp + cmd->offset);
#line 470
  if (*access___0 != 0xffffffffffffffffUL) {
#line 471
    return ((char *)"is duplicate");
  }
#line 474
  value = (ngx_str_t *)(cf->args)->elts;
#line 476
  *access___0 = (ngx_uint_t )0;
#line 477
  user = (ngx_uint_t )384;
#line 479
  i = (ngx_uint_t )1;
  {
#line 479
  while (1) {
    while_continue: /* CIL Label */ ;
#line 479
    if (! (i < (cf->args)->nelts)) {
#line 479
      goto while_break;
    }
    {
#line 481
    p = (value + i)->data;
#line 483
    tmp___1 = strncmp((char const   *)p, "user:", sizeof("user:") - 1UL);
    }
#line 483
    if (tmp___1 == 0) {
#line 484
      shift = (ngx_uint_t )6;
#line 485
      p += sizeof("user:") - 1UL;
#line 486
      user = (ngx_uint_t )0;
    } else {
      {
#line 488
      tmp___0 = strncmp((char const   *)p, "group:", sizeof("group:") - 1UL);
      }
#line 488
      if (tmp___0 == 0) {
#line 489
        shift = (ngx_uint_t )3;
#line 490
        p += sizeof("group:") - 1UL;
      } else {
        {
#line 492
        tmp = strncmp((char const   *)p, "all:", sizeof("all:") - 1UL);
        }
#line 492
        if (tmp == 0) {
#line 493
          shift = (ngx_uint_t )0;
#line 494
          p += sizeof("all:") - 1UL;
        } else {
#line 497
          goto invalid;
        }
      }
    }
    {
#line 500
    tmp___3 = strcmp((char const   *)p, "rw");
    }
#line 500
    if (tmp___3 == 0) {
#line 501
      right = (ngx_uint_t )6;
    } else {
      {
#line 503
      tmp___2 = strcmp((char const   *)p, "r");
      }
#line 503
      if (tmp___2 == 0) {
#line 504
        right = (ngx_uint_t )4;
      } else {
#line 507
        goto invalid;
      }
    }
#line 510
    *access___0 |= right << shift;
#line 479
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  *access___0 |= user;
#line 515
  return ((char *)((void *)0));
  invalid: 
  {
#line 519
  ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid value \"%V\"", value + i);
  }
#line 521
  return ((char *)((void *)-1));
}
}
#line 525 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_int_t ngx_add_path(ngx_conf_t *cf , ngx_path_t **slot___0 ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_path_t *path ;
  ngx_path_t **p ;
  int tmp ;
  void *tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 531
  path = *slot___0;
#line 533
  p = (ngx_path_t **)(cf->cycle)->paths.elts;
#line 534
  i = (ngx_uint_t )0;
  {
#line 534
  while (1) {
    while_continue: /* CIL Label */ ;
#line 534
    if (! (i < (cf->cycle)->paths.nelts)) {
#line 534
      goto while_break;
    }
#line 535
    if ((*(p + i))->name.len == path->name.len) {
      {
#line 535
      tmp = strcmp((char const   *)(*(p + i))->name.data, (char const   *)path->name.data);
      }
#line 535
      if (tmp == 0) {
#line 538
        if ((unsigned long )(*(p + i))->data != (unsigned long )path->data) {
          {
#line 539
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the same path name \"%V\" used in %s:%ui and",
                             & (*(p + i))->name, (*(p + i))->conf_file, (*(p + i))->line);
          }
#line 543
          return ((ngx_int_t )-1);
        }
#line 546
        n = (ngx_uint_t )0;
        {
#line 546
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 546
          if (! (n < 3UL)) {
#line 546
            goto while_break___0;
          }
#line 547
          if ((*(p + i))->level[n] != path->level[n]) {
#line 548
            if ((unsigned long )path->conf_file == (unsigned long )((void *)0)) {
#line 549
              if ((unsigned long )(*(p + i))->conf_file == (unsigned long )((void *)0)) {
#line 550
                if ((cf->log)->log_level >= 1UL) {
                  {
#line 550
                  ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "the default path name \"%V\" has the same name as another default path, but the different levels, you need to redefine one of them in http section",
                                     & (*(p + i))->name);
                  }
                }
#line 556
                return ((ngx_int_t )-1);
              }
#line 559
              if ((cf->log)->log_level >= 1UL) {
                {
#line 559
                ngx_log_error_core((ngx_uint_t )1, cf->log, 0, "the path name \"%V\" in %s:%ui has the same name as default path, but the different levels, you need to define default path in http section",
                                   & (*(p + i))->name, (*(p + i))->conf_file, (*(p + i))->line);
                }
              }
#line 565
              return ((ngx_int_t )-1);
            }
            {
#line 568
            ngx_conf_log_error((ngx_uint_t )1, cf, 0, "the same path name \"%V\" in %s:%ui has the different levels than",
                               & (*(p + i))->name, (*(p + i))->conf_file, (*(p + i))->line);
            }
#line 572
            return ((ngx_int_t )-1);
          }
#line 575
          if ((*(p + i))->level[n] == 0UL) {
#line 576
            goto while_break___0;
          }
#line 546
          n ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 580
        *slot___0 = *(p + i);
#line 582
        return ((ngx_int_t )0);
      }
    }
#line 534
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 586
  tmp___0 = ngx_array_push(& (cf->cycle)->paths);
#line 586
  p = (ngx_path_t **)tmp___0;
  }
#line 587
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 588
    return ((ngx_int_t )-1);
  }
#line 591
  *p = path;
#line 593
  return ((ngx_int_t )0);
}
}
#line 597 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_int_t ngx_create_paths(ngx_cycle_t *cycle , ngx_uid_t user ) 
{ 
  ngx_err_t err ;
  ngx_uint_t i ;
  ngx_path_t **path ;
  int *tmp ;
  int tmp___0 ;
  ngx_file_info_t fi ;
  int *tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  void *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 604
  path = (ngx_path_t **)cycle->paths.elts;
#line 605
  i = (ngx_uint_t )0;
  {
#line 605
  while (1) {
    while_continue: /* CIL Label */ ;
#line 605
    if (! (i < cycle->paths.nelts)) {
#line 605
      goto while_break;
    }
    {
#line 607
    tmp___0 = mkdir((char const   *)(*(path + i))->name.data, (__mode_t )448);
    }
#line 607
    if (tmp___0 == -1) {
      {
#line 608
      tmp = __errno_location();
#line 608
      err = *tmp;
      }
#line 609
      if (err != 17) {
#line 610
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 610
          ngx_log_error_core((ngx_uint_t )1, cycle->log, err, "mkdir() \"%s\" failed",
                             (*(path + i))->name.data);
          }
        }
#line 613
        return ((ngx_int_t )-1);
      }
    }
#line 617
    if (user == 4294967295U) {
#line 618
      goto __Cont;
    }
    {
#line 625
    tmp___2 = stat((char const   */* __restrict  */)((char const   *)(*(path + i))->name.data),
                   (struct stat */* __restrict  */)(& fi));
    }
#line 625
    if (tmp___2 == -1) {
#line 626
      if ((cycle->log)->log_level >= 1UL) {
        {
#line 626
        tmp___1 = __errno_location();
#line 626
        ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___1, "stat() \"%s\" failed",
                           (*(path + i))->name.data);
        }
      }
#line 628
      return ((ngx_int_t )-1);
    }
#line 631
    if (fi.st_uid != user) {
      {
#line 632
      tmp___4 = chown((char const   *)(*(path + i))->name.data, user, (__gid_t )-1);
      }
#line 632
      if (tmp___4 == -1) {
#line 633
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 633
          tmp___3 = __errno_location();
#line 633
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___3, "chown(\"%s\", %d) failed",
                             (*(path + i))->name.data, user);
          }
        }
#line 636
        return ((ngx_int_t )-1);
      }
    }
#line 640
    if ((fi.st_mode & 448U) != 448U) {
      {
#line 643
      fi.st_mode |= 448U;
#line 645
      tmp___6 = chmod((char const   *)(*(path + i))->name.data, fi.st_mode);
      }
#line 645
      if (tmp___6 == -1) {
#line 646
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 646
          tmp___5 = __errno_location();
#line 646
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___5, "chmod() \"%s\" failed",
                             (*(path + i))->name.data);
          }
        }
#line 648
        return ((ngx_int_t )-1);
      }
    }
    __Cont: /* CIL Label */ 
#line 605
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 655
  return ((ngx_int_t )0);
}
}
#line 659 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_int_t ngx_ext_rename_file(ngx_str_t *src , ngx_str_t *to , ngx_ext_rename_file_t *ext ) 
{ 
  u_char *name ;
  ngx_err_t err ;
  ngx_copy_file_t cf ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  ngx_int_t tmp___2 ;
  int tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;
  int *tmp___6 ;
  void *tmp___7 ;
  ngx_atomic_uint_t tmp___8 ;
  int *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  int *tmp___13 ;
  int tmp___14 ;
  ngx_int_t tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 668
  if (ext->access) {
    {
#line 669
    tmp___0 = chmod((char const   *)src->data, (__mode_t )ext->access);
    }
#line 669
    if (tmp___0 == -1) {
#line 670
      if ((ext->log)->log_level >= 3UL) {
        {
#line 670
        tmp = __errno_location();
#line 670
        ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp, "chmod() \"%s\" failed",
                           src->data);
        }
      }
#line 672
      err = 0;
#line 673
      goto failed;
    }
  }
#line 679
  if (ext->time != -1L) {
    {
#line 680
    tmp___2 = ngx_set_file_time(src->data, ext->fd, ext->time);
    }
#line 680
    if (tmp___2 != 0L) {
#line 681
      if ((ext->log)->log_level >= 3UL) {
        {
#line 681
        tmp___1 = __errno_location();
#line 681
        ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___1, "utimes() \"%s\" failed",
                           src->data);
        }
      }
#line 683
      err = 0;
#line 684
      goto failed;
    }
  }
  {
#line 688
  tmp___3 = rename((char const   *)src->data, (char const   *)to->data);
  }
#line 688
  if (tmp___3 != -1) {
#line 689
    return ((ngx_int_t )0);
  }
  {
#line 692
  tmp___4 = __errno_location();
#line 692
  err = *tmp___4;
  }
#line 694
  if (err == 2) {
#line 696
    if (! ext->create_path) {
#line 697
      goto failed;
    }
    {
#line 700
    err = ngx_create_full_path(to->data, ext->path_access | ((ext->path_access & 292UL) >> 2));
    }
#line 702
    if (err) {
#line 703
      if ((ext->log)->log_level >= 3UL) {
        {
#line 703
        ngx_log_error_core((ngx_uint_t )3, ext->log, err, "mkdir() \"%s\" failed",
                           to->data);
        }
      }
#line 705
      err = 0;
#line 706
      goto failed;
    }
    {
#line 709
    tmp___5 = rename((char const   *)src->data, (char const   *)to->data);
    }
#line 709
    if (tmp___5 != -1) {
#line 710
      return ((ngx_int_t )0);
    }
    {
#line 713
    tmp___6 = __errno_location();
#line 713
    err = *tmp___6;
    }
  }
#line 728
  if (err == 18) {
    {
#line 730
    cf.size = (off_t )-1;
#line 731
    cf.buf_size = (size_t )0;
#line 732
    cf.access = ext->access;
#line 733
    cf.time = ext->time;
#line 734
    cf.log = ext->log;
#line 736
    tmp___7 = ngx_alloc(((to->len + 1UL) + 10UL) + 1UL, ext->log);
#line 736
    name = (u_char *)tmp___7;
    }
#line 737
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 738
      return ((ngx_int_t )-1);
    }
    {
#line 741
    tmp___8 = ngx_next_temp_number((ngx_uint_t )0);
#line 741
    ngx_sprintf(name, "%*s.%010uD%Z", to->len, to->data, (uint32_t )tmp___8);
#line 744
    tmp___15 = ngx_copy_file(src->data, name, & cf);
    }
#line 744
    if (tmp___15 == 0L) {
      {
#line 746
      tmp___11 = rename((char const   *)name, (char const   *)to->data);
      }
#line 746
      if (tmp___11 != -1) {
        {
#line 747
        free((void *)name);
#line 749
        tmp___10 = unlink((char const   *)src->data);
        }
#line 749
        if (tmp___10 == -1) {
#line 750
          if ((ext->log)->log_level >= 3UL) {
            {
#line 750
            tmp___9 = __errno_location();
#line 750
            ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___9, "unlink() \"%s\" failed",
                               src->data);
            }
          }
#line 753
          return ((ngx_int_t )-1);
        }
#line 756
        return ((ngx_int_t )0);
      }
#line 759
      if ((ext->log)->log_level >= 3UL) {
        {
#line 759
        tmp___12 = __errno_location();
#line 759
        ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___12, "rename() \"%s\" to \"%s\" failed",
                           name, to->data);
        }
      }
      {
#line 763
      tmp___14 = unlink((char const   *)name);
      }
#line 763
      if (tmp___14 == -1) {
#line 764
        if ((ext->log)->log_level >= 3UL) {
          {
#line 764
          tmp___13 = __errno_location();
#line 764
          ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___13, "unlink() \"%s\" failed",
                             name);
          }
        }
      }
    }
    {
#line 770
    free((void *)name);
#line 772
    err = 0;
    }
  }
  failed: 
#line 777
  if (ext->delete_file) {
    {
#line 778
    tmp___17 = unlink((char const   *)src->data);
    }
#line 778
    if (tmp___17 == -1) {
#line 779
      if ((ext->log)->log_level >= 3UL) {
        {
#line 779
        tmp___16 = __errno_location();
#line 779
        ngx_log_error_core((ngx_uint_t )3, ext->log, *tmp___16, "unlink() \"%s\" failed",
                           src->data);
        }
      }
    }
  }
#line 784
  if (err) {
#line 785
    if ((ext->log)->log_level >= 3UL) {
      {
#line 785
      ngx_log_error_core((ngx_uint_t )3, ext->log, err, "rename() \"%s\" to \"%s\" failed",
                         src->data, to->data);
      }
    }
  }
#line 790
  return ((ngx_int_t )-1);
}
}
#line 794 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_int_t ngx_copy_file(u_char *from , u_char *to , ngx_copy_file_t *cf ) 
{ 
  char *buf ;
  off_t size ;
  size_t len ;
  ssize_t n ;
  ngx_fd_t fd ;
  ngx_fd_t nfd ;
  ngx_int_t rc ;
  ngx_file_info_t fi ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  ngx_int_t tmp___7 ;
  int *tmp___8 ;
  int tmp___9 ;
  int *tmp___10 ;
  int tmp___11 ;
  void *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
#line 805
  rc = (ngx_int_t )-1;
#line 806
  buf = (char *)((void *)0);
#line 807
  nfd = -1;
#line 809
  fd = open((char const   *)from, 0, 0);
  }
#line 811
  if (fd == -1) {
#line 812
    if ((cf->log)->log_level >= 3UL) {
      {
#line 812
      tmp = __errno_location();
#line 812
      ngx_log_error_core((ngx_uint_t )3, cf->log, *tmp, "open() \"%s\" failed", from);
      }
    }
#line 814
    goto failed;
  }
#line 817
  if (cf->size != -1L) {
#line 818
    size = cf->size;
  } else {
    {
#line 821
    tmp___1 = fstat(fd, & fi);
    }
#line 821
    if (tmp___1 == -1) {
#line 822
      if ((cf->log)->log_level >= 2UL) {
        {
#line 822
        tmp___0 = __errno_location();
#line 822
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___0, "fstat() \"%s\" failed",
                           from);
        }
      }
#line 825
      goto failed;
    }
#line 828
    size = fi.st_size;
  }
#line 831
  if (cf->buf_size) {
#line 831
    len = cf->buf_size;
  } else {
#line 831
    len = (size_t )65536;
  }
#line 833
  if ((off_t )len > size) {
#line 834
    len = (size_t )size;
  }
  {
#line 837
  tmp___2 = ngx_alloc(len, cf->log);
#line 837
  buf = (char *)tmp___2;
  }
#line 838
  if ((unsigned long )buf == (unsigned long )((void *)0)) {
#line 839
    goto failed;
  }
  {
#line 842
  nfd = open((char const   *)to, 65, cf->access);
  }
#line 845
  if (nfd == -1) {
#line 846
    if ((cf->log)->log_level >= 3UL) {
      {
#line 846
      tmp___3 = __errno_location();
#line 846
      ngx_log_error_core((ngx_uint_t )3, cf->log, *tmp___3, "open() \"%s\" failed",
                         to);
      }
    }
#line 848
    goto failed;
  }
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 851
    if (! (size > 0L)) {
#line 851
      goto while_break;
    }
#line 853
    if ((off_t )len > size) {
#line 854
      len = (size_t )size;
    }
    {
#line 857
    n = read(fd, (void *)buf, len);
    }
#line 859
    if (n == -1L) {
#line 860
      if ((cf->log)->log_level >= 2UL) {
        {
#line 860
        tmp___4 = __errno_location();
#line 860
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___4, "read() \"%s\" failed",
                           from);
        }
      }
#line 862
      goto failed;
    }
#line 865
    if ((size_t )n != len) {
#line 866
      if ((cf->log)->log_level >= 2UL) {
        {
#line 866
        ngx_log_error_core((ngx_uint_t )2, cf->log, 0, "read() has read only %z of %O from %s",
                           n, size, from);
        }
      }
#line 869
      goto failed;
    }
    {
#line 872
    n = ngx_write_fd(nfd, (void *)buf, len);
    }
#line 874
    if (n == -1L) {
#line 875
      if ((cf->log)->log_level >= 2UL) {
        {
#line 875
        tmp___5 = __errno_location();
#line 875
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___5, "write() \"%s\" failed",
                           to);
        }
      }
#line 877
      goto failed;
    }
#line 880
    if ((size_t )n != len) {
#line 881
      if ((cf->log)->log_level >= 2UL) {
        {
#line 881
        ngx_log_error_core((ngx_uint_t )2, cf->log, 0, "write() has written only %z of %O to %s",
                           n, size, to);
        }
      }
#line 884
      goto failed;
    }
#line 887
    size -= n;
  }
  while_break: /* CIL Label */ ;
  }
#line 890
  if (cf->time != -1L) {
    {
#line 891
    tmp___7 = ngx_set_file_time(to, nfd, cf->time);
    }
#line 891
    if (tmp___7 != 0L) {
#line 892
      if ((cf->log)->log_level >= 2UL) {
        {
#line 892
        tmp___6 = __errno_location();
#line 892
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___6, "utimes() \"%s\" failed",
                           to);
        }
      }
#line 894
      goto failed;
    }
  }
#line 898
  rc = (ngx_int_t )0;
  failed: 
#line 902
  if (nfd != -1) {
    {
#line 903
    tmp___9 = close(nfd);
    }
#line 903
    if (tmp___9 == -1) {
#line 904
      if ((cf->log)->log_level >= 2UL) {
        {
#line 904
        tmp___8 = __errno_location();
#line 904
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___8, "close() \"%s\" failed",
                           to);
        }
      }
    }
  }
#line 909
  if (fd != -1) {
    {
#line 910
    tmp___11 = close(fd);
    }
#line 910
    if (tmp___11 == -1) {
#line 911
      if ((cf->log)->log_level >= 2UL) {
        {
#line 911
        tmp___10 = __errno_location();
#line 911
        ngx_log_error_core((ngx_uint_t )2, cf->log, *tmp___10, "close() \"%s\" failed",
                           from);
        }
      }
    }
  }
#line 916
  if (buf) {
    {
#line 917
    free((void *)buf);
    }
  }
#line 920
  return (rc);
}
}
#line 942 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_file.c"
ngx_int_t ngx_walk_tree(ngx_tree_ctx_t *ctx , ngx_str_t *tree ) 
{ 
  void *data ;
  void *prev ;
  u_char *p ;
  u_char *name ;
  size_t len ;
  ngx_int_t rc ;
  ngx_err_t err ;
  ngx_str_t file ;
  ngx_str_t buf ;
  ngx_dir_t dir ;
  int *tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  ngx_int_t tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  u_char *tmp___7 ;
  int *tmp___8 ;
  ngx_int_t tmp___9 ;
  ngx_int_t tmp___10 ;
  ngx_int_t tmp___11 ;
  ngx_int_t tmp___12 ;
  ngx_int_t tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
  {
#line 953
  buf.len = (size_t )0;
#line 953
  buf.data = (u_char *)((void *)0);
#line 958
  tmp___0 = ngx_open_dir(tree, & dir);
  }
#line 958
  if (tmp___0 == -1L) {
#line 959
    if ((ctx->log)->log_level >= 3UL) {
      {
#line 959
      tmp = __errno_location();
#line 959
      ngx_log_error_core((ngx_uint_t )3, ctx->log, *tmp, "opendir() \"%s\" failed",
                         tree->data);
      }
    }
#line 961
    return ((ngx_int_t )-1);
  }
#line 964
  prev = ctx->data;
#line 966
  if (ctx->alloc) {
    {
#line 967
    data = ngx_alloc(ctx->alloc, ctx->log);
    }
#line 968
    if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 969
      goto failed;
    }
    {
#line 972
    tmp___1 = (*(ctx->init_handler))(data, prev);
    }
#line 972
    if (tmp___1 == -6L) {
#line 973
      goto failed;
    }
#line 976
    ctx->data = data;
  } else {
#line 979
    data = (void *)0;
  }
  {
#line 982
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 984
    tmp___2 = __errno_location();
#line 984
    *tmp___2 = 0;
#line 986
    tmp___4 = ngx_read_dir(& dir);
    }
#line 986
    if (tmp___4 == -1L) {
      {
#line 987
      tmp___3 = __errno_location();
#line 987
      err = *tmp___3;
      }
#line 989
      if (err == 0) {
#line 990
        rc = (ngx_int_t )0;
      } else {
#line 993
        if ((ctx->log)->log_level >= 3UL) {
          {
#line 993
          ngx_log_error_core((ngx_uint_t )3, ctx->log, err, "readdir() \"%s\" failed",
                             tree->data);
          }
        }
#line 995
        rc = (ngx_int_t )-1;
      }
#line 998
      goto done;
    }
    {
#line 1001
    len = strlen((char const   *)((dir.de)->d_name));
#line 1002
    name = (u_char *)((dir.de)->d_name);
    }
#line 1007
    if (len == 1UL) {
#line 1007
      if ((int )*(name + 0) == 46) {
#line 1008
        goto __Cont;
      }
    }
#line 1011
    if (len == 2UL) {
#line 1011
      if ((int )*(name + 0) == 46) {
#line 1011
        if ((int )*(name + 1) == 46) {
#line 1012
          goto __Cont;
        }
      }
    }
#line 1015
    file.len = (tree->len + 1UL) + len;
#line 1017
    if (file.len > buf.len) {
#line 1019
      if (buf.len) {
        {
#line 1020
        free((void *)buf.data);
        }
      }
      {
#line 1023
      buf.len = (tree->len + 1UL) + len;
#line 1025
      tmp___5 = ngx_alloc(buf.len + 1UL, ctx->log);
#line 1025
      buf.data = (u_char *)tmp___5;
      }
#line 1026
      if ((unsigned long )buf.data == (unsigned long )((void *)0)) {
#line 1027
        goto failed;
      }
    }
    {
#line 1031
    tmp___6 = memcpy((void */* __restrict  */)buf.data, (void const   */* __restrict  */)tree->data,
                     tree->len);
#line 1031
    p = (u_char *)tmp___6 + tree->len;
#line 1032
    tmp___7 = p;
#line 1032
    p ++;
#line 1032
    *tmp___7 = (u_char )'/';
#line 1033
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)name, len + 1UL);
#line 1035
    file.data = buf.data;
    }
#line 1040
    if (! dir.valid_info) {
      {
#line 1041
      tmp___9 = ngx_de_info(file.data, & dir);
      }
#line 1041
      if (tmp___9 == -1L) {
#line 1042
        if ((ctx->log)->log_level >= 3UL) {
          {
#line 1042
          tmp___8 = __errno_location();
#line 1042
          ngx_log_error_core((ngx_uint_t )3, ctx->log, *tmp___8, "stat() \"%s\" failed",
                             file.data);
          }
        }
#line 1044
        goto __Cont;
      }
    }
#line 1048
    if (dir.type) {
#line 1048
      tmp___15 = dir.type == 8U;
    } else {
#line 1048
      tmp___15 = (dir.info.st_mode & 61440U) == 32768U;
    }
#line 1048
    if (tmp___15) {
#line 1053
      ctx->size = dir.info.st_size;
#line 1054
      if (dir.info.st_size < dir.info.st_blocks * 512L) {
#line 1054
        ctx->fs_size = dir.info.st_blocks * 512L;
      } else {
#line 1054
        ctx->fs_size = dir.info.st_size;
      }
      {
#line 1055
      ctx->access = (ngx_uint_t )(dir.info.st_mode & 511U);
#line 1056
      ctx->mtime = dir.info.st_mtim.tv_sec;
#line 1058
      tmp___10 = (*(ctx->file_handler))(ctx, & file);
      }
#line 1058
      if (tmp___10 == -6L) {
#line 1059
        goto failed;
      }
    } else {
#line 1062
      if (dir.type) {
#line 1062
        tmp___14 = dir.type == 4U;
      } else {
#line 1062
        tmp___14 = (dir.info.st_mode & 61440U) == 16384U;
      }
#line 1062
      if (tmp___14) {
        {
#line 1067
        ctx->access = (ngx_uint_t )(dir.info.st_mode & 511U);
#line 1068
        ctx->mtime = dir.info.st_mtim.tv_sec;
#line 1070
        rc = (*(ctx->pre_tree_handler))(ctx, & file);
        }
#line 1072
        if (rc == -6L) {
#line 1073
          goto failed;
        }
#line 1076
        if (rc == -5L) {
#line 1079
          goto __Cont;
        }
        {
#line 1082
        tmp___11 = ngx_walk_tree(ctx, & file);
        }
#line 1082
        if (tmp___11 == -6L) {
#line 1083
          goto failed;
        }
        {
#line 1086
        ctx->access = (ngx_uint_t )(dir.info.st_mode & 511U);
#line 1087
        ctx->mtime = dir.info.st_mtim.tv_sec;
#line 1089
        tmp___12 = (*(ctx->post_tree_handler))(ctx, & file);
        }
#line 1089
        if (tmp___12 == -6L) {
#line 1090
          goto failed;
        }
      } else {
        {
#line 1098
        tmp___13 = (*(ctx->spec_handler))(ctx, & file);
        }
#line 1098
        if (tmp___13 == -6L) {
#line 1099
          goto failed;
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  failed: 
#line 1106
  rc = (ngx_int_t )-6;
  done: 
#line 1110
  if (buf.len) {
    {
#line 1111
    free((void *)buf.data);
    }
  }
#line 1114
  if (data) {
    {
#line 1115
    free(data);
#line 1116
    ctx->data = prev;
    }
  }
  {
#line 1119
  tmp___17 = closedir(dir.dir);
  }
#line 1119
  if (tmp___17 == -1) {
#line 1120
    if ((ctx->log)->log_level >= 3UL) {
      {
#line 1120
      tmp___16 = __errno_location();
#line 1120
      ngx_log_error_core((ngx_uint_t )3, ctx->log, *tmp___16, "closedir() \"%s\" failed",
                         tree->data);
      }
    }
  }
#line 1124
  return (rc);
}
}
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 63 "src/core/ngx_string.h"
size_t ngx_strnlen(u_char *p , size_t n ) ;
#line 110 "src/core/ngx_inet.h"
ngx_int_t ngx_inet6_addr(u_char *p , size_t len , u_char *addr ) ;
#line 111
size_t ngx_inet6_ntop(u_char *p , u_char *text , size_t len ) ;
#line 115
size_t ngx_inet_ntop(int family , void *addr , u_char *text , size_t len ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
static ngx_int_t ngx_parse_unix_domain_url(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 13
static ngx_int_t ngx_parse_inet_url(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 14
static ngx_int_t ngx_parse_inet6_url(ngx_pool_t *pool , ngx_url_t *u ) ;
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
in_addr_t ngx_inet_addr(u_char *text , size_t len ) 
{ 
  u_char *p ;
  u_char c ;
  in_addr_t addr ;
  ngx_uint_t octet ;
  ngx_uint_t n ;
  uint32_t tmp ;

  {
#line 24
  addr = (in_addr_t )0;
#line 25
  octet = (ngx_uint_t )0;
#line 26
  n = (ngx_uint_t )0;
#line 28
  p = text;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! ((unsigned long )p < (unsigned long )(text + len))) {
#line 28
      goto while_break;
    }
#line 29
    c = *p;
#line 31
    if ((int )c >= 48) {
#line 31
      if ((int )c <= 57) {
#line 32
        octet = octet * 10UL + (ngx_uint_t )((int )c - 48);
#line 34
        if (octet > 255UL) {
#line 35
          return (4294967295U);
        }
#line 38
        goto __Cont;
      }
    }
#line 41
    if ((int )c == 46) {
#line 42
      addr = (in_addr_t )((ngx_uint_t )(addr << 8) + octet);
#line 43
      octet = (ngx_uint_t )0;
#line 44
      n ++;
#line 45
      goto __Cont;
    }
#line 48
    return (4294967295U);
    __Cont: /* CIL Label */ 
#line 28
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  if (n == 3UL) {
    {
#line 52
    addr = (in_addr_t )((ngx_uint_t )(addr << 8) + octet);
#line 53
    tmp = htonl(addr);
    }
#line 53
    return (tmp);
  }
#line 56
  return (4294967295U);
}
}
#line 62 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
ngx_int_t ngx_inet6_addr(u_char *p , size_t len , u_char *addr ) 
{ 
  u_char c ;
  u_char *zero___0 ;
  u_char *digit ;
  u_char *s ;
  u_char *d ;
  size_t len4 ;
  ngx_uint_t n ;
  ngx_uint_t nibbles ;
  ngx_uint_t word ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  in_addr_t tmp___2 ;
  uint32_t tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;

  {
#line 69
  if (len == 0UL) {
#line 70
    return ((ngx_int_t )-1);
  }
#line 73
  zero___0 = (u_char *)((void *)0);
#line 74
  digit = (u_char *)((void *)0);
#line 75
  len4 = (size_t )0;
#line 76
  nibbles = (ngx_uint_t )0;
#line 77
  word = (ngx_uint_t )0;
#line 78
  n = (ngx_uint_t )8;
#line 80
  if ((int )*(p + 0) == 58) {
#line 81
    p ++;
#line 82
    len --;
  }
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! len) {
#line 85
      goto while_break;
    }
#line 86
    tmp = p;
#line 86
    p ++;
#line 86
    c = *tmp;
#line 88
    if ((int )c == 58) {
#line 89
      if (nibbles) {
#line 90
        digit = p;
#line 91
        len4 = len;
#line 92
        tmp___0 = addr;
#line 92
        addr ++;
#line 92
        *tmp___0 = (u_char )(word >> 8);
#line 93
        tmp___1 = addr;
#line 93
        addr ++;
#line 93
        *tmp___1 = (u_char )(word & 255UL);
#line 95
        n --;
#line 95
        if (n) {
#line 96
          nibbles = (ngx_uint_t )0;
#line 97
          word = (ngx_uint_t )0;
#line 98
          goto __Cont;
        }
      } else
#line 102
      if ((unsigned long )zero___0 == (unsigned long )((void *)0)) {
#line 103
        digit = p;
#line 104
        len4 = len;
#line 105
        zero___0 = addr;
#line 106
        goto __Cont;
      }
#line 110
      return ((ngx_int_t )-1);
    }
#line 113
    if ((int )c == 46) {
#line 113
      if (nibbles) {
#line 114
        if (n < 2UL) {
#line 115
          return ((ngx_int_t )-1);
        } else
#line 114
        if ((unsigned long )digit == (unsigned long )((void *)0)) {
#line 115
          return ((ngx_int_t )-1);
        }
        {
#line 118
        tmp___2 = ngx_inet_addr(digit, len4 - 1UL);
#line 118
        word = (ngx_uint_t )tmp___2;
        }
#line 119
        if (word == 4294967295UL) {
#line 120
          return ((ngx_int_t )-1);
        }
        {
#line 123
        tmp___3 = ntohl((uint32_t )word);
#line 123
        word = (ngx_uint_t )tmp___3;
#line 124
        tmp___4 = addr;
#line 124
        addr ++;
#line 124
        *tmp___4 = (u_char )((word >> 24) & 255UL);
#line 125
        tmp___5 = addr;
#line 125
        addr ++;
#line 125
        *tmp___5 = (u_char )((word >> 16) & 255UL);
#line 126
        n --;
        }
#line 127
        goto while_break;
      }
    }
#line 130
    nibbles ++;
#line 130
    if (nibbles > 4UL) {
#line 131
      return ((ngx_int_t )-1);
    }
#line 134
    if ((int )c >= 48) {
#line 134
      if ((int )c <= 57) {
#line 135
        word = word * 16UL + (ngx_uint_t )((int )c - 48);
#line 136
        goto __Cont;
      }
    }
#line 139
    c = (u_char )((int )c | 32);
#line 141
    if ((int )c >= 97) {
#line 141
      if ((int )c <= 102) {
#line 142
        word = (word * 16UL + (ngx_uint_t )((int )c - 97)) + 10UL;
#line 143
        goto __Cont;
      }
    }
#line 146
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ 
#line 85
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  if (nibbles == 0UL) {
#line 149
    if ((unsigned long )zero___0 == (unsigned long )((void *)0)) {
#line 150
      return ((ngx_int_t )-1);
    }
  }
#line 153
  tmp___6 = addr;
#line 153
  addr ++;
#line 153
  *tmp___6 = (u_char )(word >> 8);
#line 154
  tmp___7 = addr;
#line 154
  addr ++;
#line 154
  *tmp___7 = (u_char )(word & 255UL);
#line 156
  n --;
#line 156
  if (n) {
#line 157
    if (zero___0) {
#line 158
      n *= 2UL;
#line 159
      s = addr - 1;
#line 160
      d = s + n;
      {
#line 161
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 161
        if (! ((unsigned long )s >= (unsigned long )zero___0)) {
#line 161
          goto while_break___0;
        }
#line 162
        tmp___8 = d;
#line 162
        d --;
#line 162
        tmp___9 = s;
#line 162
        s --;
#line 162
        *tmp___8 = *tmp___9;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 164
      memset((void *)zero___0, 0, n);
      }
#line 165
      return ((ngx_int_t )0);
    }
  } else
#line 169
  if ((unsigned long )zero___0 == (unsigned long )((void *)0)) {
#line 170
    return ((ngx_int_t )0);
  }
#line 174
  return ((ngx_int_t )-1);
}
}
#line 180 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
size_t ngx_sock_ntop(struct sockaddr *sa , socklen_t socklen , u_char *text , size_t len ,
                     ngx_uint_t port ) 
{ 
  u_char *p ;
  size_t n ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  struct sockaddr_un *saun ;
  uint16_t tmp ;
  size_t tmp___0 ;
  uint16_t tmp___1 ;
  u_char *tmp___2 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 198
  if ((int )sa->sa_family == 2) {
#line 198
    goto case_2;
  }
#line 215
  if ((int )sa->sa_family == 10) {
#line 215
    goto case_10;
  }
#line 237
  if ((int )sa->sa_family == 1) {
#line 237
    goto case_1;
  }
#line 257
  goto switch_default;
  case_2: /* CIL Label */ 
#line 200
  sin = (struct sockaddr_in *)sa;
#line 201
  p = (u_char *)(& sin->sin_addr);
#line 203
  if (port) {
    {
#line 204
    tmp = ntohs(sin->sin_port);
#line 204
    p = ngx_snprintf(text, len, "%ud.%ud.%ud.%ud:%d", (int )*(p + 0), (int )*(p + 1),
                     (int )*(p + 2), (int )*(p + 3), (int )tmp);
    }
  } else {
    {
#line 207
    p = ngx_snprintf(text, len, "%ud.%ud.%ud.%ud", (int )*(p + 0), (int )*(p + 1),
                     (int )*(p + 2), (int )*(p + 3));
    }
  }
#line 211
  return ((size_t )(p - text));
  case_10: /* CIL Label */ 
#line 217
  sin6 = (struct sockaddr_in6 *)sa;
#line 219
  n = (size_t )0;
#line 221
  if (port) {
#line 222
    tmp___0 = n;
#line 222
    n ++;
#line 222
    *(text + tmp___0) = (u_char )'[';
  }
  {
#line 225
  n = ngx_inet6_ntop(sin6->sin6_addr.__in6_u.__u6_addr8, text + n, len);
  }
#line 227
  if (port) {
    {
#line 228
    tmp___1 = ntohs(sin6->sin6_port);
#line 228
    tmp___2 = ngx_sprintf(text + (1UL + n), "]:%d", (int )tmp___1);
#line 228
    n = (size_t )(tmp___2 - text);
    }
  }
#line 232
  return (n);
  case_1: /* CIL Label */ 
#line 238
  saun = (struct sockaddr_un *)sa;
#line 242
  if (socklen <= (socklen_t )((unsigned long )(& ((struct sockaddr_un *)0)->sun_path))) {
    {
#line 243
    p = ngx_snprintf(text, len, "unix:%Z");
    }
  } else {
    {
#line 246
    n = ngx_strnlen((u_char *)(saun->sun_path), (unsigned long )socklen - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path));
#line 248
    p = ngx_snprintf(text, len, "unix:%*s%Z", n, saun->sun_path);
    }
  }
#line 253
  return ((size_t )((p - text) - 1L));
  switch_default: /* CIL Label */ 
#line 258
  return ((size_t )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 263 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
size_t ngx_inet_ntop(int family , void *addr , u_char *text , size_t len ) 
{ 
  u_char *p ;
  u_char *tmp ;
  size_t tmp___0 ;
  char *__cil_tmp8 ;

  {
  {
#line 270
  if (family == 2) {
#line 270
    goto case_2;
  }
#line 280
  if (family == 10) {
#line 280
    goto case_10;
  }
#line 285
  goto switch_default;
  case_2: /* CIL Label */ 
  {
#line 272
  p = (u_char *)addr;
#line 274
  tmp = ngx_snprintf(text, len, "%ud.%ud.%ud.%ud", (int )*(p + 0), (int )*(p + 1),
                     (int )*(p + 2), (int )*(p + 3));
  }
#line 274
  return ((size_t )(tmp - text));
  case_10: /* CIL Label */ 
  {
#line 281
  tmp___0 = ngx_inet6_ntop((u_char *)addr, text, len);
  }
#line 281
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 286
  return ((size_t )0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 293 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
size_t ngx_inet6_ntop(u_char *p , u_char *text , size_t len ) 
{ 
  u_char *dst ;
  size_t max ;
  size_t n ;
  ngx_uint_t i ;
  ngx_uint_t zero___0 ;
  ngx_uint_t last ;
  size_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 300
  if (len < sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL) {
#line 301
    return ((size_t )0);
  }
#line 304
  zero___0 = (ngx_uint_t )-1;
#line 305
  last = (ngx_uint_t )-1;
#line 306
  max = (size_t )1;
#line 307
  n = (size_t )0;
#line 309
  i = (ngx_uint_t )0;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < 16UL)) {
#line 309
      goto while_break;
    }
#line 311
    if (*(p + i)) {
#line 311
      goto _L;
    } else
#line 311
    if (*(p + (i + 1UL))) {
      _L: /* CIL Label */ 
#line 313
      if (max < n) {
#line 314
        zero___0 = last;
#line 315
        max = n;
      }
#line 318
      n = (size_t )0;
#line 319
      goto __Cont;
    }
#line 322
    tmp = n;
#line 322
    n ++;
#line 322
    if (tmp == 0UL) {
#line 323
      last = i;
    }
    __Cont: /* CIL Label */ 
#line 309
    i += 2UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  if (max < n) {
#line 328
    zero___0 = last;
#line 329
    max = n;
  }
#line 332
  dst = text;
#line 333
  n = (size_t )16;
#line 335
  if (zero___0 == 0UL) {
#line 337
    if (max == 5UL) {
#line 337
      if ((int )*(p + 10) == 255) {
#line 337
        if ((int )*(p + 11) == 255) {
#line 341
          n = (size_t )12;
        } else {
#line 337
          goto _L___1;
        }
      } else {
#line 337
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 337
    if (max == 6UL) {
#line 341
      n = (size_t )12;
    } else
#line 337
    if (max == 7UL) {
#line 337
      if ((int )*(p + 14) != 0) {
#line 337
        if ((int )*(p + 15) != 1) {
#line 341
          n = (size_t )12;
        }
      }
    }
#line 344
    tmp___0 = dst;
#line 344
    dst ++;
#line 344
    *tmp___0 = (u_char )':';
  }
#line 347
  i = (ngx_uint_t )0;
  {
#line 347
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 347
    if (! (i < n)) {
#line 347
      goto while_break___0;
    }
#line 349
    if (i == zero___0) {
#line 350
      tmp___1 = dst;
#line 350
      dst ++;
#line 350
      *tmp___1 = (u_char )':';
#line 351
      i += (max - 1UL) * 2UL;
#line 352
      goto __Cont___0;
    }
    {
#line 355
    dst = ngx_sprintf(dst, "%xd", (int )*(p + i) * 256 + (int )*(p + (i + 1UL)));
    }
#line 357
    if (i < 14UL) {
#line 358
      tmp___2 = dst;
#line 358
      dst ++;
#line 358
      *tmp___2 = (u_char )':';
    }
    __Cont___0: /* CIL Label */ 
#line 347
    i += 2UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  if (n == 12UL) {
    {
#line 363
    dst = ngx_sprintf(dst, "%ud.%ud.%ud.%ud", (int )*(p + 12), (int )*(p + 13), (int )*(p + 14),
                      (int )*(p + 15));
    }
  }
#line 366
  return ((size_t )(dst - text));
}
}
#line 372 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
ngx_int_t ngx_ptocidr(ngx_str_t *text , ngx_cidr_t *cidr ) 
{ 
  u_char *addr ;
  u_char *mask ;
  u_char *last ;
  size_t len ;
  ngx_int_t shift ;
  ngx_int_t rc ;
  ngx_uint_t s ;
  ngx_uint_t i ;
  u_char *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 383
  addr = text->data;
#line 384
  last = addr + text->len;
#line 386
  mask = ngx_strlchr(addr, last, (u_char )'/');
  }
#line 387
  if (mask) {
#line 387
    tmp = mask;
  } else {
#line 387
    tmp = last;
  }
  {
#line 387
  len = (size_t )(tmp - addr);
#line 389
  cidr->u.in.addr = ngx_inet_addr(addr, len);
  }
#line 391
  if (cidr->u.in.addr != 4294967295U) {
#line 392
    cidr->family = (ngx_uint_t )2;
#line 394
    if ((unsigned long )mask == (unsigned long )((void *)0)) {
#line 395
      cidr->u.in.mask = 4294967295U;
#line 396
      return ((ngx_int_t )0);
    }
  } else {
    {
#line 400
    tmp___0 = ngx_inet6_addr(addr, len, cidr->u.in6.addr.__in6_u.__u6_addr8);
    }
#line 400
    if (tmp___0 == 0L) {
#line 401
      cidr->family = (ngx_uint_t )10;
#line 403
      if ((unsigned long )mask == (unsigned long )((void *)0)) {
        {
#line 404
        memset((void *)(cidr->u.in6.mask.__in6_u.__u6_addr8), 255, (size_t )16);
        }
#line 405
        return ((ngx_int_t )0);
      }
    } else {
#line 410
      return ((ngx_int_t )-1);
    }
  }
  {
#line 413
  mask ++;
#line 415
  shift = ngx_atoi(mask, (size_t )(last - mask));
  }
#line 416
  if (shift == -1L) {
#line 417
    return ((ngx_int_t )-1);
  }
  {
#line 423
  if (cidr->family == 10UL) {
#line 423
    goto case_10;
  }
#line 448
  goto switch_default;
  case_10: /* CIL Label */ 
#line 424
  if (shift > 128L) {
#line 425
    return ((ngx_int_t )-1);
  }
#line 428
  addr = cidr->u.in6.addr.__in6_u.__u6_addr8;
#line 429
  mask = cidr->u.in6.mask.__in6_u.__u6_addr8;
#line 430
  rc = (ngx_int_t )0;
#line 432
  i = (ngx_uint_t )0;
  {
#line 432
  while (1) {
    while_continue: /* CIL Label */ ;
#line 432
    if (! (i < 16UL)) {
#line 432
      goto while_break;
    }
#line 434
    if (shift > 8L) {
#line 434
      s = (ngx_uint_t )8;
    } else {
#line 434
      s = (ngx_uint_t )shift;
    }
#line 435
    shift = (ngx_int_t )((ngx_uint_t )shift - s);
#line 437
    *(mask + i) = (u_char )(255U << (8UL - s));
#line 439
    if ((int )*(addr + i) != ((int )*(addr + i) & (int )*(mask + i))) {
#line 440
      rc = (ngx_int_t )-4;
#line 441
      *(addr + i) = (u_char )((int )*(addr + i) & (int )*(mask + i));
    }
#line 432
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 445
  return (rc);
  switch_default: /* CIL Label */ 
#line 449
  if (shift > 32L) {
#line 450
    return ((ngx_int_t )-1);
  }
#line 453
  if (shift) {
    {
#line 454
    cidr->u.in.mask = htonl(4294967295U << (32L - shift));
    }
  } else {
#line 458
    cidr->u.in.mask = (in_addr_t )0;
  }
#line 461
  if (cidr->u.in.addr == (cidr->u.in.addr & cidr->u.in.mask)) {
#line 462
    return ((ngx_int_t )0);
  }
#line 465
  cidr->u.in.addr &= cidr->u.in.mask;
#line 467
  return ((ngx_int_t )-4);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 472 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
ngx_int_t ngx_cidr_match(struct sockaddr *sa , ngx_array_t *cidrs ) 
{ 
  u_char *p ;
  in_addr_t inaddr ;
  ngx_cidr_t *cidr ;
  ngx_uint_t family ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  struct in6_addr *inaddr6 ;
  struct in6_addr  const  *__a ;
  uint32_t tmp ;
  int tmp___0 ;

  {
#line 487
  inaddr = (in_addr_t )0;
#line 489
  inaddr6 = (struct in6_addr *)((void *)0);
#line 493
  family = (ngx_uint_t )sa->sa_family;
#line 495
  if (family == 2UL) {
#line 496
    inaddr = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
  } else
#line 500
  if (family == 10UL) {
#line 501
    inaddr6 = & ((struct sockaddr_in6 *)sa)->sin6_addr;
#line 503
    __a = (struct in6_addr  const  *)inaddr6;
#line 503
    if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 503
      if (__a->__in6_u.__u6_addr32[1] == 0U) {
        {
#line 503
        tmp = htonl((uint32_t )65535);
        }
#line 503
        if (__a->__in6_u.__u6_addr32[2] == tmp) {
#line 503
          tmp___0 = 1;
        } else {
#line 503
          tmp___0 = 0;
        }
      } else {
#line 503
        tmp___0 = 0;
      }
    } else {
#line 503
      tmp___0 = 0;
    }
#line 503
    if (tmp___0) {
      {
#line 504
      family = (ngx_uint_t )2;
#line 506
      p = inaddr6->__in6_u.__u6_addr8;
#line 508
      inaddr = (in_addr_t )((int )*(p + 12) << 24);
#line 509
      inaddr += (in_addr_t )((int )*(p + 13) << 16);
#line 510
      inaddr += (in_addr_t )((int )*(p + 14) << 8);
#line 511
      inaddr += (in_addr_t )*(p + 15);
#line 513
      inaddr = htonl(inaddr);
      }
    }
  }
#line 518
  cidr = (ngx_cidr_t *)cidrs->elts;
#line 518
  i = (ngx_uint_t )0;
  {
#line 518
  while (1) {
    while_continue: /* CIL Label */ ;
#line 518
    if (! (i < cidrs->nelts)) {
#line 518
      goto while_break;
    }
#line 519
    if ((cidr + i)->family != family) {
#line 520
      goto next;
    }
    {
#line 526
    if (family == 10UL) {
#line 526
      goto case_10;
    }
#line 538
    if (family == 1UL) {
#line 538
      goto case_1;
    }
#line 542
    goto switch_default;
    case_10: /* CIL Label */ 
#line 527
    n = (ngx_uint_t )0;
    {
#line 527
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 527
      if (! (n < 16UL)) {
#line 527
        goto while_break___0;
      }
#line 528
      if (((int )inaddr6->__in6_u.__u6_addr8[n] & (int )(cidr + i)->u.in6.mask.__in6_u.__u6_addr8[n]) != (int )(cidr + i)->u.in6.addr.__in6_u.__u6_addr8[n]) {
#line 531
        goto next;
      }
#line 527
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 534
    goto switch_break;
    case_1: /* CIL Label */ 
#line 539
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 543
    if ((inaddr & (cidr + i)->u.in.mask) != (cidr + i)->u.in.addr) {
#line 544
      goto next;
    }
#line 546
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 549
    return ((ngx_int_t )0);
    next: 
#line 552
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 518
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return ((ngx_int_t )-5);
}
}
#line 559 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
ngx_int_t ngx_parse_addr(ngx_pool_t *pool , ngx_addr_t *addr , u_char *text , size_t len ) 
{ 
  in_addr_t inaddr ;
  ngx_uint_t family ;
  struct sockaddr_in *sin ;
  struct in6_addr inaddr6 ;
  struct sockaddr_in6 *sin6 ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *__cil_tmp12 ;
  void *__cil_tmp13 ;
  void *__cil_tmp14 ;

  {
  {
#line 573
  memset((void *)(& inaddr6), 0, sizeof(struct in6_addr ));
#line 576
  inaddr = ngx_inet_addr(text, len);
  }
#line 578
  if (inaddr != 4294967295U) {
#line 579
    family = (ngx_uint_t )2;
#line 580
    len = sizeof(struct sockaddr_in );
  } else {
    {
#line 583
    tmp = ngx_inet6_addr(text, len, inaddr6.__in6_u.__u6_addr8);
    }
#line 583
    if (tmp == 0L) {
#line 584
      family = (ngx_uint_t )10;
#line 585
      len = sizeof(struct sockaddr_in6 );
    } else {
#line 589
      return ((ngx_int_t )-5);
    }
  }
  {
#line 592
  tmp___0 = ngx_pcalloc(pool, len);
#line 592
  addr->sockaddr = (struct sockaddr *)tmp___0;
  }
#line 593
  if ((unsigned long )addr->sockaddr == (unsigned long )((void *)0)) {
#line 594
    return ((ngx_int_t )-1);
  }
#line 597
  (addr->sockaddr)->sa_family = (sa_family_t )((u_char )family);
#line 598
  addr->socklen = (socklen_t )len;
  {
#line 603
  if (family == 10UL) {
#line 603
    goto case_10;
  }
#line 609
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 604
  sin6 = (struct sockaddr_in6 *)addr->sockaddr;
#line 605
  memcpy((void */* __restrict  */)(sin6->sin6_addr.__in6_u.__u6_addr8), (void const   */* __restrict  */)(inaddr6.__in6_u.__u6_addr8),
         (size_t )16);
  }
#line 606
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 610
  sin = (struct sockaddr_in *)addr->sockaddr;
#line 611
  sin->sin_addr.s_addr = inaddr;
#line 612
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 615
  return ((ngx_int_t )0);
}
}
#line 619 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
ngx_int_t ngx_parse_addr_port(ngx_pool_t *pool , ngx_addr_t *addr , u_char *text ,
                              size_t len ) 
{ 
  u_char *p ;
  u_char *last ;
  size_t plen ;
  ngx_int_t rc ;
  ngx_int_t port ;

  {
  {
#line 627
  rc = ngx_parse_addr(pool, addr, text, len);
  }
#line 629
  if (rc != -5L) {
#line 630
    return (rc);
  }
#line 633
  last = text + len;
#line 636
  if (len) {
#line 636
    if ((int )*(text + 0) == 91) {
      {
#line 638
      p = ngx_strlchr(text, last, (u_char )']');
      }
#line 640
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 641
        return ((ngx_int_t )-5);
      } else
#line 640
      if ((unsigned long )p == (unsigned long )(last - 1)) {
#line 641
        return ((ngx_int_t )-5);
      } else {
#line 640
        p ++;
#line 640
        if ((int )*p != 58) {
#line 641
          return ((ngx_int_t )-5);
        }
      }
#line 644
      text ++;
#line 645
      len -= 2UL;
    } else {
#line 636
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 651
    p = ngx_strlchr(text, last, (u_char )':');
    }
#line 653
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 654
      return ((ngx_int_t )-5);
    }
  }
  {
#line 658
  p ++;
#line 659
  plen = (size_t )(last - p);
#line 661
  port = ngx_atoi(p, plen);
  }
#line 663
  if (port < 1L) {
#line 664
    return ((ngx_int_t )-5);
  } else
#line 663
  if (port > 65535L) {
#line 664
    return ((ngx_int_t )-5);
  }
  {
#line 667
  len -= plen + 1UL;
#line 669
  rc = ngx_parse_addr(pool, addr, text, len);
  }
#line 671
  if (rc != 0L) {
#line 672
    return (rc);
  }
  {
#line 675
  ngx_inet_set_port(addr->sockaddr, (in_port_t )port);
  }
#line 677
  return ((ngx_int_t )0);
}
}
#line 681 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
ngx_int_t ngx_parse_url(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *p ;
  size_t len ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp9 ;

  {
#line 687
  p = u->url.data;
#line 688
  len = u->url.len;
#line 690
  if (len >= 5UL) {
    {
#line 690
    tmp___0 = ngx_strncasecmp(p, (u_char *)"unix:", (size_t )5);
    }
#line 690
    if (tmp___0 == 0L) {
      {
#line 691
      tmp = ngx_parse_unix_domain_url(pool, u);
      }
#line 691
      return (tmp);
    }
  }
#line 694
  if (len) {
#line 694
    if ((int )*(p + 0) == 91) {
      {
#line 695
      tmp___1 = ngx_parse_inet6_url(pool, u);
      }
#line 695
      return (tmp___1);
    }
  }
  {
#line 698
  tmp___2 = ngx_parse_inet_url(pool, u);
  }
#line 698
  return (tmp___2);
}
}
#line 702 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
static ngx_int_t ngx_parse_unix_domain_url(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *path ;
  u_char *uri___0 ;
  u_char *last ;
  size_t len ;
  struct sockaddr_un *saun ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 710
  len = u->url.len;
#line 711
  path = u->url.data;
#line 713
  path += 5;
#line 714
  len -= 5UL;
#line 716
  if (u->uri_part) {
    {
#line 718
    last = path + len;
#line 719
    uri___0 = ngx_strlchr(path, last, (u_char )':');
    }
#line 721
    if (uri___0) {
#line 722
      len = (size_t )(uri___0 - path);
#line 723
      uri___0 ++;
#line 724
      u->uri.len = (size_t )(last - uri___0);
#line 725
      u->uri.data = uri___0;
    }
  }
#line 729
  if (len == 0UL) {
#line 730
    u->err = (char *)"no path in the unix domain socket";
#line 731
    return ((ngx_int_t )-1);
  }
#line 734
  tmp = len;
#line 734
  len ++;
#line 734
  u->host.len = tmp;
#line 735
  u->host.data = path;
#line 737
  if (len > sizeof(saun->sun_path)) {
#line 738
    u->err = (char *)"too long path in the unix domain socket";
#line 739
    return ((ngx_int_t )-1);
  }
  {
#line 742
  u->socklen = (socklen_t )sizeof(struct sockaddr_un );
#line 743
  saun = (struct sockaddr_un *)(& u->sockaddr);
#line 744
  saun->sun_family = (sa_family_t )1;
#line 745
  ngx_cpystrn((u_char *)(saun->sun_path), path, len);
#line 747
  tmp___0 = ngx_pcalloc(pool, sizeof(ngx_addr_t ));
#line 747
  u->addrs = (ngx_addr_t *)tmp___0;
  }
#line 748
  if ((unsigned long )u->addrs == (unsigned long )((void *)0)) {
#line 749
    return ((ngx_int_t )-1);
  }
  {
#line 752
  tmp___1 = ngx_pcalloc(pool, sizeof(struct sockaddr_un ));
#line 752
  saun = (struct sockaddr_un *)tmp___1;
  }
#line 753
  if ((unsigned long )saun == (unsigned long )((void *)0)) {
#line 754
    return ((ngx_int_t )-1);
  }
  {
#line 757
  u->family = 1;
#line 758
  u->naddrs = (ngx_uint_t )1;
#line 760
  saun->sun_family = (sa_family_t )1;
#line 761
  ngx_cpystrn((u_char *)(saun->sun_path), path, len);
#line 763
  (u->addrs + 0)->sockaddr = (struct sockaddr *)saun;
#line 764
  (u->addrs + 0)->socklen = (socklen_t )sizeof(struct sockaddr_un );
#line 765
  (u->addrs + 0)->name.len = len + 4UL;
#line 766
  (u->addrs + 0)->name.data = u->url.data;
  }
#line 768
  return ((ngx_int_t )0);
}
}
#line 780 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
static ngx_int_t ngx_parse_inet_url(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *p ;
  u_char *host ;
  u_char *port ;
  u_char *last ;
  u_char *uri___0 ;
  u_char *args___0 ;
  size_t len ;
  ngx_int_t n ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  u_char *tmp___2 ;
  ngx_int_t tmp___3 ;
  struct in6_addr  const  *__a ;
  int tmp___4 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;

  {
  {
#line 791
  u->socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 792
  sin = (struct sockaddr_in *)(& u->sockaddr);
#line 793
  sin->sin_family = (sa_family_t )2;
#line 795
  u->family = 2;
#line 797
  host = u->url.data;
#line 799
  last = host + u->url.len;
#line 801
  port = ngx_strlchr(host, last, (u_char )':');
#line 803
  uri___0 = ngx_strlchr(host, last, (u_char )'/');
#line 805
  args___0 = ngx_strlchr(host, last, (u_char )'?');
  }
#line 807
  if (args___0) {
#line 808
    if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 809
      uri___0 = args___0;
    } else
#line 808
    if ((unsigned long )args___0 < (unsigned long )uri___0) {
#line 809
      uri___0 = args___0;
    }
  }
#line 813
  if (uri___0) {
#line 814
    if (u->listen) {
#line 815
      u->err = (char *)"invalid host";
#line 816
      return ((ngx_int_t )-1);
    } else
#line 814
    if (! u->uri_part) {
#line 815
      u->err = (char *)"invalid host";
#line 816
      return ((ngx_int_t )-1);
    }
#line 819
    u->uri.len = (size_t )(last - uri___0);
#line 820
    u->uri.data = uri___0;
#line 822
    last = uri___0;
#line 824
    if ((unsigned long )uri___0 < (unsigned long )port) {
#line 825
      port = (u_char *)((void *)0);
    }
  }
#line 829
  if (port) {
    {
#line 830
    port ++;
#line 832
    len = (size_t )(last - port);
#line 834
    n = ngx_atoi(port, len);
    }
#line 836
    if (n < 1L) {
#line 837
      u->err = (char *)"invalid port";
#line 838
      return ((ngx_int_t )-1);
    } else
#line 836
    if (n > 65535L) {
#line 837
      u->err = (char *)"invalid port";
#line 838
      return ((ngx_int_t )-1);
    }
    {
#line 841
    u->port = (in_port_t )n;
#line 842
    sin->sin_port = htons((in_port_t )n);
#line 844
    u->port_text.len = len;
#line 845
    u->port_text.data = port;
#line 847
    last = port - 1;
    }
  } else {
#line 850
    if ((unsigned long )uri___0 == (unsigned long )((void *)0)) {
#line 852
      if (u->listen) {
        {
#line 856
        n = ngx_atoi(host, (size_t )(last - host));
        }
#line 858
        if (n != -1L) {
#line 860
          if (n < 1L) {
#line 861
            u->err = (char *)"invalid port";
#line 862
            return ((ngx_int_t )-1);
          } else
#line 860
          if (n > 65535L) {
#line 861
            u->err = (char *)"invalid port";
#line 862
            return ((ngx_int_t )-1);
          }
          {
#line 865
          u->port = (in_port_t )n;
#line 866
          sin->sin_port = htons((in_port_t )n);
#line 868
          u->port_text.len = (size_t )(last - host);
#line 869
          u->port_text.data = host;
#line 871
          u->wildcard = 1U;
          }
#line 873
          return ((ngx_int_t )0);
        }
      }
    }
    {
#line 878
    u->no_port = 1U;
#line 879
    u->port = u->default_port;
#line 880
    sin->sin_port = htons(u->default_port);
    }
  }
#line 883
  len = (size_t )(last - host);
#line 885
  if (len == 0UL) {
#line 886
    u->err = (char *)"no host";
#line 887
    return ((ngx_int_t )-1);
  }
#line 890
  u->host.len = len;
#line 891
  u->host.data = host;
#line 893
  if (u->listen) {
#line 893
    if (len == 1UL) {
#line 893
      if ((int )*host == 42) {
#line 894
        sin->sin_addr.s_addr = (in_addr_t )0;
#line 895
        u->wildcard = 1U;
#line 896
        return ((ngx_int_t )0);
      }
    }
  }
  {
#line 899
  sin->sin_addr.s_addr = ngx_inet_addr(host, len);
  }
#line 901
  if (sin->sin_addr.s_addr != 4294967295U) {
#line 903
    if (sin->sin_addr.s_addr == 0U) {
#line 904
      u->wildcard = 1U;
    }
    {
#line 907
    u->naddrs = (ngx_uint_t )1;
#line 909
    tmp = ngx_pcalloc(pool, sizeof(ngx_addr_t ));
#line 909
    u->addrs = (ngx_addr_t *)tmp;
    }
#line 910
    if ((unsigned long )u->addrs == (unsigned long )((void *)0)) {
#line 911
      return ((ngx_int_t )-1);
    }
    {
#line 914
    tmp___0 = ngx_pcalloc(pool, sizeof(struct sockaddr_in ));
#line 914
    sin = (struct sockaddr_in *)tmp___0;
    }
#line 915
    if ((unsigned long )sin == (unsigned long )((void *)0)) {
#line 916
      return ((ngx_int_t )-1);
    }
    {
#line 919
    memcpy((void */* __restrict  */)sin, (void const   */* __restrict  */)(& u->sockaddr),
           sizeof(struct sockaddr_in ));
#line 921
    (u->addrs + 0)->sockaddr = (struct sockaddr *)sin;
#line 922
    (u->addrs + 0)->socklen = (socklen_t )sizeof(struct sockaddr_in );
#line 924
    tmp___1 = ngx_pnalloc(pool, (u->host.len + sizeof(":65535")) - 1UL);
#line 924
    p = (u_char *)tmp___1;
    }
#line 925
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 926
      return ((ngx_int_t )-1);
    }
    {
#line 929
    tmp___2 = ngx_sprintf(p, "%V:%d", & u->host, (int )u->port);
#line 929
    (u->addrs + 0)->name.len = (size_t )(tmp___2 - p);
#line 931
    (u->addrs + 0)->name.data = p;
    }
#line 933
    return ((ngx_int_t )0);
  }
#line 936
  if (u->no_resolve) {
#line 937
    return ((ngx_int_t )0);
  }
  {
#line 940
  tmp___3 = ngx_inet_resolve_host(pool, u);
  }
#line 940
  if (tmp___3 != 0L) {
#line 941
    return ((ngx_int_t )-1);
  }
  {
#line 944
  u->family = (int )((u->addrs + 0)->sockaddr)->sa_family;
#line 945
  u->socklen = (u->addrs + 0)->socklen;
#line 946
  memcpy((void */* __restrict  */)(& u->sockaddr), (void const   */* __restrict  */)(u->addrs + 0)->sockaddr,
         (size_t )(u->addrs + 0)->socklen);
  }
  {
#line 951
  if (u->family == 10) {
#line 951
    goto case_10;
  }
#line 961
  goto switch_default;
  case_10: /* CIL Label */ 
#line 952
  sin6 = (struct sockaddr_in6 *)(& u->sockaddr);
#line 954
  __a = (struct in6_addr  const  *)(& sin6->sin6_addr);
#line 954
  if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 954
    if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 954
      if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 954
        if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 954
          tmp___4 = 1;
        } else {
#line 954
          tmp___4 = 0;
        }
      } else {
#line 954
        tmp___4 = 0;
      }
    } else {
#line 954
      tmp___4 = 0;
    }
  } else {
#line 954
    tmp___4 = 0;
  }
#line 954
  if (tmp___4) {
#line 955
    u->wildcard = 1U;
  }
#line 958
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 962
  sin = (struct sockaddr_in *)(& u->sockaddr);
#line 964
  if (sin->sin_addr.s_addr == 0U) {
#line 965
    u->wildcard = 1U;
  }
#line 968
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 971
  return ((ngx_int_t )0);
}
}
#line 975 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
static ngx_int_t ngx_parse_inet6_url(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *p ;
  u_char *host ;
  u_char *port ;
  u_char *last ;
  u_char *uri___0 ;
  size_t len ;
  ngx_int_t n ;
  struct sockaddr_in6 *sin6 ;
  ngx_int_t tmp ;
  struct in6_addr  const  *__a ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  u_char *tmp___4 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
  {
#line 984
  u->socklen = (socklen_t )sizeof(struct sockaddr_in6 );
#line 985
  sin6 = (struct sockaddr_in6 *)(& u->sockaddr);
#line 986
  sin6->sin6_family = (sa_family_t )10;
#line 988
  host = u->url.data + 1;
#line 990
  last = u->url.data + u->url.len;
#line 992
  p = ngx_strlchr(host, last, (u_char )']');
  }
#line 994
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 995
    u->err = (char *)"invalid host";
#line 996
    return ((ngx_int_t )-1);
  }
  {
#line 999
  port = p + 1;
#line 1001
  uri___0 = ngx_strlchr(port, last, (u_char )'/');
  }
#line 1003
  if (uri___0) {
#line 1004
    if (u->listen) {
#line 1005
      u->err = (char *)"invalid host";
#line 1006
      return ((ngx_int_t )-1);
    } else
#line 1004
    if (! u->uri_part) {
#line 1005
      u->err = (char *)"invalid host";
#line 1006
      return ((ngx_int_t )-1);
    }
#line 1009
    u->uri.len = (size_t )(last - uri___0);
#line 1010
    u->uri.data = uri___0;
#line 1012
    last = uri___0;
  }
#line 1015
  if ((unsigned long )port < (unsigned long )last) {
#line 1016
    if ((int )*port != 58) {
#line 1017
      u->err = (char *)"invalid host";
#line 1018
      return ((ngx_int_t )-1);
    }
    {
#line 1021
    port ++;
#line 1023
    len = (size_t )(last - port);
#line 1025
    n = ngx_atoi(port, len);
    }
#line 1027
    if (n < 1L) {
#line 1028
      u->err = (char *)"invalid port";
#line 1029
      return ((ngx_int_t )-1);
    } else
#line 1027
    if (n > 65535L) {
#line 1028
      u->err = (char *)"invalid port";
#line 1029
      return ((ngx_int_t )-1);
    }
    {
#line 1032
    u->port = (in_port_t )n;
#line 1033
    sin6->sin6_port = htons((in_port_t )n);
#line 1035
    u->port_text.len = len;
#line 1036
    u->port_text.data = port;
    }
  } else {
    {
#line 1039
    u->no_port = 1U;
#line 1040
    u->port = u->default_port;
#line 1041
    sin6->sin6_port = htons(u->default_port);
    }
  }
#line 1044
  len = (size_t )(p - host);
#line 1046
  if (len == 0UL) {
#line 1047
    u->err = (char *)"no host";
#line 1048
    return ((ngx_int_t )-1);
  }
  {
#line 1051
  u->host.len = len + 2UL;
#line 1052
  u->host.data = host - 1;
#line 1054
  tmp = ngx_inet6_addr(host, len, sin6->sin6_addr.__in6_u.__u6_addr8);
  }
#line 1054
  if (tmp != 0L) {
#line 1055
    u->err = (char *)"invalid IPv6 address";
#line 1056
    return ((ngx_int_t )-1);
  }
#line 1059
  __a = (struct in6_addr  const  *)(& sin6->sin6_addr);
#line 1059
  if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 1059
    if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 1059
      if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 1059
        if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 1059
          tmp___0 = 1;
        } else {
#line 1059
          tmp___0 = 0;
        }
      } else {
#line 1059
        tmp___0 = 0;
      }
    } else {
#line 1059
      tmp___0 = 0;
    }
  } else {
#line 1059
    tmp___0 = 0;
  }
#line 1059
  if (tmp___0) {
#line 1060
    u->wildcard = 1U;
  }
  {
#line 1063
  u->family = 10;
#line 1064
  u->naddrs = (ngx_uint_t )1;
#line 1066
  tmp___1 = ngx_pcalloc(pool, sizeof(ngx_addr_t ));
#line 1066
  u->addrs = (ngx_addr_t *)tmp___1;
  }
#line 1067
  if ((unsigned long )u->addrs == (unsigned long )((void *)0)) {
#line 1068
    return ((ngx_int_t )-1);
  }
  {
#line 1071
  tmp___2 = ngx_pcalloc(pool, sizeof(struct sockaddr_in6 ));
#line 1071
  sin6 = (struct sockaddr_in6 *)tmp___2;
  }
#line 1072
  if ((unsigned long )sin6 == (unsigned long )((void *)0)) {
#line 1073
    return ((ngx_int_t )-1);
  }
  {
#line 1076
  memcpy((void */* __restrict  */)sin6, (void const   */* __restrict  */)(& u->sockaddr),
         sizeof(struct sockaddr_in6 ));
#line 1078
  (u->addrs + 0)->sockaddr = (struct sockaddr *)sin6;
#line 1079
  (u->addrs + 0)->socklen = (socklen_t )sizeof(struct sockaddr_in6 );
#line 1081
  tmp___3 = ngx_pnalloc(pool, (u->host.len + sizeof(":65535")) - 1UL);
#line 1081
  p = (u_char *)tmp___3;
  }
#line 1082
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1083
    return ((ngx_int_t )-1);
  }
  {
#line 1086
  tmp___4 = ngx_sprintf(p, "%V:%d", & u->host, (int )u->port);
#line 1086
  (u->addrs + 0)->name.len = (size_t )(tmp___4 - p);
#line 1088
  (u->addrs + 0)->name.data = p;
  }
#line 1090
  return ((ngx_int_t )0);
}
}
#line 1104 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
ngx_int_t ngx_inet_resolve_host(ngx_pool_t *pool , ngx_url_t *u ) 
{ 
  u_char *p ;
  u_char *host ;
  size_t len ;
  in_port_t port ;
  ngx_uint_t i ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *rp ;
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  void *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
#line 1115
  port = htons(u->port);
#line 1117
  tmp = ngx_alloc(u->host.len + 1UL, pool->log);
#line 1117
  host = (u_char *)tmp;
  }
#line 1118
  if ((unsigned long )host == (unsigned long )((void *)0)) {
#line 1119
    return ((ngx_int_t )-1);
  }
  {
#line 1122
  ngx_cpystrn(host, u->host.data, u->host.len + 1UL);
#line 1124
  memset((void *)(& hints), 0, sizeof(struct addrinfo ));
#line 1125
  hints.ai_family = 0;
#line 1126
  hints.ai_socktype = 1;
#line 1128
  hints.ai_flags = 32;
#line 1131
  tmp___0 = getaddrinfo((char const   */* __restrict  */)((char *)host), (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 1131
  if (tmp___0 != 0) {
    {
#line 1132
    u->err = (char *)"host not found";
#line 1133
    free((void *)host);
    }
#line 1134
    return ((ngx_int_t )-1);
  }
  {
#line 1137
  free((void *)host);
#line 1139
  i = (ngx_uint_t )0;
#line 1139
  rp = res;
  }
  {
#line 1139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1139
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1139
      goto while_break;
    }
    {
#line 1144
    if (rp->ai_family == 10) {
#line 1144
      goto case_10;
    }
#line 1144
    if (rp->ai_family == 2) {
#line 1144
      goto case_10;
    }
#line 1147
    goto switch_default;
    case_10: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 1145
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 1148
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
#line 1151
    i ++;
    __Cont: /* CIL Label */ 
#line 1139
    rp = rp->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1154
  if (i == 0UL) {
#line 1155
    u->err = (char *)"host not found";
#line 1156
    goto failed;
  }
  {
#line 1161
  tmp___1 = ngx_pcalloc(pool, i * sizeof(ngx_addr_t ));
#line 1161
  u->addrs = (ngx_addr_t *)tmp___1;
  }
#line 1162
  if ((unsigned long )u->addrs == (unsigned long )((void *)0)) {
#line 1163
    goto failed;
  }
#line 1166
  u->naddrs = i;
#line 1168
  i = (ngx_uint_t )0;
#line 1172
  rp = res;
  {
#line 1172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1172
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1172
      goto while_break___0;
    }
#line 1174
    if (rp->ai_family != 2) {
#line 1175
      goto __Cont___0;
    }
    {
#line 1178
    tmp___2 = ngx_pcalloc(pool, (size_t )rp->ai_addrlen);
#line 1178
    sin = (struct sockaddr_in *)tmp___2;
    }
#line 1179
    if ((unsigned long )sin == (unsigned long )((void *)0)) {
#line 1180
      goto failed;
    }
    {
#line 1183
    memcpy((void */* __restrict  */)sin, (void const   */* __restrict  */)rp->ai_addr,
           (size_t )rp->ai_addrlen);
#line 1185
    sin->sin_port = port;
#line 1187
    (u->addrs + i)->sockaddr = (struct sockaddr *)sin;
#line 1188
    (u->addrs + i)->socklen = rp->ai_addrlen;
#line 1190
    len = ((sizeof("255.255.255.255") - 1UL) + sizeof(":65535")) - 1UL;
#line 1192
    tmp___3 = ngx_pnalloc(pool, len);
#line 1192
    p = (u_char *)tmp___3;
    }
#line 1193
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1194
      goto failed;
    }
    {
#line 1197
    len = ngx_sock_ntop((struct sockaddr *)sin, rp->ai_addrlen, p, len, (ngx_uint_t )1);
#line 1199
    (u->addrs + i)->name.len = len;
#line 1200
    (u->addrs + i)->name.data = p;
#line 1202
    i ++;
    }
    __Cont___0: /* CIL Label */ 
#line 1172
    rp = rp->ai_next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1205
  rp = res;
  {
#line 1205
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1205
    if (! ((unsigned long )rp != (unsigned long )((void *)0))) {
#line 1205
      goto while_break___1;
    }
#line 1207
    if (rp->ai_family != 10) {
#line 1208
      goto __Cont___1;
    }
    {
#line 1211
    tmp___4 = ngx_pcalloc(pool, (size_t )rp->ai_addrlen);
#line 1211
    sin6 = (struct sockaddr_in6 *)tmp___4;
    }
#line 1212
    if ((unsigned long )sin6 == (unsigned long )((void *)0)) {
#line 1213
      goto failed;
    }
    {
#line 1216
    memcpy((void */* __restrict  */)sin6, (void const   */* __restrict  */)rp->ai_addr,
           (size_t )rp->ai_addrlen);
#line 1218
    sin6->sin6_port = port;
#line 1220
    (u->addrs + i)->sockaddr = (struct sockaddr *)sin6;
#line 1221
    (u->addrs + i)->socklen = rp->ai_addrlen;
#line 1223
    len = ((sizeof("ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255") - 1UL) + sizeof("[]:65535")) - 1UL;
#line 1225
    tmp___5 = ngx_pnalloc(pool, len);
#line 1225
    p = (u_char *)tmp___5;
    }
#line 1226
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1227
      goto failed;
    }
    {
#line 1230
    len = ngx_sock_ntop((struct sockaddr *)sin6, rp->ai_addrlen, p, len, (ngx_uint_t )1);
#line 1233
    (u->addrs + i)->name.len = len;
#line 1234
    (u->addrs + i)->name.data = p;
#line 1236
    i ++;
    }
    __Cont___1: /* CIL Label */ 
#line 1205
    rp = rp->ai_next;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 1239
  freeaddrinfo(res);
  }
#line 1240
  return ((ngx_int_t )0);
  failed: 
  {
#line 1244
  freeaddrinfo(res);
  }
#line 1245
  return ((ngx_int_t )-1);
}
}
#line 1362 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
ngx_int_t ngx_cmp_sockaddr(struct sockaddr *sa1 , socklen_t slen1 , struct sockaddr *sa2 ,
                           socklen_t slen2 , ngx_uint_t cmp_port ) 
{ 
  struct sockaddr_in *sin1 ;
  struct sockaddr_in *sin2 ;
  struct sockaddr_in6 *sin61 ;
  struct sockaddr_in6 *sin62 ;
  size_t len ;
  struct sockaddr_un *saun1 ;
  struct sockaddr_un *saun2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 1375
  if ((int )sa1->sa_family != (int )sa2->sa_family) {
#line 1376
    return ((ngx_int_t )-5);
  }
  {
#line 1382
  if ((int )sa1->sa_family == 10) {
#line 1382
    goto case_10;
  }
#line 1399
  if ((int )sa1->sa_family == 1) {
#line 1399
    goto case_1;
  }
#line 1422
  goto switch_default;
  case_10: /* CIL Label */ 
#line 1384
  sin61 = (struct sockaddr_in6 *)sa1;
#line 1385
  sin62 = (struct sockaddr_in6 *)sa2;
#line 1387
  if (cmp_port) {
#line 1387
    if ((int )sin61->sin6_port != (int )sin62->sin6_port) {
#line 1388
      return ((ngx_int_t )-5);
    }
  }
  {
#line 1391
  tmp = memcmp((void const   *)((char const   *)(& sin61->sin6_addr)), (void const   *)((char const   *)(& sin62->sin6_addr)),
               (size_t )16);
  }
#line 1391
  if (tmp != 0) {
#line 1392
    return ((ngx_int_t )-5);
  }
#line 1395
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1401
  saun1 = (struct sockaddr_un *)sa1;
#line 1402
  saun2 = (struct sockaddr_un *)sa2;
#line 1404
  if (slen1 < slen2) {
#line 1405
    len = (unsigned long )slen1 - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
  } else {
#line 1408
    len = (unsigned long )slen2 - (unsigned long )(& ((struct sockaddr_un *)0)->sun_path);
  }
#line 1411
  if (len > sizeof(saun1->sun_path)) {
#line 1412
    len = sizeof(saun1->sun_path);
  }
  {
#line 1415
  tmp___0 = memcmp((void const   *)((char const   *)(& saun1->sun_path)), (void const   *)((char const   *)(& saun2->sun_path)),
                   len);
  }
#line 1415
  if (tmp___0 != 0) {
#line 1416
    return ((ngx_int_t )-5);
  }
#line 1419
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 1424
  sin1 = (struct sockaddr_in *)sa1;
#line 1425
  sin2 = (struct sockaddr_in *)sa2;
#line 1427
  if (cmp_port) {
#line 1427
    if ((int )sin1->sin_port != (int )sin2->sin_port) {
#line 1428
      return ((ngx_int_t )-5);
    }
  }
#line 1431
  if (sin1->sin_addr.s_addr != sin2->sin_addr.s_addr) {
#line 1432
    return ((ngx_int_t )-5);
  }
#line 1435
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1438
  return ((ngx_int_t )0);
}
}
#line 1442 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
in_port_t ngx_inet_get_port(struct sockaddr *sa ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;
  uint16_t tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 1453
  if ((int )sa->sa_family == 10) {
#line 1453
    goto case_10;
  }
#line 1459
  if ((int )sa->sa_family == 1) {
#line 1459
    goto case_1;
  }
#line 1463
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1454
  sin6 = (struct sockaddr_in6 *)sa;
#line 1455
  tmp = ntohs(sin6->sin6_port);
  }
#line 1455
  return (tmp);
  case_1: /* CIL Label */ 
#line 1460
  return ((in_port_t )0);
  switch_default: /* CIL Label */ 
  {
#line 1464
  sin = (struct sockaddr_in *)sa;
#line 1465
  tmp___0 = ntohs(sin->sin_port);
  }
#line 1465
  return (tmp___0);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 1470 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_inet.c"
void ngx_inet_set_port(struct sockaddr *sa , in_port_t port ) 
{ 
  struct sockaddr_in *sin ;
  struct sockaddr_in6 *sin6 ;

  {
  {
#line 1481
  if ((int )sa->sa_family == 10) {
#line 1481
    goto case_10;
  }
#line 1488
  if ((int )sa->sa_family == 1) {
#line 1488
    goto case_1;
  }
#line 1492
  goto switch_default;
  case_10: /* CIL Label */ 
  {
#line 1482
  sin6 = (struct sockaddr_in6 *)sa;
#line 1483
  sin6->sin6_port = htons(port);
  }
#line 1484
  goto switch_break;
  case_1: /* CIL Label */ 
#line 1489
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1493
  sin = (struct sockaddr_in *)sa;
#line 1494
  sin->sin_port = htons(port);
  }
#line 1495
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 1497
  return;
}
}
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_parse_time.c"
static ngx_uint_t mday[12]  = 
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_parse_time.c"
  {      (ngx_uint_t )31,      (ngx_uint_t )28,      (ngx_uint_t )31,      (ngx_uint_t )30, 
        (ngx_uint_t )31,      (ngx_uint_t )30,      (ngx_uint_t )31,      (ngx_uint_t )31, 
        (ngx_uint_t )30,      (ngx_uint_t )31,      (ngx_uint_t )30,      (ngx_uint_t )31};
#line 14 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_parse_time.c"
time_t ngx_parse_http_time(u_char *value , size_t len ) 
{ 
  u_char *p ;
  u_char *end ;
  ngx_int_t month ;
  ngx_uint_t day ;
  ngx_uint_t year ;
  ngx_uint_t hour ;
  ngx_uint_t min ;
  ngx_uint_t sec ;
  uint64_t time___0 ;
  enum __anonenum_fmt_171 fmt ;
  int tmp ;
  int tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;

  {
#line 28
  fmt = (enum __anonenum_fmt_171 )0;
#line 29
  end = value + len;
#line 32
  day = (ngx_uint_t )32;
#line 33
  year = (ngx_uint_t )2038;
#line 36
  p = value;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
#line 36
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 36
      goto while_break;
    }
#line 37
    if ((int )*p == 44) {
#line 38
      goto while_break;
    }
#line 41
    if ((int )*p == 32) {
#line 42
      fmt = (enum __anonenum_fmt_171 )3;
#line 43
      goto while_break;
    }
#line 36
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 47
  p ++;
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 47
    if (! ((unsigned long )p < (unsigned long )end)) {
#line 47
      goto while_break___0;
    }
#line 48
    if ((int )*p != 32) {
#line 49
      goto while_break___0;
    }
#line 47
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 53
  if (end - p < 18L) {
#line 54
    return ((time_t )-1);
  }
#line 57
  if ((unsigned int )fmt != 3U) {
#line 58
    if ((int )*p < 48) {
#line 59
      return ((time_t )-1);
    } else
#line 58
    if ((int )*p > 57) {
#line 59
      return ((time_t )-1);
    } else
#line 58
    if ((int )*(p + 1) < 48) {
#line 59
      return ((time_t )-1);
    } else
#line 58
    if ((int )*(p + 1) > 57) {
#line 59
      return ((time_t )-1);
    }
#line 62
    day = (ngx_uint_t )(((int )*p - 48) * 10 + ((int )*(p + 1) - 48));
#line 63
    p += 2;
#line 65
    if ((int )*p == 32) {
#line 66
      if (end - p < 18L) {
#line 67
        return ((time_t )-1);
      }
#line 69
      fmt = (enum __anonenum_fmt_171 )1;
    } else
#line 71
    if ((int )*p == 45) {
#line 72
      fmt = (enum __anonenum_fmt_171 )2;
    } else {
#line 75
      return ((time_t )-1);
    }
#line 78
    p ++;
  }
  {
#line 83
  if ((int )*p == 74) {
#line 83
    goto case_74;
  }
#line 87
  if ((int )*p == 70) {
#line 87
    goto case_70;
  }
#line 91
  if ((int )*p == 77) {
#line 91
    goto case_77;
  }
#line 95
  if ((int )*p == 65) {
#line 95
    goto case_65;
  }
#line 99
  if ((int )*p == 83) {
#line 99
    goto case_83;
  }
#line 103
  if ((int )*p == 79) {
#line 103
    goto case_79;
  }
#line 107
  if ((int )*p == 78) {
#line 107
    goto case_78;
  }
#line 111
  if ((int )*p == 68) {
#line 111
    goto case_68;
  }
#line 115
  goto switch_default;
  case_74: /* CIL Label */ 
#line 84
  if ((int )*(p + 1) == 97) {
#line 84
    month = (ngx_int_t )0;
  } else {
#line 84
    if ((int )*(p + 2) == 110) {
#line 84
      tmp = 5;
    } else {
#line 84
      tmp = 6;
    }
#line 84
    month = (ngx_int_t )tmp;
  }
#line 85
  goto switch_break;
  case_70: /* CIL Label */ 
#line 88
  month = (ngx_int_t )1;
#line 89
  goto switch_break;
  case_77: /* CIL Label */ 
#line 92
  if ((int )*(p + 2) == 114) {
#line 92
    month = (ngx_int_t )2;
  } else {
#line 92
    month = (ngx_int_t )4;
  }
#line 93
  goto switch_break;
  case_65: /* CIL Label */ 
#line 96
  if ((int )*(p + 1) == 112) {
#line 96
    month = (ngx_int_t )3;
  } else {
#line 96
    month = (ngx_int_t )7;
  }
#line 97
  goto switch_break;
  case_83: /* CIL Label */ 
#line 100
  month = (ngx_int_t )8;
#line 101
  goto switch_break;
  case_79: /* CIL Label */ 
#line 104
  month = (ngx_int_t )9;
#line 105
  goto switch_break;
  case_78: /* CIL Label */ 
#line 108
  month = (ngx_int_t )10;
#line 109
  goto switch_break;
  case_68: /* CIL Label */ 
#line 112
  month = (ngx_int_t )11;
#line 113
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 116
  return ((time_t )-1);
  switch_break: /* CIL Label */ ;
  }
#line 119
  p += 3;
#line 121
  if ((unsigned int )fmt == 1U) {
#line 121
    if ((int )*p != 32) {
#line 122
      return ((time_t )-1);
    } else {
#line 121
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 121
  if ((unsigned int )fmt == 2U) {
#line 121
    if ((int )*p != 45) {
#line 122
      return ((time_t )-1);
    }
  }
#line 125
  p ++;
#line 127
  if ((unsigned int )fmt == 1U) {
#line 128
    if ((int )*p < 48) {
#line 132
      return ((time_t )-1);
    } else
#line 128
    if ((int )*p > 57) {
#line 132
      return ((time_t )-1);
    } else
#line 128
    if ((int )*(p + 1) < 48) {
#line 132
      return ((time_t )-1);
    } else
#line 128
    if ((int )*(p + 1) > 57) {
#line 132
      return ((time_t )-1);
    } else
#line 128
    if ((int )*(p + 2) < 48) {
#line 132
      return ((time_t )-1);
    } else
#line 128
    if ((int )*(p + 2) > 57) {
#line 132
      return ((time_t )-1);
    } else
#line 128
    if ((int )*(p + 3) < 48) {
#line 132
      return ((time_t )-1);
    } else
#line 128
    if ((int )*(p + 3) > 57) {
#line 132
      return ((time_t )-1);
    }
#line 135
    year = (ngx_uint_t )(((((int )*p - 48) * 1000 + ((int )*(p + 1) - 48) * 100) + ((int )*(p + 2) - 48) * 10) + ((int )*(p + 3) - 48));
#line 137
    p += 4;
  } else
#line 139
  if ((unsigned int )fmt == 2U) {
#line 140
    if ((int )*p < 48) {
#line 141
      return ((time_t )-1);
    } else
#line 140
    if ((int )*p > 57) {
#line 141
      return ((time_t )-1);
    } else
#line 140
    if ((int )*(p + 1) < 48) {
#line 141
      return ((time_t )-1);
    } else
#line 140
    if ((int )*(p + 1) > 57) {
#line 141
      return ((time_t )-1);
    }
#line 144
    year = (ngx_uint_t )(((int )*p - 48) * 10 + ((int )*(p + 1) - 48));
#line 145
    if (year < 70UL) {
#line 145
      tmp___0 = 2000;
    } else {
#line 145
      tmp___0 = 1900;
    }
#line 145
    year += (ngx_uint_t )tmp___0;
#line 146
    p += 2;
  }
#line 149
  if ((unsigned int )fmt == 3U) {
#line 150
    if ((int )*p == 32) {
#line 151
      p ++;
    }
#line 154
    if ((int )*p < 48) {
#line 155
      return ((time_t )-1);
    } else
#line 154
    if ((int )*p > 57) {
#line 155
      return ((time_t )-1);
    }
#line 158
    tmp___1 = p;
#line 158
    p ++;
#line 158
    day = (ngx_uint_t )((int )*tmp___1 - 48);
#line 160
    if ((int )*p != 32) {
#line 161
      if ((int )*p < 48) {
#line 162
        return ((time_t )-1);
      } else
#line 161
      if ((int )*p > 57) {
#line 162
        return ((time_t )-1);
      }
#line 165
      tmp___2 = p;
#line 165
      p ++;
#line 165
      day = day * 10UL + (ngx_uint_t )((int )*tmp___2 - 48);
    }
#line 168
    if (end - p < 14L) {
#line 169
      return ((time_t )-1);
    }
  }
#line 173
  tmp___3 = p;
#line 173
  p ++;
#line 173
  if ((int )*tmp___3 != 32) {
#line 174
    return ((time_t )-1);
  }
#line 177
  if ((int )*p < 48) {
#line 178
    return ((time_t )-1);
  } else
#line 177
  if ((int )*p > 57) {
#line 178
    return ((time_t )-1);
  } else
#line 177
  if ((int )*(p + 1) < 48) {
#line 178
    return ((time_t )-1);
  } else
#line 177
  if ((int )*(p + 1) > 57) {
#line 178
    return ((time_t )-1);
  }
#line 181
  hour = (ngx_uint_t )(((int )*p - 48) * 10 + ((int )*(p + 1) - 48));
#line 182
  p += 2;
#line 184
  tmp___4 = p;
#line 184
  p ++;
#line 184
  if ((int )*tmp___4 != 58) {
#line 185
    return ((time_t )-1);
  }
#line 188
  if ((int )*p < 48) {
#line 189
    return ((time_t )-1);
  } else
#line 188
  if ((int )*p > 57) {
#line 189
    return ((time_t )-1);
  } else
#line 188
  if ((int )*(p + 1) < 48) {
#line 189
    return ((time_t )-1);
  } else
#line 188
  if ((int )*(p + 1) > 57) {
#line 189
    return ((time_t )-1);
  }
#line 192
  min = (ngx_uint_t )(((int )*p - 48) * 10 + ((int )*(p + 1) - 48));
#line 193
  p += 2;
#line 195
  tmp___5 = p;
#line 195
  p ++;
#line 195
  if ((int )*tmp___5 != 58) {
#line 196
    return ((time_t )-1);
  }
#line 199
  if ((int )*p < 48) {
#line 200
    return ((time_t )-1);
  } else
#line 199
  if ((int )*p > 57) {
#line 200
    return ((time_t )-1);
  } else
#line 199
  if ((int )*(p + 1) < 48) {
#line 200
    return ((time_t )-1);
  } else
#line 199
  if ((int )*(p + 1) > 57) {
#line 200
    return ((time_t )-1);
  }
#line 203
  sec = (ngx_uint_t )(((int )*p - 48) * 10 + ((int )*(p + 1) - 48));
#line 205
  if ((unsigned int )fmt == 3U) {
#line 206
    p += 2;
#line 208
    tmp___6 = p;
#line 208
    p ++;
#line 208
    if ((int )*tmp___6 != 32) {
#line 209
      return ((time_t )-1);
    }
#line 212
    if ((int )*p < 48) {
#line 216
      return ((time_t )-1);
    } else
#line 212
    if ((int )*p > 57) {
#line 216
      return ((time_t )-1);
    } else
#line 212
    if ((int )*(p + 1) < 48) {
#line 216
      return ((time_t )-1);
    } else
#line 212
    if ((int )*(p + 1) > 57) {
#line 216
      return ((time_t )-1);
    } else
#line 212
    if ((int )*(p + 2) < 48) {
#line 216
      return ((time_t )-1);
    } else
#line 212
    if ((int )*(p + 2) > 57) {
#line 216
      return ((time_t )-1);
    } else
#line 212
    if ((int )*(p + 3) < 48) {
#line 216
      return ((time_t )-1);
    } else
#line 212
    if ((int )*(p + 3) > 57) {
#line 216
      return ((time_t )-1);
    }
#line 219
    year = (ngx_uint_t )(((((int )*p - 48) * 1000 + ((int )*(p + 1) - 48) * 100) + ((int )*(p + 2) - 48) * 10) + ((int )*(p + 3) - 48));
  }
#line 223
  if (hour > 23UL) {
#line 224
    return ((time_t )-1);
  } else
#line 223
  if (min > 59UL) {
#line 224
    return ((time_t )-1);
  } else
#line 223
  if (sec > 59UL) {
#line 224
    return ((time_t )-1);
  }
#line 227
  if (day == 29UL) {
#line 227
    if (month == 1L) {
#line 228
      if (year & 3UL) {
#line 229
        return ((time_t )-1);
      } else
#line 228
      if (year % 100UL == 0UL) {
#line 228
        if (year % 400UL != 0UL) {
#line 229
          return ((time_t )-1);
        }
      }
    } else {
#line 227
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 232
  if (day > mday[month]) {
#line 233
    return ((time_t )-1);
  }
#line 241
  month --;
#line 241
  if (month <= 0L) {
#line 242
    month += 12L;
#line 243
    year --;
  }
#line 248
  time___0 = ((((((((((((365UL * year + year / 4UL) - year / 100UL) + year / 400UL) + (ngx_uint_t )((367L * month) / 12L)) - 30UL) + day) - 1UL) - 719527UL) + 31UL) + 28UL) * 86400UL + hour * 3600UL) + min * 60UL) + sec;
#line 276
  return ((time_t )time___0);
}
}
#line 176 "src/core/ngx_string.h"
ssize_t ngx_atosz(u_char *line , size_t n ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_parse.c"
ssize_t ngx_parse_size(ngx_str_t *line ) 
{ 
  u_char unit ;
  size_t len ;
  ssize_t size ;
  ssize_t scale ;
  ssize_t max ;

  {
#line 19
  len = line->len;
#line 21
  if (len == 0UL) {
#line 22
    return ((ssize_t )-1);
  }
#line 25
  unit = *(line->data + (len - 1UL));
  {
#line 29
  if ((int )unit == 107) {
#line 29
    goto case_107;
  }
#line 29
  if ((int )unit == 75) {
#line 29
    goto case_107;
  }
#line 36
  if ((int )unit == 109) {
#line 36
    goto case_109;
  }
#line 36
  if ((int )unit == 77) {
#line 36
    goto case_109;
  }
#line 42
  goto switch_default;
  case_107: /* CIL Label */ 
  case_75: /* CIL Label */ 
#line 30
  len --;
#line 31
  max = (ssize_t )9007199254740991LL;
#line 32
  scale = (ssize_t )1024;
#line 33
  goto switch_break;
  case_109: /* CIL Label */ 
  case_77: /* CIL Label */ 
#line 37
  len --;
#line 38
  max = (ssize_t )8796093022207LL;
#line 39
  scale = (ssize_t )1048576;
#line 40
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 43
  max = (ssize_t )9223372036854775807LL;
#line 44
  scale = (ssize_t )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 47
  size = ngx_atosz(line->data, len);
  }
#line 48
  if (size == -1L) {
#line 49
    return ((ssize_t )-1);
  } else
#line 48
  if (size > max) {
#line 49
    return ((ssize_t )-1);
  }
#line 52
  size *= scale;
#line 54
  return (size);
}
}
#line 58 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_parse.c"
off_t ngx_parse_offset(ngx_str_t *line ) 
{ 
  u_char unit ;
  off_t offset ;
  off_t scale ;
  off_t max ;
  size_t len ;

  {
#line 65
  len = line->len;
#line 67
  if (len == 0UL) {
#line 68
    return ((off_t )-1);
  }
#line 71
  unit = *(line->data + (len - 1UL));
  {
#line 75
  if ((int )unit == 107) {
#line 75
    goto case_107;
  }
#line 75
  if ((int )unit == 75) {
#line 75
    goto case_107;
  }
#line 82
  if ((int )unit == 109) {
#line 82
    goto case_109;
  }
#line 82
  if ((int )unit == 77) {
#line 82
    goto case_109;
  }
#line 89
  if ((int )unit == 103) {
#line 89
    goto case_103;
  }
#line 89
  if ((int )unit == 71) {
#line 89
    goto case_103;
  }
#line 95
  goto switch_default;
  case_107: /* CIL Label */ 
  case_75: /* CIL Label */ 
#line 76
  len --;
#line 77
  max = (off_t )9007199254740991LL;
#line 78
  scale = (off_t )1024;
#line 79
  goto switch_break;
  case_109: /* CIL Label */ 
  case_77: /* CIL Label */ 
#line 83
  len --;
#line 84
  max = (off_t )8796093022207LL;
#line 85
  scale = (off_t )1048576;
#line 86
  goto switch_break;
  case_103: /* CIL Label */ 
  case_71: /* CIL Label */ 
#line 90
  len --;
#line 91
  max = (off_t )8589934591LL;
#line 92
  scale = (off_t )1073741824;
#line 93
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 96
  max = (off_t )9223372036854775807LL;
#line 97
  scale = (off_t )1;
  switch_break: /* CIL Label */ ;
  }
  {
#line 100
  offset = ngx_atoof(line->data, len);
  }
#line 101
  if (offset == -1L) {
#line 102
    return ((off_t )-1);
  } else
#line 101
  if (offset > max) {
#line 102
    return ((off_t )-1);
  }
#line 105
  offset *= scale;
#line 107
  return (offset);
}
}
#line 111 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_parse.c"
ngx_int_t ngx_parse_time(ngx_str_t *line , ngx_uint_t is_sec ) 
{ 
  u_char *p ;
  u_char *last ;
  ngx_int_t value ;
  ngx_int_t total ;
  ngx_int_t scale ;
  ngx_int_t max ;
  ngx_int_t cutoff ;
  ngx_int_t cutlim ;
  ngx_uint_t valid ;
  enum __anonenum_step_171 step ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
#line 131
  valid = (ngx_uint_t )0;
#line 132
  value = (ngx_int_t )0;
#line 133
  total = (ngx_int_t )0;
#line 134
  cutoff = 922337203685477580L;
#line 135
  cutlim = 7L;
#line 136
  if (is_sec) {
#line 136
    step = (enum __anonenum_step_171 )0;
  } else {
#line 136
    step = (enum __anonenum_step_171 )2;
  }
#line 138
  p = line->data;
#line 139
  last = p + line->len;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 141
      goto while_break;
    }
#line 143
    if ((int )*p >= 48) {
#line 143
      if ((int )*p <= 57) {
#line 144
        if (value >= cutoff) {
#line 144
          if (value > cutoff) {
#line 145
            return ((ngx_int_t )-1);
          } else
#line 144
          if ((ngx_int_t )((int )*p - 48) > cutlim) {
#line 145
            return ((ngx_int_t )-1);
          }
        }
#line 148
        tmp = p;
#line 148
        p ++;
#line 148
        value = value * 10L + (ngx_int_t )((int )*tmp - 48);
#line 149
        valid = (ngx_uint_t )1;
#line 150
        goto while_continue;
      }
    }
#line 153
    tmp___0 = p;
#line 153
    p ++;
    {
#line 155
    if ((int )*tmp___0 == 121) {
#line 155
      goto case_121;
    }
#line 164
    if ((int )*tmp___0 == 77) {
#line 164
      goto case_77;
    }
#line 173
    if ((int )*tmp___0 == 119) {
#line 173
      goto case_119;
    }
#line 182
    if ((int )*tmp___0 == 100) {
#line 182
      goto case_100;
    }
#line 191
    if ((int )*tmp___0 == 104) {
#line 191
      goto case_104;
    }
#line 200
    if ((int )*tmp___0 == 109) {
#line 200
      goto case_109;
    }
#line 220
    if ((int )*tmp___0 == 115) {
#line 220
      goto case_115;
    }
#line 229
    if ((int )*tmp___0 == 32) {
#line 229
      goto case_32;
    }
#line 238
    goto switch_default;
    case_121: /* CIL Label */ 
#line 156
    if ((unsigned int )step > 0U) {
#line 157
      return ((ngx_int_t )-1);
    }
#line 159
    step = (enum __anonenum_step_171 )1;
#line 160
    max = 292471208677L;
#line 161
    scale = (ngx_int_t )31536000;
#line 162
    goto switch_break;
    case_77: /* CIL Label */ 
#line 165
    if ((unsigned int )step >= 2U) {
#line 166
      return ((ngx_int_t )-1);
    }
#line 168
    step = (enum __anonenum_step_171 )2;
#line 169
    max = 3558399705576L;
#line 170
    scale = (ngx_int_t )2592000;
#line 171
    goto switch_break;
    case_119: /* CIL Label */ 
#line 174
    if ((unsigned int )step >= 3U) {
#line 175
      return ((ngx_int_t )-1);
    }
#line 177
    step = (enum __anonenum_step_171 )3;
#line 178
    max = 15250284452471L;
#line 179
    scale = (ngx_int_t )604800;
#line 180
    goto switch_break;
    case_100: /* CIL Label */ 
#line 183
    if ((unsigned int )step >= 4U) {
#line 184
      return ((ngx_int_t )-1);
    }
#line 186
    step = (enum __anonenum_step_171 )4;
#line 187
    max = 106751991167300L;
#line 188
    scale = (ngx_int_t )86400;
#line 189
    goto switch_break;
    case_104: /* CIL Label */ 
#line 192
    if ((unsigned int )step >= 5U) {
#line 193
      return ((ngx_int_t )-1);
    }
#line 195
    step = (enum __anonenum_step_171 )5;
#line 196
    max = 2562047788015215L;
#line 197
    scale = (ngx_int_t )3600;
#line 198
    goto switch_break;
    case_109: /* CIL Label */ 
#line 201
    if ((unsigned long )p < (unsigned long )last) {
#line 201
      if ((int )*p == 115) {
#line 202
        if (is_sec) {
#line 203
          return ((ngx_int_t )-1);
        } else
#line 202
        if ((unsigned int )step >= 8U) {
#line 203
          return ((ngx_int_t )-1);
        }
#line 205
        p ++;
#line 206
        step = (enum __anonenum_step_171 )8;
#line 207
        max = 9223372036854775807L;
#line 208
        scale = (ngx_int_t )1;
#line 209
        goto switch_break;
      }
    }
#line 212
    if ((unsigned int )step >= 6U) {
#line 213
      return ((ngx_int_t )-1);
    }
#line 215
    step = (enum __anonenum_step_171 )6;
#line 216
    max = 153722867280912930L;
#line 217
    scale = (ngx_int_t )60;
#line 218
    goto switch_break;
    case_115: /* CIL Label */ 
#line 221
    if ((unsigned int )step >= 7U) {
#line 222
      return ((ngx_int_t )-1);
    }
#line 224
    step = (enum __anonenum_step_171 )7;
#line 225
    max = 9223372036854775807L;
#line 226
    scale = (ngx_int_t )1;
#line 227
    goto switch_break;
    case_32: /* CIL Label */ 
#line 230
    if ((unsigned int )step >= 7U) {
#line 231
      return ((ngx_int_t )-1);
    }
#line 233
    step = (enum __anonenum_step_171 )9;
#line 234
    max = 9223372036854775807L;
#line 235
    scale = (ngx_int_t )1;
#line 236
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 239
    return ((ngx_int_t )-1);
    switch_break: /* CIL Label */ ;
    }
#line 242
    if ((unsigned int )step != 8U) {
#line 242
      if (! is_sec) {
#line 243
        scale *= 1000L;
#line 244
        max /= 1000L;
      }
    }
#line 247
    if (value > max) {
#line 248
      return ((ngx_int_t )-1);
    }
#line 251
    value *= scale;
#line 253
    if (total > 9223372036854775807L - value) {
#line 254
      return ((ngx_int_t )-1);
    }
#line 257
    total += value;
#line 259
    value = (ngx_int_t )0;
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      if ((unsigned long )p < (unsigned long )last) {
#line 261
        if (! ((int )*p == 32)) {
#line 261
          goto while_break___0;
        }
      } else {
#line 261
        goto while_break___0;
      }
#line 262
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  if (! valid) {
#line 267
    return ((ngx_int_t )-1);
  }
#line 270
  if (! is_sec) {
#line 271
    if (value > 9223372036854775L) {
#line 272
      return ((ngx_int_t )-1);
    }
#line 275
    value *= 1000L;
  }
#line 278
  if (total > 9223372036854775807L - value) {
#line 279
    return ((ngx_int_t )-1);
  }
#line 282
  return (total + value);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 188 "src/core/ngx_string.h"
void ngx_encode_base64url(ngx_str_t *dst , ngx_str_t *src ) ;
#line 190
ngx_int_t ngx_decode_base64url(ngx_str_t *dst , ngx_str_t *src ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char *ngx_sprintf_num(u_char *buf , u_char *last , uint64_t ui64 , u_char zero___0 ,
                               ngx_uint_t hexadecimal , ngx_uint_t width ) ;
#line 14
static void ngx_encode_base64_internal(ngx_str_t *dst , ngx_str_t *src , u_char const   *basis ,
                                       ngx_uint_t padding ) ;
#line 16
static ngx_int_t ngx_decode_base64_internal(ngx_str_t *dst , ngx_str_t *src , u_char const   *basis ) ;
#line 20 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
void ngx_strlow(u_char *dst , u_char *src , size_t n ) 
{ 
  int tmp ;

  {
  {
#line 23
  while (1) {
    while_continue: /* CIL Label */ ;
#line 23
    if (! n) {
#line 23
      goto while_break;
    }
#line 24
    if ((int )*src >= 65) {
#line 24
      if ((int )*src <= 90) {
#line 24
        tmp = (int )*src | 32;
      } else {
#line 24
        tmp = (int )*src;
      }
    } else {
#line 24
      tmp = (int )*src;
    }
#line 24
    *dst = (u_char )tmp;
#line 25
    dst ++;
#line 26
    src ++;
#line 27
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 29
  return;
}
}
#line 32 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
size_t ngx_strnlen(u_char *p , size_t n ) 
{ 
  size_t i ;

  {
#line 37
  i = (size_t )0;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i < n)) {
#line 37
      goto while_break;
    }
#line 39
    if ((int )*(p + i) == 0) {
#line 40
      return (i);
    }
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 44
  return (n);
}
}
#line 48 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_cpystrn(u_char *dst , u_char *src , size_t n ) 
{ 


  {
#line 51
  if (n == 0UL) {
#line 52
    return (dst);
  }
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    n --;
#line 55
    if (! n) {
#line 55
      goto while_break;
    }
#line 56
    *dst = *src;
#line 58
    if ((int )*dst == 0) {
#line 59
      return (dst);
    }
#line 62
    dst ++;
#line 63
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  *dst = (u_char )'\000';
#line 68
  return (dst);
}
}
#line 72 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_pstrdup(ngx_pool_t *pool , ngx_str_t *src ) 
{ 
  u_char *dst ;
  void *tmp ;

  {
  {
#line 77
  tmp = ngx_pnalloc(pool, src->len);
#line 77
  dst = (u_char *)tmp;
  }
#line 78
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 79
    return ((u_char *)((void *)0));
  }
  {
#line 82
  memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)src->data,
         src->len);
  }
#line 84
  return (dst);
}
}
#line 120 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_sprintf(u_char *buf , char const   *fmt  , ...) 
{ 
  u_char *p ;
  va_list args___0 ;

  {
  {
#line 126
  __builtin_va_start(args___0, fmt);
#line 127
  p = ngx_vslprintf(buf, (u_char *)((void *)-1), fmt, args___0);
#line 128
  __builtin_va_end(args___0);
  }
#line 130
  return (p);
}
}
#line 134 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_snprintf(u_char *buf , size_t max , char const   *fmt  , ...) 
{ 
  u_char *p ;
  va_list args___0 ;

  {
  {
#line 140
  __builtin_va_start(args___0, fmt);
#line 141
  p = ngx_vslprintf(buf, buf + max, fmt, args___0);
#line 142
  __builtin_va_end(args___0);
  }
#line 144
  return (p);
}
}
#line 148 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_slprintf(u_char *buf , u_char *last , char const   *fmt  , ...) 
{ 
  u_char *p ;
  va_list args___0 ;

  {
  {
#line 154
  __builtin_va_start(args___0, fmt);
#line 155
  p = ngx_vslprintf(buf, last, fmt, args___0);
#line 156
  __builtin_va_end(args___0);
  }
#line 158
  return (p);
}
}
#line 162 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_vslprintf(u_char *buf , u_char *last , char const   *fmt , va_list args___0 ) 
{ 
  u_char *p ;
  u_char zero___0 ;
  int d ;
  double f ;
  size_t len ;
  size_t slen ;
  int64_t i64 ;
  uint64_t ui64 ;
  uint64_t frac ;
  ngx_msec_t ms ;
  ngx_uint_t width ;
  ngx_uint_t sign ;
  ngx_uint_t hex___3 ;
  ngx_uint_t max_width ;
  ngx_uint_t frac_width ;
  ngx_uint_t scale ;
  ngx_uint_t n ;
  ngx_str_t *v ;
  ngx_variable_value_t *vv ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  size_t tmp___2 ;
  ngx_str_t *tmp___3 ;
  void *tmp___4 ;
  ngx_variable_value_t *tmp___5 ;
  void *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  void *tmp___10 ;
  off_t tmp___12 ;
  ngx_pid_t tmp___14 ;
  time_t tmp___16 ;
  ngx_msec_t tmp___18 ;
  ssize_t tmp___20 ;
  size_t tmp___22 ;
  ngx_int_t tmp___24 ;
  ngx_uint_t tmp___26 ;
  int tmp___28 ;
  u_int tmp___30 ;
  long tmp___32 ;
  u_long tmp___34 ;
  int32_t tmp___36 ;
  uint32_t tmp___38 ;
  int64_t tmp___39 ;
  uint64_t tmp___40 ;
  ngx_atomic_int_t tmp___42 ;
  ngx_atomic_uint_t tmp___44 ;
  double tmp___45 ;
  u_char *tmp___46 ;
  u_char *tmp___47 ;
  rlim_t tmp___49 ;
  void *tmp___51 ;
  int tmp___52 ;
  u_char *tmp___53 ;
  u_char *tmp___54 ;
  u_char *tmp___55 ;
  u_char *tmp___56 ;
  u_char *tmp___57 ;
  char const   *tmp___58 ;
  u_char *tmp___59 ;
  u_char *tmp___60 ;
  char const   *tmp___61 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (*fmt) {
#line 176
      if (! ((unsigned long )buf < (unsigned long )last)) {
#line 176
        goto while_break;
      }
    } else {
#line 176
      goto while_break;
    }
#line 183
    if ((int const   )*fmt == 37) {
#line 185
      i64 = (int64_t )0;
#line 186
      ui64 = (uint64_t )0;
#line 188
      fmt ++;
#line 188
      if ((int const   )*fmt == 48) {
#line 188
        tmp = '0';
      } else {
#line 188
        tmp = ' ';
      }
#line 188
      zero___0 = (u_char )tmp;
#line 189
      width = (ngx_uint_t )0;
#line 190
      sign = (ngx_uint_t )1;
#line 191
      hex___3 = (ngx_uint_t )0;
#line 192
      max_width = (ngx_uint_t )0;
#line 193
      frac_width = (ngx_uint_t )0;
#line 194
      slen = (size_t )-1;
      {
#line 196
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 196
        if ((int const   )*fmt >= 48) {
#line 196
          if (! ((int const   )*fmt <= 57)) {
#line 196
            goto while_break___0;
          }
        } else {
#line 196
          goto while_break___0;
        }
#line 197
        tmp___0 = fmt;
#line 197
        fmt ++;
#line 197
        width = width * 10UL + (ngx_uint_t )((int const   )*tmp___0 - 48);
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 201
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 204
        if ((int const   )*fmt == 117) {
#line 204
          goto case_117;
        }
#line 209
        if ((int const   )*fmt == 109) {
#line 209
          goto case_109;
        }
#line 214
        if ((int const   )*fmt == 88) {
#line 214
          goto case_88;
        }
#line 220
        if ((int const   )*fmt == 120) {
#line 220
          goto case_120;
        }
#line 226
        if ((int const   )*fmt == 46) {
#line 226
          goto case_46;
        }
#line 235
        if ((int const   )*fmt == 42) {
#line 235
          goto case_42;
        }
#line 240
        goto switch_default;
        case_117: /* CIL Label */ 
#line 205
        sign = (ngx_uint_t )0;
#line 206
        fmt ++;
#line 207
        goto __Cont;
        case_109: /* CIL Label */ 
#line 210
        max_width = (ngx_uint_t )1;
#line 211
        fmt ++;
#line 212
        goto __Cont;
        case_88: /* CIL Label */ 
#line 215
        hex___3 = (ngx_uint_t )2;
#line 216
        sign = (ngx_uint_t )0;
#line 217
        fmt ++;
#line 218
        goto __Cont;
        case_120: /* CIL Label */ 
#line 221
        hex___3 = (ngx_uint_t )1;
#line 222
        sign = (ngx_uint_t )0;
#line 223
        fmt ++;
#line 224
        goto __Cont;
        case_46: /* CIL Label */ 
#line 227
        fmt ++;
        {
#line 229
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 229
          if ((int const   )*fmt >= 48) {
#line 229
            if (! ((int const   )*fmt <= 57)) {
#line 229
              goto while_break___2;
            }
          } else {
#line 229
            goto while_break___2;
          }
#line 230
          tmp___1 = fmt;
#line 230
          fmt ++;
#line 230
          frac_width = frac_width * 10UL + (ngx_uint_t )((int const   )*tmp___1 - 48);
        }
        while_break___2: /* CIL Label */ ;
        }
#line 233
        goto switch_break;
        case_42: /* CIL Label */ 
        {
#line 236
        tmp___2 = __builtin_va_arg(args___0, size_t );
#line 236
        slen = tmp___2;
#line 237
        fmt ++;
        }
#line 238
        goto __Cont;
        switch_default: /* CIL Label */ 
#line 241
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
#line 244
        goto while_break___1;
        __Cont: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 250
      if ((int const   )*fmt == 86) {
#line 250
        goto case_86;
      }
#line 259
      if ((int const   )*fmt == 118) {
#line 259
        goto case_118;
      }
#line 268
      if ((int const   )*fmt == 115) {
#line 268
        goto case_115;
      }
#line 285
      if ((int const   )*fmt == 79) {
#line 285
        goto case_79;
      }
#line 290
      if ((int const   )*fmt == 80) {
#line 290
        goto case_80;
      }
#line 295
      if ((int const   )*fmt == 84) {
#line 295
        goto case_84;
      }
#line 300
      if ((int const   )*fmt == 77) {
#line 300
        goto case_77;
      }
#line 311
      if ((int const   )*fmt == 122) {
#line 311
        goto case_122;
      }
#line 319
      if ((int const   )*fmt == 105) {
#line 319
        goto case_105;
      }
#line 332
      if ((int const   )*fmt == 100) {
#line 332
        goto case_100;
      }
#line 340
      if ((int const   )*fmt == 108) {
#line 340
        goto case_108;
      }
#line 348
      if ((int const   )*fmt == 68) {
#line 348
        goto case_68;
      }
#line 356
      if ((int const   )*fmt == 76) {
#line 356
        goto case_76;
      }
#line 364
      if ((int const   )*fmt == 65) {
#line 364
        goto case_65;
      }
#line 377
      if ((int const   )*fmt == 102) {
#line 377
        goto case_102;
      }
#line 418
      if ((int const   )*fmt == 114) {
#line 418
        goto case_114;
      }
#line 424
      if ((int const   )*fmt == 112) {
#line 424
        goto case_112;
      }
#line 432
      if ((int const   )*fmt == 99) {
#line 432
        goto case_99;
      }
#line 439
      if ((int const   )*fmt == 90) {
#line 439
        goto case_90;
      }
#line 445
      if ((int const   )*fmt == 78) {
#line 445
        goto case_78;
      }
#line 458
      if ((int const   )*fmt == 37) {
#line 458
        goto case_37;
      }
#line 464
      goto switch_default___0;
      case_86: /* CIL Label */ 
      {
#line 251
      tmp___3 = __builtin_va_arg(args___0, ngx_str_t *);
#line 251
      v = tmp___3;
      }
#line 253
      if ((size_t )(last - buf) > v->len) {
#line 253
        len = v->len;
      } else {
#line 253
        len = (size_t )(last - buf);
      }
      {
#line 254
      tmp___4 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)v->data,
                       len);
#line 254
      buf = (u_char *)tmp___4 + len;
#line 255
      fmt ++;
      }
#line 257
      goto while_continue;
      case_118: /* CIL Label */ 
      {
#line 260
      tmp___5 = __builtin_va_arg(args___0, ngx_variable_value_t *);
#line 260
      vv = tmp___5;
      }
#line 262
      if ((size_t )(last - buf) > (size_t )vv->len) {
#line 262
        len = (size_t )vv->len;
      } else {
#line 262
        len = (size_t )(last - buf);
      }
      {
#line 263
      tmp___6 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)vv->data,
                       len);
#line 263
      buf = (u_char *)tmp___6 + len;
#line 264
      fmt ++;
      }
#line 266
      goto while_continue;
      case_115: /* CIL Label */ 
      {
#line 269
      tmp___7 = __builtin_va_arg(args___0, u_char *);
#line 269
      p = tmp___7;
      }
#line 271
      if (slen == 0xffffffffffffffffUL) {
        {
#line 272
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 272
          if (*p) {
#line 272
            if (! ((unsigned long )buf < (unsigned long )last)) {
#line 272
              goto while_break___3;
            }
          } else {
#line 272
            goto while_break___3;
          }
#line 273
          tmp___8 = buf;
#line 273
          buf ++;
#line 273
          tmp___9 = p;
#line 273
          p ++;
#line 273
          *tmp___8 = *tmp___9;
        }
        while_break___3: /* CIL Label */ ;
        }
      } else {
#line 277
        if ((size_t )(last - buf) > slen) {
#line 277
          len = slen;
        } else {
#line 277
          len = (size_t )(last - buf);
        }
        {
#line 278
        tmp___10 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)p,
                          len);
#line 278
        buf = (u_char *)tmp___10 + len;
        }
      }
#line 281
      fmt ++;
#line 283
      goto while_continue;
      case_79: /* CIL Label */ 
      {
#line 286
      tmp___12 = __builtin_va_arg(args___0, off_t );
#line 286
      i64 = tmp___12;
#line 287
      sign = (ngx_uint_t )1;
      }
#line 288
      goto switch_break___0;
      case_80: /* CIL Label */ 
      {
#line 291
      tmp___14 = __builtin_va_arg(args___0, ngx_pid_t );
#line 291
      i64 = (int64_t )tmp___14;
#line 292
      sign = (ngx_uint_t )1;
      }
#line 293
      goto switch_break___0;
      case_84: /* CIL Label */ 
      {
#line 296
      tmp___16 = __builtin_va_arg(args___0, time_t );
#line 296
      i64 = tmp___16;
#line 297
      sign = (ngx_uint_t )1;
      }
#line 298
      goto switch_break___0;
      case_77: /* CIL Label */ 
      {
#line 301
      tmp___18 = __builtin_va_arg(args___0, ngx_msec_t );
#line 301
      ms = tmp___18;
      }
#line 302
      if ((ngx_msec_int_t )ms == -1L) {
#line 303
        sign = (ngx_uint_t )1;
#line 304
        i64 = (int64_t )-1;
      } else {
#line 306
        sign = (ngx_uint_t )0;
#line 307
        ui64 = ms;
      }
#line 309
      goto switch_break___0;
      case_122: /* CIL Label */ 
#line 312
      if (sign) {
        {
#line 313
        tmp___20 = __builtin_va_arg(args___0, ssize_t );
#line 313
        i64 = tmp___20;
        }
      } else {
        {
#line 315
        tmp___22 = __builtin_va_arg(args___0, size_t );
#line 315
        ui64 = tmp___22;
        }
      }
#line 317
      goto switch_break___0;
      case_105: /* CIL Label */ 
#line 320
      if (sign) {
        {
#line 321
        tmp___24 = __builtin_va_arg(args___0, ngx_int_t );
#line 321
        i64 = tmp___24;
        }
      } else {
        {
#line 323
        tmp___26 = __builtin_va_arg(args___0, ngx_uint_t );
#line 323
        ui64 = tmp___26;
        }
      }
#line 326
      if (max_width) {
#line 327
        width = sizeof("-9223372036854775808") - 1UL;
      }
#line 330
      goto switch_break___0;
      case_100: /* CIL Label */ 
#line 333
      if (sign) {
        {
#line 334
        tmp___28 = __builtin_va_arg(args___0, int );
#line 334
        i64 = (int64_t )tmp___28;
        }
      } else {
        {
#line 336
        tmp___30 = __builtin_va_arg(args___0, u_int );
#line 336
        ui64 = (uint64_t )tmp___30;
        }
      }
#line 338
      goto switch_break___0;
      case_108: /* CIL Label */ 
#line 341
      if (sign) {
        {
#line 342
        tmp___32 = __builtin_va_arg(args___0, long );
#line 342
        i64 = tmp___32;
        }
      } else {
        {
#line 344
        tmp___34 = __builtin_va_arg(args___0, u_long );
#line 344
        ui64 = tmp___34;
        }
      }
#line 346
      goto switch_break___0;
      case_68: /* CIL Label */ 
#line 349
      if (sign) {
        {
#line 350
        tmp___36 = __builtin_va_arg(args___0, int32_t );
#line 350
        i64 = (int64_t )tmp___36;
        }
      } else {
        {
#line 352
        tmp___38 = __builtin_va_arg(args___0, uint32_t );
#line 352
        ui64 = (uint64_t )tmp___38;
        }
      }
#line 354
      goto switch_break___0;
      case_76: /* CIL Label */ 
#line 357
      if (sign) {
        {
#line 358
        tmp___39 = __builtin_va_arg(args___0, int64_t );
#line 358
        i64 = tmp___39;
        }
      } else {
        {
#line 360
        tmp___40 = __builtin_va_arg(args___0, uint64_t );
#line 360
        ui64 = tmp___40;
        }
      }
#line 362
      goto switch_break___0;
      case_65: /* CIL Label */ 
#line 365
      if (sign) {
        {
#line 366
        tmp___42 = __builtin_va_arg(args___0, ngx_atomic_int_t );
#line 366
        i64 = tmp___42;
        }
      } else {
        {
#line 368
        tmp___44 = __builtin_va_arg(args___0, ngx_atomic_uint_t );
#line 368
        ui64 = tmp___44;
        }
      }
#line 371
      if (max_width) {
#line 372
        width = sizeof("-9223372036854775808") - 1UL;
      }
#line 375
      goto switch_break___0;
      case_102: /* CIL Label */ 
      {
#line 378
      tmp___45 = __builtin_va_arg(args___0, double );
#line 378
      f = tmp___45;
      }
#line 380
      if (f < (double )0) {
#line 381
        tmp___46 = buf;
#line 381
        buf ++;
#line 381
        *tmp___46 = (u_char )'-';
#line 382
        f = - f;
      }
#line 385
      ui64 = (uint64_t )((int64_t )f);
#line 386
      frac = (uint64_t )0;
#line 388
      if (frac_width) {
#line 390
        scale = (ngx_uint_t )1;
#line 391
        n = frac_width;
        {
#line 391
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 391
          if (! n) {
#line 391
            goto while_break___4;
          }
#line 392
          scale *= 10UL;
#line 391
          n --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 395
        frac = (uint64_t )((f - (double )ui64) * (double )scale + 0.5);
#line 397
        if (frac == scale) {
#line 398
          ui64 ++;
#line 399
          frac = (uint64_t )0;
        }
      }
      {
#line 403
      buf = ngx_sprintf_num(buf, last, ui64, zero___0, (ngx_uint_t )0, width);
      }
#line 405
      if (frac_width) {
#line 406
        if ((unsigned long )buf < (unsigned long )last) {
#line 407
          tmp___47 = buf;
#line 407
          buf ++;
#line 407
          *tmp___47 = (u_char )'.';
        }
        {
#line 410
        buf = ngx_sprintf_num(buf, last, frac, (u_char )'0', (ngx_uint_t )0, frac_width);
        }
      }
#line 413
      fmt ++;
#line 415
      goto while_continue;
      case_114: /* CIL Label */ 
      {
#line 419
      tmp___49 = __builtin_va_arg(args___0, rlim_t );
#line 419
      i64 = (int64_t )tmp___49;
#line 420
      sign = (ngx_uint_t )1;
      }
#line 421
      goto switch_break___0;
      case_112: /* CIL Label */ 
      {
#line 425
      tmp___51 = __builtin_va_arg(args___0, void *);
#line 425
      ui64 = (uintptr_t )tmp___51;
#line 426
      hex___3 = (ngx_uint_t )2;
#line 427
      sign = (ngx_uint_t )0;
#line 428
      zero___0 = (u_char )'0';
#line 429
      width = 2UL * sizeof(void *);
      }
#line 430
      goto switch_break___0;
      case_99: /* CIL Label */ 
      {
#line 433
      tmp___52 = __builtin_va_arg(args___0, int );
#line 433
      d = tmp___52;
#line 434
      tmp___53 = buf;
#line 434
      buf ++;
#line 434
      *tmp___53 = (u_char )(d & 255);
#line 435
      fmt ++;
      }
#line 437
      goto while_continue;
      case_90: /* CIL Label */ 
#line 440
      tmp___54 = buf;
#line 440
      buf ++;
#line 440
      *tmp___54 = (u_char )'\000';
#line 441
      fmt ++;
#line 443
      goto while_continue;
      case_78: /* CIL Label */ 
#line 452
      tmp___55 = buf;
#line 452
      buf ++;
#line 452
      *tmp___55 = (u_char )'\n';
#line 454
      fmt ++;
#line 456
      goto while_continue;
      case_37: /* CIL Label */ 
#line 459
      tmp___56 = buf;
#line 459
      buf ++;
#line 459
      *tmp___56 = (u_char )'%';
#line 460
      fmt ++;
#line 462
      goto while_continue;
      switch_default___0: /* CIL Label */ 
#line 465
      tmp___57 = buf;
#line 465
      buf ++;
#line 465
      tmp___58 = fmt;
#line 465
      fmt ++;
#line 465
      *tmp___57 = (u_char )*tmp___58;
#line 467
      goto while_continue;
      switch_break___0: /* CIL Label */ ;
      }
#line 470
      if (sign) {
#line 471
        if (i64 < 0L) {
#line 472
          tmp___59 = buf;
#line 472
          buf ++;
#line 472
          *tmp___59 = (u_char )'-';
#line 473
          ui64 = (uint64_t )(- i64);
        } else {
#line 476
          ui64 = (uint64_t )i64;
        }
      }
      {
#line 480
      buf = ngx_sprintf_num(buf, last, ui64, zero___0, hex___3, width);
#line 482
      fmt ++;
      }
    } else {
#line 485
      tmp___60 = buf;
#line 485
      buf ++;
#line 485
      tmp___61 = fmt;
#line 485
      fmt ++;
#line 485
      *tmp___60 = (u_char )*tmp___61;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  return (buf);
}
}
#line 504 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char hex___0[17]  = 
#line 504
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'\000'};
#line 505 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char HEX[17]  = 
#line 505
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'A',      (u_char )'B', 
        (u_char )'C',      (u_char )'D',      (u_char )'E',      (u_char )'F', 
        (u_char )'\000'};
#line 493 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char *ngx_sprintf_num(u_char *buf , u_char *last , uint64_t ui64 , u_char zero___0 ,
                               ngx_uint_t hexadecimal , ngx_uint_t width ) 
{ 
  u_char *p ;
  u_char temp[(sizeof("-9223372036854775808") - 1UL) + 1UL] ;
  size_t len ;
  uint32_t ui32 ;
  u_char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 507
  p = temp + (sizeof("-9223372036854775808") - 1UL);
#line 509
  if (hexadecimal == 0UL) {
#line 511
    if (ui64 <= 4294967295UL) {
#line 528
      ui32 = (uint32_t )ui64;
      {
#line 530
      while (1) {
        while_continue: /* CIL Label */ ;
#line 531
        p --;
#line 531
        *p = (u_char )(ui32 % 10U + 48U);
#line 530
        ui32 /= 10U;
#line 530
        if (! ui32) {
#line 530
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
      {
#line 535
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 536
        p --;
#line 536
        *p = (u_char )(ui64 % 10UL + 48UL);
#line 535
        ui64 /= 10UL;
#line 535
        if (! ui64) {
#line 535
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 540
  if (hexadecimal == 1UL) {
    {
#line 542
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 545
      p --;
#line 545
      *p = hex___0[(uint32_t )(ui64 & 15UL)];
#line 542
      ui64 >>= 4;
#line 542
      if (! ui64) {
#line 542
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 551
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 554
      p --;
#line 554
      *p = HEX[(uint32_t )(ui64 & 15UL)];
#line 551
      ui64 >>= 4;
#line 551
      if (! ui64) {
#line 551
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 561
  len = (size_t )((temp + (sizeof("-9223372036854775808") - 1UL)) - p);
  {
#line 563
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 563
    tmp___0 = len;
#line 563
    len ++;
#line 563
    if (tmp___0 < width) {
#line 563
      if (! ((unsigned long )buf < (unsigned long )last)) {
#line 563
        goto while_break___3;
      }
    } else {
#line 563
      goto while_break___3;
    }
#line 564
    tmp = buf;
#line 564
    buf ++;
#line 564
    *tmp = zero___0;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 569
  len = (size_t )((temp + (sizeof("-9223372036854775808") - 1UL)) - p);
#line 571
  if ((unsigned long )(buf + len) > (unsigned long )last) {
#line 572
    len = (size_t )(last - buf);
  }
  {
#line 575
  tmp___1 = memcpy((void */* __restrict  */)buf, (void const   */* __restrict  */)p,
                   len);
  }
#line 575
  return ((u_char *)tmp___1 + len);
}
}
#line 586 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_strcasecmp(u_char *s1 , u_char *s2 ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    tmp = s1;
#line 592
    s1 ++;
#line 592
    c1 = (ngx_uint_t )*tmp;
#line 593
    tmp___0 = s2;
#line 593
    s2 ++;
#line 593
    c2 = (ngx_uint_t )*tmp___0;
#line 595
    if (c1 >= 65UL) {
#line 595
      if (c1 <= 90UL) {
#line 595
        c1 |= 32UL;
      } else {
#line 595
        c1 = c1;
      }
    } else {
#line 595
      c1 = c1;
    }
#line 596
    if (c2 >= 65UL) {
#line 596
      if (c2 <= 90UL) {
#line 596
        c2 |= 32UL;
      } else {
#line 596
        c2 = c2;
      }
    } else {
#line 596
      c2 = c2;
    }
#line 598
    if (c1 == c2) {
#line 600
      if (c1) {
#line 601
        goto __Cont;
      }
#line 604
      return ((ngx_int_t )0);
    }
#line 607
    return ((ngx_int_t )(c1 - c2));
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 612 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_strncasecmp(u_char *s1 , u_char *s2 , size_t n ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 617
  while (1) {
    while_continue: /* CIL Label */ ;
#line 617
    if (! n) {
#line 617
      goto while_break;
    }
#line 618
    tmp = s1;
#line 618
    s1 ++;
#line 618
    c1 = (ngx_uint_t )*tmp;
#line 619
    tmp___0 = s2;
#line 619
    s2 ++;
#line 619
    c2 = (ngx_uint_t )*tmp___0;
#line 621
    if (c1 >= 65UL) {
#line 621
      if (c1 <= 90UL) {
#line 621
        c1 |= 32UL;
      } else {
#line 621
        c1 = c1;
      }
    } else {
#line 621
      c1 = c1;
    }
#line 622
    if (c2 >= 65UL) {
#line 622
      if (c2 <= 90UL) {
#line 622
        c2 |= 32UL;
      } else {
#line 622
        c2 = c2;
      }
    } else {
#line 622
      c2 = c2;
    }
#line 624
    if (c1 == c2) {
#line 626
      if (c1) {
#line 627
        n --;
#line 628
        goto while_continue;
      }
#line 631
      return ((ngx_int_t )0);
    }
#line 634
    return ((ngx_int_t )(c1 - c2));
  }
  while_break: /* CIL Label */ ;
  }
#line 637
  return ((ngx_int_t )0);
}
}
#line 641 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_strnstr(u_char *s1 , char *s2 , size_t len ) 
{ 
  u_char c1 ;
  u_char c2 ;
  size_t n ;
  char *tmp ;
  size_t tmp___0 ;
  u_char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 647
  tmp = s2;
#line 647
  s2 ++;
#line 647
  c2 = *((u_char *)tmp);
#line 649
  n = strlen((char const   *)s2);
  }
  {
#line 651
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 652
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 653
      tmp___0 = len;
#line 653
      len --;
#line 653
      if (tmp___0 == 0UL) {
#line 654
        return ((u_char *)((void *)0));
      }
#line 657
      tmp___1 = s1;
#line 657
      s1 ++;
#line 657
      c1 = *tmp___1;
#line 659
      if ((int )c1 == 0) {
#line 660
        return ((u_char *)((void *)0));
      }
#line 652
      if (! ((int )c1 != (int )c2)) {
#line 652
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 665
    if (n > len) {
#line 666
      return ((u_char *)((void *)0));
    }
    {
#line 651
    tmp___2 = strncmp((char const   *)s1, (char const   *)((u_char *)s2), n);
    }
#line 651
    if (! (tmp___2 != 0)) {
#line 651
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 671
  s1 --;
#line 671
  return (s1);
}
}
#line 681 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_strstrn(u_char *s1 , char *s2 , size_t n ) 
{ 
  u_char c1 ;
  u_char c2 ;
  char *tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;

  {
#line 686
  tmp = s2;
#line 686
  s2 ++;
#line 686
  c2 = *((u_char *)tmp);
  {
#line 688
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 689
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 690
      tmp___0 = s1;
#line 690
      s1 ++;
#line 690
      c1 = *tmp___0;
#line 692
      if ((int )c1 == 0) {
#line 693
        return ((u_char *)((void *)0));
      }
#line 689
      if (! ((int )c1 != (int )c2)) {
#line 689
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 688
    tmp___1 = strncmp((char const   *)s1, (char const   *)((u_char *)s2), n);
    }
#line 688
    if (! (tmp___1 != 0)) {
#line 688
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 700
  s1 --;
#line 700
  return (s1);
}
}
#line 704 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_strcasestrn(u_char *s1 , char *s2 , size_t n ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  char *tmp ;
  u_char *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 709
  tmp = s2;
#line 709
  s2 ++;
#line 709
  c2 = (ngx_uint_t )*tmp;
#line 710
  if (c2 >= 65UL) {
#line 710
    if (c2 <= 90UL) {
#line 710
      c2 |= 32UL;
    } else {
#line 710
      c2 = c2;
    }
  } else {
#line 710
    c2 = c2;
  }
  {
#line 712
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 713
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 714
      tmp___0 = s1;
#line 714
      s1 ++;
#line 714
      c1 = (ngx_uint_t )*tmp___0;
#line 716
      if (c1 == 0UL) {
#line 717
        return ((u_char *)((void *)0));
      }
#line 720
      if (c1 >= 65UL) {
#line 720
        if (c1 <= 90UL) {
#line 720
          c1 |= 32UL;
        } else {
#line 720
          c1 = c1;
        }
      } else {
#line 720
        c1 = c1;
      }
#line 713
      if (! (c1 != c2)) {
#line 713
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 712
    tmp___1 = ngx_strncasecmp(s1, (u_char *)s2, n);
    }
#line 712
    if (! (tmp___1 != 0L)) {
#line 712
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 726
  s1 --;
#line 726
  return (s1);
}
}
#line 736 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_strlcasestrn(u_char *s1 , u_char *last , u_char *s2 , size_t n ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;
  ngx_int_t tmp___1 ;

  {
#line 741
  tmp = s2;
#line 741
  s2 ++;
#line 741
  c2 = (ngx_uint_t )*tmp;
#line 742
  if (c2 >= 65UL) {
#line 742
    if (c2 <= 90UL) {
#line 742
      c2 |= 32UL;
    } else {
#line 742
      c2 = c2;
    }
  } else {
#line 742
    c2 = c2;
  }
#line 743
  last -= n;
  {
#line 745
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 746
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 747
      if ((unsigned long )s1 >= (unsigned long )last) {
#line 748
        return ((u_char *)((void *)0));
      }
#line 751
      tmp___0 = s1;
#line 751
      s1 ++;
#line 751
      c1 = (ngx_uint_t )*tmp___0;
#line 753
      if (c1 >= 65UL) {
#line 753
        if (c1 <= 90UL) {
#line 753
          c1 |= 32UL;
        } else {
#line 753
          c1 = c1;
        }
      } else {
#line 753
        c1 = c1;
      }
#line 746
      if (! (c1 != c2)) {
#line 746
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 745
    tmp___1 = ngx_strncasecmp(s1, s2, n);
    }
#line 745
    if (! (tmp___1 != 0L)) {
#line 745
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 759
  s1 --;
#line 759
  return (s1);
}
}
#line 763 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_rstrncmp(u_char *s1 , u_char *s2 , size_t n ) 
{ 


  {
#line 766
  if (n == 0UL) {
#line 767
    return ((ngx_int_t )0);
  }
#line 770
  n --;
  {
#line 772
  while (1) {
    while_continue: /* CIL Label */ ;
#line 773
    if ((int )*(s1 + n) != (int )*(s2 + n)) {
#line 774
      return ((ngx_int_t )((int )*(s1 + n) - (int )*(s2 + n)));
    }
#line 777
    if (n == 0UL) {
#line 778
      return ((ngx_int_t )0);
    }
#line 781
    n --;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 786 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_rstrncasecmp(u_char *s1 , u_char *s2 , size_t n ) 
{ 
  u_char c1 ;
  u_char c2 ;

  {
#line 791
  if (n == 0UL) {
#line 792
    return ((ngx_int_t )0);
  }
#line 795
  n --;
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    c1 = *(s1 + n);
#line 799
    if ((int )c1 >= 97) {
#line 799
      if ((int )c1 <= 122) {
#line 800
        c1 = (u_char )((int )c1 - 32);
      }
    }
#line 803
    c2 = *(s2 + n);
#line 804
    if ((int )c2 >= 97) {
#line 804
      if ((int )c2 <= 122) {
#line 805
        c2 = (u_char )((int )c2 - 32);
      }
    }
#line 808
    if ((int )c1 != (int )c2) {
#line 809
      return ((ngx_int_t )((int )c1 - (int )c2));
    }
#line 812
    if (n == 0UL) {
#line 813
      return ((ngx_int_t )0);
    }
#line 816
    n --;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 821 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_memn2cmp(u_char *s1 , u_char *s2 , size_t n1 , size_t n2 ) 
{ 
  size_t n ;
  ngx_int_t m ;
  ngx_int_t z ;
  int tmp ;

  {
#line 827
  if (n1 <= n2) {
#line 828
    n = n1;
#line 829
    z = (ngx_int_t )-1;
  } else {
#line 832
    n = n2;
#line 833
    z = (ngx_int_t )1;
  }
  {
#line 836
  tmp = memcmp((void const   *)((char const   *)s1), (void const   *)((char const   *)s2),
               n);
#line 836
  m = (ngx_int_t )tmp;
  }
#line 838
  if (m) {
#line 839
    return (m);
  } else
#line 838
  if (n1 == n2) {
#line 839
    return (m);
  }
#line 842
  return (z);
}
}
#line 846 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_dns_strcmp(u_char *s1 , u_char *s2 ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 851
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    tmp = s1;
#line 852
    s1 ++;
#line 852
    c1 = (ngx_uint_t )*tmp;
#line 853
    tmp___0 = s2;
#line 853
    s2 ++;
#line 853
    c2 = (ngx_uint_t )*tmp___0;
#line 855
    if (c1 >= 65UL) {
#line 855
      if (c1 <= 90UL) {
#line 855
        c1 |= 32UL;
      } else {
#line 855
        c1 = c1;
      }
    } else {
#line 855
      c1 = c1;
    }
#line 856
    if (c2 >= 65UL) {
#line 856
      if (c2 <= 90UL) {
#line 856
        c2 |= 32UL;
      } else {
#line 856
        c2 = c2;
      }
    } else {
#line 856
      c2 = c2;
    }
#line 858
    if (c1 == c2) {
#line 860
      if (c1) {
#line 861
        goto __Cont;
      }
#line 864
      return ((ngx_int_t )0);
    }
#line 869
    if (c1 == 46UL) {
#line 869
      c1 = (ngx_uint_t )' ';
    } else {
#line 869
      c1 = c1;
    }
#line 870
    if (c2 == 46UL) {
#line 870
      c2 = (ngx_uint_t )' ';
    } else {
#line 870
      c2 = c2;
    }
#line 872
    return ((ngx_int_t )(c1 - c2));
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 877 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_filename_cmp(u_char *s1 , u_char *s2 , size_t n ) 
{ 
  ngx_uint_t c1 ;
  ngx_uint_t c2 ;
  u_char *tmp ;
  u_char *tmp___0 ;

  {
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! n) {
#line 882
      goto while_break;
    }
#line 883
    tmp = s1;
#line 883
    s1 ++;
#line 883
    c1 = (ngx_uint_t )*tmp;
#line 884
    tmp___0 = s2;
#line 884
    s2 ++;
#line 884
    c2 = (ngx_uint_t )*tmp___0;
#line 891
    if (c1 == c2) {
#line 893
      if (c1) {
#line 894
        n --;
#line 895
        goto while_continue;
      }
#line 898
      return ((ngx_int_t )0);
    }
#line 903
    if (c1 == 0UL) {
#line 904
      return ((ngx_int_t )(c1 - c2));
    } else
#line 903
    if (c2 == 0UL) {
#line 904
      return ((ngx_int_t )(c1 - c2));
    }
#line 907
    if (c1 == 47UL) {
#line 907
      c1 = (ngx_uint_t )0;
    } else {
#line 907
      c1 = c1;
    }
#line 908
    if (c2 == 47UL) {
#line 908
      c2 = (ngx_uint_t )0;
    } else {
#line 908
      c2 = c2;
    }
#line 910
    return ((ngx_int_t )(c1 - c2));
  }
  while_break: /* CIL Label */ ;
  }
#line 913
  return ((ngx_int_t )0);
}
}
#line 917 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_atoi(u_char *line , size_t n ) 
{ 
  ngx_int_t value ;
  ngx_int_t cutoff ;
  ngx_int_t cutlim ;
  size_t tmp ;

  {
#line 922
  if (n == 0UL) {
#line 923
    return ((ngx_int_t )-1);
  }
#line 926
  cutoff = 922337203685477580L;
#line 927
  cutlim = 7L;
#line 929
  value = (ngx_int_t )0;
  {
#line 929
  while (1) {
    while_continue: /* CIL Label */ ;
#line 929
    tmp = n;
#line 929
    n --;
#line 929
    if (! tmp) {
#line 929
      goto while_break;
    }
#line 930
    if ((int )*line < 48) {
#line 931
      return ((ngx_int_t )-1);
    } else
#line 930
    if ((int )*line > 57) {
#line 931
      return ((ngx_int_t )-1);
    }
#line 934
    if (value >= cutoff) {
#line 934
      if (value > cutoff) {
#line 935
        return ((ngx_int_t )-1);
      } else
#line 934
      if ((ngx_int_t )((int )*line - 48) > cutlim) {
#line 935
        return ((ngx_int_t )-1);
      }
    }
#line 938
    value = value * 10L + (ngx_int_t )((int )*line - 48);
#line 929
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 941
  return (value);
}
}
#line 947 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_atofp(u_char *line , size_t n , size_t point ) 
{ 
  ngx_int_t value ;
  ngx_int_t cutoff ;
  ngx_int_t cutlim ;
  ngx_uint_t dot ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 953
  if (n == 0UL) {
#line 954
    return ((ngx_int_t )-1);
  }
#line 957
  cutoff = 922337203685477580L;
#line 958
  cutlim = 7L;
#line 960
  dot = (ngx_uint_t )0;
#line 962
  value = (ngx_int_t )0;
  {
#line 962
  while (1) {
    while_continue: /* CIL Label */ ;
#line 962
    tmp = n;
#line 962
    n --;
#line 962
    if (! tmp) {
#line 962
      goto while_break;
    }
#line 964
    if (point == 0UL) {
#line 965
      return ((ngx_int_t )-1);
    }
#line 968
    if ((int )*line == 46) {
#line 969
      if (dot) {
#line 970
        return ((ngx_int_t )-1);
      }
#line 973
      dot = (ngx_uint_t )1;
#line 974
      goto __Cont;
    }
#line 977
    if ((int )*line < 48) {
#line 978
      return ((ngx_int_t )-1);
    } else
#line 977
    if ((int )*line > 57) {
#line 978
      return ((ngx_int_t )-1);
    }
#line 981
    if (value >= cutoff) {
#line 981
      if (value > cutoff) {
#line 982
        return ((ngx_int_t )-1);
      } else
#line 981
      if ((ngx_int_t )((int )*line - 48) > cutlim) {
#line 982
        return ((ngx_int_t )-1);
      }
    }
#line 985
    value = value * 10L + (ngx_int_t )((int )*line - 48);
#line 986
    point -= dot;
    __Cont: /* CIL Label */ 
#line 962
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 989
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 989
    tmp___0 = point;
#line 989
    point --;
#line 989
    if (! tmp___0) {
#line 989
      goto while_break___0;
    }
#line 990
    if (value > cutoff) {
#line 991
      return ((ngx_int_t )-1);
    }
#line 994
    value *= 10L;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 997
  return (value);
}
}
#line 1001 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ssize_t ngx_atosz(u_char *line , size_t n ) 
{ 
  ssize_t value ;
  ssize_t cutoff ;
  ssize_t cutlim ;
  size_t tmp ;

  {
#line 1006
  if (n == 0UL) {
#line 1007
    return ((ssize_t )-1);
  }
#line 1010
  cutoff = (ssize_t )922337203685477580LL;
#line 1011
  cutlim = (ssize_t )7LL;
#line 1013
  value = (ssize_t )0;
  {
#line 1013
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1013
    tmp = n;
#line 1013
    n --;
#line 1013
    if (! tmp) {
#line 1013
      goto while_break;
    }
#line 1014
    if ((int )*line < 48) {
#line 1015
      return ((ssize_t )-1);
    } else
#line 1014
    if ((int )*line > 57) {
#line 1015
      return ((ssize_t )-1);
    }
#line 1018
    if (value >= cutoff) {
#line 1018
      if (value > cutoff) {
#line 1019
        return ((ssize_t )-1);
      } else
#line 1018
      if ((ssize_t )((int )*line - 48) > cutlim) {
#line 1019
        return ((ssize_t )-1);
      }
    }
#line 1022
    value = value * 10L + (ssize_t )((int )*line - 48);
#line 1013
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1025
  return (value);
}
}
#line 1029 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
off_t ngx_atoof(u_char *line , size_t n ) 
{ 
  off_t value ;
  off_t cutoff ;
  off_t cutlim ;
  size_t tmp ;

  {
#line 1034
  if (n == 0UL) {
#line 1035
    return ((off_t )-1);
  }
#line 1038
  cutoff = (off_t )922337203685477580LL;
#line 1039
  cutlim = (off_t )7LL;
#line 1041
  value = (off_t )0;
  {
#line 1041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1041
    tmp = n;
#line 1041
    n --;
#line 1041
    if (! tmp) {
#line 1041
      goto while_break;
    }
#line 1042
    if ((int )*line < 48) {
#line 1043
      return ((off_t )-1);
    } else
#line 1042
    if ((int )*line > 57) {
#line 1043
      return ((off_t )-1);
    }
#line 1046
    if (value >= cutoff) {
#line 1046
      if (value > cutoff) {
#line 1047
        return ((off_t )-1);
      } else
#line 1046
      if ((off_t )((int )*line - 48) > cutlim) {
#line 1047
        return ((off_t )-1);
      }
    }
#line 1050
    value = value * 10L + (off_t )((int )*line - 48);
#line 1041
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1053
  return (value);
}
}
#line 1057 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
time_t ngx_atotm(u_char *line , size_t n ) 
{ 
  time_t value ;
  time_t cutoff ;
  time_t cutlim ;
  size_t tmp ;

  {
#line 1062
  if (n == 0UL) {
#line 1063
    return ((time_t )-1);
  }
#line 1066
  cutoff = (time_t )922337203685477580LL;
#line 1067
  cutlim = (time_t )7LL;
#line 1069
  value = (time_t )0;
  {
#line 1069
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1069
    tmp = n;
#line 1069
    n --;
#line 1069
    if (! tmp) {
#line 1069
      goto while_break;
    }
#line 1070
    if ((int )*line < 48) {
#line 1071
      return ((time_t )-1);
    } else
#line 1070
    if ((int )*line > 57) {
#line 1071
      return ((time_t )-1);
    }
#line 1074
    if (value >= cutoff) {
#line 1074
      if (value > cutoff) {
#line 1075
        return ((time_t )-1);
      } else
#line 1074
      if ((time_t )((int )*line - 48) > cutlim) {
#line 1075
        return ((time_t )-1);
      }
    }
#line 1078
    value = value * 10L + (time_t )((int )*line - 48);
#line 1069
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1081
  return (value);
}
}
#line 1085 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_hextoi(u_char *line , size_t n ) 
{ 
  u_char c ;
  u_char ch ;
  ngx_int_t value ;
  ngx_int_t cutoff ;
  size_t tmp ;

  {
#line 1091
  if (n == 0UL) {
#line 1092
    return ((ngx_int_t )-1);
  }
#line 1095
  cutoff = 576460752303423487L;
#line 1097
  value = (ngx_int_t )0;
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1097
    tmp = n;
#line 1097
    n --;
#line 1097
    if (! tmp) {
#line 1097
      goto while_break;
    }
#line 1098
    if (value > cutoff) {
#line 1099
      return ((ngx_int_t )-1);
    }
#line 1102
    ch = *line;
#line 1104
    if ((int )ch >= 48) {
#line 1104
      if ((int )ch <= 57) {
#line 1105
        value = value * 16L + (ngx_int_t )((int )ch - 48);
#line 1106
        goto __Cont;
      }
    }
#line 1109
    c = (u_char )((int )ch | 32);
#line 1111
    if ((int )c >= 97) {
#line 1111
      if ((int )c <= 102) {
#line 1112
        value = value * 16L + (ngx_int_t )(((int )c - 97) + 10);
#line 1113
        goto __Cont;
      }
    }
#line 1116
    return ((ngx_int_t )-1);
    __Cont: /* CIL Label */ 
#line 1097
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1119
  return (value);
}
}
#line 1126 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char hex___1[17]  = 
#line 1126
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'\000'};
#line 1123 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_hex_dump(u_char *dst , u_char *src , size_t len ) 
{ 
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 1128
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1128
    tmp___2 = len;
#line 1128
    len --;
#line 1128
    if (! tmp___2) {
#line 1128
      goto while_break;
    }
#line 1129
    tmp = dst;
#line 1129
    dst ++;
#line 1129
    *tmp = hex___1[(int )*src >> 4];
#line 1130
    tmp___0 = dst;
#line 1130
    dst ++;
#line 1130
    tmp___1 = src;
#line 1130
    src ++;
#line 1130
    *tmp___0 = hex___1[(int )*tmp___1 & 15];
  }
  while_break: /* CIL Label */ ;
  }
#line 1133
  return (dst);
}
}
#line 1140 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char basis64[65]  = 
#line 1140
  {      (u_char )'A',      (u_char )'B',      (u_char )'C',      (u_char )'D', 
        (u_char )'E',      (u_char )'F',      (u_char )'G',      (u_char )'H', 
        (u_char )'I',      (u_char )'J',      (u_char )'K',      (u_char )'L', 
        (u_char )'M',      (u_char )'N',      (u_char )'O',      (u_char )'P', 
        (u_char )'Q',      (u_char )'R',      (u_char )'S',      (u_char )'T', 
        (u_char )'U',      (u_char )'V',      (u_char )'W',      (u_char )'X', 
        (u_char )'Y',      (u_char )'Z',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'g',      (u_char )'h',      (u_char )'i',      (u_char )'j', 
        (u_char )'k',      (u_char )'l',      (u_char )'m',      (u_char )'n', 
        (u_char )'o',      (u_char )'p',      (u_char )'q',      (u_char )'r', 
        (u_char )'s',      (u_char )'t',      (u_char )'u',      (u_char )'v', 
        (u_char )'w',      (u_char )'x',      (u_char )'y',      (u_char )'z', 
        (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'+',      (u_char )'/', 
        (u_char )'\000'};
#line 1137 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
void ngx_encode_base64(ngx_str_t *dst , ngx_str_t *src ) 
{ 


  {
  {
#line 1143
  ngx_encode_base64_internal(dst, src, (u_char const   *)(basis64), (ngx_uint_t )1);
  }
#line 1144
  return;
}
}
#line 1150 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char basis64___0[65]  = 
#line 1150
  {      (u_char )'A',      (u_char )'B',      (u_char )'C',      (u_char )'D', 
        (u_char )'E',      (u_char )'F',      (u_char )'G',      (u_char )'H', 
        (u_char )'I',      (u_char )'J',      (u_char )'K',      (u_char )'L', 
        (u_char )'M',      (u_char )'N',      (u_char )'O',      (u_char )'P', 
        (u_char )'Q',      (u_char )'R',      (u_char )'S',      (u_char )'T', 
        (u_char )'U',      (u_char )'V',      (u_char )'W',      (u_char )'X', 
        (u_char )'Y',      (u_char )'Z',      (u_char )'a',      (u_char )'b', 
        (u_char )'c',      (u_char )'d',      (u_char )'e',      (u_char )'f', 
        (u_char )'g',      (u_char )'h',      (u_char )'i',      (u_char )'j', 
        (u_char )'k',      (u_char )'l',      (u_char )'m',      (u_char )'n', 
        (u_char )'o',      (u_char )'p',      (u_char )'q',      (u_char )'r', 
        (u_char )'s',      (u_char )'t',      (u_char )'u',      (u_char )'v', 
        (u_char )'w',      (u_char )'x',      (u_char )'y',      (u_char )'z', 
        (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'-',      (u_char )'_', 
        (u_char )'\000'};
#line 1147 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
void ngx_encode_base64url(ngx_str_t *dst , ngx_str_t *src ) 
{ 


  {
  {
#line 1153
  ngx_encode_base64_internal(dst, src, (u_char const   *)(basis64___0), (ngx_uint_t )0);
  }
#line 1154
  return;
}
}
#line 1157 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static void ngx_encode_base64_internal(ngx_str_t *dst , ngx_str_t *src , u_char const   *basis ,
                                       ngx_uint_t padding ) 
{ 
  u_char *d ;
  u_char *s ;
  size_t len ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;

  {
#line 1164
  len = src->len;
#line 1165
  s = src->data;
#line 1166
  d = dst->data;
  {
#line 1168
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1168
    if (! (len > 2UL)) {
#line 1168
      goto while_break;
    }
#line 1169
    tmp = d;
#line 1169
    d ++;
#line 1169
    *tmp = (u_char )*(basis + (((int )*(s + 0) >> 2) & 63));
#line 1170
    tmp___0 = d;
#line 1170
    d ++;
#line 1170
    *tmp___0 = (u_char )*(basis + ((((int )*(s + 0) & 3) << 4) | ((int )*(s + 1) >> 4)));
#line 1171
    tmp___1 = d;
#line 1171
    d ++;
#line 1171
    *tmp___1 = (u_char )*(basis + ((((int )*(s + 1) & 15) << 2) | ((int )*(s + 2) >> 6)));
#line 1172
    tmp___2 = d;
#line 1172
    d ++;
#line 1172
    *tmp___2 = (u_char )*(basis + ((int )*(s + 2) & 63));
#line 1174
    s += 3;
#line 1175
    len -= 3UL;
  }
  while_break: /* CIL Label */ ;
  }
#line 1178
  if (len) {
#line 1179
    tmp___3 = d;
#line 1179
    d ++;
#line 1179
    *tmp___3 = (u_char )*(basis + (((int )*(s + 0) >> 2) & 63));
#line 1181
    if (len == 1UL) {
#line 1182
      tmp___4 = d;
#line 1182
      d ++;
#line 1182
      *tmp___4 = (u_char )*(basis + (((int )*(s + 0) & 3) << 4));
#line 1183
      if (padding) {
#line 1184
        tmp___5 = d;
#line 1184
        d ++;
#line 1184
        *tmp___5 = (u_char )'=';
      }
    } else {
#line 1188
      tmp___6 = d;
#line 1188
      d ++;
#line 1188
      *tmp___6 = (u_char )*(basis + ((((int )*(s + 0) & 3) << 4) | ((int )*(s + 1) >> 4)));
#line 1189
      tmp___7 = d;
#line 1189
      d ++;
#line 1189
      *tmp___7 = (u_char )*(basis + (((int )*(s + 1) & 15) << 2));
    }
#line 1192
    if (padding) {
#line 1193
      tmp___8 = d;
#line 1193
      d ++;
#line 1193
      *tmp___8 = (u_char )'=';
    }
  }
#line 1197
  dst->len = (size_t )(d - dst->data);
#line 1198
  return;
}
}
#line 1204 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char basis64___1[256]  = 
#line 1204
  {      (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )62, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )63, 
        (u_char )52,      (u_char )53,      (u_char )54,      (u_char )55, 
        (u_char )56,      (u_char )57,      (u_char )58,      (u_char )59, 
        (u_char )60,      (u_char )61,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )0,      (u_char )1,      (u_char )2, 
        (u_char )3,      (u_char )4,      (u_char )5,      (u_char )6, 
        (u_char )7,      (u_char )8,      (u_char )9,      (u_char )10, 
        (u_char )11,      (u_char )12,      (u_char )13,      (u_char )14, 
        (u_char )15,      (u_char )16,      (u_char )17,      (u_char )18, 
        (u_char )19,      (u_char )20,      (u_char )21,      (u_char )22, 
        (u_char )23,      (u_char )24,      (u_char )25,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )26,      (u_char )27,      (u_char )28, 
        (u_char )29,      (u_char )30,      (u_char )31,      (u_char )32, 
        (u_char )33,      (u_char )34,      (u_char )35,      (u_char )36, 
        (u_char )37,      (u_char )38,      (u_char )39,      (u_char )40, 
        (u_char )41,      (u_char )42,      (u_char )43,      (u_char )44, 
        (u_char )45,      (u_char )46,      (u_char )47,      (u_char )48, 
        (u_char )49,      (u_char )50,      (u_char )51,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77};
#line 1201 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_decode_base64(ngx_str_t *dst , ngx_str_t *src ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 1224
  tmp = ngx_decode_base64_internal(dst, src, (u_char const   *)(basis64___1));
  }
#line 1224
  return (tmp);
}
}
#line 1231 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char basis64___2[256]  = 
#line 1231
  {      (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )62,      (u_char )77,      (u_char )77, 
        (u_char )52,      (u_char )53,      (u_char )54,      (u_char )55, 
        (u_char )56,      (u_char )57,      (u_char )58,      (u_char )59, 
        (u_char )60,      (u_char )61,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )0,      (u_char )1,      (u_char )2, 
        (u_char )3,      (u_char )4,      (u_char )5,      (u_char )6, 
        (u_char )7,      (u_char )8,      (u_char )9,      (u_char )10, 
        (u_char )11,      (u_char )12,      (u_char )13,      (u_char )14, 
        (u_char )15,      (u_char )16,      (u_char )17,      (u_char )18, 
        (u_char )19,      (u_char )20,      (u_char )21,      (u_char )22, 
        (u_char )23,      (u_char )24,      (u_char )25,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )63, 
        (u_char )77,      (u_char )26,      (u_char )27,      (u_char )28, 
        (u_char )29,      (u_char )30,      (u_char )31,      (u_char )32, 
        (u_char )33,      (u_char )34,      (u_char )35,      (u_char )36, 
        (u_char )37,      (u_char )38,      (u_char )39,      (u_char )40, 
        (u_char )41,      (u_char )42,      (u_char )43,      (u_char )44, 
        (u_char )45,      (u_char )46,      (u_char )47,      (u_char )48, 
        (u_char )49,      (u_char )50,      (u_char )51,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77, 
        (u_char )77,      (u_char )77,      (u_char )77,      (u_char )77};
#line 1228 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_int_t ngx_decode_base64url(ngx_str_t *dst , ngx_str_t *src ) 
{ 
  ngx_int_t tmp ;

  {
  {
#line 1251
  tmp = ngx_decode_base64_internal(dst, src, (u_char const   *)(basis64___2));
  }
#line 1251
  return (tmp);
}
}
#line 1255 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static ngx_int_t ngx_decode_base64_internal(ngx_str_t *dst , ngx_str_t *src , u_char const   *basis ) 
{ 
  size_t len ;
  u_char *d ;
  u_char *s ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;

  {
#line 1261
  len = (size_t )0;
  {
#line 1261
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1261
    if (! (len < src->len)) {
#line 1261
      goto while_break;
    }
#line 1262
    if ((int )*(src->data + len) == 61) {
#line 1263
      goto while_break;
    }
#line 1266
    if ((int const   )*(basis + *(src->data + len)) == 77) {
#line 1267
      return ((ngx_int_t )-1);
    }
#line 1261
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1271
  if (len % 4UL == 1UL) {
#line 1272
    return ((ngx_int_t )-1);
  }
#line 1275
  s = src->data;
#line 1276
  d = dst->data;
  {
#line 1278
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1278
    if (! (len > 3UL)) {
#line 1278
      goto while_break___0;
    }
#line 1279
    tmp = d;
#line 1279
    d ++;
#line 1279
    *tmp = (u_char )(((int const   )*(basis + *(s + 0)) << 2) | ((int const   )*(basis + *(s + 1)) >> 4));
#line 1280
    tmp___0 = d;
#line 1280
    d ++;
#line 1280
    *tmp___0 = (u_char )(((int const   )*(basis + *(s + 1)) << 4) | ((int const   )*(basis + *(s + 2)) >> 2));
#line 1281
    tmp___1 = d;
#line 1281
    d ++;
#line 1281
    *tmp___1 = (u_char )(((int const   )*(basis + *(s + 2)) << 6) | (int const   )*(basis + *(s + 3)));
#line 1283
    s += 4;
#line 1284
    len -= 4UL;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1287
  if (len > 1UL) {
#line 1288
    tmp___2 = d;
#line 1288
    d ++;
#line 1288
    *tmp___2 = (u_char )(((int const   )*(basis + *(s + 0)) << 2) | ((int const   )*(basis + *(s + 1)) >> 4));
  }
#line 1291
  if (len > 2UL) {
#line 1292
    tmp___3 = d;
#line 1292
    d ++;
#line 1292
    *tmp___3 = (u_char )(((int const   )*(basis + *(s + 1)) << 4) | ((int const   )*(basis + *(s + 2)) >> 2));
  }
#line 1295
  dst->len = (size_t )(d - dst->data);
#line 1297
  return ((ngx_int_t )0);
}
}
#line 1310 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
uint32_t ngx_utf8_decode(u_char **p , size_t n ) 
{ 
  size_t len ;
  uint32_t u ;
  uint32_t i ;
  uint32_t valid ;
  u_char *tmp ;

  {
#line 1316
  u = (uint32_t )*(*p);
#line 1318
  if (u >= 240U) {
#line 1320
    u &= 7U;
#line 1321
    valid = (uint32_t )65535;
#line 1322
    len = (size_t )3;
  } else
#line 1324
  if (u >= 224U) {
#line 1326
    u &= 15U;
#line 1327
    valid = (uint32_t )2047;
#line 1328
    len = (size_t )2;
  } else
#line 1330
  if (u >= 194U) {
#line 1332
    u &= 31U;
#line 1333
    valid = (uint32_t )127;
#line 1334
    len = (size_t )1;
  } else {
#line 1337
    (*p) ++;
#line 1338
    return (4294967295U);
  }
#line 1341
  if (n - 1UL < len) {
#line 1342
    return (4294967294U);
  }
#line 1345
  (*p) ++;
  {
#line 1347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1347
    if (! len) {
#line 1347
      goto while_break;
    }
#line 1348
    tmp = *p;
#line 1348
    (*p) ++;
#line 1348
    i = (uint32_t )*tmp;
#line 1350
    if (i < 128U) {
#line 1351
      return (4294967295U);
    }
#line 1354
    u = (u << 6) | (i & 63U);
#line 1356
    len --;
  }
  while_break: /* CIL Label */ ;
  }
#line 1359
  if (u > valid) {
#line 1360
    return (u);
  }
#line 1363
  return (4294967295U);
}
}
#line 1367 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
size_t ngx_utf8_length(u_char *p , size_t n ) 
{ 
  u_char c ;
  u_char *last ;
  size_t len ;
  uint32_t tmp ;

  {
#line 1373
  last = p + n;
#line 1375
  len = (size_t )0;
  {
#line 1375
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1375
    if (! ((unsigned long )p < (unsigned long )last)) {
#line 1375
      goto while_break;
    }
#line 1377
    c = *p;
#line 1379
    if ((int )c < 128) {
#line 1380
      p ++;
#line 1381
      goto __Cont;
    }
    {
#line 1384
    tmp = ngx_utf8_decode(& p, n);
    }
#line 1384
    if (tmp > 1114111U) {
#line 1386
      return (n);
    }
    __Cont: /* CIL Label */ 
#line 1375
    len ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1390
  return (len);
}
}
#line 1394 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
u_char *ngx_utf8_cpystrn(u_char *dst , u_char *src , size_t n , size_t len ) 
{ 
  u_char c ;
  u_char *next ;
  uint32_t tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;

  {
#line 1399
  if (n == 0UL) {
#line 1400
    return (dst);
  }
  {
#line 1403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1403
    n --;
#line 1403
    if (! n) {
#line 1403
      goto while_break;
    }
#line 1405
    c = *src;
#line 1406
    *dst = c;
#line 1408
    if ((int )c < 128) {
#line 1410
      if ((int )c != 0) {
#line 1411
        dst ++;
#line 1412
        src ++;
#line 1413
        len --;
#line 1415
        goto while_continue;
      }
#line 1418
      return (dst);
    }
    {
#line 1421
    next = src;
#line 1423
    tmp = ngx_utf8_decode(& next, len);
    }
#line 1423
    if (tmp > 1114111U) {
#line 1425
      goto while_break;
    }
    {
#line 1428
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1428
      if (! ((unsigned long )src < (unsigned long )next)) {
#line 1428
        goto while_break___0;
      }
#line 1429
      tmp___0 = dst;
#line 1429
      dst ++;
#line 1429
      tmp___1 = src;
#line 1429
      src ++;
#line 1429
      *tmp___0 = *tmp___1;
#line 1430
      len --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1434
  *dst = (u_char )'\000';
#line 1436
  return (dst);
}
}
#line 1445 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static u_char hex___2[17]  = 
#line 1445
  {      (u_char )'0',      (u_char )'1',      (u_char )'2',      (u_char )'3', 
        (u_char )'4',      (u_char )'5',      (u_char )'6',      (u_char )'7', 
        (u_char )'8',      (u_char )'9',      (u_char )'A',      (u_char )'B', 
        (u_char )'C',      (u_char )'D',      (u_char )'E',      (u_char )'F', 
        (u_char )'\000'};
#line 1449 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static uint32_t uri[8]  = 
#line 1449
  {      4294967295U,      2147483689U,      (uint32_t )0,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1469 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static uint32_t args[8]  = 
#line 1469
  {      4294967295U,      2281703529U,      (uint32_t )0,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1489 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static uint32_t uri_component[8]  = 
#line 1489
  {      4294967295U,      4227899391U,      (uint32_t )2013265921,      3087007745U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1509 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static uint32_t html[8]  = 
#line 1509
  {      4294967295U,      (uint32_t )173,      (uint32_t )0,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1529 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static uint32_t refresh[8]  = 
#line 1529
  {      4294967295U,      (uint32_t )133,      (uint32_t )0,      2147483648U, 
        4294967295U,      4294967295U,      4294967295U,      4294967295U};
#line 1549 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static uint32_t memcached[8]  = 
#line 1549
  {      4294967295U,      (uint32_t )33,      (uint32_t )0,      (uint32_t )0, 
        (uint32_t )0,      (uint32_t )0,      (uint32_t )0,      (uint32_t )0};
#line 1569 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
static uint32_t *map[7]  = {      uri,      args,      uri_component,      html, 
        refresh,      memcached,      memcached};
#line 1440 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
uintptr_t ngx_escape_uri(u_char *dst , u_char *src , size_t size , ngx_uint_t type ) 
{ 
  ngx_uint_t n ;
  uint32_t *escape___0 ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;

  {
#line 1573
  escape___0 = map[type];
#line 1575
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1579
    n = (ngx_uint_t )0;
    {
#line 1581
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1581
      if (! size) {
#line 1581
        goto while_break;
      }
#line 1582
      if (*(escape___0 + ((int )*src >> 5)) & (1U << ((int )*src & 31))) {
#line 1583
        n ++;
      }
#line 1585
      src ++;
#line 1586
      size --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1589
    return (n);
  }
  {
#line 1592
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1592
    if (! size) {
#line 1592
      goto while_break___0;
    }
#line 1593
    if (*(escape___0 + ((int )*src >> 5)) & (1U << ((int )*src & 31))) {
#line 1594
      tmp = dst;
#line 1594
      dst ++;
#line 1594
      *tmp = (u_char )'%';
#line 1595
      tmp___0 = dst;
#line 1595
      dst ++;
#line 1595
      *tmp___0 = hex___2[(int )*src >> 4];
#line 1596
      tmp___1 = dst;
#line 1596
      dst ++;
#line 1596
      *tmp___1 = hex___2[(int )*src & 15];
#line 1597
      src ++;
    } else {
#line 1600
      tmp___2 = dst;
#line 1600
      dst ++;
#line 1600
      tmp___3 = src;
#line 1600
      src ++;
#line 1600
      *tmp___2 = *tmp___3;
    }
#line 1602
    size --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1605
  return ((uintptr_t )dst);
}
}
#line 1609 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
void ngx_unescape_uri(u_char **dst , u_char **src , size_t size , ngx_uint_t type ) 
{ 
  u_char *d ;
  u_char *s ;
  u_char ch ;
  u_char c ;
  u_char decoded ;
  enum __anonenum_state_171 state ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  size_t tmp___16 ;

  {
#line 1619
  d = *dst;
#line 1620
  s = *src;
#line 1622
  state = (enum __anonenum_state_171 )0;
#line 1623
  decoded = (u_char )0;
  {
#line 1625
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1625
    tmp___16 = size;
#line 1625
    size --;
#line 1625
    if (! tmp___16) {
#line 1625
      goto while_break;
    }
#line 1627
    tmp = s;
#line 1627
    s ++;
#line 1627
    ch = *tmp;
    {
#line 1630
    if ((unsigned int )state == 0U) {
#line 1630
      goto case_0;
    }
#line 1646
    if ((unsigned int )state == 1U) {
#line 1646
      goto case_1;
    }
#line 1669
    if ((unsigned int )state == 2U) {
#line 1669
      goto case_2;
    }
#line 1629
    goto switch_break;
    case_0: /* CIL Label */ 
#line 1631
    if ((int )ch == 63) {
#line 1631
      if (type & 3UL) {
#line 1634
        tmp___0 = d;
#line 1634
        d ++;
#line 1634
        *tmp___0 = ch;
#line 1635
        goto done;
      }
    }
#line 1638
    if ((int )ch == 37) {
#line 1639
      state = (enum __anonenum_state_171 )1;
#line 1640
      goto switch_break;
    }
#line 1643
    tmp___1 = d;
#line 1643
    d ++;
#line 1643
    *tmp___1 = ch;
#line 1644
    goto switch_break;
    case_1: /* CIL Label */ 
#line 1648
    if ((int )ch >= 48) {
#line 1648
      if ((int )ch <= 57) {
#line 1649
        decoded = (u_char )((int )ch - 48);
#line 1650
        state = (enum __anonenum_state_171 )2;
#line 1651
        goto switch_break;
      }
    }
#line 1654
    c = (u_char )((int )ch | 32);
#line 1655
    if ((int )c >= 97) {
#line 1655
      if ((int )c <= 102) {
#line 1656
        decoded = (u_char )(((int )c - 97) + 10);
#line 1657
        state = (enum __anonenum_state_171 )2;
#line 1658
        goto switch_break;
      }
    }
#line 1663
    state = (enum __anonenum_state_171 )0;
#line 1665
    tmp___2 = d;
#line 1665
    d ++;
#line 1665
    *tmp___2 = ch;
#line 1667
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1671
    state = (enum __anonenum_state_171 )0;
#line 1673
    if ((int )ch >= 48) {
#line 1673
      if ((int )ch <= 57) {
#line 1674
        ch = (u_char )(((int )decoded << 4) + ((int )ch - 48));
#line 1676
        if (type & 2UL) {
#line 1677
          if ((int )ch > 37) {
#line 1677
            if ((int )ch < 127) {
#line 1678
              tmp___3 = d;
#line 1678
              d ++;
#line 1678
              *tmp___3 = ch;
#line 1679
              goto switch_break;
            }
          }
#line 1682
          tmp___4 = d;
#line 1682
          d ++;
#line 1682
          *tmp___4 = (u_char )'%';
#line 1682
          tmp___5 = d;
#line 1682
          d ++;
#line 1682
          *tmp___5 = *(s - 2);
#line 1682
          tmp___6 = d;
#line 1682
          d ++;
#line 1682
          *tmp___6 = *(s - 1);
#line 1684
          goto switch_break;
        }
#line 1687
        tmp___7 = d;
#line 1687
        d ++;
#line 1687
        *tmp___7 = ch;
#line 1689
        goto switch_break;
      }
    }
#line 1692
    c = (u_char )((int )ch | 32);
#line 1693
    if ((int )c >= 97) {
#line 1693
      if ((int )c <= 102) {
#line 1694
        ch = (u_char )((((int )decoded << 4) + ((int )c - 97)) + 10);
#line 1696
        if (type & 1UL) {
#line 1697
          if ((int )ch == 63) {
#line 1698
            tmp___8 = d;
#line 1698
            d ++;
#line 1698
            *tmp___8 = ch;
#line 1699
            goto done;
          }
#line 1702
          tmp___9 = d;
#line 1702
          d ++;
#line 1702
          *tmp___9 = ch;
#line 1703
          goto switch_break;
        }
#line 1706
        if (type & 2UL) {
#line 1707
          if ((int )ch == 63) {
#line 1708
            tmp___10 = d;
#line 1708
            d ++;
#line 1708
            *tmp___10 = ch;
#line 1709
            goto done;
          }
#line 1712
          if ((int )ch > 37) {
#line 1712
            if ((int )ch < 127) {
#line 1713
              tmp___11 = d;
#line 1713
              d ++;
#line 1713
              *tmp___11 = ch;
#line 1714
              goto switch_break;
            }
          }
#line 1717
          tmp___12 = d;
#line 1717
          d ++;
#line 1717
          *tmp___12 = (u_char )'%';
#line 1717
          tmp___13 = d;
#line 1717
          d ++;
#line 1717
          *tmp___13 = *(s - 2);
#line 1717
          tmp___14 = d;
#line 1717
          d ++;
#line 1717
          *tmp___14 = *(s - 1);
#line 1718
          goto switch_break;
        }
#line 1721
        tmp___15 = d;
#line 1721
        d ++;
#line 1721
        *tmp___15 = ch;
#line 1723
        goto switch_break;
      }
    }
#line 1728
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 1734
  *dst = d;
#line 1735
  *src = s;
#line 1736
  return;
}
}
#line 1739 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
uintptr_t ngx_escape_html(u_char *dst , u_char *src , size_t size ) 
{ 
  u_char ch ;
  ngx_uint_t len ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  u_char *tmp___14 ;
  u_char *tmp___15 ;
  u_char *tmp___16 ;
  u_char *tmp___17 ;
  u_char *tmp___18 ;
  u_char *tmp___19 ;
  u_char *tmp___20 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
#line 1745
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1747
    len = (ngx_uint_t )0;
    {
#line 1749
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1749
      if (! size) {
#line 1749
        goto while_break;
      }
#line 1750
      tmp = src;
#line 1750
      src ++;
      {
#line 1752
      if ((int )*tmp == 60) {
#line 1752
        goto case_60;
      }
#line 1756
      if ((int )*tmp == 62) {
#line 1756
        goto case_62;
      }
#line 1760
      if ((int )*tmp == 38) {
#line 1760
        goto case_38;
      }
#line 1764
      if ((int )*tmp == 34) {
#line 1764
        goto case_34;
      }
#line 1768
      goto switch_default;
      case_60: /* CIL Label */ 
#line 1753
      len += sizeof("&lt;") - 2UL;
#line 1754
      goto switch_break;
      case_62: /* CIL Label */ 
#line 1757
      len += sizeof("&gt;") - 2UL;
#line 1758
      goto switch_break;
      case_38: /* CIL Label */ 
#line 1761
      len += sizeof("&amp;") - 2UL;
#line 1762
      goto switch_break;
      case_34: /* CIL Label */ 
#line 1765
      len += sizeof("&quot;") - 2UL;
#line 1766
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 1769
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 1771
      size --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1774
    return (len);
  }
  {
#line 1777
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1777
    if (! size) {
#line 1777
      goto while_break___0;
    }
#line 1778
    tmp___0 = src;
#line 1778
    src ++;
#line 1778
    ch = *tmp___0;
    {
#line 1782
    if ((int )ch == 60) {
#line 1782
      goto case_60___0;
    }
#line 1786
    if ((int )ch == 62) {
#line 1786
      goto case_62___0;
    }
#line 1790
    if ((int )ch == 38) {
#line 1790
      goto case_38___0;
    }
#line 1795
    if ((int )ch == 34) {
#line 1795
      goto case_34___0;
    }
#line 1800
    goto switch_default___0;
    case_60___0: /* CIL Label */ 
#line 1783
    tmp___1 = dst;
#line 1783
    dst ++;
#line 1783
    *tmp___1 = (u_char )'&';
#line 1783
    tmp___2 = dst;
#line 1783
    dst ++;
#line 1783
    *tmp___2 = (u_char )'l';
#line 1783
    tmp___3 = dst;
#line 1783
    dst ++;
#line 1783
    *tmp___3 = (u_char )'t';
#line 1783
    tmp___4 = dst;
#line 1783
    dst ++;
#line 1783
    *tmp___4 = (u_char )';';
#line 1784
    goto switch_break___0;
    case_62___0: /* CIL Label */ 
#line 1787
    tmp___5 = dst;
#line 1787
    dst ++;
#line 1787
    *tmp___5 = (u_char )'&';
#line 1787
    tmp___6 = dst;
#line 1787
    dst ++;
#line 1787
    *tmp___6 = (u_char )'g';
#line 1787
    tmp___7 = dst;
#line 1787
    dst ++;
#line 1787
    *tmp___7 = (u_char )'t';
#line 1787
    tmp___8 = dst;
#line 1787
    dst ++;
#line 1787
    *tmp___8 = (u_char )';';
#line 1788
    goto switch_break___0;
    case_38___0: /* CIL Label */ 
#line 1791
    tmp___9 = dst;
#line 1791
    dst ++;
#line 1791
    *tmp___9 = (u_char )'&';
#line 1791
    tmp___10 = dst;
#line 1791
    dst ++;
#line 1791
    *tmp___10 = (u_char )'a';
#line 1791
    tmp___11 = dst;
#line 1791
    dst ++;
#line 1791
    *tmp___11 = (u_char )'m';
#line 1791
    tmp___12 = dst;
#line 1791
    dst ++;
#line 1791
    *tmp___12 = (u_char )'p';
#line 1792
    tmp___13 = dst;
#line 1792
    dst ++;
#line 1792
    *tmp___13 = (u_char )';';
#line 1793
    goto switch_break___0;
    case_34___0: /* CIL Label */ 
#line 1796
    tmp___14 = dst;
#line 1796
    dst ++;
#line 1796
    *tmp___14 = (u_char )'&';
#line 1796
    tmp___15 = dst;
#line 1796
    dst ++;
#line 1796
    *tmp___15 = (u_char )'q';
#line 1796
    tmp___16 = dst;
#line 1796
    dst ++;
#line 1796
    *tmp___16 = (u_char )'u';
#line 1796
    tmp___17 = dst;
#line 1796
    dst ++;
#line 1796
    *tmp___17 = (u_char )'o';
#line 1797
    tmp___18 = dst;
#line 1797
    dst ++;
#line 1797
    *tmp___18 = (u_char )'t';
#line 1797
    tmp___19 = dst;
#line 1797
    dst ++;
#line 1797
    *tmp___19 = (u_char )';';
#line 1798
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 1801
    tmp___20 = dst;
#line 1801
    dst ++;
#line 1801
    *tmp___20 = ch;
#line 1802
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
#line 1804
    size --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1807
  return ((uintptr_t )dst);
}
}
#line 1811 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
uintptr_t ngx_escape_json(u_char *dst , u_char *src , size_t size ) 
{ 
  u_char ch ;
  ngx_uint_t len ;
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  u_char *tmp___3 ;
  u_char *tmp___4 ;
  u_char *tmp___5 ;
  u_char *tmp___6 ;
  u_char *tmp___7 ;
  u_char *tmp___8 ;
  u_char *tmp___9 ;
  u_char *tmp___10 ;
  u_char *tmp___11 ;
  u_char *tmp___12 ;
  u_char *tmp___13 ;
  char *__cil_tmp21 ;

  {
#line 1817
  if ((unsigned long )dst == (unsigned long )((void *)0)) {
#line 1818
    len = (ngx_uint_t )0;
    {
#line 1820
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1820
      if (! size) {
#line 1820
        goto while_break;
      }
#line 1821
      tmp = src;
#line 1821
      src ++;
#line 1821
      ch = *tmp;
#line 1823
      if ((int )ch == 92) {
#line 1824
        len ++;
      } else
#line 1823
      if ((int )ch == 34) {
#line 1824
        len ++;
      } else
#line 1826
      if ((int )ch <= 31) {
        {
#line 1833
        if ((int )ch == 12) {
#line 1833
          goto case_12;
        }
#line 1833
        if ((int )ch == 8) {
#line 1833
          goto case_12;
        }
#line 1833
        if ((int )ch == 9) {
#line 1833
          goto case_12;
        }
#line 1833
        if ((int )ch == 13) {
#line 1833
          goto case_12;
        }
#line 1833
        if ((int )ch == 10) {
#line 1833
          goto case_12;
        }
#line 1837
        goto switch_default;
        case_12: /* CIL Label */ 
        case_8: /* CIL Label */ 
        case_9: /* CIL Label */ 
        case_13: /* CIL Label */ 
        case_10: /* CIL Label */ 
#line 1834
        len ++;
#line 1835
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 1838
        len += sizeof("\\u001F") - 2UL;
        switch_break: /* CIL Label */ ;
        }
      }
#line 1842
      size --;
    }
    while_break: /* CIL Label */ ;
    }
#line 1845
    return (len);
  }
  {
#line 1848
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1848
    if (! size) {
#line 1848
      goto while_break___0;
    }
#line 1849
    tmp___0 = src;
#line 1849
    src ++;
#line 1849
    ch = *tmp___0;
#line 1851
    if ((int )ch > 31) {
#line 1853
      if ((int )ch == 92) {
#line 1854
        tmp___1 = dst;
#line 1854
        dst ++;
#line 1854
        *tmp___1 = (u_char )'\\';
      } else
#line 1853
      if ((int )ch == 34) {
#line 1854
        tmp___1 = dst;
#line 1854
        dst ++;
#line 1854
        *tmp___1 = (u_char )'\\';
      }
#line 1857
      tmp___2 = dst;
#line 1857
      dst ++;
#line 1857
      *tmp___2 = ch;
    } else {
#line 1860
      tmp___3 = dst;
#line 1860
      dst ++;
#line 1860
      *tmp___3 = (u_char )'\\';
      {
#line 1863
      if ((int )ch == 10) {
#line 1863
        goto case_10___0;
      }
#line 1867
      if ((int )ch == 13) {
#line 1867
        goto case_13___0;
      }
#line 1871
      if ((int )ch == 9) {
#line 1871
        goto case_9___0;
      }
#line 1875
      if ((int )ch == 8) {
#line 1875
        goto case_8___0;
      }
#line 1879
      if ((int )ch == 12) {
#line 1879
        goto case_12___0;
      }
#line 1883
      goto switch_default___0;
      case_10___0: /* CIL Label */ 
#line 1864
      tmp___4 = dst;
#line 1864
      dst ++;
#line 1864
      *tmp___4 = (u_char )'n';
#line 1865
      goto switch_break___0;
      case_13___0: /* CIL Label */ 
#line 1868
      tmp___5 = dst;
#line 1868
      dst ++;
#line 1868
      *tmp___5 = (u_char )'r';
#line 1869
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
#line 1872
      tmp___6 = dst;
#line 1872
      dst ++;
#line 1872
      *tmp___6 = (u_char )'t';
#line 1873
      goto switch_break___0;
      case_8___0: /* CIL Label */ 
#line 1876
      tmp___7 = dst;
#line 1876
      dst ++;
#line 1876
      *tmp___7 = (u_char )'b';
#line 1877
      goto switch_break___0;
      case_12___0: /* CIL Label */ 
#line 1880
      tmp___8 = dst;
#line 1880
      dst ++;
#line 1880
      *tmp___8 = (u_char )'f';
#line 1881
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
#line 1884
      tmp___9 = dst;
#line 1884
      dst ++;
#line 1884
      *tmp___9 = (u_char )'u';
#line 1884
      tmp___10 = dst;
#line 1884
      dst ++;
#line 1884
      *tmp___10 = (u_char )'0';
#line 1884
      tmp___11 = dst;
#line 1884
      dst ++;
#line 1884
      *tmp___11 = (u_char )'0';
#line 1885
      tmp___12 = dst;
#line 1885
      dst ++;
#line 1885
      *tmp___12 = (u_char )(48 + ((int )ch >> 4));
#line 1887
      ch = (u_char )((int )ch & 15);
#line 1889
      tmp___13 = dst;
#line 1889
      dst ++;
#line 1889
      if ((int )ch < 10) {
#line 1889
        *tmp___13 = (u_char )(48 + (int )ch);
      } else {
#line 1889
        *tmp___13 = (u_char )((65 + (int )ch) - 10);
      }
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1893
    size --;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1896
  return ((uintptr_t )dst);
}
}
#line 1900 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
void ngx_str_rbtree_insert_value(ngx_rbtree_node_t *temp , ngx_rbtree_node_t *node ,
                                 ngx_rbtree_node_t *sentinel ) 
{ 
  ngx_str_node_t *n ;
  ngx_str_node_t *t ;
  ngx_rbtree_node_t **p ;
  int tmp___0 ;

  {
  {
#line 1907
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1909
    n = (ngx_str_node_t *)node;
#line 1910
    t = (ngx_str_node_t *)temp;
#line 1912
    if (node->key != temp->key) {
#line 1914
      if (node->key < temp->key) {
#line 1914
        p = & temp->left;
      } else {
#line 1914
        p = & temp->right;
      }
    } else
#line 1916
    if (n->str.len != t->str.len) {
#line 1918
      if (n->str.len < t->str.len) {
#line 1918
        p = & temp->left;
      } else {
#line 1918
        p = & temp->right;
      }
    } else {
      {
#line 1921
      tmp___0 = memcmp((void const   *)((char const   *)n->str.data), (void const   *)((char const   *)t->str.data),
                       n->str.len);
      }
#line 1921
      if (tmp___0 < 0) {
#line 1921
        p = & temp->left;
      } else {
#line 1921
        p = & temp->right;
      }
    }
#line 1925
    if ((unsigned long )*p == (unsigned long )sentinel) {
#line 1926
      goto while_break;
    }
#line 1929
    temp = *p;
  }
  while_break: /* CIL Label */ ;
  }
#line 1932
  *p = node;
#line 1933
  node->parent = temp;
#line 1934
  node->left = sentinel;
#line 1935
  node->right = sentinel;
#line 1936
  node->color = (u_char )1;
#line 1937
  return;
}
}
#line 1940 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
ngx_str_node_t *ngx_str_rbtree_lookup(ngx_rbtree_t *rbtree , ngx_str_t *val , uint32_t hash ) 
{ 
  ngx_int_t rc ;
  ngx_str_node_t *n ;
  ngx_rbtree_node_t *node ;
  ngx_rbtree_node_t *sentinel ;
  int tmp ;

  {
#line 1947
  node = rbtree->root;
#line 1948
  sentinel = rbtree->sentinel;
  {
#line 1950
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1950
    if (! ((unsigned long )node != (unsigned long )sentinel)) {
#line 1950
      goto while_break;
    }
#line 1952
    n = (ngx_str_node_t *)node;
#line 1954
    if ((ngx_rbtree_key_t )hash != node->key) {
#line 1955
      if ((ngx_rbtree_key_t )hash < node->key) {
#line 1955
        node = node->left;
      } else {
#line 1955
        node = node->right;
      }
#line 1956
      goto while_continue;
    }
#line 1959
    if (val->len != n->str.len) {
#line 1960
      if (val->len < n->str.len) {
#line 1960
        node = node->left;
      } else {
#line 1960
        node = node->right;
      }
#line 1961
      goto while_continue;
    }
    {
#line 1964
    tmp = memcmp((void const   *)((char const   *)val->data), (void const   *)((char const   *)n->str.data),
                 val->len);
#line 1964
    rc = (ngx_int_t )tmp;
    }
#line 1966
    if (rc < 0L) {
#line 1967
      node = node->left;
#line 1968
      goto while_continue;
    }
#line 1971
    if (rc > 0L) {
#line 1972
      node = node->right;
#line 1973
      goto while_continue;
    }
#line 1976
    return (n);
  }
  while_break: /* CIL Label */ ;
  }
#line 1979
  return ((ngx_str_node_t *)((void *)0));
}
}
#line 1985 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_string.c"
void ngx_sort(void *base , size_t n , size_t size , ngx_int_t (*cmp)(void const   * ,
                                                                     void const   * ) ) 
{ 
  u_char *p1 ;
  u_char *p2 ;
  u_char *p ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1991
  tmp = ngx_alloc(size, (ngx_log_t *)ngx_cycle->log);
#line 1991
  p = (u_char *)tmp;
  }
#line 1992
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 1993
    return;
  }
#line 1996
  p1 = (u_char *)base + size;
  {
#line 1996
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1996
    if (! ((unsigned long )p1 < (unsigned long )((u_char *)base + n * size))) {
#line 1996
      goto while_break;
    }
    {
#line 2000
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)p1, size);
#line 2002
    p2 = p1;
    }
    {
#line 2002
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2002
      if ((unsigned long )p2 > (unsigned long )((u_char *)base)) {
        {
#line 2002
        tmp___0 = (*cmp)((void const   *)(p2 - size), (void const   *)p);
        }
#line 2002
        if (! (tmp___0 > 0L)) {
#line 2002
          goto while_break___0;
        }
      } else {
#line 2002
        goto while_break___0;
      }
      {
#line 2006
      memcpy((void */* __restrict  */)p2, (void const   */* __restrict  */)(p2 - size),
             size);
#line 2002
      p2 -= size;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2009
    memcpy((void */* __restrict  */)p2, (void const   */* __restrict  */)p, size);
#line 1996
    p1 += size;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2012
  free((void *)p);
  }
#line 2013
  return;
}
}
#line 30 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_output_chain.c"
__inline static ngx_int_t ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx , ngx_buf_t *buf ) ;
#line 36
static ngx_int_t ngx_output_chain_add_copy(ngx_pool_t *pool , ngx_chain_t **chain ,
                                           ngx_chain_t *in ) ;
#line 38
static ngx_int_t ngx_output_chain_align_file_buf(ngx_output_chain_ctx_t *ctx , off_t bsize ) ;
#line 40
static ngx_int_t ngx_output_chain_get_buf(ngx_output_chain_ctx_t *ctx , off_t bsize ) ;
#line 42
static ngx_int_t ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx ) ;
#line 45 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_output_chain.c"
ngx_int_t ngx_output_chain(ngx_output_chain_ctx_t *ctx , ngx_chain_t *in ) 
{ 
  off_t bsize ;
  ngx_int_t rc ;
  ngx_int_t last ;
  ngx_chain_t *cl ;
  ngx_chain_t *out ;
  ngx_chain_t **last_out ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  off_t tmp___5 ;
  char *__cil_tmp16 ;

  {
#line 52
  if ((unsigned long )ctx->in == (unsigned long )((void *)0)) {
#line 52
    if ((unsigned long )ctx->busy == (unsigned long )((void *)0)) {
#line 64
      if ((unsigned long )in == (unsigned long )((void *)0)) {
        {
#line 65
        tmp = (*(ctx->output_filter))(ctx->filter_ctx, in);
        }
#line 65
        return (tmp);
      }
#line 68
      if ((unsigned long )in->next == (unsigned long )((void *)0)) {
        {
#line 68
        tmp___1 = ngx_output_chain_as_is(ctx, in->buf);
        }
#line 68
        if (tmp___1) {
          {
#line 74
          tmp___0 = (*(ctx->output_filter))(ctx->filter_ctx, in);
          }
#line 74
          return (tmp___0);
        }
      }
    }
  }
#line 80
  if (in) {
    {
#line 81
    tmp___2 = ngx_output_chain_add_copy(ctx->pool, & ctx->in, in);
    }
#line 81
    if (tmp___2 == -1L) {
#line 82
      return ((ngx_int_t )-1);
    }
  }
#line 86
  out = (ngx_chain_t *)((void *)0);
#line 87
  last_out = & out;
#line 88
  last = (ngx_int_t )1;
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! ctx->in) {
#line 98
        goto while_break___0;
      }
#line 105
      if (((ctx->in)->buf)->temporary) {
#line 105
        bsize = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else
#line 105
      if (((ctx->in)->buf)->memory) {
#line 105
        bsize = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else
#line 105
      if (((ctx->in)->buf)->mmap) {
#line 105
        bsize = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else {
#line 105
        bsize = ((ctx->in)->buf)->file_last - ((ctx->in)->buf)->file_pos;
      }
#line 107
      if (bsize == 0L) {
#line 107
        if (((ctx->in)->buf)->flush) {
#line 107
          goto _L___1;
        } else
#line 107
        if (((ctx->in)->buf)->last_buf) {
#line 107
          goto _L___1;
        } else
#line 107
        if (((ctx->in)->buf)->sync) {
          _L___1: /* CIL Label */ 
#line 107
          if (((ctx->in)->buf)->temporary) {
#line 107
            goto _L___0;
          } else
#line 107
          if (((ctx->in)->buf)->memory) {
#line 107
            goto _L___0;
          } else
#line 107
          if (((ctx->in)->buf)->mmap) {
#line 107
            goto _L___0;
          } else
#line 107
          if (! (! ((ctx->in)->buf)->in_file)) {
#line 107
            goto _L___0;
          }
        } else {
          _L___0: /* CIL Label */ 
#line 109
          if (((ctx->pool)->log)->log_level >= 2UL) {
            {
#line 109
            ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, 0, "zero size buf in output t:%d r:%d f:%d %p %p-%p %p %O-%O",
                               ((ctx->in)->buf)->temporary, ((ctx->in)->buf)->recycled,
                               ((ctx->in)->buf)->in_file, ((ctx->in)->buf)->start,
                               ((ctx->in)->buf)->pos, ((ctx->in)->buf)->last, ((ctx->in)->buf)->file,
                               ((ctx->in)->buf)->file_pos, ((ctx->in)->buf)->file_last);
            }
          }
          {
#line 122
          ngx_debug_point();
#line 124
          ctx->in = (ctx->in)->next;
          }
#line 126
          goto while_continue___0;
        }
      }
      {
#line 129
      tmp___3 = ngx_output_chain_as_is(ctx, (ctx->in)->buf);
      }
#line 129
      if (tmp___3) {
#line 133
        cl = ctx->in;
#line 134
        ctx->in = cl->next;
#line 136
        *last_out = cl;
#line 137
        last_out = & cl->next;
#line 138
        cl->next = (ngx_chain_t *)((void *)0);
#line 140
        goto while_continue___0;
      }
#line 143
      if ((unsigned long )ctx->buf == (unsigned long )((void *)0)) {
        {
#line 145
        rc = ngx_output_chain_align_file_buf(ctx, bsize);
        }
#line 147
        if (rc == -1L) {
#line 148
          return ((ngx_int_t )-1);
        }
#line 151
        if (rc != 0L) {
#line 153
          if (ctx->free) {
#line 157
            cl = ctx->free;
#line 158
            ctx->buf = cl->buf;
#line 159
            ctx->free = cl->next;
#line 161
            cl->next = (ctx->pool)->chain;
#line 161
            (ctx->pool)->chain = cl;
          } else
#line 163
          if (out) {
#line 165
            goto while_break___0;
          } else
#line 163
          if (ctx->allocated == ctx->bufs.num) {
#line 165
            goto while_break___0;
          } else {
            {
#line 167
            tmp___4 = ngx_output_chain_get_buf(ctx, bsize);
            }
#line 167
            if (tmp___4 != 0L) {
#line 168
              return ((ngx_int_t )-1);
            }
          }
        }
      }
      {
#line 173
      rc = ngx_output_chain_copy_buf(ctx);
      }
#line 175
      if (rc == -1L) {
#line 176
        return (rc);
      }
#line 179
      if (rc == -2L) {
#line 180
        if (out) {
#line 181
          goto while_break___0;
        }
#line 184
        return (rc);
      }
#line 189
      if (((ctx->in)->buf)->temporary) {
#line 189
        tmp___5 = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else
#line 189
      if (((ctx->in)->buf)->memory) {
#line 189
        tmp___5 = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else
#line 189
      if (((ctx->in)->buf)->mmap) {
#line 189
        tmp___5 = ((ctx->in)->buf)->last - ((ctx->in)->buf)->pos;
      } else {
#line 189
        tmp___5 = ((ctx->in)->buf)->file_last - ((ctx->in)->buf)->file_pos;
      }
#line 189
      if (tmp___5 == 0L) {
#line 190
        ctx->in = (ctx->in)->next;
      }
      {
#line 193
      cl = ngx_alloc_chain_link(ctx->pool);
      }
#line 194
      if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 195
        return ((ngx_int_t )-1);
      }
#line 198
      cl->buf = ctx->buf;
#line 199
      cl->next = (ngx_chain_t *)((void *)0);
#line 200
      *last_out = cl;
#line 201
      last_out = & cl->next;
#line 202
      ctx->buf = (ngx_buf_t *)((void *)0);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 205
    if ((unsigned long )out == (unsigned long )((void *)0)) {
#line 205
      if (last != 1L) {
#line 207
        if (ctx->in) {
#line 208
          return ((ngx_int_t )-2);
        }
#line 211
        return (last);
      }
    }
    {
#line 214
    last = (*(ctx->output_filter))(ctx->filter_ctx, out);
    }
#line 216
    if (last == -1L) {
#line 217
      return (last);
    } else
#line 216
    if (last == -4L) {
#line 217
      return (last);
    }
    {
#line 220
    ngx_chain_update_chains(ctx->pool, & ctx->free, & ctx->busy, & out, ctx->tag);
#line 222
    last_out = & out;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 227 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_output_chain.c"
__inline static ngx_int_t ngx_output_chain_as_is(ngx_output_chain_ctx_t *ctx , ngx_buf_t *buf ) 
{ 
  ngx_uint_t sendfile___0 ;

  {
#line 232
  if (buf->flush) {
#line 232
    goto _L;
  } else
#line 232
  if (buf->last_buf) {
#line 232
    goto _L;
  } else
#line 232
  if (buf->sync) {
    _L: /* CIL Label */ 
#line 232
    if (! buf->temporary) {
#line 232
      if (! buf->memory) {
#line 232
        if (! buf->mmap) {
#line 232
          if (! buf->in_file) {
#line 233
            return ((ngx_int_t )1);
          }
        }
      }
    }
  }
#line 243
  if (buf->in_file) {
#line 243
    if ((buf->file)->directio) {
#line 244
      return ((ngx_int_t )0);
    }
  }
#line 247
  sendfile___0 = (ngx_uint_t )ctx->sendfile;
#line 257
  if (! sendfile___0) {
#line 259
    if (! buf->temporary) {
#line 259
      if (! buf->memory) {
#line 259
        if (! buf->mmap) {
#line 260
          return ((ngx_int_t )0);
        }
      }
    }
#line 263
    buf->in_file = 0U;
  }
#line 272
  if (ctx->need_in_memory) {
#line 272
    if (! buf->temporary) {
#line 272
      if (! buf->memory) {
#line 272
        if (! buf->mmap) {
#line 273
          return ((ngx_int_t )0);
        }
      }
    }
  }
#line 276
  if (ctx->need_in_temp) {
#line 276
    if (buf->memory) {
#line 277
      return ((ngx_int_t )0);
    } else
#line 276
    if (buf->mmap) {
#line 277
      return ((ngx_int_t )0);
    }
  }
#line 280
  return ((ngx_int_t )1);
}
}
#line 306 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_output_chain.c"
static ngx_int_t ngx_output_chain_add_copy(ngx_pool_t *pool , ngx_chain_t **chain ,
                                           ngx_chain_t *in ) 
{ 
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;

  {
#line 315
  ll = chain;
#line 317
  cl = *chain;
  {
#line 317
  while (1) {
    while_continue: /* CIL Label */ ;
#line 317
    if (! cl) {
#line 317
      goto while_break;
    }
#line 318
    ll = & cl->next;
#line 317
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 321
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 321
    if (! in) {
#line 321
      goto while_break___0;
    }
    {
#line 323
    cl = ngx_alloc_chain_link(pool);
    }
#line 324
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 325
      return ((ngx_int_t )-1);
    }
#line 361
    cl->buf = in->buf;
#line 362
    in = in->next;
#line 366
    cl->next = (ngx_chain_t *)((void *)0);
#line 367
    *ll = cl;
#line 368
    ll = & cl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 371
  return ((ngx_int_t )0);
}
}
#line 375 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_output_chain.c"
static ngx_int_t ngx_output_chain_align_file_buf(ngx_output_chain_ctx_t *ctx , off_t bsize ) 
{ 
  size_t size ;
  ngx_buf_t *in ;

  {
#line 381
  in = (ctx->in)->buf;
#line 383
  if ((unsigned long )in->file == (unsigned long )((void *)0)) {
#line 384
    return ((ngx_int_t )-5);
  } else
#line 383
  if (! (in->file)->directio) {
#line 384
    return ((ngx_int_t )-5);
  }
#line 387
  ctx->directio = 1U;
#line 389
  size = (size_t )(in->file_pos - (in->file_pos & ~ (ctx->alignment - 1L)));
#line 391
  if (size == 0UL) {
#line 393
    if (bsize >= (off_t )ctx->bufs.size) {
#line 394
      return ((ngx_int_t )-5);
    }
#line 397
    size = (size_t )bsize;
  } else {
#line 400
    size = (size_t )ctx->alignment - size;
#line 402
    if ((off_t )size > bsize) {
#line 403
      size = (size_t )bsize;
    }
  }
  {
#line 407
  ctx->buf = ngx_create_temp_buf(ctx->pool, size);
  }
#line 408
  if ((unsigned long )ctx->buf == (unsigned long )((void *)0)) {
#line 409
    return ((ngx_int_t )-1);
  }
#line 418
  ctx->unaligned = 1U;
#line 421
  return ((ngx_int_t )0);
}
}
#line 425 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_output_chain.c"
static ngx_int_t ngx_output_chain_get_buf(ngx_output_chain_ctx_t *ctx , off_t bsize ) 
{ 
  size_t size ;
  ngx_buf_t *b ;
  ngx_buf_t *in ;
  ngx_uint_t recycled ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 432
  in = (ctx->in)->buf;
#line 433
  size = ctx->bufs.size;
#line 434
  recycled = (ngx_uint_t )1;
#line 436
  if (in->last_in_chain) {
#line 438
    if (bsize < (off_t )size) {
#line 445
      size = (size_t )bsize;
#line 446
      recycled = (ngx_uint_t )0;
    } else
#line 448
    if (! ctx->directio) {
#line 448
      if (ctx->bufs.num == 1L) {
#line 448
        if (bsize < (off_t )(size + size / 4UL)) {
#line 458
          size = (size_t )bsize;
#line 459
          recycled = (ngx_uint_t )0;
        }
      }
    }
  }
  {
#line 463
  tmp = ngx_pcalloc(ctx->pool, sizeof(ngx_buf_t ));
#line 463
  b = (ngx_buf_t *)tmp;
  }
#line 464
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 465
    return ((ngx_int_t )-1);
  }
#line 468
  if (ctx->directio) {
    {
#line 475
    tmp___0 = ngx_pmemalign(ctx->pool, size, (size_t )ctx->alignment);
#line 475
    b->start = (u_char *)tmp___0;
    }
#line 476
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 477
      return ((ngx_int_t )-1);
    }
  } else {
    {
#line 481
    tmp___1 = ngx_palloc(ctx->pool, size);
#line 481
    b->start = (u_char *)tmp___1;
    }
#line 482
    if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 483
      return ((ngx_int_t )-1);
    }
  }
#line 487
  b->pos = b->start;
#line 488
  b->last = b->start;
#line 489
  b->end = b->last + size;
#line 490
  b->temporary = 1U;
#line 491
  b->tag = ctx->tag;
#line 492
  b->recycled = (unsigned int )recycled;
#line 494
  ctx->buf = b;
#line 495
  (ctx->allocated) ++;
#line 497
  return ((ngx_int_t )0);
}
}
#line 501 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_output_chain.c"
static ngx_int_t ngx_output_chain_copy_buf(ngx_output_chain_ctx_t *ctx ) 
{ 
  off_t size ;
  ssize_t n ;
  ngx_buf_t *src ;
  ngx_buf_t *dst ;
  ngx_uint_t sendfile___0 ;
  int tmp ;
  int *tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_err_t err ;
  int *tmp___2 ;
  int *tmp___3 ;
  ngx_int_t tmp___4 ;
  int *tmp___5 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 509
  src = (ctx->in)->buf;
#line 510
  dst = ctx->buf;
#line 512
  if (src->temporary) {
#line 512
    size = src->last - src->pos;
  } else
#line 512
  if (src->memory) {
#line 512
    size = src->last - src->pos;
  } else
#line 512
  if (src->mmap) {
#line 512
    size = src->last - src->pos;
  } else {
#line 512
    size = src->file_last - src->file_pos;
  }
#line 513
  if (size > dst->end - dst->pos) {
#line 513
    size = dst->end - dst->pos;
  } else {
#line 513
    size = size;
  }
#line 515
  if (ctx->sendfile) {
#line 515
    if (! ctx->directio) {
#line 515
      tmp = 1;
    } else {
#line 515
      tmp = 0;
    }
  } else {
#line 515
    tmp = 0;
  }
#line 515
  sendfile___0 = (ngx_uint_t )tmp;
#line 525
  if (src->temporary) {
#line 525
    goto _L;
  } else
#line 525
  if (src->memory) {
#line 525
    goto _L;
  } else
#line 525
  if (src->mmap) {
    _L: /* CIL Label */ 
    {
#line 526
    memcpy((void */* __restrict  */)dst->pos, (void const   */* __restrict  */)src->pos,
           (size_t )size);
#line 527
    src->pos += (size_t )size;
#line 528
    dst->last += (size_t )size;
    }
#line 530
    if (src->in_file) {
#line 532
      if (sendfile___0) {
#line 533
        dst->in_file = 1U;
#line 534
        dst->file = src->file;
#line 535
        dst->file_pos = src->file_pos;
#line 536
        dst->file_last = src->file_pos + size;
      } else {
#line 539
        dst->in_file = 0U;
      }
#line 542
      src->file_pos += size;
    } else {
#line 545
      dst->in_file = 0U;
    }
#line 548
    if ((unsigned long )src->pos == (unsigned long )src->last) {
#line 549
      dst->flush = src->flush;
#line 550
      dst->last_buf = src->last_buf;
#line 551
      dst->last_in_chain = src->last_in_chain;
    }
  } else {
#line 558
    if (ctx->unaligned) {
      {
#line 559
      tmp___1 = ngx_directio_off((src->file)->fd);
      }
#line 559
      if (tmp___1 == -1L) {
#line 560
        if (((ctx->pool)->log)->log_level >= 2UL) {
          {
#line 560
          tmp___0 = __errno_location();
#line 560
          ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, *tmp___0, "fcntl(!O_DIRECT) \"%s\" failed",
                             (src->file)->name.data);
          }
        }
      }
    }
    {
#line 595
    n = ngx_read_file(src->file, dst->pos, (size_t )size, src->file_pos);
    }
#line 601
    if (ctx->unaligned) {
      {
#line 604
      tmp___2 = __errno_location();
#line 604
      err = *tmp___2;
#line 606
      tmp___4 = ngx_directio_on((src->file)->fd);
      }
#line 606
      if (tmp___4 == -1L) {
#line 607
        if (((ctx->pool)->log)->log_level >= 2UL) {
          {
#line 607
          tmp___3 = __errno_location();
#line 607
          ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, *tmp___3, "fcntl(O_DIRECT) \"%s\" failed",
                             (src->file)->name.data);
          }
        }
      }
      {
#line 612
      tmp___5 = __errno_location();
#line 612
      *tmp___5 = err;
#line 614
      ctx->unaligned = 0U;
      }
    }
#line 619
    if (n == -1L) {
#line 620
      return (n);
    }
#line 623
    if (n != size) {
#line 624
      if (((ctx->pool)->log)->log_level >= 2UL) {
        {
#line 624
        ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, 0, "pread() read only %z of %O from \"%s\"",
                           n, size, (src->file)->name.data);
        }
      }
#line 627
      return ((ngx_int_t )-1);
    }
#line 630
    dst->last += n;
#line 632
    if (sendfile___0) {
#line 633
      dst->in_file = 1U;
#line 634
      dst->file = src->file;
#line 635
      dst->file_pos = src->file_pos;
#line 636
      dst->file_last = src->file_pos + n;
    } else {
#line 639
      dst->in_file = 0U;
    }
#line 642
    src->file_pos += n;
#line 644
    if (src->file_pos == src->file_last) {
#line 645
      dst->flush = src->flush;
#line 646
      dst->last_buf = src->last_buf;
#line 647
      dst->last_in_chain = src->last_in_chain;
    }
  }
#line 651
  return ((ngx_int_t )0);
}
}
#line 655 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_output_chain.c"
ngx_int_t ngx_chain_writer(void *data , ngx_chain_t *in ) 
{ 
  ngx_chain_writer_ctx_t *ctx ;
  off_t size ;
  ngx_chain_t *cl ;
  ngx_chain_t *ln ;
  ngx_chain_t *chain ;
  ngx_connection_t *c ;
  off_t tmp ;
  off_t tmp___0 ;
  off_t tmp___1 ;
  off_t tmp___2 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 658
  ctx = (ngx_chain_writer_ctx_t *)data;
#line 664
  c = ctx->connection;
#line 666
  size = (off_t )0;
  {
#line 666
  while (1) {
    while_continue: /* CIL Label */ ;
#line 666
    if (! in) {
#line 666
      goto while_break;
    }
#line 669
    if ((in->buf)->temporary) {
#line 669
      tmp = (in->buf)->last - (in->buf)->pos;
    } else
#line 669
    if ((in->buf)->memory) {
#line 669
      tmp = (in->buf)->last - (in->buf)->pos;
    } else
#line 669
    if ((in->buf)->mmap) {
#line 669
      tmp = (in->buf)->last - (in->buf)->pos;
    } else {
#line 669
      tmp = (in->buf)->file_last - (in->buf)->file_pos;
    }
#line 669
    if (tmp == 0L) {
#line 669
      if ((in->buf)->flush) {
#line 669
        goto _L___1;
      } else
#line 669
      if ((in->buf)->last_buf) {
#line 669
        goto _L___1;
      } else
#line 669
      if ((in->buf)->sync) {
        _L___1: /* CIL Label */ 
#line 669
        if ((in->buf)->temporary) {
#line 669
          goto _L___0;
        } else
#line 669
        if ((in->buf)->memory) {
#line 669
          goto _L___0;
        } else
#line 669
        if ((in->buf)->mmap) {
#line 669
          goto _L___0;
        } else
#line 669
        if (! (! (in->buf)->in_file)) {
#line 669
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 671
        if (((ctx->pool)->log)->log_level >= 2UL) {
          {
#line 671
          ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, 0, "zero size buf in chain writer t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (in->buf)->temporary, (in->buf)->recycled, (in->buf)->in_file,
                             (in->buf)->start, (in->buf)->pos, (in->buf)->last, (in->buf)->file,
                             (in->buf)->file_pos, (in->buf)->file_last);
          }
        }
        {
#line 684
        ngx_debug_point();
        }
#line 686
        goto __Cont;
      }
    }
#line 690
    if ((in->buf)->temporary) {
#line 690
      tmp___0 = (in->buf)->last - (in->buf)->pos;
    } else
#line 690
    if ((in->buf)->memory) {
#line 690
      tmp___0 = (in->buf)->last - (in->buf)->pos;
    } else
#line 690
    if ((in->buf)->mmap) {
#line 690
      tmp___0 = (in->buf)->last - (in->buf)->pos;
    } else {
#line 690
      tmp___0 = (in->buf)->file_last - (in->buf)->file_pos;
    }
    {
#line 690
    size += tmp___0;
#line 696
    cl = ngx_alloc_chain_link(ctx->pool);
    }
#line 697
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 698
      return ((ngx_int_t )-1);
    }
#line 701
    cl->buf = in->buf;
#line 702
    cl->next = (ngx_chain_t *)((void *)0);
#line 703
    *(ctx->last) = cl;
#line 704
    ctx->last = & cl->next;
    __Cont: /* CIL Label */ 
#line 666
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 710
  cl = ctx->out;
  {
#line 710
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 710
    if (! cl) {
#line 710
      goto while_break___0;
    }
#line 713
    if ((cl->buf)->temporary) {
#line 713
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 713
    if ((cl->buf)->memory) {
#line 713
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 713
    if ((cl->buf)->mmap) {
#line 713
      tmp___1 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 713
      tmp___1 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 713
    if (tmp___1 == 0L) {
#line 713
      if ((cl->buf)->flush) {
#line 713
        goto _L___4;
      } else
#line 713
      if ((cl->buf)->last_buf) {
#line 713
        goto _L___4;
      } else
#line 713
      if ((cl->buf)->sync) {
        _L___4: /* CIL Label */ 
#line 713
        if ((cl->buf)->temporary) {
#line 713
          goto _L___3;
        } else
#line 713
        if ((cl->buf)->memory) {
#line 713
          goto _L___3;
        } else
#line 713
        if ((cl->buf)->mmap) {
#line 713
          goto _L___3;
        } else
#line 713
        if (! (! (cl->buf)->in_file)) {
#line 713
          goto _L___3;
        }
      } else {
        _L___3: /* CIL Label */ 
#line 715
        if (((ctx->pool)->log)->log_level >= 2UL) {
          {
#line 715
          ngx_log_error_core((ngx_uint_t )2, (ctx->pool)->log, 0, "zero size buf in chain writer t:%d r:%d f:%d %p %p-%p %p %O-%O",
                             (cl->buf)->temporary, (cl->buf)->recycled, (cl->buf)->in_file,
                             (cl->buf)->start, (cl->buf)->pos, (cl->buf)->last, (cl->buf)->file,
                             (cl->buf)->file_pos, (cl->buf)->file_last);
          }
        }
        {
#line 728
        ngx_debug_point();
        }
#line 730
        goto __Cont___0;
      }
    }
#line 734
    if ((cl->buf)->temporary) {
#line 734
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 734
    if ((cl->buf)->memory) {
#line 734
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 734
    if ((cl->buf)->mmap) {
#line 734
      tmp___2 = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 734
      tmp___2 = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 734
    size += tmp___2;
    __Cont___0: /* CIL Label */ 
#line 710
    cl = cl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 737
  if (size == 0L) {
#line 737
    if (! c->buffered) {
#line 738
      return ((ngx_int_t )0);
    }
  }
  {
#line 741
  chain = (*(c->send_chain))(c, ctx->out, ctx->limit);
  }
#line 746
  if ((unsigned long )chain == (unsigned long )((ngx_chain_t *)-1)) {
#line 747
    return ((ngx_int_t )-1);
  }
#line 750
  cl = ctx->out;
  {
#line 750
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 750
    if (cl) {
#line 750
      if (! ((unsigned long )cl != (unsigned long )chain)) {
#line 750
        goto while_break___1;
      }
    } else {
#line 750
      goto while_break___1;
    }
#line 751
    ln = cl;
#line 752
    cl = cl->next;
#line 753
    ln->next = (ctx->pool)->chain;
#line 753
    (ctx->pool)->chain = ln;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 756
  ctx->out = chain;
#line 758
  if ((unsigned long )ctx->out == (unsigned long )((void *)0)) {
#line 759
    ctx->last = & ctx->out;
#line 761
    if (! c->buffered) {
#line 762
      return ((ngx_int_t )0);
    }
  }
#line 766
  return ((ngx_int_t )-2);
}
}
#line 17 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_queue.c"
ngx_queue_t *ngx_queue_middle(ngx_queue_t *queue ) 
{ 
  ngx_queue_t *middle ;
  ngx_queue_t *next ;

  {
#line 22
  middle = queue->next;
#line 24
  if ((unsigned long )middle == (unsigned long )queue->prev) {
#line 25
    return (middle);
  }
#line 28
  next = queue->next;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    middle = middle->next;
#line 33
    next = next->next;
#line 35
    if ((unsigned long )next == (unsigned long )queue->prev) {
#line 36
      return (middle);
    }
#line 39
    next = next->next;
#line 41
    if ((unsigned long )next == (unsigned long )queue->prev) {
#line 42
      return (middle);
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 50 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_queue.c"
void ngx_queue_sort(ngx_queue_t *queue , ngx_int_t (*cmp)(ngx_queue_t const   * ,
                                                          ngx_queue_t const   * ) ) 
{ 
  ngx_queue_t *q ;
  ngx_queue_t *prev ;
  ngx_queue_t *next ;
  ngx_int_t tmp ;

  {
#line 56
  q = queue->next;
#line 58
  if ((unsigned long )q == (unsigned long )queue->prev) {
#line 59
    return;
  }
#line 62
  q = q->next;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! ((unsigned long )q != (unsigned long )queue)) {
#line 62
      goto while_break;
    }
#line 64
    prev = q->prev;
#line 65
    next = q->next;
#line 67
    (q->next)->prev = q->prev;
#line 67
    (q->prev)->next = q->next;
    {
#line 69
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 70
      tmp = (*cmp)((ngx_queue_t const   *)prev, (ngx_queue_t const   *)q);
      }
#line 70
      if (tmp <= 0L) {
#line 71
        goto while_break___0;
      }
#line 74
      prev = prev->prev;
#line 69
      if (! ((unsigned long )prev != (unsigned long )queue)) {
#line 69
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 78
    q->next = prev->next;
#line 78
    (q->next)->prev = q;
#line 78
    q->prev = prev;
#line 78
    prev->next = q;
#line 62
    q = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  return;
}
}
#line 144 "src/core/ngx_buf.h"
ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool , ngx_bufs_t *bufs ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_buf.c"
ngx_buf_t *ngx_create_temp_buf(ngx_pool_t *pool , size_t size ) 
{ 
  ngx_buf_t *b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 17
  tmp = ngx_pcalloc(pool, sizeof(ngx_buf_t ));
#line 17
  b = (ngx_buf_t *)tmp;
  }
#line 18
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 19
    return ((ngx_buf_t *)((void *)0));
  }
  {
#line 22
  tmp___0 = ngx_palloc(pool, size);
#line 22
  b->start = (u_char *)tmp___0;
  }
#line 23
  if ((unsigned long )b->start == (unsigned long )((void *)0)) {
#line 24
    return ((ngx_buf_t *)((void *)0));
  }
#line 38
  b->pos = b->start;
#line 39
  b->last = b->start;
#line 40
  b->end = b->last + size;
#line 41
  b->temporary = 1U;
#line 43
  return (b);
}
}
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_buf.c"
ngx_chain_t *ngx_alloc_chain_link(ngx_pool_t *pool ) 
{ 
  ngx_chain_t *cl ;
  void *tmp ;

  {
#line 52
  cl = pool->chain;
#line 54
  if (cl) {
#line 55
    pool->chain = cl->next;
#line 56
    return (cl);
  }
  {
#line 59
  tmp = ngx_palloc(pool, sizeof(ngx_chain_t ));
#line 59
  cl = (ngx_chain_t *)tmp;
  }
#line 60
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 61
    return ((ngx_chain_t *)((void *)0));
  }
#line 64
  return (cl);
}
}
#line 68 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_buf.c"
ngx_chain_t *ngx_create_chain_of_bufs(ngx_pool_t *pool , ngx_bufs_t *bufs ) 
{ 
  u_char *p ;
  ngx_int_t i ;
  ngx_buf_t *b ;
  ngx_chain_t *chain ;
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 76
  tmp = ngx_palloc(pool, (size_t )bufs->num * bufs->size);
#line 76
  p = (u_char *)tmp;
  }
#line 77
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 78
    return ((ngx_chain_t *)((void *)0));
  }
#line 81
  ll = & chain;
#line 83
  i = (ngx_int_t )0;
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! (i < bufs->num)) {
#line 83
      goto while_break;
    }
    {
#line 85
    tmp___0 = ngx_pcalloc(pool, sizeof(ngx_buf_t ));
#line 85
    b = (ngx_buf_t *)tmp___0;
    }
#line 86
    if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 87
      return ((ngx_chain_t *)((void *)0));
    }
    {
#line 102
    b->pos = p;
#line 103
    b->last = p;
#line 104
    b->temporary = 1U;
#line 106
    b->start = p;
#line 107
    p += bufs->size;
#line 108
    b->end = p;
#line 110
    cl = ngx_alloc_chain_link(pool);
    }
#line 111
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 112
      return ((ngx_chain_t *)((void *)0));
    }
#line 115
    cl->buf = b;
#line 116
    *ll = cl;
#line 117
    ll = & cl->next;
#line 83
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  *ll = (ngx_chain_t *)((void *)0);
#line 122
  return (chain);
}
}
#line 126 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_buf.c"
ngx_int_t ngx_chain_add_copy(ngx_pool_t *pool , ngx_chain_t **chain , ngx_chain_t *in ) 
{ 
  ngx_chain_t *cl ;
  ngx_chain_t **ll ;

  {
#line 131
  ll = chain;
#line 133
  cl = *chain;
  {
#line 133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 133
    if (! cl) {
#line 133
      goto while_break;
    }
#line 134
    ll = & cl->next;
#line 133
    cl = cl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 137
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 137
    if (! in) {
#line 137
      goto while_break___0;
    }
    {
#line 138
    cl = ngx_alloc_chain_link(pool);
    }
#line 139
    if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 140
      return ((ngx_int_t )-1);
    }
#line 143
    cl->buf = in->buf;
#line 144
    *ll = cl;
#line 145
    ll = & cl->next;
#line 146
    in = in->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 149
  *ll = (ngx_chain_t *)((void *)0);
#line 151
  return ((ngx_int_t )0);
}
}
#line 155 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_buf.c"
ngx_chain_t *ngx_chain_get_free_buf(ngx_pool_t *p , ngx_chain_t **free___0 ) 
{ 
  ngx_chain_t *cl ;
  void *tmp ;

  {
#line 160
  if (*free___0) {
#line 161
    cl = *free___0;
#line 162
    *free___0 = cl->next;
#line 163
    cl->next = (ngx_chain_t *)((void *)0);
#line 164
    return (cl);
  }
  {
#line 167
  cl = ngx_alloc_chain_link(p);
  }
#line 168
  if ((unsigned long )cl == (unsigned long )((void *)0)) {
#line 169
    return ((ngx_chain_t *)((void *)0));
  }
  {
#line 172
  tmp = ngx_pcalloc(p, sizeof(ngx_buf_t ));
#line 172
  cl->buf = (ngx_buf_t *)tmp;
  }
#line 173
  if ((unsigned long )cl->buf == (unsigned long )((void *)0)) {
#line 174
    return ((ngx_chain_t *)((void *)0));
  }
#line 177
  cl->next = (ngx_chain_t *)((void *)0);
#line 179
  return (cl);
}
}
#line 183 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_buf.c"
void ngx_chain_update_chains(ngx_pool_t *p , ngx_chain_t **free___0 , ngx_chain_t **busy ,
                             ngx_chain_t **out , ngx_buf_tag_t tag ) 
{ 
  ngx_chain_t *cl ;
  off_t tmp ;

  {
#line 189
  if (*out) {
#line 190
    if ((unsigned long )*busy == (unsigned long )((void *)0)) {
#line 191
      *busy = *out;
    } else {
#line 194
      cl = *busy;
      {
#line 194
      while (1) {
        while_continue: /* CIL Label */ ;
#line 194
        if (! cl->next) {
#line 194
          goto while_break;
        }
#line 194
        cl = cl->next;
      }
      while_break: /* CIL Label */ ;
      }
#line 196
      cl->next = *out;
    }
#line 199
    *out = (ngx_chain_t *)((void *)0);
  }
  {
#line 202
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 202
    if (! *busy) {
#line 202
      goto while_break___0;
    }
#line 203
    cl = *busy;
#line 205
    if ((cl->buf)->temporary) {
#line 205
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 205
    if ((cl->buf)->memory) {
#line 205
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else
#line 205
    if ((cl->buf)->mmap) {
#line 205
      tmp = (cl->buf)->last - (cl->buf)->pos;
    } else {
#line 205
      tmp = (cl->buf)->file_last - (cl->buf)->file_pos;
    }
#line 205
    if (tmp != 0L) {
#line 206
      goto while_break___0;
    }
#line 209
    if ((unsigned long )(cl->buf)->tag != (unsigned long )tag) {
#line 210
      *busy = cl->next;
#line 211
      cl->next = p->chain;
#line 211
      p->chain = cl;
#line 212
      goto while_continue___0;
    }
#line 215
    (cl->buf)->pos = (cl->buf)->start;
#line 216
    (cl->buf)->last = (cl->buf)->start;
#line 218
    *busy = cl->next;
#line 219
    cl->next = *free___0;
#line 220
    *free___0 = cl;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 222
  return;
}
}
#line 225 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_buf.c"
off_t ngx_chain_coalesce_file(ngx_chain_t **in , off_t limit ) 
{ 
  off_t total ;
  off_t size ;
  off_t aligned ;
  off_t fprev ;
  ngx_fd_t fd ;
  ngx_chain_t *cl ;

  {
#line 232
  total = (off_t )0;
#line 234
  cl = *in;
#line 235
  fd = ((cl->buf)->file)->fd;
  {
#line 237
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    size = (cl->buf)->file_last - (cl->buf)->file_pos;
#line 240
    if (size > limit - total) {
#line 241
      size = limit - total;
#line 243
      aligned = (off_t )((((ngx_uint_t )((cl->buf)->file_pos + size) + ngx_pagesize) - 1UL) & (unsigned long )(~ ((off_t )ngx_pagesize - 1L)));
#line 246
      if (aligned <= (cl->buf)->file_last) {
#line 247
        size = aligned - (cl->buf)->file_pos;
      }
#line 250
      total += size;
#line 251
      goto while_break;
    }
#line 254
    total += size;
#line 255
    fprev = (cl->buf)->file_pos + size;
#line 256
    cl = cl->next;
#line 237
    if (cl) {
#line 237
      if ((cl->buf)->in_file) {
#line 237
        if (total < limit) {
#line 237
          if (fd == ((cl->buf)->file)->fd) {
#line 237
            if (! (fprev == (cl->buf)->file_pos)) {
#line 237
              goto while_break;
            }
          } else {
#line 237
            goto while_break;
          }
        } else {
#line 237
          goto while_break;
        }
      } else {
#line 237
        goto while_break;
      }
    } else {
#line 237
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  *in = cl;
#line 266
  return (total);
}
}
#line 270 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_buf.c"
ngx_chain_t *ngx_chain_update_sent(ngx_chain_t *in , off_t sent ) 
{ 
  off_t size ;

  {
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! in) {
#line 275
      goto while_break;
    }
#line 277
    if ((in->buf)->flush) {
#line 277
      goto _L;
    } else
#line 277
    if ((in->buf)->last_buf) {
#line 277
      goto _L;
    } else
#line 277
    if ((in->buf)->sync) {
      _L: /* CIL Label */ 
#line 277
      if (! (in->buf)->temporary) {
#line 277
        if (! (in->buf)->memory) {
#line 277
          if (! (in->buf)->mmap) {
#line 277
            if (! (in->buf)->in_file) {
#line 278
              goto __Cont;
            }
          }
        }
      }
    }
#line 281
    if (sent == 0L) {
#line 282
      goto while_break;
    }
#line 285
    if ((in->buf)->temporary) {
#line 285
      size = (in->buf)->last - (in->buf)->pos;
    } else
#line 285
    if ((in->buf)->memory) {
#line 285
      size = (in->buf)->last - (in->buf)->pos;
    } else
#line 285
    if ((in->buf)->mmap) {
#line 285
      size = (in->buf)->last - (in->buf)->pos;
    } else {
#line 285
      size = (in->buf)->file_last - (in->buf)->file_pos;
    }
#line 287
    if (sent >= size) {
#line 288
      sent -= size;
#line 290
      if ((in->buf)->temporary) {
#line 291
        (in->buf)->pos = (in->buf)->last;
      } else
#line 290
      if ((in->buf)->memory) {
#line 291
        (in->buf)->pos = (in->buf)->last;
      } else
#line 290
      if ((in->buf)->mmap) {
#line 291
        (in->buf)->pos = (in->buf)->last;
      }
#line 294
      if ((in->buf)->in_file) {
#line 295
        (in->buf)->file_pos = (in->buf)->file_last;
      }
#line 298
      goto __Cont;
    }
#line 301
    if ((in->buf)->temporary) {
#line 302
      (in->buf)->pos += (size_t )sent;
    } else
#line 301
    if ((in->buf)->memory) {
#line 302
      (in->buf)->pos += (size_t )sent;
    } else
#line 301
    if ((in->buf)->mmap) {
#line 302
      (in->buf)->pos += (size_t )sent;
    }
#line 305
    if ((in->buf)->in_file) {
#line 306
      (in->buf)->file_pos += sent;
    }
#line 309
    goto while_break;
    __Cont: /* CIL Label */ 
#line 275
    in = in->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 312
  return (in);
}
}
#line 101 "src/core/ngx_hash.h"
void *ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc , u_char *name , size_t len ) ;
#line 102
void *ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc , u_char *name , size_t len ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
void *ngx_hash_find(ngx_hash_t *hash , ngx_uint_t key , u_char *name , size_t len ) 
{ 
  ngx_uint_t i ;
  ngx_hash_elt_t *elt ;

  {
#line 22
  elt = *(hash->buckets + key % hash->size);
#line 24
  if ((unsigned long )elt == (unsigned long )((void *)0)) {
#line 25
    return ((void *)0);
  }
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! elt->value) {
#line 28
      goto while_break;
    }
#line 29
    if (len != (size_t )elt->len) {
#line 30
      goto next;
    }
#line 33
    i = (ngx_uint_t )0;
    {
#line 33
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 33
      if (! (i < len)) {
#line 33
        goto while_break___0;
      }
#line 34
      if ((int )*(name + i) != (int )elt->name[i]) {
#line 35
        goto next;
      }
#line 33
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 39
    return (elt->value);
    next: 
#line 43
    elt = (ngx_hash_elt_t *)((u_char *)(((uintptr_t )(& elt->name[0] + (int )elt->len) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL)));
#line 45
    goto while_continue;
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return ((void *)0);
}
}
#line 52 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
void *ngx_hash_find_wc_head(ngx_hash_wildcard_t *hwc , u_char *name , size_t len ) 
{ 
  void *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t key ;

  {
#line 62
  n = len;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! n) {
#line 64
      goto while_break;
    }
#line 65
    if ((int )*(name + (n - 1UL)) == 46) {
#line 66
      goto while_break;
    }
#line 69
    n --;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  key = (ngx_uint_t )0;
#line 74
  i = n;
  {
#line 74
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (! (i < len)) {
#line 74
      goto while_break___0;
    }
#line 75
    key = key * 31UL + (ngx_uint_t )*(name + i);
#line 74
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 82
  value = ngx_hash_find(& hwc->hash, key, name + n, len - n);
  }
#line 88
  if (value) {
#line 101
    if ((uintptr_t )value & 2UL) {
#line 103
      if (n == 0UL) {
#line 107
        if ((uintptr_t )value & 1UL) {
#line 108
          return ((void *)0);
        }
#line 111
        hwc = (ngx_hash_wildcard_t *)((uintptr_t )value & 0xfffffffffffffffcUL);
#line 113
        return (hwc->value);
      }
      {
#line 116
      hwc = (ngx_hash_wildcard_t *)((uintptr_t )value & 0xfffffffffffffffcUL);
#line 118
      value = ngx_hash_find_wc_head(hwc, name, n - 1UL);
      }
#line 120
      if (value) {
#line 121
        return (value);
      }
#line 124
      return (hwc->value);
    }
#line 127
    if ((uintptr_t )value & 1UL) {
#line 129
      if (n == 0UL) {
#line 133
        return ((void *)0);
      }
#line 136
      return ((void *)((uintptr_t )value & 0xfffffffffffffffcUL));
    }
#line 139
    return (value);
  }
#line 142
  return (hwc->value);
}
}
#line 146 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
void *ngx_hash_find_wc_tail(ngx_hash_wildcard_t *hwc , u_char *name , size_t len ) 
{ 
  void *value ;
  ngx_uint_t i ;
  ngx_uint_t key ;

  {
#line 156
  key = (ngx_uint_t )0;
#line 158
  i = (ngx_uint_t )0;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! (i < len)) {
#line 158
      goto while_break;
    }
#line 159
    if ((int )*(name + i) == 46) {
#line 160
      goto while_break;
    }
#line 163
    key = key * 31UL + (ngx_uint_t )*(name + i);
#line 158
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 166
  if (i == len) {
#line 167
    return ((void *)0);
  }
  {
#line 174
  value = ngx_hash_find(& hwc->hash, key, name, i);
  }
#line 180
  if (value) {
#line 188
    if ((uintptr_t )value & 2UL) {
      {
#line 190
      i ++;
#line 192
      hwc = (ngx_hash_wildcard_t *)((uintptr_t )value & 0xfffffffffffffffcUL);
#line 194
      value = ngx_hash_find_wc_tail(hwc, name + i, len - i);
      }
#line 196
      if (value) {
#line 197
        return (value);
      }
#line 200
      return (hwc->value);
    }
#line 203
    return (value);
  }
#line 206
  return (hwc->value);
}
}
#line 210 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
void *ngx_hash_find_combined(ngx_hash_combined_t *hash , ngx_uint_t key , u_char *name ,
                             size_t len ) 
{ 
  void *value ;

  {
#line 216
  if (hash->hash.buckets) {
    {
#line 217
    value = ngx_hash_find(& hash->hash, key, name, len);
    }
#line 219
    if (value) {
#line 220
      return (value);
    }
  }
#line 224
  if (len == 0UL) {
#line 225
    return ((void *)0);
  }
#line 228
  if (hash->wc_head) {
#line 228
    if ((hash->wc_head)->hash.buckets) {
      {
#line 229
      value = ngx_hash_find_wc_head(hash->wc_head, name, len);
      }
#line 231
      if (value) {
#line 232
        return (value);
      }
    }
  }
#line 236
  if (hash->wc_tail) {
#line 236
    if ((hash->wc_tail)->hash.buckets) {
      {
#line 237
      value = ngx_hash_find_wc_tail(hash->wc_tail, name, len);
      }
#line 239
      if (value) {
#line 240
        return (value);
      }
    }
  }
#line 244
  return ((void *)0);
}
}
#line 251 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
ngx_int_t ngx_hash_init(ngx_hash_init_t *hinit , ngx_hash_key_t *names , ngx_uint_t nelts ) 
{ 
  u_char *elts ;
  size_t len ;
  u_short *test ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t key ;
  ngx_uint_t size ;
  ngx_uint_t start ;
  ngx_uint_t bucket_size ;
  ngx_hash_elt_t *elt ;
  ngx_hash_elt_t **buckets ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
#line 260
  if (hinit->max_size == 0UL) {
#line 261
    if (((hinit->pool)->log)->log_level >= 1UL) {
      {
#line 261
      ngx_log_error_core((ngx_uint_t )1, (hinit->pool)->log, 0, "could not build %s, you should increase %s_max_size: %i",
                         hinit->name, hinit->name, hinit->max_size);
      }
    }
#line 265
    return ((ngx_int_t )-1);
  }
#line 268
  n = (ngx_uint_t )0;
  {
#line 268
  while (1) {
    while_continue: /* CIL Label */ ;
#line 268
    if (! (n < nelts)) {
#line 268
      goto while_break;
    }
#line 269
    if (hinit->bucket_size < (sizeof(void *) + ((((names + n)->key.len + 2UL) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL))) + sizeof(void *)) {
#line 271
      if (((hinit->pool)->log)->log_level >= 1UL) {
        {
#line 271
        ngx_log_error_core((ngx_uint_t )1, (hinit->pool)->log, 0, "could not build %s, you should increase %s_bucket_size: %i",
                           hinit->name, hinit->name, hinit->bucket_size);
        }
      }
#line 275
      return ((ngx_int_t )-1);
    }
#line 268
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 279
  tmp = ngx_alloc(hinit->max_size * sizeof(u_short ), (hinit->pool)->log);
#line 279
  test = (u_short *)tmp;
  }
#line 280
  if ((unsigned long )test == (unsigned long )((void *)0)) {
#line 281
    return ((ngx_int_t )-1);
  }
#line 284
  bucket_size = hinit->bucket_size - sizeof(void *);
#line 286
  start = nelts / (bucket_size / (2UL * sizeof(void *)));
#line 287
  if (start) {
#line 287
    start = start;
  } else {
#line 287
    start = (ngx_uint_t )1;
  }
#line 289
  if (hinit->max_size > 10000UL) {
#line 289
    if (nelts) {
#line 289
      if (hinit->max_size / nelts < 100UL) {
#line 290
        start = hinit->max_size - 1000UL;
      }
    }
  }
#line 293
  size = start;
  {
#line 293
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 293
    if (! (size <= hinit->max_size)) {
#line 293
      goto while_break___0;
    }
    {
#line 295
    memset((void *)test, 0, size * sizeof(u_short ));
#line 297
    n = (ngx_uint_t )0;
    }
    {
#line 297
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 297
      if (! (n < nelts)) {
#line 297
        goto while_break___1;
      }
#line 298
      if ((unsigned long )(names + n)->key.data == (unsigned long )((void *)0)) {
#line 299
        goto __Cont;
      }
#line 302
      key = (names + n)->key_hash % size;
#line 303
      *(test + key) = (u_short )((unsigned long )*(test + key) + (sizeof(void *) + ((((names + n)->key.len + 2UL) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL))));
#line 311
      if ((int )*(test + key) > (int )((u_short )bucket_size)) {
#line 312
        goto next;
      }
      __Cont: /* CIL Label */ 
#line 297
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 316
    goto found;
    next: 
#line 320
    goto __Cont___0;
    __Cont___0: /* CIL Label */ 
#line 293
    size ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 323
  size = hinit->max_size;
#line 325
  if (((hinit->pool)->log)->log_level >= 5UL) {
    {
#line 325
    ngx_log_error_core((ngx_uint_t )5, (hinit->pool)->log, 0, "could not build optimal %s, you should increase either %s_max_size: %i or %s_bucket_size: %i; ignoring %s_bucket_size",
                       hinit->name, hinit->name, hinit->max_size, hinit->name, hinit->bucket_size,
                       hinit->name);
    }
  }
  found: 
#line 334
  i = (ngx_uint_t )0;
  {
#line 334
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 334
    if (! (i < size)) {
#line 334
      goto while_break___2;
    }
#line 335
    *(test + i) = (u_short )sizeof(void *);
#line 334
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 338
  n = (ngx_uint_t )0;
  {
#line 338
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 338
    if (! (n < nelts)) {
#line 338
      goto while_break___3;
    }
#line 339
    if ((unsigned long )(names + n)->key.data == (unsigned long )((void *)0)) {
#line 340
      goto __Cont___1;
    }
#line 343
    key = (names + n)->key_hash % size;
#line 344
    *(test + key) = (u_short )((unsigned long )*(test + key) + (sizeof(void *) + ((((names + n)->key.len + 2UL) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL))));
    __Cont___1: /* CIL Label */ 
#line 338
    n ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 347
  len = (size_t )0;
#line 349
  i = (ngx_uint_t )0;
  {
#line 349
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 349
    if (! (i < size)) {
#line 349
      goto while_break___4;
    }
#line 350
    if ((unsigned long )*(test + i) == sizeof(void *)) {
#line 351
      goto __Cont___2;
    }
#line 354
    *(test + i) = (u_short )(((ngx_uint_t )*(test + i) + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL));
#line 356
    len += (size_t )*(test + i);
    __Cont___2: /* CIL Label */ 
#line 349
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 359
  if ((unsigned long )hinit->hash == (unsigned long )((void *)0)) {
    {
#line 360
    tmp___0 = ngx_pcalloc(hinit->pool, sizeof(ngx_hash_wildcard_t ) + size * sizeof(ngx_hash_elt_t *));
#line 360
    hinit->hash = (ngx_hash_t *)tmp___0;
    }
#line 362
    if ((unsigned long )hinit->hash == (unsigned long )((void *)0)) {
      {
#line 363
      free((void *)test);
      }
#line 364
      return ((ngx_int_t )-1);
    }
#line 367
    buckets = (ngx_hash_elt_t **)((u_char *)hinit->hash + sizeof(ngx_hash_wildcard_t ));
  } else {
    {
#line 371
    tmp___1 = ngx_pcalloc(hinit->pool, size * sizeof(ngx_hash_elt_t *));
#line 371
    buckets = (ngx_hash_elt_t **)tmp___1;
    }
#line 372
    if ((unsigned long )buckets == (unsigned long )((void *)0)) {
      {
#line 373
      free((void *)test);
      }
#line 374
      return ((ngx_int_t )-1);
    }
  }
  {
#line 378
  tmp___2 = ngx_palloc(hinit->pool, len + ngx_cacheline_size);
#line 378
  elts = (u_char *)tmp___2;
  }
#line 379
  if ((unsigned long )elts == (unsigned long )((void *)0)) {
    {
#line 380
    free((void *)test);
    }
#line 381
    return ((ngx_int_t )-1);
  }
#line 384
  elts = (u_char *)(((uintptr_t )elts + (ngx_cacheline_size - 1UL)) & ~ (ngx_cacheline_size - 1UL));
#line 386
  i = (ngx_uint_t )0;
  {
#line 386
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 386
    if (! (i < size)) {
#line 386
      goto while_break___5;
    }
#line 387
    if ((unsigned long )*(test + i) == sizeof(void *)) {
#line 388
      goto __Cont___3;
    }
#line 391
    *(buckets + i) = (ngx_hash_elt_t *)elts;
#line 392
    elts += (int )*(test + i);
    __Cont___3: /* CIL Label */ 
#line 386
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 395
  i = (ngx_uint_t )0;
  {
#line 395
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 395
    if (! (i < size)) {
#line 395
      goto while_break___6;
    }
#line 396
    *(test + i) = (u_short )0;
#line 395
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 399
  n = (ngx_uint_t )0;
  {
#line 399
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 399
    if (! (n < nelts)) {
#line 399
      goto while_break___7;
    }
#line 400
    if ((unsigned long )(names + n)->key.data == (unsigned long )((void *)0)) {
#line 401
      goto __Cont___4;
    }
    {
#line 404
    key = (names + n)->key_hash % size;
#line 405
    elt = (ngx_hash_elt_t *)((u_char *)*(buckets + key) + (int )*(test + key));
#line 407
    elt->value = (names + n)->value;
#line 408
    elt->len = (u_short )(names + n)->key.len;
#line 410
    ngx_strlow(elt->name, (names + n)->key.data, (names + n)->key.len);
#line 412
    *(test + key) = (u_short )((unsigned long )*(test + key) + (sizeof(void *) + ((((names + n)->key.len + 2UL) + (sizeof(void *) - 1UL)) & ~ (sizeof(void *) - 1UL))));
    }
    __Cont___4: /* CIL Label */ 
#line 399
    n ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 415
  i = (ngx_uint_t )0;
  {
#line 415
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 415
    if (! (i < size)) {
#line 415
      goto while_break___8;
    }
#line 416
    if ((unsigned long )*(buckets + i) == (unsigned long )((void *)0)) {
#line 417
      goto __Cont___5;
    }
#line 420
    elt = (ngx_hash_elt_t *)((u_char *)*(buckets + i) + (int )*(test + i));
#line 422
    elt->value = (void *)0;
    __Cont___5: /* CIL Label */ 
#line 415
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 425
  free((void *)test);
#line 427
  (hinit->hash)->buckets = buckets;
#line 428
  (hinit->hash)->size = size;
  }
#line 460
  return ((ngx_int_t )0);
}
}
#line 464 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
ngx_int_t ngx_hash_wildcard_init(ngx_hash_init_t *hinit , ngx_hash_key_t *names ,
                                 ngx_uint_t nelts ) 
{ 
  size_t len ;
  size_t dot_len ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t dot ;
  ngx_array_t curr_names ;
  ngx_array_t next_names ;
  ngx_hash_key_t *name ;
  ngx_hash_key_t *next_name ;
  ngx_hash_init_t h ;
  ngx_hash_wildcard_t *wdc ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  ngx_int_t tmp___5 ;
  int tmp___6 ;
  ngx_int_t tmp___7 ;

  {
  {
#line 475
  tmp = ngx_array_init(& curr_names, hinit->temp_pool, nelts, sizeof(ngx_hash_key_t ));
  }
#line 475
  if (tmp != 0L) {
#line 479
    return ((ngx_int_t )-1);
  }
  {
#line 482
  tmp___0 = ngx_array_init(& next_names, hinit->temp_pool, nelts, sizeof(ngx_hash_key_t ));
  }
#line 482
  if (tmp___0 != 0L) {
#line 486
    return ((ngx_int_t )-1);
  }
#line 489
  n = (ngx_uint_t )0;
  {
#line 489
  while (1) {
    while_continue: /* CIL Label */ ;
#line 489
    if (! (n < nelts)) {
#line 489
      goto while_break;
    }
#line 496
    dot = (ngx_uint_t )0;
#line 498
    len = (size_t )0;
    {
#line 498
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 498
      if (! (len < (names + n)->key.len)) {
#line 498
        goto while_break___0;
      }
#line 499
      if ((int )*((names + n)->key.data + len) == 46) {
#line 500
        dot = (ngx_uint_t )1;
#line 501
        goto while_break___0;
      }
#line 498
      len ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 505
    tmp___1 = ngx_array_push(& curr_names);
#line 505
    name = (ngx_hash_key_t *)tmp___1;
    }
#line 506
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 507
      return ((ngx_int_t )-1);
    }
    {
#line 510
    name->key.len = len;
#line 511
    name->key.data = (names + n)->key.data;
#line 512
    name->key_hash = (*(hinit->key))(name->key.data, name->key.len);
#line 513
    name->value = (names + n)->value;
#line 520
    dot_len = len + 1UL;
    }
#line 522
    if (dot) {
#line 523
      len ++;
    }
#line 526
    next_names.nelts = (ngx_uint_t )0;
#line 528
    if ((names + n)->key.len != len) {
      {
#line 529
      tmp___2 = ngx_array_push(& next_names);
#line 529
      next_name = (ngx_hash_key_t *)tmp___2;
      }
#line 530
      if ((unsigned long )next_name == (unsigned long )((void *)0)) {
#line 531
        return ((ngx_int_t )-1);
      }
#line 534
      next_name->key.len = (names + n)->key.len - len;
#line 535
      next_name->key.data = (names + n)->key.data + len;
#line 536
      next_name->key_hash = (ngx_uint_t )0;
#line 537
      next_name->value = (names + n)->value;
    }
#line 545
    i = n + 1UL;
    {
#line 545
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 545
      if (! (i < nelts)) {
#line 545
        goto while_break___1;
      }
      {
#line 546
      tmp___3 = strncmp((char const   *)(names + n)->key.data, (char const   *)(names + i)->key.data,
                        len);
      }
#line 546
      if (tmp___3 != 0) {
#line 547
        goto while_break___1;
      }
#line 550
      if (! dot) {
#line 550
        if ((names + i)->key.len > len) {
#line 550
          if ((int )*((names + i)->key.data + len) != 46) {
#line 554
            goto while_break___1;
          }
        }
      }
      {
#line 557
      tmp___4 = ngx_array_push(& next_names);
#line 557
      next_name = (ngx_hash_key_t *)tmp___4;
      }
#line 558
      if ((unsigned long )next_name == (unsigned long )((void *)0)) {
#line 559
        return ((ngx_int_t )-1);
      }
#line 562
      next_name->key.len = (names + i)->key.len - dot_len;
#line 563
      next_name->key.data = (names + i)->key.data + dot_len;
#line 564
      next_name->key_hash = (ngx_uint_t )0;
#line 565
      next_name->value = (names + i)->value;
#line 545
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 573
    if (next_names.nelts) {
      {
#line 575
      h = *hinit;
#line 576
      h.hash = (ngx_hash_t *)((void *)0);
#line 578
      tmp___5 = ngx_hash_wildcard_init(& h, (ngx_hash_key_t *)next_names.elts, next_names.nelts);
      }
#line 578
      if (tmp___5 != 0L) {
#line 582
        return ((ngx_int_t )-1);
      }
#line 585
      wdc = (ngx_hash_wildcard_t *)h.hash;
#line 587
      if ((names + n)->key.len == len) {
#line 588
        wdc->value = (names + n)->value;
      }
#line 591
      if (dot) {
#line 591
        tmp___6 = 3;
      } else {
#line 591
        tmp___6 = 2;
      }
#line 591
      name->value = (void *)((uintptr_t )wdc | (unsigned long )tmp___6);
    } else
#line 593
    if (dot) {
#line 594
      name->value = (void *)((uintptr_t )name->value | 1UL);
    }
#line 489
    n = i;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 598
  tmp___7 = ngx_hash_init(hinit, (ngx_hash_key_t *)curr_names.elts, curr_names.nelts);
  }
#line 598
  if (tmp___7 != 0L) {
#line 602
    return ((ngx_int_t )-1);
  }
#line 605
  return ((ngx_int_t )0);
}
}
#line 609 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
ngx_uint_t ngx_hash_key(u_char *data , size_t len ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t key ;

  {
#line 614
  key = (ngx_uint_t )0;
#line 616
  i = (ngx_uint_t )0;
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! (i < len)) {
#line 616
      goto while_break;
    }
#line 617
    key = key * 31UL + (ngx_uint_t )*(data + i);
#line 616
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  return (key);
}
}
#line 624 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
ngx_uint_t ngx_hash_key_lc(u_char *data , size_t len ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t key ;
  int tmp ;

  {
#line 629
  key = (ngx_uint_t )0;
#line 631
  i = (ngx_uint_t )0;
  {
#line 631
  while (1) {
    while_continue: /* CIL Label */ ;
#line 631
    if (! (i < len)) {
#line 631
      goto while_break;
    }
#line 632
    if ((int )*(data + i) >= 65) {
#line 632
      if ((int )*(data + i) <= 90) {
#line 632
        tmp = (int )*(data + i) | 32;
      } else {
#line 632
        tmp = (int )*(data + i);
      }
    } else {
#line 632
      tmp = (int )*(data + i);
    }
#line 632
    key = key * 31UL + (ngx_uint_t )((u_char )tmp);
#line 631
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  return (key);
}
}
#line 639 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
ngx_uint_t ngx_hash_strlow(u_char *dst , u_char *src , size_t n ) 
{ 
  ngx_uint_t key ;
  int tmp ;
  size_t tmp___0 ;

  {
#line 644
  key = (ngx_uint_t )0;
  {
#line 646
  while (1) {
    while_continue: /* CIL Label */ ;
#line 646
    tmp___0 = n;
#line 646
    n --;
#line 646
    if (! tmp___0) {
#line 646
      goto while_break;
    }
#line 647
    if ((int )*src >= 65) {
#line 647
      if ((int )*src <= 90) {
#line 647
        tmp = (int )*src | 32;
      } else {
#line 647
        tmp = (int )*src;
      }
    } else {
#line 647
      tmp = (int )*src;
    }
#line 647
    *dst = (u_char )tmp;
#line 648
    key = key * 31UL + (ngx_uint_t )*dst;
#line 649
    dst ++;
#line 650
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  return (key);
}
}
#line 657 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
ngx_int_t ngx_hash_keys_array_init(ngx_hash_keys_arrays_t *ha , ngx_uint_t type ) 
{ 
  ngx_uint_t asize ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 662
  if (type == 1UL) {
#line 663
    asize = (ngx_uint_t )4;
#line 664
    ha->hsize = (ngx_uint_t )107;
  } else {
#line 667
    asize = (ngx_uint_t )16384;
#line 668
    ha->hsize = (ngx_uint_t )10007;
  }
  {
#line 671
  tmp = ngx_array_init(& ha->keys, ha->temp_pool, asize, sizeof(ngx_hash_key_t ));
  }
#line 671
  if (tmp != 0L) {
#line 674
    return ((ngx_int_t )-1);
  }
  {
#line 677
  tmp___0 = ngx_array_init(& ha->dns_wc_head, ha->temp_pool, asize, sizeof(ngx_hash_key_t ));
  }
#line 677
  if (tmp___0 != 0L) {
#line 681
    return ((ngx_int_t )-1);
  }
  {
#line 684
  tmp___1 = ngx_array_init(& ha->dns_wc_tail, ha->temp_pool, asize, sizeof(ngx_hash_key_t ));
  }
#line 684
  if (tmp___1 != 0L) {
#line 688
    return ((ngx_int_t )-1);
  }
  {
#line 691
  tmp___2 = ngx_pcalloc(ha->temp_pool, sizeof(ngx_array_t ) * ha->hsize);
#line 691
  ha->keys_hash = (ngx_array_t *)tmp___2;
  }
#line 692
  if ((unsigned long )ha->keys_hash == (unsigned long )((void *)0)) {
#line 693
    return ((ngx_int_t )-1);
  }
  {
#line 696
  tmp___3 = ngx_pcalloc(ha->temp_pool, sizeof(ngx_array_t ) * ha->hsize);
#line 696
  ha->dns_wc_head_hash = (ngx_array_t *)tmp___3;
  }
#line 698
  if ((unsigned long )ha->dns_wc_head_hash == (unsigned long )((void *)0)) {
#line 699
    return ((ngx_int_t )-1);
  }
  {
#line 702
  tmp___4 = ngx_pcalloc(ha->temp_pool, sizeof(ngx_array_t ) * ha->hsize);
#line 702
  ha->dns_wc_tail_hash = (ngx_array_t *)tmp___4;
  }
#line 704
  if ((unsigned long )ha->dns_wc_tail_hash == (unsigned long )((void *)0)) {
#line 705
    return ((ngx_int_t )-1);
  }
#line 708
  return ((ngx_int_t )0);
}
}
#line 712 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_hash.c"
ngx_int_t ngx_hash_add_key(ngx_hash_keys_arrays_t *ha , ngx_str_t *key , void *value ,
                           ngx_uint_t flags ) 
{ 
  size_t len ;
  u_char *p ;
  ngx_str_t *name ;
  ngx_uint_t i ;
  ngx_uint_t k ;
  ngx_uint_t n ;
  ngx_uint_t skip ;
  ngx_uint_t last ;
  ngx_array_t *keys ;
  ngx_array_t *hwc ;
  ngx_hash_key_t *hk ;
  int tmp ;
  int tmp___0 ;
  ngx_int_t tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  ngx_int_t tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  ngx_uint_t tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  ngx_int_t tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;

  {
#line 723
  last = key->len;
#line 725
  if (flags & 1UL) {
#line 732
    n = (ngx_uint_t )0;
#line 734
    i = (ngx_uint_t )0;
    {
#line 734
    while (1) {
      while_continue: /* CIL Label */ ;
#line 734
      if (! (i < key->len)) {
#line 734
        goto while_break;
      }
#line 736
      if ((int )*(key->data + i) == 42) {
#line 737
        n ++;
#line 737
        if (n > 1UL) {
#line 738
          return ((ngx_int_t )-5);
        }
      }
#line 742
      if ((int )*(key->data + i) == 46) {
#line 742
        if ((int )*(key->data + (i + 1UL)) == 46) {
#line 743
          return ((ngx_int_t )-5);
        }
      }
#line 746
      if ((int )*(key->data + i) == 0) {
#line 747
        return ((ngx_int_t )-5);
      }
#line 734
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 751
    if (key->len > 1UL) {
#line 751
      if ((int )*(key->data + 0) == 46) {
#line 752
        skip = (ngx_uint_t )1;
#line 753
        goto wildcard;
      }
    }
#line 756
    if (key->len > 2UL) {
#line 758
      if ((int )*(key->data + 0) == 42) {
#line 758
        if ((int )*(key->data + 1) == 46) {
#line 759
          skip = (ngx_uint_t )2;
#line 760
          goto wildcard;
        }
      }
#line 763
      if ((int )*(key->data + (i - 2UL)) == 46) {
#line 763
        if ((int )*(key->data + (i - 1UL)) == 42) {
#line 764
          skip = (ngx_uint_t )0;
#line 765
          last -= 2UL;
#line 766
          goto wildcard;
        }
      }
    }
#line 770
    if (n) {
#line 771
      return ((ngx_int_t )-5);
    }
  }
#line 777
  k = (ngx_uint_t )0;
#line 779
  i = (ngx_uint_t )0;
  {
#line 779
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 779
    if (! (i < last)) {
#line 779
      goto while_break___0;
    }
#line 780
    if (! (flags & 2UL)) {
#line 781
      if ((int )*(key->data + i) >= 65) {
#line 781
        if ((int )*(key->data + i) <= 90) {
#line 781
          tmp = (int )*(key->data + i) | 32;
        } else {
#line 781
          tmp = (int )*(key->data + i);
        }
      } else {
#line 781
        tmp = (int )*(key->data + i);
      }
#line 781
      *(key->data + i) = (u_char )tmp;
    }
#line 783
    k = k * 31UL + (ngx_uint_t )*(key->data + i);
#line 779
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 786
  k %= ha->hsize;
#line 790
  name = (ngx_str_t *)(ha->keys_hash + k)->elts;
#line 792
  if (name) {
#line 793
    i = (ngx_uint_t )0;
    {
#line 793
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 793
      if (! (i < (ha->keys_hash + k)->nelts)) {
#line 793
        goto while_break___1;
      }
#line 794
      if (last != (name + i)->len) {
#line 795
        goto __Cont;
      }
      {
#line 798
      tmp___0 = strncmp((char const   *)key->data, (char const   *)(name + i)->data,
                        last);
      }
#line 798
      if (tmp___0 == 0) {
#line 799
        return ((ngx_int_t )-3);
      }
      __Cont: /* CIL Label */ 
#line 793
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 804
    tmp___1 = ngx_array_init(ha->keys_hash + k, ha->temp_pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
    }
#line 804
    if (tmp___1 != 0L) {
#line 808
      return ((ngx_int_t )-1);
    }
  }
  {
#line 812
  tmp___2 = ngx_array_push(ha->keys_hash + k);
#line 812
  name = (ngx_str_t *)tmp___2;
  }
#line 813
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 814
    return ((ngx_int_t )-1);
  }
  {
#line 817
  *name = *key;
#line 819
  tmp___3 = ngx_array_push(& ha->keys);
#line 819
  hk = (ngx_hash_key_t *)tmp___3;
  }
#line 820
  if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 821
    return ((ngx_int_t )-1);
  }
  {
#line 824
  hk->key = *key;
#line 825
  hk->key_hash = ngx_hash_key(key->data, last);
#line 826
  hk->value = value;
  }
#line 828
  return ((ngx_int_t )0);
  wildcard: 
  {
#line 835
  k = ngx_hash_strlow(key->data + skip, key->data + skip, last - skip);
#line 837
  k %= ha->hsize;
  }
#line 839
  if (skip == 1UL) {
#line 843
    name = (ngx_str_t *)(ha->keys_hash + k)->elts;
#line 845
    if (name) {
#line 846
      len = last - skip;
#line 848
      i = (ngx_uint_t )0;
      {
#line 848
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 848
        if (! (i < (ha->keys_hash + k)->nelts)) {
#line 848
          goto while_break___2;
        }
#line 849
        if (len != (name + i)->len) {
#line 850
          goto __Cont___0;
        }
        {
#line 853
        tmp___4 = strncmp((char const   *)(key->data + 1), (char const   *)(name + i)->data,
                          len);
        }
#line 853
        if (tmp___4 == 0) {
#line 854
          return ((ngx_int_t )-3);
        }
        __Cont___0: /* CIL Label */ 
#line 848
        i ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    } else {
      {
#line 859
      tmp___5 = ngx_array_init(ha->keys_hash + k, ha->temp_pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
      }
#line 859
      if (tmp___5 != 0L) {
#line 863
        return ((ngx_int_t )-1);
      }
    }
    {
#line 867
    tmp___6 = ngx_array_push(ha->keys_hash + k);
#line 867
    name = (ngx_str_t *)tmp___6;
    }
#line 868
    if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 869
      return ((ngx_int_t )-1);
    }
    {
#line 872
    name->len = last - 1UL;
#line 873
    tmp___7 = ngx_pnalloc(ha->temp_pool, name->len);
#line 873
    name->data = (u_char *)tmp___7;
    }
#line 874
    if ((unsigned long )name->data == (unsigned long )((void *)0)) {
#line 875
      return ((ngx_int_t )-1);
    }
    {
#line 878
    memcpy((void */* __restrict  */)name->data, (void const   */* __restrict  */)(key->data + 1),
           name->len);
    }
  }
#line 882
  if (skip) {
    {
#line 889
    tmp___8 = ngx_pnalloc(ha->temp_pool, last);
#line 889
    p = (u_char *)tmp___8;
    }
#line 890
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 891
      return ((ngx_int_t )-1);
    }
#line 894
    len = (size_t )0;
#line 895
    n = (ngx_uint_t )0;
#line 897
    i = last - 1UL;
    {
#line 897
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 897
      if (! i) {
#line 897
        goto while_break___3;
      }
#line 898
      if ((int )*(key->data + i) == 46) {
        {
#line 899
        memcpy((void */* __restrict  */)(p + n), (void const   */* __restrict  */)(key->data + (i + 1UL)),
               len);
#line 900
        n += len;
#line 901
        tmp___9 = n;
#line 901
        n ++;
#line 901
        *(p + tmp___9) = (u_char )'.';
#line 902
        len = (size_t )0;
        }
#line 903
        goto __Cont___1;
      }
#line 906
      len ++;
      __Cont___1: /* CIL Label */ 
#line 897
      i --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 909
    if (len) {
      {
#line 910
      memcpy((void */* __restrict  */)(p + n), (void const   */* __restrict  */)(key->data + 1),
             len);
#line 911
      n += len;
      }
    }
#line 914
    *(p + n) = (u_char )'\000';
#line 916
    hwc = & ha->dns_wc_head;
#line 917
    keys = ha->dns_wc_head_hash + k;
  } else {
    {
#line 923
    last ++;
#line 925
    tmp___10 = ngx_pnalloc(ha->temp_pool, last);
#line 925
    p = (u_char *)tmp___10;
    }
#line 926
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 927
      return ((ngx_int_t )-1);
    }
    {
#line 930
    ngx_cpystrn(p, key->data, last);
#line 932
    hwc = & ha->dns_wc_tail;
#line 933
    keys = ha->dns_wc_tail_hash + k;
    }
  }
#line 939
  name = (ngx_str_t *)keys->elts;
#line 941
  if (name) {
#line 942
    len = last - skip;
#line 944
    i = (ngx_uint_t )0;
    {
#line 944
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 944
      if (! (i < keys->nelts)) {
#line 944
        goto while_break___4;
      }
#line 945
      if (len != (name + i)->len) {
#line 946
        goto __Cont___2;
      }
      {
#line 949
      tmp___11 = strncmp((char const   *)key->data + skip, (char const   *)(name + i)->data,
                         len);
      }
#line 949
      if (tmp___11 == 0) {
#line 950
        return ((ngx_int_t )-3);
      }
      __Cont___2: /* CIL Label */ 
#line 944
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
#line 955
    tmp___12 = ngx_array_init(keys, ha->temp_pool, (ngx_uint_t )4, sizeof(ngx_str_t ));
    }
#line 955
    if (tmp___12 != 0L) {
#line 957
      return ((ngx_int_t )-1);
    }
  }
  {
#line 961
  tmp___13 = ngx_array_push(keys);
#line 961
  name = (ngx_str_t *)tmp___13;
  }
#line 962
  if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 963
    return ((ngx_int_t )-1);
  }
  {
#line 966
  name->len = last - skip;
#line 967
  tmp___14 = ngx_pnalloc(ha->temp_pool, name->len);
#line 967
  name->data = (u_char *)tmp___14;
  }
#line 968
  if ((unsigned long )name->data == (unsigned long )((void *)0)) {
#line 969
    return ((ngx_int_t )-1);
  }
  {
#line 972
  memcpy((void */* __restrict  */)name->data, (void const   */* __restrict  */)(key->data + skip),
         name->len);
#line 977
  tmp___15 = ngx_array_push(hwc);
#line 977
  hk = (ngx_hash_key_t *)tmp___15;
  }
#line 978
  if ((unsigned long )hk == (unsigned long )((void *)0)) {
#line 979
    return ((ngx_int_t )-1);
  }
#line 982
  hk->key.len = last - 1UL;
#line 983
  hk->key.data = p;
#line 984
  hk->key_hash = (ngx_uint_t )0;
#line 985
  hk->value = value;
#line 987
  return ((ngx_int_t )0);
}
}
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_list.c"
ngx_list_t *ngx_list_create(ngx_pool_t *pool , ngx_uint_t n , size_t size ) 
{ 
  ngx_list_t *list ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 17
  tmp = ngx_palloc(pool, sizeof(ngx_list_t ));
#line 17
  list = (ngx_list_t *)tmp;
  }
#line 18
  if ((unsigned long )list == (unsigned long )((void *)0)) {
#line 19
    return ((ngx_list_t *)((void *)0));
  }
  {
#line 22
  tmp___0 = ngx_list_init(list, pool, n, size);
  }
#line 22
  if (tmp___0 != 0L) {
#line 23
    return ((ngx_list_t *)((void *)0));
  }
#line 26
  return (list);
}
}
#line 30 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_list.c"
void *ngx_list_push(ngx_list_t *l ) 
{ 
  void *elt ;
  ngx_list_part_t *last ;
  void *tmp ;

  {
#line 36
  last = l->last;
#line 38
  if (last->nelts == l->nalloc) {
    {
#line 42
    tmp = ngx_palloc(l->pool, sizeof(ngx_list_part_t ));
#line 42
    last = (ngx_list_part_t *)tmp;
    }
#line 43
    if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 44
      return ((void *)0);
    }
    {
#line 47
    last->elts = ngx_palloc(l->pool, l->nalloc * l->size);
    }
#line 48
    if ((unsigned long )last->elts == (unsigned long )((void *)0)) {
#line 49
      return ((void *)0);
    }
#line 52
    last->nelts = (ngx_uint_t )0;
#line 53
    last->next = (ngx_list_part_t *)((void *)0);
#line 55
    (l->last)->next = last;
#line 56
    l->last = last;
  }
#line 59
  elt = (void *)((char *)last->elts + l->size * last->nelts);
#line 60
  (last->nelts) ++;
#line 62
  return (elt);
}
}
#line 26 "src/core/ngx_array.h"
void ngx_array_destroy(ngx_array_t *a ) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_array.c"
ngx_array_t *ngx_array_create(ngx_pool_t *p , ngx_uint_t n , size_t size ) 
{ 
  ngx_array_t *a ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 17
  tmp = ngx_palloc(p, sizeof(ngx_array_t ));
#line 17
  a = (ngx_array_t *)tmp;
  }
#line 18
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 19
    return ((ngx_array_t *)((void *)0));
  }
  {
#line 22
  tmp___0 = ngx_array_init(a, p, n, size);
  }
#line 22
  if (tmp___0 != 0L) {
#line 23
    return ((ngx_array_t *)((void *)0));
  }
#line 26
  return (a);
}
}
#line 30 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_array.c"
void ngx_array_destroy(ngx_array_t *a ) 
{ 
  ngx_pool_t *p ;

  {
#line 35
  p = a->pool;
#line 37
  if ((unsigned long )((u_char *)a->elts + a->size * a->nalloc) == (unsigned long )p->d.last) {
#line 38
    p->d.last -= a->size * a->nalloc;
  }
#line 41
  if ((unsigned long )((u_char *)a + sizeof(ngx_array_t )) == (unsigned long )p->d.last) {
#line 42
    p->d.last = (u_char *)a;
  }
#line 44
  return;
}
}
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_array.c"
void *ngx_array_push(ngx_array_t *a ) 
{ 
  void *elt ;
  void *new ;
  size_t size ;
  ngx_pool_t *p ;

  {
#line 54
  if (a->nelts == a->nalloc) {
#line 58
    size = a->size * a->nalloc;
#line 60
    p = a->pool;
#line 62
    if ((unsigned long )((u_char *)a->elts + size) == (unsigned long )p->d.last) {
#line 62
      if ((unsigned long )(p->d.last + a->size) <= (unsigned long )p->d.end) {
#line 70
        p->d.last += a->size;
#line 71
        (a->nalloc) ++;
      } else {
#line 62
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 76
      new = ngx_palloc(p, 2UL * size);
      }
#line 77
      if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 78
        return ((void *)0);
      }
      {
#line 81
      memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)a->elts,
             size);
#line 82
      a->elts = new;
#line 83
      a->nalloc *= 2UL;
      }
    }
  }
#line 87
  elt = (void *)((u_char *)a->elts + a->size * a->nelts);
#line 88
  (a->nelts) ++;
#line 90
  return (elt);
}
}
#line 94 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_array.c"
void *ngx_array_push_n(ngx_array_t *a , ngx_uint_t n ) 
{ 
  void *elt ;
  void *new ;
  size_t size ;
  ngx_uint_t nalloc ;
  ngx_pool_t *p ;
  ngx_uint_t tmp ;

  {
#line 102
  size = n * a->size;
#line 104
  if (a->nelts + n > a->nalloc) {
#line 108
    p = a->pool;
#line 110
    if ((unsigned long )((u_char *)a->elts + a->size * a->nalloc) == (unsigned long )p->d.last) {
#line 110
      if ((unsigned long )(p->d.last + size) <= (unsigned long )p->d.end) {
#line 118
        p->d.last += size;
#line 119
        a->nalloc += n;
      } else {
#line 110
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 124
      if (n >= a->nalloc) {
#line 124
        tmp = n;
      } else {
#line 124
        tmp = a->nalloc;
      }
      {
#line 124
      nalloc = 2UL * tmp;
#line 126
      new = ngx_palloc(p, nalloc * a->size);
      }
#line 127
      if ((unsigned long )new == (unsigned long )((void *)0)) {
#line 128
        return ((void *)0);
      }
      {
#line 131
      memcpy((void */* __restrict  */)new, (void const   */* __restrict  */)a->elts,
             a->nelts * a->size);
#line 132
      a->elts = new;
#line 133
      a->nalloc = nalloc;
      }
    }
  }
#line 137
  elt = (void *)((u_char *)a->elts + a->size * a->nelts);
#line 138
  a->nelts += n;
#line 140
  return (elt);
}
}
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
__inline static void *ngx_palloc_small(ngx_pool_t *pool , size_t size , ngx_uint_t align ) ;
#line 14
static void *ngx_palloc_block(ngx_pool_t *pool , size_t size ) ;
#line 15
static void *ngx_palloc_large(ngx_pool_t *pool , size_t size ) ;
#line 18 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
ngx_pool_t *ngx_create_pool(size_t size , ngx_log_t *log ) 
{ 
  ngx_pool_t *p ;
  void *tmp ;

  {
  {
#line 23
  tmp = ngx_memalign((size_t )16, size, log);
#line 23
  p = (ngx_pool_t *)tmp;
  }
#line 24
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 25
    return ((ngx_pool_t *)((void *)0));
  }
#line 28
  p->d.last = (u_char *)p + sizeof(ngx_pool_t );
#line 29
  p->d.end = (u_char *)p + size;
#line 30
  p->d.next = (ngx_pool_t *)((void *)0);
#line 31
  p->d.failed = (ngx_uint_t )0;
#line 33
  size -= sizeof(ngx_pool_t );
#line 34
  if (size < ngx_pagesize - 1UL) {
#line 34
    p->max = size;
  } else {
#line 34
    p->max = ngx_pagesize - 1UL;
  }
#line 36
  p->current = p;
#line 37
  p->chain = (ngx_chain_t *)((void *)0);
#line 38
  p->large = (ngx_pool_large_t *)((void *)0);
#line 39
  p->cleanup = (ngx_pool_cleanup_t *)((void *)0);
#line 40
  p->log = log;
#line 42
  return (p);
}
}
#line 46 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void ngx_destroy_pool(ngx_pool_t *pool ) 
{ 
  ngx_pool_t *p ;
  ngx_pool_t *n ;
  ngx_pool_large_t *l ;
  ngx_pool_cleanup_t *c ;

  {
#line 53
  c = pool->cleanup;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! c) {
#line 53
      goto while_break;
    }
#line 54
    if (c->handler) {
      {
#line 57
      (*(c->handler))(c->data);
      }
    }
#line 53
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 83
  l = pool->large;
  {
#line 83
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 83
    if (! l) {
#line 83
      goto while_break___0;
    }
#line 84
    if (l->alloc) {
      {
#line 85
      free(l->alloc);
      }
    }
#line 83
    l = l->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 89
  p = pool;
#line 89
  n = pool->d.next;
  {
#line 89
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 90
    free((void *)p);
    }
#line 92
    if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 93
      goto while_break___1;
    }
#line 89
    p = n;
#line 89
    n = n->d.next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 96
  return;
}
}
#line 99 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void ngx_reset_pool(ngx_pool_t *pool ) 
{ 
  ngx_pool_t *p ;
  ngx_pool_large_t *l ;

  {
#line 105
  l = pool->large;
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! l) {
#line 105
      goto while_break;
    }
#line 106
    if (l->alloc) {
      {
#line 107
      free(l->alloc);
      }
    }
#line 105
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  p = pool;
  {
#line 111
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 111
    if (! p) {
#line 111
      goto while_break___0;
    }
#line 112
    p->d.last = (u_char *)p + sizeof(ngx_pool_t );
#line 113
    p->d.failed = (ngx_uint_t )0;
#line 111
    p = p->d.next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 116
  pool->current = pool;
#line 117
  pool->chain = (ngx_chain_t *)((void *)0);
#line 118
  pool->large = (ngx_pool_large_t *)((void *)0);
#line 119
  return;
}
}
#line 122 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void *ngx_palloc(ngx_pool_t *pool , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 126
  if (size <= pool->max) {
    {
#line 127
    tmp = ngx_palloc_small(pool, size, (ngx_uint_t )1);
    }
#line 127
    return (tmp);
  }
  {
#line 131
  tmp___0 = ngx_palloc_large(pool, size);
  }
#line 131
  return (tmp___0);
}
}
#line 135 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void *ngx_pnalloc(ngx_pool_t *pool , size_t size ) 
{ 
  void *tmp ;
  void *tmp___0 ;

  {
#line 139
  if (size <= pool->max) {
    {
#line 140
    tmp = ngx_palloc_small(pool, size, (ngx_uint_t )0);
    }
#line 140
    return (tmp);
  }
  {
#line 144
  tmp___0 = ngx_palloc_large(pool, size);
  }
#line 144
  return (tmp___0);
}
}
#line 148 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
__inline static void *ngx_palloc_small(ngx_pool_t *pool , size_t size , ngx_uint_t align ) 
{ 
  u_char *m ;
  ngx_pool_t *p ;
  void *tmp ;

  {
#line 154
  p = pool->current;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    m = p->d.last;
#line 159
    if (align) {
#line 160
      m = (u_char *)(((uintptr_t )m + (sizeof(unsigned long ) - 1UL)) & ~ (sizeof(unsigned long ) - 1UL));
    }
#line 163
    if ((size_t )(p->d.end - m) >= size) {
#line 164
      p->d.last = m + size;
#line 166
      return ((void *)m);
    }
#line 169
    p = p->d.next;
#line 156
    if (! p) {
#line 156
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 173
  tmp = ngx_palloc_block(pool, size);
  }
#line 173
  return (tmp);
}
}
#line 177 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
static void *ngx_palloc_block(ngx_pool_t *pool , size_t size ) 
{ 
  u_char *m ;
  size_t psize ;
  ngx_pool_t *p ;
  ngx_pool_t *new ;
  void *tmp ;
  ngx_uint_t tmp___0 ;

  {
  {
#line 184
  psize = (size_t )(pool->d.end - (u_char *)pool);
#line 186
  tmp = ngx_memalign((size_t )16, psize, pool->log);
#line 186
  m = (u_char *)tmp;
  }
#line 187
  if ((unsigned long )m == (unsigned long )((void *)0)) {
#line 188
    return ((void *)0);
  }
#line 191
  new = (ngx_pool_t *)m;
#line 193
  new->d.end = m + psize;
#line 194
  new->d.next = (ngx_pool_t *)((void *)0);
#line 195
  new->d.failed = (ngx_uint_t )0;
#line 197
  m += sizeof(ngx_pool_data_t );
#line 198
  m = (u_char *)(((uintptr_t )m + (sizeof(unsigned long ) - 1UL)) & ~ (sizeof(unsigned long ) - 1UL));
#line 199
  new->d.last = m + size;
#line 201
  p = pool->current;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! p->d.next) {
#line 201
      goto while_break;
    }
#line 202
    tmp___0 = p->d.failed;
#line 202
    (p->d.failed) ++;
#line 202
    if (tmp___0 > 4UL) {
#line 203
      pool->current = p->d.next;
    }
#line 201
    p = p->d.next;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  p->d.next = new;
#line 209
  return ((void *)m);
}
}
#line 213 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
static void *ngx_palloc_large(ngx_pool_t *pool , size_t size ) 
{ 
  void *p ;
  ngx_uint_t n ;
  ngx_pool_large_t *large ;
  ngx_uint_t tmp ;
  void *tmp___0 ;

  {
  {
#line 220
  p = ngx_alloc(size, pool->log);
  }
#line 221
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 222
    return ((void *)0);
  }
#line 225
  n = (ngx_uint_t )0;
#line 227
  large = pool->large;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! large) {
#line 227
      goto while_break;
    }
#line 228
    if ((unsigned long )large->alloc == (unsigned long )((void *)0)) {
#line 229
      large->alloc = p;
#line 230
      return (p);
    }
#line 233
    tmp = n;
#line 233
    n ++;
#line 233
    if (tmp > 3UL) {
#line 234
      goto while_break;
    }
#line 227
    large = large->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 238
  tmp___0 = ngx_palloc_small(pool, sizeof(ngx_pool_large_t ), (ngx_uint_t )1);
#line 238
  large = (ngx_pool_large_t *)tmp___0;
  }
#line 239
  if ((unsigned long )large == (unsigned long )((void *)0)) {
    {
#line 240
    free(p);
    }
#line 241
    return ((void *)0);
  }
#line 244
  large->alloc = p;
#line 245
  large->next = pool->large;
#line 246
  pool->large = large;
#line 248
  return (p);
}
}
#line 252 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void *ngx_pmemalign(ngx_pool_t *pool , size_t size , size_t alignment ) 
{ 
  void *p ;
  ngx_pool_large_t *large ;
  void *tmp ;

  {
  {
#line 258
  p = ngx_memalign(alignment, size, pool->log);
  }
#line 259
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 260
    return ((void *)0);
  }
  {
#line 263
  tmp = ngx_palloc_small(pool, sizeof(ngx_pool_large_t ), (ngx_uint_t )1);
#line 263
  large = (ngx_pool_large_t *)tmp;
  }
#line 264
  if ((unsigned long )large == (unsigned long )((void *)0)) {
    {
#line 265
    free(p);
    }
#line 266
    return ((void *)0);
  }
#line 269
  large->alloc = p;
#line 270
  large->next = pool->large;
#line 271
  pool->large = large;
#line 273
  return (p);
}
}
#line 277 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
ngx_int_t ngx_pfree(ngx_pool_t *pool , void *p ) 
{ 
  ngx_pool_large_t *l ;

  {
#line 282
  l = pool->large;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! l) {
#line 282
      goto while_break;
    }
#line 283
    if ((unsigned long )p == (unsigned long )l->alloc) {
      {
#line 286
      free(l->alloc);
#line 287
      l->alloc = (void *)0;
      }
#line 289
      return ((ngx_int_t )0);
    }
#line 282
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return ((ngx_int_t )-5);
}
}
#line 297 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void *ngx_pcalloc(ngx_pool_t *pool , size_t size ) 
{ 
  void *p ;

  {
  {
#line 302
  p = ngx_palloc(pool, size);
  }
#line 303
  if (p) {
    {
#line 304
    memset(p, 0, size);
    }
  }
#line 307
  return (p);
}
}
#line 311 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
ngx_pool_cleanup_t *ngx_pool_cleanup_add(ngx_pool_t *p , size_t size ) 
{ 
  ngx_pool_cleanup_t *c ;
  void *tmp ;

  {
  {
#line 316
  tmp = ngx_palloc(p, sizeof(ngx_pool_cleanup_t ));
#line 316
  c = (ngx_pool_cleanup_t *)tmp;
  }
#line 317
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 318
    return ((ngx_pool_cleanup_t *)((void *)0));
  }
#line 321
  if (size) {
    {
#line 322
    c->data = ngx_palloc(p, size);
    }
#line 323
    if ((unsigned long )c->data == (unsigned long )((void *)0)) {
#line 324
      return ((ngx_pool_cleanup_t *)((void *)0));
    }
  } else {
#line 328
    c->data = (void *)0;
  }
#line 331
  c->handler = (void (*)(void *data ))((void *)0);
#line 332
  c->next = p->cleanup;
#line 334
  p->cleanup = c;
#line 338
  return (c);
}
}
#line 342 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void ngx_pool_run_cleanup_file(ngx_pool_t *p , ngx_fd_t fd ) 
{ 
  ngx_pool_cleanup_t *c ;
  ngx_pool_cleanup_file_t *cf ;

  {
#line 348
  c = p->cleanup;
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! c) {
#line 348
      goto while_break;
    }
#line 349
    if ((unsigned long )c->handler == (unsigned long )(& ngx_pool_cleanup_file)) {
#line 351
      cf = (ngx_pool_cleanup_file_t *)c->data;
#line 353
      if (cf->fd == fd) {
        {
#line 354
        (*(c->handler))((void *)cf);
#line 355
        c->handler = (void (*)(void *data ))((void *)0);
        }
#line 356
        return;
      }
    }
#line 348
    c = c->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 360
  return;
}
}
#line 363 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void ngx_pool_cleanup_file(void *data ) 
{ 
  ngx_pool_cleanup_file_t *c ;
  int *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 366
  c = (ngx_pool_cleanup_file_t *)data;
#line 371
  tmp___0 = close(c->fd);
  }
#line 371
  if (tmp___0 == -1) {
#line 372
    if ((c->log)->log_level >= 2UL) {
      {
#line 372
      tmp = __errno_location();
#line 372
      ngx_log_error_core((ngx_uint_t )2, c->log, *tmp, "close() \"%s\" failed", c->name);
      }
    }
  }
#line 375
  return;
}
}
#line 378 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_palloc.c"
void ngx_pool_delete_file(void *data ) 
{ 
  ngx_pool_cleanup_file_t *c ;
  ngx_err_t err ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
#line 381
  c = (ngx_pool_cleanup_file_t *)data;
#line 388
  tmp___0 = unlink((char const   *)c->name);
  }
#line 388
  if (tmp___0 == -1) {
    {
#line 389
    tmp = __errno_location();
#line 389
    err = *tmp;
    }
#line 391
    if (err != 2) {
#line 392
      if ((c->log)->log_level >= 3UL) {
        {
#line 392
        ngx_log_error_core((ngx_uint_t )3, c->log, err, "unlink() \"%s\" failed",
                           c->name);
        }
      }
    }
  }
  {
#line 397
  tmp___2 = close(c->fd);
  }
#line 397
  if (tmp___2 == -1) {
#line 398
    if ((c->log)->log_level >= 2UL) {
      {
#line 398
      tmp___1 = __errno_location();
#line 398
      ngx_log_error_core((ngx_uint_t )2, c->log, *tmp___1, "close() \"%s\" failed",
                         c->name);
      }
    }
  }
#line 401
  return;
}
}
#line 231 "src/core/ngx_log.h"
ngx_log_t *ngx_log_init(u_char *prefix ) ;
#line 232
void ngx_log_abort(ngx_err_t err , char const   *fmt  , ...) ;
#line 12 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static char *ngx_error_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 13
static char *ngx_log_set_levels(ngx_conf_t *cf , ngx_log_t *log ) ;
#line 14
static void ngx_log_insert(ngx_log_t *log , ngx_log_t *new_log ) ;
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static ngx_command_t ngx_errlog_commands[2]  = {      {{sizeof("error_log") - 1UL, (u_char *)"error_log"}, (ngx_uint_t )16779264, & ngx_error_log,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 47 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static ngx_core_module_t ngx_errlog_module_ctx  =    {{sizeof("errlog") - 1UL, (u_char *)"errlog"}, (void *(*)(ngx_cycle_t *cycle ))((void *)0),
    (char *(*)(ngx_cycle_t *cycle , void *conf ))((void *)0)};
#line 54 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
ngx_module_t ngx_errlog_module  = 
#line 54
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_errlog_module_ctx),
    ngx_errlog_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 70 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static ngx_log_t ngx_log  ;
#line 71 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static ngx_open_file_t ngx_log_file  ;
#line 72 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
ngx_uint_t ngx_use_stderr  =    (ngx_uint_t )1;
#line 75 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static ngx_str_t err_levels[9]  = 
#line 75
  {      {(size_t )0, (u_char *)((void *)0)}, 
        {sizeof("emerg") - 1UL, (u_char *)"emerg"}, 
        {sizeof("alert") - 1UL, (u_char *)"alert"}, 
        {sizeof("crit") - 1UL, (u_char *)"crit"}, 
        {sizeof("error") - 1UL, (u_char *)"error"}, 
        {sizeof("warn") - 1UL, (u_char *)"warn"}, 
        {sizeof("notice") - 1UL, (u_char *)"notice"}, 
        {sizeof("info") - 1UL, (u_char *)"info"}, 
        {sizeof("debug") - 1UL, (u_char *)"debug"}};
#line 87 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static char const   *debug_levels[7]  = {      "debug_core",      "debug_alloc",      "debug_mutex",      "debug_event", 
        "debug_http",      "debug_mail",      "debug_stream"};
#line 95 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
void ngx_log_error_core(ngx_uint_t level , ngx_log_t *log , ngx_err_t err , char const   *fmt 
                        , ...) 
{ 
  va_list args___0 ;
  u_char *p ;
  u_char *last ;
  u_char *msg ;
  ssize_t n ;
  ngx_uint_t wrote_stderr ;
  ngx_uint_t debug_connection ;
  u_char errstr[2048] ;
  void *tmp ;
  u_char *tmp___0 ;
  int *tmp___1 ;
  void *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
  {
#line 115
  last = errstr + 2048;
#line 117
  tmp = memcpy((void */* __restrict  */)(errstr), (void const   */* __restrict  */)ngx_cached_err_log_time.data,
               (size_t )ngx_cached_err_log_time.len);
#line 117
  p = (u_char *)tmp + ngx_cached_err_log_time.len;
#line 120
  p = ngx_slprintf(p, last, " [%V] ", & err_levels[level]);
#line 123
  p = ngx_slprintf(p, last, "%P#%d: ", ngx_pid, 0);
  }
#line 126
  if (log->connection) {
    {
#line 127
    p = ngx_slprintf(p, last, "*%uA ", log->connection);
    }
  }
  {
#line 130
  msg = p;
#line 134
  __builtin_va_start(args___0, fmt);
#line 135
  p = ngx_vslprintf(p, last, fmt, args___0);
#line 136
  __builtin_va_end(args___0);
  }
#line 144
  if (err) {
    {
#line 145
    p = ngx_log_errno(p, last, err);
    }
  }
#line 148
  if (level != 8UL) {
#line 148
    if (log->handler) {
      {
#line 149
      p = (*(log->handler))(log, p, (size_t )(last - p));
      }
    }
  }
#line 152
  if ((unsigned long )p > (unsigned long )(last - 1)) {
#line 153
    p = last - 1;
  }
#line 156
  tmp___0 = p;
#line 156
  p ++;
#line 156
  *tmp___0 = (u_char )'\n';
#line 158
  wrote_stderr = (ngx_uint_t )0;
#line 159
  debug_connection = (ngx_uint_t )((log->log_level & 2147483648UL) != 0UL);
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! log) {
#line 161
      goto while_break;
    }
#line 163
    if (log->log_level < level) {
#line 163
      if (! debug_connection) {
#line 164
        goto while_break;
      }
    }
#line 167
    if (log->writer) {
      {
#line 168
      (*(log->writer))(log, level, errstr, (size_t )(p - errstr));
      }
#line 169
      goto next;
    }
#line 172
    if (ngx_cached_time->sec == (time_t volatile   )log->disk_full_time) {
#line 180
      goto next;
    }
    {
#line 183
    n = ngx_write_fd((log->file)->fd, (void *)(errstr), (size_t )(p - errstr));
    }
#line 185
    if (n == -1L) {
      {
#line 185
      tmp___1 = __errno_location();
      }
#line 185
      if (*tmp___1 == 28) {
#line 186
        log->disk_full_time = (time_t )ngx_cached_time->sec;
      }
    }
#line 189
    if ((log->file)->fd == 2) {
#line 190
      wrote_stderr = (ngx_uint_t )1;
    }
    next: 
#line 195
    log = log->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  if (! ngx_use_stderr) {
#line 202
    return;
  } else
#line 198
  if (level > 5UL) {
#line 202
    return;
  } else
#line 198
  if (wrote_stderr) {
#line 202
    return;
  }
  {
#line 205
  msg -= (7UL + err_levels[level].len) + 3UL;
#line 207
  ngx_sprintf(msg, "nginx: [%V] ", & err_levels[level]);
#line 209
  ngx_write_fd(2, (void *)msg, (size_t )(p - msg));
  }
#line 210
  return;
}
}
#line 242 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
void ngx_log_abort(ngx_err_t err , char const   *fmt  , ...) 
{ 
  u_char *p ;
  va_list args___0 ;
  u_char errstr[1024] ;
  void *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
  {
#line 249
  __builtin_va_start(args___0, fmt);
#line 250
  p = ngx_vslprintf(errstr, errstr + (sizeof(errstr) - 1UL), fmt, args___0);
#line 251
  __builtin_va_end(args___0);
  }
#line 253
  if ((ngx_cycle->log)->log_level >= 2UL) {
    {
#line 253
    ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, err, "%*s", p - errstr,
                       errstr);
    }
  }
#line 255
  return;
}
}
#line 258 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
void ngx_log_stderr(ngx_err_t err , char const   *fmt  , ...) 
{ 
  u_char *p ;
  u_char *last ;
  va_list args___0 ;
  u_char errstr[2048] ;
  void *tmp ;
  u_char *tmp___0 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
#line 265
  last = errstr + 2048;
#line 267
  tmp = memcpy((void */* __restrict  */)(errstr), (void const   */* __restrict  */)"nginx: ",
               (size_t )7);
#line 267
  p = (u_char *)tmp + 7;
#line 269
  __builtin_va_start(args___0, fmt);
#line 270
  p = ngx_vslprintf(p, last, fmt, args___0);
#line 271
  __builtin_va_end(args___0);
  }
#line 273
  if (err) {
    {
#line 274
    p = ngx_log_errno(p, last, err);
    }
  }
#line 277
  if ((unsigned long )p > (unsigned long )(last - 1)) {
#line 278
    p = last - 1;
  }
  {
#line 281
  tmp___0 = p;
#line 281
  p ++;
#line 281
  *tmp___0 = (u_char )'\n';
#line 283
  ngx_write_fd(2, (void *)(errstr), (size_t )(p - errstr));
  }
#line 284
  return;
}
}
#line 287 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
u_char *ngx_log_errno(u_char *buf , u_char *last , ngx_err_t err ) 
{ 
  u_char *tmp ;
  u_char *tmp___0 ;
  u_char *tmp___1 ;
  u_char *tmp___2 ;
  char *__cil_tmp8 ;

  {
#line 290
  if ((unsigned long )buf > (unsigned long )(last - 50)) {
#line 294
    buf = last - 50;
#line 295
    tmp = buf;
#line 295
    buf ++;
#line 295
    *tmp = (u_char )'.';
#line 296
    tmp___0 = buf;
#line 296
    buf ++;
#line 296
    *tmp___0 = (u_char )'.';
#line 297
    tmp___1 = buf;
#line 297
    buf ++;
#line 297
    *tmp___1 = (u_char )'.';
  }
  {
#line 304
  buf = ngx_slprintf(buf, last, " (%d: ", err);
#line 307
  buf = ngx_strerror(err, buf, (size_t )(last - buf));
  }
#line 309
  if ((unsigned long )buf < (unsigned long )last) {
#line 310
    tmp___2 = buf;
#line 310
    buf ++;
#line 310
    *tmp___2 = (u_char )')';
  }
#line 313
  return (buf);
}
}
#line 317 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
ngx_log_t *ngx_log_init(u_char *prefix ) 
{ 
  u_char *p ;
  u_char *name ;
  size_t nlen ;
  size_t plen ;
  void *tmp ;
  void *tmp___0 ;
  u_char *tmp___1 ;
  int *tmp___2 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 323
  ngx_log.file = & ngx_log_file;
#line 324
  ngx_log.log_level = (ngx_uint_t )6;
#line 326
  name = (u_char *)"logs/error.log";
#line 333
  nlen = strlen((char const   *)name);
  }
#line 335
  if (nlen == 0UL) {
#line 336
    ngx_log_file.fd = 2;
#line 337
    return (& ngx_log);
  }
#line 340
  p = (u_char *)((void *)0);
#line 345
  if ((int )*(name + 0) != 47) {
#line 348
    if (prefix) {
      {
#line 349
      plen = strlen((char const   *)prefix);
      }
    } else {
      {
#line 353
      prefix = (u_char *)"/usr/local/nginx/";
#line 354
      plen = strlen((char const   *)prefix);
      }
    }
#line 360
    if (plen) {
      {
#line 361
      tmp = malloc((plen + nlen) + 2UL);
#line 361
      name = (u_char *)tmp;
      }
#line 362
      if ((unsigned long )name == (unsigned long )((void *)0)) {
#line 363
        return ((ngx_log_t *)((void *)0));
      }
      {
#line 366
      tmp___0 = memcpy((void */* __restrict  */)name, (void const   */* __restrict  */)prefix,
                       plen);
#line 366
      p = (u_char *)tmp___0 + plen;
      }
#line 368
      if (! ((int )*(p - 1) == 47)) {
#line 369
        tmp___1 = p;
#line 369
        p ++;
#line 369
        *tmp___1 = (u_char )'/';
      }
      {
#line 372
      ngx_cpystrn(p, (u_char *)"logs/error.log", nlen + 1UL);
#line 374
      p = name;
      }
    }
  }
  {
#line 378
  ngx_log_file.fd = open((char const   *)name, 1089, 420);
  }
#line 382
  if (ngx_log_file.fd == -1) {
    {
#line 383
    tmp___2 = __errno_location();
#line 383
    ngx_log_stderr(*tmp___2, "[alert] could not open error log file: open() \"%s\" failed",
                   name);
#line 392
    ngx_log_file.fd = 2;
    }
  }
#line 395
  if (p) {
    {
#line 396
    free((void *)p);
    }
  }
#line 399
  return (& ngx_log);
}
}
#line 407 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static ngx_str_t error_log  =    {sizeof("logs/error.log") - 1UL, (u_char *)"logs/error.log"};
#line 403 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
ngx_int_t ngx_log_open_default(ngx_cycle_t *cycle ) 
{ 
  ngx_log_t *log ;
  ngx_log_t *tmp ;
  void *tmp___0 ;

  {
  {
#line 409
  tmp = ngx_log_get_file_log(& cycle->new_log);
  }
#line 409
  if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 410
    return ((ngx_int_t )0);
  }
#line 413
  if (cycle->new_log.log_level != 0UL) {
    {
#line 416
    tmp___0 = ngx_pcalloc(cycle->pool, sizeof(ngx_log_t ));
#line 416
    log = (ngx_log_t *)tmp___0;
    }
#line 417
    if ((unsigned long )log == (unsigned long )((void *)0)) {
#line 418
      return ((ngx_int_t )-1);
    }
  } else {
#line 423
    log = & cycle->new_log;
  }
  {
#line 426
  log->log_level = (ngx_uint_t )4;
#line 428
  log->file = ngx_conf_open_file(cycle, & error_log);
  }
#line 429
  if ((unsigned long )log->file == (unsigned long )((void *)0)) {
#line 430
    return ((ngx_int_t )-1);
  }
#line 433
  if ((unsigned long )log != (unsigned long )(& cycle->new_log)) {
    {
#line 434
    ngx_log_insert(& cycle->new_log, log);
    }
  }
#line 437
  return ((ngx_int_t )0);
}
}
#line 441 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
ngx_int_t ngx_log_redirect_stderr(ngx_cycle_t *cycle ) 
{ 
  ngx_fd_t fd ;
  ngx_log_t *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp6 ;

  {
#line 446
  if (cycle->log_use_stderr) {
#line 447
    return ((ngx_int_t )0);
  }
  {
#line 451
  tmp = ngx_log_get_file_log(cycle->log);
#line 451
  fd = (tmp->file)->fd;
  }
#line 453
  if (fd != 2) {
    {
#line 454
    tmp___1 = dup2(fd, 2);
    }
#line 454
    if (tmp___1 == -1) {
#line 455
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 455
        tmp___0 = __errno_location();
#line 455
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___0, "dup2(STDERR_FILENO) failed");
        }
      }
#line 458
      return ((ngx_int_t )-1);
    }
  }
#line 462
  return ((ngx_int_t )0);
}
}
#line 466 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
ngx_log_t *ngx_log_get_file_log(ngx_log_t *head___0 ) 
{ 
  ngx_log_t *log ;

  {
#line 471
  log = head___0;
  {
#line 471
  while (1) {
    while_continue: /* CIL Label */ ;
#line 471
    if (! log) {
#line 471
      goto while_break;
    }
#line 472
    if ((unsigned long )log->file != (unsigned long )((void *)0)) {
#line 473
      return (log);
    }
#line 471
    log = log->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 477
  return ((ngx_log_t *)((void *)0));
}
}
#line 481 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static char *ngx_log_set_levels(ngx_conf_t *cf , ngx_log_t *log ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_uint_t d ;
  ngx_uint_t found ;
  ngx_str_t *value ;
  int tmp ;
  ngx_uint_t tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 487
  if ((cf->args)->nelts == 2UL) {
#line 488
    log->log_level = (ngx_uint_t )4;
#line 489
    return ((char *)((void *)0));
  }
#line 492
  value = (ngx_str_t *)(cf->args)->elts;
#line 494
  i = (ngx_uint_t )2;
  {
#line 494
  while (1) {
    while_continue: /* CIL Label */ ;
#line 494
    if (! (i < (cf->args)->nelts)) {
#line 494
      goto while_break;
    }
#line 495
    found = (ngx_uint_t )0;
#line 497
    n = (ngx_uint_t )1;
    {
#line 497
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 497
      if (! (n <= 8UL)) {
#line 497
        goto while_break___0;
      }
      {
#line 498
      tmp = strcmp((char const   *)(value + i)->data, (char const   *)err_levels[n].data);
      }
#line 498
      if (tmp == 0) {
#line 500
        if (log->log_level != 0UL) {
          {
#line 501
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "duplicate log level \"%V\"",
                             value + i);
          }
#line 504
          return ((char *)((void *)-1));
        }
#line 507
        log->log_level = n;
#line 508
        found = (ngx_uint_t )1;
#line 509
        goto while_break___0;
      }
#line 497
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 513
    n = (ngx_uint_t )0;
#line 513
    d = (ngx_uint_t )16;
    {
#line 513
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 513
      if (! (d <= 1024UL)) {
#line 513
        goto while_break___1;
      }
      {
#line 514
      tmp___0 = n;
#line 514
      n ++;
#line 514
      tmp___1 = strcmp((char const   *)(value + i)->data, debug_levels[tmp___0]);
      }
#line 514
      if (tmp___1 == 0) {
#line 515
        if (log->log_level & 0xffffffff8000000fUL) {
          {
#line 516
          ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid log level \"%V\"", value + i);
          }
#line 519
          return ((char *)((void *)-1));
        }
#line 522
        log->log_level |= d;
#line 523
        found = (ngx_uint_t )1;
#line 524
        goto while_break___1;
      }
#line 513
      d <<= 1;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 529
    if (! found) {
      {
#line 530
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid log level \"%V\"", value + i);
      }
#line 532
      return ((char *)((void *)-1));
    }
#line 494
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  if (log->log_level == 8UL) {
#line 537
    log->log_level = (ngx_uint_t )2147483632;
  }
#line 540
  return ((char *)((void *)0));
}
}
#line 544 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static char *ngx_error_log(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_log_t *dummy ;
  char *tmp ;

  {
  {
#line 549
  dummy = & (cf->cycle)->new_log;
#line 551
  tmp = ngx_log_set_log(cf, & dummy);
  }
#line 551
  return (tmp);
}
}
#line 555 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
char *ngx_log_set_log(ngx_conf_t *cf , ngx_log_t **head___0 ) 
{ 
  ngx_log_t *new_log ;
  ngx_str_t *value ;
  ngx_str_t name ;
  ngx_syslog_peer_t *peer ;
  void *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  char *__cil_tmp14 ;

  {
#line 562
  if ((unsigned long )*head___0 != (unsigned long )((void *)0)) {
#line 562
    if ((*head___0)->log_level == 0UL) {
#line 563
      new_log = *head___0;
    } else {
#line 562
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 567
    tmp = ngx_pcalloc(cf->pool, sizeof(ngx_log_t ));
#line 567
    new_log = (ngx_log_t *)tmp;
    }
#line 568
    if ((unsigned long )new_log == (unsigned long )((void *)0)) {
#line 569
      return ((char *)((void *)-1));
    }
#line 572
    if ((unsigned long )*head___0 == (unsigned long )((void *)0)) {
#line 573
      *head___0 = new_log;
    }
  }
  {
#line 577
  value = (ngx_str_t *)(cf->args)->elts;
#line 579
  tmp___4 = strcmp((char const   *)(value + 1)->data, "stderr");
  }
#line 579
  if (tmp___4 == 0) {
    {
#line 580
    name.len = (size_t )0;
#line 580
    name.data = (u_char *)((void *)0);
#line 581
    (cf->cycle)->log_use_stderr = (ngx_uint_t )1;
#line 583
    new_log->file = ngx_conf_open_file(cf->cycle, & name);
    }
#line 584
    if ((unsigned long )new_log->file == (unsigned long )((void *)0)) {
#line 585
      return ((char *)((void *)-1));
    }
  } else {
    {
#line 588
    tmp___3 = strncmp((char const   *)(value + 1)->data, "memory:", (size_t )7);
    }
#line 588
    if (tmp___3 == 0) {
      {
#line 642
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "nginx was built without debug support");
      }
#line 644
      return ((char *)((void *)-1));
    } else {
      {
#line 647
      tmp___2 = strncmp((char const   *)(value + 1)->data, "syslog:", (size_t )7);
      }
#line 647
      if (tmp___2 == 0) {
        {
#line 648
        tmp___0 = ngx_pcalloc(cf->pool, sizeof(ngx_syslog_peer_t ));
#line 648
        peer = (ngx_syslog_peer_t *)tmp___0;
        }
#line 649
        if ((unsigned long )peer == (unsigned long )((void *)0)) {
#line 650
          return ((char *)((void *)-1));
        }
        {
#line 653
        tmp___1 = ngx_syslog_process_conf(cf, peer);
        }
#line 653
        if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
#line 654
          return ((char *)((void *)-1));
        }
#line 657
        new_log->writer = & ngx_syslog_writer;
#line 658
        new_log->wdata = (void *)peer;
      } else {
        {
#line 661
        new_log->file = ngx_conf_open_file(cf->cycle, value + 1);
        }
#line 662
        if ((unsigned long )new_log->file == (unsigned long )((void *)0)) {
#line 663
          return ((char *)((void *)-1));
        }
      }
    }
  }
  {
#line 667
  tmp___5 = ngx_log_set_levels(cf, new_log);
  }
#line 667
  if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 668
    return ((char *)((void *)-1));
  }
#line 671
  if ((unsigned long )*head___0 != (unsigned long )new_log) {
    {
#line 672
    ngx_log_insert(*head___0, new_log);
    }
  }
#line 675
  return ((char *)((void *)0));
}
}
#line 679 "/home/khheo/project/nginx-release-1.13.8/src/core/ngx_log.c"
static void ngx_log_insert(ngx_log_t *log , ngx_log_t *new_log ) 
{ 
  ngx_log_t tmp ;

  {
#line 684
  if (new_log->log_level > log->log_level) {
#line 691
    tmp = *log;
#line 692
    *log = *new_log;
#line 693
    *new_log = tmp;
#line 695
    log->next = new_log;
#line 696
    return;
  }
  {
#line 699
  while (1) {
    while_continue: /* CIL Label */ ;
#line 699
    if (! log->next) {
#line 699
      goto while_break;
    }
#line 700
    if (new_log->log_level > (log->next)->log_level) {
#line 701
      new_log->next = log->next;
#line 702
      log->next = new_log;
#line 703
      return;
    }
#line 706
    log = log->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 709
  log->next = new_log;
#line 710
  return;
}
}
/* compiler builtin: 
   void *__builtin_memset(void * , int  , int  ) ;  */
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 250 "src/core/ngx_log.h"
__inline static void ngx_write_stderr(char *text ) 
{ 
  size_t tmp ;

  {
  {
#line 253
  tmp = strlen((char const   *)text);
#line 253
  ngx_write_fd(2, (void *)text, tmp);
  }
#line 254
  return;
}
}
#line 257 "src/core/ngx_log.h"
__inline static void ngx_write_stdout(char *text ) 
{ 
  size_t tmp ;

  {
  {
#line 260
  tmp = strlen((char const   *)text);
#line 260
  ngx_write_fd(1, (void *)text, tmp);
  }
#line 261
  return;
}
}
#line 13 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static void ngx_show_version_info(void) ;
#line 14
static ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle ) ;
#line 15
static void ngx_cleanup_environment(void *data ) ;
#line 16
static ngx_int_t ngx_get_options(int argc , char * const  *argv ) ;
#line 17
static ngx_int_t ngx_process_options(ngx_cycle_t *cycle ) ;
#line 18
static ngx_int_t ngx_save_argv(ngx_cycle_t *cycle , int argc , char * const  *argv ) ;
#line 19
static void *ngx_core_module_create_conf(ngx_cycle_t *cycle ) ;
#line 20
static char *ngx_core_module_init_conf(ngx_cycle_t *cycle , void *conf ) ;
#line 21
static char *ngx_set_user(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 22
static char *ngx_set_env(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 23
static char *ngx_set_priority(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 24
static char *ngx_set_cpu_affinity(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 26
static char *ngx_set_worker_processes(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 28
static char *ngx_load_module(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) ;
#line 30
static void ngx_unload_module(void *data ) ;
#line 34 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_conf_enum_t ngx_debug_points[3]  = {      {{sizeof("stop") - 1UL, (u_char *)"stop"}, (ngx_uint_t )1}, 
        {{sizeof("abort") - 1UL, (u_char *)"abort"}, (ngx_uint_t )2}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0}};
#line 41 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_command_t ngx_core_commands[17]  = 
#line 41
  {      {{sizeof("daemon") - 1UL, (u_char *)"daemon"}, (ngx_uint_t )16843264, & ngx_conf_set_flag_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->daemon), (void *)0}, 
        {{sizeof("master_process") - 1UL,
       (u_char *)"master_process"}, (ngx_uint_t )16843264, & ngx_conf_set_flag_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->master), (void *)0}, 
        {{sizeof("timer_resolution") - 1UL,
       (u_char *)"timer_resolution"}, (ngx_uint_t )16842754, & ngx_conf_set_msec_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->timer_resolution),
      (void *)0}, 
        {{sizeof("pid") - 1UL, (u_char *)"pid"}, (ngx_uint_t )16842754, & ngx_conf_set_str_slot,
      (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->pid), (void *)0}, 
        {{sizeof("lock_file") - 1UL,
       (u_char *)"lock_file"}, (ngx_uint_t )16842754, & ngx_conf_set_str_slot, (ngx_uint_t )0,
      (unsigned long )(& ((ngx_core_conf_t *)0)->lock_file), (void *)0}, 
        {{sizeof("worker_processes") - 1UL, (u_char *)"worker_processes"}, (ngx_uint_t )16842754,
      & ngx_set_worker_processes, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("debug_points") - 1UL, (u_char *)"debug_points"}, (ngx_uint_t )16842754,
      & ngx_conf_set_enum_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->debug_points),
      (void *)(& ngx_debug_points)}, 
        {{sizeof("user") - 1UL, (u_char *)"user"}, (ngx_uint_t )16842758, & ngx_set_user,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("worker_priority") - 1UL, (u_char *)"worker_priority"}, (ngx_uint_t )16842754,
      & ngx_set_priority, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("worker_cpu_affinity") - 1UL, (u_char *)"worker_cpu_affinity"}, (ngx_uint_t )16844800,
      & ngx_set_cpu_affinity, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("worker_rlimit_nofile") - 1UL, (u_char *)"worker_rlimit_nofile"}, (ngx_uint_t )16842754,
      & ngx_conf_set_num_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->rlimit_nofile),
      (void *)0}, 
        {{sizeof("worker_rlimit_core") - 1UL, (u_char *)"worker_rlimit_core"}, (ngx_uint_t )16842754,
      & ngx_conf_set_off_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->rlimit_core),
      (void *)0}, 
        {{sizeof("worker_shutdown_timeout") - 1UL, (u_char *)"worker_shutdown_timeout"},
      (ngx_uint_t )16842754, & ngx_conf_set_msec_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->shutdown_timeout),
      (void *)0}, 
        {{sizeof("working_directory") - 1UL, (u_char *)"working_directory"}, (ngx_uint_t )16842754,
      & ngx_conf_set_str_slot, (ngx_uint_t )0, (unsigned long )(& ((ngx_core_conf_t *)0)->working_directory),
      (void *)0}, 
        {{sizeof("env") - 1UL, (u_char *)"env"}, (ngx_uint_t )16842754, & ngx_set_env,
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{sizeof("load_module") - 1UL, (u_char *)"load_module"}, (ngx_uint_t )16842754,
      & ngx_load_module, (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}, 
        {{(size_t )0, (u_char *)((void *)0)}, (ngx_uint_t )0, (char *(*)(ngx_conf_t *cf ,
                                                                      ngx_command_t *cmd ,
                                                                      void *conf ))((void *)0),
      (ngx_uint_t )0, (ngx_uint_t )0, (void *)0}};
#line 159 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_core_module_t ngx_core_module_ctx  =    {{sizeof("core") - 1UL, (u_char *)"core"}, & ngx_core_module_create_conf, & ngx_core_module_init_conf};
#line 166 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
ngx_module_t ngx_core_module  = 
#line 166
     {(ngx_uint_t )-1, (ngx_uint_t )-1, (char *)((void *)0), (ngx_uint_t )0, (ngx_uint_t )0,
    (ngx_uint_t )1013008, "8,4,8,0000111111010111001110101111000110", (void *)(& ngx_core_module_ctx),
    ngx_core_commands, (ngx_uint_t )1163022147, (ngx_int_t (*)(ngx_log_t *log ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0),
    (ngx_int_t (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (void (*)(ngx_cycle_t *cycle ))((void *)0), (void (*)(ngx_cycle_t *cycle ))((void *)0),
    (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0, (uintptr_t )0,
    (uintptr_t )0, (uintptr_t )0};
#line 182 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_uint_t ngx_show_help  ;
#line 183 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_uint_t ngx_show_version  ;
#line 184 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_uint_t ngx_show_configure  ;
#line 185 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static u_char *ngx_prefix  ;
#line 186 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static u_char *ngx_conf_file  ;
#line 187 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static u_char *ngx_conf_params  ;
#line 188 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char *ngx_signal  ;
#line 191 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char **ngx_os_environ  ;
#line 194 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
int main(int argc , char * const  *argv ) 
{ 
  ngx_buf_t *b ;
  ngx_log_t *log ;
  ngx_uint_t i ;
  ngx_cycle_t *cycle ;
  ngx_cycle_t init_cycle ;
  ngx_conf_dump_t *cd ;
  ngx_core_conf_t *ccf ;
  ngx_int_t tmp ;
  ngx_int_t tmp___0 ;
  ngx_int_t tmp___1 ;
  ngx_int_t tmp___2 ;
  ngx_int_t tmp___3 ;
  ngx_int_t tmp___4 ;
  ngx_int_t tmp___5 ;
  ngx_int_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_int_t tmp___8 ;
  ngx_int_t tmp___9 ;
  ngx_int_t tmp___10 ;
  ngx_int_t tmp___11 ;
  int *tmp___12 ;
  int tmp___13 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;

  {
  {
#line 206
  tmp = ngx_strerror_init();
  }
#line 206
  if (tmp != 0L) {
#line 207
    return (1);
  }
  {
#line 210
  tmp___0 = ngx_get_options(argc, argv);
  }
#line 210
  if (tmp___0 != 0L) {
#line 211
    return (1);
  }
#line 214
  if (ngx_show_version) {
    {
#line 215
    ngx_show_version_info();
    }
#line 217
    if (! ngx_test_config) {
#line 218
      return (0);
    }
  }
  {
#line 222
  ngx_max_sockets = (ngx_int_t )-1;
#line 224
  ngx_time_init();
#line 227
  ngx_regex_init();
#line 230
  ngx_pid = getpid();
#line 231
  ngx_parent = getppid();
#line 233
  log = ngx_log_init(ngx_prefix);
  }
#line 234
  if ((unsigned long )log == (unsigned long )((void *)0)) {
#line 235
    return (1);
  }
  {
#line 248
  memset((void *)(& init_cycle), 0, sizeof(ngx_cycle_t ));
#line 249
  init_cycle.log = log;
#line 250
  ngx_cycle = (ngx_cycle_t volatile   *)(& init_cycle);
#line 252
  init_cycle.pool = ngx_create_pool((size_t )1024, log);
  }
#line 253
  if ((unsigned long )init_cycle.pool == (unsigned long )((void *)0)) {
#line 254
    return (1);
  }
  {
#line 257
  tmp___1 = ngx_save_argv(& init_cycle, argc, argv);
  }
#line 257
  if (tmp___1 != 0L) {
#line 258
    return (1);
  }
  {
#line 261
  tmp___2 = ngx_process_options(& init_cycle);
  }
#line 261
  if (tmp___2 != 0L) {
#line 262
    return (1);
  }
  {
#line 265
  tmp___3 = ngx_os_init(log);
  }
#line 265
  if (tmp___3 != 0L) {
#line 266
    return (1);
  }
  {
#line 273
  tmp___4 = ngx_crc32_table_init();
  }
#line 273
  if (tmp___4 != 0L) {
#line 274
    return (1);
  }
  {
#line 281
  ngx_slab_sizes_init();
#line 283
  tmp___5 = ngx_add_inherited_sockets(& init_cycle);
  }
#line 283
  if (tmp___5 != 0L) {
#line 284
    return (1);
  }
  {
#line 287
  tmp___6 = ngx_preinit_modules();
  }
#line 287
  if (tmp___6 != 0L) {
#line 288
    return (1);
  }
  {
#line 291
  cycle = ngx_init_cycle(& init_cycle);
  }
#line 292
  if ((unsigned long )cycle == (unsigned long )((void *)0)) {
#line 293
    if (ngx_test_config) {
      {
#line 294
      ngx_log_stderr(0, "configuration file %s test failed", init_cycle.conf_file.data);
      }
    }
#line 298
    return (1);
  }
#line 301
  if (ngx_test_config) {
#line 302
    if (! ngx_quiet_mode) {
      {
#line 303
      ngx_log_stderr(0, "configuration file %s test is successful", cycle->conf_file.data);
      }
    }
#line 307
    if (ngx_dump_config) {
#line 308
      cd = (ngx_conf_dump_t *)cycle->config_dump.elts;
#line 310
      i = (ngx_uint_t )0;
      {
#line 310
      while (1) {
        while_continue: /* CIL Label */ ;
#line 310
        if (! (i < cycle->config_dump.nelts)) {
#line 310
          goto while_break;
        }
        {
#line 312
        ngx_write_stdout((char *)"# configuration file ");
#line 313
        ngx_write_fd(1, (void *)(cd + i)->name.data, (cd + i)->name.len);
#line 315
        ngx_write_stdout((char *)":\n");
#line 317
        b = (cd + i)->buffer;
#line 319
        ngx_write_fd(1, (void *)b->pos, (size_t )(b->last - b->pos));
#line 320
        ngx_write_stdout((char *)"\n");
#line 310
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 324
    return (0);
  }
#line 327
  if (ngx_signal) {
    {
#line 328
    tmp___7 = ngx_signal_process(cycle, ngx_signal);
    }
#line 328
    return ((int )tmp___7);
  }
  {
#line 331
  ngx_os_status(cycle->log);
#line 333
  ngx_cycle = (ngx_cycle_t volatile   *)cycle;
#line 335
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
  }
#line 337
  if (ccf->master) {
#line 337
    if (ngx_process == 0UL) {
#line 338
      ngx_process = (ngx_uint_t )1;
    }
  }
  {
#line 343
  tmp___8 = ngx_init_signals(cycle->log);
  }
#line 343
  if (tmp___8 != 0L) {
#line 344
    return (1);
  }
#line 347
  if (! ngx_inherited) {
#line 347
    if (ccf->daemon) {
      {
#line 348
      tmp___9 = ngx_daemon(cycle->log);
      }
#line 348
      if (tmp___9 != 0L) {
#line 349
        return (1);
      }
#line 352
      ngx_daemonized = (ngx_uint_t )1;
    }
  }
#line 355
  if (ngx_inherited) {
#line 356
    ngx_daemonized = (ngx_uint_t )1;
  }
  {
#line 361
  tmp___10 = ngx_create_pidfile(& ccf->pid, cycle->log);
  }
#line 361
  if (tmp___10 != 0L) {
#line 362
    return (1);
  }
  {
#line 365
  tmp___11 = ngx_log_redirect_stderr(cycle);
  }
#line 365
  if (tmp___11 != 0L) {
#line 366
    return (1);
  }
#line 369
  if ((log->file)->fd != 2) {
    {
#line 370
    tmp___13 = close((log->file)->fd);
    }
#line 370
    if (tmp___13 == -1) {
#line 371
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 371
        tmp___12 = __errno_location();
#line 371
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___12, "close() built-in log failed");
        }
      }
    }
  }
#line 376
  ngx_use_stderr = (ngx_uint_t )0;
#line 378
  if (ngx_process == 0UL) {
    {
#line 379
    ngx_single_process_cycle(cycle);
    }
  } else {
    {
#line 382
    ngx_master_process_cycle(cycle);
    }
  }
#line 385
  return (0);
}
}
#line 389 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static void ngx_show_version_info(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
#line 392
  ngx_write_stderr((char *)"nginx version: nginx/1.13.8\n");
  }
#line 394
  if (ngx_show_help) {
    {
#line 395
    ngx_write_stderr((char *)"Usage: nginx [-?hvVtTq] [-s signal] [-c filename] [-p prefix] [-g directives]\n\nOptions:\n  -?,-h         : this help\n  -v            : show version and exit\n  -V            : show version and configure options then exit\n  -t            : test configuration and exit\n  -T            : test configuration, dump it and exit\n  -q            : suppress non-error messages during configuration testing\n  -s signal     : send signal to a master process: stop, quit, reopen, reload\n  -p prefix     : set prefix path (default: /usr/local/nginx/)\n  -c filename   : set configuration file (default: conf/nginx.conf)\n  -g directives : set global directives out of configuration file\n\n");
    }
  }
#line 424
  if (ngx_show_configure) {
    {
#line 427
    ngx_write_stderr((char *)"built by gcc 5.3.0 (Homebrew gcc 5.3.0) \n");
#line 446
    ngx_write_stderr((char *)"configure arguments:\n");
    }
  }
#line 448
  return;
}
}
#line 451 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle ) 
{ 
  u_char *p ;
  u_char *v ;
  u_char *inherited ;
  ngx_int_t s ;
  ngx_listening_t *ls ;
  char *tmp ;
  ngx_int_t tmp___0 ;
  void *tmp___1 ;
  ngx_int_t tmp___2 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
#line 458
  tmp = getenv("NGINX");
#line 458
  inherited = (u_char *)tmp;
  }
#line 460
  if ((unsigned long )inherited == (unsigned long )((void *)0)) {
#line 461
    return ((ngx_int_t )0);
  }
#line 464
  if ((cycle->log)->log_level >= 6UL) {
    {
#line 464
    ngx_log_error_core((ngx_uint_t )6, cycle->log, 0, "using inherited sockets from \"%s\"",
                       inherited);
    }
  }
  {
#line 467
  tmp___0 = ngx_array_init(& cycle->listening, cycle->pool, (ngx_uint_t )10, sizeof(ngx_listening_t ));
  }
#line 467
  if (tmp___0 != 0L) {
#line 471
    return ((ngx_int_t )-1);
  }
#line 474
  p = inherited;
#line 474
  v = p;
  {
#line 474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 474
    if (! *p) {
#line 474
      goto while_break;
    }
#line 475
    if ((int )*p == 58) {
#line 475
      goto _L;
    } else
#line 475
    if ((int )*p == 59) {
      _L: /* CIL Label */ 
      {
#line 476
      s = ngx_atoi(v, (size_t )(p - v));
      }
#line 477
      if (s == -1L) {
#line 478
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 478
          ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "invalid socket number \"%s\" in NGINX environment variable, ignoring the rest of the variable",
                             v);
          }
        }
#line 482
        goto while_break;
      }
      {
#line 485
      v = p + 1;
#line 487
      tmp___1 = ngx_array_push(& cycle->listening);
#line 487
      ls = (ngx_listening_t *)tmp___1;
      }
#line 488
      if ((unsigned long )ls == (unsigned long )((void *)0)) {
#line 489
        return ((ngx_int_t )-1);
      }
      {
#line 492
      memset((void *)ls, 0, sizeof(ngx_listening_t ));
#line 494
      ls->fd = (ngx_socket_t )s;
      }
    }
#line 474
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  if ((unsigned long )v != (unsigned long )p) {
#line 499
    if ((cycle->log)->log_level >= 1UL) {
      {
#line 499
      ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "invalid socket number \"%s\" in NGINX environment variable, ignoring",
                         v);
      }
    }
  }
  {
#line 504
  ngx_inherited = (ngx_uint_t )1;
#line 506
  tmp___2 = ngx_set_inherited_sockets(cycle);
  }
#line 506
  return (tmp___2);
}
}
#line 510 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
char **ngx_set_environment(ngx_cycle_t *cycle , ngx_uint_t *last ) 
{ 
  char **p ;
  char **env ;
  ngx_str_t *var ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_core_conf_t *ccf ;
  ngx_pool_cleanup_t *cln ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  ngx_uint_t tmp___5 ;
  ngx_uint_t tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp19 ;

  {
#line 519
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 521
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 521
    if (ccf->environment) {
#line 522
      return (ccf->environment);
    }
  }
#line 525
  var = (ngx_str_t *)ccf->env.elts;
#line 527
  i = (ngx_uint_t )0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! (i < ccf->env.nelts)) {
#line 527
      goto while_break;
    }
    {
#line 528
    tmp = strcmp((char const   *)(var + i)->data, "TZ");
    }
#line 528
    if (tmp == 0) {
#line 531
      goto tz_found;
    } else {
      {
#line 528
      tmp___0 = strncmp((char const   *)(var + i)->data, "TZ=", (size_t )3);
      }
#line 528
      if (tmp___0 == 0) {
#line 531
        goto tz_found;
      }
    }
#line 527
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 535
  tmp___1 = ngx_array_push(& ccf->env);
#line 535
  var = (ngx_str_t *)tmp___1;
  }
#line 536
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 537
    return ((char **)((void *)0));
  }
#line 540
  var->len = (size_t )2;
#line 541
  var->data = (u_char *)"TZ";
#line 543
  var = (ngx_str_t *)ccf->env.elts;
  tz_found: 
#line 547
  n = (ngx_uint_t )0;
#line 549
  i = (ngx_uint_t )0;
  {
#line 549
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 549
    if (! (i < ccf->env.nelts)) {
#line 549
      goto while_break___0;
    }
#line 551
    if ((int )*((var + i)->data + (var + i)->len) == 61) {
#line 552
      n ++;
#line 553
      goto __Cont;
    }
#line 556
    p = ngx_os_environ;
    {
#line 556
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 556
      if (! *p) {
#line 556
        goto while_break___1;
      }
      {
#line 558
      tmp___2 = strncmp((char const   *)*p, (char const   *)(var + i)->data, (var + i)->len);
      }
#line 558
      if (tmp___2 == 0) {
#line 558
        if ((int )*(*p + (var + i)->len) == 61) {
#line 561
          n ++;
#line 562
          goto while_break___1;
        }
      }
#line 556
      p ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 549
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 567
  if (last) {
    {
#line 568
    tmp___3 = ngx_alloc(((*last + n) + 1UL) * sizeof(char *), cycle->log);
#line 568
    env = (char **)tmp___3;
    }
#line 569
    if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 570
      return ((char **)((void *)0));
    }
#line 573
    *last = n;
  } else {
    {
#line 576
    cln = ngx_pool_cleanup_add(cycle->pool, (size_t )0);
    }
#line 577
    if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 578
      return ((char **)((void *)0));
    }
    {
#line 581
    tmp___4 = ngx_alloc((n + 1UL) * sizeof(char *), cycle->log);
#line 581
    env = (char **)tmp___4;
    }
#line 582
    if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 583
      return ((char **)((void *)0));
    }
#line 586
    cln->handler = & ngx_cleanup_environment;
#line 587
    cln->data = (void *)env;
  }
#line 590
  n = (ngx_uint_t )0;
#line 592
  i = (ngx_uint_t )0;
  {
#line 592
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 592
    if (! (i < ccf->env.nelts)) {
#line 592
      goto while_break___2;
    }
#line 594
    if ((int )*((var + i)->data + (var + i)->len) == 61) {
#line 595
      tmp___5 = n;
#line 595
      n ++;
#line 595
      *(env + tmp___5) = (char *)(var + i)->data;
#line 596
      goto __Cont___0;
    }
#line 599
    p = ngx_os_environ;
    {
#line 599
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 599
      if (! *p) {
#line 599
        goto while_break___3;
      }
      {
#line 601
      tmp___7 = strncmp((char const   *)*p, (char const   *)(var + i)->data, (var + i)->len);
      }
#line 601
      if (tmp___7 == 0) {
#line 601
        if ((int )*(*p + (var + i)->len) == 61) {
#line 604
          tmp___6 = n;
#line 604
          n ++;
#line 604
          *(env + tmp___6) = *p;
#line 605
          goto while_break___3;
        }
      }
#line 599
      p ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont___0: /* CIL Label */ 
#line 592
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 610
  *(env + n) = (char *)((void *)0);
#line 612
  if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 613
    ccf->environment = env;
#line 614
    environ = env;
  }
#line 617
  return (env);
}
}
#line 621 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static void ngx_cleanup_environment(void *data ) 
{ 
  char **env ;

  {
#line 624
  env = (char **)data;
#line 626
  if ((unsigned long )environ == (unsigned long )env) {
#line 633
    return;
  }
  {
#line 636
  free((void *)env);
  }
#line 637
  return;
}
}
#line 640 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
ngx_pid_t ngx_exec_new_binary(ngx_cycle_t *cycle , char * const  *argv ) 
{ 
  char **env ;
  char *var ;
  u_char *p ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_pid_t pid ;
  ngx_exec_ctx_t ctx ;
  ngx_core_conf_t *ccf ;
  ngx_listening_t *ls ;
  void *tmp ;
  void *tmp___0 ;
  ngx_uint_t tmp___1 ;
  ngx_uint_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;

  {
  {
#line 651
  memset((void *)(& ctx), 0, sizeof(ngx_exec_ctx_t ));
#line 653
  ctx.path = (char *)*(argv + 0);
#line 654
  ctx.name = (char *)"new binary process";
#line 655
  ctx.argv = argv;
#line 657
  n = (ngx_uint_t )2;
#line 658
  env = ngx_set_environment(cycle, & n);
  }
#line 659
  if ((unsigned long )env == (unsigned long )((void *)0)) {
#line 660
    return (-1);
  }
  {
#line 663
  tmp = ngx_alloc((sizeof("NGINX") + cycle->listening.nelts * ((sizeof("-2147483648") - 1UL) + 1UL)) + 2UL,
                  cycle->log);
#line 663
  var = (char *)tmp;
  }
#line 666
  if ((unsigned long )var == (unsigned long )((void *)0)) {
    {
#line 667
    free((void *)env);
    }
#line 668
    return (-1);
  }
  {
#line 671
  tmp___0 = memcpy((void */* __restrict  */)var, (void const   */* __restrict  */)"NGINX=",
                   sizeof("NGINX"));
#line 671
  p = (u_char *)tmp___0 + sizeof("NGINX");
#line 673
  ls = (ngx_listening_t *)cycle->listening.elts;
#line 674
  i = (ngx_uint_t )0;
  }
  {
#line 674
  while (1) {
    while_continue: /* CIL Label */ ;
#line 674
    if (! (i < cycle->listening.nelts)) {
#line 674
      goto while_break;
    }
    {
#line 675
    p = ngx_sprintf(p, "%ud;", (ls + i)->fd);
#line 674
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 678
  *p = (u_char )'\000';
#line 680
  tmp___1 = n;
#line 680
  n ++;
#line 680
  *(env + tmp___1) = var;
#line 686
  tmp___2 = n;
#line 686
  n ++;
#line 686
  *(env + tmp___2) = (char *)"SPARE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";
#line 694
  *(env + n) = (char *)((void *)0);
#line 705
  ctx.envp = (char * const  *)env;
#line 707
  ccf = (ngx_core_conf_t *)*(cycle->conf_ctx + ngx_core_module.index);
#line 709
  tmp___4 = rename((char const   *)ccf->pid.data, (char const   *)ccf->oldpid.data);
  }
#line 709
  if (tmp___4 == -1) {
#line 710
    if ((cycle->log)->log_level >= 2UL) {
      {
#line 710
      tmp___3 = __errno_location();
#line 710
      ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___3, "rename() %s to %s failed before executing new binary process \"%s\"",
                         ccf->pid.data, ccf->oldpid.data, *(argv + 0));
      }
    }
    {
#line 715
    free((void *)env);
#line 716
    free((void *)var);
    }
#line 718
    return (-1);
  }
  {
#line 721
  pid = ngx_execute(cycle, & ctx);
  }
#line 723
  if (pid == -1) {
    {
#line 724
    tmp___6 = rename((char const   *)ccf->oldpid.data, (char const   *)ccf->pid.data);
    }
#line 724
    if (tmp___6 == -1) {
#line 727
      if ((cycle->log)->log_level >= 2UL) {
        {
#line 727
        tmp___5 = __errno_location();
#line 727
        ngx_log_error_core((ngx_uint_t )2, cycle->log, *tmp___5, "rename() %s back to %s failed after an attempt to execute new binary process \"%s\"",
                           ccf->oldpid.data, ccf->pid.data, *(argv + 0));
        }
      }
    }
  }
  {
#line 734
  free((void *)env);
#line 735
  free((void *)var);
  }
#line 737
  return (pid);
}
}
#line 741 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_int_t ngx_get_options(int argc , char * const  *argv ) 
{ 
  u_char *p ;
  ngx_int_t i ;
  u_char *tmp ;
  u_char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 747
  i = (ngx_int_t )1;
  {
#line 747
  while (1) {
    while_continue: /* CIL Label */ ;
#line 747
    if (! (i < (ngx_int_t )argc)) {
#line 747
      goto while_break;
    }
#line 749
    p = (u_char *)*(argv + i);
#line 751
    tmp = p;
#line 751
    p ++;
#line 751
    if ((int )*tmp != 45) {
      {
#line 752
      ngx_log_stderr(0, "invalid option: \"%s\"", *(argv + i));
      }
#line 753
      return ((ngx_int_t )-1);
    }
    {
#line 756
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 756
      if (! *p) {
#line 756
        goto while_break___0;
      }
#line 758
      tmp___0 = p;
#line 758
      p ++;
      {
#line 761
      if ((int )*tmp___0 == 104) {
#line 761
        goto case_104;
      }
#line 761
      if ((int )*tmp___0 == 63) {
#line 761
        goto case_104;
      }
#line 766
      if ((int )*tmp___0 == 118) {
#line 766
        goto case_118;
      }
#line 770
      if ((int )*tmp___0 == 86) {
#line 770
        goto case_86;
      }
#line 775
      if ((int )*tmp___0 == 116) {
#line 775
        goto case_116;
      }
#line 779
      if ((int )*tmp___0 == 84) {
#line 779
        goto case_84;
      }
#line 784
      if ((int )*tmp___0 == 113) {
#line 784
        goto case_113;
      }
#line 788
      if ((int )*tmp___0 == 112) {
#line 788
        goto case_112;
      }
#line 802
      if ((int )*tmp___0 == 99) {
#line 802
        goto case_99;
      }
#line 816
      if ((int )*tmp___0 == 103) {
#line 816
        goto case_103;
      }
#line 830
      if ((int )*tmp___0 == 115) {
#line 830
        goto case_115;
      }
#line 854
      goto switch_default;
      case_104: /* CIL Label */ 
      case_63: /* CIL Label */ 
#line 762
      ngx_show_version = (ngx_uint_t )1;
#line 763
      ngx_show_help = (ngx_uint_t )1;
#line 764
      goto switch_break;
      case_118: /* CIL Label */ 
#line 767
      ngx_show_version = (ngx_uint_t )1;
#line 768
      goto switch_break;
      case_86: /* CIL Label */ 
#line 771
      ngx_show_version = (ngx_uint_t )1;
#line 772
      ngx_show_configure = (ngx_uint_t )1;
#line 773
      goto switch_break;
      case_116: /* CIL Label */ 
#line 776
      ngx_test_config = (ngx_uint_t )1;
#line 777
      goto switch_break;
      case_84: /* CIL Label */ 
#line 780
      ngx_test_config = (ngx_uint_t )1;
#line 781
      ngx_dump_config = (ngx_uint_t )1;
#line 782
      goto switch_break;
      case_113: /* CIL Label */ 
#line 785
      ngx_quiet_mode = (ngx_uint_t )1;
#line 786
      goto switch_break;
      case_112: /* CIL Label */ 
#line 789
      if (*p) {
#line 790
        ngx_prefix = p;
#line 791
        goto next;
      }
#line 794
      i ++;
#line 794
      if (*(argv + i)) {
#line 795
        ngx_prefix = (u_char *)*(argv + i);
#line 796
        goto next;
      }
      {
#line 799
      ngx_log_stderr(0, "option \"-p\" requires directory name");
      }
#line 800
      return ((ngx_int_t )-1);
      case_99: /* CIL Label */ 
#line 803
      if (*p) {
#line 804
        ngx_conf_file = p;
#line 805
        goto next;
      }
#line 808
      i ++;
#line 808
      if (*(argv + i)) {
#line 809
        ngx_conf_file = (u_char *)*(argv + i);
#line 810
        goto next;
      }
      {
#line 813
      ngx_log_stderr(0, "option \"-c\" requires file name");
      }
#line 814
      return ((ngx_int_t )-1);
      case_103: /* CIL Label */ 
#line 817
      if (*p) {
#line 818
        ngx_conf_params = p;
#line 819
        goto next;
      }
#line 822
      i ++;
#line 822
      if (*(argv + i)) {
#line 823
        ngx_conf_params = (u_char *)*(argv + i);
#line 824
        goto next;
      }
      {
#line 827
      ngx_log_stderr(0, "option \"-g\" requires parameter");
      }
#line 828
      return ((ngx_int_t )-1);
      case_115: /* CIL Label */ 
#line 831
      if (*p) {
#line 832
        ngx_signal = (char *)p;
      } else {
#line 834
        i ++;
#line 834
        if (*(argv + i)) {
#line 835
          ngx_signal = (char *)*(argv + i);
        } else {
          {
#line 838
          ngx_log_stderr(0, "option \"-s\" requires parameter");
          }
#line 839
          return ((ngx_int_t )-1);
        }
      }
      {
#line 842
      tmp___1 = strcmp((char const   *)ngx_signal, "stop");
      }
#line 842
      if (tmp___1 == 0) {
#line 847
        ngx_process = (ngx_uint_t )2;
#line 848
        goto next;
      } else {
        {
#line 842
        tmp___2 = strcmp((char const   *)ngx_signal, "quit");
        }
#line 842
        if (tmp___2 == 0) {
#line 847
          ngx_process = (ngx_uint_t )2;
#line 848
          goto next;
        } else {
          {
#line 842
          tmp___3 = strcmp((char const   *)ngx_signal, "reopen");
          }
#line 842
          if (tmp___3 == 0) {
#line 847
            ngx_process = (ngx_uint_t )2;
#line 848
            goto next;
          } else {
            {
#line 842
            tmp___4 = strcmp((char const   *)ngx_signal, "reload");
            }
#line 842
            if (tmp___4 == 0) {
#line 847
              ngx_process = (ngx_uint_t )2;
#line 848
              goto next;
            }
          }
        }
      }
      {
#line 851
      ngx_log_stderr(0, "invalid option: \"-s %s\"", ngx_signal);
      }
#line 852
      return ((ngx_int_t )-1);
      switch_default: /* CIL Label */ 
      {
#line 855
      ngx_log_stderr(0, "invalid option: \"%c\"", (int )*(p - 1));
      }
#line 856
      return ((ngx_int_t )-1);
      switch_break: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    next: 
#line 862
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 747
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 865
  return ((ngx_int_t )0);
}
}
#line 869 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_int_t ngx_save_argv(ngx_cycle_t *cycle , int argc , char * const  *argv ) 
{ 
  size_t len ;
  ngx_int_t i ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 882
  ngx_os_argv = (char **)argv;
#line 883
  ngx_argc = argc;
#line 885
  tmp = ngx_alloc((unsigned long )(argc + 1) * sizeof(char *), cycle->log);
#line 885
  ngx_argv = (char **)tmp;
  }
#line 886
  if ((unsigned long )ngx_argv == (unsigned long )((void *)0)) {
#line 887
    return ((ngx_int_t )-1);
  }
#line 890
  i = (ngx_int_t )0;
  {
#line 890
  while (1) {
    while_continue: /* CIL Label */ ;
#line 890
    if (! (i < (ngx_int_t )argc)) {
#line 890
      goto while_break;
    }
    {
#line 891
    tmp___0 = strlen((char const   *)*(argv + i));
#line 891
    len = tmp___0 + 1UL;
#line 893
    tmp___1 = ngx_alloc(len, cycle->log);
#line 893
    *(ngx_argv + i) = (char *)tmp___1;
    }
#line 894
    if ((unsigned long )*(ngx_argv + i) == (unsigned long )((void *)0)) {
#line 895
      return ((ngx_int_t )-1);
    }
    {
#line 898
    ngx_cpystrn((u_char *)*(ngx_argv + i), (u_char *)*(argv + i), len);
#line 890
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 901
  *(ngx_argv + i) = (char *)((void *)0);
#line 905
  ngx_os_environ = environ;
#line 907
  return ((ngx_int_t )0);
}
}
#line 911 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_int_t ngx_process_options(ngx_cycle_t *cycle ) 
{ 
  u_char *p ;
  size_t len ;
  void *tmp ;
  size_t tmp___0 ;
  ngx_int_t tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 917
  if (ngx_prefix) {
    {
#line 918
    len = strlen((char const   *)ngx_prefix);
#line 919
    p = ngx_prefix;
    }
#line 921
    if (len) {
#line 921
      if (! ((int )*(p + (len - 1UL)) == 47)) {
        {
#line 922
        tmp = ngx_pnalloc(cycle->pool, len + 1UL);
#line 922
        p = (u_char *)tmp;
        }
#line 923
        if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 924
          return ((ngx_int_t )-1);
        }
        {
#line 927
        memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)ngx_prefix,
               len);
#line 928
        tmp___0 = len;
#line 928
        len ++;
#line 928
        *(p + tmp___0) = (u_char )'/';
        }
      }
    }
#line 931
    cycle->conf_prefix.len = len;
#line 932
    cycle->conf_prefix.data = p;
#line 933
    cycle->prefix.len = len;
#line 934
    cycle->prefix.data = p;
  } else {
#line 962
    cycle->conf_prefix.len = sizeof("conf/") - 1UL;
#line 962
    cycle->conf_prefix.data = (u_char *)"conf/";
#line 966
    cycle->prefix.len = sizeof("/usr/local/nginx/") - 1UL;
#line 966
    cycle->prefix.data = (u_char *)"/usr/local/nginx/";
  }
#line 971
  if (ngx_conf_file) {
    {
#line 972
    cycle->conf_file.len = strlen((char const   *)ngx_conf_file);
#line 973
    cycle->conf_file.data = ngx_conf_file;
    }
  } else {
#line 976
    cycle->conf_file.len = sizeof("conf/nginx.conf") - 1UL;
#line 976
    cycle->conf_file.data = (u_char *)"conf/nginx.conf";
  }
  {
#line 979
  tmp___1 = ngx_conf_full_name(cycle, & cycle->conf_file, (ngx_uint_t )0);
  }
#line 979
  if (tmp___1 != 0L) {
#line 980
    return ((ngx_int_t )-1);
  }
#line 983
  p = (cycle->conf_file.data + cycle->conf_file.len) - 1;
  {
#line 983
  while (1) {
    while_continue: /* CIL Label */ ;
#line 983
    if (! ((unsigned long )p > (unsigned long )cycle->conf_file.data)) {
#line 983
      goto while_break;
    }
#line 987
    if ((int )*p == 47) {
#line 988
      cycle->conf_prefix.len = (size_t )((p - (u_char *)ngx_cycle->conf_file.data) + 1L);
#line 989
      cycle->conf_prefix.data = (u_char *)ngx_cycle->conf_file.data;
#line 990
      goto while_break;
    }
#line 983
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 994
  if (ngx_conf_params) {
    {
#line 995
    cycle->conf_param.len = strlen((char const   *)ngx_conf_params);
#line 996
    cycle->conf_param.data = ngx_conf_params;
    }
  }
#line 999
  if (ngx_test_config) {
#line 1000
    (cycle->log)->log_level = (ngx_uint_t )7;
  }
#line 1003
  return ((ngx_int_t )0);
}
}
#line 1007 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static void *ngx_core_module_create_conf(ngx_cycle_t *cycle ) 
{ 
  ngx_core_conf_t *ccf ;
  void *tmp ;
  ngx_int_t tmp___0 ;

  {
  {
#line 1012
  tmp = ngx_pcalloc(cycle->pool, sizeof(ngx_core_conf_t ));
#line 1012
  ccf = (ngx_core_conf_t *)tmp;
  }
#line 1013
  if ((unsigned long )ccf == (unsigned long )((void *)0)) {
#line 1014
    return ((void *)0);
  }
  {
#line 1028
  ccf->daemon = (ngx_flag_t )-1;
#line 1029
  ccf->master = (ngx_flag_t )-1;
#line 1030
  ccf->timer_resolution = (ngx_msec_t )-1;
#line 1031
  ccf->shutdown_timeout = (ngx_msec_t )-1;
#line 1033
  ccf->worker_processes = (ngx_int_t )-1;
#line 1034
  ccf->debug_points = (ngx_int_t )-1;
#line 1036
  ccf->rlimit_nofile = (ngx_int_t )-1;
#line 1037
  ccf->rlimit_core = (off_t )-1;
#line 1039
  ccf->user = (ngx_uid_t )((ngx_uint_t )-1);
#line 1040
  ccf->group = (ngx_gid_t )((ngx_uint_t )-1);
#line 1042
  tmp___0 = ngx_array_init(& ccf->env, cycle->pool, (ngx_uint_t )1, sizeof(ngx_str_t ));
  }
#line 1042
  if (tmp___0 != 0L) {
#line 1045
    return ((void *)0);
  }
#line 1048
  return ((void *)ccf);
}
}
#line 1052 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char *ngx_core_module_init_conf(ngx_cycle_t *cycle , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  ngx_int_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  struct group *grp ;
  struct passwd *pwd ;
  int *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  __uid_t tmp___6 ;
  ngx_int_t tmp___7 ;
  ngx_str_t lock_file ;
  int tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;

  {
#line 1055
  ccf = (ngx_core_conf_t *)conf;
#line 1057
  if (ccf->daemon == -1L) {
#line 1057
    ccf->daemon = (ngx_flag_t )1;
  }
#line 1058
  if (ccf->master == -1L) {
#line 1058
    ccf->master = (ngx_flag_t )1;
  }
#line 1059
  if (ccf->timer_resolution == 0xffffffffffffffffUL) {
#line 1059
    ccf->timer_resolution = (ngx_msec_t )0;
  }
#line 1060
  if (ccf->shutdown_timeout == 0xffffffffffffffffUL) {
#line 1060
    ccf->shutdown_timeout = (ngx_msec_t )0;
  }
#line 1062
  if (ccf->worker_processes == -1L) {
#line 1062
    ccf->worker_processes = (ngx_int_t )1;
  }
#line 1063
  if (ccf->debug_points == -1L) {
#line 1063
    ccf->debug_points = (ngx_int_t )0;
  }
#line 1067
  if (! ccf->cpu_affinity_auto) {
#line 1067
    if (ccf->cpu_affinity_n) {
#line 1067
      if (ccf->cpu_affinity_n != 1UL) {
#line 1067
        if (ccf->cpu_affinity_n != (ngx_uint_t )ccf->worker_processes) {
#line 1072
          if ((cycle->log)->log_level >= 5UL) {
            {
#line 1072
            ngx_log_error_core((ngx_uint_t )5, cycle->log, 0, "the number of \"worker_processes\" is not equal to the number of \"worker_cpu_affinity\" masks, using last mask for remaining worker processes");
            }
          }
        }
      }
    }
  }
#line 1081
  if (ccf->pid.len == 0UL) {
#line 1082
    ccf->pid.len = sizeof("logs/nginx.pid") - 1UL;
#line 1082
    ccf->pid.data = (u_char *)"logs/nginx.pid";
  }
  {
#line 1085
  tmp = ngx_conf_full_name(cycle, & ccf->pid, (ngx_uint_t )0);
  }
#line 1085
  if (tmp != 0L) {
#line 1086
    return ((char *)((void *)-1));
  }
  {
#line 1089
  ccf->oldpid.len = ccf->pid.len + sizeof(".oldbin");
#line 1091
  tmp___0 = ngx_pnalloc(cycle->pool, ccf->oldpid.len);
#line 1091
  ccf->oldpid.data = (u_char *)tmp___0;
  }
#line 1092
  if ((unsigned long )ccf->oldpid.data == (unsigned long )((void *)0)) {
#line 1093
    return ((char *)((void *)-1));
  }
  {
#line 1096
  tmp___1 = memcpy((void */* __restrict  */)ccf->oldpid.data, (void const   */* __restrict  */)ccf->pid.data,
                   ccf->pid.len);
#line 1096
  memcpy((void */* __restrict  */)((u_char *)tmp___1 + ccf->pid.len), (void const   */* __restrict  */)".oldbin",
         sizeof(".oldbin"));
  }
#line 1102
  if (ccf->user == 4294967295U) {
    {
#line 1102
    tmp___6 = geteuid();
    }
#line 1102
    if (tmp___6 == 0U) {
      {
#line 1106
      tmp___2 = __errno_location();
#line 1106
      *tmp___2 = 0;
#line 1107
      pwd = getpwnam("nobody");
      }
#line 1108
      if ((unsigned long )pwd == (unsigned long )((void *)0)) {
#line 1109
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1109
          tmp___3 = __errno_location();
#line 1109
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___3, "getpwnam(\"nobody\") failed");
          }
        }
#line 1111
        return ((char *)((void *)-1));
      }
      {
#line 1114
      ccf->username = (char *)"nobody";
#line 1115
      ccf->user = pwd->pw_uid;
#line 1117
      tmp___4 = __errno_location();
#line 1117
      *tmp___4 = 0;
#line 1118
      grp = getgrnam("nogroup");
      }
#line 1119
      if ((unsigned long )grp == (unsigned long )((void *)0)) {
#line 1120
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1120
          tmp___5 = __errno_location();
#line 1120
          ngx_log_error_core((ngx_uint_t )1, cycle->log, *tmp___5, "getgrnam(\"nogroup\") failed");
          }
        }
#line 1122
        return ((char *)((void *)-1));
      }
#line 1125
      ccf->group = grp->gr_gid;
    }
  }
#line 1129
  if (ccf->lock_file.len == 0UL) {
#line 1130
    ccf->lock_file.len = sizeof("logs/nginx.lock") - 1UL;
#line 1130
    ccf->lock_file.data = (u_char *)"logs/nginx.lock";
  }
  {
#line 1133
  tmp___7 = ngx_conf_full_name(cycle, & ccf->lock_file, (ngx_uint_t )0);
  }
#line 1133
  if (tmp___7 != 0L) {
#line 1134
    return ((char *)((void *)-1));
  }
#line 1140
  lock_file = (cycle->old_cycle)->lock_file;
#line 1142
  if (lock_file.len) {
#line 1143
    (lock_file.len) --;
#line 1145
    if (ccf->lock_file.len != lock_file.len) {
#line 1145
      goto _L;
    } else {
      {
#line 1145
      tmp___8 = strncmp((char const   *)ccf->lock_file.data, (char const   *)lock_file.data,
                        lock_file.len);
      }
#line 1145
      if (tmp___8 != 0) {
        _L: /* CIL Label */ 
#line 1149
        if ((cycle->log)->log_level >= 1UL) {
          {
#line 1149
          ngx_log_error_core((ngx_uint_t )1, cycle->log, 0, "\"lock_file\" could not be changed, ignored");
          }
        }
      }
    }
    {
#line 1153
    cycle->lock_file.len = lock_file.len + 1UL;
#line 1154
    lock_file.len += sizeof(".accept");
#line 1156
    cycle->lock_file.data = ngx_pstrdup(cycle->pool, & lock_file);
    }
#line 1157
    if ((unsigned long )cycle->lock_file.data == (unsigned long )((void *)0)) {
#line 1158
      return ((char *)((void *)-1));
    }
  } else {
    {
#line 1162
    cycle->lock_file.len = ccf->lock_file.len + 1UL;
#line 1163
    tmp___9 = ngx_pnalloc(cycle->pool, ccf->lock_file.len + sizeof(".accept"));
#line 1163
    cycle->lock_file.data = (u_char *)tmp___9;
    }
#line 1165
    if ((unsigned long )cycle->lock_file.data == (unsigned long )((void *)0)) {
#line 1166
      return ((char *)((void *)-1));
    }
    {
#line 1169
    tmp___10 = memcpy((void */* __restrict  */)cycle->lock_file.data, (void const   */* __restrict  */)ccf->lock_file.data,
                      ccf->lock_file.len);
#line 1169
    memcpy((void */* __restrict  */)((u_char *)tmp___10 + ccf->lock_file.len), (void const   */* __restrict  */)".accept",
           sizeof(".accept"));
    }
  }
#line 1177
  return ((char *)((void *)0));
}
}
#line 1181 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char *ngx_set_user(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  char *group ;
  struct passwd *pwd ;
  struct group *grp ;
  ngx_str_t *value ;
  __uid_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  u_char *tmp___2 ;
  int *tmp___3 ;
  int *tmp___4 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;

  {
#line 1193
  ccf = (ngx_core_conf_t *)conf;
#line 1200
  if (ccf->user != 4294967295U) {
#line 1201
    return ((char *)"is duplicate");
  }
  {
#line 1204
  tmp = geteuid();
  }
#line 1204
  if (tmp != 0U) {
    {
#line 1205
    ngx_conf_log_error((ngx_uint_t )5, cf, 0, "the \"user\" directive makes sense only if the master process runs with super-user privileges, ignored");
    }
#line 1209
    return ((char *)((void *)0));
  }
  {
#line 1212
  value = (ngx_str_t *)(cf->args)->elts;
#line 1214
  ccf->username = (char *)(value + 1)->data;
#line 1216
  tmp___0 = __errno_location();
#line 1216
  *tmp___0 = 0;
#line 1217
  pwd = getpwnam((char const   *)(value + 1)->data);
  }
#line 1218
  if ((unsigned long )pwd == (unsigned long )((void *)0)) {
    {
#line 1219
    tmp___1 = __errno_location();
#line 1219
    ngx_conf_log_error((ngx_uint_t )1, cf, *tmp___1, "getpwnam(\"%s\") failed", (value + 1)->data);
    }
#line 1221
    return ((char *)((void *)-1));
  }
#line 1224
  ccf->user = pwd->pw_uid;
#line 1226
  if ((cf->args)->nelts == 2UL) {
#line 1226
    tmp___2 = (value + 1)->data;
  } else {
#line 1226
    tmp___2 = (value + 2)->data;
  }
  {
#line 1226
  group = (char *)tmp___2;
#line 1228
  tmp___3 = __errno_location();
#line 1228
  *tmp___3 = 0;
#line 1229
  grp = getgrnam((char const   *)group);
  }
#line 1230
  if ((unsigned long )grp == (unsigned long )((void *)0)) {
    {
#line 1231
    tmp___4 = __errno_location();
#line 1231
    ngx_conf_log_error((ngx_uint_t )1, cf, *tmp___4, "getgrnam(\"%s\") failed", group);
    }
#line 1233
    return ((char *)((void *)-1));
  }
#line 1236
  ccf->group = grp->gr_gid;
#line 1238
  return ((char *)((void *)0));
}
}
#line 1244 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char *ngx_set_env(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  ngx_str_t *value ;
  ngx_str_t *var ;
  ngx_uint_t i ;
  void *tmp ;

  {
  {
#line 1247
  ccf = (ngx_core_conf_t *)conf;
#line 1252
  tmp = ngx_array_push(& ccf->env);
#line 1252
  var = (ngx_str_t *)tmp;
  }
#line 1253
  if ((unsigned long )var == (unsigned long )((void *)0)) {
#line 1254
    return ((char *)((void *)-1));
  }
#line 1257
  value = (ngx_str_t *)(cf->args)->elts;
#line 1258
  *var = *(value + 1);
#line 1260
  i = (ngx_uint_t )0;
  {
#line 1260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1260
    if (! (i < (value + 1)->len)) {
#line 1260
      goto while_break;
    }
#line 1262
    if ((int )*((value + 1)->data + i) == 61) {
#line 1264
      var->len = i;
#line 1266
      return ((char *)((void *)0));
    }
#line 1260
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1270
  return ((char *)((void *)0));
}
}
#line 1274 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char *ngx_set_priority(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  ngx_str_t *value ;
  ngx_uint_t n ;
  ngx_uint_t minus ;
  ngx_int_t tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 1277
  ccf = (ngx_core_conf_t *)conf;
#line 1282
  if (ccf->priority != 0) {
#line 1283
    return ((char *)"is duplicate");
  }
#line 1286
  value = (ngx_str_t *)(cf->args)->elts;
#line 1288
  if ((int )*((value + 1)->data + 0) == 45) {
#line 1289
    n = (ngx_uint_t )1;
#line 1290
    minus = (ngx_uint_t )1;
  } else
#line 1292
  if ((int )*((value + 1)->data + 0) == 43) {
#line 1293
    n = (ngx_uint_t )1;
#line 1294
    minus = (ngx_uint_t )0;
  } else {
#line 1297
    n = (ngx_uint_t )0;
#line 1298
    minus = (ngx_uint_t )0;
  }
  {
#line 1301
  tmp = ngx_atoi((value + 1)->data + n, (value + 1)->len - n);
#line 1301
  ccf->priority = (int )tmp;
  }
#line 1302
  if (ccf->priority == -1) {
#line 1303
    return ((char *)"invalid number");
  }
#line 1306
  if (minus) {
#line 1307
    ccf->priority = - ccf->priority;
  }
#line 1310
  return ((char *)((void *)0));
}
}
#line 1314 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char *ngx_set_cpu_affinity(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_core_conf_t *ccf ;
  u_char ch ;
  u_char *p ;
  ngx_str_t *value ;
  ngx_uint_t i ;
  ngx_uint_t n ;
  ngx_cpuset_t *mask ;
  void *tmp ;
  size_t __cpu ;
  ngx_int_t tmp___0 ;
  int tmp___1 ;
  size_t __cpu___0 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
#line 1318
  ccf = (ngx_core_conf_t *)conf;
#line 1325
  if (ccf->cpu_affinity) {
#line 1326
    return ((char *)"is duplicate");
  }
  {
#line 1329
  tmp = ngx_palloc(cf->pool, ((cf->args)->nelts - 1UL) * sizeof(ngx_cpuset_t ));
#line 1329
  mask = (ngx_cpuset_t *)tmp;
  }
#line 1330
  if ((unsigned long )mask == (unsigned long )((void *)0)) {
#line 1331
    return ((char *)((void *)-1));
  }
  {
#line 1334
  ccf->cpu_affinity_n = (cf->args)->nelts - 1UL;
#line 1335
  ccf->cpu_affinity = mask;
#line 1337
  value = (ngx_str_t *)(cf->args)->elts;
#line 1339
  tmp___1 = strcmp((char const   *)(value + 1)->data, "auto");
  }
#line 1339
  if (tmp___1 == 0) {
#line 1341
    if ((cf->args)->nelts > 3UL) {
      {
#line 1342
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid number of arguments in \"worker_cpu_affinity\" directive");
      }
#line 1345
      return ((char *)((void *)-1));
    }
#line 1348
    ccf->cpu_affinity_auto = (ngx_uint_t )1;
    {
#line 1350
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1350
      __builtin_memset((void *)(mask + 0), '\000', (int )sizeof(cpu_set_t ));
      }
#line 1350
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 1351
    i = (ngx_uint_t )0;
    {
#line 1351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1351
      if (ngx_ncpu > 1024L) {
#line 1351
        tmp___0 = (ngx_int_t )1024;
      } else {
#line 1351
        tmp___0 = ngx_ncpu;
      }
#line 1351
      if (! (i < (ngx_uint_t )tmp___0)) {
#line 1351
        goto while_break___0;
      }
#line 1352
      __cpu = i;
#line 1352
      if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 1352
        (mask + 0)->__bits[__cpu / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu % (8UL * sizeof(__cpu_mask ));
      }
#line 1351
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1355
    n = (ngx_uint_t )2;
  } else {
#line 1358
    n = (ngx_uint_t )1;
  }
  {
#line 1361
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1361
    if (! (n < (cf->args)->nelts)) {
#line 1361
      goto while_break___1;
    }
#line 1363
    if ((value + n)->len > 1024UL) {
      {
#line 1364
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "\"worker_cpu_affinity\" supports up to %d CPUs only",
                         1024);
      }
#line 1367
      return ((char *)((void *)-1));
    }
#line 1370
    i = (ngx_uint_t )0;
    {
#line 1371
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1371
      __builtin_memset((void *)(mask + (n - 1UL)), '\000', (int )sizeof(cpu_set_t ));
      }
#line 1371
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1373
    p = ((value + n)->data + (value + n)->len) - 1;
    {
#line 1373
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 1373
      if (! ((unsigned long )p >= (unsigned long )(value + n)->data)) {
#line 1373
        goto while_break___3;
      }
#line 1377
      ch = *p;
#line 1379
      if ((int )ch == 32) {
#line 1380
        goto __Cont;
      }
#line 1383
      i ++;
#line 1385
      if ((int )ch == 48) {
#line 1386
        goto __Cont;
      }
#line 1389
      if ((int )ch == 49) {
#line 1390
        __cpu___0 = i - 1UL;
#line 1390
        if (__cpu___0 / 8UL < sizeof(cpu_set_t )) {
#line 1390
          (mask + (n - 1UL))->__bits[__cpu___0 / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu___0 % (8UL * sizeof(__cpu_mask ));
        }
#line 1391
        goto __Cont;
      }
      {
#line 1394
      ngx_conf_log_error((ngx_uint_t )1, cf, 0, "invalid character \"%c\" in \"worker_cpu_affinity\"",
                         (int )ch);
      }
#line 1397
      return ((char *)((void *)-1));
      __Cont: /* CIL Label */ 
#line 1373
      p --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 1361
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1408
  return ((char *)((void *)0));
}
}
#line 1420 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static ngx_cpuset_t result  ;
#line 1412 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
ngx_cpuset_t *ngx_get_cpu_affinity(ngx_uint_t n ) 
{ 
  ngx_uint_t i ;
  ngx_uint_t j ;
  ngx_cpuset_t *mask ;
  ngx_core_conf_t *ccf ;
  size_t __cpu ;
  int tmp ;
  ngx_uint_t tmp___0 ;
  size_t __cpu___0 ;

  {
#line 1422
  ccf = (ngx_core_conf_t *)*(ngx_cycle->conf_ctx + ngx_core_module.index);
#line 1425
  if ((unsigned long )ccf->cpu_affinity == (unsigned long )((void *)0)) {
#line 1426
    return ((ngx_cpuset_t *)((void *)0));
  }
#line 1429
  if (ccf->cpu_affinity_auto) {
#line 1430
    mask = ccf->cpu_affinity + (ccf->cpu_affinity_n - 1UL);
#line 1432
    i = (ngx_uint_t )0;
#line 1432
    j = n;
    {
#line 1432
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1434
      __cpu = i % 1024UL;
#line 1434
      if (__cpu / 8UL < sizeof(cpu_set_t )) {
#line 1434
        tmp = (*((__cpu_mask const   *)(mask->__bits) + __cpu / (8UL * sizeof(__cpu_mask ))) & (unsigned long const   )(1UL << __cpu % (8UL * sizeof(__cpu_mask )))) != 0UL;
      } else {
#line 1434
        tmp = 0;
      }
#line 1434
      if (tmp) {
#line 1434
        tmp___0 = j;
#line 1434
        j --;
#line 1434
        if (tmp___0 == 0UL) {
#line 1435
          goto while_break;
        }
      }
#line 1438
      if (i == 1024UL) {
#line 1438
        if (j == n) {
#line 1440
          return ((ngx_cpuset_t *)((void *)0));
        }
      }
#line 1432
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1446
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1446
      __builtin_memset((void *)(& result), '\000', (int )sizeof(cpu_set_t ));
      }
#line 1446
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1447
    __cpu___0 = i % 1024UL;
#line 1447
    if (__cpu___0 / 8UL < sizeof(cpu_set_t )) {
#line 1447
      result.__bits[__cpu___0 / (8UL * sizeof(__cpu_mask ))] |= 1UL << __cpu___0 % (8UL * sizeof(__cpu_mask ));
    }
#line 1449
    return (& result);
  }
#line 1452
  if (ccf->cpu_affinity_n > n) {
#line 1453
    return (ccf->cpu_affinity + n);
  }
#line 1456
  return (ccf->cpu_affinity + (ccf->cpu_affinity_n - 1UL));
}
}
#line 1466 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char *ngx_set_worker_processes(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  ngx_str_t *value ;
  ngx_core_conf_t *ccf ;
  int tmp ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
#line 1472
  ccf = (ngx_core_conf_t *)conf;
#line 1474
  if (ccf->worker_processes != -1L) {
#line 1475
    return ((char *)"is duplicate");
  }
  {
#line 1478
  value = (ngx_str_t *)(cf->args)->elts;
#line 1480
  tmp = strcmp((char const   *)(value + 1)->data, "auto");
  }
#line 1480
  if (tmp == 0) {
#line 1481
    ccf->worker_processes = ngx_ncpu;
#line 1482
    return ((char *)((void *)0));
  }
  {
#line 1485
  ccf->worker_processes = ngx_atoi((value + 1)->data, (value + 1)->len);
  }
#line 1487
  if (ccf->worker_processes == -1L) {
#line 1488
    return ((char *)"invalid value");
  }
#line 1491
  return ((char *)((void *)0));
}
}
#line 1495 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static char *ngx_load_module(ngx_conf_t *cf , ngx_command_t *cmd , void *conf ) 
{ 
  void *handle ;
  char **names ;
  char **order ;
  ngx_str_t *value ;
  ngx_str_t file ;
  ngx_uint_t i ;
  ngx_module_t *module ;
  ngx_module_t **modules ;
  ngx_pool_cleanup_t *cln ;
  ngx_int_t tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  void *tmp___5 ;
  ngx_int_t tmp___6 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;

  {
#line 1506
  if ((cf->cycle)->modules_used) {
#line 1507
    return ((char *)"is specified too late");
  }
  {
#line 1510
  value = (ngx_str_t *)(cf->args)->elts;
#line 1512
  file = *(value + 1);
#line 1514
  tmp = ngx_conf_full_name(cf->cycle, & file, (ngx_uint_t )0);
  }
#line 1514
  if (tmp != 0L) {
#line 1515
    return ((char *)((void *)-1));
  }
  {
#line 1518
  cln = ngx_pool_cleanup_add((cf->cycle)->pool, (size_t )0);
  }
#line 1519
  if ((unsigned long )cln == (unsigned long )((void *)0)) {
#line 1520
    return ((char *)((void *)-1));
  }
  {
#line 1523
  handle = dlopen((char const   *)((char *)file.data), 258);
  }
#line 1524
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
    {
#line 1525
    tmp___0 = ngx_dlerror();
#line 1525
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "dlopen() \"%s\" failed (%s)", file.data,
                       tmp___0);
    }
#line 1528
    return ((char *)((void *)-1));
  }
  {
#line 1531
  cln->handler = & ngx_unload_module;
#line 1532
  cln->data = handle;
#line 1534
  tmp___1 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)"ngx_modules");
#line 1534
  modules = (ngx_module_t **)tmp___1;
  }
#line 1535
  if ((unsigned long )modules == (unsigned long )((void *)0)) {
    {
#line 1536
    tmp___2 = ngx_dlerror();
#line 1536
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "dlsym() \"%V\", \"%s\" failed (%s)",
                       value + 1, "ngx_modules", tmp___2);
    }
#line 1539
    return ((char *)((void *)-1));
  }
  {
#line 1542
  tmp___3 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)"ngx_module_names");
#line 1542
  names = (char **)tmp___3;
  }
#line 1543
  if ((unsigned long )names == (unsigned long )((void *)0)) {
    {
#line 1544
    tmp___4 = ngx_dlerror();
#line 1544
    ngx_conf_log_error((ngx_uint_t )1, cf, 0, "dlsym() \"%V\", \"%s\" failed (%s)",
                       value + 1, "ngx_module_names", tmp___4);
    }
#line 1547
    return ((char *)((void *)-1));
  }
  {
#line 1550
  tmp___5 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)"ngx_module_order");
#line 1550
  order = (char **)tmp___5;
#line 1552
  i = (ngx_uint_t )0;
  }
  {
#line 1552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1552
    if (! *(modules + i)) {
#line 1552
      goto while_break;
    }
    {
#line 1553
    module = *(modules + i);
#line 1554
    module->name = *(names + i);
#line 1556
    tmp___6 = ngx_add_module(cf, & file, module, order);
    }
#line 1556
    if (tmp___6 != 0L) {
#line 1557
      return ((char *)((void *)-1));
    }
#line 1552
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1564
  return ((char *)((void *)0));
}
}
#line 1579 "/home/khheo/project/nginx-release-1.13.8/src/core/nginx.c"
static void ngx_unload_module(void *data ) 
{ 
  void *handle ;
  char *tmp ;
  int tmp___0 ;
  char *__cil_tmp5 ;

  {
  {
#line 1582
  handle = data;
#line 1584
  tmp___0 = dlclose(handle);
  }
#line 1584
  if (tmp___0 != 0) {
#line 1585
    if ((ngx_cycle->log)->log_level >= 2UL) {
      {
#line 1585
      tmp = ngx_dlerror();
#line 1585
      ngx_log_error_core((ngx_uint_t )2, (ngx_log_t *)ngx_cycle->log, 0, "dlclose() failed (%s)",
                         tmp);
      }
    }
  }
#line 1588
  return;
}
}
