/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 147 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef long ptrdiff_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 100 "/usr/include/netdb.h"
struct hostent {
   char *h_name ;
   char **h_aliases ;
   int h_addrtype ;
   int h_length ;
   char **h_addr_list ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 61 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
typedef int BOOL;
#line 74 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
typedef short int16;
#line 79 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
typedef unsigned short uint16;
#line 83 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
typedef unsigned int uint32;
#line 226 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
typedef char pstring[1024];
#line 227 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
typedef char fstring[128];
#line 230 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
struct __anonstruct_file_info_82 {
   int size ;
   int mode ;
   int uid ;
   int gid ;
   time_t mtime ;
   time_t atime ;
   time_t ctime ;
   char name[1024] ;
};
#line 230 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
typedef struct __anonstruct_file_info_82 file_info;
#line 2231 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
struct __anonstruct_prots_91 {
   int prot ;
   char *name ;
};
#line 4309 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
struct __anonstruct_err_code_struct_92 {
   char *name ;
   int code ;
   char *message ;
};
#line 4309 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
typedef struct __anonstruct_err_code_struct_92 err_code_struct;
#line 4422 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
struct __anonstruct_err_classes_93 {
   int code ;
   char *class ;
   err_code_struct *err_msgs ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 7 "/home/june/repo/benchmarks/collector/temp/nat-1.0/parse_ip.h"
struct ipstr {
   char *name ;
   struct ipstr *next ;
};
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
enum node_type {
    B_NODE = 0,
    P_NODE = 1,
    M_NODE = 2,
    NBDD_NODE = 3
} ;
#line 39
enum packet_type {
    NMB_PACKET = 0,
    DGRAM_PACKET = 1
} ;
#line 42 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct nmb_name {
   char name[17] ;
   char scope[64] ;
   int name_type ;
};
#line 83 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct res_rec {
   struct nmb_name rr_name ;
   int rr_type ;
   int rr_class ;
   int ttl ;
   int rdlength ;
   char rdata[576] ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct __anonstruct_nm_flags_92 {
   BOOL bcast ;
   BOOL recursion_available ;
   BOOL recursion_desired ;
   BOOL trunc ;
   BOOL authoritative ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct __anonstruct_header_91 {
   int name_trn_id ;
   int opcode ;
   BOOL response ;
   struct __anonstruct_nm_flags_92 nm_flags ;
   int rcode ;
   int qdcount ;
   int ancount ;
   int nscount ;
   int arcount ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct __anonstruct_question_93 {
   struct nmb_name question_name ;
   int question_type ;
   int question_class ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct nmb_packet {
   struct __anonstruct_header_91 header ;
   struct __anonstruct_question_93 question ;
   struct res_rec *answers ;
   struct res_rec *nsrecs ;
   struct res_rec *additional ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct __anonstruct_flags_95 {
   enum node_type node_type ;
   BOOL first ;
   BOOL more ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct __anonstruct_header_94 {
   int msg_type ;
   struct __anonstruct_flags_95 flags ;
   int dgm_id ;
   struct in_addr source_ip ;
   int source_port ;
   int dgm_length ;
   int packet_offset ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct dgram_packet {
   struct __anonstruct_header_94 header ;
   struct nmb_name source_name ;
   struct nmb_name dest_name ;
   int datasize ;
   char data[576] ;
};
#line 148 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
union __anonunion_packet_96 {
   struct nmb_packet nmb ;
   struct dgram_packet dgram ;
};
#line 148 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
struct packet_struct {
   struct packet_struct *next ;
   struct packet_struct *prev ;
   struct in_addr ip ;
   int port ;
   int fd ;
   time_t timestamp ;
   enum packet_type packet_type ;
   union __anonunion_packet_96 packet ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 48 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ino_t ino_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 37 "/usr/include/utime.h"
struct utimbuf {
   __time_t actime ;
   __time_t modtime ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 111 "/usr/include/net/if.h"
struct ifmap {
   unsigned long mem_start ;
   unsigned long mem_end ;
   unsigned short base_addr ;
   unsigned char irq ;
   unsigned char dma ;
   unsigned char port ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifrn_78 {
   char ifrn_name[16] ;
};
#line 126 "/usr/include/net/if.h"
union __anonunion_ifr_ifru_79 {
   struct sockaddr ifru_addr ;
   struct sockaddr ifru_dstaddr ;
   struct sockaddr ifru_broadaddr ;
   struct sockaddr ifru_netmask ;
   struct sockaddr ifru_hwaddr ;
   short ifru_flags ;
   int ifru_ivalue ;
   int ifru_mtu ;
   struct ifmap ifru_map ;
   char ifru_slave[16] ;
   char ifru_newname[16] ;
   __caddr_t ifru_data ;
};
#line 126 "/usr/include/net/if.h"
struct ifreq {
   union __anonunion_ifr_ifrn_78 ifr_ifrn ;
   union __anonunion_ifr_ifru_79 ifr_ifru ;
};
#line 176 "/usr/include/net/if.h"
union __anonunion_ifc_ifcu_80 {
   __caddr_t ifcu_buf ;
   struct ifreq *ifcu_req ;
};
#line 176 "/usr/include/net/if.h"
struct ifconf {
   int ifc_len ;
   union __anonunion_ifc_ifcu_80 ifc_ifcu ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 228 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
typedef fstring string;
#line 589 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
struct from_host {
   char *name ;
   char *addr ;
   struct sockaddr_in *sin ;
};
#line 422 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct dst_table {
   time_t start ;
   time_t end ;
   BOOL is_dst ;
};
#line 649 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct __anonstruct_socket_options_91 {
   char *name ;
   int level ;
   int option ;
   int value ;
   int opttype ;
};
#line 1636 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct __anonstruct_ino_list_92 {
   ino_t inode ;
   dev_t dev ;
   char *text ;
   BOOL valid ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 27 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
struct vuln_res {
   u_long vr_vulid ;
   char **vr_output ;
   struct vuln_res *vr_next ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 261 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) asctime)(struct tm  const  *__tp ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 444
extern unsigned int sleep(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 675
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 948
extern char *( __attribute__((__nonnull__(1))) getpass)(char const   *__prompt ) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 459
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) bzero)(void *__s ,
                                                                                             size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 624 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
int smb_offset(char *p , char *buf___0 ) ;
#line 638
void TimeInit(void) ;
#line 640
time_t interpret_long_date(char *p ) ;
#line 645
void set_socket_options(int fd , char *options ) ;
#line 646
void putip(void *dest , void *src ) ;
#line 665
void _smb_setlen(char *buf___0 , int len ) ;
#line 686
char *StrnCpy(char *dest , char const   *src , int n ) ;
#line 690
char *skip_string(char *buf___0 , int n ) ;
#line 736
char *StrCpy(char *dest , char *src ) ;
#line 738
time_t make_unix_date2(void *date_ptr ) ;
#line 756
struct hostent *Get_Hostbyname(char *name___1 ) ;
#line 759
void *Realloc(void *p , int size___0 ) ;
#line 761
int set_message(char *buf___0 , int num_words , int num_bytes , BOOL zero ) ;
#line 767
char *attrib_string(int mode ) ;
#line 774
void strupper(char *s ) ;
#line 777
void close_sockets(void) ;
#line 778
BOOL send_smb(int fd , char *buffer ) ;
#line 782
BOOL receive_smb(int fd , char *buffer , int timeout ) ;
#line 783
void show_msg(char *buf___0 ) ;
#line 791
char *smb_buf(char *buf___0 ) ;
#line 794
BOOL strequal(char *s1 , char *s2 ) ;
#line 797
BOOL mask_match(char *str , char *regexp , int case_sig , BOOL trans2 ) ;
#line 807
int name_len(char *s ) ;
#line 810
time_t make_unix_date(void *date_ptr ) ;
#line 818
int name_mangle(char *In , char *Out , char name_type___0 ) ;
#line 825
int Debug1(char *format_str  , ...) ;
#line 832
char *smb_errstr(char *inbuf___0 ) ;
#line 834
struct tm *LocalTime(time_t *t , int timemul ) ;
#line 839
void expand_mask(char *Mask , BOOL doext ) ;
#line 844
int open_socket_in(int type , int port , int dlevel ) ;
#line 845
int open_socket_out(int type , struct in_addr *addr , int port ) ;
#line 852
int smb_buflen(char *buf___0 ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.h"
void charset_initialise(void) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
FILE *userfd ;
#line 40
FILE *passfd ;
#line 42
char *passfile ;
#line 44 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char cur_dir[1024]  = {      (char )'\\',      (char )'\000'};
#line 45 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char cd_path[1024]  = {      (char )'\000'};
#line 46 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char service[1024]  = {      (char )'\000'};
#line 47 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char desthost[1024]  = {      (char )'\000'};
#line 48 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char myname[1024]  = {      (char )'\000'};
#line 49 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char password[1024]  = {      (char )'\000'};
#line 50 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char username[1024]  = {      (char )'\000'};
#line 51 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char workgroup[1024]  = 
#line 51
  {      (char )'W',      (char )'O',      (char )'R',      (char )'K', 
        (char )'G',      (char )'R',      (char )'O',      (char )'U', 
        (char )'P',      (char )'\000'};
#line 52 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL got_pass  =    0;
#line 53 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL connect_as_printer  =    0;
#line 54 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL connect_as_ipc  =    0;
#line 56 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char cryptkey[8]  ;
#line 57 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL doencrypt  =    0;
#line 59
char user_socket_options[1024] ;
#line 72 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int name_type  =    32;
#line 74 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int max_protocol  =    5;
#line 91
int cur_vuln ;
#line 92
int clear_block(char **blk , int idx ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static file_info stash  ;
#line 98 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
file_info *cur_stash  =    (file_info *)((void *)0);
#line 99 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int tested_stash  =    0;
#line 105 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int cur_port  =    0;
#line 106 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char cur_user[1024]  = {      (char )'\000'};
#line 107 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char cur_pass[1024]  = {      (char )'\000'};
#line 108 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int cur_sec_mode  =    0;
#line 109 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int cur_protocol  =    0;
#line 110 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int cur_serr  =    0;
#line 112 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL read_pass  =    0;
#line 113 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL stepping  =    0;
#line 114 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL xflag  =    0;
#line 117 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
time_t newer_than  =    (time_t )0;
#line 118 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int archive_level  =    0;
#line 123
int DEBUGLEVEL ;
#line 125 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL translation  =    0;
#line 128
void cmd_tar(void) ;
#line 129
void cmd_block(void) ;
#line 130
void cmd_tarmode(void) ;
#line 131
void cmd_setmode(void) ;
#line 137 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int cnum  =    0;
#line 138 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int pid  =    0;
#line 139 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int gid  =    0;
#line 140 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int uid  =    0;
#line 141 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int mid  =    0;
#line 142 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int myumask  =    493;
#line 144 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int max_xmit  =    65535;
#line 148 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL prompt  =    1;
#line 150 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int printmode  =    1;
#line 152 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL recurse  =    0;
#line 153 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL lowercase  =    0;
#line 155 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL have_ip  =    0;
#line 157 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
struct in_addr dest_ip  ;
#line 161 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL abort_mget  =    1;
#line 163
int Protocol ;
#line 165 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL readbraw_supported  =    0;
#line 166 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL writebraw_supported  =    0;
#line 168 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char fileselection[1024]  = {      (char )'\000'};
#line 170
file_info def_finfo ;
#line 173 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int get_total_size  =    0;
#line 174 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int get_total_time_ms  =    0;
#line 175 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int put_total_size  =    0;
#line 176 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int put_total_time_ms  =    0;
#line 178
int Client ;
#line 180 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int said_protocol  =    0;
#line 206 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int ptr_names  =    0;
#line 207 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int idx_names  =    1;
#line 208 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char *try_names[10]  = 
#line 208
  {      (char *)"*",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)((void *)0)};
#line 217 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int ptr_users  =    0;
#line 218 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int idx_users  =    13;
#line 219 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char *try_users[22]  = 
#line 219
  {      (char *)"",      (char *)"ADMINISTRATOR",      (char *)"GUEST",      (char *)"BACKUP", 
        (char *)"ROOT",      (char *)"ADMIN",      (char *)"USER",      (char *)"DEMO", 
        (char *)"TEST",      (char *)"SYSTEM",      (char *)"OPERATOR",      (char *)"OPER", 
        (char *)"LOCAL",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)((void *)0)};
#line 231 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int ptr_pass  =    0;
#line 232 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int idx_pass  =    21;
#line 233 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char *try_pass[38]  = 
#line 233
  {      (char *)"",      (char *)"ADMINISTRATOR",      (char *)"GUEST",      (char *)"ROOT", 
        (char *)"ADMIN",      (char *)"PASSWORD",      (char *)"TEMP",      (char *)"SHARE", 
        (char *)"WRITE",      (char *)"FULL",      (char *)"BOTH",      (char *)"READ", 
        (char *)"FILES",      (char *)"DEMO",      (char *)"TEST",      (char *)"ACCESS", 
        (char *)"USER",      (char *)"BACKUP",      (char *)"SYSTEM",      (char *)"SERVER", 
        (char *)"LOCAL",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)((void *)0)};
#line 245 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int ptr_shares  =    0;
#line 246 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int idx_shares  =    1;
#line 247 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int hid_shares  =    0;
#line 248 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char *try_shares[18]  = 
#line 248
  {      (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)"",      (char *)"",      (char *)"", 
        (char *)"",      (char *)((void *)0)};
#line 255 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int ptr_browses  =    0;
#line 256 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int idx_browses  =    0;
#line 257 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char *browses[16]  ;
#line 271 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int fill_block(char **block , char *str ) 
{ 
  register int i___0 ;
  register char **p ;
  int tmp ;
  void *tmp___0 ;

  {
#line 273
  i___0 = 1;
#line 274
  p = block;
#line 276
  if (! str) {
#line 277
    return (0);
  }
#line 278
  if ((int )*(str + 0) == 0) {
#line 279
    return (0);
  }
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
#line 281
    if (! (i___0 < 128)) {
#line 281
      goto while_break;
    }
#line 282
    if ((unsigned long )*(p + i___0) == (unsigned long )((void *)0)) {
#line 283
      return (0);
    }
#line 284
    if ((int )*(*(p + i___0)) == 0) {
#line 285
      goto while_break;
    }
    {
#line 286
    tmp = strcmp((char const   *)*(p + i___0), (char const   *)str);
    }
#line 286
    if (! tmp) {
#line 287
      return (0);
    }
#line 281
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 289
  tmp___0 = malloc((size_t )128);
#line 289
  *(p + i___0) = (char *)tmp___0;
  }
#line 290
  if (! *(p + i___0)) {
#line 291
    return (0);
  }
  {
#line 292
  memset((void *)*(p + i___0), 0, (size_t )128);
#line 293
  StrnCpy(*(p + i___0), (char const   *)str, 126);
  }
#line 294
  return (i___0);
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char *get_block(char **blk , int idx ) 
{ 


  {
#line 306
  if (! blk) {
#line 307
    return ((char *)((void *)0));
  }
#line 309
  if (idx > 127) {
#line 310
    return ((char *)((void *)0));
  }
#line 312
  if (idx == 0) {
#line 313
    if ((unsigned long )*(blk + 0) == (unsigned long )((void *)0)) {
#line 314
      return ((char *)((void *)0));
    }
#line 315
    return (*(blk + 0));
  }
#line 318
  if (*(blk + idx)) {
#line 319
    if (*(*(blk + idx))) {
#line 320
      return (*(blk + idx));
    }
  }
#line 321
  return ((char *)((void *)0));
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
void cmd_tar(void) 
{ 


  {
#line 325
  return;
}
}
#line 326 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
void cmd_block(void) 
{ 


  {
#line 326
  return;
}
}
#line 327 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
void cmd_tarmode(void) 
{ 


  {
#line 327
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
void cmd_setmode(void) 
{ 


  {
#line 328
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static void get_stash(file_info *finfo ) 
{ 


  {
#line 336
  if ((unsigned long )cur_stash != (unsigned long )((void *)0)) {
#line 337
    return;
  }
  {
#line 339
  cur_stash = & stash;
#line 340
  memset((void *)cur_stash, 0, sizeof(file_info ));
#line 341
  memcpy((void */* __restrict  */)cur_stash, (void const   */* __restrict  */)finfo,
         sizeof(file_info ));
#line 342
  tested_stash = 1;
  }
#line 343
  return;
}
}
#line 383
void natprintf(char *format  , ...) ;
#line 388
int fill_vuln(char *flag , char *str ) ;
#line 352 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static void cmp_stash(file_info *finfo ) 
{ 
  register int diff_stash ;
  int tmp ;

  {
#line 355
  diff_stash = 0;
#line 357
  if (tested_stash) {
#line 358
    if (DEBUGLEVEL >= 1) {
      {
#line 358
      Debug1((char *)"Redundant cmp_stash call?!\n");
      }
    }
#line 359
    return;
  }
#line 361
  tested_stash = 1;
#line 362
  if ((unsigned long )cur_stash == (unsigned long )((void *)0)) {
#line 363
    return;
  }
#line 364
  if (! (cur_stash->name)) {
#line 365
    return;
  }
#line 366
  if (! finfo) {
#line 367
    return;
  } else
#line 366
  if (! (finfo->name)) {
#line 367
    return;
  }
  {
#line 374
  tmp = strcmp((char const   *)(cur_stash->name), (char const   *)(finfo->name));
  }
#line 374
  if (tmp) {
#line 375
    diff_stash = 1;
  }
#line 376
  if (cur_stash->size != finfo->size) {
#line 377
    diff_stash = 1;
  }
#line 378
  if (cur_stash->mtime != finfo->mtime) {
#line 379
    diff_stash = 1;
  }
#line 381
  if (diff_stash) {
    {
#line 383
    natprintf("[*]--- WARNING: Was able to exercise .. bug in: %s\n", cur_dir);
    }
#line 386
    if (DEBUGLEVEL >= 0) {
      {
#line 386
      Debug1((char *)"probable directory-handling bug using %s\n", cur_dir);
      }
    }
    {
#line 387
    cur_vuln = 16009;
#line 388
    fill_vuln("Was able to exercise .. bug in directory:", cur_dir);
    }
  }
#line 390
  return;
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int upp_ctx  =    0;
#line 410
static BOOL uppair(void) ;
#line 410 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int count  =    0;
#line 406 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL uppair(void) 
{ 
  char *user ;
  char *pass ;
  size_t tmp ;
  char *tmp___0 ;

  {
#line 412
  pass = (char *)((void *)0);
#line 413
  if (stepping) {
#line 414
    goto upp_mode;
  }
#line 420
  if (read_pass) {
    {
#line 421
    pass = fgets((char */* __restrict  */)(password), 128, (FILE */* __restrict  */)stdin);
    }
#line 422
    if (! pass) {
#line 423
      return (0);
    }
    {
#line 424
    tmp = strlen((char const   *)(password));
#line 424
    pass += tmp;
#line 425
    pass --;
    }
#line 426
    if ((int )*pass == 10) {
#line 426
      *pass = (char )'\000';
    }
#line 427
    pass --;
#line 428
    if ((int )*pass == 13) {
#line 428
      *pass = (char )'\000';
    }
#line 429
    return (1);
  }
  {
#line 435
  tmp___0 = getpass("Password: ");
#line 435
  pass = tmp___0;
  }
#line 436
  goto upp_done;
  upp_mode: 
#line 439
  if (upp_ctx == 0) {
    {
#line 440
    ptr_pass = 0;
#line 441
    ptr_users = 0;
#line 442
    StrCpy(username, try_users[0]);
#line 443
    upp_ctx ++;
    }
  } else
#line 439
  if (upp_ctx == 4) {
    {
#line 440
    ptr_pass = 0;
#line 441
    ptr_users = 0;
#line 442
    StrCpy(username, try_users[0]);
#line 443
    upp_ctx ++;
    }
  }
#line 445
  if (upp_ctx == 1) {
#line 445
    goto _L;
  } else
#line 445
  if (upp_ctx == 5) {
    _L: /* CIL Label */ 
    {
#line 446
    pass = get_block(try_pass, ptr_pass);
#line 447
    ptr_pass ++;
    }
#line 448
    if ((unsigned long )pass == (unsigned long )((void *)0)) {
#line 449
      ptr_users ++;
#line 450
      if (upp_ctx == 5) {
#line 451
        return (0);
      }
      {
#line 452
      user = get_block(try_users, ptr_users);
      }
#line 453
      if ((unsigned long )user == (unsigned long )((void *)0)) {
#line 454
        return (0);
      }
      {
#line 455
      StrCpy(username, user);
#line 456
      pass = try_pass[0];
#line 457
      ptr_pass = 1;
      }
    }
  }
#line 463
  if (upp_ctx == 3) {
    {
#line 464
    StrCpy(username, cur_user);
#line 465
    StrCpy(password, cur_pass);
    }
  }
  upp_done: 
#line 469
  if ((unsigned long )pass == (unsigned long )((void *)0)) {
#line 470
    return (0);
  }
#line 471
  if (count > 20) {
    {
#line 472
    sleep(1U);
#line 473
    count = 0;
    }
  }
  {
#line 475
  StrCpy(password, pass);
  }
#line 476
  return (1);
}
}
#line 489
BOOL reopen_connection(char *inbuf___0 , char *outbuf___1 ) ;
#line 490
static int do_long_dir(char *inbuf___0 , char *outbuf___1 , char *Mask , int attribute ,
                       void (*fn)() , BOOL recurse_dir ) ;
#line 492
static int do_short_dir(char *inbuf___0 , char *outbuf___1 , char *Mask , int attribute ,
                        void (*fn)() , BOOL recurse_dir ) ;
#line 494
static BOOL call_api(int prcnt , int drcnt , int mprcnt , int mdrcnt , int *rprcnt ,
                     int *rdrcnt , char *param , char *data , char **rparam , char **rdata ) ;
#line 497
static BOOL send_trans_request(char *outbuf___1 , int trans , char *name___1 , int fid ,
                               int flags , char *data , char *param , uint16 *setup ,
                               int ldata , int lparam , int lsetup , int mdata , int mparam ,
                               int msetup ) ;
#line 507 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
void setup_pkt(char *outbuf___1 ) 
{ 


  {
#line 509
  *((unsigned char *)outbuf___1 + 30) = (unsigned char )((int )((uint16 )pid) & 255);
#line 509
  *((unsigned char *)outbuf___1 + 31) = (unsigned char )((int )((uint16 )pid) >> 8);
#line 510
  *((unsigned char *)outbuf___1 + 32) = (unsigned char )((int )((uint16 )uid) & 255);
#line 510
  *((unsigned char *)outbuf___1 + 33) = (unsigned char )((int )((uint16 )uid) >> 8);
#line 511
  *((unsigned char *)outbuf___1 + 34) = (unsigned char )((int )((uint16 )mid) & 255);
#line 511
  *((unsigned char *)outbuf___1 + 35) = (unsigned char )((int )((uint16 )mid) >> 8);
#line 512
  if (Protocol > 1) {
#line 513
    *((unsigned char *)outbuf___1 + 13) = (unsigned char)8;
#line 514
    *((unsigned char *)outbuf___1 + 14) = (unsigned char)1;
#line 514
    *((unsigned char *)outbuf___1 + 15) = (unsigned char )(1 >> 8);
  }
#line 525
  if (Protocol > 1) {
#line 526
    *((unsigned char *)outbuf___1 + 13) = (unsigned char)24;
#line 527
    *((unsigned char *)outbuf___1 + 14) = (unsigned char)1;
#line 527
    *((unsigned char *)outbuf___1 + 15) = (unsigned char )(8193 >> 8);
  }
#line 530
  return;
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static void display_finfo(file_info *finfo ) 
{ 
  time_t t ;
  struct tm *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 721
  t = finfo->mtime;
#line 722
  if (DEBUGLEVEL >= 0) {
    {
#line 722
    tmp = LocalTime(& t, -1);
#line 722
    tmp___0 = asctime((struct tm  const  *)tmp);
#line 722
    tmp___1 = attrib_string(finfo->mode);
#line 722
    Debug1((char *)"  %-30s%7.7s%10d  %s", finfo->name, tmp___1, finfo->size, tmp___0);
    }
  }
#line 725
  return;
}
}
#line 730 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
void do_dir(char *inbuf___0 , char *outbuf___1 , char *Mask , int attribute , void (*fn)() ,
            BOOL recurse_dir ) 
{ 
  int tmp ;

  {
#line 732
  if (Protocol >= 4) {
    {
#line 734
    tmp = do_long_dir(inbuf___0, outbuf___1, Mask, attribute, fn, recurse_dir);
    }
#line 734
    if (tmp > 0) {
#line 735
      return;
    }
  }
  {
#line 738
  expand_mask(Mask, 0);
#line 739
  do_short_dir(inbuf___0, outbuf___1, Mask, attribute, fn, recurse_dir);
  }
#line 740
  return;
}
}
#line 746 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL do_this_one(file_info *finfo ) 
{ 


  {
#line 748
  if ((long )finfo->mode & (1L << 4)) {
#line 748
    return (1);
  }
#line 750
  if (newer_than) {
#line 750
    if (finfo->mtime < newer_than) {
#line 751
      return (0);
    }
  }
#line 753
  if (archive_level == 1) {
#line 753
    goto _L;
  } else
#line 753
  if (archive_level == 2) {
    _L: /* CIL Label */ 
#line 753
    if (! ((long )finfo->mode & (1L << 5))) {
#line 754
      return (0);
    }
  }
#line 756
  return (1);
}
}
#line 763 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int interpret_short_filename(char *p , file_info *finfo ) 
{ 
  time_t tmp ;

  {
  {
#line 765
  finfo->mode = (int )*((unsigned char *)p + 21);
#line 771
  finfo->ctime = make_unix_date((void *)(p + 22));
#line 772
  tmp = finfo->ctime;
#line 772
  finfo->atime = tmp;
#line 772
  finfo->mtime = tmp;
#line 773
  finfo->size = (int )(((unsigned int )*((unsigned char *)p + 26) | ((unsigned int )*((unsigned char *)p + 27) << 8)) | (((unsigned int )*((unsigned char *)p + 28) | ((unsigned int )*((unsigned char *)p + 29) << 8)) << 16));
#line 774
  StrCpy(finfo->name, p + 30);
  }
#line 776
  return (43);
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int interpret_long_filename(int level , char *p , file_info *finfo ) 
{ 
  int ret___2 ;
  int namelen ;

  {
#line 787
  if (finfo) {
    {
#line 788
    memcpy((void */* __restrict  */)finfo, (void const   */* __restrict  */)(& def_finfo),
           sizeof(*finfo));
    }
  }
  {
#line 792
  if (level == 1) {
#line 792
    goto case_1;
  }
#line 805
  if (level == 2) {
#line 805
    goto case_2;
  }
#line 819
  if (level == 3) {
#line 819
    goto case_3;
  }
#line 832
  if (level == 4) {
#line 832
    goto case_4;
  }
#line 845
  if (level == 260) {
#line 845
    goto case_260;
  }
#line 790
  goto switch_break;
  case_1: /* CIL Label */ 
#line 793
  if (finfo) {
    {
#line 796
    finfo->ctime = make_unix_date2((void *)(p + 4));
#line 797
    finfo->atime = make_unix_date2((void *)(p + 8));
#line 798
    finfo->mtime = make_unix_date2((void *)(p + 12));
#line 799
    finfo->size = (int )(((unsigned int )*((unsigned char *)p + 16) | ((unsigned int )*((unsigned char *)p + 17) << 8)) | (((unsigned int )*((unsigned char *)p + 18) | ((unsigned int )*((unsigned char *)p + 19) << 8)) << 16));
#line 800
    finfo->mode = (int )*((unsigned char *)p + 24);
#line 801
    StrCpy(finfo->name, p + 27);
    }
  }
#line 803
  return (28 + (int )*((unsigned char *)p + 26));
  case_2: /* CIL Label */ 
#line 806
  if (finfo) {
    {
#line 809
    finfo->ctime = make_unix_date2((void *)(p + 4));
#line 810
    finfo->atime = make_unix_date2((void *)(p + 8));
#line 811
    finfo->mtime = make_unix_date2((void *)(p + 12));
#line 812
    finfo->size = (int )(((unsigned int )*((unsigned char *)p + 16) | ((unsigned int )*((unsigned char *)p + 17) << 8)) | (((unsigned int )*((unsigned char *)p + 18) | ((unsigned int )*((unsigned char *)p + 19) << 8)) << 16));
#line 813
    finfo->mode = (int )*((unsigned char *)p + 24);
#line 814
    StrCpy(finfo->name, p + 31);
    }
  }
#line 816
  return (32 + (int )*((unsigned char *)p + 30));
  case_3: /* CIL Label */ 
#line 820
  if (finfo) {
    {
#line 823
    finfo->ctime = make_unix_date2((void *)(p + 8));
#line 824
    finfo->atime = make_unix_date2((void *)(p + 12));
#line 825
    finfo->mtime = make_unix_date2((void *)(p + 16));
#line 826
    finfo->size = (int )(((unsigned int )*((unsigned char *)p + 20) | ((unsigned int )*((unsigned char *)p + 21) << 8)) | (((unsigned int )*((unsigned char *)p + 22) | ((unsigned int )*((unsigned char *)p + 23) << 8)) << 16));
#line 827
    finfo->mode = (int )*((unsigned char *)p + 28);
#line 828
    StrCpy(finfo->name, p + 33);
    }
  }
#line 830
  return ((int )(((unsigned int )*((unsigned char *)p + 4) | ((unsigned int )*((unsigned char *)p + 5) << 8)) + 4U));
  case_4: /* CIL Label */ 
#line 833
  if (finfo) {
    {
#line 836
    finfo->ctime = make_unix_date2((void *)(p + 8));
#line 837
    finfo->atime = make_unix_date2((void *)(p + 12));
#line 838
    finfo->mtime = make_unix_date2((void *)(p + 16));
#line 839
    finfo->size = (int )(((unsigned int )*((unsigned char *)p + 20) | ((unsigned int )*((unsigned char *)p + 21) << 8)) | (((unsigned int )*((unsigned char *)p + 22) | ((unsigned int )*((unsigned char *)p + 23) << 8)) << 16));
#line 840
    finfo->mode = (int )*((unsigned char *)p + 28);
#line 841
    StrCpy(finfo->name, p + 37);
    }
  }
#line 843
  return ((int )(((unsigned int )*((unsigned char *)p + 4) | ((unsigned int )*((unsigned char *)p + 5) << 8)) + 4U));
  case_260: /* CIL Label */ 
#line 846
  if (finfo) {
    {
#line 848
    ret___2 = (int )((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8));
#line 850
    p += 4;
#line 851
    p += 4;
#line 863
    finfo->ctime = interpret_long_date(p);
#line 863
    p += 8;
#line 864
    finfo->atime = interpret_long_date(p);
#line 864
    p += 8;
#line 865
    finfo->mtime = interpret_long_date(p);
#line 865
    p += 8;
#line 865
    p += 8;
#line 866
    finfo->size = (int )(((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8)) | (((unsigned int )*((unsigned char *)p + 2) | ((unsigned int )*((unsigned char *)p + 3) << 8)) << 16));
#line 866
    p += 8;
#line 867
    p += 8;
#line 868
    finfo->mode = (int )*((unsigned char *)p + 0);
#line 868
    p += 4;
#line 869
    namelen = (int )(((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8)) | (((unsigned int )*((unsigned char *)p + 2) | ((unsigned int )*((unsigned char *)p + 3) << 8)) << 16));
#line 869
    p += 4;
#line 870
    p += 4;
#line 871
    p += 2;
#line 872
    p += 24;
#line 873
    StrnCpy(finfo->name, (char const   *)p, namelen);
    }
#line 874
    return (ret___2);
  }
#line 876
  return ((int )((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8)));
  switch_break: /* CIL Label */ ;
  }
#line 879
  if (DEBUGLEVEL >= 1) {
    {
#line 879
    Debug1((char *)"Unknown long filename format %d\n", level);
    }
  }
#line 880
  return ((int )((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8)));
}
}
#line 886 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static void dir_action(char *inbuf___0 , char *outbuf___1 , int attribute , file_info *finfo ,
                       BOOL recurse_dir , void (*fn)() , BOOL longdir ) 
{ 
  pstring mask2 ;
  pstring sav_dir ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;

  {
#line 891
  if (((long )finfo->mode & (1L << 4)) == 0L) {
#line 891
    if (fileselection[0]) {
      {
#line 891
      tmp___0 = mask_match(finfo->name, fileselection, 0, 0);
      }
#line 891
      if (tmp___0) {
#line 891
        goto _L___2;
      }
    } else {
#line 891
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 891
  if (recurse_dir) {
    {
#line 891
    tmp___1 = strequal(finfo->name, (char *)".");
    }
#line 891
    if (! tmp___1) {
      {
#line 891
      tmp___2 = strequal(finfo->name, (char *)"..");
      }
#line 891
      if (! tmp___2) {
#line 891
        goto _L___0;
      }
    }
  } else
  _L___0: /* CIL Label */ 
#line 896
  if (recurse_dir) {
#line 896
    if ((long )finfo->mode & (1L << 4)) {
      {
#line 900
      StrCpy(sav_dir, cur_dir);
#line 901
      strcat((char */* __restrict  */)(cur_dir), (char const   */* __restrict  */)(finfo->name));
#line 902
      strcat((char */* __restrict  */)(cur_dir), (char const   */* __restrict  */)"\\");
#line 903
      StrCpy(mask2, cur_dir);
      }
#line 905
      if (! fn) {
#line 906
        if (DEBUGLEVEL >= 0) {
          {
#line 906
          Debug1((char *)"\n%s\n", cur_dir);
          }
        }
      }
#line 908
      if (longdir) {
        {
#line 910
        strcat((char */* __restrict  */)(mask2), (char const   */* __restrict  */)"*");
#line 911
        do_long_dir(inbuf___0, outbuf___1, mask2, attribute, fn, 1);
        }
      } else {
        {
#line 915
        strcat((char */* __restrict  */)(mask2), (char const   */* __restrict  */)"*.*");
#line 916
        do_dir(inbuf___0, outbuf___1, mask2, attribute, fn, 1);
        }
      }
      {
#line 918
      StrCpy(cur_dir, sav_dir);
      }
    } else {
#line 896
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 922
  if (fn) {
    {
#line 922
    tmp = do_this_one(finfo);
    }
#line 922
    if (tmp) {
      {
#line 923
      (*fn)(finfo);
      }
    }
  }
#line 926
  return;
}
}
#line 931 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int do_short_dir(char *inbuf___0 , char *outbuf___1 , char *Mask , int attribute ,
                        void (*fn)() , BOOL recurse_dir ) 
{ 
  char *p ;
  int received ;
  BOOL first ;
  char status[21] ;
  int num_asked ;
  int num_received ;
  int i___0 ;
  char *dirlist ;
  pstring mask ;
  file_info finfo ;
  size_t tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 936
  received = 0;
#line 937
  first = 1;
#line 939
  num_asked = (max_xmit - 100) / 43;
#line 940
  num_received = 0;
#line 942
  dirlist = (char *)((void *)0);
#line 946
  finfo = def_finfo;
#line 948
  bzero((void *)(status), (size_t )21);
#line 950
  StrCpy(mask, Mask);
  }
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 954
    bzero((void *)outbuf___1, (size_t )39);
    }
#line 955
    if (first) {
      {
#line 956
      tmp = strlen((char const   *)(mask));
#line 956
      set_message(outbuf___1, 2, (int )(5UL + tmp), 1);
      }
    } else {
      {
#line 958
      set_message(outbuf___1, 2, 26, 1);
      }
    }
    {
#line 965
    *((unsigned char *)outbuf___1 + 8) = (unsigned char)129;
#line 967
    *((unsigned char *)outbuf___1 + 28) = (unsigned char )((int )((uint16 )cnum) & 255);
#line 967
    *((unsigned char *)outbuf___1 + 29) = (unsigned char )((int )((uint16 )cnum) >> 8);
#line 968
    setup_pkt(outbuf___1);
#line 970
    *((unsigned char *)outbuf___1 + 37) = (unsigned char )((int )((uint16 )num_asked) & 255);
#line 970
    *((unsigned char *)outbuf___1 + 38) = (unsigned char )((int )((uint16 )num_asked) >> 8);
#line 971
    *((unsigned char *)outbuf___1 + 39) = (unsigned char )((int )((uint16 )attribute) & 255);
#line 971
    *((unsigned char *)outbuf___1 + 40) = (unsigned char )((int )((uint16 )attribute) >> 8);
#line 973
    p = smb_buf(outbuf___1);
#line 974
    tmp___0 = p;
#line 974
    p ++;
#line 974
    *tmp___0 = (char)4;
    }
#line 976
    if (first) {
      {
#line 977
      StrCpy(p, mask);
      }
    } else {
      {
#line 979
      StrCpy(p, (char *)"");
      }
    }
    {
#line 980
    tmp___1 = strlen((char const   *)p);
#line 980
    p += tmp___1 + 1UL;
#line 982
    tmp___2 = p;
#line 982
    p ++;
#line 982
    *tmp___2 = (char)5;
    }
#line 983
    if (first) {
#line 984
      *((unsigned char *)p + 0) = (unsigned char)0;
#line 984
      *((unsigned char *)p + 1) = (unsigned char)0;
    } else {
      {
#line 987
      *((unsigned char *)p + 0) = (unsigned char)21;
#line 987
      *((unsigned char *)p + 1) = (unsigned char )(21 >> 8);
#line 988
      p += 2;
#line 989
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(status),
             (size_t )21);
      }
    }
    {
#line 992
    send_smb(Client, outbuf___1);
#line 993
    receive_smb(Client, inbuf___0, 15000);
#line 995
    received = (int )((unsigned int )*((unsigned char *)inbuf___0 + 37) | ((unsigned int )*((unsigned char *)inbuf___0 + 38) << 8));
    }
#line 997
    if (DEBUGLEVEL >= 5) {
      {
#line 997
      Debug1((char *)"dir received %d\n", received);
      }
    }
#line 999
    if (DEBUGLEVEL >= 6) {
      {
#line 999
      tmp___3 = smb_errstr(inbuf___0);
#line 999
      Debug1((char *)"errstr=%s\n", tmp___3);
      }
    }
#line 1001
    if (received <= 0) {
#line 1001
      goto while_break;
    }
    {
#line 1003
    first = 0;
#line 1005
    tmp___4 = Realloc((void *)dirlist, (num_received + received) * 43);
#line 1005
    dirlist = (char *)tmp___4;
    }
#line 1007
    if (! dirlist) {
#line 1008
      return (0);
    }
    {
#line 1010
    tmp___5 = smb_buf(inbuf___0);
#line 1010
    p = tmp___5 + 3;
#line 1012
    memcpy((void */* __restrict  */)(dirlist + num_received * 43), (void const   */* __restrict  */)p,
           (size_t )(received * 43));
#line 1015
    memcpy((void */* __restrict  */)(status), (void const   */* __restrict  */)(p + (received - 1) * 43),
           (size_t )21);
#line 1017
    num_received += received;
    }
#line 1019
    if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 1019
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1050
  if (! fn) {
#line 1051
    p = dirlist;
#line 1051
    i___0 = 0;
    {
#line 1051
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1051
      if (! (i___0 < num_received)) {
#line 1051
        goto while_break___0;
      }
      {
#line 1053
      tmp___6 = interpret_short_filename(p, & finfo);
#line 1053
      p += tmp___6;
#line 1054
      display_finfo(& finfo);
#line 1051
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1057
  p = dirlist;
#line 1057
  i___0 = 0;
  {
#line 1057
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1057
    if (! (i___0 < num_received)) {
#line 1057
      goto while_break___1;
    }
#line 1060
    if (stepping) {
#line 1060
      if (tested_stash) {
#line 1061
        goto while_break___1;
      }
    }
    {
#line 1063
    tmp___7 = interpret_short_filename(p, & finfo);
#line 1063
    p += tmp___7;
#line 1064
    dir_action(inbuf___0, outbuf___1, attribute, & finfo, recurse_dir, fn, 0);
#line 1057
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1068
  if (dirlist) {
    {
#line 1068
    free((void *)dirlist);
    }
  }
#line 1069
  return (num_received);
}
}
#line 1075 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL receive_trans_response(char *inbuf___0 , int trans , int *data_len , int *param_len ,
                                   char **data , char **param ) 
{ 
  int total_data ;
  int total_param ;
  int this_data ;
  int this_param ;
  int tmp ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  char const   *tmp___4 ;

  {
  {
#line 1079
  total_data = 0;
#line 1080
  total_param = 0;
#line 1083
  tmp = 0;
#line 1083
  *param_len = tmp;
#line 1083
  *data_len = tmp;
#line 1085
  receive_smb(Client, inbuf___0, 15000);
#line 1086
  show_msg(inbuf___0);
  }
#line 1089
  if ((int )*((unsigned char *)inbuf___0 + 8) != trans) {
#line 1091
    if (DEBUGLEVEL >= 0) {
#line 1091
      if (trans == 37) {
#line 1091
        tmp___0 = "SMBtrans";
      } else {
#line 1091
        tmp___0 = "SMBtrans2";
      }
      {
#line 1091
      Debug1((char *)"Expected %s response, got command 0x%02x\n", tmp___0, (int )*((unsigned char *)inbuf___0 + 8));
      }
    }
#line 1093
    return (0);
  }
#line 1095
  if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 1099
    if (DEBUGLEVEL >= 0) {
      {
#line 1099
      tmp___1 = smb_errstr(inbuf___0);
#line 1099
      Debug1((char *)"Trans failed (%d, %d): %s\n", (int )*((unsigned char *)inbuf___0 + 9),
             (unsigned int )*((unsigned char *)inbuf___0 + 11) | ((unsigned int )*((unsigned char *)inbuf___0 + 12) << 8),
             tmp___1);
      }
    }
#line 1101
    return (0);
  }
  {
#line 1108
  total_data = (int )((unsigned int )*((unsigned char *)inbuf___0 + 39) | ((unsigned int )*((unsigned char *)inbuf___0 + 40) << 8));
#line 1109
  total_param = (int )((unsigned int )*((unsigned char *)inbuf___0 + 37) | ((unsigned int )*((unsigned char *)inbuf___0 + 38) << 8));
#line 1112
  tmp___2 = Realloc((void *)*data, total_data);
#line 1112
  *data = (char *)tmp___2;
#line 1113
  tmp___3 = Realloc((void *)*param, total_param);
#line 1113
  *param = (char *)tmp___3;
  }
  {
#line 1115
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1117
    this_data = (int )((unsigned int )*((unsigned char *)inbuf___0 + 49) | ((unsigned int )*((unsigned char *)inbuf___0 + 50) << 8));
#line 1118
    this_param = (int )((unsigned int )*((unsigned char *)inbuf___0 + 43) | ((unsigned int )*((unsigned char *)inbuf___0 + 44) << 8));
#line 1119
    if (this_data) {
      {
#line 1120
      memcpy((void */* __restrict  */)(*data + ((unsigned int )*((unsigned char *)inbuf___0 + 53) | ((unsigned int )*((unsigned char *)inbuf___0 + 54) << 8))),
             (void const   */* __restrict  */)((inbuf___0 + 4) + ((unsigned int )*((unsigned char *)inbuf___0 + 51) | ((unsigned int )*((unsigned char *)inbuf___0 + 52) << 8))),
             (size_t )this_data);
      }
    }
#line 1123
    if (this_param) {
      {
#line 1124
      memcpy((void */* __restrict  */)(*param + ((unsigned int )*((unsigned char *)inbuf___0 + 47) | ((unsigned int )*((unsigned char *)inbuf___0 + 48) << 8))),
             (void const   */* __restrict  */)((inbuf___0 + 4) + ((unsigned int )*((unsigned char *)inbuf___0 + 45) | ((unsigned int )*((unsigned char *)inbuf___0 + 46) << 8))),
             (size_t )this_param);
      }
    }
#line 1127
    *data_len += this_data;
#line 1128
    *param_len += this_param;
#line 1131
    total_data = (int )((unsigned int )*((unsigned char *)inbuf___0 + 39) | ((unsigned int )*((unsigned char *)inbuf___0 + 40) << 8));
#line 1132
    total_param = (int )((unsigned int )*((unsigned char *)inbuf___0 + 37) | ((unsigned int )*((unsigned char *)inbuf___0 + 38) << 8));
#line 1134
    if (total_data <= *data_len) {
#line 1134
      if (total_param <= *param_len) {
#line 1135
        goto while_break;
      }
    }
    {
#line 1137
    receive_smb(Client, inbuf___0, 15000);
#line 1138
    show_msg(inbuf___0);
    }
#line 1141
    if ((int )*((unsigned char *)inbuf___0 + 8) != trans) {
#line 1143
      if (DEBUGLEVEL >= 0) {
#line 1143
        if (trans == 37) {
#line 1143
          tmp___4 = "SMBtrans";
        } else {
#line 1143
          tmp___4 = "SMBtrans2";
        }
        {
#line 1143
        Debug1((char *)"Expected %s response, got command 0x%02x\n", tmp___4, (int )*((unsigned char *)inbuf___0 + 8));
        }
      }
#line 1145
      return (0);
    }
#line 1147
    if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 1148
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1151
  return (1);
}
}
#line 1158 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int do_long_dir(char *inbuf___0 , char *outbuf___1 , char *Mask , int attribute ,
                       void (*fn)() , BOOL recurse_dir ) 
{ 
  int max_matches ;
  int info_level ;
  int tmp ;
  char *p ;
  pstring mask ;
  file_info finfo ;
  int i___0 ;
  char *dirlist ;
  int dirlist_len ;
  int total_received ;
  BOOL First ;
  char *resp_data ;
  char *resp_param ;
  int resp_data_len ;
  int resp_param_len ;
  int ff_resume_key ;
  int ff_searchcount ;
  int ff_eos ;
  int ff_lastname ;
  int ff_dir_handle ;
  int loop_count ;
  uint16 setup ;
  pstring param ;
  size_t tmp___0 ;
  char *tmp___1 ;
  char const   *tmp___2 ;
  BOOL tmp___3 ;
  void *tmp___4 ;
  char *p2 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 1162
  max_matches = 512;
#line 1163
  if (Protocol < 5) {
#line 1163
    tmp = 1;
  } else {
#line 1163
    tmp = 260;
  }
  {
#line 1163
  info_level = tmp;
#line 1168
  dirlist = (char *)((void *)0);
#line 1169
  dirlist_len = 0;
#line 1170
  total_received = 0;
#line 1171
  First = 1;
#line 1172
  resp_data = (char *)((void *)0);
#line 1173
  resp_param = (char *)((void *)0);
#line 1174
  resp_data_len = 0;
#line 1175
  resp_param_len = 0;
#line 1177
  ff_resume_key = 0;
#line 1178
  ff_searchcount = 0;
#line 1179
  ff_eos = 0;
#line 1180
  ff_lastname = 0;
#line 1181
  ff_dir_handle = 0;
#line 1182
  loop_count = 0;
#line 1187
  StrCpy(mask, Mask);
  }
  {
#line 1189
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1189
    if (! (ff_eos == 0)) {
#line 1189
      goto while_break;
    }
#line 1191
    loop_count ++;
#line 1192
    if (loop_count > 200) {
#line 1194
      if (DEBUGLEVEL >= 0) {
        {
#line 1194
        Debug1((char *)"ERROR: Looping in FIND_NEXT??\n");
        }
      }
#line 1195
      goto while_break;
    }
#line 1198
    if (First) {
      {
#line 1200
      setup = (uint16 )1;
#line 1201
      *((unsigned char *)(param) + 0) = (unsigned char )((int )((uint16 )attribute) & 255);
#line 1201
      *((unsigned char *)(param) + 1) = (unsigned char )((int )((uint16 )attribute) >> 8);
#line 1202
      *((unsigned char *)(param) + 2) = (unsigned char )((int )((uint16 )max_matches) & 255);
#line 1202
      *((unsigned char *)(param) + 3) = (unsigned char )((int )((uint16 )max_matches) >> 8);
#line 1203
      *((unsigned char *)(param) + 4) = (unsigned char)14;
#line 1203
      *((unsigned char *)(param) + 5) = (unsigned char )(14 >> 8);
#line 1204
      *((unsigned char *)(param) + 6) = (unsigned char )((int )((uint16 )info_level) & 255);
#line 1204
      *((unsigned char *)(param) + 7) = (unsigned char )((int )((uint16 )info_level) >> 8);
#line 1205
      *((unsigned char *)(param) + 8) = (unsigned char)0;
#line 1205
      *((unsigned char *)(param) + 9) = (unsigned char)0;
#line 1205
      *((unsigned char *)(param) + 10) = (unsigned char)0;
#line 1205
      *((unsigned char *)(param) + 11) = (unsigned char)0;
#line 1206
      StrCpy(param + 12, mask);
      }
    } else {
      {
#line 1210
      setup = (uint16 )2;
#line 1211
      *((unsigned char *)(param) + 0) = (unsigned char )((int )((uint16 )ff_dir_handle) & 255);
#line 1211
      *((unsigned char *)(param) + 1) = (unsigned char )((int )((uint16 )ff_dir_handle) >> 8);
#line 1212
      *((unsigned char *)(param) + 2) = (unsigned char )((int )((uint16 )max_matches) & 255);
#line 1212
      *((unsigned char *)(param) + 3) = (unsigned char )((int )((uint16 )max_matches) >> 8);
#line 1213
      *((unsigned char *)(param) + 4) = (unsigned char )((int )((uint16 )info_level) & 255);
#line 1213
      *((unsigned char *)(param) + 5) = (unsigned char )((int )((uint16 )info_level) >> 8);
#line 1214
      *((unsigned char *)(param) + 6) = (unsigned char )(((uint32 )ff_resume_key & 65535U) & 255U);
#line 1214
      *((unsigned char *)(param) + 7) = (unsigned char )(((uint32 )ff_resume_key & 65535U) >> 8);
#line 1214
      *((unsigned char *)(param) + 8) = (unsigned char )(((uint32 )ff_resume_key >> 16) & 255U);
#line 1214
      *((unsigned char *)(param) + 9) = (unsigned char )(((uint32 )ff_resume_key >> 16) >> 8);
#line 1215
      *((unsigned char *)(param) + 10) = (unsigned char)14;
#line 1215
      *((unsigned char *)(param) + 11) = (unsigned char )(14 >> 8);
#line 1216
      StrCpy(param + 12, mask);
      }
#line 1218
      if (DEBUGLEVEL >= 5) {
        {
#line 1218
        Debug1((char *)"hand=0x%X resume=%d ff_lastname=%d mask=%s\n", ff_dir_handle,
               ff_resume_key, ff_lastname, mask);
        }
      }
    }
    {
#line 1223
    tmp___0 = strlen((char const   *)(mask));
#line 1223
    send_trans_request(outbuf___1, 50, (char *)((void *)0), 65535, 0, (char *)((void *)0),
                       param, & setup, 0, (int )((12UL + tmp___0) + 1UL), 1, 65535,
                       10, 0);
#line 1228
    tmp___3 = receive_trans_response(inbuf___0, 50, & resp_data_len, & resp_param_len,
                                     & resp_data, & resp_param);
    }
#line 1228
    if (! tmp___3) {
#line 1232
      if (DEBUGLEVEL >= 3) {
        {
#line 1232
        tmp___1 = smb_errstr(inbuf___0);
        }
#line 1232
        if (First) {
#line 1232
          tmp___2 = "FIRST";
        } else {
#line 1232
          tmp___2 = "NEXT";
        }
        {
#line 1232
        Debug1((char *)"FIND%s gave %s\n", tmp___2, tmp___1);
        }
      }
#line 1233
      goto while_break;
    }
#line 1237
    p = resp_param;
#line 1238
    if (First) {
#line 1240
      ff_dir_handle = (int )((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8));
#line 1241
      ff_searchcount = (int )((unsigned int )*((unsigned char *)p + 2) | ((unsigned int )*((unsigned char *)p + 3) << 8));
#line 1242
      ff_eos = (int )((unsigned int )*((unsigned char *)p + 4) | ((unsigned int )*((unsigned char *)p + 5) << 8));
#line 1243
      ff_lastname = (int )((unsigned int )*((unsigned char *)p + 8) | ((unsigned int )*((unsigned char *)p + 9) << 8));
    } else {
#line 1247
      ff_searchcount = (int )((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8));
#line 1248
      ff_eos = (int )((unsigned int )*((unsigned char *)p + 2) | ((unsigned int )*((unsigned char *)p + 3) << 8));
#line 1249
      ff_lastname = (int )((unsigned int )*((unsigned char *)p + 6) | ((unsigned int )*((unsigned char *)p + 7) << 8));
    }
#line 1252
    if (ff_searchcount == 0) {
#line 1253
      goto while_break;
    }
#line 1256
    p = resp_data;
#line 1259
    if (ff_lastname > 0) {
      {
#line 1263
      if (info_level == 260) {
#line 1263
        goto case_260;
      }
#line 1268
      if (info_level == 1) {
#line 1268
        goto case_1;
      }
#line 1261
      goto switch_break;
      case_260: /* CIL Label */ 
      {
#line 1264
      ff_resume_key = 0;
#line 1265
      StrnCpy(mask, (char const   *)(p + ff_lastname), resp_data_len - ff_lastname);
      }
#line 1267
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 1269
      StrCpy(mask, (p + ff_lastname) + 1);
#line 1270
      ff_resume_key = 0;
      }
#line 1271
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 1275
      StrCpy(mask, (char *)"");
      }
    }
    {
#line 1278
    tmp___4 = Realloc((void *)dirlist, dirlist_len + resp_data_len);
#line 1278
    dirlist = (char *)tmp___4;
    }
#line 1280
    if (! dirlist) {
#line 1282
      if (DEBUGLEVEL >= 0) {
        {
#line 1282
        Debug1((char *)"Failed to expand dirlist\n");
        }
      }
#line 1283
      goto while_break;
    }
#line 1290
    p2 = p;
#line 1290
    i___0 = 0;
    {
#line 1290
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1290
      if (! (i___0 < ff_searchcount - 1)) {
#line 1290
        goto while_break___0;
      }
      {
#line 1291
      tmp___5 = interpret_long_filename(info_level, p2, (file_info *)((void *)0));
#line 1291
      p2 += tmp___5;
#line 1290
      i___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1292
    *((unsigned char *)p2 + 0) = (unsigned char )((int )((uint16 )((ptrdiff_t )resp_data_len - (p2 - p))) & 255);
#line 1292
    *((unsigned char *)p2 + 1) = (unsigned char )((int )((uint16 )((ptrdiff_t )resp_data_len - (p2 - p))) >> 8);
#line 1296
    memcpy((void */* __restrict  */)(dirlist + dirlist_len), (void const   */* __restrict  */)p,
           (size_t )resp_data_len);
#line 1297
    dirlist_len += resp_data_len;
#line 1299
    total_received += ff_searchcount;
    }
#line 1301
    if (resp_data) {
      {
#line 1301
      free((void *)resp_data);
      }
    }
#line 1301
    resp_data = (char *)((void *)0);
#line 1302
    if (resp_param) {
      {
#line 1302
      free((void *)resp_param);
      }
    }
#line 1302
    resp_param = (char *)((void *)0);
#line 1304
    if (DEBUGLEVEL >= 3) {
      {
#line 1304
      Debug1((char *)"received %d entries (eos=%d resume=%d)\n", ff_searchcount, ff_eos,
             ff_resume_key);
      }
    }
#line 1307
    First = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 1310
  if (! fn) {
#line 1311
    p = dirlist;
#line 1311
    i___0 = 0;
    {
#line 1311
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1311
      if (! (i___0 < total_received)) {
#line 1311
        goto while_break___1;
      }
      {
#line 1313
      tmp___6 = interpret_long_filename(info_level, p, & finfo);
#line 1313
      p += tmp___6;
#line 1314
      display_finfo(& finfo);
#line 1311
      i___0 ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1317
  p = dirlist;
#line 1317
  i___0 = 0;
  {
#line 1317
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1317
    if (! (i___0 < total_received)) {
#line 1317
      goto while_break___2;
    }
#line 1320
    if (stepping) {
#line 1320
      if (tested_stash) {
#line 1321
        goto while_break___2;
      }
    }
    {
#line 1323
    tmp___7 = interpret_long_filename(info_level, p, & finfo);
#line 1323
    p += tmp___7;
#line 1324
    dir_action(inbuf___0, outbuf___1, attribute, & finfo, recurse_dir, fn, 1);
#line 1317
    i___0 ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 1328
  if (dirlist) {
    {
#line 1328
    free((void *)dirlist);
    }
  }
#line 1329
  return (total_received);
}
}
#line 1794 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL do_mkdir(char *name___1 ) 
{ 
  char *p ;
  char *inbuf___0 ;
  char *outbuf___1 ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1799
  tmp = malloc((size_t )66559);
#line 1799
  inbuf___0 = (char *)tmp;
#line 1800
  tmp___0 = malloc((size_t )66559);
#line 1800
  outbuf___1 = (char *)tmp___0;
  }
#line 1802
  if (! inbuf___0) {
#line 1802
    goto _L;
  } else
#line 1802
  if (! outbuf___1) {
    _L: /* CIL Label */ 
#line 1804
    if (DEBUGLEVEL >= 0) {
      {
#line 1804
      Debug1((char *)"out of memory\n");
      }
    }
#line 1805
    return (0);
  }
  {
#line 1808
  bzero((void *)outbuf___1, (size_t )39);
#line 1809
  tmp___1 = strlen((char const   *)name___1);
#line 1809
  set_message(outbuf___1, 0, (int )(2UL + tmp___1), 1);
#line 1811
  *((unsigned char *)outbuf___1 + 8) = (unsigned char)0;
#line 1812
  *((unsigned char *)outbuf___1 + 28) = (unsigned char )((int )((uint16 )cnum) & 255);
#line 1812
  *((unsigned char *)outbuf___1 + 29) = (unsigned char )((int )((uint16 )cnum) >> 8);
#line 1813
  setup_pkt(outbuf___1);
#line 1814
  p = smb_buf(outbuf___1);
#line 1815
  tmp___2 = p;
#line 1815
  p ++;
#line 1815
  *tmp___2 = (char)4;
#line 1816
  StrCpy(p, name___1);
#line 1818
  send_smb(Client, outbuf___1);
#line 1819
  receive_smb(Client, inbuf___0, 15000);
  }
#line 1821
  if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 1823
    if (DEBUGLEVEL >= 0) {
      {
#line 1823
      tmp___3 = smb_errstr(inbuf___0);
#line 1823
      Debug1((char *)"%s making remote directory %s\n", tmp___3, name___1);
      }
    }
    {
#line 1826
    free((void *)inbuf___0);
#line 1826
    free((void *)outbuf___1);
    }
#line 1827
    return (0);
  }
  {
#line 1830
  free((void *)inbuf___0);
#line 1830
  free((void *)outbuf___1);
  }
#line 1831
  return (1);
}
}
#line 1882 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL do_rmdir(char *name___1 ) 
{ 
  char *p ;
  char *inbuf___0 ;
  char *outbuf___1 ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 1887
  tmp = malloc((size_t )66559);
#line 1887
  inbuf___0 = (char *)tmp;
#line 1888
  tmp___0 = malloc((size_t )66559);
#line 1888
  outbuf___1 = (char *)tmp___0;
  }
#line 1890
  if (! inbuf___0) {
#line 1890
    goto _L;
  } else
#line 1890
  if (! outbuf___1) {
    _L: /* CIL Label */ 
#line 1892
    if (DEBUGLEVEL >= 0) {
      {
#line 1892
      Debug1((char *)"out of memory\n");
      }
    }
#line 1893
    return (0);
  }
  {
#line 1896
  bzero((void *)outbuf___1, (size_t )39);
#line 1897
  tmp___1 = strlen((char const   *)name___1);
#line 1897
  set_message(outbuf___1, 0, (int )(2UL + tmp___1), 1);
#line 1899
  *((unsigned char *)outbuf___1 + 8) = (unsigned char)1;
#line 1900
  *((unsigned char *)outbuf___1 + 28) = (unsigned char )((int )((uint16 )cnum) & 255);
#line 1900
  *((unsigned char *)outbuf___1 + 29) = (unsigned char )((int )((uint16 )cnum) >> 8);
#line 1901
  setup_pkt(outbuf___1);
#line 1902
  p = smb_buf(outbuf___1);
#line 1903
  tmp___2 = p;
#line 1903
  p ++;
#line 1903
  *tmp___2 = (char)4;
#line 1904
  StrCpy(p, name___1);
#line 1906
  send_smb(Client, outbuf___1);
#line 1907
  receive_smb(Client, inbuf___0, 15000);
  }
#line 1909
  if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 1911
    if (DEBUGLEVEL >= 0) {
      {
#line 1911
      tmp___3 = smb_errstr(inbuf___0);
#line 1911
      Debug1((char *)"%s removing remote directory %s\n", tmp___3, name___1);
      }
    }
    {
#line 1914
    free((void *)inbuf___0);
#line 1914
    free((void *)outbuf___1);
    }
#line 1915
    return (0);
  }
  {
#line 1918
  free((void *)inbuf___0);
#line 1918
  free((void *)outbuf___1);
  }
#line 1919
  return (1);
}
}
#line 2037 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL send_session_request(char *inbuf___0 , char *outbuf___1 ) 
{ 
  fstring dest ;
  char *p ;
  int len ;
  int tmp ;
  int tmp___0 ;
  int port ;
  char *tmp___1 ;
  BOOL tmp___2 ;
  int ecode ;

  {
  {
#line 2041
  len = 4;
#line 2044
  StrCpy(dest, desthost);
#line 2045
  p = strchr((char const   *)(dest), '.');
  }
#line 2046
  if (p) {
#line 2046
    *p = (char)0;
  }
  {
#line 2049
  p = outbuf___1 + len;
#line 2050
  name_mangle(dest, p, (char )name_type);
#line 2051
  tmp = name_len(p);
#line 2051
  len += tmp;
#line 2054
  p = outbuf___1 + len;
#line 2055
  name_mangle(myname, p, (char)0);
#line 2056
  tmp___0 = name_len(p);
#line 2056
  len += tmp___0;
#line 2059
  _smb_setlen(outbuf___1, len);
#line 2060
  *((unsigned char *)outbuf___1 + 0) = (unsigned char)129;
#line 2062
  send_smb(Client, outbuf___1);
  }
#line 2063
  if (DEBUGLEVEL >= 5) {
    {
#line 2063
    Debug1((char *)"Sent session request\n");
    }
  }
  {
#line 2065
  receive_smb(Client, inbuf___0, 15000);
  }
#line 2067
  if ((int )*((unsigned char *)inbuf___0 + 0) == 132) {
    {
#line 2080
    port = ((int )*((unsigned char *)inbuf___0 + 8) << 8) + (int )*((unsigned char *)inbuf___0 + 9);
#line 2082
    putip((void *)((char *)(& dest_ip)), (void *)(inbuf___0 + 4));
#line 2084
    close_sockets();
    }
#line 2086
    if (DEBUGLEVEL >= 3) {
      {
#line 2086
      tmp___1 = inet_ntoa(dest_ip);
#line 2086
      Debug1((char *)"Retargeted to [%s] %d\n", tmp___1, port);
      }
    }
    {
#line 2088
    Client = open_socket_out(1, & dest_ip, port);
    }
#line 2089
    if (Client == -1) {
#line 2090
      return (0);
    }
#line 2092
    if (DEBUGLEVEL >= 3) {
      {
#line 2092
      Debug1((char *)"Retargeted\n");
      }
    }
    {
#line 2094
    set_socket_options(Client, user_socket_options);
#line 2097
    tmp___2 = send_session_request(inbuf___0, outbuf___1);
    }
#line 2097
    return (tmp___2);
  }
#line 2100
  if ((int )*((unsigned char *)inbuf___0 + 0) != 130) {
#line 2102
    ecode = (int )*((unsigned char *)inbuf___0 + 4);
#line 2103
    if (DEBUGLEVEL >= 0) {
      {
#line 2103
      Debug1((char *)"Session request failed (%d,%d) with myname=%s destname=%s\n",
             (int )*((unsigned char *)inbuf___0 + 0), ecode, myname, desthost);
      }
    }
#line 2138
    return (0);
  }
#line 2140
  return (1);
}
}
#line 2158 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int interpret_serr(unsigned char rcls , uint16 err ) 
{ 
  register int reserr ;

  {
#line 2162
  reserr = 0;
#line 2164
  if ((int )rcls == 0) {
#line 2164
    if ((int )err == 0) {
#line 2164
      return (0);
    }
  }
#line 2165
  if ((int )rcls == 2) {
#line 2166
    if ((int )err == 1) {
#line 2166
      return (1);
    }
#line 2167
    if ((int )err == 2) {
#line 2167
      return (2);
    }
#line 2168
    if ((int )err == 4) {
#line 2168
      return (1);
    }
#line 2169
    if ((int )err == 5) {
#line 2169
      return (5);
    }
#line 2170
    if ((int )err == 6) {
#line 2170
      return (6);
    }
#line 2171
    if ((int )err == 7) {
#line 2171
      return (6);
    }
  }
#line 2173
  if ((int )rcls == 1) {
#line 2174
    if ((int )err == 5) {
#line 2174
      return (2);
    }
#line 2175
    if ((int )err == 65) {
#line 2175
      return (1);
    }
#line 2176
    if ((int )err == 67) {
#line 2176
      return (6);
    }
#line 2177
    if ((int )err == 71) {
#line 2177
      return (1);
    }
#line 2178
    if ((int )err == 86) {
#line 2178
      return (2);
    }
#line 2179
    if ((int )err == 87) {
#line 2179
      return (1);
    }
#line 2180
    if ((int )err == 90) {
#line 2180
      return (1);
    }
#line 2181
    if ((int )err == 2239) {
#line 2181
      return (1);
    }
#line 2182
    if ((int )err == 2240) {
#line 2182
      return (1);
    }
#line 2183
    if ((int )err == 2241) {
#line 2183
      return (1);
    }
#line 2184
    if ((int )err == 2242) {
#line 2184
      return (1);
    }
#line 2185
    if ((int )err == 2247) {
#line 2185
      return (1);
    }
  }
#line 2187
  return (1);
}
}
#line 2203
BOOL H_name_status(int fd , char *name___1 , int name_type___0 , struct in_addr to_ip ) ;
#line 2193 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL send_status(char *lookup ) 
{ 
  register int x ;
  int udpfd ;

  {
  {
#line 2198
  udpfd = open_socket_in(2, 137, 3);
  }
#line 2198
  if (udpfd < 0) {
#line 2199
    return (0);
  }
#line 2201
  if (DEBUGLEVEL >= 3) {
    {
#line 2201
    Debug1((char *)"UDP Socket opened.\n");
    }
  }
  {
#line 2203
  x = H_name_status(udpfd, lookup, name_type, dest_ip);
#line 2214
  close(udpfd);
  }
#line 2215
  if (x == 0) {
#line 2216
    return (0);
  }
#line 2217
  return (1);
}
}
#line 2221 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int sesskey  =    0;
#line 2222 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static time_t servertime  =    (time_t )0;
#line 2223 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int sec_mode  =    0;
#line 2224 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int crypt_len  ;
#line 2225 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int max_vcs  =    0;
#line 2230
int serverzone ;
#line 2364
static BOOL send_prots(char *inbuf___0 , char *outbuf___1 ) ;
#line 2364 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL done_time  =    0;
#line 2227 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL send_prots(char *inbuf___0 , char *outbuf___1 ) 
{ 
  BOOL was_null ;
  int tmp ;
  struct __anonstruct_prots_91 prots[9] ;
  register char *p ;
  int numprots ;
  int plength ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  register int i___0 ;
  struct tm *tmp___7 ;
  char *tmp___8 ;
  struct tm *tmp___9 ;
  char *tmp___10 ;

  {
#line 2229
  if (! inbuf___0) {
#line 2229
    if (! outbuf___1) {
#line 2229
      tmp = 1;
    } else {
#line 2229
      tmp = 0;
    }
  } else {
#line 2229
    tmp = 0;
  }
#line 2229
  was_null = tmp;
#line 2231
  prots[0].prot = 1;
#line 2231
  prots[0].name = (char *)"PC NETWORK PROGRAM 1.0";
#line 2231
  prots[1].prot = 2;
#line 2231
  prots[1].name = (char *)"MICROSOFT NETWORKS 1.03";
#line 2231
  prots[2].prot = 3;
#line 2231
  prots[2].name = (char *)"MICROSOFT NETWORKS 3.0";
#line 2231
  prots[3].prot = 3;
#line 2231
  prots[3].name = (char *)"LANMAN1.0";
#line 2231
  prots[4].prot = 4;
#line 2231
  prots[4].name = (char *)"LM1.2X002";
#line 2231
  prots[5].prot = 4;
#line 2231
  prots[5].name = (char *)"Samba";
#line 2231
  prots[6].prot = 5;
#line 2231
  prots[6].name = (char *)"NT LM 0.12";
#line 2231
  prots[7].prot = 5;
#line 2231
  prots[7].name = (char *)"NT LANMAN 1.0";
#line 2231
  prots[8].prot = -1;
#line 2231
  prots[8].name = (char *)((void *)0);
#line 2250
  if (was_null) {
#line 2251
    return (0);
  }
  {
#line 2253
  bzero((void *)outbuf___1, (size_t )39);
#line 2259
  plength = 0;
#line 2259
  numprots = 0;
  }
  {
#line 2259
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2259
    if (prots[numprots].name) {
#line 2259
      if (! (prots[numprots].prot <= max_protocol)) {
#line 2259
        goto while_break;
      }
    } else {
#line 2259
      goto while_break;
    }
    {
#line 2262
    tmp___0 = strlen((char const   *)prots[numprots].name);
#line 2262
    plength = (int )((size_t )plength + (tmp___0 + 2UL));
#line 2259
    numprots ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2264
  set_message(outbuf___1, 0, plength, 1);
#line 2266
  p = smb_buf(outbuf___1);
#line 2267
  numprots = 0;
  }
  {
#line 2267
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2267
    if (prots[numprots].name) {
#line 2267
      if (! (prots[numprots].prot <= max_protocol)) {
#line 2267
        goto while_break___0;
      }
    } else {
#line 2267
      goto while_break___0;
    }
    {
#line 2271
    tmp___1 = p;
#line 2271
    p ++;
#line 2271
    *tmp___1 = (char)2;
#line 2272
    StrCpy(p, prots[numprots].name);
#line 2273
    tmp___2 = strlen((char const   *)p);
#line 2273
    p += tmp___2 + 1UL;
#line 2267
    numprots ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 2277
  *((unsigned char *)outbuf___1 + 8) = (unsigned char)114;
#line 2278
  setup_pkt(outbuf___1);
#line 2280
  tmp___3 = smb_buf(outbuf___1);
#line 2280
  *((unsigned char *)tmp___3 + 0) = (unsigned char)2;
#line 2282
  send_smb(Client, outbuf___1);
#line 2283
  receive_smb(Client, inbuf___0, 15000);
#line 2285
  show_msg(inbuf___0);
  }
#line 2287
  if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 2287
    goto _L;
  } else
#line 2287
  if ((int )((unsigned int )*((unsigned char *)inbuf___0 + 37) | ((unsigned int )*((unsigned char *)inbuf___0 + 38) << 8)) >= numprots) {
    _L: /* CIL Label */ 
#line 2289
    if (DEBUGLEVEL >= 0) {
      {
#line 2289
      tmp___4 = smb_errstr(inbuf___0);
#line 2289
      Debug1((char *)"SMBnegprot failed. myname=%s destname=%s - %s \n", myname, desthost,
             tmp___4);
      }
    }
#line 2291
    return (0);
  }
#line 2294
  Protocol = prots[(unsigned int )*((unsigned char *)inbuf___0 + 37) | ((unsigned int )*((unsigned char *)inbuf___0 + 38) << 8)].prot;
#line 2301
  if (Protocol < 5) {
    {
#line 2302
    sec_mode = (int )((unsigned int )*((unsigned char *)inbuf___0 + 39) | ((unsigned int )*((unsigned char *)inbuf___0 + 40) << 8));
#line 2303
    max_xmit = (int )((unsigned int )*((unsigned char *)inbuf___0 + 41) | ((unsigned int )*((unsigned char *)inbuf___0 + 42) << 8));
#line 2304
    sesskey = (int )(((unsigned int )*((unsigned char *)inbuf___0 + 49) | ((unsigned int )*((unsigned char *)inbuf___0 + 50) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + 51) | ((unsigned int )*((unsigned char *)inbuf___0 + 52) << 8)) << 16));
#line 2305
    serverzone = (int )((int16 )((unsigned int )*((unsigned char *)inbuf___0 + 57) | ((unsigned int )*((unsigned char *)inbuf___0 + 58) << 8))) * 60;
#line 2307
    servertime = make_unix_date((void *)(inbuf___0 + 53));
    }
#line 2308
    if (Protocol >= 2) {
#line 2309
      readbraw_supported = (((unsigned int )*((unsigned char *)inbuf___0 + 47) | ((unsigned int )*((unsigned char *)inbuf___0 + 48) << 8)) & 1U) != 0U;
#line 2310
      writebraw_supported = (((unsigned int )*((unsigned char *)inbuf___0 + 47) | ((unsigned int )*((unsigned char *)inbuf___0 + 48) << 8)) & 2U) != 0U;
    }
    {
#line 2312
    crypt_len = smb_buflen(inbuf___0);
#line 2313
    tmp___5 = smb_buf(inbuf___0);
#line 2313
    memcpy((void */* __restrict  */)(cryptkey), (void const   */* __restrict  */)tmp___5,
           (size_t )8);
    }
#line 2314
    if (DEBUGLEVEL >= 3) {
      {
#line 2314
      Debug1((char *)"max mux %d\n", (unsigned int )*((unsigned char *)inbuf___0 + 43) | ((unsigned int )*((unsigned char *)inbuf___0 + 44) << 8));
      }
    }
#line 2315
    max_vcs = (int )((unsigned int )*((unsigned char *)inbuf___0 + 45) | ((unsigned int )*((unsigned char *)inbuf___0 + 46) << 8));
#line 2316
    if (DEBUGLEVEL >= 3) {
      {
#line 2316
      Debug1((char *)"max vcs %d\n", max_vcs);
      }
    }
#line 2317
    if (DEBUGLEVEL >= 3) {
      {
#line 2317
      Debug1((char *)"max blk %d\n", (unsigned int )*((unsigned char *)inbuf___0 + 47) | ((unsigned int )*((unsigned char *)inbuf___0 + 48) << 8));
      }
    }
  } else {
    {
#line 2320
    sec_mode = (int )*((unsigned char *)inbuf___0 + 39);
#line 2321
    max_xmit = (int )(((unsigned int )*((unsigned char *)inbuf___0 + 44) | ((unsigned int )*((unsigned char *)inbuf___0 + 45) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + 46) | ((unsigned int )*((unsigned char *)inbuf___0 + 47) << 8)) << 16));
#line 2322
    sesskey = (int )(((unsigned int )*((unsigned char *)inbuf___0 + 52) | ((unsigned int )*((unsigned char *)inbuf___0 + 53) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + 54) | ((unsigned int )*((unsigned char *)inbuf___0 + 55) << 8)) << 16));
#line 2323
    serverzone = (int )((int16 )((unsigned int )*((unsigned char *)inbuf___0 + 68) | ((unsigned int )*((unsigned char *)inbuf___0 + 69) << 8))) * 60;
#line 2325
    servertime = interpret_long_date((inbuf___0 + 59) + 1);
#line 2326
    crypt_len = (int )*((unsigned char *)inbuf___0 + 70);
#line 2327
    tmp___6 = smb_buf(inbuf___0);
#line 2327
    memcpy((void */* __restrict  */)(cryptkey), (void const   */* __restrict  */)tmp___6,
           (size_t )8);
    }
#line 2328
    if ((((unsigned int )*((unsigned char *)inbuf___0 + 56) | ((unsigned int )*((unsigned char *)inbuf___0 + 57) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + 58) | ((unsigned int )*((unsigned char *)inbuf___0 + 59) << 8)) << 16)) & 1U) {
#line 2329
      writebraw_supported = 1;
#line 2329
      readbraw_supported = writebraw_supported;
    }
#line 2330
    if (DEBUGLEVEL >= 3) {
      {
#line 2330
      Debug1((char *)"max mux %d\n", (unsigned int )*((unsigned char *)inbuf___0 + 40) | ((unsigned int )*((unsigned char *)inbuf___0 + 41) << 8));
      }
    }
#line 2331
    max_vcs = (int )((unsigned int )*((unsigned char *)inbuf___0 + 42) | ((unsigned int )*((unsigned char *)inbuf___0 + 43) << 8));
#line 2332
    if (DEBUGLEVEL >= 3) {
      {
#line 2332
      Debug1((char *)"max vcs %d\n", max_vcs);
      }
    }
#line 2333
    if (DEBUGLEVEL >= 3) {
      {
#line 2333
      Debug1((char *)"max raw %d\n", ((unsigned int )*((unsigned char *)inbuf___0 + 48) | ((unsigned int )*((unsigned char *)inbuf___0 + 49) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + 50) | ((unsigned int )*((unsigned char *)inbuf___0 + 51) << 8)) << 16));
      }
    }
#line 2334
    if (DEBUGLEVEL >= 3) {
      {
#line 2334
      Debug1((char *)"capabilities 0x%x\n", ((unsigned int )*((unsigned char *)inbuf___0 + 56) | ((unsigned int )*((unsigned char *)inbuf___0 + 57) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + 58) | ((unsigned int )*((unsigned char *)inbuf___0 + 59) << 8)) << 16));
      }
    }
  }
#line 2337
  if (DEBUGLEVEL >= 3) {
    {
#line 2337
    Debug1((char *)"Sec mode %d\n", (unsigned int )*((unsigned char *)inbuf___0 + 39) | ((unsigned int )*((unsigned char *)inbuf___0 + 40) << 8));
    }
  }
#line 2339
  if (DEBUGLEVEL >= 3) {
    {
#line 2339
    Debug1((char *)"Real Sec mode %d\n", sec_mode);
    }
  }
#line 2341
  if (DEBUGLEVEL >= 3) {
    {
#line 2341
    Debug1((char *)"max xmt %d\n", max_xmit);
    }
  }
#line 2342
  if (DEBUGLEVEL >= 3) {
    {
#line 2342
    Debug1((char *)"Got %d byte crypt key\n", crypt_len);
    }
  }
#line 2346
  i___0 = 0;
  {
#line 2346
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2346
    if (! (i___0 < crypt_len)) {
#line 2346
      goto while_break___1;
    }
#line 2347
    if (DEBUGLEVEL >= 5) {
      {
#line 2347
      Debug1((char *)"%02X ", (int )((unsigned char )cryptkey[i___0]));
      }
    }
#line 2348
    if (DEBUGLEVEL >= 5) {
      {
#line 2348
      Debug1((char *)"\n");
      }
    }
    {
#line 2348
    fflush(stdout);
#line 2346
    i___0 ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2352
  if (DEBUGLEVEL >= 3) {
    {
#line 2352
    Debug1((char *)"Chose protocol [%s]\n", prots[(unsigned int )*((unsigned char *)inbuf___0 + 37) | ((unsigned int )*((unsigned char *)inbuf___0 + 38) << 8)].name);
    }
  }
#line 2355
  if (! said_protocol) {
    {
#line 2356
    natprintf("[*]--- Attempting to connect with protocol: %s\n", prots[(unsigned int )*((unsigned char *)inbuf___0 + 37) | ((unsigned int )*((unsigned char *)inbuf___0 + 38) << 8)].name);
    }
  }
#line 2360
  if (xflag) {
#line 2361
    doencrypt = (sec_mode & 2) != 0;
  }
#line 2363
  if (servertime) {
#line 2365
    if (! done_time) {
#line 2368
      if (! said_protocol) {
        {
#line 2369
        tmp___7 = LocalTime(& servertime, -1);
#line 2369
        tmp___8 = asctime((struct tm  const  *)tmp___7);
#line 2369
        natprintf("[*]--- Server time is %s[*]--- Timezone is UTC%+02.1f\n", tmp___8,
                  - ((double )serverzone / 3600.0));
#line 2372
        said_protocol ++;
        }
      }
#line 2376
      if (DEBUGLEVEL >= 1) {
        {
#line 2376
        tmp___9 = LocalTime(& servertime, -1);
#line 2376
        tmp___10 = asctime((struct tm  const  *)tmp___9);
#line 2376
        Debug1((char *)"Server time is %sTimezone is UTC%+02.1f\n", tmp___10, - ((double )serverzone / 3600.0));
        }
      }
#line 2379
      done_time = 1;
    }
  }
#line 2382
  return (1);
}
}
#line 2392 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL send_setup(char *inbuf___0 , char *outbuf___1 ) 
{ 
  char *pass ;
  register char *p ;
  register int x ;
  fstring pword ;
  int passlen ;
  size_t tmp ;
  size_t tmp___0 ;
  __pid_t tmp___1 ;
  __pid_t tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *domain ;
  char *os ;
  char *lanman ;

  {
  {
#line 2394
  pass = password;
#line 2398
  bzero((void *)outbuf___1, (size_t )39);
  }
#line 2399
  if (Protocol >= 3) {
    {
#line 2402
    tmp = strlen((char const   *)pass);
#line 2402
    passlen = (int )(tmp + 1UL);
#line 2403
    StrCpy(pword, pass);
#line 2413
    doencrypt = 0;
    }
#line 2417
    if (! (sec_mode & 1)) {
      {
#line 2417
      StrCpy(pword, (char *)"");
#line 2417
      passlen = 1;
      }
    }
    {
#line 2420
    bzero((void *)outbuf___1, (size_t )39);
    }
#line 2422
    if (Protocol < 5) {
      {
#line 2423
      tmp___0 = strlen((char const   *)(username));
#line 2423
      set_message(outbuf___1, 10, (int )((1UL + tmp___0) + (size_t )passlen), 1);
#line 2424
      *((unsigned char *)outbuf___1 + 8) = (unsigned char)115;
#line 2425
      setup_pkt(outbuf___1);
#line 2427
      *((unsigned char *)outbuf___1 + 37) = (unsigned char)255;
#line 2428
      *((unsigned char *)outbuf___1 + 41) = (unsigned char )((int )((uint16 )max_xmit) & 255);
#line 2428
      *((unsigned char *)outbuf___1 + 42) = (unsigned char )((int )((uint16 )max_xmit) >> 8);
#line 2429
      *((unsigned char *)outbuf___1 + 43) = (unsigned char)2;
#line 2429
      *((unsigned char *)outbuf___1 + 44) = (unsigned char )(2 >> 8);
#line 2430
      *((unsigned char *)outbuf___1 + 45) = (unsigned char )((int )((uint16 )(max_vcs - 1)) & 255);
#line 2430
      *((unsigned char *)outbuf___1 + 46) = (unsigned char )((int )((uint16 )(max_vcs - 1)) >> 8);
#line 2431
      *((unsigned char *)outbuf___1 + 47) = (unsigned char )(((uint32 )sesskey & 65535U) & 255U);
#line 2431
      *((unsigned char *)outbuf___1 + 48) = (unsigned char )(((uint32 )sesskey & 65535U) >> 8);
#line 2431
      *((unsigned char *)outbuf___1 + 49) = (unsigned char )(((uint32 )sesskey >> 16) & 255U);
#line 2431
      *((unsigned char *)outbuf___1 + 50) = (unsigned char )(((uint32 )sesskey >> 16) >> 8);
#line 2432
      *((unsigned char *)outbuf___1 + 51) = (unsigned char )((int )((uint16 )passlen) & 255);
#line 2432
      *((unsigned char *)outbuf___1 + 52) = (unsigned char )((int )((uint16 )passlen) >> 8);
#line 2433
      p = smb_buf(outbuf___1);
#line 2434
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(pword),
             (size_t )passlen);
#line 2435
      p += passlen;
#line 2436
      StrCpy(p, username);
      }
    } else {
      {
#line 2441
      set_message(outbuf___1, 13, 0, 1);
#line 2442
      *((unsigned char *)outbuf___1 + 8) = (unsigned char)115;
#line 2443
      setup_pkt(outbuf___1);
#line 2445
      *((unsigned char *)outbuf___1 + 37) = (unsigned char)255;
#line 2446
      *((unsigned char *)outbuf___1 + 41) = (unsigned char)255;
#line 2446
      *((unsigned char *)outbuf___1 + 42) = (unsigned char )(65535 >> 8);
#line 2447
      *((unsigned char *)outbuf___1 + 43) = (unsigned char)2;
#line 2447
      *((unsigned char *)outbuf___1 + 44) = (unsigned char )(2 >> 8);
#line 2449
      tmp___1 = getpid();
#line 2449
      *((unsigned char *)outbuf___1 + 45) = (unsigned char )((int )((uint16 )tmp___1) & 255);
#line 2449
      tmp___2 = getpid();
#line 2449
      *((unsigned char *)outbuf___1 + 46) = (unsigned char )((int )((uint16 )tmp___2) >> 8);
#line 2450
      *((unsigned char *)outbuf___1 + 47) = (unsigned char )(((uint32 )sesskey & 65535U) & 255U);
#line 2450
      *((unsigned char *)outbuf___1 + 48) = (unsigned char )(((uint32 )sesskey & 65535U) >> 8);
#line 2450
      *((unsigned char *)outbuf___1 + 49) = (unsigned char )(((uint32 )sesskey >> 16) & 255U);
#line 2450
      *((unsigned char *)outbuf___1 + 50) = (unsigned char )(((uint32 )sesskey >> 16) >> 8);
#line 2451
      *((unsigned char *)outbuf___1 + 51) = (unsigned char )((int )((uint16 )passlen) & 255);
#line 2451
      *((unsigned char *)outbuf___1 + 52) = (unsigned char )((int )((uint16 )passlen) >> 8);
#line 2452
      *((unsigned char *)outbuf___1 + 53) = (unsigned char)0;
#line 2452
      *((unsigned char *)outbuf___1 + 54) = (unsigned char)0;
#line 2453
      p = smb_buf(outbuf___1);
#line 2454
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(pword),
             (size_t )passlen);
#line 2454
      p += (unsigned int )*((unsigned char *)outbuf___1 + 51) | ((unsigned int )*((unsigned char *)outbuf___1 + 52) << 8);
      }
#line 2476
      if (! doencrypt) {
#line 2476
        passlen = 0;
      }
      {
#line 2477
      *((unsigned char *)outbuf___1 + 53) = (unsigned char )((int )((uint16 )passlen) & 255);
#line 2477
      *((unsigned char *)outbuf___1 + 54) = (unsigned char )((int )((uint16 )passlen) >> 8);
#line 2485
      memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(pword),
             (size_t )passlen);
#line 2485
      p += (unsigned int )*((unsigned char *)outbuf___1 + 53) | ((unsigned int )*((unsigned char *)outbuf___1 + 54) << 8);
#line 2498
      StrCpy(p, username);
#line 2498
      p = skip_string(p, 1);
#line 2499
      StrCpy(p, workgroup);
#line 2499
      p = skip_string(p, 1);
#line 2503
      StrCpy(p, (char *)"Unix");
#line 2503
      p = skip_string(p, 1);
#line 2504
      StrCpy(p, (char *)"Samba");
#line 2504
      p = skip_string(p, 1);
#line 2505
      tmp___3 = smb_buf(outbuf___1);
#line 2505
      set_message(outbuf___1, 13, (int )(p - tmp___3), 0);
      }
    }
    {
#line 2508
    send_smb(Client, outbuf___1);
#line 2509
    x = receive_smb(Client, inbuf___0, 15000);
    }
#line 2515
    if (x == 0) {
#line 2516
      if (DEBUGLEVEL >= 0) {
        {
#line 2516
        Debug1((char *)"setupX reply failed\n");
        }
      }
#line 2517
      return (0);
    }
    {
#line 2520
    show_msg(inbuf___0);
    }
#line 2554
    if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 2556
      if (DEBUGLEVEL >= 2) {
        {
#line 2556
        tmp___4 = smb_errstr(inbuf___0);
#line 2556
        Debug1((char *)"%s/%s: session: %s\n", username, pass, tmp___4);
        }
      }
      {
#line 2557
      cur_serr = interpret_serr(*((unsigned char *)inbuf___0 + 9), (uint16 )((unsigned int )*((unsigned char *)inbuf___0 + 11) | ((unsigned int )*((unsigned char *)inbuf___0 + 12) << 8)));
      }
#line 2559
      return (0);
    }
#line 2562
    if (((unsigned int )*((unsigned char *)inbuf___0 + 41) | ((unsigned int )*((unsigned char *)inbuf___0 + 42) << 8)) & 1U) {
#line 2563
      if (DEBUGLEVEL >= 0) {
        {
#line 2563
        Debug1((char *)"GUEST-mode ");
        }
      }
    }
#line 2564
    if (DEBUGLEVEL >= 0) {
      {
#line 2564
      Debug1((char *)"session established as %s/%s\n", username, pass);
      }
    }
    {
#line 2579
    p = smb_buf(inbuf___0);
#line 2580
    os = p;
#line 2581
    lanman = skip_string(os, 1);
#line 2582
    domain = skip_string(lanman, 1);
    }
#line 2583
    if (*domain) {
#line 2583
      goto _L;
    } else
#line 2583
    if (*os) {
#line 2583
      goto _L;
    } else
#line 2583
    if (*lanman) {
      _L: /* CIL Label */ 
#line 2584
      if (DEBUGLEVEL >= 1) {
        {
#line 2584
        Debug1((char *)"Domain=[%s] OS=[%s] Server=[%s]\n", domain, os, lanman);
        }
      }
      {
#line 2587
      cur_vuln = 182;
#line 2588
      fill_vuln("Domain: ", domain);
#line 2589
      fill_vuln("OS: ", os);
      }
    }
#line 2596
    if (((unsigned int )*((unsigned char *)inbuf___0 + 32) | ((unsigned int )*((unsigned char *)inbuf___0 + 33) << 8)) != (unsigned int )uid) {
#line 2597
      if (DEBUGLEVEL >= 3) {
        {
#line 2597
        Debug1((char *)"Server gave us a UID of %d. We gave %d\n", (unsigned int )*((unsigned char *)inbuf___0 + 32) | ((unsigned int )*((unsigned char *)inbuf___0 + 33) << 8),
               uid);
        }
      }
    }
#line 2599
    uid = (int )((unsigned int )*((unsigned char *)inbuf___0 + 32) | ((unsigned int )*((unsigned char *)inbuf___0 + 33) << 8));
  }
#line 2601
  return (1);
}
}
#line 2604 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL send_tcon(char *inbuf___0 , char *outbuf___1 ) 
{ 
  char *pass ;
  pstring dev ;
  register char *p ;
  register int x ;
  int passlen ;
  size_t tmp ;
  fstring pword ;
  int tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 2606
  pass = password;
#line 2610
  tmp = strlen((char const   *)pass);
#line 2610
  passlen = (int )(tmp + 1UL);
#line 2617
  StrCpy(dev, (char *)"A:");
  }
#line 2618
  if (connect_as_printer) {
    {
#line 2619
    StrCpy(dev, (char *)"LPT1:");
    }
  }
#line 2620
  if (connect_as_ipc) {
    {
#line 2621
    StrCpy(dev, (char *)"IPC");
    }
  }
  {
#line 2628
  bzero((void *)outbuf___1, (size_t )39);
#line 2630
  tmp___0 = strncmp((char const   *)(service), "\\\\", (size_t )2);
  }
#line 2630
  if (tmp___0 != 0) {
#line 2632
    if (DEBUGLEVEL >= 0) {
      {
#line 2632
      Debug1((char *)"\nWarning: Your service name doesn\'t start with \\\\. This is probably incorrect.\n");
      }
    }
#line 2633
    if (DEBUGLEVEL >= 0) {
      {
#line 2633
      Debug1((char *)"Perhaps try replacing each \\ with \\\\ on the command line?\n\n");
      }
    }
  }
  {
#line 2638
  StrCpy(pword, pass);
  }
#line 2641
  if (sec_mode & 1) {
    {
#line 2642
    StrCpy(pword, (char *)"");
#line 2642
    passlen = 1;
    }
  }
  {
#line 2655
  tmp___1 = strlen((char const   *)(service));
#line 2655
  tmp___2 = strlen((char const   *)(dev));
#line 2655
  set_message(outbuf___1, 4, (int )(((2UL + tmp___1) + (size_t )passlen) + tmp___2),
              1);
#line 2656
  *((unsigned char *)outbuf___1 + 8) = (unsigned char)117;
#line 2657
  setup_pkt(outbuf___1);
#line 2659
  *((unsigned char *)outbuf___1 + 37) = (unsigned char)255;
#line 2659
  *((unsigned char *)outbuf___1 + 38) = (unsigned char )(255 >> 8);
#line 2660
  *((unsigned char *)outbuf___1 + 43) = (unsigned char )((int )((uint16 )passlen) & 255);
#line 2660
  *((unsigned char *)outbuf___1 + 44) = (unsigned char )((int )((uint16 )passlen) >> 8);
#line 2662
  p = smb_buf(outbuf___1);
#line 2663
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(pword), (size_t )passlen);
#line 2664
  p += passlen;
#line 2665
  StrCpy(p, service);
#line 2666
  p = skip_string(p, 1);
#line 2667
  StrCpy(p, dev);
#line 2670
  send_smb(Client, outbuf___1);
#line 2671
  x = receive_smb(Client, inbuf___0, 15000);
  }
#line 2673
  if (x == 0) {
#line 2674
    if (DEBUGLEVEL >= 0) {
      {
#line 2674
      Debug1((char *)"tcon reply failed\n");
      }
    }
#line 2675
    return (0);
  }
#line 2700
  if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 2709
    if (DEBUGLEVEL >= 2) {
      {
#line 2709
      tmp___3 = smb_errstr(inbuf___0);
#line 2709
      Debug1((char *)"%s/%s: %s: %s\n", username, pass, service, tmp___3);
      }
    }
    {
#line 2710
    cur_serr = interpret_serr(*((unsigned char *)inbuf___0 + 9), (uint16 )((unsigned int )*((unsigned char *)inbuf___0 + 11) | ((unsigned int )*((unsigned char *)inbuf___0 + 12) << 8)));
    }
#line 2713
    if (cur_serr == 2) {
#line 2713
      if (sec_mode & 1) {
#line 2714
        if (DEBUGLEVEL >= 1) {
          {
#line 2714
          Debug1((char *)"Wanted TCon passwd in USER-mode sec?!??!\n");
          }
        }
      }
    }
#line 2715
    return (0);
  }
#line 2719
  if (DEBUGLEVEL >= 0) {
    {
#line 2719
    Debug1((char *)"tcon %s connected as %s/%s\n", service, username, pass);
    }
  }
#line 2727
  if (max_xmit < 65531) {
#line 2727
    max_xmit = max_xmit;
  } else {
#line 2727
    max_xmit = 65531;
  }
#line 2728
  if (max_xmit <= 0) {
#line 2729
    max_xmit = 65531;
  }
#line 2731
  cnum = (int )((unsigned int )*((unsigned char *)inbuf___0 + 28) | ((unsigned int )*((unsigned char *)inbuf___0 + 29) << 8));
#line 2734
  if (cnum == 0) {
#line 2735
    if (DEBUGLEVEL >= 0) {
      {
#line 2735
      Debug1((char *)"OOPS! opened tcon, but Tree-ID is zero?!?!\n");
      }
    }
#line 2736
    return (0);
  }
#line 2738
  if (DEBUGLEVEL >= 3) {
    {
#line 2738
    Debug1((char *)"Connected with cnum=%d max_xmit=%d\n", cnum, max_xmit);
    }
  }
#line 2740
  return (1);
}
}
#line 2746 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL send_login(char *inbuf___0 , char *outbuf___1 , BOOL start_session , BOOL use_setup ) 
{ 
  register BOOL x ;
  BOOL was_null ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  BOOL tmp___6 ;
  BOOL tmp___7 ;

  {
#line 2751
  if (! inbuf___0) {
#line 2751
    if (! outbuf___1) {
#line 2751
      tmp = 1;
    } else {
#line 2751
      tmp = 0;
    }
  } else {
#line 2751
    tmp = 0;
  }
#line 2751
  was_null = tmp;
#line 2752
  if (was_null) {
    {
#line 2754
    tmp___0 = malloc((size_t )66559);
#line 2754
    inbuf___0 = (char *)tmp___0;
#line 2755
    tmp___1 = malloc((size_t )66559);
#line 2755
    outbuf___1 = (char *)tmp___1;
    }
  }
#line 2757
  x = 0;
#line 2758
  if (read_pass) {
#line 2759
    if (DEBUGLEVEL >= 0) {
      {
#line 2759
      Debug1((char *)"Reading passwords from stdin...\n");
      }
    }
  }
#line 2765
  if (start_session) {
    {
#line 2765
    tmp___2 = send_session_request(inbuf___0, outbuf___1);
    }
#line 2765
    if (! tmp___2) {
#line 2766
      goto lame_bailout;
    }
  }
  {
#line 2767
  tmp___3 = send_prots(inbuf___0, outbuf___1);
  }
#line 2767
  if (! tmp___3) {
#line 2768
    goto lame_bailout;
  }
  sl_setx: 
#line 2770
  cur_serr = 0;
#line 2771
  if (use_setup) {
    {
#line 2771
    tmp___5 = send_setup(inbuf___0, outbuf___1);
    }
#line 2771
    if (! tmp___5) {
#line 2772
      if (cur_serr == 2) {
        {
#line 2772
        tmp___4 = uppair();
        }
#line 2772
        if (tmp___4) {
#line 2773
          goto sl_setx;
        }
      }
#line 2774
      goto lame_bailout;
    }
  }
  sl_tcon: 
  {
#line 2777
  cur_serr = 0;
#line 2778
  tmp___7 = send_tcon(inbuf___0, outbuf___1);
  }
#line 2778
  if (! tmp___7) {
#line 2779
    if (cur_serr == 2) {
      {
#line 2779
      tmp___6 = uppair();
      }
#line 2779
      if (tmp___6) {
#line 2780
        goto sl_tcon;
      }
    }
#line 2781
    goto lame_bailout;
  }
#line 2783
  x = 1;
  lame_bailout: 
#line 2786
  if (was_null) {
    {
#line 2788
    free((void *)inbuf___0);
#line 2789
    free((void *)outbuf___1);
    }
  }
#line 2791
  if (read_pass) {
    {
#line 2792
    exit(0);
    }
  }
#line 2793
  return (x);
}
}
#line 2799 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static void send_tdis(char *inbuf___0 , char *outbuf___1 ) 
{ 
  char *tmp ;

  {
  {
#line 2801
  bzero((void *)outbuf___1, (size_t )39);
#line 2802
  set_message(outbuf___1, 0, 0, 1);
#line 2803
  *((unsigned char *)outbuf___1 + 8) = (unsigned char)113;
#line 2804
  *((unsigned char *)outbuf___1 + 28) = (unsigned char )((int )((uint16 )cnum) & 255);
#line 2804
  *((unsigned char *)outbuf___1 + 29) = (unsigned char )((int )((uint16 )cnum) >> 8);
#line 2805
  setup_pkt(outbuf___1);
  }
#line 2807
  if (cnum == 0) {
#line 2807
    return;
  }
  {
#line 2809
  send_smb(Client, outbuf___1);
#line 2810
  receive_smb(Client, inbuf___0, 5000);
  }
#line 2812
  if ((int )*((unsigned char *)inbuf___0 + 9) != 0) {
#line 2814
    if (DEBUGLEVEL >= 3) {
      {
#line 2814
      tmp = smb_errstr(inbuf___0);
#line 2814
      Debug1((char *)"SMBtdis failed %s\n", tmp);
      }
    }
  }
#line 2816
  cnum = 0;
#line 2817
  return;
}
}
#line 2854 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static char *inbuf  =    (char *)((void *)0);
#line 2855 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static char *outbuf  =    (char *)((void *)0);
#line 2848 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL call_api(int prcnt , int drcnt , int mprcnt , int mdrcnt , int *rprcnt ,
                     int *rdrcnt , char *param , char *data , char **rparam , char **rdata ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  BOOL tmp___1 ;

  {
#line 2857
  if (! inbuf) {
    {
#line 2857
    tmp = malloc((size_t )66559);
#line 2857
    inbuf = (char *)tmp;
    }
  }
#line 2858
  if (! outbuf) {
    {
#line 2858
    tmp___0 = malloc((size_t )66559);
#line 2858
    outbuf = (char *)tmp___0;
    }
  }
  {
#line 2860
  send_trans_request(outbuf, 37, (char *)"\\PIPE\\LANMAN", 0, 0, data, param, (uint16 *)((void *)0),
                     drcnt, prcnt, 0, mdrcnt, mprcnt, 0);
#line 2864
  tmp___1 = receive_trans_response(inbuf, 37, rdrcnt, rprcnt, rdata, rparam);
  }
#line 2864
  return (tmp___1);
}
}
#line 2870 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL send_trans_request(char *outbuf___1 , int trans , char *name___1 , int fid ,
                               int flags , char *data , char *param , uint16 *setup ,
                               int ldata , int lparam , int lsetup , int mdata , int mparam ,
                               int msetup ) 
{ 
  int i___0 ;
  int this_ldata ;
  int this_lparam ;
  int tot_data ;
  int tot_param ;
  char *outdata ;
  char *outparam ;
  pstring inbuf___0 ;
  char *p ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char const   *tmp___11 ;
  BOOL tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;

  {
#line 2878
  tot_data = 0;
#line 2878
  tot_param = 0;
#line 2883
  if (lparam < max_xmit - (500 + lsetup * 2)) {
#line 2883
    this_lparam = lparam;
  } else {
#line 2883
    this_lparam = max_xmit - (500 + lsetup * 2);
  }
#line 2884
  if (ldata < max_xmit - ((500 + lsetup * 2) + this_lparam)) {
#line 2884
    this_ldata = ldata;
  } else {
#line 2884
    this_ldata = max_xmit - ((500 + lsetup * 2) + this_lparam);
  }
  {
#line 2886
  bzero((void *)outbuf___1, (size_t )39);
#line 2887
  set_message(outbuf___1, 14 + lsetup, 0, 1);
#line 2888
  *((unsigned char *)outbuf___1 + 8) = (unsigned char )trans;
#line 2889
  *((unsigned char *)outbuf___1 + 28) = (unsigned char )((int )((uint16 )cnum) & 255);
#line 2889
  *((unsigned char *)outbuf___1 + 29) = (unsigned char )((int )((uint16 )cnum) >> 8);
#line 2890
  setup_pkt(outbuf___1);
#line 2892
  tmp = smb_buf(outbuf___1);
  }
#line 2892
  if (trans == 37) {
    {
#line 2892
    tmp___0 = strlen((char const   *)name___1);
#line 2892
    tmp___1 = tmp___0 + 1UL;
    }
  } else {
#line 2892
    tmp___1 = (size_t )3;
  }
  {
#line 2892
  outparam = tmp + tmp___1;
#line 2893
  outdata = outparam + this_lparam;
#line 2896
  *((unsigned char *)outbuf___1 + 37) = (unsigned char )((int )((uint16 )lparam) & 255);
#line 2896
  *((unsigned char *)outbuf___1 + 38) = (unsigned char )((int )((uint16 )lparam) >> 8);
#line 2897
  *((unsigned char *)outbuf___1 + 39) = (unsigned char )((int )((uint16 )ldata) & 255);
#line 2897
  *((unsigned char *)outbuf___1 + 40) = (unsigned char )((int )((uint16 )ldata) >> 8);
#line 2898
  *((unsigned char *)outbuf___1 + 41) = (unsigned char )((int )((uint16 )mparam) & 255);
#line 2898
  *((unsigned char *)outbuf___1 + 42) = (unsigned char )((int )((uint16 )mparam) >> 8);
#line 2899
  *((unsigned char *)outbuf___1 + 43) = (unsigned char )((int )((uint16 )mdata) & 255);
#line 2899
  *((unsigned char *)outbuf___1 + 44) = (unsigned char )((int )((uint16 )mdata) >> 8);
#line 2900
  *((unsigned char *)outbuf___1 + 45) = (unsigned char )msetup;
#line 2901
  *((unsigned char *)outbuf___1 + 47) = (unsigned char )((int )((uint16 )flags) & 255);
#line 2901
  *((unsigned char *)outbuf___1 + 48) = (unsigned char )((int )((uint16 )flags) >> 8);
#line 2902
  *((unsigned char *)outbuf___1 + 49) = (unsigned char)0;
#line 2902
  *((unsigned char *)outbuf___1 + 50) = (unsigned char)0;
#line 2902
  *((unsigned char *)outbuf___1 + 51) = (unsigned char)0;
#line 2902
  *((unsigned char *)outbuf___1 + 52) = (unsigned char)0;
#line 2903
  *((unsigned char *)outbuf___1 + 55) = (unsigned char )((int )((uint16 )this_lparam) & 255);
#line 2903
  *((unsigned char *)outbuf___1 + 56) = (unsigned char )((int )((uint16 )this_lparam) >> 8);
#line 2904
  tmp___2 = smb_offset(outparam, outbuf___1);
#line 2904
  *((unsigned char *)outbuf___1 + 57) = (unsigned char )((int )((uint16 )tmp___2) & 255);
#line 2904
  tmp___3 = smb_offset(outparam, outbuf___1);
#line 2904
  *((unsigned char *)outbuf___1 + 58) = (unsigned char )((int )((uint16 )tmp___3) >> 8);
#line 2905
  *((unsigned char *)outbuf___1 + 59) = (unsigned char )((int )((uint16 )this_ldata) & 255);
#line 2905
  *((unsigned char *)outbuf___1 + 60) = (unsigned char )((int )((uint16 )this_ldata) >> 8);
#line 2906
  tmp___4 = smb_offset(outdata, outbuf___1);
#line 2906
  *((unsigned char *)outbuf___1 + 61) = (unsigned char )((int )((uint16 )tmp___4) & 255);
#line 2906
  tmp___5 = smb_offset(outdata, outbuf___1);
#line 2906
  *((unsigned char *)outbuf___1 + 62) = (unsigned char )((int )((uint16 )tmp___5) >> 8);
#line 2907
  *((unsigned char *)outbuf___1 + 63) = (unsigned char )lsetup;
#line 2908
  i___0 = 0;
  }
  {
#line 2908
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2908
    if (! (i___0 < lsetup)) {
#line 2908
      goto while_break;
    }
#line 2909
    *((unsigned char *)outbuf___1 + (65 + i___0 * 2)) = (unsigned char )((int )*(setup + i___0) & 255);
#line 2909
    *((unsigned char *)outbuf___1 + ((65 + i___0 * 2) + 1)) = (unsigned char )((int )*(setup + i___0) >> 8);
#line 2908
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2910
  p = smb_buf(outbuf___1);
  }
#line 2911
  if (trans == 37) {
    {
#line 2912
    StrCpy(p, name___1);
    }
  } else {
#line 2915
    tmp___6 = p;
#line 2915
    p ++;
#line 2915
    *tmp___6 = (char)0;
#line 2916
    tmp___7 = p;
#line 2916
    p ++;
#line 2916
    *tmp___7 = (char )'D';
#line 2916
    tmp___8 = p;
#line 2916
    p ++;
#line 2916
    *tmp___8 = (char )' ';
  }
#line 2918
  if (this_lparam) {
    {
#line 2919
    memcpy((void */* __restrict  */)outparam, (void const   */* __restrict  */)param,
           (size_t )this_lparam);
    }
  }
#line 2920
  if (this_ldata) {
    {
#line 2921
    memcpy((void */* __restrict  */)outdata, (void const   */* __restrict  */)data,
           (size_t )this_ldata);
    }
  }
  {
#line 2922
  tmp___9 = smb_buf(outbuf___1);
#line 2922
  set_message(outbuf___1, 14 + lsetup, (int )((outdata + this_ldata) - tmp___9), 0);
#line 2925
  show_msg(outbuf___1);
#line 2926
  send_smb(Client, outbuf___1);
  }
#line 2928
  if (this_ldata < ldata) {
#line 2928
    goto _L___0;
  } else
#line 2928
  if (this_lparam < lparam) {
    _L___0: /* CIL Label */ 
    {
#line 2931
    tmp___12 = receive_smb(Client, inbuf___0, 5000);
    }
#line 2931
    if (tmp___12) {
#line 2931
      if ((int )*((unsigned char *)(inbuf___0) + 9) != 0) {
        _L: /* CIL Label */ 
#line 2933
        if (DEBUGLEVEL >= 0) {
          {
#line 2933
          tmp___10 = smb_errstr(inbuf___0);
          }
#line 2933
          if (trans == 37) {
#line 2933
            tmp___11 = "SMBtrans";
          } else {
#line 2933
            tmp___11 = "SMBtrans2";
          }
          {
#line 2933
          Debug1((char *)"%s request failed (%s)\n", tmp___11, tmp___10);
          }
        }
#line 2935
        return (0);
      }
    } else {
#line 2931
      goto _L;
    }
#line 2938
    tot_data = this_ldata;
#line 2939
    tot_param = this_lparam;
    {
#line 2941
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2941
      if (! (tot_data < ldata)) {
#line 2941
        if (! (tot_param < lparam)) {
#line 2941
          goto while_break___0;
        }
      }
#line 2942
      if (lparam - tot_param < max_xmit - 500) {
#line 2942
        this_lparam = lparam - tot_param;
      } else {
#line 2942
        this_lparam = max_xmit - 500;
      }
#line 2943
      if (ldata - tot_data < max_xmit - (500 + this_lparam)) {
#line 2943
        this_ldata = ldata - tot_data;
      } else {
#line 2943
        this_ldata = max_xmit - (500 + this_lparam);
      }
#line 2945
      if (trans == 37) {
#line 2945
        tmp___13 = 8;
      } else {
#line 2945
        tmp___13 = 9;
      }
      {
#line 2945
      set_message(outbuf___1, tmp___13, 0, 1);
      }
#line 2946
      if (trans == 37) {
#line 2946
        *((unsigned char *)outbuf___1 + 8) = (unsigned char)38;
      } else {
#line 2946
        *((unsigned char *)outbuf___1 + 8) = (unsigned char)51;
      }
      {
#line 2948
      outparam = smb_buf(outbuf___1);
#line 2949
      outdata = outparam + this_lparam;
#line 2952
      *((unsigned char *)outbuf___1 + 37) = (unsigned char )((int )((uint16 )lparam) & 255);
#line 2952
      *((unsigned char *)outbuf___1 + 38) = (unsigned char )((int )((uint16 )lparam) >> 8);
#line 2953
      *((unsigned char *)outbuf___1 + 39) = (unsigned char )((int )((uint16 )ldata) & 255);
#line 2953
      *((unsigned char *)outbuf___1 + 40) = (unsigned char )((int )((uint16 )ldata) >> 8);
#line 2954
      *((unsigned char *)outbuf___1 + 41) = (unsigned char )((int )((uint16 )this_lparam) & 255);
#line 2954
      *((unsigned char *)outbuf___1 + 42) = (unsigned char )((int )((uint16 )this_lparam) >> 8);
#line 2955
      tmp___14 = smb_offset(outparam, outbuf___1);
#line 2955
      *((unsigned char *)outbuf___1 + 43) = (unsigned char )((int )((uint16 )tmp___14) & 255);
#line 2955
      tmp___15 = smb_offset(outparam, outbuf___1);
#line 2955
      *((unsigned char *)outbuf___1 + 44) = (unsigned char )((int )((uint16 )tmp___15) >> 8);
#line 2956
      *((unsigned char *)outbuf___1 + 45) = (unsigned char )((int )((uint16 )tot_param) & 255);
#line 2956
      *((unsigned char *)outbuf___1 + 46) = (unsigned char )((int )((uint16 )tot_param) >> 8);
#line 2957
      *((unsigned char *)outbuf___1 + 47) = (unsigned char )((int )((uint16 )this_ldata) & 255);
#line 2957
      *((unsigned char *)outbuf___1 + 48) = (unsigned char )((int )((uint16 )this_ldata) >> 8);
#line 2958
      tmp___16 = smb_offset(outdata, outbuf___1);
#line 2958
      *((unsigned char *)outbuf___1 + 49) = (unsigned char )((int )((uint16 )tmp___16) & 255);
#line 2958
      tmp___17 = smb_offset(outdata, outbuf___1);
#line 2958
      *((unsigned char *)outbuf___1 + 50) = (unsigned char )((int )((uint16 )tmp___17) >> 8);
#line 2959
      *((unsigned char *)outbuf___1 + 51) = (unsigned char )((int )((uint16 )tot_data) & 255);
#line 2959
      *((unsigned char *)outbuf___1 + 52) = (unsigned char )((int )((uint16 )tot_data) >> 8);
      }
#line 2960
      if (trans == 50) {
#line 2961
        *((unsigned char *)outbuf___1 + 53) = (unsigned char )((int )((uint16 )fid) & 255);
#line 2961
        *((unsigned char *)outbuf___1 + 54) = (unsigned char )((int )((uint16 )fid) >> 8);
      }
#line 2962
      if (this_lparam) {
        {
#line 2963
        memcpy((void */* __restrict  */)outparam, (void const   */* __restrict  */)param,
               (size_t )this_lparam);
        }
      }
#line 2964
      if (this_ldata) {
        {
#line 2965
        memcpy((void */* __restrict  */)outdata, (void const   */* __restrict  */)data,
               (size_t )this_ldata);
        }
      }
      {
#line 2966
      tmp___18 = smb_buf(outbuf___1);
      }
#line 2966
      if (trans == 37) {
#line 2966
        tmp___19 = 8;
      } else {
#line 2966
        tmp___19 = 9;
      }
      {
#line 2966
      set_message(outbuf___1, tmp___19, (int )((outdata + this_ldata) - tmp___18),
                  0);
#line 2969
      show_msg(outbuf___1);
#line 2970
      send_smb(Client, outbuf___1);
#line 2972
      tot_data += this_ldata;
#line 2973
      tot_param += this_lparam;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2976
  return (1);
}
}
#line 2982 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL browse_host(BOOL sort ) 
{ 
  char *rparam ;
  char *rdata ;
  char *p ;
  int rdrcnt ;
  int rprcnt ;
  pstring param ;
  int count___0 ;
  int res ;
  int converter ;
  int i___0 ;
  BOOL long_share_name ;
  char *sname ;
  int type ;
  int comment_offset ;
  fstring typestr ;
  char const   *tmp ;
  size_t tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 2989
  rparam = (char *)((void *)0);
#line 2990
  rdata = (char *)((void *)0);
#line 2994
  count___0 = -1;
#line 2999
  p = param;
#line 3000
  *((unsigned char *)p + 0) = (unsigned char)0;
#line 3000
  *((unsigned char *)p + 1) = (unsigned char)0;
#line 3001
  p += 2;
#line 3002
  StrCpy(p, (char *)"WrLeh");
#line 3003
  p = skip_string(p, 1);
#line 3004
  StrCpy(p, (char *)"B13BWz");
#line 3005
  p = skip_string(p, 1);
#line 3006
  *((unsigned char *)p + 0) = (unsigned char)1;
#line 3006
  *((unsigned char *)p + 1) = (unsigned char )(1 >> 8);
#line 3007
  *((unsigned char *)p + 2) = (unsigned char)255;
#line 3007
  *((unsigned char *)p + 3) = (unsigned char )(65535 >> 8);
#line 3008
  p += 4;
#line 3010
  tmp___1 = call_api((int )(p - param), 0, 1024, 65535, & rprcnt, & rdrcnt, param,
                     (char *)((void *)0), & rparam, & rdata);
  }
#line 3010
  if (tmp___1) {
#line 3012
    res = (int )((unsigned int )*((unsigned char *)rparam + 0) | ((unsigned int )*((unsigned char *)rparam + 1) << 8));
#line 3013
    converter = (int )((unsigned int )*((unsigned char *)rparam + 2) | ((unsigned int )*((unsigned char *)rparam + 3) << 8));
#line 3015
    long_share_name = 0;
#line 3017
    if (res == 0) {
      {
#line 3019
      cur_vuln = 16004;
#line 3020
      fill_vuln("Was able to retrieve listing", " of availible services:");
#line 3022
      count___0 = (int )((unsigned int )*((unsigned char *)rparam + 4) | ((unsigned int )*((unsigned char *)rparam + 5) << 8));
#line 3023
      p = rdata;
#line 3026
      natprintf("\n[*]--- Obtained listing of shares:\n");
      }
#line 3029
      if (count___0 > 0) {
        {
#line 3030
        natprintf("\n\tSharename      Type      Comment\n");
#line 3031
        natprintf("\t---------      ----      -------\n");
        }
      }
#line 3034
      if (sort) {
        {
#line 3035
        qsort((void *)p, (size_t )count___0, (size_t )20, (int (*)(void const   * ,
                                                                   void const   * ))((int (*)())(& strcasecmp)));
        }
      }
#line 3037
      i___0 = 0;
      {
#line 3037
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3037
        if (! (i___0 < count___0)) {
#line 3037
          goto while_break;
        }
#line 3038
        sname = p;
#line 3039
        type = (int )((unsigned int )*((unsigned char *)p + 14) | ((unsigned int )*((unsigned char *)p + 15) << 8));
#line 3040
        comment_offset = (int )((((unsigned int )*((unsigned char *)p + 16) | ((unsigned int )*((unsigned char *)p + 17) << 8)) | (((unsigned int )*((unsigned char *)p + 18) | ((unsigned int )*((unsigned char *)p + 19) << 8)) << 16)) & 65535U);
#line 3042
        typestr[0] = (char)0;
        {
#line 3045
        if (type == 0) {
#line 3045
          goto case_0;
        }
#line 3054
        if (type == 1) {
#line 3054
          goto case_1;
        }
#line 3056
        if (type == 2) {
#line 3056
          goto case_2;
        }
#line 3058
        if (type == 3) {
#line 3058
          goto case_3;
        }
#line 3044
        goto switch_break;
        case_0: /* CIL Label */ 
#line 3047
        if (stepping) {
          {
#line 3048
          fill_block(try_shares, sname);
#line 3049
          fill_block(try_users, sname);
#line 3050
          fill_block(try_pass, sname);
          }
        }
        {
#line 3053
        StrCpy(typestr, (char *)"Disk");
        }
#line 3053
        goto switch_break;
        case_1: /* CIL Label */ 
        {
#line 3055
        StrCpy(typestr, (char *)"Printer");
        }
#line 3055
        goto switch_break;
        case_2: /* CIL Label */ 
        {
#line 3057
        StrCpy(typestr, (char *)"Device");
        }
#line 3057
        goto switch_break;
        case_3: /* CIL Label */ 
        {
#line 3059
        StrCpy(typestr, (char *)"IPC");
        }
#line 3059
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
        {
#line 3063
        strcat((char */* __restrict  */)(typestr), (char const   */* __restrict  */)": ");
#line 3064
        fill_vuln(typestr, sname);
        }
#line 3066
        if (comment_offset) {
#line 3066
          tmp = (char const   *)((rdata + comment_offset) - converter);
        } else {
#line 3066
          tmp = "";
        }
        {
#line 3066
        natprintf("\t%-15.15s%-10.10s%s\n", sname, typestr, tmp);
#line 3069
        tmp___0 = strlen((char const   *)sname);
        }
#line 3069
        if (tmp___0 > 8UL) {
#line 3069
          long_share_name = 1;
        }
#line 3070
        p += 20;
#line 3037
        i___0 ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 3075
  if (rparam) {
    {
#line 3075
    free((void *)rparam);
    }
  }
#line 3076
  if (rdata) {
    {
#line 3076
    free((void *)rdata);
    }
  }
#line 3078
  return (count___0 > 0);
}
}
#line 3084 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static void server_info(void) 
{ 
  char *rparam ;
  char *rdata ;
  char *p ;
  int rdrcnt ;
  int rprcnt ;
  pstring param ;
  int res ;
  int converter ;
  BOOL tmp ;

  {
  {
#line 3086
  rparam = (char *)((void *)0);
#line 3087
  rdata = (char *)((void *)0);
#line 3092
  bzero((void *)(param), sizeof(param));
#line 3094
  p = param;
#line 3095
  *((unsigned char *)p + 0) = (unsigned char)63;
#line 3095
  *((unsigned char *)p + 1) = (unsigned char )(63 >> 8);
#line 3096
  p += 2;
#line 3097
  StrCpy(p, (char *)"WrLh");
#line 3098
  p = skip_string(p, 1);
#line 3099
  StrCpy(p, (char *)"zzzBBzz");
#line 3100
  p = skip_string(p, 1);
#line 3101
  *((unsigned char *)p + 0) = (unsigned char)10;
#line 3101
  *((unsigned char *)p + 1) = (unsigned char )(10 >> 8);
#line 3102
  *((unsigned char *)p + 2) = (unsigned char)232;
#line 3102
  *((unsigned char *)p + 3) = (unsigned char )(1000 >> 8);
#line 3103
  p += 6;
#line 3105
  tmp = call_api((int )(p - param), 0, 6, 1000, & rprcnt, & rdrcnt, param, (char *)((void *)0),
                 & rparam, & rdata);
  }
#line 3105
  if (tmp) {
#line 3111
    res = (int )((unsigned int )*((unsigned char *)rparam + 0) | ((unsigned int )*((unsigned char *)rparam + 1) << 8));
#line 3112
    converter = (int )((unsigned int )*((unsigned char *)rparam + 2) | ((unsigned int )*((unsigned char *)rparam + 3) << 8));
#line 3114
    if (res == 0) {
      {
#line 3116
      p = rdata;
#line 3119
      natprintf("\n[*]--- Obtained server information:\n");
#line 3122
      natprintf("\nServer=[%s] User=[%s] Workgroup=[%s] Domain=[%s]\n", (rdata + ((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8))) - converter,
                (rdata + ((unsigned int )*((unsigned char *)p + 4) | ((unsigned int )*((unsigned char *)p + 5) << 8))) - converter,
                (rdata + ((unsigned int )*((unsigned char *)p + 8) | ((unsigned int )*((unsigned char *)p + 9) << 8))) - converter,
                (rdata + ((unsigned int )*((unsigned char *)p + 14) | ((unsigned int )*((unsigned char *)p + 15) << 8))) - converter);
#line 3128
      cur_vuln = 16003;
#line 3129
      fill_vuln("Was able to obtain server info:", "");
#line 3130
      sprintf((char */* __restrict  */)(param), (char const   */* __restrict  */)"Server %.15s, User %.15s",
              (rdata + ((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8))) - converter,
              (rdata + ((unsigned int )*((unsigned char *)p + 4) | ((unsigned int )*((unsigned char *)p + 5) << 8))) - converter);
#line 3133
      fill_vuln("Serverinfo: ", param);
#line 3134
      sprintf((char */* __restrict  */)(param), (char const   */* __restrict  */)"Workgroup %.15s, Domain %.15s",
              (rdata + ((unsigned int )*((unsigned char *)p + 8) | ((unsigned int )*((unsigned char *)p + 9) << 8))) - converter,
              (rdata + ((unsigned int )*((unsigned char *)p + 14) | ((unsigned int )*((unsigned char *)p + 15) << 8))) - converter);
#line 3137
      fill_vuln("Serverinfo: ", param);
      }
    }
  }
#line 3142
  if (rparam) {
    {
#line 3142
    free((void *)rparam);
    }
  }
#line 3143
  if (rdata) {
    {
#line 3143
    free((void *)rdata);
    }
  }
#line 3145
  return;
}
}
#line 3151 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL list_servers(void) 
{ 
  char *rparam ;
  char *rdata ;
  int rdrcnt ;
  int rprcnt ;
  char *p ;
  pstring param ;
  int uLevel ;
  int count___0 ;
  int servertype ;
  int res ;
  int converter ;
  int i___0 ;
  char *sname ;
  int comment_offset ;
  char const   *tmp ;
  char const   *tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 3153
  rparam = (char *)((void *)0);
#line 3154
  rdata = (char *)((void *)0);
#line 3158
  uLevel = 1;
#line 3159
  count___0 = 0;
#line 3161
  servertype = -1;
#line 3164
  p = param;
#line 3165
  *((unsigned char *)p + 0) = (unsigned char)104;
#line 3165
  *((unsigned char *)p + 1) = (unsigned char )(104 >> 8);
#line 3166
  p += 2;
#line 3167
  StrCpy(p, (char *)"WrLehDO");
#line 3168
  p = skip_string(p, 1);
#line 3170
  StrCpy(p, (char *)"B16BBDz");
#line 3175
  p = skip_string(p, 1);
#line 3176
  *((unsigned char *)p + 0) = (unsigned char )((int )((uint16 )uLevel) & 255);
#line 3176
  *((unsigned char *)p + 1) = (unsigned char )((int )((uint16 )uLevel) >> 8);
#line 3177
  *((unsigned char *)p + 2) = (unsigned char)0;
#line 3177
  *((unsigned char *)p + 3) = (unsigned char )(8192 >> 8);
#line 3178
  p += 4;
#line 3179
  *((unsigned char *)p + 0) = (unsigned char )(((uint32 )servertype & 65535U) & 255U);
#line 3179
  *((unsigned char *)p + 1) = (unsigned char )(((uint32 )servertype & 65535U) >> 8);
#line 3179
  *((unsigned char *)p + 2) = (unsigned char )(((uint32 )servertype >> 16) & 255U);
#line 3179
  *((unsigned char *)p + 3) = (unsigned char )(((uint32 )servertype >> 16) >> 8);
#line 3180
  p += 4;
#line 3182
  tmp___1 = call_api((int )(p - param), 0, 8, 10000, & rprcnt, & rdrcnt, param, (char *)((void *)0),
                     & rparam, & rdata);
  }
#line 3182
  if (tmp___1) {
#line 3185
    res = (int )((unsigned int )*((unsigned char *)rparam + 0) | ((unsigned int )*((unsigned char *)rparam + 1) << 8));
#line 3186
    converter = (int )((unsigned int )*((unsigned char *)rparam + 2) | ((unsigned int )*((unsigned char *)rparam + 3) << 8));
#line 3189
    if (res == 0) {
#line 3191
      count___0 = (int )((unsigned int )*((unsigned char *)rparam + 4) | ((unsigned int )*((unsigned char *)rparam + 5) << 8));
#line 3192
      p = rdata;
#line 3194
      if (count___0 > 0) {
        {
#line 3196
        natprintf("\n[*]--- This machine has a browse list:\n");
#line 3197
        natprintf("\n\tServer               Comment\n");
#line 3198
        natprintf("\t---------            -------\n");
        }
      }
      {
#line 3202
      cur_vuln = 16005;
#line 3203
      fill_vuln("Was able to obtain browselist:", "");
#line 3205
      i___0 = 0;
      }
      {
#line 3205
      while (1) {
        while_continue: /* CIL Label */ ;
#line 3205
        if (! (i___0 < count___0)) {
#line 3205
          goto while_break;
        }
#line 3207
        sname = p;
#line 3208
        comment_offset = (int )((((unsigned int )*((unsigned char *)p + 22) | ((unsigned int )*((unsigned char *)p + 23) << 8)) | (((unsigned int )*((unsigned char *)p + 24) | ((unsigned int )*((unsigned char *)p + 25) << 8)) << 16)) & 65535U);
#line 3210
        if (comment_offset) {
#line 3210
          tmp = (char const   *)((rdata + comment_offset) - converter);
        } else {
#line 3210
          tmp = "";
        }
        {
#line 3210
        sprintf((char */* __restrict  */)(param), (char const   */* __restrict  */)"%.16s : %.40s",
                sname, tmp);
#line 3212
        fill_vuln("Browselist: ", param);
        }
#line 3214
        if (comment_offset) {
#line 3214
          tmp___0 = (char const   *)((rdata + comment_offset) - converter);
        } else {
#line 3214
          tmp___0 = "";
        }
        {
#line 3214
        natprintf("\t%-16.16s     %s\n", sname, tmp___0);
#line 3218
        p += 26;
#line 3205
        i___0 ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 3220
      natprintf("\n");
      }
    }
  }
#line 3224
  if (rparam) {
    {
#line 3224
    free((void *)rparam);
    }
  }
#line 3225
  if (rdata) {
    {
#line 3225
    free((void *)rdata);
    }
  }
#line 3227
  return (count___0 > 0);
}
}
#line 3235 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int last_port  ;
#line 3233 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static BOOL open_sockets(int port ) 
{ 
  char *host ;
  pstring service2 ;
  struct hostent *hp ;

  {
#line 3240
  if (port == 0) {
#line 3240
    port = last_port;
  }
  {
#line 3241
  last_port = port;
#line 3243
  strupper(service);
  }
#line 3245
  if (desthost[0]) {
#line 3246
    host = desthost;
  } else {
    {
#line 3248
    StrCpy(service2, service);
#line 3249
    host = strtok((char */* __restrict  */)(service2), (char const   */* __restrict  */)"\\/");
#line 3250
    StrCpy(desthost, host);
    }
  }
#line 3253
  if (DEBUGLEVEL >= 3) {
    {
#line 3253
    Debug1((char *)"Opening sockets\n");
    }
  }
#line 3263
  if (! have_ip) {
    {
#line 3266
    hp = Get_Hostbyname(host);
    }
#line 3266
    if ((unsigned long )hp == (unsigned long )((struct hostent *)0)) {
#line 3267
      if (DEBUGLEVEL >= 0) {
        {
#line 3267
        Debug1((char *)"Get_Hostbyname: Unknown host %s.\n", host);
        }
      }
#line 3268
      return (0);
    }
    {
#line 3271
    putip((void *)((char *)(& dest_ip)), (void *)*(hp->h_addr_list + 0));
    }
  }
  {
#line 3274
  Client = open_socket_out(1, & dest_ip, port);
  }
#line 3275
  if (Client == -1) {
#line 3276
    return (0);
  }
#line 3278
  if (DEBUGLEVEL >= 3) {
    {
#line 3278
    Debug1((char *)"Connected\n");
    }
  }
  {
#line 3280
  set_socket_options(Client, user_socket_options);
  }
#line 3281
  return (1);
}
}
#line 3289 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static int open_count  =    0;
#line 3287 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
BOOL reopen_connection(char *inbuf___0 , char *outbuf___1 ) 
{ 
  BOOL tmp ;
  BOOL tmp___0 ;

  {
#line 3291
  open_count ++;
#line 3293
  if (open_count > 5) {
#line 3293
    return (0);
  }
#line 3295
  if (DEBUGLEVEL >= 1) {
    {
#line 3295
    Debug1((char *)"Trying to re-open connection\n");
    }
  }
  {
#line 3297
  set_message(outbuf___1, 0, 0, 1);
#line 3298
  *((unsigned char *)outbuf___1 + 8) = (unsigned char)113;
#line 3299
  *((unsigned char *)outbuf___1 + 28) = (unsigned char )((int )((uint16 )cnum) & 255);
#line 3299
  *((unsigned char *)outbuf___1 + 29) = (unsigned char )((int )((uint16 )cnum) >> 8);
#line 3300
  setup_pkt(outbuf___1);
#line 3302
  send_smb(Client, outbuf___1);
#line 3303
  receive_smb(Client, inbuf___0, 5000);
#line 3305
  close_sockets();
#line 3306
  tmp = open_sockets(0);
  }
#line 3306
  if (! tmp) {
#line 3306
    return (0);
  }
  {
#line 3308
  tmp___0 = send_login(inbuf___0, outbuf___1, 1, 1);
  }
#line 3308
  return (tmp___0);
}
}
#line 3317 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
void busted(void) 
{ 


  {
#line 3319
  if (DEBUGLEVEL >= 3) {
    {
#line 3319
    Debug1((char *)"sigpipe!  restarting...\n");
    }
  }
  {
#line 3320
  signal(13, (void (*)(int  ))0);
  }
#line 3321
  return;
}
}
#line 3432
char *Get_Hostbyaddr(struct in_addr ip ) ;
#line 3348 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int step(char *inbuf___0 , char *outbuf___1 ) 
{ 
  fstring test_dir ;
  unsigned int tmp ;
  int fattr ;
  char *p ;
  register int x ;
  int rval ;
  int phase ;
  int done ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  __uid_t tmp___3 ;
  BOOL tmp___4 ;
  BOOL tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  BOOL tmp___11 ;
  int tmp___12 ;
  BOOL tmp___13 ;
  BOOL tmp___14 ;
  BOOL tmp___15 ;

  {
#line 3354
  test_dir[0] = (char )'\\';
#line 3354
  test_dir[1] = (char )'-';
#line 3354
  test_dir[2] = (char )'N';
#line 3354
  test_dir[3] = (char )'A';
#line 3354
  test_dir[4] = (char )'S';
#line 3354
  test_dir[5] = (char )'T';
#line 3354
  test_dir[6] = (char )'Y';
#line 3354
  test_dir[7] = (char )'-';
#line 3354
  test_dir[8] = (char )'.';
#line 3354
  test_dir[9] = (char )'$';
#line 3354
  test_dir[10] = (char )'$';
#line 3354
  test_dir[11] = (char )'$';
#line 3354
  test_dir[12] = (char )'\000';
#line 3354
  tmp = 13U;
  {
#line 3354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3354
    if (tmp >= 128U) {
#line 3354
      goto while_break;
    }
#line 3354
    test_dir[tmp] = (char)0;
#line 3354
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3357
  fattr = (int )(((1L << 4) | (1L << 2)) | (1L << 1));
#line 3361
  rval = 0;
#line 3362
  phase = 0;
#line 3389
  max_protocol = 2;
#line 3390
  Client = -1;
#line 3391
  upp_ctx = 0;
#line 3392
  ptr_names = 0;
#line 3398
  if ((unsigned long )inbuf___0 == (unsigned long )((void *)0)) {
    {
#line 3399
    tmp___0 = malloc((size_t )66559);
#line 3399
    inbuf___0 = (char *)tmp___0;
    }
  }
#line 3400
  if ((unsigned long )outbuf___1 == (unsigned long )((void *)0)) {
    {
#line 3401
    tmp___1 = malloc((size_t )66559);
#line 3401
    outbuf___1 = (char *)tmp___1;
    }
  }
#line 3402
  if (! inbuf___0) {
#line 3403
    return (-1);
  } else
#line 3402
  if (! outbuf___1) {
#line 3403
    return (-1);
  }
  {
#line 3405
  signal(13, (void (*)(int  ))(& busted));
#line 3416
  natprintf("[*]--- Obtaining list of remote NetBIOS names\n");
#line 3419
  name_type = 0;
#line 3420
  p = (char *)((void *)0);
#line 3421
  x = send_status((char *)"*");
  }
#line 3422
  if (x) {
#line 3423
    goto s_got_names;
  }
#line 3425
  if (DEBUGLEVEL >= 1) {
    {
#line 3425
    Debug1((char *)"NBSTAT * query failed, making some more guesses\n");
    }
  }
  {
#line 3432
  tmp___2 = (int )Get_Hostbyaddr(dest_ip);
#line 3432
  p = (char *)tmp___2;
  }
#line 3434
  if (p) {
    {
#line 3434
    p = strtok((char */* __restrict  */)p, (char const   */* __restrict  */)".");
    }
#line 3434
    if (p) {
      {
#line 3435
      fill_block(try_names, p);
#line 3441
      tmp___3 = getuid();
      }
#line 3441
      if (tmp___3) {
#line 3442
        goto s_got_names;
      }
      {
#line 3443
      x = send_status(p);
#line 3444
      p = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)".");
      }
#line 3445
      if (p) {
        {
#line 3446
        send_status(p);
        }
      }
    }
  }
#line 3457
  if (! x) {
    {
#line 3457
    x = send_status((char *)"WORKGROUP");
    }
  }
#line 3459
  if (! x) {
    {
#line 3460
    name_type = 1;
#line 3461
    x = send_status((char *)"\001\002__MSBROWSE__\002");
#line 3462
    name_type = 0;
    }
  }
#line 3464
  if (! x) {
    {
#line 3464
    x = send_status((char *)"DEFAULT");
    }
  }
#line 3465
  if (! x) {
    {
#line 3465
    x = send_status((char *)"SERVER");
    }
  }
#line 3466
  if (! x) {
    {
#line 3466
    x = send_status((char *)"ADMINISTRATOR");
    }
  }
  s_got_names: 
  {
#line 3469
  fill_block(try_names, (char *)"*SMBSERVER");
#line 3470
  fill_block(try_names, (char *)"SMBSERVER");
#line 3471
  fill_block(try_names, (char *)"*               ");
#line 3472
  name_type = 32;
  }
  phase_0: 
  {
#line 3480
  phase = 0;
#line 3481
  rval = 0;
#line 3482
  close_sockets();
#line 3483
  tmp___4 = open_sockets(cur_port);
  }
#line 3483
  if (tmp___4) {
#line 3484
    phase ++;
  }
#line 3486
  if (phase != 1) {
#line 3487
    goto nope;
  }
#line 3488
  rval = 1;
#line 3498
  if (phase == 2) {
#line 3499
    goto phase_2;
  }
  {
#line 3502
  p = get_block(try_names, ptr_names);
  }
#line 3503
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3504
    if (name_type == 0) {
#line 3505
      goto nope;
    }
#line 3506
    name_type = 0;
#line 3507
    ptr_names = 0;
#line 3508
    if (DEBUGLEVEL >= 1) {
      {
#line 3508
      Debug1((char *)"retrying session-names with type 0...\n");
      }
    }
#line 3509
    goto phase_0;
  }
  {
#line 3511
  StrCpy(desthost, p);
#line 3514
  natprintf("\n[*]--- Attempting to connect with name: %s\n", p);
#line 3517
  x = send_session_request(inbuf___0, outbuf___1);
  }
#line 3518
  if (x == 1) {
    {
#line 3521
    natprintf("[*]--- CONNECTED with name: %s\n", p);
    }
#line 3524
    if (DEBUGLEVEL >= 0) {
      {
#line 3524
      Debug1((char *)"session to %s (0x%x) open\n", desthost, name_type);
      }
    }
#line 3525
    phase = 2;
#line 3526
    goto phase_2;
  } else {
    {
#line 3530
    natprintf("[*]--- Unable to connect\n");
#line 3533
    ptr_names ++;
    }
#line 3534
    goto phase_0;
  }
  phase_2: 
#line 3544
  if (phase == 3) {
#line 3545
    goto phase_3;
  }
  {
#line 3548
  name_type = 32;
#line 3549
  x = send_prots(inbuf___0, outbuf___1);
  }
#line 3555
  if (x == 1) {
#line 3556
    if (max_protocol == 2) {
#line 3556
      if (sec_mode & 3) {
        {
#line 3563
        natprintf("[*]--- Remote server wants us to encrypt, telling it not to\n");
#line 3566
        max_protocol = 4;
#line 3567
        x = send_prots(inbuf___0, outbuf___1);
        }
#line 3568
        if (x == 0) {
#line 3569
          goto phase_0;
        }
      }
    }
#line 3572
    cur_protocol = max_protocol;
#line 3573
    cur_sec_mode = sec_mode;
#line 3574
    phase ++;
  }
#line 3577
  if (phase != 3) {
#line 3578
    goto nope;
  }
  phase_3: 
#line 3586
  if (phase == 4) {
#line 3587
    goto phase_4;
  }
  {
#line 3595
  natprintf("[*]--- Attempting to establish session\n");
#line 3598
  x = send_setup(inbuf___0, outbuf___1);
  }
#line 3599
  if (x == 1) {
    {
#line 3600
    cur_vuln = 16001;
#line 3601
    fill_vuln("Was able to connect with no username", "or password");
#line 3602
    phase = 4;
    }
#line 3603
    goto phase_4;
  }
  {
#line 3607
  natprintf("[*]--- Was not able to establish session with no password\n");
#line 3610
  upp_ctx = 0;
#line 3612
  done = 0;
#line 3613
  username[0] = (char )'\000';
  }
  {
#line 3614
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 3614
    if (! (! done)) {
#line 3614
      goto while_break___0;
    }
#line 3615
    if (! userfd) {
#line 3615
      goto _L;
    } else
#line 3615
    if (! passfd) {
      _L: /* CIL Label */ 
      {
#line 3616
      tmp___5 = uppair();
      }
#line 3616
      if (tmp___5) {
#line 3616
        tmp___6 = 0;
      } else {
#line 3616
        tmp___6 = 1;
      }
#line 3616
      done = tmp___6;
    } else {
      {
#line 3618
      tmp___8 = fgets((char */* __restrict  */)(password), (int )sizeof(password),
                      (FILE */* __restrict  */)passfd);
      }
#line 3618
      if ((unsigned long )tmp___8 == (unsigned long )((void *)0)) {
        {
#line 3619
        rewind(passfd);
#line 3620
        tmp___7 = fgets((char */* __restrict  */)(password), (int )sizeof(password),
                        (FILE */* __restrict  */)passfd);
        }
#line 3620
        if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
          {
#line 3621
          natprintf("[*]--- Failure reading password from: %s\n", passfile);
#line 3622
          exit(-1);
          }
        }
#line 3624
        username[0] = (char )'\000';
      }
      {
#line 3626
      strtok((char */* __restrict  */)(password), (char const   */* __restrict  */)"\r\n");
      }
#line 3627
      if ((int )username[0] == 0) {
        {
#line 3628
        tmp___10 = fgets((char */* __restrict  */)(username), (int )sizeof(username),
                         (FILE */* __restrict  */)userfd);
        }
#line 3628
        if ((unsigned long )tmp___10 == (unsigned long )((void *)0)) {
          {
#line 3629
          tmp___9 = feof(userfd);
          }
#line 3629
          if (tmp___9) {
#line 3630
            done ++;
#line 3631
            goto nope;
          }
        }
        {
#line 3634
        strtok((char */* __restrict  */)(username), (char const   */* __restrict  */)"\r\n");
        }
      }
    }
#line 3638
    if (! username[0]) {
#line 3638
      if (! password[0]) {
        {
#line 3639
        tmp___11 = uppair();
        }
#line 3639
        if (tmp___11) {
#line 3639
          tmp___12 = 0;
        } else {
#line 3639
          tmp___12 = 1;
        }
#line 3639
        done = tmp___12;
      }
    }
#line 3641
    if (done) {
#line 3642
      goto while_break___0;
    }
    {
#line 3645
    natprintf("[*]--- Attempting to connect with Username: `%s\' Password: `%s\'\n",
              username, password);
#line 3649
    x = send_setup(inbuf___0, outbuf___1);
    }
#line 3650
    if (x == 1) {
#line 3650
      if (upp_ctx < 3) {
        {
#line 3653
        natprintf("[*]--- CONNECTED: Username: `%s\' Password: `%s\'\n", username,
                  password);
#line 3657
        StrCpy(cur_user, username);
#line 3658
        StrCpy(cur_pass, password);
#line 3659
        upp_ctx = 3;
#line 3660
        phase ++;
#line 3661
        cur_vuln = 16002;
#line 3662
        fill_vuln("Was able to guess the username and", " password to establish a connection");
#line 3664
        sprintf((char */* __restrict  */)outbuf___1, (char const   */* __restrict  */)"Username: `%s\'",
                username);
#line 3665
        fill_vuln(outbuf___1, "");
#line 3666
        sprintf((char */* __restrict  */)outbuf___1, (char const   */* __restrict  */)"Password: `%s\'",
                password);
#line 3667
        fill_vuln(outbuf___1, "");
        }
#line 3668
        goto while_break___0;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 3671
  if (phase == 4) {
#line 3672
    goto phase_4;
  }
  {
#line 3685
  username[0] = (char )'\000';
#line 3686
  password[0] = (char )'\000';
#line 3687
  tmp___13 = send_setup(inbuf___0, outbuf___1);
  }
#line 3687
  if (tmp___13) {
#line 3688
    phase ++;
  }
#line 3689
  if (phase != 4) {
#line 3690
    goto nope;
  }
  phase_4: 
#line 3698
  if (phase == 5) {
#line 3699
    goto phase_5;
  }
  {
#line 3717
  sprintf((char */* __restrict  */)(service), (char const   */* __restrict  */)"\\\\%s\\IPC$",
          desthost);
#line 3718
  strupper(service);
#line 3719
  connect_as_ipc = 1;
#line 3720
  cur_serr = 0;
#line 3721
  x = send_tcon(inbuf___0, outbuf___1);
  }
#line 3722
  if (x == 1) {
#line 3723
    goto phase_4b;
  }
#line 3724
  if (cur_serr != 2) {
#line 3725
    phase ++;
#line 3726
    goto phase_5;
  }
#line 3732
  upp_ctx = 4;
  {
#line 3733
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 3733
    tmp___14 = uppair();
    }
#line 3733
    if (! tmp___14) {
#line 3733
      goto while_break___1;
    }
    {
#line 3734
    cur_serr = 0;
#line 3735
    x = send_tcon(inbuf___0, outbuf___1);
    }
#line 3736
    if (x == 1) {
#line 3737
      goto phase_4b;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  phase_4b: 
  {
#line 3762
  server_info();
#line 3763
  x = browse_host(1);
#line 3764
  x = list_servers();
#line 3765
  send_tdis(inbuf___0, outbuf___1);
#line 3766
  phase ++;
  }
  phase_5: 
#line 3774
  if (phase == 6) {
#line 3775
    goto phase_6;
  }
  {
#line 3783
  x = fill_block(try_shares, (char *)"ADMIN$");
  }
#line 3784
  if (x) {
#line 3784
    hid_shares = x;
  }
  {
#line 3785
  x = fill_block(try_shares, (char *)"C$");
  }
#line 3786
  if (x) {
#line 3786
    hid_shares = x;
  }
  {
#line 3787
  x = fill_block(try_shares, (char *)"D$");
  }
#line 3788
  if (x) {
#line 3788
    hid_shares = x;
  }
  {
#line 3789
  x = fill_block(try_shares, (char *)"ROOT");
  }
#line 3790
  if (x) {
#line 3790
    hid_shares = x;
  }
  {
#line 3791
  x = fill_block(try_shares, (char *)"WINNT$");
  }
#line 3792
  if (x) {
#line 3792
    hid_shares = x;
  }
#line 3793
  ptr_shares = 0;
#line 3794
  connect_as_ipc = 0;
  phase_5a: 
  {
#line 3800
  p = get_block(try_shares, ptr_shares);
  }
#line 3801
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 3802
    goto nope;
  }
  {
#line 3804
  cur_serr = 0;
#line 3806
  sprintf((char */* __restrict  */)(service), (char const   */* __restrict  */)"\\\\%s\\%s",
          desthost, p);
#line 3809
  natprintf("\n[*]--- Attempting to access share: %s\n", service);
#line 3812
  x = send_tcon(inbuf___0, outbuf___1);
  }
#line 3813
  if (x == 1) {
    {
#line 3816
    natprintf("[*]--- WARNING: Able to access share: %s\n", service);
#line 3819
    phase = 6;
    }
#line 3820
    goto phase_6;
  } else {
    {
#line 3823
    natprintf("[*]--- Unable to access\n");
    }
  }
#line 3837
  if (cur_serr == 6) {
#line 3838
    ptr_shares ++;
#line 3839
    goto phase_5a;
  }
#line 3841
  upp_ctx = 4;
  {
#line 3842
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 3842
    tmp___15 = uppair();
    }
#line 3842
    if (! tmp___15) {
#line 3842
      goto while_break___2;
    }
    {
#line 3843
    x = send_tcon(inbuf___0, outbuf___1);
    }
#line 3844
    if (x == 1) {
#line 3845
      phase = 6;
#line 3846
      goto phase_6;
    }
#line 3848
    if (sec_mode & 1) {
#line 3848
      if (cur_serr == 2) {
#line 3849
        goto while_break___2;
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3851
  ptr_shares ++;
#line 3852
  goto phase_5a;
  phase_6: 
  {
#line 3858
  cur_vuln = 16006;
#line 3859
  sprintf((char */* __restrict  */)outbuf___1, (char const   */* __restrict  */)"%s as user `%s\' pass `%s\'",
          service, username, password);
#line 3860
  fill_vuln("Connected to share ", outbuf___1);
  }
#line 3874
  if (ptr_shares >= hid_shares) {
    {
#line 3875
    cur_vuln = 16007;
#line 3876
    fill_vuln("Hidden share: ", service);
    }
  }
  {
#line 3883
  StrCpy(cur_dir, test_dir);
#line 3884
  natprintf("[*]--- Checking write access in: %s\n", service);
#line 3885
  x = do_mkdir(cur_dir);
  }
#line 3886
  if (x == 1) {
    {
#line 3887
    cur_vuln = 16008;
#line 3888
    fill_vuln("Write access: ", service);
#line 3889
    natprintf("[*]--- WARNING: Directory is writeable: %s\n", service);
#line 3890
    StrCpy(cur_dir, test_dir);
#line 3891
    x = do_rmdir(cur_dir);
    }
#line 3892
    if (x == 0) {
      {
#line 3893
      fill_vuln("cleanup FAILED: ", service);
      }
    }
  }
  {
#line 3899
  natprintf("[*]--- Attempting to exercise .. bug on: %s\n", service);
  }
#line 3900
  if (DEBUGLEVEL >= 0) {
    {
#line 3900
    Debug1((char *)"%s: insert dotdot here!\n", try_shares[ptr_shares]);
    }
  }
  {
#line 3901
  cur_stash = (file_info *)((void *)0);
#line 3902
  StrCpy(cur_dir, (char *)"\\*.*");
#line 3903
  do_dir(inbuf___0, outbuf___1, cur_dir, fattr, (void (*)())(& get_stash), 0);
#line 3904
  tested_stash = 0;
#line 3905
  StrCpy(cur_dir, (char *)"..\\*.*");
#line 3906
  do_dir(inbuf___0, outbuf___1, cur_dir, fattr, (void (*)())(& cmp_stash), 0);
#line 3907
  tested_stash = 0;
#line 3908
  StrCpy(cur_dir, (char *)"\\..\\*.*");
#line 3909
  do_dir(inbuf___0, outbuf___1, cur_dir, fattr, (void (*)())(& cmp_stash), 0);
#line 3910
  tested_stash = 0;
#line 3911
  StrCpy(cur_dir, (char *)"...\\*.*");
#line 3912
  do_dir(inbuf___0, outbuf___1, cur_dir, fattr, (void (*)())(& cmp_stash), 0);
#line 3913
  tested_stash = 0;
#line 3914
  StrCpy(cur_dir, (char *)".\\...\\*.*");
#line 3915
  do_dir(inbuf___0, outbuf___1, cur_dir, fattr, (void (*)())(& cmp_stash), 0);
#line 3916
  tested_stash = 0;
#line 3923
  send_tdis(inbuf___0, outbuf___1);
#line 3924
  ptr_shares ++;
  }
#line 3925
  goto phase_5a;
  nope: 
  {
#line 3933
  free((void *)inbuf___0);
#line 3934
  free((void *)outbuf___1);
#line 3935
  outbuf___1 = (char *)((void *)0);
#line 3935
  inbuf___0 = outbuf___1;
  }
#line 3936
  return (rval);
}
}
#line 3945 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
int nas_step(unsigned long xip ) 
{ 
  BOOL is_vuln ;

  {
  {
#line 3949
  is_vuln = 0;
#line 3951
  TimeInit();
#line 3952
  charset_initialise();
  }
#line 3954
  if (xip == 0UL) {
#line 3954
    return (0);
  }
#line 3955
  if (xip == 4294967295UL) {
#line 3955
    return (0);
  }
  {
#line 3956
  putip((void *)(& dest_ip), (void *)((struct in_addr *)(& xip)));
#line 3957
  have_ip = 1;
#line 3958
  pid = 10240;
#line 3959
  uid = 0;
#line 3960
  gid = 0;
#line 3961
  cur_port = 139;
#line 3962
  stepping = 1;
#line 3963
  StrCpy(username, (char *)"ADMINISTRATOR");
#line 3964
  xflag = 0;
#line 3966
  is_vuln = step((char *)((void *)0), (char *)((void *)0));
#line 3967
  close_sockets();
#line 3968
  clear_block(try_names, idx_names);
#line 3969
  clear_block(try_users, idx_users);
#line 3970
  clear_block(try_pass, idx_pass);
#line 3971
  clear_block(try_shares, idx_shares);
  }
#line 3972
  return (is_vuln);
}
}
#line 4317 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
err_code_struct dos_msgs[40]  = 
#line 4317
  {      {(char *)"ERRbadfunc", 1, (char *)"Invalid function."}, 
        {(char *)"ERRbadfile", 2, (char *)"File not found."}, 
        {(char *)"ERRbadpath", 3, (char *)"Directory invalid."}, 
        {(char *)"ERRnofids", 4, (char *)"No file descriptors available"}, 
        {(char *)"ERRnoaccess", 5, (char *)"Access denied."}, 
        {(char *)"ERRbadfid", 6, (char *)"Invalid file handle."}, 
        {(char *)"ERRbadmcb", 7, (char *)"Memory control blocks destroyed."}, 
        {(char *)"ERRnomem", 8, (char *)"Insufficient server memory to perform the requested function."}, 
        {(char *)"ERRbadmem",
      9, (char *)"Invalid memory block address."}, 
        {(char *)"ERRbadenv", 10, (char *)"Invalid environment."}, 
        {(char *)"ERRbadformat", 11, (char *)"Invalid format."}, 
        {(char *)"ERRbadaccess", 12, (char *)"Invalid open mode."}, 
        {(char *)"ERRbaddata", 13, (char *)"Invalid data."}, 
        {(char *)"ERR", 14, (char *)"reserved."}, 
        {(char *)"ERRbaddrive", 15, (char *)"Invalid drive specified."}, 
        {(char *)"ERRremcd", 16, (char *)"A Delete Directory request attempted  to  remove  the  server\'s  current directory."}, 
        {(char *)"ERRdiffdevice",
      17, (char *)"Not same device."}, 
        {(char *)"ERRnofiles", 18, (char *)"A File Search command can find no more files matching the specified criteria."}, 
        {(char *)"ERRbadshare",
      32, (char *)"The sharing mode specified for an Open conflicts with existing  FIDs  on the file."}, 
        {(char *)"ERRlock",
      33, (char *)"A Lock request conflicted with an existing lock or specified an  invalid mode,  or an Unlock requested attempted to remove a lock held by another process."}, 
        {(char *)"ERRfilexists",
      80, (char *)"The file named in a Create Directory, Make  New  File  or  Link  request already exists."}, 
        {(char *)"ERRbadpipe",
      230, (char *)"Pipe invalid."}, 
        {(char *)"ERRpipebusy", 231, (char *)"All instances of the requested pipe are busy."}, 
        {(char *)"ERRpipeclosing",
      232, (char *)"Pipe close in progress."}, 
        {(char *)"ERRnotconnected", 233, (char *)"No process on other end of pipe."}, 
        {(char *)"ERRmoredata",
      234, (char *)"There is more data to be returned."}, 
        {(char *)"ERRnetaccess", 65, (char *)"Network access denied"}, 
        {(char *)"ERRresourcetype", 66, (char *)"Network resource type incorrect"}, 
        {(char *)"ERRnetname", 67, (char *)"Network name not found"}, 
        {(char *)"ERRnomoreconn", 71, (char *)"No more connections available"}, 
        {(char *)"ERRnetpassword", 86, (char *)"Network password incorrect"}, 
        {(char *)"ERRparam", 87, (char *)"Parameter incorrect"}, 
        {(char *)"ERRnouids", 90, (char *)"Too many UIDs"}, 
        {(char *)"ERRaccexpired", 2239, (char *)"Account expired or disabled"}, 
        {(char *)"ERRwsaccess", 2240, (char *)"Access denied from this workstation"}, 
        {(char *)"ERRtimeaccess",
      2241, (char *)"Cannot log in at this time"}, 
        {(char *)"ERRpassword", 2242, (char *)"Password expired"}, 
        {(char *)"ERRcorruptsec", 2247, (char *)"Security database corrupted"}, 
        {(char *)"ERRinvgroup", 2455, (char *)"Invalid workgroup"}, 
        {(char *)((void *)0), -1, (char *)((void *)0)}};
#line 4365 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
err_code_struct server_msgs[33]  = 
#line 4365
  {      {(char *)"ERRerror", 1, (char *)"Non-specific error code."}, 
        {(char *)"ERRbadpw", 2, (char *)"Bad password - name/password pair in a Tree Connect or Session Setup are invalid."}, 
        {(char *)"ERRbadtype",
      3, (char *)"reserved."}, 
        {(char *)"ERRaccess", 4, (char *)"The requester does not have  the  necessary  access  rights  within  the specified  context for the requested function. The context is defined by the TID or the UID."}, 
        {(char *)"ERRinvnid",
      5, (char *)"The tree ID (TID) specified in a command was invalid."}, 
        {(char *)"ERRinvnetname", 6, (char *)"Invalid network name in tree connect."}, 
        {(char *)"ERRinvdevice",
      7, (char *)"Invalid device - printer request made to non-printer connection or  non-printer request made to printer connection."}, 
        {(char *)"ERRqfull",
      49, (char *)"Print queue full (files) -- returned by open print file."}, 
        {(char *)"ERRqtoobig", 50, (char *)"Print queue full -- no space."}, 
        {(char *)"ERRqeof", 51, (char *)"EOF on print queue dump."}, 
        {(char *)"ERRinvpfid", 52, (char *)"Invalid print file FID."}, 
        {(char *)"ERRsmbcmd", 64, (char *)"The server did not recognize the command received."}, 
        {(char *)"ERRsrverror",
      65, (char *)"The server encountered an internal error, e.g., system file unavailable."}, 
        {(char *)"ERRfilespecs",
      67, (char *)"The file handle (FID) and pathname parameters contained an invalid  combination of values."}, 
        {(char *)"ERRreserved",
      68, (char *)"reserved."}, 
        {(char *)"ERRbadpermits", 69, (char *)"The access permissions specified for a file or directory are not a valid combination.  The server cannot set the requested attribute."}, 
        {(char *)"ERRreserved",
      70, (char *)"reserved."}, 
        {(char *)"ERRsetattrmode", 71, (char *)"The attribute mode in the Set File Attribute request is invalid."}, 
        {(char *)"ERRpaused",
      81, (char *)"Server is paused."}, 
        {(char *)"ERRmsgoff", 82, (char *)"Not receiving messages."}, 
        {(char *)"ERRnoroom", 83, (char *)"No room to buffer message."}, 
        {(char *)"ERRrmuns", 87, (char *)"Too many remote user names."}, 
        {(char *)"ERRtimeout", 88, (char *)"Operation timed out."}, 
        {(char *)"ERRnoresource", 89, (char *)"No resources currently available for request."}, 
        {(char *)"ERRtoomanyuids",
      90, (char *)"Too many UIDs active on this session."}, 
        {(char *)"ERRbaduid", 91, (char *)"The UID is not known as a valid ID on this session."}, 
        {(char *)"ERRusempx",
      250, (char *)"Temp unable to support Raw, use MPX mode."}, 
        {(char *)"ERRusestd", 251, (char *)"Temp unable to support Raw, use standard read/write."}, 
        {(char *)"ERRcontmpx",
      252, (char *)"Continue in MPX mode."}, 
        {(char *)"ERRreserved", 253, (char *)"reserved."}, 
        {(char *)"ERRreserved", 254, (char *)"reserved."}, 
        {(char *)"ERRnosupport", 65535, (char *)"Function not supported."}, 
        {(char *)((void *)0), -1, (char *)((void *)0)}};
#line 4401 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
err_code_struct hard_msgs[19]  = 
#line 4401
  {      {(char *)"ERRnowrite", 19, (char *)"Attempt to write on write-protected diskette."}, 
        {(char *)"ERRbadunit",
      20, (char *)"Unknown unit."}, 
        {(char *)"ERRnotready", 21, (char *)"Drive not ready."}, 
        {(char *)"ERRbadcmd", 22, (char *)"Unknown command."}, 
        {(char *)"ERRdata", 23, (char *)"Data error (CRC)."}, 
        {(char *)"ERRbadreq", 24, (char *)"Bad request structure length."}, 
        {(char *)"ERRseek", 25, (char *)"Seek error."}, 
        {(char *)"ERRbadmedia", 26, (char *)"Unknown media type."}, 
        {(char *)"ERRbadsector", 27, (char *)"Sector not found."}, 
        {(char *)"ERRnopaper", 28, (char *)"Printer out of paper."}, 
        {(char *)"ERRwrite", 29, (char *)"Write fault."}, 
        {(char *)"ERRread", 30, (char *)"Read fault."}, 
        {(char *)"ERRgeneral", 31, (char *)"General failure."}, 
        {(char *)"ERRbadshare", 32, (char *)"A open conflicts with an existing open."}, 
        {(char *)"ERRlock",
      33, (char *)"A Lock request conflicted with an existing lock or specified an invalid mode, or an Unlock requested attempted to remove a lock held by another process."}, 
        {(char *)"ERRwrongdisk",
      34, (char *)"The wrong disk was found in a drive."}, 
        {(char *)"ERRFCBUnavail", 35, (char *)"No FCBs are available to process request."}, 
        {(char *)"ERRsharebufexc",
      36, (char *)"A sharing buffer has been exceeded."}, 
        {(char *)((void *)0), -1, (char *)((void *)0)}};
#line 4422 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
struct __anonstruct_err_classes_93 err_classes[10]  = 
#line 4422
  {      {0, (char *)"SUCCESS", (err_code_struct *)((void *)0)}, 
        {1, (char *)"ERRDOS", dos_msgs}, 
        {2, (char *)"ERRSRV", server_msgs}, 
        {3, (char *)"ERRHRD", hard_msgs}, 
        {4, (char *)"ERRXOS", (err_code_struct *)((void *)0)}, 
        {225, (char *)"ERRRMX1", (err_code_struct *)((void *)0)}, 
        {226, (char *)"ERRRMX2", (err_code_struct *)((void *)0)}, 
        {227, (char *)"ERRRMX3", (err_code_struct *)((void *)0)}, 
        {255, (char *)"ERRCMD", (err_code_struct *)((void *)0)}, 
        {-1, (char *)((void *)0), (err_code_struct *)((void *)0)}};
#line 4445 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
static pstring ret  ;
#line 4443 "/home/june/repo/benchmarks/collector/temp/nat-1.0/client.c"
char *smb_errstr(char *inbuf___0 ) 
{ 
  int class ;
  int num ;
  int i___0 ;
  int j ;
  err_code_struct *err ;

  {
#line 4446
  class = (int )*((unsigned char *)inbuf___0 + 9);
#line 4447
  num = (int )((unsigned int )*((unsigned char *)inbuf___0 + 11) | ((unsigned int )*((unsigned char *)inbuf___0 + 12) << 8));
#line 4450
  i___0 = 0;
  {
#line 4450
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4450
    if (! err_classes[i___0].class) {
#line 4450
      goto while_break;
    }
#line 4451
    if (err_classes[i___0].code == class) {
#line 4453
      if (err_classes[i___0].err_msgs) {
#line 4455
        err = err_classes[i___0].err_msgs;
#line 4456
        j = 0;
        {
#line 4456
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 4456
          if (! (err + j)->name) {
#line 4456
            goto while_break___0;
          }
#line 4457
          if (num == (err + j)->code) {
#line 4459
            if (DEBUGLEVEL > 0) {
              {
#line 4460
              sprintf((char */* __restrict  */)(ret), (char const   */* __restrict  */)"%s - %s (%s)",
                      err_classes[i___0].class, (err + j)->name, (err + j)->message);
              }
            } else {
              {
#line 4463
              sprintf((char */* __restrict  */)(ret), (char const   */* __restrict  */)"%s - %s",
                      err_classes[i___0].class, (err + j)->name);
              }
            }
#line 4464
            return (ret);
          }
#line 4456
          j ++;
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 4468
      sprintf((char */* __restrict  */)(ret), (char const   */* __restrict  */)"%s - %d",
              err_classes[i___0].class, num);
      }
#line 4469
      return (ret);
    }
#line 4450
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 4472
  sprintf((char */* __restrict  */)(ret), (char const   */* __restrict  */)"ERROR: Unknown error (%d,%d)",
          class, num);
  }
#line 4473
  return (ret);
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 144 "/usr/include/netdb.h"
extern struct hostent *gethostbyname(char const   *__name ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/nat-1.0/parse_ip.c"
struct ipstr *parse_ip(char *input ) ;
#line 12
void add_parse_ip(struct ipstr **ip , char *new ) ;
#line 13
char *ip_ntoa(u_long in ) ;
#line 93
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/nat-1.0/parse_ip.c"
struct ipstr *parse_ip(char *input ) 
{ 
  char *one ;
  char *dup ;
  char *r1 ;
  char *r2 ;
  u_long ip1 ;
  u_long ip2 ;
  u_char start ;
  u_char stop ;
  struct hostent *hp ;
  int count___0 ;
  struct ipstr *ip ;
  char tmpip[20] ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  size_t tmp___12 ;

  {
  {
#line 46
  one = (char *)((void *)0);
#line 46
  dup = (char *)((void *)0);
#line 47
  r1 = (char *)((void *)0);
#line 47
  r2 = (char *)((void *)0);
#line 48
  ip1 = (u_long )0;
#line 48
  ip2 = (u_long )0;
#line 49
  start = (u_char )0;
#line 49
  stop = (u_char )0;
#line 50
  hp = (struct hostent *)((void *)0);
#line 51
  count___0 = 0;
#line 52
  ip = (struct ipstr *)((void *)0);
#line 55
  dup = strdup((char const   *)input);
#line 56
  one = strtok((char */* __restrict  */)dup, (char const   */* __restrict  */)",");
  }
  {
#line 57
  while (1) {
    while_continue: /* CIL Label */ ;
#line 57
    if (! one) {
#line 57
      goto while_break;
    }
    {
#line 58
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 58
      tmp = __ctype_b_loc();
      }
#line 58
      if ((int const   )*(*tmp + (int )*one) & 8192) {
#line 58
        if (! *one) {
#line 58
          goto while_break___0;
        }
      } else {
#line 58
        goto while_break___0;
      }
#line 59
      one ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 63
    if (*one) {
      {
#line 63
      tmp___1 = __ctype_b_loc();
      }
#line 63
      if (! ((int const   )*(*tmp___1 + (int )*one) & 2048)) {
        {
#line 64
        hp = (struct hostent *)((void *)0);
#line 65
        hp = gethostbyname((char const   *)one);
        }
#line 66
        if (hp) {
          {
#line 67
          memcpy((void */* __restrict  */)((char *)(& ip1)), (void const   */* __restrict  */)*(hp->h_addr_list + 0),
                 sizeof(ip1));
#line 68
          tmp___0 = ip_ntoa(ip1);
#line 68
          sprintf((char */* __restrict  */)(tmpip), (char const   */* __restrict  */)"%s",
                  tmp___0);
#line 69
          add_parse_ip(& ip, tmpip);
#line 70
          count___0 ++;
          }
        } else {
          {
#line 75
          natprintf("[*]--- Unknown host: %s\n", one);
          }
        }
        {
#line 77
        one = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
        }
#line 78
        goto while_continue;
      }
    }
#line 83
    if (*one) {
      {
#line 83
      tmp___7 = strstr((char const   *)one, "-");
      }
#line 83
      if (tmp___7) {
#line 84
        r1 = one;
#line 85
        r2 = one;
        {
#line 85
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 85
          if (*r2) {
#line 85
            if (! ((int )*r2 != 45)) {
#line 85
              goto while_break___1;
            }
          } else {
#line 85
            goto while_break___1;
          }
#line 85
          r2 ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 86
        *r2 = (char )'\000';
#line 87
        r2 ++;
#line 92
        if (r2) {
#line 92
          if (*r2) {
#line 92
            if (r1) {
#line 92
              if (*r1) {
                {
#line 92
                tmp___6 = strlen((char const   *)r1);
                }
#line 92
                if (tmp___6 > 6UL) {
                  {
#line 93
                  tmp___2 = (int )inet_addr(r1);
#line 93
                  ip1 = (u_long )tmp___2;
#line 94
                  tmp___3 = (int )inet_addr(r2);
#line 94
                  ip2 = (u_long )tmp___3;
                  }
#line 95
                  if (ip1 != 0xffffffffffffffffUL) {
#line 95
                    if (ip2 != 0xffffffffffffffffUL) {
#line 96
                      start = (u_char )(ip1 >> 24);
#line 97
                      stop = (u_char )(ip2 >> 24);
#line 98
                      if ((int )start <= (int )stop) {
#line 98
                        if (ip1 != 0xffffffffffffffffUL) {
#line 98
                          if (ip2 != 0xffffffffffffffffUL) {
                            {
#line 99
                            while (1) {
                              while_continue___2: /* CIL Label */ ;
#line 99
                              if ((int )start <= (int )stop) {
#line 99
                                if (! ((int )start > 0)) {
#line 99
                                  goto while_break___2;
                                }
                              } else {
#line 99
                                goto while_break___2;
                              }
                              {
#line 100
                              sprintf((char */* __restrict  */)(tmpip), (char const   */* __restrict  */)"%d.%d.%d.%d",
                                      (int )((u_char )ip1), (int )((u_char )(ip1 >> 8)),
                                      (int )((u_char )(ip1 >> 16)), (int )start);
#line 102
                              add_parse_ip(& ip, tmpip);
#line 103
                              count___0 ++;
#line 104
                              start = (u_char )((int )start + 1);
                              }
                            }
                            while_break___2: /* CIL Label */ ;
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
#line 92
                  goto _L___2;
                }
              } else {
#line 92
                goto _L___2;
              }
            } else {
#line 92
              goto _L___2;
            }
          } else {
#line 92
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 113
        if ((int )((u_char )ip1) != 0) {
#line 113
          if (r2) {
#line 113
            if (*r2) {
#line 113
              if (r1) {
#line 113
                if (*r1) {
                  {
#line 114
                  tmp___4 = atoi((char const   *)r1);
#line 114
                  start = (u_char )tmp___4;
#line 115
                  tmp___5 = atoi((char const   *)r2);
#line 115
                  stop = (u_char )tmp___5;
                  }
#line 116
                  if ((int )start < (int )stop) {
                    {
#line 117
                    while (1) {
                      while_continue___3: /* CIL Label */ ;
#line 117
                      if ((int )start <= (int )stop) {
#line 117
                        if (! ((int )start > 0)) {
#line 117
                          goto while_break___3;
                        }
                      } else {
#line 117
                        goto while_break___3;
                      }
                      {
#line 118
                      sprintf((char */* __restrict  */)(tmpip), (char const   */* __restrict  */)"%d.%d.%d.%d",
                              (int )((u_char )ip1), (int )((u_char )(ip1 >> 8)), (int )((u_char )(ip1 >> 16)),
                              (int )start);
#line 120
                      add_parse_ip(& ip, tmpip);
#line 121
                      count___0 ++;
#line 122
                      start = (u_char )((int )start + 1);
                      }
                    }
                    while_break___3: /* CIL Label */ ;
                    }
                  }
                }
              }
            }
          }
        }
        {
#line 127
        one = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
        }
#line 128
        goto while_continue;
      }
    }
#line 133
    if (*one) {
      {
#line 133
      tmp___11 = (int )inet_addr(one);
#line 133
      ip2 = (u_long )tmp___11;
      }
#line 133
      if (ip2 != 0xffffffffffffffffUL) {
        {
#line 133
        tmp___12 = strlen((char const   *)one);
        }
#line 133
        if (tmp___12 > 6UL) {
          {
#line 134
          ip1 = ip2;
#line 135
          tmp___8 = ip_ntoa(ip1);
#line 135
          sprintf((char */* __restrict  */)(tmpip), (char const   */* __restrict  */)"%s",
                  tmp___8);
#line 136
          add_parse_ip(& ip, tmpip);
#line 137
          count___0 ++;
          }
        } else {
#line 133
          goto _L___4;
        }
      } else {
#line 133
        goto _L___4;
      }
    } else {
      _L___4: /* CIL Label */ 
      {
#line 139
      tmp___10 = strstr((char const   *)one, ".");
      }
#line 139
      if (! tmp___10) {
        {
#line 140
        tmp___9 = atoi((char const   *)one);
#line 140
        sprintf((char */* __restrict  */)(tmpip), (char const   */* __restrict  */)"%d.%d.%d.%d",
                (int )((u_char )ip1), (int )((u_char )(ip1 >> 8)), (int )((u_char )(ip1 >> 16)),
                tmp___9);
#line 142
        add_parse_ip(& ip, tmpip);
#line 143
        count___0 ++;
        }
      }
    }
    {
#line 146
    one = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (ip);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/nat-1.0/parse_ip.c"
void add_parse_ip(struct ipstr **ip , char *new ) 
{ 
  struct ipstr *newitem ;
  struct ipstr *tmp ;
  void *tmp___0 ;

  {
  {
#line 160
  tmp___0 = malloc(sizeof(struct ipstr ));
#line 160
  newitem = (struct ipstr *)tmp___0;
#line 161
  newitem->name = strdup((char const   *)new);
#line 162
  newitem->next = (struct ipstr *)((void *)0);
  }
#line 164
  if (! *ip) {
#line 165
    *ip = newitem;
  } else {
#line 167
    tmp = *ip;
    {
#line 167
    while (1) {
      while_continue: /* CIL Label */ ;
#line 167
      if (! tmp->next) {
#line 167
        goto while_break;
      }
#line 167
      tmp = tmp->next;
    }
    while_break: /* CIL Label */ ;
    }
#line 168
    tmp->next = newitem;
  }
#line 171
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/nat-1.0/parse_ip.c"
static char b[18]  ;
#line 174 "/home/june/repo/benchmarks/collector/temp/nat-1.0/parse_ip.c"
char *ip_ntoa(u_long in ) 
{ 
  register char *p ;

  {
  {
#line 180
  p = (char *)(& in);
#line 182
  sprintf((char */* __restrict  */)(b), (char const   */* __restrict  */)"%d.%d.%d.%d",
          (int )*(p + 0) & 255, (int )*(p + 1) & 255, (int )*(p + 2) & 255, (int )*(p + 3) & 255);
  }
#line 183
  return (b);
}
}
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 379 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 598 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
int sys_select(fd_set *fds , struct timeval *tval ) ;
#line 623
int TvalDiff(struct timeval *tvalold , struct timeval *tvalnew ) ;
#line 678
int read_udp_socket(int fd , char *buf___0 , int len ) ;
#line 799
char *timestring(void) ;
#line 812
BOOL trim_string(char *s , char *front , char *back ) ;
#line 833
void GetTimeOfDay(struct timeval *tval ) ;
#line 174 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nameserv.h"
void free_nmb_packet(struct nmb_packet *nmb ) ;
#line 175
void free_packet(struct packet_struct *packet ) ;
#line 176
struct packet_struct *read_packet(int fd , enum packet_type packet_type ) ;
#line 177
BOOL send_packet(struct packet_struct *p ) ;
#line 178
struct packet_struct *receive_packet(int fd , enum packet_type type , int t ) ;
#line 179
void make_nmb_name(struct nmb_name *n , char *name___1 , int type , char *this_scope ) ;
#line 180
BOOL name_query(int fd , char *name___1 , int name_type___0 , BOOL bcast , BOOL recurse___0 ,
                struct in_addr to_ip , struct in_addr *ip , void (*fn)() ) ;
#line 183
BOOL name_status(int fd , char *name___1 , int name_type___0 , BOOL recurse___0 ,
                 struct in_addr to_ip , char *master , char *rname , void (*fn)() ) ;
#line 186
BOOL send_mailslot_reply(char *mailslot , int fd , char *buf___0 , int len , char *srcname ,
                         char *dstname , int src_type , int dest_type , struct in_addr dest_ip___0 ,
                         struct in_addr src_ip ) ;
#line 191
char *namestr(struct nmb_name *n ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static fstring tbuf  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
int num_good_sends  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
int num_good_receives  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static uint16 name_trn_id  =    (uint16 )0;
#line 47 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
BOOL CanRecurse  =    1;
#line 48
char scope[1024] ;
#line 53 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static BOOL handle_name_ptrs(unsigned char *ubuf , int *offset , int length , BOOL *got_pointer ,
                             int *ret___2 ) 
{ 
  int loop_count ;
  int tmp ;

  {
#line 56
  loop_count = 0;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! (((int )*(ubuf + *offset) & 192) == 192)) {
#line 58
      goto while_break;
    }
#line 59
    if (! *got_pointer) {
#line 59
      *ret___2 += 2;
    }
#line 60
    *got_pointer = 1;
#line 61
    *offset = (((int )*(ubuf + *offset) & -193) << 8) | (int )*(ubuf + (*offset + 1));
#line 62
    tmp = loop_count;
#line 62
    loop_count ++;
#line 62
    if (tmp == 10) {
#line 63
      return (0);
    } else
#line 62
    if (*offset < 0) {
#line 63
      return (0);
    } else
#line 62
    if (*offset > length - 2) {
#line 63
      return (0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 66
  return (1);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static int parse_nmb_name(char *inbuf___0 , int offset , int length , struct nmb_name *name___1 ) 
{ 
  int m ;
  int n ;
  unsigned char *ubuf ;
  int ret___2 ;
  BOOL got_pointer ;
  BOOL tmp ;
  unsigned char c1 ;
  unsigned char c2 ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  BOOL tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
#line 76
  n = 0;
#line 77
  ubuf = (unsigned char *)inbuf___0;
#line 78
  ret___2 = 0;
#line 79
  got_pointer = 0;
#line 81
  if (length - offset < 2) {
#line 81
    return (0);
  }
  {
#line 84
  tmp = handle_name_ptrs(ubuf, & offset, length, & got_pointer, & ret___2);
  }
#line 84
  if (! tmp) {
#line 84
    return (0);
  }
#line 86
  m = (int )*(ubuf + offset);
#line 88
  if (! m) {
#line 88
    return (0);
  }
#line 89
  if (m & 192) {
#line 89
    return (0);
  } else
#line 89
  if ((offset + m) + 2 > length) {
#line 89
    return (0);
  }
  {
#line 91
  bzero((void *)((char *)name___1), sizeof(*name___1));
  }
#line 94
  if (! got_pointer) {
#line 94
    ret___2 += m + 2;
  }
#line 95
  offset ++;
  {
#line 96
  while (1) {
    while_continue: /* CIL Label */ ;
#line 96
    if (! m) {
#line 96
      goto while_break;
    }
#line 98
    tmp___0 = offset;
#line 98
    offset ++;
#line 98
    c1 = (unsigned char )((int )*(ubuf + tmp___0) - 65);
#line 99
    tmp___1 = offset;
#line 99
    offset ++;
#line 99
    c2 = (unsigned char )((int )*(ubuf + tmp___1) - 65);
#line 100
    if ((int )c1 & 240) {
#line 100
      return (0);
    } else
#line 100
    if ((int )c2 & 240) {
#line 100
      return (0);
    }
#line 101
    tmp___2 = n;
#line 101
    n ++;
#line 101
    name___1->name[tmp___2] = (char )(((int )c1 << 4) | (int )c2);
#line 102
    m -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  name___1->name[n] = (char)0;
#line 106
  if (n == 16) {
#line 109
    name___1->name_type = (int )name___1->name[15];
#line 112
    name___1->name[15] = (char)0;
#line 113
    n = 14;
    {
#line 114
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 114
      if (n) {
#line 114
        if (! ((int )name___1->name[n] == 32)) {
#line 114
          goto while_break___0;
        }
      } else {
#line 114
        goto while_break___0;
      }
#line 114
      tmp___3 = n;
#line 114
      n --;
#line 114
      name___1->name[tmp___3] = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 118
  n = 0;
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 119
    m = (int )*(ubuf + offset);
#line 119
    if (! m) {
#line 119
      goto while_break___1;
    }
    {
#line 121
    tmp___4 = handle_name_ptrs(ubuf, & offset, length, & got_pointer, & ret___2);
    }
#line 121
    if (! tmp___4) {
#line 121
      return (0);
    }
#line 123
    if (! got_pointer) {
#line 123
      ret___2 += m + 1;
    }
#line 124
    if (n) {
#line 124
      tmp___5 = n;
#line 124
      n ++;
#line 124
      name___1->scope[tmp___5] = (char )'.';
    }
#line 125
    if ((m + 2) + offset > length) {
#line 125
      return (0);
    } else
#line 125
    if ((unsigned long )((n + m) + 1) > sizeof(name___1->scope)) {
#line 125
      return (0);
    }
#line 126
    offset ++;
    {
#line 127
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 127
      tmp___8 = m;
#line 127
      m --;
#line 127
      if (! tmp___8) {
#line 127
        goto while_break___2;
      }
#line 127
      tmp___6 = n;
#line 127
      n ++;
#line 127
      tmp___7 = offset;
#line 127
      offset ++;
#line 127
      name___1->scope[tmp___6] = (char )*(ubuf + tmp___7);
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 129
  tmp___9 = n;
#line 129
  n ++;
#line 129
  name___1->scope[tmp___9] = (char)0;
#line 131
  return (ret___2);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static int put_nmb_name(char *buf___0 , int offset , struct nmb_name *name___1 ) 
{ 
  int ret___2 ;
  int m ;
  fstring buf1 ;
  char *p ;
  size_t tmp ;
  size_t tmp___0 ;

  {
#line 149
  if ((int )name___1->name[0] == 42) {
    {
#line 151
    bzero((void *)(buf1), (size_t )20);
#line 152
    buf1[0] = (char )'*';
    }
  } else {
    {
#line 154
    sprintf((char */* __restrict  */)(buf1), (char const   */* __restrict  */)"%-15.15s%c",
            name___1->name, name___1->name_type);
    }
  }
#line 157
  *(buf___0 + offset) = (char)32;
#line 159
  ret___2 = 34;
#line 161
  m = 0;
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 161
    if (! (m < 16)) {
#line 161
      goto while_break;
    }
#line 162
    *(buf___0 + ((offset + 1) + 2 * m)) = (char )(65 + (((int )buf1[m] >> 4) & 15));
#line 163
    *(buf___0 + ((offset + 2) + 2 * m)) = (char )(65 + ((int )buf1[m] & 15));
#line 161
    m ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  offset += 33;
#line 167
  *(buf___0 + offset) = (char)0;
#line 169
  if (name___1->scope[0]) {
    {
#line 171
    tmp = strlen((char const   *)(name___1->scope));
#line 171
    ret___2 = (int )((size_t )ret___2 + (tmp + 1UL));
#line 172
    StrCpy(buf___0 + (offset + 1), name___1->scope);
#line 174
    p = buf___0 + (offset + 1);
    }
    {
#line 175
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 175
      p = strchr((char const   *)p, '.');
      }
#line 175
      if (! p) {
#line 175
        goto while_break___0;
      }
#line 176
      *(buf___0 + offset) = (char )(p - (buf___0 + offset));
#line 177
      offset += (int )*(buf___0 + offset);
#line 178
      p = buf___0 + (offset + 1);
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 180
    tmp___0 = strlen((char const   *)(buf___0 + (offset + 1)));
#line 180
    *(buf___0 + offset) = (char )tmp___0;
    }
  }
#line 183
  return (ret___2);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static int i  =    0;
#line 192 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static fstring ret___0[4]  ;
#line 189 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
char *namestr(struct nmb_name *n ) 
{ 
  char *p ;

  {
#line 193
  p = ret___0[i];
#line 195
  if (! n->scope[0]) {
    {
#line 196
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s(%x)",
            n->name, n->name_type);
    }
  } else {
    {
#line 198
    sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%s(%x).%s",
            n->name, n->name_type, n->scope);
    }
  }
#line 200
  i = (i + 1) % 4;
#line 201
  return (p);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static BOOL parse_alloc_res_rec(char *inbuf___0 , int *offset , int length , struct res_rec **recs ,
                                int count___0 ) 
{ 
  int i___0 ;
  void *tmp ;
  int l ;
  int tmp___0 ;

  {
  {
#line 212
  tmp = malloc(sizeof(*(*recs)) * (unsigned long )count___0);
#line 212
  *recs = (struct res_rec *)tmp;
  }
#line 213
  if (! *recs) {
#line 213
    return (0);
  }
  {
#line 215
  bzero((void *)*recs, sizeof(*(*recs)) * (unsigned long )count___0);
#line 217
  i___0 = 0;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i___0 < count___0)) {
#line 217
      goto while_break;
    }
    {
#line 218
    tmp___0 = parse_nmb_name(inbuf___0, *offset, length, & (*recs + i___0)->rr_name);
#line 218
    l = tmp___0;
#line 219
    *offset += l;
    }
#line 220
    if (! l) {
      {
#line 221
      free((void *)*recs);
      }
#line 222
      return (0);
    } else
#line 220
    if (*offset + 10 > length) {
      {
#line 221
      free((void *)*recs);
      }
#line 222
      return (0);
    }
#line 224
    (*recs + i___0)->rr_type = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + *offset) | ((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 1)) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + *offset) | ((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 1)) << 8)) >> 8) & 255U));
#line 225
    (*recs + i___0)->rr_class = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 2)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 2) + 1)) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 2)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 2) + 1)) << 8)) >> 8) & 255U));
#line 226
    (*recs + i___0)->ttl = (int )((((((((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 4)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 4) + 1)) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 4) + 2)) | ((unsigned int )*((unsigned char *)inbuf___0 + (((*offset + 4) + 2) + 1)) << 8)) << 16)) & 255U) << 8) | (((((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 4)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 4) + 1)) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 4) + 2)) | ((unsigned int )*((unsigned char *)inbuf___0 + (((*offset + 4) + 2) + 1)) << 8)) << 16)) >> 8) & 255U)) << 16) | (((((((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 4)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 4) + 1)) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 4) + 2)) | ((unsigned int )*((unsigned char *)inbuf___0 + (((*offset + 4) + 2) + 1)) << 8)) << 16)) >> 16) & 255U) << 8) | ((((((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 4)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 4) + 1)) << 8)) | (((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 4) + 2)) | ((unsigned int )*((unsigned char *)inbuf___0 + (((*offset + 4) + 2) + 1)) << 8)) << 16)) >> 16) >> 8) & 255U)));
#line 227
    (*recs + i___0)->rdlength = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 8)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 8) + 1)) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + (*offset + 8)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((*offset + 8) + 1)) << 8)) >> 8) & 255U));
#line 228
    *offset += 10;
#line 229
    if ((unsigned long )(*recs + i___0)->rdlength > sizeof((*recs + i___0)->rdata)) {
      {
#line 231
      free((void *)*recs);
      }
#line 232
      return (0);
    } else
#line 229
    if (*offset + (*recs + i___0)->rdlength > length) {
      {
#line 231
      free((void *)*recs);
      }
#line 232
      return (0);
    }
    {
#line 234
    memcpy((void */* __restrict  */)((*recs + i___0)->rdata), (void const   */* __restrict  */)(inbuf___0 + *offset),
           (size_t )(*recs + i___0)->rdlength);
#line 235
    *offset += (*recs + i___0)->rdlength;
#line 217
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return (1);
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static int put_res_rec(char *buf___0 , int offset , struct res_rec *recs , int count___0 ) 
{ 
  int ret___2 ;
  int i___0 ;
  int l ;
  int tmp ;

  {
#line 245
  ret___2 = 0;
#line 248
  i___0 = 0;
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (! (i___0 < count___0)) {
#line 248
      goto while_break;
    }
    {
#line 249
    tmp = put_nmb_name(buf___0, offset, & (recs + i___0)->rr_name);
#line 249
    l = tmp;
#line 250
    offset += l;
#line 251
    ret___2 += l;
#line 252
    *((unsigned char *)buf___0 + offset) = (unsigned char )((int )((uint16 )((((recs + i___0)->rr_type & 255) << 8) | (((recs + i___0)->rr_type >> 8) & 255))) & 255);
#line 252
    *((unsigned char *)buf___0 + (offset + 1)) = (unsigned char )((int )((uint16 )((((recs + i___0)->rr_type & 255) << 8) | (((recs + i___0)->rr_type >> 8) & 255))) >> 8);
#line 253
    *((unsigned char *)buf___0 + (offset + 2)) = (unsigned char )((int )((uint16 )((((recs + i___0)->rr_class & 255) << 8) | (((recs + i___0)->rr_class >> 8) & 255))) & 255);
#line 253
    *((unsigned char *)buf___0 + ((offset + 2) + 1)) = (unsigned char )((int )((uint16 )((((recs + i___0)->rr_class & 255) << 8) | (((recs + i___0)->rr_class >> 8) & 255))) >> 8);
#line 254
    *((unsigned char *)buf___0 + (offset + 4)) = (unsigned char )(((uint32 )((((((recs + i___0)->ttl & 255) << 8) | (((recs + i___0)->ttl >> 8) & 255)) << 16) | (((((recs + i___0)->ttl >> 16) & 255) << 8) | ((((recs + i___0)->ttl >> 16) >> 8) & 255))) & 65535U) & 255U);
#line 254
    *((unsigned char *)buf___0 + ((offset + 4) + 1)) = (unsigned char )(((uint32 )((((((recs + i___0)->ttl & 255) << 8) | (((recs + i___0)->ttl >> 8) & 255)) << 16) | (((((recs + i___0)->ttl >> 16) & 255) << 8) | ((((recs + i___0)->ttl >> 16) >> 8) & 255))) & 65535U) >> 8);
#line 254
    *((unsigned char *)buf___0 + ((offset + 4) + 2)) = (unsigned char )(((uint32 )((((((recs + i___0)->ttl & 255) << 8) | (((recs + i___0)->ttl >> 8) & 255)) << 16) | (((((recs + i___0)->ttl >> 16) & 255) << 8) | ((((recs + i___0)->ttl >> 16) >> 8) & 255))) >> 16) & 255U);
#line 254
    *((unsigned char *)buf___0 + (((offset + 4) + 2) + 1)) = (unsigned char )(((uint32 )((((((recs + i___0)->ttl & 255) << 8) | (((recs + i___0)->ttl >> 8) & 255)) << 16) | (((((recs + i___0)->ttl >> 16) & 255) << 8) | ((((recs + i___0)->ttl >> 16) >> 8) & 255))) >> 16) >> 8);
#line 255
    *((unsigned char *)buf___0 + (offset + 8)) = (unsigned char )((int )((uint16 )((((recs + i___0)->rdlength & 255) << 8) | (((recs + i___0)->rdlength >> 8) & 255))) & 255);
#line 255
    *((unsigned char *)buf___0 + ((offset + 8) + 1)) = (unsigned char )((int )((uint16 )((((recs + i___0)->rdlength & 255) << 8) | (((recs + i___0)->rdlength >> 8) & 255))) >> 8);
#line 256
    memcpy((void */* __restrict  */)((buf___0 + offset) + 10), (void const   */* __restrict  */)((recs + i___0)->rdata),
           (size_t )(recs + i___0)->rdlength);
#line 257
    offset += 10 + (recs + i___0)->rdlength;
#line 258
    ret___2 += 10 + (recs + i___0)->rdlength;
#line 248
    i___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return (ret___2);
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static BOOL parse_dgram(char *inbuf___0 , int length , struct dgram_packet *dgram ) 
{ 
  int offset ;
  int flags ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 275
  bzero((void *)((char *)dgram), sizeof(*dgram));
  }
#line 277
  if (length < 14) {
#line 277
    return (0);
  }
#line 279
  dgram->header.msg_type = (int )*((unsigned char *)inbuf___0 + 0);
#line 280
  flags = (int )*((unsigned char *)inbuf___0 + 1);
#line 281
  dgram->header.flags.node_type = (enum node_type )((flags >> 2) & 3);
#line 282
  if (flags & 1) {
#line 282
    dgram->header.flags.more = 1;
  }
#line 283
  if (flags & 2) {
#line 283
    dgram->header.flags.first = 1;
  }
  {
#line 284
  dgram->header.dgm_id = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 2) | ((unsigned int )*((unsigned char *)inbuf___0 + 3) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 2) | ((unsigned int )*((unsigned char *)inbuf___0 + 3) << 8)) >> 8) & 255U));
#line 285
  putip((void *)((char *)(& dgram->header.source_ip)), (void *)(inbuf___0 + 4));
#line 286
  dgram->header.source_port = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 8) | ((unsigned int )*((unsigned char *)inbuf___0 + 9) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 8) | ((unsigned int )*((unsigned char *)inbuf___0 + 9) << 8)) >> 8) & 255U));
#line 287
  dgram->header.dgm_length = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 10) | ((unsigned int )*((unsigned char *)inbuf___0 + 11) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 10) | ((unsigned int )*((unsigned char *)inbuf___0 + 11) << 8)) >> 8) & 255U));
#line 288
  dgram->header.packet_offset = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 12) | ((unsigned int )*((unsigned char *)inbuf___0 + 13) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 12) | ((unsigned int )*((unsigned char *)inbuf___0 + 13) << 8)) >> 8) & 255U));
#line 290
  offset = 14;
  }
#line 292
  if (dgram->header.msg_type == 16) {
    {
#line 295
    tmp = parse_nmb_name(inbuf___0, offset, length, & dgram->source_name);
#line 295
    offset += tmp;
#line 296
    tmp___0 = parse_nmb_name(inbuf___0, offset, length, & dgram->dest_name);
#line 296
    offset += tmp___0;
    }
  } else
#line 292
  if (dgram->header.msg_type == 17) {
    {
#line 295
    tmp = parse_nmb_name(inbuf___0, offset, length, & dgram->source_name);
#line 295
    offset += tmp;
#line 296
    tmp___0 = parse_nmb_name(inbuf___0, offset, length, & dgram->dest_name);
#line 296
    offset += tmp___0;
    }
  } else
#line 292
  if (dgram->header.msg_type == 18) {
    {
#line 295
    tmp = parse_nmb_name(inbuf___0, offset, length, & dgram->source_name);
#line 295
    offset += tmp;
#line 296
    tmp___0 = parse_nmb_name(inbuf___0, offset, length, & dgram->dest_name);
#line 296
    offset += tmp___0;
    }
  }
#line 299
  if (offset >= length) {
#line 300
    return (0);
  } else
#line 299
  if ((unsigned long )(length - offset) > sizeof(dgram->data)) {
#line 300
    return (0);
  }
  {
#line 302
  dgram->datasize = length - offset;
#line 303
  memcpy((void */* __restrict  */)(dgram->data), (void const   */* __restrict  */)(inbuf___0 + offset),
         (size_t )dgram->datasize);
  }
#line 305
  return (1);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static BOOL parse_nmb(char *inbuf___0 , int length , struct nmb_packet *nmb ) 
{ 
  int nm_flags ;
  int offset ;
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 317
  bzero((void *)((char *)nmb), sizeof(*nmb));
  }
#line 319
  if (length < 12) {
#line 319
    return (0);
  }
#line 322
  nmb->header.name_trn_id = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 0) | ((unsigned int )*((unsigned char *)inbuf___0 + 1) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 0) | ((unsigned int )*((unsigned char *)inbuf___0 + 1) << 8)) >> 8) & 255U));
#line 323
  nmb->header.opcode = ((int )*((unsigned char *)inbuf___0 + 2) >> 3) & 15;
#line 324
  if (((int )*((unsigned char *)inbuf___0 + 2) >> 7) & 1) {
#line 324
    nmb->header.response = 1;
  } else {
#line 324
    nmb->header.response = 0;
  }
#line 325
  nm_flags = (((int )*((unsigned char *)inbuf___0 + 2) & 7) << 4) + ((int )*((unsigned char *)inbuf___0 + 3) >> 4);
#line 326
  if (nm_flags & 1) {
#line 326
    nmb->header.nm_flags.bcast = 1;
  } else {
#line 326
    nmb->header.nm_flags.bcast = 0;
  }
#line 327
  if (nm_flags & 8) {
#line 327
    nmb->header.nm_flags.recursion_available = 1;
  } else {
#line 327
    nmb->header.nm_flags.recursion_available = 0;
  }
#line 328
  if (nm_flags & 16) {
#line 328
    nmb->header.nm_flags.recursion_desired = 1;
  } else {
#line 328
    nmb->header.nm_flags.recursion_desired = 0;
  }
#line 329
  if (nm_flags & 32) {
#line 329
    nmb->header.nm_flags.trunc = 1;
  } else {
#line 329
    nmb->header.nm_flags.trunc = 0;
  }
#line 330
  if (nm_flags & 64) {
#line 330
    nmb->header.nm_flags.authoritative = 1;
  } else {
#line 330
    nmb->header.nm_flags.authoritative = 0;
  }
#line 331
  nmb->header.rcode = (int )*((unsigned char *)inbuf___0 + 3) & 15;
#line 332
  nmb->header.qdcount = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 4) | ((unsigned int )*((unsigned char *)inbuf___0 + 5) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 4) | ((unsigned int )*((unsigned char *)inbuf___0 + 5) << 8)) >> 8) & 255U));
#line 333
  nmb->header.ancount = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 6) | ((unsigned int )*((unsigned char *)inbuf___0 + 7) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 6) | ((unsigned int )*((unsigned char *)inbuf___0 + 7) << 8)) >> 8) & 255U));
#line 334
  nmb->header.nscount = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 8) | ((unsigned int )*((unsigned char *)inbuf___0 + 9) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 8) | ((unsigned int )*((unsigned char *)inbuf___0 + 9) << 8)) >> 8) & 255U));
#line 335
  nmb->header.arcount = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + 10) | ((unsigned int )*((unsigned char *)inbuf___0 + 11) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + 10) | ((unsigned int )*((unsigned char *)inbuf___0 + 11) << 8)) >> 8) & 255U));
#line 337
  if (nmb->header.qdcount) {
    {
#line 338
    offset = parse_nmb_name(inbuf___0, 12, length, & nmb->question.question_name);
    }
#line 339
    if (! offset) {
#line 339
      return (0);
    }
#line 341
    if (length - (12 + offset) < 4) {
#line 341
      return (0);
    }
#line 342
    nmb->question.question_type = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + (12 + offset)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((12 + offset) + 1)) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + (12 + offset)) | ((unsigned int )*((unsigned char *)inbuf___0 + ((12 + offset) + 1)) << 8)) >> 8) & 255U));
#line 343
    nmb->question.question_class = (int )(((((unsigned int )*((unsigned char *)inbuf___0 + ((12 + offset) + 2)) | ((unsigned int )*((unsigned char *)inbuf___0 + (((12 + offset) + 2) + 1)) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)inbuf___0 + ((12 + offset) + 2)) | ((unsigned int )*((unsigned char *)inbuf___0 + (((12 + offset) + 2) + 1)) << 8)) >> 8) & 255U));
#line 345
    offset += 16;
  } else {
#line 347
    offset = 12;
  }
#line 351
  if (nmb->header.ancount) {
    {
#line 351
    tmp = parse_alloc_res_rec(inbuf___0, & offset, length, & nmb->answers, nmb->header.ancount);
    }
#line 351
    if (! tmp) {
#line 354
      return (0);
    }
  }
#line 356
  if (nmb->header.nscount) {
    {
#line 356
    tmp___0 = parse_alloc_res_rec(inbuf___0, & offset, length, & nmb->nsrecs, nmb->header.nscount);
    }
#line 356
    if (! tmp___0) {
#line 359
      return (0);
    }
  }
#line 361
  if (nmb->header.arcount) {
    {
#line 361
    tmp___1 = parse_alloc_res_rec(inbuf___0, & offset, length, & nmb->additional,
                                  nmb->header.arcount);
    }
#line 361
    if (! tmp___1) {
#line 364
      return (0);
    }
  }
#line 366
  return (1);
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
void free_nmb_packet(struct nmb_packet *nmb ) 
{ 


  {
#line 374
  if (nmb->answers) {
    {
#line 374
    free((void *)nmb->answers);
    }
  }
#line 375
  if (nmb->nsrecs) {
    {
#line 375
    free((void *)nmb->nsrecs);
    }
  }
#line 376
  if (nmb->additional) {
    {
#line 376
    free((void *)nmb->additional);
    }
  }
#line 377
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
void free_packet(struct packet_struct *packet ) 
{ 


  {
#line 384
  if ((unsigned int )packet->packet_type == 0U) {
    {
#line 385
    free_nmb_packet(& packet->packet.nmb);
    }
  }
  {
#line 386
  free((void *)packet);
  }
#line 387
  return;
}
}
#line 395
struct in_addr lastip ;
#line 396
int lastport ;
#line 393 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
struct packet_struct *read_packet(int fd , enum packet_type packet_type ) 
{ 
  struct packet_struct *packet ;
  char buf___0[576] ;
  int length ;
  BOOL ok ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 400
  ok = 0;
#line 402
  length = read_udp_socket(fd, buf___0, (int )sizeof(buf___0));
  }
#line 403
  if (length < 12) {
#line 403
    return ((struct packet_struct *)((void *)0));
  }
  {
#line 405
  tmp = malloc(sizeof(*packet));
#line 405
  packet = (struct packet_struct *)tmp;
  }
#line 406
  if (! packet) {
#line 406
    return ((struct packet_struct *)((void *)0));
  }
  {
#line 408
  packet->next = (struct packet_struct *)((void *)0);
#line 409
  packet->prev = (struct packet_struct *)((void *)0);
#line 410
  packet->ip = lastip;
#line 411
  packet->port = lastport;
#line 412
  packet->fd = fd;
#line 413
  packet->timestamp = time((time_t *)((void *)0));
#line 414
  packet->packet_type = packet_type;
  }
  {
#line 417
  if ((unsigned int )packet_type == 0U) {
#line 417
    goto case_0;
  }
#line 421
  if ((unsigned int )packet_type == 1U) {
#line 421
    goto case_1;
  }
#line 415
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 418
  ok = parse_nmb(buf___0, length, & packet->packet.nmb);
  }
#line 419
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 422
  ok = parse_dgram(buf___0, length, & packet->packet.dgram);
  }
#line 423
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 425
  if (! ok) {
    {
#line 426
    free((void *)packet);
    }
#line 427
    return ((struct packet_struct *)((void *)0));
  }
#line 430
  num_good_receives ++;
#line 432
  if (DEBUGLEVEL >= 4) {
    {
#line 432
    tmp___0 = inet_ntoa(packet->ip);
#line 432
    tmp___1 = timestring();
#line 432
    Debug1((char *)"%s received a packet of len %d from (%s) port %d\n", tmp___1,
           length, tmp___0, packet->port);
    }
  }
#line 435
  return (packet);
}
}
#line 442 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static BOOL send_udp(int fd , char *buf___0 , int len , struct in_addr ip , int port ) 
{ 
  BOOL ret___2 ;
  struct sockaddr_in sock_out ;
  char *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 448
  bzero((void *)((char *)(& sock_out)), sizeof(sock_out));
#line 449
  putip((void *)((char *)(& sock_out.sin_addr)), (void *)((char *)(& ip)));
#line 450
  sock_out.sin_port = htons((uint16_t )port);
#line 451
  sock_out.sin_family = (sa_family_t )2;
  }
#line 453
  if (DEBUGLEVEL >= 4) {
    {
#line 453
    tmp = inet_ntoa(ip);
#line 453
    tmp___0 = timestring();
#line 453
    Debug1((char *)"%s sending a packet of len %d to (%s) on port %d\n", tmp___0,
           len, tmp, port);
    }
  }
  {
#line 456
  tmp___1 = sendto(fd, (void const   *)buf___0, (size_t )len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& sock_out)),
                   (socklen_t )sizeof(sock_out));
#line 456
  ret___2 = tmp___1 >= 0L;
  }
#line 459
  if (! ret___2) {
#line 460
    if (DEBUGLEVEL >= 0) {
      {
#line 460
      tmp___2 = __errno_location();
#line 460
      tmp___3 = strerror(*tmp___2);
#line 460
      tmp___4 = inet_ntoa(ip);
#line 460
      Debug1((char *)"Packet send failed to %s(%d) ERRNO=%s\n", tmp___4, port, tmp___3);
      }
    }
  }
#line 463
  if (ret___2) {
#line 464
    num_good_sends ++;
  }
#line 466
  return (ret___2);
}
}
#line 476 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static int build_dgram(char *buf___0 , struct packet_struct *p ) 
{ 
  struct dgram_packet *dgram ;
  unsigned char *ubuf ;
  int offset ;
  int tmp ;
  int tmp___0 ;

  {
#line 478
  dgram = & p->packet.dgram;
#line 479
  ubuf = (unsigned char *)buf___0;
#line 480
  offset = 0;
#line 483
  *(ubuf + 0) = (unsigned char )dgram->header.msg_type;
#line 484
  *(ubuf + 1) = (unsigned char )((int )dgram->header.flags.node_type << 2);
#line 485
  if (dgram->header.flags.more) {
#line 485
    *(ubuf + 1) = (unsigned char )((int )*(ubuf + 1) | 1);
  }
#line 486
  if (dgram->header.flags.first) {
#line 486
    *(ubuf + 1) = (unsigned char )((int )*(ubuf + 1) | 2);
  }
  {
#line 487
  *(ubuf + 2) = (unsigned char )((int )((uint16 )(((dgram->header.dgm_id & 255) << 8) | ((dgram->header.dgm_id >> 8) & 255))) & 255);
#line 487
  *(ubuf + 3) = (unsigned char )((int )((uint16 )(((dgram->header.dgm_id & 255) << 8) | ((dgram->header.dgm_id >> 8) & 255))) >> 8);
#line 488
  putip((void *)(ubuf + 4), (void *)((char *)(& dgram->header.source_ip)));
#line 489
  *(ubuf + 8) = (unsigned char )((int )((uint16 )(((dgram->header.source_port & 255) << 8) | ((dgram->header.source_port >> 8) & 255))) & 255);
#line 489
  *(ubuf + 9) = (unsigned char )((int )((uint16 )(((dgram->header.source_port & 255) << 8) | ((dgram->header.source_port >> 8) & 255))) >> 8);
#line 490
  *(ubuf + 12) = (unsigned char )((int )((uint16 )(((dgram->header.packet_offset & 255) << 8) | ((dgram->header.packet_offset >> 8) & 255))) & 255);
#line 490
  *(ubuf + 13) = (unsigned char )((int )((uint16 )(((dgram->header.packet_offset & 255) << 8) | ((dgram->header.packet_offset >> 8) & 255))) >> 8);
#line 492
  offset = 14;
  }
#line 494
  if (dgram->header.msg_type == 16) {
    {
#line 497
    tmp = put_nmb_name((char *)ubuf, offset, & dgram->source_name);
#line 497
    offset += tmp;
#line 498
    tmp___0 = put_nmb_name((char *)ubuf, offset, & dgram->dest_name);
#line 498
    offset += tmp___0;
    }
  } else
#line 494
  if (dgram->header.msg_type == 17) {
    {
#line 497
    tmp = put_nmb_name((char *)ubuf, offset, & dgram->source_name);
#line 497
    offset += tmp;
#line 498
    tmp___0 = put_nmb_name((char *)ubuf, offset, & dgram->dest_name);
#line 498
    offset += tmp___0;
    }
  } else
#line 494
  if (dgram->header.msg_type == 18) {
    {
#line 497
    tmp = put_nmb_name((char *)ubuf, offset, & dgram->source_name);
#line 497
    offset += tmp;
#line 498
    tmp___0 = put_nmb_name((char *)ubuf, offset, & dgram->dest_name);
#line 498
    offset += tmp___0;
    }
  }
  {
#line 501
  memcpy((void */* __restrict  */)(ubuf + offset), (void const   */* __restrict  */)(dgram->data),
         (size_t )dgram->datasize);
#line 502
  offset += dgram->datasize;
#line 505
  dgram->header.dgm_length = offset;
#line 506
  *(ubuf + 10) = (unsigned char )((int )((uint16 )(((dgram->header.dgm_length & 255) << 8) | ((dgram->header.dgm_length >> 8) & 255))) & 255);
#line 506
  *(ubuf + 11) = (unsigned char )((int )((uint16 )(((dgram->header.dgm_length & 255) << 8) | ((dgram->header.dgm_length >> 8) & 255))) >> 8);
  }
#line 508
  return (offset);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
void make_nmb_name(struct nmb_name *n , char *name___1 , int type , char *this_scope ) 
{ 


  {
  {
#line 516
  StrCpy(n->name, name___1);
#line 517
  strupper(n->name);
#line 518
  n->name_type = type;
#line 519
  StrCpy(n->scope, this_scope);
  }
#line 520
  return;
}
}
#line 531 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static int build_nmb(char *buf___0 , struct packet_struct *p ) 
{ 
  struct nmb_packet *nmb ;
  unsigned char *ubuf ;
  int offset ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 533
  nmb = & p->packet.nmb;
#line 534
  ubuf = (unsigned char *)buf___0;
#line 535
  offset = 0;
#line 538
  *(ubuf + offset) = (unsigned char )((int )((uint16 )(((nmb->header.name_trn_id & 255) << 8) | ((nmb->header.name_trn_id >> 8) & 255))) & 255);
#line 538
  *(ubuf + (offset + 1)) = (unsigned char )((int )((uint16 )(((nmb->header.name_trn_id & 255) << 8) | ((nmb->header.name_trn_id >> 8) & 255))) >> 8);
#line 539
  *(ubuf + (offset + 2)) = (unsigned char )((nmb->header.opcode & 15) << 3);
#line 540
  if (nmb->header.response) {
#line 540
    *(ubuf + (offset + 2)) = (unsigned char )((int )*(ubuf + (offset + 2)) | (1 << 7));
  }
#line 541
  if (nmb->header.nm_flags.authoritative) {
#line 541
    *(ubuf + (offset + 2)) = (unsigned char )((int )*(ubuf + (offset + 2)) | 4);
  }
#line 542
  if (nmb->header.nm_flags.trunc) {
#line 542
    *(ubuf + (offset + 2)) = (unsigned char )((int )*(ubuf + (offset + 2)) | 2);
  }
#line 543
  if (nmb->header.nm_flags.recursion_desired) {
#line 543
    *(ubuf + (offset + 2)) = (unsigned char )((int )*(ubuf + (offset + 2)) | 1);
  }
#line 544
  if (nmb->header.nm_flags.recursion_available) {
#line 544
    *(ubuf + (offset + 3)) = (unsigned char )((int )*(ubuf + (offset + 3)) | 128);
  }
#line 545
  if (nmb->header.nm_flags.bcast) {
#line 545
    *(ubuf + (offset + 3)) = (unsigned char )((int )*(ubuf + (offset + 3)) | 16);
  }
#line 546
  *(ubuf + (offset + 3)) = (unsigned char )((int )*(ubuf + (offset + 3)) | (nmb->header.rcode & 15));
#line 547
  *(ubuf + (offset + 4)) = (unsigned char )((int )((uint16 )(((nmb->header.qdcount & 255) << 8) | ((nmb->header.qdcount >> 8) & 255))) & 255);
#line 547
  *(ubuf + ((offset + 4) + 1)) = (unsigned char )((int )((uint16 )(((nmb->header.qdcount & 255) << 8) | ((nmb->header.qdcount >> 8) & 255))) >> 8);
#line 548
  *(ubuf + (offset + 6)) = (unsigned char )((int )((uint16 )(((nmb->header.ancount & 255) << 8) | ((nmb->header.ancount >> 8) & 255))) & 255);
#line 548
  *(ubuf + ((offset + 6) + 1)) = (unsigned char )((int )((uint16 )(((nmb->header.ancount & 255) << 8) | ((nmb->header.ancount >> 8) & 255))) >> 8);
#line 549
  *(ubuf + (offset + 8)) = (unsigned char )((int )((uint16 )(((nmb->header.nscount & 255) << 8) | ((nmb->header.nscount >> 8) & 255))) & 255);
#line 549
  *(ubuf + ((offset + 8) + 1)) = (unsigned char )((int )((uint16 )(((nmb->header.nscount & 255) << 8) | ((nmb->header.nscount >> 8) & 255))) >> 8);
#line 550
  *(ubuf + (offset + 10)) = (unsigned char )((int )((uint16 )(((nmb->header.arcount & 255) << 8) | ((nmb->header.arcount >> 8) & 255))) & 255);
#line 550
  *(ubuf + ((offset + 10) + 1)) = (unsigned char )((int )((uint16 )(((nmb->header.arcount & 255) << 8) | ((nmb->header.arcount >> 8) & 255))) >> 8);
#line 552
  offset += 12;
#line 553
  if (nmb->header.qdcount) {
    {
#line 555
    tmp = put_nmb_name((char *)ubuf, offset, & nmb->question.question_name);
#line 555
    offset += tmp;
#line 556
    *(ubuf + offset) = (unsigned char )((int )((uint16 )(((nmb->question.question_type & 255) << 8) | ((nmb->question.question_type >> 8) & 255))) & 255);
#line 556
    *(ubuf + (offset + 1)) = (unsigned char )((int )((uint16 )(((nmb->question.question_type & 255) << 8) | ((nmb->question.question_type >> 8) & 255))) >> 8);
#line 557
    *(ubuf + (offset + 2)) = (unsigned char )((int )((uint16 )(((nmb->question.question_class & 255) << 8) | ((nmb->question.question_class >> 8) & 255))) & 255);
#line 557
    *(ubuf + ((offset + 2) + 1)) = (unsigned char )((int )((uint16 )(((nmb->question.question_class & 255) << 8) | ((nmb->question.question_class >> 8) & 255))) >> 8);
#line 558
    offset += 4;
    }
  }
#line 561
  if (nmb->header.ancount) {
    {
#line 562
    tmp___0 = put_res_rec((char *)ubuf, offset, nmb->answers, nmb->header.ancount);
#line 562
    offset += tmp___0;
    }
  }
#line 565
  if (nmb->header.nscount) {
    {
#line 566
    tmp___1 = put_res_rec((char *)ubuf, offset, nmb->nsrecs, nmb->header.nscount);
#line 566
    offset += tmp___1;
    }
  }
#line 569
  if (nmb->header.arcount) {
    {
#line 570
    tmp___2 = put_res_rec((char *)ubuf, offset, nmb->additional, nmb->header.arcount);
#line 570
    offset += tmp___2;
    }
  }
#line 573
  return (offset);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
BOOL send_packet(struct packet_struct *p ) 
{ 
  char buf___0[1024] ;
  int len ;
  BOOL tmp ;

  {
  {
#line 583
  len = 0;
#line 585
  bzero((void *)(buf___0), sizeof(buf___0));
  }
  {
#line 589
  if ((unsigned int )p->packet_type == 0U) {
#line 589
    goto case_0;
  }
#line 593
  if ((unsigned int )p->packet_type == 1U) {
#line 593
    goto case_1;
  }
#line 587
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 590
  len = build_nmb(buf___0, p);
  }
#line 591
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 594
  len = build_dgram(buf___0, p);
  }
#line 595
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 598
  if (! len) {
#line 598
    return (0);
  }
  {
#line 600
  tmp = send_udp(p->fd, buf___0, len, p->ip, p->port);
  }
#line 600
  return (tmp);
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
struct packet_struct *receive_packet(int fd , enum packet_type type , int t ) 
{ 
  fd_set fds ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  struct packet_struct *tmp ;

  {
  {
#line 612
  while (1) {
    while_continue: /* CIL Label */ ;
#line 612
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 612
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 613
  fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 614
  timeout.tv_sec = (__time_t )(t / 1000);
#line 615
  timeout.tv_usec = (__suseconds_t )(1000 * (t % 1000));
#line 617
  sys_select(& fds, & timeout);
  }
#line 619
  if ((fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 620
    tmp = read_packet(fd, type);
    }
#line 620
    return (tmp);
  }
#line 622
  return ((struct packet_struct *)((void *)0));
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static void interpret_node_status(char *p , char *master , char *rname ) 
{ 
  int level ;
  int tmp ;
  int numnames ;
  char qname[17] ;
  int type ;
  fstring flags ;
  int tmp___0 ;

  {
#line 631
  if (master) {
#line 631
    tmp = 4;
  } else
#line 631
  if (rname) {
#line 631
    tmp = 4;
  } else {
#line 631
    tmp = 0;
  }
#line 631
  level = tmp;
#line 632
  numnames = (int )*((unsigned char *)p + 0);
#line 633
  if (DEBUGLEVEL >= level) {
    {
#line 633
    Debug1((char *)"received %d names\n", numnames);
    }
  }
#line 635
  if (rname) {
#line 635
    *rname = (char)0;
  }
#line 636
  if (master) {
#line 636
    *master = (char)0;
  }
#line 638
  p ++;
  {
#line 639
  while (1) {
    while_continue: /* CIL Label */ ;
#line 639
    tmp___0 = numnames;
#line 639
    numnames --;
#line 639
    if (! tmp___0) {
#line 639
      goto while_break;
    }
    {
#line 644
    flags[0] = (char)0;
#line 645
    StrnCpy(qname, (char const   *)p, 15);
#line 646
    type = (int )*((unsigned char *)p + 15);
#line 647
    p += 16;
    }
#line 649
    if ((int )*(p + 0) & 128) {
      {
#line 649
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<GROUP> ");
      }
    }
#line 650
    if (((int )*(p + 0) & 96) == 0) {
      {
#line 650
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"B ");
      }
    }
#line 651
    if (((int )*(p + 0) & 96) == 1) {
      {
#line 651
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"P ");
      }
    }
#line 652
    if (((int )*(p + 0) & 96) == 2) {
      {
#line 652
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"M ");
      }
    }
#line 653
    if (((int )*(p + 0) & 96) == 3) {
      {
#line 653
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"_ ");
      }
    }
#line 654
    if ((int )*(p + 0) & 16) {
      {
#line 654
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<DEREGISTERING> ");
      }
    }
#line 655
    if ((int )*(p + 0) & 8) {
      {
#line 655
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<CONFLICT> ");
      }
    }
#line 656
    if ((int )*(p + 0) & 4) {
      {
#line 656
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<ACTIVE> ");
      }
    }
#line 657
    if ((int )*(p + 0) & 2) {
      {
#line 657
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<PERMANENT> ");
      }
    }
#line 659
    if (master) {
#line 659
      if (! *master) {
#line 659
        if (type == 29) {
          {
#line 660
          StrnCpy(master, (char const   *)(qname), 15);
#line 661
          trim_string(master, (char *)((void *)0), (char *)" ");
          }
        }
      }
    }
#line 664
    if (rname) {
#line 664
      if (! *rname) {
#line 664
        if (type == 32) {
#line 664
          if (! ((int )*(p + 0) & 128)) {
            {
#line 665
            StrnCpy(rname, (char const   *)(qname), 15);
#line 666
            trim_string(rname, (char *)((void *)0), (char *)" ");
            }
          }
        }
      }
    }
#line 669
    if (DEBUGLEVEL >= level) {
      {
#line 669
      Debug1((char *)"\t%s (type=0x%x)\t%s\n", qname, type, flags);
      }
    }
#line 670
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 672
  if (DEBUGLEVEL >= level) {
    {
#line 672
    Debug1((char *)"num_good_sends=%d num_good_receives=%d\n", ((unsigned int )*((unsigned char *)p + 20) | ((unsigned int )*((unsigned char *)p + 21) << 8)) | (((unsigned int )*((unsigned char *)p + 22) | ((unsigned int )*((unsigned char *)p + 23) << 8)) << 16),
           ((unsigned int )*((unsigned char *)p + 24) | ((unsigned int )*((unsigned char *)p + 25) << 8)) | (((unsigned int )*((unsigned char *)p + 26) | ((unsigned int )*((unsigned char *)p + 27) << 8)) << 16));
    }
  }
#line 674
  return;
}
}
#line 682 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
BOOL name_status(int fd , char *name___1 , int name_type___0 , BOOL recurse___0 ,
                 struct in_addr to_ip , char *master , char *rname , void (*fn)() ) 
{ 
  BOOL found ;
  int retries ;
  int retry_time ;
  struct timeval tval ;
  struct packet_struct p ;
  struct packet_struct *p2 ;
  struct nmb_packet *nmb ;
  time_t tmp ;
  __pid_t tmp___0 ;
  BOOL tmp___1 ;
  struct timeval tval2 ;
  BOOL tmp___2 ;
  int tmp___3 ;
  struct nmb_packet *nmb2 ;

  {
  {
#line 686
  found = 0;
#line 687
  retries = 2;
#line 688
  retry_time = 5000;
#line 692
  nmb = & p.packet.nmb;
#line 694
  bzero((void *)((char *)(& p)), sizeof(p));
  }
#line 696
  if (! name_trn_id) {
    {
#line 696
    tmp = time((time_t *)((void *)0));
#line 696
    tmp___0 = getpid();
#line 696
    name_trn_id = (uint16 )(tmp % 32767L + (long )((unsigned int )tmp___0 % 100U));
    }
  }
  {
#line 698
  name_trn_id = (uint16 )((unsigned int )((int )name_trn_id + 1) % 32767U);
#line 700
  nmb->header.name_trn_id = (int )name_trn_id;
#line 701
  nmb->header.opcode = 0;
#line 702
  nmb->header.response = 0;
#line 703
  nmb->header.nm_flags.bcast = 0;
#line 704
  nmb->header.nm_flags.recursion_available = CanRecurse;
#line 705
  nmb->header.nm_flags.recursion_desired = recurse___0;
#line 706
  nmb->header.nm_flags.trunc = 0;
#line 707
  nmb->header.nm_flags.authoritative = 0;
#line 708
  nmb->header.rcode = 0;
#line 709
  nmb->header.qdcount = 1;
#line 710
  nmb->header.ancount = 0;
#line 711
  nmb->header.nscount = 0;
#line 712
  nmb->header.arcount = 0;
#line 714
  make_nmb_name(& nmb->question.question_name, name___1, name_type___0, scope);
#line 716
  nmb->question.question_type = 33;
#line 717
  nmb->question.question_class = 1;
#line 719
  p.ip = to_ip;
#line 720
  p.port = 137;
#line 721
  p.fd = fd;
#line 722
  p.timestamp = time((time_t *)((void *)0));
#line 723
  p.packet_type = (enum packet_type )0;
#line 725
  GetTimeOfDay(& tval);
#line 727
  tmp___1 = send_packet(& p);
  }
#line 727
  if (! tmp___1) {
#line 728
    return (0);
  }
#line 730
  retries --;
  {
#line 732
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 735
    GetTimeOfDay(& tval2);
#line 736
    tmp___3 = TvalDiff(& tval, & tval2);
    }
#line 736
    if (tmp___3 > retry_time) {
#line 737
      if (! retries) {
#line 737
        goto while_break;
      }
#line 738
      if (! found) {
        {
#line 738
        tmp___2 = send_packet(& p);
        }
#line 738
        if (! tmp___2) {
#line 739
          return (0);
        }
      }
      {
#line 740
      GetTimeOfDay(& tval);
#line 741
      retries --;
      }
    }
    {
#line 744
    p2 = receive_packet(fd, (enum packet_type )0, 90);
    }
#line 744
    if (p2) {
#line 746
      nmb2 = & p2->packet.nmb;
#line 747
      if (nmb->header.name_trn_id != nmb2->header.name_trn_id) {
#line 747
        goto _L;
      } else
#line 747
      if (! nmb2->header.response) {
        _L: /* CIL Label */ 
#line 750
        if (fn) {
          {
#line 751
          (*fn)(p2);
          }
        } else {
          {
#line 753
          free_packet(p2);
          }
        }
#line 754
        goto while_continue;
      }
#line 757
      if (nmb2->header.opcode != 0) {
        {
#line 764
        free_packet(p2);
        }
#line 765
        goto while_continue;
      } else
#line 757
      if (nmb2->header.nm_flags.bcast) {
        {
#line 764
        free_packet(p2);
        }
#line 765
        goto while_continue;
      } else
#line 757
      if (nmb2->header.rcode) {
        {
#line 764
        free_packet(p2);
        }
#line 765
        goto while_continue;
      } else
#line 757
      if (! nmb2->header.ancount) {
        {
#line 764
        free_packet(p2);
        }
#line 765
        goto while_continue;
      } else
#line 757
      if ((nmb2->answers)->rr_type != 33) {
        {
#line 764
        free_packet(p2);
        }
#line 765
        goto while_continue;
      }
      {
#line 768
      interpret_node_status(& (nmb2->answers)->rdata[0], master, rname);
#line 769
      free_packet(p2);
      }
#line 770
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 775
  if (DEBUGLEVEL >= 0) {
    {
#line 775
    Debug1((char *)"No status response (this is not unusual)\n");
    }
  }
#line 777
  return (0);
}
}
#line 790 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
static void H_interpret_node_status(char *p ) 
{ 
  int level ;
  int numnames ;
  char qname[17] ;
  int type ;
  fstring flags ;
  int tmp ;

  {
#line 793
  level = 0;
#line 794
  numnames = (int )*((unsigned char *)p + 0);
#line 796
  if (DEBUGLEVEL >= level) {
    {
#line 796
    Debug1((char *)"received %d names\n", numnames);
    }
  }
#line 797
  p ++;
#line 798
  if (numnames > 0) {
    {
#line 799
    cur_vuln = 16010;
#line 800
    fill_vuln("Was able to obtain name tables:", "");
    }
  }
#line 804
  if (numnames > 0) {
    {
#line 805
    natprintf("[*]--- Remote systems name tables:\n\n");
    }
  }
  {
#line 808
  while (1) {
    while_continue: /* CIL Label */ ;
#line 808
    tmp = numnames;
#line 808
    numnames --;
#line 808
    if (! tmp) {
#line 808
      goto while_break;
    }
    {
#line 813
    flags[0] = (char)0;
#line 814
    StrnCpy(qname, (char const   *)p, 15);
#line 815
    type = (int )*((unsigned char *)p + 15);
#line 816
    p += 16;
    }
#line 818
    if ((int )*(p + 0) & 128) {
      {
#line 818
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<GROUP> ");
      }
    }
#line 819
    if (((int )*(p + 0) & 96) == 0) {
      {
#line 819
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"B ");
      }
    }
#line 820
    if (((int )*(p + 0) & 96) == 1) {
      {
#line 820
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"P ");
      }
    }
#line 821
    if (((int )*(p + 0) & 96) == 2) {
      {
#line 821
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"M ");
      }
    }
#line 822
    if (((int )*(p + 0) & 96) == 3) {
      {
#line 822
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"_ ");
      }
    }
#line 823
    if ((int )*(p + 0) & 16) {
      {
#line 823
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<DEREGISTERING> ");
      }
    }
#line 824
    if ((int )*(p + 0) & 8) {
      {
#line 824
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<CONFLICT> ");
      }
    }
#line 825
    if ((int )*(p + 0) & 4) {
      {
#line 825
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<ACTIVE> ");
      }
    }
#line 826
    if ((int )*(p + 0) & 2) {
      {
#line 826
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<PERMANENT> ");
      }
    }
#line 829
    if (type == 29) {
      {
#line 830
      strcat((char */* __restrict  */)(flags), (char const   */* __restrict  */)"<MASTER> ");
      }
    }
    {
#line 831
    trim_string(qname, (char *)((void *)0), (char *)" ");
#line 833
    fill_block(try_names, qname);
    }
#line 838
    if (type != 29) {
      {
#line 839
      fill_block(try_users, qname);
#line 840
      fill_block(try_pass, qname);
      }
    }
    {
#line 845
    natprintf("     %s\n", qname);
#line 849
    cur_vuln = 16010;
#line 850
    sprintf((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"%s (type 0x%x) %s",
            qname, type, flags);
#line 851
    fill_vuln("Name: ", tbuf);
    }
#line 854
    if (DEBUGLEVEL >= level) {
      {
#line 854
      Debug1((char *)"\t%s (type=0x%x)\t%s\n", qname, type, flags);
      }
    }
#line 855
    p += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 857
  if (DEBUGLEVEL >= level) {
    {
#line 857
    Debug1((char *)"num_good_sends=%d num_good_receives=%d\n", ((unsigned int )*((unsigned char *)p + 20) | ((unsigned int )*((unsigned char *)p + 21) << 8)) | (((unsigned int )*((unsigned char *)p + 22) | ((unsigned int )*((unsigned char *)p + 23) << 8)) << 16),
           ((unsigned int )*((unsigned char *)p + 24) | ((unsigned int )*((unsigned char *)p + 25) << 8)) | (((unsigned int )*((unsigned char *)p + 26) | ((unsigned int )*((unsigned char *)p + 27) << 8)) << 16));
    }
  }
#line 859
  return;
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
BOOL H_name_status(int fd , char *name___1 , int name_type___0 , struct in_addr to_ip ) 
{ 
  BOOL found ;
  int retries ;
  int retry_time ;
  struct timeval tval ;
  struct packet_struct p ;
  struct packet_struct *p2 ;
  struct nmb_packet *nmb ;
  int recurse___0 ;
  time_t tmp ;
  __pid_t tmp___0 ;
  BOOL tmp___1 ;
  struct timeval tval2 ;
  BOOL tmp___2 ;
  int tmp___3 ;
  struct nmb_packet *nmb2 ;

  {
  {
#line 869
  found = 0;
#line 870
  retries = 2;
#line 871
  retry_time = 5000;
#line 875
  nmb = & p.packet.nmb;
#line 876
  recurse___0 = 0;
#line 877
  bzero((void *)((char *)(& p)), sizeof(p));
  }
#line 879
  if (! name_trn_id) {
    {
#line 879
    tmp = time((time_t *)((void *)0));
#line 879
    tmp___0 = getpid();
#line 879
    name_trn_id = (uint16 )(tmp % 32767L + (long )((unsigned int )tmp___0 % 100U));
    }
  }
  {
#line 881
  name_trn_id = (uint16 )((unsigned int )((int )name_trn_id + 1) % 32767U);
#line 883
  nmb->header.name_trn_id = (int )name_trn_id;
#line 884
  nmb->header.opcode = 0;
#line 885
  nmb->header.response = 0;
#line 886
  nmb->header.nm_flags.bcast = 0;
#line 887
  nmb->header.nm_flags.recursion_available = CanRecurse;
#line 888
  nmb->header.nm_flags.recursion_desired = recurse___0;
#line 889
  nmb->header.nm_flags.trunc = 0;
#line 890
  nmb->header.nm_flags.authoritative = 0;
#line 891
  nmb->header.rcode = 0;
#line 892
  nmb->header.qdcount = 1;
#line 893
  nmb->header.ancount = 0;
#line 894
  nmb->header.nscount = 0;
#line 895
  nmb->header.arcount = 0;
#line 897
  make_nmb_name(& nmb->question.question_name, name___1, name_type___0, scope);
#line 899
  nmb->question.question_type = 33;
#line 900
  nmb->question.question_class = 1;
#line 902
  p.ip = to_ip;
#line 903
  p.port = 137;
#line 904
  p.fd = fd;
#line 905
  p.timestamp = time((time_t *)((void *)0));
#line 906
  p.packet_type = (enum packet_type )0;
#line 908
  GetTimeOfDay(& tval);
#line 910
  tmp___1 = send_packet(& p);
  }
#line 910
  if (! tmp___1) {
#line 911
    return (0);
  }
#line 913
  retries --;
  {
#line 915
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 918
    GetTimeOfDay(& tval2);
#line 919
    tmp___3 = TvalDiff(& tval, & tval2);
    }
#line 919
    if (tmp___3 > retry_time) {
#line 920
      if (! retries) {
#line 920
        goto while_break;
      }
#line 921
      if (! found) {
        {
#line 921
        tmp___2 = send_packet(& p);
        }
#line 921
        if (! tmp___2) {
#line 922
          return (0);
        }
      }
      {
#line 923
      GetTimeOfDay(& tval);
#line 924
      retries --;
      }
    }
    {
#line 927
    p2 = receive_packet(fd, (enum packet_type )0, 90);
    }
#line 927
    if (p2) {
#line 929
      nmb2 = & p2->packet.nmb;
#line 930
      if (nmb->header.name_trn_id != nmb2->header.name_trn_id) {
#line 933
        goto while_continue;
      } else
#line 930
      if (! nmb2->header.response) {
#line 933
        goto while_continue;
      }
#line 936
      if (nmb2->header.opcode != 0) {
        {
#line 943
        free_packet(p2);
        }
#line 944
        goto while_continue;
      } else
#line 936
      if (nmb2->header.nm_flags.bcast) {
        {
#line 943
        free_packet(p2);
        }
#line 944
        goto while_continue;
      } else
#line 936
      if (nmb2->header.rcode) {
        {
#line 943
        free_packet(p2);
        }
#line 944
        goto while_continue;
      } else
#line 936
      if (! nmb2->header.ancount) {
        {
#line 943
        free_packet(p2);
        }
#line 944
        goto while_continue;
      } else
#line 936
      if ((nmb2->answers)->rr_type != 33) {
        {
#line 943
        free_packet(p2);
        }
#line 944
        goto while_continue;
      }
      {
#line 947
      H_interpret_node_status(& (nmb2->answers)->rdata[0]);
#line 948
      free_packet(p2);
      }
#line 949
      return (1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 958
  return (0);
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
BOOL name_query(int fd , char *name___1 , int name_type___0 , BOOL bcast , BOOL recurse___0 ,
                struct in_addr to_ip , struct in_addr *ip , void (*fn)() ) 
{ 
  BOOL found ;
  int retries ;
  int retry_time ;
  int tmp ;
  struct timeval tval ;
  struct packet_struct p ;
  struct packet_struct *p2 ;
  struct nmb_packet *nmb ;
  time_t tmp___0 ;
  __pid_t tmp___1 ;
  BOOL tmp___2 ;
  struct timeval tval2 ;
  BOOL tmp___3 ;
  int tmp___4 ;
  struct nmb_packet *nmb2 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
#line 970
  found = 0;
#line 971
  retries = 3;
#line 972
  if (bcast) {
#line 972
    tmp = 250;
  } else {
#line 972
    tmp = 2000;
  }
  {
#line 972
  retry_time = tmp;
#line 976
  nmb = & p.packet.nmb;
#line 978
  bzero((void *)((char *)(& p)), sizeof(p));
  }
#line 980
  if (! name_trn_id) {
    {
#line 980
    tmp___0 = time((time_t *)((void *)0));
#line 980
    tmp___1 = getpid();
#line 980
    name_trn_id = (uint16 )(tmp___0 % 32767L + (long )((unsigned int )tmp___1 % 100U));
    }
  }
  {
#line 982
  name_trn_id = (uint16 )((unsigned int )((int )name_trn_id + 1) % 32767U);
#line 984
  nmb->header.name_trn_id = (int )name_trn_id;
#line 985
  nmb->header.opcode = 0;
#line 986
  nmb->header.response = 0;
#line 987
  nmb->header.nm_flags.bcast = bcast;
#line 988
  nmb->header.nm_flags.recursion_available = CanRecurse;
#line 989
  nmb->header.nm_flags.recursion_desired = recurse___0;
#line 990
  nmb->header.nm_flags.trunc = 0;
#line 991
  nmb->header.nm_flags.authoritative = 0;
#line 992
  nmb->header.rcode = 0;
#line 993
  nmb->header.qdcount = 1;
#line 994
  nmb->header.ancount = 0;
#line 995
  nmb->header.nscount = 0;
#line 996
  nmb->header.arcount = 0;
#line 998
  make_nmb_name(& nmb->question.question_name, name___1, name_type___0, scope);
#line 1000
  nmb->question.question_type = 32;
#line 1001
  nmb->question.question_class = 1;
#line 1003
  p.ip = to_ip;
#line 1004
  p.port = 137;
#line 1005
  p.fd = fd;
#line 1006
  p.timestamp = time((time_t *)((void *)0));
#line 1007
  p.packet_type = (enum packet_type )0;
#line 1009
  GetTimeOfDay(& tval);
#line 1011
  tmp___2 = send_packet(& p);
  }
#line 1011
  if (! tmp___2) {
#line 1012
    return (0);
  }
#line 1014
  retries --;
  {
#line 1016
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1019
    GetTimeOfDay(& tval2);
#line 1020
    tmp___4 = TvalDiff(& tval, & tval2);
    }
#line 1020
    if (tmp___4 > retry_time) {
#line 1021
      if (! retries) {
#line 1021
        goto while_break;
      }
#line 1022
      if (! found) {
        {
#line 1022
        tmp___3 = send_packet(& p);
        }
#line 1022
        if (! tmp___3) {
#line 1023
          return (0);
        }
      }
      {
#line 1024
      GetTimeOfDay(& tval);
#line 1025
      retries --;
      }
    }
    {
#line 1028
    p2 = receive_packet(fd, (enum packet_type )0, 90);
    }
#line 1028
    if (p2) {
#line 1030
      nmb2 = & p2->packet.nmb;
#line 1031
      if (nmb->header.name_trn_id != nmb2->header.name_trn_id) {
#line 1031
        goto _L;
      } else
#line 1031
      if (! nmb2->header.response) {
        _L: /* CIL Label */ 
#line 1035
        if (fn) {
          {
#line 1036
          (*fn)(p2);
          }
        } else {
          {
#line 1038
          free_packet(p2);
          }
        }
#line 1039
        goto while_continue;
      }
#line 1042
      if (nmb2->header.opcode != 0) {
        {
#line 1048
        free_packet(p2);
        }
#line 1049
        goto while_continue;
      } else
#line 1042
      if (nmb2->header.nm_flags.bcast) {
        {
#line 1048
        free_packet(p2);
        }
#line 1049
        goto while_continue;
      } else
#line 1042
      if (nmb2->header.rcode) {
        {
#line 1048
        free_packet(p2);
        }
#line 1049
        goto while_continue;
      } else
#line 1042
      if (! nmb2->header.ancount) {
        {
#line 1048
        free_packet(p2);
        }
#line 1049
        goto while_continue;
      }
#line 1052
      if (ip) {
        {
#line 1053
        putip((void *)((char *)ip), (void *)(& (nmb2->answers)->rdata[2]));
        }
#line 1054
        if (fn) {
#line 1054
          tmp___6 = 3;
        } else {
#line 1054
          tmp___6 = 2;
        }
#line 1054
        if (DEBUGLEVEL >= tmp___6) {
          {
#line 1054
          tmp___5 = inet_ntoa(p2->ip);
#line 1054
          Debug1((char *)"Got a positive name query response from %s", tmp___5);
          }
        }
#line 1056
        if (fn) {
#line 1056
          tmp___8 = 3;
        } else {
#line 1056
          tmp___8 = 2;
        }
#line 1056
        if (DEBUGLEVEL >= tmp___8) {
          {
#line 1056
          tmp___7 = inet_ntoa(*ip);
#line 1056
          Debug1((char *)" (%s)\n", tmp___7);
          }
        }
      }
      {
#line 1058
      found = 1;
#line 1058
      retries = 0;
#line 1059
      free_packet(p2);
      }
#line 1060
      if (fn) {
#line 1060
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1064
  return (found);
}
}
#line 1074 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nmb.c"
BOOL send_mailslot_reply(char *mailslot , int fd , char *buf___0 , int len , char *srcname ,
                         char *dstname , int src_type , int dest_type , struct in_addr dest_ip___0 ,
                         struct in_addr src_ip ) 
{ 
  struct packet_struct p ;
  struct dgram_packet *dgram ;
  char *ptr ;
  char *p2 ;
  char tmp[4] ;
  uint16 tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  BOOL tmp___3 ;

  {
  {
#line 1081
  dgram = & p.packet.dgram;
#line 1085
  bzero((void *)((char *)(& p)), sizeof(p));
#line 1087
  dgram->header.msg_type = 17;
#line 1088
  dgram->header.flags.node_type = (enum node_type )2;
#line 1089
  dgram->header.flags.first = 1;
#line 1090
  dgram->header.flags.more = 0;
#line 1091
  tmp___0 = name_trn_id;
#line 1091
  name_trn_id = (uint16 )((int )name_trn_id + 1);
#line 1091
  dgram->header.dgm_id = (int )tmp___0;
#line 1092
  dgram->header.source_ip = src_ip;
#line 1093
  dgram->header.source_port = 138;
#line 1094
  dgram->header.dgm_length = 0;
#line 1095
  dgram->header.packet_offset = 0;
#line 1097
  make_nmb_name(& dgram->source_name, srcname, src_type, scope);
#line 1098
  make_nmb_name(& dgram->dest_name, dstname, dest_type, scope);
#line 1100
  ptr = & dgram->data[0];
#line 1103
  ptr -= 4;
#line 1104
  memcpy((void */* __restrict  */)(tmp), (void const   */* __restrict  */)ptr, (size_t )4);
#line 1105
  set_message(ptr, 17, 17 + len, 1);
#line 1106
  memcpy((void */* __restrict  */)ptr, (void const   */* __restrict  */)(tmp), (size_t )4);
#line 1108
  *((unsigned char *)ptr + 8) = (unsigned char)37;
#line 1109
  *((unsigned char *)ptr + 39) = (unsigned char )((int )((uint16 )len) & 255);
#line 1109
  *((unsigned char *)ptr + 40) = (unsigned char )((int )((uint16 )len) >> 8);
#line 1110
  *((unsigned char *)ptr + 59) = (unsigned char )((int )((uint16 )len) & 255);
#line 1110
  *((unsigned char *)ptr + 60) = (unsigned char )((int )((uint16 )len) >> 8);
#line 1111
  tmp___1 = strlen((char const   *)mailslot);
#line 1111
  *((unsigned char *)ptr + 61) = (unsigned char )((int )((uint16 )(70UL + tmp___1)) & 255);
#line 1111
  tmp___2 = strlen((char const   *)mailslot);
#line 1111
  *((unsigned char *)ptr + 62) = (unsigned char )((int )((uint16 )(70UL + tmp___2)) >> 8);
#line 1112
  *((unsigned char *)ptr + 63) = (unsigned char)3;
#line 1112
  *((unsigned char *)ptr + 64) = (unsigned char )(3 >> 8);
#line 1113
  *((unsigned char *)ptr + 65) = (unsigned char)1;
#line 1113
  *((unsigned char *)ptr + 66) = (unsigned char )(1 >> 8);
#line 1114
  *((unsigned char *)ptr + 67) = (unsigned char)1;
#line 1114
  *((unsigned char *)ptr + 68) = (unsigned char )(1 >> 8);
#line 1115
  *((unsigned char *)ptr + 69) = (unsigned char)2;
#line 1115
  *((unsigned char *)ptr + 70) = (unsigned char )(2 >> 8);
#line 1116
  p2 = smb_buf(ptr);
#line 1117
  StrCpy(p2, mailslot);
#line 1118
  p2 = skip_string(p2, 1);
#line 1120
  memcpy((void */* __restrict  */)p2, (void const   */* __restrict  */)buf___0, (size_t )len);
#line 1121
  p2 += len;
#line 1123
  dgram->datasize = (int )(p2 - (ptr + 4));
#line 1125
  p.ip = dest_ip___0;
#line 1126
  p.port = 138;
#line 1127
  p.fd = fd;
#line 1128
  p.timestamp = time((time_t *)((void *)0));
#line 1129
  p.packet_type = (enum packet_type )1;
#line 1131
  tmp___3 = send_packet(& p);
  }
#line 1131
  return (tmp___3);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 199 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) mktime)(struct tm *__tp ) ;
#line 205
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 239
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) gmtime)(time_t const   *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 219
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void * __restrict  __optval ,
                                                                                 socklen_t * __restrict  __optlen ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 375
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 137 "/usr/include/netdb.h"
extern struct hostent *gethostbyaddr(void const   *__addr , __socklen_t __len , int __type ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 214
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 105 "/usr/include/grp.h"
extern struct group *getgrgid(__gid_t __gid ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 511
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) getcwd)(char *__buf ,
                                                                               size_t __size ) ;
#line 879
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gethostname)(char *__name ,
                                                                                                  size_t __len ) ;
#line 1016
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ftruncate)(int __fd ,
                                                                                __off_t __length ) ;
#line 162 "/usr/include/dirent.h"
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 602 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
int sys_stat(char *fname , struct stat *sbuf ) ;
#line 606
int sys_chdir(char *dname ) ;
#line 607
int sys_utime(char *fname , struct utimbuf *times ) ;
#line 617
BOOL fcntl_lock(int fd , int op , uint32 offset , uint32 count___0 , int type ) ;
#line 618
void BlockSignals(BOOL block ) ;
#line 619
void msleep(int t ) ;
#line 620
int file_lock(char *name___1 , int timeout ) ;
#line 621
void file_unlock(int fd ) ;
#line 626
void PutUniCode(char *dst , char *src ) ;
#line 628
void close_low_fds(void) ;
#line 630
int write_socket(int fd , char *buf___0 , int len ) ;
#line 631
char *readdirname(void *p ) ;
#line 633
int smb_numwords(char *buf___0 ) ;
#line 637
int DSTDiff(time_t t ) ;
#line 639
void put_long_date(char *p , time_t t ) ;
#line 647
void standard_sub_basic(char *s ) ;
#line 653
int write_data(int fd , char *buffer , int N ) ;
#line 660
int transfer_file(int infd , int outfd___0 , int n , char *header , int headlen ,
                  int align ) ;
#line 662
time_t file_modtime(char *fname ) ;
#line 663
BOOL do_match(char *str , char *regexp , int case_sig ) ;
#line 664
BOOL is_a_socket(int fd ) ;
#line 671
BOOL strisnormal(char *s ) ;
#line 675
BOOL next_token(char **ptr , char *buff , char *sep ) ;
#line 677
char *fgets_slash(char *s2 , int maxlen , FILE *f ) ;
#line 680
BOOL process_exists(int pid___0 ) ;
#line 682
void array_promote(char *array , int elsize , int element ) ;
#line 683
void string_replace(char *s , char oldc , char newc ) ;
#line 685
BOOL string_sub(char *s , char *pattern , char *insert ) ;
#line 689
int smb_buf_ofs(char *buf___0 ) ;
#line 728
BOOL strhasupper(char *s ) ;
#line 729
BOOL strhaslower(char *s ) ;
#line 731
char *uidtoname(int uid___0 ) ;
#line 732
char *gidtoname(int gid___0 ) ;
#line 747
int read_smb_length(int fd , char *inbuf___0 , int timeout ) ;
#line 748
int read_predict(int fd , int offset , char *buf___0 , char **ptr , int num ) ;
#line 749
void invalidate_read_prediction(int fd ) ;
#line 750
void do_read_prediction(void) ;
#line 753
int count_chars(char *s , char c ) ;
#line 760
void smb_setlen(char *buf___0 , int len ) ;
#line 763
BOOL in_group(gid_t group , int current_gid , int ngroups , int *groups ) ;
#line 764
BOOL string_set(char **dest , char *src ) ;
#line 765
BOOL string_init(char **dest , char *src ) ;
#line 766
void string_free(char **s ) ;
#line 769
BOOL directory_exist(char *dname , struct stat *st ) ;
#line 770
time_t make_unix_date3(void *date_ptr ) ;
#line 771
void put_dos_date3(char *buf___0 , int offset , time_t unixdate ) ;
#line 772
void make_dir_struct(char *buf___0 , char *mask , char *fname , unsigned int size___0 ,
                     int mode , time_t date ) ;
#line 773
BOOL in_list(char *s , char *list , BOOL casesensitive ) ;
#line 775
BOOL file_exist(char *fname , struct stat *sbuf ) ;
#line 776
int read_with_timeout(int fd , char *buf___0 , int mincnt , int maxcnt , long time_out ,
                      BOOL exact ) ;
#line 779
BOOL send_keepalive(int client ) ;
#line 780
int read_data(int fd , char *buffer , int N ) ;
#line 781
int smb_len(char *buf___0 ) ;
#line 788
BOOL reduce_name(char *s , char *dir , BOOL widelinks ) ;
#line 789
void strlower(char *s ) ;
#line 790
void strnorm(char *s ) ;
#line 795
BOOL strnequal(char *s1 , char *s2 , int n ) ;
#line 796
BOOL strcsequal(char *s1 , char *s2 ) ;
#line 800
BOOL ip_equal(struct in_addr ip1 , struct in_addr ip2 ) ;
#line 801
BOOL send_one_packet(char *buf___0 , int len , struct in_addr ip , int port , int type ) ;
#line 803
int set_filelen(int fd , long len ) ;
#line 804
void put_dos_date(char *buf___0 , int offset , time_t unixdate ) ;
#line 805
void put_dos_date2(char *buf___0 , int offset , time_t unixdate ) ;
#line 808
void dos_clean_name(char *s ) ;
#line 809
void unix_clean_name(char *s ) ;
#line 813
int byte_checksum(char *buf___0 , int len ) ;
#line 814
BOOL yesno(char *p ) ;
#line 815
uint32 file_size(char *file_name ) ;
#line 817
char *GetWd(char *str ) ;
#line 821
int name_extract(char *buf___0 , int ofs , char *name___1 ) ;
#line 822
void get_broadcast(struct in_addr *if_ipaddr , struct in_addr *if_bcast , struct in_addr *if_nmask ) ;
#line 835
int TimeDiff(time_t t ) ;
#line 836
BOOL set_filetime(char *fname , time_t mtime ) ;
#line 837
char *dirname_dos(char *path , char *buf___0 ) ;
#line 838
BOOL get_myname(char *myname___0 , struct in_addr *ip ) ;
#line 840
BOOL sane_unix_date(time_t unixdate ) ;
#line 841
time_t start_of_month(void) ;
#line 846
struct in_addr *interpret_addr2(char *str ) ;
#line 847
BOOL zero_ip(struct in_addr ip ) ;
#line 848
int read_max_udp(int fd , char *buffer , int bufsize , int maxtime ) ;
#line 849
int interpret_protocol(char *str , int def ) ;
#line 850
int interpret_security(char *str , int def ) ;
#line 851
int ChDir(char *path ) ;
#line 853
unsigned long interpret_addr(char *str ) ;
#line 856
void setup_logging(char *pname , BOOL interactive ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.h"
char *upper_char_map ;
#line 33
char *lower_char_map ;
#line 36 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char scope[1024]  = {      (char )'\000'};
#line 38 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int DEBUGLEVEL  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL passive  =    0;
#line 42 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int Protocol  =    2;
#line 44 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int serverzone  =    0;
#line 47 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
file_info def_finfo  = 
#line 47
     {-1, 0, 0, 0, (time_t )0, (time_t )0, (time_t )0, {(char )'\000'}};
#line 50 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
FILE *dbf  =    (FILE *)((void *)0);
#line 53 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int Client  =    -1;
#line 56 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct from_host Client_info  =    {(char *)"UNKNOWN", (char *)"0.0.0.0", (struct sockaddr_in *)((void *)0)};
#line 60 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct in_addr lastip  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int lastport  =    0;
#line 66 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct in_addr myip  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct in_addr bcast_ip  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct in_addr Netmask  ;
#line 70 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int trans_num  =    0;
#line 75 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int case_default  =    0;
#line 79 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int ReadSize  =    16384;
#line 81 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char debugf[1024]  = 
#line 81
  {      (char )'/',      (char )'t',      (char )'m',      (char )'p', 
        (char )'/',      (char )'l',      (char )'o',      (char )'g', 
        (char )'.',      (char )'s',      (char )'a',      (char )'m', 
        (char )'b',      (char )'a',      (char )'\000'};
#line 82 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int syslog_level  ;
#line 86 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL case_sensitive  ;
#line 87 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL case_preserve  ;
#line 88 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL use_mangled_map  =    0;
#line 89 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL short_case_preserve  ;
#line 90 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL case_mangle  ;
#line 92 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char remote_machine[128]  = {      (char )'\000'};
#line 93 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char local_machine[128]  = {      (char )'\000'};
#line 94 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char remote_arch[128]  = 
#line 94
  {      (char )'U',      (char )'N',      (char )'K',      (char )'N', 
        (char )'O',      (char )'W',      (char )'N',      (char )'\000'};
#line 95 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char remote_proto[128]  = 
#line 95
  {      (char )'U',      (char )'N',      (char )'K',      (char )'N', 
        (char )'O',      (char )'W',      (char )'N',      (char )'\000'};
#line 96 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char myhostname[1024]  = {      (char )'\000'};
#line 97 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char user_socket_options[1024]  = {      (char )'\000'};
#line 98 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char sesssetup_user[1024]  = {      (char )'\000'};
#line 101
static char *filename_dos(char *path , char *buf___0 ) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static BOOL stdout_logging  =    0;
#line 113 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void setup_logging(char *pname , BOOL interactive ) 
{ 


  {
#line 122
  if (interactive) {
#line 123
    stdout_logging = 1;
#line 124
    dbf = stdout;
  }
#line 126
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL append_log  =    0;
#line 136 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int Debug1(char *format_str  , ...) 
{ 
  va_list ap ;

  {
  {
#line 147
  __builtin_va_start(ap, format_str);
  }
#line 153
  if (stdout_logging) {
    {
#line 154
    vfprintf((FILE */* __restrict  */)dbf, (char const   */* __restrict  */)format_str,
             ap);
#line 155
    __builtin_va_end(ap);
    }
#line 156
    return (0);
  }
#line 241
  return (0);
}
}
#line 246 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL fcntl_lock(int fd , int op , uint32 offset , uint32 count___0 , int type ) 
{ 
  struct flock lock ;
  int ret___2 ;
  uint32 mask ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  __pid_t tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int *tmp___7 ;

  {
#line 253
  mask = 3221225472U;
#line 256
  count___0 &= ~ mask;
#line 262
  if ((offset & mask) != 0U) {
#line 263
    offset = (offset & ~ mask) | ((offset & mask) >> 2);
  }
#line 283
  if (DEBUGLEVEL >= 5) {
    {
#line 283
    Debug1((char *)"fcntl_lock %d %d %d %d %d\n", fd, op, (int )offset, (int )count___0,
           type);
    }
  }
  {
#line 285
  lock.l_type = (short )type;
#line 286
  lock.l_whence = (short)0;
#line 287
  lock.l_start = (__off_t )((int )offset);
#line 288
  lock.l_len = (__off_t )((int )count___0);
#line 289
  lock.l_pid = 0;
#line 291
  tmp = __errno_location();
#line 291
  *tmp = 0;
#line 293
  ret___2 = fcntl(fd, op, & lock);
#line 295
  tmp___3 = __errno_location();
  }
#line 295
  if (*tmp___3 != 0) {
#line 296
    if (DEBUGLEVEL >= 3) {
      {
#line 296
      tmp___0 = __errno_location();
#line 296
      tmp___1 = strerror(*tmp___0);
#line 296
      tmp___2 = __errno_location();
#line 296
      Debug1((char *)"fcntl lock gave errno %d (%s)\n", *tmp___2, tmp___1);
      }
    }
  }
#line 299
  if (op == 5) {
#line 301
    if (ret___2 != -1) {
#line 301
      if ((int )lock.l_type != 2) {
#line 301
        if (lock.l_pid != 0) {
          {
#line 301
          tmp___4 = getpid();
          }
#line 301
          if (lock.l_pid != tmp___4) {
#line 306
            if (DEBUGLEVEL >= 3) {
              {
#line 306
              Debug1((char *)"fd %d is locked by pid %d\n", fd, lock.l_pid);
              }
            }
#line 307
            return (1);
          }
        }
      }
    }
#line 311
    return (0);
  }
#line 315
  if (ret___2 == -1) {
#line 317
    if (DEBUGLEVEL >= 3) {
      {
#line 317
      tmp___5 = __errno_location();
#line 317
      tmp___6 = strerror(*tmp___5);
#line 317
      Debug1((char *)"lock failed at offset %d count %d op %d type %d (%s)\n", offset,
             count___0, op, type, tmp___6);
      }
    }
    {
#line 321
    tmp___7 = __errno_location();
    }
#line 321
    if (*tmp___7 == 22) {
#line 323
      if (DEBUGLEVEL >= 3) {
        {
#line 323
        Debug1((char *)"locking not supported? returning True\n");
        }
      }
#line 324
      return (1);
    }
#line 327
    return (0);
  }
#line 331
  if (DEBUGLEVEL >= 5) {
    {
#line 331
    Debug1((char *)"Lock call successful\n");
    }
  }
#line 333
  return (1);
}
}
#line 343 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int file_lock(char *name___1 , int timeout ) 
{ 
  int fd ;
  int tmp ;
  time_t t ;
  BOOL tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 345
  tmp = open((char const   *)name___1, 66, 438);
#line 345
  fd = tmp;
#line 346
  t = (time_t )0;
  }
#line 347
  if (fd < 0) {
#line 347
    return (-1);
  }
#line 350
  if (timeout) {
    {
#line 350
    t = time((time_t *)((void *)0));
    }
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! (! timeout)) {
      {
#line 351
      tmp___1 = time((time_t *)((void *)0));
      }
#line 351
      if (! (tmp___1 - t < (time_t )timeout)) {
#line 351
        goto while_break;
      }
    }
    {
#line 352
    tmp___0 = fcntl_lock(fd, 6, (uint32 )0, (uint32 )1, 1);
    }
#line 352
    if (tmp___0) {
#line 352
      return (fd);
    }
    {
#line 353
    msleep(100);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (-1);
}
}
#line 364 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void file_unlock(int fd ) 
{ 


  {
#line 366
  if (fd < 0) {
#line 366
    return;
  }
  {
#line 368
  fcntl_lock(fd, 6, (uint32 )0, (uint32 )1, 2);
#line 370
  close(fd);
  }
#line 371
  return;
}
}
#line 376 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void GetTimeOfDay(struct timeval *tval ) 
{ 


  {
  {
#line 381
  gettimeofday((struct timeval */* __restrict  */)tval, (__timezone_ptr_t )((void *)0));
  }
#line 383
  return;
}
}
#line 385 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int extra_time_offset  =    0;
#line 387 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static int timediff  =    0;
#line 392 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void TimeInit(void) 
{ 
  struct tm tm_utc ;
  struct tm tm_local ;
  time_t t ;
  struct tm *tmp ;
  struct tm *tmp___0 ;
  time_t tmp___1 ;
  time_t tmp___2 ;
  int tmp___3 ;

  {
  {
#line 397
  t = time((time_t *)((void *)0));
#line 399
  tmp = gmtime((time_t const   *)(& t));
#line 399
  tm_utc = *tmp;
#line 400
  tmp___0 = localtime((time_t const   *)(& t));
#line 400
  tm_local = *tmp___0;
#line 405
  tmp___1 = mktime(& tm_utc);
#line 405
  tmp___2 = mktime(& tm_local);
#line 405
  timediff = (int )(tmp___1 - tmp___2);
  }
#line 408
  if (serverzone == 0) {
    {
#line 409
    tmp___3 = DSTDiff(t);
#line 409
    serverzone = timediff - tmp___3;
    }
#line 410
    if (DEBUGLEVEL >= 4) {
      {
#line 410
      Debug1((char *)"Serverzone is %d\n", serverzone);
      }
    }
  }
#line 412
  return;
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static struct dst_table *dst_table  =    (struct dst_table *)((void *)0);
#line 423 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static int table_size  =    0;
#line 420 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int DSTDiff(time_t t ) 
{ 
  int i___0 ;
  BOOL is_dst ;
  time_t low ;
  time_t high ;
  void *tmp ;
  struct tm *tmp___1 ;
  time_t tmp___2 ;
  int tmp___4 ;
  struct tm *tmp___5 ;
  int tmp___7 ;
  struct tm *tmp___8 ;
  int tmp___9 ;

  {
#line 425
  is_dst = 0;
#line 427
  if (t == 0L) {
    {
#line 427
    t = time((time_t *)((void *)0));
    }
  }
#line 430
  i___0 = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (i___0 < table_size)) {
#line 430
      goto while_break;
    }
#line 431
    if (t >= (dst_table + i___0)->start) {
#line 431
      if (t <= (dst_table + i___0)->end) {
#line 431
        goto while_break;
      }
    }
#line 430
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  if (i___0 < table_size) {
#line 434
    is_dst = (dst_table + i___0)->is_dst;
  } else {
    {
#line 438
    tmp = Realloc((void *)dst_table, (int )(sizeof(*(dst_table + 0)) * (unsigned long )(i___0 + 1)));
#line 438
    dst_table = (struct dst_table *)tmp;
    }
#line 440
    if (! dst_table) {
#line 441
      table_size = 0;
#line 442
      return (0);
    }
    {
#line 445
    table_size ++;
#line 447
    tmp___1 = localtime((time_t const   *)(& t));
    }
#line 447
    if (tmp___1->tm_isdst) {
#line 447
      is_dst = 1;
    } else {
#line 447
      is_dst = 0;
    }
#line 447
    (dst_table + i___0)->is_dst = is_dst;
#line 448
    tmp___2 = t;
#line 448
    (dst_table + i___0)->end = tmp___2;
#line 448
    (dst_table + i___0)->start = tmp___2;
#line 451
    low = t - 7776000L;
#line 452
    high = t + 7776000L;
    {
#line 455
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 455
      if (! (low + 3600L < (dst_table + i___0)->start)) {
#line 455
        goto while_break___0;
      }
      {
#line 456
      t = low + ((dst_table + i___0)->start - low) / 2L;
#line 457
      tmp___5 = localtime((time_t const   *)(& t));
      }
#line 457
      if (tmp___5->tm_isdst) {
#line 457
        tmp___4 = 1;
      } else {
#line 457
        tmp___4 = 0;
      }
#line 457
      if (tmp___4 == is_dst) {
#line 458
        (dst_table + i___0)->start = t;
      } else {
#line 460
        low = t;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 463
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 463
      if (! (high - 3600L > (dst_table + i___0)->end)) {
#line 463
        goto while_break___1;
      }
      {
#line 464
      t = high + (high - (dst_table + i___0)->end) / 2L;
#line 465
      tmp___8 = localtime((time_t const   *)(& t));
      }
#line 465
      if (tmp___8->tm_isdst) {
#line 465
        tmp___7 = 1;
      } else {
#line 465
        tmp___7 = 0;
      }
#line 465
      if (tmp___7 == is_dst) {
#line 466
        (dst_table + i___0)->end = t;
      } else {
#line 468
        high = t;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 480
  if (is_dst) {
#line 480
    tmp___9 = 3600;
  } else {
#line 480
    tmp___9 = 0;
  }
#line 480
  return (tmp___9 - extra_time_offset * 60);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static BOOL initialised  =    0;
#line 486 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int TimeDiff(time_t t ) 
{ 
  int tmp ;

  {
#line 489
  if (! initialised) {
    {
#line 489
    initialised = 1;
#line 489
    TimeInit();
    }
  }
  {
#line 490
  tmp = DSTDiff(t);
  }
#line 490
  return (timediff - tmp);
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct tm *LocalTime(time_t *t , int timemul ) 
{ 
  time_t t2 ;
  int tmp ;
  struct tm *tmp___0 ;

  {
#line 499
  t2 = *t;
#line 501
  if (timemul) {
    {
#line 502
    tmp = TimeDiff(t2);
#line 502
    t2 += (time_t )(timemul * tmp);
    }
  }
  {
#line 504
  tmp___0 = gmtime((time_t const   *)(& t2));
  }
#line 504
  return (tmp___0);
}
}
#line 511 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL is_a_socket(int fd ) 
{ 
  int v ;
  int l ;
  int tmp ;

  {
  {
#line 514
  l = (int )sizeof(int );
#line 519
  tmp = getsockopt(fd, 1, 3, (void */* __restrict  */)((char *)(& v)), (socklen_t */* __restrict  */)(& l));
  }
#line 519
  return (tmp == 0);
}
}
#line 532 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char *last_ptr  =    (char *)((void *)0);
#line 530 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL next_token(char **ptr , char *buff , char *sep ) 
{ 
  char *s ;
  BOOL quoted ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 536
  if (! ptr) {
#line 536
    ptr = & last_ptr;
  }
#line 537
  if (! ptr) {
#line 537
    return (0);
  }
#line 539
  s = *ptr;
#line 542
  if (! sep) {
#line 542
    sep = (char *)" \t\n\r";
  }
  {
#line 545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 545
    if (*s) {
      {
#line 545
      tmp = strchr((char const   *)sep, (int )*s);
      }
#line 545
      if (! tmp) {
#line 545
        goto while_break;
      }
    } else {
#line 545
      goto while_break;
    }
#line 545
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 548
  if (! *s) {
#line 548
    return (0);
  }
#line 551
  quoted = 0;
  {
#line 551
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 551
    if (*s) {
#line 551
      if (! quoted) {
        {
#line 551
        tmp___1 = strchr((char const   *)sep, (int )*s);
        }
#line 551
        if (tmp___1) {
#line 551
          goto while_break___0;
        }
      }
    } else {
#line 551
      goto while_break___0;
    }
#line 553
    if ((int )*s == 34) {
#line 554
      quoted = ! quoted;
    } else {
#line 556
      tmp___0 = buff;
#line 556
      buff ++;
#line 556
      *tmp___0 = *s;
    }
#line 551
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 559
  if (*s) {
#line 559
    *ptr = s + 1;
  } else {
#line 559
    *ptr = s;
  }
#line 560
  *buff = (char)0;
#line 561
  last_ptr = *ptr;
#line 563
  return (1);
}
}
#line 572 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void *MemMove(void *dest , void *src , int size___0 ) 
{ 
  unsigned long d ;
  unsigned long s ;
  int i___0 ;
  int *idest ;
  int *isrc ;
  char *cdest ;
  char *csrc ;
  int *idest___0 ;
  int *isrc___0 ;
  char *cdest___0 ;
  char *csrc___0 ;

  {
#line 576
  if ((unsigned long )dest == (unsigned long )src) {
#line 576
    return (dest);
  } else
#line 576
  if (! size___0) {
#line 576
    return (dest);
  }
#line 578
  d = (unsigned long )dest;
#line 579
  s = (unsigned long )src;
#line 581
  if (d >= s + (unsigned long )size___0) {
    {
#line 583
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (size_t )size___0);
    }
#line 584
    return (dest);
  } else
#line 581
  if (s >= d + (unsigned long )size___0) {
    {
#line 583
    memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (size_t )size___0);
    }
#line 584
    return (dest);
  }
#line 587
  if (d < s) {
#line 590
    if (s - d >= sizeof(int )) {
#line 590
      if (! (s % sizeof(int ))) {
#line 590
        if (! (d % sizeof(int ))) {
#line 590
          if (! ((unsigned long )size___0 % sizeof(int ))) {
#line 593
            idest = (int *)dest;
#line 594
            isrc = (int *)src;
#line 595
            size___0 = (int )((unsigned long )size___0 / sizeof(int ));
#line 596
            i___0 = 0;
            {
#line 596
            while (1) {
              while_continue: /* CIL Label */ ;
#line 596
              if (! (i___0 < size___0)) {
#line 596
                goto while_break;
              }
#line 596
              *(idest + i___0) = *(isrc + i___0);
#line 596
              i___0 ++;
            }
            while_break: /* CIL Label */ ;
            }
          } else {
#line 590
            goto _L___1;
          }
        } else {
#line 590
          goto _L___1;
        }
      } else {
#line 590
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 599
      cdest = (char *)dest;
#line 600
      csrc = (char *)src;
#line 601
      i___0 = 0;
      {
#line 601
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 601
        if (! (i___0 < size___0)) {
#line 601
          goto while_break___0;
        }
#line 601
        *(cdest + i___0) = *(csrc + i___0);
#line 601
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  } else
#line 607
  if (d - s >= sizeof(int )) {
#line 607
    if (! (s % sizeof(int ))) {
#line 607
      if (! (d % sizeof(int ))) {
#line 607
        if (! ((unsigned long )size___0 % sizeof(int ))) {
#line 610
          idest___0 = (int *)dest;
#line 611
          isrc___0 = (int *)src;
#line 612
          size___0 = (int )((unsigned long )size___0 / sizeof(int ));
#line 613
          i___0 = size___0 - 1;
          {
#line 613
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 613
            if (! (i___0 >= 0)) {
#line 613
              goto while_break___1;
            }
#line 613
            *(idest___0 + i___0) = *(isrc___0 + i___0);
#line 613
            i___0 --;
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
#line 607
          goto _L___4;
        }
      } else {
#line 607
        goto _L___4;
      }
    } else {
#line 607
      goto _L___4;
    }
  } else {
    _L___4: /* CIL Label */ 
#line 616
    cdest___0 = (char *)dest;
#line 617
    csrc___0 = (char *)src;
#line 618
    i___0 = size___0 - 1;
    {
#line 618
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 618
      if (! (i___0 >= 0)) {
#line 618
        goto while_break___2;
      }
#line 618
      *(cdest___0 + i___0) = *(csrc___0 + i___0);
#line 618
      i___0 --;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 621
  return (dest);
}
}
#line 628 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void array_promote(char *array , int elsize , int element ) 
{ 
  char *p ;
  void *tmp ;

  {
#line 631
  if (element == 0) {
#line 632
    return;
  }
  {
#line 634
  tmp = malloc((size_t )elsize);
#line 634
  p = (char *)tmp;
  }
#line 636
  if (! p) {
#line 638
    if (DEBUGLEVEL >= 5) {
      {
#line 638
      Debug1((char *)"Ahh! Can\'t malloc\n");
      }
    }
#line 639
    return;
  }
  {
#line 641
  memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)(array + element * elsize),
         (size_t )elsize);
#line 642
  memmove((void *)(array + elsize), (void const   *)array, (size_t )(elsize * element));
#line 643
  memcpy((void */* __restrict  */)array, (void const   */* __restrict  */)p, (size_t )elsize);
#line 644
  free((void *)p);
  }
#line 645
  return;
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct __anonstruct_socket_options_91 socket_options[8]  = 
#line 649
  {      {(char *)"SO_KEEPALIVE", 1, 9, 0, 0}, 
        {(char *)"SO_REUSEADDR", 1, 2, 0, 0}, 
        {(char *)"SO_BROADCAST", 1, 6, 0, 0}, 
        {(char *)"SO_SNDBUF", 1, 7, 0, 1}, 
        {(char *)"SO_RCVBUF", 1, 8, 0, 1}, 
        {(char *)"SO_SNDLOWAT", 1, 19, 0, 1}, 
        {(char *)"SO_RCVLOWAT", 1, 18, 0, 1}, 
        {(char *)((void *)0), 0, 0, 0, 0}};
#line 688 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void set_socket_options(int fd , char *options ) 
{ 
  string tok ;
  int ret___2 ;
  int i___0 ;
  int value ;
  char *p ;
  BOOL got_value ;
  BOOL tmp ;
  int on ;
  BOOL tmp___0 ;

  {
  {
#line 692
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 692
    tmp___0 = next_token(& options, tok, (char *)" \t,");
    }
#line 692
    if (! tmp___0) {
#line 692
      goto while_break;
    }
    {
#line 694
    ret___2 = 0;
#line 695
    value = 1;
#line 697
    got_value = 0;
#line 699
    p = strchr((char const   *)(tok), '=');
    }
#line 699
    if (p) {
      {
#line 701
      *p = (char)0;
#line 702
      value = atoi((char const   *)(p + 1));
#line 703
      got_value = 1;
      }
    }
#line 706
    i___0 = 0;
    {
#line 706
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 706
      if (! socket_options[i___0].name) {
#line 706
        goto while_break___0;
      }
      {
#line 707
      tmp = strequal(socket_options[i___0].name, tok);
      }
#line 707
      if (tmp) {
#line 708
        goto while_break___0;
      }
#line 706
      i___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 710
    if (! socket_options[i___0].name) {
#line 712
      if (DEBUGLEVEL >= 0) {
        {
#line 712
        Debug1((char *)"Unknown socket option %s\n", tok);
        }
      }
#line 713
      goto while_continue;
    }
    {
#line 719
    if (socket_options[i___0].opttype == 1) {
#line 719
      goto case_1;
    }
#line 719
    if (socket_options[i___0].opttype == 0) {
#line 719
      goto case_1;
    }
#line 724
    if (socket_options[i___0].opttype == 2) {
#line 724
      goto case_2;
    }
#line 716
    goto switch_break;
    case_1: /* CIL Label */ 
    case_0: /* CIL Label */ 
    {
#line 720
    ret___2 = setsockopt(fd, socket_options[i___0].level, socket_options[i___0].option,
                         (void const   *)((char *)(& value)), (socklen_t )sizeof(int ));
    }
#line 722
    goto switch_break;
    case_2: /* CIL Label */ 
#line 725
    if (got_value) {
#line 726
      if (DEBUGLEVEL >= 0) {
        {
#line 726
        Debug1((char *)"syntax error - %s does not take a value\n", tok);
        }
      }
    }
    {
#line 729
    on = socket_options[i___0].value;
#line 730
    ret___2 = setsockopt(fd, socket_options[i___0].level, socket_options[i___0].option,
                         (void const   *)((char *)(& on)), (socklen_t )sizeof(int ));
    }
#line 733
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 736
    if (ret___2 != 0) {
#line 737
      if (DEBUGLEVEL >= 0) {
        {
#line 737
        Debug1((char *)"Failed to set socket option %s\n", tok);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 739
  return;
}
}
#line 746 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void close_sockets(void) 
{ 


  {
  {
#line 748
  close(Client);
#line 750
  Client = -1;
  }
#line 754
  return;
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char TimeBuf[100]  ;
#line 759 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *timestring(void) 
{ 
  time_t t ;
  struct tm *tmp ;

  {
  {
#line 763
  t = time((time_t *)((void *)0));
#line 777
  tmp = LocalTime(& t, -1);
#line 777
  strftime((char */* __restrict  */)(TimeBuf), (size_t )100, (char const   */* __restrict  */)"%D %T",
           (struct tm  const  */* __restrict  */)tmp);
  }
#line 779
  return (TimeBuf);
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL in_group(gid_t group , int current_gid , int ngroups , int *groups ) 
{ 
  int i___0 ;

  {
#line 789
  if (group == (gid_t )current_gid) {
#line 789
    return (1);
  }
#line 791
  i___0 = 0;
  {
#line 791
  while (1) {
    while_continue: /* CIL Label */ ;
#line 791
    if (! (i___0 < ngroups)) {
#line 791
      goto while_break;
    }
#line 792
    if (group == (gid_t )*(groups + i___0)) {
#line 793
      return (1);
    }
#line 791
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 795
  return (0);
}
}
#line 801 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *StrCpy(char *dest , char *src ) 
{ 
  char *d ;
  char *tmp ;
  char tmp___0 ;
  char *tmp___1 ;

  {
#line 803
  d = dest;
#line 813
  if (! dest) {
#line 813
    return ((char *)((void *)0));
  }
#line 814
  if (! src) {
#line 815
    *dest = (char)0;
#line 816
    return (dest);
  }
  {
#line 818
  while (1) {
    while_continue: /* CIL Label */ ;
#line 818
    tmp = d;
#line 818
    d ++;
#line 818
    tmp___1 = src;
#line 818
    src ++;
#line 818
    tmp___0 = *tmp___1;
#line 818
    *tmp = tmp___0;
#line 818
    if (! tmp___0) {
#line 818
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 819
  return (dest);
}
}
#line 825 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *StrnCpy(char *dest , char const   *src , int n ) 
{ 
  char *d ;
  int tmp ;
  char *tmp___0 ;
  char tmp___1 ;
  char const   *tmp___2 ;

  {
#line 827
  d = dest;
#line 828
  if (! dest) {
#line 828
    return ((char *)((void *)0));
  }
#line 829
  if (! src) {
#line 830
    *dest = (char)0;
#line 831
    return (dest);
  }
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    tmp = n;
#line 833
    n --;
#line 833
    if (tmp) {
#line 833
      tmp___0 = d;
#line 833
      d ++;
#line 833
      tmp___2 = src;
#line 833
      src ++;
#line 833
      tmp___1 = (char )*tmp___2;
#line 833
      *tmp___0 = tmp___1;
#line 833
      if (! tmp___1) {
#line 833
        goto while_break;
      }
    } else {
#line 833
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 834
  *d = (char)0;
#line 835
  return (dest);
}
}
#line 842 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void putip(void *dest , void *src ) 
{ 


  {
  {
#line 844
  memcpy((void */* __restrict  */)dest, (void const   */* __restrict  */)src, (size_t )4);
  }
#line 845
  return;
}
}
#line 851 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static int name_interpret(char *in , char *out ) 
{ 
  int ret___2 ;
  int len ;
  char *tmp ;
  int tmp___0 ;

  {
#line 854
  tmp = in;
#line 854
  in ++;
#line 854
  len = (int )*tmp / 2;
#line 856
  *out = (char)0;
#line 858
  if (len > 30) {
#line 858
    return (0);
  } else
#line 858
  if (len < 1) {
#line 858
    return (0);
  }
  {
#line 860
  while (1) {
    while_continue: /* CIL Label */ ;
#line 860
    tmp___0 = len;
#line 860
    len --;
#line 860
    if (! tmp___0) {
#line 860
      goto while_break;
    }
#line 862
    if ((int )*(in + 0) < 65) {
#line 863
      *out = (char)0;
#line 864
      return (0);
    } else
#line 862
    if ((int )*(in + 0) > 80) {
#line 863
      *out = (char)0;
#line 864
      return (0);
    } else
#line 862
    if ((int )*(in + 1) < 65) {
#line 863
      *out = (char)0;
#line 864
      return (0);
    } else
#line 862
    if ((int )*(in + 1) > 80) {
#line 863
      *out = (char)0;
#line 864
      return (0);
    }
#line 866
    *out = (char )((((int )*(in + 0) - 65) << 4) + ((int )*(in + 1) - 65));
#line 867
    in += 2;
#line 868
    out ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 870
  *out = (char)0;
#line 871
  ret___2 = (int )*(out + -1);
#line 885
  return (ret___2);
}
}
#line 891 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int name_mangle(char *In , char *Out , char name_type___0 ) 
{ 
  fstring name___1 ;
  char buf___0[20] ;
  char *in ;
  char *out ;
  char *p ;
  char *label ;
  int i___0 ;
  char *tmp ;
  char c ;
  size_t tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
#line 895
  in = & buf___0[0];
#line 896
  out = Out;
#line 901
  if ((int )*(In + 0) == 42) {
#line 901
    if ((int )*(In + 1) == 0) {
      {
#line 902
      buf___0[0] = (char )'*';
#line 903
      memset((void *)(& buf___0[1]), 0, (size_t )16);
      }
    } else {
      {
#line 905
      StrnCpy(name___1, (char const   *)In, (int )(sizeof(name___1) - 1UL));
#line 906
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%-15.15s%c",
              name___1, (int )name_type___0);
      }
    }
  } else {
    {
#line 905
    StrnCpy(name___1, (char const   *)In, (int )(sizeof(name___1) - 1UL));
#line 906
    sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%-15.15s%c",
            name___1, (int )name_type___0);
    }
  }
#line 918
  tmp = out;
#line 918
  out ++;
#line 918
  *tmp = (char)32;
#line 919
  i___0 = 0;
  {
#line 919
  while (1) {
    while_continue: /* CIL Label */ ;
#line 919
    if (! (i___0 < 16)) {
#line 919
      goto while_break;
    }
#line 920
    c = *(upper_char_map + *(in + i___0));
#line 921
    *(out + i___0 * 2) = (char )(((int )c >> 4) + 65);
#line 922
    *(out + (i___0 * 2 + 1)) = (char )(((int )c & 15) + 65);
#line 919
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 924
  *(out + 32) = (char)0;
#line 925
  out += 32;
#line 927
  label = scope;
  {
#line 928
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 928
    if (! *label) {
#line 928
      goto while_break___0;
    }
    {
#line 930
    p = strchr((char const   *)label, '.');
    }
#line 931
    if ((unsigned long )p == (unsigned long )((char *)0)) {
      {
#line 932
      tmp___0 = strlen((char const   *)label);
#line 932
      p = label + tmp___0;
      }
    }
    {
#line 933
    tmp___1 = out;
#line 933
    out ++;
#line 933
    *tmp___1 = (char )(p - label);
#line 934
    memcpy((void */* __restrict  */)out, (void const   */* __restrict  */)label, (size_t )(p - label));
#line 935
    out += p - label;
#line 936
    label += (p - label) + (long )((int )*p == 46);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 938
  *out = (char)0;
#line 939
  tmp___2 = name_len(Out);
  }
#line 939
  return (tmp___2);
}
}
#line 946 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL file_exist(char *fname , struct stat *sbuf ) 
{ 
  struct stat st ;
  int tmp ;

  {
#line 949
  if (! sbuf) {
#line 949
    sbuf = & st;
  }
  {
#line 951
  tmp = sys_stat(fname, sbuf);
  }
#line 951
  if (tmp != 0) {
#line 952
    return (0);
  }
#line 954
  return ((sbuf->st_mode & 61440U) == 32768U);
}
}
#line 960 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
time_t file_modtime(char *fname ) 
{ 
  struct stat st ;
  int tmp ;

  {
  {
#line 964
  tmp = sys_stat(fname, & st);
  }
#line 964
  if (tmp != 0) {
#line 965
    return ((time_t )0);
  }
#line 967
  return (st.st_mtim.tv_sec);
}
}
#line 973 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL directory_exist(char *dname , struct stat *st ) 
{ 
  struct stat st2 ;
  int tmp ;

  {
#line 976
  if (! st) {
#line 976
    st = & st2;
  }
  {
#line 978
  tmp = sys_stat(dname, st);
  }
#line 978
  if (tmp != 0) {
#line 979
    return (0);
  }
#line 981
  return ((st->st_mode & 61440U) == 16384U);
}
}
#line 987 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
uint32 file_size(char *file_name ) 
{ 
  struct stat buf___0 ;

  {
  {
#line 990
  buf___0.st_size = (__off_t )0;
#line 991
  sys_stat(file_name, & buf___0);
  }
#line 992
  return ((uint32 )buf___0.st_size);
}
}
#line 998 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static BOOL null_mtime(time_t mtime ) 
{ 


  {
#line 1000
  if (mtime == 0L) {
#line 1001
    return (1);
  } else
#line 1000
  if (mtime == 4294967295L) {
#line 1001
    return (1);
  }
#line 1002
  return (0);
}
}
#line 1008 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static uint16 make_dos_date1(time_t unixdate , struct tm *t ) 
{ 
  uint16 ret___2 ;

  {
#line 1010
  ret___2 = (uint16 )0;
#line 1011
  ret___2 = (uint16 )(((unsigned int )(t->tm_mon + 1) >> 3) | (unsigned int )((t->tm_year - 80) << 1));
#line 1012
  ret___2 = (uint16 )((((int )ret___2 & 255) << 8) | (t->tm_mday | (((t->tm_mon + 1) & 7) << 5)));
#line 1013
  return (ret___2);
}
}
#line 1019 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static uint16 make_dos_time1(time_t unixdate , struct tm *t ) 
{ 
  uint16 ret___2 ;

  {
#line 1021
  ret___2 = (uint16 )0;
#line 1022
  ret___2 = (uint16 )((((unsigned int )t->tm_min >> 3) & 7U) | ((unsigned int )t->tm_hour << 3));
#line 1023
  ret___2 = (uint16 )((((int )ret___2 & 255) << 8) | (t->tm_sec / 2 | ((t->tm_min & 7) << 5)));
#line 1024
  return (ret___2);
}
}
#line 1031 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static uint32 make_dos_date(time_t unixdate ) 
{ 
  struct tm *t ;
  uint32 ret___2 ;
  uint16 tmp ;
  uint16 tmp___0 ;

  {
  {
#line 1034
  ret___2 = (uint32 )0;
#line 1036
  t = LocalTime(& unixdate, -1);
#line 1038
  tmp = make_dos_date1(unixdate, t);
#line 1038
  ret___2 = (uint32 )tmp;
#line 1039
  tmp___0 = make_dos_time1(unixdate, t);
#line 1039
  ret___2 = ((ret___2 & 65535U) << 16) | (unsigned int )tmp___0;
  }
#line 1041
  return (ret___2);
}
}
#line 1048 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void put_dos_date(char *buf___0 , int offset , time_t unixdate ) 
{ 
  uint32 x ;
  uint32 tmp ;

  {
  {
#line 1050
  tmp = make_dos_date(unixdate);
#line 1050
  x = tmp;
#line 1051
  *((unsigned char *)buf___0 + offset) = (unsigned char )((x & 65535U) & 255U);
#line 1051
  *((unsigned char *)buf___0 + (offset + 1)) = (unsigned char )((x & 65535U) >> 8);
#line 1051
  *((unsigned char *)buf___0 + (offset + 2)) = (unsigned char )((x >> 16) & 255U);
#line 1051
  *((unsigned char *)buf___0 + ((offset + 2) + 1)) = (unsigned char )((x >> 16) >> 8);
  }
#line 1052
  return;
}
}
#line 1058 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void put_dos_date2(char *buf___0 , int offset , time_t unixdate ) 
{ 
  uint32 x ;
  uint32 tmp ;

  {
  {
#line 1060
  tmp = make_dos_date(unixdate);
#line 1060
  x = tmp;
#line 1061
  x = ((x & 65535U) << 16) | ((x & 4294901760U) >> 16);
#line 1062
  *((unsigned char *)buf___0 + offset) = (unsigned char )((x & 65535U) & 255U);
#line 1062
  *((unsigned char *)buf___0 + (offset + 1)) = (unsigned char )((x & 65535U) >> 8);
#line 1062
  *((unsigned char *)buf___0 + (offset + 2)) = (unsigned char )((x >> 16) & 255U);
#line 1062
  *((unsigned char *)buf___0 + ((offset + 2) + 1)) = (unsigned char )((x >> 16) >> 8);
  }
#line 1063
  return;
}
}
#line 1070 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void put_dos_date3(char *buf___0 , int offset , time_t unixdate ) 
{ 
  int tmp ;
  BOOL tmp___0 ;

  {
  {
#line 1072
  tmp___0 = null_mtime(unixdate);
  }
#line 1072
  if (! tmp___0) {
    {
#line 1073
    tmp = TimeDiff(unixdate);
#line 1073
    unixdate += (time_t )(-1 * tmp);
    }
  }
#line 1074
  *((unsigned char *)buf___0 + offset) = (unsigned char )(((uint32 )unixdate & 65535U) & 255U);
#line 1074
  *((unsigned char *)buf___0 + (offset + 1)) = (unsigned char )(((uint32 )unixdate & 65535U) >> 8);
#line 1074
  *((unsigned char *)buf___0 + (offset + 2)) = (unsigned char )(((uint32 )unixdate >> 16) & 255U);
#line 1074
  *((unsigned char *)buf___0 + ((offset + 2) + 1)) = (unsigned char )(((uint32 )unixdate >> 16) >> 8);
#line 1075
  return;
}
}
#line 1080 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static void interpret_dos_date(uint32 date , int *year , int *month , int *day , int *hour ,
                               int *minute , int *second ) 
{ 
  uint32 p0 ;
  uint32 p1 ;
  uint32 p2 ;
  uint32 p3 ;

  {
#line 1084
  p0 = date & 255U;
#line 1084
  p1 = ((date & 65280U) >> 8) & 255U;
#line 1085
  p2 = ((date & 16711680U) >> 16) & 255U;
#line 1085
  p3 = ((date & 4278190080U) >> 24) & 255U;
#line 1087
  *second = (int )(2U * (p0 & 31U));
#line 1088
  *minute = (int )(((p0 >> 5) & 255U) + ((p1 & 7U) << 3));
#line 1089
  *hour = (int )((p1 >> 3) & 255U);
#line 1090
  *day = (int )(p2 & 31U);
#line 1091
  *month = (int )((((p2 >> 5) & 255U) + ((p3 & 1U) << 3)) - 1U);
#line 1092
  *year = (int )(((p3 >> 1) & 255U) + 80U);
#line 1093
  return;
}
}
#line 1099 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
time_t make_unix_date(void *date_ptr ) 
{ 
  uint32 dos_date ;
  struct tm t ;
  time_t ret___2 ;

  {
#line 1101
  dos_date = (uint32 )0;
#line 1105
  dos_date = ((unsigned int )*((unsigned char *)date_ptr + 0) | ((unsigned int )*((unsigned char *)date_ptr + 1) << 8)) | (((unsigned int )*((unsigned char *)date_ptr + 2) | ((unsigned int )*((unsigned char *)date_ptr + 3) << 8)) << 16);
#line 1107
  if (dos_date == 0U) {
#line 1107
    return ((time_t )0);
  }
  {
#line 1109
  interpret_dos_date(dos_date, & t.tm_year, & t.tm_mon, & t.tm_mday, & t.tm_hour,
                     & t.tm_min, & t.tm_sec);
#line 1111
  t.tm_wday = 1;
#line 1112
  t.tm_yday = 1;
#line 1113
  t.tm_isdst = -1;
#line 1117
  ret___2 = mktime(& t);
  }
#line 1119
  return (ret___2);
}
}
#line 1125 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
time_t make_unix_date2(void *date_ptr ) 
{ 
  uint32 x ;
  uint32 x2 ;
  time_t tmp ;

  {
  {
#line 1129
  x = ((unsigned int )*((unsigned char *)date_ptr + 0) | ((unsigned int )*((unsigned char *)date_ptr + 1) << 8)) | (((unsigned int )*((unsigned char *)date_ptr + 2) | ((unsigned int )*((unsigned char *)date_ptr + 3) << 8)) << 16);
#line 1130
  x2 = ((x & 65535U) << 16) | ((x & 4294901760U) >> 16);
#line 1131
  *((unsigned char *)(& x) + 0) = (unsigned char )((x2 & 65535U) & 255U);
#line 1131
  *((unsigned char *)(& x) + 1) = (unsigned char )((x2 & 65535U) >> 8);
#line 1131
  *((unsigned char *)(& x) + 2) = (unsigned char )((x2 >> 16) & 255U);
#line 1131
  *((unsigned char *)(& x) + 3) = (unsigned char )((x2 >> 16) >> 8);
#line 1133
  tmp = make_unix_date((void *)(& x));
  }
#line 1133
  return (tmp);
}
}
#line 1140 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
time_t make_unix_date3(void *date_ptr ) 
{ 
  time_t t ;
  int tmp ;
  BOOL tmp___0 ;

  {
  {
#line 1142
  t = (time_t )(((unsigned int )*((unsigned char *)date_ptr + 0) | ((unsigned int )*((unsigned char *)date_ptr + 1) << 8)) | (((unsigned int )*((unsigned char *)date_ptr + 2) | ((unsigned int )*((unsigned char *)date_ptr + 3) << 8)) << 16));
#line 1143
  tmp___0 = null_mtime(t);
  }
#line 1143
  if (! tmp___0) {
    {
#line 1144
    tmp = TimeDiff(t);
#line 1144
    t += (time_t )tmp;
    }
  }
#line 1145
  return (t);
}
}
#line 1153 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char attrstr[10]  ;
#line 1151 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *attrib_string(int mode ) 
{ 


  {
#line 1155
  attrstr[0] = (char)0;
#line 1157
  if ((long )mode & (1L << 3)) {
    {
#line 1157
    strcat((char */* __restrict  */)(attrstr), (char const   */* __restrict  */)"V");
    }
  }
#line 1158
  if ((long )mode & (1L << 4)) {
    {
#line 1158
    strcat((char */* __restrict  */)(attrstr), (char const   */* __restrict  */)"D");
    }
  }
#line 1159
  if ((long )mode & (1L << 5)) {
    {
#line 1159
    strcat((char */* __restrict  */)(attrstr), (char const   */* __restrict  */)"A");
    }
  }
#line 1160
  if ((long )mode & (1L << 1)) {
    {
#line 1160
    strcat((char */* __restrict  */)(attrstr), (char const   */* __restrict  */)"H");
    }
  }
#line 1161
  if ((long )mode & (1L << 2)) {
    {
#line 1161
    strcat((char */* __restrict  */)(attrstr), (char const   */* __restrict  */)"S");
    }
  }
#line 1162
  if ((long )mode & 1L) {
    {
#line 1162
    strcat((char */* __restrict  */)(attrstr), (char const   */* __restrict  */)"R");
    }
  }
#line 1164
  return (attrstr);
}
}
#line 1171 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int StrCaseCmp(char *s , char *t ) 
{ 


  {
  {
#line 1173
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1173
    if (! ((int )*(lower_char_map + *s) == (int )*(lower_char_map + *t))) {
#line 1173
      goto while_break;
    }
#line 1174
    if (! *s) {
#line 1174
      return (0);
    }
#line 1173
    s ++;
#line 1173
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1176
  return ((int )*(lower_char_map + *s) - (int )*(lower_char_map + *t));
}
}
#line 1182 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int StrnCaseCmp(char *s , char *t , int n ) 
{ 
  int tmp ;

  {
  {
#line 1184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1184
    tmp = n;
#line 1184
    n --;
#line 1184
    if (tmp) {
#line 1184
      if (*s) {
#line 1184
        if (! *t) {
#line 1184
          goto while_break;
        }
      } else {
#line 1184
        goto while_break;
      }
    } else {
#line 1184
      goto while_break;
    }
#line 1185
    if ((int )*(lower_char_map + *s) != (int )*(lower_char_map + *t)) {
#line 1185
      return ((int )*(lower_char_map + *s) - (int )*(lower_char_map + *t));
    }
#line 1186
    s ++;
#line 1186
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1188
  if (n) {
#line 1188
    return ((int )*(lower_char_map + *s) - (int )*(lower_char_map + *t));
  }
#line 1190
  return (0);
}
}
#line 1196 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL strequal(char *s1 , char *s2 ) 
{ 
  int tmp ;

  {
#line 1198
  if (! s1) {
#line 1198
    return (0);
  } else
#line 1198
  if (! s2) {
#line 1198
    return (0);
  }
  {
#line 1200
  tmp = StrCaseCmp(s1, s2);
  }
#line 1200
  return (tmp == 0);
}
}
#line 1206 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL strnequal(char *s1 , char *s2 , int n ) 
{ 
  int tmp ;

  {
#line 1208
  if (! s1) {
#line 1208
    return (0);
  } else
#line 1208
  if (! s2) {
#line 1208
    return (0);
  } else
#line 1208
  if (! n) {
#line 1208
    return (0);
  }
  {
#line 1210
  tmp = StrnCaseCmp(s1, s2, n);
  }
#line 1210
  return (tmp == 0);
}
}
#line 1216 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL strcsequal(char *s1 , char *s2 ) 
{ 
  int tmp ;

  {
#line 1218
  if (! s1) {
#line 1218
    return (0);
  } else
#line 1218
  if (! s2) {
#line 1218
    return (0);
  }
  {
#line 1220
  tmp = strcmp((char const   *)s1, (char const   *)s2);
  }
#line 1220
  return (tmp == 0);
}
}
#line 1253 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void strlower(char *s ) 
{ 


  {
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if (! *s) {
#line 1255
      goto while_break;
    }
#line 1268
    if ((int )*s != (int )*(lower_char_map + *s)) {
#line 1269
      *s = *(lower_char_map + *s);
    }
#line 1270
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1273
  return;
}
}
#line 1278 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void strupper(char *s ) 
{ 


  {
  {
#line 1280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1280
    if (! *s) {
#line 1280
      goto while_break;
    }
#line 1293
    if ((int )*s != (int )*(upper_char_map + *s)) {
#line 1294
      *s = *(upper_char_map + *s);
    }
#line 1295
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1298
  return;
}
}
#line 1304 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void strnorm(char *s ) 
{ 


  {
#line 1306
  if (case_default == 1) {
    {
#line 1307
    strupper(s);
    }
  } else {
    {
#line 1309
    strlower(s);
    }
  }
#line 1310
  return;
}
}
#line 1315 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL strisnormal(char *s ) 
{ 
  BOOL tmp ;
  int tmp___0 ;
  BOOL tmp___1 ;
  int tmp___2 ;

  {
#line 1317
  if (case_default == 1) {
    {
#line 1318
    tmp = strhaslower(s);
    }
#line 1318
    if (tmp) {
#line 1318
      tmp___0 = 0;
    } else {
#line 1318
      tmp___0 = 1;
    }
#line 1318
    return (tmp___0);
  }
  {
#line 1320
  tmp___1 = strhasupper(s);
  }
#line 1320
  if (tmp___1) {
#line 1320
    tmp___2 = 0;
  } else {
#line 1320
    tmp___2 = 1;
  }
#line 1320
  return (tmp___2);
}
}
#line 1327 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void string_replace(char *s , char oldc , char newc ) 
{ 


  {
  {
#line 1329
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1329
    if (! *s) {
#line 1329
      goto while_break;
    }
#line 1342
    if ((int )oldc == (int )*s) {
#line 1343
      *s = newc;
    }
#line 1344
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1347
  return;
}
}
#line 1384 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void show_msg(char *buf___0 ) 
{ 
  int i___0 ;
  int bcc ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;

  {
#line 1387
  bcc = 0;
#line 1388
  if (DEBUGLEVEL < 5) {
#line 1389
    return;
  }
#line 1391
  if (DEBUGLEVEL >= 5) {
    {
#line 1391
    tmp = smb_len(buf___0);
#line 1391
    Debug1((char *)"size=%d\nsmb_com=0x%x\nsmb_rcls=%d\nsmb_reh=%d\nsmb_err=%d\nsmb_flg=%d\nsmb_flg2=%d\n",
           tmp, (int )*((unsigned char *)buf___0 + 8), (int )*((unsigned char *)buf___0 + 9),
           (int )*((unsigned char *)buf___0 + 10), (int )((unsigned int )*((unsigned char *)buf___0 + 11) | ((unsigned int )*((unsigned char *)buf___0 + 12) << 8)),
           (int )*((unsigned char *)buf___0 + 13), (int )((unsigned int )*((unsigned char *)buf___0 + 14) | ((unsigned int )*((unsigned char *)buf___0 + 15) << 8)));
    }
  }
#line 1399
  if (DEBUGLEVEL >= 5) {
    {
#line 1399
    Debug1((char *)"smb_tid=%d\nsmb_pid=%d\nsmb_uid=%d\nsmb_mid=%d\nsmt_wct=%d\n",
           (int )((unsigned int )*((unsigned char *)buf___0 + 28) | ((unsigned int )*((unsigned char *)buf___0 + 29) << 8)),
           (int )((unsigned int )*((unsigned char *)buf___0 + 30) | ((unsigned int )*((unsigned char *)buf___0 + 31) << 8)),
           (int )((unsigned int )*((unsigned char *)buf___0 + 32) | ((unsigned int )*((unsigned char *)buf___0 + 33) << 8)),
           (int )((unsigned int )*((unsigned char *)buf___0 + 34) | ((unsigned int )*((unsigned char *)buf___0 + 35) << 8)),
           (int )*((unsigned char *)buf___0 + 36));
    }
  }
#line 1405
  i___0 = 0;
  {
#line 1405
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1405
    if (! (i___0 < (int )*((unsigned char *)buf___0 + 36))) {
#line 1405
      goto while_break;
    }
#line 1406
    if (DEBUGLEVEL >= 5) {
      {
#line 1406
      Debug1((char *)"smb_vwv[%d]=%d (0x%X)\n", i___0, (unsigned int )*((unsigned char *)buf___0 + (37 + 2 * i___0)) | ((unsigned int )*((unsigned char *)buf___0 + ((37 + 2 * i___0) + 1)) << 8),
             (unsigned int )*((unsigned char *)buf___0 + (37 + 2 * i___0)) | ((unsigned int )*((unsigned char *)buf___0 + ((37 + 2 * i___0) + 1)) << 8));
      }
    }
#line 1405
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1408
  bcc = (int )((unsigned int )*((unsigned char *)buf___0 + (37 + 2 * (int )*((unsigned char *)buf___0 + 36))) | ((unsigned int )*((unsigned char *)buf___0 + ((37 + 2 * (int )*((unsigned char *)buf___0 + 36)) + 1)) << 8));
#line 1409
  if (DEBUGLEVEL >= 5) {
    {
#line 1409
    Debug1((char *)"smb_bcc=%d\n", bcc);
    }
  }
#line 1410
  if (DEBUGLEVEL < 10) {
#line 1411
    return;
  }
#line 1412
  i___0 = 0;
  {
#line 1412
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1412
    if (bcc < 128) {
#line 1412
      tmp___1 = bcc;
    } else {
#line 1412
      tmp___1 = 128;
    }
#line 1412
    if (! (i___0 < tmp___1)) {
#line 1412
      goto while_break___0;
    }
#line 1413
    if (DEBUGLEVEL >= 10) {
      {
#line 1413
      tmp___0 = smb_buf(buf___0);
#line 1413
      Debug1((char *)"%X ", (int )*((unsigned char *)tmp___0 + i___0));
      }
    }
#line 1412
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1414
  if (DEBUGLEVEL >= 10) {
    {
#line 1414
    Debug1((char *)"\n");
    }
  }
#line 1415
  return;
}
}
#line 1420 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int smb_len(char *buf___0 ) 
{ 


  {
#line 1422
  return ((int )(((unsigned int )*((unsigned char *)buf___0 + 3) | ((unsigned int )*((unsigned char *)buf___0 + 2) << 8)) | (((unsigned int )*((unsigned char *)buf___0 + 1) & 1U) << 16)));
}
}
#line 1428 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void _smb_setlen(char *buf___0 , int len ) 
{ 


  {
#line 1430
  *(buf___0 + 0) = (char)0;
#line 1431
  *(buf___0 + 1) = (char )((len & 65536) >> 16);
#line 1432
  *(buf___0 + 2) = (char )((len & 65280) >> 8);
#line 1433
  *(buf___0 + 3) = (char )(len & 255);
#line 1434
  return;
}
}
#line 1439 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void smb_setlen(char *buf___0 , int len ) 
{ 


  {
  {
#line 1441
  _smb_setlen(buf___0, len);
#line 1443
  *((unsigned char *)buf___0 + 4) = (unsigned char)255;
#line 1444
  *((unsigned char *)buf___0 + 5) = (unsigned char )'S';
#line 1445
  *((unsigned char *)buf___0 + 6) = (unsigned char )'M';
#line 1446
  *((unsigned char *)buf___0 + 7) = (unsigned char )'B';
  }
#line 1447
  return;
}
}
#line 1452 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int set_message(char *buf___0 , int num_words , int num_bytes , BOOL zero ) 
{ 


  {
#line 1454
  if (zero) {
    {
#line 1455
    bzero((void *)(buf___0 + 39), (size_t )(num_words * 2 + num_bytes));
    }
  }
  {
#line 1456
  *((unsigned char *)buf___0 + 36) = (unsigned char )num_words;
#line 1457
  *((unsigned char *)buf___0 + (37 + num_words * 2)) = (unsigned char )((int )((uint16 )num_bytes) & 255);
#line 1457
  *((unsigned char *)buf___0 + ((37 + num_words * 2) + 1)) = (unsigned char )((int )((uint16 )num_bytes) >> 8);
#line 1458
  smb_setlen(buf___0, ((39 + num_words * 2) + num_bytes) - 4);
  }
#line 1459
  return ((39 + num_words * 2) + num_bytes);
}
}
#line 1465 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int smb_numwords(char *buf___0 ) 
{ 


  {
#line 1467
  return ((int )*((unsigned char *)buf___0 + 36));
}
}
#line 1473 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int smb_buflen(char *buf___0 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1475
  tmp = smb_numwords(buf___0);
#line 1475
  tmp___0 = smb_numwords(buf___0);
  }
#line 1475
  return ((int )((unsigned int )*((unsigned char *)buf___0 + (37 + tmp * 2)) | ((unsigned int )*((unsigned char *)buf___0 + ((37 + tmp___0 * 2) + 1)) << 8)));
}
}
#line 1481 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int smb_buf_ofs(char *buf___0 ) 
{ 


  {
#line 1483
  return (39 + (int )*((unsigned char *)buf___0 + 36) * 2);
}
}
#line 1489 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *smb_buf(char *buf___0 ) 
{ 
  int tmp ;

  {
  {
#line 1491
  tmp = smb_buf_ofs(buf___0);
  }
#line 1491
  return (buf___0 + tmp);
}
}
#line 1497 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int smb_offset(char *p , char *buf___0 ) 
{ 


  {
#line 1499
  return ((int )(p - (buf___0 + 4)));
}
}
#line 1506 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *skip_string(char *buf___0 , int n ) 
{ 
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 1508
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1508
    tmp___0 = n;
#line 1508
    n --;
#line 1508
    if (! tmp___0) {
#line 1508
      goto while_break;
    }
    {
#line 1509
    tmp = strlen((char const   *)buf___0);
#line 1509
    buf___0 += tmp + 1UL;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1510
  return (buf___0);
}
}
#line 1516 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL trim_string(char *s , char *front , char *back ) 
{ 
  BOOL ret___2 ;
  char *p ;
  char tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;

  {
#line 1518
  ret___2 = 0;
  {
#line 1519
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1519
    if (front) {
#line 1519
      if (*front) {
        {
#line 1519
        tmp___1 = strlen((char const   *)front);
#line 1519
        tmp___2 = strncmp((char const   *)s, (char const   *)front, tmp___1);
        }
#line 1519
        if (! (tmp___2 == 0)) {
#line 1519
          goto while_break;
        }
      } else {
#line 1519
        goto while_break;
      }
    } else {
#line 1519
      goto while_break;
    }
#line 1521
    p = s;
#line 1522
    ret___2 = 1;
    {
#line 1523
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1525
      tmp___0 = strlen((char const   *)front);
#line 1525
      tmp = *(p + tmp___0);
#line 1525
      *p = tmp;
      }
#line 1525
      if (! tmp) {
#line 1526
        goto while_break___0;
      }
#line 1527
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1530
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1530
    if (back) {
#line 1530
      if (*back) {
        {
#line 1530
        tmp___5 = strlen((char const   *)s);
#line 1530
        tmp___6 = strlen((char const   *)back);
        }
#line 1530
        if (tmp___5 >= tmp___6) {
          {
#line 1530
          tmp___7 = strlen((char const   *)back);
#line 1530
          tmp___8 = strlen((char const   *)s);
#line 1530
          tmp___9 = strlen((char const   *)back);
#line 1530
          tmp___10 = strncmp((char const   *)((s + tmp___8) - tmp___9), (char const   *)back,
                             tmp___7);
          }
#line 1530
          if (! (tmp___10 == 0)) {
#line 1530
            goto while_break___1;
          }
        } else {
#line 1530
          goto while_break___1;
        }
      } else {
#line 1530
        goto while_break___1;
      }
    } else {
#line 1530
      goto while_break___1;
    }
    {
#line 1533
    ret___2 = 1;
#line 1534
    tmp___3 = strlen((char const   *)s);
#line 1534
    tmp___4 = strlen((char const   *)back);
#line 1534
    *(s + (tmp___3 - tmp___4)) = (char)0;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1536
  return (ret___2);
}
}
#line 1543 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void dos_clean_name(char *s ) 
{ 
  char *p ;
  pstring s1 ;

  {
#line 1545
  p = (char *)((void *)0);
#line 1547
  if (DEBUGLEVEL >= 3) {
    {
#line 1547
    Debug1((char *)"dos_clean_name [%s]\n", s);
    }
  }
  {
#line 1550
  string_sub(s, (char *)"\\\\", (char *)"\\");
  }
  {
#line 1552
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1552
    p = strstr((char const   *)s, "\\..\\");
    }
#line 1552
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1552
      goto while_break;
    }
    {
#line 1556
    *p = (char)0;
#line 1557
    StrCpy(s1, p + 3);
#line 1559
    p = strrchr((char const   *)s, '\\');
    }
#line 1559
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1560
      *p = (char)0;
    } else {
#line 1562
      *s = (char)0;
    }
    {
#line 1563
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)(s1));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1566
  trim_string(s, (char *)((void *)0), (char *)"\\..");
#line 1568
  string_sub(s, (char *)"\\.\\", (char *)"\\");
  }
#line 1569
  return;
}
}
#line 1574 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void unix_clean_name(char *s ) 
{ 
  char *p ;
  pstring s1 ;

  {
#line 1576
  p = (char *)((void *)0);
#line 1578
  if (DEBUGLEVEL >= 3) {
    {
#line 1578
    Debug1((char *)"unix_clean_name [%s]\n", s);
    }
  }
  {
#line 1581
  string_sub(s, (char *)"//", (char *)"/");
  }
  {
#line 1583
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1583
    p = strstr((char const   *)s, "/../");
    }
#line 1583
    if (! ((unsigned long )p != (unsigned long )((void *)0))) {
#line 1583
      goto while_break;
    }
    {
#line 1587
    *p = (char)0;
#line 1588
    StrCpy(s1, p + 3);
#line 1590
    p = strrchr((char const   *)s, '/');
    }
#line 1590
    if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 1591
      *p = (char)0;
    } else {
#line 1593
      *s = (char)0;
    }
    {
#line 1594
    strcat((char */* __restrict  */)s, (char const   */* __restrict  */)(s1));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1597
  trim_string(s, (char *)((void *)0), (char *)"/..");
  }
#line 1598
  return;
}
}
#line 1607 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char LastDir[1024]  = {      (char )'\000'};
#line 1604 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int ChDir(char *path ) 
{ 
  int res ;
  BOOL tmp ;
  BOOL tmp___0 ;

  {
  {
#line 1609
  tmp = strcsequal(path, (char *)".");
  }
#line 1609
  if (tmp) {
#line 1609
    return (0);
  }
#line 1611
  if ((int )*path == 47) {
    {
#line 1611
    tmp___0 = strcsequal(LastDir, path);
    }
#line 1611
    if (tmp___0) {
#line 1611
      return (0);
    }
  }
#line 1612
  if (DEBUGLEVEL >= 3) {
    {
#line 1612
    Debug1((char *)"chdir to %s\n", path);
    }
  }
  {
#line 1613
  res = sys_chdir(path);
  }
#line 1614
  if (! res) {
    {
#line 1615
    StrCpy(LastDir, path);
    }
  }
#line 1616
  return (res);
}
}
#line 1623 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char *Dumb_GetWd(char *s ) 
{ 
  char *tmp ;

  {
  {
#line 1626
  tmp = getcwd(s, sizeof(pstring ));
  }
#line 1626
  return (tmp);
}
}
#line 1636 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct __anonstruct_ino_list_92 ino_list[50]  ;
#line 1644 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL use_getwd_cache  =    1;
#line 1652 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static BOOL getwd_cache_init  =    0;
#line 1649 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *GetWd(char *str ) 
{ 
  pstring s ;
  struct stat st ;
  struct stat st2 ;
  int i___0 ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;

  {
#line 1656
  s[0] = (char)0;
#line 1658
  if (! use_getwd_cache) {
    {
#line 1659
    tmp = Dumb_GetWd(str);
    }
#line 1659
    return (tmp);
  }
#line 1662
  if (! getwd_cache_init) {
#line 1664
    getwd_cache_init = 1;
#line 1665
    i___0 = 0;
    {
#line 1665
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1665
      if (! (i___0 < 50)) {
#line 1665
        goto while_break;
      }
      {
#line 1667
      string_init(& ino_list[i___0].text, (char *)"");
#line 1668
      ino_list[i___0].valid = 0;
#line 1665
      i___0 ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 1675
  tmp___1 = stat((char const   */* __restrict  */)".", (struct stat */* __restrict  */)(& st));
  }
#line 1675
  if (tmp___1 == -1) {
#line 1677
    if (DEBUGLEVEL >= 0) {
      {
#line 1677
      Debug1((char *)"Very strange, couldn\'t stat \".\"\n");
      }
    }
    {
#line 1678
    tmp___0 = Dumb_GetWd(str);
    }
#line 1678
    return (tmp___0);
  }
#line 1682
  i___0 = 0;
  {
#line 1682
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1682
    if (! (i___0 < 50)) {
#line 1682
      goto while_break___0;
    }
#line 1683
    if (ino_list[i___0].valid) {
#line 1692
      if (st.st_ino == ino_list[i___0].inode) {
#line 1692
        if (st.st_dev == ino_list[i___0].dev) {
          {
#line 1695
          tmp___2 = stat((char const   */* __restrict  */)ino_list[i___0].text, (struct stat */* __restrict  */)(& st2));
          }
#line 1695
          if (tmp___2 == 0) {
#line 1697
            if (st.st_ino == st2.st_ino) {
#line 1697
              if (st.st_dev == st2.st_dev) {
#line 1697
                if ((st2.st_mode & 61440U) == 16384U) {
                  {
#line 1701
                  StrCpy(str, ino_list[i___0].text);
#line 1704
                  array_promote((char *)(& ino_list[0]), (int )sizeof(ino_list[0]),
                                i___0);
                  }
#line 1705
                  return (str);
                } else {
#line 1711
                  ino_list[i___0].valid = 0;
                }
              } else {
#line 1711
                ino_list[i___0].valid = 0;
              }
            } else {
#line 1711
              ino_list[i___0].valid = 0;
            }
          }
        }
      }
    }
#line 1682
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1722
  tmp___4 = Dumb_GetWd(s);
  }
#line 1722
  if (! tmp___4) {
#line 1724
    if (DEBUGLEVEL >= 0) {
      {
#line 1724
      tmp___3 = __errno_location();
#line 1724
      Debug1((char *)"Getwd failed, errno %d\n", *tmp___3);
      }
    }
#line 1725
    return ((char *)((void *)0));
  }
  {
#line 1728
  StrCpy(str, s);
  }
#line 1730
  if (DEBUGLEVEL >= 5) {
    {
#line 1730
    Debug1((char *)"GetWd %s, inode %d, dev %x\n", s, (int )st.st_ino, (int )st.st_dev);
    }
  }
  {
#line 1733
  i___0 = 49;
#line 1734
  string_set(& ino_list[i___0].text, s);
#line 1735
  ino_list[i___0].dev = st.st_dev;
#line 1736
  ino_list[i___0].inode = st.st_ino;
#line 1737
  ino_list[i___0].valid = 1;
#line 1740
  array_promote((char *)(& ino_list[0]), (int )sizeof(ino_list[0]), i___0);
  }
#line 1742
  return (str);
}
}
#line 1754 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL reduce_name(char *s , char *dir , BOOL widelinks ) 
{ 
  pstring dir2 ;
  pstring wd ;
  pstring basename ;
  pstring newname ;
  char *p ;
  BOOL relative ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  int l ;
  size_t tmp___7 ;
  int tmp___8 ;
  size_t tmp___9 ;

  {
#line 1763
  p = (char *)((void *)0);
#line 1764
  relative = (int )*s != 47;
#line 1766
  newname[0] = (char)0;
#line 1766
  basename[0] = newname[0];
#line 1766
  wd[0] = basename[0];
#line 1766
  dir2[0] = wd[0];
#line 1768
  if (widelinks) {
    {
#line 1770
    unix_clean_name(s);
#line 1772
    tmp = strncmp((char const   *)s, "..", (size_t )2);
    }
#line 1772
    if (tmp == 0) {
#line 1772
      if ((int )*(s + 2) == 0) {
#line 1772
        goto _L;
      } else
#line 1772
      if ((int )*(s + 2) == 47) {
        _L: /* CIL Label */ 
#line 1774
        if (DEBUGLEVEL >= 3) {
          {
#line 1774
          Debug1((char *)"Illegal file name? (%s)\n", s);
          }
        }
#line 1775
        return (0);
      }
    }
#line 1777
    return (1);
  }
#line 1780
  if (DEBUGLEVEL >= 3) {
    {
#line 1780
    Debug1((char *)"reduce_name [%s] [%s]\n", s, dir);
    }
  }
  {
#line 1783
  string_sub(s, (char *)"//", (char *)"/");
#line 1785
  StrCpy(basename, s);
#line 1786
  p = strrchr((char const   *)(basename), '/');
  }
#line 1788
  if (! p) {
#line 1789
    return (1);
  }
  {
#line 1791
  tmp___0 = GetWd(wd);
  }
#line 1791
  if (! tmp___0) {
#line 1793
    if (DEBUGLEVEL >= 0) {
      {
#line 1793
      Debug1((char *)"couldn\'t getwd for %s %s\n", s, dir);
      }
    }
#line 1794
    return (0);
  }
  {
#line 1797
  tmp___1 = ChDir(dir);
  }
#line 1797
  if (tmp___1 != 0) {
#line 1799
    if (DEBUGLEVEL >= 0) {
      {
#line 1799
      Debug1((char *)"couldn\'t chdir to %s\n", dir);
      }
    }
#line 1800
    return (0);
  }
  {
#line 1803
  tmp___2 = GetWd(dir2);
  }
#line 1803
  if (! tmp___2) {
#line 1805
    if (DEBUGLEVEL >= 0) {
      {
#line 1805
      Debug1((char *)"couldn\'t getwd for %s\n", dir);
      }
    }
    {
#line 1806
    ChDir(wd);
    }
#line 1807
    return (0);
  }
#line 1811
  if (p) {
#line 1811
    if ((unsigned long )p != (unsigned long )(basename)) {
      {
#line 1813
      *p = (char)0;
#line 1814
      tmp___3 = strcmp((char const   *)(p + 1), ".");
      }
#line 1814
      if (tmp___3 == 0) {
#line 1815
        *(p + 1) = (char)0;
      }
      {
#line 1816
      tmp___4 = strcmp((char const   *)(p + 1), "..");
      }
#line 1816
      if (tmp___4 == 0) {
#line 1817
        *p = (char )'/';
      }
    }
  }
  {
#line 1820
  tmp___5 = ChDir(basename);
  }
#line 1820
  if (tmp___5 != 0) {
    {
#line 1822
    ChDir(wd);
    }
#line 1823
    if (DEBUGLEVEL >= 3) {
      {
#line 1823
      Debug1((char *)"couldn\'t chdir for %s %s basename=%s\n", s, dir, basename);
      }
    }
#line 1824
    return (0);
  }
  {
#line 1827
  tmp___6 = GetWd(newname);
  }
#line 1827
  if (! tmp___6) {
    {
#line 1829
    ChDir(wd);
    }
#line 1830
    if (DEBUGLEVEL >= 2) {
      {
#line 1830
      Debug1((char *)"couldn\'t get wd for %s %s\n", s, dir2);
      }
    }
#line 1831
    return (0);
  }
#line 1834
  if (p) {
#line 1834
    if ((unsigned long )p != (unsigned long )(basename)) {
      {
#line 1836
      strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)"/");
#line 1837
      strcat((char */* __restrict  */)(newname), (char const   */* __restrict  */)(p + 1));
      }
    }
  }
  {
#line 1841
  tmp___7 = strlen((char const   *)(dir2));
#line 1841
  l = (int )tmp___7;
  }
#line 1842
  if ((int )dir2[l - 1] == 47) {
#line 1843
    l --;
  }
  {
#line 1845
  tmp___8 = strncmp((char const   *)(newname), (char const   *)(dir2), (size_t )l);
  }
#line 1845
  if (tmp___8 != 0) {
    {
#line 1847
    ChDir(wd);
    }
#line 1848
    if (DEBUGLEVEL >= 2) {
      {
#line 1848
      Debug1((char *)"Bad access attempt? s=%s dir=%s newname=%s l=%d\n", s, dir2,
             newname, l);
      }
    }
#line 1849
    return (0);
  }
#line 1852
  if (relative) {
#line 1854
    if ((int )newname[l] == 47) {
      {
#line 1855
      StrCpy(s, (newname + l) + 1);
      }
    } else {
      {
#line 1857
      StrCpy(s, newname + l);
      }
    }
  } else {
    {
#line 1860
    StrCpy(s, newname);
    }
  }
  {
#line 1863
  ChDir(wd);
#line 1865
  tmp___9 = strlen((char const   *)s);
  }
#line 1865
  if (tmp___9 == 0UL) {
    {
#line 1866
    StrCpy(s, (char *)"./");
    }
  }
#line 1868
  if (DEBUGLEVEL >= 3) {
    {
#line 1868
    Debug1((char *)"reduced to %s\n", s);
    }
  }
#line 1869
  return (1);
}
}
#line 1876 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static void expand_one(char *Mask , int len ) 
{ 
  char *p1 ;
  int lfill ;
  size_t tmp ;
  int l1 ;
  pstring tmp___0 ;

  {
  {
#line 1879
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1879
    p1 = strchr((char const   *)Mask, '*');
    }
#line 1879
    if (! ((unsigned long )p1 != (unsigned long )((void *)0))) {
#line 1879
      goto while_break;
    }
    {
#line 1881
    tmp = strlen((char const   *)Mask);
#line 1881
    lfill = (int )((size_t )(len + 1) - tmp);
#line 1882
    l1 = (int )(p1 - Mask);
#line 1884
    StrCpy(tmp___0, Mask);
#line 1885
    memset((void *)(tmp___0 + l1), '?', (size_t )lfill);
#line 1886
    StrCpy((tmp___0 + l1) + lfill, (Mask + l1) + 1);
#line 1887
    StrCpy(Mask, tmp___0);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1889
  return;
}
}
#line 1894 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void expand_mask(char *Mask , BOOL doext ) 
{ 
  pstring mbeg ;
  pstring mext ;
  pstring dirpart ;
  pstring filepart ;
  BOOL hasdot ;
  char *p1 ;
  BOOL absolute ;
  char *tmp ;
  size_t tmp___0 ;

  {
  {
#line 1899
  hasdot = 0;
#line 1901
  absolute = (int )*Mask == 92;
#line 1903
  filepart[0] = (char)0;
#line 1903
  dirpart[0] = filepart[0];
#line 1903
  mext[0] = dirpart[0];
#line 1903
  mbeg[0] = mext[0];
#line 1906
  tmp = strchr((char const   *)Mask, '\\');
  }
#line 1906
  if (tmp) {
    {
#line 1907
    dirname_dos(Mask, dirpart);
    }
  }
  {
#line 1909
  filename_dos(Mask, filepart);
#line 1911
  StrCpy(mbeg, filepart);
#line 1912
  p1 = strchr((char const   *)(mbeg), '.');
  }
#line 1912
  if ((unsigned long )p1 != (unsigned long )((void *)0)) {
    {
#line 1914
    hasdot = 1;
#line 1915
    *p1 = (char)0;
#line 1916
    p1 ++;
#line 1917
    StrCpy(mext, p1);
    }
  } else {
    {
#line 1921
    StrCpy(mext, (char *)"");
#line 1922
    tmp___0 = strlen((char const   *)(mbeg));
    }
#line 1922
    if (tmp___0 > 8UL) {
      {
#line 1924
      StrCpy(mext, mbeg + 8);
#line 1925
      mbeg[8] = (char)0;
      }
    }
  }
#line 1929
  if ((int )mbeg[0] == 0) {
    {
#line 1930
    StrCpy(mbeg, (char *)"????????");
    }
  }
#line 1931
  if ((int )mext[0] == 0) {
#line 1931
    if (doext) {
#line 1931
      if (! hasdot) {
        {
#line 1932
        StrCpy(mext, (char *)"???");
        }
      }
    }
  }
  {
#line 1935
  expand_one(mbeg, 8);
  }
#line 1936
  if (mext[0]) {
    {
#line 1937
    expand_one(mext, 3);
    }
  }
  {
#line 1939
  StrCpy(Mask, dirpart);
  }
#line 1940
  if (dirpart[0]) {
    {
#line 1940
    strcat((char */* __restrict  */)Mask, (char const   */* __restrict  */)"\\");
    }
  } else
#line 1940
  if (absolute) {
    {
#line 1940
    strcat((char */* __restrict  */)Mask, (char const   */* __restrict  */)"\\");
    }
  }
  {
#line 1941
  strcat((char */* __restrict  */)Mask, (char const   */* __restrict  */)(mbeg));
#line 1942
  strcat((char */* __restrict  */)Mask, (char const   */* __restrict  */)".");
#line 1943
  strcat((char */* __restrict  */)Mask, (char const   */* __restrict  */)(mext));
  }
#line 1945
  if (DEBUGLEVEL >= 6) {
    {
#line 1945
    Debug1((char *)"Mask expanded to [%s]\n", Mask);
    }
  }
#line 1946
  return;
}
}
#line 1952 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL strhasupper(char *s ) 
{ 


  {
  {
#line 1954
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1954
    if (! *s) {
#line 1954
      goto while_break;
    }
#line 1966
    if ((int )*s != (int )*(lower_char_map + *s)) {
#line 1966
      return (1);
    }
#line 1967
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1970
  return (0);
}
}
#line 1976 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL strhaslower(char *s ) 
{ 


  {
  {
#line 1978
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1978
    if (! *s) {
#line 1978
      goto while_break;
    }
#line 1990
    if ((int )*s != (int )*(upper_char_map + *s)) {
#line 1990
      return (1);
    }
#line 1991
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1994
  return (0);
}
}
#line 2000 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int count_chars(char *s , char c ) 
{ 
  int count___0 ;

  {
#line 2002
  count___0 = 0;
  {
#line 2003
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2003
    if (! *s) {
#line 2003
      goto while_break;
    }
#line 2005
    if ((int )*s == (int )c) {
#line 2006
      count___0 ++;
    }
#line 2007
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2009
  return (count___0);
}
}
#line 2016 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void make_dir_struct(char *buf___0 , char *mask , char *fname , unsigned int size___0 ,
                     int mode , time_t date ) 
{ 
  char *p ;
  pstring mask2 ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  size_t tmp___10 ;

  {
  {
#line 2021
  StrCpy(mask2, mask);
  }
#line 2023
  if (((long )mode & (1L << 4)) != 0L) {
#line 2024
    size___0 = 0U;
  }
  {
#line 2026
  memset((void *)(buf___0 + 1), ' ', (size_t )11);
#line 2027
  p = strchr((char const   *)(mask2), '.');
  }
#line 2027
  if ((unsigned long )p != (unsigned long )((void *)0)) {
    {
#line 2029
    *p = (char)0;
#line 2030
    tmp___2 = strlen((char const   *)(mask2));
    }
#line 2030
    if (tmp___2 < 8UL) {
      {
#line 2030
      tmp___0 = strlen((char const   *)(mask2));
#line 2030
      tmp___1 = tmp___0;
      }
    } else {
#line 2030
      tmp___1 = (size_t )8;
    }
    {
#line 2030
    memcpy((void */* __restrict  */)(buf___0 + 1), (void const   */* __restrict  */)(mask2),
           tmp___1);
#line 2031
    tmp___6 = strlen((char const   *)(p + 1));
    }
#line 2031
    if (tmp___6 < 3UL) {
      {
#line 2031
      tmp___4 = strlen((char const   *)(p + 1));
#line 2031
      tmp___5 = tmp___4;
      }
    } else {
#line 2031
      tmp___5 = (size_t )3;
    }
    {
#line 2031
    memcpy((void */* __restrict  */)(buf___0 + 9), (void const   */* __restrict  */)(p + 1),
           tmp___5);
#line 2032
    *p = (char )'.';
    }
  } else {
    {
#line 2035
    tmp___10 = strlen((char const   *)(mask2));
    }
#line 2035
    if (tmp___10 < 11UL) {
      {
#line 2035
      tmp___8 = strlen((char const   *)(mask2));
#line 2035
      tmp___9 = tmp___8;
      }
    } else {
#line 2035
      tmp___9 = (size_t )11;
    }
    {
#line 2035
    memcpy((void */* __restrict  */)(buf___0 + 1), (void const   */* __restrict  */)(mask2),
           tmp___9);
    }
  }
  {
#line 2037
  bzero((void *)(buf___0 + 21), (size_t )22);
#line 2038
  *((unsigned char *)buf___0 + 21) = (unsigned char )mode;
#line 2039
  put_dos_date(buf___0, 22, date);
#line 2040
  *((unsigned char *)buf___0 + 26) = (unsigned char )((int )((uint16 )(size___0 & 65535U)) & 255);
#line 2040
  *((unsigned char *)buf___0 + 27) = (unsigned char )((int )((uint16 )(size___0 & 65535U)) >> 8);
#line 2041
  *((unsigned char *)buf___0 + 28) = (unsigned char )((int )((uint16 )(size___0 >> 16)) & 255);
#line 2041
  *((unsigned char *)buf___0 + 29) = (unsigned char )((int )((uint16 )(size___0 >> 16)) >> 8);
#line 2042
  StrnCpy(buf___0 + 30, (char const   *)fname, 12);
  }
#line 2043
  if (! case_sensitive) {
    {
#line 2044
    strupper(buf___0 + 30);
    }
  }
#line 2045
  if (DEBUGLEVEL >= 8) {
    {
#line 2045
    Debug1((char *)"put name [%s] into dir struct\n", buf___0 + 30);
    }
  }
#line 2046
  return;
}
}
#line 2052 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void close_low_fds(void) 
{ 
  int fd ;
  int i___0 ;

  {
  {
#line 2056
  close(0);
#line 2056
  close(1);
#line 2056
  close(2);
#line 2059
  i___0 = 0;
  }
  {
#line 2059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2059
    if (! (i___0 < 3)) {
#line 2059
      goto while_break;
    }
    {
#line 2060
    fd = open("/dev/null", 2, 0);
    }
#line 2061
    if (fd < 0) {
      {
#line 2061
      fd = open("/dev/null", 1, 0);
      }
    }
#line 2062
    if (fd < 0) {
#line 2063
      if (DEBUGLEVEL >= 0) {
        {
#line 2063
        Debug1((char *)"Can\'t open /dev/null\n");
        }
      }
#line 2064
      return;
    }
#line 2066
    if (fd != i___0) {
#line 2067
      if (DEBUGLEVEL >= 0) {
        {
#line 2067
        Debug1((char *)"Didn\'t get file descriptor %d\n", i___0);
        }
      }
#line 2068
      return;
    }
#line 2059
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2071
  return;
}
}
#line 2077 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int write_socket(int fd , char *buf___0 , int len ) 
{ 
  int ret___2 ;

  {
#line 2079
  ret___2 = 0;
#line 2081
  if (passive) {
#line 2082
    return (len);
  }
#line 2083
  if (DEBUGLEVEL >= 6) {
    {
#line 2083
    Debug1((char *)"write_socket(%d,%d)\n", fd, len);
    }
  }
  {
#line 2084
  ret___2 = write_data(fd, buf___0, len);
  }
#line 2086
  if (DEBUGLEVEL >= 6) {
    {
#line 2086
    Debug1((char *)"write_socket(%d,%d) wrote %d\n", fd, len, ret___2);
    }
  }
#line 2087
  return (ret___2);
}
}
#line 2093 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int read_udp_socket(int fd , char *buf___0 , int len ) 
{ 
  int ret___2 ;
  struct sockaddr sock ;
  int socklen ;
  ssize_t tmp ;
  int *tmp___0 ;
  uint16_t tmp___1 ;

  {
  {
#line 2099
  socklen = (int )sizeof(sock);
#line 2100
  bzero((void *)((char *)(& sock)), (size_t )socklen);
#line 2101
  bzero((void *)((char *)(& lastip)), sizeof(lastip));
#line 2102
  tmp = recvfrom(fd, (void */* __restrict  */)buf___0, (size_t )len, 0, (struct sockaddr */* __restrict  */)(& sock),
                 (socklen_t */* __restrict  */)(& socklen));
#line 2102
  ret___2 = (int )tmp;
  }
#line 2103
  if (ret___2 <= 0) {
#line 2105
    if (DEBUGLEVEL >= 2) {
      {
#line 2105
      tmp___0 = __errno_location();
#line 2105
      Debug1((char *)"read socket failed. ERRNO=%d\n", *tmp___0);
      }
    }
#line 2106
    return (0);
  }
  {
#line 2109
  lastip = *((struct in_addr *)(& sock.sa_data[2]));
#line 2110
  tmp___1 = ntohs(((struct sockaddr_in *)(& sock))->sin_port);
#line 2110
  lastport = (int )tmp___1;
  }
#line 2112
  return (ret___2);
}
}
#line 2121 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int set_blocking(int fd , BOOL set ) 
{ 
  int val ;
  int tmp ;

  {
  {
#line 2134
  val = fcntl(fd, 3, 0);
  }
#line 2134
  if (val == -1) {
#line 2135
    return (-1);
  }
#line 2136
  if (set) {
#line 2137
    val &= -2049;
  } else {
#line 2139
    val |= 2048;
  }
  {
#line 2140
  tmp = fcntl(fd, 4, val);
  }
#line 2140
  return (tmp);
}
}
#line 2150 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static int tval_sub(struct timeval *retval , struct timeval *val1 , struct timeval *val2 ) 
{ 
  int usecdiff ;
  int secdiff ;
  int tmp ;
  int tmp___0 ;

  {
#line 2152
  usecdiff = (int )(val1->tv_usec - val2->tv_usec);
#line 2153
  secdiff = (int )(val1->tv_sec - val2->tv_sec);
#line 2154
  if (usecdiff < 0) {
#line 2155
    usecdiff = 1000000 + usecdiff;
#line 2156
    secdiff --;
  }
#line 2158
  retval->tv_sec = (__time_t )secdiff;
#line 2159
  retval->tv_usec = (__suseconds_t )usecdiff;
#line 2160
  if (secdiff < 0) {
#line 2161
    return (-1);
  }
#line 2162
  if (secdiff > 0) {
#line 2163
    return (1);
  }
#line 2164
  if (usecdiff < 0) {
#line 2164
    tmp___0 = -1;
  } else {
#line 2164
    if (usecdiff > 0) {
#line 2164
      tmp = 1;
    } else {
#line 2164
      tmp = 0;
    }
#line 2164
    tmp___0 = tmp;
  }
#line 2164
  return (tmp___0);
}
}
#line 2172 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int read_with_timeout(int fd , char *buf___0 , int mincnt , int maxcnt , long time_out ,
                      BOOL exact ) 
{ 
  fd_set fds ;
  int selrtn ;
  int readret ;
  int nread ;
  struct timeval timeout ;
  struct timeval tval1 ;
  struct timeval tval2 ;
  struct timeval tvaldiff ;
  ssize_t tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;
  int __d0 ;
  int __d1 ;
  int *tmp___2 ;
  ssize_t tmp___3 ;
  int *tmp___4 ;
  int tmp___5 ;

  {
#line 2177
  nread = 0;
#line 2181
  if (maxcnt <= 0) {
#line 2181
    return (0);
  }
#line 2183
  if (time_out == -2L) {
#line 2184
    time_out = 10000000L;
  }
#line 2187
  if (time_out < 0L) {
#line 2188
    if (mincnt == 0) {
#line 2188
      mincnt = maxcnt;
    }
    {
#line 2190
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2190
      if (! (nread < mincnt)) {
#line 2190
        goto while_break;
      }
      {
#line 2192
      tmp = read(fd, (void *)(buf___0 + nread), (size_t )(maxcnt - nread));
#line 2192
      readret = (int )tmp;
      }
#line 2193
      if (readret <= 0) {
#line 2193
        return (nread);
      }
#line 2194
      nread += readret;
    }
    while_break: /* CIL Label */ ;
    }
#line 2196
    return (nread);
  }
#line 2200
  if (time_out == 0L) {
    {
#line 2201
    set_blocking(fd, 0);
#line 2202
    nread = read_data(fd, buf___0, mincnt);
    }
#line 2203
    if (nread < maxcnt) {
      {
#line 2204
      tmp___0 = read(fd, (void *)(buf___0 + nread), (size_t )(maxcnt - nread));
#line 2204
      nread = (int )((ssize_t )nread + tmp___0);
      }
    }
#line 2205
    if (nread == -1) {
      {
#line 2205
      tmp___1 = __errno_location();
      }
#line 2205
      if (*tmp___1 == 11) {
#line 2206
        nread = 0;
      }
    }
    {
#line 2207
    set_blocking(fd, 1);
    }
#line 2208
    return (nread);
  }
#line 2218
  timeout.tv_sec = time_out / 1000L;
#line 2219
  timeout.tv_usec = 1000L * (time_out % 1000L);
#line 2226
  if (exact) {
    {
#line 2227
    GetTimeOfDay(& tval1);
    }
  }
#line 2228
  nread = 0;
  {
#line 2230
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 2233
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2233
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 2233
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2234
    fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 2236
    selrtn = sys_select(& fds, & timeout);
    }
#line 2239
    if (selrtn == -1) {
      {
#line 2241
      tmp___2 = __errno_location();
#line 2241
      *tmp___2 = 9;
      }
#line 2242
      return (-1);
    }
#line 2246
    if (selrtn == 0) {
#line 2247
      if (nread < mincnt) {
#line 2247
        return (-1);
      }
#line 2248
      goto while_break___0;
    }
    {
#line 2251
    tmp___3 = read(fd, (void *)(buf___0 + nread), (size_t )(maxcnt - nread));
#line 2251
    readret = (int )tmp___3;
    }
#line 2252
    if (readret <= 0) {
      {
#line 2256
      tmp___4 = __errno_location();
#line 2256
      *tmp___4 = 9;
      }
#line 2257
      return (-1);
    }
#line 2260
    if (readret == 0) {
#line 2261
      goto while_break___0;
    }
#line 2263
    nread += readret;
#line 2266
    if (nread >= mincnt) {
#line 2267
      goto while_break___0;
    }
#line 2272
    if (exact) {
      {
#line 2274
      GetTimeOfDay(& tval2);
#line 2275
      tval_sub(& tvaldiff, & tval2, & tval1);
#line 2277
      tmp___5 = tval_sub(& timeout, & timeout, & tvaldiff);
      }
#line 2277
      if (tmp___5 <= 0) {
#line 2280
        goto while_break___0;
      }
    }
#line 2286
    tval1 = tval2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2290
  return (nread);
}
}
#line 2296 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int read_max_udp(int fd , char *buffer , int bufsize , int maxtime ) 
{ 
  fd_set fds ;
  int selrtn ;
  int nread ;
  struct timeval timeout ;
  int __d0 ;
  int __d1 ;
  struct timeval *tmp ;

  {
  {
#line 2303
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2303
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 2303
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 2304
  fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 2306
  timeout.tv_sec = (__time_t )(maxtime / 1000);
#line 2307
  timeout.tv_usec = (__suseconds_t )((maxtime % 1000) * 1000);
#line 2309
  if (maxtime > 0) {
#line 2309
    tmp = & timeout;
  } else {
#line 2309
    tmp = (struct timeval *)((void *)0);
  }
  {
#line 2309
  selrtn = sys_select(& fds, tmp);
  }
#line 2311
  if (! ((fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 2312
    return (0);
  }
  {
#line 2314
  nread = read_udp_socket(fd, buffer, bufsize);
  }
#line 2317
  return (nread);
}
}
#line 2324 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int TvalDiff(struct timeval *tvalold , struct timeval *tvalnew ) 
{ 


  {
#line 2326
  return ((int )((tvalnew->tv_sec - tvalold->tv_sec) * 1000L + (__time_t )(((int )tvalnew->tv_usec - (int )tvalold->tv_usec) / 1000)));
}
}
#line 2333 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL send_keepalive(int client ) 
{ 
  unsigned char buf___0[4] ;
  int tmp ;

  {
  {
#line 2337
  buf___0[0] = (unsigned char)133;
#line 2338
  buf___0[3] = (unsigned char)0;
#line 2338
  buf___0[2] = buf___0[3];
#line 2338
  buf___0[1] = buf___0[2];
#line 2340
  tmp = write_data(client, (char *)(buf___0), 4);
  }
#line 2340
  return (tmp == 4);
}
}
#line 2348 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int read_data(int fd , char *buffer , int N ) 
{ 
  int ret___2 ;
  int total ;
  ssize_t tmp ;
  int *tmp___0 ;

  {
#line 2351
  total = 0;
  {
#line 2353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2353
    if (! (total < N)) {
#line 2353
      goto while_break;
    }
    {
#line 2355
    tmp = read(fd, (void *)(buffer + total), (size_t )(N - total));
#line 2355
    ret___2 = (int )tmp;
    }
#line 2358
    if (ret___2 < 0) {
      {
#line 2359
      tmp___0 = __errno_location();
#line 2359
      *tmp___0 = 9;
      }
    }
#line 2361
    if (ret___2 <= 0) {
#line 2362
      return (total);
    }
#line 2363
    total += ret___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 2365
  return (total);
}
}
#line 2372 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int write_data(int fd , char *buffer , int N ) 
{ 
  int total ;
  int ret___2 ;
  ssize_t tmp ;

  {
#line 2374
  total = 0;
  {
#line 2377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2377
    if (! (total < N)) {
#line 2377
      goto while_break;
    }
    {
#line 2379
    tmp = write(fd, (void const   *)(buffer + total), (size_t )(N - total));
#line 2379
    ret___2 = (int )tmp;
    }
#line 2381
    if (ret___2 <= 0) {
#line 2382
      return (total);
    }
#line 2384
    total += ret___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 2386
  return (total);
}
}
#line 2391 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int rp_fd  =    -1;
#line 2392 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int rp_offset  =    0;
#line 2393 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int rp_length  =    0;
#line 2394 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int rp_alloced  =    0;
#line 2395 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int rp_predict_fd  =    -1;
#line 2396 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int rp_predict_offset  =    0;
#line 2397 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int rp_predict_length  =    0;
#line 2398 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int rp_timeout  =    5;
#line 2399 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
time_t rp_time  =    (time_t )0;
#line 2400 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *rp_buffer  =    (char *)((void *)0);
#line 2401 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL predict_skip  =    0;
#line 2402 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
time_t smb_last_time  =    (time_t )0;
#line 2407 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int read_predict(int fd , int offset , char *buf___0 , char **ptr , int num ) 
{ 
  int ret___2 ;
  int possible ;

  {
#line 2409
  ret___2 = 0;
#line 2410
  possible = rp_length - (offset - rp_offset);
#line 2412
  if (possible < num) {
#line 2412
    possible = possible;
  } else {
#line 2412
    possible = num;
  }
#line 2415
  if (fd == rp_fd) {
#line 2415
    if (offset >= rp_offset) {
#line 2415
      if (possible > 0) {
#line 2415
        if (smb_last_time - rp_time < (time_t )rp_timeout) {
#line 2420
          ret___2 = possible;
#line 2421
          if (buf___0) {
            {
#line 2422
            memcpy((void */* __restrict  */)buf___0, (void const   */* __restrict  */)(rp_buffer + (offset - rp_offset)),
                   (size_t )possible);
            }
          } else {
#line 2424
            *ptr = rp_buffer + (offset - rp_offset);
          }
#line 2425
          if (DEBUGLEVEL >= 5) {
            {
#line 2425
            Debug1((char *)"read-prediction gave %d bytes of %d\n", ret___2, num);
            }
          }
        }
      }
    }
  }
#line 2428
  if (ret___2 == num) {
#line 2429
    predict_skip = 1;
  } else {
#line 2431
    predict_skip = 0;
#line 2434
    rp_predict_fd = fd;
#line 2435
    rp_predict_offset = offset + num;
#line 2436
    rp_predict_length = num;
  }
#line 2439
  if (ret___2 < 0) {
#line 2439
    ret___2 = 0;
  }
#line 2441
  return (ret___2);
}
}
#line 2447 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void do_read_prediction(void) 
{ 
  void *tmp ;
  __off_t tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 2449
  if (predict_skip) {
#line 2449
    return;
  }
#line 2451
  if (rp_predict_fd == -1) {
#line 2452
    return;
  }
#line 2454
  rp_fd = rp_predict_fd;
#line 2455
  rp_offset = rp_predict_offset;
#line 2456
  rp_length = 0;
#line 2458
  rp_predict_fd = -1;
#line 2460
  if (rp_predict_length < 2 * ReadSize) {
#line 2460
    rp_predict_length = rp_predict_length;
  } else {
#line 2460
    rp_predict_length = 2 * ReadSize;
  }
#line 2461
  if (rp_predict_length > 1024) {
#line 2461
    rp_predict_length = rp_predict_length;
  } else {
#line 2461
    rp_predict_length = 1024;
  }
#line 2462
  rp_offset = (rp_offset / 1024) * 1024;
#line 2463
  rp_predict_length = (rp_predict_length / 1024) * 1024;
#line 2465
  if (rp_predict_length > rp_alloced) {
    {
#line 2467
    tmp = Realloc((void *)rp_buffer, rp_predict_length);
#line 2467
    rp_buffer = (char *)tmp;
#line 2468
    rp_alloced = rp_predict_length;
    }
#line 2469
    if (! rp_buffer) {
#line 2471
      if (DEBUGLEVEL >= 0) {
        {
#line 2471
        Debug1((char *)"can\'t allocate read-prediction buffer\n");
        }
      }
#line 2472
      rp_predict_fd = -1;
#line 2473
      rp_fd = -1;
#line 2474
      rp_alloced = 0;
#line 2475
      return;
    }
  }
  {
#line 2479
  tmp___0 = lseek(rp_fd, (__off_t )rp_offset, 0);
  }
#line 2479
  if (tmp___0 != (__off_t )rp_offset) {
#line 2480
    rp_fd = -1;
#line 2481
    rp_predict_fd = -1;
#line 2482
    return;
  }
  {
#line 2485
  tmp___1 = read(rp_fd, (void *)rp_buffer, (size_t )rp_predict_length);
#line 2485
  rp_length = (int )tmp___1;
#line 2486
  rp_time = time((time_t *)((void *)0));
  }
#line 2487
  if (rp_length < 0) {
#line 2488
    rp_length = 0;
  }
#line 2489
  return;
}
}
#line 2494 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void invalidate_read_prediction(int fd ) 
{ 


  {
#line 2496
  if (rp_fd == fd) {
#line 2497
    rp_fd = -1;
  }
#line 2498
  if (rp_predict_fd == fd) {
#line 2499
    rp_predict_fd = -1;
  }
#line 2500
  return;
}
}
#line 2508 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char *buf  =    (char *)((void *)0);
#line 2510 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static int size  =    0;
#line 2506 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int transfer_file(int infd , int outfd___0 , int n , char *header , int headlen ,
                  int align ) 
{ 
  char *buf1 ;
  char *abuf ;
  int total ;
  void *tmp ;
  int s ;
  int tmp___0 ;
  int ret___2 ;
  int ret2 ;
  int tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;

  {
#line 2511
  total = 0;
#line 2513
  if (DEBUGLEVEL >= 4) {
    {
#line 2513
    Debug1((char *)"transfer_file %d  (head=%d) called\n", n, headlen);
    }
  }
#line 2515
  if (size < ReadSize) {
#line 2515
    if (buf) {
      {
#line 2516
      free((void *)buf);
#line 2517
      buf = (char *)((void *)0);
      }
    }
  }
#line 2520
  if (ReadSize > 1024) {
#line 2520
    size = ReadSize;
  } else {
#line 2520
    size = 1024;
  }
  {
#line 2522
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2522
    if (! buf) {
#line 2522
      if (! (size > 0)) {
#line 2522
        goto while_break;
      }
    } else {
#line 2522
      goto while_break;
    }
    {
#line 2523
    tmp = Realloc((void *)buf, size + 8);
#line 2523
    buf = (char *)tmp;
    }
#line 2524
    if (! buf) {
#line 2524
      size /= 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2526
  if (! buf) {
#line 2527
    if (DEBUGLEVEL >= 0) {
      {
#line 2527
      Debug1((char *)"Can\'t allocate transfer buffer!\n");
      }
    }
#line 2528
    return (0);
  }
#line 2531
  abuf = buf + align % 8;
#line 2533
  if (header) {
#line 2534
    n += headlen;
  }
  {
#line 2536
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2536
    if (! (n > 0)) {
#line 2536
      goto while_break___0;
    }
#line 2538
    if (n < size) {
#line 2538
      tmp___0 = n;
    } else {
#line 2538
      tmp___0 = size;
    }
#line 2538
    s = tmp___0;
#line 2539
    ret2 = 0;
#line 2541
    ret___2 = 0;
#line 2543
    if (header) {
#line 2543
      if (s < 1024) {
#line 2543
        tmp___1 = s;
      } else {
#line 2543
        tmp___1 = 1024;
      }
#line 2543
      if (headlen >= tmp___1) {
#line 2544
        buf1 = header;
#line 2545
        s = headlen;
#line 2546
        ret___2 = headlen;
#line 2547
        headlen = 0;
#line 2548
        header = (char *)((void *)0);
      } else {
#line 2550
        buf1 = abuf;
      }
    } else {
#line 2550
      buf1 = abuf;
    }
#line 2553
    if (header) {
#line 2553
      if (headlen > 0) {
#line 2555
        if (headlen < size) {
#line 2555
          ret___2 = headlen;
        } else {
#line 2555
          ret___2 = size;
        }
        {
#line 2556
        memcpy((void */* __restrict  */)buf1, (void const   */* __restrict  */)header,
               (size_t )ret___2);
#line 2557
        headlen -= ret___2;
#line 2558
        header += ret___2;
        }
#line 2559
        if (headlen <= 0) {
#line 2559
          header = (char *)((void *)0);
        }
      }
    }
#line 2562
    if (s > ret___2) {
      {
#line 2563
      tmp___2 = read(infd, (void *)(buf1 + ret___2), (size_t )(s - ret___2));
#line 2563
      ret___2 = (int )((ssize_t )ret___2 + tmp___2);
      }
    }
#line 2565
    if (ret___2 > 0) {
#line 2567
      if (outfd___0 >= 0) {
        {
#line 2567
        tmp___3 = write_data(outfd___0, buf1, ret___2);
#line 2567
        ret2 = tmp___3;
        }
      } else {
#line 2567
        ret2 = ret___2;
      }
#line 2568
      if (ret2 > 0) {
#line 2568
        total += ret2;
      }
#line 2570
      if (ret2 != ret___2) {
        {
#line 2571
        transfer_file(infd, -1, n - (ret___2 + headlen), (char *)((void *)0), 0, 0);
        }
      }
    }
#line 2573
    if (ret___2 <= 0) {
#line 2574
      return (total);
    } else
#line 2573
    if (ret2 != ret___2) {
#line 2574
      return (total);
    }
#line 2575
    n -= ret___2;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2577
  return (total);
}
}
#line 2585 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int read_smb_length(int fd , char *inbuf___0 , int timeout ) 
{ 
  char *buffer ;
  char buf___0[4] ;
  int len ;
  int msg_type ;
  BOOL ok ;
  int tmp ;
  int tmp___0 ;

  {
#line 2589
  len = 0;
#line 2590
  ok = 0;
#line 2592
  if (inbuf___0) {
#line 2593
    buffer = inbuf___0;
  } else {
#line 2595
    buffer = buf___0;
  }
  {
#line 2597
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2597
    if (! (! ok)) {
#line 2597
      goto while_break;
    }
#line 2599
    if (timeout > 0) {
      {
#line 2600
      tmp = read_with_timeout(fd, buffer, 4, 4, (long )timeout, 0);
#line 2600
      ok = tmp == 4;
      }
    } else {
      {
#line 2602
      tmp___0 = read_data(fd, buffer, 4);
#line 2602
      ok = tmp___0 == 4;
      }
    }
#line 2604
    if (! ok) {
#line 2606
      if (timeout > 0) {
#line 2608
        if (DEBUGLEVEL >= 10) {
          {
#line 2608
          Debug1((char *)"select timeout (%d)\n", timeout);
          }
        }
#line 2609
        return (-1);
      } else {
#line 2613
        if (DEBUGLEVEL >= 6) {
          {
#line 2613
          Debug1((char *)"couldn\'t read from client\n");
          }
        }
#line 2614
        return (0);
      }
    }
    {
#line 2618
    len = smb_len(buffer);
#line 2619
    msg_type = (int )*((unsigned char *)buffer + 0);
    }
#line 2621
    if (msg_type == 133) {
#line 2623
      if (DEBUGLEVEL >= 5) {
        {
#line 2623
        Debug1((char *)"Got keepalive packet\n");
        }
      }
#line 2624
      ok = 0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2628
  if (DEBUGLEVEL >= 10) {
    {
#line 2628
    Debug1((char *)"got smb length of %d\n", len);
    }
  }
#line 2630
  return (len);
}
}
#line 2639 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL receive_smb(int fd , char *buffer , int timeout ) 
{ 
  int len ;
  BOOL ok ;
  int tmp ;

  {
  {
#line 2644
  bzero((void *)buffer, (size_t )139);
#line 2646
  len = read_smb_length(fd, buffer, timeout);
  }
#line 2647
  if (len == -1) {
#line 2648
    return (0);
  }
#line 2650
  if (len > 65535) {
#line 2652
    if (DEBUGLEVEL >= 0) {
      {
#line 2652
      Debug1((char *)"Invalid packet length! (%d bytes)\n", len);
      }
    }
#line 2653
    if (len > 66047) {
#line 2654
      return (0);
    }
  }
  {
#line 2657
  tmp = read_data(fd, buffer + 4, len);
#line 2657
  ok = tmp == len;
  }
#line 2659
  if (! ok) {
    {
#line 2661
    close_sockets();
    }
#line 2662
    return (0);
  }
#line 2665
  return (1);
}
}
#line 2672 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL send_smb(int fd , char *buffer ) 
{ 
  int len ;
  int ret___2 ;
  int nwritten ;
  int tmp ;

  {
  {
#line 2675
  nwritten = 0;
#line 2676
  tmp = smb_len(buffer);
#line 2676
  len = tmp + 4;
  }
  {
#line 2678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2678
    if (! (nwritten < len)) {
#line 2678
      goto while_break;
    }
    {
#line 2680
    ret___2 = write_socket(fd, buffer + nwritten, len - nwritten);
    }
#line 2681
    if (ret___2 <= 0) {
#line 2683
      if (DEBUGLEVEL >= 0) {
        {
#line 2683
        Debug1((char *)"Error writing %d bytes to client. %d. Exiting\n", len, ret___2);
        }
      }
      {
#line 2684
      close_sockets();
      }
#line 2685
      return (0);
    }
#line 2687
    nwritten += ret___2;
  }
  while_break: /* CIL Label */ ;
  }
#line 2691
  return (1);
}
}
#line 2698 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *name_ptr(char *buf___0 , int ofs ) 
{ 
  unsigned char c ;
  uint16 l ;
  char p[2] ;

  {
#line 2700
  c = *((unsigned char *)(buf___0 + ofs));
#line 2702
  if (((int )c & 192) == 192) {
    {
#line 2706
    memcpy((void */* __restrict  */)(p), (void const   */* __restrict  */)(buf___0 + ofs),
           (size_t )2);
#line 2707
    p[0] = (char )((int )p[0] & -193);
#line 2708
    l = (uint16 )(((((unsigned int )*((unsigned char *)(p) + 0) | ((unsigned int )*((unsigned char *)(p) + 1) << 8)) & 255U) << 8) | ((((unsigned int )*((unsigned char *)(p) + 0) | ((unsigned int )*((unsigned char *)(p) + 1) << 8)) >> 8) & 255U));
    }
#line 2709
    if (DEBUGLEVEL >= 5) {
      {
#line 2709
      Debug1((char *)"name ptr to pos %d from %d is %s\n", (int )l, ofs, buf___0 + (int )l);
      }
    }
#line 2710
    return (buf___0 + (int )l);
  } else {
#line 2713
    return (buf___0 + ofs);
  }
}
}
#line 2719 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int name_extract(char *buf___0 , int ofs , char *name___1 ) 
{ 
  char *p ;
  char *tmp ;
  int d ;
  int tmp___0 ;

  {
  {
#line 2721
  tmp = name_ptr(buf___0, ofs);
#line 2721
  p = tmp;
#line 2722
  d = (int )(p - (buf___0 + ofs));
#line 2723
  StrCpy(name___1, (char *)"");
  }
#line 2724
  if (d < -50) {
#line 2724
    return (0);
  } else
#line 2724
  if (d > 50) {
#line 2724
    return (0);
  }
  {
#line 2725
  tmp___0 = name_interpret(p, name___1);
  }
#line 2725
  return (tmp___0);
}
}
#line 2732 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int name_len(char *s ) 
{ 
  char *s0 ;
  unsigned char c ;

  {
#line 2734
  s0 = s;
#line 2735
  c = *((unsigned char *)s);
#line 2736
  if (((int )c & 192) == 192) {
#line 2737
    return (2);
  }
  {
#line 2738
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2738
    if (! *s) {
#line 2738
      goto while_break;
    }
#line 2738
    s += (int )*s + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 2739
  return ((int )((s - s0) + 1L));
}
}
#line 2745 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL send_one_packet(char *buf___0 , int len , struct in_addr ip , int port , int type ) 
{ 
  BOOL ret___2 ;
  int out_fd ;
  struct sockaddr_in sock_out ;
  char const   *tmp ;
  char *tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;

  {
#line 2751
  if (passive) {
#line 2752
    return (1);
  }
  {
#line 2755
  out_fd = socket(2, type, 0);
  }
#line 2756
  if (out_fd == -1) {
#line 2758
    if (DEBUGLEVEL >= 0) {
      {
#line 2758
      Debug1((char *)"socket failed");
      }
    }
#line 2759
    return (0);
  }
  {
#line 2763
  bzero((void *)((char *)(& sock_out)), sizeof(sock_out));
#line 2764
  putip((void *)((char *)(& sock_out.sin_addr)), (void *)((char *)(& ip)));
#line 2765
  sock_out.sin_port = htons((uint16_t )port);
#line 2766
  sock_out.sin_family = (sa_family_t )2;
  }
#line 2768
  if (DEBUGLEVEL > 0) {
#line 2769
    if (DEBUGLEVEL >= 3) {
#line 2769
      if (type == 2) {
#line 2769
        tmp = "DGRAM";
      } else {
#line 2769
        tmp = "STREAM";
      }
      {
#line 2769
      tmp___0 = inet_ntoa(ip);
#line 2769
      Debug1((char *)"sending a packet of len %d to (%s) on port %d of type %s\n",
             len, tmp___0, port, tmp);
      }
    }
  }
  {
#line 2773
  tmp___1 = sendto(out_fd, (void const   *)buf___0, (size_t )len, 0, (struct sockaddr  const  *)((struct sockaddr *)(& sock_out)),
                   (socklen_t )sizeof(sock_out));
#line 2773
  ret___2 = tmp___1 >= 0L;
  }
#line 2775
  if (! ret___2) {
#line 2776
    if (DEBUGLEVEL >= 0) {
      {
#line 2776
      tmp___2 = __errno_location();
#line 2776
      tmp___3 = inet_ntoa(ip);
#line 2776
      Debug1((char *)"Packet send to %s(%d) failed ERRNO=%d\n", tmp___3, port, *tmp___2);
      }
    }
  }
  {
#line 2779
  close(out_fd);
  }
#line 2780
  return (ret___2);
}
}
#line 2786 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void msleep(int t ) 
{ 
  int tdiff ;
  struct timeval tval ;
  struct timeval t1 ;
  struct timeval t2 ;
  fd_set fds ;
  int __d0 ;
  int __d1 ;
  int *tmp ;

  {
  {
#line 2788
  tdiff = 0;
#line 2792
  GetTimeOfDay(& t1);
#line 2793
  GetTimeOfDay(& t2);
  }
  {
#line 2795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2795
    if (! (tdiff < t)) {
#line 2795
      goto while_break;
    }
#line 2796
    tval.tv_sec = (__time_t )((t - tdiff) / 1000);
#line 2797
    tval.tv_usec = (__suseconds_t )(1000 * ((t - tdiff) % 1000));
    {
#line 2799
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2799
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& fds.__fds_bits[0]): "memory");
#line 2799
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2800
    tmp = __errno_location();
#line 2800
    *tmp = 0;
#line 2801
    sys_select(& fds, & tval);
#line 2803
    GetTimeOfDay(& t2);
#line 2804
    tdiff = TvalDiff(& t1, & t2);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2806
  return;
}
}
#line 2811 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL in_list(char *s , char *list , BOOL casesensitive ) 
{ 
  pstring tok ;
  char *p ;
  int tmp ;
  int tmp___0 ;
  BOOL tmp___1 ;

  {
#line 2814
  p = list;
#line 2816
  if (! list) {
#line 2816
    return (0);
  }
  {
#line 2818
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2818
    tmp___1 = next_token(& p, tok, (char *)" \t,;:\n\r");
    }
#line 2818
    if (! tmp___1) {
#line 2818
      goto while_break;
    }
#line 2820
    if (casesensitive) {
      {
#line 2821
      tmp = strcmp((char const   *)(tok), (char const   *)s);
      }
#line 2821
      if (tmp == 0) {
#line 2822
        return (1);
      }
    } else {
      {
#line 2824
      tmp___0 = StrCaseCmp(tok, s);
      }
#line 2824
      if (tmp___0 == 0) {
#line 2825
        return (1);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2828
  return (0);
}
}
#line 2832 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char *null_string  =    (char *)((void *)0);
#line 2837 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL string_init(char **dest , char *src ) 
{ 
  int l ;
  size_t tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 2840
  if (! src) {
#line 2841
    src = (char *)"";
  }
  {
#line 2843
  tmp = strlen((char const   *)src);
#line 2843
  l = (int )tmp;
  }
#line 2845
  if (l == 0) {
#line 2847
    if (! null_string) {
      {
#line 2848
      tmp___0 = malloc((size_t )1);
#line 2848
      null_string = (char *)tmp___0;
      }
    }
#line 2850
    *null_string = (char)0;
#line 2851
    *dest = null_string;
  } else {
    {
#line 2855
    tmp___1 = malloc((size_t )(l + 1));
#line 2855
    *dest = (char *)tmp___1;
#line 2856
    StrCpy(*dest, src);
    }
  }
#line 2858
  return (1);
}
}
#line 2864 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void string_free(char **s ) 
{ 


  {
#line 2866
  if (! s) {
#line 2866
    return;
  } else
#line 2866
  if (! *s) {
#line 2866
    return;
  }
#line 2867
  if ((unsigned long )*s == (unsigned long )null_string) {
#line 2868
    *s = (char *)((void *)0);
  }
#line 2869
  if (*s) {
    {
#line 2869
    free((void *)*s);
    }
  }
#line 2870
  *s = (char *)((void *)0);
#line 2871
  return;
}
}
#line 2877 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL string_set(char **dest , char *src ) 
{ 
  BOOL tmp ;

  {
  {
#line 2879
  string_free(dest);
#line 2881
  tmp = string_init(dest, src);
  }
#line 2881
  return (tmp);
}
}
#line 2893 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL string_sub(char *s , char *pattern , char *insert ) 
{ 
  BOOL ret___2 ;
  char *p ;
  int ls ;
  int lp ;
  int li ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;

  {
#line 2895
  ret___2 = 0;
#line 2899
  if (! insert) {
#line 2899
    return (0);
  } else
#line 2899
  if (! pattern) {
#line 2899
    return (0);
  } else
#line 2899
  if (! s) {
#line 2899
    return (0);
  }
  {
#line 2901
  tmp = strlen((char const   *)s);
#line 2901
  ls = (int )tmp;
#line 2902
  tmp___0 = strlen((char const   *)pattern);
#line 2902
  lp = (int )tmp___0;
#line 2903
  tmp___1 = strlen((char const   *)insert);
#line 2903
  li = (int )tmp___1;
  }
#line 2905
  if (! *pattern) {
#line 2905
    return (0);
  }
  {
#line 2907
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2907
    if (lp <= ls) {
      {
#line 2907
      p = strstr((char const   *)s, (char const   *)pattern);
      }
#line 2907
      if (! p) {
#line 2907
        goto while_break;
      }
    } else {
#line 2907
      goto while_break;
    }
    {
#line 2909
    ret___2 = 1;
#line 2910
    memmove((void *)(p + li), (void const   *)(p + lp), (size_t )((ptrdiff_t )(ls + 1) - ((p - s) + (ptrdiff_t )lp)));
#line 2911
    memcpy((void */* __restrict  */)p, (void const   */* __restrict  */)insert, (size_t )li);
#line 2912
    s = p + li;
#line 2913
    tmp___2 = strlen((char const   *)s);
#line 2913
    ls = (int )tmp___2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2915
  return (ret___2);
}
}
#line 2924 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL do_match(char *str , char *regexp , int case_sig ) 
{ 
  char *p ;
  int tmp ;
  BOOL tmp___0 ;

  {
#line 2928
  p = regexp;
  {
#line 2928
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2928
    if (*p) {
#line 2928
      if (! *str) {
#line 2928
        goto while_break;
      }
    } else {
#line 2928
      goto while_break;
    }
    {
#line 2930
    if ((int )*p == 63) {
#line 2930
      goto case_63;
    }
#line 2934
    if ((int )*p == 42) {
#line 2934
      goto case_42;
    }
#line 2952
    goto switch_default;
    case_63: /* CIL Label */ 
#line 2931
    str ++;
#line 2931
    p ++;
#line 2932
    goto switch_break;
    case_42: /* CIL Label */ 
#line 2937
    p ++;
#line 2938
    if (! *p) {
#line 2939
      return (1);
    }
    {
#line 2940
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2940
      if (! *str) {
#line 2940
        goto while_break___0;
      }
      {
#line 2941
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 2941
        if (*str) {
#line 2941
          if (case_sig) {
#line 2941
            tmp = (int )*p != (int )*str;
          } else {
#line 2941
            tmp = (int )*(upper_char_map + *p) != (int )*(upper_char_map + *str);
          }
#line 2941
          if (! tmp) {
#line 2941
            goto while_break___1;
          }
        } else {
#line 2941
          goto while_break___1;
        }
#line 2942
        str ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 2943
      tmp___0 = do_match(str, p, case_sig);
      }
#line 2943
      if (tmp___0) {
#line 2944
        return (1);
      }
#line 2945
      if (! *str) {
#line 2946
        return (0);
      } else {
#line 2948
        str ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2950
    return (0);
    switch_default: /* CIL Label */ 
#line 2953
    if (case_sig) {
#line 2954
      if ((int )*str != (int )*p) {
#line 2955
        return (0);
      }
    } else
#line 2957
    if ((int )*(upper_char_map + *str) != (int )*(upper_char_map + *p)) {
#line 2958
      return (0);
    }
#line 2960
    str ++;
#line 2960
    p ++;
#line 2961
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2964
  if (! *p) {
#line 2964
    if (! *str) {
#line 2965
      return (1);
    }
  }
#line 2967
  if (! *p) {
#line 2967
    if ((int )*(str + 0) == 46) {
#line 2967
      if ((int )*(str + 1) == 0) {
#line 2968
        return (1);
      }
    }
  }
#line 2970
  if (! *str) {
#line 2970
    if ((int )*p == 63) {
      {
#line 2972
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2972
        if (! ((int )*p == 63)) {
#line 2972
          goto while_break___2;
        }
#line 2972
        p ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 2973
      return (! *p);
    }
  }
#line 2976
  if (! *str) {
#line 2976
    if ((int )*p == 42) {
#line 2976
      if ((int )*(p + 1) == 0) {
#line 2977
        return (1);
      }
    }
  }
#line 2978
  return (0);
}
}
#line 2987 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL mask_match(char *str , char *regexp , int case_sig , BOOL trans2 ) 
{ 
  char *p ;
  pstring p1 ;
  pstring p2 ;
  fstring ebase ;
  fstring eext ;
  fstring sbase ;
  fstring sext ;
  BOOL matched ;
  char *tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;
  int tmp___5 ;

  {
  {
#line 2996
  StrnCpy(p1, (char const   *)regexp, (int )(sizeof(pstring ) - 1UL));
#line 2997
  StrnCpy(p2, (char const   *)str, (int )(sizeof(pstring ) - 1UL));
#line 2999
  tmp = strchr((char const   *)(p2), '.');
  }
#line 2999
  if (! tmp) {
    {
#line 3000
    strcat((char */* __restrict  */)(p2), (char const   */* __restrict  */)".");
    }
  }
#line 3018
  p = p1;
  {
#line 3018
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3018
    if (! *p) {
#line 3018
      goto while_break;
    }
    {
#line 3019
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3019
      if ((int )*p == 42) {
#line 3019
        if (! ((int )*(p + 1) == 63)) {
#line 3019
          if (! ((int )*(p + 1) == 42)) {
#line 3019
            goto while_break___0;
          }
        }
      } else {
#line 3019
        goto while_break___0;
      }
      {
#line 3020
      StrCpy(p + 1, p + 2);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3018
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3022
  tmp___0 = strequal(p1, (char *)"*");
  }
#line 3022
  if (tmp___0) {
#line 3022
    return (1);
  }
#line 3024
  if (DEBUGLEVEL >= 5) {
    {
#line 3024
    Debug1((char *)"mask_match str=<%s> regexp=<%s>, case_sig = %d\n", p2, p1, case_sig);
    }
  }
#line 3026
  if (trans2) {
    {
#line 3027
    StrCpy(ebase, p1);
#line 3028
    StrCpy(sbase, p2);
    }
  } else {
    {
#line 3030
    p = strrchr((char const   *)(p1), '.');
    }
#line 3030
    if (p) {
      {
#line 3031
      *p = (char)0;
#line 3032
      StrCpy(ebase, p1);
#line 3033
      StrCpy(eext, p + 1);
      }
    } else {
      {
#line 3035
      StrCpy(ebase, p1);
#line 3036
      eext[0] = (char)0;
      }
    }
    {
#line 3039
    tmp___1 = strequal(p2, (char *)".");
    }
#line 3039
    if (tmp___1) {
      {
#line 3044
      StrCpy(sbase, p2);
#line 3045
      StrCpy(sext, (char *)"");
      }
    } else {
      {
#line 3039
      tmp___2 = strequal(p2, (char *)"..");
      }
#line 3039
      if (tmp___2) {
        {
#line 3044
        StrCpy(sbase, p2);
#line 3045
        StrCpy(sext, (char *)"");
        }
      } else {
        {
#line 3039
        p = strrchr((char const   *)(p2), '.');
        }
#line 3039
        if (p) {
          {
#line 3040
          *p = (char)0;
#line 3041
          StrCpy(sbase, p2);
#line 3042
          StrCpy(sext, p + 1);
          }
        } else {
          {
#line 3044
          StrCpy(sbase, p2);
#line 3045
          StrCpy(sext, (char *)"");
          }
        }
      }
    }
  }
  {
#line 3049
  tmp___3 = do_match(sbase, ebase, case_sig);
  }
#line 3049
  if (tmp___3) {
#line 3049
    if (trans2) {
#line 3049
      tmp___5 = 1;
    } else {
      {
#line 3049
      tmp___4 = do_match(sext, eext, case_sig);
      }
#line 3049
      if (tmp___4) {
#line 3049
        tmp___5 = 1;
      } else {
#line 3049
        tmp___5 = 0;
      }
    }
  } else {
#line 3049
    tmp___5 = 0;
  }
#line 3049
  matched = tmp___5;
#line 3052
  if (DEBUGLEVEL >= 5) {
    {
#line 3052
    Debug1((char *)"mask_match returning %d\n", matched);
    }
  }
#line 3054
  return (matched);
}
}
#line 3089 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static void default_netmask(struct in_addr *inm , struct in_addr *iad ) 
{ 
  unsigned long ad ;
  uint32_t tmp ;
  unsigned long nm ;

  {
  {
#line 3091
  tmp = ntohl(iad->s_addr);
#line 3091
  ad = (unsigned long )tmp;
  }
#line 3096
  if ((ad & 2147483648UL) == 0UL) {
#line 3098
    nm = 4278190080UL;
  } else
#line 3099
  if ((ad & 3221225472UL) == 2147483648UL) {
#line 3101
    nm = 4294901760UL;
  } else
#line 3102
  if ((ad & 3758096384UL) == 3221225472UL) {
#line 3104
    nm = 4294967040UL;
  } else {
#line 3107
    nm = 4294967280UL;
  }
  {
#line 3109
  inm->s_addr = htonl((uint32_t )nm);
  }
#line 3110
  return;
}
}
#line 3116 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void get_broadcast(struct in_addr *if_ipaddr , struct in_addr *if_bcast , struct in_addr *if_nmask ) 
{ 
  BOOL found ;
  int sock ;
  char buff[1024] ;
  struct ifreq *ifr ;
  int i___0 ;
  struct ifconf ifc ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  unsigned long nm ;
  uint32_t tmp___5 ;
  char *tmp___6 ;
  unsigned long ad ;
  uint32_t tmp___7 ;
  unsigned long nm___0 ;
  uint32_t tmp___8 ;
  unsigned long bc ;
  char *tmp___9 ;

  {
  {
#line 3120
  found = 0;
#line 3122
  sock = -1;
#line 3124
  ifr = (struct ifreq *)((void *)0);
#line 3141
  default_netmask(if_nmask, if_ipaddr);
#line 3148
  sock = socket(2, 2, 0);
  }
#line 3148
  if (sock < 0) {
#line 3151
    if (DEBUGLEVEL >= 0) {
      {
#line 3151
      Debug1((char *)"Unable to open socket to get broadcast address\n");
      }
    }
#line 3152
    return;
  }
  {
#line 3223
  ifc.ifc_len = (int )sizeof(buff);
#line 3224
  ifc.ifc_ifcu.ifcu_buf = buff;
#line 3225
  tmp___1 = ioctl(sock, 35090UL, & ifc);
  }
#line 3225
  if (tmp___1 < 0) {
#line 3226
    if (DEBUGLEVEL >= 0) {
      {
#line 3226
      tmp = __errno_location();
#line 3226
      tmp___0 = strerror(*tmp);
#line 3226
      Debug1((char *)"SIOCGIFCONF: %s\n", tmp___0);
      }
    }
  } else {
#line 3228
    ifr = ifc.ifc_ifcu.ifcu_req;
#line 3231
    i___0 = (int )((unsigned long )ifc.ifc_len / sizeof(struct ifreq ));
    {
#line 3231
    while (1) {
      while_continue: /* CIL Label */ ;
#line 3231
      i___0 --;
#line 3231
      if (! (i___0 >= 0)) {
#line 3231
        goto while_break;
      }
#line 3235
      if (if_ipaddr->s_addr == ((struct sockaddr_in *)(& ifr->ifr_ifru.ifru_addr))->sin_addr.s_addr) {
#line 3237
        found = 1;
#line 3238
        goto while_break;
      }
#line 3231
      ifr ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 3244
  if (! found) {
#line 3245
    if (DEBUGLEVEL >= 0) {
      {
#line 3245
      tmp___2 = inet_ntoa(*if_ipaddr);
#line 3245
      Debug1((char *)"No interface found for address %s\n", tmp___2);
      }
    }
  } else {
    {
#line 3259
    tmp___3 = ioctl(sock, 35099UL, ifr);
    }
#line 3259
    if (tmp___3 < 0) {
#line 3260
      if (DEBUGLEVEL >= 0) {
        {
#line 3260
        Debug1((char *)"SIOCGIFNETMASK failed\n");
        }
      }
    } else {
#line 3262
      *if_nmask = ((struct sockaddr_in *)(& ifr->ifr_ifru.ifru_addr))->sin_addr;
    }
#line 3265
    if (DEBUGLEVEL >= 2) {
      {
#line 3265
      tmp___4 = inet_ntoa(*if_nmask);
#line 3265
      Debug1((char *)"Netmask for %s = %s\n", ifr->ifr_ifrn.ifrn_name, tmp___4);
      }
    }
  }
  {
#line 3270
  close(sock);
#line 3276
  tmp___5 = ntohl(if_nmask->s_addr);
#line 3276
  nm = (unsigned long )tmp___5;
  }
#line 3277
  if (nm >> 24 != 255UL) {
#line 3278
    if (DEBUGLEVEL >= 0) {
      {
#line 3278
      tmp___6 = inet_ntoa(*if_nmask);
#line 3278
      Debug1((char *)"Impossible netmask %s - using defaults\n", tmp___6);
      }
    }
    {
#line 3279
    default_netmask(if_nmask, if_ipaddr);
    }
  }
  {
#line 3287
  tmp___7 = ntohl(if_ipaddr->s_addr);
#line 3287
  ad = (unsigned long )tmp___7;
#line 3288
  tmp___8 = ntohl(if_nmask->s_addr);
#line 3288
  nm___0 = (unsigned long )tmp___8;
#line 3289
  bc = (ad & nm___0) | (4294967295UL & ~ nm___0);
#line 3290
  if_bcast->s_addr = htonl((uint32_t )bc);
  }
#line 3293
  if (DEBUGLEVEL >= 2) {
    {
#line 3293
    tmp___9 = inet_ntoa(*if_bcast);
#line 3293
    Debug1((char *)"Derived broadcast address %s\n", tmp___9);
    }
  }
#line 3294
  return;
}
}
#line 3300 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL yesno(char *p ) 
{ 
  pstring ans ;
  char *tmp ;

  {
  {
#line 3303
  printf((char const   */* __restrict  */)"%s", p);
#line 3305
  tmp = fgets((char */* __restrict  */)(ans), (int )(sizeof(ans) - 1UL), (FILE */* __restrict  */)stdin);
  }
#line 3305
  if (! tmp) {
#line 3306
    return (0);
  }
#line 3308
  if ((int )ans[0] == 121) {
#line 3309
    return (1);
  } else
#line 3308
  if ((int )ans[0] == 89) {
#line 3309
    return (1);
  }
#line 3311
  return (0);
}
}
#line 3319 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *fgets_slash(char *s2 , int maxlen , FILE *f ) 
{ 
  char *s ;
  int len ;
  int c ;
  BOOL start_of_line ;
  int tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 3321
  s = s2;
#line 3322
  len = 0;
#line 3324
  start_of_line = 1;
#line 3326
  tmp = feof(f);
  }
#line 3326
  if (tmp) {
#line 3327
    return ((char *)((void *)0));
  }
#line 3329
  if (! s2) {
#line 3331
    if (maxlen < 8) {
#line 3331
      maxlen = maxlen;
    } else {
#line 3331
      maxlen = 8;
    }
    {
#line 3332
    tmp___0 = Realloc((void *)s, maxlen);
#line 3332
    s = (char *)tmp___0;
    }
  }
#line 3335
  if (! s) {
#line 3335
    return ((char *)((void *)0));
  } else
#line 3335
  if (maxlen < 2) {
#line 3335
    return ((char *)((void *)0));
  }
#line 3337
  *s = (char)0;
  {
#line 3339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3339
    if (! (len < maxlen - 1)) {
#line 3339
      goto while_break;
    }
    {
#line 3341
    c = _IO_getc(f);
    }
    {
#line 3344
    if (c == 13) {
#line 3344
      goto case_13;
    }
#line 3346
    if (c == 10) {
#line 3346
      goto case_10;
    }
#line 3358
    if (c == -1) {
#line 3358
      goto case_neg_1;
    }
#line 3362
    if (c == 32) {
#line 3362
      goto case_32;
    }
#line 3365
    goto switch_default;
    case_13: /* CIL Label */ 
#line 3345
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 3347
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3347
      if (len > 0) {
#line 3347
        if (! ((int )*(s + (len - 1)) == 32)) {
#line 3347
          goto while_break___0;
        }
      } else {
#line 3347
        goto while_break___0;
      }
#line 3349
      len --;
#line 3349
      *(s + len) = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3351
    if (len > 0) {
#line 3351
      if ((int )*(s + (len - 1)) == 92) {
#line 3353
        len --;
#line 3353
        *(s + len) = (char)0;
#line 3354
        start_of_line = 1;
#line 3355
        goto switch_break;
      }
    }
#line 3357
    return (s);
    case_neg_1: /* CIL Label */ 
#line 3359
    if (len <= 0) {
#line 3359
      if (! s2) {
        {
#line 3360
        free((void *)s);
        }
      }
    }
#line 3361
    if (len > 0) {
#line 3361
      tmp___1 = s;
    } else {
#line 3361
      tmp___1 = (char *)((void *)0);
    }
#line 3361
    return (tmp___1);
    case_32: /* CIL Label */ 
#line 3363
    if (start_of_line) {
#line 3364
      goto switch_break;
    }
    switch_default: /* CIL Label */ 
#line 3366
    start_of_line = 0;
#line 3367
    tmp___2 = len;
#line 3367
    len ++;
#line 3367
    *(s + tmp___2) = (char )c;
#line 3368
    *(s + len) = (char)0;
    switch_break: /* CIL Label */ ;
    }
#line 3370
    if (! s2) {
#line 3370
      if (len > maxlen - 3) {
        {
#line 3372
        maxlen *= 2;
#line 3373
        tmp___3 = Realloc((void *)s, maxlen);
#line 3373
        s = (char *)tmp___3;
        }
#line 3374
        if (! s) {
#line 3374
          return ((char *)((void *)0));
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3377
  return (s);
}
}
#line 3386 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int set_filelen(int fd , long len ) 
{ 
  struct stat st ;
  char c ;
  long currpos ;
  __off_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  __off_t tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 3396
  c = (char)0;
#line 3397
  tmp = lseek(fd, 0L, 1);
#line 3397
  currpos = tmp;
  }
#line 3399
  if (currpos < 0L) {
#line 3400
    return (-1);
  }
  {
#line 3405
  tmp___0 = fstat(fd, & st);
  }
#line 3405
  if (tmp___0 < 0) {
#line 3406
    return (-1);
  }
#line 3409
  if ((st.st_mode & 61440U) == 4096U) {
#line 3409
    return (0);
  }
#line 3412
  if (st.st_size == len) {
#line 3413
    return (0);
  }
#line 3414
  if (st.st_size > len) {
    {
#line 3415
    tmp___1 = ftruncate(fd, len);
    }
#line 3415
    return (tmp___1);
  }
  {
#line 3417
  tmp___2 = lseek(fd, len - 1L, 0);
  }
#line 3417
  if (tmp___2 != len - 1L) {
#line 3418
    return (-1);
  }
  {
#line 3419
  tmp___3 = write(fd, (void const   *)(& c), (size_t )1);
  }
#line 3419
  if (tmp___3 != 1L) {
#line 3420
    return (-1);
  }
  {
#line 3422
  lseek(fd, currpos, 0);
  }
#line 3423
  return (0);
}
}
#line 3431 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int byte_checksum(char *buf___0 , int len ) 
{ 
  unsigned char *p ;
  int ret___2 ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 3433
  p = (unsigned char *)buf___0;
#line 3434
  ret___2 = 0;
  {
#line 3435
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3435
    tmp___0 = len;
#line 3435
    len --;
#line 3435
    if (! tmp___0) {
#line 3435
      goto while_break;
    }
#line 3436
    tmp = p;
#line 3436
    p ++;
#line 3436
    ret___2 += (int )*tmp;
  }
  while_break: /* CIL Label */ ;
  }
#line 3437
  return (ret___2);
}
}
#line 3456 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *dirname_dos(char *path , char *buf___0 ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 3458
  tmp = strrchr((char const   *)path, '\\');
#line 3458
  p = tmp;
  }
#line 3460
  if (! p) {
    {
#line 3461
    StrCpy(buf___0, path);
    }
  } else {
    {
#line 3464
    *p = (char)0;
#line 3465
    StrCpy(buf___0, path);
#line 3466
    *p = (char )'\\';
    }
  }
#line 3469
  return (buf___0);
}
}
#line 3476 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char *filename_dos(char *path , char *buf___0 ) 
{ 
  char *p ;
  char *tmp ;

  {
  {
#line 3478
  tmp = strrchr((char const   *)path, '\\');
#line 3478
  p = tmp;
  }
#line 3480
  if (! p) {
    {
#line 3481
    StrCpy(buf___0, path);
    }
  } else {
    {
#line 3483
    StrCpy(buf___0, p + 1);
    }
  }
#line 3485
  return (buf___0);
}
}
#line 3493 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void *Realloc(void *p , int size___0 ) 
{ 
  void *ret___2 ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 3495
  ret___2 = (void *)0;
#line 3496
  if (! p) {
    {
#line 3497
    tmp = malloc((size_t )size___0);
#line 3497
    ret___2 = tmp;
    }
  } else {
    {
#line 3499
    tmp___0 = realloc(p, (size_t )size___0);
#line 3499
    ret___2 = tmp___0;
    }
  }
#line 3501
  if (! ret___2) {
#line 3502
    if (DEBUGLEVEL >= 0) {
      {
#line 3502
      Debug1((char *)"Memory allocation error: failed to expand to %d bytes\n", size___0);
      }
    }
  }
#line 3504
  return (ret___2);
}
}
#line 3510 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL set_filetime(char *fname , time_t mtime ) 
{ 
  struct utimbuf times ;
  BOOL tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3514
  tmp = null_mtime(mtime);
  }
#line 3514
  if (tmp) {
#line 3514
    return (1);
  }
  {
#line 3516
  times.actime = mtime;
#line 3516
  times.modtime = times.actime;
#line 3518
  tmp___2 = sys_utime(fname, & times);
  }
#line 3518
  if (tmp___2) {
#line 3519
    if (DEBUGLEVEL >= 4) {
      {
#line 3519
      tmp___0 = __errno_location();
#line 3519
      tmp___1 = strerror(*tmp___0);
#line 3519
      Debug1((char *)"set_filetime(%s) failed: %s\n", fname, tmp___1);
      }
    }
  }
#line 3522
  return (1);
}
}
#line 3570 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
time_t start_of_month(void) 
{ 
  time_t t ;
  time_t tmp ;
  struct tm *t2 ;
  time_t tmp___0 ;

  {
  {
#line 3572
  tmp = time((time_t *)((void *)0));
#line 3572
  t = tmp;
#line 3575
  t2 = gmtime((time_t const   *)(& t));
#line 3577
  t2->tm_mday = 1;
#line 3578
  t2->tm_hour = 0;
#line 3579
  t2->tm_min = 0;
#line 3580
  t2->tm_sec = 0;
#line 3582
  tmp___0 = mktime(t2);
  }
#line 3582
  return (tmp___0);
}
}
#line 3589 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL sane_unix_date(time_t unixdate ) 
{ 
  struct tm t ;
  struct tm today ;
  time_t t_today ;
  time_t tmp ;
  struct tm *tmp___0 ;
  struct tm *tmp___1 ;

  {
  {
#line 3592
  tmp = time((time_t *)((void *)0));
#line 3592
  t_today = tmp;
#line 3594
  tmp___0 = LocalTime(& unixdate, 1);
#line 3594
  t = *tmp___0;
#line 3595
  tmp___1 = LocalTime(& t_today, 1);
#line 3595
  today = *tmp___1;
  }
#line 3597
  if (t.tm_year < 80) {
#line 3598
    return (0);
  }
#line 3600
  if (t.tm_year > today.tm_year) {
#line 3601
    return (0);
  }
#line 3603
  if (t.tm_year == today.tm_year) {
#line 3603
    if (t.tm_mon > today.tm_mon) {
#line 3605
      return (0);
    }
  }
#line 3608
  if (t.tm_year == today.tm_year) {
#line 3608
    if (t.tm_mon == today.tm_mon) {
#line 3608
      if (t.tm_mday > today.tm_mday + 1) {
#line 3611
        return (0);
      }
    }
  }
#line 3613
  return (1);
}
}
#line 3639 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL get_myname(char *myname___0 , struct in_addr *ip ) 
{ 
  struct hostent *hp ;
  pstring hostname ;
  int tmp ;
  char *p ;
  char *tmp___0 ;

  {
  {
#line 3644
  hostname[0] = (char)0;
#line 3647
  tmp = gethostname(hostname, (size_t )64);
  }
#line 3647
  if (tmp == -1) {
#line 3649
    if (DEBUGLEVEL >= 0) {
      {
#line 3649
      Debug1((char *)"gethostname failed\n");
      }
    }
#line 3650
    return (0);
  }
  {
#line 3654
  hp = Get_Hostbyname(hostname);
  }
#line 3654
  if ((unsigned long )hp == (unsigned long )((struct hostent *)0)) {
#line 3656
    if (DEBUGLEVEL >= 0) {
      {
#line 3656
      Debug1((char *)"Get_Hostbyname: Unknown host %s.\n", hostname);
      }
    }
#line 3657
    return (0);
  }
#line 3660
  if (myname___0) {
    {
#line 3663
    tmp___0 = strchr((char const   *)(hostname), '.');
#line 3663
    p = tmp___0;
    }
#line 3664
    if (p) {
#line 3664
      *p = (char)0;
    }
    {
#line 3666
    StrCpy(myname___0, hostname);
    }
  }
#line 3669
  if (ip) {
    {
#line 3670
    putip((void *)((char *)ip), (void *)*(hp->h_addr_list + 0));
    }
  }
#line 3672
  return (1);
}
}
#line 3679 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL ip_equal(struct in_addr ip1 , struct in_addr ip2 ) 
{ 
  unsigned long a1 ;
  unsigned long a2 ;
  uint32_t tmp ;
  uint32_t tmp___0 ;

  {
  {
#line 3682
  tmp = ntohl(ip1.s_addr);
#line 3682
  a1 = (unsigned long )tmp;
#line 3683
  tmp___0 = ntohl(ip2.s_addr);
#line 3683
  a2 = (unsigned long )tmp___0;
  }
#line 3684
  return (a1 == a2);
}
}
#line 3691 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int open_socket_in(int type , int port , int dlevel ) 
{ 
  struct sockaddr_in sock ;
  int res ;
  int one ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3701
  bzero((void *)((char *)(& sock)), sizeof(sock));
#line 3702
  sock.sin_port = htons((uint16_t )port);
#line 3703
  sock.sin_family = (sa_family_t )2;
#line 3704
  sock.sin_addr.s_addr = (in_addr_t )0;
#line 3705
  res = socket(2, type, 0);
  }
#line 3732
  if (res == -1) {
#line 3733
    if (DEBUGLEVEL >= 0) {
      {
#line 3733
      Debug1((char *)"socket failed\n");
      }
    }
#line 3733
    return (-1);
  }
  {
#line 3736
  one = 1;
#line 3737
  setsockopt(res, 1, 2, (void const   *)((char *)(& one)), (socklen_t )sizeof(one));
#line 3741
  tmp___2 = bind(res, (struct sockaddr  const  *)((struct sockaddr *)(& sock)), (socklen_t )sizeof(sock));
  }
#line 3741
  if (tmp___2 < 0) {
#line 3743
    if (port) {
#line 3744
      if (port == 139) {
#line 3744
        goto _L;
      } else
#line 3744
      if (port == 137) {
        _L: /* CIL Label */ 
#line 3745
        if (DEBUGLEVEL >= dlevel) {
          {
#line 3745
          tmp = __errno_location();
#line 3745
          tmp___0 = strerror(*tmp);
#line 3745
          Debug1((char *)"bind failed on port %d (%s)\n", port, tmp___0);
          }
        }
      }
      {
#line 3747
      close(res);
      }
#line 3749
      if (dlevel > 0) {
#line 3749
        if (port < 1000) {
#line 3750
          port = 7999;
        }
      }
#line 3752
      if (port >= 1000) {
#line 3752
        if (port < 9000) {
          {
#line 3753
          tmp___1 = open_socket_in(type, port + 1, dlevel);
          }
#line 3753
          return (tmp___1);
        }
      }
    }
#line 3756
    return (-1);
  }
#line 3758
  if (DEBUGLEVEL >= 3) {
    {
#line 3758
    Debug1((char *)"bind succeeded on port %d\n", port);
    }
  }
#line 3760
  return (res);
}
}
#line 3767 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int open_socket_out(int type , struct in_addr *addr , int port ) 
{ 
  struct sockaddr_in sock_out ;
  int res ;
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 3773
  res = socket(2, type, 0);
  }
#line 3774
  if (res == -1) {
#line 3775
    if (DEBUGLEVEL >= 0) {
      {
#line 3775
      Debug1((char *)"socket error\n");
      }
    }
#line 3775
    return (-1);
  }
#line 3777
  if (type != 1) {
#line 3777
    return (res);
  }
  {
#line 3779
  bzero((void *)((char *)(& sock_out)), sizeof(sock_out));
#line 3780
  putip((void *)((char *)(& sock_out.sin_addr)), (void *)((char *)addr));
#line 3782
  sock_out.sin_port = htons((uint16_t )port);
#line 3783
  sock_out.sin_family = (sa_family_t )2;
  }
#line 3785
  if (DEBUGLEVEL >= 3) {
    {
#line 3785
    tmp = inet_ntoa(*addr);
#line 3785
    Debug1((char *)"Connecting to %s at port %d\n", tmp, port);
    }
  }
  {
#line 3788
  tmp___2 = connect(res, (struct sockaddr  const  *)((struct sockaddr *)(& sock_out)),
                    (socklen_t )sizeof(sock_out));
  }
#line 3788
  if (tmp___2 < 0) {
#line 3789
    if (DEBUGLEVEL >= 0) {
      {
#line 3789
      tmp___0 = __errno_location();
#line 3789
      tmp___1 = strerror(*tmp___0);
#line 3789
      Debug1((char *)"connect error: %s\n", tmp___1);
      }
    }
    {
#line 3790
    close(res);
    }
#line 3791
    return (-1);
  }
#line 3794
  return (res);
}
}
#line 3801 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int interpret_protocol(char *str , int def ) 
{ 
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;
  BOOL tmp___2 ;
  BOOL tmp___3 ;
  BOOL tmp___4 ;

  {
  {
#line 3803
  tmp = strequal(str, (char *)"NT1");
  }
#line 3803
  if (tmp) {
#line 3804
    return (5);
  }
  {
#line 3805
  tmp___0 = strequal(str, (char *)"LANMAN2");
  }
#line 3805
  if (tmp___0) {
#line 3806
    return (4);
  }
  {
#line 3807
  tmp___1 = strequal(str, (char *)"LANMAN1");
  }
#line 3807
  if (tmp___1) {
#line 3808
    return (3);
  }
  {
#line 3809
  tmp___2 = strequal(str, (char *)"CORE");
  }
#line 3809
  if (tmp___2) {
#line 3810
    return (1);
  }
  {
#line 3811
  tmp___3 = strequal(str, (char *)"COREPLUS");
  }
#line 3811
  if (tmp___3) {
#line 3812
    return (2);
  }
  {
#line 3813
  tmp___4 = strequal(str, (char *)"CORE+");
  }
#line 3813
  if (tmp___4) {
#line 3814
    return (2);
  }
#line 3816
  if (DEBUGLEVEL >= 0) {
    {
#line 3816
    Debug1((char *)"Unrecognised protocol level %s\n", str);
    }
  }
#line 3818
  return (def);
}
}
#line 3824 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
int interpret_security(char *str , int def ) 
{ 
  BOOL tmp ;
  BOOL tmp___0 ;
  BOOL tmp___1 ;

  {
  {
#line 3826
  tmp = strequal(str, (char *)"SERVER");
  }
#line 3826
  if (tmp) {
#line 3827
    return (2);
  }
  {
#line 3828
  tmp___0 = strequal(str, (char *)"USER");
  }
#line 3828
  if (tmp___0) {
#line 3829
    return (1);
  }
  {
#line 3830
  tmp___1 = strequal(str, (char *)"SHARE");
  }
#line 3830
  if (tmp___1) {
#line 3831
    return (0);
  }
#line 3833
  if (DEBUGLEVEL >= 0) {
    {
#line 3833
    Debug1((char *)"Unrecognised security level %s\n", str);
    }
  }
#line 3835
  return (def);
}
}
#line 3842 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
unsigned long interpret_addr(char *str ) 
{ 
  struct hostent *hp ;
  unsigned long res ;
  int tmp ;
  int tmp___0 ;
  in_addr_t tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 3847
  tmp = strcmp((char const   *)str, "0.0.0.0");
  }
#line 3847
  if (tmp == 0) {
#line 3847
    return (0UL);
  }
  {
#line 3848
  tmp___0 = strcmp((char const   *)str, "255.255.255.255");
  }
#line 3848
  if (tmp___0 == 0) {
#line 3848
    return (4294967295UL);
  }
  {
#line 3854
  tmp___2 = __ctype_b_loc();
  }
#line 3854
  if ((int const   )*(*tmp___2 + (int )*(str + 0)) & 2048) {
    {
#line 3855
    tmp___1 = inet_addr((char const   *)str);
#line 3855
    res = (unsigned long )tmp___1;
    }
  } else {
    {
#line 3858
    hp = Get_Hostbyname(str);
    }
#line 3858
    if ((unsigned long )hp == (unsigned long )((struct hostent *)0)) {
#line 3859
      if (DEBUGLEVEL >= 3) {
        {
#line 3859
        Debug1((char *)"Get_Hostbyname: Unknown host. %s\n", str);
        }
      }
#line 3860
      return (0UL);
    }
    {
#line 3862
    putip((void *)((char *)(& res)), (void *)*(hp->h_addr_list + 0));
    }
  }
#line 3865
  if (res == 0xffffffffffffffffUL) {
#line 3865
    return (0UL);
  }
#line 3867
  return (res);
}
}
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 3875 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
jmp_buf gh_buf  ;
#line 3876 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static void tmx(void) 
{ 


  {
  {
#line 3878
  longjmp((struct __jmp_buf_tag *)(gh_buf), 1);
  }
}
}
#line 3884 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char outbuf___0[68]  ;
#line 3882 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *Get_Hostbyaddr(struct in_addr ip ) 
{ 
  struct hostent *hp ;
  BOOL tmp ;
  int tmp___0 ;

  {
  {
#line 3887
  tmp = zero_ip(ip);
  }
#line 3887
  if (tmp) {
#line 3888
    return ((char *)((void *)0));
  }
  {
#line 3890
  signal(14, (void (*)(int  ))(& tmx));
#line 3891
  alarm(5U);
#line 3892
  tmp___0 = _setjmp((struct __jmp_buf_tag *)(gh_buf));
  }
#line 3892
  if (tmp___0 > 0) {
#line 3893
    return ((char *)((void *)0));
  }
  {
#line 3895
  hp = gethostbyaddr((void const   *)((char *)(& ip)), (__socklen_t )sizeof(struct in_addr ),
                     2);
#line 3897
  signal(14, (void (*)(int  ))0);
#line 3898
  alarm(0U);
  }
#line 3900
  if (hp) {
#line 3900
    if (hp->h_name) {
      {
#line 3901
      strncpy((char */* __restrict  */)(outbuf___0), (char const   */* __restrict  */)hp->h_name,
              (size_t )64);
#line 3902
      outbuf___0[64] = (char )'\000';
#line 3903
      strupper(outbuf___0);
      }
#line 3904
      return (outbuf___0);
    }
  }
#line 3906
  return ((char *)((void *)0));
}
}
#line 3916 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static struct in_addr ret___1  ;
#line 3914 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct in_addr *interpret_addr2(char *str ) 
{ 
  unsigned long a ;
  unsigned long tmp ;

  {
  {
#line 3917
  tmp = interpret_addr(str);
#line 3917
  a = tmp;
#line 3918
  putip((void *)((char *)(& ret___1)), (void *)((char *)(& a)));
  }
#line 3919
  return (& ret___1);
}
}
#line 3925 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL zero_ip(struct in_addr ip ) 
{ 
  unsigned long a ;

  {
  {
#line 3928
  putip((void *)((char *)(& a)), (void *)((char *)(& ip)));
  }
#line 3929
  return (a == 0UL);
}
}
#line 3943 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
time_t interpret_long_date(char *p ) 
{ 
  double d ;
  time_t ret___2 ;
  uint32 tlow ;
  uint32 thigh ;
  int tmp ;

  {
#line 3948
  tlow = ((unsigned int )*((unsigned char *)p + 0) | ((unsigned int )*((unsigned char *)p + 1) << 8)) | (((unsigned int )*((unsigned char *)p + 2) | ((unsigned int )*((unsigned char *)p + 3) << 8)) << 16);
#line 3949
  thigh = ((unsigned int )*((unsigned char *)p + 4) | ((unsigned int )*((unsigned char *)p + 5) << 8)) | (((unsigned int )*((unsigned char *)p + 6) | ((unsigned int )*((unsigned char *)p + 7) << 8)) << 16);
#line 3951
  if (thigh == 0U) {
#line 3951
    return ((time_t )0);
  }
#line 3953
  d = ((double )thigh * 4.0) * (double )(1 << 30);
#line 3954
  d += (double )(tlow & 4293918720U);
#line 3955
  d *= 1.0e-7;
#line 3958
  d -= (((369.0 * 365.25) * (double )24) * (double )60) * (double )60 - (((3.0 * (double )24) * (double )60) * (double )60 + (6.0 * (double )60) * (double )60);
#line 3960
  if (d >= (double )((1U << (sizeof(int ) * 8UL - 1UL)) - 1U)) {
#line 3961
    return ((time_t )0);
  }
  {
#line 3963
  ret___2 = (time_t )(d + 0.5);
#line 3966
  tmp = TimeDiff(ret___2);
#line 3966
  ret___2 += (time_t )(tmp - serverzone);
  }
#line 3968
  return (ret___2);
}
}
#line 3976 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void put_long_date(char *p , time_t t ) 
{ 
  uint32 tlow ;
  uint32 thigh ;
  double d ;
  int tmp ;

  {
#line 3981
  if (t == 0L) {
#line 3982
    *((unsigned char *)p + 0) = (unsigned char)0;
#line 3982
    *((unsigned char *)p + 1) = (unsigned char)0;
#line 3982
    *((unsigned char *)p + 2) = (unsigned char)0;
#line 3982
    *((unsigned char *)p + 3) = (unsigned char)0;
#line 3982
    *((unsigned char *)p + 4) = (unsigned char)0;
#line 3982
    *((unsigned char *)p + 5) = (unsigned char)0;
#line 3982
    *((unsigned char *)p + 6) = (unsigned char)0;
#line 3982
    *((unsigned char *)p + 7) = (unsigned char)0;
#line 3983
    return;
  }
  {
#line 3987
  tmp = TimeDiff(t);
#line 3987
  t -= (time_t )(tmp - serverzone);
#line 3989
  d = (double )t;
#line 3991
  d += (((369.0 * 365.25) * (double )24) * (double )60) * (double )60 - (((3.0 * (double )24) * (double )60) * (double )60 + (6.0 * (double )60) * (double )60);
#line 3993
  d *= 1.0e7;
#line 3995
  thigh = (uint32 )(d * (1.0 / (4.0 * (double )(1 << 30))));
#line 3996
  tlow = (uint32 )(d - ((double )thigh * 4.0) * (double )(1 << 30));
#line 3998
  *((unsigned char *)p + 0) = (unsigned char )((tlow & 65535U) & 255U);
#line 3998
  *((unsigned char *)p + 1) = (unsigned char )((tlow & 65535U) >> 8);
#line 3998
  *((unsigned char *)p + 2) = (unsigned char )((tlow >> 16) & 255U);
#line 3998
  *((unsigned char *)p + 3) = (unsigned char )((tlow >> 16) >> 8);
#line 3999
  *((unsigned char *)p + 4) = (unsigned char )((thigh & 65535U) & 255U);
#line 3999
  *((unsigned char *)p + 5) = (unsigned char )((thigh & 65535U) >> 8);
#line 3999
  *((unsigned char *)p + 6) = (unsigned char )((thigh >> 16) & 255U);
#line 3999
  *((unsigned char *)p + 7) = (unsigned char )((thigh >> 16) >> 8);
  }
#line 4000
  return;
}
}
#line 4005 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void standard_sub_basic(char *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char pidstr[10] ;
  __pid_t tmp___4 ;

  {
  {
#line 4007
  tmp = strchr((char const   *)s, '%');
  }
#line 4007
  if (! tmp) {
#line 4007
    return;
  }
  {
#line 4009
  string_sub(s, (char *)"%R", remote_proto);
#line 4010
  string_sub(s, (char *)"%a", remote_arch);
#line 4011
  string_sub(s, (char *)"%m", remote_machine);
#line 4012
  string_sub(s, (char *)"%L", local_machine);
#line 4014
  tmp___0 = strchr((char const   *)s, '%');
  }
#line 4014
  if (! tmp___0) {
#line 4014
    return;
  }
  {
#line 4016
  string_sub(s, (char *)"%v", (char *)"X");
#line 4017
  string_sub(s, (char *)"%h", myhostname);
#line 4018
  string_sub(s, (char *)"%U", sesssetup_user);
#line 4020
  tmp___1 = strchr((char const   *)s, '%');
  }
#line 4020
  if (! tmp___1) {
#line 4020
    return;
  }
  {
#line 4022
  string_sub(s, (char *)"%I", Client_info.addr);
#line 4023
  string_sub(s, (char *)"%M", Client_info.name);
#line 4024
  tmp___2 = timestring();
#line 4024
  string_sub(s, (char *)"%T", tmp___2);
#line 4026
  tmp___3 = strchr((char const   *)s, '%');
  }
#line 4026
  if (! tmp___3) {
#line 4026
    return;
  }
  {
#line 4030
  tmp___4 = getpid();
#line 4030
  sprintf((char */* __restrict  */)(pidstr), (char const   */* __restrict  */)"%d",
          tmp___4);
#line 4031
  string_sub(s, (char *)"%d", pidstr);
  }
#line 4033
  return;
}
}
#line 4039 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void PutUniCode(char *dst , char *src ) 
{ 
  char tmp ;

  {
  {
#line 4041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 4041
    if (! *src) {
#line 4041
      goto while_break;
    }
#line 4042
    *(dst + 0) = *(src + 0);
#line 4043
    *(dst + 1) = (char)0;
#line 4044
    dst += 2;
#line 4045
    src ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 4047
  tmp = (char)0;
#line 4047
  *(dst + 1) = tmp;
#line 4047
  *(dst + 0) = tmp;
#line 4048
  return;
}
}
#line 4055 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
struct hostent *Get_Hostbyname(char *name___1 ) 
{ 
  char *name2 ;
  char *tmp ;
  struct hostent *ret___2 ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
  {
#line 4057
  tmp = strdup((char const   *)name___1);
#line 4057
  name2 = tmp;
  }
#line 4060
  if (! name2) {
#line 4062
    if (DEBUGLEVEL >= 0) {
      {
#line 4062
      Debug1((char *)"Memory allocation error in Get_Hostbyname! panic\n");
      }
    }
#line 4063
    return ((struct hostent *)0);
  }
  {
#line 4066
  tmp___0 = __ctype_b_loc();
  }
#line 4066
  if (! ((int const   )*(*tmp___0 + (int )*name2) & 8)) {
    {
#line 4068
    free((void *)name2);
    }
#line 4069
    return ((struct hostent *)((void *)0));
  }
  {
#line 4073
  signal(14, (void (*)(int  ))(& tmx));
#line 4074
  alarm(5U);
#line 4075
  tmp___1 = _setjmp((struct __jmp_buf_tag *)(gh_buf));
  }
#line 4075
  if (tmp___1 > 0) {
#line 4076
    return ((struct hostent *)((void *)0));
  }
  {
#line 4078
  ret___2 = gethostbyname((char const   *)name2);
#line 4080
  signal(14, (void (*)(int  ))0);
#line 4081
  alarm(0U);
  }
#line 4083
  if ((unsigned long )ret___2 != (unsigned long )((void *)0)) {
    {
#line 4085
    free((void *)name2);
    }
#line 4086
    return (ret___2);
  }
  {
#line 4090
  strlower(name2);
#line 4091
  ret___2 = gethostbyname((char const   *)name2);
  }
#line 4092
  if ((unsigned long )ret___2 != (unsigned long )((void *)0)) {
    {
#line 4094
    free((void *)name2);
    }
#line 4095
    return (ret___2);
  }
  {
#line 4099
  strupper(name2);
#line 4100
  ret___2 = gethostbyname((char const   *)name2);
  }
#line 4101
  if ((unsigned long )ret___2 != (unsigned long )((void *)0)) {
    {
#line 4103
    free((void *)name2);
    }
#line 4104
    return (ret___2);
  }
  {
#line 4108
  free((void *)name2);
  }
#line 4109
  return ((struct hostent *)((void *)0));
}
}
#line 4116 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
BOOL process_exists(int pid___0 ) 
{ 
  fstring s ;
  BOOL tmp ;

  {
  {
#line 4120
  sprintf((char */* __restrict  */)(s), (char const   */* __restrict  */)"/proc/%d",
          pid___0);
#line 4121
  tmp = directory_exist(s, (struct stat *)((void *)0));
  }
#line 4121
  return (tmp);
}
}
#line 4152 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char name[20]  ;
#line 4150 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *uidtoname(int uid___0 ) 
{ 
  struct passwd *pass ;
  struct passwd *tmp ;

  {
  {
#line 4153
  tmp = getpwuid((__uid_t )uid___0);
#line 4153
  pass = tmp;
  }
#line 4154
  if (pass) {
#line 4154
    return (pass->pw_name);
  }
  {
#line 4155
  sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%d",
          uid___0);
  }
#line 4156
  return (name);
}
}
#line 4164 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
static char name___0[20]  ;
#line 4162 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *gidtoname(int gid___0 ) 
{ 
  struct group *grp ;
  struct group *tmp ;

  {
  {
#line 4165
  tmp = getgrgid((__gid_t )gid___0);
#line 4165
  grp = tmp;
  }
#line 4166
  if (grp) {
#line 4166
    return (grp->gr_name);
  }
  {
#line 4167
  sprintf((char */* __restrict  */)(name___0), (char const   */* __restrict  */)"%d",
          gid___0);
  }
#line 4168
  return (name___0);
}
}
#line 4174 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
void BlockSignals(BOOL block ) 
{ 


  {
#line 4185
  return;
}
}
#line 4197 "/home/june/repo/benchmarks/collector/temp/nat-1.0/util.c"
char *readdirname(void *p ) 
{ 
  struct dirent *ptr ;
  char *dname ;
  struct dirent *tmp ;

  {
#line 4202
  if (! p) {
#line 4202
    return ((char *)((void *)0));
  }
  {
#line 4204
  tmp = readdir((DIR *)p);
#line 4204
  ptr = tmp;
  }
#line 4205
  if (! ptr) {
#line 4205
    return ((char *)((void *)0));
  }
#line 4207
  dname = ptr->d_name;
#line 4237
  return (dname);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 17 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
extern char *optarg ;
#line 18
extern int optind ;
#line 21 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
char *outputfile  =    (char *)((void *)0);
#line 22 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
char *userfile  =    (char *)((void *)0);
#line 23 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
char *passfile  =    (char *)((void *)0);
#line 24 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
FILE *userfd  =    (FILE *)((void *)0);
#line 25 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
FILE *passfd  =    (FILE *)((void *)0);
#line 34
struct vuln_res *module_16000(u_long ipaddr ) ;
#line 48
extern int ( /* missing proto */  getopt)() ;
#line 36 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
int main(int argc , char **argv ) 
{ 
  struct vuln_res *vr ;
  int opt ;
  char *progname ;
  struct ipstr *hosts ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 46
  progname = strdup((char const   *)*(argv + 0));
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 48
    opt = getopt(argc, argv, "o:u:p:");
    }
#line 48
    if (! (opt != -1)) {
#line 48
      goto while_break;
    }
    {
#line 50
    if (opt == 111) {
#line 50
      goto case_111;
    }
#line 52
    if (opt == 117) {
#line 52
      goto case_117;
    }
#line 54
    if (opt == 112) {
#line 54
      goto case_112;
    }
#line 56
    goto switch_default;
    case_111: /* CIL Label */ 
    {
#line 50
    outputfile = strdup((char const   *)optarg);
    }
#line 51
    goto switch_break;
    case_117: /* CIL Label */ 
    {
#line 52
    userfile = strdup((char const   *)optarg);
    }
#line 53
    goto switch_break;
    case_112: /* CIL Label */ 
    {
#line 54
    passfile = strdup((char const   *)optarg);
    }
#line 55
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 56
    exit(-1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  argc -= optind;
#line 60
  argv += optind;
#line 62
  if (argc < 1) {
    {
#line 63
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s [-o filename] [-u userlist] [-p passlist] <address>\n",
            progname);
#line 65
    exit(1);
    }
  }
#line 68
  if (userfile) {
    {
#line 69
    userfd = fopen((char const   */* __restrict  */)userfile, (char const   */* __restrict  */)"r");
    }
#line 69
    if (userfd) {
      {
#line 70
      natprintf((char *)"[*]--- Reading usernames from %s\n", userfile);
      }
    } else {
      {
#line 72
      natprintf((char *)"[*]--- Error: cannot open %s\n", userfile);
#line 73
      exit(-1);
      }
    }
  }
#line 77
  if (passfile) {
    {
#line 78
    passfd = fopen((char const   */* __restrict  */)passfile, (char const   */* __restrict  */)"r");
    }
#line 78
    if (passfd) {
      {
#line 79
      natprintf((char *)"[*]--- Reading passwords from %s\n", passfile);
      }
    } else {
      {
#line 81
      natprintf((char *)"[*]--- Error: cannot open %s\n", passfile);
#line 82
      exit(-1);
      }
    }
  }
#line 86
  if (passfile) {
#line 86
    if (! userfile) {
      {
#line 87
      natprintf((char *)"[*]--- Please specify both userlist and password list\n");
#line 88
      exit(-1);
      }
    } else {
#line 86
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 86
  if (userfile) {
#line 86
    if (! passfile) {
      {
#line 87
      natprintf((char *)"[*]--- Please specify both userlist and password list\n");
#line 88
      exit(-1);
      }
    }
  }
  {
#line 91
  tmp = (int )parse_ip(*(argv + 0));
#line 91
  hosts = (struct ipstr *)tmp;
  }
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 91
    if (! hosts) {
#line 91
      goto while_break___0;
    }
    {
#line 92
    natprintf((char *)"\n[*]--- Checking host: %s\n", hosts->name);
    }
#line 94
    if (userfd) {
      {
#line 95
      rewind(userfd);
      }
    }
#line 96
    if (passfd) {
      {
#line 97
      rewind(passfd);
      }
    }
    {
#line 102
    tmp___0 = (int )inet_addr(hosts->name);
#line 102
    vr = module_16000(tmp___0);
    }
#line 102
    if ((unsigned long )vr == (unsigned long )((void *)0)) {
      {
#line 103
      natprintf((char *)"[*]--- Was not able to obtain any information from remote server\n");
      }
    }
#line 91
    hosts = hosts->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 108
  if (userfd) {
    {
#line 109
    fclose(userfd);
    }
  }
#line 110
  if (passfd) {
    {
#line 111
    fclose(passfd);
    }
  }
  {
#line 122
  exit(0);
  }
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
struct vuln_res *bugblk  ;
#line 126 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
struct vuln_res *bughead  ;
#line 127 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
struct vuln_res *prev_bugblk  ;
#line 128 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
int ptr_vuln  =    0;
#line 129 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
int idx_vuln  =    1;
#line 130 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
int cur_vuln  =    0;
#line 131 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
char *vuln_strings[128]  = {      (char *)"",      (char *)"",      (char *)"",      (char *)""};
#line 134 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
int vuln_ids[128]  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
char *vvr_strings[256]  ;
#line 136 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
int ptr_vvr  =    0;
#line 138 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
static u_long prev_ip  =    (u_long )0L;
#line 139 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
static int prev_res  =    0;
#line 141 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
void donothing(void) 
{ 


  {
#line 141
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
int fill_vuln(char *flag , char *str ) 
{ 
  char buf___0[128] ;
  register char *p ;
  register int x ;
  size_t tmp ;

  {
#line 152
  if (! flag) {
#line 153
    return (0);
  }
#line 154
  if (cur_vuln <= 0) {
#line 155
    return (0);
  }
#line 156
  if (ptr_vuln > 127) {
#line 157
    return (0);
  }
  {
#line 158
  StrnCpy(buf___0, flag, 40);
#line 159
  tmp = strlen((char const   *)(buf___0));
#line 159
  x = (int )tmp;
#line 160
  p = buf___0 + x;
#line 161
  x = 79 - x;
#line 162
  StrnCpy(p, str, x);
#line 163
  buf___0[79] = (char )'\000';
#line 164
  x = fill_block(vuln_strings, buf___0);
  }
#line 165
  if (x >= 0) {
#line 166
    vuln_ids[x] = cur_vuln;
#line 167
    ptr_vuln ++;
  }
#line 169
  return (x);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
char *get_vuln(int id ) 
{ 
  register int x ;
  char *tmp ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (ptr_vuln < 127)) {
#line 176
      goto while_break;
    }
#line 177
    ptr_vuln ++;
#line 178
    if (vuln_ids[ptr_vuln] == id) {
      {
#line 179
      x = ptr_vuln;
#line 180
      tmp = get_block(vuln_strings, x);
      }
#line 180
      return (tmp);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  return ((char *)((void *)0));
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
static char *nullstr  =    (char *)"";
#line 186 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
int clear_block(char **blk , int idx ) 
{ 
  register int x ;

  {
#line 191
  x = idx;
#line 193
  if (x <= 0) {
#line 194
    goto cbbogus;
  }
#line 195
  if (! blk) {
#line 196
    goto cbbogus;
  }
  {
#line 197
  while (1) {
    while_continue: /* CIL Label */ ;
#line 197
    if (! (x < 128)) {
#line 197
      goto while_break;
    }
#line 198
    if ((unsigned long )*(blk + x) == (unsigned long )((void *)0)) {
#line 199
      goto while_break;
    }
#line 200
    if (*(*(blk + x) + 0)) {
      {
#line 201
      *(*(blk + x) + 0) = (char )'\000';
#line 202
      free((void *)*(blk + x));
      }
    }
#line 204
    *(blk + x) = nullstr;
#line 205
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 207
  return (1);
  cbbogus: 
  {
#line 209
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"OOPS! clear_block tried to clear bogus entry %d @ %x\n",
          idx, blk);
  }
#line 211
  return (0);
}
}
#line 214 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
struct vuln_res *module_16000(u_long ipaddr ) 
{ 
  register int i___0 ;
  register char *pp ;
  char *buf___0 ;
  char **ptr ;
  int strsize ;
  void *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
#line 222
  if (ipaddr == 0UL) {
#line 223
    return ((struct vuln_res *)-1);
  }
#line 224
  if (ipaddr != prev_ip) {
    {
#line 225
    clear_block(vuln_strings, 1);
#line 226
    i___0 = 1;
    }
    {
#line 226
    while (1) {
      while_continue: /* CIL Label */ ;
#line 226
      if (! (i___0 < 127)) {
#line 226
        goto while_break;
      }
#line 227
      vuln_strings[i___0] = vuln_strings[0];
#line 228
      vuln_ids[i___0] = 0;
#line 226
      i___0 ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 230
    vuln_strings[127] = (char *)((void *)0);
#line 231
    i___0 = nas_step(ipaddr);
#line 232
    prev_ip = ipaddr;
#line 233
    prev_res = i___0;
    }
  }
#line 236
  if (prev_res == 0) {
#line 237
    return ((struct vuln_res *)((void *)0));
  }
#line 239
  ptr_vvr = 0;
#line 240
  prev_bugblk = (struct vuln_res *)((void *)0);
#line 241
  bughead = (struct vuln_res *)((void *)0);
#line 242
  i___0 = 16000;
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 242
    if (! (i___0 <= 16010)) {
#line 242
      goto while_break___0;
    }
    {
#line 243
    ptr_vuln = 0;
#line 244
    pp = get_vuln(i___0);
    }
#line 245
    if (! pp) {
#line 246
      goto __Cont;
    }
    {
#line 248
    tmp = malloc(sizeof(struct vuln_res ));
#line 248
    bugblk = (struct vuln_res *)tmp;
    }
#line 249
    if (! bugblk) {
#line 250
      goto __Cont;
    }
#line 252
    if (prev_bugblk) {
#line 253
      prev_bugblk->vr_next = bugblk;
    } else {
#line 255
      bughead = bugblk;
    }
#line 258
    prev_bugblk = bugblk;
#line 259
    bugblk->vr_vulid = (u_long )i___0;
#line 260
    bugblk->vr_output = & vvr_strings[ptr_vvr];
#line 261
    bugblk->vr_next = (struct vuln_res *)((void *)0);
#line 262
    vvr_strings[ptr_vvr] = pp;
#line 263
    ptr_vvr ++;
    {
#line 265
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 265
      pp = get_vuln(i___0);
      }
#line 265
      if (! pp) {
#line 265
        goto while_break___1;
      }
#line 266
      vvr_strings[ptr_vvr] = pp;
#line 267
      ptr_vvr ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 269
    vvr_strings[ptr_vvr] = (char *)((void *)0);
#line 270
    ptr_vvr ++;
    __Cont: /* CIL Label */ 
#line 242
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 274
  prev_bugblk = bughead;
  {
#line 274
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 274
    if (! prev_bugblk) {
#line 274
      goto while_break___2;
    }
#line 276
    strsize = 0;
#line 277
    ptr = prev_bugblk->vr_output;
    {
#line 277
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 277
      if (! *ptr) {
#line 277
        goto while_break___3;
      }
      {
#line 278
      tmp___0 = strlen((char const   *)*ptr);
#line 278
      strsize = (int )((size_t )strsize + (tmp___0 + 10UL));
#line 277
      ptr ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 279
    tmp___1 = malloc((size_t )(strsize + 100));
#line 279
    buf___0 = (char *)tmp___1;
#line 280
    memset((void *)buf___0, 0, (size_t )(strsize + 100));
#line 281
    ptr = prev_bugblk->vr_output;
    }
    {
#line 281
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 281
      if (! *ptr) {
#line 281
        goto while_break___4;
      }
      {
#line 282
      strcat((char */* __restrict  */)buf___0, (char const   */* __restrict  */)*ptr);
#line 283
      strcat((char */* __restrict  */)buf___0, (char const   */* __restrict  */)"\n");
#line 281
      ptr ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 285
    tmp___2 = malloc((size_t )2);
#line 285
    prev_bugblk->vr_output = (char **)tmp___2;
#line 286
    *(prev_bugblk->vr_output + 0) = buf___0;
#line 287
    *(prev_bugblk->vr_output + 1) = (char *)((void *)0);
#line 274
    prev_bugblk = prev_bugblk->vr_next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 290
  return (bughead);
}
}
#line 306 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
static FILE *outfd  =    (FILE *)((void *)0);
#line 297 "/home/june/repo/benchmarks/collector/temp/nat-1.0/nat.c"
void natprintf(char *format  , ...) 
{ 
  va_list ap ;

  {
  {
#line 310
  __builtin_va_start(ap, format);
#line 316
  vfprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)format,
           ap);
  }
#line 318
  if (! outputfile) {
#line 319
    return;
  }
#line 321
  if (! outfd) {
    {
#line 322
    outfd = fopen((char const   */* __restrict  */)outputfile, (char const   */* __restrict  */)"a");
    }
#line 322
    if (! outfd) {
      {
#line 323
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"[*]--- Error: Unable to open: %s\n",
              outputfile);
#line 324
      exit(-1);
      }
    }
  }
  {
#line 328
  vfprintf((FILE */* __restrict  */)outfd, (char const   */* __restrict  */)format,
           ap);
  }
#line 329
  return;
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 45 "/usr/include/utime.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) utime)(char const   *__file ,
                                                                                            struct utimbuf  const  *__file_times ) ;
#line 263 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) lstat)(char const   * __restrict  __file ,
                                                                                              struct stat * __restrict  __buf ) ;
#line 321
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkdir)(char const   *__path ,
                                                                                            __mode_t __mode ) ;
#line 473 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chown)(char const   *__file ,
                                                                                            __uid_t __owner ,
                                                                                            __gid_t __group ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 835
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) rmdir)(char const   *__path ) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 597 "/home/june/repo/benchmarks/collector/temp/nat-1.0/smb.h"
int sys_rename(char *from , char *to ) ;
#line 599
int sys_unlink(char *fname ) ;
#line 600
int sys_open(char *fname , int flags , int mode ) ;
#line 601
DIR *sys_opendir(char *dname ) ;
#line 603
int sys_lstat(char *fname , struct stat *sbuf ) ;
#line 604
int sys_mkdir(char *dname , int mode ) ;
#line 605
int sys_rmdir(char *dname ) ;
#line 673
int sys_chown(char *fname , int uid___0 , int gid___0 ) ;
#line 674
int sys_chroot(char *dname ) ;
#line 98 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_select(fd_set *fds , struct timeval *tval ) 
{ 
  struct timeval t2 ;
  int selrtn ;
  int *tmp ;
  struct timeval *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (tval) {
      {
#line 104
      memcpy((void */* __restrict  */)((void *)(& t2)), (void const   */* __restrict  */)((void *)tval),
             sizeof(t2));
      }
    }
    {
#line 105
    tmp = __errno_location();
#line 105
    *tmp = 0;
    }
#line 106
    if (tval) {
#line 106
      tmp___0 = & t2;
    } else {
#line 106
      tmp___0 = (struct timeval *)((void *)0);
    }
    {
#line 106
    selrtn = select(1024, (fd_set */* __restrict  */)fds, (fd_set */* __restrict  */)((void *)0),
                    (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)tmp___0);
    }
#line 103
    if (selrtn < 0) {
      {
#line 103
      tmp___1 = __errno_location();
      }
#line 103
      if (! (*tmp___1 == 4)) {
#line 103
        goto while_break;
      }
    } else {
#line 103
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  return (selrtn);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_unlink(char *fname ) 
{ 
  int tmp ;

  {
  {
#line 119
  tmp = unlink((char const   *)fname);
  }
#line 119
  return (tmp);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_open(char *fname , int flags , int mode ) 
{ 
  int tmp ;

  {
  {
#line 128
  tmp = open((char const   *)fname, flags, mode);
  }
#line 128
  return (tmp);
}
}
#line 135 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
DIR *sys_opendir(char *dname ) 
{ 
  DIR *tmp ;

  {
  {
#line 137
  tmp = opendir((char const   *)dname);
  }
#line 137
  return (tmp);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_stat(char *fname , struct stat *sbuf ) 
{ 
  int tmp ;

  {
  {
#line 146
  tmp = stat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)sbuf);
  }
#line 146
  return (tmp);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_lstat(char *fname , struct stat *sbuf ) 
{ 
  int tmp ;

  {
  {
#line 154
  tmp = lstat((char const   */* __restrict  */)fname, (struct stat */* __restrict  */)sbuf);
  }
#line 154
  return (tmp);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_mkdir(char *dname , int mode ) 
{ 
  int tmp ;

  {
  {
#line 163
  tmp = mkdir((char const   *)dname, (__mode_t )mode);
  }
#line 163
  return (tmp);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_rmdir(char *dname ) 
{ 
  int tmp ;

  {
  {
#line 172
  tmp = rmdir((char const   *)dname);
  }
#line 172
  return (tmp);
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_chdir(char *dname ) 
{ 
  int tmp ;

  {
  {
#line 181
  tmp = chdir((char const   *)dname);
  }
#line 181
  return (tmp);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_utime(char *fname , struct utimbuf *times ) 
{ 
  int tmp ;

  {
  {
#line 190
  tmp = utime((char const   *)fname, (struct utimbuf  const  *)times);
  }
#line 190
  return (tmp);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_rename(char *from , char *to ) 
{ 
  int tmp ;

  {
  {
#line 204
  tmp = rename((char const   *)from, (char const   *)to);
  }
#line 204
  return (tmp);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_chown(char *fname , int uid___0 , int gid___0 ) 
{ 
  int tmp ;

  {
  {
#line 217
  tmp = chown((char const   *)fname, (__uid_t )uid___0, (__gid_t )gid___0);
  }
#line 217
  return (tmp);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/nat-1.0/system.c"
int sys_chroot(char *dname ) 
{ 
  int tmp ;

  {
  {
#line 237
  tmp = chroot((char const   *)dname);
  }
#line 237
  return (tmp);
}
}
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 124 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
char xx_dos_char_map[256]  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
char xx_upper_char_map[256]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
char xx_lower_char_map[256]  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
char *dos_char_map  =    (char *)((void *)0);
#line 39 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
char *upper_char_map  =    (char *)((void *)0);
#line 40 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
char *lower_char_map  =    (char *)((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
static void add_dos_char(int lower , int upper ) 
{ 


  {
#line 44
  if (DEBUGLEVEL >= 6) {
    {
#line 44
    Debug1((char *)"Adding chars 0%o 0%o\n", lower, upper);
    }
  }
#line 45
  if (lower) {
#line 45
    *(dos_char_map + (char )lower) = (char)1;
  }
#line 46
  if (upper) {
#line 46
    *(dos_char_map + (char )upper) = (char)1;
  }
#line 47
  if (lower) {
#line 47
    if (upper) {
#line 48
      *(lower_char_map + (char )upper) = (char )lower;
#line 49
      *(upper_char_map + (char )lower) = (char )upper;
    }
  }
#line 51
  return;
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
void charset_initialise(void) 
{ 
  int i___0 ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char c ;
  char tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
#line 60
  dos_char_map = & xx_dos_char_map[128];
#line 61
  upper_char_map = & xx_upper_char_map[128];
#line 62
  lower_char_map = & xx_lower_char_map[128];
#line 64
  i___0 = -128;
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
#line 64
    if (! (i___0 <= 127)) {
#line 64
      goto while_break;
    }
#line 65
    *(dos_char_map + (char )i___0) = (char)0;
#line 64
    i___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 68
  i___0 = 0;
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 68
    if (! (i___0 <= 127)) {
#line 68
      goto while_break___0;
    }
    {
#line 69
    tmp = __ctype_b_loc();
    }
#line 69
    if ((int const   )*(*tmp + (int )((char )i___0)) & 8) {
      {
#line 70
      add_dos_char(i___0, 0);
      }
    } else {
      {
#line 69
      tmp___0 = strchr("._^$~!#%&-{}()@\'`", (int )((char )i___0));
      }
#line 69
      if (tmp___0) {
        {
#line 70
        add_dos_char(i___0, 0);
        }
      }
    }
#line 68
    i___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 73
  i___0 = -128;
  {
#line 73
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 73
    if (! (i___0 <= 127)) {
#line 73
      goto while_break___1;
    }
    {
#line 74
    c = (char )i___0;
#line 75
    tmp___1 = c;
#line 75
    *(lower_char_map + i___0) = tmp___1;
#line 75
    *(upper_char_map + i___0) = tmp___1;
#line 76
    tmp___3 = __ctype_b_loc();
    }
#line 76
    if ((int const   )*(*tmp___3 + (int )c) & 256) {
      {
#line 76
      tmp___2 = tolower((int )c);
#line 76
      *(lower_char_map + c) = (char )tmp___2;
      }
    }
    {
#line 77
    tmp___5 = __ctype_b_loc();
    }
#line 77
    if ((int const   )*(*tmp___5 + (int )c) & 512) {
      {
#line 77
      tmp___4 = toupper((int )c);
#line 77
      *(upper_char_map + c) = (char )tmp___4;
      }
    }
#line 73
    i___0 ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 81
  add_dos_char(142, 0);
#line 82
  add_dos_char(143, 0);
#line 83
  add_dos_char(144, 0);
#line 84
  add_dos_char(146, 0);
#line 85
  add_dos_char(153, 0);
#line 86
  add_dos_char(154, 0);
#line 87
  add_dos_char(165, 0);
#line 88
  add_dos_char(128, 0);
#line 89
  add_dos_char(156, 0);
#line 90
  add_dos_char(183, 0);
#line 91
  add_dos_char(157, 0);
#line 92
  add_dos_char(212, 0);
  }
#line 93
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/nat-1.0/charset.c"
void add_char_string(char *s ) 
{ 
  char *extra_chars ;
  char *tmp ;
  char *t ;
  char c1 ;
  char c2 ;
  int i1 ;
  int i2 ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 101
  tmp = strdup((char const   *)s);
#line 101
  extra_chars = tmp;
  }
#line 103
  if (! extra_chars) {
#line 103
    return;
  }
  {
#line 105
  t = strtok((char */* __restrict  */)extra_chars, (char const   */* __restrict  */)" \t\r\n");
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! t) {
#line 105
      goto while_break;
    }
    {
#line 106
    c1 = (char)0;
#line 106
    c2 = (char)0;
#line 107
    i1 = 0;
#line 107
    i2 = 0;
#line 108
    tmp___0 = __ctype_b_loc();
    }
#line 108
    if ((int const   )*(*tmp___0 + (int )*t) & 2048) {
      {
#line 109
      sscanf((char const   */* __restrict  */)t, (char const   */* __restrict  */)"%i:%i",
             & i1, & i2);
#line 110
      add_dos_char(i1, i2);
      }
    } else
#line 108
    if ((int )*t == 45) {
      {
#line 109
      sscanf((char const   */* __restrict  */)t, (char const   */* __restrict  */)"%i:%i",
             & i1, & i2);
#line 110
      add_dos_char(i1, i2);
      }
    } else {
      {
#line 112
      sscanf((char const   */* __restrict  */)t, (char const   */* __restrict  */)"%c:%c",
             & c1, & c2);
#line 113
      add_dos_char((int )c1, (int )c2);
      }
    }
    {
#line 105
    t = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)" \t\r\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  free((void *)extra_chars);
  }
#line 118
  return;
}
}
