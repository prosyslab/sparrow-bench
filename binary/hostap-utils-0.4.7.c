/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 37 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __uint8_t;
#line 38 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef short __int16_t;
#line 39 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __uint16_t;
#line 40 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __int32_t;
#line 41 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uint32_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 183 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef char *__caddr_t;
#line 116 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __caddr_t caddr_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
typedef __uint32_t __u32;
#line 90 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
typedef __int32_t __s32;
#line 91 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
typedef __uint16_t __u16;
#line 92 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
typedef __int16_t __s16;
#line 93 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
typedef __uint8_t __u8;
#line 650 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
struct iw_param {
   __s32 value ;
   __u8 fixed ;
   __u8 disabled ;
   __u16 flags ;
};
#line 662 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
struct iw_point {
   void *pointer ;
   __u16 length ;
   __u16 flags ;
};
#line 677 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
struct iw_freq {
   __s32 m ;
   __s16 e ;
   __u8 i ;
   __u8 flags ;
};
#line 688 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
struct iw_quality {
   __u8 qual ;
   __u8 level ;
   __u8 noise ;
   __u8 updated ;
};
#line 885 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
union iwreq_data {
   char name[16] ;
   struct iw_point essid ;
   struct iw_param nwid ;
   struct iw_freq freq ;
   struct iw_param sens ;
   struct iw_param bitrate ;
   struct iw_param txpower ;
   struct iw_param rts ;
   struct iw_param frag ;
   __u32 mode ;
   struct iw_param retry ;
   struct iw_point encoding ;
   struct iw_param power ;
   struct iw_quality qual ;
   struct sockaddr ap_addr ;
   struct sockaddr addr ;
   struct iw_param param ;
   struct iw_point data ;
};
#line 923 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
union __anonunion_ifr_ifrn_37 {
   char ifrn_name[16] ;
};
#line 923 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/wireless_copy.h"
struct iwreq {
   union __anonunion_ifr_ifrn_37 ifr_ifrn ;
   union iwreq_data u ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 21 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.h"
typedef uint32_t u32;
#line 22 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.h"
typedef uint16_t u16;
#line 23 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.h"
typedef uint8_t u8;
#line 315 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct hfa384x_comp_ident {
   u16 id ;
   u16 variant ;
   u16 major ;
   u16 minor ;
} __attribute__((__packed__)) ;
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct __anonstruct_add_sta_44 {
   u16 aid ;
   u16 capability ;
   u8 tx_supp_rates ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct __anonstruct_get_info_sta_45 {
   u32 inactive_sec ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct __anonstruct_crypt_46 {
   u8 alg[16] ;
   u32 flags ;
   u32 err ;
   u8 idx ;
   u8 seq[8] ;
   u16 key_len ;
   u8 key[0] ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct __anonstruct_set_flags_sta_47 {
   u32 flags_and ;
   u32 flags_or ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct __anonstruct_rid_48 {
   u16 rid ;
   u16 len ;
   u8 data[0] ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct __anonstruct_generic_elem_49 {
   u8 len ;
   u8 data[0] ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct __anonstruct_mlme_50 {
   u16 cmd ;
   u16 reason_code ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct __anonstruct_scan_req_51 {
   u8 ssid_len ;
   u8 ssid[32] ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
union __anonunion_u_43 {
   struct __anonstruct_add_sta_44 add_sta ;
   struct __anonstruct_get_info_sta_45 get_info_sta ;
   struct __anonstruct_crypt_46 crypt ;
   struct __anonstruct_set_flags_sta_47 set_flags_sta ;
   struct __anonstruct_rid_48 rid ;
   struct __anonstruct_generic_elem_49 generic_elem ;
   struct __anonstruct_mlme_50 mlme ;
   struct __anonstruct_scan_req_51 scan_req ;
};
#line 500 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct prism2_hostapd_param {
   u32 cmd ;
   u8 sta_addr[6] ;
   union __anonunion_u_43 u ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.h"
struct prism2_pdr {
   unsigned int pdr ;
   unsigned int len ;
   unsigned char *data ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.h"
struct prism2_pda {
   char pda_buf[1024] ;
   struct prism2_pdr *pdrs ;
   int pdr_count ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
struct hostap_nicid_rec {
   u16 id ;
   char *txt ;
};
#line 327 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct hfa384x_sup_range {
   u16 role ;
   u16 id ;
   u16 variant ;
   u16 bottom ;
   u16 top ;
} __attribute__((__packed__)) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
struct __anonstruct_rid_table_46 {
   u16 rid ;
   char *name ;
   int type ;
};
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 100 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_io_debug.c"
struct reg_info {
   int reg ;
   char *name ;
};
#line 455 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct prism2_download_area {
   u32 addr ;
   u32 len ;
   caddr_t ptr ;
};
#line 455 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_common.h"
struct prism2_download_param {
   u32 dl_cmd ;
   u32 start_addr ;
   u32 num_areas ;
   struct prism2_download_area data[0] ;
};
#line 100 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.h"
struct pdr_supplier_range {
   u16 role ;
   u16 iface_id ;
   u16 variant ;
   u16 bottom ;
   u16 top ;
} __attribute__((__packed__)) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.h"
struct pdr_compid {
   u16 id ;
   u16 variant ;
   u16 major ;
   u16 minor ;
} __attribute__((__packed__)) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct s3_record {
   unsigned int addr ;
   int len ;
   unsigned char *data ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct s3_info_platform {
   unsigned int platform ;
   unsigned int variant ;
   unsigned int major ;
   unsigned int minor ;
};
#line 45 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct s3_info_component {
   unsigned int component ;
   unsigned int variant ;
   unsigned int major ;
   unsigned int minor ;
};
#line 49 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct s3_info_compatibility {
   unsigned int role ;
   unsigned int iface_id ;
   unsigned int variant ;
   unsigned int bottom ;
   unsigned int top ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct s3_crc16 {
   unsigned int start ;
   unsigned int len ;
   unsigned int prog ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct s3_plug_record {
   unsigned int pdr ;
   unsigned int plug_addr ;
   unsigned int plug_len ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct srec_data {
   char *name ;
   char *name_rec ;
   struct s3_info_component component ;
   int component_set ;
   int start_addr_set ;
   unsigned int start_addr ;
   struct s3_record *s3_records ;
   int s3_used ;
   int s3_entries ;
   struct s3_info_platform *platforms ;
   int platform_count ;
   struct s3_info_compatibility *compatibilities ;
   int compatibility_count ;
   struct s3_crc16 *crc16 ;
   int crc16_count ;
   struct s3_plug_record *plugs ;
   int plug_count ;
   unsigned int s3_fw_info_addr ;
   size_t s3_fw_info_buf_len ;
   char *s3_fw_info_buf ;
};
#line 102 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct wlan_info {
   struct s3_info_platform nicid ;
   struct s3_info_platform priid ;
   struct s3_info_platform staid ;
   struct s3_info_compatibility mfi_pri_sup ;
   struct s3_info_compatibility cfi_pri_sup ;
   struct s3_info_compatibility pri_sup ;
   struct s3_info_compatibility sta_sup ;
   struct s3_info_compatibility mfi_sta_act ;
   struct s3_info_compatibility cfi_pri_act ;
   struct s3_info_compatibility cfi_sta_act ;
   struct prism2_pda pda ;
   char const   *ifname ;
};
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 580
extern int putchar(int __c ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 285
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1,2), __leaf__)) strcspn)(char const   *__s ,
                                                                                                   char const   *__reject )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.h"
void hostap_show_nicid(u8 *data , int len ) ;
#line 35
void hostap_show_priid(u8 *data , int len ) ;
#line 36
void hostap_show_staid(u8 *data , int len ) ;
#line 37
int hostapd_ioctl(char const   *dev , struct prism2_hostapd_param *param , int len ,
                  int show_err ) ;
#line 39
int hostapd_get_rid(char const   *dev , struct prism2_hostapd_param *param , u16 rid ,
                    int show_err ) ;
#line 41
int hostapd_set_rid(char const   *dev , u16 rid , u8 *data , size_t len , int show_err ) ;
#line 43
int hostap_ioctl_readmif(char const   *dev , int cr ) ;
#line 59
int read_wlan_pda(char const   *fname , struct prism2_pda *pda_info ) ;
#line 60
int read_wlan_pda_text(char const   *fname , struct prism2_pda *pda_info ) ;
#line 116
char const   *prism2_pdr_name(int pdr ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static struct hostap_nicid_rec hostap_nicids[29]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
  {      {(u16 )32768, (char *)"EVB2 (HFA3841EVAL1) with PRISM I (3860B) Radio"}, 
        {(u16 )32769, (char *)"HWB3763 Rev B"}, 
        {(u16 )32770, (char *)"HWB3163-01,02,03,04 Rev A"}, 
        {(u16 )32771, (char *)"HWB3163 Rev B, Samsung PC Card Rev. B"}, 
        {(u16 )32772, (char *)"EVB3 (HFA3843EVAL1, Rev B1)"}, 
        {(u16 )32774, (char *)"Nortel Sputnik I"}, 
        {(u16 )32775, (char *)"HWB1153 PRISM I Ref"}, 
        {(u16 )32776, (char *)"HWB3163, Prism II reference with SSF Flash"}, 
        {(u16 )32778, (char *)"3842 Evaluation Board"}, 
        {(u16 )32779, (char *)"PRISM II (2.5) PCMCIA (AMD parallel flash)"}, 
        {(u16 )32780, (char *)"PRISM II (2.5) PCMCIA (SST parallel flash)"}, 
        {(u16 )32781, (char *)"PRISM II (2.5) PCMCIA (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32782,
      (char *)"PRISM II (2.5) PCMCIA (AT24C08 compatible small serial flash)"}, 
        {(u16 )32786, (char *)"PRISM II (2.5) Mini-PCI (AMD parallel flash)"}, 
        {(u16 )32787, (char *)"PRISM II (2.5) Mini-PCI (SST parallel flash)"}, 
        {(u16 )32788, (char *)"PRISM II (2.5) Mini-PCI (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32789,
      (char *)"PRISM II (2.5) Mini-PCI (AT24C08 compatible small serial flash)"}, 
        {(u16 )32790, (char *)"PCI-bridge (AMD parallel flash)"}, 
        {(u16 )32791, (char *)"PCI-bridge (SST parallel flash)"}, 
        {(u16 )32792, (char *)"PCI-bridge (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32793,
      (char *)"PCI-bridge (AT24C08 compatible small serial flash)"}, 
        {(u16 )32794, (char *)"PRISM III PCMCIA (AMD parallel flash)"}, 
        {(u16 )32795, (char *)"PRISM III PCMCIA (SST parallel flash)"}, 
        {(u16 )32796, (char *)"PRISM III PCMCIA (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32797,
      (char *)"PRISM III PCMCIA (AT24C08 compatible small serial flash)"}, 
        {(u16 )32801, (char *)"PRISM III Mini-PCI (AMD parallel flash)"}, 
        {(u16 )32802, (char *)"PRISM III Mini-PCI (SST parallel flash)"}, 
        {(u16 )32803, (char *)"PRISM III Mini-PCI (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32804,
      (char *)"PRISM III Mini-PCI (AT24C08 compatible small serial flash)"}};
#line 70 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
void hostap_show_nicid(u8 *data , int len ) 
{ 
  struct hfa384x_comp_ident *comp ;
  int i ;
  u16 id ;
  char *txt ;

  {
#line 75
  txt = (char *)"unknown";
#line 77
  if ((unsigned long )len != sizeof(*comp)) {
    {
#line 78
    printf((char const   */* __restrict  */)"Invalid NICID length %d\n", len);
    }
#line 79
    return;
  }
#line 82
  comp = (struct hfa384x_comp_ident *)data;
#line 84
  id = comp->id;
#line 85
  i = 0;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! ((unsigned long )i < sizeof(hostap_nicids) / sizeof(hostap_nicids[0]))) {
#line 85
      goto while_break;
    }
#line 87
    if ((int )hostap_nicids[i].id == (int )id) {
#line 88
      txt = hostap_nicids[i].txt;
#line 89
      goto while_break;
    }
#line 85
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 93
  printf((char const   */* __restrict  */)"NICID: id=0x%04x v%d.%d.%d (%s)", (int )id,
         (int )comp->major, (int )comp->minor, (int )comp->variant, txt);
#line 97
  printf((char const   */* __restrict  */)"\n");
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
void hostap_show_priid(u8 *data , int len ) 
{ 
  struct hfa384x_comp_ident *comp ;

  {
#line 105
  if ((unsigned long )len != sizeof(*comp)) {
    {
#line 106
    printf((char const   */* __restrict  */)"Invalid PRIID length %d\n", len);
    }
#line 107
    return;
  }
  {
#line 110
  comp = (struct hfa384x_comp_ident *)data;
#line 111
  printf((char const   */* __restrict  */)"PRIID: id=0x%04x v%d.%d.%d\n", (int )comp->id,
         (int )comp->major, (int )comp->minor, (int )comp->variant);
  }
#line 116
  if ((int )comp->id != 21) {
    {
#line 117
    printf((char const   */* __restrict  */)"   Unknown primary firmware component id!\n");
    }
  }
#line 118
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
void hostap_show_staid(u8 *data , int len ) 
{ 
  struct hfa384x_comp_ident *comp ;
  u16 id ;
  u16 major ;
  u16 minor ;
  u16 variant ;

  {
#line 126
  if ((unsigned long )len != sizeof(*comp)) {
    {
#line 127
    printf((char const   */* __restrict  */)"Invalid STAID length %d\n", len);
    }
#line 128
    return;
  }
  {
#line 131
  comp = (struct hfa384x_comp_ident *)data;
#line 133
  id = comp->id;
#line 134
  major = comp->major;
#line 135
  minor = comp->minor;
#line 136
  variant = comp->variant;
#line 138
  printf((char const   */* __restrict  */)"STAID: id=0x%04x v%d.%d.%d", (int )id,
         (int )major, (int )minor, (int )variant);
  }
  {
#line 141
  if ((int )id == 31) {
#line 141
    goto case_31;
  }
#line 144
  if ((int )id == 331) {
#line 144
    goto case_331;
  }
#line 147
  goto switch_default;
  case_31: /* CIL Label */ 
  {
#line 142
  printf((char const   */* __restrict  */)" (station firmware)\n");
  }
#line 143
  goto switch_break;
  case_331: /* CIL Label */ 
  {
#line 145
  printf((char const   */* __restrict  */)" (tertiary firmware)\n");
  }
#line 146
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 148
  printf((char const   */* __restrict  */)" (unknown component id!)\n");
  }
#line 149
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 151
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
int hostapd_ioctl(char const   *dev , struct prism2_hostapd_param *param , int len ,
                  int show_err ) 
{ 
  int s ;
  struct iwreq iwr ;
  int ret ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 160
  s = socket(2, 2, 0);
  }
#line 161
  if (s < 0) {
    {
#line 162
    perror("socket");
    }
#line 163
    return (-1);
  }
  {
#line 166
  memset((void *)(& iwr), 0, sizeof(iwr));
#line 167
  strncpy((char */* __restrict  */)(iwr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 168
  iwr.u.data.pointer = (void *)((caddr_t )param);
#line 169
  iwr.u.data.length = (__u16 )len;
#line 171
  tmp___0 = ioctl(s, 35326UL, & iwr);
  }
#line 171
  if (tmp___0 < 0) {
    {
#line 173
    close(s);
#line 174
    tmp = __errno_location();
#line 174
    ret = *tmp;
    }
#line 175
    if (show_err) {
      {
#line 176
      perror("ioctl[PRISM2_IOCTL_HOSTAPD]");
      }
    }
#line 177
    return (ret);
  }
  {
#line 179
  close(s);
  }
#line 181
  return (0);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
int hostapd_get_rid(char const   *dev , struct prism2_hostapd_param *param , u16 rid ,
                    int show_err ) 
{ 
  int res ;

  {
  {
#line 189
  memset((void *)param, 0, (size_t )1024);
#line 190
  param->cmd = (u32 )9;
#line 191
  param->u.rid.rid = rid;
#line 192
  param->u.rid.len = (u16 )(1024 - (int )(& ((struct prism2_hostapd_param *)0)->u.rid.data));
#line 194
  res = hostapd_ioctl(dev, param, 1024, show_err);
  }
#line 196
  if (res >= 0) {
#line 196
    if ((int )param->u.rid.len > 1024 - (int )(& ((struct prism2_hostapd_param *)0)->u.rid.data)) {
#line 198
      return (-1);
    }
  }
#line 200
  return (res);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
int hostapd_set_rid(char const   *dev , u16 rid , u8 *data , size_t len , int show_err ) 
{ 
  struct prism2_hostapd_param *param ;
  int res ;
  size_t blen ;
  void *tmp ;

  {
#line 209
  blen = (size_t )((int )(& ((struct prism2_hostapd_param *)0)->u.rid.data)) + len;
#line 210
  if (blen < sizeof(*param)) {
#line 211
    blen = sizeof(*param);
  }
  {
#line 213
  tmp = malloc(blen);
#line 213
  param = (struct prism2_hostapd_param *)tmp;
  }
#line 214
  if ((unsigned long )param == (unsigned long )((void *)0)) {
#line 215
    return (-1);
  }
  {
#line 217
  memset((void *)param, 0, blen);
#line 218
  param->cmd = (u32 )10;
#line 219
  param->u.rid.rid = rid;
#line 220
  param->u.rid.len = (u16 )len;
#line 221
  memcpy((void */* __restrict  */)(param->u.rid.data), (void const   */* __restrict  */)data,
         len);
#line 222
  res = hostapd_ioctl(dev, param, (int )blen, show_err);
#line 224
  free((void *)param);
  }
#line 226
  return (res);
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
int hostap_ioctl_readmif(char const   *dev , int cr ) 
{ 
  int s ;
  struct iwreq iwr ;
  u8 val ;
  int tmp ;

  {
  {
#line 236
  s = socket(2, 2, 0);
  }
#line 237
  if (s < 0) {
    {
#line 238
    perror("socket");
    }
#line 239
    return (-1);
  }
  {
#line 242
  memset((void *)(& iwr), 0, sizeof(iwr));
#line 243
  strncpy((char */* __restrict  */)(iwr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 244
  iwr.u.name[0] = (char )(cr * 2);
#line 246
  tmp = ioctl(s, 35811UL, & iwr);
  }
#line 246
  if (tmp < 0) {
    {
#line 247
    perror("ioctl[PRISM2_IOCTL_READMIF]");
#line 248
    close(s);
    }
#line 249
    return (-1);
  }
  {
#line 251
  close(s);
#line 253
  val = (u8 )iwr.u.name[0];
  }
#line 254
  return ((int )val);
}
}
#line 258 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static u16 const   crc16_table[256]  = 
#line 258
  {      (u16 const   )0,      (u16 const   )49345,      (u16 const   )49537,      (u16 const   )320, 
        (u16 const   )49921,      (u16 const   )960,      (u16 const   )640,      (u16 const   )49729, 
        (u16 const   )50689,      (u16 const   )1728,      (u16 const   )1920,      (u16 const   )51009, 
        (u16 const   )1280,      (u16 const   )50625,      (u16 const   )50305,      (u16 const   )1088, 
        (u16 const   )52225,      (u16 const   )3264,      (u16 const   )3456,      (u16 const   )52545, 
        (u16 const   )3840,      (u16 const   )53185,      (u16 const   )52865,      (u16 const   )3648, 
        (u16 const   )2560,      (u16 const   )51905,      (u16 const   )52097,      (u16 const   )2880, 
        (u16 const   )51457,      (u16 const   )2496,      (u16 const   )2176,      (u16 const   )51265, 
        (u16 const   )55297,      (u16 const   )6336,      (u16 const   )6528,      (u16 const   )55617, 
        (u16 const   )6912,      (u16 const   )56257,      (u16 const   )55937,      (u16 const   )6720, 
        (u16 const   )7680,      (u16 const   )57025,      (u16 const   )57217,      (u16 const   )8000, 
        (u16 const   )56577,      (u16 const   )7616,      (u16 const   )7296,      (u16 const   )56385, 
        (u16 const   )5120,      (u16 const   )54465,      (u16 const   )54657,      (u16 const   )5440, 
        (u16 const   )55041,      (u16 const   )6080,      (u16 const   )5760,      (u16 const   )54849, 
        (u16 const   )53761,      (u16 const   )4800,      (u16 const   )4992,      (u16 const   )54081, 
        (u16 const   )4352,      (u16 const   )53697,      (u16 const   )53377,      (u16 const   )4160, 
        (u16 const   )61441,      (u16 const   )12480,      (u16 const   )12672,      (u16 const   )61761, 
        (u16 const   )13056,      (u16 const   )62401,      (u16 const   )62081,      (u16 const   )12864, 
        (u16 const   )13824,      (u16 const   )63169,      (u16 const   )63361,      (u16 const   )14144, 
        (u16 const   )62721,      (u16 const   )13760,      (u16 const   )13440,      (u16 const   )62529, 
        (u16 const   )15360,      (u16 const   )64705,      (u16 const   )64897,      (u16 const   )15680, 
        (u16 const   )65281,      (u16 const   )16320,      (u16 const   )16000,      (u16 const   )65089, 
        (u16 const   )64001,      (u16 const   )15040,      (u16 const   )15232,      (u16 const   )64321, 
        (u16 const   )14592,      (u16 const   )63937,      (u16 const   )63617,      (u16 const   )14400, 
        (u16 const   )10240,      (u16 const   )59585,      (u16 const   )59777,      (u16 const   )10560, 
        (u16 const   )60161,      (u16 const   )11200,      (u16 const   )10880,      (u16 const   )59969, 
        (u16 const   )60929,      (u16 const   )11968,      (u16 const   )12160,      (u16 const   )61249, 
        (u16 const   )11520,      (u16 const   )60865,      (u16 const   )60545,      (u16 const   )11328, 
        (u16 const   )58369,      (u16 const   )9408,      (u16 const   )9600,      (u16 const   )58689, 
        (u16 const   )9984,      (u16 const   )59329,      (u16 const   )59009,      (u16 const   )9792, 
        (u16 const   )8704,      (u16 const   )58049,      (u16 const   )58241,      (u16 const   )9024, 
        (u16 const   )57601,      (u16 const   )8640,      (u16 const   )8320,      (u16 const   )57409, 
        (u16 const   )40961,      (u16 const   )24768,      (u16 const   )24960,      (u16 const   )41281, 
        (u16 const   )25344,      (u16 const   )41921,      (u16 const   )41601,      (u16 const   )25152, 
        (u16 const   )26112,      (u16 const   )42689,      (u16 const   )42881,      (u16 const   )26432, 
        (u16 const   )42241,      (u16 const   )26048,      (u16 const   )25728,      (u16 const   )42049, 
        (u16 const   )27648,      (u16 const   )44225,      (u16 const   )44417,      (u16 const   )27968, 
        (u16 const   )44801,      (u16 const   )28608,      (u16 const   )28288,      (u16 const   )44609, 
        (u16 const   )43521,      (u16 const   )27328,      (u16 const   )27520,      (u16 const   )43841, 
        (u16 const   )26880,      (u16 const   )43457,      (u16 const   )43137,      (u16 const   )26688, 
        (u16 const   )30720,      (u16 const   )47297,      (u16 const   )47489,      (u16 const   )31040, 
        (u16 const   )47873,      (u16 const   )31680,      (u16 const   )31360,      (u16 const   )47681, 
        (u16 const   )48641,      (u16 const   )32448,      (u16 const   )32640,      (u16 const   )48961, 
        (u16 const   )32000,      (u16 const   )48577,      (u16 const   )48257,      (u16 const   )31808, 
        (u16 const   )46081,      (u16 const   )29888,      (u16 const   )30080,      (u16 const   )46401, 
        (u16 const   )30464,      (u16 const   )47041,      (u16 const   )46721,      (u16 const   )30272, 
        (u16 const   )29184,      (u16 const   )45761,      (u16 const   )45953,      (u16 const   )29504, 
        (u16 const   )45313,      (u16 const   )29120,      (u16 const   )28800,      (u16 const   )45121, 
        (u16 const   )20480,      (u16 const   )37057,      (u16 const   )37249,      (u16 const   )20800, 
        (u16 const   )37633,      (u16 const   )21440,      (u16 const   )21120,      (u16 const   )37441, 
        (u16 const   )38401,      (u16 const   )22208,      (u16 const   )22400,      (u16 const   )38721, 
        (u16 const   )21760,      (u16 const   )38337,      (u16 const   )38017,      (u16 const   )21568, 
        (u16 const   )39937,      (u16 const   )23744,      (u16 const   )23936,      (u16 const   )40257, 
        (u16 const   )24320,      (u16 const   )40897,      (u16 const   )40577,      (u16 const   )24128, 
        (u16 const   )23040,      (u16 const   )39617,      (u16 const   )39809,      (u16 const   )23360, 
        (u16 const   )39169,      (u16 const   )22976,      (u16 const   )22656,      (u16 const   )38977, 
        (u16 const   )34817,      (u16 const   )18624,      (u16 const   )18816,      (u16 const   )35137, 
        (u16 const   )19200,      (u16 const   )35777,      (u16 const   )35457,      (u16 const   )19008, 
        (u16 const   )19968,      (u16 const   )36545,      (u16 const   )36737,      (u16 const   )20288, 
        (u16 const   )36097,      (u16 const   )19904,      (u16 const   )19584,      (u16 const   )35905, 
        (u16 const   )17408,      (u16 const   )33985,      (u16 const   )34177,      (u16 const   )17728, 
        (u16 const   )34561,      (u16 const   )18368,      (u16 const   )18048,      (u16 const   )34369, 
        (u16 const   )33281,      (u16 const   )17088,      (u16 const   )17280,      (u16 const   )33601, 
        (u16 const   )16640,      (u16 const   )33217,      (u16 const   )32897,      (u16 const   )16448};
#line 295 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int crc16(u8 *buf___0 , int len ) 
{ 
  u16 crc ;
  int i ;
  u8 *tmp ;

  {
#line 300
  crc = (u16 )0;
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (i < len)) {
#line 301
      goto while_break;
    }
#line 302
    tmp = buf___0;
#line 302
    buf___0 ++;
#line 302
    crc = (u16 )(((int )crc >> 8) ^ (int )crc16_table[((int )crc & 255) ^ (int )*tmp]);
#line 301
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return ((int )crc);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int parse_wlan_pda(struct prism2_pda *pda_info , int update_crc ) 
{ 
  int pos ;
  u16 *pda ;
  u16 len ;
  u16 pdr ;
  void *tmp ;
  int crc ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 311
  pda = (u16 *)(pda_info->pda_buf);
#line 312
  pos = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (pos + 1 < 512)) {
#line 313
      goto while_break;
    }
#line 314
    len = *(pda + pos);
#line 315
    pdr = *(pda + (pos + 1));
#line 316
    if ((int )len == 0) {
      {
#line 317
      printf((char const   */* __restrict  */)"Invalid PDR 0x%04x len=%d\n", (int )pdr,
             (int )len);
      }
#line 318
      return (1);
    } else
#line 316
    if (pos + (int )len > 512) {
      {
#line 317
      printf((char const   */* __restrict  */)"Invalid PDR 0x%04x len=%d\n", (int )pdr,
             (int )len);
      }
#line 318
      return (1);
    }
    {
#line 321
    tmp = realloc((void *)pda_info->pdrs, (unsigned long )(pda_info->pdr_count + 1) * sizeof(struct prism2_pdr ));
#line 321
    pda_info->pdrs = (struct prism2_pdr *)tmp;
    }
#line 325
    if (! ((unsigned long )pda_info->pdrs != (unsigned long )((void *)0))) {
      {
#line 325
      __assert_fail("pda_info->pdrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c",
                    325U, "parse_wlan_pda");
      }
    }
#line 326
    (pda_info->pdrs + pda_info->pdr_count)->pdr = (unsigned int )pdr;
#line 327
    (pda_info->pdrs + pda_info->pdr_count)->len = (unsigned int )(((int )len - 1) * 2);
#line 328
    (pda_info->pdrs + pda_info->pdr_count)->data = (unsigned char *)(pda + (pos + 2));
#line 330
    (pda_info->pdr_count) ++;
#line 332
    if ((int )pdr == 0) {
#line 332
      if ((int )len == 2) {
        {
#line 334
        tmp___1 = crc16((u8 *)(pda_info->pda_buf), (pos + 3) * 2);
        }
#line 334
        if (tmp___1 != 0) {
#line 335
          if (update_crc) {
            {
#line 336
            tmp___0 = crc16((u8 *)(pda_info->pda_buf), (pos + 2) * 2);
#line 336
            crc = tmp___0;
#line 338
            printf((char const   */* __restrict  */)"Updating PDA checksum to match with data (%04x -> %04x).\n",
                   (int )*(pda + (pos + 2)), crc);
#line 341
            *(pda + (pos + 2)) = (u16 )crc;
            }
          } else {
            {
#line 343
            printf((char const   */* __restrict  */)"PDA checksum incorrect.\n");
            }
#line 344
            return (1);
          }
        }
#line 347
        return (0);
      }
    }
#line 350
    pos += (int )len + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 353
  printf((char const   */* __restrict  */)"Could not find PDA end record.\n");
  }
#line 354
  return (1);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
int read_wlan_pda(char const   *fname , struct prism2_pda *pda_info ) 
{ 
  FILE *f ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 362
  memset((void *)pda_info, 0, sizeof(struct prism2_pda ));
#line 363
  f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 364
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 365
    return (1);
  }
  {
#line 367
  tmp = fread((void */* __restrict  */)(pda_info->pda_buf), (size_t )1, (size_t )1024,
              (FILE */* __restrict  */)f);
  }
#line 367
  if (tmp != 1024UL) {
    {
#line 369
    fclose(f);
    }
#line 370
    return (1);
  }
  {
#line 373
  fclose(f);
#line 375
  tmp___0 = parse_wlan_pda(pda_info, 0);
  }
#line 375
  return (tmp___0);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int get_next_word(FILE *f , char *linebuf , char **_pos ) 
{ 
  size_t len ;
  char *pos ;
  char *end ;
  char *pos2 ;
  int ret ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;

  {
#line 387
  pos = *_pos;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 389
    tmp = __ctype_b_loc();
    }
#line 389
    if (! ((int const   )*(*tmp + (int )*pos) & 8192)) {
#line 389
      goto while_break;
    }
#line 390
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  if ((int )*pos == 0) {
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 393
      tmp___0 = fgets((char */* __restrict  */)linebuf, 2048, (FILE */* __restrict  */)f);
      }
#line 393
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 394
        return (-1);
      }
      {
#line 395
      len = strcspn((char const   *)linebuf, ";/#");
#line 396
      *(linebuf + len) = (char )'\000';
#line 397
      pos = linebuf;
      }
      {
#line 398
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 398
        tmp___1 = __ctype_b_loc();
        }
#line 398
        if (! ((int const   )*(*tmp___1 + (int )*pos) & 8192)) {
#line 398
          goto while_break___1;
        }
#line 399
        pos ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 392
      if (! ((int )*pos == 0)) {
#line 392
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 401
    pos2 = pos;
    {
#line 402
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 402
      if (! ((int )*pos2 != 0)) {
#line 402
        goto while_break___2;
      }
#line 403
      if ((int )*pos2 == 44) {
#line 404
        *pos2 = (char )' ';
      }
#line 405
      pos2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 409
  tmp___2 = strtol((char const   */* __restrict  */)pos, (char **/* __restrict  */)(& end),
                   16);
#line 409
  ret = (int )tmp___2;
  }
#line 410
  if ((unsigned long )end == (unsigned long )pos) {
    {
#line 411
    pos = linebuf;
#line 412
    printf((char const   */* __restrict  */)"Expected a hex number at position marked with *:\n");
    }
    {
#line 413
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 413
      if (! ((int )*pos != 0)) {
#line 413
        goto while_break___3;
      }
#line 414
      if ((unsigned long )pos == (unsigned long )end) {
        {
#line 415
        putchar('*');
        }
      }
      {
#line 416
      tmp___3 = pos;
#line 416
      pos ++;
#line 416
      putchar((int )*tmp___3);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 418
    printf((char const   */* __restrict  */)"\n");
    }
#line 419
    return (-2);
  }
#line 421
  pos = end;
#line 422
  if ((unsigned long )pos >= (unsigned long )(linebuf + 2048)) {
#line 423
    pos = (linebuf + 2048) - 1;
  }
#line 424
  *_pos = pos;
#line 426
  return (ret);
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
int read_wlan_pda_text(char const   *fname , struct prism2_pda *pda_info ) 
{ 
  FILE *f ;
  char linebuf[2048] ;
  char *pos ;
  int words ;
  int w ;
  u16 *pda ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 437
  f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 438
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 439
    return (-1);
  }
  {
#line 441
  memset((void *)pda_info, 0, sizeof(struct prism2_pda ));
#line 442
  memset((void *)(pda_info->pda_buf), 255, (size_t )1024);
#line 443
  pda = (u16 *)(pda_info->pda_buf);
#line 444
  linebuf[0] = (char )'\000';
#line 445
  pos = linebuf;
#line 446
  words = 0;
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! (words < 512)) {
#line 447
      goto while_break;
    }
    {
#line 448
    w = get_next_word(f, linebuf, & pos);
    }
#line 449
    if (w == -2) {
      {
#line 450
      printf((char const   */* __restrict  */)"Parsing PDA data failed.\n");
#line 451
      fclose(f);
      }
#line 452
      return (-1);
    } else
#line 453
    if (w == -1) {
#line 454
      goto while_break;
    }
#line 455
    tmp = words;
#line 455
    words ++;
#line 455
    *(pda + tmp) = (u16 )w;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 458
  fclose(f);
  }
#line 460
  if (words + 3 < 512) {
#line 463
    tmp___0 = words;
#line 463
    words ++;
#line 463
    *(pda + tmp___0) = (u16 )2;
#line 464
    tmp___1 = words;
#line 464
    words ++;
#line 464
    *(pda + tmp___1) = (u16 )0;
#line 465
    tmp___2 = words;
#line 465
    words ++;
#line 465
    *(pda + tmp___2) = (u16 )0;
  }
  {
#line 468
  tmp___3 = parse_wlan_pda(pda_info, 1);
  }
#line 468
  return (tmp___3);
}
}
#line 472 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
char const   *prism2_pdr_name(int pdr ) 
{ 


  {
  {
#line 475
  if (pdr == 0) {
#line 475
    goto case_0;
  }
#line 477
  if (pdr == 1) {
#line 477
    goto case_1;
  }
#line 479
  if (pdr == 2) {
#line 479
    goto case_2;
  }
#line 481
  if (pdr == 3) {
#line 481
    goto case_3;
  }
#line 483
  if (pdr == 5) {
#line 483
    goto case_5;
  }
#line 485
  if (pdr == 6) {
#line 485
    goto case_6;
  }
#line 487
  if (pdr == 7) {
#line 487
    goto case_7;
  }
#line 489
  if (pdr == 8) {
#line 489
    goto case_8;
  }
#line 491
  if (pdr == 257) {
#line 491
    goto case_257;
  }
#line 493
  if (pdr == 259) {
#line 493
    goto case_259;
  }
#line 495
  if (pdr == 260) {
#line 495
    goto case_260;
  }
#line 497
  if (pdr == 261) {
#line 497
    goto case_261;
  }
#line 499
  if (pdr == 263) {
#line 499
    goto case_263;
  }
#line 501
  if (pdr == 512) {
#line 501
    goto case_512;
  }
#line 503
  if (pdr == 513) {
#line 503
    goto case_513;
  }
#line 505
  if (pdr == 514) {
#line 505
    goto case_514;
  }
#line 507
  if (pdr == 515) {
#line 507
    goto case_515;
  }
#line 509
  if (pdr == 516) {
#line 509
    goto case_516;
  }
#line 511
  if (pdr == 768) {
#line 511
    goto case_768;
  }
#line 513
  if (pdr == 769) {
#line 513
    goto case_769;
  }
#line 515
  if (pdr == 770) {
#line 515
    goto case_770;
  }
#line 517
  if (pdr == 771) {
#line 517
    goto case_771;
  }
#line 519
  if (pdr == 1024) {
#line 519
    goto case_1024;
  }
#line 521
  if (pdr == 1025) {
#line 521
    goto case_1025;
  }
#line 523
  if (pdr == 1026) {
#line 523
    goto case_1026;
  }
#line 525
  if (pdr == 1027) {
#line 525
    goto case_1027;
  }
#line 527
  if (pdr == 1028) {
#line 527
    goto case_1028;
  }
#line 529
  if (pdr == 1029) {
#line 529
    goto case_1029;
  }
#line 531
  if (pdr == 1030) {
#line 531
    goto case_1030;
  }
#line 533
  if (pdr == 1031) {
#line 533
    goto case_1031;
  }
#line 535
  if (pdr == 1033) {
#line 535
    goto case_1033;
  }
#line 537
  if (pdr == 1040) {
#line 537
    goto case_1040;
  }
#line 539
  if (pdr == 1041) {
#line 539
    goto case_1041;
  }
#line 541
  if (pdr == 1042) {
#line 541
    goto case_1042;
  }
#line 543
  if (pdr == 1043) {
#line 543
    goto case_1043;
  }
#line 545
  if (pdr == 2304) {
#line 545
    goto case_2304;
  }
#line 547
  if (pdr == 2305) {
#line 547
    goto case_2305;
  }
#line 474
  goto switch_break;
  case_0: /* CIL Label */ 
#line 476
  return ("PDA End Record");
  case_1: /* CIL Label */ 
#line 478
  return ("Platform name / Manufacturing part number");
  case_2: /* CIL Label */ 
#line 480
  return ("PDA Version Record");
  case_3: /* CIL Label */ 
#line 482
  return ("NIC Serial Number");
  case_5: /* CIL Label */ 
#line 484
  return ("NIC RAM Size");
  case_6: /* CIL Label */ 
#line 486
  return ("RF Modem Supplier Range");
  case_7: /* CIL Label */ 
#line 488
  return ("MAC Controller Supplier Range");
  case_8: /* CIL Label */ 
#line 490
  return ("NIC ID (component ID)");
  case_257: /* CIL Label */ 
#line 492
  return ("MAC Address");
  case_259: /* CIL Label */ 
#line 494
  return ("Regulatory Domain List");
  case_260: /* CIL Label */ 
#line 496
  return ("Allowed Channel Set/Active Channel List");
  case_261: /* CIL Label */ 
#line 498
  return ("Default Channel");
  case_263: /* CIL Label */ 
#line 500
  return ("Temperature Type");
  case_512: /* CIL Label */ 
#line 502
  return ("IFR Setting");
  case_513: /* CIL Label */ 
#line 504
  return ("RFR Setting");
  case_514: /* CIL Label */ 
#line 506
  return ("3861 Baseline Register Settings");
  case_515: /* CIL Label */ 
#line 508
  return ("3861 Shadow Register Settings");
  case_516: /* CIL Label */ 
#line 510
  return ("3861 IF/RF Register Settings");
  case_768: /* CIL Label */ 
#line 512
  return ("3861 Channel Calibration Set Point");
  case_769: /* CIL Label */ 
#line 514
  return ("3861 Channel Calibration Integrator");
  case_770: /* CIL Label */ 
#line 516
  return ("Maximum Radio TX Power");
  case_771: /* CIL Label */ 
#line 518
  return ("Scannable/Master Channel List");
  case_1024: /* CIL Label */ 
#line 520
  return ("3842 PRISM II NIC Configuration");
  case_1025: /* CIL Label */ 
#line 522
  return ("PRISM USB Identifier");
  case_1026: /* CIL Label */ 
#line 524
  return ("PRISM PCI Identifier");
  case_1027: /* CIL Label */ 
#line 526
  return ("PRISM PCI Interface Configuration");
  case_1028: /* CIL Label */ 
#line 528
  return ("PRISM PCI PM Configuration");
  case_1029: /* CIL Label */ 
#line 530
  return ("ZIF Synthesizer Settings");
  case_1030: /* CIL Label */ 
#line 532
  return ("RSSI-to-dBm Conversion Constant");
  case_1031: /* CIL Label */ 
#line 534
  return ("USB Power Type");
  case_1033: /* CIL Label */ 
#line 536
  return ("PRISM USB Max Power");
  case_1040: /* CIL Label */ 
#line 538
  return ("USB Manufacture String");
  case_1041: /* CIL Label */ 
#line 540
  return ("USB Product String");
  case_1042: /* CIL Label */ 
#line 542
  return ("SW Diversity Control");
  case_1043: /* CIL Label */ 
#line 544
  return ("HFO Delay");
  case_2304: /* CIL Label */ 
#line 546
  return ("3861 Manufacturing Test Channel Set Points");
  case_2305: /* CIL Label */ 
#line 548
  return ("Manufacturing Test Channel Integrators");
  switch_break: /* CIL Label */ ;
  }
#line 551
  return ("");
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_rid.c"
static void usage___0(void) 
{ 


  {
  {
#line 24
  printf((char const   */* __restrict  */)"Usage: hostap_rid <device> <get/set> <rid id> [data]\n\nExamples:\n   hostap_rid wlan0 get fc00\n   hostap_rid wlan0 set fc00 06 00\n   hostap_rid wlan0 set fc0e 06 00 66 6f 6f 62 61 72\n\nNote:\n- Prism2/2.5/3 uses little-endian byte order\n- The most common word size is 16 bits\n- Set command needs the raw RID contents, i.e., it will be written as is to the device\n");
  }
#line 36
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_rid.c"
static int get_rid(char const   *dev , u16 rid ) 
{ 
  char buf___0[1024] ;
  struct prism2_hostapd_param *param ;
  int res ;
  int i ;

  {
  {
#line 45
  param = (struct prism2_hostapd_param *)(buf___0);
#line 47
  res = hostapd_get_rid(dev, param, rid, 1);
  }
#line 48
  if (res == 1) {
    {
#line 49
    printf((char const   */* __restrict  */)"hostap_rid requires root privileges\n");
    }
#line 50
    return (-1);
  }
#line 52
  if (res == 61) {
    {
#line 53
    printf((char const   */* __restrict  */)"Get RID did not return any data.\n");
    }
#line 54
    return (-1);
  } else
#line 55
  if (res) {
    {
#line 56
    printf((char const   */* __restrict  */)"Could not communicate with the kernel driver.\n");
    }
#line 57
    return (-1);
  }
#line 60
  i = 0;
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < (int )param->u.rid.len)) {
#line 60
      goto while_break;
    }
    {
#line 61
    printf((char const   */* __restrict  */)"%02x ", (int )param->u.rid.data[i]);
#line 60
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 62
  printf((char const   */* __restrict  */)"\n");
  }
#line 64
  return (0);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_rid.c"
static int set_rid(char const   *dev , u16 rid , int argc , char **argv ) 
{ 
  u8 *data ;
  int res ;
  int i ;
  long val ;
  void *tmp ;

  {
  {
#line 74
  tmp = malloc((size_t )argc);
#line 74
  data = (u8 *)tmp;
  }
#line 75
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 76
    return (-1);
  }
#line 78
  i = 0;
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < argc)) {
#line 78
      goto while_break;
    }
    {
#line 79
    val = strtol((char const   */* __restrict  */)*(argv + i), (char **/* __restrict  */)((void *)0),
                 16);
    }
#line 80
    if (val < 0L) {
      {
#line 81
      usage___0();
#line 82
      printf((char const   */* __restrict  */)"\nInvalid data value \'%s\'\n", *(argv + i));
      }
#line 83
      return (-1);
    } else
#line 80
    if (val > 255L) {
      {
#line 81
      usage___0();
#line 82
      printf((char const   */* __restrict  */)"\nInvalid data value \'%s\'\n", *(argv + i));
      }
#line 83
      return (-1);
    }
#line 85
    *(data + i) = (u8 )val;
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  res = hostapd_set_rid(dev, rid, data, (size_t )argc, 1);
  }
#line 89
  if (res == 1) {
    {
#line 90
    printf((char const   */* __restrict  */)"hostap_rid requires root privileges\n");
    }
#line 91
    return (-1);
  }
#line 93
  if (res) {
    {
#line 94
    printf((char const   */* __restrict  */)"Could not communicate with the kernel driver.\n");
    }
#line 95
    return (-1);
  }
#line 98
  return (0);
}
}
#line 102 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_rid.c"
int main(int argc , char **argv ) 
{ 
  char *dev ;
  int set ;
  long rid ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 108
  if (argc < 4) {
    {
#line 109
    usage___0();
    }
#line 110
    return (-1);
  }
  {
#line 113
  dev = *(argv + 1);
#line 114
  tmp___0 = strcmp((char const   *)*(argv + 2), "set");
  }
#line 114
  if (tmp___0 == 0) {
#line 115
    set = 1;
  } else {
    {
#line 116
    tmp = strcmp((char const   *)*(argv + 2), "get");
    }
#line 116
    if (tmp == 0) {
#line 117
      set = 0;
    } else {
      {
#line 119
      usage___0();
      }
#line 120
      return (-1);
    }
  }
  {
#line 123
  rid = strtol((char const   */* __restrict  */)*(argv + 3), (char **/* __restrict  */)((void *)0),
               16);
  }
#line 124
  if (rid < 0L) {
    {
#line 125
    usage___0();
#line 126
    printf((char const   */* __restrict  */)"\nInvalid rid 0x%lx\n", rid);
    }
#line 127
    return (-1);
  } else
#line 124
  if (rid > 65535L) {
    {
#line 125
    usage___0();
#line 126
    printf((char const   */* __restrict  */)"\nInvalid rid 0x%lx\n", rid);
    }
#line 127
    return (-1);
  }
#line 130
  if (set) {
    {
#line 131
    tmp___1 = set_rid((char const   *)dev, (u16 )rid, argc - 4, argv + 4);
    }
#line 131
    return (tmp___1);
  } else {
    {
#line 133
    tmp___2 = get_rid((char const   *)dev, (u16 )rid);
    }
#line 133
    return (tmp___2);
  }
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static struct hostap_nicid_rec hostap_nicids___0[29]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
  {      {(u16 )32768, (char *)"EVB2 (HFA3841EVAL1) with PRISM I (3860B) Radio"}, 
        {(u16 )32769, (char *)"HWB3763 Rev B"}, 
        {(u16 )32770, (char *)"HWB3163-01,02,03,04 Rev A"}, 
        {(u16 )32771, (char *)"HWB3163 Rev B, Samsung PC Card Rev. B"}, 
        {(u16 )32772, (char *)"EVB3 (HFA3843EVAL1, Rev B1)"}, 
        {(u16 )32774, (char *)"Nortel Sputnik I"}, 
        {(u16 )32775, (char *)"HWB1153 PRISM I Ref"}, 
        {(u16 )32776, (char *)"HWB3163, Prism II reference with SSF Flash"}, 
        {(u16 )32778, (char *)"3842 Evaluation Board"}, 
        {(u16 )32779, (char *)"PRISM II (2.5) PCMCIA (AMD parallel flash)"}, 
        {(u16 )32780, (char *)"PRISM II (2.5) PCMCIA (SST parallel flash)"}, 
        {(u16 )32781, (char *)"PRISM II (2.5) PCMCIA (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32782,
      (char *)"PRISM II (2.5) PCMCIA (AT24C08 compatible small serial flash)"}, 
        {(u16 )32786, (char *)"PRISM II (2.5) Mini-PCI (AMD parallel flash)"}, 
        {(u16 )32787, (char *)"PRISM II (2.5) Mini-PCI (SST parallel flash)"}, 
        {(u16 )32788, (char *)"PRISM II (2.5) Mini-PCI (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32789,
      (char *)"PRISM II (2.5) Mini-PCI (AT24C08 compatible small serial flash)"}, 
        {(u16 )32790, (char *)"PCI-bridge (AMD parallel flash)"}, 
        {(u16 )32791, (char *)"PCI-bridge (SST parallel flash)"}, 
        {(u16 )32792, (char *)"PCI-bridge (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32793,
      (char *)"PCI-bridge (AT24C08 compatible small serial flash)"}, 
        {(u16 )32794, (char *)"PRISM III PCMCIA (AMD parallel flash)"}, 
        {(u16 )32795, (char *)"PRISM III PCMCIA (SST parallel flash)"}, 
        {(u16 )32796, (char *)"PRISM III PCMCIA (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32797,
      (char *)"PRISM III PCMCIA (AT24C08 compatible small serial flash)"}, 
        {(u16 )32801, (char *)"PRISM III Mini-PCI (AMD parallel flash)"}, 
        {(u16 )32802, (char *)"PRISM III Mini-PCI (SST parallel flash)"}, 
        {(u16 )32803, (char *)"PRISM III Mini-PCI (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32804,
      (char *)"PRISM III Mini-PCI (AT24C08 compatible small serial flash)"}};
#line 258 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static u16 const   crc16_table___0[256]  = 
#line 258
  {      (u16 const   )0,      (u16 const   )49345,      (u16 const   )49537,      (u16 const   )320, 
        (u16 const   )49921,      (u16 const   )960,      (u16 const   )640,      (u16 const   )49729, 
        (u16 const   )50689,      (u16 const   )1728,      (u16 const   )1920,      (u16 const   )51009, 
        (u16 const   )1280,      (u16 const   )50625,      (u16 const   )50305,      (u16 const   )1088, 
        (u16 const   )52225,      (u16 const   )3264,      (u16 const   )3456,      (u16 const   )52545, 
        (u16 const   )3840,      (u16 const   )53185,      (u16 const   )52865,      (u16 const   )3648, 
        (u16 const   )2560,      (u16 const   )51905,      (u16 const   )52097,      (u16 const   )2880, 
        (u16 const   )51457,      (u16 const   )2496,      (u16 const   )2176,      (u16 const   )51265, 
        (u16 const   )55297,      (u16 const   )6336,      (u16 const   )6528,      (u16 const   )55617, 
        (u16 const   )6912,      (u16 const   )56257,      (u16 const   )55937,      (u16 const   )6720, 
        (u16 const   )7680,      (u16 const   )57025,      (u16 const   )57217,      (u16 const   )8000, 
        (u16 const   )56577,      (u16 const   )7616,      (u16 const   )7296,      (u16 const   )56385, 
        (u16 const   )5120,      (u16 const   )54465,      (u16 const   )54657,      (u16 const   )5440, 
        (u16 const   )55041,      (u16 const   )6080,      (u16 const   )5760,      (u16 const   )54849, 
        (u16 const   )53761,      (u16 const   )4800,      (u16 const   )4992,      (u16 const   )54081, 
        (u16 const   )4352,      (u16 const   )53697,      (u16 const   )53377,      (u16 const   )4160, 
        (u16 const   )61441,      (u16 const   )12480,      (u16 const   )12672,      (u16 const   )61761, 
        (u16 const   )13056,      (u16 const   )62401,      (u16 const   )62081,      (u16 const   )12864, 
        (u16 const   )13824,      (u16 const   )63169,      (u16 const   )63361,      (u16 const   )14144, 
        (u16 const   )62721,      (u16 const   )13760,      (u16 const   )13440,      (u16 const   )62529, 
        (u16 const   )15360,      (u16 const   )64705,      (u16 const   )64897,      (u16 const   )15680, 
        (u16 const   )65281,      (u16 const   )16320,      (u16 const   )16000,      (u16 const   )65089, 
        (u16 const   )64001,      (u16 const   )15040,      (u16 const   )15232,      (u16 const   )64321, 
        (u16 const   )14592,      (u16 const   )63937,      (u16 const   )63617,      (u16 const   )14400, 
        (u16 const   )10240,      (u16 const   )59585,      (u16 const   )59777,      (u16 const   )10560, 
        (u16 const   )60161,      (u16 const   )11200,      (u16 const   )10880,      (u16 const   )59969, 
        (u16 const   )60929,      (u16 const   )11968,      (u16 const   )12160,      (u16 const   )61249, 
        (u16 const   )11520,      (u16 const   )60865,      (u16 const   )60545,      (u16 const   )11328, 
        (u16 const   )58369,      (u16 const   )9408,      (u16 const   )9600,      (u16 const   )58689, 
        (u16 const   )9984,      (u16 const   )59329,      (u16 const   )59009,      (u16 const   )9792, 
        (u16 const   )8704,      (u16 const   )58049,      (u16 const   )58241,      (u16 const   )9024, 
        (u16 const   )57601,      (u16 const   )8640,      (u16 const   )8320,      (u16 const   )57409, 
        (u16 const   )40961,      (u16 const   )24768,      (u16 const   )24960,      (u16 const   )41281, 
        (u16 const   )25344,      (u16 const   )41921,      (u16 const   )41601,      (u16 const   )25152, 
        (u16 const   )26112,      (u16 const   )42689,      (u16 const   )42881,      (u16 const   )26432, 
        (u16 const   )42241,      (u16 const   )26048,      (u16 const   )25728,      (u16 const   )42049, 
        (u16 const   )27648,      (u16 const   )44225,      (u16 const   )44417,      (u16 const   )27968, 
        (u16 const   )44801,      (u16 const   )28608,      (u16 const   )28288,      (u16 const   )44609, 
        (u16 const   )43521,      (u16 const   )27328,      (u16 const   )27520,      (u16 const   )43841, 
        (u16 const   )26880,      (u16 const   )43457,      (u16 const   )43137,      (u16 const   )26688, 
        (u16 const   )30720,      (u16 const   )47297,      (u16 const   )47489,      (u16 const   )31040, 
        (u16 const   )47873,      (u16 const   )31680,      (u16 const   )31360,      (u16 const   )47681, 
        (u16 const   )48641,      (u16 const   )32448,      (u16 const   )32640,      (u16 const   )48961, 
        (u16 const   )32000,      (u16 const   )48577,      (u16 const   )48257,      (u16 const   )31808, 
        (u16 const   )46081,      (u16 const   )29888,      (u16 const   )30080,      (u16 const   )46401, 
        (u16 const   )30464,      (u16 const   )47041,      (u16 const   )46721,      (u16 const   )30272, 
        (u16 const   )29184,      (u16 const   )45761,      (u16 const   )45953,      (u16 const   )29504, 
        (u16 const   )45313,      (u16 const   )29120,      (u16 const   )28800,      (u16 const   )45121, 
        (u16 const   )20480,      (u16 const   )37057,      (u16 const   )37249,      (u16 const   )20800, 
        (u16 const   )37633,      (u16 const   )21440,      (u16 const   )21120,      (u16 const   )37441, 
        (u16 const   )38401,      (u16 const   )22208,      (u16 const   )22400,      (u16 const   )38721, 
        (u16 const   )21760,      (u16 const   )38337,      (u16 const   )38017,      (u16 const   )21568, 
        (u16 const   )39937,      (u16 const   )23744,      (u16 const   )23936,      (u16 const   )40257, 
        (u16 const   )24320,      (u16 const   )40897,      (u16 const   )40577,      (u16 const   )24128, 
        (u16 const   )23040,      (u16 const   )39617,      (u16 const   )39809,      (u16 const   )23360, 
        (u16 const   )39169,      (u16 const   )22976,      (u16 const   )22656,      (u16 const   )38977, 
        (u16 const   )34817,      (u16 const   )18624,      (u16 const   )18816,      (u16 const   )35137, 
        (u16 const   )19200,      (u16 const   )35777,      (u16 const   )35457,      (u16 const   )19008, 
        (u16 const   )19968,      (u16 const   )36545,      (u16 const   )36737,      (u16 const   )20288, 
        (u16 const   )36097,      (u16 const   )19904,      (u16 const   )19584,      (u16 const   )35905, 
        (u16 const   )17408,      (u16 const   )33985,      (u16 const   )34177,      (u16 const   )17728, 
        (u16 const   )34561,      (u16 const   )18368,      (u16 const   )18048,      (u16 const   )34369, 
        (u16 const   )33281,      (u16 const   )17088,      (u16 const   )17280,      (u16 const   )33601, 
        (u16 const   )16640,      (u16 const   )33217,      (u16 const   )32897,      (u16 const   )16448};
#line 295 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int crc16___0(u8 *buf___0 , int len ) 
{ 
  u16 crc ;
  int i ;
  u8 *tmp ;

  {
#line 300
  crc = (u16 )0;
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (i < len)) {
#line 301
      goto while_break;
    }
#line 302
    tmp = buf___0;
#line 302
    buf___0 ++;
#line 302
    crc = (u16 )(((int )crc >> 8) ^ (int )crc16_table___0[((int )crc & 255) ^ (int )*tmp]);
#line 301
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return ((int )crc);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int parse_wlan_pda___0(struct prism2_pda *pda_info , int update_crc ) 
{ 
  int pos ;
  u16 *pda ;
  u16 len ;
  u16 pdr ;
  void *tmp ;
  int crc ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 311
  pda = (u16 *)(pda_info->pda_buf);
#line 312
  pos = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (pos + 1 < 512)) {
#line 313
      goto while_break;
    }
#line 314
    len = *(pda + pos);
#line 315
    pdr = *(pda + (pos + 1));
#line 316
    if ((int )len == 0) {
      {
#line 317
      printf((char const   */* __restrict  */)"Invalid PDR 0x%04x len=%d\n", (int )pdr,
             (int )len);
      }
#line 318
      return (1);
    } else
#line 316
    if (pos + (int )len > 512) {
      {
#line 317
      printf((char const   */* __restrict  */)"Invalid PDR 0x%04x len=%d\n", (int )pdr,
             (int )len);
      }
#line 318
      return (1);
    }
    {
#line 321
    tmp = realloc((void *)pda_info->pdrs, (unsigned long )(pda_info->pdr_count + 1) * sizeof(struct prism2_pdr ));
#line 321
    pda_info->pdrs = (struct prism2_pdr *)tmp;
    }
#line 325
    if (! ((unsigned long )pda_info->pdrs != (unsigned long )((void *)0))) {
      {
#line 325
      __assert_fail("pda_info->pdrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c",
                    325U, "parse_wlan_pda");
      }
    }
#line 326
    (pda_info->pdrs + pda_info->pdr_count)->pdr = (unsigned int )pdr;
#line 327
    (pda_info->pdrs + pda_info->pdr_count)->len = (unsigned int )(((int )len - 1) * 2);
#line 328
    (pda_info->pdrs + pda_info->pdr_count)->data = (unsigned char *)(pda + (pos + 2));
#line 330
    (pda_info->pdr_count) ++;
#line 332
    if ((int )pdr == 0) {
#line 332
      if ((int )len == 2) {
        {
#line 334
        tmp___1 = crc16___0((u8 *)(pda_info->pda_buf), (pos + 3) * 2);
        }
#line 334
        if (tmp___1 != 0) {
#line 335
          if (update_crc) {
            {
#line 336
            tmp___0 = crc16___0((u8 *)(pda_info->pda_buf), (pos + 2) * 2);
#line 336
            crc = tmp___0;
#line 338
            printf((char const   */* __restrict  */)"Updating PDA checksum to match with data (%04x -> %04x).\n",
                   (int )*(pda + (pos + 2)), crc);
#line 341
            *(pda + (pos + 2)) = (u16 )crc;
            }
          } else {
            {
#line 343
            printf((char const   */* __restrict  */)"PDA checksum incorrect.\n");
            }
#line 344
            return (1);
          }
        }
#line 347
        return (0);
      }
    }
#line 350
    pos += (int )len + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 353
  printf((char const   */* __restrict  */)"Could not find PDA end record.\n");
  }
#line 354
  return (1);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int get_next_word___0(FILE *f , char *linebuf , char **_pos ) 
{ 
  size_t len ;
  char *pos ;
  char *end ;
  char *pos2 ;
  int ret ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;

  {
#line 387
  pos = *_pos;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 389
    tmp = __ctype_b_loc();
    }
#line 389
    if (! ((int const   )*(*tmp + (int )*pos) & 8192)) {
#line 389
      goto while_break;
    }
#line 390
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  if ((int )*pos == 0) {
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 393
      tmp___0 = fgets((char */* __restrict  */)linebuf, 2048, (FILE */* __restrict  */)f);
      }
#line 393
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 394
        return (-1);
      }
      {
#line 395
      len = strcspn((char const   *)linebuf, ";/#");
#line 396
      *(linebuf + len) = (char )'\000';
#line 397
      pos = linebuf;
      }
      {
#line 398
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 398
        tmp___1 = __ctype_b_loc();
        }
#line 398
        if (! ((int const   )*(*tmp___1 + (int )*pos) & 8192)) {
#line 398
          goto while_break___1;
        }
#line 399
        pos ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 392
      if (! ((int )*pos == 0)) {
#line 392
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 401
    pos2 = pos;
    {
#line 402
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 402
      if (! ((int )*pos2 != 0)) {
#line 402
        goto while_break___2;
      }
#line 403
      if ((int )*pos2 == 44) {
#line 404
        *pos2 = (char )' ';
      }
#line 405
      pos2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 409
  tmp___2 = strtol((char const   */* __restrict  */)pos, (char **/* __restrict  */)(& end),
                   16);
#line 409
  ret = (int )tmp___2;
  }
#line 410
  if ((unsigned long )end == (unsigned long )pos) {
    {
#line 411
    pos = linebuf;
#line 412
    printf((char const   */* __restrict  */)"Expected a hex number at position marked with *:\n");
    }
    {
#line 413
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 413
      if (! ((int )*pos != 0)) {
#line 413
        goto while_break___3;
      }
#line 414
      if ((unsigned long )pos == (unsigned long )end) {
        {
#line 415
        putchar('*');
        }
      }
      {
#line 416
      tmp___3 = pos;
#line 416
      pos ++;
#line 416
      putchar((int )*tmp___3);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 418
    printf((char const   */* __restrict  */)"\n");
    }
#line 419
    return (-2);
  }
#line 421
  pos = end;
#line 422
  if ((unsigned long )pos >= (unsigned long )(linebuf + 2048)) {
#line 423
    pos = (linebuf + 2048) - 1;
  }
#line 424
  *_pos = pos;
#line 426
  return (ret);
}
}
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
static int diag_show_summary(char const   *dev ) 
{ 
  char buf___0[1024] ;
  struct prism2_hostapd_param *param ;
  int res ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 28
  printf((char const   */* __restrict  */)"Host AP driver diagnostics information for \'%s\'\n\n",
         dev);
#line 30
  param = (struct prism2_hostapd_param *)(buf___0);
#line 32
  res = hostapd_get_rid(dev, param, (u16 )64779, 1);
  }
#line 33
  if (res == 1) {
    {
#line 34
    printf((char const   */* __restrict  */)"hostap_diag requires root privileges\n");
    }
#line 35
    return (-1);
  }
#line 37
  if (res == 61) {
    {
#line 38
    printf((char const   */* __restrict  */)"NICID read did not return any data.\n");
    }
  } else
#line 39
  if (res) {
    {
#line 40
    printf((char const   */* __restrict  */)"Could not communicate with the kernel driver.\n");
    }
#line 41
    return (-1);
  }
#line 44
  if (res == 0) {
    {
#line 45
    hostap_show_nicid(param->u.rid.data, (int )param->u.rid.len);
    }
  }
  {
#line 47
  tmp = hostapd_get_rid(dev, param, (u16 )64770, 1);
  }
#line 47
  if (! tmp) {
    {
#line 48
    hostap_show_priid(param->u.rid.data, (int )param->u.rid.len);
    }
  }
  {
#line 50
  tmp___0 = hostapd_get_rid(dev, param, (u16 )64800, 1);
  }
#line 50
  if (! tmp___0) {
    {
#line 51
    hostap_show_staid(param->u.rid.data, (int )param->u.rid.len);
    }
  }
#line 53
  return (0);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
static struct __anonstruct_rid_table_46 rid_table[160]  = 
#line 61
  {      {(u16 )64512, (char *)"CNFPORTTYPE", 1}, 
        {(u16 )64513, (char *)"CNFOWNMACADDR", 2}, 
        {(u16 )64514, (char *)"CNFDESIREDSSID", 3}, 
        {(u16 )64515, (char *)"CNFOWNCHANNEL", 1}, 
        {(u16 )64516, (char *)"CNFOWNSSID", 3}, 
        {(u16 )64517, (char *)"CNFOWNATIMWINDOW", 1}, 
        {(u16 )64518, (char *)"CNFSYSTEMSCALE", 1}, 
        {(u16 )64519, (char *)"CNFMAXDATALEN", 1}, 
        {(u16 )64520, (char *)"CNFWDSADDRESS", 2}, 
        {(u16 )64521, (char *)"CNFPMENABLED", 1}, 
        {(u16 )64522, (char *)"CNFPMEPS", 1}, 
        {(u16 )64523, (char *)"CNFMULTICASTRECEIVE", 1}, 
        {(u16 )64524, (char *)"CNFMAXSLEEPDURATION", 1}, 
        {(u16 )64525, (char *)"CNFPMHOLDOVERDURATION", 1}, 
        {(u16 )64526, (char *)"CNFOWNNAME", 3}, 
        {(u16 )64528, (char *)"CNFOWNDTIMPERIOD", 1}, 
        {(u16 )64529, (char *)"CNFWDSADDRESS1", 2}, 
        {(u16 )64530, (char *)"CNFWDSADDRESS2", 2}, 
        {(u16 )64531, (char *)"CNFWDSADDRESS3", 2}, 
        {(u16 )64532, (char *)"CNFWDSADDRESS4", 2}, 
        {(u16 )64533, (char *)"CNFWDSADDRESS5", 2}, 
        {(u16 )64534, (char *)"CNFWDSADDRESS6", 2}, 
        {(u16 )64535, (char *)"CNFMULTICASTPMBUFFERING", 1}, 
        {(u16 )64544, (char *)"UNKNOWN1", 1}, 
        {(u16 )64545, (char *)"UNKNOWN2", 1}, 
        {(u16 )64547, (char *)"CNFWEPDEFAULTKEYID", 1}, 
        {(u16 )64548, (char *)"CNFDEFAULTKEY0", 0}, 
        {(u16 )64549, (char *)"CNFDEFAULTKEY1", 0}, 
        {(u16 )64550, (char *)"CNFDEFAULTKEY2", 0}, 
        {(u16 )64551, (char *)"CNFDEFAULTKEY3", 0}, 
        {(u16 )64552, (char *)"CNFWEPFLAGS", 0}, 
        {(u16 )64553, (char *)"CNFWEPKEYMAPPINGTABLE", 0}, 
        {(u16 )64554, (char *)"CNFAUTHENTICATION", 1}, 
        {(u16 )64555, (char *)"CNFMAXASSOCSTA", 1}, 
        {(u16 )64556, (char *)"CNFTXCONTROL", 1}, 
        {(u16 )64557, (char *)"CNFROAMINGMODE", 1}, 
        {(u16 )64558, (char *)"CNFHOSTAUTHENTICATION", 1}, 
        {(u16 )64560, (char *)"CNFRCVCRCERROR", 1}, 
        {(u16 )64561, (char *)"CNFMMLIFE", 1}, 
        {(u16 )64562, (char *)"CNFALTRETRYCOUNT", 1}, 
        {(u16 )64563, (char *)"CNFBEACONINT", 1}, 
        {(u16 )64564, (char *)"CNFAPPCFINFO", 0}, 
        {(u16 )64565, (char *)"CNFSTAPCFINFO", 0}, 
        {(u16 )64567, (char *)"CNFPRIORITYQUSAGE", 0}, 
        {(u16 )64576, (char *)"CNFTIMCTRL", 1}, 
        {(u16 )64577, (char *)"UNKNOWN3", 0}, 
        {(u16 )64578, (char *)"CNFTHIRTY2TALLY", 1}, 
        {(u16 )64579, (char *)"CNFENHSECURITY", 1}, 
        {(u16 )64582, (char *)"CNFDBMADJUST", 1}, 
        {(u16 )64584, (char *)"GENERICELEMENT", 0}, 
        {(u16 )64585, (char *)"PROPAGATIONDELAY", 1}, 
        {(u16 )64640, (char *)"GROUPADDRESSES", 0}, 
        {(u16 )64641, (char *)"CREATEIBSS", 1}, 
        {(u16 )64642, (char *)"FRAGMENTATIONTHRESHOLD", 1}, 
        {(u16 )64643, (char *)"RTSTHRESHOLD", 1}, 
        {(u16 )64644, (char *)"TXRATECONTROL", 1}, 
        {(u16 )64645, (char *)"PROMISCUOUSMODE", 1}, 
        {(u16 )64656, (char *)"FRAGMENTATIONTHRESHOLD0", 1}, 
        {(u16 )64657, (char *)"FRAGMENTATIONTHRESHOLD1", 1}, 
        {(u16 )64658, (char *)"FRAGMENTATIONTHRESHOLD2", 1}, 
        {(u16 )64659, (char *)"FRAGMENTATIONTHRESHOLD3", 1}, 
        {(u16 )64660, (char *)"FRAGMENTATIONTHRESHOLD4", 1}, 
        {(u16 )64661, (char *)"FRAGMENTATIONTHRESHOLD5", 1}, 
        {(u16 )64662, (char *)"FRAGMENTATIONTHRESHOLD6", 1}, 
        {(u16 )64663, (char *)"RTSTHRESHOLD0", 1}, 
        {(u16 )64664, (char *)"RTSTHRESHOLD1", 1}, 
        {(u16 )64665, (char *)"RTSTHRESHOLD2", 1}, 
        {(u16 )64666, (char *)"RTSTHRESHOLD3", 1}, 
        {(u16 )64667, (char *)"RTSTHRESHOLD4", 1}, 
        {(u16 )64668, (char *)"RTSTHRESHOLD5", 1}, 
        {(u16 )64669, (char *)"RTSTHRESHOLD6", 1}, 
        {(u16 )64670, (char *)"TXRATECONTROL0", 1}, 
        {(u16 )64671, (char *)"TXRATECONTROL1", 1}, 
        {(u16 )64672, (char *)"TXRATECONTROL2", 1}, 
        {(u16 )64673, (char *)"TXRATECONTROL3", 1}, 
        {(u16 )64674, (char *)"TXRATECONTROL4", 1}, 
        {(u16 )64675, (char *)"TXRATECONTROL5", 1}, 
        {(u16 )64676, (char *)"TXRATECONTROL6", 1}, 
        {(u16 )64688, (char *)"CNFSHORTPREAMBLE", 1}, 
        {(u16 )64689, (char *)"CNFEXCLUDELONGPREAMBLE", 1}, 
        {(u16 )64690, (char *)"CNFAUTHENTICATIONRSPTO", 1}, 
        {(u16 )64691, (char *)"CNFBASICRATES", 0}, 
        {(u16 )64692, (char *)"CNFSUPPORTEDRATES", 0}, 
        {(u16 )64693, (char *)"CNFFALLBACKCTRL", 1}, 
        {(u16 )64694, (char *)"WEPKEYDISABLE", 1}, 
        {(u16 )64695, (char *)"WEPKEYMAPINDEX", 0}, 
        {(u16 )64696, (char *)"BROADCASTKEYID", 0}, 
        {(u16 )64697, (char *)"ENTSECFLAGEYID", 0}, 
        {(u16 )64698, (char *)"CNFPASSIVESCANCTRL", 1}, 
        {(u16 )64699, (char *)"SSNHANDLINGMODE", 1}, 
        {(u16 )64700, (char *)"MDCCONTROL", 1}, 
        {(u16 )64701, (char *)"MDCCOUNTRY", 0}, 
        {(u16 )64702, (char *)"TXPOWERMAX", 1}, 
        {(u16 )64703, (char *)"CNFLFOENABLED", 1}, 
        {(u16 )64704, (char *)"CAPINFO", 1}, 
        {(u16 )64705, (char *)"LISTENINTERVAL", 1}, 
        {(u16 )64706, (char *)"SW_ANT_DIV", 0}, 
        {(u16 )64708, (char *)"LED_CTRL", 0}, 
        {(u16 )64709, (char *)"HFODELAY", 1}, 
        {(u16 )64710, (char *)"DISALLOWEDBSSID", 0}, 
        {(u16 )64736, (char *)"TICKTIME", 1}, 
        {(u16 )64737, (char *)"SCANREQUEST", 0}, 
        {(u16 )64738, (char *)"JOINREQUEST", 0}, 
        {(u16 )64739, (char *)"AUTHENTICATESTATION", 0}, 
        {(u16 )64740, (char *)"CHANNELINFOREQUEST", 0}, 
        {(u16 )64741, (char *)"HOSTSCAN", 0}, 
        {(u16 )64768, (char *)"MAXLOADTIME", 1}, 
        {(u16 )64769, (char *)"DOWNLOADBUFFER", 0}, 
        {(u16 )64770, (char *)"PRIID", 4}, 
        {(u16 )64771, (char *)"PRISUPRANGE", 5}, 
        {(u16 )64772, (char *)"CFIACTRANGES", 5}, 
        {(u16 )64778, (char *)"NICSERNUM", 3}, 
        {(u16 )64779, (char *)"NICID", 4}, 
        {(u16 )64780, (char *)"MFISUPRANGE", 5}, 
        {(u16 )64781, (char *)"CFISUPRANGE", 5}, 
        {(u16 )64784, (char *)"CHANNELLIST", 0}, 
        {(u16 )64785, (char *)"REGULATORYDOMAINS", 3}, 
        {(u16 )64786, (char *)"TEMPTYPE", 1}, 
        {(u16 )64787, (char *)"CIS", 7}, 
        {(u16 )64800, (char *)"STAID", 4}, 
        {(u16 )64801, (char *)"STASUPRANGE", 5}, 
        {(u16 )64802, (char *)"MFIACTRANGES", 5}, 
        {(u16 )64803, (char *)"CFIACTRANGES2", 5}, 
        {(u16 )64804, (char *)"PRODUCTNAME", 3}, 
        {(u16 )64832, (char *)"PORTSTATUS", 1}, 
        {(u16 )64833, (char *)"CURRENTSSID", 3}, 
        {(u16 )64834, (char *)"CURRENTBSSID", 2}, 
        {(u16 )64835, (char *)"COMMSQUALITY", 0}, 
        {(u16 )64836, (char *)"CURRENTTXRATE", 1}, 
        {(u16 )64837, (char *)"CURRENTBEACONINTERVAL", 1}, 
        {(u16 )64838, (char *)"CURRENTSCALETHRESHOLDS", 0}, 
        {(u16 )64839, (char *)"PROTOCOLRSPTIME", 1}, 
        {(u16 )64840, (char *)"SHORTRETRYLIMIT", 1}, 
        {(u16 )64841, (char *)"LONGRETRYLIMIT", 1}, 
        {(u16 )64842, (char *)"MAXTRANSMITLIFETIME", 1}, 
        {(u16 )64843, (char *)"MAXRECEIVELIFETIME", 1}, 
        {(u16 )64844, (char *)"CFPOLLABLE", 1}, 
        {(u16 )64845, (char *)"AUTHENTICATIONALGORITHMS", 0}, 
        {(u16 )64847, (char *)"PRIVACYOPTIONIMPLEMENTED", 1}, 
        {(u16 )64849, (char *)"DBMCOMMSQUALITY", 0}, 
        {(u16 )64896, (char *)"CURRENTTXRATE1", 1}, 
        {(u16 )64897, (char *)"CURRENTTXRATE2", 1}, 
        {(u16 )64898, (char *)"CURRENTTXRATE3", 1}, 
        {(u16 )64899, (char *)"CURRENTTXRATE4", 1}, 
        {(u16 )64900, (char *)"CURRENTTXRATE5", 1}, 
        {(u16 )64901, (char *)"CURRENTTXRATE6", 1}, 
        {(u16 )64902, (char *)"OWNMACADDR", 2}, 
        {(u16 )64904, (char *)"SCANRESULTSTABLE", 0}, 
        {(u16 )64905, (char *)"HOSTSCANRESULTS", 0}, 
        {(u16 )64906, (char *)"AUTHENTICATIONUSED", 0}, 
        {(u16 )64907, (char *)"CNFFAASWITCHCTRL", 1}, 
        {(u16 )64909, (char *)"ASSOCIATIONFAILURE", 0}, 
        {(u16 )64960, (char *)"PHYTYPE", 1}, 
        {(u16 )64961, (char *)"CURRENTCHANNEL", 1}, 
        {(u16 )64962, (char *)"CURRENTPOWERSTATE", 1}, 
        {(u16 )64963, (char *)"CCAMODE", 1}, 
        {(u16 )64966, (char *)"SUPPORTEDDATARATES", 6}, 
        {(u16 )64967, (char *)"LFO_VOLT_REG_TEST_RES", 0}, 
        {(u16 )65534, (char *)"BUILDSEQ", 0}, 
        {(u16 )65535, (char *)"FWID", 3}};
#line 232 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
static void diag_show_known_rids(char const   *dev ) 
{ 
  char buf___0[1024] ;
  u8 *rid ;
  struct prism2_hostapd_param *param ;
  int res ;
  int i ;
  int j ;
  int k ;
  int len ;
  int slen ;
  struct hfa384x_comp_ident *compid ;
  struct hfa384x_sup_range *range ;
  u16 val ;

  {
  {
#line 241
  printf((char const   */* __restrict  */)"\nKnown RIDs (Resource IDentifiers)\n\n");
#line 243
  param = (struct prism2_hostapd_param *)(buf___0);
#line 245
  i = 0;
  }
  {
#line 245
  while (1) {
    while_continue: /* CIL Label */ ;
#line 245
    if (! ((unsigned long )i < sizeof(rid_table) / sizeof(rid_table[0]))) {
#line 245
      goto while_break;
    }
    {
#line 246
    res = hostapd_get_rid(dev, param, rid_table[i].rid, 0);
    }
#line 247
    if (res == 61) {
#line 248
      goto __Cont;
    }
#line 249
    if (res) {
      {
#line 250
      printf((char const   */* __restrict  */)"Could not read RID %04X (res=%d)\n",
             (int )rid_table[i].rid, res);
      }
#line 252
      goto while_break;
    }
    {
#line 255
    printf((char const   */* __restrict  */)"%04X=%s=", (int )rid_table[i].rid, rid_table[i].name);
#line 256
    rid = param->u.rid.data;
#line 257
    len = (int )param->u.rid.len;
    }
    {
#line 260
    if (rid_table[i].type == 0) {
#line 260
      goto case_0;
    }
#line 266
    if (rid_table[i].type == 1) {
#line 266
      goto case_1;
    }
#line 275
    if (rid_table[i].type == 2) {
#line 275
      goto case_2;
    }
#line 283
    if (rid_table[i].type == 3) {
#line 283
      goto case_3;
    }
#line 296
    if (rid_table[i].type == 4) {
#line 296
      goto case_4;
    }
#line 310
    if (rid_table[i].type == 5) {
#line 310
      goto case_5;
    }
#line 325
    if (rid_table[i].type == 6) {
#line 325
      goto case_6;
    }
#line 334
    if (rid_table[i].type == 7) {
#line 334
      goto case_7;
    }
#line 345
    goto switch_default;
    case_0: /* CIL Label */ 
#line 261
    j = 0;
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      if (! (j < len)) {
#line 261
        goto while_break___0;
      }
      {
#line 262
      printf((char const   */* __restrict  */)"<%02x>", (int )*(rid + j));
#line 261
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 263
    printf((char const   */* __restrict  */)"\n");
    }
#line 264
    goto switch_break;
    case_1: /* CIL Label */ 
#line 267
    if (len != 2) {
      {
#line 268
      printf((char const   */* __restrict  */)"<INVALID RID_WORD LEN %d>\n", len);
      }
    } else {
      {
#line 270
      val = *((u16 *)rid);
#line 271
      printf((char const   */* __restrict  */)"%d\n", (int )val);
      }
    }
#line 273
    goto switch_break;
    case_2: /* CIL Label */ 
#line 276
    if (len != 6) {
      {
#line 277
      printf((char const   */* __restrict  */)"<INVALID RID_HWADDR LEN %d>\n", len);
      }
    } else {
      {
#line 279
      printf((char const   */* __restrict  */)"%02x:%02x:%02x:%02x:%02x:%02x\n", (int )*(rid + 0),
             (int )*(rid + 1), (int )*(rid + 2), (int )*(rid + 3), (int )*(rid + 4),
             (int )*(rid + 5));
      }
    }
#line 281
    goto switch_break;
    case_3: /* CIL Label */ 
#line 284
    slen = (int )*((u16 *)rid);
#line 285
    if (slen > len) {
#line 286
      slen = len;
    }
#line 287
    j = 2;
    {
#line 287
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 287
      if (! (j < slen + 2)) {
#line 287
        goto while_break___1;
      }
#line 288
      if ((int )*(rid + j) >= 32) {
#line 288
        if ((int )*(rid + j) < 127) {
          {
#line 289
          printf((char const   */* __restrict  */)"%c", (int )*(rid + j));
          }
        } else {
          {
#line 291
          printf((char const   */* __restrict  */)"<%02x>", (int )*(rid + j));
          }
        }
      } else {
        {
#line 291
        printf((char const   */* __restrict  */)"<%02x>", (int )*(rid + j));
        }
      }
#line 287
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 293
    printf((char const   */* __restrict  */)"\n");
    }
#line 294
    goto switch_break;
    case_4: /* CIL Label */ 
#line 297
    if ((unsigned long )len != sizeof(*compid)) {
      {
#line 298
      printf((char const   */* __restrict  */)"<INVALID RID_COMPID LEN %d>\n", len);
      }
#line 300
      goto switch_break;
    }
    {
#line 302
    compid = (struct hfa384x_comp_ident *)rid;
#line 303
    printf((char const   */* __restrict  */)"0x%02x v%d.%d.%d\n", (int )compid->id,
           (int )compid->major, (int )compid->minor, (int )compid->variant);
    }
#line 308
    goto switch_break;
    case_5: /* CIL Label */ 
#line 311
    if ((unsigned long )len != sizeof(*range)) {
      {
#line 312
      printf((char const   */* __restrict  */)"<INVALID RID_SUPRANGE LEN %d>\n", len);
      }
#line 314
      goto switch_break;
    }
    {
#line 316
    range = (struct hfa384x_sup_range *)rid;
#line 317
    printf((char const   */* __restrict  */)"%d 0x%02x %d %d-%d\n", (int )range->role,
           (int )range->id, (int )range->variant, (int )range->bottom, (int )range->top);
    }
#line 323
    goto switch_break;
    case_6: /* CIL Label */ 
#line 326
    slen = (int )*((u16 *)rid);
#line 327
    if (slen > len) {
#line 328
      slen = len;
    }
#line 329
    j = 2;
    {
#line 329
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 329
      if (! (j < slen + 2)) {
#line 329
        goto while_break___2;
      }
      {
#line 330
      printf((char const   */* __restrict  */)"<%02x>", (int )*(rid + j));
#line 329
      j ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 331
    printf((char const   */* __restrict  */)"\n");
    }
#line 332
    goto switch_break;
    case_7: /* CIL Label */ 
#line 335
    k = len;
    {
#line 336
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 336
      if (k > 0) {
#line 336
        if (! ((int )*(rid + (k - 1)) == 255)) {
#line 336
          goto while_break___3;
        }
      } else {
#line 336
        goto while_break___3;
      }
#line 337
      k --;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 338
    j = 0;
    {
#line 338
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 338
      if (! (j < k)) {
#line 338
        goto while_break___4;
      }
      {
#line 339
      printf((char const   */* __restrict  */)"<%02x>", (int )*(rid + j));
#line 338
      j ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 340
    if (k != len) {
      {
#line 341
      printf((char const   */* __restrict  */)" + %d*<ff>", len - k);
      }
    }
    {
#line 342
    printf((char const   */* __restrict  */)"\n");
    }
#line 343
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 346
    printf((char const   */* __restrict  */)"<UNKNOWN TYPE %d>\n", rid_table[i].type);
    }
#line 347
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 245
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return;
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
static void diag_show_unknown_rids(char const   *dev ) 
{ 
  char buf___0[1024] ;
  struct prism2_hostapd_param *param ;
  int res ;
  int j ;
  u16 rid ;
  int pos ;
  int rid_entries ;

  {
  {
#line 361
  printf((char const   */* __restrict  */)"\nUnknown RIDs (Resource IDentifiers)\n\n");
#line 363
  param = (struct prism2_hostapd_param *)(buf___0);
#line 365
  pos = 0;
#line 366
  rid_entries = (int )(sizeof(rid_table) / sizeof(rid_table[0]));
#line 368
  rid = (u16 )64512;
  }
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! ((int )rid <= 65023)) {
#line 368
      goto while_break;
    }
#line 369
    if (pos < rid_entries) {
#line 370
      if ((int )rid_table[pos].rid == (int )rid) {
#line 371
        pos ++;
#line 372
        goto __Cont;
      }
      {
#line 374
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 374
        if (pos < rid_entries) {
#line 374
          if (! ((int )rid_table[pos].rid < (int )rid)) {
#line 374
            goto while_break___0;
          }
        } else {
#line 374
          goto while_break___0;
        }
#line 375
        pos ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 377
    res = hostapd_get_rid(dev, param, rid, 0);
    }
#line 378
    if (res == 61) {
#line 379
      goto __Cont;
    }
#line 380
    if (res) {
      {
#line 381
      printf((char const   */* __restrict  */)"Could not read RID %04X (res=%d)\n",
             (int )rid_table[pos].rid, res);
      }
#line 383
      goto while_break;
    }
    {
#line 386
    printf((char const   */* __restrict  */)"%04X=", (int )rid);
#line 387
    j = 0;
    }
    {
#line 387
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 387
      if (! (j < (int )param->u.rid.len)) {
#line 387
        goto while_break___1;
      }
      {
#line 388
      printf((char const   */* __restrict  */)"<%02x>", (int )param->u.rid.data[j]);
#line 387
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 389
    printf((char const   */* __restrict  */)"\n");
    }
    __Cont: /* CIL Label */ 
#line 368
    rid = (u16 )((int )rid + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  return;
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
__inline static void show_bbp_cr(char const   *dev , int cr , char const   *desc ,
                                 char const   *extra ) 
{ 
  int res ;

  {
  {
#line 398
  res = hostap_ioctl_readmif(dev, cr);
  }
#line 399
  if (res >= 0) {
    {
#line 400
    printf((char const   */* __restrict  */)"CR%d (%s): %d%s\n", cr, desc, res, extra);
    }
  }
#line 401
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
__inline static void show_bbp_cr_signed(char const   *dev , int cr , char const   *desc ,
                                        char const   *extra ) 
{ 
  int res ;

  {
  {
#line 408
  res = hostap_ioctl_readmif(dev, cr);
  }
#line 409
  if (res >= 0) {
    {
#line 410
    printf((char const   */* __restrict  */)"CR%d (%s): %d%s\n", cr, desc, (int )((signed char )res),
           extra);
    }
  }
#line 412
  return;
}
}
#line 415 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
__inline static void show_a_values(char const   *dev ) 
{ 


  {
  {
#line 417
  printf((char const   */* __restrict  */)"    CR50..CR63: \'a\' value\n");
#line 419
  show_bbp_cr(dev, 50, "Test Bus Read", "");
#line 420
  show_bbp_cr(dev, 51, "Noise floorAntA", "");
#line 421
  show_bbp_cr(dev, 52, "Noise floorAntB", "");
#line 422
  show_bbp_cr(dev, 53, "AGC error / I DC Offset", "");
#line 423
  show_bbp_cr(dev, 54, "Unassigned / Q DC Offset", "");
#line 424
  show_bbp_cr(dev, 55, "Unassigned  Multipath Metric", "");
#line 425
  show_bbp_cr(dev, 56, "Unassigned / Multipath Count", "");
#line 426
  show_bbp_cr(dev, 57, "Unassigned / Packet Signal Quality", "");
#line 427
  show_bbp_cr_signed(dev, 58, "TX Power Measurement", "");
#line 428
  show_bbp_cr(dev, 59, "RX Mean Power / Header Signal Quality", "");
  }
#line 429
  return;
}
}
#line 432 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
__inline static void show_b_values(char const   *dev ) 
{ 


  {
  {
#line 434
  printf((char const   */* __restrict  */)"    CR50..CR63: \'b\' value\n");
#line 436
  show_bbp_cr(dev, 50, "Test Bus Read", "");
#line 437
  show_bbp_cr(dev, 51, "Signal Quality Measure Based on Carrier Tracking", "");
#line 439
  show_bbp_cr(dev, 52, "Received Signal Field", "");
#line 440
  show_bbp_cr(dev, 53, "Received Service Field", "");
#line 441
  show_bbp_cr(dev, 54, "Received Length Field, Low", "");
#line 442
  show_bbp_cr(dev, 55, "Received Length Field, High", "");
#line 443
  show_bbp_cr(dev, 56, "Calculated CRC on Received Header, Low", "");
#line 444
  show_bbp_cr(dev, 57, "Calculated CRC on Received Header, High", "");
#line 445
  show_bbp_cr_signed(dev, 58, "TX Power Measurement", "");
#line 446
  show_bbp_cr(dev, 59, "RX Mean Power", "");
  }
#line 447
  return;
}
}
#line 450 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
static void diag_show_bbp(char const   *dev ) 
{ 
  int res ;
  int res2 ;
  int part ;
  int version ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char const   *tmp___7 ;
  char const   *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  char const   *tmp___15 ;
  char const   *tmp___16 ;
  char const   *tmp___17 ;
  char const   *tmp___18 ;
  int tmp___19 ;
  char const   *tmp___20 ;
  char const   *tmp___21 ;
  char const   *tmp___22 ;
  char const   *tmp___23 ;
  char const   *tmp___24 ;
  char const   *tmp___25 ;
  char const   *tmp___26 ;
  char const   *tmp___27 ;
  char const   *tmp___28 ;
  char const   *tmp___29 ;
  char const   *tmp___30 ;
  char const   *tmp___31 ;
  char const   *tmp___32 ;
  char const   *tmp___33 ;
  char const   *tmp___34 ;
  char const   *tmp___35 ;
  char const   *tmp___36 ;
  char const   *tmp___37 ;
  char const   *tmp___38 ;
  char const   *tmp___39 ;
  int tmp___40 ;
  char const   *tmp___41 ;
  char const   *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  char const   *tmp___45 ;
  int val ;

  {
  {
#line 456
  printf((char const   */* __restrict  */)"\nBaseband proccessor (BBP) Configuration Registers\n\n");
#line 458
  res = hostap_ioctl_readmif(dev, 0);
  }
#line 459
  if (res >= 0) {
    {
#line 461
    part = res / 16;
#line 462
    version = res % 16;
#line 463
    printf((char const   */* __restrict  */)"CR0 (Part/Version Code): %d - Part=%d ",
           res, part);
    }
    {
#line 465
    if (part == 1) {
#line 465
      goto case_1;
    }
#line 466
    if (part == 3) {
#line 466
      goto case_3;
    }
#line 467
    if (part == 7) {
#line 467
      goto case_7;
    }
#line 468
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 465
    printf((char const   */* __restrict  */)"(HFA3861B series)");
    }
#line 465
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 466
    printf((char const   */* __restrict  */)"(HFA3863 series)");
    }
#line 466
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 467
    printf((char const   */* __restrict  */)"(HFA3871 series?)");
    }
#line 467
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 468
    printf((char const   */* __restrict  */)"(unknown)");
    }
#line 468
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 470
    printf((char const   */* __restrict  */)" Version=%d ", version);
    }
    {
#line 472
    if (version == 0) {
#line 472
      goto case_0;
    }
#line 473
    if (version == 3) {
#line 473
      goto case_3___0;
    }
#line 474
    if (version == 4) {
#line 474
      goto case_4;
    }
#line 475
    goto switch_default___0;
    case_0: /* CIL Label */ 
    {
#line 472
    printf((char const   */* __restrict  */)"(3863 Version)");
    }
#line 472
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 473
    printf((char const   */* __restrict  */)"(3861B Version)");
    }
#line 473
    goto switch_break___0;
    case_4: /* CIL Label */ 
    {
#line 474
    printf((char const   */* __restrict  */)"(3871 Version?)");
    }
#line 474
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
    {
#line 475
    printf((char const   */* __restrict  */)"(unknown)");
    }
#line 475
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
    {
#line 477
    printf((char const   */* __restrict  */)"\n");
    }
  }
  {
#line 480
  res = hostap_ioctl_readmif(dev, 1);
  }
#line 481
  if (res >= 0) {
    {
#line 482
    printf((char const   */* __restrict  */)"CR1 (I/O Polarity): %d (normal setting 0)\n",
           res);
    }
#line 483
    if (res & (1 << 7)) {
#line 483
      tmp = "Inverted rotation (CW), Invert Q in";
    } else {
#line 483
      tmp = "normal rotation (CCW)";
    }
    {
#line 483
    printf((char const   */* __restrict  */)"    Phase of RX carrier rotation sense: %s\n",
           tmp);
    }
#line 487
    if (res & (1 << 6)) {
#line 487
      tmp___0 = "Inverted rotation (CW), Invert Q out";
    } else {
#line 487
      tmp___0 = "normal rotation (CCW)";
    }
    {
#line 487
    printf((char const   */* __restrict  */)"    Phase of TX carrier rotation sense: %s\n",
           tmp___0);
    }
#line 491
    if (res & (1 << 5)) {
#line 491
      tmp___1 = "Inverted TXCLK";
    } else {
#line 491
      tmp___1 = "NON-Inverted TXCLK";
    }
    {
#line 491
    printf((char const   */* __restrict  */)"    Phase of TX output clock (TXCLK) pin: %s\n",
           tmp___1);
    }
#line 493
    if (res & (1 << 4)) {
#line 493
      tmp___2 = "TX_RDY Active 0";
    } else {
#line 493
      tmp___2 = "TX_RDY Active 1";
    }
    {
#line 493
    printf((char const   */* __restrict  */)"    Active level of the Transmit Ready output: %s\n",
           tmp___2);
    }
#line 495
    if (res & (1 << 3)) {
#line 495
      tmp___3 = "TX_PE Active 0";
    } else {
#line 495
      tmp___3 = "TX_PE Active 1";
    }
    {
#line 495
    printf((char const   */* __restrict  */)"    Active level of the transmit enable input: %s\n",
           tmp___3);
    }
#line 497
    if (res & (1 << 2)) {
#line 497
      tmp___4 = "CCA Active 1";
    } else {
#line 497
      tmp___4 = "CCA Active 0";
    }
    {
#line 497
    printf((char const   */* __restrict  */)"    Active level of the Clear Channel Assessment output: %s\n",
           tmp___4);
    }
#line 500
    if (res & (1 << 1)) {
#line 500
      tmp___5 = "MD_RDY Active 0";
    } else {
#line 500
      tmp___5 = "MD_RDY Active 1";
    }
    {
#line 500
    printf((char const   */* __restrict  */)"    Active level of the MD_RDY output: %s\n",
           tmp___5);
    }
#line 502
    if (res & 1) {
#line 502
      tmp___6 = "Invert Clk";
    } else {
#line 502
      tmp___6 = "Non-Inverted Clk";
    }
    {
#line 502
    printf((char const   */* __restrict  */)"    Phase of the RX_CLK output: %s\n",
           tmp___6);
    }
  }
  {
#line 506
  show_bbp_cr(dev, 2, "I Cover Code", " (nominally 72)");
#line 507
  show_bbp_cr(dev, 3, "Q Cover Code", " (nominally 72)");
#line 508
  show_bbp_cr(dev, 4, "TX Preamble Length", " (IEEE 802.11: 128)");
#line 510
  res = hostap_ioctl_readmif(dev, 5);
  }
#line 511
  if (res >= 0) {
#line 512
    if (res & (1 << 3)) {
#line 512
      tmp___7 = "Short preamble and header mode";
    } else {
#line 512
      tmp___7 = "Normal";
    }
    {
#line 512
    printf((char const   */* __restrict  */)"CR5 (TX Signal Field): %d\n    Preamble mode: %s\n    TX data rate: ",
           res, tmp___7);
    }
    {
#line 518
    if ((res & ((1 << 1) | 1)) == 0) {
#line 518
      goto case_0___0;
    }
#line 521
    if ((res & ((1 << 1) | 1)) == 1) {
#line 521
      goto case_1___0;
    }
#line 524
    if ((res & ((1 << 1) | 1)) == 2) {
#line 524
      goto case_2;
    }
#line 527
    if ((res & ((1 << 1) | 1)) == 3) {
#line 527
      goto case_3___1;
    }
#line 517
    goto switch_break___1;
    case_0___0: /* CIL Label */ 
    {
#line 519
    printf((char const   */* __restrict  */)"00 = DBPSK - 11 chip sequence (1Mbps)\n");
    }
#line 520
    goto switch_break___1;
    case_1___0: /* CIL Label */ 
    {
#line 522
    printf((char const   */* __restrict  */)"01 = DQPSK - 11 chip sequence (2Mbps)\n");
    }
#line 523
    goto switch_break___1;
    case_2: /* CIL Label */ 
    {
#line 525
    printf((char const   */* __restrict  */)"10 = CCK - 8 chip sequence (5.5Mbps)\n");
    }
#line 526
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
    {
#line 528
    printf((char const   */* __restrict  */)"11 = CCK - 8 chip sequence (11Mbps)\n");
    }
#line 529
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  }
  {
#line 533
  show_bbp_cr(dev, 6, "TX Service Field", "");
#line 535
  show_bbp_cr(dev, 7, "TX Length Field, High", "");
#line 536
  show_bbp_cr(dev, 8, "TX Length Field, Low", "");
#line 537
  res = hostap_ioctl_readmif(dev, 7);
#line 538
  res2 = hostap_ioctl_readmif(dev, 8);
  }
#line 539
  if (res >= 0) {
#line 539
    if (res2 >= 0) {
      {
#line 540
      printf((char const   */* __restrict  */)"    TX Length Field: %d usec\n", (res << 8) | res2);
      }
    }
  }
  {
#line 543
  res = hostap_ioctl_readmif(dev, 9);
  }
#line 544
  if (res >= 0) {
    {
#line 545
    printf((char const   */* __restrict  */)"CR9 (TX Configure): %d\n", res);
    }
#line 546
    if (res & (1 << 7)) {
#line 546
      tmp___8 = "15.8";
    } else {
#line 546
      tmp___8 = "19.9";
    }
    {
#line 546
    printf((char const   */* __restrict  */)"    CCA sample mode time: %s usec\n",
           tmp___8);
#line 548
    printf((char const   */* __restrict  */)"    CCA mode: CCA is based ");
    }
    {
#line 550
    if ((res & ((1 << 6) | (1 << 5))) >> 5 == 0) {
#line 550
      goto case_0___1;
    }
#line 551
    if ((res & ((1 << 6) | (1 << 5))) >> 5 == 1) {
#line 551
      goto case_1___1;
    }
#line 552
    if ((res & ((1 << 6) | (1 << 5))) >> 5 == 2) {
#line 552
      goto case_2___0;
    }
#line 553
    if ((res & ((1 << 6) | (1 << 5))) >> 5 == 3) {
#line 553
      goto case_3___2;
    }
#line 549
    goto switch_break___2;
    case_0___1: /* CIL Label */ 
    {
#line 550
    printf((char const   */* __restrict  */)"only on ED\n");
    }
#line 550
    goto switch_break___2;
    case_1___1: /* CIL Label */ 
    {
#line 551
    printf((char const   */* __restrict  */)"on (CS1 OR SQ1/CS2)\n");
    }
#line 551
    goto switch_break___2;
    case_2___0: /* CIL Label */ 
    {
#line 552
    printf((char const   */* __restrict  */)"on (ED AND (CS1 OR SQ1/CS2))\n");
    }
#line 552
    goto switch_break___2;
    case_3___2: /* CIL Label */ 
    {
#line 553
    printf((char const   */* __restrict  */)"on (ED OR (CS1 OR SQ1/CS2))\n");
    }
#line 553
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
#line 555
    if (res & (1 << 4)) {
#line 555
      tmp___9 = "all chips set to 1 for CW carrier";
    } else {
#line 555
      tmp___9 = "Alternating bits for carrier suppression test";
    }
    {
#line 555
    printf((char const   */* __restrict  */)"    TX test modes: %s\n", tmp___9);
    }
#line 558
    if (res & (1 << 3)) {
#line 558
      tmp___10 = "Invoke tests described above";
    } else {
#line 558
      tmp___10 = "normal operation";
    }
    {
#line 558
    printf((char const   */* __restrict  */)"    Enable TX test modes: %s\n", tmp___10);
    }
#line 561
    if (res & (1 << 2)) {
#line 561
      tmp___11 = "high";
    } else {
#line 561
      tmp___11 = "low";
    }
    {
#line 561
    printf((char const   */* __restrict  */)"    Antenna choice for TX: Set AntSel %s\n",
           tmp___11);
    }
#line 563
    if (res & (1 << 1)) {
#line 563
      tmp___12 = "antenna for which last valid header CRC occurred";
    } else {
#line 563
      tmp___12 = "value in choice above";
    }
    {
#line 563
    printf((char const   */* __restrict  */)"    TX Antenna Mode: set AntSel pin to %s\n",
           tmp___12);
    }
  }
  {
#line 568
  res = hostap_ioctl_readmif(dev, 10);
  }
#line 569
  if (res >= 0) {
    {
#line 570
    printf((char const   */* __restrict  */)"CR10 (RX Configure): %d\n", res);
    }
#line 571
    if (res & (1 << 7)) {
#line 571
      tmp___13 = "SQ1 from Barker correlator peaks";
    } else {
#line 571
      tmp___13 = "dot product result";
    }
    {
#line 571
    printf((char const   */* __restrict  */)"    Initial CS2 estimate: Use %s\n",
           tmp___13);
    }
#line 574
    if (res & (1 << 6)) {
#line 574
      tmp___14 = "only on after detect";
    } else {
#line 574
      tmp___14 = "on during acquisition";
    }
    {
#line 574
    printf((char const   */* __restrict  */)"    CIR estimate/Dot product clock control: %s\n",
           tmp___14);
#line 577
    printf((char const   */* __restrict  */)"    SFD Time-out values: ");
    }
    {
#line 579
    if (((res & ((1 << 5) | (1 << 4))) > 4) == 0) {
#line 579
      goto case_0___2;
    }
#line 580
    if (((res & ((1 << 5) | (1 << 4))) > 4) == 1) {
#line 580
      goto case_1___2;
    }
#line 581
    if (((res & ((1 << 5) | (1 << 4))) > 4) == 2) {
#line 581
      goto case_2___1;
    }
#line 582
    if (((res & ((1 << 5) | (1 << 4))) > 4) == 3) {
#line 582
      goto case_3___3;
    }
#line 578
    goto switch_break___3;
    case_0___2: /* CIL Label */ 
    {
#line 579
    printf((char const   */* __restrict  */)"56 usec\n");
    }
#line 579
    goto switch_break___3;
    case_1___2: /* CIL Label */ 
    {
#line 580
    printf((char const   */* __restrict  */)"64 usec\n");
    }
#line 580
    goto switch_break___3;
    case_2___1: /* CIL Label */ 
    {
#line 581
    printf((char const   */* __restrict  */)"128 usec\n");
    }
#line 581
    goto switch_break___3;
    case_3___3: /* CIL Label */ 
    {
#line 582
    printf((char const   */* __restrict  */)"144 usec\n");
    }
#line 582
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 584
    if (res & (1 << 3)) {
#line 584
      tmp___15 = "SFD";
    } else {
#line 584
      tmp___15 = "CRC16";
    }
    {
#line 584
    printf((char const   */* __restrict  */)"    MD_RDY control: After %s\n", tmp___15);
    }
#line 586
    if (res & (1 << 2)) {
#line 586
      tmp___16 = "enabled";
    } else {
#line 586
      tmp___16 = "disabled";
    }
    {
#line 586
    printf((char const   */* __restrict  */)"    Force Frequency Offset Estimating in all antenna diversity timelines: %s\n",
           tmp___16);
    }
#line 589
    if (res & (1 << 1)) {
#line 589
      tmp___17 = "high";
    } else {
#line 589
      tmp___17 = "low";
    }
    {
#line 589
    printf((char const   */* __restrict  */)"    Antenna choice for RX when single antenna acquisition is selected: AntSel pin %s\n",
           tmp___17);
    }
#line 592
    if (res & 1) {
#line 592
      tmp___18 = "single antenna";
    } else {
#line 592
      tmp___18 = "dual antenna for diversity acquisition";
    }
    {
#line 592
    printf((char const   */* __restrict  */)"    Antenna acquire: %s\n", tmp___18);
    }
  }
  {
#line 597
  res = hostap_ioctl_readmif(dev, 11);
  }
#line 598
  if (res >= 0) {
    {
#line 599
    printf((char const   */* __restrict  */)"CR11 (RX/TX Configure): %d\n", res);
    }
#line 600
    if (res & (1 << 7)) {
#line 600
      tmp___19 = 1;
    } else {
#line 600
      tmp___19 = 0;
    }
    {
#line 600
    printf((char const   */* __restrict  */)"    Continuous internal RX 22 and 44 MHZ clocks: %d\n",
           tmp___19);
    }
#line 602
    if (res & (1 << 6)) {
#line 602
      tmp___20 = "AC (external bias network required)";
    } else {
#line 602
      tmp___20 = "DC";
    }
    {
#line 602
    printf((char const   */* __restrict  */)"    A/D input coupling: %s\n", tmp___20);
    }
#line 605
    if (res & (1 << 5)) {
#line 605
      tmp___21 = "Japan";
    } else {
#line 605
      tmp___21 = "US";
    }
    {
#line 605
    printf((char const   */* __restrict  */)"    TX filter / CMF weight select: %s\n",
           tmp___21);
    }
#line 607
    if (res & (1 << 4)) {
#line 607
      tmp___22 = "normal";
    } else {
#line 607
      tmp___22 = "disabled";
    }
    {
#line 607
    printf((char const   */* __restrict  */)"    Ping Pong Differential Encode: %s\n",
           tmp___22);
    }
#line 609
    if (res & (1 << 3)) {
#line 609
      tmp___23 = "Sampled CCA; CCA will update once per slot (20 usec)";
    } else {
#line 609
      tmp___23 = "normal CCA; CCA will immediately respond to changes in ED, CS1, and SQ1";
    }
    {
#line 609
    printf((char const   */* __restrict  */)"    CCA mode: %s\n", tmp___23);
#line 613
    printf((char const   */* __restrict  */)"    Precursor value in CIR estimate: %d\n",
           res & (((1 << 2) | (1 << 1)) | 1));
    }
  }
  {
#line 617
  res = hostap_ioctl_readmif(dev, 12);
  }
#line 618
  if (res >= 0) {
    {
#line 619
    printf((char const   */* __restrict  */)"CR12 (A/D Test Modes 1): %d\n", res);
    }
#line 620
    if (res & (1 << 7)) {
#line 620
      tmp___24 = "clock via SDI pin";
    } else {
#line 620
      tmp___24 = "normal internal clocks";
    }
    {
#line 620
    printf((char const   */* __restrict  */)"    All DAC and A/D clock source control: %s\n",
           tmp___24);
    }
#line 623
    if (res & (1 << 6)) {
#line 623
      tmp___25 = "disable";
    } else {
#line 623
      tmp___25 = "enable";
    }
    {
#line 623
    printf((char const   */* __restrict  */)"    TX DAC clock: %s\n", tmp___25);
    }
#line 625
    if (res & (1 << 5)) {
#line 625
      tmp___26 = "disable";
    } else {
#line 625
      tmp___26 = "enable";
    }
    {
#line 625
    printf((char const   */* __restrict  */)"    RX DAC clock: %s\n", tmp___26);
    }
#line 627
    if (res & (1 << 4)) {
#line 627
      tmp___27 = "disable";
    } else {
#line 627
      tmp___27 = "enable";
    }
    {
#line 627
    printf((char const   */* __restrict  */)"    I DAC clock: %s\n", tmp___27);
    }
#line 629
    if (res & (1 << 3)) {
#line 629
      tmp___28 = "disable";
    } else {
#line 629
      tmp___28 = "enable";
    }
    {
#line 629
    printf((char const   */* __restrict  */)"    Q DAC clock: %s\n", tmp___28);
    }
#line 631
    if (res & (1 << 2)) {
#line 631
      tmp___29 = "disable";
    } else {
#line 631
      tmp___29 = "enable";
    }
    {
#line 631
    printf((char const   */* __restrict  */)"    RF A/D clock: %s\n", tmp___29);
    }
#line 633
    if (res & (1 << 1)) {
#line 633
      tmp___30 = "disable";
    } else {
#line 633
      tmp___30 = "enable";
    }
    {
#line 633
    printf((char const   */* __restrict  */)"    I A/D clock: %s\n", tmp___30);
    }
#line 635
    if (res & 1) {
#line 635
      tmp___31 = "disable";
    } else {
#line 635
      tmp___31 = "enable";
    }
    {
#line 635
    printf((char const   */* __restrict  */)"    Q A/D clock: %s\n", tmp___31);
    }
  }
  {
#line 639
  res = hostap_ioctl_readmif(dev, 13);
  }
#line 640
  if (res >= 0) {
    {
#line 641
    printf((char const   */* __restrict  */)"CR13 (A/D Test Modes 2): %d\n", res);
    }
#line 642
    if (res & (1 << 7)) {
#line 642
      tmp___32 = "enable";
    } else {
#line 642
      tmp___32 = "disable";
    }
    {
#line 642
    printf((char const   */* __restrict  */)"    Standby: %s\n", tmp___32);
    }
#line 644
    if (res & (1 << 6)) {
#line 644
      tmp___33 = "enable";
    } else {
#line 644
      tmp___33 = "disable";
    }
    {
#line 644
    printf((char const   */* __restrict  */)"    SLEEP TX: %s\n", tmp___33);
    }
#line 646
    if (res & (1 << 5)) {
#line 646
      tmp___34 = "enable";
    } else {
#line 646
      tmp___34 = "disable";
    }
    {
#line 646
    printf((char const   */* __restrict  */)"    SLEEP RX: %s\n", tmp___34);
    }
#line 648
    if (res & (1 << 4)) {
#line 648
      tmp___35 = "enable";
    } else {
#line 648
      tmp___35 = "disable";
    }
    {
#line 648
    printf((char const   */* __restrict  */)"    SLEEP IQ: %s\n", tmp___35);
    }
#line 650
    if (res & (1 << 3)) {
#line 650
      tmp___36 = "enable";
    } else {
#line 650
      tmp___36 = "disable";
    }
    {
#line 650
    printf((char const   */* __restrict  */)"    Analog TX Shut_down: %s\n", tmp___36);
    }
#line 652
    if (res & (1 << 2)) {
#line 652
      tmp___37 = "enable";
    } else {
#line 652
      tmp___37 = "disable";
    }
    {
#line 652
    printf((char const   */* __restrict  */)"    Analog RX Shut_down: %s\n", tmp___37);
    }
#line 654
    if (res & (1 << 1)) {
#line 654
      tmp___38 = "enable";
    } else {
#line 654
      tmp___38 = "disable";
    }
    {
#line 654
    printf((char const   */* __restrict  */)"    Analog Standby: %s\n", tmp___38);
    }
#line 656
    if (res & 1) {
#line 656
      tmp___39 = "enable";
    } else {
#line 656
      tmp___39 = "disable";
    }
    {
#line 656
    printf((char const   */* __restrict  */)"    Manual control of mixed signal power down signals (other CR13 bits): %s\n",
           tmp___39);
    }
  }
  {
#line 661
  res = hostap_ioctl_readmif(dev, 14);
  }
#line 662
  if (res >= 0) {
    {
#line 663
    printf((char const   */* __restrict  */)"CR14 (A/D Test Modes 3): %d\n", res);
    }
#line 664
    if (res & (1 << 7)) {
#line 664
      tmp___40 = 1;
    } else {
#line 664
      tmp___40 = 0;
    }
    {
#line 664
    printf((char const   */* __restrict  */)"    DFS - select straight binary output of I/Q and RF A/D converters: %d\n",
           tmp___40);
#line 667
    printf((char const   */* __restrict  */)"    I/Q DAC input control: ");
    }
    {
#line 669
    if ((res & (((1 << 6) | (1 << 5)) | (1 << 4))) >> 4 == 0) {
#line 669
      goto case_0___3;
    }
#line 670
    if ((res & (((1 << 6) | (1 << 5)) | (1 << 4))) >> 4 == 1) {
#line 670
      goto case_1___3;
    }
#line 671
    if ((res & (((1 << 6) | (1 << 5)) | (1 << 4))) >> 4 == 2) {
#line 671
      goto case_2___2;
    }
#line 675
    if ((res & (((1 << 6) | (1 << 5)) | (1 << 4))) >> 4 == 3) {
#line 675
      goto case_3___4;
    }
#line 676
    if ((res & (((1 << 6) | (1 << 5)) | (1 << 4))) >> 4 == 4) {
#line 676
      goto case_4___0;
    }
#line 680
    if ((res & (((1 << 6) | (1 << 5)) | (1 << 4))) >> 4 == 5) {
#line 680
      goto case_5;
    }
#line 686
    if ((res & (((1 << 6) | (1 << 5)) | (1 << 4))) >> 4 == 6) {
#line 686
      goto case_6;
    }
#line 690
    if ((res & (((1 << 6) | (1 << 5)) | (1 << 4))) >> 4 == 7) {
#line 690
      goto case_7___0;
    }
#line 668
    goto switch_break___4;
    case_0___3: /* CIL Label */ 
    {
#line 669
    printf((char const   */* __restrict  */)"normal (TX filter)\n");
    }
#line 669
    goto switch_break___4;
    case_1___3: /* CIL Label */ 
    {
#line 670
    printf((char const   */* __restrict  */)"down converter\n");
    }
#line 670
    goto switch_break___4;
    case_2___2: /* CIL Label */ 
    {
#line 672
    printf((char const   */* __restrict  */)"E/L integrator - upper 6 bits (Q) and AGC error (I)\n");
    }
#line 674
    goto switch_break___4;
    case_3___4: /* CIL Label */ 
    {
#line 675
    printf((char const   */* __restrict  */)"I/Q A/D\'s\n");
    }
#line 675
    goto switch_break___4;
    case_4___0: /* CIL Label */ 
    {
#line 677
    printf((char const   */* __restrict  */)"Bigger picker output - upper 6 bits of FWT_I winner and FWT_Q winner\n");
    }
#line 679
    goto switch_break___4;
    case_5: /* CIL Label */ 
    {
#line 681
    printf((char const   */* __restrict  */)"CMF weights - upper 6 bits of all 16 CMF weights circularly shifted with full scale negative sync pulse interleaved between them\n");
    }
#line 685
    goto switch_break___4;
    case_6: /* CIL Label */ 
    {
#line 687
    printf((char const   */* __restrict  */)"Test Bus pins (5:0) when configured as inputs\n");
    }
#line 689
    goto switch_break___4;
    case_7___0: /* CIL Label */ 
    {
#line 690
    printf((char const   */* __restrict  */)"Barker Correlator/low rate samples\n");
    }
#line 690
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
#line 692
    if (res & (1 << 3)) {
#line 692
      tmp___41 = "enable";
    } else {
#line 692
      tmp___41 = "disable";
    }
    {
#line 692
    printf((char const   */* __restrict  */)"    Enable test bus into RX and TX DAC: %s\n",
           tmp___41);
    }
#line 694
    if (res & (1 << 2)) {
#line 694
      tmp___42 = "enable";
    } else {
#line 694
      tmp___42 = "disable";
    }
    {
#line 694
    printf((char const   */* __restrict  */)"    Enable RF A/D into RX DAC: %s\n",
           tmp___42);
    }
#line 696
    if (res & (1 << 1)) {
#line 696
      tmp___43 = 1;
    } else {
#line 696
      tmp___43 = 0;
    }
    {
#line 696
    printf((char const   */* __restrict  */)"    VRbit1: %d\n", tmp___43);
    }
#line 697
    if (res & 1) {
#line 697
      tmp___44 = 1;
    } else {
#line 697
      tmp___44 = 0;
    }
    {
#line 697
    printf((char const   */* __restrict  */)"    VRbit0: %d\n", tmp___44);
    }
  }
  {
#line 700
  show_bbp_cr(dev, 15, "AGC GainClip", "");
#line 702
  res = hostap_ioctl_readmif(dev, 16);
  }
#line 703
  if (res >= 0) {
    {
#line 704
    printf((char const   */* __restrict  */)"CR16 (AGC Sat Cpints): %d\n", res);
#line 705
    printf((char const   */* __restrict  */)"    AGC mid Sat counts: %d\n", (res & ((((1 << 7) | (1 << 6)) | (1 << 5)) | (1 << 4))) >> 4);
#line 707
    printf((char const   */* __restrict  */)"    AGC low Sat counts: %d\n", res & ((((1 << 3) | (1 << 2)) | (1 << 1)) | 1));
    }
  }
  {
#line 711
  res = hostap_ioctl_readmif(dev, 17);
  }
#line 712
  if (res >= 0) {
    {
#line 713
    printf((char const   */* __restrict  */)"CR17 (AGC Update Control): %d\n", res);
    }
#line 714
    if (res & (1 << 7)) {
#line 714
      tmp___45 = "enable";
    } else {
#line 714
      tmp___45 = "disable";
    }
    {
#line 714
    printf((char const   */* __restrict  */)"    AGC update during CIR injest: %s\n",
           tmp___45);
#line 716
    printf((char const   */* __restrict  */)"    AGC timer count: %d (must be >31)\n",
           res & ((((((1 << 5) | (1 << 4)) | (1 << 3)) | (1 << 2)) | (1 << 1)) | 1));
    }
  }
  {
#line 721
  show_bbp_cr(dev, 18, "AGC HiSat", "");
#line 722
  show_bbp_cr(dev, 19, "AGC LockinLevel/CW detect threshold", "");
#line 723
  show_bbp_cr(dev, 20, "AGC LockWindow, pos side", "");
#line 724
  show_bbp_cr(dev, 21, "AGC Threshold", "");
#line 725
  show_bbp_cr(dev, 22, "AGC Lookup Table Addr and Control", "");
#line 726
  show_bbp_cr(dev, 23, "AGC Lookup Table Data", "");
#line 727
  show_bbp_cr(dev, 24, "AGC LoopGain", "");
#line 728
  show_bbp_cr(dev, 25, "AGC RX_IF", "");
#line 729
  show_bbp_cr(dev, 26, "AGC Test Modes", "");
#line 730
  show_bbp_cr(dev, 27, "AGC RX_RF Threshold", "");
#line 731
  show_bbp_cr(dev, 28, "AGC Low SatAtten", "");
#line 732
  show_bbp_cr(dev, 29, "AGC LockWindow, negative side", "");
#line 733
  show_bbp_cr(dev, 30, "Carrier Sense 2", "");
#line 734
  show_bbp_cr(dev, 31, "Manual TX Power Control", "");
#line 735
  show_bbp_cr(dev, 32, "Test Modes 1", "");
#line 736
  show_bbp_cr(dev, 33, "Test Modes 2", "");
#line 737
  show_bbp_cr(dev, 34, "Test Bus Address", "");
#line 738
  show_bbp_cr(dev, 35, "CMF Coefficient Control", "");
#line 739
  show_bbp_cr(dev, 36, "Scrambler Seed, Long Preamble Option", "");
#line 740
  show_bbp_cr(dev, 37, "Scrambler Seed, Short Preamble Option", "");
#line 741
  show_bbp_cr(dev, 38, "ED Threshold", "");
#line 742
  show_bbp_cr(dev, 39, "CMF Gain Threshold", "");
#line 743
  show_bbp_cr(dev, 40, "Threshold for antenna decision", "");
#line 744
  show_bbp_cr(dev, 41, "Preamble tracking loop lead coefficient", "");
#line 745
  show_bbp_cr(dev, 42, "Preamble tracking loop lag coefficient", "");
#line 746
  show_bbp_cr(dev, 43, "Header tracking loop lead coefficient", "");
#line 747
  show_bbp_cr(dev, 44, "Header tracking loop lag coefficient", "");
#line 748
  show_bbp_cr(dev, 45, "Data tracking loop lead coefficient", "");
#line 749
  show_bbp_cr(dev, 46, "Data tracking loop lag coefficient", "");
#line 750
  show_bbp_cr(dev, 47, "RF attenuator value", "");
#line 751
  show_bbp_cr(dev, 48, "ED and SQ1 control and SQ1 scale factor", "");
#line 753
  res = hostap_ioctl_readmif(dev, 49);
  }
#line 754
  if (res >= 0) {
    {
#line 755
    printf((char const   */* __restrict  */)"CR49 (Read only register mux control for registers 50 to 63): %d\n",
           res);
#line 757
    printf((char const   */* __restrict  */)"    CW RSSI threshold: %d\n", res & 127);
    }
#line 758
    if (res & 128) {
      {
#line 759
      show_a_values(dev);
      }
    } else {
      {
#line 761
      show_b_values(dev);
      }
    }
  }
  {
#line 764
  show_bbp_cr(dev, 60, "RX_IF AGC", "");
#line 766
  res = hostap_ioctl_readmif(dev, 61);
  }
#line 767
  if (res >= 0) {
    {
#line 768
    printf((char const   */* __restrict  */)"CR61 (RX Status Reg): %d\n", res);
    }
#line 769
    if (res & (1 << 4)) {
      {
#line 770
      printf((char const   */* __restrict  */)"    ED, energy detect past threshold\n");
      }
    }
#line 771
    if (res & (1 << 3)) {
      {
#line 772
      printf((char const   */* __restrict  */)"    TX PWR det Register semaphore (CR58 updated since last read)\n");
      }
    }
#line 774
    if (res & (1 << 2)) {
      {
#line 775
      printf((char const   */* __restrict  */)"    AGC_lock (AGC is within limits of lock window CR20)\n");
      }
    }
#line 777
    if (res & (1 << 1)) {
      {
#line 778
      printf((char const   */* __restrict  */)"    hwStopBHit (rails hit, AGC updates stopped)\n");
      }
    }
#line 780
    if (res & 1) {
      {
#line 781
      printf((char const   */* __restrict  */)"    RX_RF_AGC - status of AGC output to RF chip\n");
      }
    }
  }
  {
#line 786
  show_bbp_cr(dev, 62, "RSSI", "");
#line 788
  res = hostap_ioctl_readmif(dev, 63);
  }
#line 789
  if (res >= 0) {
    {
#line 791
    printf((char const   */* __restrict  */)"CR63 (RX Status Reg): %d\n", res);
#line 792
    val = (res & ((1 << 7) | (1 << 6))) >> 6;
#line 793
    printf((char const   */* __restrict  */)"    Signal field value: ");
    }
    {
#line 795
    if (val == 0) {
#line 795
      goto case_0___4;
    }
#line 796
    if (val == 1) {
#line 796
      goto case_1___4;
    }
#line 797
    if (val == 2) {
#line 797
      goto case_2___3;
    }
#line 798
    if (val == 3) {
#line 798
      goto case_3___5;
    }
#line 794
    goto switch_break___5;
    case_0___4: /* CIL Label */ 
    {
#line 795
    printf((char const   */* __restrict  */)"1 M\n");
    }
#line 795
    goto switch_break___5;
    case_1___4: /* CIL Label */ 
    {
#line 796
    printf((char const   */* __restrict  */)"2 M\n");
    }
#line 796
    goto switch_break___5;
    case_2___3: /* CIL Label */ 
    {
#line 797
    printf((char const   */* __restrict  */)"5.5 M\n");
    }
#line 797
    goto switch_break___5;
    case_3___5: /* CIL Label */ 
    {
#line 798
    printf((char const   */* __restrict  */)"11 M\n");
    }
#line 798
    goto switch_break___5;
    switch_break___5: /* CIL Label */ ;
    }
#line 800
    if (res & (1 << 5)) {
      {
#line 801
      printf((char const   */* __restrict  */)"    SFD found\n");
      }
    }
#line 802
    if (res & (1 << 4)) {
      {
#line 803
      printf((char const   */* __restrict  */)"    Short preamble detected\n");
      }
    }
#line 804
    if (res & (1 << 3)) {
      {
#line 805
      printf((char const   */* __restrict  */)"    Valid signal field found\n");
      }
    }
#line 806
    if (res & (1 << 2)) {
      {
#line 807
      printf((char const   */* __restrict  */)"    Valid CRC 16\n");
      }
    }
#line 808
    if (res & (1 << 1)) {
      {
#line 809
      printf((char const   */* __restrict  */)"    Antenna selected by received when last valid header CRC occurred\n");
      }
    }
#line 811
    if (res & 1) {
      {
#line 812
      printf((char const   */* __restrict  */)"    not used\n");
      }
    }
  }
#line 814
  return;
}
}
#line 817 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
static void diag_show_pda(char const   *dev ) 
{ 
  char fname[256] ;
  struct prism2_pda pda ;
  int i ;
  int j ;
  int tmp ;
  char const   *tmp___0 ;

  {
  {
#line 823
  printf((char const   */* __restrict  */)"\nProduction Data Area (PDA)\n\n");
#line 825
  snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/proc/net/hostap/%s/pda",
           dev);
#line 826
  tmp = read_wlan_pda((char const   *)(fname), & pda);
  }
#line 826
  if (tmp) {
    {
#line 827
    printf((char const   */* __restrict  */)"Could not read wlan PDA. This requires PRISM2_DOWNLOAD_SUPPORT definition for the kernel driver.\n");
    }
#line 830
    return;
  }
#line 833
  i = 0;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! (i < pda.pdr_count)) {
#line 833
      goto while_break;
    }
    {
#line 834
    tmp___0 = prism2_pdr_name((int )(pda.pdrs + i)->pdr);
#line 834
    printf((char const   */* __restrict  */)"PDR 0x%04x len=%i %s\n  ", (pda.pdrs + i)->pdr,
           (pda.pdrs + i)->len, tmp___0);
#line 837
    j = 0;
    }
    {
#line 837
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 837
      if (! ((unsigned int )j < (pda.pdrs + i)->len)) {
#line 837
        goto while_break___0;
      }
      {
#line 838
      printf((char const   */* __restrict  */)" %02x", (int )*((pda.pdrs + i)->data + j));
#line 837
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 839
    printf((char const   */* __restrict  */)"\n");
#line 833
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 842
  free((void *)pda.pdrs);
  }
#line 843
  return;
}
}
#line 846 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_diag.c"
static void usage___1(void) 
{ 


  {
  {
#line 848
  printf((char const   */* __restrict  */)"Usage: hostap_diag [-abhpru] <device>\nOptions:\n  -h      show this usage info\n  -a      show all info\n  -b      show baseband processor control registers\n  -p      show production data area (PDA)\n  -r      show known RIDs\n  -u      show unknown RIDs\n");
#line 857
  exit(1);
  }
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
__inline static int hex2int(char c ) 
{ 


  {
#line 30
  if ((int )c >= 48) {
#line 30
    if ((int )c <= 57) {
#line 31
      return ((int )c - 48);
    }
  }
#line 32
  if ((int )c >= 97) {
#line 32
    if ((int )c <= 102) {
#line 33
      return (((int )c - 97) + 10);
    }
  }
#line 34
  if ((int )c >= 65) {
#line 34
    if ((int )c <= 70) {
#line 35
      return (((int )c - 65) + 10);
    }
  }
#line 36
  return (-1);
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
static int macstr2addr(char const   *macstr , u8 *addr ) 
{ 
  int i ;
  int val ;
  int val2 ;
  char const   *pos ;
  char const   *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
#line 43
  pos = macstr;
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue: /* CIL Label */ ;
#line 45
    if (! (i < 6)) {
#line 45
      goto while_break;
    }
    {
#line 46
    tmp = pos;
#line 46
    pos ++;
#line 46
    val = hex2int((char )*tmp);
    }
#line 47
    if (val < 0) {
#line 48
      return (-1);
    }
    {
#line 49
    tmp___0 = pos;
#line 49
    pos ++;
#line 49
    val2 = hex2int((char )*tmp___0);
    }
#line 50
    if (val2 < 0) {
#line 51
      return (-1);
    }
#line 52
    *(addr + i) = (u8 )((val * 16 + val2) & 255);
#line 54
    if (i < 5) {
#line 54
      tmp___1 = pos;
#line 54
      pos ++;
#line 54
      if ((int const   )*tmp___1 != 58) {
#line 55
        return (-1);
      }
    }
#line 45
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  if ((int const   )*pos != 0) {
#line 59
    return (-1);
  }
#line 61
  return (0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
static void usage___2(void) 
{ 


  {
  {
#line 67
  printf((char const   */* __restrict  */)"Usage: hostap_crypt_conf [-123456789tpl] <device> [addr] [alg] [key]\nOptions:\n  -1 .. -9   key index (for WEP); only one index per command\n  -t         set TX key index (given with -1 .. -9)\n  -p         permanent station configuration (do not expire data)\n  -l         list configured keys (do not use addr or alg)\n  device     wlan#\n  addr       station hwaddr or ff:ff:ff:ff:ff:ff for default/broadcast key\n  alg        crypt algorithm (WEP, NULL, none)\n  key        key data (in hex, e.g. \'0011223344\', or s:string)\n\nAlgorithms:\n  WEP        40 or 104 bit WEP\n  NULL       NULL encryption (i.e., do not encrypt/decrypt);\n             used to configure no encryption for given\n             station when using default encryption\n  none       disable encryption\n");
#line 88
  exit(1);
  }
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
static void parse_key_string(struct prism2_hostapd_param *param , char const   *key ) 
{ 
  size_t tmp ;

  {
  {
#line 95
  tmp = strlen(key);
#line 95
  param->u.crypt.key_len = (u16 )tmp;
  }
#line 96
  if ((unsigned long )param->u.crypt.key_len > 1024UL - sizeof(*param)) {
    {
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too long key.\n");
#line 98
    exit(1);
    }
  }
  {
#line 101
  memcpy((void */* __restrict  */)(param->u.crypt.key), (void const   */* __restrict  */)key,
         (size_t )param->u.crypt.key_len);
  }
#line 102
  return;
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
static void parse_key_hex(struct prism2_hostapd_param *param , char const   *key ) 
{ 
  int len ;
  size_t tmp ;
  char const   *ipos ;
  char *opos ;
  int val1 ;
  int val2 ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 108
  tmp = strlen(key);
#line 108
  len = (int )tmp;
  }
#line 112
  if (len & 1) {
    {
#line 113
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid hex string \'%s\' (odd length)\n",
            key);
#line 114
    exit(1);
    }
  }
#line 116
  param->u.crypt.key_len = (u16 )(len / 2);
#line 117
  if ((unsigned long )param->u.crypt.key_len > 1024UL - sizeof(*param)) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too long key.\n");
#line 119
    exit(1);
    }
  }
#line 122
  ipos = key;
#line 123
  opos = (char *)(param->u.crypt.key);
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
#line 124
    if (! (len > 0)) {
#line 124
      goto while_break;
    }
    {
#line 126
    tmp___0 = ipos;
#line 126
    ipos ++;
#line 126
    val1 = hex2int((char )*tmp___0);
#line 127
    tmp___1 = ipos;
#line 127
    ipos ++;
#line 127
    val2 = hex2int((char )*tmp___1);
    }
#line 128
    if (val1 < 0) {
      {
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid hex string \'%s\' (could not parse \'%c%c\')\n",
              key, (int const   )*(ipos - 2), (int const   )*(ipos - 1));
#line 132
      exit(1);
      }
    } else
#line 128
    if (val2 < 0) {
      {
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Invalid hex string \'%s\' (could not parse \'%c%c\')\n",
              key, (int const   )*(ipos - 2), (int const   )*(ipos - 1));
#line 132
      exit(1);
      }
    }
#line 134
    tmp___2 = opos;
#line 134
    opos ++;
#line 134
    *tmp___2 = (char )((val1 << 4) + val2);
#line 135
    len -= 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
static void show_error(struct prism2_hostapd_param *param ) 
{ 


  {
  {
#line 143
  if (param->u.crypt.err == 2U) {
#line 143
    goto case_2;
  }
#line 150
  if (param->u.crypt.err == 3U) {
#line 150
    goto case_3;
  }
#line 157
  if (param->u.crypt.err == 4U) {
#line 157
    goto case_4;
  }
#line 160
  if (param->u.crypt.err == 5U) {
#line 160
    goto case_5;
  }
#line 163
  if (param->u.crypt.err == 6U) {
#line 163
    goto case_6;
  }
#line 166
  if (param->u.crypt.err == 7U) {
#line 166
    goto case_7;
  }
#line 142
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 144
  printf((char const   */* __restrict  */)"Unknown algorithm \'%s\'.\nYou may need to load kernel module to register that algorithm.\nE.g., \'modprobe hostap_crypt_wep\' for WEP.\n",
         param->u.crypt.alg);
  }
#line 149
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 151
  printf((char const   */* __restrict  */)"Unknown address %02x:%02x:%02x:%02x:%02x:%02x.\n",
         (int )param->sta_addr[0], (int )param->sta_addr[1], (int )param->sta_addr[2],
         (int )param->sta_addr[3], (int )param->sta_addr[4], (int )param->sta_addr[5]);
  }
#line 153
  if (! (param->u.crypt.flags & (unsigned int )(1 << 1))) {
    {
#line 154
    printf((char const   */* __restrict  */)"You can use -p flag to add permanent entry for not yet associated station.\n");
    }
  }
#line 156
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 158
  printf((char const   */* __restrict  */)"Crypt algorithm initialization failed.\n");
  }
#line 159
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 161
  printf((char const   */* __restrict  */)"Key setting failed.\n");
  }
#line 162
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 164
  printf((char const   */* __restrict  */)"TX key index setting failed.\n");
  }
#line 165
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 167
  printf((char const   */* __restrict  */)"Card configuration failed.\n");
  }
#line 168
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 170
  return;
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
static int do_ioctl(char const   *dev , struct prism2_hostapd_param *param , int show_err ) 
{ 
  int s ;
  struct iwreq iwr ;
  int tmp ;

  {
  {
#line 179
  s = socket(2, 2, 0);
  }
#line 180
  if (s < 0) {
    {
#line 181
    perror("socket");
    }
#line 182
    return (-1);
  }
  {
#line 185
  memset((void *)(& iwr), 0, sizeof(iwr));
#line 186
  strncpy((char */* __restrict  */)(iwr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)dev,
          (size_t )16);
#line 187
  iwr.u.data.pointer = (void *)((caddr_t )param);
#line 188
  iwr.u.data.length = (__u16 )((int )((char *)(param->u.crypt.key) - (char *)param) + (int )param->u.crypt.key_len);
#line 192
  tmp = ioctl(s, 35326UL, & iwr);
  }
#line 192
  if (tmp < 0) {
#line 193
    if (show_err) {
      {
#line 194
      perror("ioctl[PRISM2_IOCTL_HOSTAPD]");
#line 195
      show_error(param);
      }
    }
#line 197
    return (-1);
  }
#line 200
  return (0);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
static int show_key(char const   *dev , char *addr , int forced_show ) 
{ 
  char buf___0[1024] ;
  struct prism2_hostapd_param *param ;
  int idx ;
  int i ;
  int max_key_len ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 210
  max_key_len = (int )(sizeof(buf___0) - (unsigned long )((int )((char *)(param->u.crypt.key) - (char *)param)));
#line 213
  memset((void *)(buf___0), 0, sizeof(buf___0));
#line 214
  param = (struct prism2_hostapd_param *)(buf___0);
#line 215
  param->cmd = (u32 )7;
#line 217
  tmp = macstr2addr((char const   *)addr, param->sta_addr);
  }
#line 217
  if (tmp) {
#line 218
    return (-1);
  }
  {
#line 219
  param->u.crypt.idx = (u8 )255;
#line 220
  param->u.crypt.key_len = (u16 )max_key_len;
#line 221
  tmp___0 = do_ioctl(dev, param, forced_show);
  }
#line 221
  if (tmp___0) {
#line 222
    return (-1);
  }
#line 224
  if (! forced_show) {
    {
#line 224
    tmp___1 = strcmp((char const   *)(param->u.crypt.alg), "none");
    }
#line 224
    if (tmp___1 == 0) {
#line 225
      return (0);
    }
  }
  {
#line 227
  tmp___2 = strcmp((char const   *)addr, "ff:ff:ff:ff:ff:ff");
  }
#line 227
  if (tmp___2 == 0) {
    {
#line 228
    printf((char const   */* __restrict  */)"Default keys\n");
    }
  } else {
    {
#line 230
    printf((char const   */* __restrict  */)"\nKeys for %s\n", addr);
    }
  }
  {
#line 231
  printf((char const   */* __restrict  */)"  algorithm: %s\n", param->u.crypt.alg);
#line 232
  tmp___3 = strcmp((char const   *)(param->u.crypt.alg), "none");
  }
#line 232
  if (tmp___3 == 0) {
#line 233
    return (0);
  }
#line 235
  if ((int )param->u.crypt.idx != 255) {
    {
#line 236
    printf((char const   */* __restrict  */)"  TX key idx: %d\n", (int )param->u.crypt.idx + 1);
    }
  }
#line 238
  idx = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (idx < 4)) {
#line 238
      goto while_break;
    }
    {
#line 239
    param->u.crypt.idx = (u8 )idx;
#line 240
    param->u.crypt.key_len = (u16 )max_key_len;
#line 241
    tmp___4 = do_ioctl(dev, param, forced_show);
    }
#line 241
    if (tmp___4 == 0) {
      {
#line 242
      printf((char const   */* __restrict  */)"  key %d:", idx + 1);
      }
#line 243
      if ((int )param->u.crypt.key_len > max_key_len) {
        {
#line 244
        printf((char const   */* __restrict  */)" invalid key_len %d", (int )param->u.crypt.key_len);
        }
      } else {
#line 247
        i = 0;
        {
#line 247
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 247
          if (! (i < (int )param->u.crypt.key_len)) {
#line 247
            goto while_break___0;
          }
          {
#line 248
          printf((char const   */* __restrict  */)" %02x", (int )param->u.crypt.key[i]);
#line 247
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 249
      printf((char const   */* __restrict  */)"\n");
      }
    }
#line 238
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_crypt_conf.c"
static int show_key_list(char const   *dev ) 
{ 
  char dirname[128] ;
  DIR *procdir ;
  struct dirent *entry ;
  int tmp ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 262
  tmp = show_key(dev, (char *)"ff:ff:ff:ff:ff:ff", 1);
  }
#line 262
  if (tmp) {
#line 263
    return (-1);
  }
  {
#line 265
  snprintf((char */* __restrict  */)(dirname), sizeof(dirname), (char const   */* __restrict  */)"/proc/net/hostap/%s",
           dev);
#line 266
  procdir = opendir((char const   *)(dirname));
  }
#line 267
  if (! procdir) {
    {
#line 268
    printf((char const   */* __restrict  */)"Could not open directory \'%s\'\n", dirname);
#line 269
    perror("opendir");
    }
#line 270
    return (-1);
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 273
    entry = readdir(procdir);
    }
#line 273
    if (! ((unsigned long )entry != (unsigned long )((void *)0))) {
#line 273
      goto while_break;
    }
    {
#line 274
    tmp___0 = strlen((char const   *)(entry->d_name));
    }
#line 274
    if (tmp___0 == 17UL) {
#line 274
      if ((int )entry->d_name[2] == 58) {
        {
#line 275
        show_key(dev, entry->d_name, 0);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 278
  tmp___1 = closedir(procdir);
  }
#line 278
  if (tmp___1) {
    {
#line 279
    perror("closedir");
    }
  }
#line 281
  return (0);
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_io_debug.c"
static struct reg_info prism2_pccard_regs[29]  = 
#line 106 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_io_debug.c"
  {      {0, (char *)"CMD"}, 
        {2, (char *)"PARAM0"}, 
        {4, (char *)"PARAM1"}, 
        {6, (char *)"PARAM2"}, 
        {8, (char *)"STATUS"}, 
        {10, (char *)"RESP0"}, 
        {12, (char *)"RESP1"}, 
        {14, (char *)"RESP2"}, 
        {16, (char *)"INFOFID"}, 
        {20, (char *)"CONTROL"}, 
        {24, (char *)"SELECT0"}, 
        {26, (char *)"SELECT1"}, 
        {28, (char *)"OFFSET0"}, 
        {30, (char *)"OFFSET1"}, 
        {32, (char *)"RXFID"}, 
        {34, (char *)"ALLOCFID"}, 
        {36, (char *)"TXCOMPLFID"}, 
        {40, (char *)"SWSUPPORT0"}, 
        {42, (char *)"SWSUPPORT1"}, 
        {44, (char *)"SWSUPPORT2"}, 
        {48, (char *)"EVSTAT"}, 
        {50, (char *)"INTEN"}, 
        {52, (char *)"EVACK"}, 
        {54, (char *)"DATA0"}, 
        {56, (char *)"DATA1"}, 
        {58, (char *)"AUXPAGE"}, 
        {60, (char *)"AUXOFFSET"}, 
        {62, (char *)"AUXDATA"}, 
        {0, (char *)((void *)0)}};
#line 139 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_io_debug.c"
static struct reg_info prism2_pci_regs[29]  = 
#line 139
  {      {0, (char *)"CMD"}, 
        {4, (char *)"PARAM0"}, 
        {8, (char *)"PARAM1"}, 
        {12, (char *)"PARAM2"}, 
        {16, (char *)"STATUS"}, 
        {20, (char *)"RESP0"}, 
        {24, (char *)"RESP1"}, 
        {28, (char *)"RESP2"}, 
        {32, (char *)"INFOFID"}, 
        {40, (char *)"CONTROL"}, 
        {48, (char *)"SELECT0"}, 
        {52, (char *)"SELECT1"}, 
        {56, (char *)"OFFSET0"}, 
        {60, (char *)"OFFSET1"}, 
        {64, (char *)"RXFID"}, 
        {68, (char *)"ALLOCFID"}, 
        {72, (char *)"TXCOMPLFID"}, 
        {80, (char *)"SWSUPPORT0"}, 
        {84, (char *)"SWSUPPORT1"}, 
        {88, (char *)"SWSUPPORT2"}, 
        {96, (char *)"EVSTAT"}, 
        {100, (char *)"INTEN"}, 
        {104, (char *)"EVACK"}, 
        {108, (char *)"DATA0"}, 
        {112, (char *)"DATA1"}, 
        {116, (char *)"AUXPAGE"}, 
        {120, (char *)"AUXOFFSET"}, 
        {124, (char *)"AUXDATA"}, 
        {0, (char *)((void *)0)}};
#line 172 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_io_debug.c"
static struct reg_info *prism2_regs  =    prism2_pccard_regs;
#line 175 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_io_debug.c"
static char const   *cmd_str(int cmd ) 
{ 


  {
  {
#line 178
  if (cmd == 0) {
#line 178
    goto case_0;
  }
#line 179
  if (cmd == 1) {
#line 179
    goto case_1;
  }
#line 180
  if (cmd == 2) {
#line 180
    goto case_2;
  }
#line 181
  if (cmd == 3) {
#line 181
    goto case_3;
  }
#line 182
  if (cmd == 4) {
#line 182
    goto case_4;
  }
#line 183
  if (cmd == 5) {
#line 183
    goto case_5;
  }
#line 184
  if (cmd == 6) {
#line 184
    goto case_6;
  }
#line 185
  if (cmd == 7) {
#line 185
    goto case_7;
  }
#line 186
  goto switch_default;
  case_0: /* CIL Label */ 
#line 178
  return ("INB");
  case_1: /* CIL Label */ 
#line 179
  return ("INW");
  case_2: /* CIL Label */ 
#line 180
  return ("INSW");
  case_3: /* CIL Label */ 
#line 181
  return ("OUTB");
  case_4: /* CIL Label */ 
#line 182
  return ("OUTW");
  case_5: /* CIL Label */ 
#line 183
  return ("OUTSW");
  case_6: /* CIL Label */ 
#line 184
  return ("ERROR");
  case_7: /* CIL Label */ 
#line 185
  return ("INTERRUPT");
  switch_default: /* CIL Label */ 
#line 186
  return ("??");
  switch_break: /* CIL Label */ ;
  }
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_io_debug.c"
static char buf[32]  ;
#line 191 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/hostap_io_debug.c"
static char const   *addr_str(int cmd , int addr ) 
{ 
  struct reg_info *reg ;

  {
#line 194
  reg = prism2_regs;
#line 196
  if (cmd == 6) {
#line 197
    return ("");
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! reg->name) {
#line 199
      goto while_break;
    }
#line 200
    if (reg->reg == addr) {
#line 201
      return ((char const   *)reg->name);
    }
#line 202
    reg ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 205
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%d",
           addr);
  }
#line 206
  return ((char const   *)(buf));
}
}
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 26 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int verbose  =    0;
#line 27 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int ignore_incompatible_interface  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int skip_pda_read  =    0;
#line 112 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int s3_comp(void const   *a , void const   *b ) 
{ 
  struct s3_record  const  *aa ;
  struct s3_record  const  *bb ;

  {
#line 114
  aa = (struct s3_record  const  *)a;
#line 114
  bb = (struct s3_record  const  *)b;
#line 116
  return ((int )(aa->addr - bb->addr));
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int hex2int___0(char c ) 
{ 


  {
#line 121
  if ((int )c >= 48) {
#line 121
    if ((int )c <= 57) {
#line 122
      return ((int )c - 48);
    }
  }
#line 123
  if ((int )c >= 97) {
#line 123
    if ((int )c <= 102) {
#line 124
      return (((int )c - 97) + 10);
    }
  }
#line 125
  if ((int )c >= 65) {
#line 125
    if ((int )c <= 70) {
#line 126
      return (((int )c - 65) + 10);
    }
  }
  {
#line 128
  printf((char const   */* __restrict  */)"{hex2int failure \'%c\'}", (int )c);
  }
#line 129
  return (-1);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int get_hex8(char *txt ) 
{ 
  int val ;
  int val2 ;

  {
  {
#line 136
  val = hex2int___0(*(txt + 0));
#line 137
  val2 = hex2int___0(*(txt + 1));
  }
#line 138
  if (val < 0) {
#line 139
    return (-1);
  } else
#line 138
  if (val2 < 0) {
#line 139
    return (-1);
  }
#line 141
  return ((val * 16 + val2) & 255);
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
unsigned int get_hex16_le(char *txt ) 
{ 
  unsigned int val ;
  int i ;
  int tmp ;

  {
#line 146
  val = 0U;
#line 148
  i = 1;
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
#line 148
    if (! (i >= 0)) {
#line 148
      goto while_break;
    }
    {
#line 149
    tmp = get_hex8(txt + i * 2);
#line 149
    val = (val << 8) | (unsigned int )tmp;
#line 148
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return (val);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
unsigned int get_hex32(char *txt ) 
{ 
  unsigned int val ;
  int i ;
  int tmp ;

  {
#line 155
  val = 0U;
#line 157
  i = 0;
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
#line 157
    if (! (i < 4)) {
#line 157
      goto while_break;
    }
    {
#line 158
    tmp = get_hex8(txt + i * 2);
#line 158
    val = (val << 8) | (unsigned int )tmp;
#line 157
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return (val);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
unsigned int get_hex32_le(char *txt ) 
{ 
  unsigned int val ;
  int i ;
  int tmp ;

  {
#line 164
  val = 0U;
#line 166
  i = 3;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 166
    if (! (i >= 0)) {
#line 166
      goto while_break;
    }
    {
#line 167
    tmp = get_hex8(txt + i * 2);
#line 167
    val = (val << 8) | (unsigned int )tmp;
#line 166
    i --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return (val);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int verify_checksum(char *data , int len ) 
{ 
  int i ;
  unsigned char c ;
  unsigned char c2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 177
  c = (unsigned char)0;
#line 178
  i = 0;
  {
#line 178
  while (1) {
    while_continue: /* CIL Label */ ;
#line 178
    if (! (i < len)) {
#line 178
      goto while_break;
    }
    {
#line 179
    tmp = get_hex8(data + i * 2);
#line 179
    c = (unsigned char )((int )c + tmp);
#line 178
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 180
  c = (unsigned char )(255 - (int )c);
#line 181
  tmp___0 = get_hex8(data + len * 2);
#line 181
  c2 = (unsigned char )tmp___0;
  }
#line 182
  if ((int )c != (int )c2) {
#line 183
    return (1);
  }
#line 185
  return (0);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void enlarge_s3_buf(struct srec_data *srec ) 
{ 
  void *tmp ;

  {
  {
#line 190
  tmp = realloc((void *)srec->s3_records, (unsigned long )(2 * srec->s3_entries) * sizeof(struct s3_record ));
#line 190
  srec->s3_records = (struct s3_record *)tmp;
  }
#line 193
  if ((unsigned long )srec->s3_records == (unsigned long )((void *)0)) {
    {
#line 194
    printf((char const   */* __restrict  */)"Could not allocate memory for S3 records.\n");
#line 195
    exit(1);
    }
  }
  {
#line 197
  memset((void *)(srec->s3_records + srec->s3_entries), 0, (unsigned long )srec->s3_entries * sizeof(struct s3_record ));
#line 199
  srec->s3_entries *= 2;
  }
#line 200
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int s3_combine(struct srec_data *srec ) 
{ 
  int from ;
  int to ;
  int removed ;
  struct s3_record *_to ;
  struct s3_record *_to_1 ;
  struct s3_record *_from ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 206
  removed = 0;
#line 206
  to = removed;
#line 206
  from = to;
  {
#line 207
  while (1) {
    while_continue: /* CIL Label */ ;
#line 207
    if (! (from < srec->s3_used)) {
#line 207
      goto while_break;
    }
#line 209
    _to = srec->s3_records + to;
#line 210
    if (to > 0) {
#line 210
      _to_1 = srec->s3_records + (to - 1);
    } else {
#line 210
      _to_1 = (struct s3_record *)((void *)0);
    }
#line 211
    _from = srec->s3_records + from;
#line 213
    if (_from->len == 0) {
#line 214
      removed ++;
#line 215
      from ++;
#line 216
      goto while_continue;
    }
#line 219
    if (to != 0) {
#line 219
      if (_to_1->addr + (unsigned int )_to_1->len == _from->addr) {
        {
#line 220
        tmp = realloc((void *)_to_1->data, (size_t )(_to_1->len + _from->len));
#line 220
        _to_1->data = (unsigned char *)tmp;
        }
#line 222
        if ((unsigned long )_to_1->data == (unsigned long )((void *)0)) {
          {
#line 223
          printf((char const   */* __restrict  */)"realloc() failed\n");
          }
#line 224
          return (1);
        }
        {
#line 226
        memcpy((void */* __restrict  */)(_to_1->data + _to_1->len), (void const   */* __restrict  */)_from->data,
               (size_t )_from->len);
#line 228
        free((void *)_from->data);
#line 229
        _from->data = (unsigned char *)((void *)0);
#line 230
        _to_1->len += _from->len;
#line 231
        removed ++;
        }
      } else {
#line 219
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 233
      if (from != to) {
        {
#line 234
        memcpy((void */* __restrict  */)_to, (void const   */* __restrict  */)_from,
               sizeof(struct s3_record ));
        }
      }
#line 235
      to ++;
    }
#line 237
    from ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 240
  srec->s3_used -= removed;
#line 242
  if (srec->s3_entries > srec->s3_used) {
    {
#line 243
    srec->s3_entries = srec->s3_used;
#line 244
    tmp___0 = realloc((void *)srec->s3_records, (unsigned long )srec->s3_entries * sizeof(struct s3_record ));
#line 244
    srec->s3_records = (struct s3_record *)tmp___0;
    }
#line 247
    if ((unsigned long )srec->s3_records == (unsigned long )((void *)0)) {
      {
#line 248
      printf((char const   */* __restrict  */)"realloc() failed\n");
      }
#line 249
      return (1);
    }
  }
#line 253
  return (0);
}
}
#line 257 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void show_s3_data_areas(struct srec_data *srec ) 
{ 
  int i ;
  int total_len ;

  {
  {
#line 261
  printf((char const   */* __restrict  */)"S3 area count: %i\n", srec->s3_used);
#line 262
  total_len = 0;
#line 263
  i = 0;
  }
  {
#line 263
  while (1) {
    while_continue: /* CIL Label */ ;
#line 263
    if (! (i < srec->s3_used)) {
#line 263
      goto while_break;
    }
    {
#line 264
    printf((char const   */* __restrict  */)"  addr=0x%08X..0x%08X (len=%i)\n", (srec->s3_records + i)->addr,
           ((srec->s3_records + i)->addr + (unsigned int )(srec->s3_records + i)->len) - 1U,
           (srec->s3_records + i)->len);
#line 269
    total_len += (srec->s3_records + i)->len;
#line 263
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 271
  printf((char const   */* __restrict  */)"Total data length: %i\n", total_len);
  }
#line 272
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int verify_s3_data(struct srec_data *srec ) 
{ 
  int i ;
  struct s3_record *p ;
  struct s3_record *e ;

  {
#line 280
  i = 1;
  {
#line 280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 280
    if (! (i < srec->s3_used)) {
#line 280
      goto while_break;
    }
#line 281
    p = srec->s3_records + (i - 1);
#line 282
    e = srec->s3_records + i;
#line 283
    if (p->addr + (unsigned int )p->len > e->addr) {
      {
#line 284
      printf((char const   */* __restrict  */)"Overlapping S3 data records (%08x..%08x and %08x..%08x)\n",
             p->addr, p->addr + (unsigned int )p->len, e->addr, e->addr + (unsigned int )e->len);
      }
#line 288
      return (1);
    }
#line 280
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 294
  return (0);
}
}
#line 298 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void overlap_crc16_signatures(struct srec_data *srec , struct srec_data *srec2 ) 
{ 
  int i ;
  int j ;
  struct s3_crc16 *c ;
  struct s3_record *s ;

  {
#line 305
  i = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (! (i < srec2->crc16_count)) {
#line 305
      goto while_break;
    }
#line 306
    c = srec2->crc16 + i;
#line 307
    if (! c->prog) {
#line 308
      goto __Cont;
    }
#line 310
    j = 0;
    {
#line 310
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 310
      if (! (j < srec->s3_used)) {
#line 310
        goto while_break___0;
      }
#line 311
      s = srec->s3_records + j;
#line 313
      if (c->start == s->addr + (unsigned int )s->len) {
#line 313
        if (s->len >= 2) {
          {
#line 314
          printf((char const   */* __restrict  */)"Allowing S3 overlap due to CRC-16 signature at 0x%08x (was: %02x%02x)\n",
                 c->start - 2U, (int )*(s->data + (s->len - 2)), (int )*(s->data + (s->len - 1)));
#line 318
          s->len -= 2;
          }
#line 319
          goto while_break___0;
        }
      }
#line 310
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 305
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 323
  return;
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int merge_s3_data(struct srec_data *srec , struct srec_data *srec2 ) 
{ 
  int total ;
  int i ;
  int ret ;
  struct s3_record *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 332
  overlap_crc16_signatures(srec, srec2);
#line 334
  total = srec->s3_used + srec2->s3_used;
  }
#line 335
  if (srec->s3_entries < total) {
    {
#line 337
    tmp___0 = realloc((void *)srec->s3_records, (unsigned long )total * sizeof(struct s3_record ));
#line 337
    tmp = (struct s3_record *)tmp___0;
    }
#line 340
    if (! tmp) {
#line 341
      return (1);
    }
#line 342
    srec->s3_entries = total;
#line 343
    srec->s3_records = tmp;
  }
#line 346
  i = 0;
  {
#line 346
  while (1) {
    while_continue: /* CIL Label */ ;
#line 346
    if (! (i < srec2->s3_used)) {
#line 346
      goto while_break;
    }
    {
#line 347
    memcpy((void */* __restrict  */)(srec->s3_records + srec->s3_used), (void const   */* __restrict  */)(srec2->s3_records + i),
           sizeof(struct s3_record ));
#line 349
    (srec->s3_used) ++;
#line 346
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 351
  srec2->s3_used = 0;
#line 353
  qsort((void *)srec->s3_records, (size_t )srec->s3_used, sizeof(struct s3_record ),
        & s3_comp);
#line 356
  tmp___1 = s3_combine(srec);
  }
#line 356
  if (tmp___1) {
#line 356
    tmp___3 = 1;
  } else {
    {
#line 356
    tmp___2 = verify_s3_data(srec);
    }
#line 356
    if (tmp___2) {
#line 356
      tmp___3 = 1;
    } else {
#line 356
      tmp___3 = 0;
    }
  }
#line 356
  ret = tmp___3;
#line 358
  if (verbose) {
    {
#line 359
    printf((char const   */* __restrict  */)"After srec file merge\n");
#line 360
    show_s3_data_areas(srec);
    }
  }
#line 363
  return (ret);
}
}
#line 367 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int process_s3_plug(struct srec_data *srec , char *data , int len , unsigned int addr ) 
{ 
  struct s3_plug_record *p ;
  void *tmp ;

  {
#line 372
  if (len != 12) {
    {
#line 373
    printf((char const   */* __restrict  */)"Unknown S3 plug record length %d\n",
           len);
    }
#line 374
    return (1);
  }
  {
#line 377
  tmp = realloc((void *)srec->plugs, (unsigned long )(srec->plug_count + 1) * sizeof(struct s3_plug_record ));
#line 377
  srec->plugs = (struct s3_plug_record *)tmp;
  }
#line 380
  if (! ((unsigned long )srec->plugs != (unsigned long )((void *)0))) {
    {
#line 380
    __assert_fail("srec->plugs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c",
                  380U, "process_s3_plug");
    }
  }
  {
#line 382
  p = srec->plugs + srec->plug_count;
#line 383
  (srec->plug_count) ++;
#line 384
  p->pdr = get_hex32_le(data);
#line 385
  p->plug_addr = get_hex32_le(data + 8);
#line 386
  p->plug_len = get_hex32_le(data + 16);
  }
  {
#line 387
  while (1) {
    while_continue: /* CIL Label */ ;
#line 387
    if (verbose > 1) {
      {
#line 387
      printf((char const   */* __restrict  */)"S3 plug record: PDR=0x%04x plug: addr=0x%08X len=%i\n",
             p->pdr, p->plug_addr, p->plug_len);
      }
    }
#line 387
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return (0);
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int process_s3_crc16(struct srec_data *srec , char *data , int len , unsigned int addr ) 
{ 
  struct s3_crc16 *c ;
  void *tmp ;

  {
#line 399
  if (len != 12) {
    {
#line 400
    printf((char const   */* __restrict  */)"Unknown S3 CRC-16 generation record length %d\n",
           len);
    }
#line 401
    return (1);
  }
  {
#line 404
  tmp = realloc((void *)srec->crc16, (unsigned long )(srec->crc16_count + 1) * sizeof(struct s3_crc16 ));
#line 404
  srec->crc16 = (struct s3_crc16 *)tmp;
  }
#line 407
  if (! ((unsigned long )srec->crc16 != (unsigned long )((void *)0))) {
    {
#line 407
    __assert_fail("srec->crc16 != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c",
                  407U, "process_s3_crc16");
    }
  }
  {
#line 408
  c = srec->crc16 + srec->crc16_count;
#line 409
  (srec->crc16_count) ++;
#line 411
  c->start = get_hex32_le(data);
#line 412
  c->len = get_hex32_le(data + 8);
#line 413
  c->prog = get_hex32_le(data + 16);
  }
  {
#line 414
  while (1) {
    while_continue: /* CIL Label */ ;
#line 414
    if (verbose) {
      {
#line 414
      printf((char const   */* __restrict  */)"S3 CRC-16 generation record: start=0x%08X len=%d prog=%d\n",
             c->start, c->len, c->prog);
      }
    }
#line 414
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 418
  return (0);
}
}
#line 422 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int process_s3_fw_info_name(struct srec_data *srec , char *data , int len ,
                                   unsigned short words ) 
{ 
  int i ;
  void *tmp ;
  int c ;

  {
  {
#line 427
  tmp = malloc((size_t )(len + 1));
#line 427
  srec->name_rec = (char *)tmp;
  }
#line 428
  if (! ((unsigned long )srec->name_rec != (unsigned long )((void *)0))) {
    {
#line 428
    __assert_fail("srec->name_rec != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c",
                  428U, "process_s3_fw_info_name");
    }
  }
  {
#line 429
  memset((void *)srec->name_rec, 0, (size_t )(len + 1));
#line 431
  i = 0;
  }
  {
#line 431
  while (1) {
    while_continue: /* CIL Label */ ;
#line 431
    if (! (i < len)) {
#line 431
      goto while_break;
    }
    {
#line 433
    c = get_hex8(data + 2 * i);
    }
#line 434
    if (c == 0) {
#line 435
      goto while_break;
    }
#line 436
    if (c >= 32) {
#line 436
      if (c < 127) {
#line 437
        *(srec->name_rec + i) = (char )c;
      } else {
#line 439
        *(srec->name_rec + i) = (char )'_';
      }
    } else {
#line 439
      *(srec->name_rec + i) = (char )'_';
    }
#line 431
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 441
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 441
    if (verbose) {
      {
#line 441
      printf((char const   */* __restrict  */)"Special S3 firmware info record - name \'%s\'\n",
             srec->name_rec);
      }
    }
#line 441
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 443
  return (0);
}
}
#line 447 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int process_s3_fw_info_ver(struct srec_data *srec , char *data , int words ) 
{ 


  {
#line 450
  if (words != 4) {
    {
#line 451
    printf((char const   */* __restrict  */)"Invalid S3 f/w info: version info (words=%i)\n",
           words);
    }
#line 453
    return (1);
  }
#line 455
  if (srec->component_set) {
    {
#line 456
    printf((char const   */* __restrict  */)"More than one S3 f/w info component?\n");
    }
#line 457
    return (1);
  }
  {
#line 459
  (srec->component_set) ++;
#line 460
  srec->component.component = get_hex16_le(data);
#line 461
  srec->component.variant = get_hex16_le(data + 4);
#line 462
  srec->component.major = get_hex16_le(data + 8);
#line 463
  srec->component.minor = get_hex16_le(data + 12);
  }
  {
#line 464
  while (1) {
    while_continue: /* CIL Label */ ;
#line 464
    if (verbose > 1) {
      {
#line 464
      printf((char const   */* __restrict  */)"S3 f/w info: version: component=0x%04x %i.%i.%i\n",
             srec->component.component, srec->component.major, srec->component.minor,
             srec->component.variant);
      }
    }
#line 464
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 467
  return (0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int process_s3_fw_info_comp(struct srec_data *srec , char *data , int words ) 
{ 
  struct s3_info_compatibility *r ;
  int role ;
  int iface_id ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  void *tmp___1 ;

  {
#line 477
  if (words < 5) {
    {
#line 478
    printf((char const   */* __restrict  */)"Invalid S3 firmware info: compatibility info (words=%i)\n",
           words);
    }
#line 480
    return (1);
  } else
#line 477
  if ((words - 2) % 3) {
    {
#line 478
    printf((char const   */* __restrict  */)"Invalid S3 firmware info: compatibility info (words=%i)\n",
           words);
    }
#line 480
    return (1);
  }
  {
#line 483
  tmp = get_hex16_le(data);
#line 483
  role = (int )tmp;
#line 484
  tmp___0 = get_hex16_le(data + 4);
#line 484
  iface_id = (int )tmp___0;
#line 485
  data += 8;
#line 486
  words -= 2;
  }
  {
#line 488
  while (1) {
    while_continue: /* CIL Label */ ;
#line 488
    if (! (words >= 3)) {
#line 488
      goto while_break;
    }
    {
#line 489
    tmp___1 = realloc((void *)srec->compatibilities, (unsigned long )(srec->compatibility_count + 1) * sizeof(struct s3_info_compatibility ));
#line 489
    srec->compatibilities = (struct s3_info_compatibility *)tmp___1;
    }
#line 493
    if (! ((unsigned long )srec->compatibilities != (unsigned long )((void *)0))) {
      {
#line 493
      __assert_fail("srec->compatibilities != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c",
                    493U, "process_s3_fw_info_comp");
      }
    }
    {
#line 495
    r = srec->compatibilities + srec->compatibility_count;
#line 496
    (srec->compatibility_count) ++;
#line 497
    r->role = (unsigned int )role;
#line 498
    r->iface_id = (unsigned int )iface_id;
#line 499
    r->variant = get_hex16_le(data);
#line 500
    r->bottom = get_hex16_le(data + 4);
#line 501
    r->top = get_hex16_le(data + 8);
#line 502
    data += 12;
#line 503
    words -= 3;
    }
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 504
      if (verbose > 1) {
        {
#line 504
        printf((char const   */* __restrict  */)"S3 f/w info: compatibility: role=0x%04x iface_id=0x%04x variant=%i range=%i-%i\n",
               r->role, r->iface_id, r->variant, r->bottom, r->top);
        }
      }
#line 504
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 510
  return (0);
}
}
#line 514 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int process_s3_fw_info_seq(struct srec_data *srec , char *data , int words ) 
{ 
  unsigned short seq ;
  unsigned int tmp ;

  {
#line 519
  if (words != 1) {
    {
#line 520
    printf((char const   */* __restrict  */)"Invalid S3 firmware info: build sequence words: %i\n",
           words);
    }
#line 522
    return (1);
  }
  {
#line 524
  tmp = get_hex16_le(data);
#line 524
  seq = (unsigned short )tmp;
  }
  {
#line 525
  while (1) {
    while_continue: /* CIL Label */ ;
#line 525
    if (verbose > 1) {
      {
#line 525
      printf((char const   */* __restrict  */)"S3 f/w info: build seq#: %i\n", (int )seq);
      }
    }
#line 525
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 526
  return (0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int process_s3_fw_info_platform(struct srec_data *srec , char *data , int words ) 
{ 
  struct s3_info_platform *p ;
  void *tmp ;

  {
#line 535
  if (words != 4) {
    {
#line 536
    printf((char const   */* __restrict  */)"Invalid S3 firmware info: platform info words: %i\n",
           words);
    }
#line 538
    return (1);
  }
  {
#line 541
  tmp = realloc((void *)srec->platforms, (unsigned long )(srec->platform_count + 1) * sizeof(struct s3_info_platform ));
#line 541
  srec->platforms = (struct s3_info_platform *)tmp;
  }
#line 544
  if (! ((unsigned long )srec->platforms != (unsigned long )((void *)0))) {
    {
#line 544
    __assert_fail("srec->platforms != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c",
                  544U, "process_s3_fw_info_platform");
    }
  }
  {
#line 546
  p = srec->platforms + srec->platform_count;
#line 547
  (srec->platform_count) ++;
#line 548
  p->platform = get_hex16_le(data);
#line 549
  p->variant = get_hex16_le(data + 4);
#line 550
  p->major = get_hex16_le(data + 8);
#line 551
  p->minor = get_hex16_le(data + 12);
  }
  {
#line 552
  while (1) {
    while_continue: /* CIL Label */ ;
#line 552
    if (verbose > 1) {
      {
#line 552
      printf((char const   */* __restrict  */)"S3 f/w info: platform: id=0x%04x %u.%u.%u\n",
             p->platform, p->major, p->minor, p->variant);
      }
    }
#line 552
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 555
  return (0);
}
}
#line 559 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int process_s3_fw_info(struct srec_data *srec , char *data , int len , unsigned int addr ) 
{ 
  unsigned short words ;
  unsigned short type ;
  int ret ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  unsigned int tmp___2 ;
  char *newbuf ;
  void *tmp___3 ;

  {
#line 563
  ret = 0;
#line 565
  if (addr != srec->s3_fw_info_addr) {
    {
#line 566
    printf((char const   */* __restrict  */)"Invalid S3 firmware info start addr 0x%x (expected 0x%x)\n",
           addr, srec->s3_fw_info_addr);
#line 568
    srec->s3_fw_info_addr = 4280287232U;
    }
#line 569
    return (1);
  }
#line 572
  if (addr == 4280287232U) {
#line 573
    if (srec->s3_fw_info_buf) {
      {
#line 574
      printf((char const   */* __restrict  */)"Unfinished S3 firmware info\n");
      }
#line 575
      return (1);
    }
#line 577
    if (len < 4) {
      {
#line 578
      printf((char const   */* __restrict  */)"Too short S3 firmware info (len %i)\n",
             len);
#line 579
      printf((char const   */* __restrict  */)"S3 line: %s\n", data);
      }
#line 580
      return (1);
    }
    {
#line 582
    tmp = get_hex16_le(data);
#line 582
    words = (unsigned short )tmp;
#line 583
    tmp___0 = get_hex16_le(data + 4);
#line 583
    type = (unsigned short )tmp___0;
    }
  } else {
#line 585
    if ((unsigned long )srec->s3_fw_info_buf == (unsigned long )((void *)0)) {
      {
#line 586
      printf((char const   */* __restrict  */)"Did not see first fragment of S3 firmware info record\n");
      }
#line 588
      return (-1);
    }
    {
#line 590
    tmp___1 = get_hex16_le(srec->s3_fw_info_buf);
#line 590
    words = (unsigned short )tmp___1;
#line 591
    tmp___2 = get_hex16_le(srec->s3_fw_info_buf + 4);
#line 591
    type = (unsigned short )tmp___2;
    }
  }
#line 594
  if (addr != 4280287232U) {
#line 594
    goto _L;
  } else
#line 594
  if ((size_t )len + srec->s3_fw_info_buf_len < (size_t )((int )words * 2)) {
    _L: /* CIL Label */ 
    {
#line 598
    tmp___3 = realloc((void *)srec->s3_fw_info_buf, (srec->s3_fw_info_buf_len + (size_t )len) * 2UL);
#line 598
    newbuf = (char *)tmp___3;
    }
#line 600
    if ((unsigned long )newbuf == (unsigned long )((void *)0)) {
      {
#line 601
      printf((char const   */* __restrict  */)"Failed to allocate memory for S3 f/w info record\n");
      }
#line 603
      return (1);
    }
    {
#line 605
    memcpy((void */* __restrict  */)(newbuf + srec->s3_fw_info_buf_len * 2UL), (void const   */* __restrict  */)data,
           (size_t )(len * 2));
#line 606
    srec->s3_fw_info_buf = newbuf;
#line 607
    srec->s3_fw_info_buf_len += (size_t )len;
#line 608
    srec->s3_fw_info_addr = addr + (unsigned int )len;
    }
#line 609
    if (srec->s3_fw_info_buf_len < (size_t )((int )words * 2)) {
#line 610
      return (0);
    }
#line 613
    data = srec->s3_fw_info_buf;
#line 614
    len = (int )srec->s3_fw_info_buf_len;
  }
#line 618
  data += 8;
#line 619
  len -= 4;
#line 622
  if ((int )type != 32769) {
#line 623
    words = (unsigned short )((int )words - 1);
  }
#line 625
  if ((int )words * 2 != len) {
    {
#line 626
    printf((char const   */* __restrict  */)"Invalid S3 firmware info len: len=%i words=%i type=0x%x\n",
           len, (int )words, (int )type);
#line 628
    printf((char const   */* __restrict  */)"S3 line: %s\n", data);
    }
#line 629
    return (1);
  }
#line 633
  srec->s3_fw_info_addr = 4280287232U;
  {
#line 636
  if ((int )type == 1) {
#line 636
    goto case_1;
  }
#line 639
  if ((int )type == 2) {
#line 639
    goto case_2;
  }
#line 642
  if ((int )type == 3) {
#line 642
    goto case_3;
  }
#line 645
  if ((int )type == 4) {
#line 645
    goto case_4;
  }
#line 648
  if ((int )type == 32769) {
#line 648
    goto case_32769;
  }
#line 651
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 637
  ret = process_s3_fw_info_ver(srec, data, (int )words);
  }
#line 638
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 640
  ret = process_s3_fw_info_comp(srec, data, (int )words);
  }
#line 641
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 643
  ret = process_s3_fw_info_seq(srec, data, (int )words);
  }
#line 644
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 646
  ret = process_s3_fw_info_platform(srec, data, (int )words);
  }
#line 647
  goto switch_break;
  case_32769: /* CIL Label */ 
  {
#line 649
  ret = process_s3_fw_info_name(srec, data, len, words);
  }
#line 650
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 652
  printf((char const   */* __restrict  */)"Unknown S3 firmware info type %i\n", (int )type);
#line 653
  ret = 1;
  }
#line 654
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 657
  free((void *)srec->s3_fw_info_buf);
#line 658
  srec->s3_fw_info_buf = (char *)((void *)0);
#line 659
  srec->s3_fw_info_buf_len = (size_t )0;
  }
#line 660
  return (ret);
}
}
#line 666 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int process_s3_data(struct srec_data *srec , char *data , int len , unsigned int addr ) 
{ 
  unsigned char buf___0[128] ;
  int i ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 672
  i = 0;
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! (i < len)) {
#line 672
      goto while_break;
    }
    {
#line 673
    tmp = get_hex8(data + i * 2);
#line 673
    buf___0[i] = (unsigned char )tmp;
#line 672
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 675
  if (srec->s3_used > 0) {
#line 675
    if ((srec->s3_records + (srec->s3_used - 1))->addr + (unsigned int )(srec->s3_records + (srec->s3_used - 1))->len == addr) {
      {
#line 679
      tmp___0 = realloc((void *)(srec->s3_records + (srec->s3_used - 1))->data, (size_t )((srec->s3_records + (srec->s3_used - 1))->len + len));
#line 679
      (srec->s3_records + (srec->s3_used - 1))->data = (unsigned char *)tmp___0;
      }
#line 682
      if ((unsigned long )(srec->s3_records + (srec->s3_used - 1))->data == (unsigned long )((void *)0)) {
        {
#line 683
        printf((char const   */* __restrict  */)"realloc() failed\n");
        }
#line 684
        return (1);
      }
      {
#line 686
      memcpy((void */* __restrict  */)((srec->s3_records + (srec->s3_used - 1))->data + (srec->s3_records + (srec->s3_used - 1))->len),
             (void const   */* __restrict  */)(buf___0), (size_t )len);
#line 688
      (srec->s3_records + (srec->s3_used - 1))->len += len;
      }
    } else {
#line 675
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 690
    if (srec->s3_used + 1 == srec->s3_entries) {
      {
#line 691
      enlarge_s3_buf(srec);
      }
    }
    {
#line 692
    (srec->s3_records + srec->s3_used)->addr = addr;
#line 693
    (srec->s3_records + srec->s3_used)->len = len;
#line 694
    tmp___1 = malloc((size_t )len);
#line 694
    (srec->s3_records + srec->s3_used)->data = (unsigned char *)tmp___1;
    }
#line 696
    if ((unsigned long )(srec->s3_records + srec->s3_used)->data == (unsigned long )((void *)0)) {
      {
#line 697
      printf((char const   */* __restrict  */)"malloc() failed\n");
      }
#line 698
      return (1);
    }
    {
#line 700
    memcpy((void */* __restrict  */)(srec->s3_records + srec->s3_used)->data, (void const   */* __restrict  */)(buf___0),
           (size_t )len);
#line 701
    (srec->s3_used) ++;
    }
  }
#line 704
  return (0);
}
}
#line 708 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int process_s3(struct srec_data *srec , char *data , int len ) 
{ 
  unsigned int addr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 712
  if (len < 4) {
    {
#line 713
    printf((char const   */* __restrict  */)"Too short S3 len=%i\n", len);
    }
#line 714
    return (1);
  }
#line 717
  if (len - 4 > 128) {
    {
#line 718
    printf((char const   */* __restrict  */)"Too long S3 len=%i\n", len);
    }
#line 719
    return (1);
  }
  {
#line 722
  addr = get_hex32(data);
#line 723
  len -= 4;
#line 724
  data += 8;
  }
#line 726
  if (addr & 4278190080U) {
#line 728
    if (addr == 4278190080U) {
      {
#line 729
      tmp = process_s3_plug(srec, data, len, addr);
      }
#line 729
      if (tmp) {
#line 730
        return (1);
      }
    } else
#line 731
    if (addr == 4279238656U) {
      {
#line 732
      tmp___0 = process_s3_crc16(srec, data, len, addr);
      }
#line 732
      if (tmp___0) {
#line 733
        return (1);
      }
    } else
#line 734
    if ((addr & 4294901760U) == 4280287232U) {
      {
#line 735
      tmp___1 = process_s3_fw_info(srec, data, len, addr);
      }
#line 735
      if (tmp___1) {
#line 736
        return (1);
      }
    } else {
      {
#line 738
      printf((char const   */* __restrict  */)"Unknown special S3 record: \'%s\'\n",
             data);
      }
#line 739
      return (1);
    }
  } else {
    {
#line 743
    tmp___2 = process_s3_data(srec, data, len, addr);
    }
#line 743
    if (tmp___2) {
#line 744
      return (1);
    }
  }
#line 747
  return (0);
}
}
#line 750 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int process_s7(struct srec_data *srec , char *data , int len ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 753
  if (len != 4) {
    {
#line 754
    printf((char const   */* __restrict  */)"Invalid S7 length %i (expected 4)\n",
           len);
    }
#line 755
    return (1);
  }
#line 758
  srec->start_addr = 0U;
#line 759
  i = 0;
  {
#line 759
  while (1) {
    while_continue: /* CIL Label */ ;
#line 759
    if (! (i < 4)) {
#line 759
      goto while_break;
    }
    {
#line 760
    tmp = hex2int___0(*(data + i * 2));
#line 760
    tmp___0 = hex2int___0(*(data + (1 + i * 2)));
#line 760
    srec->start_addr = ((srec->start_addr << 8) | (unsigned int )(tmp << 4)) | (unsigned int )tmp___0;
#line 759
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 764
  srec->start_addr_set = 1;
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 765
    if (verbose) {
      {
#line 765
      printf((char const   */* __restrict  */)"Start address 0x%08x\n", srec->start_addr);
      }
    }
#line 765
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 767
  return (0);
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void free_srec(struct srec_data *srec ) 
{ 
  int i ;

  {
#line 775
  if ((unsigned long )srec == (unsigned long )((void *)0)) {
#line 776
    return;
  }
#line 778
  if ((unsigned long )srec->s3_records != (unsigned long )((void *)0)) {
#line 779
    i = 0;
    {
#line 779
    while (1) {
      while_continue: /* CIL Label */ ;
#line 779
      if (! (i < srec->s3_used)) {
#line 779
        goto while_break;
      }
      {
#line 780
      free((void *)(srec->s3_records + i)->data);
#line 779
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 781
    free((void *)srec->s3_records);
    }
  }
  {
#line 784
  free((void *)srec->platforms);
#line 785
  free((void *)srec->compatibilities);
#line 786
  free((void *)srec->crc16);
#line 787
  free((void *)srec->plugs);
#line 788
  free((void *)srec->name);
#line 789
  free((void *)srec->name_rec);
#line 790
  free((void *)srec->s3_fw_info_buf);
#line 791
  free((void *)srec);
  }
#line 792
  return;
}
}
#line 794 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
struct srec_data *read_srec(char const   *fname ) 
{ 
  FILE *f ;
  char buf___0[1024] ;
  char const   *pos ;
  int i ;
  int len ;
  int slen ;
  int errors ;
  int line ;
  struct srec_data *srec ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 800
  errors = 0;
#line 800
  line = 0;
#line 803
  f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 804
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 805
    tmp = __errno_location();
#line 805
    tmp___0 = strerror(*tmp);
#line 805
    printf((char const   */* __restrict  */)"\'%s\' not readable: %s.\n", fname, tmp___0);
    }
#line 806
    return ((struct srec_data *)((void *)0));
  }
  {
#line 809
  tmp___1 = malloc(sizeof(struct srec_data ));
#line 809
  srec = (struct srec_data *)tmp___1;
  }
#line 810
  if ((unsigned long )srec == (unsigned long )((void *)0)) {
    {
#line 811
    fclose(f);
    }
#line 812
    return ((struct srec_data *)((void *)0));
  }
  {
#line 814
  memset((void *)srec, 0, sizeof(struct srec_data ));
#line 815
  srec->s3_fw_info_addr = 4280287232U;
#line 817
  tmp___2 = strrchr(fname, '/');
#line 817
  pos = (char const   *)tmp___2;
  }
#line 818
  if ((unsigned long )pos == (unsigned long )((void *)0)) {
#line 819
    pos = fname;
  } else {
#line 821
    pos ++;
  }
  {
#line 822
  srec->name = strdup(pos);
#line 824
  srec->s3_used = 0;
#line 825
  srec->s3_entries = 1024;
#line 826
  tmp___3 = malloc((unsigned long )srec->s3_entries * sizeof(struct s3_record ));
#line 826
  srec->s3_records = (struct s3_record *)tmp___3;
  }
#line 828
  if ((unsigned long )srec->s3_records == (unsigned long )((void *)0)) {
    {
#line 829
    printf((char const   */* __restrict  */)"Could not allocate memory for S3 records.\n");
#line 830
    fclose(f);
#line 831
    free((void *)srec);
    }
#line 832
    return ((struct srec_data *)((void *)0));
  }
  {
#line 834
  memset((void *)srec->s3_records, 0, (unsigned long )srec->s3_entries * sizeof(struct s3_record ));
  }
  {
#line 837
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 837
    tmp___8 = fgets((char */* __restrict  */)(buf___0), (int )sizeof(buf___0), (FILE */* __restrict  */)f);
    }
#line 837
    if (! ((unsigned long )tmp___8 != (unsigned long )((void *)0))) {
#line 837
      goto while_break;
    }
#line 838
    line ++;
#line 839
    buf___0[sizeof(buf___0) - 1UL] = (char )'\000';
#line 840
    i = 0;
    {
#line 840
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 840
      if (! ((unsigned long )i < sizeof(buf___0))) {
#line 840
        goto while_break___0;
      }
#line 841
      if ((int )buf___0[i] == 13) {
#line 842
        buf___0[i] = (char )'\000';
      } else
#line 841
      if ((int )buf___0[i] == 10) {
#line 842
        buf___0[i] = (char )'\000';
      }
#line 844
      if ((int )buf___0[i] == 0) {
#line 845
        goto while_break___0;
      }
#line 840
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 847
    if ((int )buf___0[0] == 0) {
#line 848
      goto while_continue;
    }
#line 850
    if ((int )buf___0[0] != 83) {
      {
#line 851
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipped unrecognized line %i: \'%s\'\n",
              line, buf___0);
#line 853
      errors ++;
      }
#line 854
      goto while_continue;
    } else
#line 850
    if ((int )buf___0[1] == 0) {
      {
#line 851
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipped unrecognized line %i: \'%s\'\n",
              line, buf___0);
#line 853
      errors ++;
      }
#line 854
      goto while_continue;
    }
    {
#line 857
    len = get_hex8(buf___0 + 2);
#line 858
    tmp___4 = strlen((char const   *)(buf___0 + 2));
#line 858
    slen = (int )tmp___4;
    }
#line 859
    if (len < 1) {
      {
#line 860
      printf((char const   */* __restrict  */)"Invalid line %i length (len=%d slen=%d) \'%s\'\n",
             line, len, slen, buf___0);
      }
    } else
#line 859
    if (slen & 1) {
      {
#line 860
      printf((char const   */* __restrict  */)"Invalid line %i length (len=%d slen=%d) \'%s\'\n",
             line, len, slen, buf___0);
      }
    } else
#line 859
    if (len + 1 != slen / 2) {
      {
#line 860
      printf((char const   */* __restrict  */)"Invalid line %i length (len=%d slen=%d) \'%s\'\n",
             line, len, slen, buf___0);
      }
    }
    {
#line 864
    tmp___5 = verify_checksum(buf___0 + 2, len);
    }
#line 864
    if (tmp___5) {
      {
#line 865
      printf((char const   */* __restrict  */)"line %i: checksum failure\n", line);
#line 866
      errors ++;
      }
#line 867
      goto while_continue;
    }
#line 870
    buf___0[slen] = (char )'\000';
    {
#line 873
    if ((int )buf___0[1] == 51) {
#line 873
      goto case_51;
    }
#line 879
    if ((int )buf___0[1] == 55) {
#line 879
      goto case_55;
    }
#line 885
    goto switch_default;
    case_51: /* CIL Label */ 
    {
#line 874
    tmp___6 = process_s3(srec, buf___0 + 4, len - 1);
    }
#line 874
    if (tmp___6) {
      {
#line 875
      printf((char const   */* __restrict  */)"S3 parse error; line=%d\n", line);
#line 876
      errors ++;
      }
    }
#line 878
    goto switch_break;
    case_55: /* CIL Label */ 
    {
#line 880
    tmp___7 = process_s7(srec, buf___0 + 4, len - 1);
    }
#line 880
    if (tmp___7) {
      {
#line 881
      printf((char const   */* __restrict  */)"S7 parse error; line=%d\n", line);
#line 882
      errors ++;
      }
    }
#line 884
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 886
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Skipped unrecognized S-line %i: \'%s\'\n",
            line, buf___0);
#line 888
    errors ++;
    }
#line 889
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 893
  fclose(f);
  }
#line 895
  if (srec->s3_fw_info_buf) {
    {
#line 896
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unfinished S3 firmware info\n");
#line 897
    errors ++;
    }
  }
#line 900
  if (verbose > 1) {
    {
#line 901
    printf((char const   */* __restrict  */)"Before S3 sort\n");
#line 902
    show_s3_data_areas(srec);
    }
  }
  {
#line 905
  qsort((void *)srec->s3_records, (size_t )srec->s3_used, sizeof(struct s3_record ),
        & s3_comp);
#line 907
  tmp___9 = s3_combine(srec);
  }
#line 907
  if (tmp___9) {
#line 908
    errors ++;
  } else {
    {
#line 907
    tmp___10 = verify_s3_data(srec);
    }
#line 907
    if (tmp___10) {
#line 908
      errors ++;
    }
  }
#line 910
  if (verbose > 1) {
    {
#line 911
    printf((char const   */* __restrict  */)"\nAfter S3 sort\n");
#line 912
    show_s3_data_areas(srec);
    }
  }
#line 915
  if (errors > 0) {
    {
#line 916
    printf((char const   */* __restrict  */)"Errors found - file cannot be used\n");
#line 917
    free_srec(srec);
    }
#line 918
    return ((struct srec_data *)((void *)0));
  }
#line 921
  return (srec);
}
}
#line 927 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void show_compatibility(struct s3_info_compatibility *r , char const   *prefix ) 
{ 
  char const   *iface_id_str ;
  char const   *tmp ;

  {
  {
#line 931
  if (r->iface_id == 1U) {
#line 931
    goto case_1;
  }
#line 932
  if (r->iface_id == 2U) {
#line 932
    goto case_2;
  }
#line 933
  if (r->iface_id == 3U) {
#line 933
    goto case_3;
  }
#line 934
  if (r->iface_id == 4U) {
#line 934
    goto case_4;
  }
#line 935
  goto switch_default;
  case_1: /* CIL Label */ 
#line 931
  iface_id_str = "Modem-Firmware";
#line 931
  goto switch_break;
  case_2: /* CIL Label */ 
#line 932
  iface_id_str = "Controller-Firmware";
#line 932
  goto switch_break;
  case_3: /* CIL Label */ 
#line 933
  iface_id_str = "Primary Firmware-Driver";
#line 933
  goto switch_break;
  case_4: /* CIL Label */ 
#line 934
  iface_id_str = "Station Firmware-Driver";
#line 934
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 935
  iface_id_str = "??";
#line 935
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 937
  if (r->role == 0U) {
#line 937
    tmp = "Supplier";
  } else {
#line 937
    tmp = "Actor   ";
  }
  {
#line 937
  printf((char const   */* __restrict  */)"  %srole=%s variant=%d range=%d-%d iface=%s (%d)\n",
         prefix, tmp, r->variant, r->bottom, r->top, iface_id_str, r->iface_id);
  }
#line 941
  return;
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void show_srec(struct srec_data *srec ) 
{ 
  int i ;
  struct s3_info_platform *p ;

  {
  {
#line 948
  printf((char const   */* __restrict  */)"srec summary for %s\n", srec->name);
  }
#line 950
  if (srec->name_rec) {
    {
#line 951
    printf((char const   */* __restrict  */)"Included file name: %s\n", srec->name_rec);
    }
  }
  {
#line 953
  printf((char const   */* __restrict  */)"Component: 0x%04x %i.%i.%i", srec->component.component,
         srec->component.major, srec->component.minor, srec->component.variant);
  }
  {
#line 959
  if (srec->component.component == 21U) {
#line 959
    goto case_21;
  }
#line 962
  if (srec->component.component == 31U) {
#line 962
    goto case_31;
  }
#line 965
  if (srec->component.component == 331U) {
#line 965
    goto case_331;
  }
#line 958
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 960
  printf((char const   */* __restrict  */)" (primary firmware)");
  }
#line 961
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 963
  printf((char const   */* __restrict  */)" (station firmware)");
  }
#line 964
  goto switch_break;
  case_331: /* CIL Label */ 
  {
#line 966
  printf((char const   */* __restrict  */)" (tertiary firmware)");
  }
#line 967
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 969
  printf((char const   */* __restrict  */)"\n");
  }
#line 971
  if (verbose) {
    {
#line 972
    printf((char const   */* __restrict  */)"Supported platforms:\n");
#line 973
    i = 0;
    }
    {
#line 973
    while (1) {
      while_continue: /* CIL Label */ ;
#line 973
      if (! (i < srec->platform_count)) {
#line 973
        goto while_break;
      }
      {
#line 974
      p = srec->platforms + i;
#line 975
      printf((char const   */* __restrict  */)"  0x%04x %u.%u.%u", p->platform, p->major,
             p->minor, p->variant);
      }
#line 977
      if (i == srec->platform_count - 1) {
        {
#line 978
        printf((char const   */* __restrict  */)"\n");
        }
      } else
#line 977
      if (i % 5 == 4) {
        {
#line 978
        printf((char const   */* __restrict  */)"\n");
        }
      } else {
        {
#line 980
        printf((char const   */* __restrict  */)",");
        }
      }
#line 973
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 983
    printf((char const   */* __restrict  */)"Interface compatibility information:\n");
#line 984
    i = 0;
    }
    {
#line 984
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 984
      if (! (i < srec->compatibility_count)) {
#line 984
        goto while_break___0;
      }
      {
#line 985
      show_compatibility(srec->compatibilities + i, "");
#line 984
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 987
    printf((char const   */* __restrict  */)"Separate S3 data areas:\n");
#line 988
    show_s3_data_areas(srec);
    }
#line 989
    if (srec->start_addr_set) {
      {
#line 990
      printf((char const   */* __restrict  */)"Start address 0x%08x\n", srec->start_addr);
      }
    }
  }
#line 992
  return;
}
}
#line 995 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int get_compid(char const   *dev , u16 rid , struct s3_info_platform *p ) 
{ 
  char buf___0[1024] ;
  struct prism2_hostapd_param *param ;
  struct hfa384x_comp_ident *comp ;
  int tmp ;

  {
  {
#line 1001
  param = (struct prism2_hostapd_param *)(buf___0);
#line 1002
  comp = (struct hfa384x_comp_ident *)(param->u.rid.data);
#line 1004
  tmp = hostapd_get_rid(dev, param, rid, 1);
  }
#line 1004
  if (tmp) {
#line 1006
    return (-1);
  } else
#line 1004
  if ((unsigned long )param->u.rid.len != sizeof(*comp)) {
#line 1006
    return (-1);
  }
#line 1008
  p->platform = (unsigned int )comp->id;
#line 1009
  p->major = (unsigned int )comp->major;
#line 1010
  p->minor = (unsigned int )comp->minor;
#line 1011
  p->variant = (unsigned int )comp->variant;
#line 1013
  return (0);
}
}
#line 1017 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int get_range(char const   *dev , u16 rid , struct s3_info_compatibility *r ) 
{ 
  char buf___0[1024] ;
  struct prism2_hostapd_param *param ;
  struct hfa384x_sup_range *range ;
  int tmp ;

  {
  {
#line 1023
  param = (struct prism2_hostapd_param *)(buf___0);
#line 1024
  range = (struct hfa384x_sup_range *)(param->u.rid.data);
#line 1026
  tmp = hostapd_get_rid(dev, param, rid, 1);
  }
#line 1026
  if (tmp) {
#line 1028
    return (-1);
  } else
#line 1026
  if ((unsigned long )param->u.rid.len != sizeof(*range)) {
#line 1028
    return (-1);
  }
#line 1030
  r->role = (unsigned int )range->role;
#line 1031
  r->iface_id = (unsigned int )range->id;
#line 1032
  r->variant = (unsigned int )range->variant;
#line 1033
  r->bottom = (unsigned int )range->bottom;
#line 1034
  r->top = (unsigned int )range->top;
#line 1036
  return (0);
}
}
#line 1040 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int read_wlan_rids(char const   *dev , struct wlan_info *wlan ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1042
  tmp = get_compid(dev, (u16 )64779, & wlan->nicid);
  }
#line 1042
  if (tmp) {
    {
#line 1044
    printf((char const   */* __restrict  */)"Missing wlan component info\n");
    }
#line 1045
    return (1);
  } else {
    {
#line 1042
    tmp___0 = get_compid(dev, (u16 )64770, & wlan->priid);
    }
#line 1042
    if (tmp___0) {
      {
#line 1044
      printf((char const   */* __restrict  */)"Missing wlan component info\n");
      }
#line 1045
      return (1);
    }
  }
  {
#line 1048
  tmp___1 = get_compid(dev, (u16 )64800, & wlan->staid);
  }
#line 1048
  if (tmp___1) {
    {
#line 1049
    printf((char const   */* __restrict  */)"STAID not available (maybe running PRI-only)\n");
    }
  }
  {
#line 1051
  get_range(dev, (u16 )64771, & wlan->pri_sup);
#line 1052
  get_range(dev, (u16 )64772, & wlan->cfi_pri_act);
#line 1053
  get_range(dev, (u16 )64780, & wlan->mfi_pri_sup);
#line 1054
  get_range(dev, (u16 )64781, & wlan->cfi_pri_sup);
#line 1055
  get_range(dev, (u16 )64801, & wlan->sta_sup);
#line 1056
  get_range(dev, (u16 )64802, & wlan->mfi_sta_act);
#line 1057
  get_range(dev, (u16 )64772, & wlan->cfi_sta_act);
  }
#line 1059
  return (0);
}
}
#line 1063 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void show_wlan(struct wlan_info *wlan ) 
{ 
  int i ;
  int j ;

  {
#line 1065
  if (verbose) {
    {
#line 1066
    printf((char const   */* __restrict  */)"Wireless LAN card information:\n");
#line 1067
    printf((char const   */* __restrict  */)"Components:\n");
#line 1068
    printf((char const   */* __restrict  */)"  NICID: 0x%04x v%u.%u.%u\n", wlan->nicid.platform,
           wlan->nicid.major, wlan->nicid.minor, wlan->nicid.variant);
#line 1071
    printf((char const   */* __restrict  */)"  PRIID: 0x%04x v%u.%u.%u\n", wlan->priid.platform,
           wlan->priid.major, wlan->priid.minor, wlan->priid.variant);
#line 1074
    printf((char const   */* __restrict  */)"  STAID: 0x%04x v%u.%u.%u\n", wlan->staid.platform,
           wlan->staid.major, wlan->staid.minor, wlan->staid.variant);
#line 1078
    printf((char const   */* __restrict  */)"Interface compatibility information:\n");
#line 1079
    show_compatibility(& wlan->mfi_pri_sup, "PRI ");
#line 1080
    show_compatibility(& wlan->cfi_pri_sup, "PRI ");
#line 1081
    show_compatibility(& wlan->pri_sup, "PRI ");
#line 1082
    show_compatibility(& wlan->sta_sup, "STA ");
#line 1083
    show_compatibility(& wlan->cfi_pri_act, "PRI ");
#line 1084
    show_compatibility(& wlan->cfi_sta_act, "STA ");
#line 1085
    show_compatibility(& wlan->mfi_sta_act, "STA ");
    }
  }
#line 1088
  if (verbose > 1) {
#line 1090
    i = 0;
    {
#line 1090
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1090
      if (! (i < wlan->pda.pdr_count)) {
#line 1090
        goto while_break;
      }
      {
#line 1091
      printf((char const   */* __restrict  */)"PDR 0x%04x len=%i:", (wlan->pda.pdrs + i)->pdr,
             (wlan->pda.pdrs + i)->len);
#line 1093
      j = 0;
      }
      {
#line 1093
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1093
        if (! ((unsigned int )j < (wlan->pda.pdrs + i)->len)) {
#line 1093
          goto while_break___0;
        }
        {
#line 1094
        printf((char const   */* __restrict  */)" %02x", (int )*((wlan->pda.pdrs + i)->data + j));
#line 1093
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1095
      printf((char const   */* __restrict  */)"\n");
#line 1090
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1098
  return;
}
}
#line 1101 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void free_wlan(struct wlan_info *wlan ) 
{ 


  {
#line 1103
  if (wlan->pda.pdrs) {
    {
#line 1104
    free((void *)wlan->pda.pdrs);
    }
  }
#line 1105
  return;
}
}
#line 1108 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
unsigned char *get_s3_data_pos(struct srec_data *srec , unsigned int addr , unsigned int len ) 
{ 
  int i ;
  struct s3_record *s ;

  {
#line 1113
  i = 0;
  {
#line 1113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1113
    if (! (i < srec->s3_used)) {
#line 1113
      goto while_break;
    }
#line 1114
    s = srec->s3_records + i;
#line 1116
    if (s->addr <= addr) {
#line 1116
      if (s->addr + (unsigned int )s->len > addr) {
#line 1117
        if ((unsigned int )s->len - (addr - s->addr) < len) {
          {
#line 1118
          printf((char const   */* __restrict  */)"Plug record (addr=0x%08x, len=%u) not within data area\n",
                 addr, len);
          }
#line 1121
          return ((unsigned char *)((void *)0));
        }
#line 1123
        return (s->data + (addr - s->addr));
      }
    }
#line 1113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1127
  return ((unsigned char *)((void *)0));
}
}
#line 1131 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int supported_platform(struct s3_info_platform *nicid , struct srec_data *srec ,
                              int dl_mode ) 
{ 
  int i ;
  struct s3_info_platform *p ;
  struct s3_info_platform *p___0 ;

  {
#line 1136
  if (dl_mode == 3) {
#line 1136
    if (skip_pda_read) {
#line 1141
      return (1);
    } else
#line 1136
    if (ignore_incompatible_interface) {
#line 1136
      if (srec->component.component == 21U) {
#line 1141
        return (1);
      }
    }
  }
#line 1144
  i = 0;
  {
#line 1144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1144
    if (! (i < srec->platform_count)) {
#line 1144
      goto while_break;
    }
#line 1145
    p = srec->platforms + i;
#line 1147
    if (p->platform == nicid->platform) {
#line 1147
      if (p->major == nicid->major) {
#line 1147
        if (p->minor == nicid->minor) {
#line 1147
          if (p->variant == nicid->variant) {
#line 1151
            return (1);
          }
        }
      }
    }
#line 1144
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1156
  if (dl_mode == 2) {
#line 1157
    return (0);
  }
#line 1159
  i = 0;
  {
#line 1159
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1159
    if (! (i < srec->platform_count)) {
#line 1159
      goto while_break___0;
    }
#line 1160
    p___0 = srec->platforms + i;
#line 1166
    if (nicid->platform == 32776U) {
#line 1166
      if (nicid->major == 1U) {
#line 1166
        if (nicid->minor == 0U) {
#line 1166
          if (nicid->variant == 1U) {
#line 1166
            if (p___0->platform == 32776U) {
#line 1166
              if (p___0->major == 1U) {
#line 1166
                if (p___0->minor == 0U) {
#line 1166
                  if (p___0->variant == 0U) {
                    {
#line 1170
                    printf((char const   */* __restrict  */)"Exact NICID was not found from the list of supported platforms, but an\nalternative that has been reported to work was found.\n");
                    }
#line 1173
                    return (1);
                  }
                }
              }
            }
          }
        }
      }
    }
#line 1159
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1177
  return (0);
}
}
#line 1181 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int verify_compatibility(struct wlan_info *wlan , struct srec_data *srec , struct s3_info_compatibility *pri_sup ,
                         int image2 , int dl_mode ) 
{ 
  int i ;
  struct s3_info_compatibility *sr ;
  struct s3_info_compatibility *wr ;

  {
#line 1187
  if (dl_mode == 3) {
#line 1187
    if (skip_pda_read) {
#line 1189
      return (0);
    }
  }
#line 1192
  i = 0;
  {
#line 1192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1192
    if (! (i < srec->compatibility_count)) {
#line 1192
      goto while_break;
    }
#line 1194
    sr = srec->compatibilities + i;
#line 1195
    if (sr->role == 0U) {
#line 1196
      goto __Cont;
    }
#line 1197
    if (sr->role != 1U) {
      {
#line 1198
      printf((char const   */* __restrict  */)"Unknown interface compatibility role %d\n",
             sr->role);
      }
#line 1200
      return (1);
    }
    {
#line 1204
    if (sr->iface_id == 1U) {
#line 1204
      goto case_1;
    }
#line 1205
    if (sr->iface_id == 2U) {
#line 1205
      goto case_2;
    }
#line 1206
    if (sr->iface_id == 3U) {
#line 1206
      goto case_3;
    }
#line 1207
    if (sr->iface_id == 4U) {
#line 1207
      goto case_4;
    }
#line 1208
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1204
    wr = & wlan->mfi_pri_sup;
#line 1204
    goto switch_break;
    case_2: /* CIL Label */ 
#line 1205
    wr = & wlan->cfi_pri_sup;
#line 1205
    goto switch_break;
    case_3: /* CIL Label */ 
#line 1206
    wr = pri_sup;
#line 1206
    goto switch_break;
    case_4: /* CIL Label */ 
#line 1207
    wr = & wlan->sta_sup;
#line 1207
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1209
    printf((char const   */* __restrict  */)"Unknown interface compatibility id %d\n",
           sr->iface_id);
    }
#line 1211
    return (1);
    switch_break: /* CIL Label */ ;
    }
#line 1216
    if (! image2) {
#line 1216
      goto _L___1;
    } else
#line 1216
    if (sr->iface_id != 3U) {
      _L___1: /* CIL Label */ 
#line 1216
      if (sr->variant != wr->variant) {
#line 1216
        goto _L;
      } else {
#line 1216
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1216
    if (sr->top < wr->bottom) {
#line 1216
      goto _L;
    } else
#line 1216
    if (sr->bottom > wr->top) {
      _L: /* CIL Label */ 
      {
#line 1219
      printf((char const   */* __restrict  */)"Incompatible interfaces:\n");
#line 1220
      show_compatibility(sr, "SREC: ");
#line 1221
      show_compatibility(wr, "card: ");
      }
#line 1222
      if (ignore_incompatible_interface) {
        {
#line 1223
        printf((char const   */* __restrict  */)"Ignoring incompatibility\n");
        }
      } else {
#line 1225
        return (1);
      }
    }
    __Cont: /* CIL Label */ 
#line 1192
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1229
  return (0);
}
}
#line 1233 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static int plug_pdr_0400(char const   *ifname , u8 *pdr ) 
{ 
  int ram16 ;
  int pci ;
  int len ;
  char fname[256] ;
  char buf___0[1024] ;
  char *pos ;
  char *pos2 ;
  char *end ;
  FILE *f ;
  size_t tmp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 1235
  ram16 = -1;
#line 1235
  pci = -1;
#line 1239
  snprintf((char */* __restrict  */)(fname), sizeof(fname), (char const   */* __restrict  */)"/proc/net/hostap/%s/debug",
           ifname);
#line 1240
  f = fopen((char const   */* __restrict  */)(fname), (char const   */* __restrict  */)"r");
  }
#line 1241
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 1242
    printf((char const   */* __restrict  */)"Failed to open \'%s\' for reading.\n",
           fname);
    }
#line 1243
    return (-1);
  }
  {
#line 1246
  tmp = fread((void */* __restrict  */)(buf___0), (size_t )1, sizeof(buf___0) - 1UL,
              (FILE */* __restrict  */)f);
#line 1246
  len = (int )tmp;
  }
#line 1247
  if (len < 0) {
    {
#line 1248
    printf((char const   */* __restrict  */)"Failed to read \'%s\' for reading.\n",
           fname);
    }
#line 1249
    return (-1);
  }
#line 1252
  buf___0[len] = (char )'\000';
#line 1253
  pos = buf___0;
#line 1254
  end = buf___0 + len;
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if (! ((unsigned long )pos < (unsigned long )end)) {
#line 1255
      goto while_break;
    }
    {
#line 1256
    pos2 = strchr((char const   *)pos, '\n');
    }
#line 1257
    if (pos2) {
#line 1258
      *pos2 = (char )'\000';
    }
    {
#line 1260
    tmp___3 = strncmp((char const   *)pos, "pci=", (size_t )4);
    }
#line 1260
    if (tmp___3 == 0) {
      {
#line 1261
      pci = atoi((char const   *)(pos + 4));
      }
    } else {
      {
#line 1262
      tmp___2 = strncmp((char const   *)pos, "sram_type=", (size_t )10);
      }
#line 1262
      if (tmp___2 == 0) {
        {
#line 1263
        tmp___1 = atoi((char const   *)(pos + 10));
        }
#line 1263
        if (tmp___1 == 0) {
#line 1263
          ram16 = 0;
        } else {
#line 1263
          ram16 = 1;
        }
      }
    }
#line 1266
    if ((unsigned long )pos2 == (unsigned long )((void *)0)) {
#line 1267
      goto while_break;
    }
#line 1268
    pos = pos2 + 1;
  }
  while_break: /* CIL Label */ ;
  }
#line 1271
  if (pci == -1) {
    {
#line 1272
    printf((char const   */* __restrict  */)"Failed to parse \'pci\' or \'sram_type\' from %s.\n",
           fname);
    }
#line 1274
    return (-1);
  } else
#line 1271
  if (ram16 == -1) {
    {
#line 1272
    printf((char const   */* __restrict  */)"Failed to parse \'pci\' or \'sram_type\' from %s.\n",
           fname);
    }
#line 1274
    return (-1);
  }
#line 1277
  if (pci) {
#line 1277
    tmp___4 = 1 << 2;
  } else {
#line 1277
    tmp___4 = 0;
  }
#line 1277
  if (ram16) {
#line 1277
    tmp___5 = 1 << 1;
  } else {
#line 1277
    tmp___5 = 0;
  }
  {
#line 1277
  *(pdr + 0) = (u8 )((tmp___4 | tmp___5) | 1);
#line 1278
  *(pdr + 1) = (u8 )0;
#line 1279
  printf((char const   */* __restrict  */)"Plugging PDR 0400 (NIC configuration): ram16=%d pci=%d (%02x %02x)\n",
         ram16, pci, (int )*(pdr + 0), (int )*(pdr + 1));
  }
#line 1282
  return (0);
}
}
#line 1286 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int plug_pdr_entries(struct wlan_info *wlan , struct srec_data *srec ) 
{ 
  int i ;
  int j ;
  int found ;
  struct s3_plug_record *p ;
  unsigned char *pos ;
  int len ;
  size_t tmp ;
  unsigned int tmp___0 ;
  int tmp___1 ;
  int j___0 ;

  {
#line 1290
  i = 0;
  {
#line 1290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1290
    if (! (i < srec->plug_count)) {
#line 1290
      goto while_break;
    }
#line 1291
    p = srec->plugs + i;
    {
#line 1293
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1293
      if (verbose) {
        {
#line 1293
        printf((char const   */* __restrict  */)"Plugging PDR 0x%04x at 0x%08x (len=%d)\n",
               p->pdr, p->plug_addr, p->plug_len);
        }
      }
#line 1293
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1295
    pos = get_s3_data_pos(srec, p->plug_addr, p->plug_len);
    }
#line 1296
    if ((unsigned long )pos == (unsigned long )((void *)0)) {
      {
#line 1297
      printf((char const   */* __restrict  */)"Could not find data position for plugging PDR 0x%04x at 0x%08x (len=%d)\n",
             p->pdr, p->plug_addr, p->plug_len);
      }
    }
#line 1302
    if (p->pdr == 4294967295U) {
#line 1307
      if ((unsigned long )pos == (unsigned long )((void *)0)) {
#line 1308
        return (1);
      }
      {
#line 1309
      memset((void *)pos, 0, (size_t )p->plug_len);
#line 1310
      tmp = strlen((char const   *)srec->name);
#line 1310
      len = (int )tmp;
      }
#line 1311
      if (p->plug_len > 0U) {
#line 1312
        if ((unsigned int )len > p->plug_len - 1U) {
#line 1312
          tmp___0 = p->plug_len - 1U;
        } else {
#line 1312
          tmp___0 = (unsigned int )len;
        }
        {
#line 1312
        memcpy((void */* __restrict  */)pos, (void const   */* __restrict  */)srec->name,
               (size_t )tmp___0);
        }
      }
#line 1315
      goto __Cont;
    }
#line 1318
    if (skip_pda_read) {
#line 1318
      if (p->pdr == 1024U) {
#line 1318
        if (p->plug_len == 2U) {
#line 1319
          if ((unsigned long )pos == (unsigned long )((void *)0)) {
#line 1320
            return (1);
          }
          {
#line 1321
          tmp___1 = plug_pdr_0400(wlan->ifname, pos);
          }
#line 1321
          if (tmp___1) {
#line 1322
            return (1);
          }
#line 1323
          goto __Cont;
        }
      }
    }
#line 1326
    found = 0;
#line 1327
    j = 0;
    {
#line 1327
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1327
      if (! (j < wlan->pda.pdr_count)) {
#line 1327
        goto while_break___1;
      }
#line 1328
      if ((wlan->pda.pdrs + j)->pdr == p->pdr) {
#line 1329
        if ((wlan->pda.pdrs + j)->len != p->plug_len) {
          {
#line 1330
          printf((char const   */* __restrict  */)"Plug record length mismatch (PDR=0x%04x): %i != %i\n",
                 p->pdr, (wlan->pda.pdrs + j)->len, p->plug_len);
          }
#line 1334
          if (ignore_incompatible_interface) {
            {
#line 1335
            printf((char const   */* __restrict  */)"==> use default\n");
            }
#line 1336
            goto while_break___1;
          } else
#line 1337
          if (p->pdr == 1U) {
#line 1337
            if ((wlan->pda.pdrs + j)->len < p->plug_len) {
              {
#line 1344
              printf((char const   */* __restrict  */)"==> extend from default\n");
              }
            } else {
#line 1347
              return (1);
            }
          } else {
#line 1347
            return (1);
          }
        }
#line 1349
        if ((unsigned long )pos == (unsigned long )((void *)0)) {
#line 1350
          return (1);
        }
        {
#line 1351
        memcpy((void */* __restrict  */)pos, (void const   */* __restrict  */)(wlan->pda.pdrs + j)->data,
               (size_t )(wlan->pda.pdrs + j)->len);
#line 1353
        found = 1;
        }
#line 1354
        goto while_break___1;
      }
#line 1327
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1357
    if (! found) {
#line 1357
      if ((unsigned long )pos == (unsigned long )((void *)0)) {
        {
#line 1358
        printf((char const   */* __restrict  */)"PDR 0x%04x is not in wlan card PDA and there is no default data. Ignoring plug record.\n",
               p->pdr);
        }
#line 1361
        goto __Cont;
      }
    }
#line 1363
    if (! found) {
#line 1363
      if (verbose) {
        {
#line 1365
        printf((char const   */* __restrict  */)"PDR 0x%04x not found from wlan card PDA. Using default data.\n  len=%i:",
               p->pdr, p->plug_len);
#line 1368
        j___0 = 0;
        }
        {
#line 1368
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 1368
          if (! ((unsigned int )j___0 < p->plug_len)) {
#line 1368
            goto while_break___2;
          }
          {
#line 1369
          printf((char const   */* __restrict  */)" %02x", (int )*(pos + j___0));
#line 1368
          j___0 ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 1370
        printf((char const   */* __restrict  */)"\n");
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 1290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1374
  return (0);
}
}
#line 1378 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int generate_crc16(struct srec_data *srec ) 
{ 
  int i ;
  int j ;
  int found ;
  struct s3_crc16 *c ;
  struct s3_record *s ;
  void *tmp ;

  {
#line 1382
  i = 0;
  {
#line 1382
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1382
    if (! (i < srec->crc16_count)) {
#line 1382
      goto while_break;
    }
#line 1383
    c = srec->crc16 + i;
#line 1384
    if (c->prog) {
#line 1385
      s = (struct s3_record *)((void *)0);
      {
#line 1386
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1386
        if (verbose) {
          {
#line 1386
          printf((char const   */* __restrict  */)"Generating CRC-16 (start=0x%08x, len=%d) at 0x%08x\n",
                 c->start, c->len, c->start - 2U);
          }
        }
#line 1386
        goto while_break___0;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1393
      found = 0;
#line 1394
      j = 0;
      {
#line 1394
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1394
        if (! (j < srec->s3_used)) {
#line 1394
          goto while_break___1;
        }
#line 1395
        s = srec->s3_records + j;
#line 1396
        if (s->addr == c->start) {
#line 1397
          found = 1;
#line 1398
          goto while_break___1;
        }
#line 1394
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1401
      if (! found) {
        {
#line 1402
        printf((char const   */* __restrict  */)"Could not find proper place for CRC-16\n");
        }
#line 1404
        return (1);
      }
      {
#line 1407
      tmp = realloc((void *)s->data, (size_t )(s->len + 2));
#line 1407
      s->data = (unsigned char *)tmp;
      }
#line 1408
      if (! ((unsigned long )s->data != (unsigned long )((void *)0))) {
        {
#line 1408
        __assert_fail("s->data != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c",
                      1408U, "generate_crc16");
        }
      }
      {
#line 1409
      memmove((void *)(s->data + 2), (void const   *)s->data, (size_t )s->len);
#line 1410
      s->addr -= 2U;
#line 1411
      s->len += 2;
#line 1412
      *(s->data + 0) = (unsigned char)222;
#line 1413
      *(s->data + 1) = (unsigned char)192;
      }
    }
#line 1382
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1417
  return (0);
}
}
#line 1424 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int combine_info(struct wlan_info *wlan , struct srec_data *srec , struct srec_data *srec2 ,
                 int dl_mode ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  struct s3_info_compatibility *pri_sup ;
  int i ;
  struct s3_info_compatibility *sr ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 1427
  tmp = supported_platform(& wlan->nicid, srec, dl_mode);
  }
#line 1427
  if (! tmp) {
    {
#line 1428
    printf((char const   */* __restrict  */)"NICID was not found from the list of supported platforms.\n");
    }
#line 1430
    return (1);
  }
  {
#line 1433
  tmp___0 = verify_compatibility(wlan, srec, & wlan->pri_sup, 0, dl_mode);
  }
#line 1433
  if (tmp___0) {
#line 1436
    return (1);
  } else {
    {
#line 1433
    tmp___1 = plug_pdr_entries(wlan, srec);
    }
#line 1433
    if (tmp___1) {
#line 1436
      return (1);
    } else {
      {
#line 1433
      tmp___2 = generate_crc16(srec);
      }
#line 1433
      if (tmp___2) {
#line 1436
        return (1);
      }
    }
  }
#line 1438
  if (srec2) {
#line 1439
    pri_sup = & wlan->pri_sup;
#line 1442
    i = 0;
    {
#line 1442
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1442
      if (! (i < srec->compatibility_count)) {
#line 1442
        goto while_break;
      }
#line 1444
      sr = srec->compatibilities + i;
#line 1445
      if (sr->role == 0U) {
#line 1445
        if (sr->iface_id == 3U) {
          {
#line 1447
          printf((char const   */* __restrict  */)"PRI: old iface %d:%d-%d new iface %d:%d-%d\n",
                 pri_sup->variant, pri_sup->bottom, pri_sup->top, sr->variant, sr->bottom,
                 sr->top);
#line 1452
          pri_sup = sr;
          }
#line 1453
          goto while_break;
        }
      }
#line 1442
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1457
    tmp___3 = supported_platform(& wlan->nicid, srec2, dl_mode);
    }
#line 1457
    if (tmp___3) {
      {
#line 1457
      tmp___4 = verify_compatibility(wlan, srec2, pri_sup, 1, dl_mode);
      }
#line 1457
      if (tmp___4) {
        {
#line 1461
        printf((char const   */* __restrict  */)"Compatibility verification failed for the second image.\n");
        }
#line 1463
        return (1);
      } else {
        {
#line 1457
        tmp___5 = plug_pdr_entries(wlan, srec2);
        }
#line 1457
        if (tmp___5) {
          {
#line 1461
          printf((char const   */* __restrict  */)"Compatibility verification failed for the second image.\n");
          }
#line 1463
          return (1);
        } else {
          {
#line 1457
          tmp___6 = generate_crc16(srec2);
          }
#line 1457
          if (tmp___6) {
            {
#line 1461
            printf((char const   */* __restrict  */)"Compatibility verification failed for the second image.\n");
            }
#line 1463
            return (1);
          }
        }
      }
    } else {
      {
#line 1461
      printf((char const   */* __restrict  */)"Compatibility verification failed for the second image.\n");
      }
#line 1463
      return (1);
    }
    {
#line 1466
    tmp___7 = merge_s3_data(srec, srec2);
    }
#line 1466
    if (tmp___7) {
      {
#line 1467
      printf((char const   */* __restrict  */)"Failed to merge firmware images for downloading.\n");
      }
#line 1469
      return (1);
    }
  }
#line 1473
  if (dl_mode == 1) {
#line 1473
    goto _L;
  } else
#line 1473
  if (dl_mode == 3) {
    _L: /* CIL Label */ 
#line 1473
    if (srec->start_addr == 0U) {
      {
#line 1475
      printf((char const   */* __restrict  */)"\nThis image is not meant to be downloaded to volatile memory.\n");
      }
#line 1477
      return (1);
    }
  }
#line 1480
  if (dl_mode == 2) {
#line 1480
    if (srec->start_addr != 0U) {
      {
#line 1481
      printf((char const   */* __restrict  */)"\nThis image is not meant to be downloaded to non-volatile memory.\n");
      }
#line 1483
      return (1);
    }
  }
#line 1486
  return (0);
}
}
#line 1490 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void dump_s3_data(struct srec_data *srec , char const   *fname ) 
{ 
  FILE *f ;
  int i ;

  {
  {
#line 1495
  f = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 1496
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1497
    return;
  }
  {
#line 1499
  printf((char const   */* __restrict  */)"Writing image dump into \'%s\'\n", fname);
#line 1501
  i = 0;
  }
  {
#line 1501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1501
    if (! (i < srec->s3_used)) {
#line 1501
      goto while_break;
    }
    {
#line 1502
    fseek(f, (long )(srec->s3_records + i)->addr, 0);
#line 1503
    fwrite((void const   */* __restrict  */)(srec->s3_records + i)->data, (size_t )(srec->s3_records + i)->len,
           (size_t )1, (FILE */* __restrict  */)f);
#line 1501
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1507
  fclose(f);
  }
#line 1508
  return;
}
}
#line 1511 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
int download_srec(char const   *iface , struct srec_data *srec , int non_volatile ,
                  int genesis , int persistent ) 
{ 
  struct prism2_download_param *param ;
  int plen ;
  int i ;
  int ret ;
  int s ;
  unsigned int total_len ;
  struct iwreq iwr ;
  void *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1515
  ret = 0;
#line 1515
  s = -1;
#line 1519
  plen = (int )(sizeof(struct prism2_download_param ) + (unsigned long )srec->s3_used * sizeof(struct prism2_download_area ));
#line 1521
  tmp = malloc((size_t )plen);
#line 1521
  param = (struct prism2_download_param *)tmp;
  }
#line 1522
  if (! ((unsigned long )param != (unsigned long )((void *)0))) {
    {
#line 1522
    __assert_fail("param != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c",
                  1522U, "download_srec");
    }
  }
  {
#line 1523
  memset((void *)param, 0, (size_t )plen);
  }
#line 1525
  if (non_volatile) {
#line 1526
    param->dl_cmd = (u32 )3;
  } else
#line 1527
  if (genesis) {
#line 1527
    if (persistent) {
#line 1528
      param->dl_cmd = (u32 )6;
    } else {
#line 1527
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1529
  if (genesis) {
#line 1530
    param->dl_cmd = (u32 )4;
  } else
#line 1531
  if (persistent) {
#line 1532
    param->dl_cmd = (u32 )5;
  } else {
#line 1534
    param->dl_cmd = (u32 )1;
  }
#line 1536
  param->start_addr = srec->start_addr;
#line 1537
  param->num_areas = (u32 )srec->s3_used;
#line 1539
  total_len = 0U;
#line 1540
  i = 0;
  {
#line 1540
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1540
    if (! (i < srec->s3_used)) {
#line 1540
      goto while_break;
    }
#line 1541
    if ((srec->s3_records + i)->len > 131072) {
      {
#line 1542
      printf((char const   */* __restrict  */)"Too large data area.\n");
#line 1543
      ret = 1;
      }
#line 1544
      goto out;
    }
#line 1546
    param->data[i].addr = (srec->s3_records + i)->addr;
#line 1547
    param->data[i].len = (u32 )(srec->s3_records + i)->len;
#line 1548
    param->data[i].ptr = (caddr_t )(srec->s3_records + i)->data;
#line 1549
    total_len += (unsigned int )(srec->s3_records + i)->len;
#line 1540
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1551
  if (total_len > 262144U) {
    {
#line 1552
    printf((char const   */* __restrict  */)"Too large total download length.\n");
#line 1553
    ret = 1;
    }
#line 1554
    goto out;
  }
  {
#line 1557
  s = socket(2, 2, 0);
  }
#line 1558
  if (s < 0) {
    {
#line 1559
    perror("socket");
#line 1560
    ret = 1;
    }
#line 1561
    goto out;
  }
  {
#line 1564
  memset((void *)(& iwr), 0, sizeof(iwr));
#line 1565
  strncpy((char */* __restrict  */)(iwr.ifr_ifrn.ifrn_name), (char const   */* __restrict  */)iface,
          (size_t )16);
#line 1566
  iwr.u.data.pointer = (void *)((caddr_t )param);
#line 1567
  iwr.u.data.length = (__u16 )plen;
#line 1569
  tmp___1 = ioctl(s, 35325UL, & iwr);
  }
#line 1569
  if (tmp___1 < 0) {
    {
#line 1570
    tmp___0 = __errno_location();
    }
#line 1570
    if (*tmp___0 == 95) {
      {
#line 1573
      printf((char const   */* __restrict  */)"Odd.. Download request for the kernel driver failed.\nAre you sure you have compiled (and loaded the correct version of)\nhostap.o module with PRISM2_DOWNLOAD_SUPPORT definition in\ndriver/module/hostap_config.h?\n");
      }
#line 1580
      if (non_volatile) {
        {
#line 1581
        printf((char const   */* __restrict  */)"In addition, non-volatile download requires PRISM2_NON_VOLATILE_DOWNLOAD\nto be defined.\n");
        }
      }
    }
    {
#line 1586
    perror("ioctl[PRISM2_IOCTL_DOWNLOAD]");
#line 1587
    ret = 1;
    }
#line 1588
    goto out;
  }
  out: 
#line 1592
  if (s >= 0) {
    {
#line 1593
    close(s);
    }
  }
  {
#line 1594
  free((void *)param);
  }
#line 1595
  return (ret);
}
}
#line 1599 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static void pdr_compid_to_info(struct s3_info_platform *p , unsigned char *data ) 
{ 
  struct pdr_compid *comp ;

  {
#line 1602
  comp = (struct pdr_compid *)data;
#line 1603
  p->platform = (unsigned int )comp->id;
#line 1604
  p->major = (unsigned int )comp->major;
#line 1605
  p->minor = (unsigned int )comp->minor;
#line 1606
  p->variant = (unsigned int )comp->variant;
#line 1607
  return;
}
}
#line 1610 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static void pdr_range_to_info(struct s3_info_compatibility *r , unsigned char *data ) 
{ 
  struct pdr_supplier_range *range ;

  {
#line 1613
  range = (struct pdr_supplier_range *)data;
#line 1614
  r->role = (unsigned int )range->role;
#line 1615
  r->iface_id = (unsigned int )range->iface_id;
#line 1616
  r->variant = (unsigned int )range->variant;
#line 1617
  r->bottom = (unsigned int )range->bottom;
#line 1618
  r->top = (unsigned int )range->top;
#line 1619
  return;
}
}
#line 1622 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static void compat_from_pda(struct wlan_info *wlan ) 
{ 
  int i ;

  {
#line 1626
  i = 0;
  {
#line 1626
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1626
    if (! (i < wlan->pda.pdr_count)) {
#line 1626
      goto while_break;
    }
    {
#line 1628
    if ((wlan->pda.pdrs + i)->pdr == 6U) {
#line 1628
      goto case_6;
    }
#line 1634
    if ((wlan->pda.pdrs + i)->pdr == 7U) {
#line 1634
      goto case_7;
    }
#line 1640
    if ((wlan->pda.pdrs + i)->pdr == 8U) {
#line 1640
      goto case_8;
    }
#line 1627
    goto switch_break;
    case_6: /* CIL Label */ 
#line 1629
    if ((unsigned long )(wlan->pda.pdrs + i)->len == sizeof(struct pdr_supplier_range )) {
      {
#line 1631
      pdr_range_to_info(& wlan->mfi_pri_sup, (wlan->pda.pdrs + i)->data);
      }
    }
#line 1633
    goto switch_break;
    case_7: /* CIL Label */ 
#line 1635
    if ((unsigned long )(wlan->pda.pdrs + i)->len == sizeof(struct pdr_supplier_range )) {
      {
#line 1637
      pdr_range_to_info(& wlan->cfi_pri_sup, (wlan->pda.pdrs + i)->data);
      }
    }
#line 1639
    goto switch_break;
    case_8: /* CIL Label */ 
#line 1641
    if ((unsigned long )(wlan->pda.pdrs + i)->len == sizeof(struct pdr_compid )) {
      {
#line 1643
      pdr_compid_to_info(& wlan->nicid, (wlan->pda.pdrs + i)->data);
      }
    }
#line 1645
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 1626
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1648
  return;
}
}
#line 1651 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
static void dump_pda_data(struct prism2_pda *pda ) 
{ 
  int i ;
  int j ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 1655
  i = 0;
  {
#line 1655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1655
    if (! (i < pda->pdr_count)) {
#line 1655
      goto while_break;
    }
#line 1656
    if ((pda->pdrs + i)->len & 1U) {
      {
#line 1657
      printf((char const   */* __restrict  */)"WARNING: odd PDR 0x%04x length (%d)\n",
             (pda->pdrs + i)->pdr, (pda->pdrs + i)->len);
      }
    }
    {
#line 1659
    tmp = prism2_pdr_name((int )(pda->pdrs + i)->pdr);
#line 1659
    printf((char const   */* __restrict  */)"; PDR 0x%04x data len=%i %s\n", (pda->pdrs + i)->pdr,
           (pda->pdrs + i)->len, tmp);
#line 1662
    printf((char const   */* __restrict  */)"%x %04x\n", (pda->pdrs + i)->len / 2U + 1U,
           (pda->pdrs + i)->pdr);
#line 1664
    j = 0;
    }
    {
#line 1664
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1664
      if (! ((unsigned int )j < (pda->pdrs + i)->len)) {
#line 1664
        goto while_break___0;
      }
#line 1665
      if (j == 0) {
#line 1665
        tmp___0 = "";
      } else {
#line 1665
        tmp___0 = " ";
      }
      {
#line 1665
      printf((char const   */* __restrict  */)"%s%02x%02x", tmp___0, (int )*((pda->pdrs + i)->data + (j + 1)),
             (int )*((pda->pdrs + i)->data + j));
#line 1664
      j += 2;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1667
    printf((char const   */* __restrict  */)"\n");
#line 1655
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1669
  return;
}
}
#line 1672 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/prism2_srec.c"
void usage(void) 
{ 


  {
  {
#line 1674
  printf((char const   */* __restrict  */)"Firmware image downloader for Host AP driver\n  (for Intersil Prism2/2.5/3 cards)\nCopyright (c) 2002-2004, Jouni Malinen <jkmaline@cc.hut.fi>\n\nUsage:\n  prism2_srec [-vvrgfdpisD] [-P <PDA file>] [-O <PDA binary>] <interface> \\\n              <srec file name> [srec file name]\nOptions:\n  -v   verbose (add another for more verbosity\n  -r   download SREC file into RAM (volatile)\n  -g   download SREC file into RAM (volatile in Genesis mode)\n  -f   download SREC file into flash (non-volatile)\n  -d   dump SREC image into prism2_srec.dump\n  -p   persistent mode for volatile download\n  -i   ignore incompatible interfaces errors\n       Warning! This can result in failed upgrade!\n  -s   Skip PDA reading and use defaults from the firmware image\n  -D   Dump PDA in text format (this can be used without srec file)\n  -P <PDA file>   Override card PDA (with a PDA file in text format)\n       Warning! This can result in failed upgrade!\n  -O <PDA binary>   Override procfs path for binary PDA\n       Warning! This can result in failed upgrade!\n\nOptions -r, -g, and -f cannot be used together.\nIf -r, -g, or -f is not specified, image summary is shown and\ncompatibility with WLAN card is verified without downloading\nanything.\n");
#line 1708
  exit(1);
  }
}
}
#line 30 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static struct hostap_nicid_rec hostap_nicids___1[29]  = 
#line 30 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
  {      {(u16 )32768, (char *)"EVB2 (HFA3841EVAL1) with PRISM I (3860B) Radio"}, 
        {(u16 )32769, (char *)"HWB3763 Rev B"}, 
        {(u16 )32770, (char *)"HWB3163-01,02,03,04 Rev A"}, 
        {(u16 )32771, (char *)"HWB3163 Rev B, Samsung PC Card Rev. B"}, 
        {(u16 )32772, (char *)"EVB3 (HFA3843EVAL1, Rev B1)"}, 
        {(u16 )32774, (char *)"Nortel Sputnik I"}, 
        {(u16 )32775, (char *)"HWB1153 PRISM I Ref"}, 
        {(u16 )32776, (char *)"HWB3163, Prism II reference with SSF Flash"}, 
        {(u16 )32778, (char *)"3842 Evaluation Board"}, 
        {(u16 )32779, (char *)"PRISM II (2.5) PCMCIA (AMD parallel flash)"}, 
        {(u16 )32780, (char *)"PRISM II (2.5) PCMCIA (SST parallel flash)"}, 
        {(u16 )32781, (char *)"PRISM II (2.5) PCMCIA (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32782,
      (char *)"PRISM II (2.5) PCMCIA (AT24C08 compatible small serial flash)"}, 
        {(u16 )32786, (char *)"PRISM II (2.5) Mini-PCI (AMD parallel flash)"}, 
        {(u16 )32787, (char *)"PRISM II (2.5) Mini-PCI (SST parallel flash)"}, 
        {(u16 )32788, (char *)"PRISM II (2.5) Mini-PCI (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32789,
      (char *)"PRISM II (2.5) Mini-PCI (AT24C08 compatible small serial flash)"}, 
        {(u16 )32790, (char *)"PCI-bridge (AMD parallel flash)"}, 
        {(u16 )32791, (char *)"PCI-bridge (SST parallel flash)"}, 
        {(u16 )32792, (char *)"PCI-bridge (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32793,
      (char *)"PCI-bridge (AT24C08 compatible small serial flash)"}, 
        {(u16 )32794, (char *)"PRISM III PCMCIA (AMD parallel flash)"}, 
        {(u16 )32795, (char *)"PRISM III PCMCIA (SST parallel flash)"}, 
        {(u16 )32796, (char *)"PRISM III PCMCIA (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32797,
      (char *)"PRISM III PCMCIA (AT24C08 compatible small serial flash)"}, 
        {(u16 )32801, (char *)"PRISM III Mini-PCI (AMD parallel flash)"}, 
        {(u16 )32802, (char *)"PRISM III Mini-PCI (SST parallel flash)"}, 
        {(u16 )32803, (char *)"PRISM III Mini-PCI (AT45DB011 compatible large serial flash)"}, 
        {(u16 )32804,
      (char *)"PRISM III Mini-PCI (AT24C08 compatible small serial flash)"}};
#line 258 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static u16 const   crc16_table___1[256]  = 
#line 258
  {      (u16 const   )0,      (u16 const   )49345,      (u16 const   )49537,      (u16 const   )320, 
        (u16 const   )49921,      (u16 const   )960,      (u16 const   )640,      (u16 const   )49729, 
        (u16 const   )50689,      (u16 const   )1728,      (u16 const   )1920,      (u16 const   )51009, 
        (u16 const   )1280,      (u16 const   )50625,      (u16 const   )50305,      (u16 const   )1088, 
        (u16 const   )52225,      (u16 const   )3264,      (u16 const   )3456,      (u16 const   )52545, 
        (u16 const   )3840,      (u16 const   )53185,      (u16 const   )52865,      (u16 const   )3648, 
        (u16 const   )2560,      (u16 const   )51905,      (u16 const   )52097,      (u16 const   )2880, 
        (u16 const   )51457,      (u16 const   )2496,      (u16 const   )2176,      (u16 const   )51265, 
        (u16 const   )55297,      (u16 const   )6336,      (u16 const   )6528,      (u16 const   )55617, 
        (u16 const   )6912,      (u16 const   )56257,      (u16 const   )55937,      (u16 const   )6720, 
        (u16 const   )7680,      (u16 const   )57025,      (u16 const   )57217,      (u16 const   )8000, 
        (u16 const   )56577,      (u16 const   )7616,      (u16 const   )7296,      (u16 const   )56385, 
        (u16 const   )5120,      (u16 const   )54465,      (u16 const   )54657,      (u16 const   )5440, 
        (u16 const   )55041,      (u16 const   )6080,      (u16 const   )5760,      (u16 const   )54849, 
        (u16 const   )53761,      (u16 const   )4800,      (u16 const   )4992,      (u16 const   )54081, 
        (u16 const   )4352,      (u16 const   )53697,      (u16 const   )53377,      (u16 const   )4160, 
        (u16 const   )61441,      (u16 const   )12480,      (u16 const   )12672,      (u16 const   )61761, 
        (u16 const   )13056,      (u16 const   )62401,      (u16 const   )62081,      (u16 const   )12864, 
        (u16 const   )13824,      (u16 const   )63169,      (u16 const   )63361,      (u16 const   )14144, 
        (u16 const   )62721,      (u16 const   )13760,      (u16 const   )13440,      (u16 const   )62529, 
        (u16 const   )15360,      (u16 const   )64705,      (u16 const   )64897,      (u16 const   )15680, 
        (u16 const   )65281,      (u16 const   )16320,      (u16 const   )16000,      (u16 const   )65089, 
        (u16 const   )64001,      (u16 const   )15040,      (u16 const   )15232,      (u16 const   )64321, 
        (u16 const   )14592,      (u16 const   )63937,      (u16 const   )63617,      (u16 const   )14400, 
        (u16 const   )10240,      (u16 const   )59585,      (u16 const   )59777,      (u16 const   )10560, 
        (u16 const   )60161,      (u16 const   )11200,      (u16 const   )10880,      (u16 const   )59969, 
        (u16 const   )60929,      (u16 const   )11968,      (u16 const   )12160,      (u16 const   )61249, 
        (u16 const   )11520,      (u16 const   )60865,      (u16 const   )60545,      (u16 const   )11328, 
        (u16 const   )58369,      (u16 const   )9408,      (u16 const   )9600,      (u16 const   )58689, 
        (u16 const   )9984,      (u16 const   )59329,      (u16 const   )59009,      (u16 const   )9792, 
        (u16 const   )8704,      (u16 const   )58049,      (u16 const   )58241,      (u16 const   )9024, 
        (u16 const   )57601,      (u16 const   )8640,      (u16 const   )8320,      (u16 const   )57409, 
        (u16 const   )40961,      (u16 const   )24768,      (u16 const   )24960,      (u16 const   )41281, 
        (u16 const   )25344,      (u16 const   )41921,      (u16 const   )41601,      (u16 const   )25152, 
        (u16 const   )26112,      (u16 const   )42689,      (u16 const   )42881,      (u16 const   )26432, 
        (u16 const   )42241,      (u16 const   )26048,      (u16 const   )25728,      (u16 const   )42049, 
        (u16 const   )27648,      (u16 const   )44225,      (u16 const   )44417,      (u16 const   )27968, 
        (u16 const   )44801,      (u16 const   )28608,      (u16 const   )28288,      (u16 const   )44609, 
        (u16 const   )43521,      (u16 const   )27328,      (u16 const   )27520,      (u16 const   )43841, 
        (u16 const   )26880,      (u16 const   )43457,      (u16 const   )43137,      (u16 const   )26688, 
        (u16 const   )30720,      (u16 const   )47297,      (u16 const   )47489,      (u16 const   )31040, 
        (u16 const   )47873,      (u16 const   )31680,      (u16 const   )31360,      (u16 const   )47681, 
        (u16 const   )48641,      (u16 const   )32448,      (u16 const   )32640,      (u16 const   )48961, 
        (u16 const   )32000,      (u16 const   )48577,      (u16 const   )48257,      (u16 const   )31808, 
        (u16 const   )46081,      (u16 const   )29888,      (u16 const   )30080,      (u16 const   )46401, 
        (u16 const   )30464,      (u16 const   )47041,      (u16 const   )46721,      (u16 const   )30272, 
        (u16 const   )29184,      (u16 const   )45761,      (u16 const   )45953,      (u16 const   )29504, 
        (u16 const   )45313,      (u16 const   )29120,      (u16 const   )28800,      (u16 const   )45121, 
        (u16 const   )20480,      (u16 const   )37057,      (u16 const   )37249,      (u16 const   )20800, 
        (u16 const   )37633,      (u16 const   )21440,      (u16 const   )21120,      (u16 const   )37441, 
        (u16 const   )38401,      (u16 const   )22208,      (u16 const   )22400,      (u16 const   )38721, 
        (u16 const   )21760,      (u16 const   )38337,      (u16 const   )38017,      (u16 const   )21568, 
        (u16 const   )39937,      (u16 const   )23744,      (u16 const   )23936,      (u16 const   )40257, 
        (u16 const   )24320,      (u16 const   )40897,      (u16 const   )40577,      (u16 const   )24128, 
        (u16 const   )23040,      (u16 const   )39617,      (u16 const   )39809,      (u16 const   )23360, 
        (u16 const   )39169,      (u16 const   )22976,      (u16 const   )22656,      (u16 const   )38977, 
        (u16 const   )34817,      (u16 const   )18624,      (u16 const   )18816,      (u16 const   )35137, 
        (u16 const   )19200,      (u16 const   )35777,      (u16 const   )35457,      (u16 const   )19008, 
        (u16 const   )19968,      (u16 const   )36545,      (u16 const   )36737,      (u16 const   )20288, 
        (u16 const   )36097,      (u16 const   )19904,      (u16 const   )19584,      (u16 const   )35905, 
        (u16 const   )17408,      (u16 const   )33985,      (u16 const   )34177,      (u16 const   )17728, 
        (u16 const   )34561,      (u16 const   )18368,      (u16 const   )18048,      (u16 const   )34369, 
        (u16 const   )33281,      (u16 const   )17088,      (u16 const   )17280,      (u16 const   )33601, 
        (u16 const   )16640,      (u16 const   )33217,      (u16 const   )32897,      (u16 const   )16448};
#line 295 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int crc16___1(u8 *buf___0 , int len ) 
{ 
  u16 crc ;
  int i ;
  u8 *tmp ;

  {
#line 300
  crc = (u16 )0;
#line 301
  i = 0;
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    if (! (i < len)) {
#line 301
      goto while_break;
    }
#line 302
    tmp = buf___0;
#line 302
    buf___0 ++;
#line 302
    crc = (u16 )(((int )crc >> 8) ^ (int )crc16_table___1[((int )crc & 255) ^ (int )*tmp]);
#line 301
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 303
  return ((int )crc);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int parse_wlan_pda___1(struct prism2_pda *pda_info , int update_crc ) 
{ 
  int pos ;
  u16 *pda ;
  u16 len ;
  u16 pdr ;
  void *tmp ;
  int crc ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 311
  pda = (u16 *)(pda_info->pda_buf);
#line 312
  pos = 0;
  {
#line 313
  while (1) {
    while_continue: /* CIL Label */ ;
#line 313
    if (! (pos + 1 < 512)) {
#line 313
      goto while_break;
    }
#line 314
    len = *(pda + pos);
#line 315
    pdr = *(pda + (pos + 1));
#line 316
    if ((int )len == 0) {
      {
#line 317
      printf((char const   */* __restrict  */)"Invalid PDR 0x%04x len=%d\n", (int )pdr,
             (int )len);
      }
#line 318
      return (1);
    } else
#line 316
    if (pos + (int )len > 512) {
      {
#line 317
      printf((char const   */* __restrict  */)"Invalid PDR 0x%04x len=%d\n", (int )pdr,
             (int )len);
      }
#line 318
      return (1);
    }
    {
#line 321
    tmp = realloc((void *)pda_info->pdrs, (unsigned long )(pda_info->pdr_count + 1) * sizeof(struct prism2_pdr ));
#line 321
    pda_info->pdrs = (struct prism2_pdr *)tmp;
    }
#line 325
    if (! ((unsigned long )pda_info->pdrs != (unsigned long )((void *)0))) {
      {
#line 325
      __assert_fail("pda_info->pdrs != ((void *)0)", "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c",
                    325U, "parse_wlan_pda");
      }
    }
#line 326
    (pda_info->pdrs + pda_info->pdr_count)->pdr = (unsigned int )pdr;
#line 327
    (pda_info->pdrs + pda_info->pdr_count)->len = (unsigned int )(((int )len - 1) * 2);
#line 328
    (pda_info->pdrs + pda_info->pdr_count)->data = (unsigned char *)(pda + (pos + 2));
#line 330
    (pda_info->pdr_count) ++;
#line 332
    if ((int )pdr == 0) {
#line 332
      if ((int )len == 2) {
        {
#line 334
        tmp___1 = crc16___1((u8 *)(pda_info->pda_buf), (pos + 3) * 2);
        }
#line 334
        if (tmp___1 != 0) {
#line 335
          if (update_crc) {
            {
#line 336
            tmp___0 = crc16___1((u8 *)(pda_info->pda_buf), (pos + 2) * 2);
#line 336
            crc = tmp___0;
#line 338
            printf((char const   */* __restrict  */)"Updating PDA checksum to match with data (%04x -> %04x).\n",
                   (int )*(pda + (pos + 2)), crc);
#line 341
            *(pda + (pos + 2)) = (u16 )crc;
            }
          } else {
            {
#line 343
            printf((char const   */* __restrict  */)"PDA checksum incorrect.\n");
            }
#line 344
            return (1);
          }
        }
#line 347
        return (0);
      }
    }
#line 350
    pos += (int )len + 1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 353
  printf((char const   */* __restrict  */)"Could not find PDA end record.\n");
  }
#line 354
  return (1);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/hostap-utils-0.4.7/util.c"
static int get_next_word___1(FILE *f , char *linebuf , char **_pos ) 
{ 
  size_t len ;
  char *pos ;
  char *end ;
  char *pos2 ;
  int ret ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  long tmp___2 ;
  char *tmp___3 ;

  {
#line 387
  pos = *_pos;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 389
    tmp = __ctype_b_loc();
    }
#line 389
    if (! ((int const   )*(*tmp + (int )*pos) & 8192)) {
#line 389
      goto while_break;
    }
#line 390
    pos ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 391
  if ((int )*pos == 0) {
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 393
      tmp___0 = fgets((char */* __restrict  */)linebuf, 2048, (FILE */* __restrict  */)f);
      }
#line 393
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 394
        return (-1);
      }
      {
#line 395
      len = strcspn((char const   *)linebuf, ";/#");
#line 396
      *(linebuf + len) = (char )'\000';
#line 397
      pos = linebuf;
      }
      {
#line 398
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 398
        tmp___1 = __ctype_b_loc();
        }
#line 398
        if (! ((int const   )*(*tmp___1 + (int )*pos) & 8192)) {
#line 398
          goto while_break___1;
        }
#line 399
        pos ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 392
      if (! ((int )*pos == 0)) {
#line 392
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 401
    pos2 = pos;
    {
#line 402
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 402
      if (! ((int )*pos2 != 0)) {
#line 402
        goto while_break___2;
      }
#line 403
      if ((int )*pos2 == 44) {
#line 404
        *pos2 = (char )' ';
      }
#line 405
      pos2 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 409
  tmp___2 = strtol((char const   */* __restrict  */)pos, (char **/* __restrict  */)(& end),
                   16);
#line 409
  ret = (int )tmp___2;
  }
#line 410
  if ((unsigned long )end == (unsigned long )pos) {
    {
#line 411
    pos = linebuf;
#line 412
    printf((char const   */* __restrict  */)"Expected a hex number at position marked with *:\n");
    }
    {
#line 413
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 413
      if (! ((int )*pos != 0)) {
#line 413
        goto while_break___3;
      }
#line 414
      if ((unsigned long )pos == (unsigned long )end) {
        {
#line 415
        putchar('*');
        }
      }
      {
#line 416
      tmp___3 = pos;
#line 416
      pos ++;
#line 416
      putchar((int )*tmp___3);
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 418
    printf((char const   */* __restrict  */)"\n");
    }
#line 419
    return (-2);
  }
#line 421
  pos = end;
#line 422
  if ((unsigned long )pos >= (unsigned long )(linebuf + 2048)) {
#line 423
    pos = (linebuf + 2048) - 1;
  }
#line 424
  *_pos = pos;
#line 426
  return (ret);
}
}
