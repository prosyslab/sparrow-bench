/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.6/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 103 "prescan-overflow-bad.c"
typedef int bool;
#line 109
struct envelope;
#line 109 "prescan-overflow-bad.c"
typedef struct envelope ENVELOPE;
#line 114 "prescan-overflow-bad.c"
struct envelope {
   char *e_to ;
   ENVELOPE *e_parent ;
   char *e_macro[256] ;
};
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 111 "prescan-overflow-bad.c"
ENVELOPE *CurEnv  ;
#line 145 "prescan-overflow-bad.c"
static short StateTab[6][6]  = { {        (short)32,        (short)33,        (short)34,        (short)51, 
            (short)36,        (short)53}, 
   {        (short)32,        (short)1,        (short)34,        (short)51, 
            (short)36,        (short)53}, 
   {        (short)2,        (short)2,        (short)0,        (short)2, 
            (short)2,        (short)2}, 
   {        (short)0,        (short)1,        (short)2,        (short)19, 
            (short)4,        (short)53}, 
   {        (short)0,        (short)0,        (short)0,        (short)0, 
            (short)0,        (short)53}, 
   {        (short)32,        (short)33,        (short)34,        (short)51, 
            (short)36,        (short)21}};
#line 157 "prescan-overflow-bad.c"
static u_char TokTypeTab[256]  = 
#line 157
  {      (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )3,      (u_char )3,      (u_char )3, 
        (u_char )3,      (u_char )3,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )3,      (u_char )1,      (u_char )2,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )3,      (u_char )3,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )0,      (u_char )0,      (u_char )4,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )4, 
        (u_char )4,      (u_char )4,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1};
#line 195 "prescan-overflow-bad.c"
u_char TokTypeNoC[256]  = 
#line 195
  {      (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )3,      (u_char )3,      (u_char )3, 
        (u_char )3,      (u_char )3,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )3,      (u_char )1,      (u_char )2,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )0,      (u_char )0,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )0,      (u_char )0,      (u_char )4,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )4, 
        (u_char )4,      (u_char )4,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )0,      (u_char )0,      (u_char )0,      (u_char )0, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1, 
        (u_char )1,      (u_char )1,      (u_char )1,      (u_char )1};
#line 236 "prescan-overflow-bad.c"
char *OperatorChars  ;
#line 237 "prescan-overflow-bad.c"
int ConfigLevel  ;
#line 275 "prescan-overflow-bad.c"
char **prescan(char *addr , int delim , char *pvpbuf , int pvpbsize , char **delimptr ,
               u_char *toktab , char *canary ) 
{ 
  register char *p ;
  register char *q ;
  register int c ;
  bool bslashmode ;
  bool route_syntax ;
  int cmntcnt ;
  int anglecnt ;
  char *tok ;
  int state ;
  int newstate ;
  char *saveto ;
  int errno ;
  size_t tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *ptr ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;

  {
  {
#line 296
  saveto = CurEnv->e_to;
#line 302
  printf((char const   */* __restrict  */)"Inside prescan!!\n");
#line 303
  printf((char const   */* __restrict  */)"Max storage of pvpbuf = %d\n", 50);
  }
#line 306
  if ((unsigned long )toktab == (unsigned long )((void *)0)) {
#line 307
    toktab = TokTypeTab;
  }
#line 310
  errno = 0;
#line 312
  q = pvpbuf;
#line 313
  bslashmode = 0;
#line 314
  route_syntax = 0;
#line 315
  cmntcnt = 0;
#line 316
  anglecnt = 0;
#line 320
  state = 1;
#line 321
  c = -1;
#line 322
  p = addr;
#line 323
  CurEnv->e_to = p;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 328
    tok = q;    
    {
#line 329
    while (1) {    
      while_continue___0: /* CIL Label */ ;
#line 332
      if (c != -1) {
#line 332
        if (! bslashmode) { 
#line 336
          if ((unsigned long )q >= (unsigned long )(pvpbuf + (pvpbsize - 5))) {
            {
#line 338
            printf((char const   */* __restrict  */)"553 5.1.1 Address too long\n");
#line 340
            tmp = strlen((char const   *)addr);
            }
#line 340
            if (tmp > 40UL) {
              {    
#line 342
              printf((char const   */* __restrict  */)"strlen(addr) > %d\n", 40);
#line 343
              *(addr + 40) = (char )'\000';
              }
            }
            returnnull: 
#line 346
            if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 347
              *delimptr = p;
            }
#line 348
            CurEnv->e_to = saveto;
#line 349
            return ((char **)((void *)0));
          }
          {
#line 353
          printf((char const   */* __restrict  */)"Writing %c to q!\n", c);
#line 354
          tmp___0 = q;
#line 354
          q ++;
#line 354
          *tmp___0 = (char )c;
          }
        }
      }
#line 358
      tmp___1 = p;    
#line 358
      p ++;
#line 358
      c = (int )*tmp___1;
#line 359
      if (c == 0) {
#line 362
        if (state == 2) {
          {
#line 364
          printf((char const   */* __restrict  */)"653 Unbalanced \'\"\'");
#line 365
          c = '\"';
          }
        } else
#line 367
        if (cmntcnt > 0) {
          {
#line 369
          printf((char const   */* __restrict  */)"653 Unbalanced \'(\'");
#line 370
          c = ')';
          }
        } else
#line 372
        if (anglecnt > 0) {
          {
#line 374
          c = '>';
#line 375
          printf((char const   */* __restrict  */)"653 Unbalanced \'<\'");
          }
        } else {
#line 378
          goto while_break___0;
        }
#line 380
        p --;
      } else
#line 382
      if (c == delim) {
#line 382
        if (cmntcnt <= 0) {
#line 382
          if (state != 2) {
#line 384
            if (anglecnt <= 0) {
#line 385
              goto while_break___0;
            }
#line 388
            if (delim == 44) {
#line 388
              if (! route_syntax) {
                {
#line 390
                printf((char const   */* __restrict  */)"653 Unbalanced \'<\'");
#line 391
                c = '>';
#line 392
                p --;
                }
              }
            }
          }
        }
      }
      {
#line 399
      *q = (char )'\000';
#line 400
      printf((char const   */* __restrict  */)"canaray=[%s]\n", canary);
#line 401
      printf((char const   */* __restrict  */)"canary should be 5 bytes, max\n");
      }
#line 403
      if (bslashmode) {
#line 408
        bslashmode = 0;
#line 411
        if (cmntcnt > 0) {
#line 413
          c = -1;
#line 414
          goto cont;
        } else
#line 416
        if (c != 33) {
#line 416
          goto _L;
        } else
#line 416
        if (state == 2) {
          _L: /* CIL Label */ 
          {
#line 420
          tmp___2 = q;
#line 420
          q ++;
#line 420
          *tmp___2 = (char )'\\';
#line 421
          printf((char const   */* __restrict  */)"canary=[%s]\n", canary);
#line 422
          printf((char const   */* __restrict  */)"canary should be 5 bytes, max\n");
          }
#line 423
          goto cont;
        }
      }
#line 427
      if (c == 92) {
#line 429
        bslashmode = 1;
      } else
#line 431
      if (! (state == 2)) {
#line 436
        if (c == 40) {
#line 436
          if ((int )*(toktab + 40) == 3) {
#line 438
            cmntcnt ++;
#line 439
            c = -1;
          } else {
#line 436
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 441
        if (c == 41) {
#line 441
          if ((int )*(toktab + 40) == 3) {
#line 443
            if (cmntcnt <= 0) {
              {
#line 445
              printf((char const   */* __restrict  */)"653 Unbalanced \')\'");
#line 446
              c = -1;
              }
            } else {
#line 449
              cmntcnt --;
            }
          } else {
#line 441
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 451
        if (cmntcnt > 0) {
#line 453
          c = -1;
        } else
#line 455
        if (c == 60) {
#line 457
          ptr = p;
#line 459
          anglecnt ++;
          {
#line 460
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 460
            if (((int )*ptr & -128) == 0) {
              {
#line 460
              tmp___3 = __ctype_b_loc();
              }
#line 460
              if (! ((int const   )*(*tmp___3 + (int )*ptr) & 8192)) {
#line 460
                goto while_break___1;
              }
            } else {
#line 460
              goto while_break___1;
            }
#line 461
            ptr ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 462
          if ((int )*ptr == 64) {
#line 463
            route_syntax = 1;
          }
        } else
#line 465
        if (c == 62) {
#line 467
          if (anglecnt <= 0) {
            {
#line 469
            printf((char const   */* __restrict  */)"653 Unbalanced \'>\'");
#line 470
            c = -1;
            }
          } else {
#line 473
            anglecnt --;
          }
#line 475
          route_syntax = 0;
        } else
#line 477
        if (delim == 32) {
#line 477
          if ((c & -128) == 0) {
            {
#line 477
            tmp___4 = __ctype_b_loc();
            }
#line 477
            if ((int const   )*(*tmp___4 + c) & 8192) {
#line 478
              c = ' ';
            }
          }
        }
      }
#line 480
      if (c == -1) {
        {
#line 481
        printf((char const   */* __restrict  */)"c = NOCHAR.... continuing....!\n");
        }
#line 482
        goto cont;
      }
#line 486
      if (c == delim) {
#line 486
        if (anglecnt <= 0) {
#line 486
          if (state != 2) {
            {
#line 488
            printf((char const   */* __restrict  */)"breaking from for loop!\n");
            }
#line 489
            goto while_break___0;
          }
        }
      }
#line 493
      newstate = (int )StateTab[state][*(toktab + (c & 255))];
#line 496
      state = newstate & 15;
#line 497
      if (state == 5) {
#line 499
        if ((c & -128) == 0) {
          {
#line 499
          tmp___5 = __ctype_b_loc();
          }
#line 499
          if ((int const   )*(*tmp___5 + c) & 16384) {
            {
#line 500
            printf((char const   */* __restrict  */)"653 Illegal character %c", c);
            }
          } else {
            {
#line 502
            printf((char const   */* __restrict  */)"653 Illegal character 0x%02x",
                   c);
            }
          }
        } else {
          {
#line 502
          printf((char const   */* __restrict  */)"653 Illegal character 0x%02x",
                 c);
          }
        }
      }
#line 505
      if (newstate & 16) {
#line 506
        c = -1;
      }
#line 509
      if (newstate & 32) {
#line 511
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 515
    if ((unsigned long )tok != (unsigned long )q) {
      {
#line 517
      printf((char const   */* __restrict  */)"writing null byte\n");
#line 519
      tmp___6 = q;
#line 519
      q ++;
#line 519
      *tmp___6 = (char )'\000';
#line 520
      printf((char const   */* __restrict  */)"canary=[%s]\n", canary);
#line 521
      printf((char const   */* __restrict  */)"canary should be 5 bytes, max\n");
      }
#line 523
      if (q - tok > 40L) {
        {
#line 525
        printf((char const   */* __restrict  */)"553 5.1.0 prescan: token too long");
        }
#line 526
        goto returnnull;
      }
    }
    cont: ;
#line 325
    if (c != 0) {
#line 325
      if (! (c != delim)) {
#line 325
        if (! (anglecnt > 0)) {
#line 325
          goto while_break;
        }
      }
    } else {
#line 325
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 535
  printf((char const   */* __restrict  */)"Exiting while loop!\n");
#line 537
  p --;
  }
#line 538
  if ((unsigned long )delimptr != (unsigned long )((void *)0)) {
#line 539
    *delimptr = p;
  }
#line 541
  CurEnv->e_to = saveto;
#line 543
  return ((char **)((void *)0));
}
}
#line 556 "prescan-overflow-bad.c"
static char *delimptrbuf  ;
#line 546 "prescan-overflow-bad.c"
char **parseaddr(char *addr , int delim , char **delimptr ) 
{ 
  register char **pvp ;
  char canary[5] ;
  char pvpbuf[50] ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
#line 554
  canary[0] = (char )'G';
#line 554
  canary[1] = (char )'O';
#line 554
  canary[2] = (char )'O';
#line 554
  canary[3] = (char )'D';
#line 554
  canary[4] = (char )'\000';
#line 563
  if ((unsigned long )delimptr == (unsigned long )((void *)0)) {
#line 564
    delimptr = & delimptrbuf;
  }
  {
#line 566
  pvp = prescan(addr, delim, pvpbuf, (int )sizeof(pvpbuf), delimptr, (u_char *)((void *)0),
                canary);
  }
#line 568
  return (pvp);
}
}
#line 578 "prescan-overflow-bad.c"
static char **delimptr  ;
#line 573 "prescan-overflow-bad.c"
int main(void) 
{ 
  char *addr ;
  int delim ;
  char special_char ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp9 ;

  {
  {
#line 579
  special_char = (char )'\377';
#line 580
  i = 0;
#line 582
  tmp = malloc(sizeof(char ) * 500UL);
#line 582
  addr = (char *)tmp;
#line 593
  i = 0;
  }
  {
#line 593
  while (1) {
    while_continue: /* CIL Label */ ;
#line 593
    if (! (i < 300)) {
#line 593
      goto while_break;
    }
#line 594
    *(addr + i) = (char )'\\';
#line 595
    *(addr + (i + 1)) = special_char;
#line 593
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 598
  delim = '\000';
#line 599
  delimptr = (char **)((void *)0);
#line 601
  OperatorChars = (char *)((void *)0);
#line 603
  ConfigLevel = 5;
#line 605
  tmp___0 = malloc(sizeof(struct envelope ));
#line 605
  CurEnv = (ENVELOPE *)tmp___0;
#line 606
  tmp___1 = strlen((char const   *)addr);
#line 606
  tmp___2 = malloc(tmp___1 * sizeof(char ) + 1UL);
#line 606
  CurEnv->e_to = (char *)tmp___2;
#line 608
  strcpy((char */* __restrict  */)CurEnv->e_to, (char const   */* __restrict  */)addr);
#line 610
  parseaddr(addr, delim, delimptr);
  }
#line 613
  return (0);
}
}
