/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_15 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_15 fd_set;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/bytecode.h"
typedef unsigned int rl_opcode_t;
#line 43 "/usr/include/x86_64-linux-gnu/bits/uio.h"
struct iovec {
   void *iov_base ;
   size_t iov_len ;
};
#line 59 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.h"
struct oplist;
#line 20 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct loglist {
   int type ;
   char *arg ;
   int len ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.h"
struct argvtab {
   int argc ;
   struct loglist *ents ;
   char **argv ;
   struct iovec *iov ;
   char *str ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct logtab;
#line 60 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct oplist {
   int ops_len ;
   rl_opcode_t *ops_list ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct logtab {
   int fd ;
   int argv ;
   char *path ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct buftab {
   void *addr ;
   size_t len ;
};
#line 122 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct semaphore {
   int limit ;
   int count ;
   rl_opcode_t match ;
   rl_opcode_t under ;
};
#line 37 "/usr/include/rpc/types.h"
typedef int bool_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 28 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/rlinetd.h"
struct rl_cleanup {
   int type ;
   void *data ;
   struct rl_cleanup *next ;
};
#line 18 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.h"
struct numlist {
   long num ;
   struct numlist *next ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/parse.h"
struct rlc_unrpc {
   struct numlist *vers ;
   long prog ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 51 "lex.c"
typedef short flex_int16_t;
#line 52 "lex.c"
typedef int flex_int32_t;
#line 161
struct yy_buffer_state;
#line 161 "lex.c"
typedef struct yy_buffer_state *YY_BUFFER_STATE;
#line 192 "lex.c"
typedef size_t yy_size_t;
#line 197 "lex.c"
struct yy_buffer_state {
   FILE *yy_input_file ;
   char *yy_ch_buf ;
   char *yy_buf_pos ;
   yy_size_t yy_buf_size ;
   int yy_n_chars ;
   int yy_is_our_buffer ;
   int yy_is_interactive ;
   int yy_at_bol ;
   int yy_bs_lineno ;
   int yy_bs_column ;
   int yy_fill_buffer ;
   int yy_buffer_status ;
};
#line 343 "lex.c"
typedef unsigned char YY_CHAR;
#line 347 "lex.c"
typedef int yy_state_type;
#line 180 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/grammar.h"
struct passwd;
#line 180
struct group;
#line 180
struct opmetalist;
#line 180
struct opmeta;
#line 180 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/grammar.h"
union YYSTYPE {
   long num ;
   char *cp ;
   struct passwd *uid ;
   struct group *gid ;
   struct opmetalist *opml ;
   struct opmeta *opm ;
   rlim_t rl ;
};
#line 180 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/grammar.h"
typedef union YYSTYPE YYSTYPE;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 32 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __u_int;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 41 "/usr/include/fcntl.h"
typedef __mode_t mode_t;
#line 60 "/usr/include/fcntl.h"
typedef __pid_t pid_t;
#line 37 "/usr/include/grp.h"
typedef __gid_t gid_t;
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 35 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_int u_int;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 46 "/usr/include/rpc/netdb.h"
struct rpcent {
   char *r_name ;
   char **r_aliases ;
   int r_number ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *__buffer ;
   unsigned long __allocated ;
   unsigned long __used ;
   reg_syntax_t __syntax ;
   char *__fastmap ;
   unsigned char *__translate ;
   size_t re_nsub ;
   unsigned int __can_be_null : 1 ;
   unsigned int __regs_allocated : 2 ;
   unsigned int __fastmap_accurate : 1 ;
   unsigned int __no_sub : 1 ;
   unsigned int __not_bol : 1 ;
   unsigned int __not_eol : 1 ;
   unsigned int __newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_72 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_72 regmatch_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_74 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_75 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_76 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_77 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_78 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_79 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_80 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_81 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_82 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_83 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_84 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_85 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_86 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_87 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_74 __annonCompField2 ;
   union __anonunion____missing_field_name_75 __annonCompField3 ;
   union __anonunion____missing_field_name_76 __annonCompField4 ;
   union __anonunion____missing_field_name_77 __annonCompField5 ;
   union __anonunion____missing_field_name_78 __annonCompField6 ;
   union __anonunion____missing_field_name_79 __annonCompField7 ;
   union __anonunion____missing_field_name_80 __annonCompField8 ;
   union __anonunion____missing_field_name_81 __annonCompField9 ;
   union __anonunion____missing_field_name_82 __annonCompField10 ;
   union __anonunion____missing_field_name_83 __annonCompField11 ;
   union __anonunion____missing_field_name_84 __annonCompField12 ;
   union __anonunion____missing_field_name_85 __annonCompField13 ;
   union __anonunion____missing_field_name_86 __annonCompField14 ;
   union __anonunion____missing_field_name_87 __annonCompField15 ;
};
#line 4 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/buffer.h"
struct rl_buffer {
   char *data ;
   int head ;
   int tail ;
   int size ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.h"
struct rl_stack {
   rl_opcode_t data[8] ;
   int top ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/rlinetd.h"
struct rl_instance {
   struct sockaddr *sin ;
   socklen_t sinlen ;
   struct rusage rusage ;
   int status ;
   time_t start ;
   time_t volatile   stop ;
   int sock ;
   struct rl_buffer *buf ;
   struct rl_stack stk ;
};
#line 6 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.h"
struct array {
   rl_opcode_t *elems ;
   int len ;
};
#line 20
enum __anonenum_opmeta_fixup_ptr_89 {
    ofp_none = 0,
    ofp_iname = 1,
    ofp_exec = 2,
    ofp_parent = 3,
    ofp_iuser = 4,
    ofp_setuid = 5,
    ofp_supgid = 6,
    ofp_setgid = 7,
    ofp_onexit = 8,
    ofp_max_fixups = 9
} ;
#line 20 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.h"
typedef enum __anonenum_opmeta_fixup_ptr_89 opmeta_fixup_ptr;
#line 33 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.h"
struct opmeta {
   int len ;
   rl_opcode_t *bytes ;
   struct array *after ;
   struct array *ops ;
   opmeta_fixup_ptr *fixup ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.h"
struct opmetalist {
   int len ;
   struct opmeta **opms ;
};
#line 34 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.h"
struct stringlist;
#line 34 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.h"
struct service {
   struct stringlist *port ;
   struct stringlist *interface ;
   char *name ;
   int family ;
   int socktype ;
   int proto ;
   char const   *protoname ;
   int backlog ;
   int limit ;
   int wait ;
   struct rlimit r ;
   char *rpcname ;
   long rpcnum ;
   struct numlist *rpcvers ;
   rl_opcode_t opfixups[9] ;
   int sflags ;
   int disabled ;
   int internal ;
   rl_opcode_t run ;
};
#line 70 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.h"
struct stringlist {
   char *str ;
   struct stringlist *next ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.h"
struct userdata {
   uid_t uid ;
   gid_t gid ;
   char *name ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct pidtab;
#line 111 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct pidtab {
   pid_t pid ;
   struct pidtab *next ;
   struct pidtab *prev ;
   struct pidtab *next_cleanup ;
   int onexit ;
   struct rl_instance *inst ;
};
#line 8 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/parse.h"
struct logdata {
   int index ;
   struct logdata *next ;
   char *name ;
   char *path ;
   mode_t mode ;
   uid_t uid ;
   gid_t gid ;
};
#line 392 "grammar.c"
typedef unsigned char yytype_uint8;
#line 413 "grammar.c"
typedef short yytype_int16;
#line 554 "grammar.c"
union yyalloc {
   yytype_int16 yyss_alloc ;
   YYSTYPE yyvs_alloc ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 14 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.h"
struct optab {
   rl_opcode_t opcode ;
   int nargs ;
   struct array *after ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_55 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_55 __in6_u ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 210 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
union __anonunion_75 {
   int __in ;
   int __i ;
};
#line 209 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
union __anonunion_76 {
   int __in ;
   int __i ;
};
#line 216 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
union __anonunion_77 {
   int __in ;
   int __i ;
};
#line 215 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
union __anonunion_78 {
   int __in ;
   int __i ;
};
#line 79 "/usr/include/malloc.h"
struct mallinfo {
   int arena ;
   int ordblks ;
   int smblks ;
   int hblks ;
   int hblkhd ;
   int usmblks ;
   int fsmblks ;
   int uordblks ;
   int fordblks ;
   int keepcost ;
};
#line 36 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
struct fd_ops {
   rl_opcode_t *op ;
   struct rl_instance *inst ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_1 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_1 __sigset_t;
#line 49 "/usr/include/signal.h"
typedef __sigset_t sigset_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_5 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_6 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_7 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_8 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_9 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_10 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_11 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_4 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_5 _kill ;
   struct __anonstruct__timer_6 _timer ;
   struct __anonstruct__rt_7 _rt ;
   struct __anonstruct__sigchld_8 _sigchld ;
   struct __anonstruct__sigfault_9 _sigfault ;
   struct __anonstruct__sigpoll_10 _sigpoll ;
   struct __anonstruct__sigsys_11 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_3 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_4 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_3 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_23 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_23 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_44 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_45 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_44 __wait_terminated ;
   struct __anonstruct___wait_stopped_45 __wait_stopped ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __id_t;
#line 104 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __id_t id_t;
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 44 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __priority_which_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.h"
void rl_warn(char const   *fmt  , ...) ;
#line 11
void rl_fatal(int ex , char const   *fmt  , ...) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/util.h"
int rl_readfile(char *path , void **addr , int *len ) ;
#line 39 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) gettext)(char const   *__msgid )  __attribute__((__format_arg__(1))) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/util.c"
int rl_readfile(char *path , void **addr , int *len ) 
{ 
  int fd ;
  struct stat st ;
  void *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  ssize_t tmp___9 ;

  {
  {
#line 18
  fd = open((char const   *)path, 0);
  }
#line 18
  if (fd < 0) {
    {
#line 19
    tmp___0 = __errno_location();
#line 19
    tmp___1 = strerror(*tmp___0);
#line 19
    tmp___2 = gettext("Failed to open %s (%s)");
#line 19
    rl_warn((char const   *)tmp___2, path, tmp___1);
    }
#line 20
    return (-1);
  }
  {
#line 22
  tmp___6 = fstat(fd, & st);
  }
#line 22
  if (tmp___6) {
    {
#line 23
    tmp___3 = __errno_location();
#line 23
    tmp___4 = strerror(*tmp___3);
#line 23
    tmp___5 = gettext("Failed to fstat %d (%s)");
#line 23
    rl_warn((char const   *)tmp___5, fd, tmp___4);
#line 24
    close(fd);
    }
#line 25
    return (-1);
  }
  {
#line 27
  tmp = malloc((size_t )st.st_size);
  }
#line 28
  if (! tmp) {
    {
#line 29
    tmp___7 = gettext("ABORT - Can\'t allocate memory");
#line 29
    rl_fatal(70, (char const   *)tmp___7);
    }
  }
  {
#line 30
  tmp___9 = read(fd, tmp, (size_t )st.st_size);
  }
#line 30
  if (tmp___9 < 0L) {
    {
#line 31
    tmp___8 = gettext("Failed to inhale file %s");
#line 31
    rl_warn((char const   *)tmp___8, path);
#line 32
    free(tmp);
#line 33
    close(fd);
    }
#line 34
    return (-1);
  }
  {
#line 36
  close(fd);
#line 37
  *addr = tmp;
#line 38
  *len = (int )st.st_size;
  }
#line 39
  return (0);
}
}
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
int logtab_add(int fd , char *arg ) ;
#line 39
int rlimittab_add(rlim_t soft , rlim_t hard ) ;
#line 41
void argvtab_grow(void) ;
#line 45
int argvtab_add(char *arg , int split_on_spaces ) ;
#line 53
int stringtab_add(char *str ) ;
#line 55
void stringtabs_free(void) ;
#line 65
int oplisttab_add(struct oplist *op ) ;
#line 66
void oplisttabs_free(void) ;
#line 68
void oplist_free(struct oplist *o ) ;
#line 76
struct logtab *logtabs ;
#line 77
int numlogtabs ;
#line 79
struct argvtab *argvs ;
#line 80
int numargvs ;
#line 82
struct rlimit *rlimits ;
#line 83
int numrlimits ;
#line 90
char **strings ;
#line 91
int numstrings ;
#line 98
void buftabs_free(void) ;
#line 99
int buftab_addfile(char *path ) ;
#line 100
int buftab_addbuf(char const   *buf , int len ) ;
#line 103
struct buftab *bufs ;
#line 104
int numbufs ;
#line 106
struct oplist *oplists ;
#line 107
int numoplists ;
#line 109
char rl_lf[2] ;
#line 129
struct semaphore *sems ;
#line 130
int numsems ;
#line 133
int semaphore_add(int limit , rl_opcode_t match , rl_opcode_t under ) ;
#line 134
void semaphores_free(void) ;
#line 136
fd_set *fdsets ;
#line 137
int numfdsets ;
#line 139
int fdsettab_add(fd_set *fds ) ;
#line 140
void fdsettabs_free(void) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.h"
void rlimittabs_free(void) ;
#line 5
void logtabs_free(void) ;
#line 6
void argvtabs_free(void) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void loglist_append(int idx , int type , char *arg , int len ) ;
#line 29
int loglist_parse(int idx , char c ) ;
#line 31 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void logtab_grow(void) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 32
  numlogtabs ++;
#line 32
  tmp = realloc((void *)logtabs, (unsigned long )numlogtabs * sizeof(struct logtab ));
#line 32
  logtabs = (struct logtab *)tmp;
  }
#line 33
  if (! logtabs) {
    {
#line 34
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 34
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 35
  memset((void *)((logtabs + numlogtabs) - 1), 0, sizeof(struct logtab ));
#line 36
  (logtabs + (numlogtabs - 1))->fd = -1;
  }
#line 37
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static char escape_lookup(char c ) 
{ 


  {
  {
#line 41
  if ((int )c == 110) {
#line 41
    goto case_110;
  }
#line 43
  if ((int )c == 114) {
#line 43
    goto case_114;
  }
#line 45
  if ((int )c == 116) {
#line 45
    goto case_116;
  }
#line 47
  goto switch_default;
  case_110: /* CIL Label */ 
#line 42
  return ((char )'\n');
  case_114: /* CIL Label */ 
#line 44
  return ((char )'\r');
  case_116: /* CIL Label */ 
#line 46
  return ((char )'\t');
  switch_default: /* CIL Label */ 
#line 48
  return (c);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int logtab_add(int fd , char *arg ) 
{ 
  int len ;
  int i ;
  int text ;
  int idx ;
  char *start ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 53
  text = 0;
#line 56
  idx = numargvs;
#line 57
  argvtab_grow();
#line 58
  tmp = strlen((char const   *)arg);
#line 58
  len = (int )tmp;
#line 59
  start = arg;
#line 60
  i = 0;
  }
  {
#line 60
  while (1) {
    while_continue: /* CIL Label */ ;
#line 60
    if (! (i < len)) {
#line 60
      goto while_break;
    }
#line 61
    if ((int )*(arg + i) == 37) {
#line 62
      *(arg + i) = (char )'\000';
#line 63
      if (text) {
        {
#line 64
        tmp___0 = strlen((char const   *)start);
#line 64
        loglist_append(idx, 0, start, (int )tmp___0);
        }
      }
      {
#line 65
      start = (arg + i) + 2;
#line 66
      text = 0;
#line 67
      i ++;
#line 67
      tmp___1 = loglist_parse(idx, *(arg + i));
      }
#line 67
      if (tmp___1) {
#line 68
        start --;
#line 69
        text = 1;
      }
    }
#line 72
    if ((int )*(arg + i) == 92) {
#line 73
      *(arg + i) = (char )'\000';
#line 74
      if (text) {
        {
#line 75
        tmp___2 = strlen((char const   *)start);
#line 75
        loglist_append(idx, 0, start, (int )tmp___2);
        }
      }
      {
#line 76
      i ++;
#line 76
      start = arg + i;
#line 77
      *(arg + i) = escape_lookup(*(arg + i));
      }
    }
#line 79
    text = 1;
#line 60
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 81
  if (text) {
    {
#line 82
    tmp___3 = strlen((char const   *)start);
#line 82
    loglist_append(idx, 0, start, (int )tmp___3);
    }
  }
  {
#line 83
  loglist_append(idx, 0, rl_lf, 1);
#line 84
  i = numlogtabs;
#line 85
  logtab_grow();
#line 86
  (logtabs + i)->argv = idx;
#line 87
  (logtabs + i)->fd = fd;
  }
#line 88
  return (i);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void logtabs_free(void) 
{ 


  {
#line 92
  if (logtabs) {
    {
#line 93
    free((void *)logtabs);
    }
  }
#line 94
  logtabs = (struct logtab *)((void *)0);
#line 95
  numlogtabs = 0;
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void loglist_grow(struct argvtab *argv ) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 99
  (argv->argc) ++;
#line 99
  tmp = realloc((void *)argv->ents, (unsigned long )argv->argc * sizeof(struct loglist ));
#line 99
  argv->ents = (struct loglist *)tmp;
  }
#line 101
  if (! argv->ents) {
    {
#line 102
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 102
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void loglist_append(int idx , int type , char *arg , int len ) 
{ 
  int i ;
  void *tmp ;

  {
  {
#line 107
  i = (argvs + idx)->argc;
#line 109
  loglist_grow(argvs + idx);
#line 110
  ((argvs + idx)->ents + i)->type = type;
#line 111
  ((argvs + idx)->ents + i)->len = len;
  }
#line 112
  if (len) {
    {
#line 112
    tmp = malloc((size_t )(len + 1));
#line 112
    ((argvs + idx)->ents + i)->arg = (char *)tmp;
    }
  } else {
#line 112
    ((argvs + idx)->ents + i)->arg = (char *)((void *)0);
  }
#line 113
  if (arg) {
#line 113
    if (len) {
      {
#line 114
      strncpy((char */* __restrict  */)((argvs + idx)->ents + i)->arg, (char const   */* __restrict  */)arg,
              (size_t )len);
#line 115
      *(((argvs + idx)->ents + i)->arg + len) = (char )'\000';
      }
    }
  }
#line 117
  return;
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int loglist_parse(int idx , char c ) 
{ 


  {
  {
#line 121
  if ((int )c == 37) {
#line 121
    goto case_37;
  }
#line 123
  if ((int )c == 79) {
#line 123
    goto case_79;
  }
#line 126
  if ((int )c == 80) {
#line 126
    goto case_80;
  }
#line 129
  if ((int )c == 67) {
#line 129
    goto case_67;
  }
#line 132
  if ((int )c == 85) {
#line 132
    goto case_85;
  }
#line 135
  if ((int )c == 83) {
#line 135
    goto case_83;
  }
#line 138
  if ((int )c == 114) {
#line 138
    goto case_114;
  }
#line 141
  if ((int )c == 109) {
#line 141
    goto case_109;
  }
#line 144
  if ((int )c == 100) {
#line 144
    goto case_100;
  }
#line 147
  if ((int )c == 115) {
#line 147
    goto case_115;
  }
#line 150
  if ((int )c == 102) {
#line 150
    goto case_102;
  }
#line 153
  if ((int )c == 70) {
#line 153
    goto case_70;
  }
#line 156
  if ((int )c == 112) {
#line 156
    goto case_112;
  }
#line 159
  if ((int )c == 105) {
#line 159
    goto case_105;
  }
#line 162
  if ((int )c == 111) {
#line 162
    goto case_111;
  }
#line 165
  if ((int )c == 110) {
#line 165
    goto case_110;
  }
#line 168
  if ((int )c == 99) {
#line 168
    goto case_99;
  }
#line 171
  if ((int )c == 107) {
#line 171
    goto case_107;
  }
#line 174
  if ((int )c == 119) {
#line 174
    goto case_119;
  }
#line 177
  if ((int )c == 87) {
#line 177
    goto case_87;
  }
#line 180
  if ((int )c == 101) {
#line 180
    goto case_101;
  }
#line 183
  if ((int )c == 116) {
#line 183
    goto case_116;
  }
#line 186
  if ((int )c == 77) {
#line 186
    goto case_77;
  }
#line 189
  if ((int )c == 73) {
#line 189
    goto case_73;
  }
#line 192
  goto switch_default;
  case_37: /* CIL Label */ 
#line 122
  return (1);
  case_79: /* CIL Label */ 
  {
#line 124
  loglist_append(idx, 1, (char *)((void *)0), 80);
  }
#line 125
  goto switch_break;
  case_80: /* CIL Label */ 
  {
#line 127
  loglist_append(idx, 2, (char *)((void *)0), 6);
  }
#line 128
  goto switch_break;
  case_67: /* CIL Label */ 
  {
#line 130
  loglist_append(idx, 3, (char *)((void *)0), 10);
  }
#line 131
  goto switch_break;
  case_85: /* CIL Label */ 
  {
#line 133
  loglist_append(idx, 4, (char *)((void *)0), 10);
  }
#line 134
  goto switch_break;
  case_83: /* CIL Label */ 
  {
#line 136
  loglist_append(idx, 5, (char *)((void *)0), 10);
  }
#line 137
  goto switch_break;
  case_114: /* CIL Label */ 
  {
#line 139
  loglist_append(idx, 6, (char *)((void *)0), 10);
  }
#line 140
  goto switch_break;
  case_109: /* CIL Label */ 
  {
#line 142
  loglist_append(idx, 7, (char *)((void *)0), 10);
  }
#line 143
  goto switch_break;
  case_100: /* CIL Label */ 
  {
#line 145
  loglist_append(idx, 8, (char *)((void *)0), 10);
  }
#line 146
  goto switch_break;
  case_115: /* CIL Label */ 
  {
#line 148
  loglist_append(idx, 9, (char *)((void *)0), 10);
  }
#line 149
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 151
  loglist_append(idx, 10, (char *)((void *)0), 10);
  }
#line 152
  goto switch_break;
  case_70: /* CIL Label */ 
  {
#line 154
  loglist_append(idx, 11, (char *)((void *)0), 10);
  }
#line 155
  goto switch_break;
  case_112: /* CIL Label */ 
  {
#line 157
  loglist_append(idx, 12, (char *)((void *)0), 10);
  }
#line 158
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 160
  loglist_append(idx, 13, (char *)((void *)0), 10);
  }
#line 161
  goto switch_break;
  case_111: /* CIL Label */ 
  {
#line 163
  loglist_append(idx, 14, (char *)((void *)0), 10);
  }
#line 164
  goto switch_break;
  case_110: /* CIL Label */ 
  {
#line 166
  loglist_append(idx, 15, (char *)((void *)0), 10);
  }
#line 167
  goto switch_break;
  case_99: /* CIL Label */ 
  {
#line 169
  loglist_append(idx, 16, (char *)((void *)0), 10);
  }
#line 170
  goto switch_break;
  case_107: /* CIL Label */ 
  {
#line 172
  loglist_append(idx, 17, (char *)((void *)0), 10);
  }
#line 173
  goto switch_break;
  case_119: /* CIL Label */ 
  {
#line 175
  loglist_append(idx, 18, (char *)((void *)0), 10);
  }
#line 176
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 178
  loglist_append(idx, 19, (char *)((void *)0), 10);
  }
#line 179
  goto switch_break;
  case_101: /* CIL Label */ 
  {
#line 181
  loglist_append(idx, 20, (char *)((void *)0), 6);
  }
#line 182
  goto switch_break;
  case_116: /* CIL Label */ 
  {
#line 184
  loglist_append(idx, 21, (char *)((void *)0), 10);
  }
#line 185
  goto switch_break;
  case_77: /* CIL Label */ 
  {
#line 187
  loglist_append(idx, 22, (char *)((void *)0), 5);
  }
#line 188
  goto switch_break;
  case_73: /* CIL Label */ 
  {
#line 190
  loglist_append(idx, 23, (char *)((void *)0), 35);
  }
#line 191
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 193
  rl_warn("unknown log modifier %%%c", (int )c);
  }
  switch_break: /* CIL Label */ ;
  }
#line 195
  return (0);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int argvtab_add(char *arg , int split_on_spaces ) 
{ 
  int len ;
  int i ;
  int text ;
  int idx ;
  char *start ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  size_t tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  size_t tmp___8 ;

  {
  {
#line 200
  text = 0;
#line 203
  idx = numargvs;
#line 204
  argvtab_grow();
  }
#line 205
  if (! arg) {
    {
#line 206
    tmp = gettext("No exec string passed to argvtab_add()");
#line 206
    rl_fatal(70, (char const   *)tmp);
    }
  }
  {
#line 207
  tmp___0 = strlen((char const   *)arg);
#line 207
  len = (int )tmp___0;
#line 208
  start = arg;
#line 209
  i = 0;
  }
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! (i < len)) {
#line 210
      goto while_break;
    }
#line 211
    if (split_on_spaces) {
      {
#line 211
      tmp___7 = __ctype_b_loc();
      }
#line 211
      if ((int const   )*(*tmp___7 + (int )*(arg + i)) & 8192) {
#line 212
        tmp___1 = i;
#line 212
        i ++;
#line 212
        *(arg + tmp___1) = (char )'\000';
#line 213
        if (text) {
          {
#line 214
          tmp___2 = strlen((char const   *)start);
#line 214
          loglist_append(idx, 0, start, (int )tmp___2);
          }
        }
        {
#line 215
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 215
          tmp___3 = __ctype_b_loc();
          }
#line 215
          if ((int const   )*(*tmp___3 + (int )*(arg + i)) & 8192) {
#line 215
            if (! (i < len)) {
#line 215
              goto while_break___0;
            }
          } else {
#line 215
            goto while_break___0;
          }
#line 216
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 217
        start = arg + i;
#line 218
        text = 0;
#line 219
        goto while_continue;
      } else {
#line 211
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 221
    if ((int )*(arg + i) == 92) {
#line 222
      *(arg + i) = (char )'\000';
#line 223
      if (text) {
        {
#line 224
        tmp___4 = strlen((char const   *)start);
#line 224
        loglist_append(idx, 0, start, (int )tmp___4);
        }
      }
      {
#line 225
      i ++;
#line 225
      start = arg + i;
#line 226
      *(arg + i) = escape_lookup(*(arg + i));
#line 227
      i ++;
      }
    } else
#line 229
    if ((int )*(arg + i) == 37) {
#line 230
      *(arg + i) = (char )'\000';
#line 231
      if (text) {
        {
#line 232
        tmp___5 = strlen((char const   *)start);
#line 232
        loglist_append(idx, 0, start, (int )tmp___5);
        }
      }
      {
#line 233
      start = (arg + i) + 2;
#line 234
      text = 0;
#line 235
      i ++;
#line 235
      tmp___6 = loglist_parse(idx, *(arg + i));
      }
#line 235
      if (tmp___6) {
#line 236
        start --;
#line 237
        text = 1;
      }
#line 239
      i ++;
#line 240
      goto while_continue;
    } else {
#line 242
      i ++;
#line 243
      text = 1;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  if (text) {
    {
#line 247
    tmp___8 = strlen((char const   *)start);
#line 247
    loglist_append(idx, 0, start, (int )tmp___8);
    }
  }
  {
#line 248
  free((void *)arg);
  }
#line 249
  return (idx);
}
}
#line 252 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void rlimittab_grow(void) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 253
  numrlimits ++;
#line 253
  tmp = realloc((void *)rlimits, (unsigned long )numrlimits * sizeof(struct rlimit ));
#line 253
  rlimits = (struct rlimit *)tmp;
  }
#line 255
  if (! rlimits) {
    {
#line 256
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 256
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
#line 257
  return;
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void rlimittabs_free(void) 
{ 


  {
#line 260
  if (rlimits) {
    {
#line 261
    free((void *)rlimits);
    }
  }
#line 262
  numrlimits = 0;
#line 263
  rlimits = (struct rlimit *)((void *)0);
#line 264
  return;
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int rlimittab_add(rlim_t soft , rlim_t hard ) 
{ 
  int i ;

  {
  {
#line 268
  i = numrlimits;
#line 270
  rlimittab_grow();
#line 271
  (rlimits + i)->rlim_cur = soft;
#line 272
  (rlimits + i)->rlim_max = hard;
  }
#line 273
  return (i);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void argvtabs_free(void) 
{ 
  int i ;
  int j ;

  {
#line 279
  j = 0;
  {
#line 279
  while (1) {
    while_continue: /* CIL Label */ ;
#line 279
    if (! (j < numargvs)) {
#line 279
      goto while_break;
    }
#line 280
    i = 0;
    {
#line 280
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 280
      if (! (i < (argvs + j)->argc)) {
#line 280
        goto while_break___0;
      }
#line 281
      if (((argvs + j)->ents + i)->arg) {
        {
#line 282
        ((argvs + j)->ents + i)->len = 0;
#line 283
        free((void *)((argvs + j)->ents + i)->arg);
        }
      }
#line 280
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 286
    if ((argvs + j)->ents) {
      {
#line 287
      free((void *)(argvs + j)->ents);
      }
    }
#line 288
    if ((argvs + j)->argv) {
      {
#line 289
      free((void *)(argvs + j)->argv);
      }
    }
#line 290
    if ((argvs + j)->iov) {
      {
#line 291
      free((void *)(argvs + j)->iov);
      }
    }
#line 292
    if ((argvs + j)->str) {
      {
#line 293
      free((void *)(argvs + j)->str);
      }
    }
#line 294
    (argvs + j)->argc = 0;
#line 279
    j ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if (argvs) {
    {
#line 297
    free((void *)argvs);
    }
  }
#line 298
  numargvs = 0;
#line 299
  argvs = (struct argvtab *)((void *)0);
#line 300
  return;
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void argvtab_grow(void) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 303
  numargvs ++;
#line 303
  tmp = realloc((void *)argvs, (unsigned long )numargvs * sizeof(struct argvtab ));
#line 303
  argvs = (struct argvtab *)tmp;
  }
#line 304
  if (! argvs) {
    {
#line 305
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 305
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 306
  memset((void *)((argvs + numargvs) - 1), 0, sizeof(struct argvtab ));
  }
#line 307
  return;
}
}
#line 339 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void stringtab_grow(void) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 340
  numstrings ++;
#line 340
  tmp = realloc((void *)strings, (unsigned long )numstrings * sizeof(char *));
#line 340
  strings = (char **)tmp;
  }
#line 341
  if (! strings) {
    {
#line 342
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 342
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 343
  memset((void *)((strings + numstrings) - 1), 0, sizeof(char *));
  }
#line 344
  return;
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int stringtab_add(char *str ) 
{ 
  int idx ;
  int tmp ;

  {
#line 349
  idx = 0;
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
#line 349
    if (! (idx < numstrings)) {
#line 349
      goto while_break;
    }
    {
#line 350
    tmp = strcmp((char const   *)*(strings + idx), (char const   *)str);
    }
#line 350
    if (! tmp) {
#line 351
      return (idx);
    }
#line 349
    idx ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 352
  stringtab_grow();
#line 353
  *(strings + idx) = strdup((char const   *)str);
  }
#line 354
  return (idx);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void stringtabs_free(void) 
{ 
  int i ;

  {
#line 360
  i = 0;
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    if (! (i < numstrings)) {
#line 360
      goto while_break;
    }
#line 361
    if (*(strings + i)) {
      {
#line 362
      free((void *)*(strings + i));
      }
    }
#line 360
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 363
  free((void *)strings);
#line 364
  strings = (char **)((void *)0);
#line 365
  numstrings = 0;
  }
#line 366
  return;
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void buftab_grow(void) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 369
  numbufs ++;
#line 369
  tmp = realloc((void *)bufs, (unsigned long )numbufs * sizeof(struct buftab ));
#line 369
  bufs = (struct buftab *)tmp;
  }
#line 370
  if (! bufs) {
    {
#line 371
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 371
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 372
  memset((void *)((bufs + numbufs) - 1), 0, sizeof(struct buftab ));
  }
#line 373
  return;
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int buftab_addbuf(char const   *buf , int len ) 
{ 
  int idx ;
  char *tmp ;

  {
  {
#line 376
  idx = numbufs;
#line 378
  buftab_grow();
#line 379
  (bufs + idx)->addr = malloc((size_t )len);
  }
#line 380
  if (! (bufs + idx)->addr) {
    {
#line 381
    tmp = gettext("ABORT - Can\'t allocate memory");
#line 381
    rl_fatal(70, (char const   *)tmp);
    }
  }
  {
#line 382
  memcpy((void */* __restrict  */)(bufs + idx)->addr, (void const   */* __restrict  */)buf,
         (size_t )len);
#line 383
  (bufs + idx)->len = (size_t )len;
  }
#line 384
  return (idx);
}
}
#line 387 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int buftab_addfile(char *path ) 
{ 
  int idx ;
  void *addr ;
  int len ;
  int tmp ;

  {
  {
#line 388
  idx = numbufs;
#line 392
  tmp = rl_readfile(path, & addr, & len);
  }
#line 392
  if (tmp) {
#line 393
    return (-1);
  }
  {
#line 394
  buftab_grow();
#line 395
  (bufs + idx)->addr = addr;
#line 396
  (bufs + idx)->len = (size_t )len;
  }
#line 397
  return (idx);
}
}
#line 400 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void buftabs_free(void) 
{ 
  int i ;

  {
#line 403
  i = 0;
  {
#line 403
  while (1) {
    while_continue: /* CIL Label */ ;
#line 403
    if (! (i < numbufs)) {
#line 403
      goto while_break;
    }
    {
#line 404
    free((bufs + i)->addr);
#line 403
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 406
  free((void *)bufs);
#line 407
  bufs = (struct buftab *)((void *)0);
#line 408
  numbufs = 0;
  }
#line 409
  return;
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void oplisttab_grow(void) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 412
  numoplists ++;
#line 412
  tmp = realloc((void *)oplists, (unsigned long )numoplists * sizeof(struct oplist ));
#line 412
  oplists = (struct oplist *)tmp;
  }
#line 413
  if (! oplists) {
    {
#line 414
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 414
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 415
  memset((void *)((oplists + numoplists) - 1), 0, sizeof(struct oplist ));
  }
#line 416
  return;
}
}
#line 418 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void oplist_copy(struct oplist *to , struct oplist *from ) 
{ 
  int len ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 419
  len = (int )(sizeof(rl_opcode_t ) * (unsigned long )from->ops_len);
#line 421
  to->ops_len = from->ops_len;
#line 422
  if (to->ops_len) {
#line 422
    if (len) {
      {
#line 423
      tmp = malloc((size_t )len);
#line 423
      to->ops_list = (rl_opcode_t *)tmp;
      }
#line 424
      if (! to->ops_list) {
        {
#line 425
        tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 425
        rl_fatal(70, (char const   *)tmp___0);
        }
      }
      {
#line 426
      memcpy((void */* __restrict  */)to->ops_list, (void const   */* __restrict  */)from->ops_list,
             (size_t )len);
      }
    }
  }
#line 428
  return;
}
}
#line 430 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int oplisttab_add(struct oplist *op ) 
{ 
  int i ;
  int tmp ;

  {
#line 433
  i = 0;
  {
#line 433
  while (1) {
    while_continue: /* CIL Label */ ;
#line 433
    if (! (i < numoplists)) {
#line 433
      goto while_break;
    }
#line 434
    if ((oplists + i)->ops_len == op->ops_len) {
      {
#line 435
      tmp = memcmp((void const   *)(oplists + i)->ops_list, (void const   *)op->ops_list,
                   (unsigned long )op->ops_len * sizeof(rl_opcode_t ));
      }
#line 435
      if (! tmp) {
#line 436
        return (i);
      }
    }
#line 433
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 437
  oplisttab_grow();
#line 439
  oplist_copy(oplists + i, op);
  }
#line 440
  return (i);
}
}
#line 443 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void oplist_free(struct oplist *o ) 
{ 


  {
#line 444
  if (o->ops_list) {
    {
#line 445
    free((void *)o->ops_list);
#line 446
    o->ops_list = (rl_opcode_t *)((void *)0);
    }
  }
#line 448
  o->ops_len = 0;
#line 449
  return;
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void oplisttabs_free(void) 
{ 
  int i ;

  {
#line 454
  i = 0;
  {
#line 454
  while (1) {
    while_continue: /* CIL Label */ ;
#line 454
    if (! (i < numoplists)) {
#line 454
      goto while_break;
    }
    {
#line 455
    oplist_free(oplists + i);
#line 454
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 456
  free((void *)oplists);
#line 457
  oplists = (struct oplist *)((void *)0);
#line 458
  numoplists = 0;
  }
#line 459
  return;
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void semaphores_free(void) 
{ 


  {
  {
#line 462
  free((void *)sems);
#line 463
  sems = (struct semaphore *)((void *)0);
#line 464
  numsems = 0;
  }
#line 465
  return;
}
}
#line 467 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void semaphore_grow(void) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 468
  numsems ++;
#line 468
  tmp = realloc((void *)sems, (unsigned long )numsems * sizeof(*sems));
#line 468
  sems = (struct semaphore *)tmp;
  }
#line 469
  if (! sems) {
    {
#line 470
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 470
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 471
  memset((void *)((sems + numsems) - 1), 0, sizeof(*sems));
  }
#line 472
  return;
}
}
#line 474 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int semaphore_add(int limit , rl_opcode_t match , rl_opcode_t under ) 
{ 
  int idx ;

  {
  {
#line 475
  idx = numsems;
#line 477
  semaphore_grow();
#line 478
  (sems + idx)->limit = limit;
#line 479
  (sems + idx)->match = match;
#line 480
  (sems + idx)->under = under;
  }
#line 481
  return (idx);
}
}
#line 484 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
static void fdsettab_grow(void) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 485
  numfdsets ++;
#line 485
  tmp = realloc((void *)fdsets, (unsigned long )numfdsets * sizeof(*fdsets));
#line 485
  fdsets = (fd_set *)tmp;
  }
#line 486
  if (! fdsets) {
    {
#line 487
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 487
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 488
  memset((void *)((fdsets + numfdsets) - 1), 0, sizeof(*fdsets));
  }
#line 489
  return;
}
}
#line 491 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
int fdsettab_add(fd_set *fds ) 
{ 


  {
  {
#line 492
  fdsettab_grow();
#line 493
  memcpy((void */* __restrict  */)((fdsets + numfdsets) - 1), (void const   */* __restrict  */)fds,
         sizeof(*fds));
  }
#line 494
  return (numfdsets - 1);
}
}
#line 497 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/libdb.c"
void fdsettabs_free(void) 
{ 


  {
  {
#line 498
  free((void *)fdsets);
#line 499
  fdsets = (fd_set *)((void *)0);
#line 500
  numfdsets = 0;
  }
#line 501
  return;
}
}
#line 71 "/usr/include/rpc/pmap_clnt.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) pmap_unset)(u_long const   __program ,
                                                                                    u_long const   __vers ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.h"
void numlist_free(struct numlist *n ) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/parse.h"
void rlp_cleanup(struct rl_cleanup *rlc ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/cleanups.c"
void rlp_cleanup(struct rl_cleanup *rlc ) 
{ 
  struct numlist *nl ;
  struct rlc_unrpc *rlcu ;
  struct rl_cleanup *next ;
  char *tmp ;

  {
  {
#line 21
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 23
    if (rlc->type == 0) {
#line 23
      goto case_0;
    }
#line 32
    goto switch_default;
    case_0: /* CIL Label */ 
#line 24
    rlcu = (struct rlc_unrpc *)rlc->data;
#line 25
    nl = rlcu->vers;
#line 25
    if (nl) {
      {
#line 26
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 27
        pmap_unset((u_long const   )rlcu->prog, (u_long const   )nl->num);
#line 26
        nl = nl->next;
        }
#line 26
        if (! nl) {
#line 26
          goto while_break___0;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 30
    numlist_free(rlcu->vers);
    }
#line 31
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 33
    tmp = gettext("unknown cleanup type %d");
#line 33
    rl_warn((char const   *)tmp, rlc->type);
    }
    switch_break: /* CIL Label */ ;
    }
#line 35
    if (rlc->data) {
      {
#line 36
      free(rlc->data);
      }
    }
    {
#line 37
    next = rlc->next;
#line 38
    free((void *)rlc);
#line 21
    rlc = next;
    }
#line 21
    if (! rlc) {
#line 21
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 826
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) clearerr)(FILE *__stream ) ;
#line 830
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 164 "lex.c"
int yyleng  ;
#line 166
FILE *yyin ;
#line 166
FILE *yyout ;
#line 261 "lex.c"
static size_t yy_buffer_stack_top  =    (size_t )0;
#line 262 "lex.c"
static size_t yy_buffer_stack_max  =    (size_t )0;
#line 263 "lex.c"
static YY_BUFFER_STATE *yy_buffer_stack  =    (YY_BUFFER_STATE *)0;
#line 281 "lex.c"
static char yy_hold_char  ;
#line 282 "lex.c"
static int yy_n_chars  ;
#line 286 "lex.c"
static char *yy_c_buf_p  =    (char *)0;
#line 287 "lex.c"
static int yy_init  =    0;
#line 288 "lex.c"
static int yy_start  =    0;
#line 293 "lex.c"
static int yy_did_buffer_switch_on_eof  ;
#line 295
void yyrestart(FILE *input_file ) ;
#line 296
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) ;
#line 297
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) ;
#line 298
void yy_delete_buffer(YY_BUFFER_STATE b ) ;
#line 299
void yy_flush_buffer(YY_BUFFER_STATE b ) ;
#line 300
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) ;
#line 301
void yypop_buffer_state(void) ;
#line 303
static void yyensure_buffer_stack(void) ;
#line 304
static void yy_load_buffer_state(void) ;
#line 305
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) ;
#line 309
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) ;
#line 310
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) ;
#line 311
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) ;
#line 313
void *yyalloc(yy_size_t size ) ;
#line 314
void *yyrealloc(void *ptr , yy_size_t size ) ;
#line 315
void yyfree(void *ptr ) ;
#line 345 "lex.c"
FILE *yyin  =    (FILE *)0;
#line 345 "lex.c"
FILE *yyout  =    (FILE *)0;
#line 349
int yylineno ;
#line 351 "lex.c"
int yylineno  =    1;
#line 353 "lex.c"
char *yytext  ;
#line 356
static yy_state_type yy_get_previous_state(void) ;
#line 357
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) ;
#line 358
static int yy_get_next_buffer(void) ;
#line 359
static void yy_fatal_error(char const   *msg ) ;
#line 380 "lex.c"
static flex_int16_t const   yy_accept[303]  = 
#line 380
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )75, 
        (flex_int16_t const   )74,      (flex_int16_t const   )66,      (flex_int16_t const   )74,      (flex_int16_t const   )67, 
        (flex_int16_t const   )64,      (flex_int16_t const   )65,      (flex_int16_t const   )70,      (flex_int16_t const   )71, 
        (flex_int16_t const   )63,      (flex_int16_t const   )71,      (flex_int16_t const   )73,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )72,      (flex_int16_t const   )72,      (flex_int16_t const   )73,      (flex_int16_t const   )72, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )61,      (flex_int16_t const   )62,      (flex_int16_t const   )0,      (flex_int16_t const   )68, 
        (flex_int16_t const   )67,      (flex_int16_t const   )69,      (flex_int16_t const   )70,      (flex_int16_t const   )71, 
        (flex_int16_t const   )71,      (flex_int16_t const   )73,      (flex_int16_t const   )71,      (flex_int16_t const   )72, 
        (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )72,      (flex_int16_t const   )72, 
        (flex_int16_t const   )71,      (flex_int16_t const   )71,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )71,      (flex_int16_t const   )71, 
        (flex_int16_t const   )73,      (flex_int16_t const   )71,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )71,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )73, 
        (flex_int16_t const   )59,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )69,      (flex_int16_t const   )70,      (flex_int16_t const   )71,      (flex_int16_t const   )60, 
        (flex_int16_t const   )71,      (flex_int16_t const   )72,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )14, 
        (flex_int16_t const   )73,      (flex_int16_t const   )71,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )25, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )37,      (flex_int16_t const   )19,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )58,      (flex_int16_t const   )69,      (flex_int16_t const   )69,      (flex_int16_t const   )70, 
        (flex_int16_t const   )71,      (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )18, 
        (flex_int16_t const   )16,      (flex_int16_t const   )71,      (flex_int16_t const   )47,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )51,      (flex_int16_t const   )73,      (flex_int16_t const   )2, 
        (flex_int16_t const   )50,      (flex_int16_t const   )73,      (flex_int16_t const   )33,      (flex_int16_t const   )73, 
        (flex_int16_t const   )26,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )28, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )43, 
        (flex_int16_t const   )44,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )34, 
        (flex_int16_t const   )39,      (flex_int16_t const   )12,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )32,      (flex_int16_t const   )30,      (flex_int16_t const   )3,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )27,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )40,      (flex_int16_t const   )73,      (flex_int16_t const   )7, 
        (flex_int16_t const   )73,      (flex_int16_t const   )56,      (flex_int16_t const   )69,      (flex_int16_t const   )69, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )48,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )15,      (flex_int16_t const   )8,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )20,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )17,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )69,      (flex_int16_t const   )69, 
        (flex_int16_t const   )46,      (flex_int16_t const   )73,      (flex_int16_t const   )49,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )29,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )42,      (flex_int16_t const   )53, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )21,      (flex_int16_t const   )73,      (flex_int16_t const   )13, 
        (flex_int16_t const   )35,      (flex_int16_t const   )73,      (flex_int16_t const   )31,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )69,      (flex_int16_t const   )69,      (flex_int16_t const   )9, 
        (flex_int16_t const   )73,      (flex_int16_t const   )54,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )52,      (flex_int16_t const   )57,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )22,      (flex_int16_t const   )73, 
        (flex_int16_t const   )1,      (flex_int16_t const   )73,      (flex_int16_t const   )38,      (flex_int16_t const   )69, 
        (flex_int16_t const   )73,      (flex_int16_t const   )11,      (flex_int16_t const   )73,      (flex_int16_t const   )73, 
        (flex_int16_t const   )73,      (flex_int16_t const   )73,      (flex_int16_t const   )55,      (flex_int16_t const   )4, 
        (flex_int16_t const   )73,      (flex_int16_t const   )69,      (flex_int16_t const   )73,      (flex_int16_t const   )36, 
        (flex_int16_t const   )73,      (flex_int16_t const   )10,      (flex_int16_t const   )24,      (flex_int16_t const   )23, 
        (flex_int16_t const   )41,      (flex_int16_t const   )45,      (flex_int16_t const   )0};
#line 418 "lex.c"
static flex_int32_t const   yy_ec[256]  = 
#line 418
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3,      (flex_int32_t const   )4, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )5,      (flex_int32_t const   )6,      (flex_int32_t const   )7,      (flex_int32_t const   )1, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )8, 
        (flex_int32_t const   )9,      (flex_int32_t const   )8,      (flex_int32_t const   )10,      (flex_int32_t const   )8, 
        (flex_int32_t const   )8,      (flex_int32_t const   )8,      (flex_int32_t const   )11,      (flex_int32_t const   )12, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13, 
        (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )13,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14, 
        (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )14,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )15,      (flex_int32_t const   )16,      (flex_int32_t const   )17, 
        (flex_int32_t const   )18,      (flex_int32_t const   )19,      (flex_int32_t const   )20,      (flex_int32_t const   )21, 
        (flex_int32_t const   )22,      (flex_int32_t const   )23,      (flex_int32_t const   )14,      (flex_int32_t const   )24, 
        (flex_int32_t const   )25,      (flex_int32_t const   )26,      (flex_int32_t const   )27,      (flex_int32_t const   )28, 
        (flex_int32_t const   )29,      (flex_int32_t const   )14,      (flex_int32_t const   )30,      (flex_int32_t const   )31, 
        (flex_int32_t const   )32,      (flex_int32_t const   )33,      (flex_int32_t const   )34,      (flex_int32_t const   )35, 
        (flex_int32_t const   )36,      (flex_int32_t const   )37,      (flex_int32_t const   )38,      (flex_int32_t const   )39, 
        (flex_int32_t const   )1,      (flex_int32_t const   )40,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1};
#line 450 "lex.c"
static flex_int32_t const   yy_meta[41]  = 
#line 450
  {      (flex_int32_t const   )0,      (flex_int32_t const   )1,      (flex_int32_t const   )2,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )1,      (flex_int32_t const   )3, 
        (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )5, 
        (flex_int32_t const   )1,      (flex_int32_t const   )4,      (flex_int32_t const   )3,      (flex_int32_t const   )5, 
        (flex_int32_t const   )5,      (flex_int32_t const   )4,      (flex_int32_t const   )4,      (flex_int32_t const   )4, 
        (flex_int32_t const   )4,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )6,      (flex_int32_t const   )6,      (flex_int32_t const   )3,      (flex_int32_t const   )6, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3, 
        (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )3,      (flex_int32_t const   )1, 
        (flex_int32_t const   )1};
#line 458 "lex.c"
static flex_int16_t const   yy_base[308]  = 
#line 458
  {      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )278, 
        (flex_int16_t const   )949,      (flex_int16_t const   )949,      (flex_int16_t const   )273,      (flex_int16_t const   )0, 
        (flex_int16_t const   )949,      (flex_int16_t const   )949,      (flex_int16_t const   )34,      (flex_int16_t const   )47, 
        (flex_int16_t const   )949,      (flex_int16_t const   )68,      (flex_int16_t const   )62,      (flex_int16_t const   )78, 
        (flex_int16_t const   )53,      (flex_int16_t const   )82,      (flex_int16_t const   )77,      (flex_int16_t const   )81, 
        (flex_int16_t const   )91,      (flex_int16_t const   )102,      (flex_int16_t const   )105,      (flex_int16_t const   )108, 
        (flex_int16_t const   )131,      (flex_int16_t const   )224,      (flex_int16_t const   )117,      (flex_int16_t const   )111, 
        (flex_int16_t const   )137,      (flex_int16_t const   )143,      (flex_int16_t const   )150,      (flex_int16_t const   )114, 
        (flex_int16_t const   )152,      (flex_int16_t const   )122,      (flex_int16_t const   )166,      (flex_int16_t const   )169, 
        (flex_int16_t const   )949,      (flex_int16_t const   )949,      (flex_int16_t const   )243,      (flex_int16_t const   )949, 
        (flex_int16_t const   )0,      (flex_int16_t const   )176,      (flex_int16_t const   )182,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )116,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )74,      (flex_int16_t const   )227,      (flex_int16_t const   )0,      (flex_int16_t const   )193, 
        (flex_int16_t const   )126,      (flex_int16_t const   )195,      (flex_int16_t const   )186,      (flex_int16_t const   )187, 
        (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )181,      (flex_int16_t const   )144, 
        (flex_int16_t const   )195,      (flex_int16_t const   )190,      (flex_int16_t const   )196,      (flex_int16_t const   )198, 
        (flex_int16_t const   )125,      (flex_int16_t const   )203,      (flex_int16_t const   )197,      (flex_int16_t const   )212, 
        (flex_int16_t const   )220,      (flex_int16_t const   )222,      (flex_int16_t const   )225,      (flex_int16_t const   )228, 
        (flex_int16_t const   )231,      (flex_int16_t const   )230,      (flex_int16_t const   )123,      (flex_int16_t const   )244, 
        (flex_int16_t const   )155,      (flex_int16_t const   )236,      (flex_int16_t const   )251,      (flex_int16_t const   )253, 
        (flex_int16_t const   )256,      (flex_int16_t const   )261,      (flex_int16_t const   )258,      (flex_int16_t const   )263, 
        (flex_int16_t const   )264,      (flex_int16_t const   )266,      (flex_int16_t const   )277,      (flex_int16_t const   )283, 
        (flex_int16_t const   )280,      (flex_int16_t const   )292,      (flex_int16_t const   )293,      (flex_int16_t const   )294, 
        (flex_int16_t const   )295,      (flex_int16_t const   )301,      (flex_int16_t const   )302,      (flex_int16_t const   )309, 
        (flex_int16_t const   )319,      (flex_int16_t const   )325,      (flex_int16_t const   )111,      (flex_int16_t const   )330, 
        (flex_int16_t const   )94,      (flex_int16_t const   )72,      (flex_int16_t const   )331,      (flex_int16_t const   )332, 
        (flex_int16_t const   )337,      (flex_int16_t const   )338,      (flex_int16_t const   )340,      (flex_int16_t const   )343, 
        (flex_int16_t const   )345,      (flex_int16_t const   )75,      (flex_int16_t const   )346,      (flex_int16_t const   )356, 
        (flex_int16_t const   )357,      (flex_int16_t const   )359,      (flex_int16_t const   )365,      (flex_int16_t const   )371, 
        (flex_int16_t const   )366,      (flex_int16_t const   )373,      (flex_int16_t const   )378,      (flex_int16_t const   )379, 
        (flex_int16_t const   )384,      (flex_int16_t const   )392,      (flex_int16_t const   )393,      (flex_int16_t const   )395, 
        (flex_int16_t const   )398,      (flex_int16_t const   )401,      (flex_int16_t const   )406,      (flex_int16_t const   )407, 
        (flex_int16_t const   )412,      (flex_int16_t const   )417,      (flex_int16_t const   )424,      (flex_int16_t const   )425, 
        (flex_int16_t const   )426,      (flex_int16_t const   )427,      (flex_int16_t const   )440,      (flex_int16_t const   )441, 
        (flex_int16_t const   )442,      (flex_int16_t const   )447,      (flex_int16_t const   )448,      (flex_int16_t const   )449, 
        (flex_int16_t const   )455,      (flex_int16_t const   )458,      (flex_int16_t const   )460,      (flex_int16_t const   )463, 
        (flex_int16_t const   )465,      (flex_int16_t const   )466,      (flex_int16_t const   )474,      (flex_int16_t const   )476, 
        (flex_int16_t const   )477,      (flex_int16_t const   )479,      (flex_int16_t const   )482,      (flex_int16_t const   )490, 
        (flex_int16_t const   )491,      (flex_int16_t const   )384,      (flex_int16_t const   )496,      (flex_int16_t const   )502, 
        (flex_int16_t const   )53,      (flex_int16_t const   )507,      (flex_int16_t const   )42,      (flex_int16_t const   )508, 
        (flex_int16_t const   )509,      (flex_int16_t const   )510,      (flex_int16_t const   )516,      (flex_int16_t const   )518, 
        (flex_int16_t const   )526,      (flex_int16_t const   )26,      (flex_int16_t const   )529,      (flex_int16_t const   )532, 
        (flex_int16_t const   )535,      (flex_int16_t const   )534,      (flex_int16_t const   )537,      (flex_int16_t const   )540, 
        (flex_int16_t const   )545,      (flex_int16_t const   )546,      (flex_int16_t const   )547,      (flex_int16_t const   )548, 
        (flex_int16_t const   )553,      (flex_int16_t const   )554,      (flex_int16_t const   )559,      (flex_int16_t const   )561, 
        (flex_int16_t const   )568,      (flex_int16_t const   )567,      (flex_int16_t const   )569,      (flex_int16_t const   )570, 
        (flex_int16_t const   )576,      (flex_int16_t const   )579,      (flex_int16_t const   )585,      (flex_int16_t const   )586, 
        (flex_int16_t const   )587,      (flex_int16_t const   )593,      (flex_int16_t const   )594,      (flex_int16_t const   )595, 
        (flex_int16_t const   )596,      (flex_int16_t const   )603,      (flex_int16_t const   )604,      (flex_int16_t const   )609, 
        (flex_int16_t const   )610,      (flex_int16_t const   )611,      (flex_int16_t const   )616,      (flex_int16_t const   )617, 
        (flex_int16_t const   )618,      (flex_int16_t const   )624,      (flex_int16_t const   )625,      (flex_int16_t const   )631, 
        (flex_int16_t const   )632,      (flex_int16_t const   )633,      (flex_int16_t const   )640,      (flex_int16_t const   )41, 
        (flex_int16_t const   )645,      (flex_int16_t const   )646,      (flex_int16_t const   )651,      (flex_int16_t const   )652, 
        (flex_int16_t const   )653,      (flex_int16_t const   )654,      (flex_int16_t const   )659,      (flex_int16_t const   )660, 
        (flex_int16_t const   )662,      (flex_int16_t const   )669,      (flex_int16_t const   )671,      (flex_int16_t const   )672, 
        (flex_int16_t const   )677,      (flex_int16_t const   )680,      (flex_int16_t const   )682,      (flex_int16_t const   )685, 
        (flex_int16_t const   )690,      (flex_int16_t const   )691,      (flex_int16_t const   )693,      (flex_int16_t const   )699, 
        (flex_int16_t const   )707,      (flex_int16_t const   )712,      (flex_int16_t const   )713,      (flex_int16_t const   )714, 
        (flex_int16_t const   )720,      (flex_int16_t const   )721,      (flex_int16_t const   )722,      (flex_int16_t const   )728, 
        (flex_int16_t const   )729,      (flex_int16_t const   )730,      (flex_int16_t const   )734,      (flex_int16_t const   )746, 
        (flex_int16_t const   )740,      (flex_int16_t const   )750,      (flex_int16_t const   )752,      (flex_int16_t const   )753, 
        (flex_int16_t const   )755,      (flex_int16_t const   )758,      (flex_int16_t const   )761,      (flex_int16_t const   )763, 
        (flex_int16_t const   )766,      (flex_int16_t const   )768,      (flex_int16_t const   )769,      (flex_int16_t const   )774, 
        (flex_int16_t const   )776,      (flex_int16_t const   )781,      (flex_int16_t const   )788,      (flex_int16_t const   )783, 
        (flex_int16_t const   )790,      (flex_int16_t const   )795,      (flex_int16_t const   )798,      (flex_int16_t const   )800, 
        (flex_int16_t const   )801,      (flex_int16_t const   )806,      (flex_int16_t const   )808,      (flex_int16_t const   )809, 
        (flex_int16_t const   )811,      (flex_int16_t const   )819,      (flex_int16_t const   )39,      (flex_int16_t const   )823, 
        (flex_int16_t const   )824,      (flex_int16_t const   )825,      (flex_int16_t const   )826,      (flex_int16_t const   )832, 
        (flex_int16_t const   )833,      (flex_int16_t const   )835,      (flex_int16_t const   )838,      (flex_int16_t const   )841, 
        (flex_int16_t const   )844,      (flex_int16_t const   )843,      (flex_int16_t const   )852,      (flex_int16_t const   )857, 
        (flex_int16_t const   )858,      (flex_int16_t const   )859,      (flex_int16_t const   )865,      (flex_int16_t const   )865, 
        (flex_int16_t const   )870,      (flex_int16_t const   )872,      (flex_int16_t const   )873,      (flex_int16_t const   )878, 
        (flex_int16_t const   )880,      (flex_int16_t const   )879,      (flex_int16_t const   )881,      (flex_int16_t const   )886, 
        (flex_int16_t const   )888,      (flex_int16_t const   )949,      (flex_int16_t const   )889,      (flex_int16_t const   )894, 
        (flex_int16_t const   )897,      (flex_int16_t const   )902,      (flex_int16_t const   )905,      (flex_int16_t const   )907, 
        (flex_int16_t const   )908,      (flex_int16_t const   )910,      (flex_int16_t const   )949,      (flex_int16_t const   )928, 
        (flex_int16_t const   )934,      (flex_int16_t const   )938,      (flex_int16_t const   )941,      (flex_int16_t const   )942};
#line 496 "lex.c"
static flex_int16_t const   yy_def[308]  = 
#line 496
  {      (flex_int16_t const   )0,      (flex_int16_t const   )302,      (flex_int16_t const   )1,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )304, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )305,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )13, 
        (flex_int16_t const   )15,      (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )24,      (flex_int16_t const   )305,      (flex_int16_t const   )24, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )303,      (flex_int16_t const   )302, 
        (flex_int16_t const   )304,      (flex_int16_t const   )302,      (flex_int16_t const   )13,      (flex_int16_t const   )306, 
        (flex_int16_t const   )13,      (flex_int16_t const   )305,      (flex_int16_t const   )11,      (flex_int16_t const   )307, 
        (flex_int16_t const   )15,      (flex_int16_t const   )13,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )15,      (flex_int16_t const   )13,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )13,      (flex_int16_t const   )13, 
        (flex_int16_t const   )305,      (flex_int16_t const   )13,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )13,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )24,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )302,      (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )305, 
        (flex_int16_t const   )13,      (flex_int16_t const   )24,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )13,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )305,      (flex_int16_t const   )24,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )13,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )302, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )302,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )0,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302};
#line 534 "lex.c"
static flex_int16_t const   yy_nxt[990]  = 
#line 534
  {      (flex_int16_t const   )0,      (flex_int16_t const   )4,      (flex_int16_t const   )5,      (flex_int16_t const   )6, 
        (flex_int16_t const   )7,      (flex_int16_t const   )8,      (flex_int16_t const   )9,      (flex_int16_t const   )4, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )11, 
        (flex_int16_t const   )12,      (flex_int16_t const   )13,      (flex_int16_t const   )14,      (flex_int16_t const   )15, 
        (flex_int16_t const   )16,      (flex_int16_t const   )17,      (flex_int16_t const   )18,      (flex_int16_t const   )19, 
        (flex_int16_t const   )20,      (flex_int16_t const   )21,      (flex_int16_t const   )22,      (flex_int16_t const   )23, 
        (flex_int16_t const   )24,      (flex_int16_t const   )25,      (flex_int16_t const   )26,      (flex_int16_t const   )27, 
        (flex_int16_t const   )14,      (flex_int16_t const   )28,      (flex_int16_t const   )29,      (flex_int16_t const   )30, 
        (flex_int16_t const   )31,      (flex_int16_t const   )32,      (flex_int16_t const   )33,      (flex_int16_t const   )34, 
        (flex_int16_t const   )14,      (flex_int16_t const   )35,      (flex_int16_t const   )14,      (flex_int16_t const   )36, 
        (flex_int16_t const   )37,      (flex_int16_t const   )41,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )43,      (flex_int16_t const   )238,      (flex_int16_t const   )44, 
        (flex_int16_t const   )153,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )43, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )46,      (flex_int16_t const   )215, 
        (flex_int16_t const   )43,      (flex_int16_t const   )210,      (flex_int16_t const   )46,      (flex_int16_t const   )46, 
        (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )43, 
        (flex_int16_t const   )52,      (flex_int16_t const   )302,      (flex_int16_t const   )44,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )302,      (flex_int16_t const   )47,      (flex_int16_t const   )302, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )43, 
        (flex_int16_t const   )50,      (flex_int16_t const   )44,      (flex_int16_t const   )208,      (flex_int16_t const   )44, 
        (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44,      (flex_int16_t const   )44, 
        (flex_int16_t const   )44,      (flex_int16_t const   )46,      (flex_int16_t const   )165,      (flex_int16_t const   )44, 
        (flex_int16_t const   )58,      (flex_int16_t const   )48,      (flex_int16_t const   )48,      (flex_int16_t const   )49, 
        (flex_int16_t const   )59,      (flex_int16_t const   )53,      (flex_int16_t const   )61,      (flex_int16_t const   )158, 
        (flex_int16_t const   )60,      (flex_int16_t const   )50,      (flex_int16_t const   )50,      (flex_int16_t const   )50, 
        (flex_int16_t const   )54,      (flex_int16_t const   )51,      (flex_int16_t const   )64,      (flex_int16_t const   )55, 
        (flex_int16_t const   )62,      (flex_int16_t const   )302,      (flex_int16_t const   )56,      (flex_int16_t const   )57, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )65,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )63,      (flex_int16_t const   )157,      (flex_int16_t const   )302, 
        (flex_int16_t const   )68,      (flex_int16_t const   )302,      (flex_int16_t const   )66,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )74,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )156,      (flex_int16_t const   )89, 
        (flex_int16_t const   )67,      (flex_int16_t const   )302,      (flex_int16_t const   )75,      (flex_int16_t const   )69, 
        (flex_int16_t const   )72,      (flex_int16_t const   )70,      (flex_int16_t const   )302,      (flex_int16_t const   )76, 
        (flex_int16_t const   )77,      (flex_int16_t const   )93,      (flex_int16_t const   )47,      (flex_int16_t const   )100, 
        (flex_int16_t const   )302,      (flex_int16_t const   )73,      (flex_int16_t const   )50,      (flex_int16_t const   )50, 
        (flex_int16_t const   )302,      (flex_int16_t const   )131,      (flex_int16_t const   )302,      (flex_int16_t const   )117, 
        (flex_int16_t const   )78,      (flex_int16_t const   )101,      (flex_int16_t const   )302,      (flex_int16_t const   )50, 
        (flex_int16_t const   )50,      (flex_int16_t const   )302,      (flex_int16_t const   )50,      (flex_int16_t const   )302, 
        (flex_int16_t const   )79,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )109,      (flex_int16_t const   )80,      (flex_int16_t const   )302,      (flex_int16_t const   )81, 
        (flex_int16_t const   )82,      (flex_int16_t const   )85,      (flex_int16_t const   )90,      (flex_int16_t const   )110, 
        (flex_int16_t const   )83,      (flex_int16_t const   )302,      (flex_int16_t const   )84,      (flex_int16_t const   )133, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )86,      (flex_int16_t const   )91, 
        (flex_int16_t const   )302,      (flex_int16_t const   )94,      (flex_int16_t const   )87,      (flex_int16_t const   )92, 
        (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )88, 
        (flex_int16_t const   )95,      (flex_int16_t const   )41,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )97,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )103,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )114, 
        (flex_int16_t const   )113,      (flex_int16_t const   )108,      (flex_int16_t const   )302,      (flex_int16_t const   )105, 
        (flex_int16_t const   )104,      (flex_int16_t const   )115,      (flex_int16_t const   )106,      (flex_int16_t const   )302, 
        (flex_int16_t const   )120,      (flex_int16_t const   )116,      (flex_int16_t const   )107,      (flex_int16_t const   )302, 
        (flex_int16_t const   )102,      (flex_int16_t const   )111,      (flex_int16_t const   )112,      (flex_int16_t const   )302, 
        (flex_int16_t const   )118,      (flex_int16_t const   )302,      (flex_int16_t const   )99,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )119,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )121,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )98,      (flex_int16_t const   )123,      (flex_int16_t const   )39,      (flex_int16_t const   )302, 
        (flex_int16_t const   )130,      (flex_int16_t const   )127,      (flex_int16_t const   )122,      (flex_int16_t const   )302, 
        (flex_int16_t const   )71,      (flex_int16_t const   )124,      (flex_int16_t const   )125,      (flex_int16_t const   )302, 
        (flex_int16_t const   )128,      (flex_int16_t const   )129,      (flex_int16_t const   )302,      (flex_int16_t const   )126, 
        (flex_int16_t const   )302,      (flex_int16_t const   )132,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )134,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )39,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )140,      (flex_int16_t const   )139,      (flex_int16_t const   )136,      (flex_int16_t const   )135, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )137,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )138,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )141, 
        (flex_int16_t const   )142,      (flex_int16_t const   )143,      (flex_int16_t const   )144,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )145, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )149,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )148, 
        (flex_int16_t const   )302,      (flex_int16_t const   )146,      (flex_int16_t const   )147,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )151,      (flex_int16_t const   )153,      (flex_int16_t const   )154, 
        (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )302,      (flex_int16_t const   )150, 
        (flex_int16_t const   )41,      (flex_int16_t const   )155,      (flex_int16_t const   )155,      (flex_int16_t const   )155, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )152,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )159,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )163, 
        (flex_int16_t const   )164,      (flex_int16_t const   )302,      (flex_int16_t const   )160,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )161,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )162,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )168,      (flex_int16_t const   )167, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )170,      (flex_int16_t const   )302,      (flex_int16_t const   )166, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )169, 
        (flex_int16_t const   )171,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )302, 
        (flex_int16_t const   )173,      (flex_int16_t const   )174,      (flex_int16_t const   )172,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )176,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )175,      (flex_int16_t const   )179, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )183, 
        (flex_int16_t const   )184,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )182,      (flex_int16_t const   )302,      (flex_int16_t const   )177,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )178,      (flex_int16_t const   )302,      (flex_int16_t const   )180, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )181,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )185,      (flex_int16_t const   )186,      (flex_int16_t const   )187, 
        (flex_int16_t const   )188,      (flex_int16_t const   )189,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )190,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )193,      (flex_int16_t const   )302,      (flex_int16_t const   )192, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )191,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )196, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )194, 
        (flex_int16_t const   )195,      (flex_int16_t const   )302,      (flex_int16_t const   )199,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )200, 
        (flex_int16_t const   )201,      (flex_int16_t const   )302,      (flex_int16_t const   )197,      (flex_int16_t const   )198, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )202,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )153, 
        (flex_int16_t const   )207,      (flex_int16_t const   )207,      (flex_int16_t const   )207,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )203,      (flex_int16_t const   )155,      (flex_int16_t const   )155, 
        (flex_int16_t const   )155,      (flex_int16_t const   )204,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )205,      (flex_int16_t const   )302, 
        (flex_int16_t const   )211,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )212,      (flex_int16_t const   )302, 
        (flex_int16_t const   )209,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )214, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )213,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )216,      (flex_int16_t const   )217,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )218,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )220, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )219, 
        (flex_int16_t const   )302,      (flex_int16_t const   )221,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )224,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )222,      (flex_int16_t const   )223,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )226, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )225, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )229,      (flex_int16_t const   )227,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )228, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )232,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )231,      (flex_int16_t const   )233,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )230,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )234,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )235,      (flex_int16_t const   )238, 
        (flex_int16_t const   )239,      (flex_int16_t const   )239,      (flex_int16_t const   )239,      (flex_int16_t const   )236, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )237, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )244,      (flex_int16_t const   )302,      (flex_int16_t const   )241,      (flex_int16_t const   )243, 
        (flex_int16_t const   )302,      (flex_int16_t const   )240,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )242,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )246,      (flex_int16_t const   )245,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )249,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )247,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )248, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )251, 
        (flex_int16_t const   )255,      (flex_int16_t const   )250,      (flex_int16_t const   )302,      (flex_int16_t const   )254, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )252, 
        (flex_int16_t const   )256,      (flex_int16_t const   )253,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )257,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )258,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )261,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )265,      (flex_int16_t const   )265, 
        (flex_int16_t const   )265,      (flex_int16_t const   )302,      (flex_int16_t const   )259,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )262,      (flex_int16_t const   )260,      (flex_int16_t const   )302, 
        (flex_int16_t const   )263,      (flex_int16_t const   )238,      (flex_int16_t const   )266,      (flex_int16_t const   )266, 
        (flex_int16_t const   )266,      (flex_int16_t const   )302,      (flex_int16_t const   )264,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )267, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )268,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )269,      (flex_int16_t const   )302, 
        (flex_int16_t const   )272,      (flex_int16_t const   )302,      (flex_int16_t const   )273,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )271, 
        (flex_int16_t const   )302,      (flex_int16_t const   )270,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )275,      (flex_int16_t const   )302, 
        (flex_int16_t const   )277,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )276, 
        (flex_int16_t const   )274,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )278,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )280,      (flex_int16_t const   )279,      (flex_int16_t const   )283, 
        (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )282,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )281,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )284, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )285,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )288,      (flex_int16_t const   )289,      (flex_int16_t const   )286,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )290, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )287, 
        (flex_int16_t const   )302,      (flex_int16_t const   )293,      (flex_int16_t const   )293,      (flex_int16_t const   )293, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )292,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )291,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )298,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )294,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )299,      (flex_int16_t const   )296, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )295,      (flex_int16_t const   )297, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )300,      (flex_int16_t const   )302, 
        (flex_int16_t const   )301,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )38, 
        (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )38,      (flex_int16_t const   )40, 
        (flex_int16_t const   )302,      (flex_int16_t const   )40,      (flex_int16_t const   )40,      (flex_int16_t const   )40, 
        (flex_int16_t const   )40,      (flex_int16_t const   )45,      (flex_int16_t const   )45,      (flex_int16_t const   )45, 
        (flex_int16_t const   )45,      (flex_int16_t const   )43,      (flex_int16_t const   )43,      (flex_int16_t const   )47, 
        (flex_int16_t const   )47,      (flex_int16_t const   )3,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302};
#line 646 "lex.c"
static flex_int16_t const   yy_chk[990]  = 
#line 646
  {      (flex_int16_t const   )0,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1,      (flex_int16_t const   )1, 
        (flex_int16_t const   )1,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )266,      (flex_int16_t const   )10, 
        (flex_int16_t const   )207,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10, 
        (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )10,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )165, 
        (flex_int16_t const   )11,      (flex_int16_t const   )158,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11,      (flex_int16_t const   )11, 
        (flex_int16_t const   )16,      (flex_int16_t const   )14,      (flex_int16_t const   )16,      (flex_int16_t const   )11, 
        (flex_int16_t const   )11,      (flex_int16_t const   )14,      (flex_int16_t const   )11,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )13, 
        (flex_int16_t const   )16,      (flex_int16_t const   )13,      (flex_int16_t const   )156,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )13,      (flex_int16_t const   )13, 
        (flex_int16_t const   )13,      (flex_int16_t const   )15,      (flex_int16_t const   )109,      (flex_int16_t const   )48, 
        (flex_int16_t const   )18,      (flex_int16_t const   )15,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )18,      (flex_int16_t const   )17,      (flex_int16_t const   )19,      (flex_int16_t const   )101, 
        (flex_int16_t const   )18,      (flex_int16_t const   )48,      (flex_int16_t const   )15,      (flex_int16_t const   )15, 
        (flex_int16_t const   )17,      (flex_int16_t const   )15,      (flex_int16_t const   )20,      (flex_int16_t const   )17, 
        (flex_int16_t const   )19,      (flex_int16_t const   )21,      (flex_int16_t const   )17,      (flex_int16_t const   )17, 
        (flex_int16_t const   )22,      (flex_int16_t const   )21,      (flex_int16_t const   )20,      (flex_int16_t const   )23, 
        (flex_int16_t const   )22,      (flex_int16_t const   )19,      (flex_int16_t const   )100,      (flex_int16_t const   )23, 
        (flex_int16_t const   )22,      (flex_int16_t const   )31,      (flex_int16_t const   )20,      (flex_int16_t const   )45, 
        (flex_int16_t const   )26,      (flex_int16_t const   )31,      (flex_int16_t const   )27,      (flex_int16_t const   )45, 
        (flex_int16_t const   )26,      (flex_int16_t const   )33,      (flex_int16_t const   )98,      (flex_int16_t const   )31, 
        (flex_int16_t const   )21,      (flex_int16_t const   )33,      (flex_int16_t const   )27,      (flex_int16_t const   )23, 
        (flex_int16_t const   )26,      (flex_int16_t const   )23,      (flex_int16_t const   )24,      (flex_int16_t const   )27, 
        (flex_int16_t const   )27,      (flex_int16_t const   )33,      (flex_int16_t const   )24,      (flex_int16_t const   )52, 
        (flex_int16_t const   )28,      (flex_int16_t const   )26,      (flex_int16_t const   )24,      (flex_int16_t const   )24, 
        (flex_int16_t const   )28,      (flex_int16_t const   )74,      (flex_int16_t const   )29,      (flex_int16_t const   )64, 
        (flex_int16_t const   )28,      (flex_int16_t const   )52,      (flex_int16_t const   )29,      (flex_int16_t const   )24, 
        (flex_int16_t const   )24,      (flex_int16_t const   )30,      (flex_int16_t const   )24,      (flex_int16_t const   )32, 
        (flex_int16_t const   )28,      (flex_int16_t const   )30,      (flex_int16_t const   )76,      (flex_int16_t const   )32, 
        (flex_int16_t const   )59,      (flex_int16_t const   )28,      (flex_int16_t const   )76,      (flex_int16_t const   )28, 
        (flex_int16_t const   )29,      (flex_int16_t const   )30,      (flex_int16_t const   )32,      (flex_int16_t const   )59, 
        (flex_int16_t const   )29,      (flex_int16_t const   )34,      (flex_int16_t const   )29,      (flex_int16_t const   )76, 
        (flex_int16_t const   )35,      (flex_int16_t const   )34,      (flex_int16_t const   )30,      (flex_int16_t const   )32, 
        (flex_int16_t const   )35,      (flex_int16_t const   )34,      (flex_int16_t const   )30,      (flex_int16_t const   )32, 
        (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )41,      (flex_int16_t const   )30, 
        (flex_int16_t const   )35,      (flex_int16_t const   )42,      (flex_int16_t const   )42,      (flex_int16_t const   )42, 
        (flex_int16_t const   )42,      (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )56, 
        (flex_int16_t const   )57,      (flex_int16_t const   )54,      (flex_int16_t const   )55,      (flex_int16_t const   )56, 
        (flex_int16_t const   )57,      (flex_int16_t const   )54,      (flex_int16_t const   )60,      (flex_int16_t const   )62, 
        (flex_int16_t const   )66,      (flex_int16_t const   )63,      (flex_int16_t const   )60,      (flex_int16_t const   )62, 
        (flex_int16_t const   )66,      (flex_int16_t const   )63,      (flex_int16_t const   )65,      (flex_int16_t const   )62, 
        (flex_int16_t const   )61,      (flex_int16_t const   )58,      (flex_int16_t const   )65,      (flex_int16_t const   )55, 
        (flex_int16_t const   )54,      (flex_int16_t const   )63,      (flex_int16_t const   )56,      (flex_int16_t const   )67, 
        (flex_int16_t const   )66,      (flex_int16_t const   )63,      (flex_int16_t const   )57,      (flex_int16_t const   )67, 
        (flex_int16_t const   )53,      (flex_int16_t const   )60,      (flex_int16_t const   )60,      (flex_int16_t const   )68, 
        (flex_int16_t const   )65,      (flex_int16_t const   )69,      (flex_int16_t const   )51,      (flex_int16_t const   )68, 
        (flex_int16_t const   )70,      (flex_int16_t const   )69,      (flex_int16_t const   )65,      (flex_int16_t const   )71, 
        (flex_int16_t const   )70,      (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )71, 
        (flex_int16_t const   )67,      (flex_int16_t const   )73,      (flex_int16_t const   )72,      (flex_int16_t const   )77, 
        (flex_int16_t const   )49,      (flex_int16_t const   )69,      (flex_int16_t const   )38,      (flex_int16_t const   )77, 
        (flex_int16_t const   )73,      (flex_int16_t const   )71,      (flex_int16_t const   )68,      (flex_int16_t const   )75, 
        (flex_int16_t const   )25,      (flex_int16_t const   )69,      (flex_int16_t const   )69,      (flex_int16_t const   )75, 
        (flex_int16_t const   )71,      (flex_int16_t const   )72,      (flex_int16_t const   )78,      (flex_int16_t const   )70, 
        (flex_int16_t const   )79,      (flex_int16_t const   )75,      (flex_int16_t const   )78,      (flex_int16_t const   )80, 
        (flex_int16_t const   )79,      (flex_int16_t const   )82,      (flex_int16_t const   )77,      (flex_int16_t const   )80, 
        (flex_int16_t const   )81,      (flex_int16_t const   )82,      (flex_int16_t const   )83,      (flex_int16_t const   )84, 
        (flex_int16_t const   )81,      (flex_int16_t const   )85,      (flex_int16_t const   )83,      (flex_int16_t const   )84, 
        (flex_int16_t const   )6,      (flex_int16_t const   )85,      (flex_int16_t const   )3,      (flex_int16_t const   )0, 
        (flex_int16_t const   )83,      (flex_int16_t const   )82,      (flex_int16_t const   )79,      (flex_int16_t const   )78, 
        (flex_int16_t const   )86,      (flex_int16_t const   )0,      (flex_int16_t const   )80,      (flex_int16_t const   )88, 
        (flex_int16_t const   )86,      (flex_int16_t const   )81,      (flex_int16_t const   )87,      (flex_int16_t const   )88, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )87,      (flex_int16_t const   )84, 
        (flex_int16_t const   )85,      (flex_int16_t const   )86,      (flex_int16_t const   )87,      (flex_int16_t const   )89, 
        (flex_int16_t const   )90,      (flex_int16_t const   )91,      (flex_int16_t const   )92,      (flex_int16_t const   )89, 
        (flex_int16_t const   )90,      (flex_int16_t const   )91,      (flex_int16_t const   )92,      (flex_int16_t const   )0, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )0,      (flex_int16_t const   )88, 
        (flex_int16_t const   )93,      (flex_int16_t const   )94,      (flex_int16_t const   )92,      (flex_int16_t const   )0, 
        (flex_int16_t const   )95,      (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )91, 
        (flex_int16_t const   )95,      (flex_int16_t const   )89,      (flex_int16_t const   )90,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )94,      (flex_int16_t const   )96,      (flex_int16_t const   )96, 
        (flex_int16_t const   )96,      (flex_int16_t const   )96,      (flex_int16_t const   )0,      (flex_int16_t const   )93, 
        (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97,      (flex_int16_t const   )97, 
        (flex_int16_t const   )0,      (flex_int16_t const   )99,      (flex_int16_t const   )102,      (flex_int16_t const   )103, 
        (flex_int16_t const   )95,      (flex_int16_t const   )99,      (flex_int16_t const   )102,      (flex_int16_t const   )103, 
        (flex_int16_t const   )104,      (flex_int16_t const   )105,      (flex_int16_t const   )102,      (flex_int16_t const   )106, 
        (flex_int16_t const   )104,      (flex_int16_t const   )105,      (flex_int16_t const   )107,      (flex_int16_t const   )106, 
        (flex_int16_t const   )108,      (flex_int16_t const   )110,      (flex_int16_t const   )107,      (flex_int16_t const   )0, 
        (flex_int16_t const   )108,      (flex_int16_t const   )110,      (flex_int16_t const   )0,      (flex_int16_t const   )106, 
        (flex_int16_t const   )108,      (flex_int16_t const   )0,      (flex_int16_t const   )103,      (flex_int16_t const   )111, 
        (flex_int16_t const   )112,      (flex_int16_t const   )104,      (flex_int16_t const   )113,      (flex_int16_t const   )111, 
        (flex_int16_t const   )112,      (flex_int16_t const   )105,      (flex_int16_t const   )113,      (flex_int16_t const   )0, 
        (flex_int16_t const   )114,      (flex_int16_t const   )116,      (flex_int16_t const   )112,      (flex_int16_t const   )111, 
        (flex_int16_t const   )114,      (flex_int16_t const   )116,      (flex_int16_t const   )115,      (flex_int16_t const   )0, 
        (flex_int16_t const   )117,      (flex_int16_t const   )114,      (flex_int16_t const   )115,      (flex_int16_t const   )110, 
        (flex_int16_t const   )117,      (flex_int16_t const   )118,      (flex_int16_t const   )119,      (flex_int16_t const   )113, 
        (flex_int16_t const   )115,      (flex_int16_t const   )118,      (flex_int16_t const   )119,      (flex_int16_t const   )120, 
        (flex_int16_t const   )153,      (flex_int16_t const   )153,      (flex_int16_t const   )153,      (flex_int16_t const   )120, 
        (flex_int16_t const   )117,      (flex_int16_t const   )118,      (flex_int16_t const   )116,      (flex_int16_t const   )121, 
        (flex_int16_t const   )122,      (flex_int16_t const   )119,      (flex_int16_t const   )123,      (flex_int16_t const   )121, 
        (flex_int16_t const   )122,      (flex_int16_t const   )124,      (flex_int16_t const   )123,      (flex_int16_t const   )0, 
        (flex_int16_t const   )125,      (flex_int16_t const   )124,      (flex_int16_t const   )118,      (flex_int16_t const   )122, 
        (flex_int16_t const   )125,      (flex_int16_t const   )126,      (flex_int16_t const   )127,      (flex_int16_t const   )126, 
        (flex_int16_t const   )126,      (flex_int16_t const   )126,      (flex_int16_t const   )127,      (flex_int16_t const   )128, 
        (flex_int16_t const   )125,      (flex_int16_t const   )0,      (flex_int16_t const   )120,      (flex_int16_t const   )128, 
        (flex_int16_t const   )129,      (flex_int16_t const   )121,      (flex_int16_t const   )0,      (flex_int16_t const   )123, 
        (flex_int16_t const   )129,      (flex_int16_t const   )0,      (flex_int16_t const   )124,      (flex_int16_t const   )130, 
        (flex_int16_t const   )131,      (flex_int16_t const   )132,      (flex_int16_t const   )133,      (flex_int16_t const   )130, 
        (flex_int16_t const   )131,      (flex_int16_t const   )132,      (flex_int16_t const   )133,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )128,      (flex_int16_t const   )129,      (flex_int16_t const   )130, 
        (flex_int16_t const   )131,      (flex_int16_t const   )132,      (flex_int16_t const   )0,      (flex_int16_t const   )134, 
        (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )133,      (flex_int16_t const   )134, 
        (flex_int16_t const   )135,      (flex_int16_t const   )136,      (flex_int16_t const   )137,      (flex_int16_t const   )138, 
        (flex_int16_t const   )139,      (flex_int16_t const   )0,      (flex_int16_t const   )137,      (flex_int16_t const   )138, 
        (flex_int16_t const   )139,      (flex_int16_t const   )136,      (flex_int16_t const   )140,      (flex_int16_t const   )135, 
        (flex_int16_t const   )0,      (flex_int16_t const   )141,      (flex_int16_t const   )140,      (flex_int16_t const   )142, 
        (flex_int16_t const   )134,      (flex_int16_t const   )141,      (flex_int16_t const   )143,      (flex_int16_t const   )142, 
        (flex_int16_t const   )144,      (flex_int16_t const   )145,      (flex_int16_t const   )143,      (flex_int16_t const   )139, 
        (flex_int16_t const   )144,      (flex_int16_t const   )145,      (flex_int16_t const   )0,      (flex_int16_t const   )137, 
        (flex_int16_t const   )138,      (flex_int16_t const   )146,      (flex_int16_t const   )144,      (flex_int16_t const   )147, 
        (flex_int16_t const   )148,      (flex_int16_t const   )146,      (flex_int16_t const   )149,      (flex_int16_t const   )147, 
        (flex_int16_t const   )148,      (flex_int16_t const   )150,      (flex_int16_t const   )149,      (flex_int16_t const   )145, 
        (flex_int16_t const   )146,      (flex_int16_t const   )150,      (flex_int16_t const   )142,      (flex_int16_t const   )143, 
        (flex_int16_t const   )0,      (flex_int16_t const   )151,      (flex_int16_t const   )152,      (flex_int16_t const   )0, 
        (flex_int16_t const   )148,      (flex_int16_t const   )151,      (flex_int16_t const   )152,      (flex_int16_t const   )154, 
        (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )154,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )149,      (flex_int16_t const   )155,      (flex_int16_t const   )155, 
        (flex_int16_t const   )155,      (flex_int16_t const   )150,      (flex_int16_t const   )157,      (flex_int16_t const   )159, 
        (flex_int16_t const   )160,      (flex_int16_t const   )161,      (flex_int16_t const   )157,      (flex_int16_t const   )159, 
        (flex_int16_t const   )160,      (flex_int16_t const   )161,      (flex_int16_t const   )151,      (flex_int16_t const   )162, 
        (flex_int16_t const   )159,      (flex_int16_t const   )163,      (flex_int16_t const   )0,      (flex_int16_t const   )162, 
        (flex_int16_t const   )0,      (flex_int16_t const   )163,      (flex_int16_t const   )160,      (flex_int16_t const   )0, 
        (flex_int16_t const   )157,      (flex_int16_t const   )164,      (flex_int16_t const   )0,      (flex_int16_t const   )162, 
        (flex_int16_t const   )166,      (flex_int16_t const   )164,      (flex_int16_t const   )161,      (flex_int16_t const   )167, 
        (flex_int16_t const   )166,      (flex_int16_t const   )169,      (flex_int16_t const   )168,      (flex_int16_t const   )167, 
        (flex_int16_t const   )170,      (flex_int16_t const   )169,      (flex_int16_t const   )168,      (flex_int16_t const   )171, 
        (flex_int16_t const   )170,      (flex_int16_t const   )167,      (flex_int16_t const   )168,      (flex_int16_t const   )171, 
        (flex_int16_t const   )172,      (flex_int16_t const   )173,      (flex_int16_t const   )174,      (flex_int16_t const   )175, 
        (flex_int16_t const   )172,      (flex_int16_t const   )173,      (flex_int16_t const   )174,      (flex_int16_t const   )175, 
        (flex_int16_t const   )176,      (flex_int16_t const   )177,      (flex_int16_t const   )170,      (flex_int16_t const   )0, 
        (flex_int16_t const   )176,      (flex_int16_t const   )177,      (flex_int16_t const   )178,      (flex_int16_t const   )175, 
        (flex_int16_t const   )179,      (flex_int16_t const   )0,      (flex_int16_t const   )178,      (flex_int16_t const   )173, 
        (flex_int16_t const   )179,      (flex_int16_t const   )177,      (flex_int16_t const   )181,      (flex_int16_t const   )180, 
        (flex_int16_t const   )182,      (flex_int16_t const   )183,      (flex_int16_t const   )181,      (flex_int16_t const   )180, 
        (flex_int16_t const   )182,      (flex_int16_t const   )183,      (flex_int16_t const   )181,      (flex_int16_t const   )184, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )185,      (flex_int16_t const   )184, 
        (flex_int16_t const   )178,      (flex_int16_t const   )180,      (flex_int16_t const   )185,      (flex_int16_t const   )0, 
        (flex_int16_t const   )186,      (flex_int16_t const   )187,      (flex_int16_t const   )188,      (flex_int16_t const   )185, 
        (flex_int16_t const   )186,      (flex_int16_t const   )187,      (flex_int16_t const   )188,      (flex_int16_t const   )182, 
        (flex_int16_t const   )189,      (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )192, 
        (flex_int16_t const   )189,      (flex_int16_t const   )190,      (flex_int16_t const   )191,      (flex_int16_t const   )192, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )193,      (flex_int16_t const   )194, 
        (flex_int16_t const   )191,      (flex_int16_t const   )186,      (flex_int16_t const   )193,      (flex_int16_t const   )194, 
        (flex_int16_t const   )195,      (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )190, 
        (flex_int16_t const   )195,      (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )198, 
        (flex_int16_t const   )199,      (flex_int16_t const   )200,      (flex_int16_t const   )0,      (flex_int16_t const   )198, 
        (flex_int16_t const   )199,      (flex_int16_t const   )200,      (flex_int16_t const   )197,      (flex_int16_t const   )201, 
        (flex_int16_t const   )202,      (flex_int16_t const   )196,      (flex_int16_t const   )197,      (flex_int16_t const   )201, 
        (flex_int16_t const   )202,      (flex_int16_t const   )195,      (flex_int16_t const   )203,      (flex_int16_t const   )204, 
        (flex_int16_t const   )205,      (flex_int16_t const   )199,      (flex_int16_t const   )203,      (flex_int16_t const   )204, 
        (flex_int16_t const   )205,      (flex_int16_t const   )0,      (flex_int16_t const   )200,      (flex_int16_t const   )206, 
        (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )206,      (flex_int16_t const   )202, 
        (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )0,      (flex_int16_t const   )204, 
        (flex_int16_t const   )208,      (flex_int16_t const   )209,      (flex_int16_t const   )210,      (flex_int16_t const   )211, 
        (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )210,      (flex_int16_t const   )211, 
        (flex_int16_t const   )212,      (flex_int16_t const   )213,      (flex_int16_t const   )214,      (flex_int16_t const   )215, 
        (flex_int16_t const   )0,      (flex_int16_t const   )216,      (flex_int16_t const   )214,      (flex_int16_t const   )215, 
        (flex_int16_t const   )212,      (flex_int16_t const   )216,      (flex_int16_t const   )209,      (flex_int16_t const   )211, 
        (flex_int16_t const   )217,      (flex_int16_t const   )208,      (flex_int16_t const   )218,      (flex_int16_t const   )219, 
        (flex_int16_t const   )217,      (flex_int16_t const   )210,      (flex_int16_t const   )218,      (flex_int16_t const   )219, 
        (flex_int16_t const   )220,      (flex_int16_t const   )215,      (flex_int16_t const   )213,      (flex_int16_t const   )221, 
        (flex_int16_t const   )220,      (flex_int16_t const   )222,      (flex_int16_t const   )218,      (flex_int16_t const   )221, 
        (flex_int16_t const   )223,      (flex_int16_t const   )222,      (flex_int16_t const   )216,      (flex_int16_t const   )0, 
        (flex_int16_t const   )223,      (flex_int16_t const   )224,      (flex_int16_t const   )225,      (flex_int16_t const   )217, 
        (flex_int16_t const   )226,      (flex_int16_t const   )224,      (flex_int16_t const   )225,      (flex_int16_t const   )0, 
        (flex_int16_t const   )226,      (flex_int16_t const   )0,      (flex_int16_t const   )227,      (flex_int16_t const   )220, 
        (flex_int16_t const   )226,      (flex_int16_t const   )219,      (flex_int16_t const   )227,      (flex_int16_t const   )225, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )228,      (flex_int16_t const   )223, 
        (flex_int16_t const   )227,      (flex_int16_t const   )224,      (flex_int16_t const   )228,      (flex_int16_t const   )229, 
        (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )0,      (flex_int16_t const   )229, 
        (flex_int16_t const   )230,      (flex_int16_t const   )231,      (flex_int16_t const   )228,      (flex_int16_t const   )232, 
        (flex_int16_t const   )233,      (flex_int16_t const   )234,      (flex_int16_t const   )230,      (flex_int16_t const   )232, 
        (flex_int16_t const   )233,      (flex_int16_t const   )234,      (flex_int16_t const   )0,      (flex_int16_t const   )235, 
        (flex_int16_t const   )236,      (flex_int16_t const   )237,      (flex_int16_t const   )233,      (flex_int16_t const   )235, 
        (flex_int16_t const   )236,      (flex_int16_t const   )237,      (flex_int16_t const   )238,      (flex_int16_t const   )238, 
        (flex_int16_t const   )238,      (flex_int16_t const   )0,      (flex_int16_t const   )231,      (flex_int16_t const   )240, 
        (flex_int16_t const   )0,      (flex_int16_t const   )235,      (flex_int16_t const   )232,      (flex_int16_t const   )240, 
        (flex_int16_t const   )236,      (flex_int16_t const   )239,      (flex_int16_t const   )239,      (flex_int16_t const   )239, 
        (flex_int16_t const   )239,      (flex_int16_t const   )241,      (flex_int16_t const   )237,      (flex_int16_t const   )242, 
        (flex_int16_t const   )243,      (flex_int16_t const   )241,      (flex_int16_t const   )244,      (flex_int16_t const   )242, 
        (flex_int16_t const   )243,      (flex_int16_t const   )245,      (flex_int16_t const   )244,      (flex_int16_t const   )0, 
        (flex_int16_t const   )246,      (flex_int16_t const   )245,      (flex_int16_t const   )247,      (flex_int16_t const   )241, 
        (flex_int16_t const   )246,      (flex_int16_t const   )248,      (flex_int16_t const   )247,      (flex_int16_t const   )249, 
        (flex_int16_t const   )250,      (flex_int16_t const   )248,      (flex_int16_t const   )243,      (flex_int16_t const   )249, 
        (flex_int16_t const   )250,      (flex_int16_t const   )251,      (flex_int16_t const   )244,      (flex_int16_t const   )252, 
        (flex_int16_t const   )248,      (flex_int16_t const   )251,      (flex_int16_t const   )249,      (flex_int16_t const   )252, 
        (flex_int16_t const   )253,      (flex_int16_t const   )0,      (flex_int16_t const   )255,      (flex_int16_t const   )247, 
        (flex_int16_t const   )253,      (flex_int16_t const   )246,      (flex_int16_t const   )255,      (flex_int16_t const   )254, 
        (flex_int16_t const   )0,      (flex_int16_t const   )256,      (flex_int16_t const   )253,      (flex_int16_t const   )254, 
        (flex_int16_t const   )255,      (flex_int16_t const   )256,      (flex_int16_t const   )257,      (flex_int16_t const   )254, 
        (flex_int16_t const   )252,      (flex_int16_t const   )258,      (flex_int16_t const   )257,      (flex_int16_t const   )259, 
        (flex_int16_t const   )260,      (flex_int16_t const   )258,      (flex_int16_t const   )0,      (flex_int16_t const   )259, 
        (flex_int16_t const   )260,      (flex_int16_t const   )261,      (flex_int16_t const   )256,      (flex_int16_t const   )262, 
        (flex_int16_t const   )263,      (flex_int16_t const   )261,      (flex_int16_t const   )264,      (flex_int16_t const   )262, 
        (flex_int16_t const   )263,      (flex_int16_t const   )0,      (flex_int16_t const   )264,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )261,      (flex_int16_t const   )258,      (flex_int16_t const   )265, 
        (flex_int16_t const   )265,      (flex_int16_t const   )265,      (flex_int16_t const   )267,      (flex_int16_t const   )268, 
        (flex_int16_t const   )269,      (flex_int16_t const   )270,      (flex_int16_t const   )267,      (flex_int16_t const   )268, 
        (flex_int16_t const   )269,      (flex_int16_t const   )270,      (flex_int16_t const   )264,      (flex_int16_t const   )271, 
        (flex_int16_t const   )272,      (flex_int16_t const   )263,      (flex_int16_t const   )273,      (flex_int16_t const   )271, 
        (flex_int16_t const   )272,      (flex_int16_t const   )274,      (flex_int16_t const   )273,      (flex_int16_t const   )268, 
        (flex_int16_t const   )275,      (flex_int16_t const   )274,      (flex_int16_t const   )277,      (flex_int16_t const   )276, 
        (flex_int16_t const   )275,      (flex_int16_t const   )0,      (flex_int16_t const   )277,      (flex_int16_t const   )276, 
        (flex_int16_t const   )0,      (flex_int16_t const   )270,      (flex_int16_t const   )0,      (flex_int16_t const   )278, 
        (flex_int16_t const   )275,      (flex_int16_t const   )276,      (flex_int16_t const   )271,      (flex_int16_t const   )278, 
        (flex_int16_t const   )279,      (flex_int16_t const   )280,      (flex_int16_t const   )281,      (flex_int16_t const   )277, 
        (flex_int16_t const   )279,      (flex_int16_t const   )280,      (flex_int16_t const   )281,      (flex_int16_t const   )274, 
        (flex_int16_t const   )282,      (flex_int16_t const   )283,      (flex_int16_t const   )283,      (flex_int16_t const   )283, 
        (flex_int16_t const   )282,      (flex_int16_t const   )284,      (flex_int16_t const   )281,      (flex_int16_t const   )285, 
        (flex_int16_t const   )286,      (flex_int16_t const   )284,      (flex_int16_t const   )279,      (flex_int16_t const   )285, 
        (flex_int16_t const   )286,      (flex_int16_t const   )287,      (flex_int16_t const   )289,      (flex_int16_t const   )288, 
        (flex_int16_t const   )290,      (flex_int16_t const   )287,      (flex_int16_t const   )289,      (flex_int16_t const   )288, 
        (flex_int16_t const   )290,      (flex_int16_t const   )291,      (flex_int16_t const   )0,      (flex_int16_t const   )292, 
        (flex_int16_t const   )294,      (flex_int16_t const   )291,      (flex_int16_t const   )289,      (flex_int16_t const   )292, 
        (flex_int16_t const   )294,      (flex_int16_t const   )295,      (flex_int16_t const   )284,      (flex_int16_t const   )0, 
        (flex_int16_t const   )296,      (flex_int16_t const   )295,      (flex_int16_t const   )292,      (flex_int16_t const   )287, 
        (flex_int16_t const   )296,      (flex_int16_t const   )297,      (flex_int16_t const   )286,      (flex_int16_t const   )288, 
        (flex_int16_t const   )298,      (flex_int16_t const   )297,      (flex_int16_t const   )299,      (flex_int16_t const   )300, 
        (flex_int16_t const   )298,      (flex_int16_t const   )301,      (flex_int16_t const   )299,      (flex_int16_t const   )300, 
        (flex_int16_t const   )0,      (flex_int16_t const   )301,      (flex_int16_t const   )0,      (flex_int16_t const   )0, 
        (flex_int16_t const   )0,      (flex_int16_t const   )0,      (flex_int16_t const   )294,      (flex_int16_t const   )0, 
        (flex_int16_t const   )296,      (flex_int16_t const   )303,      (flex_int16_t const   )303,      (flex_int16_t const   )303, 
        (flex_int16_t const   )303,      (flex_int16_t const   )303,      (flex_int16_t const   )303,      (flex_int16_t const   )304, 
        (flex_int16_t const   )0,      (flex_int16_t const   )304,      (flex_int16_t const   )304,      (flex_int16_t const   )304, 
        (flex_int16_t const   )304,      (flex_int16_t const   )305,      (flex_int16_t const   )305,      (flex_int16_t const   )305, 
        (flex_int16_t const   )305,      (flex_int16_t const   )306,      (flex_int16_t const   )306,      (flex_int16_t const   )307, 
        (flex_int16_t const   )307,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302,      (flex_int16_t const   )302, 
        (flex_int16_t const   )302,      (flex_int16_t const   )302};
#line 758 "lex.c"
static yy_state_type yy_last_accepting_state  ;
#line 759 "lex.c"
static char *yy_last_accepting_cpos  ;
#line 761
int yy_flex_debug ;
#line 762 "lex.c"
int yy_flex_debug  =    0;
#line 202 "grammar.h"
YYSTYPE yylval ;
#line 13 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.h"
void rl_pwarn(char const   *file , int line , char const   *fmt  , ...) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/parse.h"
char *curfile_name ;
#line 31
int curfile_line ;
#line 4 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/lex.h"
void freebufs(void) ;
#line 814 "lex.c"
static int yy_init_globals(void) ;
#line 819
int yylex_destroy(void) ;
#line 821
int yyget_debug(void) ;
#line 823
void yyset_debug(int bdebug ) ;
#line 829
FILE *yyget_in(void) ;
#line 831
void yyset_in(FILE *in_str ) ;
#line 833
FILE *yyget_out(void) ;
#line 835
void yyset_out(FILE *out_str ) ;
#line 837
int yyget_leng(void) ;
#line 839
char *yyget_text(void) ;
#line 841
int yyget_lineno(void) ;
#line 843
void yyset_lineno(int line_number ) ;
#line 853
int yywrap(void) ;
#line 955
int yylex(void) ;
#line 977 "lex.c"
int yylex(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register char *yy_bp ;
  register int yy_act ;
  YY_BUFFER_STATE tmp ;
  register YY_CHAR yy_c ;
  void *tmp___0 ;
  char *tmp___1 ;
  int yy_amount_of_matched_text ;
  yy_state_type yy_next_state ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 989
  if (! yy_init) {
#line 991
    yy_init = 1;
#line 997
    if (! yy_start) {
#line 998
      yy_start = 1;
    }
#line 1000
    if (! yyin) {
#line 1001
      yyin = stdin;
    }
#line 1003
    if (! yyout) {
#line 1004
      yyout = stdout;
    }
#line 1006
    if (yy_buffer_stack) {
#line 1006
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 1006
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
#line 1006
    if (! tmp) {
      {
#line 1007
      yyensure_buffer_stack();
#line 1008
      *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
      }
    }
    {
#line 1012
    yy_load_buffer_state();
    }
  }
  {
#line 1015
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1017
    yy_cp = yy_c_buf_p;
#line 1020
    *yy_cp = yy_hold_char;
#line 1025
    yy_bp = yy_cp;
#line 1027
    yy_current_state = yy_start;
    yy_match: 
    {
#line 1029
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1031
      yy_c = (YY_CHAR )yy_ec[(unsigned int )((unsigned char )*yy_cp)];
#line 1032
      if (yy_accept[yy_current_state]) {
#line 1034
        yy_last_accepting_state = yy_current_state;
#line 1035
        yy_last_accepting_cpos = yy_cp;
      }
      {
#line 1037
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1037
        if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1037
          goto while_break___1;
        }
#line 1039
        yy_current_state = (int )yy_def[yy_current_state];
#line 1040
        if (yy_current_state >= 303) {
#line 1041
          yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1043
      yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1044
      yy_cp ++;
#line 1029
      if (! (yy_current_state != 302)) {
#line 1029
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1047
    yy_cp = yy_last_accepting_cpos;
#line 1048
    yy_current_state = yy_last_accepting_state;
    yy_find_action: 
#line 1051
    yy_act = (int )yy_accept[yy_current_state];
#line 1053
    yytext = yy_bp;
#line 1053
    yyleng = (int )((size_t )(yy_cp - yy_bp));
#line 1053
    yy_hold_char = *yy_cp;
#line 1053
    *yy_cp = (char )'\000';
#line 1053
    yy_c_buf_p = yy_cp;
    do_action: 
    {
#line 1059
    if (yy_act == 0) {
#line 1059
      goto case_0;
    }
#line 1066
    if (yy_act == 1) {
#line 1066
      goto case_1;
    }
#line 35
    if (yy_act == 2) {
#line 35 "lex.l"
      goto case_2;
    }
#line 36
    if (yy_act == 3) {
#line 36
      goto case_3;
    }
#line 37
    if (yy_act == 4) {
#line 37
      goto case_4;
    }
#line 38
    if (yy_act == 5) {
#line 38
      goto case_5;
    }
#line 39
    if (yy_act == 6) {
#line 39
      goto case_6;
    }
#line 40
    if (yy_act == 7) {
#line 40
      goto case_7;
    }
#line 41
    if (yy_act == 8) {
#line 41
      goto case_8;
    }
#line 42
    if (yy_act == 9) {
#line 42
      goto case_9;
    }
#line 43
    if (yy_act == 10) {
#line 43
      goto case_10;
    }
#line 44
    if (yy_act == 11) {
#line 44
      goto case_11;
    }
#line 45
    if (yy_act == 12) {
#line 45
      goto case_12;
    }
#line 46
    if (yy_act == 13) {
#line 46
      goto case_13;
    }
#line 47
    if (yy_act == 14) {
#line 47
      goto case_14;
    }
#line 48
    if (yy_act == 15) {
#line 48
      goto case_15;
    }
#line 49
    if (yy_act == 16) {
#line 49
      goto case_16;
    }
#line 50
    if (yy_act == 17) {
#line 50
      goto case_17;
    }
#line 51
    if (yy_act == 18) {
#line 51
      goto case_18;
    }
#line 52
    if (yy_act == 19) {
#line 52
      goto case_19;
    }
#line 53
    if (yy_act == 20) {
#line 53
      goto case_20;
    }
#line 54
    if (yy_act == 21) {
#line 54
      goto case_21;
    }
#line 55
    if (yy_act == 22) {
#line 55
      goto case_22;
    }
#line 56
    if (yy_act == 23) {
#line 56
      goto case_23;
    }
#line 57
    if (yy_act == 24) {
#line 57
      goto case_24;
    }
#line 58
    if (yy_act == 25) {
#line 58
      goto case_25;
    }
#line 59
    if (yy_act == 26) {
#line 59
      goto case_26;
    }
#line 60
    if (yy_act == 27) {
#line 60
      goto case_27;
    }
#line 61
    if (yy_act == 28) {
#line 61
      goto case_28;
    }
#line 62
    if (yy_act == 29) {
#line 62
      goto case_29;
    }
#line 63
    if (yy_act == 30) {
#line 63
      goto case_30;
    }
#line 64
    if (yy_act == 31) {
#line 64
      goto case_31;
    }
#line 65
    if (yy_act == 32) {
#line 65
      goto case_32;
    }
#line 66
    if (yy_act == 33) {
#line 66
      goto case_33;
    }
#line 67
    if (yy_act == 34) {
#line 67
      goto case_34;
    }
#line 68
    if (yy_act == 35) {
#line 68
      goto case_35;
    }
#line 69
    if (yy_act == 36) {
#line 69
      goto case_36;
    }
#line 70
    if (yy_act == 37) {
#line 70
      goto case_37;
    }
#line 71
    if (yy_act == 38) {
#line 71
      goto case_38;
    }
#line 72
    if (yy_act == 39) {
#line 72
      goto case_39;
    }
#line 73
    if (yy_act == 40) {
#line 73
      goto case_40;
    }
#line 74
    if (yy_act == 41) {
#line 74
      goto case_41;
    }
#line 75
    if (yy_act == 42) {
#line 75
      goto case_42;
    }
#line 76
    if (yy_act == 43) {
#line 76
      goto case_43;
    }
#line 77
    if (yy_act == 44) {
#line 77
      goto case_44;
    }
#line 78
    if (yy_act == 45) {
#line 78
      goto case_45;
    }
#line 79
    if (yy_act == 46) {
#line 79
      goto case_46;
    }
#line 80
    if (yy_act == 47) {
#line 80
      goto case_47;
    }
#line 81
    if (yy_act == 48) {
#line 81
      goto case_48;
    }
#line 82
    if (yy_act == 49) {
#line 82
      goto case_49;
    }
#line 83
    if (yy_act == 50) {
#line 83
      goto case_50;
    }
#line 84
    if (yy_act == 51) {
#line 84
      goto case_51;
    }
#line 85
    if (yy_act == 52) {
#line 85
      goto case_52;
    }
#line 86
    if (yy_act == 53) {
#line 86
      goto case_53;
    }
#line 87
    if (yy_act == 54) {
#line 87
      goto case_54;
    }
#line 88
    if (yy_act == 55) {
#line 88
      goto case_55;
    }
#line 89
    if (yy_act == 56) {
#line 89
      goto case_56;
    }
#line 90
    if (yy_act == 57) {
#line 90
      goto case_57;
    }
#line 91
    if (yy_act == 58) {
#line 91
      goto case_58;
    }
#line 92
    if (yy_act == 59) {
#line 92
      goto case_59;
    }
#line 93
    if (yy_act == 60) {
#line 93
      goto case_60;
    }
#line 94
    if (yy_act == 61) {
#line 94
      goto case_61;
    }
#line 96
    if (yy_act == 62) {
#line 96
      goto case_62;
    }
#line 97
    if (yy_act == 63) {
#line 97
      goto case_63;
    }
#line 98
    if (yy_act == 64) {
#line 98
      goto case_64;
    }
#line 99
    if (yy_act == 65) {
#line 99
      goto case_65;
    }
#line 100
    if (yy_act == 66) {
#line 100
      goto case_66;
    }
#line 104
    if (yy_act == 67) {
#line 104
      goto case_67;
    }
#line 105
    if (yy_act == 68) {
#line 105
      goto case_68;
    }
#line 111
    if (yy_act == 69) {
#line 111
      goto case_69;
    }
#line 115
    if (yy_act == 70) {
#line 115
      goto case_70;
    }
#line 119
    if (yy_act == 71) {
#line 119
      goto case_71;
    }
#line 123
    if (yy_act == 72) {
#line 123
      goto case_72;
    }
#line 124
    if (yy_act == 73) {
#line 124
      goto case_73;
    }
#line 128
    if (yy_act == 74) {
#line 128
      goto case_74;
    }
#line 1458
    if (yy_act == 76) {
#line 1458 "lex.c"
      goto case_76;
    }
#line 1461
    if (yy_act == 75) {
#line 1461
      goto case_75;
    }
#line 1584
    goto switch_default;
    case_0: /* CIL Label */ 
#line 1061
    *yy_cp = yy_hold_char;
#line 1062
    yy_cp = yy_last_accepting_cpos;
#line 1063
    yy_current_state = yy_last_accepting_state;
#line 1064
    goto yy_find_action;
    case_1: /* CIL Label */ 
#line 33 "lex.l"
    return (258);
#line 34
    goto switch_break;
    case_2: /* CIL Label */ 
#line 34
    return (260);
#line 35
    goto switch_break;
    case_3: /* CIL Label */ 
#line 35
    return (259);
#line 36
    goto switch_break;
    case_4: /* CIL Label */ 
#line 36
    return (261);
#line 37
    goto switch_break;
    case_5: /* CIL Label */ 
#line 37
    return (263);
#line 38
    goto switch_break;
    case_6: /* CIL Label */ 
#line 38
    return (262);
#line 39
    goto switch_break;
    case_7: /* CIL Label */ 
#line 39
    return (264);
#line 40
    goto switch_break;
    case_8: /* CIL Label */ 
#line 40
    return (265);
#line 41
    goto switch_break;
    case_9: /* CIL Label */ 
#line 41
    return (266);
#line 42
    goto switch_break;
    case_10: /* CIL Label */ 
#line 42
    return (267);
#line 43
    goto switch_break;
    case_11: /* CIL Label */ 
#line 43
    return (269);
#line 44
    goto switch_break;
    case_12: /* CIL Label */ 
#line 44
    return (270);
#line 45
    goto switch_break;
    case_13: /* CIL Label */ 
#line 45
    return (293);
#line 46
    goto switch_break;
    case_14: /* CIL Label */ 
#line 46
    return (294);
#line 47
    goto switch_break;
    case_15: /* CIL Label */ 
#line 47
    return (295);
#line 48
    goto switch_break;
    case_16: /* CIL Label */ 
#line 48
    return (296);
#line 49
    goto switch_break;
    case_17: /* CIL Label */ 
#line 49
    return (297);
#line 50
    goto switch_break;
    case_18: /* CIL Label */ 
#line 50
    return (298);
#line 51
    goto switch_break;
    case_19: /* CIL Label */ 
#line 51
    return (299);
#line 52
    goto switch_break;
    case_20: /* CIL Label */ 
#line 52
    return (300);
#line 53
    goto switch_break;
    case_21: /* CIL Label */ 
#line 53
    return (301);
#line 54
    goto switch_break;
    case_22: /* CIL Label */ 
#line 54
    return (302);
#line 55
    goto switch_break;
    case_23: /* CIL Label */ 
#line 55
    return (303);
#line 56
    goto switch_break;
    case_24: /* CIL Label */ 
#line 56
    return (271);
#line 57
    goto switch_break;
    case_25: /* CIL Label */ 
#line 57
    return (308);
#line 58
    goto switch_break;
    case_26: /* CIL Label */ 
#line 58
    return (273);
#line 59
    goto switch_break;
    case_27: /* CIL Label */ 
#line 59
    return (304);
#line 60
    goto switch_break;
    case_28: /* CIL Label */ 
#line 60
    return (305);
#line 61
    goto switch_break;
    case_29: /* CIL Label */ 
#line 61
    return (274);
#line 62
    goto switch_break;
    case_30: /* CIL Label */ 
#line 62
    return (309);
#line 63
    goto switch_break;
    case_31: /* CIL Label */ 
#line 63
    return (310);
#line 64
    goto switch_break;
    case_32: /* CIL Label */ 
#line 64
    return (311);
#line 65
    goto switch_break;
    case_33: /* CIL Label */ 
#line 65
    return (311);
#line 66
    goto switch_break;
    case_34: /* CIL Label */ 
#line 66
    return (312);
#line 67
    goto switch_break;
    case_35: /* CIL Label */ 
#line 67
    return (275);
#line 68
    goto switch_break;
    case_36: /* CIL Label */ 
#line 68
    return (276);
#line 69
    goto switch_break;
    case_37: /* CIL Label */ 
#line 69
    return (277);
#line 70
    goto switch_break;
    case_38: /* CIL Label */ 
#line 70
    return (278);
#line 71
    goto switch_break;
    case_39: /* CIL Label */ 
#line 71
    return (279);
#line 72
    goto switch_break;
    case_40: /* CIL Label */ 
#line 72
    return (280);
#line 73
    goto switch_break;
    case_41: /* CIL Label */ 
#line 73
    return (281);
#line 74
    goto switch_break;
    case_42: /* CIL Label */ 
#line 74
    return (282);
#line 75
    goto switch_break;
    case_43: /* CIL Label */ 
#line 75
    return (283);
#line 76
    goto switch_break;
    case_44: /* CIL Label */ 
#line 76
    return (284);
#line 77
    goto switch_break;
    case_45: /* CIL Label */ 
#line 77
    return (285);
#line 78
    goto switch_break;
    case_46: /* CIL Label */ 
#line 78
    return (313);
#line 79
    goto switch_break;
    case_47: /* CIL Label */ 
#line 79
    return (314);
#line 80
    goto switch_break;
    case_48: /* CIL Label */ 
#line 80
    return (315);
#line 81
    goto switch_break;
    case_49: /* CIL Label */ 
#line 81
    return (286);
#line 82
    goto switch_break;
    case_50: /* CIL Label */ 
#line 82
    return (316);
#line 83
    goto switch_break;
    case_51: /* CIL Label */ 
#line 83
    return (287);
#line 84
    goto switch_break;
    case_52: /* CIL Label */ 
#line 84
    return (288);
#line 85
    goto switch_break;
    case_53: /* CIL Label */ 
#line 85
    return (289);
#line 86
    goto switch_break;
    case_54: /* CIL Label */ 
#line 86
    return (290);
#line 87
    goto switch_break;
    case_55: /* CIL Label */ 
#line 87
    return (291);
#line 88
    goto switch_break;
    case_56: /* CIL Label */ 
#line 88
    return (268);
#line 89
    goto switch_break;
    case_57: /* CIL Label */ 
#line 89
    return (292);
#line 90
    goto switch_break;
    case_58: /* CIL Label */ 
#line 90
    return (306);
#line 91
    goto switch_break;
    case_59: /* CIL Label */ 
#line 91
    return (307);
#line 92
    goto switch_break;
    case_60: /* CIL Label */ 
#line 92
    return (272);
#line 93
    goto switch_break;
    case_61: /* CIL Label */ 
#line 94
    return ('{');
#line 95
    goto switch_break;
    case_62: /* CIL Label */ 
#line 95
    return ('}');
#line 96
    goto switch_break;
    case_63: /* CIL Label */ 
#line 96
    return (';');
#line 97
    goto switch_break;
    case_64: /* CIL Label */ 
#line 97
    return (',');
#line 98
    goto switch_break;
    case_65: /* CIL Label */ 
#line 98
    return ('-');
#line 99
    goto switch_break;
    case_66: /* CIL Label */ 
#line 101
    curfile_line ++;
#line 103
    goto switch_break;
    case_67: /* CIL Label */ 
#line 104
    goto switch_break;
    case_68: /* CIL Label */ 
    {
#line 105
    tmp___0 = malloc((size_t )(yyleng - 1));
#line 105
    yylval.cp = (char *)tmp___0;
#line 106
    memcpy((void */* __restrict  */)yylval.cp, (void const   */* __restrict  */)(yytext + 1),
           (size_t )(yyleng - 2));
#line 107
    *(yylval.cp + (yyleng - 2)) = (char )'\000';
    }
#line 108
    return (318);
#line 110
    goto switch_break;
    case_69: /* CIL Label */ 
    {
#line 111
    yylval.cp = strdup((char const   *)yytext);
    }
#line 112
    return (319);
#line 114
    goto switch_break;
    case_70: /* CIL Label */ 
    {
#line 115
    yylval.num = strtol((char const   */* __restrict  */)yytext, (char **/* __restrict  */)((void *)0),
                        0);
    }
#line 116
    return (317);
#line 118
    goto switch_break;
    case_71: /* CIL Label */ 
    {
#line 119
    yylval.cp = strdup((char const   *)yytext);
    }
#line 120
    return (319);
#line 122
    goto switch_break;
    case_72: /* CIL Label */ 
#line 123
    goto switch_break;
    case_73: /* CIL Label */ 
    {
#line 124
    tmp___1 = strdup((char const   *)yytext);
#line 124
    rl_pwarn((char const   *)curfile_name, curfile_line, "unknown directive: %s",
             tmp___1);
    }
#line 127
    goto switch_break;
    case_74: /* CIL Label */ 
    {
#line 128
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 128
      fwrite((void const   */* __restrict  */)yytext, (size_t )yyleng, (size_t )1,
             (FILE */* __restrict  */)yyout);
      }
#line 128
      goto while_break___2;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 129
    goto switch_break;
    case_76: /* CIL Label */ 
#line 1459 "lex.c"
    return (0);
    case_75: /* CIL Label */ 
#line 1464
    yy_amount_of_matched_text = (int )(yy_cp - yytext) - 1;
#line 1467
    *yy_cp = yy_hold_char;
#line 1470
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 0) {
#line 1481
      yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1482
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file = yyin;
#line 1483
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 1;
    }
#line 1493
    if ((unsigned long )yy_c_buf_p <= (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars)) {
      {
#line 1497
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1499
      yy_current_state = yy_get_previous_state();
#line 1510
      yy_next_state = yy_try_NUL_trans(yy_current_state);
#line 1512
      yy_bp = yytext + 0;
      }
#line 1514
      if (yy_next_state) {
#line 1517
        yy_c_buf_p ++;
#line 1517
        yy_cp = yy_c_buf_p;
#line 1518
        yy_current_state = yy_next_state;
#line 1519
        goto yy_match;
      } else {
#line 1524
        yy_cp = yy_last_accepting_cpos;
#line 1525
        yy_current_state = yy_last_accepting_state;
#line 1526
        goto yy_find_action;
      }
    } else {
      {
#line 1530
      tmp___2 = yy_get_next_buffer();
      }
      {
#line 1532
      if (tmp___2 == 1) {
#line 1532
        goto case_1___0;
      }
#line 1561
      if (tmp___2 == 0) {
#line 1561
        goto case_0___0;
      }
#line 1571
      if (tmp___2 == 2) {
#line 1571
        goto case_2___0;
      }
#line 1530
      goto switch_break___0;
      case_1___0: /* CIL Label */ 
      {
#line 1534
      yy_did_buffer_switch_on_eof = 0;
#line 1536
      tmp___3 = yywrap();
      }
#line 1536
      if (tmp___3) {
#line 1547
        yy_c_buf_p = yytext + 0;
#line 1549
        yy_act = (75 + (yy_start - 1) / 2) + 1;
#line 1550
        goto do_action;
      } else
#line 1555
      if (! yy_did_buffer_switch_on_eof) {
        {
#line 1556
        yyrestart(yyin);
        }
      }
#line 1558
      goto switch_break___0;
      case_0___0: /* CIL Label */ 
      {
#line 1562
      yy_c_buf_p = yytext + yy_amount_of_matched_text;
#line 1565
      yy_current_state = yy_get_previous_state();
#line 1567
      yy_cp = yy_c_buf_p;
#line 1568
      yy_bp = yytext + 0;
      }
#line 1569
      goto yy_match;
      case_2___0: /* CIL Label */ 
      {
#line 1572
      yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars;
#line 1575
      yy_current_state = yy_get_previous_state();
#line 1577
      yy_cp = yy_c_buf_p;
#line 1578
      yy_bp = yytext + 0;
      }
#line 1579
      goto yy_find_action;
      switch_break___0: /* CIL Label */ ;
      }
    }
#line 1581
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 1585
    yy_fatal_error("fatal flex scanner internal error--no action found");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1598 "lex.c"
static int yy_get_next_buffer(void) 
{ 
  register char *dest ;
  register char *source ;
  register int number_to_move ;
  register int i ;
  int ret_val ;
  char *tmp ;
  char *tmp___0 ;
  int num_to_read ;
  YY_BUFFER_STATE b ;
  YY_BUFFER_STATE tmp___1 ;
  int yy_c_buf_p_offset ;
  int new_size ;
  void *tmp___2 ;
  int c ;
  size_t n ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  int *tmp___6 ;
  int *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  yy_size_t new_size___0 ;
  void *tmp___10 ;

  {
#line 1600
  dest = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf;
#line 1601
  source = yytext;
#line 1605
  if ((unsigned long )yy_c_buf_p > (unsigned long )((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1))) {
    {
#line 1606
    yy_fatal_error("fatal flex scanner internal error--end of buffer missed");
    }
  }
#line 1609
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_fill_buffer == 0) {
#line 1611
    if (yy_c_buf_p - yytext == 1L) {
#line 1616
      return (1);
    } else {
#line 1624
      return (2);
    }
  }
#line 1631
  number_to_move = (int )(yy_c_buf_p - yytext) - 1;
#line 1633
  i = 0;
  {
#line 1633
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1633
    if (! (i < number_to_move)) {
#line 1633
      goto while_break;
    }
#line 1634
    tmp = dest;
#line 1634
    dest ++;
#line 1634
    tmp___0 = source;
#line 1634
    source ++;
#line 1634
    *tmp = *tmp___0;
#line 1633
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1636
  if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status == 2) {
#line 1640
    yy_n_chars = 0;
#line 1640
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  } else {
#line 1644
    num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    {
#line 1647
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1647
      if (! (num_to_read <= 0)) {
#line 1647
        goto while_break___0;
      }
#line 1651
      if (yy_buffer_stack) {
#line 1651
        tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
      } else {
#line 1651
        tmp___1 = (YY_BUFFER_STATE )((void *)0);
      }
#line 1651
      b = tmp___1;
#line 1653
      yy_c_buf_p_offset = (int )(yy_c_buf_p - b->yy_ch_buf);
#line 1656
      if (b->yy_is_our_buffer) {
#line 1658
        new_size = (int )(b->yy_buf_size * 2UL);
#line 1660
        if (new_size <= 0) {
#line 1661
          b->yy_buf_size += b->yy_buf_size / 8UL;
        } else {
#line 1663
          b->yy_buf_size *= 2UL;
        }
        {
#line 1665
        tmp___2 = yyrealloc((void *)b->yy_ch_buf, b->yy_buf_size + 2UL);
#line 1665
        b->yy_ch_buf = (char *)tmp___2;
        }
      } else {
#line 1671
        b->yy_ch_buf = (char *)0;
      }
#line 1673
      if (! b->yy_ch_buf) {
        {
#line 1674
        yy_fatal_error("fatal error - scanner input buffer overflow");
        }
      }
#line 1677
      yy_c_buf_p = b->yy_ch_buf + yy_c_buf_p_offset;
#line 1679
      num_to_read = (int )(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size - (yy_size_t )number_to_move) - 1UL);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1684
    if (num_to_read > 8192) {
#line 1685
      num_to_read = 8192;
    }
#line 1688
    if ((*(yy_buffer_stack + yy_buffer_stack_top))->yy_is_interactive) {
#line 1688
      c = '*';
#line 1688
      n = (size_t )0;
      {
#line 1688
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1688
        if (n < (size_t )num_to_read) {
          {
#line 1688
          c = _IO_getc(yyin);
          }
#line 1688
          if (c != -1) {
#line 1688
            if (! (c != 10)) {
#line 1688
              goto while_break___1;
            }
          } else {
#line 1688
            goto while_break___1;
          }
        } else {
#line 1688
          goto while_break___1;
        }
#line 1688
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + n) = (char )c;
#line 1688
        n ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1688
      if (c == 10) {
#line 1688
        tmp___3 = n;
#line 1688
        n ++;
#line 1688
        *(((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move) + tmp___3) = (char )c;
      }
#line 1688
      if (c == -1) {
        {
#line 1688
        tmp___4 = ferror(yyin);
        }
#line 1688
        if (tmp___4) {
          {
#line 1688
          yy_fatal_error("input in flex scanner failed");
          }
        }
      }
#line 1688
      yy_n_chars = (int )n;
    } else {
      {
#line 1688
      tmp___5 = __errno_location();
#line 1688
      *tmp___5 = 0;
      }
      {
#line 1688
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1688
        tmp___8 = fread((void */* __restrict  */)((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + number_to_move),
                        (size_t )1, (size_t )num_to_read, (FILE */* __restrict  */)yyin);
#line 1688
        yy_n_chars = (int )tmp___8;
        }
#line 1688
        if (yy_n_chars == 0) {
          {
#line 1688
          tmp___9 = ferror(yyin);
          }
#line 1688
          if (! tmp___9) {
#line 1688
            goto while_break___2;
          }
        } else {
#line 1688
          goto while_break___2;
        }
        {
#line 1688
        tmp___6 = __errno_location();
        }
#line 1688
        if (*tmp___6 != 4) {
          {
#line 1688
          yy_fatal_error("input in flex scanner failed");
          }
#line 1688
          goto while_break___2;
        }
        {
#line 1688
        tmp___7 = __errno_location();
#line 1688
        *tmp___7 = 0;
#line 1688
        clearerr(yyin);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 1691
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 1694
  if (yy_n_chars == 0) {
#line 1696
    if (number_to_move == 0) {
      {
#line 1698
      ret_val = 1;
#line 1699
      yyrestart(yyin);
      }
    } else {
#line 1704
      ret_val = 2;
#line 1705
      (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buffer_status = 2;
    }
  } else {
#line 1711
    ret_val = 0;
  }
#line 1713
  if ((yy_size_t )(yy_n_chars + number_to_move) > (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_size) {
    {
#line 1715
    new_size___0 = (yy_size_t )((yy_n_chars + number_to_move) + (yy_n_chars >> 1));
#line 1716
    tmp___10 = yyrealloc((void *)(*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf,
                         new_size___0);
#line 1716
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf = (char *)tmp___10;
    }
#line 1717
    if (! (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf) {
      {
#line 1718
      yy_fatal_error("out of dynamic memory in yy_get_next_buffer()");
      }
    }
  }
#line 1721
  yy_n_chars += number_to_move;
#line 1722
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + yy_n_chars) = (char)0;
#line 1723
  *((*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + (yy_n_chars + 1)) = (char)0;
#line 1725
  yytext = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_ch_buf + 0;
#line 1727
  return (ret_val);
}
}
#line 1732 "lex.c"
static yy_state_type yy_get_previous_state(void) 
{ 
  register yy_state_type yy_current_state ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  flex_int32_t tmp ;

  {
#line 1737
  yy_current_state = yy_start;
#line 1739
  yy_cp = yytext + 0;
  {
#line 1739
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1739
    if (! ((unsigned long )yy_cp < (unsigned long )yy_c_buf_p)) {
#line 1739
      goto while_break;
    }
#line 1741
    if (*yy_cp) {
#line 1741
      tmp = yy_ec[(unsigned int )((unsigned char )*yy_cp)];
    } else {
#line 1741
      tmp = (flex_int32_t const   )1;
    }
#line 1741
    yy_c = (YY_CHAR )tmp;
#line 1742
    if (yy_accept[yy_current_state]) {
#line 1744
      yy_last_accepting_state = yy_current_state;
#line 1745
      yy_last_accepting_cpos = yy_cp;
    }
    {
#line 1747
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1747
      if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1747
        goto while_break___0;
      }
#line 1749
      yy_current_state = (int )yy_def[yy_current_state];
#line 1750
      if (yy_current_state >= 303) {
#line 1751
        yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1753
    yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1739
    yy_cp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1756
  return (yy_current_state);
}
}
#line 1764 "lex.c"
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state ) 
{ 
  register int yy_is_jam ;
  register char *yy_cp ;
  register YY_CHAR yy_c ;
  int tmp ;

  {
#line 1767
  yy_cp = yy_c_buf_p;
#line 1769
  yy_c = (YY_CHAR )1;
#line 1770
  if (yy_accept[yy_current_state]) {
#line 1772
    yy_last_accepting_state = yy_current_state;
#line 1773
    yy_last_accepting_cpos = yy_cp;
  }
  {
#line 1775
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1775
    if (! ((int const   )yy_chk[(int const   )yy_base[yy_current_state] + (int const   )yy_c] != (int const   )yy_current_state)) {
#line 1775
      goto while_break;
    }
#line 1777
    yy_current_state = (int )yy_def[yy_current_state];
#line 1778
    if (yy_current_state >= 303) {
#line 1779
      yy_c = (YY_CHAR )yy_meta[(unsigned int )yy_c];
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1781
  yy_current_state = (yy_state_type )yy_nxt[(unsigned int )yy_base[yy_current_state] + (unsigned int )yy_c];
#line 1782
  yy_is_jam = yy_current_state == 302;
#line 1784
  if (yy_is_jam) {
#line 1784
    tmp = 0;
  } else {
#line 1784
    tmp = yy_current_state;
  }
#line 1784
  return (tmp);
}
}
#line 1866 "lex.c"
void yyrestart(FILE *input_file ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 1869
  if (yy_buffer_stack) {
#line 1869
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1869
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1869
  if (! tmp) {
    {
#line 1870
    yyensure_buffer_stack();
#line 1871
    *(yy_buffer_stack + yy_buffer_stack_top) = yy_create_buffer(yyin, 16384);
    }
  }
#line 1875
  if (yy_buffer_stack) {
#line 1875
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1875
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 1875
  yy_init_buffer(tmp___0, input_file);
#line 1876
  yy_load_buffer_state();
  }
#line 1877
  return;
}
}
#line 1883 "lex.c"
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 1891
  yyensure_buffer_stack();
  }
#line 1892
  if (yy_buffer_stack) {
#line 1892
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1892
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1892
  if ((unsigned long )tmp == (unsigned long )new_buffer) {
#line 1893
    return;
  }
#line 1895
  if (yy_buffer_stack) {
#line 1895
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1895
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1895
  if (tmp___0) {
#line 1898
    *yy_c_buf_p = yy_hold_char;
#line 1899
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 1900
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
  {
#line 1903
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 1904
  yy_load_buffer_state();
#line 1911
  yy_did_buffer_switch_on_eof = 1;
  }
#line 1912
  return;
}
}
#line 1914 "lex.c"
static void yy_load_buffer_state(void) 
{ 


  {
#line 1916
  yy_n_chars = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars;
#line 1917
  yy_c_buf_p = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos;
#line 1917
  yytext = yy_c_buf_p;
#line 1918
  yyin = (*(yy_buffer_stack + yy_buffer_stack_top))->yy_input_file;
#line 1919
  yy_hold_char = *yy_c_buf_p;
#line 1920
  return;
}
}
#line 1928 "lex.c"
YY_BUFFER_STATE yy_create_buffer(FILE *file , int size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1932
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
#line 1932
  b = (YY_BUFFER_STATE )tmp;
  }
#line 1933
  if (! b) {
    {
#line 1934
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1936
  b->yy_buf_size = (yy_size_t )size;
#line 1941
  tmp___0 = yyalloc(b->yy_buf_size + 2UL);
#line 1941
  b->yy_ch_buf = (char *)tmp___0;
  }
#line 1942
  if (! b->yy_ch_buf) {
    {
#line 1943
    yy_fatal_error("out of dynamic memory in yy_create_buffer()");
    }
  }
  {
#line 1945
  b->yy_is_our_buffer = 1;
#line 1947
  yy_init_buffer(b, file);
  }
#line 1949
  return (b);
}
}
#line 1956 "lex.c"
void yy_delete_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 1959
  if (! b) {
#line 1960
    return;
  }
#line 1962
  if (yy_buffer_stack) {
#line 1962
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1962
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 1962
  if ((unsigned long )b == (unsigned long )tmp) {
#line 1963
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )0;
  }
#line 1965
  if (b->yy_is_our_buffer) {
    {
#line 1966
    yyfree((void *)b->yy_ch_buf);
    }
  }
  {
#line 1968
  yyfree((void *)b);
  }
#line 1969
  return;
}
}
#line 1975 "lex.c"
static void yy_init_buffer(YY_BUFFER_STATE b , FILE *file ) 
{ 
  int oerrno ;
  int *tmp ;
  YY_BUFFER_STATE tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 1978
  tmp = __errno_location();
#line 1978
  oerrno = *tmp;
#line 1980
  yy_flush_buffer(b);
#line 1982
  b->yy_input_file = file;
#line 1983
  b->yy_fill_buffer = 1;
  }
#line 1989
  if (yy_buffer_stack) {
#line 1989
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 1989
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 1989
  if ((unsigned long )b != (unsigned long )tmp___0) {
#line 1990
    b->yy_bs_lineno = 1;
#line 1991
    b->yy_bs_column = 0;
  }
  {
#line 1994
  b->yy_is_interactive = 0;
#line 1996
  tmp___1 = __errno_location();
#line 1996
  *tmp___1 = oerrno;
  }
#line 1997
  return;
}
}
#line 2003 "lex.c"
void yy_flush_buffer(YY_BUFFER_STATE b ) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 2005
  if (! b) {
#line 2006
    return;
  }
#line 2008
  b->yy_n_chars = 0;
#line 2014
  *(b->yy_ch_buf + 0) = (char)0;
#line 2015
  *(b->yy_ch_buf + 1) = (char)0;
#line 2017
  b->yy_buf_pos = b->yy_ch_buf + 0;
#line 2019
  b->yy_at_bol = 1;
#line 2020
  b->yy_buffer_status = 0;
#line 2022
  if (yy_buffer_stack) {
#line 2022
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2022
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2022
  if ((unsigned long )b == (unsigned long )tmp) {
    {
#line 2023
    yy_load_buffer_state();
    }
  }
#line 2024
  return;
}
}
#line 2032 "lex.c"
void yypush_buffer_state(YY_BUFFER_STATE new_buffer ) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
#line 2034
  if ((unsigned long )new_buffer == (unsigned long )((void *)0)) {
#line 2035
    return;
  }
  {
#line 2037
  yyensure_buffer_stack();
  }
#line 2040
  if (yy_buffer_stack) {
#line 2040
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2040
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2040
  if (tmp) {
#line 2043
    *yy_c_buf_p = yy_hold_char;
#line 2044
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_buf_pos = yy_c_buf_p;
#line 2045
    (*(yy_buffer_stack + yy_buffer_stack_top))->yy_n_chars = yy_n_chars;
  }
#line 2049
  if (yy_buffer_stack) {
#line 2049
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2049
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2049
  if (tmp___0) {
#line 2050
    yy_buffer_stack_top ++;
  }
  {
#line 2051
  *(yy_buffer_stack + yy_buffer_stack_top) = new_buffer;
#line 2054
  yy_load_buffer_state();
#line 2055
  yy_did_buffer_switch_on_eof = 1;
  }
#line 2056
  return;
}
}
#line 2062 "lex.c"
void yypop_buffer_state(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;
  YY_BUFFER_STATE tmp___1 ;

  {
#line 2064
  if (yy_buffer_stack) {
#line 2064
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2064
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
#line 2064
  if (! tmp) {
#line 2065
    return;
  }
#line 2067
  if (yy_buffer_stack) {
#line 2067
    tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2067
    tmp___0 = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 2067
  yy_delete_buffer(tmp___0);
#line 2068
  *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
  }
#line 2069
  if (yy_buffer_stack_top > 0UL) {
#line 2070
    yy_buffer_stack_top --;
  }
#line 2072
  if (yy_buffer_stack) {
#line 2072
    tmp___1 = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 2072
    tmp___1 = (YY_BUFFER_STATE )((void *)0);
  }
#line 2072
  if (tmp___1) {
    {
#line 2073
    yy_load_buffer_state();
#line 2074
    yy_did_buffer_switch_on_eof = 1;
    }
  }
#line 2076
  return;
}
}
#line 2081 "lex.c"
static void yyensure_buffer_stack(void) 
{ 
  int num_to_alloc ;
  void *tmp ;
  int grow_size ;
  void *tmp___0 ;

  {
#line 2085
  if (! yy_buffer_stack) {
    {
#line 2091
    num_to_alloc = 1;
#line 2092
    tmp = yyalloc((unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2092
    yy_buffer_stack = (struct yy_buffer_state **)tmp;
    }
#line 2095
    if (! yy_buffer_stack) {
      {
#line 2096
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
      }
    }
    {
#line 2098
    memset((void *)yy_buffer_stack, 0, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2100
    yy_buffer_stack_max = (size_t )num_to_alloc;
#line 2101
    yy_buffer_stack_top = (size_t )0;
    }
#line 2102
    return;
  }
#line 2105
  if (yy_buffer_stack_top >= yy_buffer_stack_max - 1UL) {
    {
#line 2108
    grow_size = 8;
#line 2110
    num_to_alloc = (int )(yy_buffer_stack_max + (size_t )grow_size);
#line 2111
    tmp___0 = yyrealloc((void *)yy_buffer_stack, (unsigned long )num_to_alloc * sizeof(struct yy_buffer_state *));
#line 2111
    yy_buffer_stack = (struct yy_buffer_state **)tmp___0;
    }
#line 2115
    if (! yy_buffer_stack) {
      {
#line 2116
      yy_fatal_error("out of dynamic memory in yyensure_buffer_stack()");
      }
    }
    {
#line 2119
    memset((void *)(yy_buffer_stack + yy_buffer_stack_max), 0, (unsigned long )grow_size * sizeof(struct yy_buffer_state *));
#line 2120
    yy_buffer_stack_max = (size_t )num_to_alloc;
    }
  }
#line 2122
  return;
}
}
#line 2130 "lex.c"
YY_BUFFER_STATE yy_scan_buffer(char *base , yy_size_t size ) 
{ 
  YY_BUFFER_STATE b ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 2134
  if (size < 2UL) {
#line 2138
    return ((YY_BUFFER_STATE )0);
  } else
#line 2134
  if ((int )*(base + (size - 2UL)) != 0) {
#line 2138
    return ((YY_BUFFER_STATE )0);
  } else
#line 2134
  if ((int )*(base + (size - 1UL)) != 0) {
#line 2138
    return ((YY_BUFFER_STATE )0);
  }
  {
#line 2140
  tmp = yyalloc(sizeof(struct yy_buffer_state ));
#line 2140
  b = (YY_BUFFER_STATE )tmp;
  }
#line 2141
  if (! b) {
    {
#line 2142
    yy_fatal_error("out of dynamic memory in yy_scan_buffer()");
    }
  }
  {
#line 2144
  b->yy_buf_size = size - 2UL;
#line 2145
  tmp___0 = base;
#line 2145
  b->yy_ch_buf = tmp___0;
#line 2145
  b->yy_buf_pos = tmp___0;
#line 2146
  b->yy_is_our_buffer = 0;
#line 2147
  b->yy_input_file = (FILE *)0;
#line 2148
  b->yy_n_chars = (int )b->yy_buf_size;
#line 2149
  b->yy_is_interactive = 0;
#line 2150
  b->yy_at_bol = 1;
#line 2151
  b->yy_fill_buffer = 0;
#line 2152
  b->yy_buffer_status = 0;
#line 2154
  yy_switch_to_buffer(b);
  }
#line 2156
  return (b);
}
}
#line 2167 "lex.c"
YY_BUFFER_STATE yy_scan_string(char const   *yystr ) 
{ 
  size_t tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2170
  tmp = strlen(yystr);
#line 2170
  tmp___0 = yy_scan_bytes(yystr, (int )tmp);
  }
#line 2170
  return (tmp___0);
}
}
#line 2180 "lex.c"
YY_BUFFER_STATE yy_scan_bytes(char const   *yybytes , int _yybytes_len ) 
{ 
  YY_BUFFER_STATE b ;
  char *buf ;
  yy_size_t n ;
  int i ;
  void *tmp ;
  char tmp___0 ;

  {
  {
#line 2188
  n = (yy_size_t )(_yybytes_len + 2);
#line 2189
  tmp = yyalloc(n);
#line 2189
  buf = (char *)tmp;
  }
#line 2190
  if (! buf) {
    {
#line 2191
    yy_fatal_error("out of dynamic memory in yy_scan_bytes()");
    }
  }
#line 2193
  i = 0;
  {
#line 2193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2193
    if (! (i < _yybytes_len)) {
#line 2193
      goto while_break;
    }
#line 2194
    *(buf + i) = (char )*(yybytes + i);
#line 2193
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2196
  tmp___0 = (char)0;
#line 2196
  *(buf + (_yybytes_len + 1)) = tmp___0;
#line 2196
  *(buf + _yybytes_len) = tmp___0;
#line 2198
  b = yy_scan_buffer(buf, n);
  }
#line 2199
  if (! b) {
    {
#line 2200
    yy_fatal_error("bad buffer in yy_scan_bytes()");
    }
  }
#line 2205
  b->yy_is_our_buffer = 1;
#line 2207
  return (b);
}
}
#line 2214 "lex.c"
static void yy_fatal_error(char const   *msg ) 
{ 


  {
  {
#line 2216
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 2217
  exit(2);
  }
}
}
#line 2242 "lex.c"
int yyget_lineno(void) 
{ 


  {
#line 2245
  return (yylineno);
}
}
#line 2251 "lex.c"
FILE *yyget_in(void) 
{ 


  {
#line 2253
  return (yyin);
}
}
#line 2259 "lex.c"
FILE *yyget_out(void) 
{ 


  {
#line 2261
  return (yyout);
}
}
#line 2267 "lex.c"
int yyget_leng(void) 
{ 


  {
#line 2269
  return (yyleng);
}
}
#line 2276 "lex.c"
char *yyget_text(void) 
{ 


  {
#line 2278
  return (yytext);
}
}
#line 2285 "lex.c"
void yyset_lineno(int line_number ) 
{ 


  {
#line 2288
  yylineno = line_number;
#line 2289
  return;
}
}
#line 2297 "lex.c"
void yyset_in(FILE *in_str ) 
{ 


  {
#line 2299
  yyin = in_str;
#line 2300
  return;
}
}
#line 2302 "lex.c"
void yyset_out(FILE *out_str ) 
{ 


  {
#line 2304
  yyout = out_str;
#line 2305
  return;
}
}
#line 2307 "lex.c"
int yyget_debug(void) 
{ 


  {
#line 2309
  return (yy_flex_debug);
}
}
#line 2312 "lex.c"
void yyset_debug(int bdebug ) 
{ 


  {
#line 2314
  yy_flex_debug = bdebug;
#line 2315
  return;
}
}
#line 2317 "lex.c"
static int yy_init_globals(void) 
{ 


  {
#line 2323
  yy_buffer_stack = (YY_BUFFER_STATE *)0;
#line 2324
  yy_buffer_stack_top = (size_t )0;
#line 2325
  yy_buffer_stack_max = (size_t )0;
#line 2326
  yy_c_buf_p = (char *)0;
#line 2327
  yy_init = 0;
#line 2328
  yy_start = 0;
#line 2335
  yyin = (FILE *)0;
#line 2336
  yyout = (FILE *)0;
#line 2342
  return (0);
}
}
#line 2346 "lex.c"
int yylex_destroy(void) 
{ 
  YY_BUFFER_STATE tmp ;
  YY_BUFFER_STATE tmp___0 ;

  {
  {
#line 2350
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2350
    if (yy_buffer_stack) {
#line 2350
      tmp___0 = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2350
      tmp___0 = (YY_BUFFER_STATE )((void *)0);
    }
#line 2350
    if (! tmp___0) {
#line 2350
      goto while_break;
    }
#line 2351
    if (yy_buffer_stack) {
#line 2351
      tmp = *(yy_buffer_stack + yy_buffer_stack_top);
    } else {
#line 2351
      tmp = (YY_BUFFER_STATE )((void *)0);
    }
    {
#line 2351
    yy_delete_buffer(tmp);
#line 2352
    *(yy_buffer_stack + yy_buffer_stack_top) = (YY_BUFFER_STATE )((void *)0);
#line 2353
    yypop_buffer_state();
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2357
  yyfree((void *)yy_buffer_stack);
#line 2358
  yy_buffer_stack = (YY_BUFFER_STATE *)((void *)0);
#line 2362
  yy_init_globals();
  }
#line 2364
  return (0);
}
}
#line 2391 "lex.c"
void *yyalloc(yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2393
  tmp = malloc(size);
  }
#line 2393
  return (tmp);
}
}
#line 2396 "lex.c"
void *yyrealloc(void *ptr , yy_size_t size ) 
{ 
  void *tmp ;

  {
  {
#line 2405
  tmp = realloc((void *)((char *)ptr), size);
  }
#line 2405
  return (tmp);
}
}
#line 2408 "lex.c"
void yyfree(void *ptr ) 
{ 


  {
  {
#line 2410
  free((void *)((char *)ptr));
  }
#line 2411
  return;
}
}
#line 131 "lex.l"
void freebufs(void) 
{ 
  YY_BUFFER_STATE tmp ;

  {
#line 132
  if (yy_buffer_stack) {
#line 132
    tmp = *(yy_buffer_stack + yy_buffer_stack_top);
  } else {
#line 132
    tmp = (YY_BUFFER_STATE )((void *)0);
  }
  {
#line 132
  yy_delete_buffer(tmp);
  }
#line 133
  return;
}
}
/* compiler builtin: 
   void *__builtin_memcpy(void * , void const   * , unsigned long  ) ;  */
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 71 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 105
extern struct group *getgrgid(__gid_t __gid ) ;
#line 111
extern struct group *getgrnam(char const   *__name ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 54 "/usr/include/rpc/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endrpcent)(void) ;
#line 55
extern  __attribute__((__nothrow__)) struct rpcent *( __attribute__((__leaf__)) getrpcbyname)(char const   *__name ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 671
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) gai_strerror)(int __ecode ) ;
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 110
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 116
extern struct passwd *getpwnam(char const   *__name ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 411 "/usr/include/rpc/clnt.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) get_myaddress)(struct sockaddr_in * ) ;
#line 69 "/usr/include/rpc/pmap_clnt.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) pmap_set)(u_long const   __program ,
                                                                                  u_long const   __vers ,
                                                                                  int __protocol ,
                                                                                  u_short __port ) ;
#line 88
extern  __attribute__((__nothrow__)) u_short ( __attribute__((__leaf__)) pmap_getport)(struct sockaddr_in *__address ,
                                                                                       u_long const   __program ,
                                                                                       u_long const   __version ,
                                                                                       u_int __protocol ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 297
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 478 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchown)(int __fd ,
                                                                             __uid_t __owner ,
                                                                             __gid_t __group ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 582
extern size_t regerror(int __errcode , regex_t const   * __restrict  __preg , char * __restrict  __errbuf ,
                       size_t __errbuf_size ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/rlinetd.h"
int rl_debug ;
#line 50
struct rl_cleanup *rl_cleanups ;
#line 52
void read_hook(int fd , rl_opcode_t *op , struct rl_instance *inst ) ;
#line 56
void all_unhook(void) ;
#line 61
void inst_free(struct rl_instance *i ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.h"
struct opmeta *opmeta_make(int len , rl_opcode_t op  , ...) ;
#line 54
int opmetalist_add(struct opmetalist *opml , struct opmeta *opm ) ;
#line 55
struct opmetalist *opmetalist_merge(struct opmetalist *o , struct opmetalist  const  *p ) ;
#line 56
struct opmetalist *opmetalist_join(struct opmetalist *o , struct opmetalist *p ) ;
#line 57
void opmeta_fixup(struct opmeta *o , int offset , opmeta_fixup_ptr fixup ) ;
#line 58
struct opmetalist *opmetalist_new(void) ;
#line 59
struct oplist *opmetalist_resolve(struct opmetalist *o , opmeta_fixup_ptr const   *fixups ) ;
#line 60
void opmetalist_free(struct opmetalist *l ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.h"
void numlist_add(struct numlist **list , long num ) ;
#line 67
void numlist_copy(struct numlist **to , struct numlist *from ) ;
#line 75
void stringlist_add(struct stringlist **list , char *str ) ;
#line 76
void stringlist_copy(struct stringlist **to , struct stringlist *from ) ;
#line 77
void stringlist_free(struct stringlist *n ) ;
#line 86
void clearuserdata(struct userdata **dest ) ;
#line 87
void newuserdata(struct userdata **dest ) ;
#line 67 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
rl_opcode_t *oplisttab_get(int i ) ;
#line 120
struct pidtab pidtabs[8] ;
#line 141
fd_set *fdsettab_get(int i ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.h"
void rl_note(char const   *fmt  , ...) ;
#line 14
void rl_pfatal(int ex , char const   *file , int line , char const   *fmt  , ...) ;
#line 202 "grammar.h"
YYSTYPE yylval  ;
#line 212
int yyparse(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/parse.h"
void services_free(void) ;
#line 70 "grammar.y"
struct userdata *userdata  ;
#line 72 "grammar.y"
static struct service *current_service  ;
#line 74
char const   *rl_config ;
#line 75 "grammar.y"
char **files  =    (char **)((void *)0);
#line 76 "grammar.y"
static int curfile  =    -1;
#line 76 "grammar.y"
static int numfiles  =    0;
#line 77 "grammar.y"
char *curfile_name  =    (char *)((void *)0);
#line 78 "grammar.y"
int curfile_line  =    1;
#line 80 "grammar.y"
static struct service *defaults  ;
#line 81 "grammar.y"
static struct opmetalist *opml_defaults  ;
#line 83 "grammar.y"
static struct logdata *logcur  ;
#line 83 "grammar.y"
static struct logdata *logdatas  ;
#line 85 "grammar.y"
static struct numlist *numlist  =    (struct numlist *)((void *)0);
#line 86 "grammar.y"
static struct stringlist *stringlist  =    (struct stringlist *)((void *)0);
#line 88
void yyerror(char const   *str ) ;
#line 91
static int bind_ports(void) ;
#line 92
static int add_user_group(struct service  const  *s , struct opmetalist *l ) ;
#line 93
static void service_copy(struct service *to , struct service *from ) ;
#line 94
static void service_free(struct service *s ) ;
#line 95
static struct service *service_new(void) ;
#line 99
static struct logdata *logdata_get(char *name ) ;
#line 100
static struct logdata *logdata_new(void) ;
#line 101
static void pidtab_fixup(void) ;
#line 102
static void validate_service(struct service *s ) ;
#line 103
static void add_directory(char *dir , char *match , char *ignore ) ;
#line 104
static int chargen_buffer(void) ;
#line 631 "grammar.c"
static yytype_uint8 const   yytranslate[320]  = 
#line 631 "grammar.c"
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )69,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )67,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )5,      (yytype_uint8 const   )6,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8, 
        (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )13,      (yytype_uint8 const   )14,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )17,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )31,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47,      (yytype_uint8 const   )48, 
        (yytype_uint8 const   )49,      (yytype_uint8 const   )50,      (yytype_uint8 const   )51,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )54,      (yytype_uint8 const   )55,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )57,      (yytype_uint8 const   )58,      (yytype_uint8 const   )59,      (yytype_uint8 const   )60, 
        (yytype_uint8 const   )61,      (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )64};
#line 789 "grammar.c"
static yytype_uint8 const   yyr1[114]  = 
#line 789
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )70,      (yytype_uint8 const   )71,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )72,      (yytype_uint8 const   )72,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )73,      (yytype_uint8 const   )73,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )77,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )81,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )83,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )85,      (yytype_uint8 const   )86,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )87,      (yytype_uint8 const   )87,      (yytype_uint8 const   )88,      (yytype_uint8 const   )88, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )89,      (yytype_uint8 const   )90,      (yytype_uint8 const   )90, 
        (yytype_uint8 const   )91,      (yytype_uint8 const   )91,      (yytype_uint8 const   )92,      (yytype_uint8 const   )92, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )94,      (yytype_uint8 const   )94,      (yytype_uint8 const   )95, 
        (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )96,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )98,      (yytype_uint8 const   )98,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )98,      (yytype_uint8 const   )98,      (yytype_uint8 const   )98, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )99, 
        (yytype_uint8 const   )100,      (yytype_uint8 const   )100,      (yytype_uint8 const   )101,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )104};
#line 806 "grammar.c"
static yytype_uint8 const   yyr2[114]  = 
#line 806
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )4,      (yytype_uint8 const   )5,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )2,      (yytype_uint8 const   )2,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )4, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )2,      (yytype_uint8 const   )3,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )1,      (yytype_uint8 const   )2, 
        (yytype_uint8 const   )1,      (yytype_uint8 const   )1};
#line 825 "grammar.c"
static yytype_uint8 const   yydefact[215]  = 
#line 825
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )2,      (yytype_uint8 const   )7, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )5,      (yytype_uint8 const   )4,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )3,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )55,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )57, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )27,      (yytype_uint8 const   )24,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )8,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )87,      (yytype_uint8 const   )0,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )107,      (yytype_uint8 const   )106,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )103,      (yytype_uint8 const   )0,      (yytype_uint8 const   )104, 
        (yytype_uint8 const   )105,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )112,      (yytype_uint8 const   )113,      (yytype_uint8 const   )0,      (yytype_uint8 const   )110, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )84, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )82,      (yytype_uint8 const   )37,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )108,      (yytype_uint8 const   )109, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )34,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )54,      (yytype_uint8 const   )0,      (yytype_uint8 const   )56, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )53,      (yytype_uint8 const   )0,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )94,      (yytype_uint8 const   )95,      (yytype_uint8 const   )96,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )50, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )20,      (yytype_uint8 const   )26,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )0,      (yytype_uint8 const   )9,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )15, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )58,      (yytype_uint8 const   )0,      (yytype_uint8 const   )32,      (yytype_uint8 const   )59, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )43,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )111,      (yytype_uint8 const   )36,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )64,      (yytype_uint8 const   )0,      (yytype_uint8 const   )44,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )70, 
        (yytype_uint8 const   )48,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )28, 
        (yytype_uint8 const   )29,      (yytype_uint8 const   )45,      (yytype_uint8 const   )68,      (yytype_uint8 const   )35, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )52,      (yytype_uint8 const   )69,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )92,      (yytype_uint8 const   )91,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )11,      (yytype_uint8 const   )14,      (yytype_uint8 const   )86, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )76,      (yytype_uint8 const   )0,      (yytype_uint8 const   )74, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )67,      (yytype_uint8 const   )71,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )31,      (yytype_uint8 const   )30,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )78,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )42,      (yytype_uint8 const   )17,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )19,      (yytype_uint8 const   )0,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )72,      (yytype_uint8 const   )46,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )90,      (yytype_uint8 const   )79,      (yytype_uint8 const   )77, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )80,      (yytype_uint8 const   )81};
#line 852 "grammar.c"
static yytype_int16 const   yydefgoto[35]  = 
#line 852
  {      (yytype_int16 const   )-1,      (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )7, 
        (yytype_int16 const   )8,      (yytype_int16 const   )128,      (yytype_int16 const   )129,      (yytype_int16 const   )130, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )48,      (yytype_int16 const   )154, 
        (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )100,      (yytype_int16 const   )51, 
        (yytype_int16 const   )150,      (yytype_int16 const   )151,      (yytype_int16 const   )182,      (yytype_int16 const   )183, 
        (yytype_int16 const   )193,      (yytype_int16 const   )194,      (yytype_int16 const   )80,      (yytype_int16 const   )81, 
        (yytype_int16 const   )58,      (yytype_int16 const   )59,      (yytype_int16 const   )168,      (yytype_int16 const   )169, 
        (yytype_int16 const   )112,      (yytype_int16 const   )66,      (yytype_int16 const   )69,      (yytype_int16 const   )63, 
        (yytype_int16 const   )92,      (yytype_int16 const   )77,      (yytype_int16 const   )74};
#line 863 "grammar.c"
static yytype_int16 const   yypact[215]  = 
#line 863
  {      (yytype_int16 const   )12,      (yytype_int16 const   )-58,      (yytype_int16 const   )-23,      (yytype_int16 const   )3, 
        (yytype_int16 const   )14,      (yytype_int16 const   )60,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )37, 
        (yytype_int16 const   )263,      (yytype_int16 const   )20,      (yytype_int16 const   )55,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )263,      (yytype_int16 const   )-41,      (yytype_int16 const   )51, 
        (yytype_int16 const   )63,      (yytype_int16 const   )47,      (yytype_int16 const   )49,      (yytype_int16 const   )70, 
        (yytype_int16 const   )73,      (yytype_int16 const   )64,      (yytype_int16 const   )-52,      (yytype_int16 const   )-16, 
        (yytype_int16 const   )77,      (yytype_int16 const   )97,      (yytype_int16 const   )98,      (yytype_int16 const   )93, 
        (yytype_int16 const   )10,      (yytype_int16 const   )99,      (yytype_int16 const   )89,      (yytype_int16 const   )-38, 
        (yytype_int16 const   )100,      (yytype_int16 const   )101,      (yytype_int16 const   )102,      (yytype_int16 const   )103, 
        (yytype_int16 const   )105,      (yytype_int16 const   )104,      (yytype_int16 const   )64,      (yytype_int16 const   )48, 
        (yytype_int16 const   )-47,      (yytype_int16 const   )107,      (yytype_int16 const   )108,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )19,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )39,      (yytype_int16 const   )-59,      (yytype_int16 const   )2,      (yytype_int16 const   )118, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )31,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )109,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )110, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )112,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )117,      (yytype_int16 const   )119,      (yytype_int16 const   )122, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )123,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )129,      (yytype_int16 const   )127,      (yytype_int16 const   )128,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )32,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )130, 
        (yytype_int16 const   )133,      (yytype_int16 const   )96,      (yytype_int16 const   )81,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )300,      (yytype_int16 const   )134,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )135,      (yytype_int16 const   )-59,      (yytype_int16 const   )140,      (yytype_int16 const   )143, 
        (yytype_int16 const   )145,      (yytype_int16 const   )-59,      (yytype_int16 const   )146,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )147,      (yytype_int16 const   )-59,      (yytype_int16 const   )148,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )16,      (yytype_int16 const   )131,      (yytype_int16 const   )151,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )152,      (yytype_int16 const   )-59,      (yytype_int16 const   )47, 
        (yytype_int16 const   )49,      (yytype_int16 const   )153,      (yytype_int16 const   )156,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )154,      (yytype_int16 const   )2,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-41,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )106,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )160,      (yytype_int16 const   )163,      (yytype_int16 const   )-20,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )300,      (yytype_int16 const   )171,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )76, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )158,      (yytype_int16 const   )162,      (yytype_int16 const   )165, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )168,      (yytype_int16 const   )169,      (yytype_int16 const   )172, 
        (yytype_int16 const   )174,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )175,      (yytype_int16 const   )33,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )182,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )210, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-42, 
        (yytype_int16 const   )-42,      (yytype_int16 const   )-31,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )187,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )160,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )185, 
        (yytype_int16 const   )186,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59};
#line 890 "grammar.c"
static yytype_int16 const   yypgoto[35]  = 
#line 890
  {      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )247,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )36, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )236,      (yytype_int16 const   )111, 
        (yytype_int16 const   )-48,      (yytype_int16 const   )-46,      (yytype_int16 const   )-59,      (yytype_int16 const   )13, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )115,      (yytype_int16 const   )-59,      (yytype_int16 const   )50, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )62,      (yytype_int16 const   )-59,      (yytype_int16 const   )113, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )124,      (yytype_int16 const   )-59,      (yytype_int16 const   )-34, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )136,      (yytype_int16 const   )132,      (yytype_int16 const   )-59, 
        (yytype_int16 const   )-59,      (yytype_int16 const   )-59,      (yytype_int16 const   )27};
#line 902 "grammar.c"
static yytype_uint8 const   yytable[362]  = 
#line 902
  {      (yytype_uint8 const   )118,      (yytype_uint8 const   )78,      (yytype_uint8 const   )119,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )149,      (yytype_uint8 const   )11,      (yytype_uint8 const   )165,      (yytype_uint8 const   )118, 
        (yytype_uint8 const   )113,      (yytype_uint8 const   )119,      (yytype_uint8 const   )75,      (yytype_uint8 const   )123, 
        (yytype_uint8 const   )124,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )114,      (yytype_uint8 const   )76,      (yytype_uint8 const   )191,      (yytype_uint8 const   )192, 
        (yytype_uint8 const   )166,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )2,      (yytype_uint8 const   )93, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )3,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )209,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )155,      (yytype_uint8 const   )31,      (yytype_uint8 const   )156,      (yytype_uint8 const   )12, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )185, 
        (yytype_uint8 const   )79,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )125,      (yytype_uint8 const   )126, 
        (yytype_uint8 const   )15,      (yytype_uint8 const   )120,      (yytype_uint8 const   )94,      (yytype_uint8 const   )1, 
        (yytype_uint8 const   )165,      (yytype_uint8 const   )4,      (yytype_uint8 const   )13,      (yytype_uint8 const   )127, 
        (yytype_uint8 const   )120,      (yytype_uint8 const   )102,      (yytype_uint8 const   )61,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )86,      (yytype_uint8 const   )2,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )88,      (yytype_uint8 const   )14,      (yytype_uint8 const   )166,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )3,      (yytype_uint8 const   )167,      (yytype_uint8 const   )52, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )53,      (yytype_uint8 const   )117,      (yytype_uint8 const   )103, 
        (yytype_uint8 const   )104,      (yytype_uint8 const   )105,      (yytype_uint8 const   )106,      (yytype_uint8 const   )107, 
        (yytype_uint8 const   )108,      (yytype_uint8 const   )109,      (yytype_uint8 const   )110,      (yytype_uint8 const   )111, 
        (yytype_uint8 const   )132,      (yytype_uint8 const   )144,      (yytype_uint8 const   )203,      (yytype_uint8 const   )133, 
        (yytype_uint8 const   )145,      (yytype_uint8 const   )204,      (yytype_uint8 const   )121,      (yytype_uint8 const   )17, 
        (yytype_uint8 const   )122,      (yytype_uint8 const   )155,      (yytype_uint8 const   )189,      (yytype_uint8 const   )156, 
        (yytype_uint8 const   )190,      (yytype_uint8 const   )64,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )4,      (yytype_uint8 const   )60,      (yytype_uint8 const   )72, 
        (yytype_uint8 const   )73,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )148, 
        (yytype_uint8 const   )149,      (yytype_uint8 const   )54,      (yytype_uint8 const   )18,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )20,      (yytype_uint8 const   )191,      (yytype_uint8 const   )192,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )25, 
        (yytype_uint8 const   )70,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )71, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30,      (yytype_uint8 const   )189, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )190,      (yytype_uint8 const   )82,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )152,      (yytype_uint8 const   )153, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )207,      (yytype_uint8 const   )208,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )84,      (yytype_uint8 const   )89,      (yytype_uint8 const   )95, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )178,      (yytype_uint8 const   )98,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )99,      (yytype_uint8 const   )101,      (yytype_uint8 const   )79,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )115,      (yytype_uint8 const   )116,      (yytype_uint8 const   )134,      (yytype_uint8 const   )135, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )136,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )137,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )138,      (yytype_uint8 const   )131,      (yytype_uint8 const   )26,      (yytype_uint8 const   )139, 
        (yytype_uint8 const   )140,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )141, 
        (yytype_uint8 const   )142,      (yytype_uint8 const   )143,      (yytype_uint8 const   )170,      (yytype_uint8 const   )146, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )147,      (yytype_uint8 const   )157, 
        (yytype_uint8 const   )158,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )159,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )160,      (yytype_uint8 const   )43,      (yytype_uint8 const   )161,      (yytype_uint8 const   )162, 
        (yytype_uint8 const   )163,      (yytype_uint8 const   )164,      (yytype_uint8 const   )171,      (yytype_uint8 const   )19, 
        (yytype_uint8 const   )175,      (yytype_uint8 const   )172,      (yytype_uint8 const   )176,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )22,      (yytype_uint8 const   )177,      (yytype_uint8 const   )181,      (yytype_uint8 const   )195, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )26,      (yytype_uint8 const   )184,      (yytype_uint8 const   )196, 
        (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )197,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )198,      (yytype_uint8 const   )199,      (yytype_uint8 const   )32, 
        (yytype_uint8 const   )33,      (yytype_uint8 const   )200,      (yytype_uint8 const   )188,      (yytype_uint8 const   )201, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )202,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )205, 
        (yytype_uint8 const   )43,      (yytype_uint8 const   )211,      (yytype_uint8 const   )213,      (yytype_uint8 const   )214, 
        (yytype_uint8 const   )16,      (yytype_uint8 const   )55,      (yytype_uint8 const   )212,      (yytype_uint8 const   )210, 
        (yytype_uint8 const   )174,      (yytype_uint8 const   )179,      (yytype_uint8 const   )180,      (yytype_uint8 const   )173, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )44, 
        (yytype_uint8 const   )187,      (yytype_uint8 const   )186,      (yytype_uint8 const   )0,      (yytype_uint8 const   )18, 
        (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46, 
        (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )23,      (yytype_uint8 const   )24, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )206,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )31,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37, 
        (yytype_uint8 const   )38,      (yytype_uint8 const   )39,      (yytype_uint8 const   )40,      (yytype_uint8 const   )41, 
        (yytype_uint8 const   )42,      (yytype_uint8 const   )43,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )19,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )21,      (yytype_uint8 const   )22,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )26, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )0,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )45, 
        (yytype_uint8 const   )46,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )47,      (yytype_uint8 const   )0,      (yytype_uint8 const   )35,      (yytype_uint8 const   )36, 
        (yytype_uint8 const   )37,      (yytype_uint8 const   )38,      (yytype_uint8 const   )0,      (yytype_uint8 const   )40, 
        (yytype_uint8 const   )41,      (yytype_uint8 const   )0,      (yytype_uint8 const   )43,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )44,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )45,      (yytype_uint8 const   )46};
#line 949 "grammar.c"
static yytype_int16 const   yycheck[362]  = 
#line 949
  {      (yytype_int16 const   )48,      (yytype_int16 const   )17,      (yytype_int16 const   )48,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )63,      (yytype_int16 const   )48,      (yytype_int16 const   )55, 
        (yytype_int16 const   )55,      (yytype_int16 const   )55,      (yytype_int16 const   )62,      (yytype_int16 const   )9, 
        (yytype_int16 const   )10,      (yytype_int16 const   )51,      (yytype_int16 const   )52,      (yytype_int16 const   )3, 
        (yytype_int16 const   )63,      (yytype_int16 const   )69,      (yytype_int16 const   )49,      (yytype_int16 const   )50, 
        (yytype_int16 const   )62,      (yytype_int16 const   )62,      (yytype_int16 const   )63,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )14,      (yytype_int16 const   )65, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )13,      (yytype_int16 const   )21,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )67,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )88,      (yytype_int16 const   )22,      (yytype_int16 const   )88,      (yytype_int16 const   )66, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )67, 
        (yytype_int16 const   )64,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )56,      (yytype_int16 const   )57, 
        (yytype_int16 const   )0,      (yytype_int16 const   )48,      (yytype_int16 const   )35,      (yytype_int16 const   )3, 
        (yytype_int16 const   )48,      (yytype_int16 const   )53,      (yytype_int16 const   )63,      (yytype_int16 const   )65, 
        (yytype_int16 const   )55,      (yytype_int16 const   )42,      (yytype_int16 const   )7,      (yytype_int16 const   )8, 
        (yytype_int16 const   )53,      (yytype_int16 const   )63,      (yytype_int16 const   )14,      (yytype_int16 const   )65, 
        (yytype_int16 const   )66,      (yytype_int16 const   )63,      (yytype_int16 const   )62,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )21,      (yytype_int16 const   )66,      (yytype_int16 const   )63, 
        (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )67,      (yytype_int16 const   )39, 
        (yytype_int16 const   )40,      (yytype_int16 const   )41,      (yytype_int16 const   )42,      (yytype_int16 const   )43, 
        (yytype_int16 const   )44,      (yytype_int16 const   )45,      (yytype_int16 const   )46,      (yytype_int16 const   )47, 
        (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )68, 
        (yytype_int16 const   )68,      (yytype_int16 const   )68,      (yytype_int16 const   )63,      (yytype_int16 const   )66, 
        (yytype_int16 const   )65,      (yytype_int16 const   )153,      (yytype_int16 const   )154,      (yytype_int16 const   )153, 
        (yytype_int16 const   )154,      (yytype_int16 const   )62,      (yytype_int16 const   )63,      (yytype_int16 const   )62, 
        (yytype_int16 const   )63,      (yytype_int16 const   )53,      (yytype_int16 const   )63,      (yytype_int16 const   )51, 
        (yytype_int16 const   )52,      (yytype_int16 const   )28,      (yytype_int16 const   )29,      (yytype_int16 const   )23, 
        (yytype_int16 const   )24,      (yytype_int16 const   )66,      (yytype_int16 const   )4,      (yytype_int16 const   )5, 
        (yytype_int16 const   )6,      (yytype_int16 const   )49,      (yytype_int16 const   )50,      (yytype_int16 const   )9, 
        (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12,      (yytype_int16 const   )13, 
        (yytype_int16 const   )62,      (yytype_int16 const   )15,      (yytype_int16 const   )16,      (yytype_int16 const   )62, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20,      (yytype_int16 const   )187, 
        (yytype_int16 const   )22,      (yytype_int16 const   )187,      (yytype_int16 const   )65,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )65,      (yytype_int16 const   )66, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )37, 
        (yytype_int16 const   )38,      (yytype_int16 const   )191,      (yytype_int16 const   )192,      (yytype_int16 const   )66, 
        (yytype_int16 const   )63,      (yytype_int16 const   )63,      (yytype_int16 const   )63,      (yytype_int16 const   )63, 
        (yytype_int16 const   )63,      (yytype_int16 const   )129,      (yytype_int16 const   )63,      (yytype_int16 const   )65, 
        (yytype_int16 const   )63,      (yytype_int16 const   )65,      (yytype_int16 const   )64,      (yytype_int16 const   )53, 
        (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )65, 
        (yytype_int16 const   )5,      (yytype_int16 const   )65,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )65,      (yytype_int16 const   )65, 
        (yytype_int16 const   )65,      (yytype_int16 const   )67,      (yytype_int16 const   )15,      (yytype_int16 const   )65, 
        (yytype_int16 const   )65,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )62, 
        (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )63,      (yytype_int16 const   )65, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )65,      (yytype_int16 const   )65, 
        (yytype_int16 const   )65,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )65,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )65,      (yytype_int16 const   )38,      (yytype_int16 const   )65,      (yytype_int16 const   )65, 
        (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )63,      (yytype_int16 const   )5, 
        (yytype_int16 const   )63,      (yytype_int16 const   )65,      (yytype_int16 const   )62,      (yytype_int16 const   )9, 
        (yytype_int16 const   )10,      (yytype_int16 const   )67,      (yytype_int16 const   )62,      (yytype_int16 const   )65, 
        (yytype_int16 const   )53,      (yytype_int16 const   )15,      (yytype_int16 const   )63,      (yytype_int16 const   )65, 
        (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )65,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )65,      (yytype_int16 const   )65,      (yytype_int16 const   )25, 
        (yytype_int16 const   )26,      (yytype_int16 const   )65,      (yytype_int16 const   )67,      (yytype_int16 const   )65, 
        (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32,      (yytype_int16 const   )33, 
        (yytype_int16 const   )69,      (yytype_int16 const   )35,      (yytype_int16 const   )36,      (yytype_int16 const   )65, 
        (yytype_int16 const   )38,      (yytype_int16 const   )62,      (yytype_int16 const   )65,      (yytype_int16 const   )65, 
        (yytype_int16 const   )5,      (yytype_int16 const   )17,      (yytype_int16 const   )204,      (yytype_int16 const   )193, 
        (yytype_int16 const   )124,      (yytype_int16 const   )133,      (yytype_int16 const   )145,      (yytype_int16 const   )123, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )53, 
        (yytype_int16 const   )153,      (yytype_int16 const   )150,      (yytype_int16 const   )-1,      (yytype_int16 const   )4, 
        (yytype_int16 const   )5,      (yytype_int16 const   )6,      (yytype_int16 const   )60,      (yytype_int16 const   )61, 
        (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )11,      (yytype_int16 const   )12, 
        (yytype_int16 const   )13,      (yytype_int16 const   )67,      (yytype_int16 const   )15,      (yytype_int16 const   )16, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )18,      (yytype_int16 const   )19,      (yytype_int16 const   )20, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )22,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )27,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )31,      (yytype_int16 const   )32, 
        (yytype_int16 const   )33,      (yytype_int16 const   )34,      (yytype_int16 const   )35,      (yytype_int16 const   )36, 
        (yytype_int16 const   )37,      (yytype_int16 const   )38,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )5,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )9,      (yytype_int16 const   )10,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )15, 
        (yytype_int16 const   )53,      (yytype_int16 const   )-1,      (yytype_int16 const   )18,      (yytype_int16 const   )19, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )60, 
        (yytype_int16 const   )61,      (yytype_int16 const   )25,      (yytype_int16 const   )26,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )65,      (yytype_int16 const   )-1,      (yytype_int16 const   )30,      (yytype_int16 const   )31, 
        (yytype_int16 const   )32,      (yytype_int16 const   )33,      (yytype_int16 const   )-1,      (yytype_int16 const   )35, 
        (yytype_int16 const   )36,      (yytype_int16 const   )-1,      (yytype_int16 const   )38,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )53,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1,      (yytype_int16 const   )-1, 
        (yytype_int16 const   )60,      (yytype_int16 const   )61};
#line 992 "grammar.c"
static yytype_uint8 const   yystos[215]  = 
#line 992
  {      (yytype_uint8 const   )0,      (yytype_uint8 const   )3,      (yytype_uint8 const   )14,      (yytype_uint8 const   )21, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )71,      (yytype_uint8 const   )72,      (yytype_uint8 const   )73, 
        (yytype_uint8 const   )74,      (yytype_uint8 const   )78,      (yytype_uint8 const   )79,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )63,      (yytype_uint8 const   )63,      (yytype_uint8 const   )0, 
        (yytype_uint8 const   )72,      (yytype_uint8 const   )66,      (yytype_uint8 const   )4,      (yytype_uint8 const   )5, 
        (yytype_uint8 const   )6,      (yytype_uint8 const   )9,      (yytype_uint8 const   )10,      (yytype_uint8 const   )11, 
        (yytype_uint8 const   )12,      (yytype_uint8 const   )13,      (yytype_uint8 const   )15,      (yytype_uint8 const   )16, 
        (yytype_uint8 const   )18,      (yytype_uint8 const   )19,      (yytype_uint8 const   )20,      (yytype_uint8 const   )22, 
        (yytype_uint8 const   )25,      (yytype_uint8 const   )26,      (yytype_uint8 const   )27,      (yytype_uint8 const   )30, 
        (yytype_uint8 const   )31,      (yytype_uint8 const   )32,      (yytype_uint8 const   )33,      (yytype_uint8 const   )34, 
        (yytype_uint8 const   )35,      (yytype_uint8 const   )36,      (yytype_uint8 const   )37,      (yytype_uint8 const   )38, 
        (yytype_uint8 const   )53,      (yytype_uint8 const   )60,      (yytype_uint8 const   )61,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )80,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )85, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )80, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )94,      (yytype_uint8 const   )95, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )7,      (yytype_uint8 const   )8,      (yytype_uint8 const   )101, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )63,      (yytype_uint8 const   )99,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )100,      (yytype_uint8 const   )62,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )51,      (yytype_uint8 const   )52,      (yytype_uint8 const   )104,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )69,      (yytype_uint8 const   )103,      (yytype_uint8 const   )17,      (yytype_uint8 const   )64, 
        (yytype_uint8 const   )92,      (yytype_uint8 const   )93,      (yytype_uint8 const   )65,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )66,      (yytype_uint8 const   )63,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )66,      (yytype_uint8 const   )63,      (yytype_uint8 const   )28,      (yytype_uint8 const   )29, 
        (yytype_uint8 const   )102,      (yytype_uint8 const   )65,      (yytype_uint8 const   )104,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )65,      (yytype_uint8 const   )63,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )84,      (yytype_uint8 const   )65,      (yytype_uint8 const   )104,      (yytype_uint8 const   )39, 
        (yytype_uint8 const   )40,      (yytype_uint8 const   )41,      (yytype_uint8 const   )42,      (yytype_uint8 const   )43, 
        (yytype_uint8 const   )44,      (yytype_uint8 const   )45,      (yytype_uint8 const   )46,      (yytype_uint8 const   )47, 
        (yytype_uint8 const   )98,      (yytype_uint8 const   )55,      (yytype_uint8 const   )63,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )67,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83, 
        (yytype_uint8 const   )85,      (yytype_uint8 const   )63,      (yytype_uint8 const   )65,      (yytype_uint8 const   )9, 
        (yytype_uint8 const   )10,      (yytype_uint8 const   )56,      (yytype_uint8 const   )57,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )75,      (yytype_uint8 const   )76,      (yytype_uint8 const   )77,      (yytype_uint8 const   )67, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )68,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )62,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )68,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )23,      (yytype_uint8 const   )24,      (yytype_uint8 const   )86,      (yytype_uint8 const   )87, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )66,      (yytype_uint8 const   )81,      (yytype_uint8 const   )82, 
        (yytype_uint8 const   )83,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )48,      (yytype_uint8 const   )62,      (yytype_uint8 const   )66, 
        (yytype_uint8 const   )96,      (yytype_uint8 const   )97,      (yytype_uint8 const   )63,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )99,      (yytype_uint8 const   )100,      (yytype_uint8 const   )63, 
        (yytype_uint8 const   )62,      (yytype_uint8 const   )67,      (yytype_uint8 const   )77,      (yytype_uint8 const   )95, 
        (yytype_uint8 const   )93,      (yytype_uint8 const   )62,      (yytype_uint8 const   )88,      (yytype_uint8 const   )89, 
        (yytype_uint8 const   )63,      (yytype_uint8 const   )67,      (yytype_uint8 const   )87,      (yytype_uint8 const   )81, 
        (yytype_uint8 const   )67,      (yytype_uint8 const   )82,      (yytype_uint8 const   )83,      (yytype_uint8 const   )49, 
        (yytype_uint8 const   )50,      (yytype_uint8 const   )90,      (yytype_uint8 const   )91,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )65,      (yytype_uint8 const   )65,      (yytype_uint8 const   )69,      (yytype_uint8 const   )65, 
        (yytype_uint8 const   )68,      (yytype_uint8 const   )65,      (yytype_uint8 const   )67,      (yytype_uint8 const   )97, 
        (yytype_uint8 const   )97,      (yytype_uint8 const   )67,      (yytype_uint8 const   )91,      (yytype_uint8 const   )62, 
        (yytype_uint8 const   )89,      (yytype_uint8 const   )65,      (yytype_uint8 const   )65};
#line 1507 "grammar.c"
static void yydestruct(char const   *yymsg , int yytype , YYSTYPE *yyvaluep ) 
{ 


  {
#line 1519
  if (! yymsg) {
#line 1520
    yymsg = "Deleting";
  }
#line 1524
  return;
}
}
#line 1530 "grammar.c"
int yychar  ;
#line 1545 "grammar.c"
int yynerrs  ;
#line 1565 "grammar.c"
int yyparse(void) 
{ 
  int yystate ;
  int yyerrstatus ;
  yytype_int16 yyssa[200] ;
  yytype_int16 *yyss ;
  yytype_int16 *yyssp ;
  YYSTYPE yyvsa[200] ;
  YYSTYPE *yyvs ;
  YYSTYPE *yyvsp ;
  unsigned long yystacksize ;
  int yyn ;
  int yyresult ;
  int yytoken ;
  YYSTYPE yyval ;
  int yylen ;
  unsigned long yysize ;
  yytype_int16 *yyss1 ;
  union yyalloc *yyptr ;
  void *tmp ;
  unsigned long yynewbytes ;
  unsigned long yynewbytes___0 ;
  struct logdata *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  struct service *saved_defaults ;
  struct opmetalist *parent ;
  struct opmetalist *onexit ;
  struct oplist *ops ;
  int i ;
  int fds ;
  fd_set *fdst ;
  int tmp___16 ;
  char *tmp___17 ;
  struct opmeta *tmp___18 ;
  int tmp___19 ;
  struct opmeta *tmp___20 ;
  struct opmeta *tmp___21 ;
  struct opmeta *tmp___22 ;
  struct opmeta *tmp___23 ;
  struct opmeta *tmp___24 ;
  int tmp___25 ;
  struct opmetalist *o ;
  struct oplist *l ;
  int match ;
  int under ;
  struct opmeta *tmp___26 ;
  struct opmeta *tmp___27 ;
  struct opmeta *tmp___28 ;
  struct opmeta *tmp___29 ;
  struct opmeta *tmp___30 ;
  struct opmeta *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  struct opmeta *tmp___34 ;
  int tmp___35 ;
  rl_opcode_t *tmp___36 ;
  char *tmp___37 ;
  char *tmp___38 ;
  char *tmp___39 ;
  struct opmetalist *l___0 ;
  char *tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  struct opmetalist *l___1 ;
  char *tmp___45 ;
  int tmp___46 ;
  char *tmp___47 ;
  int tmp___48 ;
  char *tmp___49 ;
  struct opmetalist *l___2 ;
  struct opmeta *o___0 ;
  int tmp___50 ;
  char *tmp___51 ;
  int tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int i___0 ;
  int ret ;
  int i___1 ;
  struct logdata *ld ;
  struct logdata *tmp___56 ;
  char *tmp___57 ;
  int i___2 ;
  int tmp___58 ;
  char *tmp___59 ;
  int tmp___60 ;
  char *tmp___61 ;
  int i___3 ;
  struct oplist *op ;
  struct opmeta *tmp___62 ;
  int tmp___63 ;
  struct opmeta *o___1 ;
  int i___4 ;
  struct oplist *op___0 ;
  struct opmeta *tmp___64 ;
  struct opmetalist *l___3 ;
  int i___5 ;
  struct oplist *op___1 ;
  struct opmeta *tmp___65 ;
  int tmp___66 ;
  struct opmetalist *l___4 ;
  struct opmeta *o___2 ;
  int i___6 ;
  struct oplist *op___2 ;
  struct opmeta *tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  char *tmp___70 ;
  int i___7 ;
  char tmp___71[20] ;
  char *tmp___72 ;
  int tmp___73 ;
  char *tmp___74 ;
  int tmp___75 ;
  rlim_t tmp___76 ;
  int tmp___77 ;

  {
#line 1600
  yytoken = 0;
#line 1616
  yylen = 0;
#line 1618
  yyss = yyssa;
#line 1618
  yyssp = yyss;
#line 1619
  yyvs = yyvsa;
#line 1619
  yyvsp = yyvs;
#line 1620
  yystacksize = 200UL;
#line 1624
  yystate = 0;
#line 1625
  yyerrstatus = 0;
#line 1626
  yynerrs = 0;
#line 1627
  yychar = -2;
#line 1628
  goto yysetstate;
  yynewstate: 
#line 1636
  yyssp ++;
  yysetstate: 
#line 1639
  *yyssp = (yytype_int16 )yystate;
#line 1641
  if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1644
    yysize = (unsigned long )((yyssp - yyss) + 1L);
#line 1671
    if (10000UL <= yystacksize) {
#line 1672
      goto yyexhaustedlab;
    }
#line 1673
    yystacksize *= 2UL;
#line 1674
    if (10000UL < yystacksize) {
#line 1675
      yystacksize = 10000UL;
    }
    {
#line 1678
    yyss1 = yyss;
#line 1679
    tmp = malloc(yystacksize * (sizeof(yytype_int16 ) + sizeof(YYSTYPE )) + (sizeof(union yyalloc ) - 1UL));
#line 1679
    yyptr = (union yyalloc *)tmp;
    }
#line 1681
    if (! yyptr) {
#line 1682
      goto yyexhaustedlab;
    }
    {
#line 1683
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1683
      __builtin_memcpy((void *)(& yyptr->yyss_alloc), (void const   *)yyss, yysize * sizeof(*yyss));
#line 1683
      yyss = & yyptr->yyss_alloc;
#line 1683
      yynewbytes = yystacksize * sizeof(*yyss) + (sizeof(union yyalloc ) - 1UL);
#line 1683
      yyptr += yynewbytes / sizeof(*yyptr);
      }
#line 1683
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1684
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 1684
      __builtin_memcpy((void *)(& yyptr->yyvs_alloc), (void const   *)yyvs, yysize * sizeof(*yyvs));
#line 1684
      yyvs = & yyptr->yyvs_alloc;
#line 1684
      yynewbytes___0 = yystacksize * sizeof(*yyvs) + (sizeof(union yyalloc ) - 1UL);
#line 1684
      yyptr += yynewbytes___0 / sizeof(*yyptr);
      }
#line 1684
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1686
    if ((unsigned long )yyss1 != (unsigned long )(yyssa)) {
      {
#line 1687
      free((void *)yyss1);
      }
    }
#line 1692
    yyssp = (yyss + yysize) - 1;
#line 1693
    yyvsp = (yyvs + yysize) - 1;
#line 1698
    if ((unsigned long )((yyss + yystacksize) - 1) <= (unsigned long )yyssp) {
#line 1699
      goto yyabortlab;
    }
  }
#line 1704
  if (yystate == 15) {
#line 1705
    goto yyacceptlab;
  }
#line 1707
  goto yybackup;
  yybackup: 
#line 1718
  yyn = (int )yypact[yystate];
#line 1719
  if (! (! (yyn == -59))) {
#line 1720
    goto yydefault;
  }
#line 1725
  if (yychar == -2) {
    {
#line 1728
    yychar = yylex();
    }
  }
#line 1731
  if (yychar <= 0) {
#line 1733
    yytoken = 0;
#line 1733
    yychar = yytoken;
  } else
#line 1738
  if ((unsigned int )yychar <= 319U) {
#line 1738
    yytoken = (int )yytranslate[yychar];
  } else {
#line 1738
    yytoken = 2;
  }
#line 1744
  yyn += yytoken;
#line 1745
  if (yyn < 0) {
#line 1746
    goto yydefault;
  } else
#line 1745
  if (361 < yyn) {
#line 1746
    goto yydefault;
  } else
#line 1745
  if ((int const   )yycheck[yyn] != (int const   )yytoken) {
#line 1746
    goto yydefault;
  }
#line 1747
  yyn = (int )yytable[yyn];
#line 1748
  if (yyn <= 0) {
#line 1752
    yyn = - yyn;
#line 1753
    goto yyreduce;
  }
#line 1758
  if (yyerrstatus) {
#line 1759
    yyerrstatus --;
  }
#line 1765
  yychar = -2;
#line 1767
  yystate = yyn;
#line 1769
  yyvsp ++;
#line 1769
  *yyvsp = yylval;
#line 1772
  goto yynewstate;
  yydefault: 
#line 1779
  yyn = (int )yydefact[yystate];
#line 1780
  if (yyn == 0) {
#line 1781
    goto yyerrlab;
  }
#line 1782
  goto yyreduce;
  yyreduce: 
#line 1790
  yylen = (int )yyr2[yyn];
#line 1800
  yyval = *(yyvsp + (1 - yylen));
  {
#line 1806
  if (yyn == 8) {
#line 1806
    goto case_8;
  }
#line 161
  if (yyn == 9) {
#line 161 "grammar.y"
    goto case_9;
  }
#line 163
  if (yyn == 10) {
#line 163
    goto case_10;
  }
#line 165
  if (yyn == 11) {
#line 165
    goto case_11;
  }
#line 180
  if (yyn == 12) {
#line 180
    goto case_12;
  }
#line 206
  if (yyn == 16) {
#line 206
    goto case_16;
  }
#line 224
  if (yyn == 17) {
#line 224
    goto case_17;
  }
#line 232
  if (yyn == 18) {
#line 232
    goto case_18;
  }
#line 240
  if (yyn == 19) {
#line 240
    goto case_19;
  }
#line 249
  if (yyn == 20) {
#line 249
    goto case_20;
  }
#line 267
  if (yyn == 21) {
#line 267
    goto case_21;
  }
#line 396
  if (yyn == 22) {
#line 396
    goto case_22;
  }
#line 402
  if (yyn == 23) {
#line 402
    goto case_23;
  }
#line 406
  if (yyn == 24) {
#line 406
    goto case_24;
  }
#line 417
  if (yyn == 25) {
#line 417
    goto case_25;
  }
#line 425
  if (yyn == 26) {
#line 425
    goto case_26;
  }
#line 433
  if (yyn == 27) {
#line 433
    goto case_27;
  }
#line 437
  if (yyn == 28) {
#line 437
    goto case_28;
  }
#line 443
  if (yyn == 29) {
#line 443
    goto case_29;
  }
#line 454
  if (yyn == 30) {
#line 454
    goto case_30;
  }
#line 462
  if (yyn == 31) {
#line 462
    goto case_31;
  }
#line 470
  if (yyn == 32) {
#line 470
    goto case_32;
  }
#line 493
  if (yyn == 33) {
#line 493
    goto case_33;
  }
#line 514
  if (yyn == 34) {
#line 514
    goto case_34;
  }
#line 521
  if (yyn == 35) {
#line 521
    goto case_35;
  }
#line 529
  if (yyn == 36) {
#line 529
    goto case_36;
  }
#line 535
  if (yyn == 37) {
#line 535
    goto case_37;
  }
#line 539
  if (yyn == 38) {
#line 539
    goto case_38;
  }
#line 543
  if (yyn == 39) {
#line 543
    goto case_39;
  }
#line 551
  if (yyn == 40) {
#line 551
    goto case_40;
  }
#line 563
  if (yyn == 41) {
#line 563
    goto case_41;
  }
#line 583
  if (yyn == 42) {
#line 583
    goto case_42;
  }
#line 597
  if (yyn == 43) {
#line 597
    goto case_43;
  }
#line 611
  if (yyn == 44) {
#line 611
    goto case_44;
  }
#line 615
  if (yyn == 45) {
#line 615
    goto case_45;
  }
#line 630
  if (yyn == 46) {
#line 630
    goto case_46;
  }
#line 645
  if (yyn == 47) {
#line 645
    goto case_47;
  }
#line 662
  if (yyn == 48) {
#line 662
    goto case_48;
  }
#line 679
  if (yyn == 49) {
#line 679
    goto case_49;
  }
#line 698
  if (yyn == 50) {
#line 698
    goto case_50;
  }
#line 702
  if (yyn == 51) {
#line 702
    goto case_51;
  }
#line 706
  if (yyn == 52) {
#line 706
    goto case_52;
  }
#line 710
  if (yyn == 53) {
#line 710
    goto case_53;
  }
#line 720
  if (yyn == 54) {
#line 720
    goto case_54;
  }
#line 727
  if (yyn == 55) {
#line 727
    goto case_55;
  }
#line 731
  if (yyn == 58) {
#line 731
    goto case_58;
  }
#line 742
  if (yyn == 59) {
#line 742
    goto case_59;
  }
#line 746
  if (yyn == 60) {
#line 746
    goto case_60;
  }
#line 750
  if (yyn == 61) {
#line 750
    goto case_61;
  }
#line 754
  if (yyn == 62) {
#line 754
    goto case_62;
  }
#line 758
  if (yyn == 63) {
#line 758
    goto case_63;
  }
#line 762
  if (yyn == 64) {
#line 762
    goto case_64;
  }
#line 769
  if (yyn == 65) {
#line 769
    goto case_65;
  }
#line 775
  if (yyn == 66) {
#line 775
    goto case_66;
  }
#line 780
  if (yyn == 69) {
#line 780
    goto case_69;
  }
#line 794
  if (yyn == 72) {
#line 794
    goto case_72;
  }
#line 805
  if (yyn == 73) {
#line 805
    goto case_73;
  }
#line 810
  if (yyn == 76) {
#line 810
    goto case_76;
  }
#line 820
  if (yyn == 77) {
#line 820
    goto case_77;
  }
#line 828
  if (yyn == 80) {
#line 828
    goto case_80;
  }
#line 838
  if (yyn == 81) {
#line 838
    goto case_81;
  }
#line 842
  if (yyn == 84) {
#line 842
    goto case_84;
  }
#line 852
  if (yyn == 87) {
#line 852
    goto case_87;
  }
#line 862
  if (yyn == 88) {
#line 862
    goto case_88;
  }
#line 870
  if (yyn == 89) {
#line 870
    goto case_89;
  }
#line 876
  if (yyn == 90) {
#line 876
    goto case_90;
  }
#line 885
  if (yyn == 91) {
#line 885
    goto case_91;
  }
#line 889
  if (yyn == 92) {
#line 889
    goto case_92;
  }
#line 891
  if (yyn == 93) {
#line 891
    goto case_93;
  }
#line 901
  if (yyn == 94) {
#line 901
    goto case_94;
  }
#line 910
  if (yyn == 95) {
#line 910
    goto case_95;
  }
#line 919
  if (yyn == 96) {
#line 919
    goto case_96;
  }
#line 928
  if (yyn == 97) {
#line 928
    goto case_97;
  }
#line 937
  if (yyn == 98) {
#line 937
    goto case_98;
  }
#line 946
  if (yyn == 99) {
#line 946
    goto case_99;
  }
#line 955
  if (yyn == 100) {
#line 955
    goto case_100;
  }
#line 964
  if (yyn == 101) {
#line 964
    goto case_101;
  }
#line 973
  if (yyn == 102) {
#line 973
    goto case_102;
  }
#line 980
  if (yyn == 103) {
#line 980
    goto case_103;
  }
#line 986
  if (yyn == 104) {
#line 986
    goto case_104;
  }
#line 993
  if (yyn == 105) {
#line 993
    goto case_105;
  }
#line 999
  if (yyn == 106) {
#line 999
    goto case_106;
  }
#line 1007
  if (yyn == 107) {
#line 1007
    goto case_107;
  }
#line 1013
  if (yyn == 108) {
#line 1013
    goto case_108;
  }
#line 1019
  if (yyn == 109) {
#line 1019
    goto case_109;
  }
#line 1028
  if (yyn == 110) {
#line 1028
    goto case_110;
  }
#line 1034
  if (yyn == 111) {
#line 1034
    goto case_111;
  }
#line 1038
  if (yyn == 112) {
#line 1038
    goto case_112;
  }
#line 1044
  if (yyn == 113) {
#line 1044
    goto case_113;
  }
#line 2966 "grammar.c"
  goto switch_default;
  case_8: /* CIL Label */ 
  {
#line 158 "grammar.y"
  add_directory((yyvsp + -1)->cp, (char *)((void *)0), (char *)((void *)0));
  }
#line 159
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 160
  add_directory((yyvsp + -2)->cp, (yyvsp + -1)->cp, (char *)((void *)0));
  }
#line 161
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 162
  add_directory((yyvsp + -3)->cp, (yyvsp + -2)->cp, (yyvsp + -1)->cp);
  }
#line 163
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 167
  tmp___0 = logdata_get((yyvsp + -3)->cp);
  }
#line 167
  if (tmp___0) {
    {
#line 168
    rl_pwarn((char const   *)curfile_name, curfile_line, "duplicate declaration of log %s, ignoring",
             (yyvsp + -3)->cp);
#line 169
    free((void *)(yyvsp + -3)->cp);
    }
  } else {
    {
#line 171
    logcur->name = (yyvsp + -3)->cp;
#line 172
    logcur->next = logdatas;
#line 173
    logdatas = logcur;
#line 174
    logcur = logdata_new();
    }
  }
  {
#line 176
  clearuserdata(& userdata);
  }
#line 178
  goto switch_break;
  case_12: /* CIL Label */ 
#line 182
  if (! logcur->path) {
    {
#line 183
    tmp___1 = gettext("No path defined for log %s");
#line 183
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___1,
             logcur->name);
    }
  } else {
    {
#line 185
    tmp___13 = open((char const   *)logcur->path, 1089, logcur->mode);
#line 185
    logcur->index = tmp___13;
    }
#line 185
    if (tmp___13 < 0) {
      {
#line 186
      tmp___2 = __errno_location();
#line 186
      tmp___3 = strerror(*tmp___2);
#line 186
      tmp___4 = gettext("open(\"%s\", O_CREAT|O_APPEND|O_WRONLY, 0%o) failed (%s)");
#line 186
      rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___4,
               logcur->path, logcur->mode, tmp___3);
      }
    } else {
      {
#line 190
      tmp___8 = fchmod(logcur->index, logcur->mode);
      }
#line 190
      if (tmp___8) {
        {
#line 191
        tmp___5 = __errno_location();
#line 191
        tmp___6 = strerror(*tmp___5);
#line 191
        tmp___7 = gettext("fchmod(\"%s\", 0%o) failed (%s)");
#line 191
        rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___7,
                 logcur->path, logcur->mode, tmp___6);
        }
      }
      {
#line 196
      tmp___12 = fchown(logcur->index, logcur->uid, logcur->gid);
      }
#line 196
      if (tmp___12) {
        {
#line 197
        tmp___9 = __errno_location();
#line 197
        tmp___10 = strerror(*tmp___9);
#line 197
        tmp___11 = gettext("fchown(\"%s\", %d, %d) failed for log %s (%s)");
#line 197
        rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___11,
                 logcur->path, logcur->uid, logcur->gid, logcur->name, tmp___10);
        }
      }
    }
  }
#line 204
  goto switch_break;
  case_16: /* CIL Label */ 
#line 213
  if (logcur->path) {
    {
#line 214
    tmp___14 = gettext("duplicate path declaration (%s) in log directive %s, ignoring");
#line 214
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___14,
             (yyvsp + -1)->cp, logcur->name);
#line 217
    free((void *)(yyvsp + -1)->cp);
    }
  } else {
#line 219
    logcur->path = (yyvsp + -1)->cp;
  }
#line 222
  goto switch_break;
  case_17: /* CIL Label */ 
#line 224
  if ((yyvsp + -1)->uid) {
#line 225
    logcur->uid = ((yyvsp + -1)->uid)->pw_uid;
  } else {
    {
#line 227
    rl_pwarn((char const   *)curfile_name, curfile_line, "unknown username");
    }
  }
#line 230
  goto switch_break;
  case_18: /* CIL Label */ 
#line 232
  if ((yyvsp + -1)->gid) {
#line 233
    logcur->gid = ((yyvsp + -1)->gid)->gr_gid;
  } else {
    {
#line 235
    rl_pwarn((char const   *)curfile_name, curfile_line, "unknown groupname");
    }
  }
#line 238
  goto switch_break;
  case_19: /* CIL Label */ 
#line 240
  if ((yyvsp + -1)->num > 4095L) {
    {
#line 241
    tmp___15 = gettext("invalid mode declaration in log directive %s, ignoring");
#line 241
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___15,
             logcur->name);
    }
  } else {
#line 244
    logcur->mode = (mode_t )(yyvsp + -1)->num;
  }
#line 247
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 252
  saved_defaults = defaults;
#line 253
  defaults = current_service;
#line 254
  current_service = saved_defaults;
#line 257
  service_free(current_service);
#line 258
  service_copy(current_service, defaults);
#line 261
  opmetalist_free(opml_defaults);
#line 262
  free((void *)opml_defaults);
#line 263
  opml_defaults = (yyvsp + -1)->opml;
  }
#line 265
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 276
  parent = opmetalist_new();
#line 277
  onexit = opmetalist_new();
#line 279
  current_service->name = (yyvsp + -3)->cp;
#line 280
  tmp___16 = stringtab_add((yyvsp + -3)->cp);
#line 280
  current_service->opfixups[1] = (rl_opcode_t )tmp___16;
  }
  {
#line 282
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 284
    if (current_service->disabled) {
#line 285
      goto while_break___1;
    }
#line 287
    if (current_service->socktype == 1) {
#line 287
      if (! current_service->wait) {
        {
#line 288
        tmp___18 = opmeta_make(2, (rl_opcode_t )9, 200);
#line 288
        tmp___19 = opmetalist_add((yyvsp + -1)->opml, tmp___18);
        }
#line 288
        if (tmp___19) {
          {
#line 289
          tmp___17 = gettext("opcode resolving problem");
#line 289
          rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___17);
#line 290
          (current_service->disabled) ++;
          }
#line 291
          goto while_break___1;
        }
        {
#line 293
        tmp___20 = opmeta_make(1, (rl_opcode_t )15);
#line 293
        opmetalist_add(parent, tmp___20);
        }
#line 295
        if (current_service->internal) {
          {
#line 296
          tmp___21 = opmeta_make(1, (rl_opcode_t )15);
#line 296
          opmetalist_add(onexit, tmp___21);
          }
        } else {
          {
#line 298
          tmp___22 = opmeta_make(1, (rl_opcode_t )18);
#line 298
          opmetalist_add(onexit, tmp___22);
          }
        }
      } else {
        {
#line 301
        tmp___23 = opmeta_make(1, (rl_opcode_t )18);
#line 301
        opmetalist_add(parent, tmp___23);
#line 302
        tmp___24 = opmeta_make(1, (rl_opcode_t )18);
#line 302
        opmetalist_add(onexit, tmp___24);
        }
      }
    } else {
      {
#line 301
      tmp___23 = opmeta_make(1, (rl_opcode_t )18);
#line 301
      opmetalist_add(parent, tmp___23);
#line 302
      tmp___24 = opmeta_make(1, (rl_opcode_t )18);
#line 302
      opmetalist_add(onexit, tmp___24);
      }
    }
    {
#line 304
    validate_service(current_service);
    }
#line 307
    if (current_service->disabled) {
#line 308
      goto while_break___1;
    }
    {
#line 310
    tmp___25 = add_user_group((struct service  const  *)current_service, (yyvsp + -1)->opml);
    }
#line 310
    if (! tmp___25) {
#line 312
      (current_service->disabled) ++;
#line 313
      goto while_break___1;
    }
    {
#line 317
    fds = bind_ports();
    }
#line 320
    if (current_service->limit) {
      {
#line 325
      o = opmetalist_new();
#line 326
      tmp___26 = opmeta_make(2, (rl_opcode_t )25, fds);
#line 326
      opmetalist_add(o, tmp___26);
#line 327
      tmp___27 = opmeta_make(1, (rl_opcode_t )18);
#line 327
      opmetalist_add(o, tmp___27);
#line 328
      l = opmetalist_resolve(o, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 329
      match = oplisttab_add(l);
#line 330
      opmetalist_free(o);
#line 331
      free((void *)o);
#line 332
      oplist_free(l);
#line 333
      free((void *)l);
#line 335
      o = opmetalist_new();
#line 336
      tmp___28 = opmeta_make(2, (rl_opcode_t )24, fds);
#line 336
      opmetalist_add(o, tmp___28);
#line 337
      tmp___29 = opmeta_make(1, (rl_opcode_t )18);
#line 337
      opmetalist_add(o, tmp___29);
#line 338
      l = opmetalist_resolve(o, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 339
      under = oplisttab_add(l);
#line 340
      opmetalist_free(o);
#line 341
      free((void *)o);
#line 342
      oplist_free(l);
#line 343
      free((void *)l);
#line 345
      i = semaphore_add(current_service->limit, (rl_opcode_t )match, (rl_opcode_t )under);
#line 346
      tmp___30 = opmeta_make(2, (rl_opcode_t )22, i);
#line 346
      opmetalist_add((yyvsp + -1)->opml, tmp___30);
#line 347
      tmp___31 = opmeta_make(2, (rl_opcode_t )21, i);
#line 347
      opmetalist_add(onexit, tmp___31);
      }
    }
    {
#line 349
    ops = opmetalist_resolve(onexit, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 350
    tmp___32 = oplisttab_add(ops);
#line 350
    current_service->opfixups[8] = (rl_opcode_t )tmp___32;
#line 351
    opmetalist_free(onexit);
#line 352
    free((void *)onexit);
#line 353
    oplist_free(ops);
#line 354
    free((void *)ops);
#line 356
    ops = opmetalist_resolve(parent, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 357
    tmp___33 = oplisttab_add(ops);
#line 357
    current_service->opfixups[3] = (rl_opcode_t )tmp___33;
#line 358
    opmetalist_free(parent);
#line 359
    free((void *)parent);
#line 360
    oplist_free(ops);
#line 361
    free((void *)ops);
#line 363
    opmetalist_merge((yyvsp + -1)->opml, (struct opmetalist  const  *)opml_defaults);
#line 365
    tmp___34 = opmeta_make(2, (rl_opcode_t )34, current_service->opfixups[8]);
#line 365
    opmetalist_add((yyvsp + -1)->opml, tmp___34);
#line 366
    ops = opmetalist_resolve((yyvsp + -1)->opml, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 368
    tmp___35 = oplisttab_add(ops);
#line 368
    current_service->run = (rl_opcode_t )tmp___35;
#line 369
    opmetalist_free((yyvsp + -1)->opml);
#line 370
    free((void *)(yyvsp + -1)->opml);
#line 371
    oplist_free(ops);
#line 372
    free((void *)ops);
#line 374
    fdst = fdsettab_get(fds);
#line 375
    i = 0;
    }
    {
#line 375
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 375
      if (! (i < 1024)) {
#line 375
        goto while_break___2;
      }
#line 376
      if ((fdst->__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 377
        tmp___36 = oplisttab_get((int )current_service->run);
#line 377
        read_hook(i, tmp___36, (struct rl_instance *)((void *)0));
        }
      }
#line 375
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 282
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 381
  if (current_service->disabled) {
    {
#line 382
    tmp___37 = gettext("service %s DISABLED");
#line 382
    rl_warn((char const   *)tmp___37, current_service->name);
    }
  } else {
    {
#line 384
    tmp___38 = gettext("service %s enabled");
#line 384
    rl_note((char const   *)tmp___38, current_service->name);
    }
#line 385
    if (rl_debug > 1) {
      {
#line 386
      tmp___39 = gettext("+-> uid=%d, sgid=%d, supgid=%d fl=%d");
#line 386
      rl_note((char const   *)tmp___39, current_service->opfixups[5], current_service->opfixups[7],
              current_service->opfixups[6], current_service->sflags);
      }
    }
  }
  {
#line 391
  service_free(current_service);
#line 392
  service_copy(current_service, defaults);
  }
#line 394
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 398
  yyval.opml = opmetalist_new();
  }
#line 400
  goto switch_break;
  case_23: /* CIL Label */ 
#line 402
  yyval.opml = (yyvsp + -1)->opml;
#line 404
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 408
  l___0 = opmetalist_new();
#line 409
  tmp___41 = opmetalist_add(l___0, (yyvsp + 0)->opm);
  }
#line 409
  if (tmp___41) {
    {
#line 410
    tmp___40 = gettext("opcode resolving problem");
#line 410
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___40);
#line 411
    (current_service->disabled) ++;
    }
  }
#line 413
  yyval.opml = l___0;
#line 415
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 417
  tmp___43 = opmetalist_add((yyvsp + -1)->opml, (yyvsp + 0)->opm);
  }
#line 417
  if (tmp___43) {
    {
#line 418
    tmp___42 = gettext("opcode resolving problem");
#line 418
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___42);
#line 419
    (current_service->disabled) ++;
    }
  }
#line 421
  yyval.opml = (yyvsp + -1)->opml;
#line 423
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 425
  yyval.opml = opmetalist_join((yyvsp + -1)->opml, (yyvsp + 0)->opml);
  }
#line 426
  if (! yyval.opml) {
    {
#line 427
    tmp___44 = gettext("opcode resolving problem");
#line 427
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___44);
#line 428
    (current_service->disabled) ++;
    }
  }
#line 431
  goto switch_break;
  case_27: /* CIL Label */ 
#line 433
  yyval.opml = (yyvsp + 0)->opml;
#line 435
  goto switch_break;
  case_28: /* CIL Label */ 
#line 439
  yyval.opml = (yyvsp + 0)->opml;
#line 441
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 445
  l___1 = opmetalist_new();
#line 446
  tmp___46 = opmetalist_add(l___1, (yyvsp + 0)->opm);
  }
#line 446
  if (tmp___46) {
    {
#line 447
    tmp___45 = gettext("opcode resolving problem");
#line 447
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___45);
#line 448
    (current_service->disabled) ++;
    }
  }
#line 450
  yyval.opml = l___1;
#line 452
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 454
  tmp___48 = opmetalist_add((yyvsp + -1)->opml, (yyvsp + 0)->opm);
  }
#line 454
  if (tmp___48) {
    {
#line 455
    tmp___47 = gettext("opcode resolving problem");
#line 455
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___47);
#line 456
    (current_service->disabled) ++;
    }
  }
#line 458
  yyval.opml = (yyvsp + -1)->opml;
#line 460
  goto switch_break;
  case_31: /* CIL Label */ 
  {
#line 462
  yyval.opml = opmetalist_join((yyvsp + -1)->opml, (yyvsp + 0)->opml);
  }
#line 463
  if (! yyval.opml) {
    {
#line 464
    tmp___49 = gettext("opcode resolving problem");
#line 464
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___49);
#line 465
    (current_service->disabled) ++;
    }
  }
#line 468
  goto switch_break;
  case_32: /* CIL Label */ 
  {
#line 475
  l___2 = opmetalist_new();
#line 476
  tmp___50 = argvtab_add((yyvsp + -1)->cp, 1);
#line 476
  o___0 = opmeta_make(3, (rl_opcode_t )1, 666, tmp___50);
#line 477
  opmeta_fixup(o___0, 1, (opmeta_fixup_ptr )2);
#line 478
  tmp___52 = opmetalist_add(l___2, o___0);
  }
#line 478
  if (tmp___52) {
    {
#line 479
    tmp___51 = gettext("opcode resolving problem");
#line 479
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___51);
#line 480
    (current_service->disabled) ++;
    }
  }
  {
#line 482
  o___0 = opmeta_make(3, (rl_opcode_t )10, 666, 666);
#line 483
  opmeta_fixup(o___0, 1, (opmeta_fixup_ptr )3);
#line 484
  opmeta_fixup(o___0, 2, (opmeta_fixup_ptr )8);
#line 485
  tmp___54 = opmetalist_add(l___2, o___0);
  }
#line 485
  if (tmp___54) {
    {
#line 486
    tmp___53 = gettext("opcode resolving problem");
#line 486
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___53);
#line 487
    (current_service->disabled) ++;
    }
  }
#line 489
  yyval.opml = l___2;
#line 491
  goto switch_break;
  case_33: /* CIL Label */ 
#line 493
  if ((yyvsp + -1)->uid) {
    {
#line 495
    tmp___55 = stringtab_add(((yyvsp + -1)->uid)->pw_name);
#line 495
    current_service->opfixups[4] = (rl_opcode_t )tmp___55;
#line 496
    current_service->opfixups[5] = ((yyvsp + -1)->uid)->pw_uid;
#line 497
    current_service->opfixups[6] = ((yyvsp + -1)->uid)->pw_gid;
#line 499
    current_service->sflags |= 1;
    }
#line 501
    if (! ((current_service->sflags & 2) == 2)) {
#line 502
      current_service->opfixups[7] = ((yyvsp + -1)->uid)->pw_gid;
    }
#line 505
    yyval.opml = (struct opmetalist *)((void *)0);
  } else {
    {
#line 507
    rl_pwarn((char const   *)curfile_name, curfile_line, "unknown username");
#line 508
    (current_service->disabled) ++;
#line 509
    yyval.opml = (struct opmetalist *)((void *)0);
    }
  }
#line 512
  goto switch_break;
  case_34: /* CIL Label */ 
#line 514
  current_service->sflags |= 4;
#line 516
  yyval.opml = (struct opmetalist *)((void *)0);
#line 519
  goto switch_break;
  case_35: /* CIL Label */ 
#line 521
  if ((yyvsp + -1)->num) {
#line 522
    current_service->sflags |= 4;
  } else {
#line 524
    current_service->sflags &= -5;
  }
#line 525
  yyval.opml = (struct opmetalist *)((void *)0);
#line 527
  goto switch_break;
  case_36: /* CIL Label */ 
  {
#line 531
  yyval.opm = opmeta_make(2, (rl_opcode_t )5, (yyvsp + -1)->num);
  }
#line 533
  goto switch_break;
  case_37: /* CIL Label */ 
  {
#line 535
  yyval.opm = opmeta_make(1, (rl_opcode_t )2);
  }
#line 537
  goto switch_break;
  case_38: /* CIL Label */ 
  {
#line 539
  yyval.opm = opmeta_make(3, (rl_opcode_t )6, (yyvsp + -1)->num, (yyvsp + 0)->num);
  }
#line 541
  goto switch_break;
  case_39: /* CIL Label */ 
  {
#line 545
  i___0 = logtab_add(-1, (yyvsp + -1)->cp);
#line 546
  yyval.opm = opmeta_make(2, (rl_opcode_t )7, i___0);
#line 547
  free((void *)(yyvsp + -1)->cp);
  }
#line 549
  goto switch_break;
  case_40: /* CIL Label */ 
  {
#line 553
  ret = buftab_addfile((yyvsp + -1)->cp);
  }
#line 554
  if (ret == -1) {
#line 555
    (current_service->disabled) ++;
  }
  {
#line 556
  yyval.opm = opmeta_make(16, (rl_opcode_t )17, 40, ret, 31, 0, 32, 38, 16, 38, 35,
                          3, 36, 31, -9, 39, 41);
#line 559
  free((void *)(yyvsp + -1)->cp);
  }
#line 561
  goto switch_break;
  case_41: /* CIL Label */ 
#line 565
  if ((yyvsp + -1)->cp) {
    {
#line 566
    i___1 = buftab_addfile((yyvsp + -1)->cp);
    }
#line 567
    if (i___1 < 0) {
#line 568
      (current_service->disabled) ++;
    }
  } else {
    {
#line 570
    i___1 = chargen_buffer();
    }
  }
  {
#line 572
  yyval.opm = opmeta_make(25, (rl_opcode_t )17, 38, 40, i___1, 39, 39, 17, 31, 0,
                          32, 38, 16, 38, 33, -11, 38, 35, 3, 36, 31, -12, 39, 41,
                          34, 666);
#line 576
  opmeta_fixup(yyval.opm, 24, (opmeta_fixup_ptr )8);
#line 577
  current_service->internal = 1;
  }
#line 578
  if ((yyvsp + -1)->cp) {
    {
#line 579
    free((void *)(yyvsp + -1)->cp);
    }
  }
#line 581
  goto switch_break;
  case_42: /* CIL Label */ 
  {
#line 583
  tmp___56 = logdata_get((yyvsp + -2)->cp);
#line 583
  ld = tmp___56;
  }
#line 585
  if (! ld) {
    {
#line 586
    tmp___57 = gettext("unknown log %s");
#line 586
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___57,
             (yyvsp + -2)->cp);
#line 587
    (current_service->disabled) ++;
    }
  } else {
    {
#line 589
    tmp___58 = logtab_add(ld->index, (yyvsp + -1)->cp);
#line 589
    i___2 = tmp___58;
#line 590
    yyval.opm = opmeta_make(2, (rl_opcode_t )7, i___2);
    }
  }
  {
#line 592
  free((void *)(yyvsp + -2)->cp);
#line 593
  free((void *)(yyvsp + -1)->cp);
  }
#line 595
  goto switch_break;
  case_43: /* CIL Label */ 
#line 597
  if (! (yyvsp + -1)->gid) {
    {
#line 598
    tmp___59 = gettext("unknown group");
#line 598
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___59);
#line 599
    (current_service->disabled) ++;
#line 600
    yyval.opm = (struct opmeta *)((void *)0);
    }
  } else {
#line 603
    current_service->opfixups[7] = ((yyvsp + -1)->gid)->gr_gid;
#line 604
    current_service->sflags |= 2;
#line 606
    yyval.opm = (struct opmeta *)((void *)0);
  }
#line 609
  goto switch_break;
  case_44: /* CIL Label */ 
  {
#line 611
  tmp___60 = argvtab_add((yyvsp + -1)->cp, 1);
#line 611
  yyval.opm = opmeta_make(2, (rl_opcode_t )8, tmp___60);
  }
#line 613
  goto switch_break;
  case_45: /* CIL Label */ 
  {
#line 625
  tmp___61 = gettext("ABORT - support for capabilities not compiled in");
#line 625
  rl_pfatal(65, (char const   *)curfile_name, curfile_line, (char const   *)tmp___61);
  }
#line 628
  goto switch_break;
  case_46: /* CIL Label */ 
  {
#line 633
  tmp___62 = opmeta_make(1, (rl_opcode_t )18);
#line 633
  opmetalist_add((yyvsp + -1)->opml, tmp___62);
#line 634
  op = opmetalist_resolve((yyvsp + -1)->opml, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 635
  i___3 = oplisttab_add(op);
#line 636
  tmp___63 = stringtab_add((yyvsp + -3)->cp);
#line 636
  yyval.opm = opmeta_make(3, (rl_opcode_t )11, tmp___63, i___3);
#line 637
  free((void *)(yyvsp + -3)->cp);
#line 638
  oplist_free(op);
#line 639
  free((void *)op);
#line 640
  opmetalist_free((yyvsp + -1)->opml);
#line 641
  free((void *)(yyvsp + -1)->opml);
  }
#line 643
  goto switch_break;
  case_47: /* CIL Label */ 
  {
#line 649
  tmp___64 = opmeta_make(1, (rl_opcode_t )18);
#line 649
  opmetalist_add((yyvsp + -1)->opml, tmp___64);
#line 650
  op___0 = opmetalist_resolve((yyvsp + -1)->opml, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 651
  i___4 = oplisttab_add(op___0);
#line 652
  o___1 = opmeta_make(3, (rl_opcode_t )11, 666, i___4);
#line 653
  opmeta_fixup(o___1, 1, (opmeta_fixup_ptr )1);
#line 654
  yyval.opm = o___1;
#line 655
  oplist_free(op___0);
#line 656
  free((void *)op___0);
#line 657
  opmetalist_free((yyvsp + -1)->opml);
#line 658
  free((void *)(yyvsp + -1)->opml);
  }
#line 660
  goto switch_break;
  case_48: /* CIL Label */ 
  {
#line 666
  l___3 = opmetalist_new();
#line 667
  tmp___65 = opmeta_make(1, (rl_opcode_t )19);
#line 667
  opmetalist_add(l___3, tmp___65);
#line 668
  op___1 = opmetalist_resolve(l___3, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 669
  i___5 = oplisttab_add(op___1);
#line 670
  tmp___66 = stringtab_add((yyvsp + -1)->cp);
#line 670
  yyval.opm = opmeta_make(3, (rl_opcode_t )11, tmp___66, i___5);
#line 671
  free((void *)(yyvsp + -1)->cp);
#line 672
  oplist_free(op___1);
#line 673
  free((void *)op___1);
#line 674
  opmetalist_free(l___3);
#line 675
  free((void *)l___3);
  }
#line 677
  goto switch_break;
  case_49: /* CIL Label */ 
  {
#line 684
  l___4 = opmetalist_new();
#line 685
  tmp___67 = opmeta_make(1, (rl_opcode_t )19);
#line 685
  opmetalist_add(l___4, tmp___67);
#line 686
  op___2 = opmetalist_resolve(l___4, (opmeta_fixup_ptr const   *)(current_service->opfixups));
#line 687
  i___6 = oplisttab_add(op___2);
#line 688
  o___2 = opmeta_make(3, (rl_opcode_t )11, 666, i___6);
#line 689
  opmeta_fixup(o___2, 1, (opmeta_fixup_ptr )1);
#line 690
  yyval.opm = o___2;
#line 691
  oplist_free(op___2);
#line 692
  free((void *)op___2);
#line 693
  opmetalist_free(l___4);
#line 694
  free((void *)l___4);
  }
#line 696
  goto switch_break;
  case_50: /* CIL Label */ 
  {
#line 698
  yyval.opm = opmeta_make(1, (rl_opcode_t )15);
  }
#line 700
  goto switch_break;
  case_51: /* CIL Label */ 
  {
#line 702
  yyval.opm = opmeta_make(1, (rl_opcode_t )19);
  }
#line 704
  goto switch_break;
  case_52: /* CIL Label */ 
  {
#line 706
  tmp___68 = argvtab_add((yyvsp + -1)->cp, 0);
#line 706
  yyval.opm = opmeta_make(2, (rl_opcode_t )20, tmp___68);
  }
#line 708
  goto switch_break;
  case_53: /* CIL Label */ 
  {
#line 710
  yyval.opm = opmeta_make(29, (rl_opcode_t )17, 26, 11, 29, 0, 27, 30, 38, 35, 17,
                          36, 31, 0, 28, 32, 38, 33, 6, 38, 35, 6, 37, 31, -11, 39,
                          29, -22, 34, 666);
#line 715
  opmeta_fixup(yyval.opm, 28, (opmeta_fixup_ptr )8);
#line 716
  current_service->internal = 1;
  }
#line 718
  goto switch_break;
  case_54: /* CIL Label */ 
  {
#line 720
  yyval.opm = opmeta_make(13, (rl_opcode_t )17, 29, 0, 30, 26, 1024, 27, 35, 2, 29,
                          -8, 34, 666);
#line 722
  opmeta_fixup(yyval.opm, 12, (opmeta_fixup_ptr )8);
#line 723
  current_service->internal = 1;
  }
#line 725
  goto switch_break;
  case_55: /* CIL Label */ 
#line 728
  yyval.cp = (char *)((void *)0);
#line 729
  goto switch_break;
  case_58: /* CIL Label */ 
#line 735
  if (current_service->port) {
    {
#line 736
    stringlist_free(current_service->port);
    }
  }
#line 737
  current_service->port = stringlist;
#line 738
  stringlist = (struct stringlist *)((void *)0);
#line 740
  goto switch_break;
  case_59: /* CIL Label */ 
#line 742
  current_service->socktype = (int )(yyvsp + -1)->num;
#line 744
  goto switch_break;
  case_60: /* CIL Label */ 
#line 746
  current_service->backlog = (int )(yyvsp + -1)->num;
#line 748
  goto switch_break;
  case_61: /* CIL Label */ 
#line 750
  current_service->limit = (int )(yyvsp + -1)->num;
#line 752
  goto switch_break;
  case_62: /* CIL Label */ 
#line 754
  current_service->wait = (int )(yyvsp + -1)->num;
#line 756
  goto switch_break;
  case_63: /* CIL Label */ 
#line 758
  current_service->disabled = ! (yyvsp + -1)->num;
#line 760
  goto switch_break;
  case_64: /* CIL Label */ 
#line 762
  if (current_service->interface) {
    {
#line 763
    stringlist_free(current_service->interface);
    }
  }
#line 764
  current_service->interface = stringlist;
#line 765
  stringlist = (struct stringlist *)((void *)0);
#line 767
  goto switch_break;
  case_65: /* CIL Label */ 
#line 769
  if (current_service->interface) {
    {
#line 770
    stringlist_free(current_service->interface);
    }
  }
#line 771
  current_service->interface = (struct stringlist *)((void *)0);
#line 773
  goto switch_break;
  case_66: /* CIL Label */ 
  {
#line 775
  tmp___69 = stringtab_add((yyvsp + -1)->cp);
#line 775
  current_service->opfixups[2] = (rl_opcode_t )tmp___69;
#line 776
  free((void *)(yyvsp + -1)->cp);
  }
#line 778
  goto switch_break;
  case_69: /* CIL Label */ 
  {
#line 789
  tmp___70 = gettext("ABORT - support for socket filter not compiled in");
#line 789
  rl_pfatal(65, (char const   *)curfile_name, curfile_line, (char const   *)tmp___70);
  }
#line 792
  goto switch_break;
  case_72: /* CIL Label */ 
#line 801
  current_service->rpcname = (yyvsp + -1)->cp;
#line 803
  goto switch_break;
  case_73: /* CIL Label */ 
#line 805
  current_service->rpcvers = numlist;
#line 806
  numlist = (struct numlist *)((void *)0);
#line 808
  goto switch_break;
  case_76: /* CIL Label */ 
  {
#line 816
  numlist_add(& numlist, (yyvsp + 0)->num);
  }
#line 818
  goto switch_break;
  case_77: /* CIL Label */ 
#line 822
  if ((yyvsp + 0)->num >= (yyvsp + -2)->num) {
#line 823
    i___7 = (int )(yyvsp + -2)->num;
    {
#line 823
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 823
      if (! ((long )i___7 <= (yyvsp + 0)->num)) {
#line 823
        goto while_break___3;
      }
      {
#line 824
      numlist_add(& numlist, (long )i___7);
#line 823
      i___7 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
  }
#line 826
  goto switch_break;
  case_80: /* CIL Label */ 
#line 834
  current_service->r.rlim_cur = (yyvsp + -1)->rl;
#line 836
  goto switch_break;
  case_81: /* CIL Label */ 
#line 838
  current_service->r.rlim_max = (yyvsp + -1)->rl;
#line 840
  goto switch_break;
  case_84: /* CIL Label */ 
  {
#line 848
  stringlist_add(& stringlist, (yyvsp + 0)->cp);
  }
#line 850
  goto switch_break;
  case_87: /* CIL Label */ 
  {
#line 858
  stringlist_add(& stringlist, (yyvsp + 0)->cp);
  }
#line 860
  goto switch_break;
  case_88: /* CIL Label */ 
  {
#line 864
  snprintf((char */* __restrict  */)(tmp___71), (size_t )19, (char const   */* __restrict  */)"%ld",
           (yyvsp + 0)->num);
#line 865
  tmp___71[19] = (char )'\000';
#line 866
  tmp___72 = strdup((char const   *)(tmp___71));
#line 866
  stringlist_add(& stringlist, tmp___72);
  }
#line 868
  goto switch_break;
  case_89: /* CIL Label */ 
  {
#line 872
  tmp___73 = rlimittab_add((yyvsp + -1)->rl, (yyvsp + -1)->rl);
#line 872
  yyval.num = (long )tmp___73;
  }
#line 874
  goto switch_break;
  case_90: /* CIL Label */ 
#line 876
  if (current_service->r.rlim_max != 0xffffffffffffffffUL) {
#line 876
    if (current_service->r.rlim_cur > current_service->r.rlim_max) {
      {
#line 878
      tmp___74 = gettext("invalid resource limit");
#line 878
      rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___74);
      }
    }
  }
  {
#line 880
  tmp___75 = rlimittab_add(current_service->r.rlim_cur, current_service->r.rlim_max);
#line 880
  yyval.num = (long )tmp___75;
#line 881
  tmp___76 = (__rlim_t )-1;
#line 881
  current_service->r.rlim_max = tmp___76;
#line 881
  current_service->r.rlim_cur = tmp___76;
  }
#line 883
  goto switch_break;
  case_91: /* CIL Label */ 
#line 886
  yyval.rl = (rlim_t )(yyvsp + 0)->num;
#line 887
  goto switch_break;
  case_92: /* CIL Label */ 
#line 888
  yyval.rl = (__rlim_t )-1;
#line 889
  goto switch_break;
  case_93: /* CIL Label */ 
#line 894
  yyval.num = 0L;
#line 899
  goto switch_break;
  case_94: /* CIL Label */ 
#line 903
  yyval.num = 1L;
#line 908
  goto switch_break;
  case_95: /* CIL Label */ 
#line 912
  yyval.num = 2L;
#line 917
  goto switch_break;
  case_96: /* CIL Label */ 
#line 921
  yyval.num = 3L;
#line 926
  goto switch_break;
  case_97: /* CIL Label */ 
#line 930
  yyval.num = 4L;
#line 935
  goto switch_break;
  case_98: /* CIL Label */ 
#line 939
  yyval.num = 5L;
#line 944
  goto switch_break;
  case_99: /* CIL Label */ 
#line 948
  yyval.num = 6L;
#line 953
  goto switch_break;
  case_100: /* CIL Label */ 
#line 957
  yyval.num = 7L;
#line 962
  goto switch_break;
  case_101: /* CIL Label */ 
#line 966
  yyval.num = 8L;
#line 971
  goto switch_break;
  case_102: /* CIL Label */ 
  {
#line 975
  yyval.uid = getpwuid((__uid_t )(yyvsp + 0)->num);
#line 976
  endpwent();
  }
#line 978
  goto switch_break;
  case_103: /* CIL Label */ 
  {
#line 980
  yyval.uid = getpwnam((char const   *)(yyvsp + 0)->cp);
#line 981
  free((void *)(yyvsp + 0)->cp);
#line 982
  endpwent();
  }
#line 984
  goto switch_break;
  case_104: /* CIL Label */ 
  {
#line 988
  yyval.gid = getgrgid((__gid_t )(yyvsp + 0)->num);
#line 989
  endgrent();
  }
#line 991
  goto switch_break;
  case_105: /* CIL Label */ 
  {
#line 993
  yyval.gid = getgrnam((char const   *)(yyvsp + 0)->cp);
#line 994
  free((void *)(yyvsp + 0)->cp);
#line 995
  endgrent();
  }
#line 997
  goto switch_break;
  case_106: /* CIL Label */ 
#line 1001
  yyval.num = 1L;
#line 1002
  current_service->protoname = "tcp";
#line 1003
  current_service->proto = 6;
#line 1005
  goto switch_break;
  case_107: /* CIL Label */ 
#line 1007
  yyval.num = 2L;
#line 1008
  current_service->protoname = "udp";
#line 1009
  current_service->proto = 17;
#line 1011
  goto switch_break;
  case_108: /* CIL Label */ 
#line 1015
  current_service->family = 2;
#line 1017
  goto switch_break;
  case_109: /* CIL Label */ 
#line 1020
  current_service->family = 10;
#line 1026
  goto switch_break;
  case_110: /* CIL Label */ 
#line 1030
  yyval.num = (yyvsp + 0)->num;
#line 1032
  goto switch_break;
  case_111: /* CIL Label */ 
#line 1034
  yyval.num = - (yyvsp + 0)->num;
#line 1036
  goto switch_break;
  case_112: /* CIL Label */ 
#line 1040
  yyval.num = 1L;
#line 1042
  goto switch_break;
  case_113: /* CIL Label */ 
#line 1044
  yyval.num = 0L;
#line 1046
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2966 "grammar.c"
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2981
  yyvsp -= yylen;
#line 2981
  yyssp -= yylen;
#line 2982
  yylen = 0;
#line 2985
  yyvsp ++;
#line 2985
  *yyvsp = yyval;
#line 2991
  yyn = (int )yyr1[yyn];
#line 2993
  yystate = (int )((int const   )yypgoto[yyn - 70] + (int const   )*yyssp);
#line 2994
  if (0 <= yystate) {
#line 2994
    if (yystate <= 361) {
#line 2994
      if ((int const   )yycheck[yystate] == (int const   )*yyssp) {
#line 2995
        yystate = (int )yytable[yystate];
      } else {
#line 2997
        yystate = (int )yydefgoto[yyn - 70];
      }
    } else {
#line 2997
      yystate = (int )yydefgoto[yyn - 70];
    }
  } else {
#line 2997
    yystate = (int )yydefgoto[yyn - 70];
  }
#line 2999
  goto yynewstate;
  yyerrlab: 
#line 3008
  if (yychar == -2) {
#line 3008
    yytoken = -2;
  } else {
#line 3008
    if ((unsigned int )yychar <= 319U) {
#line 3008
      tmp___77 = (int const   )yytranslate[yychar];
    } else {
#line 3008
      tmp___77 = (int const   )2;
    }
#line 3008
    yytoken = (int )tmp___77;
  }
#line 3011
  if (! yyerrstatus) {
    {
#line 3013
    yynerrs ++;
#line 3015
    yyerror("syntax error");
    }
  }
#line 3052
  if (yyerrstatus == 3) {
#line 3057
    if (yychar <= 0) {
#line 3060
      if (yychar == 0) {
#line 3061
        goto yyabortlab;
      }
    } else {
      {
#line 3065
      yydestruct("Error: discarding", yytoken, & yylval);
#line 3067
      yychar = -2;
      }
    }
  }
#line 3073
  goto yyerrlab1;
#line 3089
  yyvsp -= yylen;
#line 3089
  yyssp -= yylen;
#line 3090
  yylen = 0;
#line 3092
  yystate = (int )*yyssp;
#line 3093
  goto yyerrlab1;
  yyerrlab1: 
#line 3100
  yyerrstatus = 3;
  {
#line 3102
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 3104
    yyn = (int )yypact[yystate];
#line 3105
    if (! (! (! (yyn == -59)))) {
#line 3107
      yyn ++;
#line 3108
      if (0 <= yyn) {
#line 3108
        if (yyn <= 361) {
#line 3108
          if ((int const   )yycheck[yyn] == 1) {
#line 3110
            yyn = (int )yytable[yyn];
#line 3111
            if (0 < yyn) {
#line 3112
              goto while_break___4;
            }
          }
        }
      }
    }
#line 3117
    if ((unsigned long )yyssp == (unsigned long )yyss) {
#line 3118
      goto yyabortlab;
    }
    {
#line 3121
    yydestruct("Error: popping", (int )yystos[yystate], yyvsp);
#line 3123
    yyvsp --;
#line 3123
    yyssp --;
#line 3124
    yystate = (int )*yyssp;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 3129
  yyvsp ++;
#line 3129
  *yyvsp = yylval;
#line 3136
  yystate = yyn;
#line 3137
  goto yynewstate;
  yyacceptlab: 
#line 3144
  yyresult = 0;
#line 3145
  goto yyreturn;
  yyabortlab: 
#line 3151
  yyresult = 1;
#line 3152
  goto yyreturn;
  yyexhaustedlab: 
  {
#line 3159
  yyerror("memory exhausted");
#line 3160
  yyresult = 2;
  }
  yyreturn: 
#line 3165
  if (yychar != -2) {
#line 3169
    if ((unsigned int )yychar <= 319U) {
#line 3169
      yytoken = (int )yytranslate[yychar];
    } else {
#line 3169
      yytoken = 2;
    }
    {
#line 3170
    yydestruct("Cleanup: discarding lookahead", yytoken, & yylval);
    }
  }
#line 3175
  yyvsp -= yylen;
#line 3175
  yyssp -= yylen;
  {
#line 3177
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3177
    if (! ((unsigned long )yyssp != (unsigned long )yyss)) {
#line 3177
      goto while_break___5;
    }
    {
#line 3179
    yydestruct("Cleanup: popping", (int )yystos[*yyssp], yyvsp);
#line 3181
    yyvsp --;
#line 3181
    yyssp --;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3184
  if ((unsigned long )yyss != (unsigned long )(yyssa)) {
    {
#line 3185
    free((void *)yyss);
    }
  }
#line 3192
  return (yyresult);
}
}
#line 1049 "grammar.y"
void yyerror(char const   *str ) 
{ 
  char *tmp ;

  {
  {
#line 1050
  tmp = gettext("ABORT - %s");
#line 1050
  rl_pfatal(65, (char const   *)curfile_name, curfile_line, (char const   *)tmp, str);
  }
#line 1051
  return;
}
}
#line 1053 "grammar.y"
int yywrap(void) 
{ 
  int *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 1054
  fclose(yyin);
  }
#line 1055
  if (numfiles) {
    {
#line 1056
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1056
      curfile ++;
#line 1056
      if (! (curfile < numfiles)) {
#line 1056
        goto while_break;
      }
      {
#line 1057
      yyin = fopen((char const   */* __restrict  */)*(files + curfile), (char const   */* __restrict  */)"r");
      }
#line 1057
      if (yyin) {
#line 1058
        curfile_name = *(files + curfile);
#line 1059
        curfile_line = 1;
#line 1060
        return (0);
      } else {
        {
#line 1062
        curfile_name = (char *)((void *)0);
#line 1063
        tmp = __errno_location();
#line 1063
        tmp___0 = strerror(*tmp);
#line 1063
        tmp___1 = gettext("cannot open file %s (%s)");
#line 1063
        rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___1,
                 *(files + curfile), tmp___0);
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 1068
  return (1);
}
}
#line 1071 "grammar.y"
static struct service *service_new(void) 
{ 
  struct service *p ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 1072
  tmp = malloc(sizeof(*p));
#line 1072
  p = (struct service *)tmp;
  }
#line 1074
  if (! p) {
    {
#line 1075
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 1075
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 1076
  memset((void *)p, 0, sizeof(*p));
  }
#line 1077
  return (p);
}
}
#line 1080 "grammar.y"
void services_free(void) 
{ 


  {
#line 1081
  if (rl_cleanups) {
    {
#line 1082
    rlp_cleanup(rl_cleanups);
#line 1083
    rl_cleanups = (struct rl_cleanup *)((void *)0);
    }
  }
#line 1085
  return;
}
}
#line 1087 "grammar.y"
static void validate_service(struct service *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char const   *rpcname ;
  struct rpcent *rep ;
  char *tmp___2 ;

  {
#line 1088
  if (! s->name) {
    {
#line 1089
    tmp = gettext("service without name");
#line 1089
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp);
#line 1090
    (s->disabled) ++;
    }
#line 1091
    return;
  }
#line 1094
  if (! ((s->sflags & 1) == 1)) {
    {
#line 1095
    tmp___0 = gettext("user is not set for service %s");
#line 1095
    rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___0,
             s->name);
#line 1096
    (s->disabled) ++;
    }
#line 1097
    return;
  }
#line 1100
  if (s->wait) {
#line 1100
    if (s->limit != 1) {
#line 1101
      if (s->limit != defaults->limit) {
        {
#line 1102
        tmp___1 = gettext("ignoring `instances %d\' directive for service %s, because `wait\' was also given");
#line 1102
        rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___1,
                 s->limit, s->name);
        }
      }
#line 1104
      s->limit = 1;
    }
  }
#line 1107
  if (s->rpcvers) {
#line 1108
    rpcname = (char const   *)s->name;
#line 1111
    if (s->rpcname) {
#line 1112
      rpcname = (char const   *)s->rpcname;
    }
    {
#line 1113
    rep = getrpcbyname(rpcname);
    }
#line 1114
    if (! rep) {
      {
#line 1115
      tmp___2 = gettext("can\'t find rpc service %s for service %s");
#line 1115
      rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___2,
               rpcname, s->name);
#line 1117
      (s->disabled) ++;
      }
    } else {
#line 1119
      s->rpcnum = (long )rep->r_number;
    }
    {
#line 1121
    endrpcent();
    }
  }
#line 1123
  return;
}
}
#line 1125 "grammar.y"
static in_port_t get_rpc_port(struct service *cur_service ) 
{ 
  struct numlist  const  *vers ;
  struct sockaddr_in myaddress ;
  in_port_t result ;
  in_port_t port ;
  u_short tmp ;

  {
#line 1127
  if (! cur_service->rpcnum) {
#line 1128
    return ((in_port_t )0);
  }
  {
#line 1129
  vers = (struct numlist  const  *)cur_service->rpcvers;
#line 1131
  get_myaddress(& myaddress);
#line 1132
  result = (in_port_t )0;
  }
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1134
    tmp = pmap_getport(& myaddress, (u_long const   )cur_service->rpcnum, (u_long const   )vers->num,
                       (u_int )cur_service->proto);
#line 1134
    port = tmp;
    }
#line 1136
    if (rl_debug > 1) {
      {
#line 1137
      rl_note("++ pmap_getport(?, %d, %d, %d) for service %s returned %d", cur_service->rpcnum,
              vers->num, cur_service->proto, cur_service->name, (int )port);
      }
    }
#line 1140
    if (result) {
#line 1140
      if (port) {
#line 1140
        if ((int )result != (int )port) {
          {
#line 1141
          rl_pwarn((char const   *)curfile_name, curfile_line, "rpc service %s already registered on different ports: %d and %d",
                   cur_service->name, (int )port, (int )result);
#line 1143
          (cur_service->disabled) ++;
          }
        } else {
#line 1140
          goto _L___0;
        }
      } else {
#line 1140
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1144
    if (port) {
#line 1145
      result = port;
    }
#line 1133
    vers = (struct numlist  const  *)vers->next;
#line 1133
    if (! vers) {
#line 1133
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1149
  return (result);
}
}
#line 1152 "grammar.y"
static int register_rpc_service(int *rpc_registered , struct service  const  * const  cur_service ,
                                in_port_t const   rpc_port ) 
{ 
  struct numlist  const  *vers ;
  char *tmp ;
  bool_t tmp___0 ;
  struct rl_cleanup *p ;
  void *tmp___1 ;
  char *tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;

  {
#line 1156
  if (*rpc_registered) {
#line 1157
    return (1);
  }
#line 1159
  vers = (struct numlist  const  *)cur_service->rpcvers;
  {
#line 1161
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1162
    if (rl_debug > 1) {
      {
#line 1163
      rl_note("++ calling pmap_set(%d, %d, %d, %d) for service %s", cur_service->rpcnum,
              vers->num, cur_service->proto, (int const   )rpc_port, cur_service->name);
      }
    }
    {
#line 1167
    tmp___0 = pmap_set((u_long const   )cur_service->rpcnum, (u_long const   )vers->num,
                       (int )cur_service->proto, (u_short )rpc_port);
    }
#line 1167
    if (tmp___0) {
#line 1168
      (*rpc_registered) ++;
    } else {
      {
#line 1170
      tmp = gettext("pmap_set(%d, %d, %d, %d) failed for service %s");
#line 1170
      rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp, cur_service->rpcnum,
               vers->num, cur_service->proto, (int const   )rpc_port, cur_service->name);
      }
    }
#line 1161
    vers = (struct numlist  const  *)vers->next;
#line 1161
    if (! vers) {
#line 1161
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1175
  if (*rpc_registered) {
    {
#line 1176
    tmp___1 = malloc(sizeof(struct rl_cleanup ));
#line 1176
    p = (struct rl_cleanup *)tmp___1;
    }
#line 1177
    if (! p) {
      {
#line 1178
      tmp___2 = gettext("ABORT - Can\'t allocate memory");
#line 1178
      rl_fatal(70, (char const   *)tmp___2);
      }
    }
    {
#line 1179
    p->next = rl_cleanups;
#line 1180
    tmp___3 = malloc(sizeof(struct rlc_unrpc ));
#line 1180
    p->data = (void *)((struct rlc_unrpc *)tmp___3);
    }
#line 1181
    if (! p->data) {
      {
#line 1182
      tmp___4 = gettext("ABORT - Can\'t allocate memory");
#line 1182
      rl_fatal(70, (char const   *)tmp___4);
      }
    }
    {
#line 1183
    p->type = 0;
#line 1184
    ((struct rlc_unrpc *)p->data)->vers = (struct numlist *)((void *)0);
#line 1185
    numlist_copy(& ((struct rlc_unrpc *)p->data)->vers, (struct numlist *)cur_service->rpcvers);
#line 1186
    ((struct rlc_unrpc *)p->data)->prog = (long )cur_service->rpcnum;
#line 1187
    rl_cleanups = p;
    }
  } else
#line 1189
  if (rl_debug > 1) {
    {
#line 1190
    rl_note("++pmap_set() failed for all versions of service %s", cur_service->name);
    }
  }
#line 1191
  return (*rpc_registered);
}
}
#line 1194 "grammar.y"
static int bind_ports(void) 
{ 
  int fd ;
  long opt ;
  struct stringlist *portp ;
  struct stringlist *ifp ;
  struct addrinfo hints ;
  struct addrinfo *results ;
  struct addrinfo *ai ;
  int ret ;
  char const   *port ;
  char const   *addr ;
  char const   *lasterror ;
  char const   *errfunc ;
  int succeeded ;
  fd_set fds ;
  int n_fds ;
  int family ;
  int socktype ;
  int protocol ;
  socklen_t saddrlen ;
  struct sockaddr *saddr ;
  int rpc_registered ;
  in_port_t rpc_port ;
  in_port_t tmp ;
  int __d0 ;
  int __d1 ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int *tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int *tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int *tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  int *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;
  int tmp___26 ;

  {
  {
#line 1196
  opt = 1L;
#line 1201
  results = (struct addrinfo *)((void *)0);
#line 1210
  errfunc = (char const   *)((void *)0);
#line 1217
  saddr = (struct sockaddr *)((void *)0);
#line 1218
  rpc_registered = 0;
#line 1219
  tmp = get_rpc_port(current_service);
#line 1219
  rpc_port = tmp;
  }
#line 1221
  if (current_service->disabled) {
#line 1222
    return (0);
  }
  {
#line 1224
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1224
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& fds.__fds_bits[0]): "memory");
#line 1224
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 1225
  n_fds = 0;
#line 1226
  ifp = current_service->interface;
  {
#line 1227
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1228
    if (ifp) {
#line 1228
      addr = (char const   *)ifp->str;
    } else {
#line 1228
      addr = (char const   *)((void *)0);
    }
#line 1229
    portp = current_service->port;
    {
#line 1230
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1231
      lasterror = (char const   *)((void *)0);
#line 1232
      succeeded = 0;
#line 1234
      if (portp) {
#line 1234
        port = (char const   *)portp->str;
      } else {
#line 1234
        if (! current_service->rpcnum) {
#line 1234
          tmp___0 = (char const   *)current_service->name;
        } else {
#line 1234
          tmp___0 = "0";
        }
#line 1234
        port = tmp___0;
      }
      {
#line 1236
      memset((void *)(& hints), 0, sizeof(hints));
#line 1237
      hints.ai_flags = 1;
#line 1238
      hints.ai_family = current_service->family;
#line 1239
      hints.ai_socktype = current_service->socktype;
#line 1240
      hints.ai_protocol = current_service->proto;
      }
#line 1241
      if (results) {
        {
#line 1242
        freeaddrinfo(results);
        }
      }
      {
#line 1243
      results = (struct addrinfo *)((void *)0);
#line 1244
      ret = getaddrinfo((char const   */* __restrict  */)addr, (char const   */* __restrict  */)port,
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& results));
      }
#line 1244
      if (ret) {
        {
#line 1246
        tmp___1 = gai_strerror(ret);
#line 1246
        tmp___2 = gettext("getaddrinfo(%s, %s) failed: %s");
#line 1246
        rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___2,
                 addr, port, tmp___1);
        }
#line 1252
        goto __Cont;
      }
#line 1254
      ai = results;
      {
#line 1255
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 1256
        family = ai->ai_family;
#line 1257
        socktype = ai->ai_socktype;
#line 1258
        protocol = ai->ai_protocol;
#line 1259
        saddr = ai->ai_addr;
#line 1260
        saddrlen = ai->ai_addrlen;
#line 1328
        fd = socket(family, socktype, protocol);
        }
#line 1328
        if (fd < 0) {
          {
#line 1329
          tmp___3 = __errno_location();
#line 1329
          tmp___4 = strerror(*tmp___3);
#line 1329
          lasterror = (char const   *)tmp___4;
#line 1330
          errfunc = "socket()";
          }
#line 1331
          goto out;
        }
        {
#line 1333
        tmp___8 = setsockopt(fd, 1, 2, (void const   *)(& opt), (socklen_t )sizeof(opt));
        }
#line 1333
        if (tmp___8) {
          {
#line 1334
          tmp___5 = __errno_location();
#line 1334
          tmp___6 = strerror(*tmp___5);
#line 1334
          tmp___7 = gettext("setsockopt(%d, SOL_SOCKET, SO_REUSEADDR, 1) failed for service %s (%s)");
#line 1334
          rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___7,
                   fd, current_service->name, tmp___6);
          }
        }
#line 1352
        if (current_service->rpcnum) {
#line 1352
          if (rpc_port) {
            {
#line 1355
            ((struct sockaddr_in *)saddr)->sin_port = htons(rpc_port);
            }
          }
        }
        {
#line 1358
        tmp___11 = bind(fd, (struct sockaddr  const  *)saddr, saddrlen);
        }
#line 1358
        if (tmp___11 < 0) {
          {
#line 1359
          tmp___9 = __errno_location();
#line 1359
          tmp___10 = strerror(*tmp___9);
#line 1359
          lasterror = (char const   *)tmp___10;
#line 1360
          close(fd);
#line 1361
          errfunc = "bind()";
          }
#line 1362
          goto out;
        }
#line 1365
        if (current_service->rpcnum) {
#line 1367
          if (! rpc_port) {
            {
#line 1368
            tmp___14 = getsockname(fd, (struct sockaddr */* __restrict  */)saddr,
                                   (socklen_t */* __restrict  */)(& saddrlen));
            }
#line 1368
            if (tmp___14 == -1) {
              {
#line 1369
              tmp___12 = __errno_location();
#line 1369
              tmp___13 = strerror(*tmp___12);
#line 1369
              lasterror = (char const   *)tmp___13;
#line 1370
              close(fd);
#line 1371
              errfunc = "getsockname()";
              }
#line 1372
              goto out;
            }
            {
#line 1376
            rpc_port = ntohs(((struct sockaddr_in *)saddr)->sin_port);
            }
#line 1377
            if (! rpc_port) {
              {
#line 1378
              lasterror = "returned port is 0";
#line 1379
              close(fd);
#line 1380
              errfunc = "getsockname()";
              }
#line 1381
              goto out;
            }
          }
          {
#line 1385
          tmp___15 = register_rpc_service(& rpc_registered, (struct service  const  */* const  */)current_service,
                                          (in_port_t const   )rpc_port);
          }
#line 1385
          if (! tmp___15) {
            {
#line 1386
            close(fd);
            }
#line 1387
            goto out_all_loops;
          }
        }
#line 1390
        fds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
#line 1391
        if (socktype == 1) {
          {
#line 1392
          tmp___18 = listen(fd, current_service->backlog);
          }
#line 1392
          if (tmp___18) {
            {
#line 1393
            tmp___16 = __errno_location();
#line 1393
            tmp___17 = strerror(*tmp___16);
#line 1393
            lasterror = (char const   *)tmp___17;
#line 1394
            close(fd);
#line 1395
            errfunc = "listen(fd)";
            }
#line 1396
            goto out;
          }
        }
        {
#line 1399
        tmp___21 = fcntl(fd, 2, 1);
        }
#line 1399
        if (tmp___21) {
          {
#line 1400
          tmp___19 = __errno_location();
#line 1400
          tmp___20 = strerror(*tmp___19);
#line 1400
          lasterror = (char const   *)tmp___20;
#line 1401
          errfunc = "fcntl(fd, F_SETFD, 1)";
#line 1402
          close(fd);
          }
#line 1403
          goto out;
        }
        {
#line 1405
        tmp___24 = fcntl(fd, 4, 2048);
        }
#line 1405
        if (tmp___24) {
          {
#line 1406
          tmp___22 = __errno_location();
#line 1406
          tmp___23 = strerror(*tmp___22);
#line 1406
          lasterror = (char const   *)tmp___23;
#line 1407
          close(fd);
#line 1408
          errfunc = "fcntl(fd, F_SETFL, O_NDELAY)";
          }
#line 1409
          goto out;
        }
#line 1411
        n_fds ++;
#line 1412
        succeeded ++;
        out: 
#line 1415
        goto __Cont___0;
        __Cont___0: /* CIL Label */ 
#line 1255
        ai = ai->ai_next;
#line 1255
        if (! ai) {
#line 1255
          goto while_break___2;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1418
      if (! succeeded) {
#line 1418
        if (lasterror) {
          {
#line 1419
          tmp___25 = gettext("%s failed for service %s: %s");
#line 1419
          rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___25,
                   errfunc, current_service->name, lasterror);
          }
        }
      }
      __Cont: /* CIL Label */ 
#line 1230
      if (portp) {
#line 1230
        portp = portp->next;
#line 1230
        if (! portp) {
#line 1230
          goto while_break___1;
        }
      } else {
#line 1230
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1227
    if (ifp) {
#line 1227
      ifp = ifp->next;
#line 1227
      if (! ifp) {
#line 1227
        goto while_break___0;
      }
    } else {
#line 1227
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  out_all_loops: 
  {
#line 1424
  stringlist_free(current_service->port);
#line 1425
  current_service->port = (struct stringlist *)((void *)0);
#line 1426
  stringlist_free(current_service->interface);
#line 1427
  current_service->interface = (struct stringlist *)((void *)0);
#line 1428
  numlist_free(current_service->rpcvers);
#line 1429
  current_service->rpcvers = (struct numlist *)((void *)0);
  }
#line 1431
  if (results) {
    {
#line 1432
    freeaddrinfo(results);
#line 1433
    results = (struct addrinfo *)((void *)0);
    }
  }
#line 1441
  if (! n_fds) {
#line 1442
    (current_service->disabled) ++;
  }
  {
#line 1443
  tmp___26 = fdsettab_add(& fds);
  }
#line 1443
  return (tmp___26);
}
}
#line 1446 "grammar.y"
static int add_user_group(struct service  const  *s , struct opmetalist *l ) 
{ 
  struct opmeta *o ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
#line 1448
  o = (struct opmeta *)((void *)0);
#line 1449
  if ((s->sflags & 1) == 1) {
    {
#line 1451
    o = opmeta_make(2, (rl_opcode_t )3, 666);
#line 1452
    opmeta_fixup(o, 1, (opmeta_fixup_ptr )5);
#line 1453
    tmp___0 = opmetalist_add(l, o);
    }
#line 1453
    if (tmp___0) {
      {
#line 1454
      tmp = gettext("opcode resolving problem");
#line 1454
      rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp);
      }
#line 1455
      return (0);
    }
  }
#line 1459
  if ((s->sflags & 1) == 1) {
#line 1459
    goto _L;
  } else
#line 1459
  if ((s->sflags & 2) == 2) {
    _L: /* CIL Label */ 
    {
#line 1461
    o = opmeta_make(2, (rl_opcode_t )4, 666);
#line 1462
    opmeta_fixup(o, 1, (opmeta_fixup_ptr )7);
#line 1463
    tmp___2 = opmetalist_add(l, o);
    }
#line 1463
    if (tmp___2) {
      {
#line 1464
      tmp___1 = gettext("opcode resolving problem");
#line 1464
      rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___1);
      }
#line 1465
      return (0);
    }
  }
#line 1469
  if ((s->sflags & 1) == 1) {
#line 1469
    if ((s->sflags & 4) == 4) {
      {
#line 1471
      o = opmeta_make(3, (rl_opcode_t )13, 666, 666);
#line 1472
      opmeta_fixup(o, 1, (opmeta_fixup_ptr )4);
#line 1473
      opmeta_fixup(o, 2, (opmeta_fixup_ptr )6);
#line 1474
      tmp___4 = opmetalist_add(l, o);
      }
#line 1474
      if (tmp___4) {
        {
#line 1475
        tmp___3 = gettext("opcode resolving problem");
#line 1475
        rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___3);
        }
#line 1476
        return (0);
      }
    }
  }
#line 1479
  return (1);
}
}
#line 1482 "grammar.y"
static void service_free(struct service *s ) 
{ 


  {
#line 1483
  if (s->name) {
    {
#line 1484
    free((void *)s->name);
#line 1485
    s->name = (char *)((void *)0);
    }
  }
  {
#line 1487
  stringlist_free(s->port);
#line 1488
  s->port = (struct stringlist *)((void *)0);
#line 1489
  stringlist_free(s->interface);
#line 1490
  s->interface = (struct stringlist *)((void *)0);
  }
#line 1491
  if (s->rpcname) {
    {
#line 1492
    free((void *)s->rpcname);
#line 1493
    s->rpcname = (char *)((void *)0);
    }
  }
#line 1495
  if (s->rpcvers) {
    {
#line 1496
    numlist_free(s->rpcvers);
#line 1497
    s->rpcvers = (struct numlist *)((void *)0);
    }
  }
#line 1512
  return;
}
}
#line 1514 "grammar.y"
static void service_copy(struct service *to , struct service *from ) 
{ 
  char *tmp ;

  {
  {
#line 1515
  memcpy((void */* __restrict  */)to, (void const   */* __restrict  */)from, sizeof(*to));
#line 1516
  to->name = (char *)((void *)0);
#line 1517
  to->port = (struct stringlist *)((void *)0);
#line 1518
  to->interface = (struct stringlist *)((void *)0);
#line 1519
  stringlist_copy(& to->port, from->port);
#line 1520
  stringlist_copy(& to->interface, from->interface);
  }
#line 1521
  if (from->rpcname) {
    {
#line 1521
    tmp = strdup((char const   *)from->rpcname);
#line 1521
    to->rpcname = tmp;
    }
  } else {
#line 1521
    to->rpcname = (char *)((void *)0);
  }
  {
#line 1522
  to->rpcvers = (struct numlist *)((void *)0);
#line 1523
  numlist_copy(& to->rpcvers, from->rpcvers);
  }
#line 1535
  return;
}
}
#line 1537 "grammar.y"
static struct logdata *logdata_get(char *name ) 
{ 
  struct logdata *ptr ;
  int tmp ;

  {
#line 1538
  ptr = logdatas;
#line 1540
  if (! ptr) {
#line 1541
    return ((struct logdata *)((void *)0));
  }
  {
#line 1542
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1543
    tmp = strcmp((char const   *)name, (char const   *)ptr->name);
    }
#line 1543
    if (! tmp) {
#line 1544
      return (ptr);
    }
#line 1542
    ptr = ptr->next;
#line 1542
    if (! ptr) {
#line 1542
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1546
  return ((struct logdata *)((void *)0));
}
}
#line 1549 "grammar.y"
static void logdatas_free(void) 
{ 
  struct logdata *p ;
  struct logdata *q ;

  {
#line 1552
  p = logdatas;
  {
#line 1553
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1553
    if (! p) {
#line 1553
      goto while_break;
    }
#line 1554
    q = p->next;
#line 1555
    if (p->name) {
      {
#line 1556
      free((void *)p->name);
      }
    }
#line 1557
    if (p->path) {
      {
#line 1558
      free((void *)p->path);
      }
    }
    {
#line 1559
    free((void *)p);
#line 1560
    p = q;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1562
  logdatas = (struct logdata *)((void *)0);
#line 1563
  return;
}
}
#line 1565 "grammar.y"
static struct logdata *logdata_new(void) 
{ 
  struct logdata *ptr ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 1566
  tmp = malloc(sizeof(*ptr));
#line 1566
  ptr = (struct logdata *)tmp;
  }
#line 1568
  if (! ptr) {
    {
#line 1569
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 1569
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 1571
  memset((void *)ptr, 0, sizeof(*ptr));
#line 1572
  ptr->index = -1;
#line 1573
  ptr->mode = (mode_t )(384 | (256 >> 3));
#line 1580
  ptr->uid = (uid_t )-1;
#line 1581
  ptr->gid = (gid_t )-1;
  }
#line 1582
  return (ptr);
}
}
#line 1585
void parse(void) ;
#line 1586 "grammar.y"
void parse(void) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 1588
  numlist = (struct numlist *)((void *)0);
#line 1589
  userdata = (struct userdata *)((void *)0);
#line 1590
  newuserdata(& userdata);
#line 1591
  pidtab_fixup();
#line 1592
  all_unhook();
#line 1593
  logtabs_free();
#line 1594
  argvtabs_free();
#line 1595
  rlimittabs_free();
#line 1596
  services_free();
#line 1597
  stringtabs_free();
#line 1598
  buftabs_free();
#line 1599
  oplisttabs_free();
#line 1603
  semaphores_free();
#line 1604
  fdsettabs_free();
#line 1605
  tmp___0 = strcmp((char const   *)rl_config, "-");
  }
#line 1605
  if (tmp___0) {
#line 1605
    goto _L;
  } else
#line 1605
  if (! rl_debug) {
    _L: /* CIL Label */ 
    {
#line 1606
    yyin = fopen((char const   */* __restrict  */)rl_config, (char const   */* __restrict  */)"r");
    }
#line 1606
    if (yyin) {
#line 1609
      curfile_name = rl_config;
#line 1610
      curfile_line = 1;
    } else {
      {
#line 1607
      tmp = gettext("fopen(%s) failed, aborting");
#line 1607
      rl_pfatal(66, (char const   *)curfile_name, curfile_line, (char const   *)tmp,
                rl_config);
      }
    }
  }
  {
#line 1614
  logcur = logdata_new();
#line 1615
  current_service = service_new();
#line 1616
  defaults = service_new();
#line 1618
  defaults->family = 0;
#line 1622
  defaults->socktype = 1;
#line 1623
  defaults->protoname = "tcp";
#line 1624
  defaults->proto = 6;
#line 1625
  defaults->backlog = 5;
#line 1626
  defaults->limit = 40;
#line 1627
  defaults->r.rlim_cur = (__rlim_t )-1;
#line 1628
  defaults->r.rlim_max = (__rlim_t )-1;
#line 1629
  defaults->wait = 0;
#line 1632
  defaults->opfixups[2] = (rl_opcode_t )-1;
#line 1634
  defaults->opfixups[1] = (rl_opcode_t )-1;
#line 1635
  defaults->opfixups[3] = (rl_opcode_t )-1;
#line 1636
  defaults->opfixups[4] = (rl_opcode_t )-1;
#line 1637
  defaults->sflags = 0;
#line 1638
  defaults->opfixups[6] = (rl_opcode_t )-1;
#line 1639
  defaults->opfixups[7] = (rl_opcode_t )-1;
#line 1640
  defaults->opfixups[5] = (rl_opcode_t )-1;
#line 1641
  service_copy(current_service, defaults);
#line 1642
  opml_defaults = opmetalist_new();
#line 1643
  yyparse();
#line 1644
  freebufs();
#line 1645
  service_free(defaults);
#line 1646
  free((void *)defaults);
#line 1647
  defaults = (struct service *)((void *)0);
#line 1648
  logdatas_free();
#line 1649
  free((void *)logcur);
#line 1650
  logcur = (struct logdata *)((void *)0);
#line 1651
  service_free(current_service);
#line 1652
  free((void *)current_service);
#line 1653
  current_service = (struct service *)((void *)0);
#line 1654
  curfile = 0;
  }
  {
#line 1654
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1654
    if (! (curfile < numfiles)) {
#line 1654
      goto while_break;
    }
    {
#line 1655
    free((void *)*(files + curfile));
#line 1656
    *(files + curfile) = (char *)((void *)0);
#line 1654
    curfile ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1658
  free((void *)files);
#line 1659
  files = (char **)((void *)0);
#line 1660
  clearuserdata(& userdata);
#line 1661
  free((void *)userdata);
  }
#line 1662
  return;
}
}
#line 1664 "grammar.y"
static void pidtab_fixup(void) 
{ 
  struct pidtab *p ;
  int i ;

  {
#line 1668
  i = 0;
  {
#line 1668
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1668
    if (! (i < 8)) {
#line 1668
      goto while_break;
    }
#line 1669
    p = pidtabs[i].next;
    {
#line 1670
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1670
      if (! p) {
#line 1670
        goto while_break___0;
      }
#line 1671
      if (p->inst) {
        {
#line 1672
        inst_free(p->inst);
        }
      }
#line 1673
      p->inst = (struct rl_instance *)((void *)0);
#line 1674
      p = p->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1668
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1677
  return;
}
}
#line 1692 "grammar.y"
static void add_directory(char *dir , char *match , char *ignore ) 
{ 
  DIR *d ;
  struct dirent *de ;
  regex_t rmatch ;
  regex_t rignore ;
  char err[128] ;
  int e ;
  struct stat st ;
  char *file ;
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  void *tmp___9 ;
  char *tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;

  {
#line 1701
  if (match) {
    {
#line 1702
    e = regcomp((regex_t */* __restrict  */)(& rmatch), (char const   */* __restrict  */)match,
                1 | (((1 << 1) << 1) << 1));
    }
#line 1702
    if (e) {
      {
#line 1703
      regerror(e, (regex_t const   */* __restrict  */)(& rmatch), (char */* __restrict  */)(err),
               (size_t )127);
#line 1704
      tmp = gettext("regexp compile failed for directory %s: %s");
#line 1704
      rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp, dir,
               err);
      }
    }
  }
#line 1707
  if (ignore) {
    {
#line 1708
    e = regcomp((regex_t */* __restrict  */)(& rignore), (char const   */* __restrict  */)ignore,
                1 | (((1 << 1) << 1) << 1));
    }
#line 1708
    if (e) {
      {
#line 1709
      regerror(e, (regex_t const   */* __restrict  */)(& rignore), (char */* __restrict  */)(err),
               (size_t )127);
#line 1710
      tmp___0 = gettext("regexp compile failed for directory %s: %s");
#line 1710
      rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___0,
               dir, err);
      }
    }
  }
  {
#line 1714
  d = opendir((char const   *)dir);
  }
#line 1714
  if (d) {
    {
#line 1715
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1715
      de = readdir(d);
      }
#line 1715
      if (! de) {
#line 1715
        goto while_break;
      }
#line 1716
      if (match) {
        {
#line 1717
        tmp___1 = regexec((regex_t const   */* __restrict  */)(& rmatch), (char const   */* __restrict  */)(de->d_name),
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 1717
        if (tmp___1) {
#line 1718
          goto while_continue;
        }
      }
#line 1719
      if (ignore) {
        {
#line 1720
        tmp___2 = regexec((regex_t const   */* __restrict  */)(& rignore), (char const   */* __restrict  */)(de->d_name),
                          (size_t )0, (regmatch_t */* __restrict  */)((void *)0),
                          0);
        }
#line 1720
        if (! tmp___2) {
#line 1721
          goto while_continue;
        }
      }
#line 1722
      if ((int )de->d_name[0] != 46) {
        {
#line 1723
        tmp___3 = strlen((char const   *)dir);
#line 1723
        tmp___4 = strlen((char const   *)(de->d_name));
#line 1723
        tmp___5 = malloc((tmp___3 + tmp___4) + 2UL);
#line 1723
        file = (char *)tmp___5;
        }
#line 1724
        if (! file) {
          {
#line 1725
          tmp___6 = gettext("ABORT - Can\'t allocate memory");
#line 1725
          rl_fatal(70, (char const   *)tmp___6);
          }
        }
        {
#line 1726
        *(file + 0) = (char )'\000';
#line 1727
        strcat((char */* __restrict  */)file, (char const   */* __restrict  */)dir);
#line 1728
        strcat((char */* __restrict  */)file, (char const   */* __restrict  */)"/");
#line 1729
        strcat((char */* __restrict  */)file, (char const   */* __restrict  */)(de->d_name));
#line 1730
        tmp___8 = stat((char const   */* __restrict  */)file, (struct stat */* __restrict  */)(& st));
        }
#line 1730
        if (tmp___8) {
          {
#line 1731
          tmp___7 = gettext("file %s does not exists or is a directory");
#line 1731
          rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___7,
                   file);
#line 1733
          free((void *)file);
          }
#line 1734
          goto while_continue;
        } else
#line 1730
        if ((st.st_mode & 61440U) == 16384U) {
          {
#line 1731
          tmp___7 = gettext("file %s does not exists or is a directory");
#line 1731
          rl_pwarn((char const   *)curfile_name, curfile_line, (char const   *)tmp___7,
                   file);
#line 1733
          free((void *)file);
          }
#line 1734
          goto while_continue;
        }
        {
#line 1736
        numfiles ++;
#line 1736
        tmp___9 = realloc((void *)files, (unsigned long )numfiles * sizeof(char *));
#line 1736
        files = (char **)tmp___9;
        }
#line 1737
        if (! files) {
          {
#line 1738
          tmp___10 = gettext("ABORT - Can\'t allocate memory");
#line 1738
          rl_fatal(70, (char const   *)tmp___10);
          }
        }
#line 1739
        *(files + (numfiles - 1)) = file;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 1743
    tmp___11 = __errno_location();
#line 1743
    tmp___12 = strerror(*tmp___11);
#line 1743
    tmp___13 = gettext("Directory %s open failed (%s)");
#line 1743
    rl_pfatal(66, (char const   *)curfile_name, curfile_line, (char const   *)tmp___13,
              dir, tmp___12);
    }
  }
  {
#line 1746
  closedir(d);
#line 1747
  free((void *)dir);
  }
#line 1748
  if (match) {
    {
#line 1749
    free((void *)match);
#line 1750
    regfree(& rmatch);
    }
  }
#line 1752
  if (ignore) {
    {
#line 1753
    free((void *)ignore);
#line 1754
    regfree(& rignore);
    }
  }
#line 1756
  return;
}
}
#line 1759 "grammar.y"
static int cb  =    -1;
#line 1758 "grammar.y"
static int chargen_buffer(void) 
{ 
  char const   *b ;
  size_t tmp ;

  {
#line 1760
  b = "01234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\r\n";
#line 1762
  if (cb == -1) {
    {
#line 1763
    tmp = strlen(b);
#line 1763
    cb = buftab_addbuf(b, (int )tmp);
    }
  }
#line 1764
  return (cb);
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 14 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static rl_opcode_t terminals[5]  = {      (rl_opcode_t )15,      (rl_opcode_t )1,      (rl_opcode_t )19,      (rl_opcode_t )34, 
        (rl_opcode_t )18};
#line 16 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array aterminals  =    {terminals, 5};
#line 23 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static rl_opcode_t restrictive[6]  = {      (rl_opcode_t )15,      (rl_opcode_t )1,      (rl_opcode_t )19,      (rl_opcode_t )34, 
        (rl_opcode_t )18,      (rl_opcode_t )3};
#line 25 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array arestrictive  =    {restrictive, 6};
#line 32 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static rl_opcode_t initgr[6]  = {      (rl_opcode_t )15,      (rl_opcode_t )1,      (rl_opcode_t )19,      (rl_opcode_t )18, 
        (rl_opcode_t )4,      (rl_opcode_t )3};
#line 34 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array ainitgr  =    {initgr, 6};
#line 41 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static rl_opcode_t children[11]  = 
#line 41
  {      (rl_opcode_t )15,      (rl_opcode_t )8,      (rl_opcode_t )1,      (rl_opcode_t )19, 
        (rl_opcode_t )10,      (rl_opcode_t )5,      (rl_opcode_t )18,      (rl_opcode_t )6, 
        (rl_opcode_t )4,      (rl_opcode_t )3,      (rl_opcode_t )11};
#line 44 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array achildren  =    {children, 11};
#line 51 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static rl_opcode_t sockops[9]  = 
#line 51
  {      (rl_opcode_t )16,      (rl_opcode_t )20,      (rl_opcode_t )10,      (rl_opcode_t )27, 
        (rl_opcode_t )28,      (rl_opcode_t )29,      (rl_opcode_t )30,      (rl_opcode_t )31, 
        (rl_opcode_t )32};
#line 55 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array asockops  =    {sockops, 9};
#line 62 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static rl_opcode_t semkids[10]  = 
#line 62
  {      (rl_opcode_t )9,      (rl_opcode_t )16,      (rl_opcode_t )20,      (rl_opcode_t )10, 
        (rl_opcode_t )27,      (rl_opcode_t )28,      (rl_opcode_t )29,      (rl_opcode_t )30, 
        (rl_opcode_t )31,      (rl_opcode_t )32};
#line 66 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array asemkids  =    {semkids, 10};
#line 72 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct optab  const  optab[43]  = 
#line 72
  {      {(rl_opcode_t )0, 0, (struct array *)((void *)0)}, 
        {(rl_opcode_t )1, 2, (struct array *)((void *)0)}, 
        {(rl_opcode_t )2, 0, & arestrictive}, 
        {(rl_opcode_t )3, 1, & aterminals}, 
        {(rl_opcode_t )4, 1, & arestrictive}, 
        {(rl_opcode_t )5, 1, & arestrictive}, 
        {(rl_opcode_t )6, 2, & arestrictive}, 
        {(rl_opcode_t )7, 1, & arestrictive}, 
        {(rl_opcode_t )8, 1, & arestrictive}, 
        {(rl_opcode_t )9, 1, & asockops}, 
        {(rl_opcode_t )10, 2, & achildren}, 
        {(rl_opcode_t )11, 2, & arestrictive}, 
        {(rl_opcode_t )12, 1, & arestrictive}, 
        {(rl_opcode_t )13, 2, & ainitgr}, 
        {(rl_opcode_t )14, 1, & aterminals}, 
        {(rl_opcode_t )15, 0, (struct array *)((void *)0)}, 
        {(rl_opcode_t )16, 1, & achildren}, 
        {(rl_opcode_t )17, 0, & aterminals}, 
        {(rl_opcode_t )18, 0, (struct array *)((void *)0)}, 
        {(rl_opcode_t )19, 0, (struct array *)((void *)0)}, 
        {(rl_opcode_t )20, 1, & aterminals}, 
        {(rl_opcode_t )21, 1, & aterminals}, 
        {(rl_opcode_t )22, 1, & asemkids}, 
        {(rl_opcode_t )23, 0, & arestrictive}, 
        {(rl_opcode_t )24, 1, & arestrictive}, 
        {(rl_opcode_t )25, 1, & arestrictive}, 
        {(rl_opcode_t )26, 1, & aterminals}, 
        {(rl_opcode_t )27, 0, & aterminals}, 
        {(rl_opcode_t )28, 0, & aterminals}, 
        {(rl_opcode_t )29, 1, & aterminals}, 
        {(rl_opcode_t )30, 0, & aterminals}, 
        {(rl_opcode_t )31, 1, & aterminals}, 
        {(rl_opcode_t )32, 0, & aterminals}, 
        {(rl_opcode_t )33, 1, & aterminals}, 
        {(rl_opcode_t )34, 1, (struct array *)((void *)0)}, 
        {(rl_opcode_t )35, 1, & aterminals}, 
        {(rl_opcode_t )36, 0, & aterminals}, 
        {(rl_opcode_t )37, 0, & aterminals}, 
        {(rl_opcode_t )38, 0, & aterminals}, 
        {(rl_opcode_t )39, 0, & aterminals}, 
        {(rl_opcode_t )40, 1, & aterminals}, 
        {(rl_opcode_t )41, 0, & aterminals}, 
        {(rl_opcode_t )0, 0, (struct array *)((void *)0)}};
#line 118 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array *array_new(void) 
{ 
  struct array *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 121
  tmp___0 = malloc(sizeof(*tmp));
#line 121
  tmp = (struct array *)tmp___0;
  }
#line 122
  if (! tmp) {
    {
#line 123
    tmp___1 = gettext("ABORT - Can\'t allocate memory");
#line 123
    rl_fatal(70, (char const   *)tmp___1);
    }
  }
  {
#line 125
  memset((void *)tmp, 0, sizeof(*tmp));
  }
#line 129
  return (tmp);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static void array_free(struct array *a ) 
{ 


  {
#line 133
  a->len = 0;
#line 134
  if (a->elems) {
    {
#line 135
    free((void *)a->elems);
    }
  }
#line 136
  a->elems = (rl_opcode_t *)((void *)0);
#line 145
  return;
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static void array_append(struct array *arr , rl_opcode_t op ) 
{ 
  int i ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 148
  i = arr->len;
#line 150
  (arr->len) ++;
#line 150
  tmp = realloc((void *)arr->elems, (unsigned long )arr->len * sizeof(rl_opcode_t ));
#line 150
  arr->elems = (rl_opcode_t *)tmp;
  }
#line 151
  if (! arr->elems) {
    {
#line 152
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 152
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
#line 153
  *(arr->elems + i) = op;
#line 154
  return;
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array *array_copy(struct array *a ) 
{ 
  struct array *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
#line 159
  if (! a) {
#line 160
    return ((struct array *)((void *)0));
  }
  {
#line 161
  tmp = array_new();
#line 162
  tmp->len = a->len;
  }
#line 163
  if (a->len) {
    {
#line 164
    tmp___0 = malloc(sizeof(rl_opcode_t ) * (unsigned long )a->len);
#line 164
    tmp->elems = (rl_opcode_t *)tmp___0;
    }
#line 165
    if (! tmp->elems) {
      {
#line 166
      tmp___1 = gettext("ABORT - Can\'t allocate memory");
#line 166
      rl_fatal(70, (char const   *)tmp___1);
      }
    }
  }
  {
#line 169
  memcpy((void */* __restrict  */)tmp->elems, (void const   */* __restrict  */)a->elems,
         sizeof(rl_opcode_t ) * (unsigned long )a->len);
  }
#line 170
  return (tmp);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct array *array_union(struct array *a , struct array *b ) 
{ 
  struct array *ret ;
  int i ;
  int j ;
  struct array *tmp ;

  {
  {
#line 177
  ret = array_copy(a);
  }
#line 178
  if (! ret) {
    {
#line 179
    tmp = array_copy(b);
    }
#line 179
    return (tmp);
  }
#line 180
  if (! b) {
#line 181
    return (ret);
  }
#line 182
  i = 0;
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < b->len)) {
#line 182
      goto while_break;
    }
#line 183
    j = 0;
    {
#line 183
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 183
      if (! (j < ret->len)) {
#line 183
        goto while_break___0;
      }
#line 184
      if (*(ret->elems + j) == *(b->elems + i)) {
#line 185
        goto found;
      }
#line 183
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 186
    array_append(ret, *(b->elems + i));
    }
    found: 
#line 188
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 182
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 190
  return (ret);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static int array_intersect_p(struct array *a , struct array *b ) 
{ 
  int i ;
  int j ;

  {
#line 196
  if (! a) {
#line 197
    return (0);
  } else
#line 196
  if (! a->len) {
#line 197
    return (0);
  } else
#line 196
  if (! b) {
#line 197
    return (0);
  } else
#line 196
  if (! b->len) {
#line 197
    return (0);
  }
#line 198
  i = 0;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (i < a->len)) {
#line 198
      goto while_break;
    }
#line 199
    j = 0;
    {
#line 199
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 199
      if (! (j < b->len)) {
#line 199
        goto while_break___0;
      }
#line 200
      if (*(a->elems + i) == *(b->elems + j)) {
#line 201
        return (1);
      }
#line 199
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 198
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct opmeta *opmeta_new(int len ) 
{ 
  struct opmeta *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 208
  tmp___0 = malloc(sizeof(*tmp));
#line 208
  tmp = (struct opmeta *)tmp___0;
  }
#line 209
  if (! tmp) {
    {
#line 210
    tmp___1 = gettext("ABORT - Can\'t allocate memory");
#line 210
    rl_fatal(70, (char const   *)tmp___1);
    }
  }
  {
#line 211
  memset((void *)tmp, 0, sizeof(*tmp));
#line 212
  tmp->after = array_new();
#line 213
  tmp->ops = array_new();
  }
#line 214
  if (len) {
    {
#line 215
    tmp___2 = malloc((unsigned long )len * sizeof(opmeta_fixup_ptr ));
#line 215
    tmp->fixup = (opmeta_fixup_ptr *)tmp___2;
    }
#line 216
    if (! tmp->fixup) {
      {
#line 217
      tmp___3 = gettext("ABORT - Can\'t allocate memory");
#line 217
      rl_fatal(70, (char const   *)tmp___3);
      }
    }
  }
  {
#line 219
  memset((void *)tmp->fixup, 0, (unsigned long )len * sizeof(opmeta_fixup_ptr ));
  }
#line 223
  return (tmp);
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static void opmeta_free(struct opmeta *tmp ) 
{ 


  {
#line 227
  if (! tmp) {
#line 228
    return;
  }
#line 229
  if (tmp->after) {
    {
#line 230
    array_free(tmp->after);
#line 231
    free((void *)tmp->after);
    }
  }
#line 233
  tmp->after = (struct array *)((void *)0);
#line 234
  if (tmp->ops) {
    {
#line 235
    array_free(tmp->ops);
#line 236
    free((void *)tmp->ops);
    }
  }
#line 238
  tmp->ops = (struct array *)((void *)0);
#line 239
  if (tmp->bytes) {
    {
#line 240
    free((void *)tmp->bytes);
    }
  }
#line 241
  if (tmp->fixup) {
    {
#line 242
    free((void *)tmp->fixup);
    }
  }
#line 243
  tmp->fixup = (opmeta_fixup_ptr *)((void *)0);
#line 244
  tmp->bytes = (rl_opcode_t *)((void *)0);
#line 245
  tmp->len = 0;
#line 254
  return;
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
struct opmeta *opmeta_make(int len , rl_opcode_t op  , ...) 
{ 
  struct opmeta *opm ;
  va_list argp ;
  int i ;
  struct array *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  rl_opcode_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 262
  __builtin_va_start(argp, op);
#line 263
  opm = opmeta_new(len);
  }
  {
#line 264
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 265
    i = (int )optab[op].nargs;
#line 266
    tmp = array_union(opm->after, (struct array *)optab[op].after);
    }
#line 267
    if (opm->after) {
      {
#line 268
      array_free(opm->after);
#line 269
      free((void *)opm->after);
      }
    }
    {
#line 271
    opm->after = tmp;
#line 272
    tmp___0 = realloc((void *)opm->bytes, sizeof(rl_opcode_t ) * (unsigned long )((1 + i) + opm->len));
#line 272
    opm->bytes = (rl_opcode_t *)tmp___0;
    }
#line 274
    if (! opm->bytes) {
      {
#line 275
      tmp___1 = gettext("ABORT - Can\'t allocate memory");
#line 275
      rl_fatal(70, (char const   *)tmp___1);
      }
    }
    {
#line 276
    array_append(opm->ops, op);
    }
    {
#line 277
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 278
      tmp___2 = opm->len;
#line 278
      (opm->len) ++;
#line 278
      *(opm->bytes + tmp___2) = op;
#line 279
      tmp___3 = __builtin_va_arg(argp, rl_opcode_t );
#line 279
      op = tmp___3;
#line 280
      len --;
#line 277
      tmp___4 = i;
#line 277
      i --;
      }
#line 277
      if (! tmp___4) {
#line 277
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 264
    if (! (len > 0)) {
#line 264
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 283
  __builtin_va_end(argp);
  }
#line 284
  return (opm);
}
}
#line 287 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
void opmeta_fixup(struct opmeta *o , int offset , opmeta_fixup_ptr fixup ) 
{ 


  {
#line 288
  *(o->fixup + offset) = fixup;
#line 289
  return;
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static void opmeta_resolve(struct opmeta *o , opmeta_fixup_ptr const   *fixups ) 
{ 
  int i ;

  {
#line 294
  i = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (i < o->len)) {
#line 294
      goto while_break;
    }
#line 295
    if (*(o->fixup + i)) {
#line 296
      *(o->bytes + i) = (rl_opcode_t )*(fixups + *(o->fixup + i));
    }
#line 294
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 297
  return;
}
}
#line 299 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
struct opmetalist *opmetalist_new(void) 
{ 
  struct opmetalist *opml ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 302
  tmp = malloc(sizeof(*opml));
#line 302
  opml = (struct opmetalist *)tmp;
  }
#line 303
  if (! opml) {
    {
#line 304
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 304
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 305
  memset((void *)opml, 0, sizeof(*opml));
  }
#line 309
  return (opml);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static struct opmeta *opmeta_copy(struct opmeta *opm ) 
{ 
  struct opmeta *o ;
  struct opmeta *tmp ;
  void *tmp___0 ;

  {
  {
#line 313
  tmp = opmeta_new(opm->len);
#line 313
  o = tmp;
  }
#line 315
  if (opm->bytes) {
    {
#line 316
    tmp___0 = malloc(sizeof(rl_opcode_t ) * (unsigned long )opm->len);
#line 316
    o->bytes = (rl_opcode_t *)tmp___0;
#line 317
    memcpy((void */* __restrict  */)o->bytes, (void const   */* __restrict  */)opm->bytes,
           sizeof(rl_opcode_t ) * (unsigned long )opm->len);
    }
  }
#line 320
  if (opm->fixup) {
    {
#line 320
    memcpy((void */* __restrict  */)o->fixup, (void const   */* __restrict  */)opm->fixup,
           sizeof(opmeta_fixup_ptr ) * (unsigned long )opm->len);
    }
  }
  {
#line 321
  array_free(o->after);
#line 322
  array_free(o->ops);
#line 323
  o->after = array_copy(opm->after);
#line 324
  o->ops = array_copy(opm->ops);
#line 325
  o->len = opm->len;
  }
#line 327
  return (o);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
static int opmetalist_add_int(struct opmetalist *opml , struct opmeta *opm , int copy ) 
{ 
  int i ;
  int idx ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  struct opmeta *tmp___5 ;

  {
#line 335
  if (! opml) {
    {
#line 336
    tmp = gettext("ABORT - opmetalist_add(NULL, ...)!");
#line 336
    rl_fatal(70, (char const   *)tmp);
    }
  }
#line 337
  if (! opm) {
#line 338
    return (0);
  }
#line 339
  i = 0;
  {
#line 339
  while (1) {
    while_continue: /* CIL Label */ ;
#line 339
    if (! (i < opml->len)) {
#line 339
      goto while_break;
    }
    {
#line 340
    tmp___0 = array_intersect_p(opm->after, (*(opml->opms + i))->ops);
    }
#line 340
    if (tmp___0) {
#line 341
      goto while_break;
    }
#line 339
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  idx = i;
  {
#line 343
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 343
    if (! (i < opml->len)) {
#line 343
      goto while_break___0;
    }
    {
#line 344
    tmp___1 = i;
#line 344
    i ++;
#line 344
    tmp___2 = array_intersect_p(opm->ops, (*(opml->opms + tmp___1))->after);
    }
#line 344
    if (tmp___2) {
#line 345
      return (1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 346
  (opml->len) ++;
#line 346
  tmp___3 = realloc((void *)opml->opms, (unsigned long )opml->len * sizeof(*(opml->opms)));
#line 346
  opml->opms = (struct opmeta **)tmp___3;
  }
#line 347
  if (! opml->opms) {
    {
#line 348
    tmp___4 = gettext("ABORT - Can\'t allocate memory");
#line 348
    rl_fatal(70, (char const   *)tmp___4);
    }
  }
  {
#line 349
  memmove((void *)((opml->opms + idx) + 1), (void const   *)(opml->opms + idx), sizeof(*(opml->opms)) * (unsigned long )((opml->len - idx) - 1));
  }
#line 351
  if (copy) {
    {
#line 351
    tmp___5 = opmeta_copy(opm);
#line 351
    *(opml->opms + idx) = tmp___5;
    }
  } else {
#line 351
    *(opml->opms + idx) = opm;
  }
#line 352
  return (0);
}
}
#line 355 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
int opmetalist_add(struct opmetalist *opml , struct opmeta *opm ) 
{ 
  int tmp ;

  {
  {
#line 356
  tmp = opmetalist_add_int(opml, opm, 0);
  }
#line 356
  return (tmp);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
void opmetalist_free(struct opmetalist *l ) 
{ 
  int tmp ;

  {
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
#line 360
    tmp = l->len;
#line 360
    (l->len) --;
#line 360
    if (! tmp) {
#line 360
      goto while_break;
    }
    {
#line 361
    opmeta_free(*(l->opms + l->len));
#line 362
    free((void *)*(l->opms + l->len));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 364
  free((void *)l->opms);
#line 365
  l->opms = (struct opmeta **)((void *)0);
#line 366
  l->len = 0;
  }
#line 375
  return;
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
struct opmetalist *opmetalist_merge(struct opmetalist *o , struct opmetalist  const  *p ) 
{ 
  int i ;
  int j ;
  int tmp ;

  {
#line 378
  if (! p) {
#line 379
    return (o);
  }
#line 380
  i = (int )p->len;
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    tmp = i;
#line 381
    i --;
#line 381
    if (! tmp) {
#line 381
      goto while_break;
    }
#line 383
    if (! *(p->opms + i)) {
#line 383
      goto while_continue;
    }
#line 385
    j = 0;
    {
#line 385
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 385
      if (! (j < (*(p->opms + i))->len)) {
#line 385
        goto while_break___0;
      }
      {
#line 386
      rl_warn("--> %d\n", *((*(p->opms + i))->bytes + j));
#line 385
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 387
    opmetalist_add_int(o, *(p->opms + i), 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 389
  return (o);
}
}
#line 392 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
struct opmetalist *opmetalist_join(struct opmetalist *o , struct opmetalist *p ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 393
  if (! p) {
#line 394
    return (o);
  }
  {
#line 395
  while (1) {
    while_continue: /* CIL Label */ ;
#line 395
    tmp___0 = p->len;
#line 395
    (p->len) --;
#line 395
    if (! tmp___0) {
#line 395
      goto while_break;
    }
    {
#line 396
    tmp = opmetalist_add(o, *(p->opms + p->len));
    }
#line 396
    if (tmp) {
#line 397
      return ((struct opmetalist *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 398
  p->len = 0;
#line 399
  opmetalist_free(p);
#line 400
  free((void *)p);
  }
#line 401
  return (o);
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/assemble.c"
struct oplist *opmetalist_resolve(struct opmetalist *o , opmeta_fixup_ptr const   *fixups ) 
{ 
  int i ;
  int j ;
  int k ;
  struct oplist *ret ;
  void *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 408
  tmp = malloc(sizeof(*ret));
#line 408
  ret = (struct oplist *)tmp;
  }
#line 409
  if (! ret) {
    {
#line 410
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 410
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
#line 411
  ret->ops_len = 0;
#line 412
  i = 0;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
#line 412
    if (! (i < o->len)) {
#line 412
      goto while_break;
    }
    {
#line 413
    opmeta_resolve(*(o->opms + i), fixups);
#line 414
    ret->ops_len += (*(o->opms + i))->len;
#line 412
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 416
  if (ret->ops_len) {
    {
#line 417
    tmp___1 = malloc(sizeof(*(ret->ops_list)) * (unsigned long )ret->ops_len);
#line 417
    ret->ops_list = (rl_opcode_t *)tmp___1;
    }
#line 418
    if (! ret->ops_list) {
      {
#line 419
      tmp___2 = gettext("ABORT - Can\'t allocate memory");
#line 419
      rl_fatal(70, (char const   *)tmp___2);
      }
    }
  }
#line 421
  k = 0;
#line 422
  i = 0;
  {
#line 422
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 422
    if (! (i < o->len)) {
#line 422
      goto while_break___0;
    }
#line 423
    j = 0;
    {
#line 423
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 423
      if (! (j < (*(o->opms + i))->len)) {
#line 423
        goto while_break___1;
      }
#line 427
      tmp___3 = k;
#line 427
      k ++;
#line 427
      *(ret->ops_list + tmp___3) = *((*(o->opms + i))->bytes + j);
#line 423
      j ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 422
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 429
  return (ret);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.h"
void builduserdata(struct userdata **dest , char *name ) ;
#line 88
void userdata_copy(struct userdata **to , struct userdata *from ) ;
#line 15 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void numlist_add(struct numlist **list , long num ) 
{ 
  struct numlist *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 16
  tmp___0 = malloc(sizeof(*tmp));
#line 16
  tmp = (struct numlist *)tmp___0;
  }
#line 18
  if (! tmp) {
    {
#line 19
    tmp___1 = gettext("ABORT - Can\'t allocate memory");
#line 19
    rl_fatal(70, (char const   *)tmp___1);
    }
  }
#line 20
  tmp->next = *list;
#line 21
  tmp->num = num;
#line 22
  *list = tmp;
#line 23
  return;
}
}
#line 25 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void numlist_copy(struct numlist **to , struct numlist *from ) 
{ 


  {
  {
#line 26
  while (1) {
    while_continue: /* CIL Label */ ;
#line 26
    if (! from) {
#line 26
      goto while_break;
    }
    {
#line 27
    numlist_add(to, from->num);
#line 28
    from = from->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 30
  return;
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void numlist_free(struct numlist *n ) 
{ 
  struct numlist *p ;

  {
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! n) {
#line 35
      goto while_break;
    }
    {
#line 36
    p = n->next;
#line 37
    free((void *)n);
#line 38
    n = p;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 40
  return;
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void stringlist_add(struct stringlist **list , char *str ) 
{ 
  struct stringlist *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 43
  tmp___0 = malloc(sizeof(*tmp));
#line 43
  tmp = (struct stringlist *)tmp___0;
  }
#line 45
  if (! tmp) {
    {
#line 46
    tmp___1 = gettext("ABORT - Can\'t allocate memory");
#line 46
    rl_fatal(70, (char const   *)tmp___1);
    }
  }
#line 47
  tmp->next = *list;
#line 48
  tmp->str = str;
#line 49
  *list = tmp;
#line 50
  return;
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void stringlist_copy(struct stringlist **to , struct stringlist *from ) 
{ 
  char *tmp ;

  {
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! from) {
#line 53
      goto while_break;
    }
    {
#line 54
    tmp = strdup((char const   *)from->str);
#line 54
    stringlist_add(to, tmp);
#line 55
    from = from->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void stringlist_free(struct stringlist *n ) 
{ 
  struct stringlist *p ;

  {
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (! n) {
#line 62
      goto while_break;
    }
#line 63
    p = n->next;
#line 64
    if (n->str) {
      {
#line 65
      free((void *)n->str);
      }
    }
    {
#line 66
    free((void *)n);
#line 67
    n = p;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void builduserdata(struct userdata **dest , char *name ) 
{ 
  struct passwd pw ;
  struct passwd *pp ;

  {
  {
#line 75
  pp = & pw;
#line 76
  pp = getpwnam((char const   *)name);
#line 77
  endpwent();
  }
#line 78
  if (! pp) {
#line 79
    return;
  }
  {
#line 80
  clearuserdata(dest);
#line 81
  (*dest)->name = name;
#line 82
  (*dest)->uid = pp->pw_uid;
#line 83
  (*dest)->gid = pp->pw_gid;
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void clearuserdata(struct userdata **dest ) 
{ 


  {
#line 87
  if (! *dest) {
#line 88
    return;
  }
#line 89
  if ((*dest)->name) {
    {
#line 90
    free((void *)(*dest)->name);
    }
  }
  {
#line 91
  memset((void *)*dest, 0, sizeof(*(*dest)));
#line 92
  (*dest)->uid = (uid_t )-1;
#line 93
  (*dest)->gid = (gid_t )-1;
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void newuserdata(struct userdata **dest ) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
#line 97
  if (! *dest) {
    {
#line 98
    tmp = malloc(sizeof(*(*dest)));
#line 98
    *dest = (struct userdata *)tmp;
    }
  }
#line 99
  if (! *dest) {
    {
#line 100
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 100
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 101
  memset((void *)*dest, 0, sizeof(*(*dest)));
#line 102
  (*dest)->uid = (uid_t )-1;
#line 103
  (*dest)->gid = (gid_t )-1;
  }
#line 104
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/data.c"
void userdata_copy(struct userdata **to , struct userdata *from ) 
{ 
  char *tmp ;

  {
#line 107
  if (! from) {
#line 108
    return;
  }
  {
#line 109
  newuserdata(to);
#line 110
  memcpy((void */* __restrict  */)*to, (void const   */* __restrict  */)from, sizeof(*(*to)));
  }
#line 111
  if (from->name) {
    {
#line 111
    tmp = strdup((char const   *)from->name);
#line 111
    (*to)->name = tmp;
    }
  } else {
#line 111
    (*to)->name = (char *)((void *)0);
  }
#line 112
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 264
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 16 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.h"
void loglist_build(struct rl_instance *inst , struct loglist *l ) ;
#line 17
void string_build(struct rl_instance *inst , struct argvtab *a ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
struct iovec *iov_build(struct rl_instance *inst , struct argvtab *a ) ;
#line 44
char **argv_build(struct rl_instance *i , struct argvtab *a ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
static void loglist_walk(struct rl_instance *inst , struct loglist *l , int c ) 
{ 
  int i ;

  {
#line 22
  i = 0;
  {
#line 22
  while (1) {
    while_continue: /* CIL Label */ ;
#line 22
    if (! (i < c)) {
#line 22
      goto while_break;
    }
    {
#line 23
    loglist_build(inst, l + i);
#line 22
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  return;
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
static void string_populate(struct argvtab *a ) 
{ 
  int i ;
  int len ;
  void *tmp ;
  char *tmp___0 ;

  {
#line 29
  len = 0;
#line 29
  i = 0;
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
#line 29
    if (! (i < a->argc)) {
#line 29
      goto while_break;
    }
#line 30
    len += (a->ents + i)->len;
#line 29
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 31
  tmp = malloc((size_t )(len + 1));
#line 31
  a->str = (char *)tmp;
  }
#line 32
  if (! a->str) {
    {
#line 33
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 33
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
#line 34
  return;
}
}
#line 36 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
void string_build(struct rl_instance *inst , struct argvtab *a ) 
{ 
  int i ;

  {
#line 39
  if (! a->str) {
    {
#line 40
    string_populate(a);
    }
  }
#line 41
  *(a->str + 0) = (char )'\000';
#line 42
  i = 0;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! (i < a->argc)) {
#line 42
      goto while_break;
    }
    {
#line 43
    loglist_build(inst, a->ents + i);
#line 44
    strncat((char */* __restrict  */)a->str, (char const   */* __restrict  */)(a->ents + i)->arg,
            (size_t )(a->ents + i)->len);
#line 42
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  return;
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
static void argv_populate(struct argvtab *a ) 
{ 
  int i ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 51
  tmp = calloc((size_t )(a->argc + 1), sizeof(char *));
#line 51
  a->argv = (char **)tmp;
  }
#line 52
  if (! a->argv) {
    {
#line 53
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 53
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
#line 54
  i = 0;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    if (! (i < a->argc)) {
#line 54
      goto while_break;
    }
#line 55
    *(a->argv + i) = (a->ents + i)->arg;
#line 54
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  *(a->argv + i) = (char *)((void *)0);
#line 57
  return;
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
char **argv_build(struct rl_instance *i , struct argvtab *a ) 
{ 


  {
#line 60
  if (! a->argv) {
    {
#line 61
    argv_populate(a);
    }
  }
  {
#line 62
  loglist_walk(i, a->ents, a->argc);
  }
#line 63
  return (a->argv);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
static void iov_populate(struct argvtab *a ) 
{ 
  int i ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 69
  tmp = calloc((size_t )a->argc, sizeof(struct iovec ));
#line 69
  a->iov = (struct iovec *)tmp;
  }
#line 70
  if (! a->iov) {
    {
#line 71
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 71
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
#line 72
  i = 0;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
#line 72
    if (! (i < a->argc)) {
#line 72
      goto while_break;
    }
#line 73
    (a->iov + i)->iov_base = (void *)(a->ents + i)->arg;
#line 72
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 74
  return;
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
struct iovec *iov_build(struct rl_instance *inst , struct argvtab *a ) 
{ 
  int i ;

  {
#line 79
  if (! a->iov) {
    {
#line 80
    iov_populate(a);
    }
  }
#line 81
  i = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (i < a->argc)) {
#line 81
      goto while_break;
    }
    {
#line 82
    loglist_build(inst, a->ents + i);
#line 83
    (a->iov + i)->iov_len = (size_t )(a->ents + i)->len;
#line 81
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 85
  return (a->iov);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/strings.c"
void loglist_build(struct rl_instance *inst , struct loglist *l ) 
{ 
  time_t tt ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  uint16_t tmp___2 ;
  union __anonunion_75 __constr_expr_0 ;
  union __anonunion_76 __constr_expr_1 ;
  union __anonunion_77 __constr_expr_2 ;
  union __anonunion_78 __constr_expr_3 ;
  time_t tmp___3 ;
  uint32_t tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 92
  if (l->type == 0) {
#line 92
    goto case_0;
  }
#line 94
  if (l->type == 1) {
#line 94
    goto case_1;
  }
#line 114
  if (l->type == 2) {
#line 114
    goto case_2;
  }
#line 122
  if (l->type == 3) {
#line 122
    goto case_3;
  }
#line 128
  if (l->type == 4) {
#line 128
    goto case_4;
  }
#line 133
  if (l->type == 5) {
#line 133
    goto case_5;
  }
#line 138
  if (l->type == 6) {
#line 138
    goto case_6;
  }
#line 143
  if (l->type == 7) {
#line 143
    goto case_7;
  }
#line 148
  if (l->type == 8) {
#line 148
    goto case_8;
  }
#line 153
  if (l->type == 9) {
#line 153
    goto case_9;
  }
#line 158
  if (l->type == 10) {
#line 158
    goto case_10;
  }
#line 163
  if (l->type == 11) {
#line 163
    goto case_11;
  }
#line 168
  if (l->type == 12) {
#line 168
    goto case_12;
  }
#line 173
  if (l->type == 13) {
#line 173
    goto case_13;
  }
#line 178
  if (l->type == 14) {
#line 178
    goto case_14;
  }
#line 183
  if (l->type == 15) {
#line 183
    goto case_15;
  }
#line 188
  if (l->type == 16) {
#line 188
    goto case_16;
  }
#line 193
  if (l->type == 17) {
#line 193
    goto case_17;
  }
#line 198
  if (l->type == 18) {
#line 198
    goto case_18;
  }
#line 203
  if (l->type == 19) {
#line 203
    goto case_19;
  }
#line 208
  if (l->type == 20) {
#line 208
    goto case_20;
  }
#line 222
  if (l->type == 21) {
#line 222
    goto case_21;
  }
#line 229
  if (l->type == 22) {
#line 229
    goto case_22;
  }
#line 235
  if (l->type == 23) {
#line 235
    goto case_23;
  }
#line 240
  goto switch_default;
  case_0: /* CIL Label */ 
#line 93
  return;
  case_1: /* CIL Label */ 
#line 95
  if (! inst->sin) {
    {
#line 96
    strcpy((char */* __restrict  */)l->arg, (char const   */* __restrict  */)"<unknown>");
#line 97
    tmp = strlen((char const   *)l->arg);
#line 97
    l->len = (int )tmp;
    }
#line 98
    return;
  }
#line 101
  if ((int )((struct sockaddr_in *)inst->sin)->sin_family == 2) {
    {
#line 102
    inet_ntop(2, (void const   */* __restrict  */)(& ((struct sockaddr_in *)inst->sin)->sin_addr),
              (char */* __restrict  */)l->arg, (socklen_t )80);
    }
  } else {
    {
#line 106
    inet_ntop(10, (void const   */* __restrict  */)(& ((struct sockaddr_in6 *)inst->sin)->sin6_addr),
              (char */* __restrict  */)l->arg, (socklen_t )80);
    }
  }
  {
#line 112
  tmp___0 = strlen((char const   *)l->arg);
#line 112
  l->len = (int )tmp___0;
  }
#line 113
  return;
  case_2: /* CIL Label */ 
#line 115
  if (! inst->sin) {
    {
#line 116
    strcpy((char */* __restrict  */)l->arg, (char const   */* __restrict  */)"<unknown>");
#line 117
    tmp___1 = strlen((char const   *)l->arg);
#line 117
    l->len = (int )tmp___1;
    }
#line 118
    return;
  }
  {
#line 120
  tmp___2 = ntohs(((struct sockaddr_in *)inst->sin)->sin_port);
#line 120
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )6, (char const   */* __restrict  */)"%d",
                    (int )tmp___2);
  }
#line 121
  return;
  case_3: /* CIL Label */ 
  {
#line 123
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.ru_utime.tv_sec + inst->rusage.ru_stime.tv_sec);
  }
#line 127
  return;
  case_4: /* CIL Label */ 
  {
#line 129
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.ru_utime.tv_sec);
  }
#line 132
  return;
  case_5: /* CIL Label */ 
  {
#line 134
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.ru_stime.tv_sec);
  }
#line 137
  return;
  case_6: /* CIL Label */ 
  {
#line 139
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField2.ru_maxrss);
  }
#line 142
  return;
  case_7: /* CIL Label */ 
  {
#line 144
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField3.ru_ixrss);
  }
#line 147
  return;
  case_8: /* CIL Label */ 
  {
#line 149
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField4.ru_idrss);
  }
#line 152
  return;
  case_9: /* CIL Label */ 
  {
#line 154
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField5.ru_isrss);
  }
#line 157
  return;
  case_10: /* CIL Label */ 
  {
#line 159
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField6.ru_minflt);
  }
#line 162
  return;
  case_11: /* CIL Label */ 
  {
#line 164
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField7.ru_majflt);
  }
#line 167
  return;
  case_12: /* CIL Label */ 
  {
#line 169
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField8.ru_nswap);
  }
#line 172
  return;
  case_13: /* CIL Label */ 
  {
#line 174
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField9.ru_inblock);
  }
#line 177
  return;
  case_14: /* CIL Label */ 
  {
#line 179
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField10.ru_oublock);
  }
#line 182
  return;
  case_15: /* CIL Label */ 
  {
#line 184
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField11.ru_msgsnd);
  }
#line 187
  return;
  case_16: /* CIL Label */ 
  {
#line 189
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField12.ru_msgrcv);
  }
#line 192
  return;
  case_17: /* CIL Label */ 
  {
#line 194
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField13.ru_nsignals);
  }
#line 197
  return;
  case_18: /* CIL Label */ 
  {
#line 199
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField14.ru_nvcsw);
  }
#line 202
  return;
  case_19: /* CIL Label */ 
  {
#line 204
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld",
                    inst->rusage.__annonCompField15.ru_nivcsw);
  }
#line 207
  return;
  case_20: /* CIL Label */ 
#line 209
  __constr_expr_1.__in = inst->status;
#line 209
  if ((__constr_expr_1.__i & 127) == 0) {
    {
#line 210
    __constr_expr_0.__in = inst->status;
#line 210
    l->len = snprintf((char */* __restrict  */)l->arg, (size_t )6, (char const   */* __restrict  */)"%d",
                      (__constr_expr_0.__i & 65280) >> 8);
    }
#line 213
    return;
  }
#line 215
  __constr_expr_3.__in = inst->status;
#line 215
  if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
    {
#line 216
    __constr_expr_2.__in = inst->status;
#line 216
    l->len = snprintf((char */* __restrict  */)l->arg, (size_t )6, (char const   */* __restrict  */)"SIG%d",
                      __constr_expr_2.__i & 127);
    }
#line 219
    return;
  }
#line 221
  return;
  case_21: /* CIL Label */ 
  {
#line 223
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )10, (char const   */* __restrict  */)"%ld:%02ld:%02ld",
                    (inst->stop - (time_t volatile   )inst->start) / (time_t volatile   )3600,
                    ((inst->stop - (time_t volatile   )inst->start) % (long volatile   )3600) / (long volatile   )60,
                    (inst->stop - (time_t volatile   )inst->start) % (long volatile   )60);
  }
#line 228
  return;
  case_22: /* CIL Label */ 
  {
#line 230
  tmp___3 = time((time_t *)((void *)0));
#line 230
  tmp___4 = htonl((uint32_t )((unsigned long )tmp___3 + 2208988800UL));
#line 230
  tt = (time_t )tmp___4;
#line 232
  l->len = (int )sizeof(tt);
#line 233
  memcpy((void */* __restrict  */)l->arg, (void const   */* __restrict  */)(& tt),
         sizeof(tt));
  }
#line 234
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 236
  tt = time((time_t *)((void *)0));
#line 237
  tmp___5 = ctime((time_t const   *)(& tt));
#line 237
  l->len = snprintf((char */* __restrict  */)l->arg, (size_t )34, (char const   */* __restrict  */)"%s",
                    tmp___5);
  }
#line 239
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 241
  tmp___6 = gettext("Unknown log request");
#line 241
  rl_fatal(70, (char const   *)tmp___6);
  }
  switch_break: /* CIL Label */ ;
  }
#line 243
  return;
}
}
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/buffer.h"
int rlbuf_read(int sock , struct rl_buffer *buf ) ;
#line 11
int rlbuf_write(int sock , struct rl_buffer *buf ) ;
#line 12
int rlbuf_copy(int sock , struct rl_buffer *buf , int offset ) ;
#line 13
void rlbuf_init(struct rl_buffer **buf , int size ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/buffer.c"
static int do_read(int sock , void *buf , int len ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 14
  tmp = read(sock, buf, (size_t )len);
#line 14
  err = (int )tmp;
  }
#line 15
  if (err == -1) {
    {
#line 16
    tmp___0 = __errno_location();
    }
    {
#line 17
    if (*tmp___0 == 11) {
#line 17
      goto case_11;
    }
#line 20
    goto switch_default;
    case_11: /* CIL Label */ 
#line 18
    return (0);
#line 19
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 21
    tmp___1 = __errno_location();
#line 21
    tmp___2 = strerror(*tmp___1);
#line 21
    tmp___3 = __errno_location();
#line 21
    rl_warn("read(%d, %p, %d): %d (%s)", sock, buf, len, *tmp___3, tmp___2);
    }
#line 23
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 26
  return (err);
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/buffer.c"
int rlbuf_read(int sock , struct rl_buffer *buf ) 
{ 
  int done ;
  int err ;
  int size ;
  char *tmp ;

  {
#line 32
  if (! buf) {
    {
#line 33
    tmp = gettext("%s called with NULL buf");
#line 33
    rl_warn((char const   *)tmp, "rlbuf_read");
    }
#line 34
    return (0);
  }
#line 36
  done = 0;
#line 37
  err = 0;
#line 38
  if (buf->head >= buf->tail) {
#line 39
    size = (buf->size - buf->head) - ! buf->tail;
#line 40
    if (size) {
      {
#line 41
      err = do_read(sock, (void *)(buf->data + buf->head), size);
      }
#line 41
      if (err < 0) {
#line 42
        return (err);
      }
#line 43
      buf->head += err;
#line 44
      done += err;
#line 45
      if (err < size) {
#line 46
        return (err);
      }
#line 47
      if (buf->tail) {
#line 48
        buf->head = 0;
      }
    }
  }
#line 51
  if (buf->tail) {
#line 51
    if (buf->head < buf->tail) {
#line 52
      size = buf->tail - 1;
#line 53
      if (size) {
        {
#line 54
        err = do_read(sock, (void *)buf->data, size);
        }
#line 55
        if (err < 0) {
#line 56
          err = 0;
        }
#line 57
        buf->head += err;
#line 58
        done += err;
      }
    }
  }
#line 61
  return (done);
}
}
#line 64 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/buffer.c"
static int do_write(int sock , void *buf , int len ) 
{ 
  int err ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;

  {
  {
#line 67
  tmp = write(sock, (void const   *)buf, (size_t )len);
#line 67
  err = (int )tmp;
  }
#line 68
  if (err == -1) {
    {
#line 69
    tmp___0 = __errno_location();
    }
    {
#line 70
    if (*tmp___0 == 11) {
#line 70
      goto case_11;
    }
#line 76
    if (*tmp___0 == 32) {
#line 76
      goto case_32;
    }
#line 73
    goto switch_default;
    case_11: /* CIL Label */ 
#line 71
    return (0);
#line 72
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 74
    tmp___1 = __errno_location();
#line 74
    tmp___2 = strerror(*tmp___1);
#line 74
    tmp___3 = __errno_location();
#line 74
    rl_warn("write(%d, %p, %d): %d (%s)", sock, buf, len, *tmp___3, tmp___2);
    }
    case_32: /* CIL Label */ 
#line 77
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 80
  return (err);
}
}
#line 83 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/buffer.c"
int rlbuf_write(int sock , struct rl_buffer *buf ) 
{ 
  int done ;
  int err ;
  int size ;
  char *tmp ;

  {
#line 86
  if (! buf) {
    {
#line 87
    tmp = gettext("%s called with NULL buf");
#line 87
    rl_warn((char const   *)tmp, "rlbuf_write");
    }
#line 88
    return (0);
  }
#line 90
  done = 0;
#line 91
  err = 0;
#line 92
  if (buf->head == buf->tail) {
#line 93
    return (0);
  }
#line 94
  if (buf->head > buf->tail) {
#line 95
    size = buf->head - buf->tail;
  } else {
#line 97
    size = buf->size - buf->tail;
  }
#line 98
  if (size) {
    {
#line 99
    err = do_write(sock, (void *)(buf->data + buf->tail), size);
    }
#line 99
    if (err < 0) {
#line 100
      return (err);
    }
#line 101
    buf->tail += err;
#line 102
    done += err;
#line 103
    if (err < size) {
#line 104
      return (err);
    }
#line 105
    if (buf->tail == buf->size) {
#line 106
      buf->tail = 0;
    }
  }
#line 108
  if (buf->tail < buf->head) {
    {
#line 109
    size = buf->head - buf->tail;
#line 110
    err = do_write(sock, (void *)(buf->data + buf->tail), size);
    }
#line 111
    if (err < 0) {
#line 112
      err = 0;
    }
#line 113
    buf->tail += err;
#line 114
    done += err;
  }
#line 116
  return (done);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/buffer.c"
int rlbuf_copy(int sock , struct rl_buffer *buf , int offset ) 
{ 
  int done ;
  int err ;
  int size ;
  char *tmp ;

  {
#line 122
  if (! buf) {
    {
#line 123
    tmp = gettext("%s called with NULL buf");
#line 123
    rl_warn((char const   *)tmp, "rlbuf_copy");
    }
#line 124
    return (0);
  }
#line 126
  done = 0;
#line 127
  err = 0;
#line 128
  if (buf->head == buf->tail) {
#line 129
    return (0);
  }
#line 130
  if (buf->head > buf->tail) {
#line 131
    size = buf->head - buf->tail;
  } else {
#line 133
    size = buf->size - buf->tail;
  }
#line 134
  if (size <= offset) {
#line 135
    offset -= size;
#line 136
    size = 0;
  }
#line 138
  if (size) {
    {
#line 139
    err = do_write(sock, (void *)((buf->data + buf->tail) + offset), size);
    }
#line 139
    if (err < 0) {
#line 140
      return (err);
    }
#line 141
    done += err;
#line 142
    if (err < size) {
#line 143
      return (err);
    }
  }
#line 145
  offset -= done;
#line 146
  if (offset < 0) {
#line 147
    offset = 0;
  }
#line 148
  if (buf->tail > buf->head) {
#line 149
    size = buf->head - offset;
#line 150
    if (size <= 0) {
#line 151
      return (0);
    }
    {
#line 152
    err = do_write(sock, (void *)(buf->data + offset), size);
    }
#line 153
    if (err < 0) {
#line 154
      err = 0;
    }
#line 155
    done += err;
  }
#line 157
  return (done);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/buffer.c"
void rlbuf_init(struct rl_buffer **buf , int size ) 
{ 
  void *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 161
  if (! *buf) {
    {
#line 162
    tmp = malloc(sizeof(*(*buf)));
#line 162
    *buf = (struct rl_buffer *)tmp;
    }
#line 163
    if (! *buf) {
      {
#line 164
      tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 164
      rl_fatal(70, (char const   *)tmp___0);
      }
    }
    {
#line 165
    memset((void *)*buf, 0, sizeof(*(*buf)));
    }
  } else {
#line 167
    tmp___1 = 0;
#line 167
    (*buf)->tail = tmp___1;
#line 167
    (*buf)->head = tmp___1;
  }
#line 169
  if ((*buf)->data) {
    {
#line 170
    free((void *)(*buf)->data);
#line 171
    (*buf)->data = (char *)((void *)0);
    }
  }
#line 173
  if (size) {
    {
#line 174
    (*buf)->size = size;
#line 175
    tmp___2 = malloc((size_t )size);
#line 175
    (*buf)->data = (char *)tmp___2;
    }
#line 176
    if (! (*buf)->data) {
      {
#line 177
      tmp___3 = gettext("ABORT - Can\'t allocate memory");
#line 177
      rl_fatal(70, (char const   *)tmp___3);
      }
    }
  }
#line 179
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.h"
void pidtab_add(pid_t pid , int onexit , struct rl_instance *inst ) ;
#line 36
struct pidtab *pidtab_get(pid_t pid ) ;
#line 38
struct logtab *logtab_get(int i ) ;
#line 40
struct rlimit *rlimittab_get(int i ) ;
#line 42
struct argvtab *argvtab_get(int i ) ;
#line 54
char *stringtab_get(int i ) ;
#line 101
struct buftab *buftab_get(int i ) ;
#line 132
struct semaphore *semaphore_get(int i ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct argvtab *argvs  =    (struct argvtab *)((void *)0);
#line 23 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
int numargvs  =    0;
#line 25 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct rlimit *rlimits  =    (struct rlimit *)((void *)0);
#line 26 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
int numrlimits  =    0;
#line 28 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct logtab *logtabs  =    (struct logtab *)((void *)0);
#line 29 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
int numlogtabs  =    0;
#line 31 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
char **strings  =    (char **)((void *)0);
#line 32 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
int numstrings  =    0;
#line 34 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct buftab *bufs  =    (struct buftab *)((void *)0);
#line 35 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
int numbufs  =    0;
#line 37 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct oplist *oplists  =    (struct oplist *)((void *)0);
#line 38 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
int numoplists  =    0;
#line 40 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct pidtab pidtabs[8]  = 
#line 40
  {      {0, (struct pidtab *)((void *)0), (struct pidtab *)((void *)0), (struct pidtab *)((void *)0),
      0, (struct rl_instance *)((void *)0)}, 
        {0, (struct pidtab *)((void *)0), (struct pidtab *)((void *)0), (struct pidtab *)((void *)0),
      0, (struct rl_instance *)((void *)0)}, 
        {0, (struct pidtab *)((void *)0), (struct pidtab *)((void *)0), (struct pidtab *)((void *)0),
      0, (struct rl_instance *)((void *)0)}, 
        {0, (struct pidtab *)((void *)0), (struct pidtab *)((void *)0), (struct pidtab *)((void *)0),
      0, (struct rl_instance *)((void *)0)}, 
        {0, (struct pidtab *)((void *)0), (struct pidtab *)((void *)0), (struct pidtab *)((void *)0),
      0, (struct rl_instance *)((void *)0)}, 
        {0, (struct pidtab *)((void *)0), (struct pidtab *)((void *)0), (struct pidtab *)((void *)0),
      0, (struct rl_instance *)((void *)0)}, 
        {0, (struct pidtab *)((void *)0), (struct pidtab *)((void *)0), (struct pidtab *)((void *)0),
      0, (struct rl_instance *)((void *)0)}, 
        {0, (struct pidtab *)((void *)0), (struct pidtab *)((void *)0), (struct pidtab *)((void *)0),
      0, (struct rl_instance *)((void *)0)}};
#line 51 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct semaphore *sems  =    (struct semaphore *)((void *)0);
#line 52 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
int numsems  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
fd_set *fdsets  =    (fd_set *)((void *)0);
#line 60 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
int numfdsets  =    0;
#line 63 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
static struct pidtab *pidtab_new(void) 
{ 
  struct pidtab *p ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 66
  tmp = malloc(sizeof(struct pidtab ));
#line 66
  p = (struct pidtab *)tmp;
  }
#line 67
  if (! p) {
    {
#line 68
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 68
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 69
  memset((void *)p, 0, sizeof(struct pidtab ));
  }
#line 70
  return (p);
}
}
#line 73 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
void pidtab_add(pid_t pid , int onexit , struct rl_instance *inst ) 
{ 
  struct pidtab *p ;
  struct pidtab *tmp ;

  {
  {
#line 74
  tmp = pidtab_new();
#line 74
  p = tmp;
#line 75
  p->pid = pid;
#line 76
  p->inst = inst;
#line 77
  p->onexit = onexit;
#line 78
  p->prev = pidtabs + (pid & 7);
#line 79
  p->next = (p->prev)->next;
#line 80
  (p->prev)->next = p;
  }
#line 81
  if (p->next) {
#line 82
    (p->next)->prev = p;
  }
#line 83
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct pidtab *pidtab_get(pid_t pid ) 
{ 
  struct pidtab *p ;

  {
#line 98
  p = pidtabs[pid & 7].next;
#line 99
  if (! p) {
#line 100
    return ((struct pidtab *)((void *)0));
  }
  {
#line 101
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (p->pid == pid) {
#line 103
      return (p);
    }
#line 101
    p = p->next;
#line 101
    if (! p) {
#line 101
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 106
  return ((struct pidtab *)((void *)0));
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct logtab *logtab_get(int i ) 
{ 


  {
#line 111
  return (logtabs + i);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct rlimit *rlimittab_get(int i ) 
{ 


  {
#line 116
  return (rlimits + i);
}
}
#line 119 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct argvtab *argvtab_get(int i ) 
{ 


  {
#line 121
  return (argvs + i);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
char *stringtab_get(int i ) 
{ 


  {
#line 135
  return (*(strings + i));
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct buftab *buftab_get(int i ) 
{ 


  {
#line 140
  return (bufs + i);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
rl_opcode_t *oplisttab_get(int i ) 
{ 


  {
#line 145
  return ((oplists + i)->ops_list);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
struct semaphore *semaphore_get(int i ) 
{ 


  {
#line 150
  return (sems + i);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/db.c"
fd_set *fdsettab_get(int i ) 
{ 


  {
#line 155
  return (fdsets + i);
}
}
#line 56 "/usr/include/dlfcn.h"
extern  __attribute__((__nothrow__)) void *dlopen(char const   *__file , int __mode ) ;
#line 60
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) dlclose)(void *__handle ) ;
#line 64
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(2), __leaf__)) dlsym)(void * __restrict  __handle ,
                                                                                              char const   * __restrict  __name ) ;
#line 82
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) dlerror)(void) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 94 "/usr/include/malloc.h"
extern  __attribute__((__nothrow__)) struct mallinfo ( __attribute__((__leaf__)) mallinfo)(void) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/rlinetd.h"
void run_bytecode(rl_opcode_t *op , struct rl_instance *inst ) ;
#line 53
void read_unhook(int fd ) ;
#line 54
void write_hook(int fd , rl_opcode_t *op , struct rl_instance *inst ) ;
#line 55
void write_unhook(int fd ) ;
#line 58
void listeners_clear(int j ) ;
#line 59
void listeners_set(int j ) ;
#line 4 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.h"
void main_loop(void) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.h"
void rls_block(void) ;
#line 10
void rls_unblock(void) ;
#line 14
int volatile   rls_need_parse ;
#line 15
int volatile   rls_term_recv ;
#line 16
struct pidtab * volatile  rls_reaped ;
#line 30 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
struct rl_cleanup *rl_cleanups  =    (struct rl_cleanup *)((void *)0);
#line 31 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
int hisock  ;
#line 32
char const   *rl_parser ;
#line 33 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
struct pidtab *rl_pending  ;
#line 34
struct rl_instance *inst_new(void) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
fd_set rfds  ;
#line 41 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
fd_set wfds  ;
#line 42 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
struct fd_ops *rfd_ops  =    (struct fd_ops *)((void *)0);
#line 42 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
struct fd_ops *wfd_ops  =    (struct fd_ops *)((void *)0);
#line 43 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
int rfd_len  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
int wfd_len  =    0;
#line 46 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
static void run_library_func(char const   * const  funcname ) 
{ 
  int i ;
  void *handle ;
  void (*libfunc)(void) ;
  int bound ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 51
  handle = dlopen((char const   *)rl_parser, 258);
  }
#line 51
  if (handle) {
    {
#line 56
    tmp___1 = dlsym((void */* __restrict  */)handle, (char const   */* __restrict  */)funcname);
#line 56
    libfunc = (void (*)(void))tmp___1;
    }
#line 56
    if (libfunc) {
      {
#line 59
      closelog();
#line 60
      i = 3;
#line 61
      bound = 1024;
      }
      {
#line 62
      while (1) {
        while_continue: /* CIL Label */ ;
#line 62
        if (! (i < bound)) {
#line 62
          goto while_break;
        }
        {
#line 63
        close(i);
#line 62
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 64
      (*libfunc)();
      }
    } else {
      {
#line 66
      tmp = dlerror();
#line 66
      tmp___0 = gettext("ABORT - failed to find function \"%s\" in parser module %s (%s)");
#line 66
      rl_fatal(70, (char const   *)tmp___0, funcname, rl_parser, tmp);
      }
    }
  } else {
    {
#line 70
    tmp___2 = dlerror();
#line 70
    tmp___3 = gettext("ABORT - failed to load parser module %s (%s)");
#line 70
    rl_fatal(70, (char const   *)tmp___3, rl_parser, tmp___2);
    }
  }
  {
#line 73
  dlclose(handle);
  }
#line 74
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
static long oldmem  ;
#line 76 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void main_loop(void) 
{ 
  fd_set srfds ;
  fd_set swfds ;
  int i ;
  int n ;
  struct mallinfo m ;
  char *tmp ;
  struct pidtab *p ;
  struct pidtab *p___0 ;
  rl_opcode_t *tmp___0 ;
  int *tmp___1 ;
  int *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  struct rl_instance *grr ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (rls_term_recv) {
      {
#line 87
      run_library_func((char const   */* const  */)"services_free");
      }
#line 88
      return;
    }
#line 91
    if (rls_need_parse) {
#line 91
      goto _L;
    } else
#line 91
    if (rls_reaped) {
      _L: /* CIL Label */ 
      {
#line 92
      rls_block();
      }
#line 93
      if (rls_need_parse) {
        {
#line 95
        m = mallinfo();
#line 97
        run_library_func((char const   */* const  */)"parse");
#line 98
        rls_need_parse = (int volatile   )0;
#line 100
        m = mallinfo();
#line 101
        tmp = gettext("rlinetd configuration (re)loaded, %ld bytes used\n");
#line 101
        rl_warn((char const   *)tmp, (long )m.uordblks - oldmem);
#line 103
        oldmem = (long )m.uordblks;
        }
      }
#line 108
      if (rls_reaped) {
#line 111
        rl_pending = (struct pidtab *)rls_reaped;
#line 112
        rls_reaped = (struct pidtab */* volatile  */)((void *)0);
#line 113
        p = rl_pending;
        {
#line 114
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 115
          if (p->next) {
#line 116
            (p->next)->prev = p->prev;
          }
#line 117
          if (p->prev) {
#line 118
            (p->prev)->next = p->next;
          }
#line 119
          p->next = (struct pidtab *)((void *)0);
#line 120
          p->prev = (struct pidtab *)((void *)0);
#line 114
          p = p->next_cleanup;
#line 114
          if (! p) {
#line 114
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
      }
      {
#line 123
      rls_unblock();
      }
    }
    {
#line 126
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 126
      if (! rl_pending) {
#line 126
        goto while_break___1;
      }
      {
#line 129
      tmp___0 = oplisttab_get(rl_pending->onexit);
#line 129
      run_bytecode(tmp___0, rl_pending->inst);
      }
#line 130
      if (rl_pending->inst) {
        {
#line 131
        inst_free(rl_pending->inst);
        }
      }
      {
#line 132
      p___0 = rl_pending->next_cleanup;
#line 133
      free((void *)rl_pending);
#line 134
      rl_pending = p___0;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 136
    srfds = rfds;
#line 137
    swfds = wfds;
#line 138
    n = select(hisock + 1, (fd_set */* __restrict  */)(& srfds), (fd_set */* __restrict  */)(& swfds),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 138
    if (n < 0) {
      {
#line 139
      tmp___1 = __errno_location();
      }
      {
#line 140
      if (*tmp___1 == 4) {
#line 140
        goto case_4;
      }
#line 142
      goto switch_default;
      case_4: /* CIL Label */ 
#line 141
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 143
      tmp___2 = __errno_location();
#line 143
      tmp___3 = strerror(*tmp___2);
#line 143
      tmp___4 = gettext("select() failed - %s");
#line 143
      rl_warn((char const   *)tmp___4, tmp___3);
      }
#line 144
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 146
      goto __Cont;
    }
#line 148
    if (! n) {
#line 149
      goto __Cont;
    }
#line 150
    i = 0;
    {
#line 150
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 150
      if (! (i <= hisock)) {
#line 150
        goto while_break___2;
      }
#line 151
      if ((srfds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 151
        if ((rfds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 154
          grr = (rfd_ops + i)->inst;
#line 155
          if (! (rfd_ops + i)->inst) {
            {
#line 156
            grr = inst_new();
#line 157
            grr->sock = i;
            }
          }
          {
#line 159
          run_bytecode((rfd_ops + i)->op, grr);
          }
        }
      }
#line 161
      if ((swfds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 161
        if ((wfds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 162
          run_bytecode((wfd_ops + i)->op, (wfd_ops + i)->inst);
          }
        }
      }
#line 150
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 167 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void listeners_set(int j ) 
{ 
  fd_set *fds ;
  int i ;

  {
  {
#line 171
  fds = fdsettab_get(j);
#line 172
  i = 0;
  }
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (i < 1024)) {
#line 172
      goto while_break;
    }
#line 173
    if ((fds->__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 174
      rfds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] |= 1L << i % (8 * (int )sizeof(__fd_mask ));
    }
#line 172
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void listeners_clear(int j ) 
{ 
  fd_set *fds ;
  int i ;

  {
  {
#line 181
  fds = fdsettab_get(j);
#line 182
  i = 0;
  }
  {
#line 182
  while (1) {
    while_continue: /* CIL Label */ ;
#line 182
    if (! (i < 1024)) {
#line 182
      goto while_break;
    }
#line 183
    if ((fds->__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] & (1L << i % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 184
      rfds.__fds_bits[i / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << i % (8 * (int )sizeof(__fd_mask )));
    }
#line 182
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 185
  return;
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
static void fdops_grow(struct fd_ops **ops , int *len , int new ) 
{ 
  void *tmp ;
  char *tmp___0 ;

  {
#line 189
  if (new < *len) {
#line 190
    return;
  }
  {
#line 191
  tmp = realloc((void *)*ops, (unsigned long )(new + 1) * sizeof(*(*ops)));
#line 191
  *ops = (struct fd_ops *)tmp;
  }
#line 192
  if (! *ops) {
    {
#line 193
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 193
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
#line 194
  *len = new + 1;
#line 195
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void read_hook(int fd , rl_opcode_t *op , struct rl_instance *inst ) 
{ 


  {
  {
#line 198
  fdops_grow(& rfd_ops, & rfd_len, fd);
#line 199
  (rfd_ops + fd)->op = op;
#line 200
  (rfd_ops + fd)->inst = inst;
#line 201
  rfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  }
#line 202
  if (fd > hisock) {
#line 203
    hisock = fd;
  }
#line 204
  return;
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void read_unhook(int fd ) 
{ 


  {
  {
#line 207
  fdops_grow(& rfd_ops, & rfd_len, fd);
#line 208
  rfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 209
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void write_hook(int fd , rl_opcode_t *op , struct rl_instance *inst ) 
{ 


  {
  {
#line 212
  fdops_grow(& wfd_ops, & wfd_len, fd);
#line 213
  (wfd_ops + fd)->op = op;
#line 214
  (wfd_ops + fd)->inst = inst;
#line 215
  wfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd % (8 * (int )sizeof(__fd_mask ));
  }
#line 216
  if (fd > hisock) {
#line 217
    hisock = fd;
  }
#line 218
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void write_unhook(int fd ) 
{ 


  {
  {
#line 221
  fdops_grow(& wfd_ops, & wfd_len, fd);
#line 222
  wfds.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
  }
#line 223
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void all_unhook(void) 
{ 
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;

  {
#line 226
  if (rfd_ops) {
    {
#line 227
    free((void *)rfd_ops);
    }
  }
#line 228
  rfd_ops = (struct fd_ops *)((void *)0);
#line 229
  rfd_len = 0;
#line 230
  if (wfd_ops) {
    {
#line 231
    free((void *)wfd_ops);
    }
  }
#line 232
  wfd_ops = (struct fd_ops *)((void *)0);
#line 233
  wfd_len = 0;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 234
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfds.__fds_bits[0]): "memory");
#line 234
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 235
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 235
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& wfds.__fds_bits[0]): "memory");
#line 235
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 236
  return;
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
struct rl_instance *inst_new(void) 
{ 
  struct rl_instance *i ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 241
  tmp = malloc(sizeof(*i));
#line 241
  i = (struct rl_instance *)tmp;
  }
#line 242
  if (! i) {
    {
#line 243
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 243
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 244
  memset((void *)i, 0, sizeof(*i));
  }
#line 245
  return (i);
}
}
#line 248 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/engine.c"
void inst_free(struct rl_instance *i ) 
{ 


  {
#line 249
  if (i->sin) {
    {
#line 250
    free((void *)i->sin);
    }
  }
#line 251
  if (i->buf) {
#line 252
    if ((i->buf)->data) {
      {
#line 253
      free((void *)(i->buf)->data);
      }
    }
    {
#line 254
    free((void *)i->buf);
    }
  }
  {
#line 256
  free((void *)i);
  }
#line 257
  return;
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 162 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern  __attribute__((__nothrow__)) __pid_t wait3(union wait *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 8 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.h"
void rl_siginit(void) ;
#line 18 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
int volatile   rls_need_parse  =    (int volatile   )1;
#line 19 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
int volatile   rls_term_recv  =    (int volatile   )0;
#line 20 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
struct pidtab * volatile  rls_reaped  =    (struct pidtab */* volatile  */)((void *)0);
#line 21 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
static sigset_t rls_atomic  ;
#line 23
void rl_reap(int i  __attribute__((__unused__)) ) ;
#line 24
void rl_hup(int i  __attribute__((__unused__)) ) ;
#line 25
void rl_term(int i  __attribute__((__unused__)) ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
void rl_siginit(void) 
{ 
  struct sigaction sa ;
  char *tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 30
  sigemptyset(& rls_atomic);
#line 31
  sigaddset(& rls_atomic, 17);
#line 32
  sigaddset(& rls_atomic, 1);
#line 34
  sigemptyset(& sa.sa_mask);
#line 35
  sa.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 36
  tmp___0 = sigaction(13, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 36
  if (tmp___0) {
    {
#line 37
    tmp = gettext("ABORT - sigaction(%s) failed");
#line 37
    rl_fatal(71, (char const   *)tmp, "SIGPIPE");
    }
  }
  {
#line 39
  sa.__sigaction_handler.sa_handler = & rl_reap;
#line 40
  sa.sa_flags = 1;
#line 41
  tmp___2 = sigaction(17, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 41
  if (tmp___2) {
    {
#line 42
    tmp___1 = gettext("ABORT - sigaction(%s) failed");
#line 42
    rl_fatal(71, (char const   *)tmp___1, "SIGCHLD");
    }
  }
  {
#line 44
  sa.__sigaction_handler.sa_handler = & rl_hup;
#line 45
  tmp___4 = sigaction(1, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 45
  if (tmp___4) {
    {
#line 46
    tmp___3 = gettext("ABORT - sigaction(%s) failed");
#line 46
    rl_fatal(71, (char const   *)tmp___3, "SIGHUP");
    }
  }
  {
#line 48
  sa.__sigaction_handler.sa_handler = & rl_term;
#line 49
  tmp___6 = sigaction(15, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 49
  if (tmp___6) {
    {
#line 50
    tmp___5 = gettext("ABORT - sigaction(%s) failed");
#line 50
    rl_fatal(71, (char const   *)tmp___5, "SIGTERM");
    }
  }
  {
#line 52
  sa.__sigaction_handler.sa_handler = & rl_term;
#line 53
  tmp___8 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 53
  if (tmp___8) {
    {
#line 54
    tmp___7 = gettext("ABORT - sigaction(%s) failed");
#line 54
    rl_fatal(71, (char const   *)tmp___7, "SIGINT");
    }
  }
#line 56
  return;
}
}
#line 58 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
void rl_reap(int i  __attribute__((__unused__)) ) 
{ 
  int status ;
  pid_t pid ;
  struct rusage rusage ;
  struct pidtab *p ;
  int *tmp ;
  char *tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 64
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 65
    pid = wait3((union wait *)(& status), 1, & rusage);
    }
    {
#line 66
    if (pid == -1) {
#line 66
      goto case_neg_1;
    }
#line 76
    if (pid == 0) {
#line 76
      goto case_0;
    }
#line 78
    goto switch_default___0;
    case_neg_1: /* CIL Label */ 
    {
#line 67
    tmp = __errno_location();
    }
    {
#line 68
    if (*tmp == 10) {
#line 68
      goto case_10;
    }
#line 70
    if (*tmp == 4) {
#line 70
      goto case_4;
    }
#line 72
    goto switch_default;
    case_10: /* CIL Label */ 
#line 69
    return;
    case_4: /* CIL Label */ 
#line 71
    goto __Cont;
    switch_default: /* CIL Label */ 
    {
#line 73
    tmp___0 = gettext("wait3 failed");
#line 73
    rl_warn((char const   *)tmp___0);
    }
#line 74
    return;
    switch_break___0: /* CIL Label */ ;
    }
    case_0: /* CIL Label */ 
#line 77
    return;
    switch_default___0: /* CIL Label */ 
    {
#line 79
    p = pidtab_get(pid);
    }
#line 80
    if (! p) {
#line 81
      goto __Cont;
    }
#line 82
    p->next_cleanup = (struct pidtab *)rls_reaped;
#line 83
    rls_reaped = (struct pidtab */* volatile  */)p;
#line 84
    if (! p->inst) {
#line 85
      goto __Cont;
    }
    {
#line 86
    (p->inst)->status = status;
#line 87
    tmp___1 = time((time_t *)((void *)0));
#line 87
    (p->inst)->stop = (time_t volatile   )tmp___1;
#line 88
    memcpy((void */* __restrict  */)(& (p->inst)->rusage), (void const   */* __restrict  */)(& rusage),
           sizeof(rusage));
    }
#line 89
    goto __Cont;
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
void rl_hup(int i  __attribute__((__unused__)) ) 
{ 


  {
#line 95
  rls_need_parse = (int volatile   )1;
#line 96
  return;
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
void rl_term(int i  __attribute__((__unused__)) ) 
{ 


  {
#line 99
  rls_term_recv = (int volatile   )1;
#line 100
  return;
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
void rls_block(void) 
{ 


  {
  {
#line 104
  sigprocmask(0, (sigset_t const   */* __restrict  */)(& rls_atomic), (sigset_t */* __restrict  */)((void *)0));
  }
#line 105
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/signals.c"
void rls_unblock(void) 
{ 


  {
  {
#line 108
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& rls_atomic), (sigset_t */* __restrict  */)((void *)0));
  }
#line 109
  return;
}
}
#line 201 "/usr/include/grp.h"
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 190 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/uio.h"
extern ssize_t writev(int __fd , struct iovec  const  *__iovec , int __count ) ;
#line 243 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 69 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 97
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpriority)(__priority_which_t __which ,
                                                                                  id_t __who ,
                                                                                  int __prio ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 563
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execv)(char const   *__path ,
                                                                                              char * const  *__argv ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 944
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.h"
void rlstk_push(struct rl_stack *s , rl_opcode_t val ) ;
#line 12
rl_opcode_t rlstk_pop(struct rl_stack *s ) ;
#line 13
rl_opcode_t rlstk_peek(struct rl_stack *s , int offset ) ;
#line 14
void rlstk_poke(struct rl_stack *s , int offset , rl_opcode_t val ) ;
#line 48 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/bytecode.c"
int allow_severity  =    6;
#line 49 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/bytecode.c"
int deny_severity  =    4;
#line 56 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/bytecode.c"
void run_bytecode(rl_opcode_t *op , struct rl_instance *inst ) 
{ 
  __pid_t tmp ;
  struct argvtab *argv ;
  struct logtab *log ;
  int i ;
  int j ;
  int k ;
  char *str ;
  gid_t gid ;
  struct semaphore *sem ;
  struct buftab *bt ;
  char *tmp___0 ;
  pid_t ssid ;
  __pid_t tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  int *tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int *tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int *tmp___17 ;
  char *tmp___18 ;
  struct rlimit *tmp___19 ;
  int tmp___20 ;
  int *tmp___21 ;
  char *tmp___22 ;
  char *tmp___23 ;
  int tmp___24 ;
  int *tmp___25 ;
  char *tmp___26 ;
  char *tmp___27 ;
  int tmp___28 ;
  int *tmp___29 ;
  char *tmp___30 ;
  ssize_t tmp___31 ;
  void *tmp___32 ;
  char *tmp___33 ;
  int *tmp___34 ;
  char *tmp___35 ;
  int tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  int *tmp___40 ;
  char *tmp___41 ;
  char *tmp___42 ;
  rl_opcode_t tmp___43 ;
  rl_opcode_t *tmp___44 ;
  int *tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  int *tmp___48 ;
  char *tmp___49 ;
  int tmp___50 ;
  rl_opcode_t tmp___51 ;
  int tmp___52 ;
  int *tmp___53 ;
  char *tmp___54 ;
  ssize_t tmp___55 ;
  rl_opcode_t *tmp___56 ;
  int tmp___57 ;
  rl_opcode_t *tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  rl_opcode_t tmp___61 ;
  rl_opcode_t *tmp___62 ;
  rl_opcode_t tmp___63 ;
  rl_opcode_t tmp___64 ;
  rl_opcode_t tmp___65 ;
  rl_opcode_t tmp___66 ;
  rl_opcode_t tmp___67 ;
  rl_opcode_t tmp___68 ;
  int tmp___69 ;
  char *tmp___70 ;
  rl_opcode_t *tmp___71 ;

  {
#line 57
  if (! op) {
#line 58
    return;
  }
#line 59
  if (rl_debug > 1) {
    {
#line 60
    tmp = getpid();
#line 60
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sched(%d)\n",
            tmp);
    }
  }
  {
#line 61
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (rl_debug > 1) {
      {
#line 66
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"op %d\n",
              *op);
      }
    }
    {
#line 80
    if (*op == 1U) {
#line 80
      goto case_1;
    }
#line 106
    if (*op == 2U) {
#line 106
      goto case_2;
    }
#line 109
    if (*op == 3U) {
#line 109
      goto case_3;
    }
#line 115
    if (*op == 4U) {
#line 115
      goto case_4;
    }
#line 121
    if (*op == 5U) {
#line 121
      goto case_5;
    }
#line 127
    if (*op == 6U) {
#line 127
      goto case_6;
    }
#line 134
    if (*op == 8U) {
#line 134
      goto case_8;
    }
#line 142
    if (*op == 7U) {
#line 142
      goto case_7;
    }
#line 154
    if (*op == 9U) {
#line 154
      goto case_9;
    }
#line 175
    if (*op == 10U) {
#line 175
      goto case_10;
    }
#line 197
    if (*op == 11U) {
#line 197
      goto case_11;
    }
#line 229
    if (*op == 12U) {
#line 229
      goto case_12;
    }
#line 235
    if (*op == 13U) {
#line 235
      goto case_13;
    }
#line 243
    if (*op == 14U) {
#line 243
      goto case_14;
    }
#line 247
    if (*op == 15U) {
#line 247
      goto case_15;
    }
#line 252
    if (*op == 16U) {
#line 252
      goto case_16;
    }
#line 255
    if (*op == 17U) {
#line 255
      goto case_17;
    }
#line 258
    if (*op == 18U) {
#line 258
      goto case_18;
    }
#line 260
    if (*op == 19U) {
#line 260
      goto case_19;
    }
#line 263
    if (*op == 20U) {
#line 263
      goto case_20;
    }
#line 270
    if (*op == 21U) {
#line 270
      goto case_21;
    }
#line 275
    if (*op == 22U) {
#line 275
      goto case_22;
    }
#line 280
    if (*op == 23U) {
#line 280
      goto case_23;
    }
#line 283
    if (*op == 24U) {
#line 283
      goto case_24;
    }
#line 286
    if (*op == 25U) {
#line 286
      goto case_25;
    }
#line 289
    if (*op == 26U) {
#line 289
      goto case_26;
    }
#line 292
    if (*op == 27U) {
#line 292
      goto case_27;
    }
#line 295
    if (*op == 28U) {
#line 295
      goto case_28;
    }
#line 298
    if (*op == 29U) {
#line 298
      goto case_29;
    }
#line 302
    if (*op == 30U) {
#line 302
      goto case_30;
    }
#line 305
    if (*op == 31U) {
#line 305
      goto case_31;
    }
#line 309
    if (*op == 32U) {
#line 309
      goto case_32;
    }
#line 312
    if (*op == 33U) {
#line 312
      goto case_33;
    }
#line 318
    if (*op == 34U) {
#line 318
      goto case_34;
    }
#line 322
    if (*op == 35U) {
#line 322
      goto case_35;
    }
#line 328
    if (*op == 36U) {
#line 328
      goto case_36;
    }
#line 333
    if (*op == 37U) {
#line 333
      goto case_37;
    }
#line 338
    if (*op == 38U) {
#line 338
      goto case_38;
    }
#line 341
    if (*op == 39U) {
#line 341
      goto case_39;
    }
#line 344
    if (*op == 40U) {
#line 344
      goto case_40;
    }
#line 351
    if (*op == 41U) {
#line 351
      goto case_41;
    }
#line 355
    goto switch_default___0;
    case_1: /* CIL Label */ 
    {
#line 81
    closelog();
#line 82
    fcntl(inst->sock, 2, 0);
#line 83
    fcntl(inst->sock, 4, 0);
#line 84
    op ++;
#line 84
    j = (int )*op;
#line 85
    op ++;
#line 85
    argv = argvtab_get((int )*op);
#line 86
    argv_build(inst, argv);
    }
#line 87
    if (j != -1) {
      {
#line 87
      tmp___0 = stringtab_get(j);
#line 87
      str = tmp___0;
      }
    } else {
#line 87
      str = *(argv->argv + 0);
    }
#line 88
    ssid = -1;
    {
#line 89
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 89
      tmp___1 = setsid();
#line 89
      ssid = tmp___1 < 0;
      }
#line 89
      if (ssid) {
        {
#line 89
        tmp___2 = __errno_location();
        }
#line 89
        if (! (*tmp___2 == 11)) {
#line 89
          goto while_break___0;
        }
      } else {
#line 89
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 91
    if (ssid < 0) {
      {
#line 93
      tmp___3 = __errno_location();
#line 93
      tmp___4 = strerror(*tmp___3);
#line 93
      rl_warn("setsid()) for %s: %s", str, tmp___4);
#line 94
      exit(65);
      }
    }
#line 96
    i = 0;
    {
#line 96
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 96
      if (! (i < 3)) {
#line 96
        goto while_break___1;
      }
#line 97
      if (inst->sock != i) {
        {
#line 98
        dup2(inst->sock, i);
        }
      }
#line 96
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 99
    if (inst->sock >= 3) {
      {
#line 100
      close(inst->sock);
      }
    }
    {
#line 101
    tmp___7 = execv((char const   *)str, (char * const  *)argv->argv);
    }
#line 101
    if (tmp___7) {
      {
#line 102
      tmp___5 = __errno_location();
#line 102
      tmp___6 = strerror(*tmp___5);
#line 102
      rl_warn("execv(%s): %s", str, tmp___6);
#line 103
      exit(65);
      }
    }
#line 105
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 107
    rl_warn("Fish!");
    }
#line 108
    goto switch_break;
    case_3: /* CIL Label */ 
#line 110
    if (rl_debug > 1) {
      {
#line 111
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"++setuid: %d\n",
              *(op + 1));
      }
    }
    {
#line 112
    op ++;
#line 112
    tmp___10 = setuid(*op);
    }
#line 112
    if (tmp___10) {
      {
#line 113
      tmp___8 = __errno_location();
#line 113
      tmp___9 = strerror(*tmp___8);
#line 113
      rl_warn("%s(%d) failed %s", "setuid", *op, tmp___9);
      }
    }
#line 114
    goto switch_break;
    case_4: /* CIL Label */ 
#line 116
    if (rl_debug > 1) {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"++setgid: %d\n",
              *(op + 1));
      }
    }
    {
#line 118
    op ++;
#line 118
    tmp___13 = setgid(*op);
    }
#line 118
    if (tmp___13) {
      {
#line 119
      tmp___11 = __errno_location();
#line 119
      tmp___12 = strerror(*tmp___11);
#line 119
      rl_warn("%s(%d) failed %s", "setgid", *op, tmp___12);
      }
    }
#line 120
    goto switch_break;
    case_5: /* CIL Label */ 
#line 122
    if (rl_debug > 1) {
      {
#line 123
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"++nice: %d\n",
              *(op + 1));
      }
    }
    {
#line 124
    op ++;
#line 124
    tmp___16 = setpriority(0, (id_t )0, (int )*op);
    }
#line 124
    if (tmp___16) {
      {
#line 125
      tmp___14 = __errno_location();
#line 125
      tmp___15 = strerror(*tmp___14);
#line 125
      rl_warn("%s(%d) failed %s", "setpriority", *op, tmp___15);
      }
    }
#line 126
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 128
    op ++;
#line 128
    j = (int )*op;
#line 129
    op ++;
#line 129
    k = (int )*op;
#line 131
    tmp___19 = rlimittab_get(k);
#line 131
    tmp___20 = setrlimit(j, (struct rlimit  const  *)tmp___19);
    }
#line 131
    if (tmp___20) {
      {
#line 132
      tmp___17 = __errno_location();
#line 132
      tmp___18 = strerror(*tmp___17);
#line 132
      rl_warn("%s(%d) failed %s", "setrlimit", *op, tmp___18);
      }
    }
#line 133
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 135
    op ++;
#line 135
    argv = argvtab_get((int )*op);
#line 136
    string_build(inst, argv);
#line 137
    tmp___24 = chroot((char const   *)argv->str);
    }
#line 137
    if (tmp___24) {
      {
#line 138
      tmp___21 = __errno_location();
#line 138
      tmp___22 = strerror(*tmp___21);
#line 138
      tmp___23 = gettext("ABORT - chroot(\"%s\"): %s");
#line 138
      rl_fatal(70, (char const   *)tmp___23, argv->str, tmp___22);
      }
    }
    {
#line 139
    tmp___28 = chdir("/");
    }
#line 139
    if (tmp___28) {
      {
#line 140
      tmp___25 = __errno_location();
#line 140
      tmp___26 = strerror(*tmp___25);
#line 140
      tmp___27 = gettext("ABORT - chdir(\"/\"): %s");
#line 140
      rl_fatal(70, (char const   *)tmp___27, tmp___26);
      }
    }
#line 141
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 143
    op ++;
#line 143
    log = logtab_get((int )*op);
#line 144
    argv = argvtab_get(log->argv);
    }
#line 145
    if (log->fd < 0) {
      {
#line 146
      string_build(inst, argv);
#line 147
      syslog(6, "%s", argv->str);
      }
    } else {
      {
#line 149
      iov_build(inst, argv);
#line 150
      tmp___31 = writev(log->fd, (struct iovec  const  *)argv->iov, argv->argc);
      }
#line 150
      if (tmp___31 < 0L) {
        {
#line 151
        tmp___29 = __errno_location();
#line 151
        tmp___30 = strerror(*tmp___29);
#line 151
        rl_warn("writev() log: %s", tmp___30);
        }
      }
    }
#line 153
    goto switch_break;
    case_9: /* CIL Label */ 
#line 155
    op ++;
#line 155
    i = (int )*op;
#line 157
    if (inst->sin) {
      {
#line 158
      free((void *)inst->sin);
      }
    }
#line 159
    inst->sin = (struct sockaddr *)((void *)0);
#line 160
    inst->sinlen = (socklen_t )i;
#line 161
    if (i) {
      {
#line 162
      tmp___32 = malloc((size_t )i);
#line 162
      inst->sin = (struct sockaddr *)tmp___32;
      }
#line 163
      if (! inst->sin) {
        {
#line 164
        tmp___33 = gettext("ABORT - Can\'t allocate memory");
#line 164
        rl_fatal(70, (char const   *)tmp___33);
        }
      }
    }
    {
#line 166
    tmp___36 = accept(inst->sock, (struct sockaddr */* __restrict  */)inst->sin, (socklen_t */* __restrict  */)(& inst->sinlen));
#line 166
    inst->sock = tmp___36;
    }
#line 166
    if (tmp___36 < 0) {
      {
#line 167
      tmp___34 = __errno_location();
#line 167
      tmp___35 = strerror(*tmp___34);
#line 167
      rl_warn("accept(): %s", tmp___35);
      }
#line 168
      return;
    }
    {
#line 170
    fcntl(inst->sock, 4, 2048);
#line 171
    tmp___39 = fcntl(inst->sock, 2, 0);
    }
#line 171
    if (tmp___39 == -1) {
      {
#line 172
      tmp___37 = __errno_location();
#line 172
      tmp___38 = strerror(*tmp___37);
#line 172
      rl_warn("fcntl(%d, F_SETFD, 0): %s", inst->sock, tmp___38);
      }
    }
#line 174
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 176
    op ++;
#line 176
    k = (int )*op;
#line 177
    op ++;
#line 177
    i = (int )*op;
#line 178
    rls_block();
#line 179
    j = fork();
    }
    {
#line 180
    if (j == -1) {
#line 180
      goto case_neg_1;
    }
#line 183
    if (j == 0) {
#line 183
      goto case_0;
    }
#line 190
    goto switch_default;
    case_neg_1: /* CIL Label */ 
    {
#line 181
    tmp___40 = __errno_location();
#line 181
    tmp___41 = strerror(*tmp___40);
#line 181
    tmp___42 = gettext("fork() failed - %s");
#line 181
    rl_warn((char const   *)tmp___42, tmp___41);
    }
#line 182
    goto switch_break___0;
    case_0: /* CIL Label */ 
    {
#line 184
    rls_unblock();
#line 185
    all_unhook();
#line 186
    rlstk_push(& inst->stk, (rl_opcode_t )0);
#line 187
    op ++;
#line 187
    run_bytecode(op, inst);
#line 188
    tmp___43 = rlstk_pop(& inst->stk);
#line 188
    exit((int )tmp___43);
    }
#line 189
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 191
    inst->start = time((time_t *)((void *)0));
#line 192
    pidtab_add(j, i, inst);
#line 193
    rls_unblock();
#line 194
    tmp___44 = oplisttab_get(k);
#line 194
    run_bytecode(tmp___44, inst);
    }
#line 194
    return;
    switch_break___0: /* CIL Label */ ;
    }
#line 196
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 198
    op ++;
#line 198
    str = stringtab_get((int )*op);
#line 199
    op ++;
#line 199
    k = (int )*op;
    }
#line 228
    goto switch_break;
    case_12: /* CIL Label */ 
#line 234
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 236
    op ++;
#line 236
    str = stringtab_get((int )*op);
#line 237
    op ++;
#line 237
    gid = *op;
    }
#line 238
    if (rl_debug > 1) {
      {
#line 239
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"++initgr: %s, %d\n",
              str, (int )gid);
      }
    }
    {
#line 240
    tmp___47 = initgroups((char const   *)str, gid);
    }
#line 240
    if (tmp___47) {
      {
#line 241
      tmp___45 = __errno_location();
#line 241
      tmp___46 = strerror(*tmp___45);
#line 241
      rl_warn("initgroups(%s, %d): %s", str, (int )gid, tmp___46);
      }
    }
#line 242
    goto switch_break;
    case_14: /* CIL Label */ 
#line 244
    op ++;
#line 244
    j = (int )*op;
#line 245
    op += j;
#line 246
    goto switch_break;
    case_15: /* CIL Label */ 
#line 248
    if (inst->sock != -1) {
      {
#line 248
      tmp___50 = close(inst->sock);
      }
#line 248
      if (tmp___50) {
        {
#line 249
        tmp___48 = __errno_location();
#line 249
        tmp___49 = strerror(*tmp___48);
#line 249
        rl_warn("close(%d): %s", inst->sock, tmp___49);
        }
      }
    }
#line 250
    inst->sock = -1;
#line 251
    return;
    case_16: /* CIL Label */ 
    {
#line 253
    tmp___51 = rlstk_pop(& inst->stk);
#line 253
    tmp___52 = rlbuf_copy(inst->sock, inst->buf, (int )tmp___51);
#line 253
    rlstk_push(& inst->stk, (rl_opcode_t )tmp___52);
    }
#line 254
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 256
    rlstk_push(& inst->stk, (rl_opcode_t )0);
    }
#line 257
    goto switch_break;
    case_18: /* CIL Label */ 
#line 259
    return;
    case_19: /* CIL Label */ 
    {
#line 261
    exit(0);
    }
#line 262
    return;
    case_20: /* CIL Label */ 
    {
#line 264
    op ++;
#line 264
    argv = argvtab_get((int )*op);
#line 266
    iov_build(inst, argv);
#line 267
    tmp___55 = writev(inst->sock, (struct iovec  const  *)argv->iov, argv->argc);
    }
#line 267
    if (tmp___55 < 0L) {
      {
#line 268
      tmp___53 = __errno_location();
#line 268
      tmp___54 = strerror(*tmp___53);
#line 268
      rl_warn("writev(): %s", tmp___54);
      }
    }
#line 269
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 271
    op ++;
#line 271
    sem = semaphore_get((int )*op);
#line 272
    tmp___57 = sem->count;
#line 272
    (sem->count) --;
    }
#line 272
    if (tmp___57 == sem->limit) {
      {
#line 273
      tmp___56 = oplisttab_get((int )sem->under);
#line 273
      run_bytecode(tmp___56, inst);
      }
    }
#line 274
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 276
    op ++;
#line 276
    sem = semaphore_get((int )*op);
#line 277
    (sem->count) ++;
    }
#line 277
    if (sem->count == sem->limit) {
      {
#line 278
      tmp___58 = oplisttab_get((int )sem->match);
#line 278
      run_bytecode(tmp___58, inst);
      }
    }
#line 279
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 281
    rl_warn("Frog!");
    }
#line 282
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 284
    op ++;
#line 284
    listeners_set((int )*op);
    }
#line 285
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 287
    op ++;
#line 287
    listeners_clear((int )*op);
    }
#line 288
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 290
    op ++;
#line 290
    rlbuf_init(& inst->buf, (int )*op);
    }
#line 291
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 293
    tmp___59 = rlbuf_read(inst->sock, inst->buf);
#line 293
    rlstk_push(& inst->stk, (rl_opcode_t )tmp___59);
    }
#line 294
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 296
    tmp___60 = rlbuf_write(inst->sock, inst->buf);
#line 296
    rlstk_push(& inst->stk, (rl_opcode_t )tmp___60);
    }
#line 297
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 299
    op ++;
#line 300
    read_hook(inst->sock, (op + 1) + *op, inst);
    }
#line 301
    return;
    case_30: /* CIL Label */ 
    {
#line 303
    read_unhook(inst->sock);
    }
#line 304
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 306
    op ++;
#line 307
    write_hook(inst->sock, (op + 1) + *op, inst);
    }
#line 308
    return;
    case_32: /* CIL Label */ 
    {
#line 310
    write_unhook(inst->sock);
    }
#line 311
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 313
    op ++;
#line 313
    j = (int )*op;
#line 315
    tmp___61 = rlstk_pop(& inst->stk);
    }
#line 315
    if (! tmp___61) {
#line 316
      op += j;
    }
#line 317
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 319
    op ++;
#line 319
    j = (int )*op;
#line 321
    tmp___62 = oplisttab_get(j);
#line 321
    run_bytecode(tmp___62, inst);
    }
#line 321
    return;
    case_35: /* CIL Label */ 
    {
#line 323
    op ++;
#line 323
    j = (int )*op;
#line 325
    tmp___63 = rlstk_pop(& inst->stk);
    }
#line 325
    if (tmp___63 <= 0U) {
#line 326
      op += j;
    }
#line 327
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 329
    tmp___64 = rlstk_peek(& inst->stk, 1);
#line 329
    j = (int )tmp___64;
#line 331
    tmp___65 = rlstk_pop(& inst->stk);
#line 331
    rlstk_poke(& inst->stk, 0, tmp___65 + (rl_opcode_t )j);
    }
#line 332
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 334
    tmp___66 = rlstk_peek(& inst->stk, 1);
#line 334
    j = (int )tmp___66;
#line 336
    tmp___67 = rlstk_pop(& inst->stk);
#line 336
    rlstk_poke(& inst->stk, 0, (rl_opcode_t )j - tmp___67);
    }
#line 337
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 339
    tmp___68 = rlstk_peek(& inst->stk, 0);
#line 339
    rlstk_push(& inst->stk, tmp___68);
    }
#line 340
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 342
    rlstk_pop(& inst->stk);
    }
#line 343
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 345
    op ++;
#line 345
    bt = buftab_get((int )*op);
#line 347
    rlbuf_init(& inst->buf, 0);
#line 348
    (inst->buf)->data = (char *)bt->addr;
#line 349
    tmp___69 = (int )bt->len;
#line 349
    (inst->buf)->head = tmp___69;
#line 349
    (inst->buf)->size = tmp___69;
    }
#line 350
    goto switch_break;
    case_41: /* CIL Label */ 
#line 352
    (inst->buf)->data = (char *)((void *)0);
#line 353
    (inst->buf)->size = 0;
#line 354
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 357
    tmp___70 = gettext("ABORT - Unknown opcode (%d)");
#line 357
    rl_fatal(70, (char const   *)tmp___70, *op);
    }
#line 358
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 61
    tmp___71 = op;
#line 61
    op ++;
#line 61
    if (! tmp___71) {
#line 61
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 361
  return;
}
}
#line 180 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 846 "/usr/include/stdio.h"
extern void perror(char const   *__s ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 937 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) daemon)(int __nochdir ,
                                                                             int __noclose ) ;
#line 181 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 173 "/usr/include/getopt.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 82 "/usr/include/libintl.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) textdomain)(char const   *__domainname ) ;
#line 86
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) bindtextdomain)(char const   *__domainname ,
                                                                                       char const   *__dirname ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/main.c"
int rl_debug  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/main.c"
char const   *rl_parser  =    "/usr/local/lib/rlinetd/libparse.so";
#line 44 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/main.c"
char const   *rl_config  =    "/usr/local/etc/rlinetd.conf";
#line 45 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/main.c"
char rl_lf[2]  = {      (char )'\n',      (char )'\000'};
#line 47 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/main.c"
struct option options[5]  = {      {"help", 0, (int *)((void *)0), 'h'}, 
        {"debug", 0, (int *)((void *)0), 'd'}, 
        {"parser", 1, (int *)((void *)0), 'p'}, 
        {"config", 1, (int *)((void *)0), 'f'}, 
        {(char const   *)((void *)0), 0, (int *)((void *)0), 0}};
#line 56 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/main.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;

  {
  {
#line 60
  setlocale(6, "");
#line 61
  bindtextdomain("rlinetd", "/usr/local/share/locale");
#line 62
  textdomain("rlinetd");
  }
  {
#line 66
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 66
    i = getopt_long(argc, (char * const  *)argv, "p:f:dh", (struct option  const  *)(options),
                    (int *)((void *)0));
    }
#line 66
    if (! (i != -1)) {
#line 66
      goto while_break;
    }
    {
#line 78
    if (i == 112) {
#line 78
      goto case_112;
    }
#line 81
    if (i == 102) {
#line 81
      goto case_102;
    }
#line 84
    if (i == 100) {
#line 84
      goto case_100;
    }
#line 87
    if (i == 104) {
#line 87
      goto case_104;
    }
#line 99
    goto switch_default;
    case_112: /* CIL Label */ 
#line 79
    rl_parser = (char const   *)optarg;
#line 80
    goto switch_break;
    case_102: /* CIL Label */ 
#line 82
    rl_config = (char const   *)optarg;
#line 83
    goto switch_break;
    case_100: /* CIL Label */ 
#line 85
    rl_debug ++;
#line 86
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 88
    tmp = gettext("%s Version %s\n");
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp,
            "rlinetd", "0.9");
#line 89
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 90
    tmp___0 = gettext("Usage:\n");
#line 90
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___0);
#line 91
    tmp___1 = gettext("%s [options]\n");
#line 91
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___1,
            *(argv + 0));
#line 92
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 93
    tmp___2 = gettext("Options:\n");
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___2);
#line 94
    tmp___3 = gettext("  -p|--parser file    alternative parser module (default %s)\n");
#line 94
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___3,
            rl_parser);
#line 95
    tmp___4 = gettext("  -f|--config file    alternative config file (default %s)\n");
#line 95
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___4,
            rl_config);
#line 96
    tmp___5 = gettext("  -d|--debug          enable debugging\n");
#line 96
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___5);
#line 97
    tmp___6 = gettext("  -h|--help           this message\n");
#line 97
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)tmp___6);
#line 98
    exit(0);
    }
    switch_default: /* CIL Label */ 
    {
#line 101
    exit(64);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 105
  if (! rl_debug) {
    {
#line 106
    tmp___7 = daemon(0, 0);
    }
#line 106
    if (tmp___7 == -1) {
      {
#line 108
      perror("daemon");
      }
    }
  }
  {
#line 111
  setgroups((size_t )0, (__gid_t const   *)((void *)0));
#line 112
  openlog("rlinetd", 9, 3 << 3);
#line 113
  rl_siginit();
#line 114
  main_loop();
  }
#line 115
  return (0);
}
}
#line 15 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.h"
struct rl_stack *rlstk_new(void) ;
#line 16
void rlstk_free(struct rl_stack *s ) ;
#line 10 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.c"
void rlstk_push(struct rl_stack *s , rl_opcode_t val ) 
{ 
  char *tmp ;
  int tmp___0 ;

  {
#line 11
  if (s->top == 8) {
    {
#line 12
    tmp = gettext("Stack overflow");
#line 12
    rl_fatal(70, (char const   *)tmp);
    }
  }
#line 13
  tmp___0 = s->top;
#line 13
  (s->top) ++;
#line 13
  s->data[tmp___0] = val;
#line 14
  return;
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.c"
rl_opcode_t rlstk_pop(struct rl_stack *s ) 
{ 
  char *tmp ;

  {
#line 17
  if (! s->top) {
    {
#line 18
    tmp = gettext("Stack underflow");
#line 18
    rl_fatal(70, (char const   *)tmp);
    }
  }
#line 19
  (s->top) --;
#line 19
  return (s->data[s->top]);
}
}
#line 22 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.c"
rl_opcode_t rlstk_peek(struct rl_stack *s , int offset ) 
{ 
  char *tmp ;

  {
#line 23
  if (offset >= s->top) {
    {
#line 24
    tmp = gettext("Stack peek undefined");
#line 24
    rl_fatal(70, (char const   *)tmp);
    }
  }
#line 25
  return (s->data[(s->top - offset) - 1]);
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.c"
void rlstk_poke(struct rl_stack *s , int offset , rl_opcode_t val ) 
{ 
  char *tmp ;

  {
#line 29
  if (offset >= s->top) {
    {
#line 30
    tmp = gettext("Stack peek undefined");
#line 30
    rl_fatal(70, (char const   *)tmp);
    }
  }
#line 31
  s->data[(s->top - offset) - 1] = val;
#line 32
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.c"
struct rl_stack *rlstk_new(void) 
{ 
  struct rl_stack *s ;
  void *tmp ;
  char *tmp___0 ;

  {
  {
#line 37
  tmp = malloc(sizeof(*s));
#line 37
  s = (struct rl_stack *)tmp;
  }
#line 38
  if (! s) {
    {
#line 39
    tmp___0 = gettext("ABORT - Can\'t allocate memory");
#line 39
    rl_fatal(70, (char const   *)tmp___0);
    }
  }
  {
#line 40
  memset((void *)s, 0, sizeof(*s));
  }
#line 41
  return (s);
}
}
#line 44 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/stack.c"
void rlstk_free(struct rl_stack *s ) 
{ 


  {
  {
#line 45
  free((void *)s);
  }
#line 46
  return;
}
}
#line 242 "/usr/include/stdio.h"
extern int fflush(FILE *__stream ) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.c"
static void rl_log(int level , char const   *file , int line , char const   *fmt ,
                   va_list argp ) ;
#line 13 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.c"
void rl_note(char const   *fmt  , ...) 
{ 
  va_list argp ;

  {
  {
#line 16
  __builtin_va_start(argp, fmt);
#line 17
  rl_log(6, (char const   *)((void *)0), 0, fmt, argp);
#line 18
  __builtin_va_end(argp);
  }
#line 19
  return;
}
}
#line 21 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.c"
void rl_warn(char const   *fmt  , ...) 
{ 
  va_list argp ;

  {
  {
#line 24
  __builtin_va_start(argp, fmt);
#line 25
  rl_log(4, (char const   *)((void *)0), 0, fmt, argp);
#line 26
  __builtin_va_end(argp);
  }
#line 27
  return;
}
}
#line 29 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.c"
void rl_pwarn(char const   *file , int line , char const   *fmt  , ...) 
{ 
  va_list argp ;

  {
  {
#line 32
  __builtin_va_start(argp, fmt);
#line 33
  rl_log(4, file, line, fmt, argp);
#line 34
  __builtin_va_end(argp);
  }
#line 35
  return;
}
}
#line 38 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.c"
void rl_fatal(int ex , char const   *fmt  , ...) 
{ 
  va_list argp ;

  {
  {
#line 41
  __builtin_va_start(argp, fmt);
#line 42
  rl_log(3, (char const   *)((void *)0), 0, fmt, argp);
#line 43
  __builtin_va_end(argp);
#line 45
  exit(ex);
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.c"
void rl_pfatal(int ex , char const   *file , int line , char const   *fmt  , ...) 
{ 
  va_list argp ;

  {
  {
#line 51
  __builtin_va_start(argp, fmt);
#line 52
  rl_log(3, file, line, fmt, argp);
#line 53
  __builtin_va_end(argp);
#line 55
  exit(ex);
  }
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/rlinetd-0.9/src/error.c"
static void rl_log(int level , char const   *file , int line , char const   *fmt ,
                   va_list argp ) 
{ 
  char message[1024] ;
  int cur_len ;
  int max_len ;
  size_t tmp ;

  {
  {
#line 66
  max_len = (int )(sizeof(message) - 1UL);
#line 67
  cur_len = 0;
#line 69
  memset((void *)(message), 0, (size_t )max_len);
  }
#line 71
  if (file) {
    {
#line 72
    snprintf((char */* __restrict  */)(message), (size_t )max_len, (char const   */* __restrict  */)"(%.255s:%d) ",
             file, line);
#line 74
    tmp = strlen((char const   *)(message));
#line 74
    cur_len = (int )tmp;
#line 75
    max_len -= cur_len + 1;
    }
  }
  {
#line 78
  vsnprintf((char */* __restrict  */)(message + cur_len), (size_t )max_len, (char const   */* __restrict  */)fmt,
            argp);
  }
#line 80
  if (rl_debug) {
    {
#line 82
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
            message);
#line 83
    fflush(stderr);
    }
  } else {
    {
#line 86
    syslog(level, "%s", message);
    }
  }
#line 87
  return;
}
}
