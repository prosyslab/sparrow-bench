/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 22 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef int __sig_atomic_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 40 "/usr/include/signal.h"
typedef __sig_atomic_t sig_atomic_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_31 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_32 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_34 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_35 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_36 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_37 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_30 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_31 _kill ;
   struct __anonstruct__timer_32 _timer ;
   struct __anonstruct__rt_33 _rt ;
   struct __anonstruct__sigchld_34 _sigchld ;
   struct __anonstruct__sigfault_35 _sigfault ;
   struct __anonstruct__sigpoll_36 _sigpoll ;
   struct __anonstruct__sigsys_37 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_29 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_30 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_29 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_49 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_49 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 28 "/usr/include/x86_64-linux-gnu/sys/ptrace.h"
enum __ptrace_request {
    PTRACE_TRACEME = 0,
    PTRACE_PEEKTEXT = 1,
    PTRACE_PEEKDATA = 2,
    PTRACE_PEEKUSER = 3,
    PTRACE_POKETEXT = 4,
    PTRACE_POKEDATA = 5,
    PTRACE_POKEUSER = 6,
    PTRACE_CONT = 7,
    PTRACE_KILL = 8,
    PTRACE_SINGLESTEP = 9,
    PTRACE_GETREGS = 12,
    PTRACE_SETREGS = 13,
    PTRACE_GETFPREGS = 14,
    PTRACE_SETFPREGS = 15,
    PTRACE_ATTACH = 16,
    PTRACE_DETACH = 17,
    PTRACE_GETFPXREGS = 18,
    PTRACE_SETFPXREGS = 19,
    PTRACE_SYSCALL = 24,
    PTRACE_SETOPTIONS = 16896,
    PTRACE_GETEVENTMSG = 16897,
    PTRACE_GETSIGINFO = 16898,
    PTRACE_SETSIGINFO = 16899,
    PTRACE_GETREGSET = 16900,
    PTRACE_SETREGSET = 16901,
    PTRACE_SEIZE = 16902,
    PTRACE_INTERRUPT = 16903,
    PTRACE_LISTEN = 16904,
    PTRACE_PEEKSIGINFO = 16905
} ;
#line 29 "/usr/include/x86_64-linux-gnu/sys/user.h"
struct user_fpregs_struct {
   unsigned short cwd ;
   unsigned short swd ;
   unsigned short ftw ;
   unsigned short fop ;
   unsigned long long rip ;
   unsigned long long rdp ;
   unsigned int mxcsr ;
   unsigned int mxcr_mask ;
   unsigned int st_space[32] ;
   unsigned int xmm_space[64] ;
   unsigned int padding[24] ;
};
#line 44 "/usr/include/x86_64-linux-gnu/sys/user.h"
struct user_regs_struct {
   unsigned long long r15 ;
   unsigned long long r14 ;
   unsigned long long r13 ;
   unsigned long long r12 ;
   unsigned long long rbp ;
   unsigned long long rbx ;
   unsigned long long r11 ;
   unsigned long long r10 ;
   unsigned long long r9 ;
   unsigned long long r8 ;
   unsigned long long rax ;
   unsigned long long rcx ;
   unsigned long long rdx ;
   unsigned long long rsi ;
   unsigned long long rdi ;
   unsigned long long orig_rax ;
   unsigned long long rip ;
   unsigned long long cs ;
   unsigned long long eflags ;
   unsigned long long rsp ;
   unsigned long long ss ;
   unsigned long long fs_base ;
   unsigned long long gs_base ;
   unsigned long long ds ;
   unsigned long long es ;
   unsigned long long fs ;
   unsigned long long gs ;
};
#line 75 "/usr/include/x86_64-linux-gnu/sys/user.h"
union __anonunion____missing_field_name_19 {
   struct user_regs_struct *u_ar0 ;
   unsigned long long __u_ar0_word ;
};
#line 75 "/usr/include/x86_64-linux-gnu/sys/user.h"
union __anonunion____missing_field_name_20 {
   struct user_fpregs_struct *u_fpstate ;
   unsigned long long __u_fpstate_word ;
};
#line 75 "/usr/include/x86_64-linux-gnu/sys/user.h"
struct user {
   struct user_regs_struct regs ;
   int u_fpvalid ;
   struct user_fpregs_struct i387 ;
   unsigned long long u_tsize ;
   unsigned long long u_dsize ;
   unsigned long long u_ssize ;
   unsigned long long start_code ;
   unsigned long long start_stack ;
   long long signal ;
   int reserved ;
   union __anonunion____missing_field_name_19 __annonCompField1 ;
   union __anonunion____missing_field_name_20 __annonCompField2 ;
   unsigned long long magic ;
   char u_comm[32] ;
   unsigned long long u_debugreg[8] ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.h"
enum child_state {
    ptrace_detached = 0,
    ptrace_at_syscall = 1,
    ptrace_after_syscall = 2,
    ptrace_running = 3,
    ptrace_stopped = 4,
    ptrace_exited = 5
} ;
#line 35 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.h"
struct ptrace_child {
   pid_t pid ;
   enum child_state state ;
   int personality ;
   int status ;
   int error ;
   unsigned long forked_pid ;
   struct user user ;
   unsigned long saved_syscall ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.h"
struct syscall_numbers {
   long nr_mmap ;
   long nr_mmap2 ;
   long nr_munmap ;
   long nr_getsid ;
   long nr_setsid ;
   long nr_setpgid ;
   long nr_fork ;
   long nr_wait4 ;
   long nr_signal ;
   long nr_rt_sigaction ;
   long nr_open ;
   long nr_close ;
   long nr_ioctl ;
   long nr_dup2 ;
};
#line 63 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.h"
typedef unsigned long child_addr_t;
#line 68 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
struct ptrace_personality {
   size_t syscall_rv ;
   size_t syscall_arg0 ;
   size_t syscall_arg1 ;
   size_t syscall_arg2 ;
   size_t syscall_arg3 ;
   size_t syscall_arg4 ;
   size_t syscall_arg5 ;
   size_t reg_ip ;
};
#line 23 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/x86_common.h"
struct x86_personality {
   size_t orig_ax ;
   size_t ax ;
};
#line 156 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
union __anonunion_58 {
   int __in ;
   int __i ;
};
#line 155 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
union __anonunion_59 {
   int __in ;
   int __i ;
};
#line 153 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
union __anonunion_60 {
   int __in ;
   int __i ;
};
#line 153 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
union __anonunion_61 {
   int __in ;
   int __i ;
};
#line 180 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
union __anonunion_62 {
   int __in ;
   int __i ;
};
#line 180 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
union __anonunion_63 {
   int __in ;
   int __i ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 60 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __dev_t dev_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 44 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
struct proc_stat {
   pid_t pid ;
   char comm[17] ;
   char state ;
   pid_t ppid ;
   pid_t sid ;
   pid_t pgid ;
   dev_t ctty ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 646
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setpgid)(__pid_t __pid ,
                                                                              __pid_t __pgid ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) setenv)(char const   *__name ,
                                                                                             char const   *__value ,
                                                                                             int __replace ) ;
#line 924
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) grantpt)(int __fd ) ;
#line 928
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) unlockpt)(int __fd ) ;
#line 933
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ptsname)(int __fd ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 76
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) cfmakeraw)(struct termios *__termios_p ) ;
#line 259 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.h"
int attach_child(pid_t pid , char const   *pty , int force_stdio ) ;
#line 27
void ( /* format attribute */  die)(char const   *msg  , ...) ;
#line 28
void ( /* format attribute */  debug)(char const   *msg  , ...) ;
#line 29
void ( /* format attribute */  error)(char const   *msg  , ...) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
static int verbose  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void _debug(char const   *pfx , char const   *msg , va_list ap ) 
{ 


  {
#line 45
  if (pfx) {
    {
#line 46
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
            pfx);
    }
  }
  {
#line 47
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)msg,
           ap);
#line 48
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 49
  return;
}
}
#line 51 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void ( /* format attribute */  die)(char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 53
  __builtin_va_start(ap, msg);
#line 54
  _debug("[!] ", msg, ap);
#line 55
  __builtin_va_end(ap);
#line 57
  exit(1);
  }
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void ( /* format attribute */  debug)(char const   *msg  , ...) 
{ 
  va_list ap ;

  {
#line 64
  if (! verbose) {
#line 65
    return;
  }
  {
#line 67
  __builtin_va_start(ap, msg);
#line 68
  _debug("[+] ", msg, ap);
#line 69
  __builtin_va_end(ap);
  }
#line 70
  return;
}
}
#line 72 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void ( /* format attribute */  error)(char const   *msg  , ...) 
{ 
  va_list ap ;

  {
  {
#line 74
  __builtin_va_start(ap, msg);
#line 75
  _debug("[-] ", msg, ap);
#line 76
  __builtin_va_end(ap);
  }
#line 77
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void setup_raw(struct termios *save ) 
{ 
  struct termios set ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 81
  tmp = tcgetattr(0, save);
  }
#line 81
  if (tmp < 0) {
    {
#line 82
    die("Unable to read terminal attributes: %m");
    }
  }
  {
#line 83
  set = *save;
#line 84
  cfmakeraw(& set);
#line 85
  tmp___0 = tcsetattr(0, 0, (struct termios  const  *)(& set));
  }
#line 85
  if (tmp___0 < 0) {
    {
#line 86
    die("Unable to set terminal attributes: %m");
    }
  }
#line 87
  return;
}
}
#line 89 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void resize_pty(int pty ) 
{ 
  struct winsize sz ;
  int tmp ;

  {
  {
#line 91
  tmp = ioctl(0, 21523UL, & sz);
  }
#line 91
  if (tmp < 0) {
#line 92
    return;
  }
  {
#line 93
  ioctl(pty, 21524UL, & sz);
  }
#line 94
  return;
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
int writeall(int fd , void const   *buf , ssize_t count ) 
{ 
  ssize_t rv ;
  int *tmp ;

  {
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! (count > 0L)) {
#line 98
      goto while_break;
    }
    {
#line 99
    rv = write(fd, buf, (size_t )count);
    }
#line 100
    if (rv < 0L) {
      {
#line 101
      tmp = __errno_location();
      }
#line 101
      if (*tmp == 4) {
#line 102
        goto while_continue;
      }
#line 103
      return ((int )rv);
    }
#line 105
    count -= rv;
#line 106
    buf += rv;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return (0);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
int volatile   winch_happened  =    (sig_atomic_t volatile   )0;
#line 113 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void do_winch(int signal___0 ) 
{ 


  {
#line 114
  winch_happened = (int volatile   )1;
#line 115
  return;
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void do_proxy(int pty ) 
{ 
  char buf[4096] ;
  ssize_t count ;
  fd_set set ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  int tmp___0 ;

  {
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (winch_happened) {
      {
#line 123
      winch_happened = (int volatile   )0;
#line 129
      resize_pty(pty);
      }
    }
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& set.fds_bits[0]): "memory");
#line 131
      goto while_break___0;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 132
    set.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << 0 % (8 * (int )sizeof(__fd_mask ));
#line 133
    set.fds_bits[pty / (8 * (int )sizeof(__fd_mask ))] |= 1L << pty % (8 * (int )sizeof(__fd_mask ));
#line 134
    tmp___0 = select(pty + 1, (fd_set */* __restrict  */)(& set), (fd_set */* __restrict  */)((void *)0),
                     (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)((void *)0));
    }
#line 134
    if (tmp___0 < 0) {
      {
#line 135
      tmp = __errno_location();
      }
#line 135
      if (*tmp == 4) {
#line 136
        goto while_continue;
      }
      {
#line 137
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"select: %m");
      }
#line 138
      return;
    }
#line 140
    if ((set.fds_bits[0 / (8 * (int )sizeof(__fd_mask ))] & (1L << 0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 141
      count = read(0, (void *)(buf), sizeof(buf));
      }
#line 142
      if (count < 0L) {
#line 143
        return;
      }
      {
#line 144
      writeall(pty, (void const   *)(buf), count);
      }
    }
#line 146
    if ((set.fds_bits[pty / (8 * (int )sizeof(__fd_mask ))] & (1L << pty % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 147
      count = read(pty, (void *)(buf), sizeof(buf));
      }
#line 148
      if (count < 0L) {
#line 149
        return;
      }
      {
#line 150
      writeall(1, (void const   *)(buf), count);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 155 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void usage(char *me ) 
{ 


  {
  {
#line 156
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-s] PID\n",
          me);
#line 157
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       %s -l|-L [COMMAND [ARGS]]\n",
          me);
#line 158
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -l    Create a new pty pair and print the name of the slave.\n");
#line 159
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"           if there are command-line arguments after -l\n");
#line 160
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"           they are executed with REPTYR_PTY set to path of pty.\n");
#line 161
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -L    Like \'-l\', but also redirect the child\'s stdio to the slave.\n");
#line 162
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -s    Attach fds 0-2 on the target, even if it is not attached to a tty.\n");
#line 163
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -h    Print this help message and exit.\n");
#line 164
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -v    Print the version number and exit.\n");
#line 165
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  -V    Print verbose debug output.\n");
  }
#line 166
  return;
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
void check_yama_ptrace_scope(void) 
{ 
  int fd ;
  int tmp ;
  char buf[256] ;
  int n ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;

  {
  {
#line 169
  tmp = open("/proc/sys/kernel/yama/ptrace_scope", 0);
#line 169
  fd = tmp;
  }
#line 170
  if (fd >= 0) {
    {
#line 173
    tmp___0 = read(fd, (void *)(buf), sizeof(buf));
#line 173
    n = (int )tmp___0;
#line 174
    close(fd);
    }
#line 175
    if (n > 0) {
      {
#line 176
      tmp___1 = atoi((char const   *)(buf));
      }
#line 176
      if (! tmp___1) {
#line 177
        return;
      }
    }
  } else {
    {
#line 180
    tmp___2 = __errno_location();
    }
#line 180
    if (*tmp___2 == 2) {
#line 181
      return;
    }
  }
  {
#line 182
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The kernel denied permission while attaching. If your uid matches\n");
#line 183
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"the target\'s, check the value of /proc/sys/kernel/yama/ptrace_scope.\n");
#line 184
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"For more information, see /etc/sysctl.d/10-ptrace.conf\n");
  }
#line 185
  return;
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/reptyr.c"
int main(int argc , char **argv ) 
{ 
  struct termios saved_termios ;
  struct sigaction act ;
  int pty ;
  int arg ;
  int do_attach ;
  int force_stdio ;
  int unattached_script_redirection ;
  int tmp ;
  int tmp___0 ;
  pid_t child ;
  int tmp___1 ;
  int err ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int f ;
  __pid_t tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  __pid_t tmp___9 ;

  {
#line 191
  arg = 1;
#line 192
  do_attach = 1;
#line 193
  force_stdio = 0;
#line 194
  unattached_script_redirection = 0;
#line 196
  if (argc < 2) {
    {
#line 197
    usage(*(argv + 0));
    }
#line 198
    return (2);
  }
#line 200
  if ((int )*(*(argv + arg) + 0) == 45) {
    {
#line 202
    if ((int )*(*(argv + arg) + 1) == 104) {
#line 202
      goto case_104;
    }
#line 205
    if ((int )*(*(argv + arg) + 1) == 108) {
#line 205
      goto case_108;
    }
#line 208
    if ((int )*(*(argv + arg) + 1) == 76) {
#line 208
      goto case_76;
    }
#line 212
    if ((int )*(*(argv + arg) + 1) == 115) {
#line 212
      goto case_115;
    }
#line 216
    if ((int )*(*(argv + arg) + 1) == 118) {
#line 216
      goto case_118;
    }
#line 221
    if ((int )*(*(argv + arg) + 1) == 86) {
#line 221
      goto case_86;
    }
#line 225
    goto switch_default;
    case_104: /* CIL Label */ 
    {
#line 203
    usage(*(argv + 0));
    }
#line 204
    return (0);
    case_108: /* CIL Label */ 
#line 206
    do_attach = 0;
#line 207
    goto switch_break;
    case_76: /* CIL Label */ 
#line 209
    do_attach = 0;
#line 210
    unattached_script_redirection = 1;
#line 211
    goto switch_break;
    case_115: /* CIL Label */ 
#line 213
    arg ++;
#line 214
    force_stdio = 1;
#line 215
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 217
    printf((char const   */* __restrict  */)"This is reptyr version %s.\n", "0.5");
#line 218
    printf((char const   */* __restrict  */)" by Nelson Elhage <nelhage@nelhage.com>\n");
#line 219
    printf((char const   */* __restrict  */)"http://github.com/nelhage/reptyr/\n");
    }
#line 220
    return (0);
    case_86: /* CIL Label */ 
#line 222
    arg ++;
#line 223
    verbose = 1;
#line 224
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 226
    usage(*(argv + 0));
    }
#line 227
    return (1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 231
  if (do_attach) {
#line 231
    if (arg >= argc) {
      {
#line 232
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: No pid specified to attach\n",
              *(argv + 0));
#line 233
      usage(*(argv + 0));
      }
#line 234
      return (1);
    }
  }
  {
#line 237
  pty = open("/dev/ptmx", 258);
  }
#line 237
  if (pty < 0) {
    {
#line 238
    die("Unable to open /dev/ptmx: %m");
    }
  }
  {
#line 239
  tmp = unlockpt(pty);
  }
#line 239
  if (tmp < 0) {
    {
#line 240
    die("Unable to unlockpt: %m");
    }
  }
  {
#line 241
  tmp___0 = grantpt(pty);
  }
#line 241
  if (tmp___0 < 0) {
    {
#line 242
    die("Unable to grantpt: %m");
    }
  }
#line 244
  if (do_attach) {
    {
#line 245
    tmp___1 = atoi((char const   *)*(argv + arg));
#line 245
    child = tmp___1;
#line 247
    tmp___3 = ptsname(pty);
#line 247
    err = attach_child(child, (char const   *)tmp___3, force_stdio);
    }
#line 247
    if (err) {
      {
#line 248
      tmp___2 = strerror(err);
#line 248
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to attach to pid %d: %s\n",
              child, tmp___2);
      }
#line 249
      if (err == 1) {
        {
#line 250
        check_yama_ptrace_scope();
        }
      }
#line 252
      return (1);
    }
  } else {
    {
#line 255
    tmp___4 = ptsname(pty);
#line 255
    printf((char const   */* __restrict  */)"Opened a new pty: %s\n", tmp___4);
#line 256
    fflush(stdout);
    }
#line 257
    if (argc > 2) {
      {
#line 258
      tmp___9 = fork();
      }
#line 258
      if (! tmp___9) {
        {
#line 259
        tmp___5 = ptsname(pty);
#line 259
        setenv("REPTYR_PTY", (char const   *)tmp___5, 1);
        }
#line 260
        if (unattached_script_redirection) {
          {
#line 262
          tmp___6 = getppid();
#line 262
          setpgid(0, tmp___6);
#line 263
          setsid();
#line 264
          tmp___7 = ptsname(pty);
#line 264
          f = open((char const   *)tmp___7, 0, 0);
#line 264
          dup2(f, 0);
#line 264
          close(f);
#line 265
          tmp___8 = ptsname(pty);
#line 265
          f = open((char const   *)tmp___8, 1, 0);
#line 265
          dup2(f, 1);
#line 265
          dup2(f, 2);
#line 265
          close(f);
          }
        }
        {
#line 267
        close(pty);
#line 268
        execvp((char const   *)*(argv + 2), (char * const  *)(argv + 2));
#line 269
        exit(1);
        }
      }
    }
  }
  {
#line 274
  setup_raw(& saved_termios);
#line 275
  memset((void *)(& act), 0, sizeof(act));
#line 276
  act.__sigaction_handler.sa_handler = & do_winch;
#line 277
  act.sa_flags = 0;
#line 278
  sigaction(28, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
#line 279
  resize_pty(pty);
#line 280
  do_proxy(pty);
#line 281
  tcsetattr(0, 0, (struct termios  const  *)(& saved_termios));
  }
#line 283
  return (0);
}
}
#line 213 "/usr/include/x86_64-linux-gnu/sys/ptrace.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) ptrace)(enum __ptrace_request __request 
                                                                              , ...) ;
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 65 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.h"
int ptrace_wait(struct ptrace_child *child ) ;
#line 66
int ptrace_attach_child(struct ptrace_child *child , pid_t pid ) ;
#line 67
int ptrace_finish_attach(struct ptrace_child *child , pid_t pid ) ;
#line 68
int ptrace_detach_child(struct ptrace_child *child ) ;
#line 70
int ptrace_advance_to_state(struct ptrace_child *child , enum child_state desired ) ;
#line 72
int ptrace_save_regs(struct ptrace_child *child ) ;
#line 73
int ptrace_restore_regs(struct ptrace_child *child ) ;
#line 74
unsigned long ptrace_remote_syscall(struct ptrace_child *child , unsigned long sysno ,
                                    unsigned long p0 , unsigned long p1 , unsigned long p2 ,
                                    unsigned long p3 , unsigned long p4 , unsigned long p5 ) ;
#line 80
int ptrace_memcpy_to_child(struct ptrace_child *child , child_addr_t dst , void const   *src ,
                           size_t n ) ;
#line 81
int ptrace_memcpy_from_child(struct ptrace_child *child , void *dst , child_addr_t src ,
                             size_t n ) ;
#line 82
struct syscall_numbers *ptrace_syscall_numbers(struct ptrace_child *child ) ;
#line 61 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
static long __ptrace_command(struct ptrace_child *child , enum __ptrace_request req ,
                             void *addr , void *data ) ;
#line 79
static struct ptrace_personality *personality(struct ptrace_child *child ) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/x86_common.h"
struct x86_personality x86_personality[2] ;
#line 30 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/x86_common.h"
__inline static struct x86_personality *x86_pers(struct ptrace_child *child ) 
{ 


  {
#line 31
  return (& x86_personality[child->personality]);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/x86_common.h"
__inline static void arch_fixup_regs(struct ptrace_child *child ) 
{ 
  struct x86_personality *x86pers ;
  struct x86_personality *tmp ;
  struct ptrace_personality *pers ;
  struct ptrace_personality *tmp___0 ;
  struct user *user ;

  {
  {
#line 35
  tmp = x86_pers(child);
#line 35
  x86pers = tmp;
#line 36
  tmp___0 = personality(child);
#line 36
  pers = tmp___0;
#line 37
  user = & child->user;
#line 39
  *((unsigned long *)((void *)user + pers->reg_ip)) -= 2UL;
#line 40
  *((unsigned long *)((void *)user + x86pers->ax)) = *((unsigned long *)((void *)user + x86pers->orig_ax));
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/x86_common.h"
__inline static int arch_set_syscall(struct ptrace_child *child , unsigned long sysno ) 
{ 
  struct x86_personality *tmp ;
  long tmp___0 ;

  {
  {
#line 45
  tmp = x86_pers(child);
#line 45
  tmp___0 = __ptrace_command(child, (enum __ptrace_request )6, (void *)tmp->orig_ax,
                             (void *)sysno);
  }
#line 45
  return ((int )tmp___0);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/x86_common.h"
__inline static int arch_save_syscall(struct ptrace_child *child ) 
{ 
  struct x86_personality *tmp ;

  {
  {
#line 51
  tmp = x86_pers(child);
#line 51
  child->saved_syscall = *((unsigned long *)((void *)(& child->user) + tmp->orig_ax));
  }
#line 52
  return (0);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/x86_common.h"
__inline static int arch_restore_syscall(struct ptrace_child *child ) 
{ 


  {
#line 56
  return (0);
}
}
#line 26 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/amd64.h"
static struct ptrace_personality arch_personality[2]  = {      {(unsigned long )(& ((struct user *)0)->regs.rax), (unsigned long )(& ((struct user *)0)->regs.rdi),
      (unsigned long )(& ((struct user *)0)->regs.rsi), (unsigned long )(& ((struct user *)0)->regs.rdx),
      (unsigned long )(& ((struct user *)0)->regs.r10), (unsigned long )(& ((struct user *)0)->regs.r8),
      (unsigned long )(& ((struct user *)0)->regs.r9), (unsigned long )(& ((struct user *)0)->regs.rip)}, 
        {(unsigned long )(& ((struct user *)0)->regs.rax),
      (unsigned long )(& ((struct user *)0)->regs.rbx), (unsigned long )(& ((struct user *)0)->regs.rcx),
      (unsigned long )(& ((struct user *)0)->regs.rdx), (unsigned long )(& ((struct user *)0)->regs.rsi),
      (unsigned long )(& ((struct user *)0)->regs.rdi), (unsigned long )(& ((struct user *)0)->regs.rbp),
      (unsigned long )(& ((struct user *)0)->regs.rip)}};
#line 49 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/amd64.h"
struct x86_personality x86_personality[2]  = {      {(unsigned long )(& ((struct user *)0)->regs.orig_rax), (unsigned long )(& ((struct user *)0)->regs.rax)}, 
        {(unsigned long )(& ((struct user *)0)->regs.orig_rax),
      (unsigned long )(& ((struct user *)0)->regs.rax)}};
#line 60 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/amd64.h"
struct syscall_numbers arch_syscall_numbers[2]  = {      {9L, -1L, 11L, 124L, 112L, 109L, 57L, 61L, -1L, 13L, 2L, 3L, 16L, 33L}, 
        {90L, 192L, 91L, 147L, 66L, 57L, 2L, 114L, 48L, 173L, 5L, 6L, 54L, 63L}};
#line 87 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/arch/amd64.h"
int arch_get_personality(struct ptrace_child *child ) 
{ 
  unsigned long cs ;
  long tmp ;

  {
  {
#line 90
  tmp = __ptrace_command(child, (enum __ptrace_request )3, (void *)((unsigned long )(& ((struct user *)0)->regs.cs)),
                         (void *)0);
#line 90
  cs = (unsigned long )tmp;
  }
#line 92
  if (child->error) {
#line 93
    return (-1);
  }
#line 94
  if (cs == 35UL) {
#line 95
    child->personality = 1;
  }
#line 96
  return (0);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
static struct ptrace_personality *personality(struct ptrace_child *child ) 
{ 


  {
#line 102
  return (& arch_personality[child->personality]);
}
}
#line 105 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
struct syscall_numbers *ptrace_syscall_numbers(struct ptrace_child *child ) 
{ 


  {
#line 106
  return (& arch_syscall_numbers[child->personality]);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_attach_child(struct ptrace_child *child , pid_t pid ) 
{ 
  long tmp ;
  int tmp___0 ;

  {
  {
#line 110
  memset((void *)child, 0, sizeof(*child));
#line 111
  child->pid = pid;
#line 112
  tmp = __ptrace_command(child, (enum __ptrace_request )16, (void *)0, (void *)0);
  }
#line 112
  if (tmp < 0L) {
#line 113
    return (-1);
  }
  {
#line 115
  tmp___0 = ptrace_finish_attach(child, pid);
  }
#line 115
  return (tmp___0);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_finish_attach(struct ptrace_child *child , pid_t pid ) 
{ 
  int tmp ;
  int tmp___0 ;
  long tmp___1 ;

  {
  {
#line 119
  memset((void *)child, 0, sizeof(*child));
#line 120
  child->pid = pid;
#line 122
  kill(pid, 18);
#line 123
  tmp = ptrace_wait(child);
  }
#line 123
  if (tmp < 0) {
#line 124
    goto detach;
  }
  {
#line 126
  tmp___0 = arch_get_personality(child);
  }
#line 126
  if (tmp___0) {
#line 127
    goto detach;
  }
  {
#line 129
  tmp___1 = __ptrace_command(child, (enum __ptrace_request )16896, (void *)0, (void *)3);
  }
#line 129
  if (tmp___1 < 0L) {
#line 131
    goto detach;
  }
#line 133
  return (0);
  detach: 
  {
#line 137
  ptrace((enum __ptrace_request )17, child->pid, 0, 0);
  }
#line 138
  return (-1);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_detach_child(struct ptrace_child *child ) 
{ 
  long tmp ;

  {
  {
#line 142
  tmp = __ptrace_command(child, (enum __ptrace_request )17, (void *)0, (void *)0);
  }
#line 142
  if (tmp < 0L) {
#line 143
    return (-1);
  }
#line 144
  child->state = (enum child_state )0;
#line 145
  return (0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_wait(struct ptrace_child *child ) 
{ 
  int *tmp ;
  __pid_t tmp___0 ;
  int sig ;
  union __anonunion_58 __constr_expr_0 ;
  union __anonunion_59 __constr_expr_1 ;
  union __anonunion_60 __constr_expr_2 ;
  union __anonunion_61 __constr_expr_3 ;

  {
  {
#line 149
  tmp___0 = waitpid(child->pid, & child->status, 0);
  }
#line 149
  if (tmp___0 < 0) {
    {
#line 150
    tmp = __errno_location();
#line 150
    child->error = *tmp;
    }
#line 151
    return (-1);
  }
#line 153
  __constr_expr_2.__in = child->status;
#line 153
  if ((__constr_expr_2.__i & 127) == 0) {
#line 154
    child->state = (enum child_state )5;
  } else {
#line 153
    __constr_expr_3.__in = child->status;
#line 153
    if ((int )((signed char )((__constr_expr_3.__i & 127) + 1)) >> 1 > 0) {
#line 154
      child->state = (enum child_state )5;
    } else {
#line 155
      __constr_expr_1.__in = child->status;
#line 155
      if ((__constr_expr_1.__i & 255) == 127) {
#line 156
        __constr_expr_0.__in = child->status;
#line 156
        sig = (__constr_expr_0.__i & 65280) >> 8;
#line 157
        if (sig & 128) {
#line 158
          if ((unsigned int )child->state == 1U) {
#line 158
            child->state = (enum child_state )2;
          } else {
#line 158
            child->state = (enum child_state )1;
          }
        } else {
#line 161
          if (sig == 5) {
#line 161
            if (((child->status >> 8) & 1) == 1) {
              {
#line 162
              __ptrace_command(child, (enum __ptrace_request )16897, (void *)0, (void *)(& child->forked_pid));
              }
            }
          }
#line 163
          if ((unsigned int )child->state != 1U) {
#line 164
            child->state = (enum child_state )4;
          }
        }
      } else {
#line 167
        child->error = 22;
#line 168
        return (-1);
      }
    }
  }
#line 170
  return (0);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_advance_to_state(struct ptrace_child *child , enum child_state desired ) 
{ 
  int err ;
  union __anonunion_62 __constr_expr_4 ;
  union __anonunion_63 __constr_expr_5 ;
  long tmp ;
  long tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! ((unsigned int )child->state != (unsigned int )desired)) {
#line 176
      goto while_break;
    }
    {
#line 179
    if ((unsigned int )desired == 1U) {
#line 179
      goto case_1;
    }
#line 179
    if ((unsigned int )desired == 2U) {
#line 179
      goto case_1;
    }
#line 186
    if ((unsigned int )desired == 3U) {
#line 186
      goto case_3;
    }
#line 188
    if ((unsigned int )desired == 4U) {
#line 188
      goto case_4;
    }
#line 193
    goto switch_default;
    case_1: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 180
    __constr_expr_4.__in = child->status;
#line 180
    if ((__constr_expr_4.__i & 255) == 127) {
#line 180
      __constr_expr_5.__in = child->status;
#line 180
      if ((__constr_expr_5.__i & 65280) >> 8 == 11) {
#line 181
        child->error = 11;
#line 182
        return (-1);
      }
    }
    {
#line 184
    tmp = __ptrace_command(child, (enum __ptrace_request )24, (void *)0, (void *)0);
#line 184
    err = (int )tmp;
    }
#line 185
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 187
    tmp___0 = __ptrace_command(child, (enum __ptrace_request )7, (void *)0, (void *)0);
    }
#line 187
    return ((int )tmp___0);
    case_4: /* CIL Label */ 
    {
#line 189
    err = kill(child->pid, 19);
    }
#line 190
    if (err < 0) {
      {
#line 191
      tmp___1 = __errno_location();
#line 191
      child->error = *tmp___1;
      }
    }
#line 192
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 194
    child->error = 22;
#line 195
    return (-1);
    switch_break: /* CIL Label */ ;
    }
#line 197
    if (err < 0) {
#line 198
      return (err);
    }
    {
#line 199
    tmp___2 = ptrace_wait(child);
    }
#line 199
    if (tmp___2 < 0) {
#line 200
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return (0);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_save_regs(struct ptrace_child *child ) 
{ 
  int tmp ;
  long tmp___0 ;
  int tmp___1 ;

  {
  {
#line 207
  tmp = ptrace_advance_to_state(child, (enum child_state )1);
  }
#line 207
  if (tmp < 0) {
#line 208
    return (-1);
  }
  {
#line 209
  tmp___0 = __ptrace_command(child, (enum __ptrace_request )12, (void *)0, (void *)(& child->user));
  }
#line 209
  if (tmp___0 < 0L) {
#line 210
    return (-1);
  }
  {
#line 211
  arch_fixup_regs(child);
#line 212
  tmp___1 = arch_save_syscall(child);
  }
#line 212
  if (tmp___1 < 0) {
#line 213
    return (-1);
  }
#line 214
  return (0);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_restore_regs(struct ptrace_child *child ) 
{ 
  int err ;
  long tmp ;
  int tmp___0 ;

  {
  {
#line 219
  tmp = __ptrace_command(child, (enum __ptrace_request )13, (void *)0, (void *)(& child->user));
#line 219
  err = (int )tmp;
  }
#line 220
  if (err < 0) {
#line 221
    return (err);
  }
  {
#line 222
  tmp___0 = arch_restore_syscall(child);
  }
#line 222
  return (tmp___0);
}
}
#line 225 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
unsigned long ptrace_remote_syscall(struct ptrace_child *child , unsigned long sysno ,
                                    unsigned long p0 , unsigned long p1 , unsigned long p2 ,
                                    unsigned long p3 , unsigned long p4 , unsigned long p5 ) 
{ 
  unsigned long rv ;
  int tmp ;
  int tmp___0 ;
  struct ptrace_personality *tmp___1 ;
  long tmp___2 ;
  struct ptrace_personality *tmp___3 ;
  long tmp___4 ;
  struct ptrace_personality *tmp___5 ;
  long tmp___6 ;
  struct ptrace_personality *tmp___7 ;
  long tmp___8 ;
  struct ptrace_personality *tmp___9 ;
  long tmp___10 ;
  struct ptrace_personality *tmp___11 ;
  long tmp___12 ;
  int tmp___13 ;
  struct ptrace_personality *tmp___14 ;
  long tmp___15 ;
  struct ptrace_personality *tmp___16 ;
  struct ptrace_personality *tmp___17 ;
  long tmp___18 ;

  {
  {
#line 231
  tmp = ptrace_advance_to_state(child, (enum child_state )1);
  }
#line 231
  if (tmp < 0) {
#line 232
    return (0xffffffffffffffffUL);
  }
  {
#line 241
  tmp___0 = arch_set_syscall(child, sysno);
  }
#line 241
  if (tmp___0 < 0) {
#line 242
    return (0xffffffffffffffffUL);
  }
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 243
    tmp___1 = personality(child);
#line 243
    tmp___2 = __ptrace_command(child, (enum __ptrace_request )6, (void *)tmp___1->syscall_arg0,
                               (void *)p0);
    }
#line 243
    if (tmp___2 < 0L) {
#line 243
      return (0xffffffffffffffffUL);
    }
#line 243
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 244
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 244
    tmp___3 = personality(child);
#line 244
    tmp___4 = __ptrace_command(child, (enum __ptrace_request )6, (void *)tmp___3->syscall_arg1,
                               (void *)p1);
    }
#line 244
    if (tmp___4 < 0L) {
#line 244
      return (0xffffffffffffffffUL);
    }
#line 244
    goto while_break___0;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 245
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 245
    tmp___5 = personality(child);
#line 245
    tmp___6 = __ptrace_command(child, (enum __ptrace_request )6, (void *)tmp___5->syscall_arg2,
                               (void *)p2);
    }
#line 245
    if (tmp___6 < 0L) {
#line 245
      return (0xffffffffffffffffUL);
    }
#line 245
    goto while_break___1;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 246
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 246
    tmp___7 = personality(child);
#line 246
    tmp___8 = __ptrace_command(child, (enum __ptrace_request )6, (void *)tmp___7->syscall_arg3,
                               (void *)p3);
    }
#line 246
    if (tmp___8 < 0L) {
#line 246
      return (0xffffffffffffffffUL);
    }
#line 246
    goto while_break___2;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 247
  while (1) {
    while_continue___3: /* CIL Label */ ;
    {
#line 247
    tmp___9 = personality(child);
#line 247
    tmp___10 = __ptrace_command(child, (enum __ptrace_request )6, (void *)tmp___9->syscall_arg4,
                                (void *)p4);
    }
#line 247
    if (tmp___10 < 0L) {
#line 247
      return (0xffffffffffffffffUL);
    }
#line 247
    goto while_break___3;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 248
  while (1) {
    while_continue___4: /* CIL Label */ ;
    {
#line 248
    tmp___11 = personality(child);
#line 248
    tmp___12 = __ptrace_command(child, (enum __ptrace_request )6, (void *)tmp___11->syscall_arg5,
                                (void *)p5);
    }
#line 248
    if (tmp___12 < 0L) {
#line 248
      return (0xffffffffffffffffUL);
    }
#line 248
    goto while_break___4;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 250
  tmp___13 = ptrace_advance_to_state(child, (enum child_state )2);
  }
#line 250
  if (tmp___13 < 0) {
#line 251
    return (0xffffffffffffffffUL);
  }
  {
#line 253
  tmp___14 = personality(child);
#line 253
  tmp___15 = __ptrace_command(child, (enum __ptrace_request )3, (void *)tmp___14->syscall_rv,
                              (void *)0);
#line 253
  rv = (unsigned long )tmp___15;
  }
#line 255
  if (child->error) {
#line 256
    return (0xffffffffffffffffUL);
  }
  {
#line 258
  while (1) {
    while_continue___5: /* CIL Label */ ;
    {
#line 258
    tmp___16 = personality(child);
#line 258
    tmp___17 = personality(child);
#line 258
    tmp___18 = __ptrace_command(child, (enum __ptrace_request )6, (void *)tmp___17->reg_ip,
                                (void *)*((unsigned long *)((void *)(& child->user) + tmp___16->reg_ip)));
    }
#line 258
    if (tmp___18 < 0L) {
#line 258
      return (0xffffffffffffffffUL);
    }
#line 258
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 263
  return (rv);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_memcpy_to_child(struct ptrace_child *child , child_addr_t dst , void const   *src ,
                           size_t n ) 
{ 
  unsigned long scratch ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 269
  while (1) {
    while_continue: /* CIL Label */ ;
#line 269
    if (! (n >= sizeof(unsigned long ))) {
#line 269
      goto while_break;
    }
    {
#line 270
    tmp = __ptrace_command(child, (enum __ptrace_request )5, (void *)dst, (void *)*((unsigned long *)src));
    }
#line 270
    if (tmp < 0L) {
#line 271
      return (-1);
    }
#line 272
    dst += sizeof(unsigned long );
#line 273
    src += sizeof(unsigned long );
#line 274
    n -= sizeof(unsigned long );
  }
  while_break: /* CIL Label */ ;
  }
#line 277
  if (n) {
    {
#line 278
    tmp___0 = __ptrace_command(child, (enum __ptrace_request )2, (void *)dst, (void *)0);
#line 278
    scratch = (unsigned long )tmp___0;
    }
#line 279
    if (child->error) {
#line 280
      return (-1);
    }
    {
#line 281
    memcpy((void */* __restrict  */)(& scratch), (void const   */* __restrict  */)src,
           n);
#line 282
    tmp___1 = __ptrace_command(child, (enum __ptrace_request )5, (void *)dst, (void *)scratch);
    }
#line 282
    if (tmp___1 < 0L) {
#line 283
      return (-1);
    }
  }
#line 286
  return (0);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
int ptrace_memcpy_from_child(struct ptrace_child *child , void *dst , child_addr_t src ,
                             size_t n ) 
{ 
  unsigned long scratch ;
  long tmp ;
  size_t _min1 ;
  unsigned long _min2 ;
  size_t tmp___0 ;

  {
  {
#line 292
  while (1) {
    while_continue: /* CIL Label */ ;
#line 292
    if (! n) {
#line 292
      goto while_break;
    }
    {
#line 293
    tmp = __ptrace_command(child, (enum __ptrace_request )2, (void *)src, (void *)0);
#line 293
    scratch = (unsigned long )tmp;
    }
#line 294
    if (child->error) {
#line 294
      return (-1);
    }
#line 295
    _min1 = n;
#line 295
    _min2 = sizeof(unsigned long );
#line 295
    if (_min1 < _min2) {
#line 295
      tmp___0 = _min1;
    } else {
#line 295
      tmp___0 = _min2;
    }
    {
#line 295
    memcpy((void */* __restrict  */)dst, (void const   */* __restrict  */)(& scratch),
           tmp___0);
#line 297
    dst += sizeof(unsigned long );
#line 298
    src += sizeof(unsigned long );
    }
#line 299
    if (n >= sizeof(unsigned long )) {
#line 300
      n -= sizeof(unsigned long );
    } else {
#line 302
      n = (size_t )0;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return (0);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/ptrace.c"
static long __ptrace_command(struct ptrace_child *child , enum __ptrace_request req ,
                             void *addr , void *data ) 
{ 
  long rv ;
  int *tmp ;
  int *tmp___0 ;

  {
  {
#line 310
  tmp = __errno_location();
#line 310
  *tmp = 0;
#line 311
  rv = ptrace(req, child->pid, addr, data);
#line 312
  tmp___0 = __errno_location();
#line 312
  child->error = *tmp___0;
  }
#line 313
  return (rv);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 386 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 619
extern  __attribute__((__nothrow__)) long ( __attribute__((__leaf__)) sysconf)(int __name ) ;
#line 639
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpgid)(__pid_t __pid ) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
int parse_proc_stat(int statfd , struct proc_stat *out ) 
{ 
  char buf[1024] ;
  int n ;
  unsigned int dev ;
  int *tmp ;
  ssize_t tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 60
  lseek(statfd, (__off_t )0, 0);
#line 61
  tmp___0 = read(statfd, (void *)(buf), sizeof(buf));
  }
#line 61
  if (tmp___0 < 0L) {
    {
#line 62
    tmp = __errno_location();
    }
#line 62
    return (*tmp);
  }
  {
#line 63
  n = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%d (%16[^)]) %c %d %d %d %u",
             & out->pid, out->comm, & out->state, & out->ppid, & out->sid, & out->pgid,
             & dev);
  }
#line 67
  if (n == -1) {
    {
#line 68
    tmp___1 = __errno_location();
    }
#line 68
    return (*tmp___1);
  }
#line 69
  if (n != 7) {
#line 70
    return (22);
  }
#line 72
  out->ctty = (dev_t )dev;
#line 73
  return (0);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
int read_proc_stat(pid_t pid , struct proc_stat *out ) 
{ 
  char stat_path[4096] ;
  int statfd ;
  int err ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 81
  snprintf((char */* __restrict  */)(stat_path), sizeof(stat_path), (char const   */* __restrict  */)"/proc/%d/stat",
           pid);
#line 82
  statfd = open((char const   *)(stat_path), 0);
  }
#line 83
  if (statfd < 0) {
    {
#line 84
    tmp = __errno_location();
#line 84
    tmp___0 = strerror(*tmp);
#line 84
    error("Unable to open %s: %s", stat_path, tmp___0);
    }
#line 85
    return (- statfd);
  }
  {
#line 88
  err = parse_proc_stat(statfd, out);
#line 89
  close(statfd);
  }
#line 90
  return (err);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
static void do_unmap(struct ptrace_child *child , child_addr_t addr , unsigned long len ) 
{ 
  struct syscall_numbers *tmp ;

  {
#line 94
  if (addr == 0xffffffffffffffffUL) {
#line 95
    return;
  }
  {
#line 96
  tmp = ptrace_syscall_numbers(child);
#line 96
  ptrace_remote_syscall(child, (unsigned long )tmp->nr_munmap, addr, len, 0UL, 0UL,
                        0UL, 0UL);
  }
#line 97
  return;
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
int *get_child_tty_fds(struct ptrace_child *child , int statfd , int *count ) 
{ 
  struct proc_stat child_status ;
  struct stat tty_st ;
  struct stat st ;
  char buf[4096] ;
  int n ;
  int allocated ;
  int *fds ;
  DIR *dir ;
  struct dirent *d ;
  int *tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 103
  n = 0;
#line 103
  allocated = 0;
#line 104
  fds = (int *)((void *)0);
#line 107
  tmp = (int *)((void *)0);
#line 109
  debug("Looking up fds for tty in child.");
#line 110
  tmp___0 = parse_proc_stat(statfd, & child_status);
#line 110
  child->error = tmp___0;
  }
#line 110
  if (tmp___0) {
#line 111
    return ((int *)((void *)0));
  }
  {
#line 113
  debug("Resolved child tty: %x", (unsigned int )child_status.ctty);
#line 115
  tmp___2 = stat((char const   */* __restrict  */)"/dev/tty", (struct stat */* __restrict  */)(& tty_st));
  }
#line 115
  if (tmp___2 < 0) {
    {
#line 116
    tmp___1 = __errno_location();
#line 116
    child->error = *tmp___1;
#line 117
    error("Unable to stat /dev/tty");
    }
#line 118
    return ((int *)((void *)0));
  }
  {
#line 121
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/fd/",
           child->pid);
#line 122
  dir = opendir((char const   *)(buf));
  }
#line 122
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 123
    return ((int *)((void *)0));
  }
  {
#line 124
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 124
    d = readdir(dir);
    }
#line 124
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 124
      goto while_break;
    }
#line 125
    if ((int )d->d_name[0] == 46) {
#line 125
      goto while_continue;
    }
    {
#line 126
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/fd/%s",
             child->pid, d->d_name);
#line 127
    tmp___3 = stat((char const   */* __restrict  */)(buf), (struct stat */* __restrict  */)(& st));
    }
#line 127
    if (tmp___3 < 0) {
#line 128
      goto while_continue;
    }
#line 130
    if (st.st_rdev == child_status.ctty) {
#line 130
      goto _L;
    } else
#line 130
    if (st.st_rdev == tty_st.st_rdev) {
      _L: /* CIL Label */ 
#line 132
      if (n == allocated) {
#line 133
        if (allocated) {
#line 133
          allocated = 2 * allocated;
        } else {
#line 133
          allocated = 2;
        }
        {
#line 134
        tmp___4 = realloc((void *)fds, (unsigned long )allocated * sizeof(*tmp));
#line 134
        tmp = (int *)tmp___4;
        }
#line 135
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
          {
#line 136
          tmp___5 = __errno_location();
#line 136
          child->error = *tmp___5;
#line 137
          error("Unable to allocate memory for fd array.");
#line 138
          free((void *)fds);
#line 139
          fds = (int *)((void *)0);
          }
#line 140
          goto out;
        }
#line 142
        fds = tmp;
      }
      {
#line 144
      debug("Found an alias for the tty: %s", d->d_name);
#line 145
      tmp___6 = n;
#line 145
      n ++;
#line 145
      *(fds + tmp___6) = atoi((char const   *)(d->d_name));
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 149
  *count = n;
#line 150
  closedir(dir);
  }
#line 151
  return (fds);
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
void move_process_group(struct ptrace_child *child , pid_t from , pid_t to ) 
{ 
  DIR *dir ;
  struct dirent *d ;
  pid_t pid ;
  char *p ;
  int err ;
  long tmp ;
  struct syscall_numbers *tmp___0 ;
  unsigned long tmp___1 ;
  char *tmp___2 ;
  __pid_t tmp___3 ;

  {
  {
#line 161
  dir = opendir("/proc/");
  }
#line 161
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
#line 162
    return;
  }
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 164
    d = readdir(dir);
    }
#line 164
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 164
      goto while_break;
    }
#line 165
    if ((int )d->d_name[0] == 46) {
#line 165
      goto while_continue;
    }
    {
#line 166
    tmp = strtol((char const   */* __restrict  */)(d->d_name), (char **/* __restrict  */)(& p),
                 10);
#line 166
    pid = (pid_t )tmp;
    }
#line 167
    if (*p) {
#line 167
      goto while_continue;
    }
    {
#line 168
    tmp___3 = getpgid(pid);
    }
#line 168
    if (tmp___3 == from) {
      {
#line 169
      debug("Change pgid for pid %d", pid);
#line 170
      tmp___0 = ptrace_syscall_numbers(child);
#line 170
      tmp___1 = ptrace_remote_syscall(child, (unsigned long )tmp___0->nr_setpgid,
                                      (unsigned long )pid, (unsigned long )to, 0UL,
                                      0UL, 0UL, 0UL);
#line 170
      err = (int )tmp___1;
      }
#line 171
      if (err < 0) {
        {
#line 172
        tmp___2 = strerror(- err);
#line 172
        error(" failed: %s", tmp___2);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 175
  closedir(dir);
  }
#line 176
  return;
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
int do_setsid(struct ptrace_child *child ) 
{ 
  int err ;
  struct ptrace_child dummy ;
  struct syscall_numbers *tmp ;
  unsigned long tmp___0 ;
  int tmp___1 ;
  struct syscall_numbers *tmp___2 ;
  unsigned long tmp___3 ;
  char *tmp___4 ;
  struct syscall_numbers *tmp___5 ;
  unsigned long tmp___6 ;
  char *tmp___7 ;
  struct syscall_numbers *tmp___8 ;

  {
  {
#line 179
  err = 0;
#line 182
  tmp = ptrace_syscall_numbers(child);
#line 182
  tmp___0 = ptrace_remote_syscall(child, (unsigned long )tmp->nr_fork, 0UL, 0UL, 0UL,
                                  0UL, 0UL, 0UL);
#line 182
  err = (int )tmp___0;
  }
#line 183
  if (err < 0) {
#line 184
    return (err);
  }
  {
#line 186
  debug("Forked a child: %ld", child->forked_pid);
#line 188
  err = ptrace_finish_attach(& dummy, (pid_t )child->forked_pid);
  }
#line 189
  if (err < 0) {
#line 190
    goto out_kill;
  }
  {
#line 192
  dummy.state = (enum child_state )2;
#line 193
  memcpy((void */* __restrict  */)(& dummy.user), (void const   */* __restrict  */)(& child->user),
         sizeof(child->user));
#line 194
  tmp___1 = ptrace_restore_regs(& dummy);
  }
#line 194
  if (tmp___1) {
#line 195
    err = dummy.error;
#line 196
    goto out_kill;
  }
  {
#line 199
  tmp___2 = ptrace_syscall_numbers(& dummy);
#line 199
  tmp___3 = ptrace_remote_syscall(& dummy, (unsigned long )tmp___2->nr_setpgid, 0UL,
                                  0UL, 0UL, 0UL, 0UL, 0UL);
#line 199
  err = (int )tmp___3;
  }
#line 200
  if (err < 0) {
    {
#line 201
    tmp___4 = strerror(- err);
#line 201
    error("Failed to setpgid: %s", tmp___4);
    }
#line 202
    goto out_kill;
  }
  {
#line 205
  move_process_group(child, child->pid, dummy.pid);
#line 207
  tmp___5 = ptrace_syscall_numbers(child);
#line 207
  tmp___6 = ptrace_remote_syscall(child, (unsigned long )tmp___5->nr_setsid, 0UL,
                                  0UL, 0UL, 0UL, 0UL, 0UL);
#line 207
  err = (int )tmp___6;
  }
#line 208
  if (err < 0) {
    {
#line 209
    tmp___7 = strerror(- err);
#line 209
    error("Failed to setsid: %s", tmp___7);
#line 210
    move_process_group(child, dummy.pid, child->pid);
    }
#line 211
    goto out_kill;
  }
  {
#line 214
  debug("Did setsid()");
  }
  out_kill: 
  {
#line 217
  kill(dummy.pid, 9);
#line 218
  ptrace_detach_child(& dummy);
#line 219
  ptrace_wait(& dummy);
#line 220
  tmp___8 = ptrace_syscall_numbers(child);
#line 220
  ptrace_remote_syscall(child, (unsigned long )tmp___8->nr_wait4, (unsigned long )dummy.pid,
                        0UL, 1UL, 0UL, 0UL, 0UL);
  }
#line 221
  return (err);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
int ignore_hup(struct ptrace_child *child , unsigned long scratch_page ) 
{ 
  int err ;
  struct syscall_numbers *tmp ;
  unsigned long tmp___0 ;
  struct sigaction act ;
  struct syscall_numbers *tmp___1 ;
  unsigned long tmp___2 ;
  struct syscall_numbers *tmp___3 ;

  {
  {
#line 226
  tmp___3 = ptrace_syscall_numbers(child);
  }
#line 226
  if (tmp___3->nr_signal != -1L) {
    {
#line 227
    tmp = ptrace_syscall_numbers(child);
#line 227
    tmp___0 = ptrace_remote_syscall(child, (unsigned long )tmp->nr_signal, 1UL, (unsigned long )((void (*)(int  ))1),
                                    0UL, 0UL, 0UL, 0UL);
#line 227
    err = (int )tmp___0;
    }
  } else {
    {
#line 229
    act.__sigaction_handler.sa_handler = (void (*)(int  ))1;
#line 229
    act.sa_mask.__val[0] = 0UL;
#line 229
    act.sa_mask.__val[1] = 0UL;
#line 229
    act.sa_mask.__val[2] = 0UL;
#line 229
    act.sa_mask.__val[3] = 0UL;
#line 229
    act.sa_mask.__val[4] = 0UL;
#line 229
    act.sa_mask.__val[5] = 0UL;
#line 229
    act.sa_mask.__val[6] = 0UL;
#line 229
    act.sa_mask.__val[7] = 0UL;
#line 229
    act.sa_mask.__val[8] = 0UL;
#line 229
    act.sa_mask.__val[9] = 0UL;
#line 229
    act.sa_mask.__val[10] = 0UL;
#line 229
    act.sa_mask.__val[11] = 0UL;
#line 229
    act.sa_mask.__val[12] = 0UL;
#line 229
    act.sa_mask.__val[13] = 0UL;
#line 229
    act.sa_mask.__val[14] = 0UL;
#line 229
    act.sa_mask.__val[15] = 0UL;
#line 229
    act.sa_flags = 0;
#line 229
    act.sa_restorer = (void (*)(void))0;
#line 232
    err = ptrace_memcpy_to_child(child, scratch_page, (void const   *)(& act), sizeof(act));
    }
#line 234
    if (err < 0) {
#line 235
      return (err);
    }
    {
#line 236
    tmp___1 = ptrace_syscall_numbers(child);
#line 236
    tmp___2 = ptrace_remote_syscall(child, (unsigned long )tmp___1->nr_rt_sigaction,
                                    1UL, scratch_page, 0UL, 8UL, 0UL, 0UL);
#line 236
    err = (int )tmp___2;
    }
  }
#line 240
  return (err);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
void wait_for_stop(pid_t pid , int fd ) 
{ 
  struct timeval start ;
  struct timeval now ;
  struct timespec sleep___0 ;
  struct proc_stat st ;
  int tmp ;

  {
  {
#line 258
  gettimeofday((struct timeval */* __restrict  */)(& start), (__timezone_ptr_t )((void *)0));
  }
  {
#line 259
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 260
    gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )((void *)0));
    }
#line 261
    if (now.tv_sec > start.tv_sec) {
#line 261
      if (now.tv_usec > start.tv_usec) {
        {
#line 263
        error("Timed out waiting for child stop.");
        }
#line 264
        goto while_break;
      } else {
#line 261
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 261
    if (now.tv_sec - start.tv_sec > 1L) {
      {
#line 263
      error("Timed out waiting for child stop.");
      }
#line 264
      goto while_break;
    }
    {
#line 270
    tmp = parse_proc_stat(fd, & st);
    }
#line 270
    if (tmp) {
#line 271
      goto while_break;
    }
#line 272
    if ((int )st.state == 84) {
#line 273
      goto while_break;
    }
    {
#line 275
    sleep___0.tv_sec = (__time_t )0;
#line 276
    sleep___0.tv_nsec = (__syscall_slong_t )10000000;
#line 277
    nanosleep((struct timespec  const  *)(& sleep___0), (struct timespec *)((void *)0));
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 279
  return;
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
int copy_tty_state(pid_t pid , char const   *pty ) 
{ 
  char buf[4096] ;
  int fd ;
  int err ;
  struct termios tio ;
  int i ;
  int tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;

  {
#line 283
  err = 22;
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (i < 3) {
#line 287
      if (! err) {
#line 287
        goto while_break;
      }
    } else {
#line 287
      goto while_break;
    }
    {
#line 288
    err = 0;
#line 289
    snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"/proc/%d/fd/%d",
             pid, i);
#line 291
    fd = open((char const   *)(buf), 0);
    }
#line 291
    if (fd < 0) {
#line 292
      err = - fd;
#line 293
      goto __Cont;
    }
    {
#line 296
    tmp = isatty(fd);
    }
#line 296
    if (! tmp) {
#line 297
      err = 25;
#line 298
      goto retry;
    }
    {
#line 301
    tmp___1 = tcgetattr(fd, & tio);
    }
#line 301
    if (tmp___1 < 0) {
      {
#line 302
      tmp___0 = __errno_location();
#line 302
      err = - *tmp___0;
      }
    }
    retry: 
    {
#line 305
    close(fd);
    }
    __Cont: /* CIL Label */ 
#line 287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 308
  if (err) {
#line 309
    return (err);
  }
  {
#line 311
  fd = open(pty, 0);
  }
#line 311
  if (fd < 0) {
    {
#line 312
    tmp___2 = __errno_location();
    }
#line 312
    return (- *tmp___2);
  }
  {
#line 314
  tmp___4 = tcsetattr(fd, 0, (struct termios  const  *)(& tio));
  }
#line 314
  if (tmp___4 < 0) {
    {
#line 315
    tmp___3 = __errno_location();
#line 315
    err = *tmp___3;
    }
  }
  {
#line 316
  close(fd);
  }
#line 317
  return (- err);
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
int check_pgroup(pid_t target ) 
{ 
  pid_t pg ;
  DIR *dir ;
  struct dirent *d ;
  pid_t pid ;
  char *p ;
  int err ;
  struct proc_stat pid_stat ;
  int *tmp ;
  long tmp___0 ;
  __pid_t tmp___1 ;

  {
  {
#line 326
  err = 0;
#line 329
  debug("Checking for problematic process group members...");
#line 331
  pg = getpgid(target);
  }
#line 332
  if (pg < 0) {
    {
#line 333
    error("Unable to get pgid (does process %d exist?)", target);
    }
#line 334
    return (pg);
  }
  {
#line 337
  dir = opendir("/proc/");
  }
#line 337
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 338
    tmp = __errno_location();
    }
#line 338
    return (*tmp);
  }
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 340
    d = readdir(dir);
    }
#line 340
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 340
      goto while_break;
    }
#line 341
    if ((int )d->d_name[0] == 46) {
#line 341
      goto while_continue;
    }
    {
#line 342
    tmp___0 = strtol((char const   */* __restrict  */)(d->d_name), (char **/* __restrict  */)(& p),
                     10);
#line 342
    pid = (pid_t )tmp___0;
    }
#line 343
    if (*p) {
#line 343
      goto while_continue;
    }
#line 344
    if (pid == target) {
#line 344
      goto while_continue;
    }
    {
#line 345
    tmp___1 = getpgid(pid);
    }
#line 345
    if (tmp___1 == pg) {
      {
#line 353
      err = read_proc_stat(pid, & pid_stat);
      }
#line 353
      if (err) {
        {
#line 354
        memcpy((void */* __restrict  */)(pid_stat.comm), (void const   */* __restrict  */)"???",
               (size_t )4);
        }
      }
      {
#line 356
      error("Process %d (%.*s) shares %d\'s process group. Unable to attach.\n(This most commonly means that %d has a suprocesses).",
            pid, 16, pid_stat.comm, target, target);
#line 359
      err = 22;
      }
#line 360
      goto out;
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 364
  closedir(dir);
  }
#line 365
  return (err);
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/reptyr-0.5/attach.c"
int attach_child(pid_t pid , char const   *pty , int force_stdio ) 
{ 
  struct ptrace_child child ;
  unsigned long scratch_page ;
  int *child_tty_fds ;
  int n_fds ;
  int child_fd ;
  int statfd ;
  int i ;
  int err ;
  long page_size ;
  long tmp ;
  char stat_path[4096] ;
  long mmap_syscall ;
  int *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct syscall_numbers *tmp___5 ;
  struct syscall_numbers *tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  struct syscall_numbers *tmp___10 ;
  unsigned long tmp___11 ;
  struct syscall_numbers *tmp___12 ;
  unsigned long tmp___13 ;
  struct syscall_numbers *tmp___14 ;
  struct syscall_numbers *tmp___15 ;
  unsigned long tmp___16 ;
  struct syscall_numbers *tmp___17 ;
  struct syscall_numbers *tmp___18 ;
  int tmp___19 ;

  {
  {
#line 370
  scratch_page = 0xffffffffffffffffUL;
#line 371
  child_tty_fds = (int *)((void *)0);
#line 373
  err = 0;
#line 374
  tmp = sysconf(30);
#line 374
  page_size = tmp;
#line 378
  err = check_pgroup(pid);
  }
#line 378
  if (err) {
#line 379
    return (err);
  }
  {
#line 382
  err = copy_tty_state(pid, pty);
  }
#line 382
  if (err) {
#line 383
    if (err == 25) {
#line 383
      if (! force_stdio) {
        {
#line 384
        error("Target is not connected to a terminal.\n    Use -s to force attaching anyways.");
        }
#line 386
        return (err);
      }
    }
  }
  {
#line 390
  snprintf((char */* __restrict  */)(stat_path), sizeof(stat_path), (char const   */* __restrict  */)"/proc/%d/stat",
           pid);
#line 391
  statfd = open((char const   *)(stat_path), 0);
  }
#line 392
  if (statfd < 0) {
    {
#line 393
    tmp___0 = __errno_location();
#line 393
    tmp___1 = strerror(*tmp___0);
#line 393
    error("Unable to open %s: %s", stat_path, tmp___1);
    }
#line 394
    return (- statfd);
  }
  {
#line 397
  kill(pid, 20);
#line 398
  wait_for_stop(pid, statfd);
#line 400
  tmp___2 = ptrace_attach_child(& child, pid);
  }
#line 400
  if (tmp___2) {
#line 401
    err = child.error;
#line 402
    goto out_cont;
  }
  {
#line 405
  tmp___3 = ptrace_advance_to_state(& child, (enum child_state )1);
  }
#line 405
  if (tmp___3) {
#line 406
    err = child.error;
#line 407
    goto out_detach;
  }
  {
#line 409
  tmp___4 = ptrace_save_regs(& child);
  }
#line 409
  if (tmp___4) {
#line 410
    err = child.error;
#line 411
    goto out_detach;
  }
  {
#line 414
  tmp___5 = ptrace_syscall_numbers(& child);
#line 414
  mmap_syscall = tmp___5->nr_mmap2;
  }
#line 415
  if (mmap_syscall == -1L) {
    {
#line 416
    tmp___6 = ptrace_syscall_numbers(& child);
#line 416
    mmap_syscall = tmp___6->nr_mmap;
    }
  }
  {
#line 417
  scratch_page = ptrace_remote_syscall(& child, (unsigned long )mmap_syscall, 0UL,
                                       (unsigned long )page_size, 3UL, 34UL, 0UL,
                                       0UL);
  }
#line 421
  if (scratch_page > 0xfffffffffffffc18UL) {
#line 422
    err = (int )(- ((long )scratch_page));
#line 423
    goto out_unmap;
  }
  {
#line 426
  debug("Allocated scratch page: %lx", scratch_page);
  }
#line 428
  if (force_stdio) {
    {
#line 429
    tmp___7 = malloc(3UL * sizeof(int ));
#line 429
    child_tty_fds = (int *)tmp___7;
    }
#line 430
    if (! child_tty_fds) {
#line 431
      err = 12;
#line 432
      goto out_unmap;
    }
#line 434
    n_fds = 3;
#line 435
    *(child_tty_fds + 0) = 0;
#line 436
    *(child_tty_fds + 1) = 1;
#line 437
    *(child_tty_fds + 2) = 2;
  } else {
    {
#line 439
    child_tty_fds = get_child_tty_fds(& child, statfd, & n_fds);
    }
#line 440
    if (! child_tty_fds) {
#line 441
      err = child.error;
#line 442
      goto out_unmap;
    }
  }
  {
#line 446
  tmp___8 = strlen(pty);
#line 446
  tmp___9 = ptrace_memcpy_to_child(& child, scratch_page, (void const   *)pty, tmp___8 + 1UL);
  }
#line 446
  if (tmp___9) {
    {
#line 447
    err = child.error;
#line 448
    error("Unable to memcpy the pty path to child.");
    }
#line 449
    goto out_free_fds;
  }
  {
#line 452
  tmp___10 = ptrace_syscall_numbers(& child);
#line 452
  tmp___11 = ptrace_remote_syscall(& child, (unsigned long )tmp___10->nr_open, scratch_page,
                                   258UL, 0UL, 0UL, 0UL, 0UL);
#line 452
  child_fd = (int )tmp___11;
  }
#line 455
  if (child_fd < 0) {
    {
#line 456
    err = child_fd;
#line 457
    error("Unable to open the tty in the child.");
    }
#line 458
    goto out_free_fds;
  }
  {
#line 461
  debug("Opened the new tty in the child: %d", child_fd);
#line 463
  err = ignore_hup(& child, scratch_page);
  }
#line 464
  if (err < 0) {
#line 465
    goto out_close;
  }
  {
#line 467
  tmp___12 = ptrace_syscall_numbers(& child);
#line 467
  tmp___13 = ptrace_remote_syscall(& child, (unsigned long )tmp___12->nr_getsid, 0UL,
                                   0UL, 0UL, 0UL, 0UL, 0UL);
#line 467
  err = (int )tmp___13;
  }
#line 468
  if (err != child.pid) {
    {
#line 469
    debug("Target is not a session leader, attempting to setsid.");
#line 470
    err = do_setsid(& child);
    }
  } else {
    {
#line 472
    tmp___14 = ptrace_syscall_numbers(& child);
#line 472
    ptrace_remote_syscall(& child, (unsigned long )tmp___14->nr_ioctl, (unsigned long )*(child_tty_fds + 0),
                          21538UL, 0UL, 0UL, 0UL, 0UL);
    }
  }
#line 474
  if (err < 0) {
#line 475
    goto out_close;
  }
  {
#line 477
  tmp___15 = ptrace_syscall_numbers(& child);
#line 477
  tmp___16 = ptrace_remote_syscall(& child, (unsigned long )tmp___15->nr_ioctl, (unsigned long )child_fd,
                                   21518UL, 0UL, 0UL, 0UL, 0UL);
#line 477
  err = (int )tmp___16;
  }
#line 478
  if (err < 0) {
    {
#line 479
    error("Unable to set controlling terminal.");
    }
#line 480
    goto out_close;
  }
  {
#line 483
  debug("Set the controlling tty");
#line 485
  i = 0;
  }
  {
#line 485
  while (1) {
    while_continue: /* CIL Label */ ;
#line 485
    if (! (i < n_fds)) {
#line 485
      goto while_break;
    }
    {
#line 486
    tmp___17 = ptrace_syscall_numbers(& child);
#line 486
    ptrace_remote_syscall(& child, (unsigned long )tmp___17->nr_dup2, (unsigned long )child_fd,
                          (unsigned long )*(child_tty_fds + i), 0UL, 0UL, 0UL, 0UL);
#line 485
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 489
  err = 0;
  out_close: 
  {
#line 492
  tmp___18 = ptrace_syscall_numbers(& child);
#line 492
  ptrace_remote_syscall(& child, (unsigned long )tmp___18->nr_close, (unsigned long )child_fd,
                        0UL, 0UL, 0UL, 0UL, 0UL);
  }
  out_free_fds: 
  {
#line 494
  free((void *)child_tty_fds);
  }
  out_unmap: 
  {
#line 497
  do_unmap(& child, scratch_page, (unsigned long )page_size);
#line 499
  ptrace_restore_regs(& child);
  }
  out_detach: 
  {
#line 501
  ptrace_detach_child(& child);
  }
#line 503
  if (err == 0) {
    {
#line 504
    kill(child.pid, 19);
#line 505
    wait_for_stop(child.pid, statfd);
    }
  }
  {
#line 507
  kill(child.pid, 28);
  }
  out_cont: 
  {
#line 509
  kill(child.pid, 18);
#line 510
  close(statfd);
  }
#line 512
  if (err < 0) {
#line 512
    tmp___19 = - err;
  } else {
#line 512
    tmp___19 = err;
  }
#line 512
  return (tmp___19);
}
}
