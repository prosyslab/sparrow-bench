/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 11 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.h"
struct dict_radix;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 90 "/usr/include/stdio.h"
typedef __off_t off_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 387 "/usr/include/x86_64-linux-gnu/zconf.h"
typedef void *voidp;
#line 1224 "/usr/include/zlib.h"
struct gzFile_s;
#line 1224 "/usr/include/zlib.h"
typedef struct gzFile_s *gzFile;
#line 1670 "/usr/include/zlib.h"
struct gzFile_s {
   unsigned int have ;
   unsigned char *next ;
   off_t pos ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gzbuffered.h"
struct __anonstruct_gzbFile_29 {
   gzFile gz ;
   char buf[4096] ;
   char *b ;
   int n ;
};
#line 32 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gzbuffered.h"
typedef struct __anonstruct_gzbFile_29 gzbFile;
#line 110 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
struct node_index {
   uint32_t val_or_index ;
};
#line 117 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
struct node {
   uint32_t value ;
   struct node_index children[29] ;
};
#line 121 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
struct node_small {
   uint32_t value ;
   char chars[2] ;
   struct node_index children[2] ;
};
#line 126 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
struct node_medium {
   uint32_t value ;
   char chars[8] ;
   struct node_index children[8] ;
};
#line 224 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
struct dict_radix {
   int nnodes_small ;
   int size_nodes_small ;
   struct node_small *nodes_small ;
   int nnodes_medium ;
   int size_nodes_medium ;
   struct node_medium *nodes_medium ;
   int nnodes ;
   int size_nodes ;
   struct node *nodes ;
   struct node_index head ;
   int free_nodes_small[16] ;
   int nfree_nodes_small ;
   int free_nodes_medium[16] ;
   int nfree_nodes_medium ;
   int nwords ;
};
#line 119 "/usr/include/stdint.h"
typedef long intptr_t;
#line 21 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef void *ClientData;
#line 22
struct Tcl_Obj;
#line 23 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef struct Tcl_Obj Tcl_Obj;
#line 28
struct Tcl_HashKeyType;
#line 28 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef struct Tcl_HashKeyType Tcl_HashKeyType;
#line 29
struct Tcl_HashTable;
#line 29 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef struct Tcl_HashTable Tcl_HashTable;
#line 30
struct Tcl_HashEntry;
#line 30 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef struct Tcl_HashEntry Tcl_HashEntry;
#line 31
struct Tcl_HashSearch;
#line 31 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef struct Tcl_HashSearch Tcl_HashSearch;
#line 33 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef unsigned int Tcl_HashKeyProc(Tcl_HashTable *tablePtr , void *keyPtr );
#line 35 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef int Tcl_CompareHashKeysProc(void *keyPtr , Tcl_HashEntry *hPtr );
#line 37 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef Tcl_HashEntry *Tcl_AllocHashEntryProc(Tcl_HashTable *tablePtr , void *keyPtr );
#line 39 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
typedef void Tcl_FreeHashEntryProc(Tcl_HashEntry *hPtr );
#line 47 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
union __anonunion_key_26 {
   char *oneWordValue ;
   Tcl_Obj *objPtr ;
   int words[1] ;
   char string[4] ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
struct Tcl_HashEntry {
   Tcl_HashEntry *nextPtr ;
   Tcl_HashTable *tablePtr ;
   unsigned int hash ;
   ClientData clientData ;
   union __anonunion_key_26 key ;
};
#line 96 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
struct Tcl_HashTable {
   Tcl_HashEntry **buckets ;
   Tcl_HashEntry *staticBuckets[4] ;
   int numBuckets ;
   int numEntries ;
   int rebuildSize ;
   int downShift ;
   int mask ;
   int keyType ;
   Tcl_HashKeyType *typePtr ;
};
#line 128 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
struct Tcl_HashSearch {
   Tcl_HashTable *tablePtr ;
   int nextIndex ;
   Tcl_HashEntry *nextEntryPtr ;
};
#line 93 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
struct Tcl_HashKeyType {
   int version ;
   int flags ;
   Tcl_HashKeyProc *hashKeyProc ;
   Tcl_CompareHashKeysProc *compareKeysProc ;
   Tcl_AllocHashEntryProc *allocEntryProc ;
   Tcl_FreeHashEntryProc *freeEntryProc ;
};
#line 186 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __intptr_t;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 38 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
typedef Tcl_HashTable hspell_hash;
#line 73 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
struct __anonstruct_hspell_hash_keyvalue_30 {
   char const   *key ;
   intptr_t value ;
};
#line 73 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
typedef struct __anonstruct_hspell_hash_keyvalue_30 hspell_hash_keyvalue;
#line 20 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.h"
struct corlist;
#line 50 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.h"
struct corlist {
   char correction[50][30] ;
   int n ;
};
#line 68 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.h"
typedef int hspell_word_split_callback_func(char const   *word , char const   *baseword ,
                                            int preflen , int prefspec );
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 59 "/usr/include/time.h"
typedef __clock_t clock_t;
#line 80 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
struct prefix_node {
   int mask ;
   struct prefix_node *next[27] ;
};
#line 13 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.h"
struct dict_radix *new_dict_radix(void) ;
#line 15
int allocate_nodes(struct dict_radix *dict , int nsmall , int nmedium , int nfull ) ;
#line 17
int read_dict(struct dict_radix *dict , char const   *dir ) ;
#line 19
void print_sizes(struct dict_radix *dict ) ;
#line 20
void print_stats(struct dict_radix *dict ) ;
#line 11 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/find_sizes.c"
int main(int argc , char **argv ) 
{ 
  struct dict_radix *dict ;
  struct dict_radix *tmp ;

  {
  {
#line 14
  tmp = new_dict_radix();
#line 14
  dict = tmp;
#line 16
  allocate_nodes(dict, 200000, 100000, 10000);
#line 18
  read_dict(dict, (char const   *)((void *)0));
#line 19
  print_sizes(dict);
#line 20
  print_stats(dict);
  }
#line 21
  return (0);
}
}
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 1264 "/usr/include/zlib.h"
extern gzFile gzdopen(int fd , char const   *mode ) ;
#line 1313
extern int gzread(gzFile file , voidp buf , unsigned int len ) ;
#line 1511
extern int gzclose(gzFile file ) ;
#line 1725
extern gzFile gzopen(char const   * , char const   * ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gzbuffered.h"
__inline static gzbFile *gzb_open(char const   *path , char const   *mode ) 
{ 
  gzbFile *ret ;
  void *tmp ;

  {
  {
#line 42
  tmp = malloc(sizeof(gzbFile ));
#line 42
  ret = (gzbFile *)tmp;
  }
#line 43
  if (! ret) {
#line 44
    return ((gzbFile *)((void *)0));
  }
  {
#line 45
  ret->n = 0;
#line 46
  ret->gz = gzopen(path, mode);
  }
#line 47
  if (! ret->gz) {
    {
#line 48
    free((void *)ret);
    }
#line 49
    return ((gzbFile *)((void *)0));
  }
#line 52
  return (ret);
}
}
#line 55 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gzbuffered.h"
__inline static gzbFile *gzb_dopen(int fd , char const   *mode ) 
{ 
  gzbFile *ret ;
  void *tmp ;

  {
  {
#line 58
  tmp = malloc(sizeof(gzbFile ));
#line 58
  ret = (gzbFile *)tmp;
  }
#line 59
  if (! ret) {
#line 60
    return ((gzbFile *)((void *)0));
  }
  {
#line 61
  ret->n = 0;
#line 62
  ret->gz = gzdopen(fd, mode);
  }
#line 63
  if (! ret->gz) {
    {
#line 64
    free((void *)ret);
    }
#line 65
    return ((gzbFile *)((void *)0));
  }
#line 67
  return (ret);
}
}
#line 70 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gzbuffered.h"
__inline static int gzb_close(gzbFile *f ) 
{ 
  int ret ;

  {
  {
#line 74
  ret = gzclose(f->gz);
#line 75
  free((void *)f);
  }
#line 76
  return (ret);
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gzbuffered.h"
__inline static int gzb_getc(gzbFile *gzbp ) 
{ 
  char *tmp ;

  {
#line 81
  if (! gzbp->n) {
    {
#line 83
    gzbp->n = gzread(gzbp->gz, (voidp )(gzbp->buf), (unsigned int )sizeof(gzbp->buf));
    }
#line 84
    if (gzbp->n <= 0) {
#line 85
      gzbp->n = 0;
#line 86
      return (-1);
    }
#line 88
    gzbp->b = gzbp->buf;
  }
#line 91
  (gzbp->n) --;
#line 92
  tmp = gzbp->b;
#line 92
  (gzbp->b) ++;
#line 92
  return ((int )*tmp);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
__inline static int char_to_letter(unsigned char c ) 
{ 


  {
#line 140
  if ((int )c >= 224) {
#line 140
    if ((int )c < 251) {
#line 141
      return (((int )c - 224) + 2);
    } else {
#line 140
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 142
  if ((int )c == 34) {
#line 143
    return (0);
  } else
#line 144
  if ((int )c == 39) {
#line 145
    return (1);
  } else {
    {
#line 147
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: unknown letter %c...\n",
            (int )c);
    }
#line 149
    return (0);
  }
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
__inline static unsigned char letter_to_char(int l ) 
{ 


  {
#line 155
  if (l >= 2) {
#line 155
    if (l < 29) {
#line 156
      return ((unsigned char )((l + 224) - 2));
    } else {
#line 155
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 157
  if (l == 0) {
#line 158
    return ((unsigned char )'\"');
  } else
#line 159
  if (l == 1) {
#line 160
    return ((unsigned char )'\'');
  } else {
    {
#line 163
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: internal error: unknown letter %d... exiting.\n",
            l);
#line 165
    exit(1);
    }
  }
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
static void do_print_tree(struct node *nodes , struct node_small *nodes_small , struct node_medium *nodes_medium ,
                          struct node_index head , char *word , int len , int maxlen ) 
{ 
  int i ;
  struct node *n ;
  unsigned char tmp ;
  struct node_small *n___0 ;
  struct node_medium *n___1 ;

  {
#line 177
  if (len >= maxlen) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_print_tree(): warning: buffer overflow.\n");
    }
#line 179
    return;
  }
#line 181
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 3U << 30) {
#line 182
    n = nodes + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 183
    if (n->value) {
      {
#line 184
      *(word + len) = (char )'\000';
#line 185
      printf((char const   */* __restrict  */)"%s %d\n", word, n->value);
      }
    }
#line 187
    i = 0;
    {
#line 187
    while (1) {
      while_continue: /* CIL Label */ ;
#line 187
      if (! (i < 29)) {
#line 187
        goto while_break;
      }
      {
#line 188
      tmp = letter_to_char(i);
#line 188
      *(word + len) = (char )tmp;
#line 189
      do_print_tree(nodes, nodes_small, nodes_medium, n->children[i], word, len + 1,
                    maxlen);
#line 187
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 192
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 193
    n___0 = nodes_small + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 194
    if (n___0->value) {
      {
#line 195
      *(word + len) = (char )'\000';
#line 196
      printf((char const   */* __restrict  */)"%s %d\n", word, n___0->value);
      }
    }
#line 198
    i = 0;
    {
#line 198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! (i < 2)) {
#line 198
        goto while_break___0;
      }
#line 199
      if (n___0->chars[i]) {
        {
#line 200
        *(word + len) = n___0->chars[i];
#line 201
        do_print_tree(nodes, nodes_small, nodes_medium, n___0->children[i], word,
                      len + 1, maxlen);
        }
      }
#line 198
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 205
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 206
    n___1 = nodes_medium + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 207
    if (n___1->value) {
      {
#line 208
      *(word + len) = (char )'\000';
#line 209
      printf((char const   */* __restrict  */)"%s %d\n", word, n___1->value);
      }
    }
#line 211
    i = 0;
    {
#line 211
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 211
      if (! (i < 8)) {
#line 211
        goto while_break___1;
      }
#line 212
      if (n___1->chars[i]) {
        {
#line 213
        *(word + len) = n___1->chars[i];
#line 214
        do_print_tree(nodes, nodes_small, nodes_medium, n___1->children[i], word,
                      len + 1, maxlen);
        }
      }
#line 211
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 218
  if (head.val_or_index) {
    {
#line 219
    *(word + len) = (char )'\000';
#line 220
    printf((char const   */* __restrict  */)"%s %d\n", word, head.val_or_index);
    }
  }
#line 222
  return;
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
struct dict_radix *new_dict_radix(void) 
{ 
  struct dict_radix *dict ;
  void *tmp ;

  {
  {
#line 257
  tmp = malloc(sizeof(struct dict_radix ));
#line 257
  dict = (struct dict_radix *)tmp;
  }
#line 259
  if (dict) {
    {
#line 260
    memset((void *)dict, 0, sizeof(*dict));
    }
  }
#line 261
  return (dict);
}
}
#line 268 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
void delete_dict_radix(struct dict_radix *dict ) 
{ 


  {
#line 271
  if (! dict) {
#line 272
    return;
  }
#line 273
  if (dict->nodes_small) {
    {
#line 274
    free((void *)dict->nodes_small);
    }
  }
#line 275
  if (dict->nodes_medium) {
    {
#line 276
    free((void *)dict->nodes_medium);
    }
  }
#line 277
  if (dict->nodes) {
    {
#line 278
    free((void *)dict->nodes);
    }
  }
  {
#line 279
  free((void *)dict);
  }
#line 280
  return;
}
}
#line 282 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
int allocate_nodes(struct dict_radix *dict , int nsmall , int nmedium , int nfull ) 
{ 
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 286
  if (dict->nodes) {
#line 287
    return (-1);
  }
  {
#line 289
  tmp = malloc(sizeof(struct node_small ) * (unsigned long )nsmall);
#line 289
  dict->nodes_small = (struct node_small *)tmp;
#line 290
  dict->size_nodes_small = nsmall;
#line 292
  tmp___0 = malloc(sizeof(struct node_medium ) * (unsigned long )nmedium);
#line 292
  dict->nodes_medium = (struct node_medium *)tmp___0;
#line 293
  dict->size_nodes_medium = nmedium;
#line 295
  tmp___1 = malloc(sizeof(struct node ) * (unsigned long )nfull);
#line 295
  dict->nodes = (struct node *)tmp___1;
#line 296
  dict->size_nodes = nfull;
  }
#line 298
  if ((unsigned long )dict->nodes_small == (unsigned long )((void *)0)) {
#line 300
    return (-2);
  } else
#line 298
  if ((unsigned long )dict->nodes_medium == (unsigned long )((void *)0)) {
#line 300
    return (-2);
  } else
#line 298
  if ((unsigned long )dict->nodes == (unsigned long )((void *)0)) {
#line 300
    return (-2);
  }
#line 302
  return (0);
}
}
#line 318
static int do_read_dict(void *fp , void *prefixes , struct dict_radix *dict ) ;
#line 323 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
int read_dict(struct dict_radix *dict , char const   *dir ) 
{ 
  void *fp ;
  char s[1024] ;
  int small ;
  int medium ;
  int full ;
  int ret ;
  void *prefixes ;
  FILE *tmp ;
  int tmp___0 ;
  gzbFile *tmp___1 ;
  gzbFile *tmp___2 ;
  void *in ;
  int tmp___3 ;
  gzbFile *tmp___4 ;
  void *zero ;
  gzbFile *tmp___5 ;
  int tmp___6 ;

  {
#line 326
  if (dir) {
    {
#line 334
    snprintf((char */* __restrict  */)(s), sizeof(s), (char const   */* __restrict  */)"%s.sizes",
             dir);
#line 335
    tmp = fopen((char const   */* __restrict  */)(s), (char const   */* __restrict  */)"r");
#line 335
    fp = (void *)tmp;
    }
#line 335
    if (! fp) {
      {
#line 336
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: can\'t open %s.\n",
              s);
      }
#line 337
      return (0);
    }
    {
#line 339
    tmp___0 = fscanf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d %d %d",
                     & small, & medium, & full);
    }
#line 339
    if (tmp___0 != 3) {
      {
#line 340
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: can\'t read from %s.\n",
              s);
      }
#line 341
      return (0);
    }
    {
#line 343
    fclose((FILE *)fp);
#line 346
    tmp___1 = gzb_open(dir, "r");
#line 346
    fp = (void *)tmp___1;
    }
#line 346
    if (! fp) {
      {
#line 347
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: can\'t open %s.\n",
              dir);
      }
#line 348
      return (0);
    }
    {
#line 360
    snprintf((char */* __restrict  */)(s), sizeof(s), (char const   */* __restrict  */)"%s.prefixes",
             dir);
#line 361
    tmp___2 = gzb_open((char const   *)(s), "rb");
#line 361
    prefixes = (void *)tmp___2;
    }
#line 361
    if (! prefixes) {
      {
#line 362
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: can\'t open %s.\n",
              s);
      }
#line 363
      return (0);
    }
    {
#line 374
    allocate_nodes(dict, small, medium, full);
#line 376
    ret = do_read_dict(fp, prefixes, dict);
#line 377
    gzb_close((gzbFile *)prefixes);
#line 381
    gzb_close((gzbFile *)fp);
    }
#line 382
    return (ret);
  } else {
    {
#line 386
    tmp___3 = fileno(stdin);
#line 386
    tmp___4 = gzb_dopen(tmp___3, "r");
#line 386
    in = (void *)tmp___4;
#line 388
    tmp___5 = gzb_open("/dev/zero", "r");
#line 388
    zero = (void *)tmp___5;
#line 398
    tmp___6 = do_read_dict(in, zero, dict);
    }
#line 398
    return (tmp___6);
  }
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
static int do_read_dict(void *fp , void *prefixes , struct dict_radix *dict ) 
{ 
  struct node_index *stack[256] ;
  int sdepth ;
  int c ;
  int n ;
  int cc ;
  int nwords ;
  struct node *nodes ;
  struct node_small *nodes_small ;
  struct node_medium *nodes_medium ;
  int nnodes_small ;
  int nnodes_medium ;
  int nnodes ;
  int tmp ;
  int tmp___0 ;
  int chosen ;
  int j ;
  struct node_small *n___0 ;
  int chosen___0 ;
  int tmp___1 ;
  int j___0 ;
  struct node_medium *n___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 412
  sdepth = 0;
#line 415
  nwords = 0;
#line 416
  nodes = dict->nodes;
#line 417
  nodes_small = dict->nodes_small;
#line 418
  nodes_medium = dict->nodes_medium;
#line 419
  nnodes_small = 0;
#line 419
  nnodes_medium = 0;
#line 419
  nnodes = 0;
#line 421
  if (dict->nnodes) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_small) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_medium) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nwords) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
#line 425
    return (0);
  }
#line 427
  if (! nodes) {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_small) {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_medium) {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
#line 430
    return (0);
  }
  {
#line 433
  memset((void *)(nodes + nnodes), 0, sizeof(*(nodes + nnodes)));
#line 434
  tmp = nnodes;
#line 434
  nnodes ++;
#line 434
  dict->head.val_or_index = (unsigned int )tmp | (3U << 30);
#line 435
  stack[0] = & dict->head;
#line 436
  sdepth = 0;
  }
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 437
    c = gzb_getc((gzbFile *)fp);
    }
#line 437
    if (! (c != -1)) {
#line 437
      goto while_break;
    }
#line 438
    if (c >= 48) {
#line 438
      if (c <= 57) {
        {
#line 440
        nwords ++;
#line 443
        tmp___0 = gzb_getc((gzbFile *)prefixes);
#line 443
        (stack[sdepth])->val_or_index = (uint32_t )tmp___0;
#line 448
        n = 0;
        }
        {
#line 449
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 451
          n *= 10;
#line 452
          n += c - 48;
#line 449
          c = gzb_getc((gzbFile *)fp);
          }
#line 449
          if (c != -1) {
#line 449
            if (c >= 48) {
#line 449
              if (! (c <= 57)) {
#line 449
                goto while_break___0;
              }
            } else {
#line 449
              goto while_break___0;
            }
          } else {
#line 449
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 454
        sdepth -= n;
#line 455
        if (sdepth < 0) {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
#line 457
          return (0);
        } else
#line 455
        if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
#line 457
          return (0);
        }
      }
    }
#line 462
    if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: word too long... giving up\n");
      }
#line 464
      return (0);
    }
    {
#line 466
    cc = char_to_letter((unsigned char )c);
    }
#line 469
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 0U) {
#line 471
      if (dict->nfree_nodes_small) {
#line 472
        (dict->nfree_nodes_small) --;
#line 472
        chosen = dict->free_nodes_small[dict->nfree_nodes_small];
      } else {
#line 475
        chosen = nnodes_small;
#line 476
        if (nnodes_small >= dict->size_nodes_small) {
          {
#line 477
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (small) - failing.\n");
          }
#line 478
          return (0);
        }
#line 480
        nnodes_small ++;
      }
      {
#line 482
      memset((void *)(nodes_small + chosen), 0, sizeof(*(nodes_small + chosen)));
#line 483
      (nodes_small + chosen)->value = (stack[sdepth])->val_or_index;
#line 484
      (stack[sdepth])->val_or_index = (unsigned int )chosen | (1U << 30);
#line 486
      (nodes_small + chosen)->chars[0] = (char )c;
#line 487
      stack[sdepth + 1] = & (nodes_small + chosen)->children[0];
      }
    } else
#line 488
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 490
      n___0 = nodes_small + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 493
      j = 0;
      {
#line 493
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 493
        if (! (j < 2)) {
#line 493
          goto while_break___1;
        }
#line 494
        if (! n___0->chars[j]) {
#line 495
          n___0->chars[j] = (char )c;
#line 496
          stack[sdepth + 1] = & n___0->children[j];
#line 497
          goto while_break___1;
        }
#line 493
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 499
      if (j == 2) {
#line 502
        if (dict->nfree_nodes_medium) {
#line 503
          (dict->nfree_nodes_medium) --;
#line 503
          chosen___0 = dict->free_nodes_medium[dict->nfree_nodes_medium];
        } else {
#line 506
          chosen___0 = nnodes_medium;
#line 507
          if (nnodes_medium >= dict->size_nodes_medium) {
            {
#line 508
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (medium) - failing.\n");
            }
#line 509
            return (0);
          }
#line 511
          nnodes_medium ++;
        }
        {
#line 513
        memset((void *)(nodes_medium + chosen___0), 0, sizeof(*(nodes_medium + chosen___0)));
        }
#line 514
        if ((unsigned long )dict->nfree_nodes_small >= sizeof(dict->free_nodes_small) / sizeof(dict->free_nodes_small[0])) {
          {
#line 517
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_small.\n");
          }
#line 518
          return (0);
        }
#line 520
        tmp___1 = dict->nfree_nodes_small;
#line 520
        (dict->nfree_nodes_small) ++;
#line 520
        dict->free_nodes_small[tmp___1] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 523
        (stack[sdepth])->val_or_index = (unsigned int )chosen___0 | (2U << 30);
#line 526
        (nodes_medium + chosen___0)->value = n___0->value;
#line 527
        j = 0;
        {
#line 527
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 527
          if (! (j < 2)) {
#line 527
            goto while_break___2;
          }
#line 528
          (nodes_medium + chosen___0)->chars[j] = n___0->chars[j];
#line 530
          (nodes_medium + chosen___0)->children[j] = n___0->children[j];
#line 527
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 534
        (nodes_medium + chosen___0)->chars[2] = (char )c;
#line 536
        stack[sdepth + 1] = & (nodes_medium + chosen___0)->children[2];
      }
    } else
#line 539
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 541
      n___1 = nodes_medium + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 544
      j___0 = 0;
      {
#line 544
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 544
        if (! (j___0 < 8)) {
#line 544
          goto while_break___3;
        }
#line 545
        if (! n___1->chars[j___0]) {
#line 546
          n___1->chars[j___0] = (char )c;
#line 547
          stack[sdepth + 1] = & n___1->children[j___0];
#line 548
          goto while_break___3;
        }
#line 544
        j___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 550
      if (j___0 == 8) {
#line 552
        if (nnodes >= dict->size_nodes) {
          {
#line 553
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (full) - failing.\n");
          }
#line 554
          return (0);
        }
        {
#line 556
        memset((void *)(nodes + nnodes), 0, sizeof(*(nodes + nnodes)));
#line 557
        (nodes + nnodes)->value = n___1->value;
        }
#line 558
        if ((unsigned long )dict->nfree_nodes_medium >= sizeof(dict->free_nodes_medium) / sizeof(dict->free_nodes_medium[0])) {
          {
#line 561
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_medium.\n");
          }
#line 562
          return (0);
        }
#line 564
        tmp___2 = dict->nfree_nodes_medium;
#line 564
        (dict->nfree_nodes_medium) ++;
#line 564
        dict->free_nodes_medium[tmp___2] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 567
        (stack[sdepth])->val_or_index = (unsigned int )nnodes | (3U << 30);
#line 569
        j___0 = 0;
        {
#line 569
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 569
          if (! (j___0 < 8)) {
#line 569
            goto while_break___4;
          }
          {
#line 570
          tmp___3 = char_to_letter((unsigned char )n___1->chars[j___0]);
#line 570
          (nodes + nnodes)->children[tmp___3] = n___1->children[j___0];
#line 569
          j___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 574
        stack[sdepth + 1] = & (nodes + nnodes)->children[cc];
#line 575
        nnodes ++;
      }
    } else {
#line 578
      stack[sdepth + 1] = & (nodes + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30))))->children[cc];
    }
#line 581
    sdepth ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 584
  nwords ++;
#line 586
  tmp___4 = gzb_getc((gzbFile *)prefixes);
#line 586
  (stack[sdepth])->val_or_index = (uint32_t )tmp___4;
#line 592
  dict->nwords = nwords;
#line 593
  dict->nnodes_small = nnodes_small;
#line 594
  dict->nnodes_medium = nnodes_medium;
#line 595
  dict->nnodes = nnodes;
  }
#line 597
  return (1);
}
}
#line 600 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
void print_stats(struct dict_radix *dict ) 
{ 


  {
  {
#line 603
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d words in %d full nodes, %d medium nodes, %d small nodes.\n",
          dict->nwords, dict->nnodes, dict->nnodes_medium, dict->nnodes_small);
#line 606
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%d nfree_nodes_small %d nfree_nodes_medium.\n",
          dict->nfree_nodes_small, dict->nfree_nodes_medium);
#line 608
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"node memory filled: %d K\n",
          (int )(((unsigned long )dict->nnodes * sizeof(struct node ) + (unsigned long )dict->nnodes_small * sizeof(struct node_small )) + (unsigned long )dict->nnodes_medium * sizeof(struct node_medium )) / 1024);
  }
#line 613
  return;
}
}
#line 615 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
void print_tree(struct dict_radix *dict ) 
{ 
  char word[256] ;

  {
  {
#line 619
  do_print_tree(dict->nodes, dict->nodes_small, dict->nodes_medium, dict->head, word,
                0, (int )sizeof(word));
  }
#line 622
  return;
}
}
#line 624 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
void print_sizes(struct dict_radix *dict ) 
{ 


  {
  {
#line 627
  printf((char const   */* __restrict  */)"%d %d %d\n", dict->nnodes_small, dict->nnodes_medium,
         dict->nnodes);
  }
#line 629
  return;
}
}
#line 631 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
int lookup(struct dict_radix  const  *dict , char const   *word ) 
{ 
  struct node_index current ;
  struct node_small *n ;
  struct node_medium *n___0 ;
  register char c ;
  register char *cs ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  register int ind ;
  register unsigned char c___0 ;

  {
#line 634
  current = dict->head;
  {
#line 635
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 637
    if ((current.val_or_index & ((1U << 31) | (1U << 30))) == 0U) {
#line 637
      goto case_0;
    }
#line 646
    if ((current.val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 646
      goto case_exp;
    }
#line 667
    if ((current.val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 667
      goto case_exp___0;
    }
#line 696
    if ((current.val_or_index & ((1U << 31) | (1U << 30))) == 3U << 30) {
#line 696
      goto case_exp___1;
    }
#line 636
    goto switch_break;
    case_0: /* CIL Label */ 
#line 638
    if (*word) {
#line 641
      return (0);
    } else {
#line 643
      return ((int )(current.val_or_index & ~ ((1U << 31) | (1U << 30))));
    }
#line 645
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 647
    if (*word) {
#line 648
      n = dict->nodes_small + (current.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 652
      if ((int )n->chars[0] == (int )*word) {
#line 653
        current = n->children[0];
      } else
#line 654
      if ((int )n->chars[1] == (int )*word) {
#line 655
        current = n->children[1];
      } else {
#line 657
        return (0);
      }
    } else {
#line 662
      return ((int )(dict->nodes_small + (current.val_or_index & ~ ((1U << 31) | (1U << 30))))->value);
    }
#line 666
    goto switch_break;
    case_exp___0: /* CIL Label */ 
#line 668
    if (*word) {
#line 669
      n___0 = dict->nodes_medium + (current.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 673
      c = (char )*word;
#line 673
      cs = n___0->chars;
#line 677
      tmp___6 = cs;
#line 677
      cs ++;
#line 677
      if ((int )*tmp___6 == (int )c) {
#line 677
        current = n___0->children[0];
      } else {
#line 678
        tmp___5 = cs;
#line 678
        cs ++;
#line 678
        if ((int )*tmp___5 == (int )c) {
#line 678
          current = n___0->children[1];
        } else {
#line 679
          tmp___4 = cs;
#line 679
          cs ++;
#line 679
          if ((int )*tmp___4 == (int )c) {
#line 679
            current = n___0->children[2];
          } else {
#line 680
            tmp___3 = cs;
#line 680
            cs ++;
#line 680
            if ((int )*tmp___3 == (int )c) {
#line 680
              current = n___0->children[3];
            } else {
#line 681
              tmp___2 = cs;
#line 681
              cs ++;
#line 681
              if ((int )*tmp___2 == (int )c) {
#line 681
                current = n___0->children[4];
              } else {
#line 682
                tmp___1 = cs;
#line 682
                cs ++;
#line 682
                if ((int )*tmp___1 == (int )c) {
#line 682
                  current = n___0->children[5];
                } else {
#line 683
                  tmp___0 = cs;
#line 683
                  cs ++;
#line 683
                  if ((int )*tmp___0 == (int )c) {
#line 683
                    current = n___0->children[6];
                  } else {
#line 684
                    tmp = cs;
#line 684
                    cs ++;
#line 684
                    if ((int )*tmp == (int )c) {
#line 684
                      current = n___0->children[7];
                    } else {
#line 686
                      return (0);
                    }
                  }
                }
              }
            }
          }
        }
      }
    } else {
#line 691
      return ((int )(dict->nodes_medium + (current.val_or_index & ~ ((1U << 31) | (1U << 30))))->value);
    }
#line 695
    goto switch_break;
    case_exp___1: /* CIL Label */ 
#line 697
    if (*word) {
#line 700
      c___0 = (unsigned char )*word;
#line 701
      if ((int )c___0 >= 224) {
#line 701
        if ((int )c___0 < 251) {
#line 703
          ind = ((int )c___0 - 224) + 2;
        } else {
#line 701
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 704
      if ((int )c___0 == 34) {
#line 705
        ind = 0;
      } else
#line 706
      if ((int )c___0 == 39) {
#line 707
        ind = 1;
      } else {
#line 709
        return (0);
      }
#line 710
      current = (dict->nodes + (current.val_or_index & ~ ((1U << 31) | (1U << 30))))->children[ind];
    } else {
#line 714
      return ((int )(dict->nodes + (current.val_or_index & ~ ((1U << 31) | (1U << 30))))->value);
    }
#line 717
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 719
    word ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.h"
Tcl_HashEntry *Tcl_NextHashEntry(Tcl_HashSearch *searchPtr ) ;
#line 82
Tcl_HashEntry *Tcl_FirstHashEntry(Tcl_HashTable *tablePtr , Tcl_HashSearch *searchPtr ) ;
#line 84
void Tcl_InitHashTable(Tcl_HashTable *tablePtr , int keyType ) ;
#line 85
void Tcl_DeleteHashTable(Tcl_HashTable *tablePtr ) ;
#line 86
Tcl_HashEntry *Tcl_CreateHashEntry(Tcl_HashTable *tablePtr , char const   *key , int *newPtr ) ;
#line 87
Tcl_HashEntry *Tcl_FindHashEntry(Tcl_HashTable *tablePtr , char const   *key ) ;
#line 156 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
static Tcl_HashEntry *AllocStringEntry(Tcl_HashTable *tablePtr , void *keyPtr ) ;
#line 159
static int CompareStringKeys(void *keyPtr , Tcl_HashEntry *hPtr ) ;
#line 161
static unsigned int HashStringKey(Tcl_HashTable *tablePtr , void *keyPtr ) ;
#line 169
static void RebuildTable(Tcl_HashTable *tablePtr ) ;
#line 171 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
Tcl_HashKeyType tclStringHashKeyType  =    {1, 0, & HashStringKey, & CompareStringKeys, & AllocStringEntry, (Tcl_FreeHashEntryProc *)((void *)0)};
#line 200 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
void Tcl_InitHashTable(Tcl_HashTable *tablePtr , int keyType ) 
{ 
  Tcl_HashEntry *tmp ;
  Tcl_HashEntry *tmp___0 ;

  {
#line 213
  tablePtr->buckets = tablePtr->staticBuckets;
#line 214
  tmp = (Tcl_HashEntry *)0;
#line 214
  tablePtr->staticBuckets[1] = tmp;
#line 214
  tablePtr->staticBuckets[0] = tmp;
#line 215
  tmp___0 = (Tcl_HashEntry *)0;
#line 215
  tablePtr->staticBuckets[3] = tmp___0;
#line 215
  tablePtr->staticBuckets[2] = tmp___0;
#line 216
  tablePtr->numBuckets = 4;
#line 217
  tablePtr->numEntries = 0;
#line 218
  tablePtr->rebuildSize = 12;
#line 219
  tablePtr->downShift = 28;
#line 220
  tablePtr->mask = 3;
#line 221
  tablePtr->keyType = keyType;
#line 225
  if (keyType == 0) {
#line 226
    tablePtr->typePtr = & tclStringHashKeyType;
  } else {
    {
#line 229
    abort();
    }
  }
#line 231
  return;
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
Tcl_HashEntry *Tcl_FindHashEntry(Tcl_HashTable *tablePtr , char const   *key ) 
{ 
  register Tcl_HashEntry *hPtr ;
  Tcl_HashKeyType *typePtr ;
  unsigned int hash ;
  int index___0 ;
  int tmp ;

  {
#line 260
  typePtr = tablePtr->typePtr;
#line 261
  if ((unsigned long )typePtr == (unsigned long )((void *)0)) {
#line 263
    return ((Tcl_HashEntry *)((void *)0));
  }
#line 266
  if (typePtr->hashKeyProc) {
    {
#line 267
    hash = (*(typePtr->hashKeyProc))(tablePtr, (void *)key);
    }
#line 268
    if (typePtr->flags & 1) {
#line 269
      index___0 = (int )(((long )hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
    } else {
#line 271
      index___0 = (int )(hash & (unsigned int )tablePtr->mask);
    }
  } else {
#line 274
    hash = (unsigned int )((intptr_t )key);
#line 275
    index___0 = (int )(((long )hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
  }
#line 282
  if (typePtr->compareKeysProc) {
#line 283
    hPtr = *(tablePtr->buckets + index___0);
    {
#line 283
    while (1) {
      while_continue: /* CIL Label */ ;
#line 283
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 283
        goto while_break;
      }
#line 285
      if (hash != hPtr->hash) {
#line 286
        goto __Cont;
      }
      {
#line 288
      tmp = (*(typePtr->compareKeysProc))((void *)key, hPtr);
      }
#line 288
      if (tmp) {
#line 289
        return (hPtr);
      }
      __Cont: /* CIL Label */ 
#line 283
      hPtr = hPtr->nextPtr;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 293
    hPtr = *(tablePtr->buckets + index___0);
    {
#line 293
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 293
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 293
        goto while_break___0;
      }
#line 295
      if (hash != hPtr->hash) {
#line 296
        goto __Cont___0;
      }
#line 298
      if ((unsigned long )key == (unsigned long )hPtr->key.oneWordValue) {
#line 299
        return (hPtr);
      }
      __Cont___0: /* CIL Label */ 
#line 293
      hPtr = hPtr->nextPtr;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 304
  return ((Tcl_HashEntry *)((void *)0));
}
}
#line 328 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
Tcl_HashEntry *Tcl_CreateHashEntry(Tcl_HashTable *tablePtr , char const   *key , int *newPtr ) 
{ 
  register Tcl_HashEntry *hPtr ;
  Tcl_HashKeyType *typePtr ;
  unsigned int hash ;
  int index___0 ;
  int tmp ;
  void *tmp___0 ;

  {
#line 341
  typePtr = tablePtr->typePtr;
#line 342
  if ((unsigned long )typePtr == (unsigned long )((void *)0)) {
#line 344
    return ((Tcl_HashEntry *)((void *)0));
  }
#line 347
  if (typePtr->hashKeyProc) {
    {
#line 348
    hash = (*(typePtr->hashKeyProc))(tablePtr, (void *)key);
    }
#line 349
    if (typePtr->flags & 1) {
#line 350
      index___0 = (int )(((long )hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
    } else {
#line 352
      index___0 = (int )(hash & (unsigned int )tablePtr->mask);
    }
  } else {
#line 355
    hash = (unsigned int )((intptr_t )key);
#line 356
    index___0 = (int )(((long )hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
  }
#line 363
  if (typePtr->compareKeysProc) {
#line 364
    hPtr = *(tablePtr->buckets + index___0);
    {
#line 364
    while (1) {
      while_continue: /* CIL Label */ ;
#line 364
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 364
        goto while_break;
      }
#line 366
      if (hash != hPtr->hash) {
#line 367
        goto __Cont;
      }
      {
#line 369
      tmp = (*(typePtr->compareKeysProc))((void *)key, hPtr);
      }
#line 369
      if (tmp) {
#line 370
        *newPtr = 0;
#line 371
        return (hPtr);
      }
      __Cont: /* CIL Label */ 
#line 364
      hPtr = hPtr->nextPtr;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 375
    hPtr = *(tablePtr->buckets + index___0);
    {
#line 375
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 375
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 375
        goto while_break___0;
      }
#line 377
      if (hash != hPtr->hash) {
#line 378
        goto __Cont___0;
      }
#line 380
      if ((unsigned long )key == (unsigned long )hPtr->key.oneWordValue) {
#line 381
        *newPtr = 0;
#line 382
        return (hPtr);
      }
      __Cont___0: /* CIL Label */ 
#line 375
      hPtr = hPtr->nextPtr;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 391
  *newPtr = 1;
#line 392
  if (typePtr->allocEntryProc) {
    {
#line 393
    hPtr = (*(typePtr->allocEntryProc))(tablePtr, (void *)key);
    }
  } else {
    {
#line 395
    tmp___0 = malloc((size_t )((unsigned int )sizeof(Tcl_HashEntry )));
#line 395
    hPtr = (Tcl_HashEntry *)tmp___0;
#line 396
    hPtr->key.oneWordValue = (char *)key;
    }
  }
#line 399
  hPtr->tablePtr = tablePtr;
#line 400
  hPtr->hash = hash;
#line 401
  hPtr->nextPtr = *(tablePtr->buckets + index___0);
#line 402
  *(tablePtr->buckets + index___0) = hPtr;
#line 403
  hPtr->clientData = (ClientData )0;
#line 404
  (tablePtr->numEntries) ++;
#line 411
  if (tablePtr->numEntries >= tablePtr->rebuildSize) {
    {
#line 412
    RebuildTable(tablePtr);
    }
  }
#line 414
  return (hPtr);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
void Tcl_DeleteHashEntry(Tcl_HashEntry *entryPtr ) 
{ 
  register Tcl_HashEntry *prevPtr ;
  Tcl_HashKeyType *typePtr ;
  Tcl_HashTable *tablePtr ;
  Tcl_HashEntry **bucketPtr ;
  int index___0 ;

  {
#line 446
  tablePtr = entryPtr->tablePtr;
#line 447
  typePtr = tablePtr->typePtr;
#line 450
  if ((unsigned long )typePtr->hashKeyProc == (unsigned long )((void *)0)) {
#line 452
    index___0 = (int )(((long )entryPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
  } else
#line 450
  if (typePtr->flags & 1) {
#line 452
    index___0 = (int )(((long )entryPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
  } else {
#line 454
    index___0 = (int )(entryPtr->hash & (unsigned int )tablePtr->mask);
  }
#line 457
  bucketPtr = tablePtr->buckets + index___0;
#line 459
  if ((unsigned long )*bucketPtr == (unsigned long )entryPtr) {
#line 460
    *bucketPtr = entryPtr->nextPtr;
  } else {
#line 462
    prevPtr = *bucketPtr;
    {
#line 462
    while (1) {
      while_continue: /* CIL Label */ ;
#line 466
      if ((unsigned long )prevPtr->nextPtr == (unsigned long )entryPtr) {
#line 467
        prevPtr->nextPtr = entryPtr->nextPtr;
#line 468
        goto while_break;
      }
#line 462
      prevPtr = prevPtr->nextPtr;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 473
  (tablePtr->numEntries) --;
#line 474
  if (typePtr->freeEntryProc) {
    {
#line 475
    (*(typePtr->freeEntryProc))(entryPtr);
    }
  } else {
    {
#line 477
    free((void *)((char *)entryPtr));
    }
  }
#line 479
  return;
}
}
#line 498 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
void Tcl_DeleteHashTable(Tcl_HashTable *tablePtr ) 
{ 
  register Tcl_HashEntry *hPtr ;
  register Tcl_HashEntry *nextPtr ;
  Tcl_HashKeyType *typePtr ;
  int i ;

  {
#line 506
  typePtr = tablePtr->typePtr;
#line 512
  i = 0;
  {
#line 512
  while (1) {
    while_continue: /* CIL Label */ ;
#line 512
    if (! (i < tablePtr->numBuckets)) {
#line 512
      goto while_break;
    }
#line 513
    hPtr = *(tablePtr->buckets + i);
    {
#line 514
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 514
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 514
        goto while_break___0;
      }
#line 515
      nextPtr = hPtr->nextPtr;
#line 516
      if (typePtr->freeEntryProc) {
        {
#line 517
        (*(typePtr->freeEntryProc))(hPtr);
        }
      } else {
        {
#line 519
        free((void *)((char *)hPtr));
        }
      }
#line 521
      hPtr = nextPtr;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 512
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 529
  if ((unsigned long )tablePtr->buckets != (unsigned long )(tablePtr->staticBuckets)) {
    {
#line 530
    free((void *)((char *)tablePtr->buckets));
    }
  }
#line 538
  tablePtr->typePtr = (Tcl_HashKeyType *)((void *)0);
#line 539
  return;
}
}
#line 563 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
Tcl_HashEntry *Tcl_FirstHashEntry(Tcl_HashTable *tablePtr , Tcl_HashSearch *searchPtr ) 
{ 
  Tcl_HashEntry *tmp ;

  {
  {
#line 569
  searchPtr->tablePtr = tablePtr;
#line 570
  searchPtr->nextIndex = 0;
#line 571
  searchPtr->nextEntryPtr = (Tcl_HashEntry *)((void *)0);
#line 572
  tmp = Tcl_NextHashEntry(searchPtr);
  }
#line 572
  return (tmp);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
Tcl_HashEntry *Tcl_NextHashEntry(Tcl_HashSearch *searchPtr ) 
{ 
  Tcl_HashEntry *hPtr ;

  {
  {
#line 603
  while (1) {
    while_continue: /* CIL Label */ ;
#line 603
    if (! ((unsigned long )searchPtr->nextEntryPtr == (unsigned long )((void *)0))) {
#line 603
      goto while_break;
    }
#line 604
    if (searchPtr->nextIndex >= (searchPtr->tablePtr)->numBuckets) {
#line 605
      return ((Tcl_HashEntry *)((void *)0));
    }
#line 607
    searchPtr->nextEntryPtr = *((searchPtr->tablePtr)->buckets + searchPtr->nextIndex);
#line 609
    (searchPtr->nextIndex) ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 611
  hPtr = searchPtr->nextEntryPtr;
#line 612
  searchPtr->nextEntryPtr = hPtr->nextPtr;
#line 613
  return (hPtr);
}
}
#line 632 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
static Tcl_HashEntry *AllocStringEntry(Tcl_HashTable *tablePtr , void *keyPtr ) 
{ 
  char const   *string ;
  Tcl_HashEntry *hPtr ;
  unsigned int size ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 637
  string = (char const   *)keyPtr;
#line 641
  tmp = strlen(string);
#line 641
  size = (unsigned int )(((sizeof(Tcl_HashEntry ) + tmp) + 1UL) - sizeof(hPtr->key));
  }
#line 642
  if ((unsigned long )size < sizeof(Tcl_HashEntry )) {
#line 643
    size = (unsigned int )sizeof(Tcl_HashEntry );
  }
  {
#line 644
  tmp___0 = malloc((size_t )size);
#line 644
  hPtr = (Tcl_HashEntry *)tmp___0;
#line 645
  strcpy((char */* __restrict  */)(hPtr->key.string), (char const   */* __restrict  */)string);
  }
#line 647
  return (hPtr);
}
}
#line 667 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
static int CompareStringKeys(void *keyPtr , Tcl_HashEntry *hPtr ) 
{ 
  register char const   *p1 ;
  register char const   *p2 ;

  {
#line 672
  p1 = (char const   *)keyPtr;
#line 673
  p2 = (char const   *)(hPtr->key.string);
  {
#line 675
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if ((int const   )*p1 != (int const   )*p2) {
#line 677
      goto while_break;
    }
#line 679
    if ((int const   )*p1 == 0) {
#line 680
      return (1);
    }
#line 675
    p1 ++;
#line 675
    p2 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return (0);
}
}
#line 704 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
static unsigned int HashStringKey(Tcl_HashTable *tablePtr , void *keyPtr ) 
{ 
  register char const   *string ;
  register unsigned int result ;
  register int c ;

  {
#line 709
  string = (char const   *)keyPtr;
#line 729
  result = 0U;
  {
#line 730
  while (1) {
    while_continue: /* CIL Label */ ;
#line 731
    c = (int )*string;
#line 732
    if (c == 0) {
#line 733
      goto while_break;
    }
#line 735
    result += (result << 3) + (unsigned int )c;
#line 736
    string ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 738
  return (result);
}
}
#line 761 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/tclHash.c"
static void RebuildTable(Tcl_HashTable *tablePtr ) 
{ 
  int oldSize ;
  int count ;
  int index___0 ;
  Tcl_HashEntry **oldBuckets ;
  register Tcl_HashEntry **oldChainPtr ;
  register Tcl_HashEntry **newChainPtr ;
  register Tcl_HashEntry *hPtr ;
  Tcl_HashKeyType *typePtr ;
  void *key ;
  void *tmp ;

  {
  {
#line 772
  oldSize = tablePtr->numBuckets;
#line 773
  oldBuckets = tablePtr->buckets;
#line 780
  tablePtr->numBuckets *= 4;
#line 781
  tmp = malloc((size_t )((unsigned int )((unsigned long )tablePtr->numBuckets * sizeof(Tcl_HashEntry *))));
#line 781
  tablePtr->buckets = (Tcl_HashEntry **)tmp;
#line 783
  count = tablePtr->numBuckets;
#line 783
  newChainPtr = tablePtr->buckets;
  }
  {
#line 783
  while (1) {
    while_continue: /* CIL Label */ ;
#line 783
    if (! (count > 0)) {
#line 783
      goto while_break;
    }
#line 785
    *newChainPtr = (Tcl_HashEntry *)((void *)0);
#line 783
    count --;
#line 783
    newChainPtr ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 787
  tablePtr->rebuildSize *= 4;
#line 788
  tablePtr->downShift -= 2;
#line 789
  tablePtr->mask = (tablePtr->mask << 2) + 3;
#line 791
  typePtr = tablePtr->typePtr;
#line 797
  oldChainPtr = oldBuckets;
  {
#line 797
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 797
    if (! (oldSize > 0)) {
#line 797
      goto while_break___0;
    }
#line 798
    hPtr = *oldChainPtr;
    {
#line 798
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 798
      if (! ((unsigned long )hPtr != (unsigned long )((void *)0))) {
#line 798
        goto while_break___1;
      }
#line 799
      *oldChainPtr = hPtr->nextPtr;
#line 801
      key = (void *)(hPtr->key.string);
#line 803
      if ((unsigned long )typePtr->hashKeyProc == (unsigned long )((void *)0)) {
#line 805
        index___0 = (int )(((long )hPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
      } else
#line 803
      if (typePtr->flags & 1) {
#line 805
        index___0 = (int )(((long )hPtr->hash * 1103515245L >> tablePtr->downShift) & (long )tablePtr->mask);
      } else {
#line 807
        index___0 = (int )(hPtr->hash & (unsigned int )tablePtr->mask);
      }
#line 809
      hPtr->nextPtr = *(tablePtr->buckets + index___0);
#line 810
      *(tablePtr->buckets + index___0) = hPtr;
#line 798
      hPtr = *oldChainPtr;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 797
    oldSize --;
#line 797
    oldChainPtr ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 818
  if ((unsigned long )oldBuckets != (unsigned long )(tablePtr->staticBuckets)) {
    {
#line 819
    free((void *)((char *)oldBuckets));
    }
  }
#line 821
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 347
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) setlinebuf)(FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 873
extern FILE *popen(char const   *__command , char const   *__modes ) ;
#line 879
extern int pclose(FILE *__stream ) ;
#line 480 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 765
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 40 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
__inline static void hspell_hash_init(hspell_hash *p ) 
{ 


  {
  {
#line 42
  Tcl_InitHashTable(p, 0);
  }
#line 43
  return;
}
}
#line 49 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
__inline static void hspell_hash_incr_int(hspell_hash *hashp , char const   *key ) 
{ 
  Tcl_HashEntry *e ;
  int isnew ;

  {
  {
#line 54
  e = Tcl_CreateHashEntry(hashp, key, & isnew);
#line 60
  e->clientData = (ClientData )((intptr_t )e->clientData + 1L);
  }
#line 61
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
__inline static int hspell_hash_exists(hspell_hash *hashp , char const   *key ) 
{ 
  Tcl_HashEntry *e ;
  int tmp ;

  {
  {
#line 69
  e = Tcl_FindHashEntry(hashp, key);
  }
#line 70
  if (e) {
#line 70
    tmp = 1;
  } else {
#line 70
    tmp = 0;
  }
#line 70
  return (tmp);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
__inline static hspell_hash_keyvalue *hspell_hash_build_keyvalue_array(hspell_hash *h ,
                                                                       int *size ) 
{ 
  Tcl_HashEntry *e ;
  Tcl_HashSearch s ;
  hspell_hash_keyvalue *array ;
  hspell_hash_keyvalue *arrayp ;
  hspell_hash_keyvalue *arrayend ;
  void *tmp ;

  {
#line 93
  if (! h->numEntries) {
#line 94
    *size = 0;
#line 95
    return ((hspell_hash_keyvalue *)0);
  }
  {
#line 98
  tmp = malloc((unsigned long )h->numEntries * sizeof(hspell_hash_keyvalue ));
#line 98
  array = (hspell_hash_keyvalue *)tmp;
#line 101
  arrayp = array;
#line 102
  arrayend = array + h->numEntries;
#line 104
  e = Tcl_FirstHashEntry(h, & s);
  }
  {
#line 104
  while (1) {
    while_continue: /* CIL Label */ ;
#line 104
    if (! e) {
#line 104
      goto while_break;
    }
#line 105
    if ((unsigned long )arrayp >= (unsigned long )arrayend) {
      {
#line 107
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Internal error: allocated array of incorrect size. Truncating it.\n");
      }
#line 109
      goto while_break;
    }
    {
#line 111
    arrayp->key = (char const   *)(e->key.string);
#line 112
    arrayp->value = (intptr_t )e->clientData;
#line 113
    arrayp ++;
#line 104
    e = Tcl_NextHashEntry(& s);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 115
  if ((unsigned long )arrayp != (unsigned long )arrayend) {
    {
#line 117
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Internal error: allocated array of incorrect size. Wasted space.\n");
#line 119
    *size = (int )(arrayp - array);
    }
  } else {
#line 121
    *size = h->numEntries;
  }
#line 123
  return (array);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
__inline static void hspell_hash_free_keyvalue_array(hspell_hash *h , int size , hspell_hash_keyvalue *p ) 
{ 


  {
#line 129
  if (p) {
    {
#line 130
    free((void *)p);
    }
  }
#line 131
  return;
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
__inline static intptr_t hspell_hash_get_int(hspell_hash *hashp , char const   *key ,
                                             int *value ) 
{ 
  Tcl_HashEntry *e ;

  {
  {
#line 146
  e = Tcl_FindHashEntry(hashp, key);
  }
#line 146
  if (! e) {
#line 147
    return ((intptr_t )0);
  }
#line 148
  *value = (int )((intptr_t )e->clientData);
#line 149
  return ((intptr_t )1);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
__inline static void hspell_hash_set_int(hspell_hash *hashp , char const   *key ,
                                         intptr_t value ) 
{ 
  Tcl_HashEntry *e ;
  int isnew ;

  {
  {
#line 158
  e = Tcl_CreateHashEntry(hashp, key, & isnew);
#line 159
  e->clientData = (ClientData )value;
  }
#line 160
  return;
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hash.h"
__inline static void hspell_hash_destroy(hspell_hash *p ) 
{ 


  {
  {
#line 167
  Tcl_DeleteHashTable(p);
  }
#line 168
  return;
}
}
#line 28 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.h"
int hspell_init(struct dict_radix **dictp , int flags ) ;
#line 30
int hspell_check_word(struct dict_radix *dict , char const   *word , int *preflen ) ;
#line 32
void hspell_trycorrect(struct dict_radix *dict , char const   *w , struct corlist *cl ) ;
#line 34
unsigned int hspell_is_canonic_gimatria(char const   *w ) ;
#line 38
char const   *hspell_get_dictionary_path(void) ;
#line 39
void hspell_set_dictionary_path(char const   *path ) ;
#line 41
int hspell_debug ;
#line 55
int corlist_init(struct corlist *cl ) ;
#line 56
int corlist_free(struct corlist *cl ) ;
#line 73
int hspell_enum_splits(struct dict_radix *dict , char const   *word , hspell_word_split_callback_func *enumf ) ;
#line 30 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
static void load_personal_dict(hspell_hash *personaldict , int *currentdir_dictfile ) 
{ 
  int i ;
  char buf[512] ;
  FILE *fp ;
  char *home ;
  char *tmp ;
  int l ;
  size_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 34
  hspell_hash_init(personaldict);
  }
#line 35
  if (currentdir_dictfile) {
#line 36
    *currentdir_dictfile = 0;
  }
#line 37
  i = 0;
  {
#line 37
  while (1) {
    while_continue: /* CIL Label */ ;
#line 37
    if (! (i <= 1)) {
#line 37
      goto while_break;
    }
#line 40
    if (i == 0) {
      {
#line 41
      tmp = getenv("HOME");
#line 41
      home = tmp;
      }
#line 42
      if (! home) {
#line 42
        goto __Cont;
      }
      {
#line 43
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s/.hspell_words",
               home);
      }
    } else {
      {
#line 46
      snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"./hspell_words");
      }
    }
    {
#line 47
    fp = fopen((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"r");
    }
#line 48
    if (! fp) {
#line 48
      goto __Cont;
    }
#line 49
    if (i == 1) {
#line 49
      if (currentdir_dictfile) {
#line 50
        *currentdir_dictfile = 1;
      }
    }
    {
#line 51
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 51
      tmp___1 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
#line 51
      if (! tmp___1) {
#line 51
        goto while_break___0;
      }
      {
#line 52
      tmp___0 = strlen((char const   *)(buf));
#line 52
      l = (int )tmp___0;
      }
#line 53
      if ((int )buf[l - 1] == 10) {
#line 54
        buf[l - 1] = (char )'\000';
      }
#line 55
      if ((int )buf[0] != 35) {
#line 55
        if ((int )buf[0] != 0) {
          {
#line 56
          hspell_hash_incr_int(personaldict, (char const   *)(buf));
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 58
    fclose(fp);
    }
    __Cont: /* CIL Label */ 
#line 37
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  return;
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
static int save_personal_dict(hspell_hash *personaldict , hspell_hash *personaldict_new_words ,
                              int currentdir_dictfile ) 
{ 
  FILE *fp ;
  hspell_hash_keyvalue *new_words_array ;
  int new_words_number ;
  int i ;
  char dict_filename[512] ;
  char *home ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 78
  tmp = getenv("HOME");
#line 78
  home = tmp;
  }
#line 79
  if (currentdir_dictfile) {
    {
#line 80
    snprintf((char */* __restrict  */)(dict_filename), sizeof(dict_filename), (char const   */* __restrict  */)"./hspell_words");
    }
  } else
#line 79
  if (! home) {
    {
#line 80
    snprintf((char */* __restrict  */)(dict_filename), sizeof(dict_filename), (char const   */* __restrict  */)"./hspell_words");
    }
  } else {
    {
#line 83
    snprintf((char */* __restrict  */)(dict_filename), sizeof(dict_filename), (char const   */* __restrict  */)"%s/.hspell_words",
             home);
    }
  }
  {
#line 86
  fp = fopen((char const   */* __restrict  */)(dict_filename), (char const   */* __restrict  */)"a");
  }
#line 87
  if (! fp) {
#line 88
    return (0);
  }
  {
#line 105
  new_words_array = hspell_hash_build_keyvalue_array(personaldict_new_words, & new_words_number);
  }
#line 107
  if (hspell_debug) {
    {
#line 108
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Saving %d words to %s\n",
            new_words_number, dict_filename);
    }
  }
#line 111
  i = 0;
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! (i < new_words_number)) {
#line 111
      goto while_break;
    }
    {
#line 112
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s\n",
            (new_words_array + i)->key);
#line 113
    hspell_hash_incr_int(personaldict, (new_words_array + i)->key);
#line 111
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  hspell_hash_free_keyvalue_array(personaldict_new_words, new_words_number, new_words_array);
#line 118
  hspell_hash_destroy(personaldict_new_words);
#line 119
  hspell_hash_init(personaldict_new_words);
#line 121
  tmp___0 = fclose(fp);
  }
#line 121
  return (tmp___0 == 0);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
char *flathints  ;
#line 129 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
int flathints_size  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
void load_spelling_hints(hspell_hash *spellinghints ) 
{ 
  FILE *fp ;
  char s[1000] ;
  int len ;
  int thishint ;
  void *tmp ;
  char const   *tmp___0 ;
  int l ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
  {
#line 133
  len = 0;
#line 134
  thishint = 0;
#line 136
  hspell_hash_init(spellinghints);
#line 138
  flathints_size = 8192;
#line 139
  tmp = malloc((size_t )flathints_size);
#line 139
  flathints = (char *)tmp;
#line 142
  tmp___0 = hspell_get_dictionary_path();
#line 142
  snprintf((char */* __restrict  */)(s), sizeof(s), (char const   */* __restrict  */)"gzip -dc \'%s.hints\'",
           tmp___0);
#line 144
  fp = popen((char const   *)(s), "r");
  }
#line 145
  if (! fp) {
    {
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open %s\n",
            s);
    }
#line 147
    return;
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 149
    tmp___3 = fgets((char */* __restrict  */)(s), (int )sizeof(s), (FILE */* __restrict  */)fp);
    }
#line 149
    if (! tmp___3) {
#line 149
      goto while_break;
    }
    {
#line 150
    tmp___1 = strlen((char const   *)(s));
#line 150
    l = (int )tmp___1;
    }
#line 151
    if ((int )s[0] == 43) {
#line 152
      if (! thishint) {
#line 153
        thishint = len;
      }
      {
#line 156
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 156
        if (! (len + l >= flathints_size)) {
#line 156
          goto while_break___0;
        }
        {
#line 157
        flathints_size *= 2;
#line 158
        tmp___2 = realloc((void *)flathints, (size_t )flathints_size);
#line 158
        flathints = (char *)tmp___2;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 164
      s[0] = (char )' ';
#line 166
      strcpy((char */* __restrict  */)(flathints + len), (char const   */* __restrict  */)(s));
#line 167
      len += l;
      }
    } else
#line 168
    if ((int )s[0] == 10) {
#line 169
      thishint = 0;
#line 170
      len ++;
    } else {
      {
#line 172
      s[l - 1] = (char)0;
#line 173
      hspell_hash_set_int(spellinghints, (char const   *)(s), (intptr_t )thishint);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 176
  pclose(fp);
  }
#line 177
  return;
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
static int compare_key(void const   *a , void const   *b ) 
{ 
  register hspell_hash_keyvalue *aa ;
  register hspell_hash_keyvalue *bb ;
  int tmp ;

  {
  {
#line 183
  aa = (hspell_hash_keyvalue *)a;
#line 184
  bb = (hspell_hash_keyvalue *)b;
#line 185
  tmp = strcmp(aa->key, bb->key);
  }
#line 185
  return (tmp);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
static int compare_value_reverse(void const   *a , void const   *b ) 
{ 
  register hspell_hash_keyvalue *aa ;
  register hspell_hash_keyvalue *bb ;

  {
#line 189
  aa = (hspell_hash_keyvalue *)a;
#line 190
  bb = (hspell_hash_keyvalue *)b;
#line 191
  if (aa->value < bb->value) {
#line 192
    return (1);
  } else
#line 193
  if (aa->value > bb->value) {
#line 194
    return (-1);
  } else {
#line 195
    return (0);
  }
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
static FILE *next_file(int *argcp , char ***argvp ) 
{ 
  FILE *ret ;

  {
#line 201
  ret = (FILE *)0;
#line 202
  if (*argcp <= 0) {
#line 203
    return ((FILE *)0);
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (*argcp) {
#line 204
      if (! (! ret)) {
#line 204
        goto while_break;
      }
    } else {
#line 204
      goto while_break;
    }
    {
#line 205
    ret = fopen((char const   */* __restrict  */)*(*argvp + 0), (char const   */* __restrict  */)"r");
    }
#line 206
    if (! ret) {
      {
#line 207
      perror((char const   *)*(*argvp + 0));
      }
    }
#line 208
    (*argvp) ++;
#line 209
    (*argcp) --;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  return (ret);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
static int uglyuglyflag  =    0;
#line 233 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.c"
int notify_split(char const   *w , char const   *baseword , int preflen , int prefspec ) 
{ 


  {
#line 238
  if (preflen > 0) {
    {
#line 239
    printf((char const   */* __restrict  */)"\366\351\370\345\363 \347\345\367\351: %.*s+%s\n",
           preflen, w, baseword);
    }
  } else
#line 240
  if (! preflen) {
    {
#line 241
    printf((char const   */* __restrict  */)"\356\351\354\344 \347\345\367\351\372: %s\n",
           w);
    }
  }
#line 257
  return (1);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
static void do_print_tree___0(struct node *nodes , struct node_small *nodes_small ,
                              struct node_medium *nodes_medium , struct node_index head ,
                              char *word , int len , int maxlen ) 
{ 
  int i ;
  struct node *n ;
  unsigned char tmp ;
  struct node_small *n___0 ;
  struct node_medium *n___1 ;

  {
#line 177
  if (len >= maxlen) {
    {
#line 178
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_print_tree(): warning: buffer overflow.\n");
    }
#line 179
    return;
  }
#line 181
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 3U << 30) {
#line 182
    n = nodes + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 183
    if (n->value) {
      {
#line 184
      *(word + len) = (char )'\000';
#line 185
      printf((char const   */* __restrict  */)"%s %d\n", word, n->value);
      }
    }
#line 187
    i = 0;
    {
#line 187
    while (1) {
      while_continue: /* CIL Label */ ;
#line 187
      if (! (i < 29)) {
#line 187
        goto while_break;
      }
      {
#line 188
      tmp = letter_to_char(i);
#line 188
      *(word + len) = (char )tmp;
#line 189
      do_print_tree___0(nodes, nodes_small, nodes_medium, n->children[i], word, len + 1,
                        maxlen);
#line 187
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else
#line 192
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 193
    n___0 = nodes_small + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 194
    if (n___0->value) {
      {
#line 195
      *(word + len) = (char )'\000';
#line 196
      printf((char const   */* __restrict  */)"%s %d\n", word, n___0->value);
      }
    }
#line 198
    i = 0;
    {
#line 198
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 198
      if (! (i < 2)) {
#line 198
        goto while_break___0;
      }
#line 199
      if (n___0->chars[i]) {
        {
#line 200
        *(word + len) = n___0->chars[i];
#line 201
        do_print_tree___0(nodes, nodes_small, nodes_medium, n___0->children[i], word,
                          len + 1, maxlen);
        }
      }
#line 198
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else
#line 205
  if ((head.val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 206
    n___1 = nodes_medium + (head.val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 207
    if (n___1->value) {
      {
#line 208
      *(word + len) = (char )'\000';
#line 209
      printf((char const   */* __restrict  */)"%s %d\n", word, n___1->value);
      }
    }
#line 211
    i = 0;
    {
#line 211
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 211
      if (! (i < 8)) {
#line 211
        goto while_break___1;
      }
#line 212
      if (n___1->chars[i]) {
        {
#line 213
        *(word + len) = n___1->chars[i];
#line 214
        do_print_tree___0(nodes, nodes_small, nodes_medium, n___1->children[i], word,
                          len + 1, maxlen);
        }
      }
#line 211
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else
#line 218
  if (head.val_or_index) {
    {
#line 219
    *(word + len) = (char )'\000';
#line 220
    printf((char const   */* __restrict  */)"%s %d\n", word, head.val_or_index);
    }
  }
#line 222
  return;
}
}
#line 318
static int do_read_dict___0(void *fp , void *prefixes , struct dict_radix *dict ) ;
#line 406 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/dict_radix.c"
static int do_read_dict___0(void *fp , void *prefixes , struct dict_radix *dict ) 
{ 
  struct node_index *stack[256] ;
  int sdepth ;
  int c ;
  int n ;
  int cc ;
  int nwords ;
  struct node *nodes ;
  struct node_small *nodes_small ;
  struct node_medium *nodes_medium ;
  int nnodes_small ;
  int nnodes_medium ;
  int nnodes ;
  int tmp ;
  int tmp___0 ;
  int chosen ;
  int j ;
  struct node_small *n___0 ;
  int chosen___0 ;
  int tmp___1 ;
  int j___0 ;
  struct node_medium *n___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 412
  sdepth = 0;
#line 415
  nwords = 0;
#line 416
  nodes = dict->nodes;
#line 417
  nodes_small = dict->nodes_small;
#line 418
  nodes_medium = dict->nodes_medium;
#line 419
  nnodes_small = 0;
#line 419
  nnodes_medium = 0;
#line 419
  nnodes = 0;
#line 421
  if (dict->nnodes) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_small) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nnodes_medium) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
#line 425
    return (0);
  } else
#line 421
  if (dict->nwords) {
    {
#line 423
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): called for a non-empty dictionary\n");
    }
#line 425
    return (0);
  }
#line 427
  if (! nodes) {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_small) {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
#line 430
    return (0);
  } else
#line 427
  if (! nodes_medium) {
    {
#line 428
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: do_read_dict(): allocate_nodes() must be called first\n");
    }
#line 430
    return (0);
  }
  {
#line 433
  memset((void *)(nodes + nnodes), 0, sizeof(*(nodes + nnodes)));
#line 434
  tmp = nnodes;
#line 434
  nnodes ++;
#line 434
  dict->head.val_or_index = (unsigned int )tmp | (3U << 30);
#line 435
  stack[0] = & dict->head;
#line 436
  sdepth = 0;
  }
  {
#line 437
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 437
    c = gzb_getc((gzbFile *)fp);
    }
#line 437
    if (! (c != -1)) {
#line 437
      goto while_break;
    }
#line 438
    if (c >= 48) {
#line 438
      if (c <= 57) {
        {
#line 440
        nwords ++;
#line 443
        tmp___0 = gzb_getc((gzbFile *)prefixes);
#line 443
        (stack[sdepth])->val_or_index = (uint32_t )tmp___0;
#line 448
        n = 0;
        }
        {
#line 449
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 451
          n *= 10;
#line 452
          n += c - 48;
#line 449
          c = gzb_getc((gzbFile *)fp);
          }
#line 449
          if (c != -1) {
#line 449
            if (c >= 48) {
#line 449
              if (! (c <= 57)) {
#line 449
                goto while_break___0;
              }
            } else {
#line 449
              goto while_break___0;
            }
          } else {
#line 449
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 454
        sdepth -= n;
#line 455
        if (sdepth < 0) {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
#line 457
          return (0);
        } else
#line 455
        if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
          {
#line 456
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: bad backlength %d... giving up\n",
                  sdepth);
          }
#line 457
          return (0);
        }
      }
    }
#line 462
    if ((unsigned long )sdepth >= sizeof(stack) / sizeof(stack[0]) - 1UL) {
      {
#line 463
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: word too long... giving up\n");
      }
#line 464
      return (0);
    }
    {
#line 466
    cc = char_to_letter((unsigned char )c);
    }
#line 469
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 0U) {
#line 471
      if (dict->nfree_nodes_small) {
#line 472
        (dict->nfree_nodes_small) --;
#line 472
        chosen = dict->free_nodes_small[dict->nfree_nodes_small];
      } else {
#line 475
        chosen = nnodes_small;
#line 476
        if (nnodes_small >= dict->size_nodes_small) {
          {
#line 477
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (small) - failing.\n");
          }
#line 478
          return (0);
        }
#line 480
        nnodes_small ++;
      }
      {
#line 482
      memset((void *)(nodes_small + chosen), 0, sizeof(*(nodes_small + chosen)));
#line 483
      (nodes_small + chosen)->value = (stack[sdepth])->val_or_index;
#line 484
      (stack[sdepth])->val_or_index = (unsigned int )chosen | (1U << 30);
#line 486
      (nodes_small + chosen)->chars[0] = (char )c;
#line 487
      stack[sdepth + 1] = & (nodes_small + chosen)->children[0];
      }
    } else
#line 488
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 1U << 30) {
#line 490
      n___0 = nodes_small + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 493
      j = 0;
      {
#line 493
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 493
        if (! (j < 2)) {
#line 493
          goto while_break___1;
        }
#line 494
        if (! n___0->chars[j]) {
#line 495
          n___0->chars[j] = (char )c;
#line 496
          stack[sdepth + 1] = & n___0->children[j];
#line 497
          goto while_break___1;
        }
#line 493
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 499
      if (j == 2) {
#line 502
        if (dict->nfree_nodes_medium) {
#line 503
          (dict->nfree_nodes_medium) --;
#line 503
          chosen___0 = dict->free_nodes_medium[dict->nfree_nodes_medium];
        } else {
#line 506
          chosen___0 = nnodes_medium;
#line 507
          if (nnodes_medium >= dict->size_nodes_medium) {
            {
#line 508
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (medium) - failing.\n");
            }
#line 509
            return (0);
          }
#line 511
          nnodes_medium ++;
        }
        {
#line 513
        memset((void *)(nodes_medium + chosen___0), 0, sizeof(*(nodes_medium + chosen___0)));
        }
#line 514
        if ((unsigned long )dict->nfree_nodes_small >= sizeof(dict->free_nodes_small) / sizeof(dict->free_nodes_small[0])) {
          {
#line 517
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_small.\n");
          }
#line 518
          return (0);
        }
#line 520
        tmp___1 = dict->nfree_nodes_small;
#line 520
        (dict->nfree_nodes_small) ++;
#line 520
        dict->free_nodes_small[tmp___1] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 523
        (stack[sdepth])->val_or_index = (unsigned int )chosen___0 | (2U << 30);
#line 526
        (nodes_medium + chosen___0)->value = n___0->value;
#line 527
        j = 0;
        {
#line 527
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 527
          if (! (j < 2)) {
#line 527
            goto while_break___2;
          }
#line 528
          (nodes_medium + chosen___0)->chars[j] = n___0->chars[j];
#line 530
          (nodes_medium + chosen___0)->children[j] = n___0->children[j];
#line 527
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 534
        (nodes_medium + chosen___0)->chars[2] = (char )c;
#line 536
        stack[sdepth + 1] = & (nodes_medium + chosen___0)->children[2];
      }
    } else
#line 539
    if (((stack[sdepth])->val_or_index & ((1U << 31) | (1U << 30))) == 2U << 30) {
#line 541
      n___1 = nodes_medium + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 544
      j___0 = 0;
      {
#line 544
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 544
        if (! (j___0 < 8)) {
#line 544
          goto while_break___3;
        }
#line 545
        if (! n___1->chars[j___0]) {
#line 546
          n___1->chars[j___0] = (char )c;
#line 547
          stack[sdepth + 1] = & n___1->children[j___0];
#line 548
          goto while_break___3;
        }
#line 544
        j___0 ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 550
      if (j___0 == 8) {
#line 552
        if (nnodes >= dict->size_nodes) {
          {
#line 553
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: Realloc needed (full) - failing.\n");
          }
#line 554
          return (0);
        }
        {
#line 556
        memset((void *)(nodes + nnodes), 0, sizeof(*(nodes + nnodes)));
#line 557
        (nodes + nnodes)->value = n___1->value;
        }
#line 558
        if ((unsigned long )dict->nfree_nodes_medium >= sizeof(dict->free_nodes_medium) / sizeof(dict->free_nodes_medium[0])) {
          {
#line 561
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hspell: overflow in free_nodes_medium.\n");
          }
#line 562
          return (0);
        }
#line 564
        tmp___2 = dict->nfree_nodes_medium;
#line 564
        (dict->nfree_nodes_medium) ++;
#line 564
        dict->free_nodes_medium[tmp___2] = (int )((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30)));
#line 567
        (stack[sdepth])->val_or_index = (unsigned int )nnodes | (3U << 30);
#line 569
        j___0 = 0;
        {
#line 569
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 569
          if (! (j___0 < 8)) {
#line 569
            goto while_break___4;
          }
          {
#line 570
          tmp___3 = char_to_letter((unsigned char )n___1->chars[j___0]);
#line 570
          (nodes + nnodes)->children[tmp___3] = n___1->children[j___0];
#line 569
          j___0 ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 574
        stack[sdepth + 1] = & (nodes + nnodes)->children[cc];
#line 575
        nnodes ++;
      }
    } else {
#line 578
      stack[sdepth + 1] = & (nodes + ((stack[sdepth])->val_or_index & ~ ((1U << 31) | (1U << 30))))->children[cc];
    }
#line 581
    sdepth ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 584
  nwords ++;
#line 586
  tmp___4 = gzb_getc((gzbFile *)prefixes);
#line 586
  (stack[sdepth])->val_or_index = (uint32_t )tmp___4;
#line 592
  dict->nwords = nwords;
#line 593
  dict->nnodes_small = nnodes_small;
#line 594
  dict->nnodes_medium = nnodes_medium;
#line 595
  dict->nnodes = nnodes;
  }
#line 597
  return (1);
}
}
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.h"
int corlist_add(struct corlist *cl , char const   *s ) ;
#line 9 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/corlist.c"
int corlist_init(struct corlist *cl ) 
{ 


  {
#line 12
  cl->n = 0;
#line 13
  return (1);
}
}
#line 16 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/corlist.c"
int corlist_free(struct corlist *cl ) 
{ 


  {
#line 20
  cl->n = 0;
#line 21
  return (1);
}
}
#line 24 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/corlist.c"
int corlist_add(struct corlist *cl , char const   *s ) 
{ 
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 28
  i = 0;
  {
#line 28
  while (1) {
    while_continue: /* CIL Label */ ;
#line 28
    if (! (i < cl->n)) {
#line 28
      goto while_break;
    }
    {
#line 29
    tmp = strcmp((char const   *)(cl->correction[i]), s);
    }
#line 29
    if (! tmp) {
#line 30
      return (1);
    }
#line 28
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 32
  if ((unsigned long )cl->n == sizeof(cl->correction) / sizeof(cl->correction[0])) {
#line 33
    return (0);
  }
  {
#line 34
  tmp___0 = cl->n;
#line 34
  (cl->n) ++;
#line 34
  strncpy((char */* __restrict  */)(cl->correction[tmp___0]), (char const   */* __restrict  */)s,
          sizeof(cl->correction[0]));
  }
#line 35
  return (1);
}
}
#line 189 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) clock_t ( __attribute__((__leaf__)) clock)(void) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/hspell.h"
void hspell_uninit(struct dict_radix *dict ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
static char const   *hspell_dictionary  =    "/usr/local/share/hspell/hebrew.wgz";
#line 25 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
char const   *hspell_get_dictionary_path(void) 
{ 


  {
#line 28
  return (hspell_dictionary);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
void hspell_set_dictionary_path(char const   *path ) 
{ 


  {
#line 35
  hspell_dictionary = path;
#line 36
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
int hspell_debug  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
static int load_data(struct dict_radix **dictp ) 
{ 
  clock_t t1 ;
  clock_t t2 ;
  int tmp ;

  {
#line 49
  if (hspell_debug) {
    {
#line 50
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Loading data files... ");
#line 51
    t1 = clock();
    }
  }
  {
#line 54
  *dictp = new_dict_radix();
#line 55
  tmp = read_dict(*dictp, hspell_dictionary);
  }
#line 55
  if (! tmp) {
    {
#line 56
    delete_dict_radix(*dictp);
    }
#line 57
    return (-1);
  }
#line 60
  if (hspell_debug) {
    {
#line 61
    t2 = clock();
#line 62
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"done (%d ms).\n",
            (int )((t2 - t1) / 1000L));
    }
  }
#line 65
  return (0);
}
}
#line 5 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/prefixes.c"
static char *prefixes_noH[243]  = 
#line 5 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/prefixes.c"
  {      (char *)"",      (char *)"\341",      (char *)"\341\353",      (char *)"\344", 
        (char *)"\345",      (char *)"\345\341",      (char *)"\345\341\353",      (char *)"\345\344", 
        (char *)"\345\353",      (char *)"\345\353\341",      (char *)"\345\353\353",      (char *)"\345\353\354", 
        (char *)"\345\353\356",      (char *)"\345\353\356\344",      (char *)"\345\353\371",      (char *)"\345\353\371\341", 
        (char *)"\345\353\371\341\353",      (char *)"\345\353\371\344",      (char *)"\345\353\371\353",      (char *)"\345\353\371\353\341", 
        (char *)"\345\353\371\353\353",      (char *)"\345\353\371\353\354",      (char *)"\345\353\371\353\356",      (char *)"\345\353\371\353\356\344", 
        (char *)"\345\353\371\354",      (char *)"\345\353\371\354\353",      (char *)"\345\353\371\356",      (char *)"\345\353\371\356\344", 
        (char *)"\345\353\371\356\353",      (char *)"\345\354",      (char *)"\345\354\353",      (char *)"\345\354\353\371", 
        (char *)"\345\354\353\371\341",      (char *)"\345\354\353\371\341\353",      (char *)"\345\354\353\371\344",      (char *)"\345\354\353\371\353", 
        (char *)"\345\354\353\371\353\341",      (char *)"\345\354\353\371\353\353",      (char *)"\345\354\353\371\353\354",      (char *)"\345\354\353\371\353\356", 
        (char *)"\345\354\353\371\353\356\344",      (char *)"\345\354\353\371\354",      (char *)"\345\354\353\371\354\353",      (char *)"\345\354\353\371\356", 
        (char *)"\345\354\353\371\356\344",      (char *)"\345\354\353\371\356\353",      (char *)"\345\356",      (char *)"\345\356\344", 
        (char *)"\345\356\353",      (char *)"\345\356\371",      (char *)"\345\356\371\341",      (char *)"\345\356\371\341\353", 
        (char *)"\345\356\371\344",      (char *)"\345\356\371\353",      (char *)"\345\356\371\353\341",      (char *)"\345\356\371\353\353", 
        (char *)"\345\356\371\353\354",      (char *)"\345\356\371\353\356",      (char *)"\345\356\371\353\356\344",      (char *)"\345\356\371\354", 
        (char *)"\345\356\371\354\353",      (char *)"\345\356\371\356",      (char *)"\345\356\371\356\344",      (char *)"\345\356\371\356\353", 
        (char *)"\345\371",      (char *)"\345\371\341",      (char *)"\345\371\341\353",      (char *)"\345\371\344", 
        (char *)"\345\371\353",      (char *)"\345\371\353\341",      (char *)"\345\371\353\353",      (char *)"\345\371\353\354", 
        (char *)"\345\371\353\356",      (char *)"\345\371\353\356\344",      (char *)"\345\371\353\371",      (char *)"\345\371\353\371\341", 
        (char *)"\345\371\353\371\341\353",      (char *)"\345\371\353\371\344",      (char *)"\345\371\353\371\353",      (char *)"\345\371\353\371\353\341", 
        (char *)"\345\371\353\371\353\353",      (char *)"\345\371\353\371\353\354",      (char *)"\345\371\353\371\353\356",      (char *)"\345\371\353\371\353\356\344", 
        (char *)"\345\371\353\371\354",      (char *)"\345\371\353\371\354\353",      (char *)"\345\371\353\371\356",      (char *)"\345\371\353\371\356\344", 
        (char *)"\345\371\353\371\356\353",      (char *)"\345\371\354",      (char *)"\345\371\354\353",      (char *)"\345\371\354\353\371", 
        (char *)"\345\371\354\353\371\341",      (char *)"\345\371\354\353\371\341\353",      (char *)"\345\371\354\353\371\344",      (char *)"\345\371\354\353\371\353", 
        (char *)"\345\371\354\353\371\353\341",      (char *)"\345\371\354\353\371\353\353",      (char *)"\345\371\354\353\371\353\354",      (char *)"\345\371\354\353\371\353\356", 
        (char *)"\345\371\354\353\371\353\356\344",      (char *)"\345\371\354\353\371\354",      (char *)"\345\371\354\353\371\354\353",      (char *)"\345\371\354\353\371\356", 
        (char *)"\345\371\354\353\371\356\344",      (char *)"\345\371\354\353\371\356\353",      (char *)"\345\371\356",      (char *)"\345\371\356\344", 
        (char *)"\345\371\356\353",      (char *)"\345\371\356\371",      (char *)"\345\371\356\371\341",      (char *)"\345\371\356\371\341\353", 
        (char *)"\345\371\356\371\344",      (char *)"\345\371\356\371\353",      (char *)"\345\371\356\371\353\341",      (char *)"\345\371\356\371\353\353", 
        (char *)"\345\371\356\371\353\354",      (char *)"\345\371\356\371\353\356",      (char *)"\345\371\356\371\353\356\344",      (char *)"\345\371\356\371\354", 
        (char *)"\345\371\356\371\354\353",      (char *)"\345\371\356\371\356",      (char *)"\345\371\356\371\356\344",      (char *)"\345\371\356\371\356\353", 
        (char *)"\353",      (char *)"\353\341",      (char *)"\353\353",      (char *)"\353\354", 
        (char *)"\353\356",      (char *)"\353\356\344",      (char *)"\353\371",      (char *)"\353\371\341", 
        (char *)"\353\371\341\353",      (char *)"\353\371\344",      (char *)"\353\371\353",      (char *)"\353\371\353\341", 
        (char *)"\353\371\353\353",      (char *)"\353\371\353\354",      (char *)"\353\371\353\356",      (char *)"\353\371\353\356\344", 
        (char *)"\353\371\354",      (char *)"\353\371\354\353",      (char *)"\353\371\356",      (char *)"\353\371\356\344", 
        (char *)"\353\371\356\353",      (char *)"\354",      (char *)"\354\353",      (char *)"\354\353\371", 
        (char *)"\354\353\371\341",      (char *)"\354\353\371\341\353",      (char *)"\354\353\371\344",      (char *)"\354\353\371\353", 
        (char *)"\354\353\371\353\341",      (char *)"\354\353\371\353\353",      (char *)"\354\353\371\353\354",      (char *)"\354\353\371\353\356", 
        (char *)"\354\353\371\353\356\344",      (char *)"\354\353\371\354",      (char *)"\354\353\371\354\353",      (char *)"\354\353\371\356", 
        (char *)"\354\353\371\356\344",      (char *)"\354\353\371\356\353",      (char *)"\356",      (char *)"\356\341", 
        (char *)"\356\344",      (char *)"\356\353",      (char *)"\356\354",      (char *)"\356\371", 
        (char *)"\356\371\341",      (char *)"\356\371\341\353",      (char *)"\356\371\344",      (char *)"\356\371\353", 
        (char *)"\356\371\353\341",      (char *)"\356\371\353\353",      (char *)"\356\371\353\354",      (char *)"\356\371\353\356", 
        (char *)"\356\371\353\356\344",      (char *)"\356\371\354",      (char *)"\356\371\354\353",      (char *)"\356\371\356", 
        (char *)"\356\371\356\344",      (char *)"\356\371\356\353",      (char *)"\371",      (char *)"\371\341", 
        (char *)"\371\341\353",      (char *)"\371\344",      (char *)"\371\353",      (char *)"\371\353\341", 
        (char *)"\371\353\353",      (char *)"\371\353\354",      (char *)"\371\353\356",      (char *)"\371\353\356\344", 
        (char *)"\371\353\371",      (char *)"\371\353\371\341",      (char *)"\371\353\371\341\353",      (char *)"\371\353\371\344", 
        (char *)"\371\353\371\353",      (char *)"\371\353\371\353\341",      (char *)"\371\353\371\353\353",      (char *)"\371\353\371\353\354", 
        (char *)"\371\353\371\353\356",      (char *)"\371\353\371\353\356\344",      (char *)"\371\353\371\354",      (char *)"\371\353\371\354\353", 
        (char *)"\371\353\371\356",      (char *)"\371\353\371\356\344",      (char *)"\371\353\371\356\353",      (char *)"\371\354", 
        (char *)"\371\354\353",      (char *)"\371\354\353\371",      (char *)"\371\354\353\371\341",      (char *)"\371\354\353\371\341\353", 
        (char *)"\371\354\353\371\344",      (char *)"\371\354\353\371\353",      (char *)"\371\354\353\371\353\341",      (char *)"\371\354\353\371\353\353", 
        (char *)"\371\354\353\371\353\354",      (char *)"\371\354\353\371\353\356",      (char *)"\371\354\353\371\353\356\344",      (char *)"\371\354\353\371\354", 
        (char *)"\371\354\353\371\354\353",      (char *)"\371\354\353\371\356",      (char *)"\371\354\353\371\356\344",      (char *)"\371\354\353\371\356\353", 
        (char *)"\371\356",      (char *)"\371\356\344",      (char *)"\371\356\353",      (char *)"\371\356\371", 
        (char *)"\371\356\371\341",      (char *)"\371\356\371\341\353",      (char *)"\371\356\371\344",      (char *)"\371\356\371\353", 
        (char *)"\371\356\371\353\341",      (char *)"\371\356\371\353\353",      (char *)"\371\356\371\353\354",      (char *)"\371\356\371\353\356", 
        (char *)"\371\356\371\353\356\344",      (char *)"\371\356\371\354",      (char *)"\371\356\371\354\353",      (char *)"\371\356\371\356", 
        (char *)"\371\356\371\356\344",      (char *)"\371\356\371\356\353",      (char *)0};
#line 248 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/prefixes.c"
static int masks_noH[243]  = 
#line 248
  {      60,      43,      42,      32, 
        60,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        44,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      44,      43, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      -1};
#line 491 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/prefixes.c"
static char *prefixes_H[361]  = 
#line 491
  {      (char *)"",      (char *)"\341",      (char *)"\341\353",      (char *)"\344", 
        (char *)"\344\341",      (char *)"\344\341\353",      (char *)"\344\344",      (char *)"\344\353", 
        (char *)"\344\353\341",      (char *)"\344\353\353",      (char *)"\344\353\354",      (char *)"\344\353\356", 
        (char *)"\344\353\356\344",      (char *)"\344\353\371",      (char *)"\344\353\371\341",      (char *)"\344\353\371\341\353", 
        (char *)"\344\353\371\344",      (char *)"\344\353\371\353",      (char *)"\344\353\371\353\341",      (char *)"\344\353\371\353\353", 
        (char *)"\344\353\371\353\354",      (char *)"\344\353\371\353\356",      (char *)"\344\353\371\353\356\344",      (char *)"\344\353\371\354", 
        (char *)"\344\353\371\354\353",      (char *)"\344\353\371\356",      (char *)"\344\353\371\356\344",      (char *)"\344\353\371\356\353", 
        (char *)"\344\354",      (char *)"\344\354\353",      (char *)"\344\354\353\371",      (char *)"\344\354\353\371\341", 
        (char *)"\344\354\353\371\341\353",      (char *)"\344\354\353\371\344",      (char *)"\344\354\353\371\353",      (char *)"\344\354\353\371\353\341", 
        (char *)"\344\354\353\371\353\353",      (char *)"\344\354\353\371\353\354",      (char *)"\344\354\353\371\353\356",      (char *)"\344\354\353\371\353\356\344", 
        (char *)"\344\354\353\371\354",      (char *)"\344\354\353\371\354\353",      (char *)"\344\354\353\371\356",      (char *)"\344\354\353\371\356\344", 
        (char *)"\344\354\353\371\356\353",      (char *)"\344\356",      (char *)"\344\356\344",      (char *)"\344\356\353", 
        (char *)"\344\356\371",      (char *)"\344\356\371\341",      (char *)"\344\356\371\341\353",      (char *)"\344\356\371\344", 
        (char *)"\344\356\371\353",      (char *)"\344\356\371\353\341",      (char *)"\344\356\371\353\353",      (char *)"\344\356\371\353\354", 
        (char *)"\344\356\371\353\356",      (char *)"\344\356\371\353\356\344",      (char *)"\344\356\371\354",      (char *)"\344\356\371\354\353", 
        (char *)"\344\356\371\356",      (char *)"\344\356\371\356\344",      (char *)"\344\356\371\356\353",      (char *)"\345", 
        (char *)"\345\341",      (char *)"\345\341\353",      (char *)"\345\344",      (char *)"\345\344\341", 
        (char *)"\345\344\341\353",      (char *)"\345\344\344",      (char *)"\345\344\353",      (char *)"\345\344\353\341", 
        (char *)"\345\344\353\353",      (char *)"\345\344\353\354",      (char *)"\345\344\353\356",      (char *)"\345\344\353\356\344", 
        (char *)"\345\344\353\371",      (char *)"\345\344\353\371\341",      (char *)"\345\344\353\371\341\353",      (char *)"\345\344\353\371\344", 
        (char *)"\345\344\353\371\353",      (char *)"\345\344\353\371\353\341",      (char *)"\345\344\353\371\353\353",      (char *)"\345\344\353\371\353\354", 
        (char *)"\345\344\353\371\353\356",      (char *)"\345\344\353\371\353\356\344",      (char *)"\345\344\353\371\354",      (char *)"\345\344\353\371\354\353", 
        (char *)"\345\344\353\371\356",      (char *)"\345\344\353\371\356\344",      (char *)"\345\344\353\371\356\353",      (char *)"\345\344\354", 
        (char *)"\345\344\354\353",      (char *)"\345\344\354\353\371",      (char *)"\345\344\354\353\371\341",      (char *)"\345\344\354\353\371\341\353", 
        (char *)"\345\344\354\353\371\344",      (char *)"\345\344\354\353\371\353",      (char *)"\345\344\354\353\371\353\341",      (char *)"\345\344\354\353\371\353\353", 
        (char *)"\345\344\354\353\371\353\354",      (char *)"\345\344\354\353\371\353\356",      (char *)"\345\344\354\353\371\353\356\344",      (char *)"\345\344\354\353\371\354", 
        (char *)"\345\344\354\353\371\354\353",      (char *)"\345\344\354\353\371\356",      (char *)"\345\344\354\353\371\356\344",      (char *)"\345\344\354\353\371\356\353", 
        (char *)"\345\344\356",      (char *)"\345\344\356\344",      (char *)"\345\344\356\353",      (char *)"\345\344\356\371", 
        (char *)"\345\344\356\371\341",      (char *)"\345\344\356\371\341\353",      (char *)"\345\344\356\371\344",      (char *)"\345\344\356\371\353", 
        (char *)"\345\344\356\371\353\341",      (char *)"\345\344\356\371\353\353",      (char *)"\345\344\356\371\353\354",      (char *)"\345\344\356\371\353\356", 
        (char *)"\345\344\356\371\353\356\344",      (char *)"\345\344\356\371\354",      (char *)"\345\344\356\371\354\353",      (char *)"\345\344\356\371\356", 
        (char *)"\345\344\356\371\356\344",      (char *)"\345\344\356\371\356\353",      (char *)"\345\353",      (char *)"\345\353\341", 
        (char *)"\345\353\353",      (char *)"\345\353\354",      (char *)"\345\353\356",      (char *)"\345\353\356\344", 
        (char *)"\345\353\371",      (char *)"\345\353\371\341",      (char *)"\345\353\371\341\353",      (char *)"\345\353\371\344", 
        (char *)"\345\353\371\353",      (char *)"\345\353\371\353\341",      (char *)"\345\353\371\353\353",      (char *)"\345\353\371\353\354", 
        (char *)"\345\353\371\353\356",      (char *)"\345\353\371\353\356\344",      (char *)"\345\353\371\354",      (char *)"\345\353\371\354\353", 
        (char *)"\345\353\371\356",      (char *)"\345\353\371\356\344",      (char *)"\345\353\371\356\353",      (char *)"\345\354", 
        (char *)"\345\354\353",      (char *)"\345\354\353\371",      (char *)"\345\354\353\371\341",      (char *)"\345\354\353\371\341\353", 
        (char *)"\345\354\353\371\344",      (char *)"\345\354\353\371\353",      (char *)"\345\354\353\371\353\341",      (char *)"\345\354\353\371\353\353", 
        (char *)"\345\354\353\371\353\354",      (char *)"\345\354\353\371\353\356",      (char *)"\345\354\353\371\353\356\344",      (char *)"\345\354\353\371\354", 
        (char *)"\345\354\353\371\354\353",      (char *)"\345\354\353\371\356",      (char *)"\345\354\353\371\356\344",      (char *)"\345\354\353\371\356\353", 
        (char *)"\345\356",      (char *)"\345\356\344",      (char *)"\345\356\353",      (char *)"\345\356\371", 
        (char *)"\345\356\371\341",      (char *)"\345\356\371\341\353",      (char *)"\345\356\371\344",      (char *)"\345\356\371\353", 
        (char *)"\345\356\371\353\341",      (char *)"\345\356\371\353\353",      (char *)"\345\356\371\353\354",      (char *)"\345\356\371\353\356", 
        (char *)"\345\356\371\353\356\344",      (char *)"\345\356\371\354",      (char *)"\345\356\371\354\353",      (char *)"\345\356\371\356", 
        (char *)"\345\356\371\356\344",      (char *)"\345\356\371\356\353",      (char *)"\345\371",      (char *)"\345\371\341", 
        (char *)"\345\371\341\353",      (char *)"\345\371\344",      (char *)"\345\371\353",      (char *)"\345\371\353\341", 
        (char *)"\345\371\353\353",      (char *)"\345\371\353\354",      (char *)"\345\371\353\356",      (char *)"\345\371\353\356\344", 
        (char *)"\345\371\353\371",      (char *)"\345\371\353\371\341",      (char *)"\345\371\353\371\341\353",      (char *)"\345\371\353\371\344", 
        (char *)"\345\371\353\371\353",      (char *)"\345\371\353\371\353\341",      (char *)"\345\371\353\371\353\353",      (char *)"\345\371\353\371\353\354", 
        (char *)"\345\371\353\371\353\356",      (char *)"\345\371\353\371\353\356\344",      (char *)"\345\371\353\371\354",      (char *)"\345\371\353\371\354\353", 
        (char *)"\345\371\353\371\356",      (char *)"\345\371\353\371\356\344",      (char *)"\345\371\353\371\356\353",      (char *)"\345\371\354", 
        (char *)"\345\371\354\353",      (char *)"\345\371\354\353\371",      (char *)"\345\371\354\353\371\341",      (char *)"\345\371\354\353\371\341\353", 
        (char *)"\345\371\354\353\371\344",      (char *)"\345\371\354\353\371\353",      (char *)"\345\371\354\353\371\353\341",      (char *)"\345\371\354\353\371\353\353", 
        (char *)"\345\371\354\353\371\353\354",      (char *)"\345\371\354\353\371\353\356",      (char *)"\345\371\354\353\371\353\356\344",      (char *)"\345\371\354\353\371\354", 
        (char *)"\345\371\354\353\371\354\353",      (char *)"\345\371\354\353\371\356",      (char *)"\345\371\354\353\371\356\344",      (char *)"\345\371\354\353\371\356\353", 
        (char *)"\345\371\356",      (char *)"\345\371\356\344",      (char *)"\345\371\356\353",      (char *)"\345\371\356\371", 
        (char *)"\345\371\356\371\341",      (char *)"\345\371\356\371\341\353",      (char *)"\345\371\356\371\344",      (char *)"\345\371\356\371\353", 
        (char *)"\345\371\356\371\353\341",      (char *)"\345\371\356\371\353\353",      (char *)"\345\371\356\371\353\354",      (char *)"\345\371\356\371\353\356", 
        (char *)"\345\371\356\371\353\356\344",      (char *)"\345\371\356\371\354",      (char *)"\345\371\356\371\354\353",      (char *)"\345\371\356\371\356", 
        (char *)"\345\371\356\371\356\344",      (char *)"\345\371\356\371\356\353",      (char *)"\353",      (char *)"\353\341", 
        (char *)"\353\353",      (char *)"\353\354",      (char *)"\353\356",      (char *)"\353\356\344", 
        (char *)"\353\371",      (char *)"\353\371\341",      (char *)"\353\371\341\353",      (char *)"\353\371\344", 
        (char *)"\353\371\353",      (char *)"\353\371\353\341",      (char *)"\353\371\353\353",      (char *)"\353\371\353\354", 
        (char *)"\353\371\353\356",      (char *)"\353\371\353\356\344",      (char *)"\353\371\354",      (char *)"\353\371\354\353", 
        (char *)"\353\371\356",      (char *)"\353\371\356\344",      (char *)"\353\371\356\353",      (char *)"\354", 
        (char *)"\354\353",      (char *)"\354\353\371",      (char *)"\354\353\371\341",      (char *)"\354\353\371\341\353", 
        (char *)"\354\353\371\344",      (char *)"\354\353\371\353",      (char *)"\354\353\371\353\341",      (char *)"\354\353\371\353\353", 
        (char *)"\354\353\371\353\354",      (char *)"\354\353\371\353\356",      (char *)"\354\353\371\353\356\344",      (char *)"\354\353\371\354", 
        (char *)"\354\353\371\354\353",      (char *)"\354\353\371\356",      (char *)"\354\353\371\356\344",      (char *)"\354\353\371\356\353", 
        (char *)"\356",      (char *)"\356\341",      (char *)"\356\344",      (char *)"\356\353", 
        (char *)"\356\354",      (char *)"\356\371",      (char *)"\356\371\341",      (char *)"\356\371\341\353", 
        (char *)"\356\371\344",      (char *)"\356\371\353",      (char *)"\356\371\353\341",      (char *)"\356\371\353\353", 
        (char *)"\356\371\353\354",      (char *)"\356\371\353\356",      (char *)"\356\371\353\356\344",      (char *)"\356\371\354", 
        (char *)"\356\371\354\353",      (char *)"\356\371\356",      (char *)"\356\371\356\344",      (char *)"\356\371\356\353", 
        (char *)"\371",      (char *)"\371\341",      (char *)"\371\341\353",      (char *)"\371\344", 
        (char *)"\371\353",      (char *)"\371\353\341",      (char *)"\371\353\353",      (char *)"\371\353\354", 
        (char *)"\371\353\356",      (char *)"\371\353\356\344",      (char *)"\371\353\371",      (char *)"\371\353\371\341", 
        (char *)"\371\353\371\341\353",      (char *)"\371\353\371\344",      (char *)"\371\353\371\353",      (char *)"\371\353\371\353\341", 
        (char *)"\371\353\371\353\353",      (char *)"\371\353\371\353\354",      (char *)"\371\353\371\353\356",      (char *)"\371\353\371\353\356\344", 
        (char *)"\371\353\371\354",      (char *)"\371\353\371\354\353",      (char *)"\371\353\371\356",      (char *)"\371\353\371\356\344", 
        (char *)"\371\353\371\356\353",      (char *)"\371\354",      (char *)"\371\354\353",      (char *)"\371\354\353\371", 
        (char *)"\371\354\353\371\341",      (char *)"\371\354\353\371\341\353",      (char *)"\371\354\353\371\344",      (char *)"\371\354\353\371\353", 
        (char *)"\371\354\353\371\353\341",      (char *)"\371\354\353\371\353\353",      (char *)"\371\354\353\371\353\354",      (char *)"\371\354\353\371\353\356", 
        (char *)"\371\354\353\371\353\356\344",      (char *)"\371\354\353\371\354",      (char *)"\371\354\353\371\354\353",      (char *)"\371\354\353\371\356", 
        (char *)"\371\354\353\371\356\344",      (char *)"\371\354\353\371\356\353",      (char *)"\371\356",      (char *)"\371\356\344", 
        (char *)"\371\356\353",      (char *)"\371\356\371",      (char *)"\371\356\371\341",      (char *)"\371\356\371\341\353", 
        (char *)"\371\356\371\344",      (char *)"\371\356\371\353",      (char *)"\371\356\371\353\341",      (char *)"\371\356\371\353\353", 
        (char *)"\371\356\371\353\354",      (char *)"\371\356\371\353\356",      (char *)"\371\356\371\353\356\344",      (char *)"\371\356\371\354", 
        (char *)"\371\356\371\354\353",      (char *)"\371\356\371\356",      (char *)"\371\356\371\356\344",      (char *)"\371\356\371\356\353", 
        (char *)0};
#line 852 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/prefixes.c"
static int masks_H[361]  = 
#line 852
  {      60,      43,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      32,      42, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      60, 
        43,      42,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      44,      43, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      32,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      42,      32, 
        44,      42,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      42,      42, 
        42,      32,      42,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        44,      43,      42,      32, 
        42,      42,      42,      42, 
        42,      32,      44,      42, 
        42,      32,      42,      42, 
        42,      42,      42,      32, 
        42,      42,      42,      32, 
        42,      42,      42,      44, 
        42,      42,      32,      42, 
        42,      42,      42,      42, 
        32,      42,      42,      42, 
        32,      42,      42,      32, 
        42,      44,      42,      42, 
        32,      42,      42,      42, 
        42,      42,      32,      42, 
        42,      42,      32,      42, 
        -1};
#line 93 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
static struct prefix_node *prefix_tree  =    (struct prefix_node *)0;
#line 95 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
static void build_prefix_tree(int allow_he_hasheela ) 
{ 
  int i ;
  char const   *p ;
  struct prefix_node **n ;
  char **prefixes ;
  int *masks ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 102
  if (allow_he_hasheela) {
#line 103
    prefixes = prefixes_H;
#line 104
    masks = masks_H;
  } else {
#line 106
    prefixes = prefixes_noH;
#line 107
    masks = masks_noH;
  }
#line 110
  i = 0;
  {
#line 110
  while (1) {
    while_continue: /* CIL Label */ ;
#line 110
    if (! *(prefixes + i)) {
#line 110
      goto while_break;
    }
#line 111
    p = (char const   *)*(prefixes + i);
#line 112
    n = & prefix_tree;
#line 113
    if (hspell_debug) {
      {
#line 114
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"prefix %s ",
              p);
      }
    }
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 115
      if (! *p) {
#line 115
        goto while_break___0;
      }
#line 116
      if (! *n) {
        {
#line 117
        tmp = calloc((size_t )1, sizeof(struct prefix_node ));
#line 117
        *n = (struct prefix_node *)tmp;
        }
      }
#line 119
      n = & (*n)->next[(int const   )*p - -32];
#line 120
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 123
    if (! *n) {
      {
#line 124
      tmp___0 = calloc((size_t )1, sizeof(struct prefix_node ));
#line 124
      *n = (struct prefix_node *)tmp___0;
      }
    }
#line 126
    (*n)->mask = *(masks + i);
#line 128
    if (hspell_debug) {
      {
#line 129
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"mask=%d\n",
              (*n)->mask);
      }
    }
#line 110
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 131
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
static void free_prefix_tree(struct prefix_node *n ) 
{ 
  int i ;

  {
#line 138
  if (! n) {
#line 139
    return;
  }
#line 140
  i = 0;
  {
#line 140
  while (1) {
    while_continue: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )i < sizeof(n->next) / sizeof(n->next[0]))) {
#line 140
      goto while_break;
    }
    {
#line 141
    free_prefix_tree(n->next[i]);
#line 140
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 142
  free((void *)n);
  }
#line 143
  return;
}
}
#line 146 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
int hspell_check_word(struct dict_radix *dict , char const   *word , int *preflen ) 
{ 
  int hashebrew ;
  char const   *w ;
  struct prefix_node *n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 150
  w = word;
#line 152
  *preflen = 0;
#line 155
  hashebrew = 0;
  {
#line 156
  while (1) {
    while_continue: /* CIL Label */ ;
#line 156
    if (! *w) {
#line 156
      goto while_break;
    }
#line 157
    if ((int const   )*w >= -32) {
#line 157
      if ((int const   )*w <= -6) {
#line 158
        hashebrew = 1;
#line 159
        goto while_break;
      }
    }
#line 161
    (*preflen) ++;
#line 162
    w ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  if (! hashebrew) {
#line 165
    return (1);
  }
#line 168
  n = prefix_tree;
#line 169
  if (hspell_debug) {
    {
#line 170
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"looking %s\n",
            w);
    }
  }
  {
#line 171
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 171
    if (*w) {
#line 171
      if (! n) {
#line 171
        goto while_break___0;
      }
    } else {
#line 171
      goto while_break___0;
    }
#line 179
    if ((int const   )*w == 34) {
#line 180
      (*preflen) ++;
#line 181
      w ++;
#line 182
      goto while_continue___0;
    }
#line 191
    if ((unsigned long )n != (unsigned long )prefix_tree) {
#line 191
      if ((int const   )*w == -27) {
#line 191
        if ((int const   )*(w + -1) != -27) {
#line 192
          if ((int const   )*(w + 1) == -27) {
#line 193
            if ((int const   )*(w + 2) != -27) {
              {
#line 193
              tmp___0 = lookup((struct dict_radix  const  *)dict, w + 1);
              }
#line 193
              if (tmp___0 & n->mask) {
#line 195
                if (hspell_debug) {
                  {
#line 196
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %s: double waw.\n",
                          w);
                  }
                }
#line 197
                return (1);
              } else {
#line 193
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 198
              tmp = lookup((struct dict_radix  const  *)dict, w);
              }
#line 198
              if (tmp & n->mask) {
#line 200
                if (hspell_debug) {
                  {
#line 201
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %s: nondouble waw.\n",
                          w);
                  }
                }
#line 202
                return (1);
              }
            }
          }
        } else {
#line 191
          goto _L___1;
        }
      } else {
#line 191
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 206
      if (hspell_debug) {
        {
#line 206
        tmp___1 = lookup((struct dict_radix  const  *)dict, w);
#line 206
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"tried %s mask %d prefmask %d\n",
                w, tmp___1, n->mask);
        }
      }
      {
#line 207
      tmp___2 = lookup((struct dict_radix  const  *)dict, w);
      }
#line 207
      if (tmp___2 & n->mask) {
#line 207
        return (1);
      }
    }
#line 211
    if ((int const   )*w >= -32) {
#line 211
      if ((int const   )*w <= -6) {
#line 212
        n = n->next[(int const   )*w - -32];
#line 213
        (*preflen) ++;
#line 214
        w ++;
      } else {
#line 216
        goto while_break___0;
      }
    } else {
#line 216
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 219
  if (n) {
#line 219
    if (! *w) {
#line 222
      if (hspell_debug) {
        {
#line 222
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting empty word\n");
        }
      }
#line 223
      return (1);
    } else {
#line 225
      return (0);
    }
  } else {
#line 225
    return (0);
  }
}
}
#line 230 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
int hspell_enum_splits(struct dict_radix *dict , char const   *word , hspell_word_split_callback_func *enumf ) 
{ 
  int preflen ;
  int count ;
  int hashebrew ;
  char const   *w ;
  struct prefix_node *n ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 233
  preflen = 0;
#line 233
  count = 0;
#line 236
  w = word;
#line 240
  hashebrew = 0;
  {
#line 241
  while (1) {
    while_continue: /* CIL Label */ ;
#line 241
    if (! *w) {
#line 241
      goto while_break;
    }
#line 242
    if ((int const   )*w >= -32) {
#line 242
      if ((int const   )*w <= -6) {
#line 243
        hashebrew = 1;
#line 244
        goto while_break;
      }
    }
#line 246
    preflen ++;
#line 247
    w ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  if (! hashebrew) {
#line 250
    return (-1);
  }
#line 252
  n = prefix_tree;
#line 253
  if (hspell_debug) {
    {
#line 254
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enum_splits looking %s\n",
            w);
    }
  }
  {
#line 255
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 255
    if (*w) {
#line 255
      if (! n) {
#line 255
        goto while_break___0;
      }
    } else {
#line 255
      goto while_break___0;
    }
#line 263
    if ((int const   )*w == 34) {
#line 264
      preflen ++;
#line 265
      w ++;
#line 266
      goto while_continue___0;
    }
#line 275
    if ((unsigned long )n != (unsigned long )prefix_tree) {
#line 275
      if ((int const   )*w == -27) {
#line 275
        if ((int const   )*(w + -1) != -27) {
#line 276
          if ((int const   )*(w + 1) == -27) {
#line 277
            if ((int const   )*(w + 2) != -27) {
              {
#line 277
              tmp___2 = lookup((struct dict_radix  const  *)dict, w + 1);
              }
#line 277
              if (tmp___2 & n->mask) {
#line 278
                w ++;
#line 280
                if (hspell_debug) {
                  {
#line 281
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %s: double waw.\n",
                          w);
                  }
                }
                {
#line 282
                tmp = preflen;
#line 282
                preflen ++;
#line 282
                (*enumf)(word, w, tmp, n->mask);
#line 283
                n = n->next[(int const   )*w - -32];
#line 283
                w ++;
#line 284
                count ++;
                }
#line 285
                goto while_continue___0;
              } else {
#line 277
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 286
              tmp___1 = lookup((struct dict_radix  const  *)dict, w);
              }
#line 286
              if (tmp___1 & n->mask) {
#line 288
                if (hspell_debug) {
                  {
#line 289
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found %s: nondouble waw.\n",
                          w);
                  }
                }
                {
#line 290
                tmp___0 = preflen;
#line 290
                preflen ++;
#line 290
                (*enumf)(word, w, tmp___0, n->mask);
#line 291
                n = n->next[(int const   )*w - -32];
#line 291
                w ++;
#line 292
                count ++;
                }
#line 293
                goto while_continue___0;
              }
            }
          }
        } else {
#line 275
          goto _L___1;
        }
      } else {
#line 275
        goto _L___1;
      }
    } else {
      _L___1: /* CIL Label */ 
#line 297
      if (hspell_debug) {
        {
#line 297
        tmp___3 = lookup((struct dict_radix  const  *)dict, w);
#line 297
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enum_splits: tried %s mask %d prefmask %d\n",
                w, tmp___3, n->mask);
        }
      }
      {
#line 298
      tmp___5 = lookup((struct dict_radix  const  *)dict, w);
      }
#line 298
      if (tmp___5 & n->mask) {
        {
#line 299
        tmp___4 = preflen;
#line 299
        preflen ++;
#line 299
        (*enumf)(word, w, tmp___4, n->mask);
#line 300
        n = n->next[(int const   )*w - -32];
#line 300
        w ++;
#line 301
        count ++;
        }
#line 302
        goto while_continue___0;
      }
    }
#line 307
    if ((int const   )*w >= -32) {
#line 307
      if ((int const   )*w <= -6) {
#line 308
        n = n->next[(int const   )*w - -32];
#line 309
        preflen ++;
#line 310
        w ++;
      } else {
#line 312
        goto while_break___0;
      }
    } else {
#line 312
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 315
  if (n) {
#line 315
    if (! *w) {
#line 318
      if (hspell_debug) {
        {
#line 318
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Accepting empty word\n");
        }
      }
      {
#line 319
      (*enumf)(word, w, preflen, n->mask);
#line 320
      count ++;
      }
    }
  }
#line 323
  if (hspell_debug) {
    {
#line 323
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"enum_splits found %d splits\n",
            count);
    }
  }
#line 324
  return (count);
}
}
#line 337 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
__inline static void splice(char *buf , int size , char const   *s1 , int s1len ,
                            char c1 , char c2 , char const   *s2 ) 
{ 
  int len ;
  int tmp ;
  int tmp___0 ;

  {
#line 340
  len = s1len;
#line 341
  if (len >= size) {
#line 342
    len = size - 1;
  }
  {
#line 343
  strncpy((char */* __restrict  */)buf, (char const   */* __restrict  */)s1, (size_t )len);
  }
#line 344
  if (len + 1 >= size) {
#line 345
    *(buf + len) = (char )'\000';
#line 346
    return;
  } else
#line 347
  if (c1) {
#line 348
    tmp = len;
#line 348
    len ++;
#line 348
    *(buf + tmp) = c1;
  }
#line 350
  if (len + 1 >= size) {
#line 351
    *(buf + len) = (char )'\000';
#line 352
    return;
  } else
#line 353
  if (c2) {
#line 354
    tmp___0 = len;
#line 354
    len ++;
#line 354
    *(buf + tmp___0) = c2;
  }
#line 356
  if (s2) {
    {
#line 357
    strncpy((char */* __restrict  */)(buf + len), (char const   */* __restrict  */)s2,
            (size_t )((size - len) - 1));
#line 358
    *(buf + (size - 1)) = (char )'\000';
    }
  } else {
#line 360
    *(buf + len) = (char )'\000';
  }
#line 362
  return;
}
}
#line 371 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
static char *similar[9]  = 
#line 371
  {      (char *)"\344\362\340",      (char *)"\342\344",      (char *)"\353\347",      (char *)"\372\350", 
        (char *)"\366\361",      (char *)"\371\361",      (char *)"\353\367",      (char *)"\341\345", 
        (char *)"\364\341"};
#line 365 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
void hspell_trycorrect(struct dict_radix *dict , char const   *w , struct corlist *cl ) 
{ 
  char buf[30] ;
  int i ;
  int len ;
  size_t tmp ;
  int preflen ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int group ;
  char *g ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
  {
#line 370
  tmp = strlen(w);
#line 370
  len = (int )tmp;
#line 376
  i = 1;
  }
  {
#line 376
  while (1) {
    while_continue: /* CIL Label */ ;
#line 376
    if (! (i < len)) {
#line 376
      goto while_break;
    }
    {
#line 377
    splice(buf, (int )sizeof(buf), w, i, (char )'\351', (char)0, w + i);
#line 378
    tmp___0 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
#line 378
    if (tmp___0) {
      {
#line 378
      corlist_add(cl, (char const   *)(buf));
      }
    }
    {
#line 379
    splice(buf, (int )sizeof(buf), w, i, (char )'\345', (char)0, w + i);
#line 380
    tmp___1 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
#line 380
    if (tmp___1) {
      {
#line 380
      corlist_add(cl, (char const   *)(buf));
      }
    }
#line 376
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 384
  i = 1;
  {
#line 384
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 384
    if (! (i < len - 1)) {
#line 384
      goto while_break___0;
    }
#line 385
    if ((int const   )*(w + i) == -23) {
#line 385
      goto _L;
    } else
#line 385
    if ((int const   )*(w + i) == -27) {
      _L: /* CIL Label */ 
      {
#line 386
      splice(buf, (int )sizeof(buf), w, i, (char)0, (char)0, (w + i) + 1);
#line 387
      tmp___2 = hspell_check_word(dict, (char const   *)(buf), & preflen);
      }
#line 387
      if (tmp___2) {
        {
#line 387
        corlist_add(cl, (char const   *)(buf));
        }
      }
    }
#line 384
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 393
  i = 1;
  {
#line 393
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 393
    if (! (i < len)) {
#line 393
      goto while_break___1;
    }
    {
#line 394
    splice(buf, (int )sizeof(buf), w, i, (char )'\340', (char)0, w + i);
#line 395
    tmp___3 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
#line 395
    if (tmp___3) {
      {
#line 395
      corlist_add(cl, (char const   *)(buf));
      }
    }
#line 393
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 397
  i = 1;
  {
#line 397
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 397
    if (! (i < len - 1)) {
#line 397
      goto while_break___2;
    }
#line 398
    if ((int const   )*(w + i) == -32) {
      {
#line 399
      splice(buf, (int )sizeof(buf), w, i, (char)0, (char)0, (w + i) + 1);
#line 400
      tmp___4 = hspell_check_word(dict, (char const   *)(buf), & preflen);
      }
#line 400
      if (tmp___4) {
        {
#line 400
        corlist_add(cl, (char const   *)(buf));
        }
      }
    }
#line 397
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 405
  i = 0;
  {
#line 405
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 405
    if (! (i < len)) {
#line 405
      goto while_break___3;
    }
#line 408
    group = 0;
    {
#line 408
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 408
      if (! ((unsigned long )group < sizeof(similar) / sizeof(similar[0]))) {
#line 408
        goto while_break___4;
      }
#line 410
      g = similar[group];
      {
#line 410
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 410
        if (*g) {
#line 410
          if (! ((int )*g != (int )*(w + i))) {
#line 410
            goto while_break___5;
          }
        } else {
#line 410
          goto while_break___5;
        }
#line 410
        g ++;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 412
      if (*g) {
#line 415
        g = similar[group];
        {
#line 415
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 415
          if (! *g) {
#line 415
            goto while_break___6;
          }
#line 416
          if ((int )*g == (int )*(w + i)) {
#line 416
            goto __Cont;
          }
#line 417
          if (i > 0) {
#line 417
            if ((int const   )*(w + i) == -27) {
#line 417
              if ((int const   )*(w + (i + 1)) == -27) {
                {
#line 418
                splice(buf, (int )sizeof(buf), w, i, *g, (char)0, (w + i) + 2);
                }
              } else {
#line 417
                goto _L___1;
              }
            } else {
#line 417
              goto _L___1;
            }
          } else
          _L___1: /* CIL Label */ 
#line 419
          if ((int )*g == -27) {
            {
#line 420
            splice(buf, (int )sizeof(buf), w, i, (char )'\345', (char )'\345', (w + i) + 1);
            }
          } else {
            {
#line 422
            splice(buf, (int )sizeof(buf), w, i, *g, (char)0, (w + i) + 1);
            }
          }
          {
#line 423
          tmp___5 = hspell_check_word(dict, (char const   *)(buf), & preflen);
          }
#line 423
          if (tmp___5) {
            {
#line 423
            corlist_add(cl, (char const   *)(buf));
            }
          }
          __Cont: /* CIL Label */ 
#line 415
          g ++;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
#line 408
      group ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 405
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 430
  if (len > 0) {
#line 430
    if ((unsigned long )len < sizeof(buf)) {
      {
#line 431
      strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)w,
              sizeof(buf));
      }
      {
#line 433
      if ((int const   )*(w + (len - 1)) == -22) {
#line 433
        goto case_neg_22;
      }
#line 434
      if ((int const   )*(w + (len - 1)) == -19) {
#line 434
        goto case_neg_19;
      }
#line 435
      if ((int const   )*(w + (len - 1)) == -17) {
#line 435
        goto case_neg_17;
      }
#line 436
      if ((int const   )*(w + (len - 1)) == -11) {
#line 436
        goto case_neg_11;
      }
#line 437
      if ((int const   )*(w + (len - 1)) == -13) {
#line 437
        goto case_neg_13;
      }
#line 438
      if ((int const   )*(w + (len - 1)) == -21) {
#line 438
        goto case_neg_21;
      }
#line 439
      if ((int const   )*(w + (len - 1)) == -18) {
#line 439
        goto case_neg_18;
      }
#line 440
      if ((int const   )*(w + (len - 1)) == -16) {
#line 440
        goto case_neg_16;
      }
#line 441
      if ((int const   )*(w + (len - 1)) == -10) {
#line 441
        goto case_neg_10;
      }
#line 442
      if ((int const   )*(w + (len - 1)) == -12) {
#line 442
        goto case_neg_12;
      }
#line 432
      goto switch_break;
      case_neg_22: /* CIL Label */ 
#line 433
      buf[len - 1] = (char )'\353';
#line 433
      goto switch_break;
      case_neg_19: /* CIL Label */ 
#line 434
      buf[len - 1] = (char )'\356';
#line 434
      goto switch_break;
      case_neg_17: /* CIL Label */ 
#line 435
      buf[len - 1] = (char )'\360';
#line 435
      goto switch_break;
      case_neg_11: /* CIL Label */ 
#line 436
      buf[len - 1] = (char )'\366';
#line 436
      goto switch_break;
      case_neg_13: /* CIL Label */ 
#line 437
      buf[len - 1] = (char )'\364';
#line 437
      goto switch_break;
      case_neg_21: /* CIL Label */ 
#line 438
      buf[len - 1] = (char )'\352';
#line 438
      goto switch_break;
      case_neg_18: /* CIL Label */ 
#line 439
      buf[len - 1] = (char )'\355';
#line 439
      goto switch_break;
      case_neg_16: /* CIL Label */ 
#line 440
      buf[len - 1] = (char )'\357';
#line 440
      goto switch_break;
      case_neg_10: /* CIL Label */ 
#line 441
      buf[len - 1] = (char )'\365';
#line 441
      goto switch_break;
      case_neg_12: /* CIL Label */ 
#line 442
      buf[len - 1] = (char )'\363';
#line 442
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
#line 444
      if ((int )buf[len - 1] != (int )*(w + (len - 1))) {
        {
#line 444
        tmp___6 = hspell_check_word(dict, (char const   *)(buf), & preflen);
        }
#line 444
        if (tmp___6) {
          {
#line 444
          corlist_add(cl, (char const   *)(buf));
          }
        }
      }
    }
  }
#line 447
  if (len >= 2) {
    {
#line 448
    splice(buf, (int )sizeof(buf), w, len - 1, (char )'\"', (char )*(w + (len - 1)),
           (char const   *)0);
#line 449
    tmp___7 = hspell_check_word(dict, (char const   *)(buf), & preflen);
    }
#line 449
    if (tmp___7) {
      {
#line 449
      corlist_add(cl, (char const   *)(buf));
      }
    }
  }
  {
#line 452
  snprintf((char */* __restrict  */)(buf), sizeof(buf), (char const   */* __restrict  */)"%s\'",
           w);
#line 453
  tmp___8 = hspell_check_word(dict, (char const   *)(buf), & preflen);
  }
#line 453
  if (tmp___8) {
    {
#line 453
    corlist_add(cl, (char const   *)(buf));
    }
  }
#line 454
  return;
}
}
#line 462 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
int hspell_init(struct dict_radix **dictp , int flags ) 
{ 
  int ret ;

  {
  {
#line 465
  ret = load_data(dictp);
  }
#line 466
  if (ret < 0) {
#line 466
    return (ret);
  }
  {
#line 467
  build_prefix_tree(flags & 1);
  }
#line 473
  return (0);
}
}
#line 490 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/libhspell.c"
void hspell_uninit(struct dict_radix *dict ) 
{ 


  {
  {
#line 493
  delete_dict_radix(dict);
#line 496
  free_prefix_tree(prefix_tree);
#line 497
  prefix_tree = (struct prefix_node *)0;
  }
#line 501
  return;
}
}
#line 11 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gimatria.c"
static unsigned int gim2int(char const   *w ) 
{ 
  int n ;

  {
#line 13
  n = 0;
#line 14
  if (hspell_debug) {
    {
#line 14
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"gim2int got %s ",
            w);
    }
  }
  {
#line 15
  while (1) {
    while_continue: /* CIL Label */ ;
#line 15
    if (! *w) {
#line 15
      goto while_break;
    }
    {
#line 17
    if ((int const   )*w == 39) {
#line 17
      goto case_39;
    }
#line 28
    if ((int const   )*w == -32) {
#line 28
      goto case_neg_32;
    }
#line 29
    if ((int const   )*w == -31) {
#line 29
      goto case_neg_31;
    }
#line 30
    if ((int const   )*w == -30) {
#line 30
      goto case_neg_30;
    }
#line 31
    if ((int const   )*w == -29) {
#line 31
      goto case_neg_29;
    }
#line 32
    if ((int const   )*w == -28) {
#line 32
      goto case_neg_28;
    }
#line 33
    if ((int const   )*w == -27) {
#line 33
      goto case_neg_27;
    }
#line 34
    if ((int const   )*w == -26) {
#line 34
      goto case_neg_26;
    }
#line 35
    if ((int const   )*w == -25) {
#line 35
      goto case_neg_25;
    }
#line 36
    if ((int const   )*w == -24) {
#line 36
      goto case_neg_24;
    }
#line 37
    if ((int const   )*w == -23) {
#line 37
      goto case_neg_23;
    }
#line 38
    if ((int const   )*w == -22) {
#line 38
      goto case_neg_22;
    }
#line 38
    if ((int const   )*w == -21) {
#line 38
      goto case_neg_22;
    }
#line 39
    if ((int const   )*w == -20) {
#line 39
      goto case_neg_20;
    }
#line 40
    if ((int const   )*w == -19) {
#line 40
      goto case_neg_19;
    }
#line 40
    if ((int const   )*w == -18) {
#line 40
      goto case_neg_19;
    }
#line 41
    if ((int const   )*w == -17) {
#line 41
      goto case_neg_17;
    }
#line 41
    if ((int const   )*w == -16) {
#line 41
      goto case_neg_17;
    }
#line 42
    if ((int const   )*w == -15) {
#line 42
      goto case_neg_15;
    }
#line 43
    if ((int const   )*w == -14) {
#line 43
      goto case_neg_14;
    }
#line 44
    if ((int const   )*w == -13) {
#line 44
      goto case_neg_13;
    }
#line 44
    if ((int const   )*w == -12) {
#line 44
      goto case_neg_13;
    }
#line 45
    if ((int const   )*w == -11) {
#line 45
      goto case_neg_11;
    }
#line 45
    if ((int const   )*w == -10) {
#line 45
      goto case_neg_11;
    }
#line 46
    if ((int const   )*w == -9) {
#line 46
      goto case_neg_9;
    }
#line 47
    if ((int const   )*w == -8) {
#line 47
      goto case_neg_8;
    }
#line 48
    if ((int const   )*w == -7) {
#line 48
      goto case_neg_7;
    }
#line 49
    if ((int const   )*w == -6) {
#line 49
      goto case_neg_6;
    }
#line 16
    goto switch_break;
    case_39: /* CIL Label */ 
#line 25
    if (*(w + 1)) {
#line 26
      n *= 1000;
    }
#line 27
    goto switch_break;
    case_neg_32: /* CIL Label */ 
#line 28
    n ++;
#line 28
    goto switch_break;
    case_neg_31: /* CIL Label */ 
#line 29
    n += 2;
#line 29
    goto switch_break;
    case_neg_30: /* CIL Label */ 
#line 30
    n += 3;
#line 30
    goto switch_break;
    case_neg_29: /* CIL Label */ 
#line 31
    n += 4;
#line 31
    goto switch_break;
    case_neg_28: /* CIL Label */ 
#line 32
    n += 5;
#line 32
    goto switch_break;
    case_neg_27: /* CIL Label */ 
#line 33
    n += 6;
#line 33
    goto switch_break;
    case_neg_26: /* CIL Label */ 
#line 34
    n += 7;
#line 34
    goto switch_break;
    case_neg_25: /* CIL Label */ 
#line 35
    n += 8;
#line 35
    goto switch_break;
    case_neg_24: /* CIL Label */ 
#line 36
    n += 9;
#line 36
    goto switch_break;
    case_neg_23: /* CIL Label */ 
#line 37
    n += 10;
#line 37
    goto switch_break;
    case_neg_22: /* CIL Label */ 
    case_neg_21: /* CIL Label */ 
#line 38
    n += 20;
#line 38
    goto switch_break;
    case_neg_20: /* CIL Label */ 
#line 39
    n += 30;
#line 39
    goto switch_break;
    case_neg_19: /* CIL Label */ 
    case_neg_18: /* CIL Label */ 
#line 40
    n += 40;
#line 40
    goto switch_break;
    case_neg_17: /* CIL Label */ 
    case_neg_16: /* CIL Label */ 
#line 41
    n += 50;
#line 41
    goto switch_break;
    case_neg_15: /* CIL Label */ 
#line 42
    n += 60;
#line 42
    goto switch_break;
    case_neg_14: /* CIL Label */ 
#line 43
    n += 70;
#line 43
    goto switch_break;
    case_neg_13: /* CIL Label */ 
    case_neg_12: /* CIL Label */ 
#line 44
    n += 80;
#line 44
    goto switch_break;
    case_neg_11: /* CIL Label */ 
    case_neg_10: /* CIL Label */ 
#line 45
    n += 90;
#line 45
    goto switch_break;
    case_neg_9: /* CIL Label */ 
#line 46
    n += 100;
#line 46
    goto switch_break;
    case_neg_8: /* CIL Label */ 
#line 47
    n += 200;
#line 47
    goto switch_break;
    case_neg_7: /* CIL Label */ 
#line 48
    n += 300;
#line 48
    goto switch_break;
    case_neg_6: /* CIL Label */ 
#line 49
    n += 400;
#line 49
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 52
    w ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 54
  if (hspell_debug) {
    {
#line 54
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"returning %d\n",
            n);
    }
  }
#line 55
  return ((unsigned int )n);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gimatria.c"
static char *appendStr(char *src , char *dst ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! *src) {
#line 99
      goto while_break;
    }
#line 100
    tmp = dst;
#line 100
    dst ++;
#line 100
    tmp___0 = src;
#line 100
    src ++;
#line 100
    *tmp = *tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  *dst = (char )'\000';
#line 103
  return (dst);
}
}
#line 108
static void int2gim(unsigned int n , char *buf ) ;
#line 108 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gimatria.c"
static char *digits[3][9]  = { {        (char *)"\340",        (char *)"\341",        (char *)"\342",        (char *)"\343", 
            (char *)"\344",        (char *)"\345",        (char *)"\346",        (char *)"\347", 
            (char *)"\350"}, 
   {        (char *)"\351",        (char *)"\353",        (char *)"\354",        (char *)"\356", 
            (char *)"\360",        (char *)"\361",        (char *)"\362",        (char *)"\364", 
            (char *)"\366"}, 
   {        (char *)"\367",        (char *)"\370",        (char *)"\371",        (char *)"\372", 
            (char *)"\367\372",        (char *)"\370\372",        (char *)"\371\372",        (char *)"\372\372", 
            (char *)"\367\372\372"}};
#line 113 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gimatria.c"
static char *special[2]  = {      (char *)"\345\350",      (char *)"\346\350"};
#line 105 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gimatria.c"
static void int2gim(unsigned int n , char *buf ) 
{ 
  int i ;
  char *b ;
  char *bleft ;
  char *bright ;
  char tmp ;
  char save ;

  {
#line 114
  i = 0;
#line 115
  b = buf;
#line 116
  *b = (char )'\000';
#line 118
  if (hspell_debug) {
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"int2gim got %d ",
            n);
    }
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
#line 119
    if (! (n > 0U)) {
#line 119
      goto while_break;
    }
#line 120
    if (i == 3) {
      {
#line 120
      i = 0;
#line 120
      b = appendStr((char *)"\'", b);
      }
    }
#line 121
    if (! i) {
#line 121
      if (n % 100U == 15U) {
        {
#line 122
        b = appendStr(special[n % 100U - 15U], b);
#line 123
        n /= 100U;
#line 124
        i = 2;
        }
      } else
#line 121
      if (n % 100U == 16U) {
        {
#line 122
        b = appendStr(special[n % 100U - 15U], b);
#line 123
        n /= 100U;
#line 124
        i = 2;
        }
      } else {
#line 121
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
#line 126
      if (n % 10U) {
        {
#line 126
        b = appendStr(digits[i][n % 10U - 1U], b);
        }
      }
#line 128
      n /= 10U;
#line 129
      i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 133
  if (hspell_debug) {
    {
#line 133
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"before %s\n",
            buf);
    }
  }
#line 134
  if ((int )*(buf + 0) != 0) {
#line 135
    bleft = buf;
#line 135
    bright = b - 1;
    {
#line 135
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 135
      if (! ((unsigned long )bright > (unsigned long )bleft)) {
#line 135
        goto while_break___0;
      }
#line 137
      tmp = *bleft;
#line 138
      *bleft = *bright;
#line 139
      *bright = tmp;
#line 135
      bleft ++;
#line 135
      bright --;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 141
  if (hspell_debug) {
    {
#line 141
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"after %s\n",
            buf);
    }
  }
#line 143
  if (*(buf + 0)) {
    {
#line 145
    if ((int )*(b + -1) == -21) {
#line 145
      goto case_neg_21;
    }
#line 146
    if ((int )*(b + -1) == -18) {
#line 146
      goto case_neg_18;
    }
#line 147
    if ((int )*(b + -1) == -16) {
#line 147
      goto case_neg_16;
    }
#line 148
    if ((int )*(b + -1) == -10) {
#line 148
      goto case_neg_10;
    }
#line 149
    if ((int )*(b + -1) == -12) {
#line 149
      goto case_neg_12;
    }
#line 144
    goto switch_break;
    case_neg_21: /* CIL Label */ 
#line 145
    *(b + -1) = (char )'\352';
#line 145
    goto switch_break;
    case_neg_18: /* CIL Label */ 
#line 146
    *(b + -1) = (char )'\355';
#line 146
    goto switch_break;
    case_neg_16: /* CIL Label */ 
#line 147
    *(b + -1) = (char )'\357';
#line 147
    goto switch_break;
    case_neg_10: /* CIL Label */ 
#line 148
    *(b + -1) = (char )'\365';
#line 148
    goto switch_break;
    case_neg_12: /* CIL Label */ 
#line 149
    *(b + -1) = (char )'\363';
#line 149
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
#line 155
  if ((int )*(buf + 0) != 0) {
#line 156
    if ((int )*(buf + 1) == 0) {
#line 157
      *(buf + 1) = (char )'\'';
#line 158
      *(buf + 2) = (char )'\000';
    } else
#line 163
    if ((int )*(b + -2) == 39) {
#line 163
      if ((int )*(b + -1) != 39) {
#line 164
        *(b + 0) = (char )'\'';
#line 165
        *(b + 1) = (char )'\000';
      } else {
#line 163
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 166
    if ((int )*(b + -1) != 39) {
#line 167
      save = *(b + -1);
#line 168
      *(b + -1) = (char )'\"';
#line 169
      *(b + 0) = save;
#line 170
      *(b + 1) = (char )'\000';
    }
  }
#line 173
  if (hspell_debug) {
    {
#line 173
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"returning %s\n",
            buf);
    }
  }
#line 174
  return;
}
}
#line 179 "/home/june/repo/benchmarks/collector/temp/hspell-1.2/gimatria.c"
unsigned int hspell_is_canonic_gimatria(char const   *w ) 
{ 
  char const   *p ;
  char buf[50] ;
  unsigned int val ;
  int tmp ;

  {
#line 187
  p = w;
  {
#line 187
  while (1) {
    while_continue: /* CIL Label */ ;
#line 187
    if (*p) {
#line 187
      if ((int const   )*p != 34) {
#line 187
        if (! ((int const   )*p != 39)) {
#line 187
          goto while_break;
        }
      } else {
#line 187
        goto while_break;
      }
    } else {
#line 187
      goto while_break;
    }
#line 187
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 189
  if (! *p) {
#line 190
    return (0U);
  }
  {
#line 192
  val = gim2int(w);
#line 192
  int2gim(val, buf);
#line 193
  tmp = strcmp(w, (char const   *)(buf));
  }
#line 193
  if (tmp) {
#line 193
    val = 0U;
  }
#line 194
  return (val);
}
}
