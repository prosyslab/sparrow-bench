/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 62 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.h"
enum __anonenum_CPLErr_31 {
    CE_None = 0,
    CE_Log = 1,
    CE_Warning = 2,
    CE_Failure = 3,
    CE_Fatal = 4
} ;
#line 62 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.h"
typedef enum __anonenum_CPLErr_31 CPLErr;
#line 107 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00compr.h"
struct _E00ReadInfo {
   FILE *fp ;
   int bEOF ;
   int bIsCompressed ;
   int nInputLineNo ;
   int iInBufPtr ;
   char szInBuf[256] ;
   char szOutBuf[256] ;
   void *pRefData ;
   char const   *(*pfnReadNextLine)(void * ) ;
   void (*pfnReadRewind)(void * ) ;
};
#line 127 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00compr.h"
typedef struct _E00ReadInfo *E00ReadPtr;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 135 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00compr.h"
struct _E00WriteInfo {
   FILE *fp ;
   int nComprLevel ;
   int nSrcLineNo ;
   int iOutBufPtr ;
   char szOutBuf[256] ;
   void *pRefData ;
   int (*pfnWriteNextLine)(void * , char const   * ) ;
};
#line 153 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00compr.h"
typedef struct _E00WriteInfo *E00WritePtr;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 89 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsi.h"
typedef struct stat VSIStatBuf;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsi.h"
FILE *VSIFOpen(char const   *pszFilename , char const   *pszAccess ) ;
#line 69
int VSIFClose(FILE *fp ) ;
#line 72
void VSIRewind(FILE *fp ) ;
#line 76
char *VSIFGets(char *pszBuffer , int nBufferSize , FILE *fp ) ;
#line 112
void VSIFree(void *pData ) ;
#line 72 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.h"
void CPLError(CPLErr eErrClass , int err_no , char const   *fmt  , ...) ;
#line 73
void CPLErrorReset(void) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.h"
void *CPLCalloc(size_t nCount , size_t nSize ) ;
#line 160 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00compr.h"
E00ReadPtr E00ReadOpen(char const   *pszFname ) ;
#line 161
E00ReadPtr E00ReadCallbackOpen(void *pRefData , char const   *(*pfnReadNextLine)(void * ) ,
                               void (*pfnReadRewind)(void * ) ) ;
#line 164
void E00ReadClose(E00ReadPtr psInfo ) ;
#line 166
char const   *E00ReadNextLine(E00ReadPtr psInfo ) ;
#line 167
void E00ReadRewind(E00ReadPtr psInfo ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _ReadNextSourceLine(E00ReadPtr psInfo ) ;
#line 70
static char const   *_UncompressNextLine(E00ReadPtr psInfo ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static E00ReadPtr _E00ReadTestOpen(E00ReadPtr psInfo ) 
{ 
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 87
  _ReadNextSourceLine(psInfo);
  }
#line 88
  if (! psInfo->bEOF) {
    {
#line 88
    tmp___3 = strncmp((char const   *)(psInfo->szInBuf), "EXP ", (size_t )4);
    }
#line 88
    if (tmp___3 == 0) {
      {
#line 101
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 103
        _ReadNextSourceLine(psInfo);
        }
#line 101
        if (! psInfo->bEOF) {
#line 101
          if (! ((int )psInfo->szInBuf[0] == 0)) {
            {
#line 101
            tmp = __ctype_b_loc();
            }
#line 101
            if (! ((int const   )*(*tmp + (int )psInfo->szInBuf[0]) & 8192)) {
#line 101
              goto while_break;
            }
          }
        } else {
#line 101
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 107
      if (! psInfo->bEOF) {
        {
#line 107
        tmp___0 = strlen((char const   *)(psInfo->szInBuf));
        }
#line 107
        if (tmp___0 == 79UL) {
#line 107
          goto _L;
        } else {
          {
#line 107
          tmp___1 = strlen((char const   *)(psInfo->szInBuf));
          }
#line 107
          if (tmp___1 == 80UL) {
            _L: /* CIL Label */ 
            {
#line 107
            tmp___2 = strchr((char const   *)(psInfo->szInBuf), '~');
            }
#line 107
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 110
              psInfo->bIsCompressed = 1;
            }
          }
        }
      }
      {
#line 114
      E00ReadRewind(psInfo);
      }
    } else {
      {
#line 118
      VSIFree((void *)psInfo);
#line 119
      psInfo = (E00ReadPtr )((void *)0);
      }
    }
  } else {
    {
#line 118
    VSIFree((void *)psInfo);
#line 119
    psInfo = (E00ReadPtr )((void *)0);
    }
  }
#line 122
  return (psInfo);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
E00ReadPtr E00ReadOpen(char const   *pszFname ) 
{ 
  E00ReadPtr psInfo ;
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 135
  psInfo = (E00ReadPtr )((void *)0);
#line 138
  CPLErrorReset();
#line 142
  fp = VSIFOpen(pszFname, "rt");
  }
#line 143
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 145
    tmp = __errno_location();
#line 145
    tmp___0 = strerror(*tmp);
#line 145
    CPLError((CPLErr )3, 4, "Failed to open %s: %s", pszFname, tmp___0);
    }
#line 147
    return ((E00ReadPtr )((void *)0));
  }
  {
#line 153
  tmp___1 = CPLCalloc((size_t )1, sizeof(struct _E00ReadInfo ));
#line 153
  psInfo = (E00ReadPtr )tmp___1;
#line 155
  psInfo->fp = fp;
#line 157
  psInfo = _E00ReadTestOpen(psInfo);
  }
#line 159
  if ((unsigned long )psInfo == (unsigned long )((void *)0)) {
    {
#line 161
    CPLError((CPLErr )3, 4, "%s is not a valid E00 file.", pszFname);
    }
  }
#line 165
  return (psInfo);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
E00ReadPtr E00ReadCallbackOpen(void *pRefData , char const   *(*pfnReadNextLine)(void * ) ,
                               void (*pfnReadRewind)(void * ) ) 
{ 
  E00ReadPtr psInfo ;
  void *tmp ;

  {
  {
#line 193
  psInfo = (E00ReadPtr )((void *)0);
#line 195
  CPLErrorReset();
  }
#line 199
  if ((unsigned long )pfnReadNextLine == (unsigned long )((void *)0)) {
    {
#line 201
    CPLError((CPLErr )3, 5, "Invalid function pointers!");
    }
#line 203
    return ((E00ReadPtr )((void *)0));
  } else
#line 199
  if ((unsigned long )pfnReadRewind == (unsigned long )((void *)0)) {
    {
#line 201
    CPLError((CPLErr )3, 5, "Invalid function pointers!");
    }
#line 203
    return ((E00ReadPtr )((void *)0));
  }
  {
#line 209
  tmp = CPLCalloc((size_t )1, sizeof(struct _E00ReadInfo ));
#line 209
  psInfo = (E00ReadPtr )tmp;
#line 211
  psInfo->pRefData = pRefData;
#line 212
  psInfo->pfnReadNextLine = pfnReadNextLine;
#line 213
  psInfo->pfnReadRewind = pfnReadRewind;
#line 215
  psInfo = _E00ReadTestOpen(psInfo);
  }
#line 217
  if ((unsigned long )psInfo == (unsigned long )((void *)0)) {
    {
#line 219
    CPLError((CPLErr )3, 4, "This is not a valid E00 file.");
    }
  }
#line 223
  return (psInfo);
}
}
#line 231 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
void E00ReadClose(E00ReadPtr psInfo ) 
{ 


  {
  {
#line 233
  CPLErrorReset();
  }
#line 235
  if (psInfo) {
#line 237
    if (psInfo->fp) {
      {
#line 238
      VSIFClose(psInfo->fp);
      }
    }
    {
#line 239
    VSIFree((void *)psInfo);
    }
  }
#line 241
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
void E00ReadRewind(E00ReadPtr psInfo ) 
{ 
  char tmp ;

  {
  {
#line 251
  CPLErrorReset();
#line 253
  tmp = (char )'\000';
#line 253
  psInfo->szOutBuf[0] = tmp;
#line 253
  psInfo->szInBuf[0] = tmp;
#line 254
  psInfo->iInBufPtr = 0;
#line 256
  psInfo->nInputLineNo = 0;
  }
#line 258
  if ((unsigned long )psInfo->pfnReadRewind == (unsigned long )((void *)0)) {
    {
#line 259
    VSIRewind(psInfo->fp);
    }
  } else {
    {
#line 261
    (*(psInfo->pfnReadRewind))(psInfo->pRefData);
    }
  }
#line 263
  psInfo->bEOF = 0;
#line 264
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
char const   *E00ReadNextLine(E00ReadPtr psInfo ) 
{ 
  char const   *pszLine ;
  char *pszPtr ;
  size_t tmp ;

  {
  {
#line 276
  pszLine = (char const   *)((void *)0);
#line 279
  CPLErrorReset();
  }
#line 281
  if (psInfo) {
#line 281
    if (! psInfo->bEOF) {
#line 283
      if (! psInfo->bIsCompressed) {
        {
#line 287
        _ReadNextSourceLine(psInfo);
#line 288
        pszLine = (char const   *)(psInfo->szInBuf);
        }
      } else
#line 290
      if (psInfo->bIsCompressed) {
#line 290
        if (psInfo->nInputLineNo == 0) {
          {
#line 296
          _ReadNextSourceLine(psInfo);
#line 297
          pszPtr = strstr((char const   *)(psInfo->szInBuf), " 1");
          }
#line 297
          if ((unsigned long )pszPtr != (unsigned long )((void *)0)) {
#line 298
            *(pszPtr + 1) = (char )'0';
          }
#line 299
          pszLine = (char const   *)(psInfo->szInBuf);
        } else {
#line 290
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 303
        if (psInfo->nInputLineNo == 1) {
          {
#line 307
          _ReadNextSourceLine(psInfo);
          }
        }
        {
#line 312
        pszLine = _UncompressNextLine(psInfo);
        }
      }
#line 318
      if (psInfo->bEOF) {
        {
#line 318
        tmp = strlen(pszLine);
        }
#line 318
        if (tmp == 0UL) {
#line 319
          pszLine = (char const   *)((void *)0);
        }
      }
    }
  }
#line 322
  return (pszLine);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _ReadNextSourceLine(E00ReadPtr psInfo ) 
{ 
  char *tmp ;
  char const   *pszLine ;
  int nLen ;
  size_t tmp___0 ;

  {
#line 334
  if (! psInfo->bEOF) {
#line 336
    psInfo->iInBufPtr = 0;
#line 337
    psInfo->szInBuf[0] = (char )'\000';
#line 342
    if ((unsigned long )psInfo->pfnReadNextLine == (unsigned long )((void *)0)) {
      {
#line 344
      tmp = VSIFGets(psInfo->szInBuf, 256, psInfo->fp);
      }
#line 344
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 348
        psInfo->bEOF = 1;
      }
    } else {
      {
#line 354
      pszLine = (*(psInfo->pfnReadNextLine))(psInfo->pRefData);
      }
#line 355
      if (pszLine) {
        {
#line 357
        strncpy((char */* __restrict  */)(psInfo->szInBuf), (char const   */* __restrict  */)pszLine,
                (size_t )256);
        }
      } else {
#line 363
        psInfo->bEOF = 1;
      }
    }
#line 367
    if (! psInfo->bEOF) {
      {
#line 373
      tmp___0 = strlen((char const   *)(psInfo->szInBuf));
#line 373
      nLen = (int )tmp___0;
      }
      {
#line 374
      while (1) {
        while_continue: /* CIL Label */ ;
#line 374
        if (nLen > 0) {
#line 374
          if (! ((int )psInfo->szInBuf[nLen - 1] == 10)) {
#line 374
            if (! ((int )psInfo->szInBuf[nLen - 1] == 13)) {
#line 374
              goto while_break;
            }
          }
        } else {
#line 374
          goto while_break;
        }
#line 377
        nLen --;
#line 378
        psInfo->szInBuf[nLen] = (char )'\000';
      }
      while_break: /* CIL Label */ ;
      }
#line 381
      (psInfo->nInputLineNo) ++;
    }
  }
#line 384
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static char _GetNextSourceChar(E00ReadPtr psInfo ) 
{ 
  char c ;
  int tmp ;

  {
#line 399
  c = (char )'\000';
#line 401
  if (! psInfo->bEOF) {
#line 403
    if ((int )psInfo->szInBuf[psInfo->iInBufPtr] == 0) {
      {
#line 405
      _ReadNextSourceLine(psInfo);
#line 406
      c = _GetNextSourceChar(psInfo);
      }
    } else {
#line 410
      tmp = psInfo->iInBufPtr;
#line 410
      (psInfo->iInBufPtr) ++;
#line 410
      c = psInfo->szInBuf[tmp];
    }
  }
#line 414
  return (c);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _UngetSourceChar(E00ReadPtr psInfo ) 
{ 


  {
#line 429
  if (psInfo->iInBufPtr > 0) {
#line 430
    (psInfo->iInBufPtr) --;
  } else {
    {
#line 436
    CPLError((CPLErr )3, 7, "UNEXPECTED INTERNAL ERROR: _UngetSourceChar() failed while reading line %d.",
             psInfo->nInputLineNo);
    }
  }
#line 440
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static char const   *_UncompressNextLine(E00ReadPtr psInfo ) 
{ 
  char c ;
  int bEOL ;
  int iOutBufPtr ;
  int i ;
  int n ;
  int iDecimalPoint ;
  int bOddNumDigits ;
  int iCurDigit ;
  char *pszExp ;
  int bPreviousCodeWasNumeric ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 451
  bEOL = 0;
#line 452
  iOutBufPtr = 0;
#line 455
  bPreviousCodeWasNumeric = 0;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! bEOL) {
      {
#line 457
      c = _GetNextSourceChar(psInfo);
      }
#line 457
      if (! ((int )c != 0)) {
#line 457
        goto while_break;
      }
    } else {
#line 457
      goto while_break;
    }
#line 459
    if ((int )c != 126) {
#line 463
      tmp = iOutBufPtr;
#line 463
      iOutBufPtr ++;
#line 463
      psInfo->szOutBuf[tmp] = c;
#line 464
      bPreviousCodeWasNumeric = 0;
    } else {
      {
#line 471
      c = _GetNextSourceChar(psInfo);
      }
#line 476
      if ((int )c == 32) {
        {
#line 480
        c = _GetNextSourceChar(psInfo);
#line 481
        n = (int )c - 32;
#line 482
        i = 0;
        }
        {
#line 482
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 482
          if (! (i < n)) {
#line 482
            goto while_break___0;
          }
#line 483
          tmp___0 = iOutBufPtr;
#line 483
          iOutBufPtr ++;
#line 483
          psInfo->szOutBuf[tmp___0] = (char )' ';
#line 482
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 484
        bPreviousCodeWasNumeric = 0;
      } else
#line 486
      if ((int )c == 125) {
#line 490
        bEOL = 1;
#line 491
        bPreviousCodeWasNumeric = 0;
      } else
#line 493
      if (bPreviousCodeWasNumeric) {
#line 504
        tmp___1 = iOutBufPtr;
#line 504
        iOutBufPtr ++;
#line 504
        psInfo->szOutBuf[tmp___1] = c;
#line 505
        bPreviousCodeWasNumeric = 0;
      } else
#line 507
      if ((int )c == 126) {
#line 511
        tmp___2 = iOutBufPtr;
#line 511
        iOutBufPtr ++;
#line 511
        psInfo->szOutBuf[tmp___2] = c;
      } else
#line 507
      if ((int )c == 45) {
#line 511
        tmp___2 = iOutBufPtr;
#line 511
        iOutBufPtr ++;
#line 511
        psInfo->szOutBuf[tmp___2] = c;
      } else
#line 533
      if ((int )c >= 33) {
#line 533
        if ((int )c <= 122) {
#line 540
          n = (int )c - 33;
#line 541
          iDecimalPoint = n % 15;
#line 542
          bOddNumDigits = n / 45;
#line 543
          n /= 15;
#line 544
          if (n % 3 == 1) {
#line 545
            pszExp = (char *)"E+";
          } else
#line 546
          if (n % 3 == 2) {
#line 547
            pszExp = (char *)"E-";
          } else {
#line 549
            pszExp = (char *)((void *)0);
          }
#line 554
          iCurDigit = 0;
          {
#line 555
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 555
            c = _GetNextSourceChar(psInfo);
            }
#line 555
            if ((int )c != 0) {
#line 555
              if ((int )c != 32) {
#line 555
                if (! ((int )c != 126)) {
#line 555
                  goto while_break___1;
                }
              } else {
#line 555
                goto while_break___1;
              }
            } else {
#line 555
              goto while_break___1;
            }
#line 558
            n = (int )c - 33;
#line 559
            if (n == 92) {
              {
#line 559
              c = _GetNextSourceChar(psInfo);
              }
#line 559
              if ((int )c != 0) {
#line 560
                n += (int )c - 33;
              }
            }
#line 562
            tmp___3 = iOutBufPtr;
#line 562
            iOutBufPtr ++;
#line 562
            psInfo->szOutBuf[tmp___3] = (char )(48 + n / 10);
#line 564
            iCurDigit ++;
#line 564
            if (iCurDigit == iDecimalPoint) {
#line 565
              tmp___4 = iOutBufPtr;
#line 565
              iOutBufPtr ++;
#line 565
              psInfo->szOutBuf[tmp___4] = (char )'.';
            }
#line 567
            tmp___5 = iOutBufPtr;
#line 567
            iOutBufPtr ++;
#line 567
            psInfo->szOutBuf[tmp___5] = (char )(48 + n % 10);
#line 569
            iCurDigit ++;
#line 569
            if (iCurDigit == iDecimalPoint) {
#line 570
              tmp___6 = iOutBufPtr;
#line 570
              iOutBufPtr ++;
#line 570
              psInfo->szOutBuf[tmp___6] = (char )'.';
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 573
          if ((int )c == 126) {
            {
#line 575
            bPreviousCodeWasNumeric = 1;
#line 576
            _UngetSourceChar(psInfo);
            }
          } else
#line 573
          if ((int )c == 32) {
            {
#line 575
            bPreviousCodeWasNumeric = 1;
#line 576
            _UngetSourceChar(psInfo);
            }
          }
#line 581
          if (bOddNumDigits) {
#line 582
            iOutBufPtr --;
          }
#line 587
          if (pszExp) {
#line 589
            i = 0;
            {
#line 589
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 589
              if (! (i < 2)) {
#line 589
                goto while_break___2;
              }
#line 591
              psInfo->szOutBuf[iOutBufPtr] = psInfo->szOutBuf[iOutBufPtr - 2];
#line 593
              psInfo->szOutBuf[iOutBufPtr - 2] = *(pszExp + i);
#line 594
              iOutBufPtr ++;
#line 589
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 612
          CPLError((CPLErr )3, 6, "Unexpected code \"~%c\" encountered in line %d.",
                   (int )c, psInfo->nInputLineNo);
#line 618
          psInfo->bEOF = 1;
#line 619
          bEOL = 1;
          }
        }
      } else {
        {
#line 612
        CPLError((CPLErr )3, 6, "Unexpected code \"~%c\" encountered in line %d.",
                 (int )c, psInfo->nInputLineNo);
#line 618
        psInfo->bEOF = 1;
#line 619
        bEOL = 1;
        }
      }
    }
#line 627
    if (iOutBufPtr > 80) {
      {
#line 629
      CPLError((CPLErr )3, 3, "Uncompressed line longer than 80 chars. Input file possibly corrupt around line %d.",
               psInfo->nInputLineNo);
#line 635
      psInfo->bEOF = 1;
#line 636
      bEOL = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  tmp___7 = iOutBufPtr;
#line 641
  iOutBufPtr ++;
#line 641
  psInfo->szOutBuf[tmp___7] = (char )'\000';
#line 643
  return ((char const   *)(psInfo->szOutBuf));
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 379
extern  __attribute__((__nothrow__)) int vsprintf(char * __restrict  __s , char const   * __restrict  __format ,
                                                  __gnuc_va_list __arg ) ;
#line 78 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsi.h"
int VSIFPrintf(FILE *fp , char const   *pszFormat  , ...) ;
#line 169 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00compr.h"
E00WritePtr E00WriteOpen(char const   *pszFname , int nComprLevel ) ;
#line 170
E00WritePtr E00WriteCallbackOpen(void *pRefData , int (*pfnWriteNextLine)(void * ,
                                                                          char const   * ) ,
                                 int nComprLevel ) ;
#line 173
void E00WriteClose(E00WritePtr psInfo ) ;
#line 174
int E00WriteNextLine(E00WritePtr psInfo , char const   *pszLine ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _CompressLine(E00WritePtr psInfo , char const   *pszLine ) ;
#line 69
static int _WriteNextCompressedLine(E00WritePtr psInfo , int bFlushWholeBuffer ) ;
#line 70
static int _PrintfNextLine(E00WritePtr psInfo , char const   *pszFmt  , ...) ;
#line 85 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
E00WritePtr E00WriteOpen(char const   *pszFname , int nComprLevel ) 
{ 
  E00WritePtr psInfo ;
  FILE *fp ;
  int *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 87
  psInfo = (E00WritePtr )((void *)0);
#line 90
  CPLErrorReset();
#line 94
  fp = VSIFOpen(pszFname, "wt");
  }
#line 95
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
#line 97
    tmp = __errno_location();
#line 97
    tmp___0 = strerror(*tmp);
#line 97
    CPLError((CPLErr )3, 4, "Failed to open %s: %s", pszFname, tmp___0);
    }
#line 99
    return ((E00WritePtr )((void *)0));
  }
  {
#line 104
  tmp___1 = CPLCalloc((size_t )1, sizeof(struct _E00WriteInfo ));
#line 104
  psInfo = (E00WritePtr )tmp___1;
#line 106
  psInfo->fp = fp;
#line 107
  psInfo->nComprLevel = nComprLevel;
  }
#line 109
  return (psInfo);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
E00WritePtr E00WriteCallbackOpen(void *pRefData , int (*pfnWriteNextLine)(void * ,
                                                                          char const   * ) ,
                                 int nComprLevel ) 
{ 
  E00WritePtr psInfo ;
  void *tmp ;

  {
  {
#line 145
  psInfo = (E00WritePtr )((void *)0);
#line 147
  CPLErrorReset();
  }
#line 151
  if ((unsigned long )pfnWriteNextLine == (unsigned long )((void *)0)) {
    {
#line 153
    CPLError((CPLErr )3, 5, "Invalid function pointer!");
    }
#line 155
    return ((E00WritePtr )((void *)0));
  }
  {
#line 160
  tmp = CPLCalloc((size_t )1, sizeof(struct _E00WriteInfo ));
#line 160
  psInfo = (E00WritePtr )tmp;
#line 162
  psInfo->pRefData = pRefData;
#line 163
  psInfo->pfnWriteNextLine = pfnWriteNextLine;
#line 164
  psInfo->nComprLevel = nComprLevel;
  }
#line 166
  return (psInfo);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
void E00WriteClose(E00WritePtr psInfo ) 
{ 


  {
  {
#line 177
  CPLErrorReset();
  }
#line 179
  if (psInfo) {
#line 183
    if (psInfo->iOutBufPtr > 0) {
      {
#line 184
      _WriteNextCompressedLine(psInfo, 1);
      }
    }
#line 186
    if (psInfo->fp) {
      {
#line 187
      fclose(psInfo->fp);
      }
    }
    {
#line 189
    VSIFree((void *)psInfo);
    }
  }
#line 191
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
int E00WriteNextLine(E00WritePtr psInfo , char const   *pszLine ) 
{ 
  char *pszPtr ;
  int nStatus ;

  {
  {
#line 207
  nStatus = 0;
#line 209
  CPLErrorReset();
  }
#line 211
  if (psInfo) {
#line 211
    if (psInfo->fp) {
#line 211
      goto _L;
    } else
#line 211
    if (psInfo->pfnWriteNextLine) {
      _L: /* CIL Label */ 
#line 213
      (psInfo->nSrcLineNo) ++;
#line 215
      if (psInfo->nComprLevel == 0) {
        {
#line 219
        nStatus = _PrintfNextLine(psInfo, "%s", pszLine);
        }
      } else
#line 221
      if (psInfo->nSrcLineNo == 1) {
        {
#line 226
        pszPtr = strstr(pszLine, " 0");
        }
#line 226
        if ((unsigned long )pszPtr != (unsigned long )((void *)0)) {
          {
#line 228
          nStatus = _PrintfNextLine(psInfo, "EXP  1%s", pszPtr + 2);
          }
        } else {
          {
#line 235
          nStatus = _PrintfNextLine(psInfo, "%s", pszLine);
          }
        }
      } else {
        {
#line 243
        nStatus = _CompressLine(psInfo, pszLine);
        }
        {
#line 245
        while (1) {
          while_continue: /* CIL Label */ ;
#line 245
          if (nStatus == 0) {
#line 245
            if (! (psInfo->iOutBufPtr >= 80)) {
#line 245
              goto while_break;
            }
          } else {
#line 245
            goto while_break;
          }
          {
#line 249
          nStatus = _WriteNextCompressedLine(psInfo, 0);
          }
        }
        while_break: /* CIL Label */ ;
        }
      }
    } else {
      {
#line 260
      CPLError((CPLErr )3, 5, "Invalid E00WritePtr handle!");
#line 262
      nStatus = 203;
      }
    }
  } else {
    {
#line 260
    CPLError((CPLErr )3, 5, "Invalid E00WritePtr handle!");
#line 262
    nStatus = 203;
    }
  }
#line 265
  return (nStatus);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _CompressLine(E00WritePtr psInfo , char const   *pszLine ) 
{ 
  int nStatus ;
  int nDigits ;
  int nExpSign ;
  int nDotPosition ;
  int iCurPos ;
  int numTotalDigits ;
  int numExpDigits ;
  char n ;
  char *pszCodePos ;
  int nStartOutBufPtr ;
  char const   *pszStartSrcPtr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;

  {
#line 280
  nStatus = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if ((int const   )*pszLine != 0) {
#line 288
      if ((int const   )*pszLine != 10) {
#line 288
        if (! ((int const   )*pszLine != 13)) {
#line 288
          goto while_break;
        }
      } else {
#line 288
        goto while_break;
      }
    } else {
#line 288
      goto while_break;
    }
#line 294
    if ((int const   )*pszLine == 126) {
      {
#line 298
      strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~~");
#line 299
      psInfo->iOutBufPtr += 2;
      }
    } else {
      {
#line 301
      tmp___15 = strncmp(pszLine, "   ", (size_t )3);
      }
#line 301
      if (tmp___15 == 0) {
#line 306
        n = (char)1;
        {
#line 307
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 307
          if (! ((int const   )*(pszLine + 1) == 32)) {
#line 307
            goto while_break___0;
          }
#line 309
          n = (char )((int )n + 1);
#line 310
          pszLine ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 312
        strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~ ");
#line 313
        psInfo->iOutBufPtr += 2;
#line 314
        tmp = psInfo->iOutBufPtr;
#line 314
        (psInfo->iOutBufPtr) ++;
#line 314
        psInfo->szOutBuf[tmp] = (char )(32 + (int )n);
        }
      } else
#line 320
      if (psInfo->nComprLevel == 2) {
        {
#line 320
        tmp___14 = __ctype_b_loc();
        }
#line 320
        if ((int const   )*(*tmp___14 + (int )*pszLine) & 2048) {
#line 327
          nStartOutBufPtr = psInfo->iOutBufPtr;
#line 328
          pszStartSrcPtr = pszLine;
#line 332
          nDigits = 0;
#line 333
          nDotPosition = 0;
#line 334
          nExpSign = 0;
#line 335
          numExpDigits = 0;
#line 336
          numTotalDigits = 0;
#line 337
          n = (char)0;
#line 343
          tmp___0 = psInfo->iOutBufPtr;
#line 343
          (psInfo->iOutBufPtr) ++;
#line 343
          psInfo->szOutBuf[tmp___0] = (char )'~';
#line 344
          tmp___1 = psInfo->iOutBufPtr;
#line 344
          (psInfo->iOutBufPtr) ++;
#line 344
          pszCodePos = psInfo->szOutBuf + tmp___1;
#line 349
          iCurPos = 0;
          {
#line 349
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 349
            if ((int const   )*pszLine != 0) {
#line 349
              if (! (numExpDigits < 2)) {
#line 349
                goto while_break___1;
              }
            } else {
#line 349
              goto while_break___1;
            }
            {
#line 353
            tmp___7 = __ctype_b_loc();
            }
#line 353
            if ((int const   )*(*tmp___7 + (int )*pszLine) & 2048) {
#line 357
              numTotalDigits ++;
#line 358
              if (numTotalDigits % 2 == 1) {
#line 360
                n = (char )(((int const   )*pszLine - 48) * 10);
              } else {
#line 364
                n = (char )((int )n + (int )((int const   )*pszLine - 48));
#line 365
                if ((int )n >= 92) {
#line 369
                  tmp___2 = psInfo->iOutBufPtr;
#line 369
                  (psInfo->iOutBufPtr) ++;
#line 369
                  psInfo->szOutBuf[tmp___2] = (char)125;
#line 370
                  n = (char )((int )n - 92);
                }
#line 372
                tmp___3 = psInfo->iOutBufPtr;
#line 372
                (psInfo->iOutBufPtr) ++;
#line 372
                psInfo->szOutBuf[tmp___3] = (char )((int )n + 33);
              }
#line 378
              if (nExpSign != 0) {
#line 379
                numExpDigits ++;
              }
            } else
#line 381
            if ((int const   )*pszLine == 46) {
#line 381
              if (nDotPosition == 0) {
#line 381
                if (iCurPos < 15) {
#line 388
                  nDotPosition = iCurPos;
                } else {
#line 381
                  goto _L___1;
                }
              } else {
#line 381
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 390
            if ((int const   )*pszLine == 69) {
#line 390
              if ((int const   )*(pszLine + 1) == 45) {
#line 390
                goto _L;
              } else
#line 390
              if ((int const   )*(pszLine + 1) == 43) {
                _L: /* CIL Label */ 
                {
#line 390
                tmp___4 = __ctype_b_loc();
                }
#line 390
                if ((int const   )*(*tmp___4 + (int )*(pszLine + 2)) & 2048) {
                  {
#line 390
                  tmp___5 = __ctype_b_loc();
                  }
#line 390
                  if ((int const   )*(*tmp___5 + (int )*(pszLine + 3)) & 2048) {
                    {
#line 390
                    tmp___6 = __ctype_b_loc();
                    }
#line 390
                    if ((int const   )*(*tmp___6 + (int )*(pszLine + 4)) & 2048) {
#line 407
                      goto while_break___1;
                    } else {
#line 400
                      pszLine ++;
#line 401
                      if ((int const   )*pszLine == 45) {
#line 401
                        nExpSign = -1;
                      } else {
#line 401
                        nExpSign = 1;
                      }
                    }
                  } else {
#line 407
                    goto while_break___1;
                  }
                } else {
#line 407
                  goto while_break___1;
                }
              } else {
#line 407
                goto while_break___1;
              }
            } else {
#line 407
              goto while_break___1;
            }
#line 349
            pszLine ++;
#line 349
            iCurPos ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 414
          if (numTotalDigits % 2 == 1) {
#line 416
            tmp___8 = psInfo->iOutBufPtr;
#line 416
            (psInfo->iOutBufPtr) ++;
#line 416
            psInfo->szOutBuf[tmp___8] = (char )((int )n + 33);
          }
#line 424
          if ((int const   )*pszLine != 126) {
#line 424
            if ((int const   )*pszLine != 32) {
#line 424
              if ((int const   )*pszLine != 0) {
#line 427
                tmp___9 = psInfo->iOutBufPtr;
#line 427
                (psInfo->iOutBufPtr) ++;
#line 427
                psInfo->szOutBuf[tmp___9] = (char )'~';
              }
            }
          }
#line 434
          pszLine --;
#line 450
          if (iCurPos < psInfo->iOutBufPtr - nStartOutBufPtr) {
            {
#line 452
            strncpy((char */* __restrict  */)(psInfo->szOutBuf + nStartOutBufPtr),
                    (char const   */* __restrict  */)pszStartSrcPtr, (size_t )iCurPos);
#line 455
            psInfo->iOutBufPtr = nStartOutBufPtr + iCurPos;
            }
          } else {
#line 462
            if (numTotalDigits % 2 == 1) {
#line 462
              tmp___10 = 45;
            } else {
#line 462
              tmp___10 = 0;
            }
#line 462
            if (nExpSign) {
#line 462
              if (nExpSign > 0) {
#line 462
                tmp___11 = 15;
              } else {
#line 462
                tmp___11 = 30;
              }
#line 462
              tmp___12 = tmp___11;
            } else {
#line 462
              tmp___12 = 0;
            }
#line 462
            *pszCodePos = (char )(((33 + tmp___10) + tmp___12) + nDotPosition);
          }
        } else {
#line 471
          tmp___13 = psInfo->iOutBufPtr;
#line 471
          (psInfo->iOutBufPtr) ++;
#line 471
          psInfo->szOutBuf[tmp___13] = (char )*pszLine;
        }
      } else {
#line 471
        tmp___13 = psInfo->iOutBufPtr;
#line 471
        (psInfo->iOutBufPtr) ++;
#line 471
        psInfo->szOutBuf[tmp___13] = (char )*pszLine;
      }
    }
#line 476
    if (psInfo->iOutBufPtr >= 256) {
      {
#line 483
      CPLError((CPLErr )3, 3, "Output buffer overflow!!!.");
#line 485
      nStatus = 205;
      }
#line 486
      goto while_break;
    }
#line 491
    pszLine ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 497
  strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~}");
#line 498
  psInfo->iOutBufPtr += 2;
  }
#line 500
  return (nStatus);
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _WriteNextCompressedLine(E00WritePtr psInfo , int bFlushWholeBuffer ) 
{ 
  int nStatus ;
  int nToWrite ;
  char *pszSrc ;
  char *pszDst ;

  {
#line 519
  nStatus = 0;
#line 522
  psInfo->szOutBuf[psInfo->iOutBufPtr] = (char )'\000';
#line 524
  if (! bFlushWholeBuffer) {
#line 524
    if (psInfo->iOutBufPtr > 80) {
#line 530
      nToWrite = 80;
      {
#line 531
      while (1) {
        while_continue: /* CIL Label */ ;
#line 531
        if (nToWrite > 1) {
#line 531
          if (! ((int )psInfo->szOutBuf[nToWrite - 1] == 32)) {
#line 531
            goto while_break;
          }
        } else {
#line 531
          goto while_break;
        }
#line 532
        nToWrite --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 534
      nStatus = _PrintfNextLine(psInfo, "%-.*s", nToWrite, psInfo->szOutBuf);
#line 538
      pszDst = psInfo->szOutBuf;
#line 539
      pszSrc = psInfo->szOutBuf + nToWrite;
      }
      {
#line 540
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 540
        if (! ((int )*pszSrc != 0)) {
#line 540
          goto while_break___0;
        }
#line 542
        *pszDst = *pszSrc;
#line 543
        pszDst ++;
#line 544
        pszSrc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 546
      psInfo->iOutBufPtr -= nToWrite;
    } else {
      {
#line 552
      nStatus = _PrintfNextLine(psInfo, "%s", psInfo->szOutBuf);
#line 554
      psInfo->iOutBufPtr = 0;
      }
    }
  } else {
    {
#line 552
    nStatus = _PrintfNextLine(psInfo, "%s", psInfo->szOutBuf);
#line 554
    psInfo->iOutBufPtr = 0;
    }
  }
#line 557
  return (nStatus);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static char szBuf[256]  ;
#line 573 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _PrintfNextLine(E00WritePtr psInfo , char const   *pszFmt  , ...) 
{ 
  va_list args ;
  int nStatus ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 577
  nStatus = 0;
#line 581
  __builtin_va_start(args, pszFmt);
#line 582
  vsprintf((char */* __restrict  */)(szBuf), (char const   */* __restrict  */)pszFmt,
           args);
#line 583
  __builtin_va_end(args);
  }
#line 587
  if ((unsigned long )psInfo->pfnWriteNextLine == (unsigned long )((void *)0)) {
    {
#line 591
    tmp___1 = VSIFPrintf(psInfo->fp, "%s\n", szBuf);
    }
#line 591
    if (tmp___1 < 0) {
      {
#line 593
      tmp = __errno_location();
#line 593
      tmp___0 = strerror(*tmp);
#line 593
      CPLError((CPLErr )3, 3, "Error writing to file: %s", tmp___0);
#line 596
      nStatus = 204;
      }
    }
  } else {
    {
#line 603
    tmp___2 = (*(psInfo->pfnWriteNextLine))(psInfo->pRefData, (char const   *)(szBuf));
    }
#line 603
    if (tmp___2 < 0) {
      {
#line 605
      CPLError((CPLErr )3, 3, "Error writing to file.");
#line 607
      nStatus = 204;
      }
    }
  }
#line 611
  return (nStatus);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _ReadNextSourceLine___0(E00ReadPtr psInfo ) ;
#line 70
static char const   *_UncompressNextLine___0(E00ReadPtr psInfo ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static E00ReadPtr _E00ReadTestOpen___0(E00ReadPtr psInfo ) 
{ 
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 87
  _ReadNextSourceLine___0(psInfo);
  }
#line 88
  if (! psInfo->bEOF) {
    {
#line 88
    tmp___3 = strncmp((char const   *)(psInfo->szInBuf), "EXP ", (size_t )4);
    }
#line 88
    if (tmp___3 == 0) {
      {
#line 101
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 103
        _ReadNextSourceLine___0(psInfo);
        }
#line 101
        if (! psInfo->bEOF) {
#line 101
          if (! ((int )psInfo->szInBuf[0] == 0)) {
            {
#line 101
            tmp = __ctype_b_loc();
            }
#line 101
            if (! ((int const   )*(*tmp + (int )psInfo->szInBuf[0]) & 8192)) {
#line 101
              goto while_break;
            }
          }
        } else {
#line 101
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 107
      if (! psInfo->bEOF) {
        {
#line 107
        tmp___0 = strlen((char const   *)(psInfo->szInBuf));
        }
#line 107
        if (tmp___0 == 79UL) {
#line 107
          goto _L;
        } else {
          {
#line 107
          tmp___1 = strlen((char const   *)(psInfo->szInBuf));
          }
#line 107
          if (tmp___1 == 80UL) {
            _L: /* CIL Label */ 
            {
#line 107
            tmp___2 = strchr((char const   *)(psInfo->szInBuf), '~');
            }
#line 107
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 110
              psInfo->bIsCompressed = 1;
            }
          }
        }
      }
      {
#line 114
      E00ReadRewind(psInfo);
      }
    } else {
      {
#line 118
      VSIFree((void *)psInfo);
#line 119
      psInfo = (E00ReadPtr )((void *)0);
      }
    }
  } else {
    {
#line 118
    VSIFree((void *)psInfo);
#line 119
    psInfo = (E00ReadPtr )((void *)0);
    }
  }
#line 122
  return (psInfo);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _ReadNextSourceLine___0(E00ReadPtr psInfo ) 
{ 
  char *tmp ;
  char const   *pszLine ;
  int nLen ;
  size_t tmp___0 ;

  {
#line 334
  if (! psInfo->bEOF) {
#line 336
    psInfo->iInBufPtr = 0;
#line 337
    psInfo->szInBuf[0] = (char )'\000';
#line 342
    if ((unsigned long )psInfo->pfnReadNextLine == (unsigned long )((void *)0)) {
      {
#line 344
      tmp = VSIFGets(psInfo->szInBuf, 256, psInfo->fp);
      }
#line 344
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 348
        psInfo->bEOF = 1;
      }
    } else {
      {
#line 354
      pszLine = (*(psInfo->pfnReadNextLine))(psInfo->pRefData);
      }
#line 355
      if (pszLine) {
        {
#line 357
        strncpy((char */* __restrict  */)(psInfo->szInBuf), (char const   */* __restrict  */)pszLine,
                (size_t )256);
        }
      } else {
#line 363
        psInfo->bEOF = 1;
      }
    }
#line 367
    if (! psInfo->bEOF) {
      {
#line 373
      tmp___0 = strlen((char const   *)(psInfo->szInBuf));
#line 373
      nLen = (int )tmp___0;
      }
      {
#line 374
      while (1) {
        while_continue: /* CIL Label */ ;
#line 374
        if (nLen > 0) {
#line 374
          if (! ((int )psInfo->szInBuf[nLen - 1] == 10)) {
#line 374
            if (! ((int )psInfo->szInBuf[nLen - 1] == 13)) {
#line 374
              goto while_break;
            }
          }
        } else {
#line 374
          goto while_break;
        }
#line 377
        nLen --;
#line 378
        psInfo->szInBuf[nLen] = (char )'\000';
      }
      while_break: /* CIL Label */ ;
      }
#line 381
      (psInfo->nInputLineNo) ++;
    }
  }
#line 384
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static char _GetNextSourceChar___0(E00ReadPtr psInfo ) 
{ 
  char c ;
  int tmp ;

  {
#line 399
  c = (char )'\000';
#line 401
  if (! psInfo->bEOF) {
#line 403
    if ((int )psInfo->szInBuf[psInfo->iInBufPtr] == 0) {
      {
#line 405
      _ReadNextSourceLine___0(psInfo);
#line 406
      c = _GetNextSourceChar___0(psInfo);
      }
    } else {
#line 410
      tmp = psInfo->iInBufPtr;
#line 410
      (psInfo->iInBufPtr) ++;
#line 410
      c = psInfo->szInBuf[tmp];
    }
  }
#line 414
  return (c);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _UngetSourceChar___0(E00ReadPtr psInfo ) 
{ 


  {
#line 429
  if (psInfo->iInBufPtr > 0) {
#line 430
    (psInfo->iInBufPtr) --;
  } else {
    {
#line 436
    CPLError((CPLErr )3, 7, "UNEXPECTED INTERNAL ERROR: _UngetSourceChar() failed while reading line %d.",
             psInfo->nInputLineNo);
    }
  }
#line 440
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static char const   *_UncompressNextLine___0(E00ReadPtr psInfo ) 
{ 
  char c ;
  int bEOL ;
  int iOutBufPtr ;
  int i ;
  int n ;
  int iDecimalPoint ;
  int bOddNumDigits ;
  int iCurDigit ;
  char *pszExp ;
  int bPreviousCodeWasNumeric ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 451
  bEOL = 0;
#line 452
  iOutBufPtr = 0;
#line 455
  bPreviousCodeWasNumeric = 0;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! bEOL) {
      {
#line 457
      c = _GetNextSourceChar___0(psInfo);
      }
#line 457
      if (! ((int )c != 0)) {
#line 457
        goto while_break;
      }
    } else {
#line 457
      goto while_break;
    }
#line 459
    if ((int )c != 126) {
#line 463
      tmp = iOutBufPtr;
#line 463
      iOutBufPtr ++;
#line 463
      psInfo->szOutBuf[tmp] = c;
#line 464
      bPreviousCodeWasNumeric = 0;
    } else {
      {
#line 471
      c = _GetNextSourceChar___0(psInfo);
      }
#line 476
      if ((int )c == 32) {
        {
#line 480
        c = _GetNextSourceChar___0(psInfo);
#line 481
        n = (int )c - 32;
#line 482
        i = 0;
        }
        {
#line 482
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 482
          if (! (i < n)) {
#line 482
            goto while_break___0;
          }
#line 483
          tmp___0 = iOutBufPtr;
#line 483
          iOutBufPtr ++;
#line 483
          psInfo->szOutBuf[tmp___0] = (char )' ';
#line 482
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 484
        bPreviousCodeWasNumeric = 0;
      } else
#line 486
      if ((int )c == 125) {
#line 490
        bEOL = 1;
#line 491
        bPreviousCodeWasNumeric = 0;
      } else
#line 493
      if (bPreviousCodeWasNumeric) {
#line 504
        tmp___1 = iOutBufPtr;
#line 504
        iOutBufPtr ++;
#line 504
        psInfo->szOutBuf[tmp___1] = c;
#line 505
        bPreviousCodeWasNumeric = 0;
      } else
#line 507
      if ((int )c == 126) {
#line 511
        tmp___2 = iOutBufPtr;
#line 511
        iOutBufPtr ++;
#line 511
        psInfo->szOutBuf[tmp___2] = c;
      } else
#line 507
      if ((int )c == 45) {
#line 511
        tmp___2 = iOutBufPtr;
#line 511
        iOutBufPtr ++;
#line 511
        psInfo->szOutBuf[tmp___2] = c;
      } else
#line 533
      if ((int )c >= 33) {
#line 533
        if ((int )c <= 122) {
#line 540
          n = (int )c - 33;
#line 541
          iDecimalPoint = n % 15;
#line 542
          bOddNumDigits = n / 45;
#line 543
          n /= 15;
#line 544
          if (n % 3 == 1) {
#line 545
            pszExp = (char *)"E+";
          } else
#line 546
          if (n % 3 == 2) {
#line 547
            pszExp = (char *)"E-";
          } else {
#line 549
            pszExp = (char *)((void *)0);
          }
#line 554
          iCurDigit = 0;
          {
#line 555
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 555
            c = _GetNextSourceChar___0(psInfo);
            }
#line 555
            if ((int )c != 0) {
#line 555
              if ((int )c != 32) {
#line 555
                if (! ((int )c != 126)) {
#line 555
                  goto while_break___1;
                }
              } else {
#line 555
                goto while_break___1;
              }
            } else {
#line 555
              goto while_break___1;
            }
#line 558
            n = (int )c - 33;
#line 559
            if (n == 92) {
              {
#line 559
              c = _GetNextSourceChar___0(psInfo);
              }
#line 559
              if ((int )c != 0) {
#line 560
                n += (int )c - 33;
              }
            }
#line 562
            tmp___3 = iOutBufPtr;
#line 562
            iOutBufPtr ++;
#line 562
            psInfo->szOutBuf[tmp___3] = (char )(48 + n / 10);
#line 564
            iCurDigit ++;
#line 564
            if (iCurDigit == iDecimalPoint) {
#line 565
              tmp___4 = iOutBufPtr;
#line 565
              iOutBufPtr ++;
#line 565
              psInfo->szOutBuf[tmp___4] = (char )'.';
            }
#line 567
            tmp___5 = iOutBufPtr;
#line 567
            iOutBufPtr ++;
#line 567
            psInfo->szOutBuf[tmp___5] = (char )(48 + n % 10);
#line 569
            iCurDigit ++;
#line 569
            if (iCurDigit == iDecimalPoint) {
#line 570
              tmp___6 = iOutBufPtr;
#line 570
              iOutBufPtr ++;
#line 570
              psInfo->szOutBuf[tmp___6] = (char )'.';
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 573
          if ((int )c == 126) {
            {
#line 575
            bPreviousCodeWasNumeric = 1;
#line 576
            _UngetSourceChar___0(psInfo);
            }
          } else
#line 573
          if ((int )c == 32) {
            {
#line 575
            bPreviousCodeWasNumeric = 1;
#line 576
            _UngetSourceChar___0(psInfo);
            }
          }
#line 581
          if (bOddNumDigits) {
#line 582
            iOutBufPtr --;
          }
#line 587
          if (pszExp) {
#line 589
            i = 0;
            {
#line 589
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 589
              if (! (i < 2)) {
#line 589
                goto while_break___2;
              }
#line 591
              psInfo->szOutBuf[iOutBufPtr] = psInfo->szOutBuf[iOutBufPtr - 2];
#line 593
              psInfo->szOutBuf[iOutBufPtr - 2] = *(pszExp + i);
#line 594
              iOutBufPtr ++;
#line 589
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 612
          CPLError((CPLErr )3, 6, "Unexpected code \"~%c\" encountered in line %d.",
                   (int )c, psInfo->nInputLineNo);
#line 618
          psInfo->bEOF = 1;
#line 619
          bEOL = 1;
          }
        }
      } else {
        {
#line 612
        CPLError((CPLErr )3, 6, "Unexpected code \"~%c\" encountered in line %d.",
                 (int )c, psInfo->nInputLineNo);
#line 618
        psInfo->bEOF = 1;
#line 619
        bEOL = 1;
        }
      }
    }
#line 627
    if (iOutBufPtr > 80) {
      {
#line 629
      CPLError((CPLErr )3, 3, "Uncompressed line longer than 80 chars. Input file possibly corrupt around line %d.",
               psInfo->nInputLineNo);
#line 635
      psInfo->bEOF = 1;
#line 636
      bEOL = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  tmp___7 = iOutBufPtr;
#line 641
  iOutBufPtr ++;
#line 641
  psInfo->szOutBuf[tmp___7] = (char )'\000';
#line 643
  return ((char const   *)(psInfo->szOutBuf));
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _CompressLine___0(E00WritePtr psInfo , char const   *pszLine ) ;
#line 69
static int _WriteNextCompressedLine___0(E00WritePtr psInfo , int bFlushWholeBuffer ) ;
#line 70
static int _PrintfNextLine___0(E00WritePtr psInfo , char const   *pszFmt  , ...) ;
#line 278 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _CompressLine___0(E00WritePtr psInfo , char const   *pszLine ) 
{ 
  int nStatus ;
  int nDigits ;
  int nExpSign ;
  int nDotPosition ;
  int iCurPos ;
  int numTotalDigits ;
  int numExpDigits ;
  char n ;
  char *pszCodePos ;
  int nStartOutBufPtr ;
  char const   *pszStartSrcPtr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;

  {
#line 280
  nStatus = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if ((int const   )*pszLine != 0) {
#line 288
      if ((int const   )*pszLine != 10) {
#line 288
        if (! ((int const   )*pszLine != 13)) {
#line 288
          goto while_break;
        }
      } else {
#line 288
        goto while_break;
      }
    } else {
#line 288
      goto while_break;
    }
#line 294
    if ((int const   )*pszLine == 126) {
      {
#line 298
      strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~~");
#line 299
      psInfo->iOutBufPtr += 2;
      }
    } else {
      {
#line 301
      tmp___15 = strncmp(pszLine, "   ", (size_t )3);
      }
#line 301
      if (tmp___15 == 0) {
#line 306
        n = (char)1;
        {
#line 307
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 307
          if (! ((int const   )*(pszLine + 1) == 32)) {
#line 307
            goto while_break___0;
          }
#line 309
          n = (char )((int )n + 1);
#line 310
          pszLine ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 312
        strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~ ");
#line 313
        psInfo->iOutBufPtr += 2;
#line 314
        tmp = psInfo->iOutBufPtr;
#line 314
        (psInfo->iOutBufPtr) ++;
#line 314
        psInfo->szOutBuf[tmp] = (char )(32 + (int )n);
        }
      } else
#line 320
      if (psInfo->nComprLevel == 2) {
        {
#line 320
        tmp___14 = __ctype_b_loc();
        }
#line 320
        if ((int const   )*(*tmp___14 + (int )*pszLine) & 2048) {
#line 327
          nStartOutBufPtr = psInfo->iOutBufPtr;
#line 328
          pszStartSrcPtr = pszLine;
#line 332
          nDigits = 0;
#line 333
          nDotPosition = 0;
#line 334
          nExpSign = 0;
#line 335
          numExpDigits = 0;
#line 336
          numTotalDigits = 0;
#line 337
          n = (char)0;
#line 343
          tmp___0 = psInfo->iOutBufPtr;
#line 343
          (psInfo->iOutBufPtr) ++;
#line 343
          psInfo->szOutBuf[tmp___0] = (char )'~';
#line 344
          tmp___1 = psInfo->iOutBufPtr;
#line 344
          (psInfo->iOutBufPtr) ++;
#line 344
          pszCodePos = psInfo->szOutBuf + tmp___1;
#line 349
          iCurPos = 0;
          {
#line 349
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 349
            if ((int const   )*pszLine != 0) {
#line 349
              if (! (numExpDigits < 2)) {
#line 349
                goto while_break___1;
              }
            } else {
#line 349
              goto while_break___1;
            }
            {
#line 353
            tmp___7 = __ctype_b_loc();
            }
#line 353
            if ((int const   )*(*tmp___7 + (int )*pszLine) & 2048) {
#line 357
              numTotalDigits ++;
#line 358
              if (numTotalDigits % 2 == 1) {
#line 360
                n = (char )(((int const   )*pszLine - 48) * 10);
              } else {
#line 364
                n = (char )((int )n + (int )((int const   )*pszLine - 48));
#line 365
                if ((int )n >= 92) {
#line 369
                  tmp___2 = psInfo->iOutBufPtr;
#line 369
                  (psInfo->iOutBufPtr) ++;
#line 369
                  psInfo->szOutBuf[tmp___2] = (char)125;
#line 370
                  n = (char )((int )n - 92);
                }
#line 372
                tmp___3 = psInfo->iOutBufPtr;
#line 372
                (psInfo->iOutBufPtr) ++;
#line 372
                psInfo->szOutBuf[tmp___3] = (char )((int )n + 33);
              }
#line 378
              if (nExpSign != 0) {
#line 379
                numExpDigits ++;
              }
            } else
#line 381
            if ((int const   )*pszLine == 46) {
#line 381
              if (nDotPosition == 0) {
#line 381
                if (iCurPos < 15) {
#line 388
                  nDotPosition = iCurPos;
                } else {
#line 381
                  goto _L___1;
                }
              } else {
#line 381
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 390
            if ((int const   )*pszLine == 69) {
#line 390
              if ((int const   )*(pszLine + 1) == 45) {
#line 390
                goto _L;
              } else
#line 390
              if ((int const   )*(pszLine + 1) == 43) {
                _L: /* CIL Label */ 
                {
#line 390
                tmp___4 = __ctype_b_loc();
                }
#line 390
                if ((int const   )*(*tmp___4 + (int )*(pszLine + 2)) & 2048) {
                  {
#line 390
                  tmp___5 = __ctype_b_loc();
                  }
#line 390
                  if ((int const   )*(*tmp___5 + (int )*(pszLine + 3)) & 2048) {
                    {
#line 390
                    tmp___6 = __ctype_b_loc();
                    }
#line 390
                    if ((int const   )*(*tmp___6 + (int )*(pszLine + 4)) & 2048) {
#line 407
                      goto while_break___1;
                    } else {
#line 400
                      pszLine ++;
#line 401
                      if ((int const   )*pszLine == 45) {
#line 401
                        nExpSign = -1;
                      } else {
#line 401
                        nExpSign = 1;
                      }
                    }
                  } else {
#line 407
                    goto while_break___1;
                  }
                } else {
#line 407
                  goto while_break___1;
                }
              } else {
#line 407
                goto while_break___1;
              }
            } else {
#line 407
              goto while_break___1;
            }
#line 349
            pszLine ++;
#line 349
            iCurPos ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 414
          if (numTotalDigits % 2 == 1) {
#line 416
            tmp___8 = psInfo->iOutBufPtr;
#line 416
            (psInfo->iOutBufPtr) ++;
#line 416
            psInfo->szOutBuf[tmp___8] = (char )((int )n + 33);
          }
#line 424
          if ((int const   )*pszLine != 126) {
#line 424
            if ((int const   )*pszLine != 32) {
#line 424
              if ((int const   )*pszLine != 0) {
#line 427
                tmp___9 = psInfo->iOutBufPtr;
#line 427
                (psInfo->iOutBufPtr) ++;
#line 427
                psInfo->szOutBuf[tmp___9] = (char )'~';
              }
            }
          }
#line 434
          pszLine --;
#line 450
          if (iCurPos < psInfo->iOutBufPtr - nStartOutBufPtr) {
            {
#line 452
            strncpy((char */* __restrict  */)(psInfo->szOutBuf + nStartOutBufPtr),
                    (char const   */* __restrict  */)pszStartSrcPtr, (size_t )iCurPos);
#line 455
            psInfo->iOutBufPtr = nStartOutBufPtr + iCurPos;
            }
          } else {
#line 462
            if (numTotalDigits % 2 == 1) {
#line 462
              tmp___10 = 45;
            } else {
#line 462
              tmp___10 = 0;
            }
#line 462
            if (nExpSign) {
#line 462
              if (nExpSign > 0) {
#line 462
                tmp___11 = 15;
              } else {
#line 462
                tmp___11 = 30;
              }
#line 462
              tmp___12 = tmp___11;
            } else {
#line 462
              tmp___12 = 0;
            }
#line 462
            *pszCodePos = (char )(((33 + tmp___10) + tmp___12) + nDotPosition);
          }
        } else {
#line 471
          tmp___13 = psInfo->iOutBufPtr;
#line 471
          (psInfo->iOutBufPtr) ++;
#line 471
          psInfo->szOutBuf[tmp___13] = (char )*pszLine;
        }
      } else {
#line 471
        tmp___13 = psInfo->iOutBufPtr;
#line 471
        (psInfo->iOutBufPtr) ++;
#line 471
        psInfo->szOutBuf[tmp___13] = (char )*pszLine;
      }
    }
#line 476
    if (psInfo->iOutBufPtr >= 256) {
      {
#line 483
      CPLError((CPLErr )3, 3, "Output buffer overflow!!!.");
#line 485
      nStatus = 205;
      }
#line 486
      goto while_break;
    }
#line 491
    pszLine ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 497
  strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~}");
#line 498
  psInfo->iOutBufPtr += 2;
  }
#line 500
  return (nStatus);
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _WriteNextCompressedLine___0(E00WritePtr psInfo , int bFlushWholeBuffer ) 
{ 
  int nStatus ;
  int nToWrite ;
  char *pszSrc ;
  char *pszDst ;

  {
#line 519
  nStatus = 0;
#line 522
  psInfo->szOutBuf[psInfo->iOutBufPtr] = (char )'\000';
#line 524
  if (! bFlushWholeBuffer) {
#line 524
    if (psInfo->iOutBufPtr > 80) {
#line 530
      nToWrite = 80;
      {
#line 531
      while (1) {
        while_continue: /* CIL Label */ ;
#line 531
        if (nToWrite > 1) {
#line 531
          if (! ((int )psInfo->szOutBuf[nToWrite - 1] == 32)) {
#line 531
            goto while_break;
          }
        } else {
#line 531
          goto while_break;
        }
#line 532
        nToWrite --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 534
      nStatus = _PrintfNextLine___0(psInfo, "%-.*s", nToWrite, psInfo->szOutBuf);
#line 538
      pszDst = psInfo->szOutBuf;
#line 539
      pszSrc = psInfo->szOutBuf + nToWrite;
      }
      {
#line 540
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 540
        if (! ((int )*pszSrc != 0)) {
#line 540
          goto while_break___0;
        }
#line 542
        *pszDst = *pszSrc;
#line 543
        pszDst ++;
#line 544
        pszSrc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 546
      psInfo->iOutBufPtr -= nToWrite;
    } else {
      {
#line 552
      nStatus = _PrintfNextLine___0(psInfo, "%s", psInfo->szOutBuf);
#line 554
      psInfo->iOutBufPtr = 0;
      }
    }
  } else {
    {
#line 552
    nStatus = _PrintfNextLine___0(psInfo, "%s", psInfo->szOutBuf);
#line 554
    psInfo->iOutBufPtr = 0;
    }
  }
#line 557
  return (nStatus);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static char szBuf___0[256]  ;
#line 573 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _PrintfNextLine___0(E00WritePtr psInfo , char const   *pszFmt  , ...) 
{ 
  va_list args ;
  int nStatus ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 577
  nStatus = 0;
#line 581
  __builtin_va_start(args, pszFmt);
#line 582
  vsprintf((char */* __restrict  */)(szBuf___0), (char const   */* __restrict  */)pszFmt,
           args);
#line 583
  __builtin_va_end(args);
  }
#line 587
  if ((unsigned long )psInfo->pfnWriteNextLine == (unsigned long )((void *)0)) {
    {
#line 591
    tmp___1 = VSIFPrintf(psInfo->fp, "%s\n", szBuf___0);
    }
#line 591
    if (tmp___1 < 0) {
      {
#line 593
      tmp = __errno_location();
#line 593
      tmp___0 = strerror(*tmp);
#line 593
      CPLError((CPLErr )3, 3, "Error writing to file: %s", tmp___0);
#line 596
      nStatus = 204;
      }
    }
  } else {
    {
#line 603
    tmp___2 = (*(psInfo->pfnWriteNextLine))(psInfo->pRefData, (char const   *)(szBuf___0));
    }
#line 603
    if (tmp___2 < 0) {
      {
#line 605
      CPLError((CPLErr )3, 3, "Error writing to file.");
#line 607
      nStatus = 204;
      }
    }
  }
#line 611
  return (nStatus);
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.h"
int CPLGetLastErrorNo(void) ;
#line 75
char const   *CPLGetLastErrorMsg(void) ;
#line 76
void CPLSetErrorHandler(void (*pfnErrorHandler)(CPLErr  , int  , char const   * ) ) ;
#line 78
void _CPLAssert(char const   *pszExpression , char const   *pszFile , int iLine ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
static char gszCPLLastErrMsg[2000]  = {      (char )'\000'};
#line 50 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
static int gnCPLLastErrNo  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
static void (*gpfnCPLErrorHandler)(CPLErr  , int  , char const   * )  =    (void (*)(CPLErr  , int  , char const   * ))((void *)0);
#line 62 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
void CPLError(CPLErr eErrClass , int err_no , char const   *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 68
  __builtin_va_start(args, fmt);
#line 69
  vsprintf((char */* __restrict  */)(gszCPLLastErrMsg), (char const   */* __restrict  */)fmt,
           args);
#line 70
  __builtin_va_end(args);
#line 75
  gnCPLLastErrNo = err_no;
  }
#line 77
  if ((unsigned long )gpfnCPLErrorHandler != (unsigned long )((void *)0)) {
    {
#line 79
    (*gpfnCPLErrorHandler)(eErrClass, err_no, (char const   *)(gszCPLLastErrMsg));
    }
  } else {
    {
#line 83
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"ERROR %d: %s\n",
            gnCPLLastErrNo, gszCPLLastErrMsg);
    }
  }
#line 86
  if ((unsigned int )eErrClass == 4U) {
    {
#line 87
    abort();
    }
  }
#line 88
  return;
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
void CPLErrorReset(void) 
{ 


  {
#line 97
  gnCPLLastErrNo = 0;
#line 98
  gszCPLLastErrMsg[0] = (char )'\000';
#line 99
  return;
}
}
#line 106 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
int CPLGetLastErrorNo(void) 
{ 


  {
#line 108
  return (gnCPLLastErrNo);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
char const   *CPLGetLastErrorMsg(void) 
{ 


  {
#line 117
  return ((char const   *)(gszCPLLastErrMsg));
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
void CPLSetErrorHandler(void (*pfnErrorHandler)(CPLErr  , int  , char const   * ) ) 
{ 


  {
#line 134
  gpfnCPLErrorHandler = pfnErrorHandler;
#line 135
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
void _CPLAssert(char const   *pszExpression , char const   *pszFile , int iLine ) 
{ 


  {
  {
#line 147
  CPLError((CPLErr )4, 7, "Assertion `%s\' failed\nin file `%s\', line %d\n", pszExpression,
           pszFile, iLine);
  }
#line 151
  return;
}
}
#line 272 "/usr/include/stdio.h"
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsi.h"
int VSIFSeek(FILE *fp , long nOffset , int nWhence ) ;
#line 71
long VSIFTell(FILE *fp ) ;
#line 74
size_t VSIFRead(void *pBuffer , size_t nSize , size_t nCount , FILE *fp ) ;
#line 75
size_t VSIFWrite(void *pBuffer , size_t nSize , size_t nCount , FILE *fp ) ;
#line 77
int VSIFPuts(char const   *pszString , FILE *fp ) ;
#line 80
int VSIFGetc(FILE *fp ) ;
#line 81
int VSIFPutc(int nChar , FILE *fp ) ;
#line 82
int VSIUngetc(int c , FILE *fp ) ;
#line 83
int VSIFEof(FILE *fp ) ;
#line 90
int VSIStat(char const   *pszFilename , VSIStatBuf *pStatBuf ) ;
#line 110
void *VSICalloc(size_t nCount , size_t nSize ) ;
#line 111
void *VSIMalloc(size_t nSize ) ;
#line 113
void *VSIRealloc(void *pData , size_t nNewSize ) ;
#line 114
char *VSIStrdup(char const   *pszString ) ;
#line 57 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
FILE *VSIFOpen(char const   *pszFilename , char const   *pszAccess ) 
{ 
  FILE *tmp ;

  {
  {
#line 60
  tmp = fopen((char const   */* __restrict  */)((char *)pszFilename), (char const   */* __restrict  */)((char *)pszAccess));
  }
#line 60
  return (tmp);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIFClose(FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 70
  tmp = fclose(fp);
  }
#line 70
  return (tmp);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIFSeek(FILE *fp , long nOffset , int nWhence ) 
{ 
  int tmp ;

  {
  {
#line 80
  tmp = fseek(fp, nOffset, nWhence);
  }
#line 80
  return (tmp);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
long VSIFTell(FILE *fp ) 
{ 
  long tmp ;

  {
  {
#line 90
  tmp = ftell(fp);
  }
#line 90
  return (tmp);
}
}
#line 97 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
void VSIRewind(FILE *fp ) 
{ 


  {
  {
#line 100
  rewind(fp);
  }
#line 101
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
size_t VSIFRead(void *pBuffer , size_t nSize , size_t nCount , FILE *fp ) 
{ 
  size_t tmp ;

  {
  {
#line 110
  tmp = fread((void */* __restrict  */)pBuffer, nSize, nCount, (FILE */* __restrict  */)fp);
  }
#line 110
  return (tmp);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
size_t VSIFWrite(void *pBuffer , size_t nSize , size_t nCount , FILE *fp ) 
{ 
  size_t tmp ;

  {
  {
#line 120
  tmp = fwrite((void const   */* __restrict  */)pBuffer, nSize, nCount, (FILE */* __restrict  */)fp);
  }
#line 120
  return (tmp);
}
}
#line 127 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
char *VSIFGets(char *pszBuffer , int nBufferSize , FILE *fp ) 
{ 
  char *tmp ;

  {
  {
#line 130
  tmp = fgets((char */* __restrict  */)pszBuffer, nBufferSize, (FILE */* __restrict  */)fp);
  }
#line 130
  return (tmp);
}
}
#line 137 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIFGetc(FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 140
  tmp = fgetc(fp);
  }
#line 140
  return (tmp);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIUngetc(int c , FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 150
  tmp = ungetc(c, fp);
  }
#line 150
  return (tmp);
}
}
#line 161 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIFPrintf(FILE *fp , char const   *pszFormat  , ...) 
{ 
  va_list args ;
  int nReturn ;

  {
  {
#line 167
  __builtin_va_start(args, pszFormat);
#line 168
  nReturn = vfprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)pszFormat,
                     args);
#line 169
  __builtin_va_end(args);
  }
#line 171
  return (nReturn);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIFEof(FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 181
  tmp = feof(fp);
  }
#line 181
  return (tmp);
}
}
#line 188 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIFPuts(char const   *pszString , FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 191
  tmp = fputs((char const   */* __restrict  */)pszString, (FILE */* __restrict  */)fp);
  }
#line 191
  return (tmp);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIFPutc(int nChar , FILE *fp ) 
{ 
  int tmp ;

  {
  {
#line 201
  tmp = fputc(nChar, fp);
  }
#line 201
  return (tmp);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
void *VSICalloc(size_t nCount , size_t nSize ) 
{ 
  void *tmp ;

  {
  {
#line 211
  tmp = calloc(nCount, nSize);
  }
#line 211
  return (tmp);
}
}
#line 218 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
void *VSIMalloc(size_t nSize ) 
{ 
  void *tmp ;

  {
  {
#line 221
  tmp = malloc(nSize);
  }
#line 221
  return (tmp);
}
}
#line 228 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
void *VSIRealloc(void *pData , size_t nNewSize ) 
{ 
  void *tmp ;

  {
  {
#line 231
  tmp = realloc(pData, nNewSize);
  }
#line 231
  return (tmp);
}
}
#line 238 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
void VSIFree(void *pData ) 
{ 


  {
#line 241
  if ((unsigned long )pData != (unsigned long )((void *)0)) {
    {
#line 242
    free(pData);
    }
  }
#line 243
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
char *VSIStrdup(char const   *pszString ) 
{ 
  char *tmp ;

  {
  {
#line 252
  tmp = strdup(pszString);
  }
#line 252
  return (tmp);
}
}
#line 259 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_vsisimple.c"
int VSIStat(char const   *pszFilename , VSIStatBuf *pStatBuf ) 
{ 
  int tmp ;

  {
  {
#line 262
  tmp = stat((char const   */* __restrict  */)pszFilename, (struct stat */* __restrict  */)pStatBuf);
  }
#line 262
  return (tmp);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.h"
void *CPLMalloc(size_t nSize ) ;
#line 48
void *CPLRealloc(void *pData , size_t nNewSize ) ;
#line 49
char *CPLStrdup(char const   *pszString ) ;
#line 56
char const   *CPLReadLine(FILE *fp ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
void *CPLCalloc(size_t nCount , size_t nSize ) 
{ 
  void *pReturn ;

  {
#line 51
  if (nSize == 0UL) {
#line 52
    return ((void *)0);
  }
  {
#line 54
  pReturn = VSICalloc(nCount, nSize);
  }
#line 55
  if ((unsigned long )pReturn == (unsigned long )((void *)0)) {
    {
#line 57
    CPLError((CPLErr )4, 2, "CPLCalloc(): Out of memory allocating %d bytes.\n", nSize * nCount);
    }
  }
#line 62
  return (pReturn);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
void *CPLMalloc(size_t nSize ) 
{ 
  void *pReturn ;

  {
#line 74
  if (nSize == 0UL) {
#line 75
    return ((void *)0);
  }
  {
#line 77
  pReturn = VSIMalloc(nSize);
  }
#line 78
  if ((unsigned long )pReturn == (unsigned long )((void *)0)) {
    {
#line 80
    CPLError((CPLErr )4, 2, "CPLMalloc(): Out of memory allocating %d bytes.\n", nSize);
    }
  }
#line 85
  return (pReturn);
}
}
#line 92 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
void *CPLRealloc(void *pData , size_t nNewSize ) 
{ 
  void *pReturn ;

  {
#line 97
  if ((unsigned long )pData == (unsigned long )((void *)0)) {
    {
#line 98
    pReturn = VSIMalloc(nNewSize);
    }
  } else {
    {
#line 100
    pReturn = VSIRealloc(pData, nNewSize);
    }
  }
#line 102
  if ((unsigned long )pReturn == (unsigned long )((void *)0)) {
    {
#line 104
    CPLError((CPLErr )4, 2, "CPLRealloc(): Out of memory allocating %d bytes.\n",
             nNewSize);
    }
  }
#line 109
  return (pReturn);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
char *CPLStrdup(char const   *pszString ) 
{ 
  char *pszReturn ;
  size_t tmp ;

  {
#line 121
  if ((unsigned long )pszString == (unsigned long )((void *)0)) {
#line 122
    pszString = "";
  }
  {
#line 124
  pszReturn = VSIStrdup(pszString);
  }
#line 126
  if ((unsigned long )pszReturn == (unsigned long )((void *)0)) {
    {
#line 128
    tmp = strlen(pszString);
#line 128
    CPLError((CPLErr )4, 2, "CPLStrdup(): Out of memory allocating %d bytes.\n", tmp);
    }
  }
#line 134
  return (pszReturn);
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
static char *pszRLBuffer  =    (char *)((void *)0);
#line 154 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
static int nRLBufferSize  =    0;
#line 150 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
char const   *CPLReadLine(FILE *fp ) 
{ 
  int nLength ;
  void *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;

  {
#line 161
  if (nRLBufferSize < 512) {
    {
#line 163
    nRLBufferSize = 512;
#line 164
    tmp = CPLRealloc((void *)pszRLBuffer, (size_t )nRLBufferSize);
#line 164
    pszRLBuffer = (char *)tmp;
    }
  }
  {
#line 170
  tmp___0 = VSIFGets(pszRLBuffer, nRLBufferSize, fp);
  }
#line 170
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 171
    return ((char const   *)((void *)0));
  }
  {
#line 176
  tmp___1 = strlen((char const   *)pszRLBuffer);
#line 176
  nLength = (int )tmp___1;
  }
#line 177
  if (nLength > 0) {
#line 177
    if ((int )*(pszRLBuffer + (nLength - 1)) == 10) {
#line 180
      nLength --;
#line 180
      *(pszRLBuffer + nLength) = (char )'\000';
    } else
#line 177
    if ((int )*(pszRLBuffer + (nLength - 1)) == 13) {
#line 180
      nLength --;
#line 180
      *(pszRLBuffer + nLength) = (char )'\000';
    }
  }
#line 183
  if (nLength > 0) {
#line 183
    if ((int )*(pszRLBuffer + (nLength - 1)) == 10) {
#line 186
      nLength --;
#line 186
      *(pszRLBuffer + nLength) = (char )'\000';
    } else
#line 183
    if ((int )*(pszRLBuffer + (nLength - 1)) == 13) {
#line 186
      nLength --;
#line 186
      *(pszRLBuffer + nLength) = (char )'\000';
    }
  }
#line 189
  return ((char const   *)pszRLBuffer);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00conv.c"
int main(int argc , char **argv ) 
{ 
  E00ReadPtr hReadPtr ;
  E00WritePtr hWritePtr ;
  char const   *pszInFile ;
  char const   *pszOutFile ;
  char const   *pszLine ;
  int nStatus ;
  int nComprLevel ;
  int tmp ;

  {
#line 70
  pszInFile = (char const   *)((void *)0);
#line 70
  pszOutFile = (char const   *)((void *)0);
#line 72
  nStatus = 0;
#line 72
  nComprLevel = 0;
#line 78
  if (argc >= 4) {
    {
#line 85
    tmp = toupper((int )*(*(argv + 3) + 0));
    }
    {
#line 87
    if (tmp == 70) {
#line 87
      goto case_70;
    }
#line 90
    if (tmp == 80) {
#line 90
      goto case_80;
    }
#line 94
    goto switch_default;
    case_70: /* CIL Label */ 
#line 88
    nComprLevel = 2;
#line 89
    goto switch_break;
    case_80: /* CIL Label */ 
#line 91
    nComprLevel = 1;
#line 92
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 95
    nComprLevel = 0;
    switch_break: /* CIL Label */ ;
    }
  }
#line 99
  if (argc >= 3) {
#line 103
    pszInFile = (char const   *)*(argv + 1);
#line 104
    pszOutFile = (char const   *)*(argv + 2);
  } else {
    {
#line 108
    printf((char const   */* __restrict  */)"\n");
#line 109
    printf((char const   */* __restrict  */)"E00CONV - Version %s\n", "1.0.0 (2005-09-17)");
#line 110
    printf((char const   */* __restrict  */)"    Converts Arc/Info E00 files from one level of compression to another.\n");
#line 111
    printf((char const   */* __restrict  */)"    Copyright (c) 1999-2005, Daniel Morissette (dmorissette@mapgears.com)\n");
#line 112
    printf((char const   */* __restrict  */)"    E00COMPR web page:  http://avce00.maptools.org/\n");
#line 113
    printf((char const   */* __restrict  */)"\n");
#line 114
    printf((char const   */* __restrict  */)"Usage: e00conv <input_file> <output_file> [NONE|PARTIAL|FULL]\n");
#line 115
    printf((char const   */* __restrict  */)"\n");
    }
#line 116
    return (1);
  }
  {
#line 122
  hReadPtr = E00ReadOpen(pszInFile);
  }
#line 124
  if (hReadPtr) {
    {
#line 126
    hWritePtr = E00WriteOpen(pszOutFile, nComprLevel);
    }
#line 128
    if (hWritePtr) {
      {
#line 132
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 132
        pszLine = E00ReadNextLine(hReadPtr);
        }
#line 132
        if (! ((unsigned long )pszLine != (unsigned long )((void *)0))) {
#line 132
          goto while_break;
        }
        {
#line 134
        nStatus = CPLGetLastErrorNo();
        }
#line 134
        if (nStatus == 0) {
          {
#line 135
          nStatus = E00WriteNextLine(hWritePtr, pszLine);
          }
        }
#line 137
        if (nStatus != 0) {
#line 141
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 147
      E00WriteClose(hWritePtr);
      }
    } else {
      {
#line 150
      nStatus = CPLGetLastErrorNo();
      }
    }
    {
#line 152
    E00ReadClose(hReadPtr);
    }
  } else {
    {
#line 155
    nStatus = CPLGetLastErrorNo();
    }
  }
#line 157
  return (nStatus);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _CompressLine___1(E00WritePtr psInfo , char const   *pszLine ) ;
#line 69
static int _WriteNextCompressedLine___1(E00WritePtr psInfo , int bFlushWholeBuffer ) ;
#line 70
static int _PrintfNextLine___1(E00WritePtr psInfo , char const   *pszFmt  , ...) ;
#line 278 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _CompressLine___1(E00WritePtr psInfo , char const   *pszLine ) 
{ 
  int nStatus ;
  int nDigits ;
  int nExpSign ;
  int nDotPosition ;
  int iCurPos ;
  int numTotalDigits ;
  int numExpDigits ;
  char n ;
  char *pszCodePos ;
  int nStartOutBufPtr ;
  char const   *pszStartSrcPtr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  unsigned short const   **tmp___14 ;
  int tmp___15 ;

  {
#line 280
  nStatus = 0;
  {
#line 288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 288
    if ((int const   )*pszLine != 0) {
#line 288
      if ((int const   )*pszLine != 10) {
#line 288
        if (! ((int const   )*pszLine != 13)) {
#line 288
          goto while_break;
        }
      } else {
#line 288
        goto while_break;
      }
    } else {
#line 288
      goto while_break;
    }
#line 294
    if ((int const   )*pszLine == 126) {
      {
#line 298
      strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~~");
#line 299
      psInfo->iOutBufPtr += 2;
      }
    } else {
      {
#line 301
      tmp___15 = strncmp(pszLine, "   ", (size_t )3);
      }
#line 301
      if (tmp___15 == 0) {
#line 306
        n = (char)1;
        {
#line 307
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 307
          if (! ((int const   )*(pszLine + 1) == 32)) {
#line 307
            goto while_break___0;
          }
#line 309
          n = (char )((int )n + 1);
#line 310
          pszLine ++;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 312
        strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~ ");
#line 313
        psInfo->iOutBufPtr += 2;
#line 314
        tmp = psInfo->iOutBufPtr;
#line 314
        (psInfo->iOutBufPtr) ++;
#line 314
        psInfo->szOutBuf[tmp] = (char )(32 + (int )n);
        }
      } else
#line 320
      if (psInfo->nComprLevel == 2) {
        {
#line 320
        tmp___14 = __ctype_b_loc();
        }
#line 320
        if ((int const   )*(*tmp___14 + (int )*pszLine) & 2048) {
#line 327
          nStartOutBufPtr = psInfo->iOutBufPtr;
#line 328
          pszStartSrcPtr = pszLine;
#line 332
          nDigits = 0;
#line 333
          nDotPosition = 0;
#line 334
          nExpSign = 0;
#line 335
          numExpDigits = 0;
#line 336
          numTotalDigits = 0;
#line 337
          n = (char)0;
#line 343
          tmp___0 = psInfo->iOutBufPtr;
#line 343
          (psInfo->iOutBufPtr) ++;
#line 343
          psInfo->szOutBuf[tmp___0] = (char )'~';
#line 344
          tmp___1 = psInfo->iOutBufPtr;
#line 344
          (psInfo->iOutBufPtr) ++;
#line 344
          pszCodePos = psInfo->szOutBuf + tmp___1;
#line 349
          iCurPos = 0;
          {
#line 349
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 349
            if ((int const   )*pszLine != 0) {
#line 349
              if (! (numExpDigits < 2)) {
#line 349
                goto while_break___1;
              }
            } else {
#line 349
              goto while_break___1;
            }
            {
#line 353
            tmp___7 = __ctype_b_loc();
            }
#line 353
            if ((int const   )*(*tmp___7 + (int )*pszLine) & 2048) {
#line 357
              numTotalDigits ++;
#line 358
              if (numTotalDigits % 2 == 1) {
#line 360
                n = (char )(((int const   )*pszLine - 48) * 10);
              } else {
#line 364
                n = (char )((int )n + (int )((int const   )*pszLine - 48));
#line 365
                if ((int )n >= 92) {
#line 369
                  tmp___2 = psInfo->iOutBufPtr;
#line 369
                  (psInfo->iOutBufPtr) ++;
#line 369
                  psInfo->szOutBuf[tmp___2] = (char)125;
#line 370
                  n = (char )((int )n - 92);
                }
#line 372
                tmp___3 = psInfo->iOutBufPtr;
#line 372
                (psInfo->iOutBufPtr) ++;
#line 372
                psInfo->szOutBuf[tmp___3] = (char )((int )n + 33);
              }
#line 378
              if (nExpSign != 0) {
#line 379
                numExpDigits ++;
              }
            } else
#line 381
            if ((int const   )*pszLine == 46) {
#line 381
              if (nDotPosition == 0) {
#line 381
                if (iCurPos < 15) {
#line 388
                  nDotPosition = iCurPos;
                } else {
#line 381
                  goto _L___1;
                }
              } else {
#line 381
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 390
            if ((int const   )*pszLine == 69) {
#line 390
              if ((int const   )*(pszLine + 1) == 45) {
#line 390
                goto _L;
              } else
#line 390
              if ((int const   )*(pszLine + 1) == 43) {
                _L: /* CIL Label */ 
                {
#line 390
                tmp___4 = __ctype_b_loc();
                }
#line 390
                if ((int const   )*(*tmp___4 + (int )*(pszLine + 2)) & 2048) {
                  {
#line 390
                  tmp___5 = __ctype_b_loc();
                  }
#line 390
                  if ((int const   )*(*tmp___5 + (int )*(pszLine + 3)) & 2048) {
                    {
#line 390
                    tmp___6 = __ctype_b_loc();
                    }
#line 390
                    if ((int const   )*(*tmp___6 + (int )*(pszLine + 4)) & 2048) {
#line 407
                      goto while_break___1;
                    } else {
#line 400
                      pszLine ++;
#line 401
                      if ((int const   )*pszLine == 45) {
#line 401
                        nExpSign = -1;
                      } else {
#line 401
                        nExpSign = 1;
                      }
                    }
                  } else {
#line 407
                    goto while_break___1;
                  }
                } else {
#line 407
                  goto while_break___1;
                }
              } else {
#line 407
                goto while_break___1;
              }
            } else {
#line 407
              goto while_break___1;
            }
#line 349
            pszLine ++;
#line 349
            iCurPos ++;
          }
          while_break___1: /* CIL Label */ ;
          }
#line 414
          if (numTotalDigits % 2 == 1) {
#line 416
            tmp___8 = psInfo->iOutBufPtr;
#line 416
            (psInfo->iOutBufPtr) ++;
#line 416
            psInfo->szOutBuf[tmp___8] = (char )((int )n + 33);
          }
#line 424
          if ((int const   )*pszLine != 126) {
#line 424
            if ((int const   )*pszLine != 32) {
#line 424
              if ((int const   )*pszLine != 0) {
#line 427
                tmp___9 = psInfo->iOutBufPtr;
#line 427
                (psInfo->iOutBufPtr) ++;
#line 427
                psInfo->szOutBuf[tmp___9] = (char )'~';
              }
            }
          }
#line 434
          pszLine --;
#line 450
          if (iCurPos < psInfo->iOutBufPtr - nStartOutBufPtr) {
            {
#line 452
            strncpy((char */* __restrict  */)(psInfo->szOutBuf + nStartOutBufPtr),
                    (char const   */* __restrict  */)pszStartSrcPtr, (size_t )iCurPos);
#line 455
            psInfo->iOutBufPtr = nStartOutBufPtr + iCurPos;
            }
          } else {
#line 462
            if (numTotalDigits % 2 == 1) {
#line 462
              tmp___10 = 45;
            } else {
#line 462
              tmp___10 = 0;
            }
#line 462
            if (nExpSign) {
#line 462
              if (nExpSign > 0) {
#line 462
                tmp___11 = 15;
              } else {
#line 462
                tmp___11 = 30;
              }
#line 462
              tmp___12 = tmp___11;
            } else {
#line 462
              tmp___12 = 0;
            }
#line 462
            *pszCodePos = (char )(((33 + tmp___10) + tmp___12) + nDotPosition);
          }
        } else {
#line 471
          tmp___13 = psInfo->iOutBufPtr;
#line 471
          (psInfo->iOutBufPtr) ++;
#line 471
          psInfo->szOutBuf[tmp___13] = (char )*pszLine;
        }
      } else {
#line 471
        tmp___13 = psInfo->iOutBufPtr;
#line 471
        (psInfo->iOutBufPtr) ++;
#line 471
        psInfo->szOutBuf[tmp___13] = (char )*pszLine;
      }
    }
#line 476
    if (psInfo->iOutBufPtr >= 256) {
      {
#line 483
      CPLError((CPLErr )3, 3, "Output buffer overflow!!!.");
#line 485
      nStatus = 205;
      }
#line 486
      goto while_break;
    }
#line 491
    pszLine ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 497
  strcpy((char */* __restrict  */)(psInfo->szOutBuf + psInfo->iOutBufPtr), (char const   */* __restrict  */)"~}");
#line 498
  psInfo->iOutBufPtr += 2;
  }
#line 500
  return (nStatus);
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _WriteNextCompressedLine___1(E00WritePtr psInfo , int bFlushWholeBuffer ) 
{ 
  int nStatus ;
  int nToWrite ;
  char *pszSrc ;
  char *pszDst ;

  {
#line 519
  nStatus = 0;
#line 522
  psInfo->szOutBuf[psInfo->iOutBufPtr] = (char )'\000';
#line 524
  if (! bFlushWholeBuffer) {
#line 524
    if (psInfo->iOutBufPtr > 80) {
#line 530
      nToWrite = 80;
      {
#line 531
      while (1) {
        while_continue: /* CIL Label */ ;
#line 531
        if (nToWrite > 1) {
#line 531
          if (! ((int )psInfo->szOutBuf[nToWrite - 1] == 32)) {
#line 531
            goto while_break;
          }
        } else {
#line 531
          goto while_break;
        }
#line 532
        nToWrite --;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 534
      nStatus = _PrintfNextLine___1(psInfo, "%-.*s", nToWrite, psInfo->szOutBuf);
#line 538
      pszDst = psInfo->szOutBuf;
#line 539
      pszSrc = psInfo->szOutBuf + nToWrite;
      }
      {
#line 540
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 540
        if (! ((int )*pszSrc != 0)) {
#line 540
          goto while_break___0;
        }
#line 542
        *pszDst = *pszSrc;
#line 543
        pszDst ++;
#line 544
        pszSrc ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 546
      psInfo->iOutBufPtr -= nToWrite;
    } else {
      {
#line 552
      nStatus = _PrintfNextLine___1(psInfo, "%s", psInfo->szOutBuf);
#line 554
      psInfo->iOutBufPtr = 0;
      }
    }
  } else {
    {
#line 552
    nStatus = _PrintfNextLine___1(psInfo, "%s", psInfo->szOutBuf);
#line 554
    psInfo->iOutBufPtr = 0;
    }
  }
#line 557
  return (nStatus);
}
}
#line 576 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static char szBuf___1[256]  ;
#line 573 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00write.c"
static int _PrintfNextLine___1(E00WritePtr psInfo , char const   *pszFmt  , ...) 
{ 
  va_list args ;
  int nStatus ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 577
  nStatus = 0;
#line 581
  __builtin_va_start(args, pszFmt);
#line 582
  vsprintf((char */* __restrict  */)(szBuf___1), (char const   */* __restrict  */)pszFmt,
           args);
#line 583
  __builtin_va_end(args);
  }
#line 587
  if ((unsigned long )psInfo->pfnWriteNextLine == (unsigned long )((void *)0)) {
    {
#line 591
    tmp___1 = VSIFPrintf(psInfo->fp, "%s\n", szBuf___1);
    }
#line 591
    if (tmp___1 < 0) {
      {
#line 593
      tmp = __errno_location();
#line 593
      tmp___0 = strerror(*tmp);
#line 593
      CPLError((CPLErr )3, 3, "Error writing to file: %s", tmp___0);
#line 596
      nStatus = 204;
      }
    }
  } else {
    {
#line 603
    tmp___2 = (*(psInfo->pfnWriteNextLine))(psInfo->pRefData, (char const   *)(szBuf___1));
    }
#line 603
    if (tmp___2 < 0) {
      {
#line 605
      CPLError((CPLErr )3, 3, "Error writing to file.");
#line 607
      nStatus = 204;
      }
    }
  }
#line 611
  return (nStatus);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _ReadNextSourceLine___1(E00ReadPtr psInfo ) ;
#line 70
static char const   *_UncompressNextLine___1(E00ReadPtr psInfo ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static E00ReadPtr _E00ReadTestOpen___1(E00ReadPtr psInfo ) 
{ 
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 87
  _ReadNextSourceLine___1(psInfo);
  }
#line 88
  if (! psInfo->bEOF) {
    {
#line 88
    tmp___3 = strncmp((char const   *)(psInfo->szInBuf), "EXP ", (size_t )4);
    }
#line 88
    if (tmp___3 == 0) {
      {
#line 101
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 103
        _ReadNextSourceLine___1(psInfo);
        }
#line 101
        if (! psInfo->bEOF) {
#line 101
          if (! ((int )psInfo->szInBuf[0] == 0)) {
            {
#line 101
            tmp = __ctype_b_loc();
            }
#line 101
            if (! ((int const   )*(*tmp + (int )psInfo->szInBuf[0]) & 8192)) {
#line 101
              goto while_break;
            }
          }
        } else {
#line 101
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 107
      if (! psInfo->bEOF) {
        {
#line 107
        tmp___0 = strlen((char const   *)(psInfo->szInBuf));
        }
#line 107
        if (tmp___0 == 79UL) {
#line 107
          goto _L;
        } else {
          {
#line 107
          tmp___1 = strlen((char const   *)(psInfo->szInBuf));
          }
#line 107
          if (tmp___1 == 80UL) {
            _L: /* CIL Label */ 
            {
#line 107
            tmp___2 = strchr((char const   *)(psInfo->szInBuf), '~');
            }
#line 107
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 110
              psInfo->bIsCompressed = 1;
            }
          }
        }
      }
      {
#line 114
      E00ReadRewind(psInfo);
      }
    } else {
      {
#line 118
      VSIFree((void *)psInfo);
#line 119
      psInfo = (E00ReadPtr )((void *)0);
      }
    }
  } else {
    {
#line 118
    VSIFree((void *)psInfo);
#line 119
    psInfo = (E00ReadPtr )((void *)0);
    }
  }
#line 122
  return (psInfo);
}
}
#line 332 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _ReadNextSourceLine___1(E00ReadPtr psInfo ) 
{ 
  char *tmp ;
  char const   *pszLine ;
  int nLen ;
  size_t tmp___0 ;

  {
#line 334
  if (! psInfo->bEOF) {
#line 336
    psInfo->iInBufPtr = 0;
#line 337
    psInfo->szInBuf[0] = (char )'\000';
#line 342
    if ((unsigned long )psInfo->pfnReadNextLine == (unsigned long )((void *)0)) {
      {
#line 344
      tmp = VSIFGets(psInfo->szInBuf, 256, psInfo->fp);
      }
#line 344
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 348
        psInfo->bEOF = 1;
      }
    } else {
      {
#line 354
      pszLine = (*(psInfo->pfnReadNextLine))(psInfo->pRefData);
      }
#line 355
      if (pszLine) {
        {
#line 357
        strncpy((char */* __restrict  */)(psInfo->szInBuf), (char const   */* __restrict  */)pszLine,
                (size_t )256);
        }
      } else {
#line 363
        psInfo->bEOF = 1;
      }
    }
#line 367
    if (! psInfo->bEOF) {
      {
#line 373
      tmp___0 = strlen((char const   *)(psInfo->szInBuf));
#line 373
      nLen = (int )tmp___0;
      }
      {
#line 374
      while (1) {
        while_continue: /* CIL Label */ ;
#line 374
        if (nLen > 0) {
#line 374
          if (! ((int )psInfo->szInBuf[nLen - 1] == 10)) {
#line 374
            if (! ((int )psInfo->szInBuf[nLen - 1] == 13)) {
#line 374
              goto while_break;
            }
          }
        } else {
#line 374
          goto while_break;
        }
#line 377
        nLen --;
#line 378
        psInfo->szInBuf[nLen] = (char )'\000';
      }
      while_break: /* CIL Label */ ;
      }
#line 381
      (psInfo->nInputLineNo) ++;
    }
  }
#line 384
  return;
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static char _GetNextSourceChar___1(E00ReadPtr psInfo ) 
{ 
  char c ;
  int tmp ;

  {
#line 399
  c = (char )'\000';
#line 401
  if (! psInfo->bEOF) {
#line 403
    if ((int )psInfo->szInBuf[psInfo->iInBufPtr] == 0) {
      {
#line 405
      _ReadNextSourceLine___1(psInfo);
#line 406
      c = _GetNextSourceChar___1(psInfo);
      }
    } else {
#line 410
      tmp = psInfo->iInBufPtr;
#line 410
      (psInfo->iInBufPtr) ++;
#line 410
      c = psInfo->szInBuf[tmp];
    }
  }
#line 414
  return (c);
}
}
#line 427 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static void _UngetSourceChar___1(E00ReadPtr psInfo ) 
{ 


  {
#line 429
  if (psInfo->iInBufPtr > 0) {
#line 430
    (psInfo->iInBufPtr) --;
  } else {
    {
#line 436
    CPLError((CPLErr )3, 7, "UNEXPECTED INTERNAL ERROR: _UngetSourceChar() failed while reading line %d.",
             psInfo->nInputLineNo);
    }
  }
#line 440
  return;
}
}
#line 448 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/e00read.c"
static char const   *_UncompressNextLine___1(E00ReadPtr psInfo ) 
{ 
  char c ;
  int bEOL ;
  int iOutBufPtr ;
  int i ;
  int n ;
  int iDecimalPoint ;
  int bOddNumDigits ;
  int iCurDigit ;
  char *pszExp ;
  int bPreviousCodeWasNumeric ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 451
  bEOL = 0;
#line 452
  iOutBufPtr = 0;
#line 455
  bPreviousCodeWasNumeric = 0;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! bEOL) {
      {
#line 457
      c = _GetNextSourceChar___1(psInfo);
      }
#line 457
      if (! ((int )c != 0)) {
#line 457
        goto while_break;
      }
    } else {
#line 457
      goto while_break;
    }
#line 459
    if ((int )c != 126) {
#line 463
      tmp = iOutBufPtr;
#line 463
      iOutBufPtr ++;
#line 463
      psInfo->szOutBuf[tmp] = c;
#line 464
      bPreviousCodeWasNumeric = 0;
    } else {
      {
#line 471
      c = _GetNextSourceChar___1(psInfo);
      }
#line 476
      if ((int )c == 32) {
        {
#line 480
        c = _GetNextSourceChar___1(psInfo);
#line 481
        n = (int )c - 32;
#line 482
        i = 0;
        }
        {
#line 482
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 482
          if (! (i < n)) {
#line 482
            goto while_break___0;
          }
#line 483
          tmp___0 = iOutBufPtr;
#line 483
          iOutBufPtr ++;
#line 483
          psInfo->szOutBuf[tmp___0] = (char )' ';
#line 482
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 484
        bPreviousCodeWasNumeric = 0;
      } else
#line 486
      if ((int )c == 125) {
#line 490
        bEOL = 1;
#line 491
        bPreviousCodeWasNumeric = 0;
      } else
#line 493
      if (bPreviousCodeWasNumeric) {
#line 504
        tmp___1 = iOutBufPtr;
#line 504
        iOutBufPtr ++;
#line 504
        psInfo->szOutBuf[tmp___1] = c;
#line 505
        bPreviousCodeWasNumeric = 0;
      } else
#line 507
      if ((int )c == 126) {
#line 511
        tmp___2 = iOutBufPtr;
#line 511
        iOutBufPtr ++;
#line 511
        psInfo->szOutBuf[tmp___2] = c;
      } else
#line 507
      if ((int )c == 45) {
#line 511
        tmp___2 = iOutBufPtr;
#line 511
        iOutBufPtr ++;
#line 511
        psInfo->szOutBuf[tmp___2] = c;
      } else
#line 533
      if ((int )c >= 33) {
#line 533
        if ((int )c <= 122) {
#line 540
          n = (int )c - 33;
#line 541
          iDecimalPoint = n % 15;
#line 542
          bOddNumDigits = n / 45;
#line 543
          n /= 15;
#line 544
          if (n % 3 == 1) {
#line 545
            pszExp = (char *)"E+";
          } else
#line 546
          if (n % 3 == 2) {
#line 547
            pszExp = (char *)"E-";
          } else {
#line 549
            pszExp = (char *)((void *)0);
          }
#line 554
          iCurDigit = 0;
          {
#line 555
          while (1) {
            while_continue___1: /* CIL Label */ ;
            {
#line 555
            c = _GetNextSourceChar___1(psInfo);
            }
#line 555
            if ((int )c != 0) {
#line 555
              if ((int )c != 32) {
#line 555
                if (! ((int )c != 126)) {
#line 555
                  goto while_break___1;
                }
              } else {
#line 555
                goto while_break___1;
              }
            } else {
#line 555
              goto while_break___1;
            }
#line 558
            n = (int )c - 33;
#line 559
            if (n == 92) {
              {
#line 559
              c = _GetNextSourceChar___1(psInfo);
              }
#line 559
              if ((int )c != 0) {
#line 560
                n += (int )c - 33;
              }
            }
#line 562
            tmp___3 = iOutBufPtr;
#line 562
            iOutBufPtr ++;
#line 562
            psInfo->szOutBuf[tmp___3] = (char )(48 + n / 10);
#line 564
            iCurDigit ++;
#line 564
            if (iCurDigit == iDecimalPoint) {
#line 565
              tmp___4 = iOutBufPtr;
#line 565
              iOutBufPtr ++;
#line 565
              psInfo->szOutBuf[tmp___4] = (char )'.';
            }
#line 567
            tmp___5 = iOutBufPtr;
#line 567
            iOutBufPtr ++;
#line 567
            psInfo->szOutBuf[tmp___5] = (char )(48 + n % 10);
#line 569
            iCurDigit ++;
#line 569
            if (iCurDigit == iDecimalPoint) {
#line 570
              tmp___6 = iOutBufPtr;
#line 570
              iOutBufPtr ++;
#line 570
              psInfo->szOutBuf[tmp___6] = (char )'.';
            }
          }
          while_break___1: /* CIL Label */ ;
          }
#line 573
          if ((int )c == 126) {
            {
#line 575
            bPreviousCodeWasNumeric = 1;
#line 576
            _UngetSourceChar___1(psInfo);
            }
          } else
#line 573
          if ((int )c == 32) {
            {
#line 575
            bPreviousCodeWasNumeric = 1;
#line 576
            _UngetSourceChar___1(psInfo);
            }
          }
#line 581
          if (bOddNumDigits) {
#line 582
            iOutBufPtr --;
          }
#line 587
          if (pszExp) {
#line 589
            i = 0;
            {
#line 589
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 589
              if (! (i < 2)) {
#line 589
                goto while_break___2;
              }
#line 591
              psInfo->szOutBuf[iOutBufPtr] = psInfo->szOutBuf[iOutBufPtr - 2];
#line 593
              psInfo->szOutBuf[iOutBufPtr - 2] = *(pszExp + i);
#line 594
              iOutBufPtr ++;
#line 589
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
          }
        } else {
          {
#line 612
          CPLError((CPLErr )3, 6, "Unexpected code \"~%c\" encountered in line %d.",
                   (int )c, psInfo->nInputLineNo);
#line 618
          psInfo->bEOF = 1;
#line 619
          bEOL = 1;
          }
        }
      } else {
        {
#line 612
        CPLError((CPLErr )3, 6, "Unexpected code \"~%c\" encountered in line %d.",
                 (int )c, psInfo->nInputLineNo);
#line 618
        psInfo->bEOF = 1;
#line 619
        bEOL = 1;
        }
      }
    }
#line 627
    if (iOutBufPtr > 80) {
      {
#line 629
      CPLError((CPLErr )3, 3, "Uncompressed line longer than 80 chars. Input file possibly corrupt around line %d.",
               psInfo->nInputLineNo);
#line 635
      psInfo->bEOF = 1;
#line 636
      bEOL = 1;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 641
  tmp___7 = iOutBufPtr;
#line 641
  iOutBufPtr ++;
#line 641
  psInfo->szOutBuf[tmp___7] = (char )'\000';
#line 643
  return ((char const   *)(psInfo->szOutBuf));
}
}
#line 153 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
static char *pszRLBuffer___0  =    (char *)((void *)0);
#line 154 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_conv.c"
static int nRLBufferSize___0  =    0;
#line 49 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
static char gszCPLLastErrMsg___0[2000]  = {      (char )'\000'};
#line 50 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
static int gnCPLLastErrNo___0  =    0;
#line 52 "/home/june/repo/benchmarks/collector/temp/e00compr-1.0.1/cpl_error.c"
static void (*gpfnCPLErrorHandler___0)(CPLErr  , int  , char const   * )  =    (void (*)(CPLErr  , int  , char const   * ))((void *)0);
