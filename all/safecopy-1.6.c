/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 15 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
struct voidident;
#line 16
struct voiddata;
#line 18 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
struct voidentry {
   struct voidident *identity ;
   struct voiddata *data ;
   struct voidentry *next ;
   struct voidentry *prev ;
};
#line 28 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
struct voidlist {
   struct voidentry *first ;
   struct voidentry *last ;
   int listcount ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 88 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __off64_t off_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 20 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned char __u8;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 169 "/usr/include/linux/cdrom.h"
struct cdrom_msf {
   __u8 cdmsf_min0 ;
   __u8 cdmsf_sec0 ;
   __u8 cdmsf_frame0 ;
   __u8 cdmsf_min1 ;
   __u8 cdmsf_sec1 ;
   __u8 cdmsf_frame1 ;
};
#line 526 "/usr/include/linux/cdrom.h"
struct dvd_layer {
   __u8 book_version : 4 ;
   __u8 book_type : 4 ;
   __u8 min_rate : 4 ;
   __u8 disc_size : 4 ;
   __u8 layer_type : 4 ;
   __u8 track_path : 1 ;
   __u8 nlayers : 2 ;
   __u8 track_density : 4 ;
   __u8 linear_density : 4 ;
   __u8 bca : 1 ;
   __u32 start_sector ;
   __u32 end_sector ;
   __u32 end_sector_l0 ;
};
#line 544 "/usr/include/linux/cdrom.h"
struct dvd_physical {
   __u8 type ;
   __u8 layer_num ;
   struct dvd_layer layer[4] ;
};
#line 550 "/usr/include/linux/cdrom.h"
struct dvd_copyright {
   __u8 type ;
   __u8 layer_num ;
   __u8 cpst ;
   __u8 rmi ;
};
#line 558 "/usr/include/linux/cdrom.h"
struct dvd_disckey {
   __u8 type ;
   unsigned int agid : 2 ;
   __u8 value[2048] ;
};
#line 565 "/usr/include/linux/cdrom.h"
struct dvd_bca {
   __u8 type ;
   int len ;
   __u8 value[188] ;
};
#line 572 "/usr/include/linux/cdrom.h"
struct dvd_manufact {
   __u8 type ;
   __u8 layer_num ;
   int len ;
   __u8 value[2048] ;
};
#line 580 "/usr/include/linux/cdrom.h"
union __anonunion_dvd_struct_19 {
   __u8 type ;
   struct dvd_physical physical ;
   struct dvd_copyright copyright ;
   struct dvd_disckey disckey ;
   struct dvd_bca bca ;
   struct dvd_manufact manufact ;
};
#line 580 "/usr/include/linux/cdrom.h"
typedef union __anonunion_dvd_struct_19 dvd_struct;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 19 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
struct lineindex {
   int line ;
};
#line 29 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
struct textlist {
   struct voidlist *liste ;
};
#line 27 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
struct argdata {
   int numparams ;
   struct textlist *parameters ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
struct arglist {
   struct textlist *given_arguments ;
   struct voidlist *arglist ;
   int argc ;
   char **argv ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 122 "/usr/include/stdint.h"
typedef unsigned long uintptr_t;
#line 401 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
union __anonunion_54 {
   int __in ;
   int __i ;
};
#line 402 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
union __anonunion_55 {
   int __in ;
   int __i ;
};
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
struct voidlist *voidlist_new(void) 
{ 
  struct voidlist *newlst ;
  void *tmp ;

  {
  {
#line 41
  tmp = malloc(sizeof(struct voidlist ));
#line 41
  newlst = (struct voidlist *)tmp;
  }
#line 42
  if (! newlst) {
#line 42
    return ((struct voidlist *)((void *)0));
  }
#line 44
  newlst->first = (struct voidentry *)((void *)0);
#line 45
  newlst->last = (struct voidentry *)((void *)0);
#line 46
  newlst->listcount = 0;
#line 47
  return (newlst);
}
}
#line 52 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
int voidlist_remitem(struct voidlist *list , struct voidident *item , int (*greater)(struct voidident *frst ,
                                                                                     struct voidident *scnd ) ,
                     int (*equality)(struct voidident *frst , struct voidident *scnd ) ,
                     int (*freecontent)(struct voidident *identity , struct voiddata *data ) ) 
{ 
  struct voidentry *member ;
  int tmp ;
  int tmp___0 ;

  {
#line 62
  if (! list) {
#line 62
    return (-1);
  }
#line 64
  member = list->first;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )member != (unsigned long )((void *)0))) {
#line 65
      goto while_break;
    }
    {
#line 66
    tmp___0 = (*greater)(member->identity, item);
    }
#line 66
    if (tmp___0) {
#line 67
      return (1);
    } else {
      {
#line 70
      tmp = (*equality)(member->identity, item);
      }
#line 70
      if (tmp) {
#line 72
        if ((unsigned long )member->prev == (unsigned long )((void *)0)) {
#line 74
          list->first = member->next;
        } else {
#line 77
          (member->prev)->next = member->next;
        }
#line 79
        if ((unsigned long )member->next == (unsigned long )((void *)0)) {
#line 81
          list->last = member->prev;
        } else {
#line 84
          (member->next)->prev = member->prev;
        }
        {
#line 86
        (list->listcount) --;
#line 88
        (*freecontent)(member->identity, member->data);
#line 89
        free((void *)member);
        }
#line 90
        return (0);
      }
#line 94
      member = member->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  return (1);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
int voidlist_kill(struct voidlist *list , int (*freecontent)(struct voidident *identity ,
                                                             struct voiddata *data ) ) 
{ 
  struct voidentry *member ;

  {
#line 110
  if (! list) {
#line 110
    return (-1);
  }
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )list->first != (unsigned long )((void *)0))) {
#line 112
      goto while_break;
    }
    {
#line 113
    member = list->first;
#line 114
    list->first = member->next;
#line 115
    (*freecontent)(member->identity, member->data);
#line 116
    free((void *)member);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 124
  free((void *)list);
  }
#line 125
  return (0);
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
int voidlist_additem(struct voidlist *list , struct voidident *item , struct voiddata *data ,
                     int (*greater)(struct voidident *frst , struct voidident *scnd ) ,
                     int (*equality)(struct voidident *frst , struct voidident *scnd ) ,
                     int (*freecontent)(struct voidident *identity , struct voiddata *data ) ) 
{ 
  struct voidentry *member ;
  struct voidentry *newmember ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
#line 141
  if (! list) {
#line 141
    return (-1);
  }
#line 143
  member = list->first;
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
#line 144
    if (! ((unsigned long )member != (unsigned long )((void *)0))) {
#line 144
      goto while_break;
    }
    {
#line 146
    tmp___1 = (*greater)(member->identity, item);
    }
#line 146
    if (tmp___1) {
      {
#line 148
      tmp = malloc(sizeof(struct voidentry ));
#line 148
      newmember = (struct voidentry *)tmp;
#line 149
      newmember->next = member;
#line 150
      newmember->prev = member->prev;
#line 151
      newmember->identity = item;
#line 152
      newmember->data = data;
      }
#line 154
      if ((unsigned long )member->prev == (unsigned long )((void *)0)) {
#line 156
        list->first = newmember;
      } else {
#line 159
        (member->prev)->next = newmember;
      }
#line 161
      member->prev = newmember;
#line 162
      (list->listcount) ++;
#line 164
      return (0);
    } else {
      {
#line 167
      tmp___0 = (*equality)(item, member->identity);
      }
#line 167
      if (tmp___0) {
        {
#line 170
        (*freecontent)(member->identity, member->data);
#line 171
        member->identity = item;
#line 172
        member->data = data;
        }
#line 173
        return (1);
      }
#line 175
      member = member->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 179
  tmp___2 = malloc(sizeof(struct voidentry ));
#line 179
  newmember = (struct voidentry *)tmp___2;
#line 180
  newmember->next = (struct voidentry *)((void *)0);
#line 181
  newmember->prev = list->last;
#line 182
  newmember->identity = item;
#line 183
  newmember->data = data;
#line 185
  list->last = newmember;
  }
#line 186
  if ((unsigned long )newmember->prev == (unsigned long )((void *)0)) {
#line 187
    list->first = newmember;
  } else {
#line 189
    (newmember->prev)->next = newmember;
  }
#line 191
  (list->listcount) ++;
#line 193
  return (0);
}
}
#line 200 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
struct voiddata *voidlist_item(struct voidlist *list , struct voidident *item , int (*greater)(struct voidident *frst ,
                                                                                               struct voidident *scnd ) ,
                               int (*equality)(struct voidident *frst , struct voidident *scnd ) ) 
{ 
  struct voidentry *member ;
  int tmp ;
  int tmp___0 ;

  {
#line 207
  if (! list) {
#line 207
    return ((struct voiddata *)((void *)0));
  }
#line 209
  member = list->first;
  {
#line 210
  while (1) {
    while_continue: /* CIL Label */ ;
#line 210
    if (! ((unsigned long )member != (unsigned long )((void *)0))) {
#line 210
      goto while_break;
    }
    {
#line 211
    tmp___0 = (*greater)(member->identity, item);
    }
#line 211
    if (tmp___0) {
#line 212
      return ((struct voiddata *)((void *)0));
    } else {
      {
#line 215
      tmp = (*equality)(member->identity, item);
      }
#line 215
      if (tmp) {
#line 216
        return (member->data);
      }
#line 219
      member = member->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  return ((struct voiddata *)((void *)0));
}
}
#line 226 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
int voidlist_all(struct voidlist *list , int (*listprint)(int number , struct voidident *identity ,
                                                          struct voiddata *data ,
                                                          void *userdata ) , void *userdata ) 
{ 
  int t ;
  struct voidentry *member ;
  int tmp ;

  {
#line 233
  t = 0;
#line 236
  if (! list) {
#line 236
    return (-1);
  }
#line 238
  member = list->first;
  {
#line 239
  while (1) {
    while_continue: /* CIL Label */ ;
#line 239
    if (! ((unsigned long )member != (unsigned long )((void *)0))) {
#line 239
      goto while_break;
    }
    {
#line 240
    tmp = t;
#line 240
    t ++;
#line 240
    (*listprint)(tmp, member->identity, member->data, userdata);
#line 241
    member = member->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 244
  if (t > 0) {
#line 245
    return (0);
  } else {
#line 247
    return (1);
  }
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
int voidlist_members(struct voidlist *list ) 
{ 


  {
#line 256
  if (! list) {
#line 256
    return (0);
  }
#line 257
  return (list->listcount);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
struct voidident *voidlist_first(struct voidlist *list ) 
{ 


  {
#line 265
  if (! list) {
#line 265
    return ((struct voidident *)((void *)0));
  }
#line 267
  if ((unsigned long )list->first != (unsigned long )((void *)0)) {
#line 268
    return ((list->first)->identity);
  } else {
#line 270
    return ((struct voidident *)((void *)0));
  }
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/voidlist.c"
struct voidident *voidlist_last(struct voidlist *list ) 
{ 


  {
#line 278
  if (! list) {
#line 278
    return ((struct voidident *)((void *)0));
  }
#line 280
  if ((unsigned long )list->last != (unsigned long )((void *)0)) {
#line 281
    return ((list->last)->identity);
  } else {
#line 283
    return ((struct voidident *)((void *)0));
  }
}
}
#line 149 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...)  __asm__("open64")  ;
#line 337 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off64_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                  __off64_t __offset ,
                                                                                  int __whence )  __asm__("lseek64")  ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
int is_floppy(int fd ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
static int isfloppy  =    -1;
#line 43 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
int is_floppy(int fd ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;

  {
#line 45
  if (isfloppy != -1) {
#line 45
    return (isfloppy);
  }
  {
#line 48
  tmp___1 = ioctl(fd, (unsigned long )((unsigned int )(2 << 8) | 84U), 2);
  }
#line 48
  if (tmp___1 >= 0) {
    {
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nFloppy low level access: drive reset, twaddle ioctl\n");
#line 50
    isfloppy = 1;
    }
  } else {
    {
#line 52
    tmp = __errno_location();
    }
#line 52
    if (*tmp == 13) {
      {
#line 53
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nFloppy low level access: twaddle ioctl\n");
#line 54
      isfloppy = 1;
      }
    } else {
      {
#line 52
      tmp___0 = __errno_location();
      }
#line 52
      if (*tmp___0 == 1) {
        {
#line 53
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nFloppy low level access: twaddle ioctl\n");
#line 54
        isfloppy = 1;
        }
      } else {
#line 56
        isfloppy = 0;
      }
    }
  }
#line 58
  return (isfloppy);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
void reset_floppy(int fd ) 
{ 


  {
  {
#line 63
  ioctl(fd, (unsigned long )((unsigned int )(2 << 8) | 84U), 2);
  }
#line 64
  return;
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
void torture_floppy(int fd ) 
{ 


  {
  {
#line 68
  ioctl(fd, (unsigned long )((unsigned int )(2 << 8) | 89U));
  }
#line 69
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
int cdromsectorsize  =    0;
#line 76 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
int cdromsectoroffset  =    16;
#line 80
int is_cd(int fd ) ;
#line 80 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
static int iscd  =    -1;
#line 79 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
int is_cd(int fd ) 
{ 
  int retval ;
  char *mode ;

  {
#line 83
  if (iscd != -1) {
#line 83
    return (iscd);
  }
  {
#line 84
  retval = ioctl(fd, 21287UL);
  }
#line 85
  if (retval >= 0) {
#line 86
    iscd = 1;
#line 87
    if (retval == 100) {
#line 88
      cdromsectorsize = 2352;
#line 89
      cdromsectoroffset = 0;
#line 90
      mode = (char *)"audio";
    } else
#line 91
    if (retval == 101) {
#line 92
      mode = (char *)"Mode1";
#line 93
      cdromsectorsize = 2048;
#line 94
      cdromsectoroffset = 16;
    } else
#line 95
    if (retval == 102) {
#line 96
      mode = (char *)"Mode2";
#line 97
      cdromsectorsize = 2336;
#line 98
      cdromsectoroffset = 16;
    } else
#line 99
    if (retval == 103) {
#line 100
      mode = (char *)"XA 1";
#line 101
      cdromsectorsize = 2048;
#line 102
      cdromsectoroffset = 24;
    } else
#line 103
    if (retval == 104) {
#line 104
      mode = (char *)"XA 2";
#line 105
      cdromsectorsize = 2324;
#line 106
      cdromsectoroffset = 24;
    } else
#line 107
    if (retval == 105) {
      {
#line 108
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CDROM mixed mode - low level access: drive reset\n");
#line 109
      cdromsectorsize = 0;
#line 110
      cdromsectoroffset = 0;
      }
#line 111
      return (1);
    } else {
      {
#line 113
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CDROM unknown disc - low level access: drive reset\n");
#line 114
      cdromsectorsize = 0;
#line 115
      cdromsectoroffset = 0;
      }
#line 116
      return (1);
    }
    {
#line 118
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CDROM %s - low level access: drive reset, raw read\n",
            mode);
    }
  } else {
#line 120
    iscd = 0;
  }
#line 122
  return (iscd);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
off_t blocksize_cd(int fd , off_t blocksize ) 
{ 


  {
#line 126
  if (cdromsectorsize != 0) {
    {
#line 127
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CDROM low level block size: %u\n",
            cdromsectorsize);
#line 128
    blocksize = (off_t )cdromsectorsize;
    }
  }
#line 130
  return (blocksize);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
off_t filesize_cd(int fd , off_t filesize ) 
{ 
  long result ;
  int retval ;
  int tmp ;

  {
  {
#line 134
  tmp = ioctl(fd, 21397UL, & result);
#line 134
  retval = tmp;
  }
#line 135
  if (retval == 0) {
#line 135
    if (cdromsectorsize > 0) {
      {
#line 136
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"CDROM low level disk size: %lu\n",
              (long )cdromsectorsize * result);
#line 137
      filesize = (long )cdromsectorsize * result;
      }
    }
  }
#line 139
  return (filesize);
}
}
#line 144
int is_dvd(int fd ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
static int isdvd  =    -1;
#line 143 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
int is_dvd(int fd ) 
{ 
  dvd_struct s ;
  int tmp ;

  {
#line 145
  if (isdvd != -1) {
#line 145
    return (isdvd);
  }
  {
#line 147
  s.type = (__u8 )0;
#line 148
  tmp = ioctl(fd, 21392UL, & s);
  }
#line 148
  if (tmp >= 0) {
    {
#line 149
    isdvd = 1;
#line 150
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"DVD low level access: drive reset\n");
    }
  } else {
#line 152
    isdvd = 0;
  }
#line 154
  return (isdvd);
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
void reset_cd(int fd ) 
{ 


  {
  {
#line 159
  ioctl(fd, 21266UL);
  }
#line 160
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
void lba_to_msf(off_t lba , struct cdrom_msf *msf ) 
{ 


  {
#line 165
  lba += 150L;
#line 167
  msf->cdmsf_frame0 = (__u8 )(lba % 75L);
#line 168
  lba /= 75L;
#line 170
  msf->cdmsf_sec0 = (__u8 )(lba % 60L);
#line 171
  msf->cdmsf_min0 = (__u8 )(lba / 60L);
#line 173
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
off_t read_from_cd(int fd , unsigned char *buffer , off_t position , off_t length ) 
{ 
  unsigned char blockbuffer[2646] ;
  struct cdrom_msf *msf ;
  ssize_t tmp ;
  off_t lba ;
  off_t extra ;
  off_t xlength ;
  int tmp___0 ;

  {
#line 178
  msf = (struct cdrom_msf *)(blockbuffer);
#line 185
  if (cdromsectorsize == 0) {
    {
#line 186
    tmp = read(fd, (void *)buffer, (size_t )length);
    }
#line 186
    return (tmp);
  }
#line 188
  lba = position / (off_t )cdromsectorsize;
#line 189
  extra = position - lba * (off_t )cdromsectorsize;
#line 190
  xlength = (off_t )cdromsectorsize - extra;
#line 192
  if (xlength > length) {
#line 192
    xlength = length;
  }
  {
#line 193
  lba_to_msf(lba, msf);
#line 194
  tmp___0 = ioctl(fd, 21268UL, msf);
  }
#line 194
  if (tmp___0 == -1) {
#line 195
    return ((off_t )-1);
  }
  {
#line 203
  memcpy((void */* __restrict  */)buffer, (void const   */* __restrict  */)((blockbuffer + extra) + cdromsectoroffset),
         (size_t )xlength);
#line 204
  lseek(fd, position + xlength, 0);
  }
#line 205
  return (xlength);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
off_t read_desperately(char *filename , int *fd , unsigned char *buffer , off_t position ,
                       off_t length , int seekable , int recovery , int syncmode ) 
{ 
  off_t retval ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 221
  tmp___2 = is_dvd(*fd);
  }
#line 221
  if (tmp___2) {
#line 224
    if (recovery) {
      {
#line 225
      reset_cd(*fd);
#line 227
      close(*fd);
#line 228
      *fd = open((char const   *)filename, 2048 | syncmode);
      }
#line 229
      if (*fd <= 0) {
#line 229
        return ((off_t )-1);
      }
      {
#line 230
      lseek(*fd, position, 0);
      }
    }
    {
#line 232
    retval = read(*fd, (void *)buffer, (size_t )length);
    }
#line 233
    return (retval);
  } else {
    {
#line 234
    tmp___1 = is_cd(*fd);
    }
#line 234
    if (tmp___1) {
#line 240
      if (recovery) {
        {
#line 241
        reset_cd(*fd);
#line 243
        close(*fd);
#line 244
        *fd = open((char const   *)filename, 2048 | syncmode);
        }
#line 245
        if (*fd <= 0) {
#line 245
          return ((off_t )-1);
        }
      }
      {
#line 247
      retval = read_from_cd(*fd, buffer, position, length);
      }
#line 248
      return (retval);
    } else {
      {
#line 249
      tmp___0 = is_floppy(*fd);
      }
#line 249
      if (tmp___0) {
#line 252
        if (recovery) {
          {
#line 253
          reset_floppy(*fd);
#line 255
          close(*fd);
#line 256
          *fd = open((char const   *)filename, 2048 | syncmode);
          }
#line 257
          if (*fd <= 0) {
#line 257
            return ((off_t )-1);
          }
          {
#line 258
          lseek(*fd, position, 0);
          }
        }
        {
#line 260
        retval = read(*fd, (void *)buffer, (size_t )length);
        }
#line 261
        if (retval < 0L) {
          {
#line 261
          tmp = __errno_location();
          }
#line 261
          if (*tmp == 5) {
            {
#line 263
            reset_floppy(*fd);
#line 265
            close(*fd);
#line 266
            *fd = open((char const   *)filename, 2048 | syncmode);
            }
#line 267
            if (*fd <= 0) {
#line 267
              return ((off_t )-1);
            }
            {
#line 268
            lseek(*fd, position, 0);
#line 270
            torture_floppy(*fd);
#line 271
            retval = read(*fd, (void *)buffer, (size_t )length);
            }
          }
        }
#line 273
        return (retval);
      } else {
        {
#line 276
        retval = read(*fd, (void *)buffer, (size_t )length);
        }
#line 277
        return (retval);
      }
    }
  }
}
}
#line 281 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
off_t lowlevel_filesize(char *filename , off_t filesize ) 
{ 
  int inf ;
  int tmp ;
  off_t result ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 282
  tmp = open((char const   *)filename, 0);
#line 282
  inf = tmp;
#line 284
  tmp___1 = is_dvd(inf);
  }
#line 284
  if (tmp___1) {
#line 285
    result = filesize;
  } else {
    {
#line 286
    tmp___0 = is_cd(inf);
    }
#line 286
    if (tmp___0) {
      {
#line 287
      result = filesize_cd(inf, filesize);
      }
    } else {
#line 289
      result = filesize;
    }
  }
  {
#line 291
  close(inf);
  }
#line 292
  return (result);
}
}
#line 294 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
off_t lowlevel_blocksize(char *filename , off_t blocksize ) 
{ 
  int inf ;
  int tmp ;
  off_t result ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 295
  tmp = open((char const   *)filename, 0);
#line 295
  inf = tmp;
#line 297
  tmp___1 = is_dvd(inf);
  }
#line 297
  if (tmp___1) {
#line 298
    result = blocksize;
  } else {
    {
#line 299
    tmp___0 = is_cd(inf);
    }
#line 299
    if (tmp___0) {
      {
#line 300
      result = blocksize_cd(inf, blocksize);
      }
    } else {
#line 302
      result = blocksize;
    }
  }
  {
#line 304
  close(inf);
  }
#line 305
  return (result);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/lowlevel.c"
int lowlevel_canseek(void) 
{ 
  int tmp ;

  {
  {
#line 308
  tmp = is_cd(0);
  }
#line 308
  if (tmp) {
#line 308
    return (1);
  }
#line 309
  return (0);
}
}
#line 39 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
int textlist_greater(struct voidident *vfrst , struct voidident *vscnd ) 
{ 
  struct lineindex *frst ;
  struct lineindex *scnd ;

  {
#line 41
  frst = (struct lineindex *)vfrst;
#line 42
  scnd = (struct lineindex *)vscnd;
#line 43
  return (frst->line > scnd->line);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
int textlist_equality(struct voidident *vfrst , struct voidident *vscnd ) 
{ 
  struct lineindex *frst ;
  struct lineindex *scnd ;

  {
#line 48
  frst = (struct lineindex *)vfrst;
#line 49
  scnd = (struct lineindex *)vscnd;
#line 50
  return (frst->line == scnd->line);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
int textlist_freecontent(struct voidident *videntity , struct voiddata *vdata ) 
{ 
  struct lineindex *identity ;

  {
  {
#line 55
  identity = (struct lineindex *)videntity;
#line 56
  free((void *)identity);
  }
#line 57
  return (0);
}
}
#line 68 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
struct textlist *textlist_new(void) 
{ 
  struct textlist *newtext ;
  void *tmp ;

  {
  {
#line 72
  tmp = malloc(sizeof(struct textlist ));
#line 72
  newtext = (struct textlist *)tmp;
  }
#line 73
  if (! newtext) {
#line 73
    return ((struct textlist *)((void *)0));
  }
  {
#line 74
  newtext->liste = voidlist_new();
  }
#line 75
  if (! newtext->liste) {
    {
#line 76
    free((void *)newtext);
    }
#line 77
    return ((struct textlist *)((void *)0));
  }
#line 81
  return (newtext);
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
int textlist_remline(struct textlist *list , int line ) 
{ 
  struct lineindex identity ;
  int tmp ;

  {
#line 90
  if (! list) {
#line 90
    return (-1);
  }
  {
#line 91
  identity.line = line;
#line 92
  tmp = voidlist_remitem(list->liste, (struct voidident *)(& identity), & textlist_greater,
                         & textlist_equality, & textlist_freecontent);
  }
#line 92
  return (tmp);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
int textlist_kill(struct textlist *list ) 
{ 


  {
#line 103
  if (! list) {
#line 103
    return (-1);
  }
  {
#line 104
  voidlist_kill(list->liste, & textlist_freecontent);
#line 105
  free((void *)list);
  }
#line 106
  return (0);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
int textlist_setline(struct textlist *list , int line , char *text ) 
{ 
  struct lineindex *identity ;
  void *tmp ;
  int tmp___0 ;

  {
#line 117
  if (! list) {
#line 117
    return (-1);
  }
  {
#line 119
  tmp = malloc(sizeof(struct lineindex ));
#line 119
  identity = (struct lineindex *)tmp;
  }
#line 120
  if (! identity) {
#line 120
    return (-1);
  }
  {
#line 123
  identity->line = line;
#line 126
  tmp___0 = voidlist_additem(list->liste, (struct voidident *)identity, (struct voiddata *)text,
                             & textlist_greater, & textlist_equality, & textlist_freecontent);
  }
#line 126
  return (tmp___0);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
int textlist_addline(struct textlist *list , char *text ) 
{ 
  struct lineindex *identity ;
  int line ;
  struct voidident *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 143
  if (! list) {
#line 143
    return (-1);
  }
  {
#line 145
  tmp = voidlist_last(list->liste);
#line 145
  identity = (struct lineindex *)tmp;
  }
#line 146
  if (! identity) {
#line 147
    line = 0;
  } else {
#line 149
    line = identity->line + 1;
  }
  {
#line 152
  tmp___0 = malloc(sizeof(struct lineindex ));
#line 152
  identity = (struct lineindex *)tmp___0;
  }
#line 153
  if (! identity) {
#line 153
    return (-1);
  }
  {
#line 156
  identity->line = line;
#line 159
  tmp___1 = voidlist_additem(list->liste, (struct voidident *)identity, (struct voiddata *)text,
                             & textlist_greater, & textlist_equality, & textlist_freecontent);
  }
#line 159
  return (tmp___1);
}
}
#line 170 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/textlist.c"
char *textlist_line(struct textlist *list , int line ) 
{ 
  struct lineindex identity ;
  struct voiddata *tmp ;

  {
#line 173
  if (! list) {
#line 173
    return ((char *)((void *)0));
  }
  {
#line 174
  identity.line = line;
#line 175
  tmp = voidlist_item(list->liste, (struct voidident *)(& identity), & textlist_greater,
                      & textlist_equality);
  }
#line 175
  return ((char *)tmp);
}
}
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_greater(struct voidident *vfrst , struct voidident *vscnd ) 
{ 
  char *frst ;
  char *scnd ;
  int tmp ;

  {
  {
#line 51
  frst = (char *)vfrst;
#line 52
  scnd = (char *)vscnd;
#line 53
  tmp = strcmp((char const   *)frst, (char const   *)scnd);
  }
#line 53
  return (tmp > 0);
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_equality(struct voidident *vfrst , struct voidident *vscnd ) 
{ 
  char *frst ;
  char *scnd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 58
  frst = (char *)vfrst;
#line 59
  scnd = (char *)vscnd;
#line 60
  tmp = strcmp((char const   *)frst, (char const   *)scnd);
  }
#line 60
  if (tmp) {
#line 60
    tmp___0 = 0;
  } else {
#line 60
    tmp___0 = 1;
  }
#line 60
  return (tmp___0);
}
}
#line 65 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_freecontent(struct voidident *videntity , struct voiddata *vdata ) 
{ 
  char *identity ;
  struct argdata *data ;

  {
#line 68
  identity = (char *)videntity;
#line 69
  data = (struct argdata *)vdata;
#line 71
  if ((unsigned long )data->parameters != (unsigned long )((void *)0)) {
    {
#line 72
    textlist_kill(data->parameters);
    }
  }
  {
#line 74
  data->parameters = (struct textlist *)((void *)0);
#line 76
  free((void *)data);
  }
#line 77
  return (0);
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_addtoknown(int number , struct voidident *videntity , struct voiddata *vdata ,
                       void *userdata ) 
{ 
  char *identity ;
  struct argdata *data ;
  struct textlist *check ;
  int tmp ;

  {
  {
#line 92
  identity = (char *)videntity;
#line 93
  data = (struct argdata *)vdata;
#line 94
  check = (struct textlist *)userdata;
#line 96
  tmp = textlist_addline(check, identity);
  }
#line 96
  return (tmp);
}
}
#line 100
int arglist_isinteger(char *text ) ;
#line 104 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int process_args(struct arglist *list ) 
{ 
  struct argdata *data ;
  int t ;
  int tt ;
  char *temp ;
  char *temp2 ;
  struct textlist *check ;
  int tmp ;
  int tmp___0 ;
  struct voiddata *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct voiddata *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  struct voiddata *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 114
  check = textlist_new();
  }
#line 115
  if (! check) {
#line 115
    return (-1);
  }
  {
#line 117
  tmp = voidlist_all(list->arglist, & arglist_addtoknown, (void *)check);
  }
#line 117
  if (tmp == -1) {
#line 118
    return (-1);
  }
  {
#line 124
  t = 0;
#line 125
  tmp___0 = t;
#line 125
  t ++;
#line 125
  temp = textlist_line(check, tmp___0);
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 126
      goto while_break;
    }
    {
#line 127
    tmp___1 = voidlist_item(list->arglist, (struct voidident *)temp, & arglist_greater,
                            & arglist_equality);
#line 127
    data = (struct argdata *)tmp___1;
    }
#line 130
    if ((unsigned long )data->parameters != (unsigned long )((void *)0)) {
      {
#line 131
      textlist_kill(data->parameters);
#line 132
      data->parameters = (struct textlist *)((void *)0);
      }
    }
    {
#line 134
    tmp___2 = t;
#line 134
    t ++;
#line 134
    temp = textlist_line(check, tmp___2);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 138
  t = 0;
#line 139
  tmp___3 = t;
#line 139
  t ++;
#line 139
  temp = textlist_line(list->given_arguments, tmp___3);
  }
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 140
    if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 140
      goto while_break___0;
    }
    {
#line 141
    tmp___4 = voidlist_item(list->arglist, (struct voidident *)temp, & arglist_greater,
                            & arglist_equality);
#line 141
    data = (struct argdata *)tmp___4;
    }
#line 144
    if ((unsigned long )data != (unsigned long )((void *)0)) {
#line 146
      if ((unsigned long )data->parameters != (unsigned long )((void *)0)) {
        {
#line 148
        textlist_kill(data->parameters);
        }
      }
      {
#line 150
      data->parameters = textlist_new();
      }
#line 151
      if (! data->parameters) {
#line 151
        return (-1);
      }
      {
#line 152
      tmp___5 = t;
#line 152
      t ++;
#line 152
      temp = textlist_line(list->given_arguments, tmp___5);
#line 153
      tt = 0;
      }
      {
#line 154
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 154
        if (tt < data->numparams) {
#line 154
          if (! ((unsigned long )temp != (unsigned long )((void *)0))) {
#line 154
            goto while_break___1;
          }
        } else {
#line 154
          goto while_break___1;
        }
        {
#line 155
        tmp___8 = strncmp((char const   *)temp, "-", (size_t )1);
        }
#line 155
        if (tmp___8) {
#line 155
          goto _L;
        } else {
          {
#line 155
          tmp___9 = arglist_isinteger(temp);
          }
#line 155
          if (tmp___9 == 0) {
            _L: /* CIL Label */ 
            {
#line 157
            tmp___6 = textlist_addline(data->parameters, temp);
            }
#line 157
            if (tmp___6 == -1) {
#line 157
              return (-1);
            }
            {
#line 158
            tmp___7 = t;
#line 158
            t ++;
#line 158
            temp = textlist_line(list->given_arguments, tmp___7);
#line 159
            tt ++;
            }
          } else {
#line 162
            tt = data->numparams;
          }
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    } else {
      {
#line 167
      temp2 = (char *)"VOIDARGS";
#line 168
      tmp___10 = voidlist_item(list->arglist, (struct voidident *)temp2, & arglist_greater,
                               & arglist_equality);
#line 168
      data = (struct argdata *)tmp___10;
      }
#line 171
      if ((unsigned long )data->parameters == (unsigned long )((void *)0)) {
        {
#line 173
        data->parameters = textlist_new();
        }
#line 174
        if (! data->parameters) {
#line 174
          return (-1);
        }
      }
      {
#line 176
      tmp___11 = textlist_addline(data->parameters, temp);
      }
#line 176
      if (tmp___11 == -1) {
#line 176
        return (-1);
      }
      {
#line 178
      tmp___12 = t;
#line 178
      t ++;
#line 178
      temp = textlist_line(list->given_arguments, tmp___12);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 183
  textlist_kill(check);
  }
#line 186
  return (0);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int parse_args(struct arglist *list , int argc , char **argv ) 
{ 
  int t ;
  int tt ;
  int len ;
  char *temp ;
  char A ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 197
  t = 1;
  {
#line 198
  while (1) {
    while_continue: /* CIL Label */ ;
#line 198
    if (! (t < argc)) {
#line 198
      goto while_break;
    }
    {
#line 199
    temp = *(argv + t);
#line 200
    tmp = strlen((char const   *)temp);
#line 200
    len = (int )tmp;
#line 201
    tt = 0;
#line 202
    tmp___2 = strncmp((char const   *)temp, "-", (size_t )1);
    }
#line 202
    if (! tmp___2) {
      {
#line 204
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 204
        if (! (tt < len)) {
#line 204
          goto while_break___0;
        }
#line 205
        A = *(temp + tt);
#line 206
        if ((int )A == 32) {
#line 206
          goto _L;
        } else
#line 206
        if ((int )A == 61) {
#line 206
          goto _L;
        } else
#line 206
        if ((int )A == 58) {
          _L: /* CIL Label */ 
          {
#line 207
          *(temp + tt) = (char )'\000';
#line 208
          tmp___0 = textlist_addline(list->given_arguments, temp);
          }
#line 208
          if (tmp___0 == -1) {
#line 208
            return (-1);
          }
          {
#line 209
          temp += tt + 1;
#line 210
          tmp___1 = strlen((char const   *)temp);
#line 210
          len = (int )tmp___1;
#line 211
          tt = -1;
          }
        }
#line 214
        tt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 217
    if (len > 0) {
      {
#line 218
      tmp___3 = textlist_addline(list->given_arguments, temp);
      }
#line 218
      if (tmp___3 == -1) {
#line 218
        return (-1);
      }
    }
#line 221
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return (0);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_addarg(struct arglist *list , char *argument , int numparams ) 
{ 
  struct argdata *data ;
  int retval ;
  void *tmp ;
  int tmp___0 ;

  {
#line 236
  if (! list) {
#line 236
    return (-1);
  }
  {
#line 238
  tmp = malloc(sizeof(struct argdata ));
#line 238
  data = (struct argdata *)tmp;
  }
#line 239
  if (! data) {
#line 239
    return (-1);
  }
  {
#line 242
  data->numparams = numparams;
#line 243
  data->parameters = textlist_new();
  }
#line 244
  if (! data->parameters) {
    {
#line 245
    free((void *)data);
    }
#line 246
    return (-1);
  }
  {
#line 251
  retval = voidlist_additem(list->arglist, (struct voidident *)argument, (struct voiddata *)data,
                            & arglist_greater, & arglist_equality, & arglist_freecontent);
  }
#line 257
  if (retval == -1) {
#line 257
    return (-1);
  }
  {
#line 259
  tmp___0 = process_args(list);
  }
#line 259
  if (tmp___0 == -1) {
#line 259
    return (-1);
  }
#line 261
  return (retval);
}
}
#line 266 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
struct arglist *arglist_new(int argc , char **argv ) 
{ 
  struct arglist *newarglist ;
  int t ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 274
  tmp = malloc(sizeof(struct arglist ));
#line 274
  newarglist = (struct arglist *)tmp;
  }
#line 275
  if (! newarglist) {
#line 275
    return ((struct arglist *)((void *)0));
  }
  {
#line 276
  newarglist->arglist = voidlist_new();
  }
#line 277
  if (! newarglist->arglist) {
    {
#line 278
    free((void *)newarglist);
    }
#line 279
    return ((struct arglist *)((void *)0));
  }
  {
#line 281
  newarglist->given_arguments = textlist_new();
  }
#line 282
  if (! newarglist->given_arguments) {
    {
#line 283
    free((void *)newarglist->arglist);
#line 284
    free((void *)newarglist);
    }
#line 285
    return ((struct arglist *)((void *)0));
  }
  {
#line 288
  newarglist->argc = argc;
#line 289
  tmp___0 = malloc((unsigned long )argc * sizeof(char *));
#line 289
  newarglist->argv = (char **)tmp___0;
  }
#line 290
  if (! newarglist->argv) {
    {
#line 291
    free((void *)newarglist->given_arguments);
#line 292
    free((void *)newarglist->arglist);
#line 293
    free((void *)newarglist);
    }
#line 294
    return ((struct arglist *)((void *)0));
  }
#line 296
  t = 0;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (t < argc)) {
#line 297
      goto while_break;
    }
    {
#line 298
    *(newarglist->argv + t) = strdup((char const   *)*(argv + t));
#line 299
    t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 303
  tmp___1 = parse_args(newarglist, newarglist->argc, newarglist->argv);
  }
#line 303
  if (tmp___1 == -1) {
#line 304
    return ((struct arglist *)((void *)0));
  }
  {
#line 307
  tmp___2 = arglist_addarg(newarglist, (char *)"VOIDARGS", 0);
  }
#line 307
  if (tmp___2 == -1) {
#line 307
    return ((struct arglist *)((void *)0));
  }
#line 308
  return (newarglist);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_remarg(struct arglist *list , char *argument ) 
{ 
  int retval ;
  int tmp ;

  {
#line 320
  if (! list) {
#line 320
    return (-1);
  }
  {
#line 322
  retval = voidlist_remitem(list->arglist, (struct voidident *)argument, & arglist_greater,
                            & arglist_equality, & arglist_freecontent);
#line 327
  tmp = process_args(list);
  }
#line 327
  if (tmp == -1) {
#line 327
    return (-1);
  }
#line 330
  return (retval);
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_kill(struct arglist *list ) 
{ 
  int t ;

  {
#line 339
  if (! list) {
#line 339
    return (-1);
  }
  {
#line 341
  textlist_kill(list->given_arguments);
#line 344
  voidlist_kill(list->arglist, & arglist_freecontent);
#line 346
  t = 0;
  }
  {
#line 347
  while (1) {
    while_continue: /* CIL Label */ ;
#line 347
    if (! (t < list->argc)) {
#line 347
      goto while_break;
    }
    {
#line 348
    free((void *)*(list->argv + t));
#line 349
    t ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 353
  free((void *)list);
  }
#line 354
  return (0);
}
}
#line 359 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_arggiven(struct arglist *list , char *argument ) 
{ 
  struct argdata *data ;
  struct voiddata *tmp ;

  {
#line 363
  if (! list) {
#line 363
    return (-1);
  }
  {
#line 365
  tmp = voidlist_item(list->arglist, (struct voidident *)argument, & arglist_greater,
                      & arglist_equality);
#line 365
  data = (struct argdata *)tmp;
  }
#line 368
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 368
    return (1);
  }
#line 369
  if ((unsigned long )data->parameters == (unsigned long )((void *)0)) {
#line 369
    return (1);
  }
#line 371
  return (0);
}
}
#line 377 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
char *arglist_parameter(struct arglist *list , char *argument , int param ) 
{ 
  struct argdata *data ;
  struct voiddata *tmp ;
  char *tmp___0 ;

  {
#line 384
  if (! list) {
#line 384
    return ((char *)((void *)0));
  }
  {
#line 386
  tmp = voidlist_item(list->arglist, (struct voidident *)argument, & arglist_greater,
                      & arglist_equality);
#line 386
  data = (struct argdata *)tmp;
  }
#line 389
  if ((unsigned long )data == (unsigned long )((void *)0)) {
#line 389
    return ((char *)((void *)0));
  }
#line 390
  if ((unsigned long )data->parameters == (unsigned long )((void *)0)) {
#line 390
    return ((char *)((void *)0));
  }
  {
#line 392
  tmp___0 = textlist_line(data->parameters, param);
  }
#line 392
  return (tmp___0);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_isinteger(char *text ) 
{ 
  int t ;
  int len ;
  int result ;
  int isnegative ;
  size_t tmp ;

  {
#line 405
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 405
    return (-1);
  }
  {
#line 406
  t = 0;
#line 407
  isnegative = 0;
#line 408
  tmp = strlen((char const   *)text);
#line 408
  len = (int )tmp;
#line 409
  result = 0;
  }
#line 410
  if (len == 0) {
#line 410
    return (0);
  }
  {
#line 411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 411
    if (! (t < len)) {
#line 411
      goto while_break;
    }
#line 412
    result *= 10;
#line 413
    if ((int )*(text + t) < 48) {
#line 413
      goto _L;
    } else
#line 413
    if ((int )*(text + t) > 57) {
      _L: /* CIL Label */ 
#line 414
      if ((int )*(text + t) == 45) {
#line 415
        if (result == 0) {
#line 416
          isnegative = 1;
        } else {
#line 418
          return (-1);
        }
      } else
#line 420
      if ((int )*(text + t) == 32) {
#line 421
        result /= 10;
      } else {
#line 423
        return (-1);
      }
    } else {
#line 426
      result ++;
    }
#line 428
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  return (0);
}
}
#line 435 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/arglist.c"
int arglist_integer(char *text ) 
{ 
  int t ;
  int len ;
  int result ;
  int isnegative ;
  size_t tmp ;

  {
#line 441
  if ((unsigned long )text == (unsigned long )((void *)0)) {
#line 441
    return (0);
  }
  {
#line 442
  t = 0;
#line 443
  isnegative = 0;
#line 444
  tmp = strlen((char const   *)text);
#line 444
  len = (int )tmp;
#line 445
  result = 0;
  }
#line 446
  if (len == 0) {
#line 446
    return (0);
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
#line 447
    if (! (t < len)) {
#line 447
      goto while_break;
    }
#line 448
    result *= 10;
#line 449
    if ((int )*(text + t) < 48) {
#line 449
      goto _L;
    } else
#line 449
    if ((int )*(text + t) > 57) {
      _L: /* CIL Label */ 
#line 450
      if ((int )*(text + t) == 45) {
#line 451
        if (result == 0) {
#line 452
          isnegative = 1;
        } else {
#line 454
          return (0);
        }
      } else
#line 456
      if ((int )*(text + t) == 32) {
#line 457
        result /= 10;
      } else {
#line 459
        return (0);
      }
    } else {
#line 462
      if ((int )*(text + t) == 49) {
#line 462
        result ++;
      }
#line 463
      if ((int )*(text + t) == 50) {
#line 463
        result += 2;
      }
#line 464
      if ((int )*(text + t) == 51) {
#line 464
        result += 3;
      }
#line 465
      if ((int )*(text + t) == 52) {
#line 465
        result += 4;
      }
#line 466
      if ((int )*(text + t) == 53) {
#line 466
        result += 5;
      }
#line 467
      if ((int )*(text + t) == 54) {
#line 467
        result += 6;
      }
#line 468
      if ((int )*(text + t) == 55) {
#line 468
        result += 7;
      }
#line 469
      if ((int )*(text + t) == 56) {
#line 469
        result += 8;
      }
#line 470
      if ((int )*(text + t) == 57) {
#line 470
        result += 9;
      }
    }
#line 472
    t ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 474
  if (isnegative == 1) {
#line 474
    result = 0 - result;
  }
#line 475
  return (result);
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 217 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf )  __asm__("stat64")  ;
#line 220
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf )  __asm__("fstat64")  ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 283
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes )  __asm__("fopen64")  ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 584
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execlp)(char const   *__file ,
                                                                                               char const   *__arg 
                                                                                               , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 779
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) isatty)(int __fd ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 97 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
static int debugmode  =    0;
#line 99 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
int debug(int debug___0 , char *format  , ...) 
{ 
  va_list ap ;
  int ret ;

  {
#line 100
  if (debugmode & debug___0) {
    {
#line 103
    __builtin_va_start(ap, format);
#line 104
    ret = vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)format,
                   ap);
#line 105
    __builtin_va_end(ap);
    }
#line 106
    return (ret);
  }
#line 108
  return (0);
}
}
#line 111 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
void usage(char *name ) 
{ 


  {
  {
#line 112
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Safecopy 1.6 by CorvusCorax\n");
#line 113
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Usage: %s [options] <source> <target>\n",
          name);
#line 114
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Options:\n");
#line 115
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t--stage1 : Preset to rescue most of the data fast,\n");
#line 116
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t           using no retries and avoiding bad areas.\n");
#line 117
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t           Presets: -f 10%% -r 10%% -R 1 -Z 0 -L 2 -M %s\n",
          "BaDbLoCk");
#line 118
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    -o stage1.badblocks\n");
#line 119
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t--stage2 : Preset to rescue more data, using no retries\n");
#line 120
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t           but searching for exact ends of bad areas.\n");
#line 121
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t           Presets: -f 128* -r 1* -R 1 -Z 0 -L 2\n");
#line 122
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    -I stage1.badblocks\n");
#line 123
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    -o stage2.badblocks\n");
#line 124
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t--stage3 : Preset to rescue everything that can be rescued\n");
#line 125
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t           using maximum retries, head realignment tricks\n");
#line 126
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t           and low level access.\n");
#line 127
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t           Presets: -f 1* -r 1* -R 4 -Z 1 -L 2\n");
#line 128
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    -I stage2.badblocks\n");
#line 129
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    -o stage3.badblocks\n");
#line 130
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\tAll stage presets can be overridden by individual options.\n");
#line 131
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-b <size> : Blocksize for default read operations.\n");
#line 132
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Set this to the physical sectorsize of your media.\n");
#line 133
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Default: 1*\n");
#line 134
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Hardware block size if reported by OS, otherwise %i\n",
          4096);
#line 135
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-f <size> : Blocksize when skipping over badblocks.\n");
#line 136
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Higher settings put less strain on your hardware,\n");
#line 137
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            but you might miss good areas in between two bad ones.\n");
#line 138
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Default: 16*\n");
#line 139
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-r <size> : Resolution in bytes when searching for the exact\n");
#line 140
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            beginning or end of a bad area.\n");
#line 141
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            If you read data directly from a device there is no\n");
#line 142
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            need to set this lower than the hardware blocksize.\n");
#line 143
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            On mounted filesystems however, read blocks\n");
#line 144
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            and physical blocks could be misaligned.\n");
#line 145
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Smaller values lead to very thorough attempts to read\n");
#line 146
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            data at the edge of damaged areas,\n");
#line 147
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            but increase the strain on the damaged media.\n");
#line 148
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Default: 1*\n");
#line 149
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-R <number> : At least that many read attempts are made on the first\n");
#line 150
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              bad block of a damaged area with minimum resolution.\n");
#line 151
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              More retries can sometimes recover a weak sector,\n");
#line 152
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              but at the cost of additional strain.\n");
#line 153
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              Default: %i\n",
          3);
#line 154
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-Z <number> : On each error, force seek the read head from start to\n");
#line 155
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              end of the source device as often as specified.\n");
#line 156
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              That takes time, creates additional strain and might\n");
#line 157
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              not be supported by all devices or drivers.\n");
#line 158
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              Default: %i\n",
          1);
#line 159
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-L <mode> : Use low level device calls as specified:\n");
#line 160
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                   0  Do not use low level device calls\n");
#line 161
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                   1  Attempt low level device calls\n");
#line 162
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                      for error recovery only\n");
#line 163
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                   2  Always use low level device calls\n");
#line 164
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                      if available\n");
#line 165
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Supported low level features in this version are:\n");
#line 166
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                SYSTEM  DEVICE TYPE   FEATURE\n");
#line 167
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                Linux   cdrom/dvd     bus/device reset\n");
#line 168
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                Linux   cdrom         read sector in raw mode\n");
#line 169
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                Linux   floppy        controller reset, twaddle\n");
#line 170
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t            Default: %i\n",
          1);
#line 171
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t--sync : Use synchronized read calls (disable driver buffering).\n");
#line 172
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t         Safecopy will use O_DIRECT if supported by the OS\n");
#line 173
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t         and O_SYNC otherwise.\n");
#line 174
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t         Default: Asynchronous read buffering by the OS is allowed\n");
#line 175
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-s <blocks> : Start position where to start reading.\n");
#line 176
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              Will correspond to position 0 in the destination file.\n");
#line 177
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              Default: block 0\n");
#line 178
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-l <blocks> : Maximum length of data to be read.\n");
#line 179
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              Default: Entire size of input file\n");
#line 180
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-I <badblockfile> : Incremental mode. Assume the target file already\n");
#line 181
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    exists and has holes specified in the badblockfile.\n");
#line 182
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    It will be attempted to retrieve more data from\n");
#line 183
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    the listed blocks or from beyond the file size\n");
#line 184
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    of the target file only.\n");
#line 185
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    Warning: Without this option, the destination file\n");
#line 186
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    will be emptied prior to writing.\n");
#line 187
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    Use -I /dev/null if you want to continue a previous\n");
#line 188
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    run of safecopy without a badblock list.\n");
#line 189
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    Default: none\n");
#line 190
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-i <bytes> : Blocksize to interpret the badblockfile given with -I.\n");
#line 191
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t             Default: Blocksize as specified by -b\n");
#line 192
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-X <badblockfile> : Exclusion mode. If used together with -I,\n");
#line 193
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    excluded blocks override included blocks.\n");
#line 194
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    Safecopy will not read or write any data from\n");
#line 195
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    areas covered by exclude blocks.\n");
#line 196
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    Default: none\n");
#line 197
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-x <bytes> : Blocksize to interpret the badblockfile given with -X.\n");
#line 198
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t             Default: Blocksize as specified by -b\n");
#line 199
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-o <badblockfile> : Write a badblocks/e2fsck compatible bad block file.\n");
#line 200
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                    Default: none\n");
#line 201
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-S <seekscript> : Use external script for seeking in input file.\n");
#line 202
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  (Might be useful for tape devices and similar).\n");
#line 203
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  Seekscript must be an executable that takes the\n");
#line 204
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  number of blocks to be skipped as argv1 (1-64)\n");
#line 205
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  the blocksize in bytes as argv2\n");
#line 206
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  and the current position (in bytes) as argv3.\n");
#line 207
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  Return value needs to be the number of blocks\n");
#line 208
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  successfully skipped, or 0 to indicate seek failure.\n");
#line 209
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  The external seekscript will only be used\n");
#line 210
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  if lseek() fails and we need to skip over data.\n");
#line 211
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  Default: none\n");
#line 212
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-M <string> : Mark unrecovered data with this string instead of\n");
#line 213
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              skipping it. This helps in later finding corrupted\n");
#line 214
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              files on rescued file system images.\n");
#line 215
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              The default is to zero unreadable data on creation\n");
#line 216
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              of output files, and leaving the data as it is\n");
#line 217
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              on any later run.\n");
#line 218
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              Warning: When used in combination with\n");
#line 219
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              incremental mode (-I) this may overwrite data\n");
#line 220
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              in any block that occurs in the -I file.\n");
#line 221
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              Blocks not in the -I file, or covered by the file\n");
#line 222
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              specified with -X are save from being overwritten.\n");
#line 223
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t              Default: none\n");
#line 224
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t--debug <level> : Enable debug output. Level is a bit field,\n");
#line 225
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  add values together for more information:\n");
#line 226
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                     program flow:     %i\n",
          1);
#line 227
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                     IO control:       %i\n",
          2);
#line 228
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                     badblock marking: %i\n",
          4);
#line 229
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                     seeking:          %i\n",
          8);
#line 230
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                     incremental mode: %i\n",
          16);
#line 231
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                     exclude mode:     %i\n",
          32);
#line 232
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  or for all debug output: %i\n",
          255);
#line 233
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  Default: 0\n");
#line 234
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-T <timingfile> : Write sector read timing information into\n");
#line 235
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  this file for later analysis.\n");
#line 236
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t                  Default: none\n");
#line 237
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t-h | --help : Show this text\n\n");
#line 238
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Valid parameters for -f -r -b <size> options are:\n");
#line 239
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t<integer>\tAmount in bytes - i.e. 1024\n");
#line 240
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t<percentage>%%\tPercentage of whole file/device size - e.g. 10%\n");
#line 241
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t<number>*\t-b only, number times blocksize reported by OS\n");
#line 242
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t<number>*\t-f and -r only, number times the value of -b\n\n");
#line 243
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Description of output:\n");
#line 244
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t. : Between 1 and 1024 blocks successfully read.\n");
#line 245
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t_ : Read of block was incomplete. (possibly end of file)\n");
#line 246
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t    The blocksize is now reduced to read the rest.\n");
#line 247
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t|/| : Seek failed, source can only be read sequentially.\n");
#line 248
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t> : Read failed, reducing blocksize to read partial data.\n");
#line 249
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t! : A low level error on read attempt of smallest allowed size\n");
#line 250
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t    leads to a retry attempt.\n");
#line 251
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t[xx](+yy){ : Current block and number of bytes continuously\n");
#line 252
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t             read successfully up to this point.\n");
#line 253
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\tX : Read failed on a block with minimum blocksize and is skipped.\n");
#line 254
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t    Unrecoverable error, destination file is padded with zeros.\n");
#line 255
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t    Data is now skipped until end of the unreadable area is reached.\n");
#line 256
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t< : Successful read after the end of a bad area causes\n");
#line 257
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t    backtracking with smaller blocksizes to search for the first\n");
#line 258
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t    readable data.\n");
#line 259
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t}[xx](+yy) : current block and number of bytes of recent\n");
#line 260
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t             continuous unreadable data.\n\n");
#line 261
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Copyright 2009 CorvusCorax\n");
#line 262
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"This is free software. You may redistribute copies of it under\n");
#line 263
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"the terms of the GNU General Public License version 2 or above.\n");
#line 264
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\t<http://www.gnu.org/licenses/gpl2.html>.\n");
#line 265
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"There is NO WARRANTY, to the extent permitted by law.\n");
  }
#line 267
  return;
}
}
#line 270 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
off_t parseoption(char *option , int blocksize , off_t filesize , char *defaultvalue ) 
{ 
  off_t tmp ;
  int len ;
  size_t tmp___0 ;
  int number ;
  off_t result ;
  char *newoption ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  off_t tmp___4 ;
  off_t tmp___5 ;
  int tmp___6 ;
  off_t tmp___7 ;
  int tmp___8 ;
  off_t tmp___9 ;
  off_t tmp___10 ;

  {
#line 271
  if ((unsigned long )option == (unsigned long )((void *)0)) {
    {
#line 272
    tmp = parseoption(defaultvalue, blocksize, filesize, defaultvalue);
    }
#line 272
    return (tmp);
  }
  {
#line 274
  tmp___0 = strlen((char const   *)option);
#line 274
  len = (int )tmp___0;
#line 277
  tmp___1 = strdup((char const   *)option);
#line 277
  newoption = tmp___1;
#line 278
  tmp___3 = arglist_isinteger(option);
  }
#line 278
  if (tmp___3 == 0) {
    {
#line 279
    tmp___2 = arglist_integer(option);
    }
#line 279
    return ((off_t )tmp___2);
  }
#line 281
  if (len < 2) {
    {
#line 281
    tmp___4 = parseoption(defaultvalue, blocksize, filesize, defaultvalue);
    }
#line 281
    return (tmp___4);
  }
#line 282
  if ((int )*(option + (len - 1)) == 37) {
    {
#line 283
    *(newoption + (len - 1)) = (char)0;
#line 284
    tmp___6 = arglist_isinteger(newoption);
    }
#line 284
    if (tmp___6 == 0) {
      {
#line 285
      number = arglist_integer(newoption);
      }
#line 286
      if (filesize > 0L) {
#line 287
        result = (filesize * (off_t )number) / 100L;
      } else {
#line 289
        result = (off_t )(blocksize * number);
      }
#line 292
      if (result / (off_t )blocksize > 0L) {
#line 292
        tmp___5 = result / (off_t )blocksize;
      } else {
#line 292
        tmp___5 = (off_t )1;
      }
#line 292
      return (tmp___5 * (off_t )blocksize);
    }
    {
#line 294
    tmp___7 = parseoption(defaultvalue, blocksize, filesize, defaultvalue);
    }
#line 294
    return (tmp___7);
  }
#line 296
  if ((int )*(option + (len - 1)) == 42) {
    {
#line 297
    *(newoption + (len - 1)) = (char)0;
#line 298
    tmp___8 = arglist_isinteger(newoption);
    }
#line 298
    if (tmp___8 == 0) {
      {
#line 299
      number = arglist_integer(newoption);
      }
#line 300
      return ((off_t )(blocksize * number));
    }
    {
#line 302
    tmp___9 = parseoption(defaultvalue, blocksize, filesize, defaultvalue);
    }
#line 302
    return (tmp___9);
  }
  {
#line 304
  tmp___10 = parseoption(defaultvalue, blocksize, filesize, defaultvalue);
  }
#line 304
  return (tmp___10);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
void printpercentage(int percent ) 
{ 
  char percentage[16] ;
  unsigned int tmp ;
  int t ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
#line 309
  percentage[0] = (char )'1';
#line 309
  percentage[1] = (char )'0';
#line 309
  percentage[2] = (char )'0';
#line 309
  percentage[3] = (char )'%';
#line 309
  percentage[4] = (char )'\000';
#line 309
  tmp = 5U;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (tmp >= 16U) {
#line 309
      goto while_break;
    }
#line 309
    percentage[tmp] = (char)0;
#line 309
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 310
  t = 0;
#line 311
  if (percent > 100) {
#line 311
    percent = 100;
  }
#line 312
  if (percent < 0) {
#line 312
    percent = 0;
  }
  {
#line 313
  sprintf((char */* __restrict  */)(percentage), (char const   */* __restrict  */)"      %i%%",
          percent);
#line 314
  tmp___0 = strlen((char const   *)(percentage));
#line 314
  write(2, (void const   *)(percentage), tmp___0);
  }
  {
#line 315
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 315
    tmp___1 = t;
#line 315
    t ++;
#line 315
    if (! ((int )percentage[tmp___1] != 0)) {
#line 315
      goto while_break___0;
    }
    {
#line 316
    write(2, (void const   *)"\b", (size_t )1);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 318
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
long timediff(struct timeval oldtime , struct timeval newtime ) 
{ 
  long usecs ;

  {
#line 323
  usecs = newtime.tv_usec - oldtime.tv_usec;
#line 324
  usecs += (newtime.tv_sec - oldtime.tv_sec) * 1000000L;
#line 325
  if (usecs < 0L) {
#line 325
    usecs = 0L;
  }
#line 326
  return (usecs);
}
}
#line 331 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
int timecategory(long time ) 
{ 


  {
#line 332
  if (time <= 100L) {
#line 332
    return (100);
  }
#line 333
  if (time <= 10000L) {
#line 333
    return (10000);
  }
#line 334
  if (time <= 100000L) {
#line 334
    return (100000);
  }
#line 335
  if (time <= 1000000L) {
#line 335
    return (1000000);
  }
#line 336
  return (10000000);
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
char *timeicon(int timecat ) 
{ 


  {
  {
#line 342
  if (timecat == 10000000) {
#line 342
    goto case_10000000;
  }
#line 343
  if (timecat == 1000000) {
#line 343
    goto case_1000000;
  }
#line 344
  if (timecat == 100000) {
#line 344
    goto case_100000;
  }
#line 345
  if (timecat == 10000) {
#line 345
    goto case_10000;
  }
#line 346
  if (timecat == 100) {
#line 346
    goto case_100;
  }
#line 341
  goto switch_break;
  case_10000000: /* CIL Label */ 
#line 342
  return ((char *)"  8-X");
  case_1000000: /* CIL Label */ 
#line 343
  return ((char *)"  8-(");
  case_100000: /* CIL Label */ 
#line 344
  return ((char *)"  :-|");
  case_10000: /* CIL Label */ 
#line 345
  return ((char *)"  :-)");
  case_100: /* CIL Label */ 
#line 346
  return ((char *)"  ;-}");
  switch_break: /* CIL Label */ ;
  }
#line 348
  return ((char *)"  ???");
}
}
#line 352 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
void printtimecategory(int timecat ) 
{ 
  char *icon ;
  char *tmp ;
  int t ;
  size_t tmp___0 ;
  int tmp___1 ;

  {
  {
#line 353
  tmp = timeicon(timecat);
#line 353
  icon = tmp;
#line 354
  t = 0;
#line 355
  tmp___0 = strlen((char const   *)icon);
#line 355
  write(2, (void const   *)icon, tmp___0);
  }
  {
#line 356
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    tmp___1 = t;
#line 356
    t ++;
#line 356
    if (! ((int )*(icon + tmp___1) != 0)) {
#line 356
      goto while_break;
    }
    {
#line 357
    write(2, (void const   *)"\b", (size_t )1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 359
  return;
}
}
#line 362 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
int wantabort  =    0;
#line 363 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
void signalhandler(int sig ) 
{ 


  {
#line 364
  wantabort = 1;
#line 365
  return;
}
}
#line 368 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
off_t emergency_seek(off_t new , off_t old , off_t blocksize , char *script ) 
{ 
  char firstarg[128] ;
  char secondarg[128] ;
  char thirdarg[128] ;
  off_t delta ;
  int status ;
  pid_t child ;
  __pid_t tmp ;
  union __anonunion_54 __constr_expr_0 ;
  union __anonunion_55 __constr_expr_1 ;

  {
  {
#line 372
  delta = new - old;
#line 374
  debug(8, (char *)"debug: emergency seek");
  }
#line 376
  if (new == old) {
#line 376
    return (old);
  }
#line 378
  if ((unsigned long )script == (unsigned long )((void *)0)) {
#line 378
    return ((off_t )-2);
  }
  {
#line 381
  while (1) {
    while_continue: /* CIL Label */ ;
#line 381
    if (! (delta > blocksize * 64L)) {
#line 381
      goto while_break;
    }
    {
#line 382
    old = emergency_seek(old + blocksize * 64L, old, blocksize, script);
    }
#line 383
    if (old < 0L) {
#line 383
      return (old);
    }
#line 384
    delta = new - old;
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  if (delta < blocksize) {
#line 387
    delta = blocksize;
  }
  {
#line 389
  sprintf((char */* __restrict  */)(firstarg), (char const   */* __restrict  */)"%llu",
          delta / blocksize);
#line 390
  sprintf((char */* __restrict  */)(secondarg), (char const   */* __restrict  */)"%llu",
          blocksize);
#line 391
  sprintf((char */* __restrict  */)(thirdarg), (char const   */* __restrict  */)"%llu",
          old);
#line 392
  tmp = fork();
#line 392
  child = tmp;
  }
#line 393
  if (child == 0) {
    {
#line 394
    execlp((char const   *)script, (char const   *)script, firstarg, secondarg, thirdarg,
           (void *)0);
#line 395
    exit(-2);
    }
  } else
#line 396
  if (child < 0) {
#line 397
    return ((off_t )-2);
  }
  {
#line 399
  waitpid(child, & status, 0);
#line 401
  __constr_expr_0.__in = status;
  }
#line 401
  if ((__constr_expr_0.__i & 65280) >> 8 == 0) {
#line 401
    return ((off_t )-2);
  }
#line 402
  __constr_expr_1.__in = status;
#line 402
  return (old + blocksize * (off_t )((__constr_expr_1.__i & 65280) >> 8));
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
void markbadblocks(int destination , off_t writeposition , off_t remain , char *marker ,
                   char *databuffer , off_t blocksize ) 
{ 
  off_t writeoffset ;
  off_t writeremain ;
  off_t writeblock ;
  off_t cposition ;
  char nullmarker[8] ;
  unsigned int tmp ;
  size_t tmp___0 ;
  off_t tmp___1 ;

  {
#line 409
  nullmarker[0] = (char)0;
#line 409
  tmp = 1U;
  {
#line 409
  while (1) {
    while_continue: /* CIL Label */ ;
#line 409
    if (tmp >= 8U) {
#line 409
      goto while_break;
    }
#line 409
    nullmarker[tmp] = (char)0;
#line 409
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  if (remain <= 0L) {
    {
#line 411
    debug(4, (char *)"debug: no bad blocks to mark\n");
    }
#line 412
    return;
  }
  {
#line 414
  debug(4, (char *)"debug: marking %llu bad bytes at %llu\n", remain, writeposition);
#line 418
  writeoffset = (off_t )0;
#line 419
  tmp___0 = strlen((char const   *)marker);
#line 419
  writeremain = (off_t )tmp___0;
  }
#line 420
  if (writeremain == 0L) {
#line 420
    writeremain = (off_t )8;
  }
  {
#line 421
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 421
    if (! (writeoffset + writeremain < blocksize)) {
#line 421
      goto while_break___0;
    }
#line 422
    if (writeremain != 0L) {
      {
#line 423
      memcpy((void */* __restrict  */)(databuffer + writeoffset), (void const   */* __restrict  */)marker,
             (size_t )writeremain);
      }
    } else {
      {
#line 425
      memcpy((void */* __restrict  */)(databuffer + writeoffset), (void const   */* __restrict  */)(nullmarker),
             (size_t )writeremain);
      }
    }
#line 427
    writeoffset += writeremain;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 429
  memcpy((void */* __restrict  */)(databuffer + writeoffset), (void const   */* __restrict  */)marker,
         (size_t )(blocksize - writeoffset));
#line 431
  writeremain = remain;
#line 432
  writeoffset = (off_t )0;
  }
  {
#line 433
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 433
    if (! (writeremain > 0L)) {
#line 433
      goto while_break___1;
    }
    {
#line 435
    debug(8, (char *)"debug: seek in destination file: %llu\n", writeposition);
#line 436
    cposition = lseek(destination, writeposition, 0);
    }
#line 437
    if (cposition < 0L) {
      {
#line 438
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError: seek() in output failed");
#line 439
      perror(" ");
      }
#line 440
      return;
    }
    {
#line 442
    debug(2, (char *)"debug: writing badblock marker to destination file: %llu bytes at %llu\n",
          writeremain, cposition);
    }
#line 443
    if (blocksize > writeremain) {
#line 443
      tmp___1 = writeremain;
    } else {
#line 443
      tmp___1 = blocksize;
    }
    {
#line 443
    writeblock = write(destination, (void const   *)(databuffer + writeoffset % blocksize),
                       (size_t )tmp___1);
    }
#line 444
    if (writeblock <= 0L) {
      {
#line 445
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError: write to output failed");
#line 446
      perror(" ");
      }
#line 447
      return;
    }
#line 449
    writeremain -= writeblock;
#line 450
    writeoffset += writeblock;
#line 451
    writeposition += writeblock;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 453
  return;
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
void outputbadblocks(off_t start , off_t limit , int bblocksout , off_t *lastbadblock ,
                     off_t startoffset , off_t blocksize , char *textbuffer ) 
{ 
  off_t tmp_pos ;
  size_t tmp ;

  {
#line 460
  tmp_pos = start / blocksize;
#line 462
  if (*lastbadblock >= tmp_pos) {
#line 463
    tmp_pos = *lastbadblock + 1L;
  }
  {
#line 469
  while (1) {
    while_continue: /* CIL Label */ ;
#line 469
    if (! (tmp_pos * blocksize < limit)) {
#line 469
      goto while_break;
    }
    {
#line 470
    *lastbadblock = tmp_pos;
#line 471
    sprintf((char */* __restrict  */)textbuffer, (char const   */* __restrict  */)"%llu\n",
            *lastbadblock);
#line 472
    debug(4, (char *)"debug: declaring bad block: %llu\n", *lastbadblock);
#line 473
    tmp = strlen((char const   *)textbuffer);
#line 473
    write(bblocksout, (void const   *)textbuffer, tmp);
#line 474
    tmp_pos ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 476
  return;
}
}
#line 480 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
void realmarkoutput(off_t start , off_t end , off_t min , off_t max , off_t startoffset ,
                    off_t blocksize , off_t *lastbadblock , off_t *lastmarked , char *marker ,
                    char *databuffer , char *textbuffer , int bblocksout , char *bblocksoutfile ,
                    int destination , char *xblocksinfile , FILE **xblocksin , off_t *lastxblock ,
                    off_t *previousxblock , off_t xblocksize , int excluding ) 
{ 
  off_t first ;
  off_t last ;
  char *tmp ;
  off_t tmp_pos ;
  int tmp___0 ;

  {
#line 486
  first = start;
#line 487
  last = end;
#line 490
  if (min + startoffset > first) {
#line 490
    first = min + startoffset;
  }
#line 491
  if (max + startoffset < last) {
#line 491
    last = max + startoffset;
  }
#line 493
  if (excluding) {
    {
#line 497
    debug(32, (char *)"debug: checking for exclude blocks during output, at position %llu\n",
          first);
    }
#line 498
    if (first < *lastxblock * xblocksize) {
      {
#line 499
      debug(32, (char *)"debug: possibly need backtracking in exclude list, next exclude block %lli\n",
            *lastxblock);
      }
#line 500
      if (first < *previousxblock * xblocksize) {
        {
#line 503
        debug(32, (char *)"debug: reopening exclude file and reading from the start\n");
#line 504
        fclose(*xblocksin);
#line 505
        *xblocksin = fopen((char const   */* __restrict  */)xblocksinfile, (char const   */* __restrict  */)"r");
        }
#line 506
        if ((unsigned long )*xblocksin == (unsigned long )((void *)0)) {
          {
#line 507
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reopening exclusion badblock file for reading: %s",
                  xblocksinfile);
#line 508
          perror(" ");
#line 509
          *previousxblock = (off_t )(4294967295U >> 1);
#line 510
          *lastxblock = (off_t )(4294967295U >> 1);
          }
#line 511
          return;
        }
#line 513
        *lastxblock = (off_t )-1;
#line 514
        *previousxblock = (off_t )-1;
      } else
#line 515
      if ((*previousxblock + 1L) * xblocksize > first) {
        {
#line 517
        *lastxblock = *previousxblock;
#line 518
        debug(32, (char *)"debug: using last exclude block %lli\n", *lastxblock);
        }
      } else {
        {
#line 520
        debug(32, (char *)"debug: false alarm, current exclude block is fine\n");
        }
      }
    }
#line 523
    tmp_pos = *lastxblock * xblocksize;
    {
#line 524
    while (1) {
      while_continue: /* CIL Label */ ;
#line 524
      if (! (tmp_pos < last)) {
#line 524
        goto while_break;
      }
#line 525
      if (tmp_pos + xblocksize > first) {
#line 526
        if (tmp_pos <= first) {
#line 528
          first = tmp_pos + xblocksize;
#line 529
          if (first > last) {
            {
#line 530
            debug(32, (char *)"debug: current bad block area is completely covered by xblocks, skipping\n");
            }
#line 531
            return;
          }
          {
#line 533
          debug(32, (char *)"debug: start of current bad block area is covered by xblocks shrinking\n");
#line 534
          realmarkoutput(first, last, first - startoffset, last - startoffset, startoffset,
                         blocksize, lastbadblock, lastmarked, marker, databuffer,
                         textbuffer, bblocksout, bblocksoutfile, destination, xblocksinfile,
                         xblocksin, lastxblock, previousxblock, xblocksize, excluding);
          }
#line 536
          return;
        } else
#line 537
        if (tmp_pos < last) {
          {
#line 540
          debug(32, (char *)"debug: current bad block area is partially covered by xblocks, splitting\n");
#line 541
          realmarkoutput(first, tmp_pos, first - startoffset, tmp_pos - startoffset,
                         startoffset, blocksize, lastbadblock, lastmarked, marker,
                         databuffer, textbuffer, bblocksout, bblocksoutfile, destination,
                         xblocksinfile, xblocksin, lastxblock, previousxblock, xblocksize,
                         excluding);
#line 542
          realmarkoutput(tmp_pos, last, tmp_pos - startoffset, last - startoffset,
                         startoffset, blocksize, lastbadblock, lastmarked, marker,
                         databuffer, textbuffer, bblocksout, bblocksoutfile, destination,
                         xblocksinfile, xblocksin, lastxblock, previousxblock, xblocksize,
                         excluding);
          }
#line 543
          return;
        } else {
#line 546
          goto while_break;
        }
      } else {
        {
#line 550
        tmp = fgets((char */* __restrict  */)textbuffer, 64, (FILE */* __restrict  */)*xblocksin);
#line 551
        tmp___0 = sscanf((char const   */* __restrict  */)textbuffer, (char const   */* __restrict  */)"%llu",
                         & tmp_pos);
        }
#line 551
        if (tmp___0 != 1) {
#line 551
          tmp = (char *)((void *)0);
        }
#line 552
        if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 554
          goto while_break;
        }
#line 556
        *previousxblock = *lastxblock;
#line 557
        *lastxblock = tmp_pos;
#line 558
        tmp_pos = *lastxblock * xblocksize;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 563
  if (marker) {
    {
#line 564
    debug(4, (char *)"debug: marking badblocks from %llu to %llu \n", first, last);
    }
#line 565
    if (*lastmarked < first - startoffset) {
#line 566
      *lastmarked = first - startoffset;
    }
    {
#line 568
    markbadblocks(destination, *lastmarked, last - (*lastmarked + startoffset), marker,
                  databuffer, blocksize);
    }
  }
#line 570
  if ((unsigned long )bblocksoutfile != (unsigned long )((void *)0)) {
    {
#line 571
    debug(4, (char *)"debug: declaring badblocks from %llu to %llu \n", first, last);
#line 573
    outputbadblocks(first, last, bblocksout, lastbadblock, startoffset, blocksize,
                    textbuffer);
    }
  }
#line 575
  return;
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
void markoutput(char *description , off_t readposition , off_t lastgood , off_t startoffset ,
                off_t blocksize , off_t targetsize , off_t *lastbadblock , off_t *lastmarked ,
                char *marker , char *databuffer , char *textbuffer , int incremental ,
                FILE *bblocksin , off_t iblocksize , off_t *lastsourceblock , int bblocksout ,
                char *bblocksoutfile , int destination , char *xblocksinfile , FILE **xblocksin ,
                off_t *lastxblock , off_t *previousxblock , off_t xblocksize , int excluding ) 
{ 
  off_t tmp_pos ;
  char *tmp ;
  off_t inc_pos ;
  int tmp___0 ;

  {
#line 588
  tmp_pos = lastgood + startoffset;
#line 592
  if (incremental) {
#line 593
    inc_pos = *lastsourceblock * iblocksize;
    {
#line 595
    while (1) {
      while_continue: /* CIL Label */ ;
#line 595
      if (! (inc_pos < readposition + startoffset)) {
#line 595
        goto while_break;
      }
#line 596
      if (inc_pos + iblocksize > tmp_pos) {
        {
#line 597
        debug(4, (char *)"debug: %s %llu - %llu - marking output for infile block %lli (%llu - %llu)\n",
              description, tmp_pos, readposition + startoffset, inc_pos / iblocksize,
              inc_pos, inc_pos + iblocksize);
#line 598
        realmarkoutput(inc_pos, inc_pos + iblocksize, lastgood, readposition, startoffset,
                       blocksize, lastbadblock, lastmarked, marker, databuffer, textbuffer,
                       bblocksout, bblocksoutfile, destination, xblocksinfile, xblocksin,
                       lastxblock, previousxblock, xblocksize, excluding);
        }
      }
#line 600
      if (inc_pos + iblocksize > readposition + startoffset) {
#line 603
        goto while_break;
      }
      {
#line 605
      tmp = fgets((char */* __restrict  */)textbuffer, 64, (FILE */* __restrict  */)bblocksin);
#line 606
      tmp___0 = sscanf((char const   */* __restrict  */)textbuffer, (char const   */* __restrict  */)"%llu",
                       lastsourceblock);
      }
#line 606
      if (tmp___0 != 1) {
#line 606
        tmp = (char *)((void *)0);
      }
#line 607
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 610
        if (readposition + startoffset < targetsize) {
#line 612
          *lastsourceblock = targetsize / iblocksize;
        } else
#line 613
        if (targetsize) {
#line 614
          *lastsourceblock = (readposition + startoffset) / iblocksize;
        } else {
#line 616
          goto while_break;
        }
      }
#line 619
      inc_pos = *lastsourceblock * iblocksize;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
    {
#line 622
    debug(4, (char *)"debug: %s %llu - %llu - marking output for whole bad area\n",
          description, tmp_pos, readposition + startoffset);
#line 623
    realmarkoutput(tmp_pos, readposition + startoffset, lastgood, readposition, startoffset,
                   blocksize, lastbadblock, lastmarked, marker, databuffer, textbuffer,
                   bblocksout, bblocksoutfile, destination, xblocksinfile, xblocksin,
                   lastxblock, previousxblock, xblocksize, excluding);
    }
  }
#line 626
  return;
}
}
#line 629 "/home/june/repo/benchmarks/collector/temp/safecopy-1.6/src/safecopy.c"
int main(int argc , char **argv ) 
{ 
  struct arglist *carglist ;
  char *sourcefile ;
  char *destfile ;
  char *bblocksinfile ;
  char *xblocksinfile ;
  char *bblocksoutfile ;
  char *seekscriptfile ;
  char *blocksizestring ;
  char *resolutionstring ;
  char *faultblocksizestring ;
  char *bblocksinstring ;
  char *bblocksoutstring ;
  char *xblocksinstring ;
  char *failuredefstring ;
  char *timingfilestring ;
  int retriesdef ;
  int headmovedef ;
  int lowleveldef ;
  int source ;
  int destination ;
  int bblocksout ;
  FILE *bblocksin ;
  FILE *xblocksin ;
  FILE *timingfile ;
  off_t readposition ;
  off_t cposition ;
  off_t sposition ;
  off_t writeposition ;
  off_t startoffset ;
  off_t length ;
  off_t writeoffset ;
  off_t remain ;
  off_t maxremain ;
  off_t block ;
  off_t writeblock ;
  off_t writeremain ;
  char *databuffer ;
  char *databufferpool ;
  char textbuffer[256] ;
  char *tmp ;
  char *marker ;
  off_t fsblocksize ;
  off_t blocksize ;
  off_t iblocksize ;
  off_t xblocksize ;
  off_t faultblocksize ;
  off_t resolution ;
  int retries ;
  int seeks ;
  int cseeks ;
  int incremental ;
  int excluding ;
  int lowlevel ;
  int syncmode ;
  int counter ;
  int percent ;
  int oldpercent ;
  int newerror ;
  int newsofterror ;
  int backtracemode ;
  int output ;
  int linewidth ;
  int seekable ;
  int desperate ;
  int human ;
  off_t softerr ;
  off_t harderr ;
  off_t lasterror ;
  off_t lastgood ;
  off_t lastmarked ;
  off_t tmp_pos ;
  off_t tmp_bytes ;
  off_t lastbadblock ;
  off_t lastxblock ;
  off_t previousxblock ;
  off_t lastsourceblock ;
  struct stat filestatus ;
  off_t filesize ;
  off_t damagesize ;
  off_t targetsize ;
  struct timeval oldtime ;
  struct timeval newtime ;
  long elapsed ;
  long oldelapsed ;
  long oldcategory ;
  fd_set rfds ;
  fd_set efds ;
  int errtmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  char *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  char *tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  char *tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  char *tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  void *tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int *tmp___53 ;
  int tmp___54 ;
  int __d0 ;
  int __d1 ;
  int __d0___0 ;
  int __d1___0 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  size_t tmp___65 ;
  size_t tmp___66 ;
  int *tmp___67 ;
  char *tmp___68 ;
  size_t tmp___69 ;
  size_t tmp___70 ;
  off_t tmp___71 ;
  size_t tmp___72 ;

  {
  {
#line 637
  blocksizestring = (char *)"1*";
#line 638
  resolutionstring = (char *)"1*";
#line 639
  faultblocksizestring = (char *)"16*";
#line 640
  bblocksinstring = (char *)((void *)0);
#line 641
  bblocksoutstring = (char *)((void *)0);
#line 642
  xblocksinstring = (char *)((void *)0);
#line 643
  failuredefstring = (char *)((void *)0);
#line 644
  timingfilestring = (char *)((void *)0);
#line 645
  retriesdef = 3;
#line 646
  headmovedef = 1;
#line 647
  lowleveldef = 1;
#line 665
  marker = (char *)((void *)0);
#line 674
  human = 0;
#line 698
  carglist = arglist_new(argc, argv);
#line 699
  arglist_addarg(carglist, (char *)"--stage", 1);
#line 700
  arglist_addarg(carglist, (char *)"--stage1", 0);
#line 701
  arglist_addarg(carglist, (char *)"--stage2", 0);
#line 702
  arglist_addarg(carglist, (char *)"--stage3", 0);
#line 703
  arglist_addarg(carglist, (char *)"--debug", 1);
#line 704
  arglist_addarg(carglist, (char *)"--help", 0);
#line 705
  arglist_addarg(carglist, (char *)"-h", 0);
#line 706
  arglist_addarg(carglist, (char *)"--sync", 0);
#line 707
  arglist_addarg(carglist, (char *)"-b", 1);
#line 708
  arglist_addarg(carglist, (char *)"-f", 1);
#line 709
  arglist_addarg(carglist, (char *)"-r", 1);
#line 710
  arglist_addarg(carglist, (char *)"-R", 1);
#line 711
  arglist_addarg(carglist, (char *)"-s", 1);
#line 712
  arglist_addarg(carglist, (char *)"-L", 1);
#line 713
  arglist_addarg(carglist, (char *)"-l", 1);
#line 714
  arglist_addarg(carglist, (char *)"-o", 1);
#line 715
  arglist_addarg(carglist, (char *)"-I", 1);
#line 716
  arglist_addarg(carglist, (char *)"-i", 1);
#line 717
  arglist_addarg(carglist, (char *)"-X", 1);
#line 718
  arglist_addarg(carglist, (char *)"-x", 1);
#line 719
  arglist_addarg(carglist, (char *)"-S", 1);
#line 720
  arglist_addarg(carglist, (char *)"-Z", 1);
#line 721
  arglist_addarg(carglist, (char *)"-M", 1);
#line 722
  arglist_addarg(carglist, (char *)"-T", 1);
#line 725
  tmp___0 = isatty(1);
#line 725
  tmp___1 = isatty(2);
#line 725
  human = tmp___0 & tmp___1;
#line 727
  tmp___3 = arglist_arggiven(carglist, (char *)"--debug");
  }
#line 727
  if (tmp___3 == 0) {
    {
#line 728
    tmp___2 = arglist_parameter(carglist, (char *)"--debug", 0);
#line 728
    debugmode = arglist_integer(tmp___2);
    }
  }
  {
#line 730
  tmp___4 = arglist_arggiven(carglist, (char *)"--help");
  }
#line 730
  if (tmp___4 == 0) {
    {
#line 734
    usage(*(argv + 0));
#line 735
    arglist_kill(carglist);
    }
#line 736
    return (0);
  } else {
    {
#line 730
    tmp___5 = arglist_arggiven(carglist, (char *)"-h");
    }
#line 730
    if (tmp___5 == 0) {
      {
#line 734
      usage(*(argv + 0));
#line 735
      arglist_kill(carglist);
      }
#line 736
      return (0);
    } else {
      {
#line 730
      tmp___6 = arglist_parameter(carglist, (char *)"VOIDARGS", 2);
      }
#line 730
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        {
#line 734
        usage(*(argv + 0));
#line 735
        arglist_kill(carglist);
        }
#line 736
        return (0);
      } else {
        {
#line 730
        tmp___7 = arglist_parameter(carglist, (char *)"VOIDARGS", 1);
        }
#line 730
        if ((unsigned long )tmp___7 == (unsigned long )((void *)0)) {
          {
#line 734
          usage(*(argv + 0));
#line 735
          arglist_kill(carglist);
          }
#line 736
          return (0);
        }
      }
    }
  }
  {
#line 738
  sourcefile = arglist_parameter(carglist, (char *)"VOIDARGS", 0);
#line 739
  destfile = arglist_parameter(carglist, (char *)"VOIDARGS", 1);
#line 741
  tmp___8 = arglist_arggiven(carglist, (char *)"--stage1");
  }
#line 741
  if (tmp___8 == 0) {
#line 741
    goto _L;
  } else {
    {
#line 741
    tmp___9 = arglist_parameter(carglist, (char *)"--stage", 0);
#line 741
    tmp___10 = arglist_integer(tmp___9);
    }
#line 741
    if (tmp___10 == 1) {
      _L: /* CIL Label */ 
#line 742
      faultblocksizestring = (char *)"10%";
#line 743
      resolutionstring = (char *)"10%";
#line 744
      retriesdef = 1;
#line 745
      headmovedef = 0;
#line 746
      lowleveldef = 2;
#line 747
      failuredefstring = (char *)"BaDbLoCk";
#line 748
      bblocksoutstring = (char *)"stage1.badblocks";
    }
  }
  {
#line 750
  tmp___11 = arglist_arggiven(carglist, (char *)"--stage2");
  }
#line 750
  if (tmp___11 == 0) {
#line 750
    goto _L___0;
  } else {
    {
#line 750
    tmp___12 = arglist_parameter(carglist, (char *)"--stage", 0);
#line 750
    tmp___13 = arglist_integer(tmp___12);
    }
#line 750
    if (tmp___13 == 2) {
      _L___0: /* CIL Label */ 
#line 751
      faultblocksizestring = (char *)"128*";
#line 752
      resolutionstring = (char *)"1*";
#line 753
      retriesdef = 1;
#line 754
      headmovedef = 0;
#line 755
      lowleveldef = 2;
#line 756
      bblocksinstring = (char *)"stage1.badblocks";
#line 757
      bblocksoutstring = (char *)"stage2.badblocks";
    }
  }
  {
#line 759
  tmp___14 = arglist_arggiven(carglist, (char *)"--stage3");
  }
#line 759
  if (tmp___14 == 0) {
#line 759
    goto _L___1;
  } else {
    {
#line 759
    tmp___15 = arglist_parameter(carglist, (char *)"--stage", 0);
#line 759
    tmp___16 = arglist_integer(tmp___15);
    }
#line 759
    if (tmp___16 == 3) {
      _L___1: /* CIL Label */ 
#line 760
      faultblocksizestring = (char *)"1*";
#line 761
      resolutionstring = (char *)"1*";
#line 762
      bblocksinstring = (char *)"stage2.badblocks";
#line 763
      bblocksoutstring = (char *)"stage3.badblocks";
#line 764
      retriesdef = 4;
#line 765
      headmovedef = 1;
#line 766
      lowleveldef = 2;
    }
  }
  {
#line 770
  lowlevel = lowleveldef;
#line 771
  tmp___18 = arglist_arggiven(carglist, (char *)"-L");
  }
#line 771
  if (tmp___18 == 0) {
    {
#line 772
    tmp___17 = arglist_parameter(carglist, (char *)"-L", 0);
#line 772
    lowlevel = arglist_integer(tmp___17);
    }
  }
#line 774
  if (lowlevel < 0) {
#line 774
    lowlevel = 0;
  }
#line 775
  if (lowlevel > 2) {
#line 775
    lowlevel = 2;
  }
  {
#line 776
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Low level device calls enabled mode: %i\n",
          lowlevel);
#line 779
  syncmode = 0;
#line 780
  tmp___19 = arglist_arggiven(carglist, (char *)"--sync");
  }
#line 780
  if (tmp___19 == 0) {
    {
#line 784
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Using synchronized IO on source. (O_DIRECT)\n");
#line 786
    syncmode = 16384;
    }
  }
  {
#line 790
  filesize = (off_t )0;
#line 791
  fsblocksize = (off_t )4096;
#line 792
  tmp___20 = stat((char const   */* __restrict  */)sourcefile, (struct stat */* __restrict  */)(& filestatus));
  }
#line 792
  if (! tmp___20) {
#line 793
    filesize = filestatus.st_size;
#line 794
    if (filestatus.st_blksize) {
      {
#line 795
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Reported hw blocksize: %lu\n",
              filestatus.st_blksize);
#line 796
      fsblocksize = filestatus.st_blksize;
      }
    }
  }
#line 799
  if (lowlevel > 0) {
    {
#line 800
    tmp___21 = (int )lowlevel_filesize(sourcefile, filesize);
#line 800
    filesize = (off_t )tmp___21;
#line 801
    tmp___22 = (int )lowlevel_blocksize(sourcefile, fsblocksize);
#line 801
    fsblocksize = (off_t )tmp___22;
#line 802
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Reported low level blocksize: %lu\n",
            fsblocksize);
    }
  }
#line 805
  if (filesize != 0L) {
    {
#line 806
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"File size: %llu\n",
            filesize);
    }
  } else {
    {
#line 808
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Filesize not reported by stat(), trying seek().\n");
#line 809
    source = open((char const   *)sourcefile, 1052672);
    }
#line 810
    if (source) {
      {
#line 811
      filesize = lseek(source, (__off64_t )0, 2);
#line 812
      close(source);
      }
    }
#line 814
    if (filesize <= 0L) {
      {
#line 815
      filesize = (off_t )0;
#line 816
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unable to determine input file size.\n");
      }
    } else {
      {
#line 818
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"File size: %llu\n",
              filesize);
      }
    }
  }
  {
#line 822
  tmp = blocksizestring;
#line 823
  tmp___23 = arglist_arggiven(carglist, (char *)"-b");
  }
#line 823
  if (tmp___23 == 0) {
    {
#line 824
    blocksizestring = arglist_parameter(carglist, (char *)"-b", 0);
    }
  }
  {
#line 826
  blocksize = parseoption(blocksizestring, (int )fsblocksize, filesize, tmp);
  }
#line 827
  if (blocksize < 1L) {
#line 827
    blocksize = fsblocksize;
  }
#line 828
  if (blocksize > 104857600L) {
#line 828
    blocksize = (off_t )104857600;
  }
  {
#line 829
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Blocksize: %llu\n",
          blocksize);
#line 831
  tmp = faultblocksizestring;
#line 832
  tmp___24 = arglist_arggiven(carglist, (char *)"-f");
  }
#line 832
  if (tmp___24 == 0) {
    {
#line 833
    faultblocksizestring = arglist_parameter(carglist, (char *)"-f", 0);
    }
  }
  {
#line 835
  faultblocksize = parseoption(faultblocksizestring, (int )blocksize, filesize, tmp);
  }
#line 836
  if (faultblocksize < blocksize) {
#line 836
    faultblocksize = blocksize;
  }
#line 837
  if (faultblocksize > 104857600L) {
#line 837
    faultblocksize = (off_t )104857600;
  }
  {
#line 838
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Fault skip blocksize: %llu\n",
          faultblocksize);
#line 840
  tmp = resolutionstring;
#line 841
  tmp___25 = arglist_arggiven(carglist, (char *)"-r");
  }
#line 841
  if (tmp___25 == 0) {
    {
#line 842
    resolutionstring = arglist_parameter(carglist, (char *)"-r", 0);
    }
  }
  {
#line 844
  resolution = parseoption(resolutionstring, (int )blocksize, filesize, tmp);
  }
#line 845
  if (resolution < 1L) {
#line 845
    resolution = (off_t )1;
  }
#line 846
  if (resolution > faultblocksize) {
#line 846
    resolution = faultblocksize;
  }
  {
#line 847
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Resolution: %llu\n",
          resolution);
#line 849
  retries = retriesdef;
#line 850
  tmp___27 = arglist_arggiven(carglist, (char *)"-R");
  }
#line 850
  if (tmp___27 == 0) {
    {
#line 851
    tmp___26 = arglist_parameter(carglist, (char *)"-R", 0);
#line 851
    retries = arglist_integer(tmp___26);
    }
  }
#line 853
  if (retries < 1) {
#line 853
    retries = 1;
  }
  {
#line 854
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Min read attempts: %u\n",
          retries);
#line 856
  seeks = headmovedef;
#line 857
  tmp___29 = arglist_arggiven(carglist, (char *)"-Z");
  }
#line 857
  if (tmp___29 == 0) {
    {
#line 858
    tmp___28 = arglist_parameter(carglist, (char *)"-Z", 0);
#line 858
    seeks = arglist_integer(tmp___28);
    }
  }
#line 860
  if (seeks < 0) {
#line 860
    seeks = 0;
  }
  {
#line 861
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Head moves on read error: %i\n",
          seeks);
#line 863
  iblocksize = blocksize;
#line 864
  tmp___32 = arglist_arggiven(carglist, (char *)"-i");
  }
#line 864
  if (tmp___32 == 0) {
    {
#line 865
    tmp___30 = arglist_parameter(carglist, (char *)"-i", 0);
#line 865
    tmp___31 = arglist_integer(tmp___30);
#line 865
    iblocksize = (off_t )tmp___31;
    }
  }
#line 867
  if (iblocksize < 1L) {
    {
#line 868
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid blocksize given for bad block include file!\n");
#line 869
    arglist_kill(carglist);
    }
#line 870
    return (2);
  } else
#line 867
  if (iblocksize > 104857600L) {
    {
#line 868
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid blocksize given for bad block include file!\n");
#line 869
    arglist_kill(carglist);
    }
#line 870
    return (2);
  }
  {
#line 873
  incremental = 0;
#line 874
  tmp___33 = arglist_arggiven(carglist, (char *)"-I");
  }
#line 874
  if (tmp___33 == 0) {
    {
#line 875
    bblocksinstring = arglist_parameter(carglist, (char *)"-I", 0);
    }
  }
#line 877
  if ((unsigned long )bblocksinstring != (unsigned long )((void *)0)) {
    {
#line 878
    incremental = 1;
#line 879
    bblocksinfile = bblocksinstring;
#line 880
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Incremental mode file: %s\nIncremental mode blocksize: %llu\n",
            bblocksinfile, iblocksize);
    }
  }
  {
#line 883
  xblocksize = blocksize;
#line 884
  tmp___36 = arglist_arggiven(carglist, (char *)"-x");
  }
#line 884
  if (tmp___36 == 0) {
    {
#line 885
    tmp___34 = arglist_parameter(carglist, (char *)"-x", 0);
#line 885
    tmp___35 = arglist_integer(tmp___34);
#line 885
    xblocksize = (off_t )tmp___35;
    }
  }
#line 887
  if (xblocksize < 1L) {
    {
#line 888
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid blocksize given for bad block exclude file!\n");
#line 889
    arglist_kill(carglist);
    }
#line 890
    return (2);
  } else
#line 887
  if (xblocksize > 104857600L) {
    {
#line 888
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error: Invalid blocksize given for bad block exclude file!\n");
#line 889
    arglist_kill(carglist);
    }
#line 890
    return (2);
  }
  {
#line 893
  excluding = 0;
#line 894
  tmp___37 = arglist_arggiven(carglist, (char *)"-X");
  }
#line 894
  if (tmp___37 == 0) {
    {
#line 895
    xblocksinstring = arglist_parameter(carglist, (char *)"-X", 0);
    }
  }
#line 897
  if ((unsigned long )xblocksinstring != (unsigned long )((void *)0)) {
    {
#line 898
    excluding = 1;
#line 899
    xblocksinfile = xblocksinstring;
#line 900
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Exclusion mode file: %s\nExclusion mode blocksize: %llu\n",
            xblocksinfile, xblocksize);
    }
  }
  {
#line 903
  bblocksoutfile = (char *)((void *)0);
#line 904
  tmp___38 = arglist_arggiven(carglist, (char *)"-o");
  }
#line 904
  if (tmp___38 == 0) {
    {
#line 905
    bblocksoutstring = arglist_parameter(carglist, (char *)"-o", 0);
    }
  }
#line 907
  if ((unsigned long )bblocksoutstring != (unsigned long )((void *)0)) {
    {
#line 908
    bblocksoutfile = bblocksoutstring;
#line 909
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Badblocks output: %s\n",
            bblocksoutfile);
    }
  }
  {
#line 912
  seekscriptfile = (char *)((void *)0);
#line 913
  tmp___39 = arglist_arggiven(carglist, (char *)"-S");
  }
#line 913
  if (tmp___39 == 0) {
    {
#line 914
    seekscriptfile = arglist_parameter(carglist, (char *)"-S", 0);
#line 915
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Seek script (fallback): %s\n",
            seekscriptfile);
    }
  }
  {
#line 918
  tmp___40 = arglist_arggiven(carglist, (char *)"-T");
  }
#line 918
  if (tmp___40 == 0) {
    {
#line 919
    timingfilestring = arglist_parameter(carglist, (char *)"-T", 0);
#line 920
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Write sector timing information to file: %s\n",
            timingfilestring);
    }
  }
  {
#line 923
  tmp___41 = arglist_arggiven(carglist, (char *)"-M");
  }
#line 923
  if (tmp___41 == 0) {
    {
#line 924
    failuredefstring = arglist_parameter(carglist, (char *)"-M", 0);
    }
#line 925
    if ((unsigned long )failuredefstring == (unsigned long )((void *)0)) {
#line 925
      failuredefstring = (char *)"";
    }
  }
#line 927
  if ((unsigned long )failuredefstring != (unsigned long )((void *)0)) {
    {
#line 928
    marker = failuredefstring;
#line 929
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Marker string: %s\n",
            marker);
    }
  }
  {
#line 932
  startoffset = (off_t )0;
#line 933
  tmp___44 = arglist_arggiven(carglist, (char *)"-s");
  }
#line 933
  if (tmp___44 == 0) {
    {
#line 934
    tmp___42 = arglist_parameter(carglist, (char *)"-s", 0);
#line 934
    tmp___43 = arglist_integer(tmp___42);
#line 934
    startoffset = (off_t )tmp___43;
    }
  }
#line 936
  if (startoffset < 1L) {
#line 936
    startoffset = (off_t )0;
  }
  {
#line 937
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Starting block: %llu\n",
          startoffset);
#line 939
  length = (off_t )0;
#line 940
  tmp___47 = arglist_arggiven(carglist, (char *)"-l");
  }
#line 940
  if (tmp___47 == 0) {
    {
#line 941
    tmp___45 = arglist_parameter(carglist, (char *)"-l", 0);
#line 941
    tmp___46 = arglist_integer(tmp___45);
#line 941
    length = (off_t )tmp___46;
    }
  }
#line 943
  if (length < 1L) {
#line 943
    length = (off_t )-1;
  }
#line 944
  if (length >= 0L) {
    {
#line 945
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Size limit (blocks): %llu\n",
            length);
    }
  }
#line 947
  startoffset *= blocksize;
#line 948
  length *= blocksize;
#line 949
  if (filesize == 0L) {
#line 949
    if (length > 0L) {
#line 950
      filesize = startoffset + length;
    }
  }
  {
#line 953
  tmp___48 = malloc((unsigned long )(2L * blocksize + 1L) * sizeof(char ));
#line 953
  databufferpool = (char *)tmp___48;
  }
#line 954
  if ((unsigned long )databufferpool == (unsigned long )((void *)0)) {
    {
#line 955
    perror("MEMORY ALLOCATION ERROR!\nCOULDNT ALLOCATE MAIN BUFFER ");
    }
#line 956
    return (2);
  }
  {
#line 959
  databuffer = (databufferpool + blocksize) - (uintptr_t )databufferpool % (unsigned long )blocksize;
#line 964
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Source: %s\nDestination: %s\n",
          sourcefile, destfile);
#line 965
  source = open((char const   *)sourcefile, 2048 | syncmode);
  }
#line 966
  if (source == -1) {
    {
#line 967
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening sourcefile: %s",
            sourcefile);
#line 968
    perror(" ");
    }
#line 969
    if (human) {
      {
#line 969
      usage(*(argv + 0));
      }
    }
    {
#line 970
    arglist_kill(carglist);
    }
#line 971
    return (2);
  }
#line 973
  if (excluding == 1) {
    {
#line 974
    xblocksin = fopen((char const   */* __restrict  */)xblocksinfile, (char const   */* __restrict  */)"r");
    }
#line 975
    if ((unsigned long )xblocksin == (unsigned long )((void *)0)) {
      {
#line 976
      close(source);
#line 977
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening exclusion badblock file for reading: %s",
              xblocksinfile);
#line 978
      perror(" ");
#line 979
      arglist_kill(carglist);
      }
#line 980
      return (2);
    }
  }
#line 983
  targetsize = (off_t )0;
#line 984
  if (incremental == 1) {
    {
#line 985
    bblocksin = fopen((char const   */* __restrict  */)bblocksinfile, (char const   */* __restrict  */)"r");
    }
#line 986
    if ((unsigned long )bblocksin == (unsigned long )((void *)0)) {
      {
#line 987
      close(source);
      }
#line 988
      if (excluding == 1) {
        {
#line 988
        fclose(xblocksin);
        }
      }
      {
#line 989
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening badblock file for reading: %s",
              bblocksinfile);
#line 990
      perror(" ");
#line 991
      arglist_kill(carglist);
      }
#line 992
      return (2);
    }
    {
#line 994
    destination = open((char const   *)destfile, 1, 438);
    }
#line 995
    if (destination == -1) {
      {
#line 996
      close(source);
#line 997
      fclose(bblocksin);
      }
#line 998
      if (excluding == 1) {
        {
#line 998
        fclose(xblocksin);
        }
      }
      {
#line 999
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening destination: %s",
              destfile);
#line 1000
      perror(" ");
      }
#line 1001
      if (human) {
        {
#line 1001
        usage(*(argv + 0));
        }
      }
      {
#line 1002
      arglist_kill(carglist);
      }
#line 1003
      return (2);
    }
    {
#line 1006
    tmp___49 = fstat(destination, & filestatus);
    }
#line 1006
    if (! tmp___49) {
#line 1007
      targetsize = filestatus.st_size;
    }
#line 1009
    if (! targetsize) {
      {
#line 1010
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Destination filesize not reported by stat(), trying seek().\n");
#line 1011
      targetsize = lseek(destination, (__off64_t )0, 2);
      }
#line 1012
      if (targetsize < 0L) {
#line 1012
        targetsize = (off_t )0;
      }
    }
#line 1014
    if (! targetsize) {
      {
#line 1015
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error determining destination file size, cannot resume!");
      }
    } else {
      {
#line 1017
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Current destination size: %llu\n",
              targetsize);
      }
    }
  } else {
    {
#line 1020
    destination = open((char const   *)destfile, 577, 438);
    }
#line 1021
    if (destination == -1) {
      {
#line 1022
      close(source);
      }
#line 1023
      if (excluding == 1) {
        {
#line 1023
        fclose(xblocksin);
        }
      }
      {
#line 1024
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening destination: %s",
              destfile);
#line 1025
      perror(" ");
      }
#line 1026
      if (human) {
        {
#line 1026
        usage(*(argv + 0));
        }
      }
      {
#line 1027
      arglist_kill(carglist);
      }
#line 1028
      return (2);
    }
  }
#line 1031
  if ((unsigned long )bblocksoutfile != (unsigned long )((void *)0)) {
    {
#line 1032
    bblocksout = open((char const   *)bblocksoutfile, 577, 438);
    }
#line 1033
    if (bblocksout == -1) {
      {
#line 1034
      close(source);
#line 1035
      close(destination);
      }
#line 1036
      if (incremental == 1) {
        {
#line 1036
        fclose(bblocksin);
        }
      }
#line 1037
      if (excluding == 1) {
        {
#line 1037
        fclose(xblocksin);
        }
      }
      {
#line 1038
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening badblock file for writing: %s",
              bblocksoutfile);
#line 1039
      perror(" ");
#line 1040
      arglist_kill(carglist);
      }
#line 1041
      return (2);
    }
  }
#line 1045
  timingfile = (FILE *)((void *)0);
#line 1046
  if ((unsigned long )timingfilestring != (unsigned long )((void *)0)) {
    {
#line 1047
    timingfile = fopen((char const   */* __restrict  */)timingfilestring, (char const   */* __restrict  */)"w");
    }
#line 1048
    if ((unsigned long )timingfile == (unsigned long )((void *)0)) {
      {
#line 1049
      close(source);
#line 1050
      close(destination);
      }
#line 1051
      if (incremental == 1) {
        {
#line 1051
        fclose(bblocksin);
        }
      }
#line 1052
      if (excluding == 1) {
        {
#line 1052
        fclose(xblocksin);
        }
      }
#line 1053
      if (bblocksout) {
        {
#line 1053
        close(bblocksout);
        }
      }
      {
#line 1054
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error opening timingfile for writing: %s",
              bblocksoutfile);
#line 1055
      perror(" ");
#line 1056
      arglist_kill(carglist);
      }
#line 1057
      return (2);
    }
  }
  {
#line 1064
  signal(2, & signalhandler);
#line 1067
  readposition = (off_t )0;
#line 1068
  writeposition = (off_t )0;
#line 1069
  block = (off_t )-1;
#line 1070
  remain = (off_t )0;
#line 1071
  writeremain = (off_t )0;
#line 1072
  softerr = (off_t )0;
#line 1073
  harderr = (off_t )0;
#line 1074
  counter = 1;
#line 1075
  newerror = retries;
#line 1077
  newsofterror = 0;
#line 1078
  lasterror = (off_t )0;
#line 1079
  lastgood = (off_t )0;
#line 1080
  lastmarked = (off_t )0;
#line 1081
  lastbadblock = (off_t )-1;
#line 1082
  lastxblock = (off_t )-1;
#line 1083
  previousxblock = (off_t )-1;
#line 1084
  lastsourceblock = (off_t )-1;
#line 1085
  damagesize = (off_t )0;
#line 1086
  backtracemode = 0;
#line 1087
  percent = -1;
#line 1088
  oldpercent = -1;
#line 1089
  oldelapsed = 0L;
#line 1090
  tmp___50 = timecategory(oldelapsed);
#line 1090
  oldcategory = (long )tmp___50;
#line 1092
  elapsed = 0L;
#line 1093
  output = 0;
#line 1094
  linewidth = 0;
#line 1095
  sposition = (off_t )0;
#line 1096
  seekable = 1;
#line 1097
  desperate = 0;
#line 1102
  cposition = lseek(source, startoffset, 0);
  }
#line 1103
  if (cposition < 0L) {
    {
#line 1104
    perror("Warning: Input file is not seekable ");
#line 1105
    seekable = 0;
#line 1106
    close(source);
#line 1107
    cposition = emergency_seek(startoffset, (off_t )0, blocksize, seekscriptfile);
    }
#line 1108
    if (cposition >= 0L) {
#line 1109
      sposition = cposition;
    }
    {
#line 1111
    source = open((char const   *)sourcefile, 2048 | syncmode);
    }
#line 1112
    if (source == -1) {
      {
#line 1113
      perror("Error reopening sourcefile after external seek ");
#line 1114
      close(destination);
      }
#line 1115
      if (incremental == 1) {
        {
#line 1115
        fclose(bblocksin);
        }
      }
#line 1116
      if (excluding == 1) {
        {
#line 1116
        fclose(xblocksin);
        }
      }
#line 1117
      if ((unsigned long )bblocksoutfile != (unsigned long )((void *)0)) {
        {
#line 1117
        close(bblocksout);
        }
      }
#line 1118
      if ((unsigned long )timingfile != (unsigned long )((void *)0)) {
        {
#line 1118
        fclose(timingfile);
        }
      }
      {
#line 1119
      arglist_kill(carglist);
      }
#line 1120
      return (2);
    }
    {
#line 1122
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"|/|");
    }
  } else {
#line 1124
    sposition = cposition;
#line 1125
    seekable = 1;
  }
  {
#line 1130
  fflush(stdout);
#line 1131
  fflush(stderr);
  }
  {
#line 1133
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1133
    if (! wantabort) {
#line 1133
      if (block != 0L) {
#line 1133
        if (! (readposition < length)) {
#line 1133
          if (! (length < 0L)) {
#line 1133
            goto while_break;
          }
        }
      } else {
#line 1133
        goto while_break;
      }
    } else {
#line 1133
      goto while_break;
    }
    {
#line 1137
    debug(1, (char *)"debug: start of cycle\n");
    }
#line 1139
    if (remain == 0L) {
      {
#line 1140
      debug(1, (char *)"debug: preparing to read a new block\n");
      }
#line 1144
      if (incremental) {
#line 1144
        if (newerror != 0) {
          {
#line 1145
          debug(16, (char *)"debug: incremental - searching next block\n");
#line 1150
          tmp_pos = (readposition + startoffset) / iblocksize;
          }
#line 1151
          if (tmp_pos != lastsourceblock) {
#line 1152
            tmp = textbuffer;
            {
#line 1153
            while (1) {
              while_continue___0: /* CIL Label */ ;
#line 1153
              if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 1153
                if (! (lastsourceblock < tmp_pos)) {
#line 1153
                  goto while_break___0;
                }
              } else {
#line 1153
                goto while_break___0;
              }
              {
#line 1154
              tmp = fgets((char */* __restrict  */)(textbuffer), 64, (FILE */* __restrict  */)bblocksin);
#line 1155
              tmp___51 = sscanf((char const   */* __restrict  */)(textbuffer), (char const   */* __restrict  */)"%llu",
                                & lastsourceblock);
              }
#line 1155
              if (tmp___51 != 1) {
#line 1155
                tmp = (char *)((void *)0);
              }
            }
            while_break___0: /* CIL Label */ ;
            }
#line 1157
            if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1160
              if (readposition + startoffset < targetsize) {
#line 1162
                lastsourceblock = targetsize / iblocksize;
              } else
#line 1163
              if (targetsize) {
#line 1164
                lastsourceblock = tmp_pos;
              } else {
#line 1167
                remain = (off_t )0;
#line 1168
                goto while_break;
              }
            }
            {
#line 1171
            debug(16, (char *)"debug: incremental - target is %llu position is %llu\n",
                  lastsourceblock, tmp_pos);
#line 1172
            readposition = lastsourceblock * iblocksize - startoffset;
            }
          } else {
            {
#line 1174
            debug(16, (char *)"debug: incremental - still in same block\n");
            }
          }
        }
      }
#line 1179
      if (newerror == 0) {
#line 1180
        remain = ((readposition / blocksize) * blocksize + faultblocksize) - readposition;
      } else {
#line 1182
        remain = ((readposition / blocksize) * blocksize + blocksize) - readposition;
      }
      {
#line 1184
      debug(1, (char *)"debug: prepared to read block %lli size %llu at %llu\n", (readposition + startoffset) / blocksize,
            remain, readposition + startoffset);
      }
    }
#line 1186
    if (excluding) {
#line 1186
      if (remain != 0L) {
        {
#line 1189
        debug(32, (char *)"debug: checking for exclude blocks at position %llu\n",
              readposition + startoffset);
        }
#line 1190
        if (readposition + startoffset < lastxblock * xblocksize) {
          {
#line 1191
          debug(32, (char *)"debug: possibly need backtracking in exclude list, next exclude block %lli\n",
                lastxblock);
          }
#line 1192
          if (readposition + startoffset < previousxblock * xblocksize) {
            {
#line 1195
            debug(32, (char *)"debug: reopening exclude file and reading from the start\n");
#line 1196
            fclose(xblocksin);
#line 1197
            xblocksin = fopen((char const   */* __restrict  */)xblocksinfile, (char const   */* __restrict  */)"r");
            }
#line 1198
            if ((unsigned long )xblocksin == (unsigned long )((void *)0)) {
              {
#line 1199
              excluding = 0;
#line 1200
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error reopening exclusion badblock file for reading: %s",
                      xblocksinfile);
#line 1201
              perror(" ");
#line 1202
              wantabort = 1;
              }
#line 1203
              goto while_break;
            }
#line 1205
            lastxblock = (off_t )-1;
#line 1206
            previousxblock = (off_t )-1;
          } else
#line 1207
          if ((previousxblock + 1L) * xblocksize > readposition + startoffset) {
            {
#line 1209
            lastxblock = previousxblock;
#line 1210
            debug(32, (char *)"debug: using last exclude block %lli\n", lastxblock);
            }
          } else {
            {
#line 1212
            debug(32, (char *)"debug: false alarm, current exclude block is fine\n");
            }
          }
        }
        {
#line 1215
        tmp_pos = lastxblock * xblocksize;
#line 1216
        debug(32, (char *)"debug: checking with xblock %lli at %llu\n", lastxblock,
              tmp_pos);
#line 1217
        tmp_bytes = (off_t )0;
        }
        {
#line 1218
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1218
          if (! (tmp_pos < (readposition + startoffset) + remain)) {
#line 1218
            goto while_break___1;
          }
#line 1219
          if (tmp_pos + xblocksize > readposition + startoffset) {
#line 1220
            if (tmp_pos <= readposition + startoffset) {
              {
#line 1222
              debug(32, (char *)"debug: skipping ahead to avoid exclude block\n");
#line 1223
              tmp_bytes = (off_t )1;
              }
#line 1224
              if (tmp_pos + xblocksize < (readposition + startoffset) + remain) {
                {
#line 1225
                remain = (tmp_pos + xblocksize) - (readposition + startoffset);
#line 1226
                debug(32, (char *)"debug: remain set to %llu\n", remain);
                }
              } else
#line 1228
              if (! backtracemode) {
#line 1229
                remain = (off_t )0;
              } else {
                {
#line 1231
                remain = (off_t )1;
#line 1232
                debug(32, (char *)"debug: remain set to %llu\n", remain);
                }
              }
#line 1235
              readposition = (tmp_pos + xblocksize) - startoffset;
#line 1236
              goto while_break___1;
            } else
#line 1237
            if (tmp_pos < (readposition + startoffset) + remain) {
              {
#line 1238
              debug(32, (char *)"debug: shrinking block size because of exclude block from %llu to %llu\n",
                    remain, tmp_pos - (readposition + startoffset));
#line 1239
              remain = tmp_pos - (readposition + startoffset);
              }
#line 1240
              goto while_break___1;
            } else {
#line 1243
              goto while_break___1;
            }
          } else {
            {
#line 1247
            debug(32, (char *)"debug: reading another exclude block\n");
#line 1248
            tmp = fgets((char */* __restrict  */)(textbuffer), 64, (FILE */* __restrict  */)xblocksin);
#line 1249
            tmp___52 = sscanf((char const   */* __restrict  */)(textbuffer), (char const   */* __restrict  */)"%llu",
                              & tmp_pos);
            }
#line 1249
            if (tmp___52 != 1) {
#line 1249
              tmp = (char *)((void *)0);
            }
#line 1250
            if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1252
              goto while_break___1;
            }
            {
#line 1254
            previousxblock = lastxblock;
#line 1255
            lastxblock = tmp_pos;
#line 1256
            tmp_pos = lastxblock * xblocksize;
#line 1257
            debug(32, (char *)"debug: reading another exclude block: %lli at %llu\n",
                  lastxblock, tmp_pos);
            }
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1260
        if (tmp_bytes == 1L) {
          {
#line 1261
          debug(32, (char *)"debug: recalculation needed because of exclude blocks, restarting cycle\n");
          }
#line 1262
          goto while_continue;
        }
      }
    }
    {
#line 1269
    gettimeofday((struct timeval */* __restrict  */)(& oldtime), (__timezone_ptr_t )((void *)0));
    }
#line 1271
    if (sposition != readposition + startoffset) {
      {
#line 1272
      debug(8, (char *)"debug: seeking in input from %llu to %llu\n", sposition, readposition + startoffset);
#line 1273
      cposition = lseek(source, readposition + startoffset, 0);
      }
#line 1274
      if (cposition > 0L) {
#line 1275
        sposition = cposition;
#line 1276
        seekable = 1;
      } else {
        {
#line 1279
        tmp___53 = __errno_location();
#line 1279
        errtmp = *tmp___53;
        }
#line 1280
        if (readposition + startoffset < filesize) {
          {
#line 1280
          tmp___54 = lowlevel_canseek();
          }
#line 1280
          if (tmp___54) {
#line 1280
            if (lowlevel == 2) {
#line 1283
              cposition = readposition + startoffset;
#line 1284
              sposition = cposition;
            } else
#line 1280
            if (lowlevel == 1) {
#line 1280
              if (desperate) {
#line 1283
                cposition = readposition + startoffset;
#line 1284
                sposition = cposition;
              } else {
#line 1280
                goto _L___4;
              }
            } else {
#line 1280
              goto _L___4;
            }
          } else {
#line 1280
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 1285
        if (errtmp == 22) {
#line 1285
          if (seekable == 1) {
#line 1287
            goto while_break;
          } else {
#line 1285
            goto _L___2;
          }
        } else {
          _L___2: /* CIL Label */ 
#line 1290
          if (seekable) {
            {
#line 1291
            write(1, (void const   *)"|/|", (size_t )3);
#line 1292
            seekable = 0;
            }
          }
#line 1294
          if (readposition + startoffset > sposition) {
            {
#line 1297
            close(source);
#line 1298
            cposition = emergency_seek(startoffset + readposition, sposition, blocksize,
                                       seekscriptfile);
            }
#line 1299
            if (cposition < 0L) {
#line 1299
              if (newerror == 0) {
                {
#line 1301
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError: Unable to skip over bad area.\n");
                }
#line 1302
                goto while_break;
              }
            }
            {
#line 1305
            source = open((char const   *)sourcefile, 2048 | syncmode);
            }
#line 1306
            if (source == -1) {
              {
#line 1307
              perror("\nError reopening sourcefile after external seek ");
#line 1308
              close(destination);
              }
#line 1309
              if (incremental == 1) {
                {
#line 1309
                fclose(bblocksin);
                }
              }
#line 1310
              if (excluding == 1) {
                {
#line 1310
                fclose(xblocksin);
                }
              }
#line 1311
              if ((unsigned long )bblocksoutfile != (unsigned long )((void *)0)) {
                {
#line 1311
                close(bblocksout);
                }
              }
#line 1312
              if ((unsigned long )timingfile != (unsigned long )((void *)0)) {
                {
#line 1312
                fclose(timingfile);
                }
              }
              {
#line 1313
              arglist_kill(carglist);
              }
#line 1314
              return (2);
            }
#line 1316
            if (cposition >= 0L) {
#line 1317
              sposition = cposition;
            }
          }
        }
      }
    }
#line 1324
    if (sposition > startoffset) {
#line 1325
      readposition = sposition - startoffset;
    } else {
#line 1327
      readposition = (off_t )0;
    }
#line 1330
    if (length >= 0L) {
#line 1331
      if (readposition >= length) {
#line 1331
        readposition = length;
      }
#line 1332
      if (readposition + remain >= length) {
#line 1332
        remain = length - readposition;
      }
    }
#line 1335
    writeposition = readposition;
#line 1336
    if (filesize > startoffset) {
#line 1337
      percent = (int )((100L * readposition) / (filesize - startoffset));
    }
    {
#line 1343
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1344
      newtime.tv_sec = (__time_t )10;
#line 1345
      newtime.tv_usec = (__suseconds_t )0;
      {
#line 1346
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 1346
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& rfds.fds_bits[0]): "memory");
#line 1346
        goto while_break___3;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
#line 1347
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 1347
        __asm__  volatile   ("cld; rep; "
                             "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                             "1" (& efds.fds_bits[0]): "memory");
#line 1347
        goto while_break___4;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
#line 1348
      rfds.fds_bits[source / (8 * (int )sizeof(__fd_mask ))] |= 1L << source % (8 * (int )sizeof(__fd_mask ));
#line 1349
      efds.fds_bits[source / (8 * (int )sizeof(__fd_mask ))] |= 1L << source % (8 * (int )sizeof(__fd_mask ));
#line 1350
      select(source + 1, (fd_set */* __restrict  */)(& rfds), (fd_set */* __restrict  */)((void *)0),
             (fd_set */* __restrict  */)(& efds), (struct timeval */* __restrict  */)(& newtime));
      }
#line 1351
      if (! ((rfds.fds_bits[source / (8 * (int )sizeof(__fd_mask ))] & (1L << source % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 1352
        desperate = 1;
#line 1353
        if (human) {
#line 1354
          if (filesize) {
            {
#line 1355
            printpercentage(percent);
            }
          }
          {
#line 1357
          printtimecategory(10000000);
          }
        }
      }
#line 1360
      if (wantabort) {
#line 1360
        goto while_break___2;
      }
#line 1343
      if ((rfds.fds_bits[source / (8 * (int )sizeof(__fd_mask ))] & (1L << source % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1343
        goto while_break___2;
      } else
#line 1343
      if ((efds.fds_bits[source / (8 * (int )sizeof(__fd_mask ))] & (1L << source % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 1343
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1362
    if (wantabort) {
#line 1362
      goto while_break;
    }
#line 1367
    maxremain = remain;
#line 1368
    if (maxremain > blocksize) {
#line 1368
      maxremain = blocksize;
    }
#line 1369
    if (lowlevel == 0) {
      {
#line 1370
      debug(2, (char *)"debug: normal read\n");
#line 1371
      block = read(source, (void *)databuffer, (size_t )maxremain);
      }
    } else
#line 1369
    if (lowlevel == 1) {
#line 1369
      if (! desperate) {
        {
#line 1370
        debug(2, (char *)"debug: normal read\n");
#line 1371
        block = read(source, (void *)databuffer, (size_t )maxremain);
        }
      } else {
        {
#line 1375
        debug(2, (char *)"debug: low level read\n");
#line 1376
        tmp___55 = (int )read_desperately(sourcefile, & source, databuffer, sposition,
                                          maxremain, seekable, desperate, syncmode);
#line 1376
        block = (off_t )tmp___55;
        }
      }
    } else {
      {
#line 1375
      debug(2, (char *)"debug: low level read\n");
#line 1376
      tmp___55 = (int )read_desperately(sourcefile, & source, databuffer, sposition,
                                        maxremain, seekable, desperate, syncmode);
#line 1376
      block = (off_t )tmp___55;
      }
    }
    {
#line 1379
    gettimeofday((struct timeval */* __restrict  */)(& newtime), (__timezone_ptr_t )((void *)0));
#line 1380
    elapsed = timediff(oldtime, newtime);
    }
#line 1381
    if (timingfile) {
      {
#line 1382
      fprintf((FILE */* __restrict  */)timingfile, (char const   */* __restrict  */)"%010llu %lu %lli\n",
              sposition / blocksize, elapsed, block);
      }
    }
    {
#line 1388
    tmp___58 = timecategory(elapsed);
#line 1388
    tmp___59 = timecategory(oldelapsed);
    }
#line 1388
    if (tmp___58 > tmp___59) {
#line 1389
      oldelapsed = (9L * oldelapsed + elapsed) / 10L;
    } else {
      {
#line 1390
      tmp___56 = timecategory(elapsed);
#line 1390
      tmp___57 = timecategory(oldelapsed);
      }
#line 1390
      if (tmp___56 < tmp___57) {
#line 1391
        oldelapsed = (99L * oldelapsed + elapsed) / 100L;
      }
    }
#line 1394
    if (filesize) {
#line 1394
      if (percent != oldpercent) {
#line 1394
        goto _L___5;
      } else
#line 1394
      if (output) {
        _L___5: /* CIL Label */ 
#line 1395
        if (human) {
          {
#line 1396
          printpercentage(percent);
#line 1397
          tmp___60 = timecategory(oldelapsed);
#line 1397
          printtimecategory(tmp___60);
          }
        }
#line 1399
        oldpercent = percent;
      }
    }
    {
#line 1402
    tmp___64 = timecategory(oldelapsed);
    }
#line 1402
    if ((long )tmp___64 != oldcategory) {
#line 1403
      if (human) {
#line 1404
        if (filesize) {
          {
#line 1404
          printpercentage(percent);
          }
        }
        {
#line 1405
        tmp___61 = timecategory(oldelapsed);
#line 1405
        printtimecategory(tmp___61);
        }
      }
      {
#line 1407
      tmp___62 = timecategory(oldelapsed);
#line 1407
      oldcategory = (long )tmp___62;
      }
    } else
#line 1408
    if (output) {
#line 1408
      if (human) {
#line 1410
        if (filesize) {
          {
#line 1410
          printpercentage(percent);
          }
        }
        {
#line 1411
        tmp___63 = timecategory(oldelapsed);
#line 1411
        printtimecategory(tmp___63);
        }
      }
    }
#line 1414
    if (linewidth > 40) {
#line 1415
      if (human) {
        {
#line 1416
        tmp_pos = readposition / blocksize;
#line 1417
        sprintf((char */* __restrict  */)(textbuffer), (char const   */* __restrict  */)" [%lli]    \n",
                tmp_pos);
#line 1418
        tmp___65 = strlen((char const   *)(textbuffer));
#line 1418
        write(2, (void const   *)(textbuffer), tmp___65);
        }
      }
#line 1420
      linewidth = 0;
    }
#line 1422
    output = 0;
#line 1426
    if (block > 0L) {
      {
#line 1427
      debug(2, (char *)"debug: successful read\n");
#line 1428
      sposition += block;
      }
#line 1431
      if (newsofterror == 1) {
#line 1432
        newsofterror = 0;
#line 1433
        softerr ++;
      }
#line 1436
      if (newerror == 0) {
#line 1441
        if (remain > resolution) {
#line 1441
          if (seekable) {
            {
#line 1442
            remain /= 2L;
#line 1443
            readposition -= remain;
#line 1444
            write(1, (void const   *)"<", (size_t )1);
#line 1445
            output = 1;
#line 1446
            linewidth ++;
#line 1447
            backtracemode = 1;
#line 1448
            debug(1, (char *)"debug: shrinking remain to %llu\n", remain);
            }
          } else {
#line 1441
            goto _L___6;
          }
        } else {
          _L___6: /* CIL Label */ 
          {
#line 1450
          newerror = retries;
#line 1451
          remain = (off_t )0;
#line 1452
          tmp_pos = readposition / blocksize;
#line 1453
          tmp_bytes = readposition - lastgood;
#line 1454
          damagesize += tmp_bytes;
#line 1455
          sprintf((char */* __restrict  */)(textbuffer), (char const   */* __restrict  */)"}[%llu](+%llu)",
                  tmp_pos, tmp_bytes);
#line 1456
          tmp___66 = strlen((char const   *)(textbuffer));
#line 1456
          write(1, (void const   *)(textbuffer), tmp___66);
          }
#line 1457
          if (human) {
            {
#line 1457
            write(2, (void const   *)"\n", (size_t )1);
            }
          }
          {
#line 1458
          output = 1;
#line 1459
          linewidth = 0;
#line 1460
          backtracemode = 0;
#line 1461
          markoutput((char *)"end of bad area", readposition, lasterror, startoffset,
                     blocksize, targetsize, & lastbadblock, & lastmarked, marker,
                     databuffer, textbuffer, incremental, bblocksin, iblocksize, & lastsourceblock,
                     bblocksout, bblocksoutfile, destination, xblocksinfile, & xblocksin,
                     & lastxblock, & previousxblock, xblocksize, excluding);
#line 1462
          lasterror = readposition;
          }
        }
      } else {
#line 1468
        desperate = 0;
#line 1469
        newerror = retries;
#line 1470
        if (block < remain) {
          {
#line 1472
          write(1, (void const   *)"_", (size_t )1);
#line 1473
          output = 1;
#line 1474
          linewidth ++;
#line 1475
          counter = 1;
          }
        } else {
#line 1476
          counter --;
#line 1476
          if (counter <= 0) {
            {
#line 1477
            write(1, (void const   *)".", (size_t )1);
#line 1478
            output = 1;
#line 1479
            linewidth ++;
#line 1480
            counter = 1024;
            }
          }
        }
#line 1483
        remain -= block;
#line 1484
        readposition += block;
#line 1485
        writeremain = block;
#line 1486
        writeoffset = (off_t )0;
#line 1487
        if (sposition < startoffset) {
#line 1489
          if (sposition + block <= startoffset) {
#line 1491
            writeremain = (off_t )0;
          } else {
#line 1494
            writeremain = (sposition + block) - startoffset;
#line 1495
            writeoffset = startoffset - sposition;
          }
        }
        {
#line 1498
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1498
          if (! (writeremain > 0L)) {
#line 1498
            goto while_break___5;
          }
          {
#line 1500
          debug(8, (char *)"debug: seek in destination file: %llu\n", writeposition);
#line 1501
          cposition = lseek(destination, writeposition, 0);
          }
#line 1502
          if (cposition < 0L) {
            {
#line 1503
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError: seek() in %s failed",
                    destfile);
#line 1504
            perror(" ");
#line 1505
            close(destination);
#line 1506
            close(source);
            }
#line 1507
            if (incremental == 1) {
              {
#line 1507
              fclose(bblocksin);
              }
            }
#line 1508
            if (excluding == 1) {
              {
#line 1508
              fclose(xblocksin);
              }
            }
#line 1509
            if ((unsigned long )bblocksoutfile != (unsigned long )((void *)0)) {
              {
#line 1509
              close(bblocksout);
              }
            }
#line 1510
            if ((unsigned long )timingfile != (unsigned long )((void *)0)) {
              {
#line 1510
              fclose(timingfile);
              }
            }
            {
#line 1511
            arglist_kill(carglist);
            }
#line 1512
            return (2);
          }
          {
#line 1514
          debug(2, (char *)"debug: writing data to destination file: %llu bytes at %llu\n",
                writeremain, cposition);
#line 1515
          writeblock = write(destination, (void const   *)(databuffer + writeoffset),
                             (size_t )writeremain);
          }
#line 1516
          if (writeblock <= 0L) {
            {
#line 1517
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\nError: write to %s failed",
                    destfile);
#line 1518
            perror(" ");
#line 1519
            close(destination);
#line 1520
            close(source);
            }
#line 1521
            if (incremental == 1) {
              {
#line 1521
              fclose(bblocksin);
              }
            }
#line 1522
            if (excluding == 1) {
              {
#line 1522
              fclose(xblocksin);
              }
            }
#line 1523
            if ((unsigned long )bblocksoutfile != (unsigned long )((void *)0)) {
              {
#line 1523
              close(bblocksout);
              }
            }
#line 1524
            if ((unsigned long )timingfile != (unsigned long )((void *)0)) {
              {
#line 1524
              fclose(timingfile);
              }
            }
            {
#line 1525
            arglist_kill(carglist);
            }
#line 1526
            return (2);
          }
#line 1528
          writeremain -= writeblock;
#line 1529
          writeoffset += writeblock;
#line 1530
          writeposition += writeblock;
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    } else
#line 1533
    if (block < 0L) {
      {
#line 1535
      tmp___67 = __errno_location();
#line 1535
      tmp___68 = strerror(*tmp___67);
#line 1535
      debug(2, (char *)"debug: read failed: %s\n", tmp___68);
#line 1537
      counter = 1;
#line 1539
      desperate = 1;
      }
#line 1541
      if (remain > resolution) {
#line 1541
        if (newerror > 0) {
          {
#line 1544
          newsofterror = 1;
#line 1545
          remain /= 2L;
#line 1546
          write(1, (void const   *)">", (size_t )1);
#line 1547
          linewidth ++;
#line 1548
          output = 1;
          }
        } else {
#line 1541
          goto _L___7;
        }
      } else
      _L___7: /* CIL Label */ 
#line 1550
      if (newerror > 1) {
        {
#line 1552
        newsofterror = 1;
#line 1553
        newerror --;
#line 1554
        write(1, (void const   *)"!", (size_t )1);
#line 1555
        linewidth ++;
#line 1556
        output = 1;
        }
      } else {
#line 1562
        if (newerror == 1) {
          {
#line 1565
          newsofterror = 0;
#line 1566
          newerror = 0;
#line 1567
          tmp_pos = readposition / blocksize;
#line 1568
          tmp_bytes = readposition - lasterror;
#line 1569
          sprintf((char */* __restrict  */)(textbuffer), (char const   */* __restrict  */)"[%llu](+%llu){",
                  tmp_pos, tmp_bytes);
#line 1570
          tmp___69 = strlen((char const   *)(textbuffer));
#line 1570
          write(1, (void const   *)(textbuffer), tmp___69);
#line 1571
          output = 1;
#line 1572
          tmp___70 = strlen((char const   *)(textbuffer));
#line 1572
          linewidth = (int )((size_t )linewidth + tmp___70);
#line 1575
          remain = ((readposition / blocksize) * blocksize + faultblocksize) - readposition;
#line 1576
          lastgood = readposition;
          }
        }
#line 1579
        if (! backtracemode) {
          {
#line 1580
          harderr ++;
#line 1581
          write(1, (void const   *)"X", (size_t )1);
#line 1582
          output = 1;
#line 1583
          linewidth ++;
          }
#line 1584
          if (lasterror > lastgood) {
#line 1584
            tmp___71 = lasterror;
          } else {
#line 1584
            tmp___71 = lastgood;
          }
          {
#line 1584
          markoutput((char *)"continuous bad area", readposition, tmp___71, startoffset,
                     blocksize, targetsize, & lastbadblock, & lastmarked, marker,
                     databuffer, textbuffer, incremental, bblocksin, iblocksize, & lastsourceblock,
                     bblocksout, bblocksoutfile, destination, xblocksinfile, & xblocksin,
                     & lastxblock, & previousxblock, xblocksize, excluding);
#line 1585
          lasterror = readposition;
          }
        }
#line 1589
        readposition += remain;
#line 1590
        if (! backtracemode) {
#line 1594
          remain = (off_t )0;
        } else {
          {
#line 1596
          debug(1, (char *)"debug: bad block during backtrace - remain is %llu at %llu\n",
                remain, readposition + startoffset);
          }
        }
      }
      {
#line 1605
      close(source);
#line 1607
      cseeks = 0;
      }
      {
#line 1607
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1607
        if (! (cseeks < seeks)) {
#line 1607
          goto while_break___6;
        }
        {
#line 1608
        debug(8, (char *)"debug: forced head realignment\n");
#line 1610
        source = open((char const   *)sourcefile, 1052672);
        }
#line 1611
        if (source) {
          {
#line 1612
          lseek(source, (__off64_t )0, 0);
#line 1613
          read(source, (void *)databuffer, (size_t )blocksize);
#line 1614
          close(source);
          }
        }
        {
#line 1616
        source = open((char const   *)sourcefile, 1052672);
        }
#line 1617
        if (source) {
          {
#line 1618
          lseek(source, - blocksize, 2);
#line 1619
          read(source, (void *)databuffer, (size_t )blocksize);
#line 1620
          close(source);
          }
        }
#line 1622
        if (wantabort) {
#line 1622
          goto while_break___6;
        }
#line 1607
        cseeks ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 1624
      source = open((char const   *)sourcefile, 2048 | syncmode);
      }
#line 1625
      if (source == -1) {
        {
#line 1626
        perror("\nError reopening sourcefile after read error ");
#line 1627
        close(destination);
        }
#line 1628
        if (incremental == 1) {
          {
#line 1628
          fclose(bblocksin);
          }
        }
#line 1629
        if (excluding == 1) {
          {
#line 1629
          fclose(xblocksin);
          }
        }
#line 1630
        if ((unsigned long )bblocksoutfile != (unsigned long )((void *)0)) {
          {
#line 1630
          close(bblocksout);
          }
        }
#line 1631
        if ((unsigned long )timingfile != (unsigned long )((void *)0)) {
          {
#line 1631
          fclose(timingfile);
          }
        }
        {
#line 1632
        arglist_kill(carglist);
        }
#line 1633
        return (2);
      }
#line 1635
      if (seekable) {
#line 1638
        sposition = (off_t )0;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1645
  debug(1, (char *)"debug: main loop ended\n");
#line 1646
  fflush(stdout);
#line 1647
  fflush(stderr);
  }
#line 1648
  if (newerror == 0) {
    {
#line 1650
    tmp_pos = readposition / blocksize;
#line 1651
    tmp_bytes = readposition - lastgood;
#line 1652
    damagesize += tmp_bytes;
#line 1653
    sprintf((char */* __restrict  */)(textbuffer), (char const   */* __restrict  */)"}[%llu](+%llu)",
            tmp_pos, tmp_bytes);
#line 1654
    tmp___72 = strlen((char const   *)(textbuffer));
#line 1654
    write(1, (void const   *)(textbuffer), tmp___72);
    }
#line 1655
    if (human) {
      {
#line 1655
      write(2, (void const   *)"\n", (size_t )1);
      }
    }
#line 1657
    if (filesize) {
#line 1657
      if (lastgood + startoffset < filesize) {
#line 1657
        if (readposition + startoffset >= filesize) {
          {
#line 1658
          markoutput((char *)"end of file - filling to filesize", filesize, lastgood,
                     startoffset, blocksize, targetsize, & lastbadblock, & lastmarked,
                     marker, databuffer, textbuffer, incremental, bblocksin, iblocksize,
                     & lastsourceblock, bblocksout, bblocksoutfile, destination, xblocksinfile,
                     & xblocksin, & lastxblock, & previousxblock, xblocksize, excluding);
          }
        } else {
          {
#line 1660
          markoutput((char *)"end of file - filling to last seen position", readposition + startoffset,
                     lastgood, startoffset, blocksize, targetsize, & lastbadblock,
                     & lastmarked, marker, databuffer, textbuffer, incremental, bblocksin,
                     iblocksize, & lastsourceblock, bblocksout, bblocksoutfile, destination,
                     xblocksinfile, & xblocksin, & lastxblock, & previousxblock, xblocksize,
                     excluding);
          }
        }
      } else {
        {
#line 1660
        markoutput((char *)"end of file - filling to last seen position", readposition + startoffset,
                   lastgood, startoffset, blocksize, targetsize, & lastbadblock, & lastmarked,
                   marker, databuffer, textbuffer, incremental, bblocksin, iblocksize,
                   & lastsourceblock, bblocksout, bblocksoutfile, destination, xblocksinfile,
                   & xblocksin, & lastxblock, & previousxblock, xblocksize, excluding);
        }
      }
    } else {
      {
#line 1660
      markoutput((char *)"end of file - filling to last seen position", readposition + startoffset,
                 lastgood, startoffset, blocksize, targetsize, & lastbadblock, & lastmarked,
                 marker, databuffer, textbuffer, incremental, bblocksin, iblocksize,
                 & lastsourceblock, bblocksout, bblocksoutfile, destination, xblocksinfile,
                 & xblocksin, & lastxblock, & previousxblock, xblocksize, excluding);
      }
    }
  }
#line 1663
  if (wantabort) {
    {
#line 1664
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nAborted!\n");
    }
  } else {
    {
#line 1666
    fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"\nDone!\n");
    }
  }
  {
#line 1668
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Recovered bad blocks: %llu\n",
          softerr);
#line 1669
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Unrecoverable bad blocks (bytes): %llu (%llu)\n",
          harderr, damagesize);
#line 1670
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Blocks (bytes) copied: %llu (%llu)\n",
          writeposition / blocksize, writeposition);
#line 1672
  close(destination);
#line 1673
  close(source);
  }
#line 1674
  if (incremental == 1) {
    {
#line 1674
    fclose(bblocksin);
    }
  }
#line 1675
  if (excluding == 1) {
    {
#line 1675
    fclose(xblocksin);
    }
  }
#line 1676
  if ((unsigned long )bblocksoutfile != (unsigned long )((void *)0)) {
    {
#line 1676
    close(bblocksout);
    }
  }
#line 1677
  if ((unsigned long )timingfile != (unsigned long )((void *)0)) {
    {
#line 1677
    fclose(timingfile);
    }
  }
  {
#line 1678
  arglist_kill(carglist);
  }
#line 1679
  return (0);
}
}
