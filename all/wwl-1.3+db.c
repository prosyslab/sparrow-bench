/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 46 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
struct location {
   double latitude ;
   double longitude ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 60 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 63
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 153
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) pow)(double __x ,
                                                                             double __y ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
char volatile   *rcs  =    (char volatile   *)"$Id: wwl.c,v 1.12 2007/10/15 19:53:08 db Exp db $";
#line 51
static int is_valid_locator(char const   *wwl ) ;
#line 52
static struct location convert_locator(char *wwl ) ;
#line 53
static void upstring(char *s ) ;
#line 54
static void bearing_dist(struct location *my_location , struct location *dx_location ,
                         int *dist , int *bearing ) ;
#line 56
static double rad_to_deg(double radians ) ;
#line 57
static double deg_to_rad(double degrees ) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
static int locator  =    0;
#line 61 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
int main(int argc , char **argv ) 
{ 
  int l ;
  int p ;
  struct location my_location ;
  struct location dx_location ;
  char my_wwl[9] ;
  char dx_wwl[9] ;
  int tmp ;
  double tmp___0 ;
  int tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 68
  if (argc < 2) {
    {
#line 69
    printf((char const   */* __restrict  */)"wwl by va3db 1.0\n");
#line 70
    printf((char const   */* __restrict  */)"wwl home_locator dx_locator\n");
#line 71
    exit(1);
    }
  }
#line 74
  if (argc != 3) {
    {
#line 75
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: wwl home_locator dx_locator\n");
#line 77
    exit(1);
    }
  }
  {
#line 80
  snprintf((char */* __restrict  */)(my_wwl), sizeof(my_wwl), (char const   */* __restrict  */)"%sAA",
           *(argv + 1));
#line 81
  my_wwl[6] = (char )'\000';
#line 82
  my_location = convert_locator(my_wwl);
#line 83
  tmp = is_valid_locator((char const   *)(my_wwl));
  }
#line 83
  if (! tmp) {
    {
#line 84
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: not a valid locator\n",
            my_wwl);
#line 85
    exit(1);
    }
  }
#line 88
  if (locator) {
    {
#line 89
    printf((char const   */* __restrict  */)"Locator    : %s\n", my_wwl);
#line 90
    tmp___0 = rad_to_deg(my_location.latitude);
    }
#line 90
    if (my_location.latitude > 0.) {
#line 90
      tmp___1 = 'N';
    } else {
#line 90
      tmp___1 = 'S';
    }
    {
#line 90
    tmp___2 = rad_to_deg(my_location.longitude);
    }
#line 90
    if (my_location.longitude < 0.) {
#line 90
      tmp___3 = 'W';
    } else {
#line 90
      tmp___3 = 'E';
    }
    {
#line 90
    printf((char const   */* __restrict  */)"Coordinates: Long: (%c) %.2f Lat : (%c) %.4f\n",
           tmp___3, tmp___2, tmp___1, tmp___0);
#line 95
    exit(0);
    }
  }
  {
#line 98
  snprintf((char */* __restrict  */)(dx_wwl), sizeof(dx_wwl), (char const   */* __restrict  */)"%sAA",
           *(argv + 2));
#line 99
  dx_wwl[6] = (char )'\000';
#line 100
  dx_location = convert_locator(dx_wwl);
#line 101
  tmp___4 = is_valid_locator((char const   *)(dx_wwl));
  }
#line 101
  if (! tmp___4) {
    {
#line 102
    printf((char const   */* __restrict  */)"%s: not a valid locator\n", dx_wwl);
#line 103
    exit(1);
    }
  }
  {
#line 106
  bearing_dist(& my_location, & dx_location, & p, & l);
#line 107
  printf((char const   */* __restrict  */)"qrb: %d kilometers, azimuth: %d degrees\n",
         p, l);
#line 109
  exit(0);
  }
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
static int is_valid_locator(char const   *wwl ) 
{ 
  size_t tmp ;

  {
  {
#line 124
  tmp = strlen(wwl);
  }
#line 124
  if (tmp != 6UL) {
#line 125
    return (0);
  }
#line 127
  if ((int const   )*(wwl + 0) < 65) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 0) > 82) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 1) < 65) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 1) > 82) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 2) < 48) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 2) > 57) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 3) < 48) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 3) > 57) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 4) < 65) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 4) > 88) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 5) < 65) {
#line 133
    return (0);
  } else
#line 127
  if ((int const   )*(wwl + 5) > 88) {
#line 133
    return (0);
  } else {
#line 135
    return (1);
  }
}
}
#line 146 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
static struct location convert_locator(char *wwl ) 
{ 
  struct location loc ;

  {
  {
#line 150
  upstring(wwl);
#line 152
  loc.latitude = ((((double )((int )*(wwl + 1) - 65) * (double )10 - (double )90) + (double )((int )*(wwl + 3) - 48)) + (double )((int )*(wwl + 5) - 65) / (double )24) + (double )0;
#line 154
  loc.latitude = deg_to_rad(loc.latitude);
#line 155
  loc.longitude = ((((double )((int )*(wwl + 0) - 65) * 20. - 180.) + (double )((int )*(wwl + 2) - 48) * (double )2) + (double )((int )*(wwl + 4) - 65) / (double )12) + (double )0;
#line 158
  loc.longitude = deg_to_rad(loc.longitude);
  }
#line 159
  return (loc);
}
}
#line 168 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
static void upstring(char *s ) 
{ 
  int tmp ;

  {
  {
#line 171
  while (1) {
    while_continue: /* CIL Label */ ;
#line 171
    if (! ((int )*s != 0)) {
#line 171
      goto while_break;
    }
    {
#line 172
    tmp = toupper((int )*s);
#line 172
    *s = (char )tmp;
#line 173
    s ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 175
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
static double deg_to_rad(double degrees ) 
{ 


  {
#line 187
  return ((degrees / 180.) * 3.14159265358979323846);
}
}
#line 197 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
static double rad_to_deg(double radians ) 
{ 


  {
#line 200
  return ((radians / 3.14159265358979323846) * 180.);
}
}
#line 215 "/home/june/repo/benchmarks/collector2/temp/wwl-1.3+db/wwl.c"
static void bearing_dist(struct location *my_location , struct location *dx_location ,
                         int *dist , int *bearing ) 
{ 
  double co ;
  double he ;
  double e ;
  double hn ;
  double n ;
  double ca ;
  double az ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;
  double tmp___8 ;
  double tmp___9 ;
  double tmp___10 ;
  double tmp___11 ;
  double tmp___12 ;

  {
  {
#line 221
  hn = my_location->latitude;
#line 222
  he = my_location->longitude;
#line 223
  n = dx_location->latitude;
#line 224
  e = dx_location->longitude;
#line 226
  tmp = cos(he - e);
#line 226
  tmp___0 = cos(hn);
#line 226
  tmp___1 = cos(n);
#line 226
  tmp___2 = sin(hn);
#line 226
  tmp___3 = sin(n);
#line 226
  co = (tmp * tmp___0) * tmp___1 + tmp___2 * tmp___3;
#line 227
  tmp___4 = pow(co, (double )2);
#line 227
  tmp___5 = sqrt((double )1 - tmp___4);
#line 227
  ca = atan2(tmp___5, co);
#line 228
  tmp___6 = sin(n);
#line 228
  tmp___7 = sin(hn);
#line 228
  tmp___8 = cos(ca);
#line 228
  tmp___9 = sin(e - he);
#line 228
  tmp___10 = cos(n);
#line 228
  tmp___11 = cos(hn);
#line 228
  az = atan2((tmp___9 * tmp___10) * tmp___11, tmp___6 - tmp___7 * tmp___8);
  }
#line 229
  if (az < (double )0) {
#line 230
    az += (double )2 * 3.14159265358979323846;
  }
  {
#line 233
  tmp___12 = rad_to_deg(az);
#line 233
  *bearing = (int )((double )((int )(tmp___12 * 10. + (double )5)) / (double )10);
#line 235
  *dist = (int )((double )((int )((6371.33 * ca) * 10. + (double )5)) / (double )10);
  }
#line 236
  return;
}
}
