/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 213 "/usr/lib/gcc-lib/i486-linux/3.3.5/include/stddef.h"
typedef unsigned int size_t;
#line 143 "/usr/include/bits/types.h"
typedef long __off_t;
#line 144 "/usr/include/bits/types.h"
typedef long long __off64_t;
#line 46 "/usr/include/stdio.h"
struct _IO_FILE;
#line 46 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 173 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 179 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 264 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   int _mode ;
   char _unused2[15UL * sizeof(int ) - 2UL * sizeof(void *)] ;
};
#line 328 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 206 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Exp_struct;
#line 206 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Exp_struct Exp;
#line 226
struct E_list_struct;
#line 226 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct E_list_struct E_list;
#line 228 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
union __anonunion_u_19 {
   E_list *l ;
   char *string ;
};
#line 228 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Exp_struct {
   char type ;
   unsigned char cost ;
   char dir ;
   char multi ;
   union __anonunion_u_19 u ;
};
#line 240 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct E_list_struct {
   E_list *next ;
   Exp *e ;
};
#line 252
struct Word_file_struct;
#line 252 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Word_file_struct Word_file;
#line 253 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Word_file_struct {
   char file[60] ;
   int changed ;
   Word_file *next ;
};
#line 263
struct Dict_node_struct;
#line 263 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Dict_node_struct Dict_node;
#line 264 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Dict_node_struct {
   char *string ;
   Word_file *file ;
   Exp *exp ;
   Dict_node *left ;
   Dict_node *right ;
};
#line 24 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
typedef unsigned int SIZET;
#line 25 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
struct __anonstruct_Nuggie_20 {
   SIZET size ;
};
#line 25 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
typedef struct __anonstruct_Nuggie_20 Nuggie;
#line 58 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
typedef double Align;
#line 172 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Connector_struct;
#line 172 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Connector_struct Connector;
#line 173 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Connector_struct {
   short label ;
   short word ;
   char priority ;
   char multi ;
   Connector *next ;
   char *string ;
};
#line 184
struct Disjunct_struct;
#line 184 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Disjunct_struct Disjunct;
#line 185 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Disjunct_struct {
   Disjunct *next ;
   short cost ;
   char marked ;
   char *string ;
   Connector *left ;
   Connector *right ;
};
#line 207
struct X_node_struct;
#line 207 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct X_node_struct X_node;
#line 208 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct X_node_struct {
   char *string ;
   Exp *exp ;
   X_node *next ;
};
#line 152 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
struct string_node_struct;
#line 152 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
typedef struct string_node_struct String_node;
#line 153 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
struct string_node_struct {
   char *string ;
   int size ;
   String_node *next ;
};
#line 214 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Word_struct;
#line 214 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Word_struct Word;
#line 215 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Word_struct {
   char string[60] ;
   X_node *x ;
   Disjunct *d ;
};
#line 934 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
struct c_list_struct;
#line 934 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
typedef struct c_list_struct C_list;
#line 935 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
struct c_list_struct {
   Connector *c ;
   int shallow ;
   C_list *next ;
};
#line 193 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Link_struct;
#line 193 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Link_struct Link;
#line 194 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Link_struct {
   int l ;
   int r ;
   Connector *lc ;
   Connector *rc ;
   char *name ;
};
#line 272
struct Violation_list_struct;
#line 272 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Violation_list_struct Violation_list;
#line 273 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Violation_list_struct {
   Violation_list *next ;
   char *string ;
};
#line 278
struct D_type_list_struct;
#line 278 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct D_type_list_struct D_type_list;
#line 279 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct D_type_list_struct {
   D_type_list *next ;
   int type ;
};
#line 284
struct PP_node_struct;
#line 284 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct PP_node_struct PP_node;
#line 285 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct PP_node_struct {
   D_type_list **d_type_array ;
   Violation_list *v ;
};
#line 299
struct List_o_links_struct;
#line 299 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct List_o_links_struct List_o_links;
#line 300 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct List_o_links_struct {
   int link ;
   int word ;
   int dir ;
   List_o_links *next ;
};
#line 116 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
struct connector_domain_name_pair_struct;
#line 116 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
typedef struct connector_domain_name_pair_struct CDNP;
#line 117 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
struct connector_domain_name_pair_struct {
   char *string ;
   int n ;
};
#line 200
struct d_tree_leaf_struct;
#line 200 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
typedef struct d_tree_leaf_struct D_tree_leaf;
#line 201
struct domain_struct;
#line 201 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
typedef struct domain_struct Domain;
#line 202 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
struct domain_struct {
   char *string ;
   int size ;
   List_o_links *lol ;
   int start_link ;
   int type ;
   D_tree_leaf *child ;
   Domain *parent ;
};
#line 212 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
struct d_tree_leaf_struct {
   Domain *parent ;
   int link ;
   D_tree_leaf *next ;
};
#line 200 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Match_node_struct;
#line 200 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Match_node_struct Match_node;
#line 201 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Match_node_struct {
   Match_node *next ;
   Disjunct *d ;
};
#line 129 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
struct Table_connector;
#line 129 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
typedef struct Table_connector Table_connector;
#line 130 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
struct Table_connector {
   short lw ;
   short rw ;
   Connector *le ;
   Connector *re ;
   short cost ;
   int count ;
   Table_connector *next ;
};
#line 293 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Linkage_info_struct;
#line 293 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
typedef struct Linkage_info_struct Linkage_info;
#line 294 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
struct Linkage_info_struct {
   int index ;
   short N_violations ;
   short null_cost ;
   short disjunct_cost ;
   short and_cost ;
   short link_cost ;
};
#line 565 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
struct __anonstruct_user_variable_20 {
   char *s ;
   int *p ;
   int isboolean ;
   char *str ;
};
#line 589 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
struct __anonstruct_user_command_21 {
   char *s ;
   char *str ;
};
#line 15 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
struct Tconnector_struct;
#line 15 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
typedef struct Tconnector_struct Tconnector;
#line 16 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
struct Tconnector_struct {
   char multi ;
   char dir ;
   Tconnector *next ;
   char *string ;
};
#line 23
struct clause_struct;
#line 23 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
typedef struct clause_struct Clause;
#line 24 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
struct clause_struct {
   Clause *next ;
   int cost ;
   int maxcost ;
   Tconnector *c ;
};
#line 280 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
struct label_node_struct;
#line 280 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
typedef struct label_node_struct Label_node;
#line 281 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
struct label_node_struct {
   int label ;
   Label_node *next ;
};
#line 1242
struct Image_node_struct;
#line 1242 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
typedef struct Image_node_struct Image_node;
#line 1243 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
struct Image_node_struct {
   Image_node *next ;
   Connector *c ;
   int place ;
};
#line 25 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
struct DIS_node_struct;
#line 25 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
typedef struct DIS_node_struct DIS_node;
#line 26
struct CON_node_struct;
#line 26 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
typedef struct CON_node_struct CON_node;
#line 27
struct CON_list_struct;
#line 27 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
typedef struct CON_list_struct CON_list;
#line 28
struct DIS_list_struct;
#line 28 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
typedef struct DIS_list_struct DIS_list;
#line 29
struct Links_to_patch_struct;
#line 29 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
typedef struct Links_to_patch_struct Links_to_patch;
#line 32 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
struct DIS_node_struct {
   CON_list *cl ;
   List_o_links *lol ;
   int word ;
};
#line 38 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
struct CON_node_struct {
   DIS_list *dl ;
   DIS_list *current ;
   int word ;
};
#line 44 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
struct DIS_list_struct {
   DIS_list *next ;
   DIS_node *dn ;
};
#line 49 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
struct CON_list_struct {
   CON_list *next ;
   CON_node *cn ;
};
#line 54 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
struct Links_to_patch_struct {
   Links_to_patch *next ;
   int link ;
   char dir ;
   int new ;
};
#line 268
struct patch_element_struct;
#line 268 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
typedef struct patch_element_struct Patch_element;
#line 269 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
struct patch_element_struct {
   char used ;
   char changed ;
   int newl ;
   int newr ;
};
#line 291 "/usr/include/string.h"
int strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 119 "/usr/include/ctype.h"
extern int toupper(int __c ) ;
#line 18 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/strncasecmp.c"
int strncasecmp(char const   *s1 , char const   *s2 , size_t n )  __attribute__((__pure__)) ;
#line 18 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/strncasecmp.c"
int strncasecmp(char const   *s1 , char const   *s2 , size_t n ) 
{ 
  char const   *i ;
  char const   *j ;
  char ui ;
  char uj ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 24
  i = s1;
#line 24
  j = s2;
  {
  {
#line 24
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 24
    if ((int const   )*i != 0) {
#line 24
      if (! ((int const   )*j != 0)) {
#line 24
        goto while_break;
      }
    } else {
#line 24
      goto while_break;
    }
#line 25
    tmp = n;
#line 25
    n --;
#line 25
    if (tmp == 0U) {
#line 25
      return (0);
    }
    {
    {
#line 26
    tmp___0 = toupper((int )*i);
    }
#line 26
    ui = (char )tmp___0;
    {
#line 27
    tmp___1 = toupper((int )*j);
    }
#line 27
    uj = (char )tmp___1;
    }
#line 28
    if ((int )ui < (int )uj) {
#line 29
      return (-1);
    } else
#line 30
    if ((int )ui > (int )uj) {
#line 31
      return (1);
    }
#line 24
    i ++;
#line 24
    j ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if (*i) {
#line 34
    return (-1);
  }
#line 35
  if (*j) {
#line 35
    return (1);
  }
#line 36
  return (0);
}
}
#line 433 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 143 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 206
extern int fclose(FILE *__stream ) ;
#line 211
extern int fflush(FILE *__stream ) ;
#line 241
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 321
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 327
extern int printf(char const   * __restrict  __format  , ...) ;
#line 81 "/usr/include/ctype.h"
extern unsigned short const   **__ctype_b_loc(void)  __attribute__((__const__)) ;
#line 82 "/usr/include/string.h"
extern char *strcpy(char * __restrict  __dest , char const   * __restrict  __src ) ;
#line 230
extern size_t strlen(char const   *__s )  __attribute__((__pure__)) ;
#line 612 "/usr/include/stdlib.h"
extern  __attribute__((__noreturn__)) void exit(int __status ) ;
#line 309 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
Dict_node *dict_root ;
#line 393
void *xalloc(int size ) ;
#line 404
Dict_node *read_word_file(Dict_node *dn , char *filename ) ;
#line 405
int files_need_saving(void) ;
#line 406
void save_files(void) ;
#line 408
void error(char *s ) ;
#line 12 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/word-file.c"
static Word_file *word_file_header  =    (Word_file *)((void *)0);
#line 14 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/word-file.c"
char *get_a_word(FILE *fp ) 
{ 
  char word[60] ;
  char *s ;
  int c ;
  int j ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
  {
#line 21
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 22
    c = _IO_getc(fp);
    }
    }
#line 21
    if (c != -1) {
      {
      {
#line 21
      tmp = __ctype_b_loc();
      }
      }
#line 21
      if (! ((int const   )*(*tmp + c) & 8192)) {
#line 21
        goto while_break;
      }
    } else {
#line 21
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 24
  if (c == -1) {
#line 24
    return ((char *)((void *)0));
  }
#line 26
  j = 0;
  {
  {
#line 26
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 26
    if (j < 60) {
      {
      {
#line 26
      tmp___0 = __ctype_b_loc();
      }
      }
#line 26
      if ((int const   )*(*tmp___0 + c) & 8192) {
#line 26
        goto while_break___0;
      } else
#line 26
      if (! (c != -1)) {
#line 26
        goto while_break___0;
      }
    } else {
#line 26
      goto while_break___0;
    }
    {
#line 27
    word[j] = (char )c;
    {
#line 28
    c = _IO_getc(fp);
    }
#line 26
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 31
  if (j == 60) {
    {
    {
#line 32
    error((char *)"The dictionary contains a word that is too long.");
    }
    }
  }
  {
#line 34
  word[j] = (char )'\000';
  {
#line 35
  tmp___1 = strlen((char const   *)(word));
  }
  {
#line 35
  tmp___2 = xalloc((int )(tmp___1 + 1U));
  }
#line 35
  s = (char *)tmp___2;
  {
#line 38
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)(word));
  }
  }
#line 39
  return (s);
}
}
#line 42 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/word-file.c"
Dict_node *read_word_file(Dict_node *dn , char *filename ) 
{ 
  Dict_node *dn_new ;
  Word_file *wf ;
  FILE *fp ;
  char *s ;
  char file_name_copy[60] ;
  void *tmp ;
  void *tmp___0 ;
  void *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
  {
#line 59
  strcpy((char */* __restrict  */)(file_name_copy), (char const   */* __restrict  */)(filename + 1));
  }
  {
#line 61
  fp = fopen((char const   */* __restrict  */)(file_name_copy), (char const   */* __restrict  */)"r");
  }
  }
#line 61
  if ((unsigned long )fp == (unsigned long )((void *)0)) {
    {
    {
#line 62
    printf((char const   */* __restrict  */)"\nCannot open file %s\n", file_name_copy);
    }
    {
#line 63
    exit(1);
    }
    }
  }
  {
  {
#line 67
  printf((char const   */* __restrict  */)"*");
  }
  {
#line 67
  fflush(stdout);
  }
  {
#line 69
  tmp = xalloc((int )sizeof(Word_file ));
  }
#line 69
  wf = (Word_file *)tmp;
  {
#line 70
  strcpy((char */* __restrict  */)(wf->file), (char const   */* __restrict  */)(file_name_copy));
  }
#line 71
  wf->changed = 0;
#line 72
  wf->next = word_file_header;
#line 73
  word_file_header = wf;
  }
  {
  {
#line 75
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 75
    s = get_a_word(fp);
    }
    }
#line 75
    if (! ((unsigned long )s != (unsigned long )((void *)0))) {
#line 75
      goto while_break;
    }
    {
    {
#line 76
    tmp___0 = xalloc((int )sizeof(Dict_node ));
    }
#line 76
    dn_new = (Dict_node *)tmp___0;
#line 77
    dn_new->left = dn;
#line 78
    dn = dn_new;
#line 79
    dn->string = s;
#line 80
    dn->file = wf;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 82
  fclose(fp);
  }
  }
#line 83
  return (dn);
}
}
#line 87 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/word-file.c"
int xwhere_in_line  ;
#line 89 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/word-file.c"
void routput_dictionary(Dict_node *dn , FILE *fp , Word_file *wf ) 
{ 
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 93
  if ((unsigned long )dn == (unsigned long )((void *)0)) {
#line 93
    return;
  }
  {
  {
#line 94
  routput_dictionary(dn->left, fp, wf);
  }
  }
#line 95
  if ((unsigned long )dn->file == (unsigned long )wf) {
    {
    {
#line 96
    tmp = strlen((char const   *)dn->string);
    }
    }
#line 96
    if ((size_t )xwhere_in_line + tmp > 70U) {
      {
#line 97
      xwhere_in_line = 0;
      {
#line 98
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
      }
      }
    }
    {
    {
#line 100
    tmp___0 = strlen((char const   *)dn->string);
    }
#line 100
    xwhere_in_line = (int )((size_t )xwhere_in_line + (tmp___0 + 1U));
    {
#line 101
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s ", dn->string);
    }
    }
  }
  {
  {
#line 103
  routput_dictionary(dn->right, fp, wf);
  }
  }
#line 104
  return;
}
}
#line 106 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/word-file.c"
void output_dictionary(Dict_node *dn , FILE *fp , Word_file *wf ) 
{ 
  char *__cil_tmp4 ;

  {
  {
#line 107
  xwhere_in_line = 0;
  {
#line 108
  routput_dictionary(dn, fp, wf);
  }
  {
#line 109
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
  }
#line 110
  return;
}
}
#line 112 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/word-file.c"
void save_files(void) 
{ 
  Word_file *wf ;
  FILE *fp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 115
  wf = word_file_header;
  {
  {
#line 115
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 115
    if (! ((unsigned long )wf != (unsigned long )((void *)0))) {
#line 115
      goto while_break;
    }
#line 116
    if (wf->changed) {
      {
      {
#line 117
      fp = fopen((char const   */* __restrict  */)(wf->file), (char const   */* __restrict  */)"w");
      }
      }
#line 117
      if ((unsigned long )fp == (unsigned long )((void *)0)) {
        {
        {
#line 118
        printf((char const   */* __restrict  */)"\nCannot open %s. Gee, this shouldn\'t happen.\n",
               wf->file);
        }
        {
#line 119
        printf((char const   */* __restrict  */)"file not saved\n");
        }
        }
#line 120
        return;
      }
      {
      {
#line 122
      printf((char const   */* __restrict  */)"   saving file \"%s\"\n", wf->file);
      }
      {
#line 123
      output_dictionary(dict_root, fp, wf);
      }
      {
#line 124
      fclose(fp);
      }
#line 125
      wf->changed = 0;
      }
    }
#line 115
    wf = wf->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 128
  return;
}
}
#line 130 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/word-file.c"
int files_need_saving(void) 
{ 
  Word_file *wf ;

  {
#line 132
  wf = word_file_header;
  {
  {
#line 132
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 132
    if (! ((unsigned long )wf != (unsigned long )((void *)0))) {
#line 132
      goto while_break;
    }
#line 133
    if (wf->changed) {
#line 133
      return (1);
    }
#line 132
    wf = wf->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  return (0);
}
}
#line 144 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 556 "/usr/include/stdlib.h"
extern void *malloc(size_t __size )  __attribute__((__malloc__)) ;
#line 594
extern  __attribute__((__noreturn__)) void abort(void) ;
#line 29 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
void initialize_memory(void) ;
#line 345 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int space_in_use  ;
#line 346 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int max_space_in_use  ;
#line 394
void xfree(char *p , int size ) ;
#line 45 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
SIZET largest_block  ;
#line 49 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
char *end_of_array  ;
#line 50 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
char *start_of_array  ;
#line 51 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
char *last_block  ;
#line 62 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
void initialize_memory(void) 
{ 
  SIZET i ;
  SIZET j ;
  void *tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 64
  if ((sizeof(Align ) & (sizeof(Align ) - 1UL)) != 0UL) {
    {
    {
#line 65
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"sizeof(Align) is not a power of 2.\n");
    }
    {
#line 66
    exit(1);
    }
    }
  }
#line 68
  i = (SIZET )0;
#line 68
  j = (SIZET )1;
  {
  {
#line 68
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 68
    if (! (i < j)) {
#line 68
      goto while_break;
    }
#line 68
    largest_block = i;
#line 68
    i = j;
#line 68
    j = 2U * j + 1U;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  largest_block = (SIZET )((unsigned long )largest_block & ~ (sizeof(Align ) - 1UL));
#line 70
  largest_block = (SIZET )((unsigned long )largest_block + - sizeof(Nuggie ));
  {
#line 72
  tmp = malloc((size_t )((31457280UL * sizeof(char *)) / 4UL));
  }
#line 72
  start_of_array = (char *)tmp;
  }
#line 73
  if ((unsigned long )start_of_array == (unsigned long )((void *)0)) {
    {
    {
#line 74
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Not enough memory for base pool.\n");
    }
    {
#line 75
    exit(1);
    }
    }
  }
#line 78
  end_of_array = start_of_array + (((sizeof(Nuggie ) + sizeof(Align )) - 1UL) & ~ (sizeof(Align ) - 1UL));
#line 79
  ((Nuggie *)(end_of_array - sizeof(Nuggie )))->size = (SIZET )0;
#line 80
  max_space_in_use = 0;
#line 81
  space_in_use = 0;
#line 82
  last_block = (char *)((void *)0);
#line 83
  return;
}
}
#line 85 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
void *xalloc(int size ) 
{ 
  char *old_end_of_array ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 87
  if ((unsigned int )size > largest_block) {
    {
    {
#line 88
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to allocate too big a block (more than %d bytes)\n",
            largest_block);
    }
    {
#line 89
    abort();
    }
    {
#line 90
    exit(1);
    }
    }
  }
#line 92
  old_end_of_array = end_of_array;
#line 93
  end_of_array += ((((unsigned long )size + sizeof(Nuggie )) + sizeof(Align )) - 1UL) & ~ (sizeof(Align ) - 1UL);
#line 94
  ((Nuggie *)(end_of_array - sizeof(Nuggie )))->size = (SIZET )(end_of_array - old_end_of_array);
#line 95
  ((Nuggie *)(end_of_array - sizeof(Nuggie )))->size &= 4294967294U;
#line 96
  ((Nuggie *)(old_end_of_array - sizeof(Nuggie )))->size |= 1U;
#line 97
  last_block = old_end_of_array;
#line 99
  if ((unsigned long )((unsigned int )(end_of_array - start_of_array)) > (31457280UL * sizeof(char *)) / 4UL) {
    {
    {
#line 100
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ran out of space.  Memory requested so far: %d bytes\n",
            end_of_array - start_of_array);
    }
    {
#line 102
    exit(1);
    }
    }
  }
#line 104
  space_in_use += size;
#line 105
  if (space_in_use > max_space_in_use) {
#line 105
    max_space_in_use = space_in_use;
  }
#line 106
  return ((void *)old_end_of_array);
}
}
#line 109 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/xalloc.c"
void xfree(char *p , int size ) 
{ 
  char *q ;

  {
#line 113
  ((Nuggie *)(p - sizeof(Nuggie )))->size &= 4294967294U;
#line 114
  if ((unsigned long )p == (unsigned long )last_block) {
    {
    {
#line 115
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 116
      q = p - (((Nuggie *)(p - sizeof(Nuggie )))->size & 4294967294U);
#line 117
      if ((unsigned long )q == (unsigned long )p) {
#line 118
        last_block = (char *)((void *)0);
#line 119
        end_of_array = p;
#line 120
        goto while_break;
      }
#line 122
      if (((Nuggie *)(q - sizeof(Nuggie )))->size & 1U) {
#line 123
        last_block = q;
#line 124
        end_of_array = p;
#line 125
        goto while_break;
      }
#line 127
      p = q;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 130
  space_in_use -= size;
#line 131
  return;
}
}
#line 473 "/usr/include/stdlib.h"
extern int rand(void) ;
#line 475
extern void srand(unsigned int __seed ) ;
#line 362 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
unsigned int randtable[256]  ;
#line 398
void free_disjuncts(Disjunct *c ) ;
#line 399
void free_X_nodes(X_node *x ) ;
#line 400
void free_connectors(Connector *e ) ;
#line 401
void init_randtable(void) ;
#line 416
Disjunct *copy_disjunct(Disjunct *d ) ;
#line 417
Connector *copy_connectors(Connector *c ) ;
#line 418
void free_strings(void) ;
#line 419
void free_this_string_later(char *s , int size ) ;
#line 425
Disjunct *catenate_disjuncts(Disjunct *d1 , Disjunct *d2 ) ;
#line 426
X_node *catenate_X_nodes(X_node *d1 , X_node *d2 ) ;
#line 435
int next_power_of_two_up(int i ) ;
#line 437
int upper_case_match(char *s , char *t ) ;
#line 449
void free_Exp(Exp *e ) ;
#line 450
void free_E_list(E_list *l ) ;
#line 451
Exp *copy_Exp(Exp *e ) ;
#line 453
int size_of_expression(Exp *e ) ;
#line 463
void left_print_string(FILE *fp , char *s , char *t ) ;
#line 14 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void free_connectors(Connector *e ) 
{ 
  Connector *n ;

  {
  {
  {
#line 19
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 19
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 19
      goto while_break;
    }
    {
#line 20
    n = e->next;
    {
#line 21
    xfree((char *)e, (int )sizeof(Connector ));
    }
#line 19
    e = n;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 23
  return;
}
}
#line 25 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void free_disjuncts(Disjunct *c ) 
{ 
  Disjunct *c1 ;

  {
  {
  {
#line 30
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 30
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 30
      goto while_break;
    }
    {
#line 31
    c1 = c->next;
    {
#line 32
    free_connectors(c->left);
    }
    {
#line 33
    free_connectors(c->right);
    }
    {
#line 34
    xfree((char *)c, (int )sizeof(Disjunct ));
    }
#line 30
    c = c1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 36
  return;
}
}
#line 38 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void free_X_nodes(X_node *x ) 
{ 
  X_node *y ;

  {
  {
  {
#line 41
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 41
    if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 41
      goto while_break;
    }
    {
#line 42
    y = x->next;
    {
#line 43
    free_Exp(x->exp);
    }
    {
#line 44
    xfree((char *)x, (int )sizeof(X_node ));
    }
#line 41
    x = y;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 46
  return;
}
}
#line 49 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void free_Exp(Exp *e ) 
{ 


  {
#line 50
  if ((int )e->type != 2) {
    {
    {
#line 51
    free_E_list(e->u.l);
    }
    }
  }
  {
  {
#line 53
  xfree((char *)e, (int )sizeof(Exp ));
  }
  }
#line 54
  return;
}
}
#line 56 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void free_E_list(E_list *l ) 
{ 


  {
#line 57
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 57
    return;
  }
  {
  {
#line 58
  free_E_list(l->next);
  }
  {
#line 59
  free_Exp(l->e);
  }
  {
#line 60
  xfree((char *)l, (int )sizeof(E_list ));
  }
  }
#line 61
  return;
}
}
#line 63 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
int size_of_expression(Exp *e ) 
{ 
  int size ;
  E_list *l ;
  int tmp ;

  {
#line 67
  if ((int )e->type == 2) {
#line 67
    return (1);
  }
#line 68
  size = 0;
#line 69
  l = e->u.l;
  {
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 69
      goto while_break;
    }
    {
    {
#line 70
    tmp = size_of_expression(l->e);
    }
#line 70
    size += tmp;
#line 69
    l = l->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  return (size);
}
}
#line 93 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void init_randtable(void) 
{ 
  int i ;
  int tmp ;

  {
  {
  {
#line 95
  srand(10U);
  }
#line 96
  i = 0;
  }
  {
  {
#line 96
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 96
    if (! (i < 256)) {
#line 96
      goto while_break;
    }
    {
    {
#line 97
    tmp = rand();
    }
#line 97
    randtable[i] = (unsigned int )tmp;
#line 96
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 103
E_list *copy_E_list(E_list *l ) ;
#line 104 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
Exp *copy_Exp(Exp *e ) 
{ 
  Exp *n ;
  void *tmp ;

  {
#line 106
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 106
    return ((Exp *)((void *)0));
  }
  {
  {
#line 107
  tmp = xalloc((int )sizeof(Exp ));
  }
#line 107
  n = (Exp *)tmp;
#line 108
  *n = *e;
  }
#line 109
  if ((int )e->type != 2) {
    {
    {
#line 110
    n->u.l = copy_E_list(e->u.l);
    }
    }
  }
#line 112
  return (n);
}
}
#line 115 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
E_list *copy_E_list(E_list *l ) 
{ 
  E_list *nl ;
  void *tmp ;

  {
#line 117
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 117
    return ((E_list *)((void *)0));
  }
  {
  {
#line 118
  tmp = xalloc((int )sizeof(E_list ));
  }
#line 118
  nl = (E_list *)tmp;
#line 119
  *nl = *l;
  {
#line 120
  nl->next = copy_E_list(l->next);
  }
  {
#line 121
  nl->e = copy_Exp(l->e);
  }
  }
#line 122
  return (nl);
}
}
#line 125 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
Connector *copy_connectors(Connector *c ) 
{ 
  Connector *c1 ;
  void *tmp ;

  {
#line 130
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 130
    return ((Connector *)((void *)0));
  }
  {
  {
#line 131
  tmp = xalloc((int )sizeof(Connector ));
  }
#line 131
  c1 = (Connector *)tmp;
#line 132
  *c1 = *c;
  {
#line 133
  c1->next = copy_connectors(c->next);
  }
  }
#line 134
  return (c1);
}
}
#line 137 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
Disjunct *copy_disjunct(Disjunct *d ) 
{ 
  Disjunct *d1 ;
  void *tmp ;

  {
#line 143
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 143
    return ((Disjunct *)((void *)0));
  }
  {
  {
#line 144
  tmp = xalloc((int )sizeof(Disjunct ));
  }
#line 144
  d1 = (Disjunct *)tmp;
#line 145
  *d1 = *d;
#line 146
  d1->next = (Disjunct *)((void *)0);
  {
#line 147
  d1->left = copy_connectors(d->left);
  }
  {
#line 148
  d1->right = copy_connectors(d->right);
  }
  }
#line 149
  return (d1);
}
}
#line 159 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
static String_node *string_list  =    (String_node *)((void *)0);
#line 161 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void free_this_string_later(char *s , int size ) 
{ 
  String_node *sn ;
  void *tmp ;

  {
  {
  {
#line 163
  tmp = xalloc((int )sizeof(String_node ));
  }
#line 163
  sn = (String_node *)tmp;
#line 164
  sn->next = string_list;
#line 165
  string_list = sn;
#line 166
  sn->string = s;
#line 167
  sn->size = size;
  }
#line 168
  return;
}
}
#line 170 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void free_strings(void) 
{ 
  String_node *sn ;

  {
  {
  {
#line 172
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )string_list != (unsigned long )((void *)0))) {
#line 172
      goto while_break;
    }
    {
#line 173
    sn = string_list->next;
    {
#line 174
    xfree(string_list->string, string_list->size);
    }
    {
#line 175
    xfree((char *)string_list, (int )sizeof(String_node ));
    }
#line 172
    string_list = sn;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return;
}
}
#line 179 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
Disjunct *catenate_disjuncts(Disjunct *d1 , Disjunct *d2 ) 
{ 
  Disjunct *dis ;

  {
#line 183
  dis = d1;
#line 185
  if ((unsigned long )d1 == (unsigned long )((void *)0)) {
#line 185
    return (d2);
  }
#line 186
  if ((unsigned long )d2 == (unsigned long )((void *)0)) {
#line 186
    return (d1);
  }
  {
  {
#line 187
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 187
    if (! ((unsigned long )dis->next != (unsigned long )((void *)0))) {
#line 187
      goto while_break;
    }
#line 187
    dis = dis->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 188
  dis->next = d2;
#line 189
  return (d1);
}
}
#line 192 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
X_node *catenate_X_nodes(X_node *d1 , X_node *d2 ) 
{ 
  X_node *dis ;

  {
#line 196
  dis = d1;
#line 198
  if ((unsigned long )d1 == (unsigned long )((void *)0)) {
#line 198
    return (d2);
  }
#line 199
  if ((unsigned long )d2 == (unsigned long )((void *)0)) {
#line 199
    return (d1);
  }
  {
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 200
    if (! ((unsigned long )dis->next != (unsigned long )((void *)0))) {
#line 200
      goto while_break;
    }
#line 200
    dis = dis->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 201
  dis->next = d2;
#line 202
  return (d1);
}
}
#line 205 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
int next_power_of_two_up(int i ) 
{ 
  int j ;

  {
#line 207
  j = 1;
  {
  {
#line 208
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 208
    if (! (j < i)) {
#line 208
      goto while_break;
    }
#line 208
    j <<= 1;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return (j);
}
}
#line 212 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
int upper_case_match(char *s , char *t ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;

  {
  {
  {
#line 214
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 214
    tmp = __ctype_b_loc();
    }
    }
#line 214
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
      {
      {
#line 214
      tmp___0 = __ctype_b_loc();
      }
      }
#line 214
      if (! ((int const   )*(*tmp___0 + (int )*t) & 256)) {
#line 214
        goto while_break;
      }
    }
#line 215
    if ((int )*s != (int )*t) {
#line 215
      return (0);
    }
#line 216
    s ++;
#line 217
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 219
  tmp___1 = __ctype_b_loc();
  }
  }
#line 219
  if ((int const   )*(*tmp___1 + (int )*s) & 256) {
#line 219
    tmp___3 = 0;
  } else {
    {
    {
#line 219
    tmp___2 = __ctype_b_loc();
    }
    }
#line 219
    if ((int const   )*(*tmp___2 + (int )*t) & 256) {
#line 219
      tmp___3 = 0;
    } else {
#line 219
      tmp___3 = 1;
    }
  }
#line 219
  return (tmp___3);
}
}
#line 222 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/utilities.c"
void left_print_string(FILE *fp , char *s , char *t ) 
{ 
  int i ;
  int j ;
  int k ;
  size_t tmp ;
  size_t tmp___0 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 227
  tmp = strlen((char const   *)t);
  }
#line 227
  j = (int )tmp;
  {
#line 228
  tmp___0 = strlen((char const   *)s);
  }
#line 228
  k = (int )tmp___0;
#line 229
  i = 0;
  }
  {
  {
#line 229
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < j)) {
#line 229
      goto while_break;
    }
#line 230
    if (i < k) {
      {
      {
#line 231
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%c",
              (int )*(s + i));
      }
      }
    } else {
      {
      {
#line 233
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%c",
              (int )*(t + i));
      }
      }
    }
#line 229
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 236
  return;
}
}
#line 435 "/usr/include/stdio.h"
extern int fgetc(FILE *__stream ) ;
#line 96 "/usr/include/string.h"
extern int strcmp(char const   *__s1 , char const   *__s2 )  __attribute__((__pure__)) ;
#line 99
extern int strncmp(char const   *__s1 , char const   *__s2 , size_t __n )  __attribute__((__pure__)) ;
#line 162
extern char *strchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 164
extern char *strrchr(char const   *__s , int __c )  __attribute__((__pure__)) ;
#line 308 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int N_dict ;
#line 363
int line_number ;
#line 370
void read_dictionary(void) ;
#line 371
void print_dictionary_data(void) ;
#line 373
void print_expression(Exp *n ) ;
#line 378
void open_dictionary(char *s ) ;
#line 379
int boolean_dictionary_lookup(char *s ) ;
#line 380
int boolean_abridged_lookup(char *s ) ;
#line 381
Dict_node *dictionary_lookup(char *s ) ;
#line 383
Dict_node *abridged_lookup(char *s ) ;
#line 384
int delete_dictionary_words(char *s ) ;
#line 407
Dict_node *insert_dict(Dict_node *n , Dict_node *new ) ;
#line 409
void insert_idiom(Dict_node *dn ) ;
#line 410
int contains_underbar(char *s ) ;
#line 412
int is_idiom_word(char *s ) ;
#line 420
void free_lookup_list(void) ;
#line 84 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int N_dict  =    0;
#line 85 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Dict_node *dict_root  =    (Dict_node *)((void *)0);
#line 87 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
static char token[50]  ;
#line 90 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
static int is_special  ;
#line 94 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int line_number  =    1;
#line 96 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
static FILE *dict_file  ;
#line 98
void advance(void) ;
#line 100 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void error(char *s ) 
{ 
  int i ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 102
  printf((char const   */* __restrict  */)"\nError in dictionary file: %s\n", s);
  }
  {
#line 103
  printf((char const   */* __restrict  */)"line %d, tokens = ", line_number);
  }
#line 104
  i = 0;
  }
  {
  {
#line 104
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 104
    if (i < 5) {
#line 104
      if (! ((int )token[0] != 0)) {
#line 104
        goto while_break;
      }
    } else {
#line 104
      goto while_break;
    }
    {
    {
#line 105
    printf((char const   */* __restrict  */)" \"%s\"", token);
    }
    {
#line 106
    advance();
    }
#line 104
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 108
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 109
  exit(1);
  }
  }
}
}
#line 112 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void warning(char *s ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 113
  printf((char const   */* __restrict  */)"\nWarning: %s\n", s);
  }
  {
#line 114
  printf((char const   */* __restrict  */)"line %d, current token = \"%s\"\n", line_number,
         token);
  }
  }
#line 115
  return;
}
}
#line 117 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int get_character(int quote_mode ) 
{ 
  int c ;

  {
  {
  {
#line 124
  c = fgetc(dict_file);
  }
  }
#line 125
  if (c == 37) {
#line 125
    if (! quote_mode) {
      {
      {
#line 126
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 126
        if (c != -1) {
#line 126
          if (! (c != 10)) {
#line 126
            goto while_break;
          }
        } else {
#line 126
          goto while_break;
        }
        {
        {
#line 126
        c = fgetc(dict_file);
        }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 128
  if (c == 10) {
#line 128
    line_number ++;
  }
#line 129
  return (c);
}
}
#line 141 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
static int already_got_it  =    '\000';
#line 138 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void advance(void) 
{ 
  int c ;
  int i ;
  int quote_mode ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
#line 144
  is_special = 0;
#line 146
  if (already_got_it != 0) {
    {
    {
#line 147
    tmp = strchr("(){};[]&|:", already_got_it);
    }
#line 147
    is_special = (unsigned long )tmp != (unsigned long )((void *)0);
    }
#line 148
    if (already_got_it == -1) {
#line 149
      token[0] = (char )'\000';
    } else {
#line 151
      token[0] = (char )already_got_it;
#line 152
      token[1] = (char )'\000';
    }
#line 154
    already_got_it = '\000';
#line 155
    return;
  }
  {
  {
#line 158
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 158
    c = get_character(0);
    }
    {
#line 158
    tmp___0 = __ctype_b_loc();
    }
    }
#line 158
    if (! ((int const   )*(*tmp___0 + c) & 8192)) {
#line 158
      goto while_break;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  quote_mode = 0;
#line 162
  i = 0;
  {
  {
#line 163
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 164
    if (i > 49) {
      {
      {
#line 165
      error((char *)"Token too long");
      }
      }
#line 166
      return;
    }
#line 168
    if (quote_mode) {
#line 169
      if (c == 34) {
#line 170
        quote_mode = 0;
#line 171
        token[i] = (char )'\000';
#line 172
        return;
      }
      {
      {
#line 174
      tmp___1 = __ctype_b_loc();
      }
      }
#line 174
      if ((int const   )*(*tmp___1 + c) & 8192) {
        {
        {
#line 175
        error((char *)"White space inside of token");
        }
        }
#line 176
        return;
      }
#line 178
      token[i] = (char )c;
#line 179
      i ++;
    } else {
      {
      {
#line 181
      tmp___2 = strchr("(){};[]&|:", c);
      }
      }
#line 181
      if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
#line 182
        if (i == 0) {
#line 183
          token[0] = (char )c;
#line 184
          token[1] = (char )'\000';
#line 185
          is_special = 1;
#line 186
          return;
        }
#line 188
        token[i] = (char )'\000';
#line 189
        already_got_it = c;
#line 190
        return;
      }
#line 192
      if (c == -1) {
#line 193
        if (i == 0) {
#line 194
          token[0] = (char )'\000';
#line 195
          return;
        }
#line 197
        token[i] = (char )'\000';
#line 198
        already_got_it = c;
#line 199
        return;
      }
      {
      {
#line 201
      tmp___3 = __ctype_b_loc();
      }
      }
#line 201
      if ((int const   )*(*tmp___3 + c) & 8192) {
#line 202
        token[i] = (char )'\000';
#line 203
        return;
      }
#line 205
      if (c == 34) {
#line 206
        quote_mode = 1;
      } else {
#line 208
        token[i] = (char )c;
#line 209
        i ++;
      }
    }
    {
    {
#line 212
    c = get_character(quote_mode);
    }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 216 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int is_equal(int c ) 
{ 
  int tmp ;

  {
#line 218
  if (is_special) {
#line 218
    if (c == (int )token[0]) {
#line 218
      if ((int )token[1] == 0) {
#line 218
        tmp = 1;
      } else {
#line 218
        tmp = 0;
      }
    } else {
#line 218
      tmp = 0;
    }
  } else {
#line 218
    tmp = 0;
  }
#line 218
  return (tmp);
}
}
#line 221 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
char *copy_string(char *str ) 
{ 
  char *s ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 223
  tmp = strlen((char const   *)str);
  }
  {
#line 223
  tmp___0 = xalloc((int )(tmp + 1U));
  }
#line 223
  s = (char *)tmp___0;
  {
#line 224
  strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)str);
  }
  }
#line 225
  return (s);
}
}
#line 228 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void check_connector(char *s ) 
{ 
  int i ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 231
  tmp = strlen((char const   *)s);
  }
#line 231
  i = (int )tmp;
  }
#line 232
  if (i < 1) {
    {
    {
#line 233
    error((char *)"Expecting a connector.");
    }
    }
  }
#line 235
  i = (int )*(s + (i - 1));
#line 236
  if (i != 43) {
#line 236
    if (i != 45) {
      {
      {
#line 237
      error((char *)"A connector must end in a \"+\" or \"-\".");
      }
      }
    }
  }
#line 239
  if ((int )*s == 64) {
#line 239
    s ++;
  }
  {
  {
#line 240
  tmp___0 = __ctype_b_loc();
  }
  }
#line 240
  if (! ((int const   )*(*tmp___0 + (int )*s) & 256)) {
    {
    {
#line 241
    error((char *)"The first letter of a connector must be in [A--Z].");
    }
    }
  }
#line 243
  if ((int )*s == 73) {
#line 243
    if ((int )*(s + 1) == 68) {
      {
      {
#line 244
      error((char *)"Connectors beginning with \"ID\" are forbidden");
      }
      }
    }
  }
  {
  {
#line 246
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 246
    if (! *(s + 1)) {
#line 246
      goto while_break;
    }
    {
    {
#line 247
    tmp___1 = __ctype_b_loc();
    }
    }
#line 247
    if (! ((int const   )*(*tmp___1 + (int )*s) & 8)) {
#line 247
      if ((int )*s != 42) {
#line 247
        if ((int )*s != 94) {
          {
          {
#line 248
          error((char *)"All letters of a connector must be alpha-numeric.");
          }
          }
        }
      }
    }
#line 250
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 254
Exp *make_unary_node(Exp *e ) ;
#line 256 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Exp *connector(void) 
{ 
  Exp *n ;
  Dict_node *dn ;
  int i ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 264
  tmp = strlen((char const   *)(token));
  }
#line 264
  i = (int )(tmp - 1U);
  }
#line 265
  if ((int )token[i] != 43) {
#line 265
    if ((int )token[i] != 45) {
      {
      {
#line 266
      dn = abridged_lookup(token);
      }
      }
      {
      {
#line 267
      while (1) {
        while_continue___0: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 267
        if ((unsigned long )dn != (unsigned long )((void *)0)) {
          {
          {
#line 267
          tmp___0 = strcmp((char const   *)dn->string, (char const   *)(token));
          }
          }
#line 267
          if (! (tmp___0 != 0)) {
#line 267
            goto while_break;
          }
        } else {
#line 267
          goto while_break;
        }
#line 268
        dn = dn->right;
      }
      while_break___0: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
#line 270
      if ((unsigned long )dn == (unsigned long )((void *)0)) {
        {
        {
#line 271
        printf((char const   */* __restrict  */)"\nPerhaps missing + or - in a connector.\n");
        }
        {
#line 272
        printf((char const   */* __restrict  */)"Or perhaps you forgot the suffix on a word.\n");
        }
        {
#line 273
        error((char *)"Or perhaps a word is used before it is defined\n");
        }
        }
      }
      {
      {
#line 275
      n = make_unary_node(dn->exp);
      }
      }
    } else {
#line 265
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
    {
#line 277
    check_connector(token);
    }
    {
#line 278
    tmp___1 = xalloc((int )sizeof(Exp ));
    }
#line 278
    n = (Exp *)tmp___1;
#line 279
    n->dir = token[i];
#line 280
    token[i] = (char )'\000';
    }
#line 281
    if ((int )token[0] == 64) {
      {
      {
#line 282
      n->u.string = copy_string(token + 1);
      }
#line 283
      n->multi = (char)1;
      }
    } else {
      {
      {
#line 285
      n->u.string = copy_string(token);
      }
#line 286
      n->multi = (char)0;
      }
    }
#line 288
    n->type = (char)2;
#line 289
    n->cost = (unsigned char)0;
  }
  {
  {
#line 291
  advance();
  }
  }
#line 292
  return (n);
}
}
#line 295 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Exp *make_unary_node(Exp *e ) 
{ 
  Exp *n ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 299
  tmp = xalloc((int )sizeof(Exp ));
  }
#line 299
  n = (Exp *)tmp;
#line 300
  n->type = (char)1;
#line 301
  n->cost = (unsigned char)0;
  {
#line 302
  tmp___0 = xalloc((int )sizeof(E_list ));
  }
#line 302
  n->u.l = (E_list *)tmp___0;
#line 303
  (n->u.l)->next = (E_list *)((void *)0);
#line 304
  (n->u.l)->e = e;
  }
#line 305
  return (n);
}
}
#line 308 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Exp *make_zeroary_node(void) 
{ 
  Exp *n ;
  void *tmp ;

  {
  {
  {
#line 312
  tmp = xalloc((int )sizeof(Exp ));
  }
#line 312
  n = (Exp *)tmp;
#line 313
  n->type = (char)1;
#line 314
  n->cost = (unsigned char)0;
#line 315
  n->u.l = (E_list *)((void *)0);
  }
#line 316
  return (n);
}
}
#line 319 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Exp *make_optional_node(Exp *e ) 
{ 
  Exp *n ;
  E_list *el ;
  E_list *elx ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
  {
#line 326
  tmp = xalloc((int )sizeof(Exp ));
  }
#line 326
  n = (Exp *)tmp;
#line 327
  n->type = (char)0;
#line 328
  n->cost = (unsigned char)0;
  {
#line 329
  tmp___0 = xalloc((int )sizeof(E_list ));
  }
#line 329
  el = (E_list *)tmp___0;
#line 329
  n->u.l = el;
  {
#line 330
  el->e = make_zeroary_node();
  }
  {
#line 331
  tmp___1 = xalloc((int )sizeof(E_list ));
  }
#line 331
  elx = (E_list *)tmp___1;
#line 331
  el->next = elx;
#line 332
  elx->next = (E_list *)((void *)0);
#line 333
  elx->e = e;
  }
#line 334
  return (n);
}
}
#line 337
Exp *expression(void) ;
#line 413
Exp *restricted_expression(int and_ok , int or_ok ) ;
#line 415 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Exp *expression(void) 
{ 
  Exp *tmp ;

  {
  {
  {
#line 419
  tmp = restricted_expression(1, 1);
  }
  }
#line 419
  return (tmp);
}
}
#line 422 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Exp *restricted_expression(int and_ok , int or_ok ) 
{ 
  Exp *nl ;
  Exp *nr ;
  Exp *n ;
  E_list *ell ;
  E_list *elr ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;

  {
  {
#line 423
  nl = (Exp *)((void *)0);
  {
#line 425
  tmp___6 = is_equal('(');
  }
  }
#line 425
  if (tmp___6) {
    {
    {
#line 426
    advance();
    }
    {
#line 427
    nl = expression();
    }
    {
#line 428
    tmp = is_equal(')');
    }
    }
#line 428
    if (! tmp) {
      {
      {
#line 428
      error((char *)"Expecting a \")\".");
      }
      }
    }
    {
    {
#line 429
    advance();
    }
    }
  } else {
    {
    {
#line 430
    tmp___5 = is_equal('{');
    }
    }
#line 430
    if (tmp___5) {
      {
      {
#line 431
      advance();
      }
      {
#line 432
      nl = expression();
      }
      {
#line 433
      tmp___0 = is_equal('}');
      }
      }
#line 433
      if (! tmp___0) {
        {
        {
#line 433
        error((char *)"Expecting a \"}\".");
        }
        }
      }
      {
      {
#line 434
      advance();
      }
      {
#line 435
      nl = make_optional_node(nl);
      }
      }
    } else {
      {
      {
#line 436
      tmp___4 = is_equal('[');
      }
      }
#line 436
      if (tmp___4) {
        {
        {
#line 437
        advance();
        }
        {
#line 438
        nl = expression();
        }
        {
#line 439
        tmp___1 = is_equal(']');
        }
        }
#line 439
        if (! tmp___1) {
          {
          {
#line 439
          error((char *)"Expecting a \"]\".");
          }
          }
        }
        {
        {
#line 440
        advance();
        }
#line 441
        nl->cost = (unsigned char )((int )nl->cost + 1);
        }
      } else
#line 442
      if (! is_special) {
        {
        {
#line 443
        nl = connector();
        }
        }
      } else {
        {
        {
#line 444
        tmp___2 = is_equal(')');
        }
        }
#line 444
        if (tmp___2) {
          {
          {
#line 445
          nl = make_zeroary_node();
          }
          }
        } else {
          {
          {
#line 444
          tmp___3 = is_equal(']');
          }
          }
#line 444
          if (tmp___3) {
            {
            {
#line 445
            nl = make_zeroary_node();
            }
            }
          } else {
            {
            {
#line 447
            error((char *)"Connector, \"(\", \"[\", or \"{\" expected.");
            }
            }
          }
        }
      }
    }
  }
  {
  {
#line 450
  tmp___15 = is_equal('&');
  }
  }
#line 450
  if (tmp___15) {
#line 450
    goto _L___0;
  } else {
    {
    {
#line 450
    tmp___16 = strcmp((char const   *)(token), "and");
    }
    }
#line 450
    if (tmp___16 == 0) {
      _L___0: /* CIL Label */ 
#line 451
      if (! and_ok) {
        {
        {
#line 452
        warning((char *)"\"and\" and \"or\" at the same level in an expression");
        }
        }
      }
      {
      {
#line 454
      advance();
      }
      {
#line 455
      nr = restricted_expression(1, 0);
      }
      {
#line 456
      tmp___7 = xalloc((int )sizeof(Exp ));
      }
#line 456
      n = (Exp *)tmp___7;
      {
#line 457
      tmp___8 = xalloc((int )sizeof(E_list ));
      }
#line 457
      ell = (E_list *)tmp___8;
#line 457
      n->u.l = ell;
      {
#line 458
      tmp___9 = xalloc((int )sizeof(E_list ));
      }
#line 458
      elr = (E_list *)tmp___9;
#line 458
      ell->next = elr;
#line 459
      elr->next = (E_list *)((void *)0);
#line 461
      ell->e = nl;
#line 462
      elr->e = nr;
#line 463
      n->type = (char)1;
#line 464
      n->cost = (unsigned char)0;
      }
    } else {
      {
      {
#line 465
      tmp___13 = is_equal('|');
      }
      }
#line 465
      if (tmp___13) {
#line 465
        goto _L;
      } else {
        {
        {
#line 465
        tmp___14 = strcmp((char const   *)(token), "or");
        }
        }
#line 465
        if (tmp___14 == 0) {
          _L: /* CIL Label */ 
#line 466
          if (! or_ok) {
            {
            {
#line 467
            warning((char *)"\"and\" and \"or\" at the same level in an expression");
            }
            }
          }
          {
          {
#line 469
          advance();
          }
          {
#line 470
          nr = restricted_expression(0, 1);
          }
          {
#line 471
          tmp___10 = xalloc((int )sizeof(Exp ));
          }
#line 471
          n = (Exp *)tmp___10;
          {
#line 472
          tmp___11 = xalloc((int )sizeof(E_list ));
          }
#line 472
          ell = (E_list *)tmp___11;
#line 472
          n->u.l = ell;
          {
#line 473
          tmp___12 = xalloc((int )sizeof(E_list ));
          }
#line 473
          elr = (E_list *)tmp___12;
#line 473
          ell->next = elr;
#line 474
          elr->next = (E_list *)((void *)0);
#line 476
          ell->e = nl;
#line 477
          elr->e = nr;
#line 478
          n->type = (char)0;
#line 479
          n->cost = (unsigned char)0;
          }
        } else {
#line 480
          return (nl);
        }
      }
    }
  }
#line 481
  return (n);
}
}
#line 520 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int dict_compare(char *s , char *t ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 521
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 521
    if ((int )*s != 0) {
#line 521
      if (! ((int )*s == (int )*t)) {
#line 521
        goto while_break;
      }
    } else {
#line 521
      goto while_break;
    }
#line 521
    s ++;
#line 521
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  if ((int )*s == 46) {
#line 522
    tmp = 1;
  } else {
#line 522
    tmp = (int )*s << 1;
  }
#line 522
  if ((int )*t == 46) {
#line 522
    tmp___0 = 1;
  } else {
#line 522
    tmp___0 = (int )*t << 1;
  }
#line 522
  return (tmp - tmp___0);
}
}
#line 525 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Dict_node *insert_dict(Dict_node *n , Dict_node *new ) 
{ 
  int comp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 532
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 532
    return (new);
  }
  {
  {
#line 533
  comp = dict_compare(new->string, n->string);
  }
  }
#line 534
  if (comp < 0) {
    {
    {
#line 535
    n->left = insert_dict(n->left, new);
    }
    }
  } else
#line 536
  if (comp > 0) {
    {
    {
#line 537
    n->right = insert_dict(n->right, new);
    }
    }
  } else {
    {
    {
#line 539
    printf((char const   */* __restrict  */)"\"%s\"\n", new->string);
    }
    {
#line 540
    error((char *)"The word shown above has been multiply defined");
    }
    }
  }
#line 542
  return (n);
}
}
#line 545 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void insert_list(Dict_node *p , int l ) 
{ 
  Dict_node *dn ;
  Dict_node *dnx ;
  Dict_node *dn_second_half ;
  int k ;
  int i ;
  Dict_node *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;

  {
#line 554
  if (l == 0) {
#line 554
    return;
  }
#line 556
  k = (l - 1) / 2;
#line 557
  dn = p;
#line 558
  i = 0;
  {
  {
#line 558
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 558
    if (! (i < k)) {
#line 558
      goto while_break;
    }
#line 559
    dn = dn->left;
#line 558
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 562
  dn_second_half = dn->left;
#line 563
  tmp = (Dict_node *)((void *)0);
#line 563
  dn->right = tmp;
#line 563
  dn->left = tmp;
  {
#line 564
  tmp___1 = contains_underbar(dn->string);
  }
  }
#line 564
  if (tmp___1) {
    {
    {
#line 565
    insert_idiom(dn);
    }
    }
  } else {
    {
    {
#line 566
    tmp___0 = is_idiom_word(dn->string);
    }
    }
#line 566
    if (tmp___0) {
      {
      {
#line 567
      printf((char const   */* __restrict  */)"*** Word \"%s\" found near line %d.\n",
             dn->string, line_number);
      }
      {
#line 568
      printf((char const   */* __restrict  */)"    Words ending \".Ix\" (x a number) are reserved for idioms.\n");
      }
      {
#line 569
      printf((char const   */* __restrict  */)"    This word will be ignored.\n");
      }
      }
    } else {
      {
      {
#line 570
      dnx = abridged_lookup(dn->string);
      }
      }
#line 570
      if ((unsigned long )dnx != (unsigned long )((void *)0)) {
        {
        {
#line 571
        printf((char const   */* __restrict  */)"*** The word \"%s\"", dn->string);
        }
        {
#line 572
        printf((char const   */* __restrict  */)" found near line %d matches the following words:\n",
               line_number);
        }
        }
        {
        {
#line 574
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 574
          if (! ((unsigned long )dnx != (unsigned long )((void *)0))) {
#line 574
            goto while_break___0;
          }
          {
          {
#line 575
          printf((char const   */* __restrict  */)" %s", dnx->string);
          }
#line 574
          dnx = dnx->right;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
        {
        {
#line 577
        printf((char const   */* __restrict  */)"\n    This word will be ignored.\n");
        }
        }
      } else {
        {
        {
#line 579
        dict_root = insert_dict(dict_root, dn);
        }
#line 580
        N_dict ++;
        }
      }
    }
  }
  {
  {
#line 583
  insert_list(p, k);
  }
  {
#line 584
  insert_list(dn_second_half, (l - k) - 1);
  }
  }
#line 585
  return;
}
}
#line 587 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void read_entry(void) 
{ 
  Exp *n ;
  int i ;
  Dict_node *dn_new ;
  Dict_node *dnx ;
  Dict_node *dn ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 593
  dn = (Dict_node *)((void *)0);
  {
  {
#line 595
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 595
    tmp___0 = is_equal(':');
    }
    }
#line 595
    if (tmp___0) {
#line 595
      goto while_break;
    }
#line 596
    if (is_special) {
      {
      {
#line 597
      error((char *)"I expected a word but didn\'t get it.");
      }
      }
    }
#line 599
    if ((int )token[0] == 47) {
      {
      {
#line 601
      dn = read_word_file(dn, token);
      }
      }
    } else {
      {
      {
#line 603
      tmp = xalloc((int )sizeof(Dict_node ));
      }
#line 603
      dn_new = (Dict_node *)tmp;
#line 604
      dn_new->left = dn;
#line 605
      dn = dn_new;
#line 606
      dn->file = (Word_file *)((void *)0);
      {
#line 607
      dn->string = copy_string(token);
      }
      }
    }
    {
    {
#line 595
    advance();
    }
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 610
  advance();
  }
  {
#line 611
  n = expression();
  }
  {
#line 612
  tmp___1 = is_equal(';');
  }
  }
#line 612
  if (! tmp___1) {
    {
    {
#line 612
    error((char *)"Expecting \";\" at the end of an entry.");
    }
    }
  }
  {
  {
#line 613
  advance();
  }
#line 617
  i = 0;
#line 618
  dnx = dn;
  }
  {
  {
#line 618
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 618
    if (! ((unsigned long )dnx != (unsigned long )((void *)0))) {
#line 618
      goto while_break___0;
    }
#line 619
    dnx->exp = n;
#line 620
    i ++;
#line 618
    dnx = dnx->left;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 622
  insert_list(dn, i);
  }
  }
#line 623
  return;
}
}
#line 625 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void print_expression(Exp *n ) 
{ 
  E_list *el ;
  int i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 627
  if ((unsigned long )n == (unsigned long )((void *)0)) {
    {
    {
#line 628
    printf((char const   */* __restrict  */)"NULL expression");
    }
    }
#line 629
    return;
  }
#line 631
  if ((int )n->type == 2) {
#line 632
    i = 0;
    {
    {
#line 632
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 632
      if (! (i < (int )n->cost)) {
#line 632
        goto while_break;
      }
      {
      {
#line 632
      printf((char const   */* __restrict  */)"[");
      }
#line 632
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
    {
    {
#line 633
    printf((char const   */* __restrict  */)"%s%c", n->u.string, (int )n->dir);
    }
#line 634
    i = 0;
    }
    {
    {
#line 634
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 634
      if (! (i < (int )n->cost)) {
#line 634
        goto while_break___0;
      }
      {
      {
#line 634
      printf((char const   */* __restrict  */)"] ");
      }
#line 634
      i ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
#line 636
    i = 0;
    {
    {
#line 636
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 636
      if (! (i < (int )n->cost)) {
#line 636
        goto while_break___1;
      }
      {
      {
#line 636
      printf((char const   */* __restrict  */)"[");
      }
#line 636
      i ++;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 637
    if ((int )n->cost == 0) {
      {
      {
#line 637
      printf((char const   */* __restrict  */)"(");
      }
      }
    }
#line 638
    if ((int )n->type == 1) {
      {
      {
#line 638
      printf((char const   */* __restrict  */)"& ");
      }
      }
    }
#line 639
    if ((int )n->type == 0) {
      {
      {
#line 639
      printf((char const   */* __restrict  */)"or ");
      }
      }
    }
#line 640
    el = n->u.l;
    {
    {
#line 640
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 640
      if (! ((unsigned long )el != (unsigned long )((void *)0))) {
#line 640
        goto while_break___2;
      }
      {
      {
#line 641
      print_expression(el->e);
      }
#line 640
      el = el->next;
      }
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 643
    i = 0;
    {
    {
#line 643
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 643
      if (! (i < (int )n->cost)) {
#line 643
        goto while_break___3;
      }
      {
      {
#line 643
      printf((char const   */* __restrict  */)"] ");
      }
#line 643
      i ++;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 644
    if ((int )n->cost == 0) {
      {
      {
#line 644
      printf((char const   */* __restrict  */)") ");
      }
      }
    }
  }
#line 646
  return;
}
}
#line 648 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void rprint_dictionary_data(Dict_node *n ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
#line 649
  if ((unsigned long )n == (unsigned long )((void *)0)) {
#line 649
    return;
  }
  {
  {
#line 650
  rprint_dictionary_data(n->left);
  }
  {
#line 651
  printf((char const   */* __restrict  */)"%s: ", n->string);
  }
  {
#line 652
  print_expression(n->exp);
  }
  {
#line 653
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 654
  rprint_dictionary_data(n->right);
  }
  }
#line 655
  return;
}
}
#line 657 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void print_dictionary_data(void) 
{ 


  {
  {
  {
#line 658
  rprint_dictionary_data(dict_root);
  }
  }
#line 659
  return;
}
}
#line 662 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void read_dictionary(void) 
{ 


  {
  {
  {
#line 663
  advance();
  }
  }
  {
  {
#line 664
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 664
    if (! ((int )token[0] != 0)) {
#line 664
      goto while_break;
    }
    {
    {
#line 665
    read_entry();
    }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 667
  return;
}
}
#line 692 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int dict_match(char *s , char *t ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 703
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 703
    if ((int )*s != 0) {
#line 703
      if (! ((int )*s == (int )*t)) {
#line 703
        goto while_break;
      }
    } else {
#line 703
      goto while_break;
    }
#line 703
    s ++;
#line 703
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 704
  if ((int )*s == 42) {
#line 704
    return (0);
  } else
#line 704
  if ((int )*t == 42) {
#line 704
    return (0);
  }
#line 705
  if ((int )*s == 46) {
#line 705
    tmp = '\000';
  } else {
#line 705
    tmp = (int )*s;
  }
#line 705
  if ((int )*t == 46) {
#line 705
    tmp___0 = '\000';
  } else {
#line 705
    tmp___0 = (int )*t;
  }
#line 705
  return (tmp - tmp___0);
}
}
#line 713 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int true_dict_match(char *s , char *t ) 
{ 
  char *ds ;
  char *dt ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
  {
#line 715
  ds = strrchr((char const   *)s, '.');
  }
  {
#line 716
  dt = strrchr((char const   *)t, '.');
  }
  }
#line 719
  if ((unsigned long )dt != (unsigned long )((void *)0)) {
#line 719
    if ((int )*(dt + 1) == 0) {
#line 719
      dt = (char *)((void *)0);
    } else {
      {
      {
#line 719
      tmp = __ctype_b_loc();
      }
      }
#line 719
      if ((int const   )*(*tmp + (int )*(dt + 1)) & 2048) {
#line 719
        dt = (char *)((void *)0);
      }
    }
  }
#line 720
  if ((unsigned long )ds != (unsigned long )((void *)0)) {
#line 720
    if ((int )*(ds + 1) == 0) {
#line 720
      ds = (char *)((void *)0);
    } else {
      {
      {
#line 720
      tmp___0 = __ctype_b_loc();
      }
      }
#line 720
      if ((int const   )*(*tmp___0 + (int )*(ds + 1)) & 2048) {
#line 720
        ds = (char *)((void *)0);
      }
    }
  }
#line 722
  if ((unsigned long )dt == (unsigned long )((void *)0)) {
#line 722
    if ((unsigned long )ds != (unsigned long )((void *)0)) {
      {
      {
#line 723
      tmp___1 = strlen((char const   *)t);
      }
      }
#line 723
      if ((long )((int )tmp___1) > ds - s) {
#line 723
        return (0);
      }
      {
      {
#line 724
      tmp___2 = strncmp((char const   *)s, (char const   *)t, (size_t )(ds - s));
      }
      }
#line 724
      return (tmp___2 == 0);
    } else {
#line 722
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 725
  if ((unsigned long )dt != (unsigned long )((void *)0)) {
#line 725
    if ((unsigned long )ds == (unsigned long )((void *)0)) {
      {
      {
#line 726
      tmp___3 = strlen((char const   *)s);
      }
      }
#line 726
      if ((long )((int )tmp___3) > dt - t) {
#line 726
        return (0);
      }
      {
      {
#line 727
      tmp___4 = strncmp((char const   *)s, (char const   *)t, (size_t )(dt - t));
      }
      }
#line 727
      return (tmp___4 == 0);
    } else {
      {
      {
#line 729
      tmp___5 = strcmp((char const   *)s, (char const   *)t);
      }
      }
#line 729
      return (tmp___5 == 0);
    }
  } else {
    {
    {
#line 729
    tmp___5 = strcmp((char const   *)s, (char const   *)t);
    }
    }
#line 729
    return (tmp___5 == 0);
  }
}
}
#line 733 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
static Dict_node *lookup_list  =    (Dict_node *)((void *)0);
#line 736 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void prune_lookup_list(char *s ) 
{ 
  Dict_node *dn ;
  Dict_node *dnx ;
  Dict_node *dn_new ;
  int tmp ;

  {
#line 738
  dn_new = (Dict_node *)((void *)0);
#line 739
  dn = lookup_list;
  {
  {
#line 739
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 739
    if (! ((unsigned long )dn != (unsigned long )((void *)0))) {
#line 739
      goto while_break;
    }
    {
#line 740
    dnx = dn->right;
    {
#line 742
    tmp = true_dict_match(dn->string, s);
    }
    }
#line 742
    if (tmp) {
#line 743
      dn->right = dn_new;
#line 744
      dn_new = dn;
    } else {
      {
      {
#line 746
      xfree((char *)dn, (int )sizeof(Dict_node ));
      }
      }
    }
#line 739
    dn = dnx;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 750
  lookup_list = (Dict_node *)((void *)0);
#line 751
  dn = dn_new;
  {
  {
#line 751
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 751
    if (! ((unsigned long )dn != (unsigned long )((void *)0))) {
#line 751
      goto while_break___0;
    }
#line 752
    dnx = dn->right;
#line 753
    dn->right = lookup_list;
#line 754
    lookup_list = dn;
#line 751
    dn = dnx;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 756
  return;
}
}
#line 758 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void free_lookup_list(void) 
{ 
  Dict_node *n ;

  {
  {
  {
#line 760
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 760
    if (! ((unsigned long )lookup_list != (unsigned long )((void *)0))) {
#line 760
      goto while_break;
    }
    {
#line 761
    n = lookup_list->right;
    {
#line 762
    xfree((char *)lookup_list, (int )sizeof(Dict_node ));
    }
#line 763
    lookup_list = n;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 765
  return;
}
}
#line 767 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void rdictionary_lookup(Dict_node *dn , char *s ) 
{ 
  int m ;
  Dict_node *dn_new ;
  void *tmp ;

  {
#line 771
  if ((unsigned long )dn == (unsigned long )((void *)0)) {
#line 771
    return;
  }
  {
  {
#line 772
  m = dict_match(s, dn->string);
  }
  }
#line 773
  if (m >= 0) {
    {
    {
#line 774
    rdictionary_lookup(dn->right, s);
    }
    }
  }
#line 776
  if (m == 0) {
    {
    {
#line 777
    tmp = xalloc((int )sizeof(Dict_node ));
    }
#line 777
    dn_new = (Dict_node *)tmp;
#line 778
    *dn_new = *dn;
#line 779
    dn_new->right = lookup_list;
#line 780
    lookup_list = dn_new;
    }
  }
#line 782
  if (m <= 0) {
    {
    {
#line 783
    rdictionary_lookup(dn->left, s);
    }
    }
  }
#line 785
  return;
}
}
#line 787 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Dict_node *dictionary_lookup(char *s ) 
{ 


  {
  {
  {
#line 795
  free_lookup_list();
  }
  {
#line 796
  rdictionary_lookup(dict_root, s);
  }
  {
#line 797
  prune_lookup_list(s);
  }
  }
#line 798
  return (lookup_list);
}
}
#line 825 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int boolean_dictionary_lookup(char *s ) 
{ 
  Dict_node *tmp ;

  {
  {
  {
#line 826
  tmp = dictionary_lookup(s);
  }
  }
#line 826
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 834 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void rabridged_lookup(Dict_node *dn , char *s ) 
{ 
  int m ;
  Dict_node *dn_new ;
  void *tmp ;
  int tmp___0 ;

  {
#line 837
  if ((unsigned long )dn == (unsigned long )((void *)0)) {
#line 837
    return;
  }
  {
  {
#line 838
  m = dict_match(s, dn->string);
  }
  }
#line 839
  if (m >= 0) {
    {
    {
#line 840
    rabridged_lookup(dn->right, s);
    }
    }
  }
#line 842
  if (m == 0) {
    {
    {
#line 842
    tmp___0 = is_idiom_word(dn->string);
    }
    }
#line 842
    if (! tmp___0) {
      {
      {
#line 843
      tmp = xalloc((int )sizeof(Dict_node ));
      }
#line 843
      dn_new = (Dict_node *)tmp;
#line 844
      *dn_new = *dn;
#line 845
      dn_new->right = lookup_list;
#line 846
      lookup_list = dn_new;
      }
    }
  }
#line 848
  if (m <= 0) {
    {
    {
#line 849
    rabridged_lookup(dn->left, s);
    }
    }
  }
#line 851
  return;
}
}
#line 853 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
Dict_node *abridged_lookup(char *s ) 
{ 


  {
  {
  {
#line 854
  free_lookup_list();
  }
  {
#line 855
  rabridged_lookup(dict_root, s);
  }
  {
#line 856
  prune_lookup_list(s);
  }
  }
#line 857
  return (lookup_list);
}
}
#line 860 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int boolean_abridged_lookup(char *s ) 
{ 
  Dict_node *tmp ;

  {
  {
  {
#line 862
  tmp = abridged_lookup(s);
  }
  }
#line 862
  return ((unsigned long )tmp != (unsigned long )((void *)0));
}
}
#line 867 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
static Dict_node *parent  ;
#line 868 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
static Dict_node *to_be_deleted  ;
#line 871 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int find_one_non_idiom_node(Dict_node *p , Dict_node *dn , char *s ) 
{ 
  int m ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 880
  if ((unsigned long )dn == (unsigned long )((void *)0)) {
#line 880
    return (0);
  }
  {
  {
#line 881
  m = dict_match(s, dn->string);
  }
  }
#line 882
  if (m <= 0) {
    {
    {
#line 883
    tmp = find_one_non_idiom_node(dn, dn->left, s);
    }
    }
#line 883
    if (tmp) {
#line 883
      return (1);
    }
  }
#line 886
  if (m == 0) {
    {
    {
#line 886
    tmp___0 = is_idiom_word(dn->string);
    }
    }
#line 886
    if (! tmp___0) {
#line 887
      to_be_deleted = dn;
#line 888
      parent = p;
#line 889
      return (1);
    }
  }
#line 891
  if (m >= 0) {
    {
    {
#line 892
    tmp___1 = find_one_non_idiom_node(dn, dn->right, s);
    }
    }
#line 892
    if (tmp___1) {
#line 892
      return (1);
    }
  }
#line 894
  return (0);
}
}
#line 897 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void set_parent_of_node(Dict_node *p , Dict_node *del , Dict_node *new ) 
{ 
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 898
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 899
    dict_root = new;
  } else
#line 901
  if ((unsigned long )p->left == (unsigned long )del) {
#line 902
    p->left = new;
  } else
#line 903
  if ((unsigned long )p->right == (unsigned long )del) {
#line 904
    p->right = new;
  } else {
    {
    {
#line 906
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Dictionary broken?");
    }
    {
#line 906
    exit(1);
    }
    }
  }
#line 909
  return;
}
}
#line 911 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
int delete_dictionary_words(char *s ) 
{ 
  Dict_node *pred ;
  Dict_node *pred_parent ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 916
  tmp = find_one_non_idiom_node((Dict_node *)((void *)0), dict_root, s);
  }
  }
#line 916
  if (! tmp) {
#line 916
    return (0);
  }
  {
  {
#line 917
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 919
    if ((unsigned long )to_be_deleted->file != (unsigned long )((void *)0)) {
#line 920
      (to_be_deleted->file)->changed = 1;
    }
#line 922
    if ((unsigned long )to_be_deleted->left == (unsigned long )((void *)0)) {
      {
      {
#line 923
      set_parent_of_node(parent, to_be_deleted, to_be_deleted->right);
      }
      {
#line 924
      xfree((char *)to_be_deleted, (int )sizeof(Dict_node ));
      }
      }
    } else {
#line 926
      pred_parent = to_be_deleted;
#line 927
      pred = to_be_deleted->left;
      {
      {
#line 928
      while (1) {
        while_continue___2: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 928
        if (! ((unsigned long )pred->right != (unsigned long )((void *)0))) {
#line 928
          goto while_break___0;
        }
#line 929
        pred_parent = pred;
#line 930
        pred = pred->right;
      }
      while_break___2: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 932
      to_be_deleted->string = pred->string;
#line 933
      to_be_deleted->file = pred->file;
#line 934
      to_be_deleted->exp = pred->exp;
      {
#line 935
      set_parent_of_node(pred_parent, pred, pred->left);
      }
      {
#line 936
      xfree((char *)pred, (int )sizeof(Dict_node ));
      }
      }
    }
    {
    {
#line 938
    tmp___0 = find_one_non_idiom_node((Dict_node *)((void *)0), dict_root, s);
    }
    }
#line 938
    if (! tmp___0) {
#line 938
      return (1);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 942 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/read-dict.c"
void open_dictionary(char *s ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;

  {
  {
  {
#line 943
  dict_file = fopen((char const   */* __restrict  */)s, (char const   */* __restrict  */)"r");
  }
  }
#line 943
  if ((unsigned long )dict_file == (unsigned long )((void *)0)) {
    {
    {
#line 944
    printf((char const   */* __restrict  */)"Cannot open file %s\n", s);
    }
    {
#line 945
    exit(1);
    }
    }
  }
#line 947
  return;
}
}
#line 312 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
Word sentence[250] ;
#line 314
int N_words ;
#line 321
int verbosity ;
#line 322
int maxlinklength ;
#line 323
int null_links ;
#line 356
char *deletable[250] ;
#line 386
void print_disjunct_counts(void) ;
#line 391
int match(Connector *a , Connector *b ) ;
#line 395
void prune(void) ;
#line 396
void power_prune(int mode ) ;
#line 397
int prune_match(Connector *a , Connector *b ) ;
#line 413
Disjunct *eliminate_duplicate_disjuncts(Disjunct *d ) ;
#line 452
void expression_prune(void) ;
#line 455
void print_expression_sizes(void) ;
#line 56 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int prune_match(Connector *a , Connector *b ) 
{ 
  char *s ;
  char *t ;
  int x ;
  int y ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 66
  if ((int )a->label != (int )b->label) {
#line 66
    return (0);
  }
#line 67
  x = (int )a->priority;
#line 68
  y = (int )b->priority;
#line 70
  s = a->string;
#line 71
  t = b->string;
  {
  {
#line 73
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 73
    tmp = __ctype_b_loc();
    }
    }
#line 73
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
      {
      {
#line 73
      tmp___0 = __ctype_b_loc();
      }
      }
#line 73
      if (! ((int const   )*(*tmp___0 + (int )*t) & 256)) {
#line 73
        goto while_break;
      }
    }
#line 74
    if ((int )*s != (int )*t) {
#line 74
      return (0);
    }
#line 75
    s ++;
#line 76
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 79
  if (x == 0) {
#line 79
    if (y == 0) {
#line 93
      if ((int )*(a->string) == 83) {
#line 93
        if ((int )*s == 115) {
#line 93
          goto _L___0;
        } else
#line 93
        if ((int )*s == 112) {
          _L___0: /* CIL Label */ 
#line 93
          if ((int )*t == 112) {
#line 93
            goto _L;
          } else
#line 93
          if ((int )*t == 115) {
            _L: /* CIL Label */ 
#line 93
            if ((unsigned long )(s - 1) == (unsigned long )a->string) {
#line 96
              return (1);
            } else
#line 93
            if ((unsigned long )(s - 2) == (unsigned long )a->string) {
#line 93
              if ((int )*(s - 1) == 73) {
#line 96
                return (1);
              }
            }
          }
        }
      }
      {
      {
#line 106
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 106
        if ((int )*s != 0) {
#line 106
          if (! ((int )*t != 0)) {
#line 106
            goto while_break___0;
          }
        } else {
#line 106
          goto while_break___0;
        }
#line 107
        if ((int )*s == 42) {
#line 112
          s ++;
#line 113
          t ++;
        } else
#line 107
        if ((int )*t == 42) {
#line 112
          s ++;
#line 113
          t ++;
        } else
#line 107
        if ((int )*s == (int )*t) {
#line 107
          if ((int )*s != 94) {
#line 112
            s ++;
#line 113
            t ++;
          } else {
#line 114
            return (0);
          }
        } else {
#line 114
          return (0);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 116
      return (1);
    } else {
#line 79
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 117
  if (x == 1) {
#line 117
    if (y == 2) {
      {
      {
#line 118
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 118
        if ((int )*s != 0) {
#line 118
          if (! ((int )*t != 0)) {
#line 118
            goto while_break___1;
          }
        } else {
#line 118
          goto while_break___1;
        }
#line 119
        if ((int )*s == (int )*t) {
#line 122
          s ++;
#line 123
          t ++;
        } else
#line 119
        if ((int )*s == 42) {
#line 122
          s ++;
#line 123
          t ++;
        } else
#line 119
        if ((int )*t == 94) {
#line 122
          s ++;
#line 123
          t ++;
        } else {
#line 124
          return (0);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 126
      return (1);
    } else {
#line 117
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 127
  if (y == 1) {
#line 127
    if (x == 2) {
      {
      {
#line 128
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 128
        if ((int )*s != 0) {
#line 128
          if (! ((int )*t != 0)) {
#line 128
            goto while_break___2;
          }
        } else {
#line 128
          goto while_break___2;
        }
#line 129
        if ((int )*s == (int )*t) {
#line 130
          s ++;
#line 131
          t ++;
        } else
#line 129
        if ((int )*t == 42) {
#line 130
          s ++;
#line 131
          t ++;
        } else
#line 129
        if ((int )*s == 94) {
#line 130
          s ++;
#line 131
          t ++;
        } else {
#line 132
          return (0);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 134
      return (1);
    } else {
#line 135
      return (0);
    }
  } else {
#line 135
    return (0);
  }
}
}
#line 138 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static int s_table_size  ;
#line 139 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static Connector **table  ;
#line 141 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void free_S(void) 
{ 
  int i ;

  {
#line 144
  i = 0;
  {
  {
#line 144
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 144
    if (! (i < s_table_size)) {
#line 144
      goto while_break;
    }
#line 145
    if ((unsigned long )*(table + i) == (unsigned long )((void *)0)) {
#line 145
      goto __Cont;
    }
    {
    {
#line 146
    free_connectors(*(table + i));
    }
#line 147
    *(table + i) = (Connector *)((void *)0);
    }
    __Cont: /* CIL Label */ 
#line 144
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return;
}
}
#line 151 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int hash_S(Connector *c ) 
{ 
  char *s ;
  int i ;
  unsigned short const   **tmp ;

  {
#line 158
  i = (int )c->label;
#line 159
  s = c->string;
  {
  {
#line 160
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 160
    tmp = __ctype_b_loc();
    }
    }
#line 160
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
#line 160
      goto while_break;
    }
#line 161
    i = (int )((unsigned int )(i + (i << 1)) + randtable[((int )*s + i) & 255]);
#line 162
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return (i & (s_table_size - 1));
}
}
#line 167 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void insert_S(Connector *c ) 
{ 
  int h ;
  Connector *e ;
  int tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 172
  h = hash_S(c);
  }
#line 174
  e = *(table + h);
  }
  {
  {
#line 174
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 174
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 174
      goto while_break;
    }
    {
    {
#line 175
    tmp = strcmp((char const   *)c->string, (char const   *)e->string);
    }
    }
#line 175
    if (tmp == 0) {
#line 175
      if ((int )c->label == (int )e->label) {
#line 175
        if ((int )c->priority == (int )e->priority) {
#line 177
          return;
        }
      }
    }
#line 174
    e = e->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 180
  tmp___0 = xalloc((int )sizeof(Connector ));
  }
#line 180
  e = (Connector *)tmp___0;
#line 181
  *e = *c;
#line 182
  e->next = *(table + h);
#line 183
  *(table + h) = e;
  }
#line 184
  return;
}
}
#line 187 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void zero_S(void) 
{ 
  int i ;

  {
#line 189
  i = 0;
  {
  {
#line 189
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 189
    if (! (i < s_table_size)) {
#line 189
      goto while_break;
    }
#line 190
    *(table + i) = (Connector *)((void *)0);
#line 189
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 192
  return;
}
}
#line 194 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void init_S(Connector *c ) 
{ 
  int h ;
  Connector *c1 ;
  void *tmp ;

  {
  {
  {
#line 198
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 198
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 198
      goto while_break;
    }
    {
    {
#line 199
    h = hash_S(c);
    }
    {
#line 200
    tmp = xalloc((int )sizeof(Connector ));
    }
#line 200
    c1 = (Connector *)tmp;
#line 201
    *c1 = *c;
#line 202
    c1->next = *(table + h);
#line 203
    *(table + h) = c1;
#line 198
    c = c->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return;
}
}
#line 207 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int matches_S(Connector *c , int dir ) 
{ 
  int h ;
  Connector *e ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 215
  h = hash_S(c);
  }
  }
#line 216
  if (dir == 45) {
#line 217
    e = *(table + h);
    {
    {
#line 217
    while (1) {
      while_continue___1: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 217
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 217
        goto while_break;
      }
      {
      {
#line 218
      tmp = prune_match(e, c);
      }
      }
#line 218
      if (tmp) {
#line 218
        return (1);
      }
#line 217
      e = e->next;
    }
    while_break___1: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 221
    e = *(table + h);
    {
    {
#line 221
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 221
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 221
        goto while_break___0;
      }
      {
      {
#line 222
      tmp___0 = prune_match(c, e);
      }
      }
#line 222
      if (tmp___0) {
#line 222
        return (1);
      }
#line 221
      e = e->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 225
  return (0);
}
}
#line 228 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void clean_up(int w ) 
{ 
  Disjunct head_disjunct ;
  Disjunct *d ;
  Disjunct *d1 ;

  {
#line 234
  d = & head_disjunct;
#line 236
  d->next = sentence[w].d;
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 238
    if (! ((unsigned long )d->next != (unsigned long )((void *)0))) {
#line 238
      goto while_break;
    }
#line 239
    if ((unsigned long )(d->next)->left == (unsigned long )((void *)0)) {
#line 239
      if ((unsigned long )(d->next)->right == (unsigned long )((void *)0)) {
        {
#line 240
        d1 = d->next;
#line 241
        d->next = d1->next;
        {
#line 242
        xfree((char *)d1, (int )sizeof(Disjunct ));
        }
        }
      } else {
#line 244
        d = d->next;
      }
    } else {
#line 244
      d = d->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  sentence[w].d = head_disjunct.next;
#line 248
  return;
}
}
#line 250 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int count_disjuncts(Disjunct *d ) 
{ 
  int count___0 ;

  {
#line 252
  count___0 = 0;
  {
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 253
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 253
      goto while_break;
    }
#line 254
    count___0 ++;
#line 253
    d = d->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  return (count___0);
}
}
#line 259 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int count_disjuncts_in_sentence(void) 
{ 
  int w ;
  int count___0 ;
  int tmp ;

  {
#line 262
  count___0 = 0;
#line 263
  w = 0;
  {
  {
#line 263
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 263
    if (! (w < N_words)) {
#line 263
      goto while_break;
    }
    {
    {
#line 264
    tmp = count_disjuncts(sentence[w].d);
    }
#line 264
    count___0 += tmp;
#line 263
    w ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return (count___0);
}
}
#line 269 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void prune(void) 
{ 
  int N_deleted ;
  Disjunct *d ;
  Connector *e ;
  int w ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  Connector *tmp___2 ;
  int tmp___3 ;
  Connector *tmp___4 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 275
  tmp = count_disjuncts_in_sentence();
  }
  {
#line 275
  s_table_size = next_power_of_two_up(tmp);
  }
  {
#line 276
  tmp___0 = xalloc((int )((unsigned long )s_table_size * sizeof(Connector *)));
  }
#line 276
  table = (Connector **)tmp___0;
  {
#line 280
  zero_S();
  }
#line 281
  N_deleted = 1;
  }
  {
  {
#line 283
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 286
    w = 0;
    {
    {
#line 286
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 286
      if (! (w < N_words)) {
#line 286
        goto while_break___0;
      }
#line 287
      d = sentence[w].d;
      {
      {
#line 287
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 287
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 287
          goto while_break___1;
        }
#line 288
        e = d->left;
        {
        {
#line 288
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 288
          if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 288
            goto while_break___2;
          }
          {
          {
#line 289
          tmp___1 = matches_S(e, '-');
          }
          }
#line 289
          if (! tmp___1) {
#line 289
            goto while_break___2;
          }
#line 288
          e = e->next;
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 291
        if ((unsigned long )e != (unsigned long )((void *)0)) {
          {
#line 293
          N_deleted ++;
          {
#line 294
          free_connectors(d->left);
          }
          {
#line 295
          free_connectors(d->right);
          }
#line 296
          tmp___2 = (Connector *)((void *)0);
#line 296
          d->right = tmp___2;
#line 296
          d->left = tmp___2;
          }
        }
#line 287
        d = d->next;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 299
      clean_up(w);
      }
#line 300
      d = sentence[w].d;
      }
      {
      {
#line 300
      while (1) {
        while_continue___14: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 300
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 300
          goto while_break___3;
        }
#line 301
        e = d->right;
        {
        {
#line 301
        while (1) {
          while_continue___15: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 301
          if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 301
            goto while_break___4;
          }
          {
          {
#line 302
          insert_S(e);
          }
#line 301
          e = e->next;
          }
        }
        while_break___15: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 300
        d = d->next;
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 286
      w ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 307
    if (verbosity > 2) {
      {
      {
#line 308
      printf((char const   */* __restrict  */)"l->r pass removed %d\n", N_deleted);
      }
      {
#line 309
      print_disjunct_counts();
      }
      }
    }
    {
    {
#line 311
    free_S();
    }
    }
#line 312
    if (N_deleted == 0) {
#line 312
      goto while_break;
    }
#line 315
    N_deleted = 0;
#line 316
    w = N_words - 1;
    {
    {
#line 316
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 316
      if (! (w >= 0)) {
#line 316
        goto while_break___5;
      }
#line 317
      d = sentence[w].d;
      {
      {
#line 317
      while (1) {
        while_continue___17: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 317
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 317
          goto while_break___6;
        }
#line 318
        e = d->right;
        {
        {
#line 318
        while (1) {
          while_continue___18: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 318
          if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 318
            goto while_break___7;
          }
          {
          {
#line 319
          tmp___3 = matches_S(e, '+');
          }
          }
#line 319
          if (! tmp___3) {
#line 319
            goto while_break___7;
          }
#line 318
          e = e->next;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
#line 321
        if ((unsigned long )e != (unsigned long )((void *)0)) {
          {
#line 323
          N_deleted ++;
          {
#line 324
          free_connectors(d->left);
          }
          {
#line 325
          free_connectors(d->right);
          }
#line 326
          tmp___4 = (Connector *)((void *)0);
#line 326
          d->right = tmp___4;
#line 326
          d->left = tmp___4;
          }
        }
#line 317
        d = d->next;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
      {
#line 329
      clean_up(w);
      }
#line 330
      d = sentence[w].d;
      }
      {
      {
#line 330
      while (1) {
        while_continue___19: /* CIL Label */ ;
        while_continue___8: /* CIL Label */ ;
#line 330
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 330
          goto while_break___8;
        }
#line 331
        e = d->left;
        {
        {
#line 331
        while (1) {
          while_continue___20: /* CIL Label */ ;
          while_continue___9: /* CIL Label */ ;
#line 331
          if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 331
            goto while_break___9;
          }
          {
          {
#line 332
          insert_S(e);
          }
#line 331
          e = e->next;
          }
        }
        while_break___20: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
#line 330
        d = d->next;
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 316
      w --;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 336
    if (verbosity > 2) {
      {
      {
#line 337
      printf((char const   */* __restrict  */)"r->l pass removed %d\n", N_deleted);
      }
      {
#line 338
      print_disjunct_counts();
      }
      }
    }
    {
    {
#line 340
    free_S();
    }
    }
#line 341
    if (N_deleted == 0) {
#line 341
      goto while_break;
    }
#line 342
    N_deleted = 0;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 344
  xfree((char *)table, (int )((unsigned long )s_table_size * sizeof(Connector *)));
  }
  }
#line 345
  return;
}
}
#line 352 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static int dup_table_size  ;
#line 353 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static Disjunct **dup_table  ;
#line 355 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int string_hash(char *s , int i ) 
{ 


  {
  {
  {
#line 357
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 357
    if (! ((int )*s != 0)) {
#line 357
      goto while_break;
    }
#line 357
    i = (int )((unsigned int )(i + (i << 1)) + randtable[((int )*s + i) & 255]);
#line 357
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 358
  return (i & (dup_table_size - 1));
}
}
#line 582 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int old_hash_disjunct(Disjunct *d ) 
{ 
  int i ;
  Connector *e ;
  int tmp ;

  {
#line 586
  i = 0;
#line 587
  e = d->left;
  {
  {
#line 587
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 587
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 587
      goto while_break;
    }
    {
    {
#line 588
    i = string_hash(e->string, i);
    }
#line 587
    e = e->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 590
  e = d->right;
  {
  {
#line 590
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 590
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 590
      goto while_break___0;
    }
    {
    {
#line 591
    i = string_hash(e->string, i);
    }
#line 590
    e = e->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 593
  tmp = string_hash(d->string, i);
  }
  }
#line 593
  return (tmp);
}
}
#line 596 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int connectors_equal_prune(Connector *c1 , Connector *c2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 601
  if ((int )c1->label == (int )c2->label) {
#line 601
    if ((int )c1->multi == (int )c2->multi) {
#line 601
      if ((int )c1->priority == (int )c2->priority) {
        {
        {
#line 601
        tmp = strcmp((char const   *)c1->string, (char const   *)c2->string);
        }
        }
#line 601
        if (tmp == 0) {
#line 601
          tmp___0 = 1;
        } else {
#line 601
          tmp___0 = 0;
        }
      } else {
#line 601
        tmp___0 = 0;
      }
    } else {
#line 601
      tmp___0 = 0;
    }
  } else {
#line 601
    tmp___0 = 0;
  }
#line 601
  return (tmp___0);
}
}
#line 607 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int disjuncts_equal(Disjunct *d1 , Disjunct *d2 ) 
{ 
  Connector *e1 ;
  Connector *e2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 610
  e1 = d1->left;
#line 611
  e2 = d2->left;
  {
  {
#line 612
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 612
    if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 612
      if (! ((unsigned long )e2 != (unsigned long )((void *)0))) {
#line 612
        goto while_break;
      }
    } else {
#line 612
      goto while_break;
    }
    {
    {
#line 613
    tmp = connectors_equal_prune(e1, e2);
    }
    }
#line 613
    if (! tmp) {
#line 613
      goto while_break;
    }
#line 614
    e1 = e1->next;
#line 615
    e2 = e2->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 617
  if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 617
    return (0);
  } else
#line 617
  if ((unsigned long )e2 != (unsigned long )((void *)0)) {
#line 617
    return (0);
  }
#line 618
  e1 = d1->right;
#line 619
  e2 = d2->right;
  {
  {
#line 620
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 620
    if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 620
      if (! ((unsigned long )e2 != (unsigned long )((void *)0))) {
#line 620
        goto while_break___0;
      }
    } else {
#line 620
      goto while_break___0;
    }
    {
    {
#line 621
    tmp___0 = connectors_equal_prune(e1, e2);
    }
    }
#line 621
    if (! tmp___0) {
#line 621
      goto while_break___0;
    }
#line 622
    e1 = e1->next;
#line 623
    e2 = e2->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 625
  if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 625
    return (0);
  } else
#line 625
  if ((unsigned long )e2 != (unsigned long )((void *)0)) {
#line 625
    return (0);
  }
  {
  {
#line 626
  tmp___1 = strcmp((char const   *)d1->string, (char const   *)d2->string);
  }
  }
#line 626
  return (tmp___1 == 0);
}
}
#line 629 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
Disjunct *eliminate_duplicate_disjuncts(Disjunct *d ) 
{ 
  int i ;
  int h ;
  int count___0 ;
  Disjunct *dn ;
  Disjunct *dx ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  char *__cil_tmp10 ;

  {
  {
#line 636
  count___0 = 0;
  {
#line 637
  tmp = count_disjuncts(d);
  }
  {
#line 637
  dup_table_size = next_power_of_two_up(2 * tmp);
  }
  {
#line 638
  tmp___0 = xalloc((int )((unsigned long )dup_table_size * sizeof(Disjunct *)));
  }
#line 638
  dup_table = (Disjunct **)tmp___0;
#line 639
  i = 0;
  }
  {
  {
#line 639
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 639
    if (! (i < dup_table_size)) {
#line 639
      goto while_break;
    }
#line 639
    *(dup_table + i) = (Disjunct *)((void *)0);
#line 639
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 640
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 640
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 640
      goto while_break___0;
    }
    {
#line 641
    dn = d->next;
    {
#line 642
    h = old_hash_disjunct(d);
    }
#line 644
    dx = *(dup_table + h);
    }
    {
    {
#line 644
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 644
      if (! ((unsigned long )dx != (unsigned long )((void *)0))) {
#line 644
        goto while_break___1;
      }
      {
      {
#line 645
      tmp___1 = disjuncts_equal(dx, d);
      }
      }
#line 645
      if (tmp___1) {
#line 645
        goto while_break___1;
      }
#line 644
      dx = dx->next;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 647
    if ((unsigned long )dx == (unsigned long )((void *)0)) {
#line 648
      d->next = *(dup_table + h);
#line 649
      *(dup_table + h) = d;
    } else {
#line 651
      d->next = (Disjunct *)((void *)0);
#line 652
      if ((int )d->cost < (int )dx->cost) {
#line 652
        dx->cost = d->cost;
      }
      {
      {
#line 653
      free_disjuncts(d);
      }
#line 654
      count___0 ++;
      }
    }
#line 656
    d = dn;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 659
  i = 0;
  {
  {
#line 659
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 659
    if (! (i < dup_table_size)) {
#line 659
      goto while_break___2;
    }
#line 660
    dn = *(dup_table + i);
    {
    {
#line 660
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 660
      if (! ((unsigned long )dn != (unsigned long )((void *)0))) {
#line 660
        goto while_break___3;
      }
#line 661
      dx = dn->next;
#line 662
      dn->next = d;
#line 663
      d = dn;
#line 660
      dn = dx;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 659
    i ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 666
  xfree((char *)dup_table, (int )((unsigned long )dup_table_size * sizeof(Disjunct *)));
  }
  }
#line 667
  if (verbosity > 2) {
#line 667
    if (count___0 != 0) {
      {
      {
#line 667
      printf((char const   */* __restrict  */)"killed %d duplicates\n", count___0);
      }
      }
    }
  }
#line 668
  return (d);
}
}
#line 679 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int size_of_sentence_expressions(void) 
{ 
  X_node *x ;
  int w ;
  int size ;
  int tmp ;

  {
#line 685
  size = 0;
#line 686
  w = 0;
  {
  {
#line 686
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 686
    if (! (w < N_words)) {
#line 686
      goto while_break;
    }
#line 687
    x = sentence[w].x;
    {
    {
#line 687
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 687
      if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 687
        goto while_break___0;
      }
      {
      {
#line 688
      tmp = size_of_expression(x->exp);
      }
#line 688
      size += tmp;
#line 687
      x = x->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 686
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 691
  return (size);
}
}
#line 702
int and_purge_E_list(E_list *l ) ;
#line 703
E_list *or_purge_E_list(E_list *l ) ;
#line 705 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
Exp *purge_Exp(Exp *e ) 
{ 
  int tmp ;

  {
#line 710
  if ((int )e->type == 2) {
#line 711
    if ((unsigned long )e->u.string == (unsigned long )((void *)0)) {
      {
      {
#line 712
      xfree((char *)e, (int )sizeof(Exp ));
      }
      }
#line 713
      return ((Exp *)((void *)0));
    } else {
#line 715
      return (e);
    }
  }
#line 718
  if ((int )e->type == 1) {
    {
    {
#line 719
    tmp = and_purge_E_list(e->u.l);
    }
    }
#line 719
    if (tmp == 0) {
      {
      {
#line 720
      xfree((char *)e, (int )sizeof(Exp ));
      }
      }
#line 721
      return ((Exp *)((void *)0));
    }
  } else {
    {
    {
#line 724
    e->u.l = or_purge_E_list(e->u.l);
    }
    }
#line 725
    if ((unsigned long )e->u.l == (unsigned long )((void *)0)) {
      {
      {
#line 726
      xfree((char *)e, (int )sizeof(Exp ));
      }
      }
#line 727
      return ((Exp *)((void *)0));
    }
  }
#line 744
  return (e);
}
}
#line 747 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int and_purge_E_list(E_list *l ) 
{ 
  Exp *tmp ;
  int tmp___0 ;

  {
#line 750
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 750
    return (1);
  }
  {
  {
#line 751
  tmp = purge_Exp(l->e);
  }
#line 751
  l->e = tmp;
  }
#line 751
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    {
#line 752
    free_E_list(l->next);
    }
    {
#line 753
    xfree((char *)l, (int )sizeof(E_list ));
    }
    }
#line 754
    return (0);
  }
  {
  {
#line 756
  tmp___0 = and_purge_E_list(l->next);
  }
  }
#line 756
  if (tmp___0 == 0) {
    {
    {
#line 757
    free_Exp(l->e);
    }
    {
#line 758
    xfree((char *)l, (int )sizeof(E_list ));
    }
    }
#line 759
    return (0);
  }
#line 761
  return (1);
}
}
#line 764 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
E_list *or_purge_E_list(E_list *l ) 
{ 
  E_list *el ;
  Exp *tmp ;

  {
#line 767
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 767
    return ((E_list *)((void *)0));
  }
  {
  {
#line 768
  tmp = purge_Exp(l->e);
  }
#line 768
  l->e = tmp;
  }
#line 768
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
    {
#line 769
    el = or_purge_E_list(l->next);
    }
    {
#line 770
    xfree((char *)l, (int )sizeof(E_list ));
    }
    }
#line 771
    return (el);
  }
  {
  {
#line 773
  l->next = or_purge_E_list(l->next);
  }
  }
#line 774
  return (l);
}
}
#line 777 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int mark_dead_connectors(Exp *e , int dir ) 
{ 
  Connector dummy ;
  int count___0 ;
  E_list *l ;
  int tmp ;
  int tmp___0 ;

  {
#line 785
  dummy.label = (short)-1;
#line 786
  dummy.priority = (char)0;
#line 787
  count___0 = 0;
#line 788
  if ((int )e->type == 2) {
#line 789
    if ((int )e->dir == dir) {
      {
#line 790
      dummy.string = e->u.string;
      {
#line 791
      tmp = matches_S(& dummy, dir);
      }
      }
#line 791
      if (! tmp) {
#line 792
        e->u.string = (char *)((void *)0);
#line 793
        count___0 ++;
      }
    }
  } else {
#line 797
    l = e->u.l;
    {
    {
#line 797
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 797
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 797
        goto while_break;
      }
      {
      {
#line 798
      tmp___0 = mark_dead_connectors(l->e, dir);
      }
#line 798
      count___0 += tmp___0;
#line 797
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 801
  return (count___0);
}
}
#line 804 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void insert_connectors(Exp *e , int dir ) 
{ 
  Connector dummy ;
  E_list *l ;

  {
#line 808
  dummy.label = (short)-1;
#line 809
  dummy.priority = (char)0;
#line 810
  if ((int )e->type == 2) {
#line 811
    if ((int )e->dir == dir) {
      {
#line 812
      dummy.string = e->u.string;
      {
#line 813
      insert_S(& dummy);
      }
      }
    }
  } else {
#line 816
    l = e->u.l;
    {
    {
#line 816
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 816
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 816
        goto while_break;
      }
      {
      {
#line 817
      insert_connectors(l->e, dir);
      }
#line 816
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 820
  return;
}
}
#line 822 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void clean_up_expressions(int w ) 
{ 
  X_node head_node ;
  X_node *d ;
  X_node *d1 ;

  {
#line 827
  d = & head_node;
#line 828
  d->next = sentence[w].x;
  {
  {
#line 829
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 829
    if (! ((unsigned long )d->next != (unsigned long )((void *)0))) {
#line 829
      goto while_break;
    }
#line 830
    if ((unsigned long )(d->next)->exp == (unsigned long )((void *)0)) {
      {
#line 831
      d1 = d->next;
#line 832
      d->next = d1->next;
      {
#line 833
      xfree((char *)d1, (int )sizeof(X_node ));
      }
      }
    } else {
#line 835
      d = d->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 838
  sentence[w].x = head_node.next;
#line 839
  return;
}
}
#line 841 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void expression_prune(void) 
{ 
  int N_deleted ;
  X_node *x ;
  int w ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 846
  tmp = size_of_sentence_expressions();
  }
  {
#line 846
  s_table_size = next_power_of_two_up(tmp);
  }
  {
#line 847
  tmp___0 = xalloc((int )((unsigned long )s_table_size * sizeof(Connector *)));
  }
#line 847
  table = (Connector **)tmp___0;
  {
#line 849
  zero_S();
  }
#line 850
  N_deleted = 1;
  }
  {
  {
#line 852
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 854
    w = 0;
    {
    {
#line 854
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 854
      if (! (w < N_words)) {
#line 854
        goto while_break___0;
      }
#line 855
      x = sentence[w].x;
      {
      {
#line 855
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 855
        if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 855
          goto while_break___1;
        }
        {
        {
#line 857
        tmp___1 = mark_dead_connectors(x->exp, '-');
        }
#line 857
        N_deleted += tmp___1;
#line 855
        x = x->next;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 860
      x = sentence[w].x;
      {
      {
#line 860
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 860
        if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 860
          goto while_break___2;
        }
        {
        {
#line 862
        x->exp = purge_Exp(x->exp);
        }
#line 860
        x = x->next;
        }
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      {
#line 865
      clean_up_expressions(w);
      }
#line 866
      x = sentence[w].x;
      }
      {
      {
#line 866
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 866
        if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 866
          goto while_break___3;
        }
        {
        {
#line 867
        insert_connectors(x->exp, '+');
        }
#line 866
        x = x->next;
        }
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 854
      w ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 871
    if (verbosity > 2) {
      {
      {
#line 872
      printf((char const   */* __restrict  */)"l->r pass removed %d\n", N_deleted);
      }
      {
#line 873
      print_expression_sizes();
      }
      }
    }
    {
    {
#line 876
    free_S();
    }
    }
#line 877
    if (N_deleted == 0) {
#line 877
      goto while_break;
    }
#line 880
    N_deleted = 0;
#line 881
    w = N_words - 1;
    {
    {
#line 881
    while (1) {
      while_continue___13: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 881
      if (! (w >= 0)) {
#line 881
        goto while_break___4;
      }
#line 882
      x = sentence[w].x;
      {
      {
#line 882
      while (1) {
        while_continue___14: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 882
        if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 882
          goto while_break___5;
        }
        {
        {
#line 884
        tmp___2 = mark_dead_connectors(x->exp, '+');
        }
#line 884
        N_deleted += tmp___2;
#line 882
        x = x->next;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 887
      x = sentence[w].x;
      {
      {
#line 887
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 887
        if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 887
          goto while_break___6;
        }
        {
        {
#line 889
        x->exp = purge_Exp(x->exp);
        }
#line 887
        x = x->next;
        }
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
      {
#line 892
      clean_up_expressions(w);
      }
#line 893
      x = sentence[w].x;
      }
      {
      {
#line 893
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 893
        if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 893
          goto while_break___7;
        }
        {
        {
#line 894
        insert_connectors(x->exp, '-');
        }
#line 893
        x = x->next;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 881
      w --;
    }
    while_break___13: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 898
    if (verbosity > 2) {
      {
      {
#line 899
      printf((char const   */* __restrict  */)"r->l pass removed %d\n", N_deleted);
      }
      {
#line 900
      print_expression_sizes();
      }
      }
    }
    {
    {
#line 902
    free_S();
    }
    }
#line 903
    if (N_deleted == 0) {
#line 903
      goto while_break;
    }
#line 904
    N_deleted = 0;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 906
  xfree((char *)table, (int )((unsigned long )s_table_size * sizeof(Connector *)));
  }
  }
#line 907
  return;
}
}
#line 961 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static int power_cost  ;
#line 962 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static int power_prune_mode  ;
#line 965 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int left_connector_count(Disjunct *d ) 
{ 
  Connector *c ;
  int i ;

  {
#line 968
  i = 0;
  {
  {
#line 969
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 969
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 969
      goto while_break;
    }
#line 970
    c = d->left;
    {
    {
#line 970
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 970
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 970
        goto while_break___0;
      }
#line 970
      i ++;
#line 970
      c = c->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 969
    d = d->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 972
  return (i);
}
}
#line 974 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int right_connector_count(Disjunct *d ) 
{ 
  Connector *c ;
  int i ;

  {
#line 976
  i = 0;
  {
  {
#line 977
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 977
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 977
      goto while_break;
    }
#line 978
    c = d->right;
    {
    {
#line 978
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 978
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 978
        goto while_break___0;
      }
#line 978
      i ++;
#line 978
      c = c->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 977
    d = d->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 980
  return (i);
}
}
#line 988 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static int l_table_size[250]  ;
#line 989 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static int r_table_size[250]  ;
#line 991 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static C_list **l_table[250]  ;
#line 993 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static C_list **r_table[250]  ;
#line 995 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void free_C_list(C_list *t ) 
{ 
  C_list *xt ;

  {
  {
  {
#line 997
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 997
    if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 997
      goto while_break;
    }
    {
#line 998
    xt = t->next;
    {
#line 999
    xfree((char *)t, (int )sizeof(C_list ));
    }
#line 997
    t = xt;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1001
  return;
}
}
#line 1003 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void free_power_tables(void) 
{ 
  int w ;
  int i ;

  {
#line 1007
  w = 0;
  {
  {
#line 1007
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1007
    if (! (w < N_words)) {
#line 1007
      goto while_break;
    }
#line 1008
    i = 0;
    {
    {
#line 1008
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1008
      if (! (i < l_table_size[w])) {
#line 1008
        goto while_break___0;
      }
      {
      {
#line 1009
      free_C_list(*(l_table[w] + i));
      }
#line 1008
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 1011
    xfree((char *)l_table[w], (int )((unsigned long )l_table_size[w] * sizeof(C_list *)));
    }
#line 1012
    i = 0;
    }
    {
    {
#line 1012
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1012
      if (! (i < r_table_size[w])) {
#line 1012
        goto while_break___1;
      }
      {
      {
#line 1013
      free_C_list(*(r_table[w] + i));
      }
#line 1012
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 1015
    xfree((char *)r_table[w], (int )((unsigned long )r_table_size[w] * sizeof(C_list *)));
    }
#line 1007
    w ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1017
  return;
}
}
#line 1019 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int power_hash(Connector *c ) 
{ 
  char *s ;
  int i ;
  unsigned short const   **tmp ;

  {
#line 1029
  i = (int )randtable[(int )c->label & 255];
#line 1030
  s = c->string;
  {
  {
#line 1031
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1031
    tmp = __ctype_b_loc();
    }
    }
#line 1031
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
#line 1031
      goto while_break;
    }
#line 1032
    i = (int )((unsigned int )(i + (i << 1)) + randtable[((int )*s + i) & 255]);
#line 1033
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1035
  return (i);
}
}
#line 1038 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void put_into_power_table(int size , C_list **t , Connector *c , int shal ) 
{ 
  int h ;
  C_list *m ;
  int tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 1044
  tmp = power_hash(c);
  }
#line 1044
  h = tmp & (size - 1);
  {
#line 1045
  tmp___0 = xalloc((int )sizeof(C_list ));
  }
#line 1045
  m = (C_list *)tmp___0;
#line 1046
  m->next = *(t + h);
#line 1047
  *(t + h) = m;
#line 1048
  m->c = c;
#line 1049
  m->shallow = shal;
  }
#line 1050
  return;
}
}
#line 1052 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int set_dist_fields(Connector *c , int w , int delta ) 
{ 
  int i ;
  int tmp ;

  {
#line 1054
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1054
    return (w);
  }
  {
  {
#line 1055
  tmp = set_dist_fields(c->next, w, delta);
  }
#line 1055
  i = tmp + delta;
#line 1056
  c->word = (short )i;
  }
#line 1057
  return (i);
}
}
#line 1060 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void init_power(void) 
{ 
  int w ;
  int len ;
  int size ;
  int i ;
  C_list **t ;
  Disjunct *d ;
  Disjunct *xd ;
  Disjunct *head ;
  Connector *c ;
  int tmp ;
  int tmp___0 ;
  C_list **tmp___1 ;
  void *tmp___2 ;
  C_list **tmp___3 ;
  void *tmp___4 ;

  {
#line 1068
  w = 0;
  {
  {
#line 1068
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1068
    if (! (w < N_words)) {
#line 1068
      goto while_break;
    }
#line 1069
    head = (Disjunct *)((void *)0);
#line 1070
    d = sentence[w].d;
    {
    {
#line 1070
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1070
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1070
        goto while_break___0;
      }
      {
#line 1071
      xd = d->next;
      {
#line 1072
      tmp = set_dist_fields(d->left, w, -1);
      }
      }
#line 1072
      if (tmp < 0) {
        {
#line 1074
        d->next = (Disjunct *)((void *)0);
        {
#line 1075
        free_disjuncts(d);
        }
        }
      } else {
        {
        {
#line 1072
        tmp___0 = set_dist_fields(d->right, w, 1);
        }
        }
#line 1072
        if (tmp___0 >= N_words) {
          {
#line 1074
          d->next = (Disjunct *)((void *)0);
          {
#line 1075
          free_disjuncts(d);
          }
          }
        } else {
#line 1077
          d->next = head;
#line 1078
          head = d;
        }
      }
#line 1070
      d = xd;
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1081
    sentence[w].d = head;
#line 1068
    w ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1084
  w = 0;
  {
  {
#line 1084
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 1084
    if (! (w < N_words)) {
#line 1084
      goto while_break___1;
    }
    {
    {
#line 1085
    len = left_connector_count(sentence[w].d);
    }
    {
#line 1086
    size = next_power_of_two_up(len);
    }
#line 1087
    l_table_size[w] = size;
    {
#line 1088
    tmp___2 = xalloc((int )((unsigned long )size * sizeof(C_list *)));
    }
#line 1088
    tmp___1 = (C_list **)tmp___2;
#line 1088
    l_table[w] = tmp___1;
#line 1088
    t = tmp___1;
#line 1089
    i = 0;
    }
    {
    {
#line 1089
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 1089
      if (! (i < size)) {
#line 1089
        goto while_break___2;
      }
#line 1089
      *(t + i) = (C_list *)((void *)0);
#line 1089
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1091
    d = sentence[w].d;
    {
    {
#line 1091
    while (1) {
      while_continue___12: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 1091
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1091
        goto while_break___3;
      }
#line 1092
      c = d->left;
#line 1093
      if ((unsigned long )c != (unsigned long )((void *)0)) {
        {
        {
#line 1094
        put_into_power_table(size, t, c, 1);
        }
#line 1095
        c = c->next;
        }
        {
        {
#line 1095
        while (1) {
          while_continue___13: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 1095
          if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1095
            goto while_break___4;
          }
          {
          {
#line 1096
          put_into_power_table(size, t, c, 0);
          }
#line 1095
          c = c->next;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
#line 1091
      d = d->next;
    }
    while_break___12: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    {
#line 1101
    len = right_connector_count(sentence[w].d);
    }
    {
#line 1102
    size = next_power_of_two_up(len);
    }
#line 1103
    r_table_size[w] = size;
    {
#line 1104
    tmp___4 = xalloc((int )((unsigned long )size * sizeof(C_list *)));
    }
#line 1104
    tmp___3 = (C_list **)tmp___4;
#line 1104
    r_table[w] = tmp___3;
#line 1104
    t = tmp___3;
#line 1105
    i = 0;
    }
    {
    {
#line 1105
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 1105
      if (! (i < size)) {
#line 1105
        goto while_break___5;
      }
#line 1105
      *(t + i) = (C_list *)((void *)0);
#line 1105
      i ++;
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1107
    d = sentence[w].d;
    {
    {
#line 1107
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___6: /* CIL Label */ ;
#line 1107
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1107
        goto while_break___6;
      }
#line 1108
      c = d->right;
#line 1109
      if ((unsigned long )c != (unsigned long )((void *)0)) {
        {
        {
#line 1110
        put_into_power_table(size, t, c, 1);
        }
#line 1111
        c = c->next;
        }
        {
        {
#line 1111
        while (1) {
          while_continue___16: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 1111
          if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1111
            goto while_break___7;
          }
          {
          {
#line 1112
          put_into_power_table(size, t, c, 0);
          }
#line 1111
          c = c->next;
          }
        }
        while_break___16: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
#line 1107
      d = d->next;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1084
    w ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1117
  return;
}
}
#line 1119 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void clean_table(int size , C_list **t ) 
{ 
  int i ;
  C_list *m ;
  C_list *xm ;
  C_list *head ;

  {
#line 1126
  i = 0;
  {
  {
#line 1126
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1126
    if (! (i < size)) {
#line 1126
      goto while_break;
    }
#line 1127
    head = (C_list *)((void *)0);
#line 1128
    m = *(t + i);
    {
    {
#line 1128
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1128
      if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 1128
        goto while_break___0;
      }
#line 1129
      xm = m->next;
#line 1130
      if ((int )(m->c)->word != 251) {
#line 1131
        m->next = head;
#line 1132
        head = m;
      } else {
        {
        {
#line 1134
        xfree((char *)m, (int )sizeof(C_list ));
        }
        }
      }
#line 1128
      m = xm;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1137
    *(t + i) = head;
#line 1126
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  return;
}
}
#line 1141 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int possible_connection(Connector *lc , Connector *rc , int lshallow , int rshallow ,
                        int lword , int rword ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 1148
  if (! lshallow) {
#line 1148
    if (! rshallow) {
#line 1148
      return (0);
    }
  }
#line 1150
  if ((int )lc->word > rword) {
#line 1150
    return (0);
  } else
#line 1150
  if ((int )rc->word < lword) {
#line 1150
    return (0);
  }
#line 1152
  if (power_prune_mode == 0) {
#line 1153
    if (lword == rword - 1) {
#line 1154
      if ((unsigned long )lc->next == (unsigned long )((void *)0)) {
#line 1154
        if (! ((unsigned long )rc->next == (unsigned long )((void *)0))) {
#line 1154
          return (0);
        }
      } else {
#line 1154
        return (0);
      }
    } else
#line 1156
    if (! null_links) {
#line 1156
      if ((unsigned long )lc->next == (unsigned long )((void *)0)) {
#line 1156
        if ((unsigned long )rc->next == (unsigned long )((void *)0)) {
#line 1156
          if (! lc->multi) {
#line 1156
            if (! rc->multi) {
#line 1158
              return (0);
            }
          }
        }
      }
    }
    {
    {
#line 1161
    tmp = match(lc, rc);
    }
    }
#line 1161
    return (tmp);
  } else {
#line 1163
    if (lword == rword - 1) {
#line 1164
      if ((unsigned long )lc->next == (unsigned long )((void *)0)) {
#line 1164
        if (! ((unsigned long )rc->next == (unsigned long )((void *)0))) {
#line 1164
          return (0);
        }
      } else {
#line 1164
        return (0);
      }
    } else
#line 1166
    if (! null_links) {
#line 1166
      if ((unsigned long )lc->next == (unsigned long )((void *)0)) {
#line 1166
        if ((unsigned long )rc->next == (unsigned long )((void *)0)) {
#line 1166
          if (! lc->multi) {
#line 1166
            if (! rc->multi) {
#line 1166
              if (! *(deletable[lword] + rword)) {
#line 1169
                return (0);
              }
            }
          }
        }
      }
    }
    {
    {
#line 1172
    tmp___0 = prune_match(lc, rc);
    }
    }
#line 1172
    return (tmp___0);
  }
}
}
#line 1177 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int right_table_search(int w , Connector *c , int shallow , int word_c ) 
{ 
  int size ;
  int h ;
  C_list *cl ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1183
  size = r_table_size[w];
  {
#line 1184
  tmp = power_hash(c);
  }
#line 1184
  h = tmp & (size - 1);
#line 1185
  cl = *(r_table[w] + h);
  }
  {
  {
#line 1185
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1185
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 1185
      goto while_break;
    }
    {
    {
#line 1186
    tmp___0 = possible_connection(cl->c, c, cl->shallow, shallow, w, word_c);
    }
    }
#line 1186
    if (tmp___0) {
#line 1187
      return (1);
    }
#line 1185
    cl = cl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1190
  return (0);
}
}
#line 1193 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int left_table_search(int w , Connector *c , int shallow , int word_c ) 
{ 
  int size ;
  int h ;
  C_list *cl ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1199
  size = l_table_size[w];
  {
#line 1200
  tmp = power_hash(c);
  }
#line 1200
  h = tmp & (size - 1);
#line 1201
  cl = *(l_table[w] + h);
  }
  {
  {
#line 1201
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1201
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 1201
      goto while_break;
    }
    {
    {
#line 1202
    tmp___0 = possible_connection(c, cl->c, shallow, cl->shallow, word_c, w);
    }
    }
#line 1202
    if (tmp___0) {
#line 1203
      return (1);
    }
#line 1201
    cl = cl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1206
  return (0);
}
}
#line 1209 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
static int N_changed  ;
#line 1212 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int ok_cwords(Connector *c ) 
{ 


  {
  {
  {
#line 1213
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1213
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1213
      goto while_break;
    }
#line 1214
    if ((int )c->word == 251) {
#line 1214
      return (0);
    }
#line 1215
    if ((int )c->word >= N_words) {
#line 1215
      return (0);
    }
#line 1213
    c = c->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1217
  return (1);
}
}
#line 1220 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int left_connector_list_update(Connector *c , int word_c , int w , int shallow ) 
{ 
  int n ;
  int foundmatch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1231
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1231
    return (w);
  }
  {
  {
#line 1232
  tmp = left_connector_list_update(c->next, word_c, w, 0);
  }
#line 1232
  n = tmp - 1;
  }
#line 1233
  if ((int )c->word < n) {
#line 1233
    n = (int )c->word;
  }
#line 1236
  foundmatch = 0;
  {
  {
#line 1237
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1237
    if (n >= 0) {
#line 1237
      if (! (w - n <= maxlinklength)) {
#line 1237
        goto while_break;
      }
    } else {
#line 1237
      goto while_break;
    }
    {
#line 1238
    power_cost ++;
    {
#line 1239
    tmp___0 = right_table_search(n, c, shallow, word_c);
    }
    }
#line 1239
    if (tmp___0) {
#line 1240
      foundmatch = 1;
#line 1241
      goto while_break;
    }
#line 1237
    n --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1244
  if (n < (int )c->word) {
#line 1245
    c->word = (short )n;
#line 1246
    N_changed ++;
  }
#line 1248
  if (foundmatch) {
#line 1248
    tmp___1 = n;
  } else {
#line 1248
    tmp___1 = -1;
  }
#line 1248
  return (tmp___1);
}
}
#line 1251 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
int right_connector_list_update(Connector *c , int word_c , int w , int shallow ) 
{ 
  int n ;
  int foundmatch ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1262
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 1262
    return (w);
  }
  {
  {
#line 1263
  tmp = right_connector_list_update(c->next, word_c, w, 0);
  }
#line 1263
  n = tmp + 1;
  }
#line 1264
  if ((int )c->word > n) {
#line 1264
    n = (int )c->word;
  }
#line 1267
  foundmatch = 0;
  {
  {
#line 1268
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1268
    if (n < N_words) {
#line 1268
      if (! (n - w <= maxlinklength)) {
#line 1268
        goto while_break;
      }
    } else {
#line 1268
      goto while_break;
    }
    {
#line 1269
    power_cost ++;
    {
#line 1270
    tmp___0 = left_table_search(n, c, shallow, word_c);
    }
    }
#line 1270
    if (tmp___0) {
#line 1271
      foundmatch = 1;
#line 1272
      goto while_break;
    }
#line 1268
    n ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1275
  if (n > (int )c->word) {
#line 1276
    c->word = (short )n;
#line 1277
    N_changed ++;
  }
#line 1279
  if (foundmatch) {
#line 1279
    tmp___1 = n;
  } else {
#line 1279
    tmp___1 = N_words;
  }
#line 1279
  return (tmp___1);
}
}
#line 1282 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/prune.c"
void power_prune(int mode ) 
{ 
  Disjunct *d ;
  Disjunct *free_later ;
  Disjunct *dx ;
  Disjunct *nd ;
  Connector *c ;
  int w ;
  int N_deleted ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
  {
#line 1287
  power_prune_mode = mode;
  {
#line 1289
  init_power();
  }
#line 1290
  power_cost = 0;
#line 1291
  free_later = (Disjunct *)((void *)0);
#line 1292
  N_changed = 1;
#line 1293
  N_deleted = 0;
  }
  {
  {
#line 1295
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1298
    w = 0;
    {
    {
#line 1298
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1298
      if (! (w < N_words)) {
#line 1298
        goto while_break___0;
      }
#line 1299
      d = sentence[w].d;
      {
      {
#line 1299
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 1299
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1299
          goto while_break___1;
        }
#line 1300
        if ((unsigned long )d->left == (unsigned long )((void *)0)) {
#line 1300
          goto __Cont;
        }
        {
        {
#line 1301
        tmp = left_connector_list_update(d->left, w, w, 1);
        }
        }
#line 1301
        if (tmp < 0) {
#line 1302
          c = d->left;
          {
          {
#line 1302
          while (1) {
            while_continue___13: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 1302
            if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1302
              goto while_break___2;
            }
#line 1302
            c->word = (short)251;
#line 1302
            c = c->next;
          }
          while_break___13: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1303
          c = d->right;
          {
          {
#line 1303
          while (1) {
            while_continue___14: /* CIL Label */ ;
            while_continue___3: /* CIL Label */ ;
#line 1303
            if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1303
              goto while_break___3;
            }
#line 1303
            c->word = (short)251;
#line 1303
            c = c->next;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1304
          N_deleted ++;
        }
        __Cont: /* CIL Label */ 
#line 1299
        d = d->next;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
      {
#line 1308
      clean_table(r_table_size[w], r_table[w]);
      }
#line 1309
      nd = (Disjunct *)((void *)0);
#line 1310
      d = sentence[w].d;
      }
      {
      {
#line 1310
      while (1) {
        while_continue___15: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 1310
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1310
          goto while_break___4;
        }
#line 1311
        dx = d->next;
#line 1312
        if ((unsigned long )d->left != (unsigned long )((void *)0)) {
#line 1312
          if ((int )(d->left)->word == 251) {
#line 1313
            d->next = free_later;
#line 1314
            free_later = d;
          } else {
#line 1316
            d->next = nd;
#line 1317
            nd = d;
          }
        } else {
#line 1316
          d->next = nd;
#line 1317
          nd = d;
        }
#line 1310
        d = dx;
      }
      while_break___15: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 1320
      sentence[w].d = nd;
#line 1298
      w ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1322
    if (verbosity > 2) {
      {
      {
#line 1323
      printf((char const   */* __restrict  */)"l->r pass changed %d and deleted %d\n",
             N_changed, N_deleted);
      }
      }
    }
#line 1326
    if (N_changed == 0) {
#line 1326
      goto while_break;
    }
#line 1328
    N_deleted = 0;
#line 1328
    N_changed = N_deleted;
#line 1331
    w = N_words - 1;
    {
    {
#line 1331
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 1331
      if (! (w >= 0)) {
#line 1331
        goto while_break___5;
      }
#line 1332
      d = sentence[w].d;
      {
      {
#line 1332
      while (1) {
        while_continue___17: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 1332
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1332
          goto while_break___6;
        }
#line 1333
        if ((unsigned long )d->right == (unsigned long )((void *)0)) {
#line 1333
          goto __Cont___0;
        }
        {
        {
#line 1334
        tmp___0 = right_connector_list_update(d->right, w, w, 1);
        }
        }
#line 1334
        if (tmp___0 >= N_words) {
#line 1335
          c = d->right;
          {
          {
#line 1335
          while (1) {
            while_continue___18: /* CIL Label */ ;
            while_continue___7: /* CIL Label */ ;
#line 1335
            if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1335
              goto while_break___7;
            }
#line 1335
            c->word = (short)251;
#line 1335
            c = c->next;
          }
          while_break___18: /* CIL Label */ ;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1336
          c = d->left;
          {
          {
#line 1336
          while (1) {
            while_continue___19: /* CIL Label */ ;
            while_continue___8: /* CIL Label */ ;
#line 1336
            if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 1336
              goto while_break___8;
            }
#line 1336
            c->word = (short)251;
#line 1336
            c = c->next;
          }
          while_break___19: /* CIL Label */ ;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 1337
          N_deleted ++;
        }
        __Cont___0: /* CIL Label */ 
#line 1332
        d = d->next;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
      {
#line 1340
      clean_table(l_table_size[w], l_table[w]);
      }
#line 1341
      nd = (Disjunct *)((void *)0);
#line 1342
      d = sentence[w].d;
      }
      {
      {
#line 1342
      while (1) {
        while_continue___20: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 1342
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1342
          goto while_break___9;
        }
#line 1343
        dx = d->next;
#line 1344
        if ((unsigned long )d->right != (unsigned long )((void *)0)) {
#line 1344
          if ((int )(d->right)->word == 251) {
#line 1345
            d->next = free_later;
#line 1346
            free_later = d;
          } else {
#line 1348
            d->next = nd;
#line 1349
            nd = d;
          }
        } else {
#line 1348
          d->next = nd;
#line 1349
          nd = d;
        }
#line 1342
        d = dx;
      }
      while_break___20: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 1352
      sentence[w].d = nd;
#line 1331
      w --;
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1355
    if (verbosity > 2) {
      {
      {
#line 1356
      printf((char const   */* __restrict  */)"r->l pass changed %d and deleted %d\n",
             N_changed, N_deleted);
      }
      }
    }
#line 1359
    if (N_changed == 0) {
#line 1359
      goto while_break;
    }
#line 1360
    N_deleted = 0;
#line 1360
    N_changed = N_deleted;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1362
  free_disjuncts(free_later);
  }
  {
#line 1363
  free_power_tables();
  }
  }
#line 1364
  if (verbosity > 2) {
    {
    {
#line 1364
    printf((char const   */* __restrict  */)"%d power prune cost:\n", power_cost);
    }
    }
  }
#line 1365
  return;
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 329 "/usr/include/stdio.h"
extern int sprintf(char * __restrict  __s , char const   * __restrict  __format  , ...) ;
#line 85 "/usr/include/string.h"
extern char *strncpy(char * __restrict  __dest , char const   * __restrict  __src ,
                     size_t __n ) ;
#line 315 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int left_wall_defined ;
#line 316
int right_wall_defined ;
#line 324
int screen_width ;
#line 325
int display_short ;
#line 328
int display_postscript ;
#line 329
int display_word_subscripts ;
#line 330
int display_link_subscripts ;
#line 334
int display_walls ;
#line 350
Link pp_link_array[497] ;
#line 351
int N_links ;
#line 352 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
char *chosen_words[250]  ;
#line 353
Disjunct *chosen_disjuncts[250] ;
#line 387
void print_links_graphically(FILE *fp ) ;
#line 414
void print_sentence(FILE *fp , int w ) ;
#line 459
void compute_chosen_words(void) ;
#line 12 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
static int center[250]  ;
#line 15 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
static int N_words_to_print  ;
#line 17 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
void set_centers(int print_word_0 ) 
{ 
  int i ;
  int len ;
  int tot ;
  size_t tmp ;

  {
#line 19
  tot = 0;
#line 20
  if (print_word_0) {
#line 20
    i = 0;
  } else {
#line 20
    i = 1;
  }
  {
  {
#line 21
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 21
    if (! (i < N_words_to_print)) {
#line 21
      goto while_break;
    }
    {
    {
#line 22
    tmp = strlen((char const   *)chosen_words[i]);
    }
#line 22
    len = (int )tmp;
#line 23
    center[i] = tot + len / 2;
#line 24
    tot += len + 1;
#line 21
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 26
  return;
}
}
#line 29 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
static int link_heights[497]  ;
#line 31 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
static int row_starts[250]  ;
#line 33 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
static int N_rows  ;
#line 36 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
void print_postscript_data(FILE *fp , int print_word_0 , int print_word_N ) 
{ 
  int link ;
  int i ;
  int j ;
  int d ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;

  {
#line 40
  if (print_word_0) {
#line 40
    d = 0;
  } else {
#line 40
    d = 1;
  }
  {
#line 42
  i = 0;
  {
#line 43
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"[");
  }
#line 44
  j = d;
  }
  {
  {
#line 44
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 44
    if (! (j < N_words_to_print)) {
#line 44
      goto while_break;
    }
#line 45
    if (i % 7 == 0) {
#line 45
      if (i > 0) {
        {
        {
#line 45
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
        }
        }
      }
    }
    {
#line 46
    i ++;
    {
#line 47
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"(%s)",
            chosen_words[j]);
    }
#line 44
    j ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 49
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"]");
  }
  {
#line 50
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
  {
#line 52
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"[");
  }
#line 53
  j = 0;
#line 54
  link = 0;
  }
  {
  {
#line 54
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 54
    if (! (link < N_links)) {
#line 54
      goto while_break___0;
    }
#line 55
    if (! print_word_0) {
#line 55
      if (pp_link_array[link].l == 0) {
#line 55
        goto __Cont;
      }
    }
#line 56
    if (! print_word_N) {
#line 56
      if (pp_link_array[link].r == N_words - 1) {
#line 56
        goto __Cont;
      }
    }
#line 57
    if (pp_link_array[link].l == -1) {
#line 57
      goto __Cont;
    }
#line 58
    if (j % 5 == 0) {
#line 58
      if (j > 0) {
        {
        {
#line 58
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
        }
        }
      }
    }
    {
#line 59
    j ++;
    {
#line 60
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"[%d %d %d",
            pp_link_array[link].l - d, pp_link_array[link].r - d, link_heights[link]);
    }
    }
#line 62
    if ((int )(pp_link_array[link].lc)->label < 0) {
      {
      {
#line 63
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" (%s)]",
              pp_link_array[link].name);
      }
      }
    } else {
      {
      {
#line 65
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" ()]");
      }
      }
    }
    __Cont: /* CIL Label */ 
#line 54
    link ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 68
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"]");
  }
  {
#line 69
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
  {
#line 70
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"[");
  }
#line 71
  j = 0;
  }
  {
  {
#line 71
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 71
    if (! (j < N_rows)) {
#line 71
      goto while_break___1;
    }
    {
    {
#line 72
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d ", row_starts[j]);
    }
#line 71
    j ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 74
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"]\n");
  }
  }
#line 75
  return;
}
}
#line 77 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
void compute_chosen_words(void) 
{ 
  int i ;
  int l ;
  char *s ;
  char *t ;
  char *u ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 84
  i = 0;
  {
  {
#line 84
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 84
    if (! (i < N_words)) {
#line 84
      goto while_break;
    }
#line 85
    chosen_words[i] = sentence[i].string;
#line 86
    if ((unsigned long )chosen_disjuncts[i] == (unsigned long )((void *)0)) {
      {
#line 87
      t = chosen_words[i];
      {
#line 88
      tmp = strlen((char const   *)t);
      }
#line 88
      l = (int )(tmp + 2U);
      {
#line 89
      tmp___0 = xalloc(l + 1);
      }
#line 89
      s = (char *)tmp___0;
      {
#line 90
      sprintf((char */* __restrict  */)s, (char const   */* __restrict  */)"[%s]",
              t);
      }
      {
#line 91
      free_this_string_later(s, l + 1);
      }
#line 92
      chosen_words[i] = s;
      }
    } else
#line 93
    if (display_word_subscripts) {
      {
#line 94
      t = (chosen_disjuncts[i])->string;
      {
#line 95
      tmp___3 = is_idiom_word(t);
      }
      }
#line 95
      if (tmp___3) {
        {
        {
#line 96
        tmp___1 = strlen((char const   *)t);
        }
#line 96
        l = (int )tmp___1;
        {
#line 97
        tmp___2 = xalloc(l + 1);
        }
#line 97
        s = (char *)tmp___2;
        {
#line 98
        free_this_string_later(s, l + 1);
        }
        {
#line 99
        strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)t);
        }
#line 100
        u = s;
        }
        {
        {
#line 100
        while (1) {
          while_continue___2: /* CIL Label */ ;
          while_continue___0: /* CIL Label */ ;
#line 100
          if (! ((int )*u != 46)) {
#line 100
            goto while_break___0;
          }
#line 100
          u ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 102
        *u = (char )'\000';
#line 103
        chosen_words[i] = s;
      } else {
#line 105
        chosen_words[i] = t;
      }
    }
#line 84
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  if (left_wall_defined) {
#line 110
    chosen_words[0] = (char *)"/////";
  }
#line 112
  if (right_wall_defined) {
#line 113
    chosen_words[N_words - 1] = (char *)"/////";
  }
#line 115
  return;
}
}
#line 120 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
static char picture[30][1500]  ;
#line 121 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
static char xpicture[30][1500]  ;
#line 123 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
void print_links_graphically(FILE *fp ) 
{ 
  int i ;
  int j ;
  int k ;
  int cl ;
  int cr ;
  int row ;
  int top_row ;
  int width ;
  int flag ;
  char *t ;
  char *s ;
  int print_word_0 ;
  int print_word_N ;
  int N_wall_connectors ;
  int suppressor_used ;
  char connector___0[50] ;
  int line_len ;
  int link_length ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  size_t tmp___5 ;
  unsigned short const   **tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  unsigned short const   **tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  void *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;

  {
#line 128
  print_word_0 = 0;
#line 128
  print_word_N = 0;
#line 132
  N_wall_connectors = 0;
#line 133
  if (left_wall_defined) {
#line 134
    suppressor_used = 0;
#line 135
    j = 0;
    {
    {
#line 135
    while (1) {
      while_continue___23: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 135
      if (! (j < N_links)) {
#line 135
        goto while_break;
      }
#line 136
      if (pp_link_array[j].l == 0) {
        {
#line 137
        N_wall_connectors ++;
        {
#line 138
        tmp = strcmp((char const   *)(pp_link_array[j].lc)->string, "xxxxxxx");
        }
        }
#line 138
        if (tmp == 0) {
#line 139
          suppressor_used = 1;
        }
      }
#line 135
      j ++;
    }
    while_break___23: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 143
    if (! suppressor_used) {
#line 143
      tmp___0 = 1;
    } else
#line 143
    if (N_wall_connectors > 1) {
#line 143
      tmp___0 = 1;
    } else
#line 143
    if (display_walls) {
#line 143
      tmp___0 = 1;
    } else {
#line 143
      tmp___0 = 0;
    }
#line 143
    print_word_0 = tmp___0;
  } else {
#line 145
    print_word_0 = 1;
  }
#line 148
  N_wall_connectors = 0;
#line 149
  if (right_wall_defined) {
#line 150
    suppressor_used = 0;
#line 151
    j = 0;
    {
    {
#line 151
    while (1) {
      while_continue___24: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 151
      if (! (j < N_links)) {
#line 151
        goto while_break___0;
      }
#line 152
      if (pp_link_array[j].r == N_words - 1) {
        {
#line 153
        N_wall_connectors ++;
        {
#line 154
        tmp___1 = strcmp((char const   *)(pp_link_array[j].lc)->string, "RW");
        }
        }
#line 154
        if (tmp___1 == 0) {
#line 155
          suppressor_used = 1;
        }
      }
#line 151
      j ++;
    }
    while_break___24: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 159
    if (! suppressor_used) {
#line 159
      tmp___2 = 1;
    } else
#line 159
    if (N_wall_connectors > 1) {
#line 159
      tmp___2 = 1;
    } else
#line 159
    if (display_walls) {
#line 159
      tmp___2 = 1;
    } else {
#line 159
      tmp___2 = 0;
    }
#line 159
    print_word_N = tmp___2;
  } else {
#line 161
    print_word_N = 1;
  }
#line 164
  N_words_to_print = N_words;
#line 165
  if (! print_word_N) {
#line 165
    N_words_to_print --;
  }
  {
  {
#line 167
  set_centers(print_word_0);
  }
#line 168
  line_len = center[N_words_to_print - 1] + 1;
#line 170
  k = 0;
  }
  {
  {
#line 170
  while (1) {
    while_continue___25: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 170
    if (! (k < 30)) {
#line 170
      goto while_break___1;
    }
#line 171
    j = 0;
    {
    {
#line 171
    while (1) {
      while_continue___26: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 171
      if (! (j < line_len)) {
#line 171
        goto while_break___2;
      }
#line 171
      picture[k][j] = (char )' ';
#line 171
      j ++;
    }
    while_break___26: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 172
    picture[k][line_len] = (char )'\000';
#line 170
    k ++;
  }
  while_break___25: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 174
  top_row = 0;
#line 176
  link_length = 1;
  {
  {
#line 176
  while (1) {
    while_continue___27: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 176
    if (! (link_length < N_words_to_print)) {
#line 176
      goto while_break___3;
    }
#line 177
    j = 0;
    {
    {
#line 177
    while (1) {
      while_continue___28: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 177
      if (! (j < N_links)) {
#line 177
        goto while_break___4;
      }
#line 178
      if (pp_link_array[j].l == -1) {
#line 178
        goto __Cont;
      }
#line 179
      if (pp_link_array[j].r - pp_link_array[j].l != link_length) {
#line 180
        goto __Cont;
      }
#line 181
      if (! print_word_0) {
#line 181
        if (pp_link_array[j].l == 0) {
#line 181
          goto __Cont;
        }
      }
#line 183
      if (! print_word_N) {
#line 183
        if (pp_link_array[j].r == N_words - 1) {
#line 183
          goto __Cont;
        }
      }
#line 187
      cl = center[pp_link_array[j].l];
#line 188
      cr = center[pp_link_array[j].r];
#line 189
      row = 0;
      {
      {
#line 189
      while (1) {
        while_continue___29: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 189
        if (! (row < 30)) {
#line 189
          goto while_break___5;
        }
#line 190
        k = cl + 1;
        {
        {
#line 190
        while (1) {
          while_continue___30: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 190
          if (! (k < cr)) {
#line 190
            goto while_break___6;
          }
#line 191
          if ((int )picture[row][k] != 32) {
#line 191
            goto while_break___6;
          }
#line 190
          k ++;
        }
        while_break___30: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 193
        if (k == cr) {
#line 193
          goto while_break___5;
        }
#line 189
        row ++;
      }
      while_break___29: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 197
      link_heights[j] = row;
#line 199
      if (2 * row + 2 > 29) {
        {
        {
#line 200
        fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"The diagram is too high.\n");
        }
        }
#line 201
        return;
      }
#line 203
      if (row > top_row) {
#line 203
        top_row = row;
      }
#line 205
      picture[row][cl] = (char )'+';
#line 206
      picture[row][cr] = (char )'+';
#line 207
      k = cl + 1;
      {
      {
#line 207
      while (1) {
        while_continue___31: /* CIL Label */ ;
        while_continue___7: /* CIL Label */ ;
#line 207
        if (! (k < cr)) {
#line 207
          goto while_break___7;
        }
#line 208
        picture[row][k] = (char )'-';
#line 207
        k ++;
      }
      while_break___31: /* CIL Label */ ;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 211
      s = pp_link_array[j].name;
#line 213
      if (display_link_subscripts) {
        {
        {
#line 214
        tmp___3 = __ctype_b_loc();
        }
        }
#line 214
        if (! ((int const   )*(*tmp___3 + (int )*s) & 1024)) {
#line 215
          s = (char *)"";
        }
      } else {
        {
        {
#line 217
        tmp___4 = __ctype_b_loc();
        }
        }
#line 217
        if (! ((int const   )*(*tmp___4 + (int )*s) & 256)) {
#line 218
          s = (char *)"";
        }
      }
      {
      {
#line 221
      strncpy((char */* __restrict  */)(connector___0), (char const   */* __restrict  */)s,
              (size_t )49);
      }
#line 222
      connector___0[49] = (char )'\000';
#line 223
      k = 0;
      }
#line 224
      if (display_link_subscripts) {
        {
        {
#line 225
        tmp___5 = strlen((char const   *)(connector___0));
        }
#line 225
        k = (int )tmp___5;
        }
      } else {
#line 227
        t = connector___0;
        {
        {
#line 227
        while (1) {
          while_continue___32: /* CIL Label */ ;
          while_continue___8: /* CIL Label */ ;
          {
          {
#line 227
          tmp___6 = __ctype_b_loc();
          }
          }
#line 227
          if (! ((int const   )*(*tmp___6 + (int )*t) & 256)) {
#line 227
            goto while_break___8;
          }
#line 227
          k ++;
#line 227
          t ++;
        }
        while_break___32: /* CIL Label */ ;
        }
        while_break___8: /* CIL Label */ ;
        }
      }
#line 228
      if (((cl + cr) - k) / 2 + 1 <= cl) {
#line 229
        t = (picture[row] + cl) + 1;
      } else {
#line 231
        t = (picture[row] + ((cl + cr) - k) / 2) + 1;
      }
#line 233
      s = connector___0;
#line 234
      if (display_link_subscripts) {
        {
        {
#line 235
        while (1) {
          while_continue___33: /* CIL Label */ ;
          while_continue___9: /* CIL Label */ ;
#line 235
          if ((int )*s != 0) {
#line 235
            if (! ((int )*t == 45)) {
#line 235
              goto while_break___9;
            }
          } else {
#line 235
            goto while_break___9;
          }
#line 235
          tmp___7 = t;
#line 235
          t ++;
#line 235
          tmp___8 = s;
#line 235
          s ++;
#line 235
          *tmp___7 = *tmp___8;
        }
        while_break___33: /* CIL Label */ ;
        }
        while_break___9: /* CIL Label */ ;
        }
      } else {
        {
        {
#line 237
        while (1) {
          while_continue___34: /* CIL Label */ ;
          while_continue___10: /* CIL Label */ ;
          {
          {
#line 237
          tmp___11 = __ctype_b_loc();
          }
          }
#line 237
          if ((int const   )*(*tmp___11 + (int )*s) & 256) {
#line 237
            if (! ((int )*t == 45)) {
#line 237
              goto while_break___10;
            }
          } else {
#line 237
            goto while_break___10;
          }
#line 237
          tmp___9 = t;
#line 237
          t ++;
#line 237
          tmp___10 = s;
#line 237
          s ++;
#line 237
          *tmp___9 = *tmp___10;
        }
        while_break___34: /* CIL Label */ ;
        }
        while_break___10: /* CIL Label */ ;
        }
      }
#line 240
      k = 0;
      {
      {
#line 240
      while (1) {
        while_continue___35: /* CIL Label */ ;
        while_continue___11: /* CIL Label */ ;
#line 240
        if (! (k < row)) {
#line 240
          goto while_break___11;
        }
#line 241
        if ((int )picture[k][cl] == 32) {
#line 242
          picture[k][cl] = (char )'|';
        }
#line 244
        if ((int )picture[k][cr] == 32) {
#line 245
          picture[k][cr] = (char )'|';
        }
#line 240
        k ++;
      }
      while_break___35: /* CIL Label */ ;
      }
      while_break___11: /* CIL Label */ ;
      }
      __Cont: /* CIL Label */ 
#line 177
      j ++;
    }
    while_break___28: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 176
    link_length ++;
  }
  while_break___27: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 253
  s = xpicture[0];
#line 254
  if (print_word_0) {
#line 254
    k = 0;
  } else {
#line 254
    k = 1;
  }
  {
  {
#line 255
  while (1) {
    while_continue___36: /* CIL Label */ ;
    while_continue___12: /* CIL Label */ ;
#line 255
    if (! (k < N_words_to_print)) {
#line 255
      goto while_break___12;
    }
#line 256
    t = chosen_words[k];
#line 257
    i = 0;
    {
    {
#line 258
    while (1) {
      while_continue___37: /* CIL Label */ ;
      while_continue___13: /* CIL Label */ ;
#line 258
      if (! ((int )*t != 0)) {
#line 258
        goto while_break___13;
      }
#line 259
      tmp___12 = s;
#line 259
      s ++;
#line 259
      tmp___13 = t;
#line 259
      t ++;
#line 259
      *tmp___12 = *tmp___13;
#line 260
      i ++;
    }
    while_break___37: /* CIL Label */ ;
    }
    while_break___13: /* CIL Label */ ;
    }
#line 262
    tmp___14 = s;
#line 262
    s ++;
#line 262
    *tmp___14 = (char )' ';
#line 255
    k ++;
  }
  while_break___36: /* CIL Label */ ;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 264
  *s = (char )'\000';
#line 266
  if (display_short) {
#line 267
    k = 0;
    {
    {
#line 267
    while (1) {
      while_continue___38: /* CIL Label */ ;
      while_continue___14: /* CIL Label */ ;
#line 267
      if (! ((int )picture[0][k] != 0)) {
#line 267
        goto while_break___14;
      }
#line 268
      if ((int )picture[0][k] == 43) {
#line 269
        xpicture[1][k] = (char )'|';
      } else
#line 268
      if ((int )picture[0][k] == 124) {
#line 269
        xpicture[1][k] = (char )'|';
      } else {
#line 271
        xpicture[1][k] = (char )' ';
      }
#line 267
      k ++;
    }
    while_break___38: /* CIL Label */ ;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 274
    xpicture[1][k] = (char )'\000';
#line 275
    row = 0;
    {
    {
#line 275
    while (1) {
      while_continue___39: /* CIL Label */ ;
      while_continue___15: /* CIL Label */ ;
#line 275
      if (! (row <= top_row)) {
#line 275
        goto while_break___15;
      }
      {
      {
#line 276
      strcpy((char */* __restrict  */)(xpicture[row + 2]), (char const   */* __restrict  */)(picture[row]));
      }
#line 275
      row ++;
      }
    }
    while_break___39: /* CIL Label */ ;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 278
    top_row += 2;
  } else {
#line 280
    row = 0;
    {
    {
#line 280
    while (1) {
      while_continue___40: /* CIL Label */ ;
      while_continue___16: /* CIL Label */ ;
#line 280
      if (! (row <= top_row)) {
#line 280
        goto while_break___16;
      }
      {
      {
#line 281
      strcpy((char */* __restrict  */)(xpicture[2 * row + 2]), (char const   */* __restrict  */)(picture[row]));
      }
#line 282
      k = 0;
      }
      {
      {
#line 282
      while (1) {
        while_continue___41: /* CIL Label */ ;
        while_continue___17: /* CIL Label */ ;
#line 282
        if (! ((int )picture[row][k] != 0)) {
#line 282
          goto while_break___17;
        }
#line 283
        if ((int )picture[row][k] == 43) {
#line 284
          xpicture[2 * row + 1][k] = (char )'|';
        } else
#line 283
        if ((int )picture[row][k] == 124) {
#line 284
          xpicture[2 * row + 1][k] = (char )'|';
        } else {
#line 286
          xpicture[2 * row + 1][k] = (char )' ';
        }
#line 282
        k ++;
      }
      while_break___41: /* CIL Label */ ;
      }
      while_break___17: /* CIL Label */ ;
      }
#line 289
      xpicture[2 * row + 1][k] = (char )'\000';
#line 280
      row ++;
    }
    while_break___40: /* CIL Label */ ;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 291
    top_row = 2 * top_row + 2;
  }
#line 296
  if (print_word_0) {
#line 296
    i = 0;
  } else {
#line 296
    i = 1;
  }
#line 297
  k = 0;
#line 298
  N_rows = 0;
#line 299
  row_starts[N_rows] = 0;
#line 300
  N_rows ++;
  {
  {
#line 301
  while (1) {
    while_continue___42: /* CIL Label */ ;
    while_continue___18: /* CIL Label */ ;
#line 301
    if (! (i < N_words_to_print)) {
#line 301
      goto while_break___18;
    }
    {
    {
#line 302
    _IO_putc('\n', fp);
    }
#line 303
    width = 0;
    }
    {
    {
#line 304
    while (1) {
      while_continue___43: /* CIL Label */ ;
      while_continue___19: /* CIL Label */ ;
      {
      {
#line 305
      tmp___15 = strlen((char const   *)chosen_words[i]);
      }
#line 305
      width = (int )((size_t )width + (tmp___15 + 1U));
#line 306
      i ++;
      }
#line 304
      if (i < N_words_to_print) {
        {
        {
#line 304
        tmp___16 = strlen((char const   *)chosen_words[i]);
        }
        }
#line 304
        if (! ((width + (int )tmp___16) + 1 < screen_width)) {
#line 304
          goto while_break___19;
        }
      } else {
#line 304
        goto while_break___19;
      }
    }
    while_break___43: /* CIL Label */ ;
    }
    while_break___19: /* CIL Label */ ;
    }
#line 309
    row_starts[N_rows] = i - ! print_word_0;
#line 310
    if (i < N_words_to_print) {
#line 310
      N_rows ++;
    }
#line 311
    row = top_row;
    {
    {
#line 311
    while (1) {
      while_continue___44: /* CIL Label */ ;
      while_continue___20: /* CIL Label */ ;
#line 311
      if (! (row >= 0)) {
#line 311
        goto while_break___20;
      }
#line 312
      flag = 1;
#line 313
      j = k;
      {
      {
#line 313
      while (1) {
        while_continue___45: /* CIL Label */ ;
        while_continue___21: /* CIL Label */ ;
#line 313
        if (flag) {
#line 313
          if (j < k + width) {
#line 313
            if (! ((int )xpicture[row][j] != 0)) {
#line 313
              goto while_break___21;
            }
          } else {
#line 313
            goto while_break___21;
          }
        } else {
#line 313
          goto while_break___21;
        }
#line 314
        if (flag) {
#line 314
          if ((int )xpicture[row][j] == 32) {
#line 314
            tmp___17 = 1;
          } else {
#line 314
            tmp___17 = 0;
          }
        } else {
#line 314
          tmp___17 = 0;
        }
#line 314
        flag = tmp___17;
#line 313
        j ++;
      }
      while_break___45: /* CIL Label */ ;
      }
      while_break___21: /* CIL Label */ ;
      }
#line 316
      if (! flag) {
#line 317
        j = k;
        {
        {
#line 317
        while (1) {
          while_continue___46: /* CIL Label */ ;
          while_continue___22: /* CIL Label */ ;
#line 317
          if (j < k + width) {
#line 317
            if (! ((int )xpicture[row][j] != 0)) {
#line 317
              goto while_break___22;
            }
          } else {
#line 317
            goto while_break___22;
          }
          {
          {
#line 318
          _IO_putc((int )xpicture[row][j], fp);
          }
#line 317
          j ++;
          }
        }
        while_break___46: /* CIL Label */ ;
        }
        while_break___22: /* CIL Label */ ;
        }
        {
        {
#line 320
        _IO_putc('\n', fp);
        }
        }
      }
#line 311
      row --;
    }
    while_break___44: /* CIL Label */ ;
    }
    while_break___20: /* CIL Label */ ;
    }
    {
    {
#line 323
    _IO_putc('\n', fp);
    }
#line 324
    k += width;
    }
  }
  while_break___42: /* CIL Label */ ;
  }
  while_break___18: /* CIL Label */ ;
  }
#line 326
  if (display_postscript) {
    {
    {
#line 326
    print_postscript_data(fp, print_word_0, print_word_N);
    }
    }
  }
#line 327
  return;
}
}
#line 329 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
void print_disjunct_counts(void) 
{ 
  int i ;
  int c ;
  Disjunct *d ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 333
  i = 0;
  {
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 333
    if (! (i < N_words)) {
#line 333
      goto while_break;
    }
#line 334
    c = 0;
#line 335
    d = sentence[i].d;
    {
    {
#line 335
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 335
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 335
        goto while_break___0;
      }
#line 336
      c ++;
#line 335
      d = d->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 338
    printf((char const   */* __restrict  */)"%s(%d) ", sentence[i].string, c);
    }
#line 333
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 340
  printf((char const   */* __restrict  */)"\n\n");
  }
  }
#line 341
  return;
}
}
#line 343 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
void print_expression_sizes(void) 
{ 
  X_node *x ;
  int w ;
  int size ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 346
  w = 0;
  {
  {
#line 346
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 346
    if (! (w < N_words)) {
#line 346
      goto while_break;
    }
#line 347
    size = 0;
#line 348
    x = sentence[w].x;
    {
    {
#line 348
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 348
      if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 348
        goto while_break___0;
      }
      {
      {
#line 349
      tmp = size_of_expression(x->exp);
      }
#line 349
      size += tmp;
#line 348
      x = x->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 351
    printf((char const   */* __restrict  */)"%s[%d] ", sentence[w].string, size);
    }
#line 346
    w ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 353
  printf((char const   */* __restrict  */)"\n\n");
  }
  }
#line 354
  return;
}
}
#line 356 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/print.c"
void print_sentence(FILE *fp , int w ) 
{ 
  int i ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 359
  if (left_wall_defined) {
#line 359
    i = 1;
  } else {
#line 359
    i = 0;
  }
#line 360
  if (w == 0) {
#line 360
    i += w;
  }
  {
  {
#line 361
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 361
    if (! (i < N_words - right_wall_defined)) {
#line 361
      goto while_break;
    }
    {
    {
#line 362
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%s ", sentence[i].string);
    }
#line 361
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 364
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
  }
#line 365
  return;
}
}
#line 743 "/usr/include/stdlib.h"
extern void qsort(void *__base , size_t __nmemb , size_t __size , int (*__compar)(void const   * ,
                                                                                  void const   * ) ) ;
#line 317 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int postprocess_defined ;
#line 390
PP_node *post_process(void) ;
#line 438
void print_a_link(FILE *fp , int link ) ;
#line 458
void free_PP_node(PP_node *p ) ;
#line 95 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *domain_starter_links[38]  = 
#line 95 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
  {      (char *)"W",      (char *)"Ce",      (char *)"Cs",      (char *)"Ca", 
        (char *)"Cc",      (char *)"Ci",      (char *)"R*",      (char *)"Re", 
        (char *)"RSe",      (char *)"Mr",      (char *)"QI#d",      (char *)"Mv", 
        (char *)"Jr",      (char *)"Mj",      (char *)"Qd",      (char *)"TOn", 
        (char *)"TOi",      (char *)"Mg",      (char *)"MVi",      (char *)"Ss#d", 
        (char *)"Bsd",      (char *)"ER",      (char *)"Z",      (char *)"Ma", 
        (char *)"SIs#g",      (char *)"BIqx",      (char *)"MX#p",      (char *)"MX#a", 
        (char *)"MX#r",      (char *)"MX#j",      (char *)"MV#o",      (char *)"MV#p", 
        (char *)"Eq",      (char *)"COq",      (char *)"CP",      (char *)"AFd", 
        (char *)"PFc",      (char *)((void *)0)};
#line 108 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *urfl_domain_starter_links[4]  = {      (char *)"TOo",      (char *)"I#j",      (char *)"Pa##j",      (char *)((void *)0)};
#line 112 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *urfl_only_domain_starter_links[4]  = {      (char *)"SFsx",      (char *)"Ss#g",      (char *)"COp",      (char *)((void *)0)};
#line 121 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
CDNP CDNP_array[44]  = 
#line 121
  {      {(char *)"Ce", 'e'}, 
        {(char *)"R", 'r'}, 
        {(char *)"Re", 'r'}, 
        {(char *)"W", 'm'}, 
        {(char *)"RSe", 'e'}, 
        {(char *)"Cs", 's'}, 
        {(char *)"Ca", 's'}, 
        {(char *)"Jr", 'e'}, 
        {(char *)"Mr", 'r'}, 
        {(char *)"Cc", 's'}, 
        {(char *)"Mv", 'e'}, 
        {(char *)"QI#d", 's'}, 
        {(char *)"BIqx", 's'}, 
        {(char *)"TOn", 'e'}, 
        {(char *)"TOi", 'e'}, 
        {(char *)"MVi", 'e'}, 
        {(char *)"MV#o", 's'}, 
        {(char *)"MV#p", 's'}, 
        {(char *)"AFd", 's'}, 
        {(char *)"PFc", 's'}, 
        {(char *)"Mg", 'e'}, 
        {(char *)"Mj", 'j'}, 
        {(char *)"Qd", 'm'}, 
        {(char *)"MX#j", 'j'}, 
        {(char *)"TOo", 'x'}, 
        {(char *)"I#j", 'x'}, 
        {(char *)"Pa##j", 'x'}, 
        {(char *)"COp", 'd'}, 
        {(char *)"SFsx", 'd'}, 
        {(char *)"Ss#g", 'd'}, 
        {(char *)"SIs#g", 's'}, 
        {(char *)"Ss#d", 's'}, 
        {(char *)"Bsd", 's'}, 
        {(char *)"ER", 's'}, 
        {(char *)"Z", 's'}, 
        {(char *)"Ma", 'e'}, 
        {(char *)"MX#p", 'e'}, 
        {(char *)"Ci", 'e'}, 
        {(char *)"MX#a", 'e'}, 
        {(char *)"Eq", 'e'}, 
        {(char *)"COq", 'e'}, 
        {(char *)"CP", 'd'}, 
        {(char *)"MX#r", 'r'}, 
        {(char *)((void *)0), 0}};
#line 139 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *domain_contains_links[21]  = 
#line 139
  {      (char *)"Mg",      (char *)"Mx",      (char *)"Bsd",      (char *)"MX#a", 
        (char *)"Ma",      (char *)"Mv",      (char *)"MX#r",      (char *)"Ss#d", 
        (char *)"CP",      (char *)"Ws",      (char *)"Wq",      (char *)"Qd", 
        (char *)"Mj",      (char *)"Wj",      (char *)"Wi",      (char *)"MX#j", 
        (char *)"AFd",      (char *)"PFc",      (char *)"Jr",      (char *)"Wd", 
        (char *)((void *)0)};
#line 146 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *ignore_these_links[2]  = {      (char *)"Xca",      (char *)((void *)0)};
#line 151 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *must_be_connected_without[8]  = 
#line 151
  {      (char *)"R*",      (char *)"Re",      (char *)"TOt",      (char *)"EXx", 
        (char *)"HA",      (char *)"SFsic",      (char *)"Jr",      (char *)((void *)0)};
#line 155 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *restricted_links[22]  = 
#line 155
  {      (char *)"B#*",      (char *)"D##w",      (char *)"B#w",      (char *)"B#d", 
        (char *)"AFh",      (char *)"MVt",      (char *)"Xx",      (char *)"HL", 
        (char *)"SFsic",      (char *)"AFd",      (char *)"Bc",      (char *)"CX", 
        (char *)"CP",      (char *)"EAh",      (char *)"H",      (char *)"HA", 
        (char *)"PFc",      (char *)"B#j",      (char *)"Wd",      (char *)"PF", 
        (char *)"Z",      (char *)((void *)0)};
#line 162 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int ppmatch(char *s , char *t ) 
{ 
  char c ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  {
#line 171
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 171
    tmp = __ctype_b_loc();
    }
    }
#line 171
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
      {
      {
#line 171
      tmp___0 = __ctype_b_loc();
      }
      }
#line 171
      if (! ((int const   )*(*tmp___0 + (int )*t) & 256)) {
#line 171
        goto while_break;
      }
    }
#line 172
    if ((int )*s != (int )*t) {
#line 172
      return (0);
    }
#line 173
    s ++;
#line 174
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 177
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 177
    if (! ((int )*s != 0)) {
#line 177
      goto while_break___0;
    }
#line 178
    if ((int )*s != 35) {
#line 179
      if ((int )*t == 0) {
#line 179
        c = (char )'*';
      } else {
#line 179
        c = *t;
      }
#line 180
      if ((int )*s != (int )c) {
#line 180
        return (0);
      }
    }
#line 182
    s ++;
#line 183
    t ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 185
  return (1);
}
}
#line 188 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int find_domain_name(char *string ) 
{ 
  int i ;
  int tmp ;

  {
#line 192
  i = 0;
  {
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 192
    if (! ((unsigned long )CDNP_array[i].string != (unsigned long )((void *)0))) {
#line 192
      goto while_break;
    }
    {
    {
#line 193
    tmp = ppmatch(CDNP_array[i].string, string);
    }
    }
#line 193
    if (tmp) {
#line 194
      return (CDNP_array[i].n);
    }
#line 192
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 197
  return (0);
}
}
#line 218 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static Domain domain_array[497]  ;
#line 220 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static int N_domains  ;
#line 221 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static int N_domain_trees  ;
#line 224 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static List_o_links *word_links[250]  ;
#line 228 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void print_domain(int d ) 
{ 
  List_o_links *lol ;
  char *__cil_tmp3 ;

  {
#line 230
  lol = domain_array[d].lol;
  {
  {
#line 230
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 230
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 230
      goto while_break;
    }
    {
    {
#line 231
    print_a_link(stdout, lol->link);
    }
#line 230
    lol = lol->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 233
  printf((char const   */* __restrict  */)"\n");
  }
  }
#line 234
  return;
}
}
#line 236 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void print_domains(void) 
{ 
  int d ;
  char *__cil_tmp2 ;

  {
#line 238
  d = 0;
  {
  {
#line 238
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 238
    if (! (d < N_domains)) {
#line 238
      goto while_break;
    }
    {
    {
#line 239
    printf((char const   */* __restrict  */)"domain %d \"%s\"\n", d, domain_array[d].string);
    }
    {
#line 240
    print_domain(d);
    }
#line 238
    d ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 242
  return;
}
}
#line 244 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int post_process_match(char *s , char *t ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  {
#line 249
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 249
    tmp = __ctype_b_loc();
    }
    }
#line 249
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
      {
      {
#line 249
      tmp___0 = __ctype_b_loc();
      }
      }
#line 249
      if (! ((int const   )*(*tmp___0 + (int )*t) & 256)) {
#line 249
        goto while_break;
      }
    }
#line 250
    if ((int )*s != (int )*t) {
#line 250
      return (0);
    }
#line 251
    s ++;
#line 252
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 255
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 255
    if ((int )*s != 0) {
#line 255
      if (! ((int )*t != 0)) {
#line 255
        goto while_break___0;
      }
    } else {
#line 255
      goto while_break___0;
    }
#line 256
    if ((int )*s == 42) {
#line 258
      s ++;
#line 259
      t ++;
    } else
#line 256
    if ((int )*t == 42) {
#line 258
      s ++;
#line 259
      t ++;
    } else
#line 256
    if ((int )*s == (int )*t) {
#line 256
      if ((int )*s != 94) {
#line 258
        s ++;
#line 259
        t ++;
      } else {
#line 260
        return (0);
      }
    } else {
#line 260
      return (0);
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 262
  return (1);
}
}
#line 265 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int match_in_list(char *s , char **a ) 
{ 
  int i ;
  int tmp ;

  {
#line 269
  i = 0;
  {
  {
#line 269
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 269
    if (! ((unsigned long )*(a + i) != (unsigned long )((void *)0))) {
#line 269
      goto while_break;
    }
    {
    {
#line 270
    tmp = post_process_match(s, *(a + i));
    }
    }
#line 270
    if (tmp) {
#line 271
      return (1);
    }
#line 269
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return (0);
}
}
#line 277 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int string_in_list(char *s , char **a ) 
{ 
  int i ;
  int tmp ;

  {
#line 281
  i = 0;
  {
  {
#line 281
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 281
    if (! ((unsigned long )*(a + i) != (unsigned long )((void *)0))) {
#line 281
      goto while_break;
    }
    {
    {
#line 282
    tmp = ppmatch(*(a + i), s);
    }
    }
#line 282
    if (tmp) {
#line 283
      return (1);
    }
#line 281
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 286
  return (0);
}
}
#line 289 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void build_graph(void) 
{ 
  int i ;
  int link ;
  List_o_links *lol ;
  int tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 296
  i = 0;
  {
  {
#line 296
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 296
    if (! (i < N_words)) {
#line 296
      goto while_break;
    }
#line 297
    word_links[i] = (List_o_links *)((void *)0);
#line 296
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  link = 0;
  {
  {
#line 299
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 299
    if (! (link < N_links)) {
#line 299
      goto while_break___0;
    }
#line 300
    if (pp_link_array[link].l == -1) {
#line 300
      goto __Cont;
    }
    {
    {
#line 301
    tmp = string_in_list(pp_link_array[link].name, ignore_these_links);
    }
    }
#line 301
    if (tmp) {
#line 302
      goto __Cont;
    }
    {
    {
#line 304
    tmp___0 = xalloc((int )sizeof(List_o_links ));
    }
#line 304
    lol = (List_o_links *)tmp___0;
#line 305
    lol->next = word_links[pp_link_array[link].l];
#line 306
    word_links[pp_link_array[link].l] = lol;
#line 307
    lol->link = link;
#line 308
    lol->word = pp_link_array[link].r;
    {
#line 310
    tmp___1 = xalloc((int )sizeof(List_o_links ));
    }
#line 310
    lol = (List_o_links *)tmp___1;
#line 311
    lol->next = word_links[pp_link_array[link].r];
#line 312
    word_links[pp_link_array[link].r] = lol;
#line 313
    lol->link = link;
#line 314
    lol->word = pp_link_array[link].l;
    }
    __Cont: /* CIL Label */ 
#line 299
    link ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 318 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void add_link_to_domain(int link ) 
{ 
  List_o_links *lol ;
  void *tmp ;

  {
  {
  {
#line 320
  tmp = xalloc((int )sizeof(List_o_links ));
  }
#line 320
  lol = (List_o_links *)tmp;
#line 321
  lol->next = domain_array[N_domains].lol;
#line 322
  domain_array[N_domains].lol = lol;
#line 323
  (domain_array[N_domains].size) ++;
#line 324
  lol->link = link;
  }
#line 325
  return;
}
}
#line 327 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static int visited[250]  ;
#line 330 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void depth_first_search(int w , int root , int start_link ) 
{ 
  List_o_links *lol ;
  int tmp ;

  {
#line 332
  visited[w] = 1;
#line 333
  lol = word_links[w];
  {
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 333
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 333
      goto while_break;
    }
#line 334
    if (lol->word < w) {
#line 334
      if (lol->link != start_link) {
        {
        {
#line 335
        add_link_to_domain(lol->link);
        }
        }
      }
    }
#line 333
    lol = lol->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  lol = word_links[w];
  {
  {
#line 338
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 338
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 338
      goto while_break___0;
    }
#line 339
    if (! visited[lol->word]) {
#line 339
      if (lol->word != root) {
#line 339
        if (lol->word < root) {
#line 339
          if (lol->word < w) {
            {
            {
#line 339
            tmp = string_in_list(pp_link_array[lol->link].name, restricted_links);
            }
            }
#line 339
            if (! tmp) {
              {
              {
#line 342
              depth_first_search(lol->word, root, start_link);
              }
              }
            }
          } else {
            {
            {
#line 342
            depth_first_search(lol->word, root, start_link);
            }
            }
          }
        } else {
          {
          {
#line 342
          depth_first_search(lol->word, root, start_link);
          }
          }
        }
      }
    }
#line 338
    lol = lol->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 345
  return;
}
}
#line 347 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void bad_depth_first_search(int w , int root , int start_link ) 
{ 
  List_o_links *lol ;
  int tmp ;

  {
#line 349
  visited[w] = 1;
#line 350
  lol = word_links[w];
  {
  {
#line 350
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 350
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 350
      goto while_break;
    }
#line 351
    if (lol->word < w) {
#line 351
      if (lol->link != start_link) {
#line 351
        if (w != root) {
          {
          {
#line 352
          add_link_to_domain(lol->link);
          }
          }
        }
      }
    }
#line 350
    lol = lol->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  lol = word_links[w];
  {
  {
#line 355
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 355
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 355
      goto while_break___0;
    }
#line 356
    if (! visited[lol->word]) {
#line 356
      if (w == root) {
#line 356
        if (! (lol->word < w)) {
#line 356
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 356
      if (lol->word < root) {
#line 356
        if (lol->word < w) {
          {
          {
#line 356
          tmp = string_in_list(pp_link_array[lol->link].name, restricted_links);
          }
          }
#line 356
          if (! tmp) {
            {
            {
#line 359
            bad_depth_first_search(lol->word, root, start_link);
            }
            }
          }
        } else {
          {
          {
#line 359
          bad_depth_first_search(lol->word, root, start_link);
          }
          }
        }
      } else {
        {
        {
#line 359
        bad_depth_first_search(lol->word, root, start_link);
        }
        }
      }
    }
#line 355
    lol = lol->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 362
  return;
}
}
#line 364 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void d_depth_first_search(int w , int root , int right , int start_link ) 
{ 
  List_o_links *lol ;
  int tmp ;

  {
#line 366
  visited[w] = 1;
#line 367
  lol = word_links[w];
  {
  {
#line 367
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 367
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 367
      goto while_break;
    }
#line 368
    if (lol->word < w) {
#line 368
      if (lol->link != start_link) {
#line 368
        if (w != root) {
          {
          {
#line 369
          add_link_to_domain(lol->link);
          }
          }
        }
      }
    }
#line 367
    lol = lol->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 372
  lol = word_links[w];
  {
  {
#line 372
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 372
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 372
      goto while_break___0;
    }
#line 373
    if (! visited[lol->word]) {
#line 373
      if (w == root) {
#line 373
        if (! (lol->word >= right)) {
#line 373
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 373
      if (w == root) {
#line 373
        if (! (lol->word < root)) {
#line 373
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 373
      if (lol->word < root) {
#line 373
        if (lol->word < w) {
          {
          {
#line 373
          tmp = string_in_list(pp_link_array[lol->link].name, restricted_links);
          }
          }
#line 373
          if (! tmp) {
            {
            {
#line 377
            d_depth_first_search(lol->word, root, right, start_link);
            }
            }
          }
        } else {
          {
          {
#line 377
          d_depth_first_search(lol->word, root, right, start_link);
          }
          }
        }
      } else {
        {
        {
#line 377
        d_depth_first_search(lol->word, root, right, start_link);
        }
        }
      }
    }
#line 372
    lol = lol->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 380
  return;
}
}
#line 382 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int domain_compare(Domain *d1 , Domain *d2 ) 
{ 


  {
#line 384
  return (d1->size - d2->size);
}
}
#line 387 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void build_domains(void) 
{ 
  int link ;
  int i ;
  int d ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp10 ;

  {
#line 391
  N_domains = 0;
#line 392
  link = 0;
  {
  {
#line 392
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 392
    if (! (link < N_links)) {
#line 392
      goto while_break;
    }
#line 393
    if (pp_link_array[link].l == -1) {
#line 393
      goto __Cont;
    }
    {
    {
#line 394
    tmp = string_in_list(pp_link_array[link].name, ignore_these_links);
    }
    }
#line 394
    if (tmp) {
#line 395
      goto __Cont;
    }
    {
#line 397
    s = pp_link_array[link].name;
    {
#line 398
    tmp___3 = string_in_list(s, domain_starter_links);
    }
    }
#line 398
    if (tmp___3) {
#line 399
      i = 0;
      {
      {
#line 399
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 399
        if (! (i < N_words)) {
#line 399
          goto while_break___0;
        }
#line 400
        visited[i] = 0;
#line 399
        i ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 402
      domain_array[N_domains].string = s;
#line 403
      domain_array[N_domains].lol = (List_o_links *)((void *)0);
#line 404
      domain_array[N_domains].size = 0;
#line 405
      domain_array[N_domains].start_link = link;
      {
#line 406
      tmp___0 = string_in_list(s, domain_contains_links);
      }
      }
#line 406
      if (tmp___0) {
        {
        {
#line 407
        add_link_to_domain(link);
        }
        }
      }
      {
      {
#line 409
      depth_first_search(pp_link_array[link].r, pp_link_array[link].l, link);
      }
#line 410
      N_domains ++;
      }
    } else {
      {
      {
#line 411
      tmp___2 = string_in_list(s, urfl_domain_starter_links);
      }
      }
#line 411
      if (tmp___2) {
#line 412
        i = 0;
        {
        {
#line 412
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 412
          if (! (i < N_words)) {
#line 412
            goto while_break___1;
          }
#line 413
          visited[i] = 0;
#line 412
          i ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 415
        domain_array[N_domains].string = s;
#line 416
        domain_array[N_domains].lol = (List_o_links *)((void *)0);
#line 417
        domain_array[N_domains].size = 0;
#line 418
        domain_array[N_domains].start_link = link;
        {
#line 419
        add_link_to_domain(link);
        }
        {
#line 421
        bad_depth_first_search(pp_link_array[link].r, pp_link_array[link].l, link);
        }
#line 422
        N_domains ++;
        }
      } else {
        {
        {
#line 423
        tmp___1 = string_in_list(s, urfl_only_domain_starter_links);
        }
        }
#line 423
        if (tmp___1) {
#line 424
          i = 0;
          {
          {
#line 424
          while (1) {
            while_continue___7: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 424
            if (! (i < N_words)) {
#line 424
              goto while_break___2;
            }
#line 425
            visited[i] = 0;
#line 424
            i ++;
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
          {
#line 427
          domain_array[N_domains].string = s;
#line 428
          domain_array[N_domains].lol = (List_o_links *)((void *)0);
#line 429
          domain_array[N_domains].size = 0;
#line 430
          domain_array[N_domains].start_link = link;
          {
#line 432
          d_depth_first_search(pp_link_array[link].l, pp_link_array[link].l, pp_link_array[link].r,
                               link);
          }
#line 434
          N_domains ++;
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 392
    link ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 437
  qsort((void *)(domain_array), (size_t )N_domains, (size_t )sizeof(Domain ), (int (*)(void const   * ,
                                                                                       void const   * ))(& domain_compare));
  }
#line 441
  d = 0;
  }
  {
  {
#line 441
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 441
    if (! (d < N_domains)) {
#line 441
      goto while_break___3;
    }
    {
    {
#line 442
    i = find_domain_name(domain_array[d].string);
    }
    }
#line 443
    if (i == 0) {
      {
      {
#line 444
      printf((char const   */* __restrict  */)"something wrong with domain name %s\n",
             domain_array[d].string);
      }
      {
#line 446
      exit(1);
      }
      }
    }
#line 448
    domain_array[d].type = i;
#line 441
    d ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 450
  return;
}
}
#line 452 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int contained_in(Domain *d1 , Domain *d2 ) 
{ 
  char mark[497] ;
  List_o_links *lol ;
  int i ;
  void *__cil_tmp6 ;

  {
#line 457
  i = 0;
  {
  {
#line 457
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 457
    if (! (i < N_links)) {
#line 457
      goto while_break;
    }
#line 458
    mark[i] = (char)0;
#line 457
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 460
  lol = d2->lol;
  {
  {
#line 460
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 460
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 460
      goto while_break___0;
    }
#line 461
    mark[lol->link] = (char)1;
#line 460
    lol = lol->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 463
  lol = d1->lol;
  {
  {
#line 463
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 463
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 463
      goto while_break___1;
    }
#line 464
    if (! mark[lol->link]) {
#line 464
      return (0);
    }
#line 463
    lol = lol->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 466
  return (1);
}
}
#line 469 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int link_in_domain(int link , Domain *d ) 
{ 
  List_o_links *lol ;

  {
#line 472
  lol = d->lol;
  {
  {
#line 472
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 472
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 472
      goto while_break;
    }
#line 473
    if (lol->link == link) {
#line 473
      return (1);
    }
#line 472
    lol = lol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 475
  return (0);
}
}
#line 478 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int check_domain_nesting(void) 
{ 
  Domain *d1 ;
  Domain *d2 ;
  int counts[4] ;
  char mark[497] ;
  List_o_links *lol ;
  int i ;
  void *__cil_tmp7 ;
  void *__cil_tmp8 ;

  {
#line 485
  d1 = domain_array;
  {
  {
#line 485
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 485
    if (! ((unsigned long )d1 < (unsigned long )(domain_array + N_domains))) {
#line 485
      goto while_break;
    }
#line 486
    d2 = d1 + 1;
    {
    {
#line 486
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 486
      if (! ((unsigned long )d2 < (unsigned long )(domain_array + N_domains))) {
#line 486
        goto while_break___0;
      }
#line 487
      i = 0;
      {
      {
#line 487
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 487
        if (! (i < N_links)) {
#line 487
          goto while_break___1;
        }
#line 488
        mark[i] = (char)0;
#line 487
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 490
      lol = d2->lol;
      {
      {
#line 490
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 490
        if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 490
          goto while_break___2;
        }
#line 491
        mark[lol->link] = (char)1;
#line 490
        lol = lol->next;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 493
      lol = d1->lol;
      {
      {
#line 493
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 493
        if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 493
          goto while_break___3;
        }
#line 494
        mark[lol->link] = (char )((int )mark[lol->link] + 2);
#line 493
        lol = lol->next;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 496
      counts[3] = 0;
#line 496
      counts[2] = counts[3];
#line 496
      counts[1] = counts[2];
#line 496
      counts[0] = counts[1];
#line 497
      i = 0;
      {
      {
#line 497
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 497
        if (! (i < N_links)) {
#line 497
          goto while_break___4;
        }
#line 497
        (counts[(int )mark[i]]) ++;
#line 497
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 498
      if (counts[1] > 0) {
#line 498
        if (counts[2] > 0) {
#line 498
          if (counts[3] > 0) {
#line 499
            return (0);
          }
        }
      }
#line 486
      d2 ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 485
    d1 ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 503
  return (1);
}
}
#line 506 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void build_domain_forest(void) 
{ 
  int d ;
  int d1 ;
  int link ;
  D_tree_leaf *dtl ;
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 509
  if (N_domains > 0) {
#line 510
    domain_array[N_domains - 1].parent = (Domain *)((void *)0);
  }
#line 512
  N_domain_trees = 1;
#line 513
  d = 0;
  {
  {
#line 513
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 513
    if (! (d < N_domains - 1)) {
#line 513
      goto while_break;
    }
#line 514
    d1 = d + 1;
    {
    {
#line 514
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 514
      if (! (d1 < N_domains)) {
#line 514
        goto while_break___0;
      }
      {
      {
#line 515
      tmp = contained_in(& domain_array[d], & domain_array[d1]);
      }
      }
#line 515
      if (tmp) {
#line 516
        domain_array[d].parent = & domain_array[d1];
#line 517
        goto while_break___0;
      }
#line 514
      d1 ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 520
    if (d1 == N_domains) {
#line 522
      domain_array[d].parent = (Domain *)((void *)0);
#line 523
      N_domain_trees ++;
    }
#line 513
    d ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 532
  d = 0;
  {
  {
#line 532
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 532
    if (! (d < N_domains)) {
#line 532
      goto while_break___1;
    }
#line 533
    domain_array[d].child = (D_tree_leaf *)((void *)0);
#line 532
    d ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 535
  link = 0;
  {
  {
#line 535
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 535
    if (! (link < N_links)) {
#line 535
      goto while_break___2;
    }
#line 536
    if (pp_link_array[link].l == -1) {
#line 536
      goto __Cont;
    }
#line 537
    d = 0;
    {
    {
#line 537
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 537
      if (! (d < N_domains)) {
#line 537
        goto while_break___3;
      }
      {
      {
#line 538
      tmp___1 = link_in_domain(link, & domain_array[d]);
      }
      }
#line 538
      if (tmp___1) {
        {
        {
#line 539
        tmp___0 = xalloc((int )sizeof(D_tree_leaf ));
        }
#line 539
        dtl = (D_tree_leaf *)tmp___0;
#line 540
        dtl->link = link;
#line 541
        dtl->parent = & domain_array[d];
#line 542
        dtl->next = domain_array[d].child;
#line 543
        domain_array[d].child = dtl;
        }
#line 544
        goto while_break___3;
      }
#line 537
      d ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 535
    link ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 548
  return;
}
}
#line 550 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void free_list_o_links(List_o_links *lol ) 
{ 
  List_o_links *xlol ;

  {
  {
  {
#line 555
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 555
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 555
      goto while_break;
    }
    {
#line 556
    xlol = lol->next;
    {
#line 557
    xfree((char *)lol, (int )sizeof(List_o_links ));
    }
#line 558
    lol = xlol;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 560
  return;
}
}
#line 562 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void free_D_tree_leaves(D_tree_leaf *dtl ) 
{ 
  D_tree_leaf *xdtl ;

  {
  {
  {
#line 564
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 564
    if (! ((unsigned long )dtl != (unsigned long )((void *)0))) {
#line 564
      goto while_break;
    }
    {
#line 565
    xdtl = dtl->next;
    {
#line 566
    xfree((char *)dtl, (int )sizeof(D_tree_leaf ));
    }
#line 567
    dtl = xdtl;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 569
  return;
}
}
#line 571 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void free_post_processing_structures(void) 
{ 
  int w ;
  int d ;

  {
#line 573
  w = 0;
  {
  {
#line 573
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 573
    if (! (w < N_words)) {
#line 573
      goto while_break;
    }
    {
    {
#line 574
    free_list_o_links(word_links[w]);
    }
#line 573
    w ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  d = 0;
  {
  {
#line 576
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 576
    if (! (d < N_domains)) {
#line 576
      goto while_break___0;
    }
    {
    {
#line 577
    free_list_o_links(domain_array[d].lol);
    }
    {
#line 578
    free_D_tree_leaves(domain_array[d].child);
    }
#line 576
    d ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 580
  return;
}
}
#line 582 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void print_domain_tree(void) 
{ 
  int d ;
  D_tree_leaf *dtl ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 585
  printf((char const   */* __restrict  */)"Domain     It\'s parent \n");
  }
#line 586
  d = 0;
  }
  {
  {
#line 586
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 586
    if (! (d < N_domains - 1)) {
#line 586
      goto while_break;
    }
    {
    {
#line 587
    printf((char const   */* __restrict  */)" %3d        %3d\n", d, (int )(domain_array[d].parent - domain_array));
    }
#line 586
    d ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 589
  d = 0;
  {
  {
#line 589
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 589
    if (! (d < N_domains)) {
#line 589
      goto while_break___0;
    }
    {
    {
#line 590
    printf((char const   */* __restrict  */)"Link children of domain %d:\n", d);
    }
#line 591
    dtl = domain_array[d].child;
    }
    {
    {
#line 591
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 591
      if (! ((unsigned long )dtl != (unsigned long )((void *)0))) {
#line 591
        goto while_break___1;
      }
      {
      {
#line 592
      print_a_link(stdout, dtl->link);
      }
#line 591
      dtl = dtl->next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 589
    d ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 595
  return;
}
}
#line 597 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int CCG_rule(void) 
{ 
  int d ;
  int t ;

  {
#line 601
  d = 0;
  {
  {
#line 601
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 601
    if (! (d < N_domains)) {
#line 601
      goto while_break;
    }
#line 602
    if (domain_array[d].type == 99) {
#line 602
      if ((unsigned long )domain_array[d].parent != (unsigned long )((void *)0)) {
#line 603
        t = (domain_array[d].parent)->type;
#line 604
        if (t != 103) {
#line 604
          if (t != 99) {
#line 604
            return (0);
          }
        }
      }
    }
#line 601
    d ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  return (1);
}
}
#line 610 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int domain_bounded(int d_type ) 
{ 
  int d ;
  int lw ;
  List_o_links *lol ;

  {
#line 618
  d = 0;
  {
  {
#line 618
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 618
    if (! (d < N_domains)) {
#line 618
      goto while_break;
    }
#line 619
    if (domain_array[d].type != d_type) {
#line 619
      goto __Cont;
    }
#line 620
    lw = pp_link_array[domain_array[d].start_link].l;
#line 621
    lol = domain_array[d].lol;
    {
    {
#line 621
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 621
      if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 621
        goto while_break___0;
      }
#line 622
      if (pp_link_array[lol->link].l < lw) {
#line 622
        return (0);
      }
#line 621
      lol = lol->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 618
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 625
  return (1);
}
}
#line 628 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int link_inhabits(char *link_name , int d_type ) 
{ 
  int d ;
  D_tree_leaf *c ;
  int tmp ;

  {
#line 635
  d = 0;
  {
  {
#line 635
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 635
    if (! (d < N_domains)) {
#line 635
      goto while_break;
    }
#line 636
    c = domain_array[d].child;
    {
    {
#line 636
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 636
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 636
        goto while_break___0;
      }
      {
      {
#line 637
      tmp = ppmatch(link_name, pp_link_array[c->link].name);
      }
      }
#line 637
      if (tmp) {
#line 638
        if (domain_array[d].type != d_type) {
#line 638
          return (0);
        }
      }
#line 636
      c = c->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 635
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 642
  return (1);
}
}
#line 645 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int group_type_contains(int d_type , char *link_name ) 
{ 
  int d ;
  D_tree_leaf *c ;
  int tmp ;

  {
#line 649
  d = 0;
  {
  {
#line 649
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 649
    if (! (d < N_domains)) {
#line 649
      goto while_break;
    }
#line 650
    if (domain_array[d].type != d_type) {
#line 650
      goto __Cont;
    }
#line 651
    c = domain_array[d].child;
    {
    {
#line 651
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 651
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 651
        goto while_break___0;
      }
      {
      {
#line 652
      tmp = ppmatch(link_name, pp_link_array[c->link].name);
      }
      }
#line 652
      if (tmp) {
#line 652
        goto while_break___0;
      }
#line 651
      c = c->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 654
    if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 654
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 649
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  return (1);
}
}
#line 659 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int group_type_contains_all(int d_type , char **name_list ) 
{ 
  int i ;
  int tmp ;

  {
#line 662
  i = 0;
  {
  {
#line 662
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 662
    if (! ((unsigned long )*(name_list + i) != (unsigned long )((void *)0))) {
#line 662
      goto while_break;
    }
    {
    {
#line 663
    tmp = group_type_contains(d_type, *(name_list + i));
    }
    }
#line 663
    if (! tmp) {
#line 663
      return (0);
    }
#line 662
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 665
  return (1);
}
}
#line 668 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int group_type_contains_one(int d_type , char **name_list ) 
{ 
  int d ;
  int i ;
  int count___0 ;
  D_tree_leaf *c ;
  int tmp ;

  {
#line 673
  d = 0;
  {
  {
#line 673
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 673
    if (! (d < N_domains)) {
#line 673
      goto while_break;
    }
#line 674
    if (domain_array[d].type != d_type) {
#line 674
      goto __Cont;
    }
#line 675
    count___0 = 0;
#line 676
    i = 0;
    {
    {
#line 676
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 676
      if (! ((unsigned long )*(name_list + i) != (unsigned long )((void *)0))) {
#line 676
        goto while_break___0;
      }
#line 677
      c = domain_array[d].child;
      {
      {
#line 677
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 677
        if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 677
          goto while_break___1;
        }
        {
        {
#line 678
        tmp = ppmatch(*(name_list + i), pp_link_array[c->link].name);
        }
        }
#line 678
        if (tmp) {
#line 678
          count___0 ++;
        }
#line 677
        c = c->next;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 676
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 681
    if (count___0 != 1) {
#line 681
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 673
    d ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return (1);
}
}
#line 686 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int contains_none(char *selector , char **incompat ) 
{ 
  D_tree_leaf *dtl ;
  int d ;
  int tmp ;
  int tmp___0 ;

  {
#line 693
  d = 0;
  {
  {
#line 693
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 693
    if (! (d < N_domains)) {
#line 693
      goto while_break;
    }
#line 694
    dtl = domain_array[d].child;
    {
    {
#line 694
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 694
      if (! ((unsigned long )dtl != (unsigned long )((void *)0))) {
#line 694
        goto while_break___0;
      }
      {
      {
#line 695
      tmp = ppmatch(selector, pp_link_array[dtl->link].name);
      }
      }
#line 695
      if (tmp) {
#line 695
        goto while_break___0;
      }
#line 694
      dtl = dtl->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 697
    if ((unsigned long )dtl != (unsigned long )((void *)0)) {
#line 698
      dtl = domain_array[d].child;
      {
      {
#line 698
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 698
        if (! ((unsigned long )dtl != (unsigned long )((void *)0))) {
#line 698
          goto while_break___1;
        }
        {
        {
#line 699
        tmp___0 = string_in_list(pp_link_array[dtl->link].name, incompat);
        }
        }
#line 699
        if (tmp___0) {
#line 700
          return (0);
        }
#line 698
        dtl = dtl->next;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 693
    d ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 705
  return (1);
}
}
#line 708 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int ordering_constraint(char *X , char *Y ) 
{ 
  D_tree_leaf *dtl ;
  int d ;
  int leftmost_y ;
  int rightmost_x ;
  int tmp ;
  int tmp___0 ;

  {
#line 718
  d = 0;
  {
  {
#line 718
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 718
    if (! (d < N_domains)) {
#line 718
      goto while_break;
    }
#line 719
    leftmost_y = N_words;
#line 720
    rightmost_x = -1;
#line 721
    dtl = domain_array[d].child;
    {
    {
#line 721
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 721
      if (! ((unsigned long )dtl != (unsigned long )((void *)0))) {
#line 721
        goto while_break___0;
      }
      {
      {
#line 722
      tmp___0 = strcmp((char const   *)pp_link_array[dtl->link].name, (char const   *)Y);
      }
      }
#line 722
      if (tmp___0 == 0) {
#line 723
        if (leftmost_y > pp_link_array[dtl->link].r) {
#line 724
          leftmost_y = pp_link_array[dtl->link].r;
        }
      } else {
        {
        {
#line 726
        tmp = strcmp((char const   *)pp_link_array[dtl->link].name, (char const   *)X);
        }
        }
#line 726
        if (tmp == 0) {
#line 727
          if (rightmost_x < pp_link_array[dtl->link].r) {
#line 728
            rightmost_x = pp_link_array[dtl->link].r;
          }
        }
      }
#line 721
      dtl = dtl->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 732
    if (leftmost_y <= rightmost_x) {
#line 732
      return (0);
    }
#line 718
    d ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 734
  return (1);
}
}
#line 737 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int contains_one(char *selector , char **required ) 
{ 
  D_tree_leaf *dtl ;
  int d ;
  int count___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 745
  d = 0;
  {
  {
#line 745
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 745
    if (! (d < N_domains)) {
#line 745
      goto while_break;
    }
#line 746
    dtl = domain_array[d].child;
    {
    {
#line 746
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 746
      if (! ((unsigned long )dtl != (unsigned long )((void *)0))) {
#line 746
        goto while_break___0;
      }
      {
      {
#line 747
      tmp = ppmatch(selector, pp_link_array[dtl->link].name);
      }
      }
#line 747
      if (tmp) {
#line 747
        goto while_break___0;
      }
#line 746
      dtl = dtl->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 749
    if ((unsigned long )dtl != (unsigned long )((void *)0)) {
#line 750
      count___0 = 0;
#line 751
      dtl = domain_array[d].child;
      {
      {
#line 751
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 751
        if (! ((unsigned long )dtl != (unsigned long )((void *)0))) {
#line 751
          goto while_break___1;
        }
        {
        {
#line 752
        tmp___0 = string_in_list(pp_link_array[dtl->link].name, required);
        }
        }
#line 752
        if (tmp___0) {
#line 753
          count___0 ++;
        }
#line 751
        dtl = dtl->next;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 756
      if (count___0 < 1) {
#line 756
        return (0);
      }
    }
#line 745
    d ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 759
  return (1);
}
}
#line 762 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void connectivity_dfs(int w , char **s ) 
{ 
  List_o_links *lol ;
  int tmp ;

  {
#line 764
  visited[w] = 1;
#line 765
  lol = word_links[w];
  {
  {
#line 765
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 765
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 765
      goto while_break;
    }
#line 766
    if (! visited[lol->word]) {
      {
      {
#line 766
      tmp = string_in_list(pp_link_array[lol->link].name, s);
      }
      }
#line 766
      if (! tmp) {
        {
        {
#line 768
        connectivity_dfs(lol->word, s);
        }
        }
      }
    }
#line 765
    lol = lol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 771
  return;
}
}
#line 773 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void mark_reachable_words(int w ) 
{ 
  List_o_links *lol ;

  {
#line 775
  if (visited[w]) {
#line 775
    return;
  }
#line 776
  visited[w] = 1;
#line 777
  lol = word_links[w];
  {
  {
#line 777
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 777
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 777
      goto while_break;
    }
    {
    {
#line 778
    mark_reachable_words(lol->word);
    }
#line 777
    lol = lol->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 780
  return;
}
}
#line 782 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int is_connected_without(char **s ) 
{ 
  int i ;

  {
#line 791
  i = 0;
  {
  {
#line 791
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 791
    if (! (i < N_words)) {
#line 791
      goto while_break;
    }
#line 792
    visited[i] = 0;
#line 791
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 794
  mark_reachable_words(0);
  }
#line 795
  i = 0;
  }
  {
  {
#line 795
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 795
    if (! (i < N_words)) {
#line 795
      goto while_break___0;
    }
#line 796
    visited[i] = ! visited[i];
#line 795
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 798
  connectivity_dfs(0, s);
  }
#line 799
  i = 0;
  }
  {
  {
#line 799
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 799
    if (! (i < N_words)) {
#line 799
      goto while_break___1;
    }
#line 800
    if (visited[i] == 0) {
#line 801
      return (0);
    }
#line 799
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 804
  return (1);
}
}
#line 807 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
int is_connected(void) 
{ 
  int i ;

  {
#line 812
  i = 0;
  {
  {
#line 812
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 812
    if (! (i < N_words)) {
#line 812
      goto while_break;
    }
#line 812
    visited[i] = (unsigned long )word_links[i] == (unsigned long )((void *)0);
#line 812
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 813
  mark_reachable_words(0);
  }
#line 814
  i = 0;
  }
  {
  {
#line 814
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 814
    if (! (i < N_words)) {
#line 814
      goto while_break___0;
    }
#line 814
    if (! visited[i]) {
#line 814
      return (0);
    }
#line 814
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 815
  return (1);
}
}
#line 818 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *incompat_with_THi[13]  = 
#line 818
  {      (char *)"I*",      (char *)"PP*",      (char *)"TO*",      (char *)"Pa*", 
        (char *)"Pam",      (char *)"S",      (char *)"SI",      (char *)"Pg*", 
        (char *)"Pv*",      (char *)"LE*",      (char *)"AFd*",      (char *)"MVta", 
        (char *)((void *)0)};
#line 821 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *SFiSFIi[4]  = {      (char *)"SFsi",      (char *)"SFIsi",      (char *)"OXi",      (char *)((void *)0)};
#line 822 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Necessary_for_SF[12]  = 
#line 822
  {      (char *)"TOi",      (char *)"THi",      (char *)"QIi",      (char *)"TSi", 
        (char *)"O#i",      (char *)"Ci",      (char *)"THb",      (char *)"COqi", 
        (char *)"CPi",      (char *)"Eqi",      (char *)"AFdi",      (char *)((void *)0)};
#line 824 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Necessary_for_MVt[15]  = 
#line 824
  {      (char *)"Dm#m",      (char *)"EAm",      (char *)"EEm",      (char *)"MVm", 
        (char *)"Pam",      (char *)"Pafm",      (char *)"AFm",      (char *)"EB#m", 
        (char *)"MVb",      (char *)"Om",      (char *)"Mam",      (char *)"Am", 
        (char *)"Jm",      (char *)"Ds*m",      (char *)((void *)0)};
#line 827 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_MVz[6]  = {      (char *)"D##y",      (char *)"EAy",      (char *)"EEy",      (char *)"MVy", 
        (char *)"EB#y",      (char *)((void *)0)};
#line 829 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Opt[7]  = {      (char *)"Opt",      (char *)"Omt",      (char *)"O*t",      (char *)"Bp#t", 
        (char *)"B*#t",      (char *)"Bc#t",      (char *)((void *)0)};
#line 831 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Ost[7]  = {      (char *)"O*t",      (char *)"Ost",      (char *)"Omt",      (char *)"Bs#t", 
        (char *)"B*#t",      (char *)"Bc#t",      (char *)((void *)0)};
#line 833 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Oxt[3]  = {      (char *)"O#t",      (char *)"B##t",      (char *)((void *)0)};
#line 834 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_BIh[3]  = {      (char *)"Ss#b",      (char *)"SIs#b",      (char *)((void *)0)};
#line 835 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_THb[5]  = {      (char *)"S##t",      (char *)"SI##t",      (char *)"SFsi",      (char *)"SFIsi", 
        (char *)((void *)0)};
#line 837 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_BIq[7]  = {      (char *)"S##q",      (char *)"SI##q",      (char *)"SFsi",      (char *)"Ss#b", 
        (char *)"SFIsi",      (char *)"SIs#b",      (char *)((void *)0)};
#line 839 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Necessary_for_Thcom[2]  = {      (char *)"TH",      (char *)((void *)0)};
#line 840 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Necessary_for_Tvcom[2]  = {      (char *)"TOi*",      (char *)((void *)0)};
#line 841 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Necessary_for_Tocom[3]  = {      (char *)"TO**",      (char *)"TOf*",      (char *)((void *)0)};
#line 842 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Necessary_for_Tvcom_Trans[2]  = {      (char *)"TOt*",      (char *)((void *)0)};
#line 843 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *MVm[2]  = {      (char *)"MVm",      (char *)((void *)0)};
#line 844 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *MV[3]  = {      (char *)"MVa",      (char *)"MVp",      (char *)((void *)0)};
#line 845 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *EBmm[3]  = {      (char *)"EB#m",      (char *)"EB#y",      (char *)((void *)0)};
#line 846 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Pa_or_Paf[3]  = {      (char *)"Pa*",      (char *)"Paf*",      (char *)((void *)0)};
#line 847 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_MVto[8]  = 
#line 847
  {      (char *)"D##m",      (char *)"D##y",      (char *)"Om",      (char *)"Oy", 
        (char *)"Jm",      (char *)"Jy",      (char *)"Am",      (char *)((void *)0)};
#line 849 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_MVtp[12]  = 
#line 849
  {      (char *)"EEm",      (char *)"MVb",      (char *)"Dm#m",      (char *)"EEy", 
        (char *)"D##y",      (char *)"MVm",      (char *)"Om",      (char *)"Oy", 
        (char *)"Jm",      (char *)"Jy",      (char *)"Am",      (char *)((void *)0)};
#line 851 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_MVta[9]  = 
#line 851
  {      (char *)"Pam",      (char *)"Pafm",      (char *)"EAm",      (char *)"Ds*m", 
        (char *)"EAy",      (char *)"AFm",      (char *)"Mam",      (char *)"Am", 
        (char *)((void *)0)};
#line 852 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Cc[6]  = {      (char *)"EEm",      (char *)"EEy",      (char *)"MVm",      (char *)"MVb", 
        (char *)"MVy",      (char *)((void *)0)};
#line 853 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Mc[2]  = {      (char *)"Dm#m",      (char *)((void *)0)};
#line 854 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Sp_com[7]  = {      (char *)"Dmcm",      (char *)"Dmcy",      (char *)"Om",      (char *)"Oy", 
        (char *)"Jm",      (char *)"Jy",      (char *)((void *)0)};
#line 856 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Ss_com[8]  = 
#line 856
  {      (char *)"Dmum",      (char *)"Dmuy",      (char *)"Om",      (char *)"Oy", 
        (char *)"Jm",      (char *)"Jy",      (char *)"Ds*y",      (char *)((void *)0)};
#line 858 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_S_com[7]  = {      (char *)"Dm#m",      (char *)"D##y",      (char *)"Om",      (char *)"Oy", 
        (char *)"Jm",      (char *)"Jy",      (char *)((void *)0)};
#line 860 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Inv[5]  = {      (char *)"Wq",      (char *)"Qd",      (char *)"CQ",      (char *)"PFc", 
        (char *)((void *)0)};
#line 861 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Incompat_with_Ws[4]  = {      (char *)"B#m",      (char *)"Ca",      (char *)"BT",      (char *)((void *)0)};
#line 863 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Ws_2[4]  = {      (char *)"D##w",      (char *)"S##w",      (char *)"H",      (char *)((void *)0)};
#line 864 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Wq[3]  = {      (char *)"SI",      (char *)"SFI",      (char *)((void *)0)};
#line 865 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Ma[13]  = 
#line 865
  {      (char *)"TO",      (char *)"TOf",      (char *)"TH",      (char *)"MVp", 
        (char *)"TOt",      (char *)"QI",      (char *)"OF",      (char *)"MVt", 
        (char *)"MVz",      (char *)"MVh",      (char *)"Ytm",      (char *)"Ya", 
        (char *)((void *)0)};
#line 867 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Ia[3]  = {      (char *)"B#m",      (char *)"B#w",      (char *)((void *)0)};
#line 868 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Jr[2]  = {      (char *)"Jr",      (char *)((void *)0)};
#line 869 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Jr[2]  = {      (char *)"B#j",      (char *)((void *)0)};
#line 870 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_j[3]  = {      (char *)"JQ",      (char *)"Jw",      (char *)((void *)0)};
#line 871 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Mj_or_Wj[4]  = {      (char *)"Mj",      (char *)"Wj",      (char *)"MX#j",      (char *)((void *)0)};
#line 872 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_Qe[2]  = {      (char *)"EEh",      (char *)((void *)0)};
#line 873 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_EAh[7]  = {      (char *)"AF",      (char *)"Bsm",      (char *)"B*m",      (char *)"Qe", 
        (char *)"Ca",      (char *)"AFm",      (char *)((void *)0)};
#line 875 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *ZZ[2]  = {      (char *)"ZZ",      (char *)((void *)0)};
#line 876 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Nec_for_MVh[4]  = {      (char *)"EExk",      (char *)"EAxk",      (char *)"D##k",      (char *)((void *)0)};
#line 878 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Incompat_with_MXsr[2]  = {      (char *)"Sp#w",      (char *)((void *)0)};
#line 879 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *Incompat_with_MXpr[3]  = {      (char *)"Ss#w",      (char *)"S#iw",      (char *)((void *)0)};
#line 880 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *illegal_S_types[7]  = {      (char *)"Spxi",      (char *)"Spi*",      (char *)"Spit",      (char *)"Spiq", 
        (char *)"Spib",      (char *)"Spiw",      (char *)((void *)0)};
#line 882 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
static char *illegal_SI_types[6]  = {      (char *)"SIpxi",      (char *)"SIpi*",      (char *)"SIpit",      (char *)"SIpiq", 
        (char *)"SIpib",      (char *)((void *)0)};
#line 895 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
void free_PP_node(PP_node *p ) 
{ 
  D_type_list *dtl ;
  D_type_list *dtlx ;
  Violation_list *v ;
  Violation_list *vx ;
  int i ;

  {
#line 899
  i = 0;
  {
  {
#line 899
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 899
    if (! (i < N_links)) {
#line 899
      goto while_break;
    }
#line 900
    dtl = *(p->d_type_array + i);
    {
    {
#line 900
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 900
      if (! ((unsigned long )dtl != (unsigned long )((void *)0))) {
#line 900
        goto while_break___0;
      }
      {
#line 901
      dtlx = dtl->next;
      {
#line 902
      xfree((char *)dtl, (int )sizeof(D_type_list ));
      }
#line 900
      dtl = dtlx;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 899
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 905
  if (N_links > 0) {
    {
    {
#line 905
    xfree((char *)p->d_type_array, (int )((unsigned long )N_links * sizeof(D_type_list *)));
    }
    }
  }
#line 906
  v = p->v;
  {
  {
#line 906
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 906
    if (! ((unsigned long )v != (unsigned long )((void *)0))) {
#line 906
      goto while_break___1;
    }
    {
#line 907
    vx = v->next;
    {
#line 908
    xfree((char *)v, (int )sizeof(Violation_list ));
    }
#line 906
    v = vx;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 910
  xfree((char *)p, (int )sizeof(PP_node ));
  }
  }
#line 911
  return;
}
}
#line 914 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
D_type_list **build_type_array(void) 
{ 
  D_type_list **array ;
  D_type_list *dtl ;
  int d ;
  int i ;
  List_o_links *lol ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 919
  array = (D_type_list **)((void *)0);
#line 920
  if (N_links > 0) {
    {
    {
#line 920
    tmp = xalloc((int )((unsigned long )N_links * sizeof(D_type_list *)));
    }
#line 920
    array = (D_type_list **)tmp;
    }
  }
#line 921
  i = 0;
  {
  {
#line 921
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 921
    if (! (i < N_links)) {
#line 921
      goto while_break;
    }
#line 922
    *(array + i) = (D_type_list *)((void *)0);
#line 921
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 924
  d = 0;
  {
  {
#line 924
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 924
    if (! (d < N_domains)) {
#line 924
      goto while_break___0;
    }
#line 925
    lol = domain_array[d].lol;
    {
    {
#line 925
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 925
      if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 925
        goto while_break___1;
      }
      {
      {
#line 926
      tmp___0 = xalloc((int )sizeof(D_type_list ));
      }
#line 926
      dtl = (D_type_list *)tmp___0;
#line 927
      dtl->next = *(array + lol->link);
#line 928
      *(array + lol->link) = dtl;
#line 929
      dtl->type = domain_array[d].type;
#line 925
      lol = lol->next;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 924
    d ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 932
  return (array);
}
}
#line 935 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
PP_node *bogus_pp_node(void) 
{ 
  PP_node *pp_return ;
  int link ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 941
  tmp = xalloc((int )sizeof(PP_node ));
  }
#line 941
  pp_return = (PP_node *)tmp;
  {
#line 942
  tmp___0 = xalloc((int )((unsigned long )N_links * sizeof(D_type_list *)));
  }
#line 942
  pp_return->d_type_array = (D_type_list **)tmp___0;
#line 944
  link = 0;
  }
  {
  {
#line 944
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 944
    if (! (link < N_links)) {
#line 944
      goto while_break;
    }
#line 945
    *(pp_return->d_type_array + link) = (D_type_list *)((void *)0);
#line 944
    link ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 947
  pp_return->v = (Violation_list *)((void *)0);
#line 948
  return (pp_return);
}
}
#line 951 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
Violation_list *issue_violation(Violation_list *v , char *string ) 
{ 
  Violation_list *v1 ;
  void *tmp ;

  {
  {
  {
#line 953
  tmp = xalloc((int )sizeof(Violation_list ));
  }
#line 953
  v1 = (Violation_list *)tmp;
#line 954
  v1->string = string;
#line 955
  v1->next = v;
  }
#line 956
  return (v1);
}
}
#line 969 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/post-process.c"
PP_node *post_process(void) 
{ 
  Violation_list *v ;
  PP_node *pp_return ;
  PP_node *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  int tmp___64 ;
  int tmp___65 ;
  int tmp___66 ;
  int tmp___67 ;
  int tmp___68 ;
  int tmp___69 ;
  int tmp___70 ;
  int tmp___71 ;
  int tmp___72 ;
  int tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  int tmp___76 ;
  int tmp___77 ;
  int tmp___78 ;
  int tmp___79 ;
  int tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;
  char *__cil_tmp122 ;
  char *__cil_tmp123 ;
  char *__cil_tmp124 ;
  char *__cil_tmp125 ;
  char *__cil_tmp126 ;
  char *__cil_tmp127 ;
  char *__cil_tmp128 ;
  char *__cil_tmp129 ;
  char *__cil_tmp130 ;
  char *__cil_tmp131 ;
  char *__cil_tmp132 ;
  char *__cil_tmp133 ;
  char *__cil_tmp134 ;
  char *__cil_tmp135 ;
  char *__cil_tmp136 ;
  char *__cil_tmp137 ;
  char *__cil_tmp138 ;
  char *__cil_tmp139 ;
  char *__cil_tmp140 ;
  char *__cil_tmp141 ;
  char *__cil_tmp142 ;
  char *__cil_tmp143 ;
  char *__cil_tmp144 ;
  char *__cil_tmp145 ;
  char *__cil_tmp146 ;
  char *__cil_tmp147 ;
  char *__cil_tmp148 ;
  char *__cil_tmp149 ;
  char *__cil_tmp150 ;
  char *__cil_tmp151 ;
  char *__cil_tmp152 ;
  char *__cil_tmp153 ;
  char *__cil_tmp154 ;
  char *__cil_tmp155 ;
  char *__cil_tmp156 ;
  char *__cil_tmp157 ;
  char *__cil_tmp158 ;
  char *__cil_tmp159 ;
  char *__cil_tmp160 ;
  char *__cil_tmp161 ;
  char *__cil_tmp162 ;
  char *__cil_tmp163 ;
  char *__cil_tmp164 ;
  char *__cil_tmp165 ;
  char *__cil_tmp166 ;
  char *__cil_tmp167 ;
  char *__cil_tmp168 ;
  char *__cil_tmp169 ;
  char *__cil_tmp170 ;
  char *__cil_tmp171 ;
  char *__cil_tmp172 ;
  char *__cil_tmp173 ;
  char *__cil_tmp174 ;
  char *__cil_tmp175 ;
  char *__cil_tmp176 ;
  char *__cil_tmp177 ;
  char *__cil_tmp178 ;
  char *__cil_tmp179 ;
  char *__cil_tmp180 ;
  char *__cil_tmp181 ;
  char *__cil_tmp182 ;
  char *__cil_tmp183 ;
  char *__cil_tmp184 ;
  char *__cil_tmp185 ;
  char *__cil_tmp186 ;
  char *__cil_tmp187 ;
  char *__cil_tmp188 ;
  char *__cil_tmp189 ;
  char *__cil_tmp190 ;
  char *__cil_tmp191 ;
  char *__cil_tmp192 ;
  char *__cil_tmp193 ;
  char *__cil_tmp194 ;
  char *__cil_tmp195 ;
  char *__cil_tmp196 ;
  char *__cil_tmp197 ;
  char *__cil_tmp198 ;
  char *__cil_tmp199 ;
  char *__cil_tmp200 ;
  char *__cil_tmp201 ;
  char *__cil_tmp202 ;
  char *__cil_tmp203 ;
  char *__cil_tmp204 ;
  char *__cil_tmp205 ;
  char *__cil_tmp206 ;
  char *__cil_tmp207 ;
  char *__cil_tmp208 ;
  char *__cil_tmp209 ;
  char *__cil_tmp210 ;
  char *__cil_tmp211 ;
  char *__cil_tmp212 ;
  char *__cil_tmp213 ;
  char *__cil_tmp214 ;
  char *__cil_tmp215 ;
  char *__cil_tmp216 ;
  char *__cil_tmp217 ;
  char *__cil_tmp218 ;
  char *__cil_tmp219 ;
  char *__cil_tmp220 ;
  char *__cil_tmp221 ;
  char *__cil_tmp222 ;
  char *__cil_tmp223 ;
  char *__cil_tmp224 ;
  char *__cil_tmp225 ;
  char *__cil_tmp226 ;
  char *__cil_tmp227 ;
  char *__cil_tmp228 ;
  char *__cil_tmp229 ;
  char *__cil_tmp230 ;
  char *__cil_tmp231 ;
  char *__cil_tmp232 ;
  char *__cil_tmp233 ;
  char *__cil_tmp234 ;
  char *__cil_tmp235 ;
  char *__cil_tmp236 ;
  char *__cil_tmp237 ;
  char *__cil_tmp238 ;
  char *__cil_tmp239 ;
  char *__cil_tmp240 ;
  char *__cil_tmp241 ;
  char *__cil_tmp242 ;
  char *__cil_tmp243 ;
  char *__cil_tmp244 ;
  char *__cil_tmp245 ;
  char *__cil_tmp246 ;
  char *__cil_tmp247 ;
  char *__cil_tmp248 ;
  char *__cil_tmp249 ;

  {
#line 982
  if (! postprocess_defined) {
    {
    {
#line 982
    tmp = bogus_pp_node();
    }
    }
#line 982
    return (tmp);
  }
  {
  {
#line 983
  tmp___0 = xalloc((int )sizeof(PP_node ));
  }
#line 983
  pp_return = (PP_node *)tmp___0;
  {
#line 984
  build_graph();
  }
  {
#line 985
  build_domains();
  }
  {
#line 986
  build_domain_forest();
  }
#line 987
  v = (Violation_list *)((void *)0);
  {
#line 995
  tmp___1 = is_connected_without(must_be_connected_without);
  }
  }
#line 995
  if (! tmp___1) {
    {
    {
#line 995
    v = issue_violation(v, (char *)"Connectivity violation");
    }
    }
#line 995
    goto done_checking;
  }
  {
  {
#line 998
  tmp___2 = is_connected();
  }
  }
#line 998
  if (! tmp___2) {
    {
    {
#line 998
    v = issue_violation(v, (char *)"Connectivity violation");
    }
    }
#line 998
    goto done_checking;
  }
  {
  {
#line 1000
  tmp___3 = domain_bounded('s');
  }
  }
#line 1000
  if (! tmp___3) {
    {
    {
#line 1000
    v = issue_violation(v, (char *)"Unbounded s domain");
    }
    }
#line 1000
    goto done_checking;
  }
  {
  {
#line 1001
  tmp___4 = domain_bounded('r');
  }
  }
#line 1001
  if (! tmp___4) {
    {
    {
#line 1001
    v = issue_violation(v, (char *)"Unbounded r domain");
    }
    }
#line 1001
    goto done_checking;
  }
  {
  {
#line 1003
  tmp___5 = contains_one((char *)"SI#*", Nec_for_Inv);
  }
  }
#line 1003
  if (! tmp___5) {
    {
    {
#line 1003
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1003
    goto done_checking;
  }
  {
  {
#line 1004
  tmp___6 = contains_one((char *)"SI#i", Nec_for_Inv);
  }
  }
#line 1004
  if (! tmp___6) {
    {
    {
#line 1004
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1004
    goto done_checking;
  }
  {
  {
#line 1005
  tmp___7 = contains_one((char *)"SI#x", Nec_for_Inv);
  }
  }
#line 1005
  if (! tmp___7) {
    {
    {
#line 1005
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1005
    goto done_checking;
  }
  {
  {
#line 1006
  tmp___8 = contains_one((char *)"SFI##*", Nec_for_Inv);
  }
  }
#line 1006
  if (! tmp___8) {
    {
    {
#line 1006
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1006
    goto done_checking;
  }
  {
  {
#line 1008
  tmp___9 = contains_none((char *)"Ws", Incompat_with_Ws);
  }
  }
#line 1008
  if (! tmp___9) {
    {
    {
#line 1008
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1008
    goto done_checking;
  }
  {
  {
#line 1009
  tmp___10 = contains_one((char *)"Ws", Nec_for_Ws_2);
  }
  }
#line 1009
  if (! tmp___10) {
    {
    {
#line 1009
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1009
    goto done_checking;
  }
  {
  {
#line 1011
  tmp___11 = contains_one((char *)"I#a", Nec_for_Ia);
  }
  }
#line 1011
  if (! tmp___11) {
    {
    {
#line 1011
    v = issue_violation(v, (char *)"incorrect use of \'to\'");
    }
    }
#line 1011
    goto done_checking;
  }
  {
  {
#line 1013
  tmp___12 = contains_one((char *)"Wq", Nec_for_Wq);
  }
  }
#line 1013
  if (! tmp___12) {
    {
    {
#line 1013
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1013
    goto done_checking;
  }
  {
  {
#line 1014
  tmp___13 = contains_one((char *)"Qd", Nec_for_Wq);
  }
  }
#line 1014
  if (! tmp___13) {
    {
    {
#line 1014
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1014
    goto done_checking;
  }
  {
  {
#line 1015
  tmp___14 = contains_one((char *)"PFc", Nec_for_Wq);
  }
  }
#line 1015
  if (! tmp___14) {
    {
    {
#line 1015
    v = issue_violation(v, (char *)"question inversion violated");
    }
    }
#line 1015
    goto done_checking;
  }
  {
  {
#line 1017
  tmp___15 = contains_one((char *)"Mj", Nec_for_j);
  }
  }
#line 1017
  if (! tmp___15) {
    {
    {
#line 1017
    v = issue_violation(v, (char *)"misuse of question word");
    }
    }
#line 1017
    goto done_checking;
  }
  {
  {
#line 1018
  tmp___16 = contains_one((char *)"MX#j", Nec_for_j);
  }
  }
#line 1018
  if (! tmp___16) {
    {
    {
#line 1018
    v = issue_violation(v, (char *)"misuse of question word");
    }
    }
#line 1018
    goto done_checking;
  }
  {
  {
#line 1019
  tmp___17 = contains_one((char *)"Wj", Nec_for_j);
  }
  }
#line 1019
  if (! tmp___17) {
    {
    {
#line 1019
    v = issue_violation(v, (char *)"misuse of question word");
    }
    }
#line 1019
    goto done_checking;
  }
  {
  {
#line 1020
  tmp___18 = contains_one((char *)"JQ", Mj_or_Wj);
  }
  }
#line 1020
  if (! tmp___18) {
    {
    {
#line 1020
    v = issue_violation(v, (char *)"misuse of preposition");
    }
    }
#line 1020
    goto done_checking;
  }
  {
  {
#line 1021
  tmp___19 = contains_one((char *)"Jw", Mj_or_Wj);
  }
  }
#line 1021
  if (! tmp___19) {
    {
    {
#line 1021
    v = issue_violation(v, (char *)"misuse of preposition");
    }
    }
#line 1021
    goto done_checking;
  }
  {
  {
#line 1023
  tmp___20 = contains_one((char *)"B#j", Jr);
  }
  }
#line 1023
  if (! tmp___20) {
    {
    {
#line 1023
    v = issue_violation(v, (char *)"A B*j must have a Jr");
    }
    }
#line 1023
    goto done_checking;
  }
  {
  {
#line 1024
  tmp___21 = contains_one((char *)"Jr", Nec_for_Jr);
  }
  }
#line 1024
  if (! tmp___21) {
    {
    {
#line 1024
    v = issue_violation(v, (char *)"A Jr must have an B*j");
    }
    }
#line 1024
    goto done_checking;
  }
  {
  {
#line 1026
  tmp___22 = contains_one((char *)"EAh", Nec_for_EAh);
  }
  }
#line 1026
  if (! tmp___22) {
    {
    {
#line 1026
    v = issue_violation(v, (char *)"Incorrect use of \'how\'");
    }
    }
#line 1026
    goto done_checking;
  }
  {
  {
#line 1028
  tmp___23 = contains_one((char *)"EEh", Nec_for_EAh);
  }
  }
#line 1028
  if (! tmp___23) {
    {
    {
#line 1028
    v = issue_violation(v, (char *)"Incorrect use of \'how\'");
    }
    }
#line 1028
    goto done_checking;
  }
  {
  {
#line 1030
  tmp___24 = contains_one((char *)"Qe", Nec_for_Qe);
  }
  }
#line 1030
  if (! tmp___24) {
    {
    {
#line 1030
    v = issue_violation(v, (char *)"Incorrect use of adverb");
    }
    }
#line 1030
    goto done_checking;
  }
  {
  {
#line 1032
  tmp___25 = contains_one((char *)"THi", SFiSFIi);
  }
  }
#line 1032
  if (! tmp___25) {
    {
    {
#line 1032
    v = issue_violation(v, (char *)"THi rule 1 violated");
    }
    }
#line 1032
    goto done_checking;
  }
  {
  {
#line 1033
  tmp___26 = contains_one((char *)"TSi", SFiSFIi);
  }
  }
#line 1033
  if (! tmp___26) {
    {
    {
#line 1033
    v = issue_violation(v, (char *)"TSi rule 1 violated");
    }
    }
#line 1033
    goto done_checking;
  }
  {
  {
#line 1034
  tmp___27 = contains_one((char *)"QIi", SFiSFIi);
  }
  }
#line 1034
  if (! tmp___27) {
    {
    {
#line 1034
    v = issue_violation(v, (char *)"QIi rule 1 violated");
    }
    }
#line 1034
    goto done_checking;
  }
  {
  {
#line 1035
  tmp___28 = contains_one((char *)"TOi", SFiSFIi);
  }
  }
#line 1035
  if (! tmp___28) {
    {
    {
#line 1035
    v = issue_violation(v, (char *)"TV rule 1 violated");
    }
    }
#line 1035
    goto done_checking;
  }
  {
  {
#line 1036
  tmp___29 = contains_one((char *)"Ci", SFiSFIi);
  }
  }
#line 1036
  if (! tmp___29) {
    {
    {
#line 1036
    v = issue_violation(v, (char *)"Ci rule 1 violated");
    }
    }
#line 1036
    goto done_checking;
  }
  {
  {
#line 1037
  tmp___30 = contains_one((char *)"COqi", SFiSFIi);
  }
  }
#line 1037
  if (! tmp___30) {
    {
    {
#line 1037
    v = issue_violation(v, (char *)"It rules violated");
    }
    }
#line 1037
    goto done_checking;
  }
  {
  {
#line 1038
  tmp___31 = contains_one((char *)"CPi", SFiSFIi);
  }
  }
#line 1038
  if (! tmp___31) {
    {
    {
#line 1038
    v = issue_violation(v, (char *)"It rules violated");
    }
    }
#line 1038
    goto done_checking;
  }
  {
  {
#line 1039
  tmp___32 = contains_one((char *)"Eqi", SFiSFIi);
  }
  }
#line 1039
  if (! tmp___32) {
    {
    {
#line 1039
    v = issue_violation(v, (char *)"It rules violated");
    }
    }
#line 1039
    goto done_checking;
  }
  {
  {
#line 1040
  tmp___33 = contains_one((char *)"LEi", SFiSFIi);
  }
  }
#line 1040
  if (! tmp___33) {
    {
    {
#line 1040
    v = issue_violation(v, (char *)"THi rule 1 violated");
    }
    }
#line 1040
    goto done_checking;
  }
  {
  {
#line 1041
  tmp___34 = contains_one((char *)"MVti", SFiSFIi);
  }
  }
#line 1041
  if (! tmp___34) {
    {
    {
#line 1041
    v = issue_violation(v, (char *)"THi rule 1 violated");
    }
    }
#line 1041
    goto done_checking;
  }
  {
  {
#line 1042
  tmp___35 = contains_one((char *)"AFdi", SFiSFIi);
  }
  }
#line 1042
  if (! tmp___35) {
    {
    {
#line 1042
    v = issue_violation(v, (char *)"THi rule 1 violated");
    }
    }
#line 1042
    goto done_checking;
  }
  {
  {
#line 1043
  tmp___36 = contains_one((char *)"O#i", SFiSFIi);
  }
  }
#line 1043
  if (! tmp___36) {
    {
    {
#line 1043
    v = issue_violation(v, (char *)"O#i rule 1 violated");
    }
    }
#line 1043
    goto done_checking;
  }
  {
  {
#line 1045
  tmp___37 = contains_none((char *)"SF", incompat_with_THi);
  }
  }
#line 1045
  if (! tmp___37) {
    {
    {
#line 1045
    v = issue_violation(v, (char *)"There rule 1 violated");
    }
    }
#line 1045
    goto done_checking;
  }
  {
  {
#line 1046
  tmp___38 = contains_none((char *)"SFI", incompat_with_THi);
  }
  }
#line 1046
  if (! tmp___38) {
    {
    {
#line 1046
    v = issue_violation(v, (char *)"There rule 1 violated");
    }
    }
#line 1046
    goto done_checking;
  }
  {
  {
#line 1047
  tmp___39 = contains_none((char *)"OX", incompat_with_THi);
  }
  }
#line 1047
  if (! tmp___39) {
    {
    {
#line 1047
    v = issue_violation(v, (char *)"OXt rule 1 violated");
    }
    }
#line 1047
    goto done_checking;
  }
  {
  {
#line 1049
  tmp___40 = contains_one((char *)"SFst", Ost);
  }
  }
#line 1049
  if (! tmp___40) {
    {
    {
#line 1049
    v = issue_violation(v, (char *)"There rule 2 violated");
    }
    }
#line 1049
    goto done_checking;
  }
  {
  {
#line 1050
  tmp___41 = contains_one((char *)"SFIst", Ost);
  }
  }
#line 1050
  if (! tmp___41) {
    {
    {
#line 1050
    v = issue_violation(v, (char *)"There rule 2 violated");
    }
    }
#line 1050
    goto done_checking;
  }
  {
  {
#line 1051
  tmp___42 = contains_one((char *)"SFp", Opt);
  }
  }
#line 1051
  if (! tmp___42) {
    {
    {
#line 1051
    v = issue_violation(v, (char *)"There rule 2 violated");
    }
    }
#line 1051
    goto done_checking;
  }
  {
  {
#line 1052
  tmp___43 = contains_one((char *)"SFIp", Opt);
  }
  }
#line 1052
  if (! tmp___43) {
    {
    {
#line 1052
    v = issue_violation(v, (char *)"There rule 2 violated");
    }
    }
#line 1052
    goto done_checking;
  }
  {
  {
#line 1053
  tmp___44 = contains_one((char *)"OXt", Oxt);
  }
  }
#line 1053
  if (! tmp___44) {
    {
    {
#line 1053
    v = issue_violation(v, (char *)"There rule 2 violated");
    }
    }
#line 1053
    goto done_checking;
  }
  {
  {
#line 1054
  tmp___45 = contains_one((char *)"SFsi*", Necessary_for_SF);
  }
  }
#line 1054
  if (! tmp___45) {
    {
    {
#line 1054
    v = issue_violation(v, (char *)"It rule violated");
    }
    }
#line 1054
    goto done_checking;
  }
  {
  {
#line 1055
  tmp___46 = contains_one((char *)"SFIsi", Necessary_for_SF);
  }
  }
#line 1055
  if (! tmp___46) {
    {
    {
#line 1055
    v = issue_violation(v, (char *)"It rule violated");
    }
    }
#line 1055
    goto done_checking;
  }
  {
  {
#line 1057
  tmp___47 = contains_one((char *)"THb", Nec_for_THb);
  }
  }
#line 1057
  if (! tmp___47) {
    {
    {
#line 1057
    v = issue_violation(v, (char *)"be-that rule violated");
    }
    }
#line 1057
    goto done_checking;
  }
  {
  {
#line 1058
  tmp___48 = contains_one((char *)"BIh", Nec_for_BIh);
  }
  }
#line 1058
  if (! tmp___48) {
    {
    {
#line 1058
    v = issue_violation(v, (char *)"be-complement rule violated");
    }
    }
#line 1058
    goto done_checking;
  }
  {
  {
#line 1059
  tmp___49 = contains_one((char *)"BIq", Nec_for_BIq);
  }
  }
#line 1059
  if (! tmp___49) {
    {
    {
#line 1059
    v = issue_violation(v, (char *)"be-complement rule violated");
    }
    }
#line 1059
    goto done_checking;
  }
  {
  {
#line 1060
  tmp___50 = contains_one((char *)"OXi", Necessary_for_SF);
  }
  }
#line 1060
  if (! tmp___50) {
    {
    {
#line 1060
    v = issue_violation(v, (char *)"SF rule violated");
    }
    }
#line 1060
    goto done_checking;
  }
  {
  {
#line 1062
  tmp___51 = contains_one((char *)"MVt", Necessary_for_MVt);
  }
  }
#line 1062
  if (! tmp___51) {
    {
    {
#line 1062
    v = issue_violation(v, (char *)"Than rule violated");
    }
    }
#line 1062
    goto done_checking;
  }
  {
  {
#line 1063
  tmp___52 = contains_one((char *)"MVz", Nec_for_MVz);
  }
  }
#line 1063
  if (! tmp___52) {
    {
    {
#line 1063
    v = issue_violation(v, (char *)"As rule violated");
    }
    }
#line 1063
    goto done_checking;
  }
  {
  {
#line 1065
  tmp___53 = contains_one((char *)"MV#a", Nec_for_MVta);
  }
  }
#line 1065
  if (! tmp___53) {
    {
    {
#line 1065
    v = issue_violation(v, (char *)"bad use of comparative");
    }
    }
#line 1065
    goto done_checking;
  }
  {
  {
#line 1066
  tmp___54 = contains_one((char *)"MV#i", Nec_for_MVta);
  }
  }
#line 1066
  if (! tmp___54) {
    {
    {
#line 1066
    v = issue_violation(v, (char *)"bad use of comparative");
    }
    }
#line 1066
    goto done_checking;
  }
  {
  {
#line 1067
  tmp___55 = contains_one((char *)"MV#o", Nec_for_MVto);
  }
  }
#line 1067
  if (! tmp___55) {
    {
    {
#line 1067
    v = issue_violation(v, (char *)"bad use of comparative");
    }
    }
#line 1067
    goto done_checking;
  }
  {
  {
#line 1068
  tmp___56 = contains_one((char *)"MV#p", Nec_for_MVtp);
  }
  }
#line 1068
  if (! tmp___56) {
    {
    {
#line 1068
    v = issue_violation(v, (char *)"bad use of comparative");
    }
    }
#line 1068
    goto done_checking;
  }
  {
  {
#line 1070
  tmp___57 = contains_one((char *)"Pafc", EBmm);
  }
  }
#line 1070
  if (! tmp___57) {
    {
    {
#line 1070
    v = issue_violation(v, (char *)"Than-adj 1 violated");
    }
    }
#line 1070
    goto done_checking;
  }
  {
  {
#line 1071
  tmp___58 = contains_one((char *)"Pafc", Pa_or_Paf);
  }
  }
#line 1071
  if (! tmp___58) {
    {
    {
#line 1071
    v = issue_violation(v, (char *)"Than-adj 2 violated");
    }
    }
#line 1071
    goto done_checking;
  }
  {
  {
#line 1072
  tmp___59 = contains_one((char *)"MVat", MVm);
  }
  }
#line 1072
  if (! tmp___59) {
    {
    {
#line 1072
    v = issue_violation(v, (char *)"Than-adv 1 violated");
    }
    }
#line 1072
    goto done_checking;
  }
  {
  {
#line 1073
  tmp___60 = contains_one((char *)"MVpt", MVm);
  }
  }
#line 1073
  if (! tmp___60) {
    {
    {
#line 1073
    v = issue_violation(v, (char *)"Than-prep 1 violated");
    }
    }
#line 1073
    goto done_checking;
  }
  {
  {
#line 1074
  tmp___61 = contains_one((char *)"MVat", MV);
  }
  }
#line 1074
  if (! tmp___61) {
    {
    {
#line 1074
    v = issue_violation(v, (char *)"Than-adv 2 violated");
    }
    }
#line 1074
    goto done_checking;
  }
  {
  {
#line 1075
  tmp___62 = contains_one((char *)"MVpt", MV);
  }
  }
#line 1075
  if (! tmp___62) {
    {
    {
#line 1075
    v = issue_violation(v, (char *)"Than-prep 2 violated");
    }
    }
#line 1075
    goto done_checking;
  }
  {
  {
#line 1077
  tmp___63 = contains_one((char *)"U#t", Nec_for_MVto);
  }
  }
#line 1077
  if (! tmp___63) {
    {
    {
#line 1077
    v = issue_violation(v, (char *)"Than-obj 2 violated");
    }
    }
#line 1077
    goto done_checking;
  }
  {
  {
#line 1079
  tmp___64 = contains_one((char *)"Cc", Nec_for_Cc);
  }
  }
#line 1079
  if (! tmp___64) {
    {
    {
#line 1079
    v = issue_violation(v, (char *)"Cc violated");
    }
    }
#line 1079
    goto done_checking;
  }
  {
  {
#line 1081
  tmp___65 = contains_one((char *)"Mc", Nec_for_Mc);
  }
  }
#line 1081
  if (! tmp___65) {
    {
    {
#line 1081
    v = issue_violation(v, (char *)"Mc violated");
    }
    }
#line 1081
    goto done_checking;
  }
  {
  {
#line 1082
  tmp___66 = contains_one((char *)"Sp#c", Nec_for_Sp_com);
  }
  }
#line 1082
  if (! tmp___66) {
    {
    {
#line 1082
    v = issue_violation(v, (char *)"Sp_com violated");
    }
    }
#line 1082
    goto done_checking;
  }
  {
  {
#line 1083
  tmp___67 = contains_one((char *)"Ss#c", Nec_for_Ss_com);
  }
  }
#line 1083
  if (! tmp___67) {
    {
    {
#line 1083
    v = issue_violation(v, (char *)"Ss_com violated");
    }
    }
#line 1083
    goto done_checking;
  }
  {
  {
#line 1084
  tmp___68 = contains_one((char *)"S*ic", Nec_for_Ss_com);
  }
  }
#line 1084
  if (! tmp___68) {
    {
    {
#line 1084
    v = issue_violation(v, (char *)"Ss_com violated");
    }
    }
#line 1084
    goto done_checking;
  }
  {
  {
#line 1085
  tmp___69 = contains_one((char *)"S##c", Nec_for_S_com);
  }
  }
#line 1085
  if (! tmp___69) {
    {
    {
#line 1085
    v = issue_violation(v, (char *)"S_com violated");
    }
    }
#line 1085
    goto done_checking;
  }
  {
  {
#line 1086
  tmp___70 = contains_one((char *)"THc", Necessary_for_Thcom);
  }
  }
#line 1086
  if (! tmp___70) {
    {
    {
#line 1086
    v = issue_violation(v, (char *)"That-comparative rule violated");
    }
    }
#line 1086
    goto done_checking;
  }
  {
  {
#line 1087
  tmp___71 = contains_one((char *)"TOfc", Necessary_for_Tocom);
  }
  }
#line 1087
  if (! tmp___71) {
    {
    {
#line 1087
    v = issue_violation(v, (char *)"To-comparative rule violated");
    }
    }
#line 1087
    goto done_checking;
  }
  {
  {
#line 1088
  tmp___72 = contains_one((char *)"TOic", Necessary_for_Tvcom);
  }
  }
#line 1088
  if (! tmp___72) {
    {
    {
#line 1088
    v = issue_violation(v, (char *)"To-comparative rule violated");
    }
    }
#line 1088
    goto done_checking;
  }
  {
  {
#line 1089
  tmp___73 = contains_one((char *)"TOtc", Necessary_for_Tvcom_Trans);
  }
  }
#line 1089
  if (! tmp___73) {
    {
    {
#line 1089
    v = issue_violation(v, (char *)"To-comparative rule violated");
    }
    }
#line 1089
    goto done_checking;
  }
  {
  {
#line 1091
  tmp___74 = contains_one((char *)"Ma*", Nec_for_Ma);
  }
  }
#line 1091
  if (! tmp___74) {
    {
    {
#line 1091
    v = issue_violation(v, (char *)"bad use of adjective");
    }
    }
#line 1091
    goto done_checking;
  }
  {
  {
#line 1092
  tmp___75 = contains_one((char *)"Mam", Nec_for_Ma);
  }
  }
#line 1092
  if (! tmp___75) {
    {
    {
#line 1092
    v = issue_violation(v, (char *)"bad use of adjective");
    }
    }
#line 1092
    goto done_checking;
  }
  {
  {
#line 1093
  tmp___76 = contains_one((char *)"MX#a", Nec_for_Ma);
  }
  }
#line 1093
  if (! tmp___76) {
    {
    {
#line 1093
    v = issue_violation(v, (char *)"bad use of adjective");
    }
    }
#line 1093
    goto done_checking;
  }
  {
  {
#line 1094
  tmp___77 = contains_one((char *)"Ixd", ZZ);
  }
  }
#line 1094
  if (! tmp___77) {
    {
    {
#line 1094
    v = issue_violation(v, (char *)"Can\'t use \"do\" with that verb");
    }
    }
#line 1094
    goto done_checking;
  }
  {
  {
#line 1095
  tmp___78 = contains_one((char *)"Oxn", ZZ);
  }
  }
#line 1095
  if (! tmp___78) {
    {
    {
#line 1095
    v = issue_violation(v, (char *)"Can\'t use a tag word after a pronoun");
    }
    }
#line 1095
    goto done_checking;
  }
  {
  {
#line 1103
  tmp___79 = contains_none((char *)"S", illegal_S_types);
  }
  }
#line 1103
  if (! tmp___79) {
    {
    {
#line 1103
    v = issue_violation(v, (char *)"bad n-v agreement");
    }
    }
#line 1103
    goto done_checking;
  }
  {
  {
#line 1104
  tmp___80 = contains_none((char *)"SI", illegal_SI_types);
  }
  }
#line 1104
  if (! tmp___80) {
    {
    {
#line 1104
    v = issue_violation(v, (char *)"bad n-v agreement");
    }
    }
#line 1104
    goto done_checking;
  }
  {
  {
#line 1107
  tmp___81 = contains_one((char *)"MVh", Nec_for_MVh);
  }
  }
#line 1107
  if (! tmp___81) {
    {
    {
#line 1107
    v = issue_violation(v, (char *)"Incorrect use of that");
    }
    }
#line 1107
    goto done_checking;
  }
  {
  {
#line 1109
  tmp___82 = contains_none((char *)"MXsr", Incompat_with_MXsr);
  }
  }
#line 1109
  if (! tmp___82) {
    {
    {
#line 1109
    v = issue_violation(v, (char *)"Bad n-v agreement");
    }
    }
#line 1109
    goto done_checking;
  }
  {
  {
#line 1110
  tmp___83 = contains_none((char *)"MXpr", Incompat_with_MXpr);
  }
  }
#line 1110
  if (! tmp___83) {
    {
    {
#line 1110
    v = issue_violation(v, (char *)"Bad n-v agreement");
    }
    }
#line 1110
    goto done_checking;
  }
  done_checking: 
  {
  {
#line 1114
  pp_return->d_type_array = build_type_array();
  }
#line 1115
  pp_return->v = v;
  {
#line 1116
  free_post_processing_structures();
  }
  }
#line 1117
  return (pp_return);
}
}
#line 341 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int mark_cost ;
#line 342
int N_in_table ;
#line 343
int N_hash_lookups ;
#line 344
int work_in_hash_lookups ;
#line 385
int table_lookup(int lw , int rw , Connector *le , Connector *re , int cost ) ;
#line 392
int count(int lw , int rw , Connector *le , Connector *re , int cost ) ;
#line 402
void init_table(void) ;
#line 403
void free_table(void) ;
#line 430
void init_fast_matcher(void) ;
#line 431
void free_fast_matcher(void) ;
#line 433
Match_node *form_match_list(int w , Connector *lc , int lw , Connector *rc , int rw ) ;
#line 434
void put_match_list(Match_node *m ) ;
#line 448
int parse(int cost ) ;
#line 464
void conjunction_prune(void) ;
#line 56 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
int match(Connector *a , Connector *b ) 
{ 
  char *s ;
  char *t ;
  int x ;
  int y ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 71
  if ((int )a->label != (int )b->label) {
#line 71
    return (0);
  }
#line 72
  x = (int )a->priority;
#line 73
  y = (int )b->priority;
#line 75
  s = a->string;
#line 76
  t = b->string;
  {
  {
#line 78
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 78
    tmp = __ctype_b_loc();
    }
    }
#line 78
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
      {
      {
#line 78
      tmp___0 = __ctype_b_loc();
      }
      }
#line 78
      if (! ((int const   )*(*tmp___0 + (int )*t) & 256)) {
#line 78
        goto while_break;
      }
    }
#line 79
    if ((int )*s != (int )*t) {
#line 79
      return (0);
    }
#line 80
    s ++;
#line 81
    t ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  if (x == 0) {
#line 84
    if (y == 0) {
      {
      {
#line 91
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 91
        if ((int )*s != 0) {
#line 91
          if (! ((int )*t != 0)) {
#line 91
            goto while_break___0;
          }
        } else {
#line 91
          goto while_break___0;
        }
#line 92
        if ((int )*s == 42) {
#line 94
          s ++;
#line 95
          t ++;
        } else
#line 92
        if ((int )*t == 42) {
#line 94
          s ++;
#line 95
          t ++;
        } else
#line 92
        if ((int )*s == (int )*t) {
#line 92
          if ((int )*s != 94) {
#line 94
            s ++;
#line 95
            t ++;
          } else {
#line 96
            return (0);
          }
        } else {
#line 96
          return (0);
        }
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 98
      return (1);
    } else {
#line 84
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 99
  if (x == 1) {
#line 99
    if (y == 2) {
      {
      {
#line 111
      while (1) {
        while_continue___5: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 111
        if ((int )*s != 0) {
#line 111
          if (! ((int )*t != 0)) {
#line 111
            goto while_break___1;
          }
        } else {
#line 111
          goto while_break___1;
        }
#line 112
        if ((int )*s == (int )*t) {
#line 113
          s ++;
#line 114
          t ++;
        } else
#line 112
        if ((int )*s == 42) {
#line 113
          s ++;
#line 114
          t ++;
        } else
#line 112
        if ((int )*t == 94) {
#line 113
          s ++;
#line 114
          t ++;
        } else {
#line 115
          return (0);
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 117
      return (1);
    } else {
#line 99
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 118
  if (y == 1) {
#line 118
    if (x == 2) {
      {
      {
#line 119
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 119
        if ((int )*s != 0) {
#line 119
          if (! ((int )*t != 0)) {
#line 119
            goto while_break___2;
          }
        } else {
#line 119
          goto while_break___2;
        }
#line 120
        if ((int )*s == (int )*t) {
#line 121
          s ++;
#line 122
          t ++;
        } else
#line 120
        if ((int )*t == 42) {
#line 121
          s ++;
#line 122
          t ++;
        } else
#line 120
        if ((int )*s == 94) {
#line 121
          s ++;
#line 122
          t ++;
        } else {
#line 123
          return (0);
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 125
      return (1);
    } else {
#line 126
      return (0);
    }
  } else {
#line 126
    return (0);
  }
}
}
#line 138 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
static int table_size  ;
#line 139 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
static Table_connector **table___0  ;
#line 141 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
void init_table(void) 
{ 
  int i ;
  void *tmp ;

  {
#line 146
  if (N_words >= 10) {
#line 147
    table_size = 1 << 16;
  } else
#line 150
  if (N_words >= 4) {
#line 151
    table_size = 1 << ((6 * (N_words - 4)) / 6 + 4);
  } else {
#line 153
    table_size = 1 << 4;
  }
  {
  {
#line 155
  tmp = xalloc((int )((unsigned long )table_size * sizeof(Table_connector *)));
  }
#line 155
  table___0 = (Table_connector **)tmp;
#line 156
  i = 0;
  }
  {
  {
#line 156
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 156
    if (! (i < table_size)) {
#line 156
      goto while_break;
    }
#line 157
    *(table___0 + i) = (Table_connector *)((void *)0);
#line 156
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 159
  return;
}
}
#line 161 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
int hash(int lw , int rw , Connector *le , Connector *re , int cost ) 
{ 
  int i ;

  {
#line 163
  i = 0;
#line 165
  i = (int )((unsigned int )(i + (i << 1)) + randtable[(lw + i) & 255]);
#line 166
  i = (int )((unsigned int )(i + (i << 1)) + randtable[(rw + i) & 255]);
#line 167
  i = (int )((unsigned int )(i + (i << 1)) + randtable[((long )le + (long )i) % (long )(table_size + 1) & 255L]);
#line 168
  i = (int )((unsigned int )(i + (i << 1)) + randtable[((long )re + (long )i) % (long )(table_size + 1) & 255L]);
#line 169
  i = (int )((unsigned int )(i + (i << 1)) + randtable[(cost + i) & 255]);
#line 170
  return (i & (table_size - 1));
}
}
#line 173 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
void free_table(void) 
{ 
  int i ;
  Table_connector *t ;
  Table_connector *x ;

  {
#line 177
  i = 0;
  {
  {
#line 177
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < table_size)) {
#line 177
      goto while_break;
    }
#line 178
    t = *(table___0 + i);
    {
    {
#line 178
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 178
      if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 178
        goto while_break___0;
      }
      {
#line 179
      x = t->next;
      {
#line 180
      xfree((char *)((void *)t), (int )sizeof(Table_connector ));
      }
#line 178
      t = x;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 177
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 183
  xfree((char *)((void *)table___0), (int )((unsigned long )table_size * sizeof(Table_connector *)));
  }
  }
#line 184
  return;
}
}
#line 186 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
Table_connector *table_pointer(int lw , int rw , Connector *le , Connector *re , int cost ) 
{ 
  Table_connector *t ;
  int tmp ;

  {
  {
#line 189
  N_hash_lookups ++;
#line 190
  work_in_hash_lookups ++;
  {
#line 191
  tmp = hash(lw, rw, le, re, cost);
  }
#line 191
  t = *(table___0 + tmp);
  }
  {
  {
#line 192
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 192
    if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 192
      goto while_break;
    }
#line 193
    work_in_hash_lookups ++;
#line 194
    if ((int )t->lw == lw) {
#line 194
      if ((int )t->rw == rw) {
#line 194
        if ((unsigned long )t->le == (unsigned long )le) {
#line 194
          if ((unsigned long )t->re == (unsigned long )re) {
#line 194
            if ((int )t->cost == cost) {
#line 194
              return (t);
            }
          }
        }
      }
    }
#line 192
    t = t->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return ((Table_connector *)((void *)0));
}
}
#line 199 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
int table_lookup(int lw , int rw , Connector *le , Connector *re , int cost ) 
{ 
  Table_connector *t ;
  Table_connector *tmp ;

  {
  {
  {
#line 201
  tmp = table_pointer(lw, rw, le, re, cost);
  }
#line 201
  t = tmp;
  }
#line 203
  if ((unsigned long )t == (unsigned long )((void *)0)) {
#line 203
    return (-1);
  } else {
#line 203
    return (t->count);
  }
}
}
#line 206 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
Table_connector *table_store(int lw , int rw , Connector *le , Connector *re , int cost ,
                             int count___0 ) 
{ 
  Table_connector *t ;
  Table_connector *n ;
  int h ;
  void *tmp ;

  {
  {
#line 210
  N_in_table ++;
  {
#line 212
  tmp = xalloc((int )sizeof(Table_connector ));
  }
#line 212
  n = (Table_connector *)tmp;
#line 213
  n->count = count___0;
#line 214
  n->lw = (short )lw;
#line 214
  n->rw = (short )rw;
#line 214
  n->le = le;
#line 214
  n->re = re;
#line 214
  n->cost = (short )cost;
  {
#line 215
  h = hash(lw, rw, le, re, cost);
  }
#line 216
  t = *(table___0 + h);
#line 217
  n->next = t;
#line 218
  *(table___0 + h) = n;
  }
#line 219
  return (n);
}
}
#line 222 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
void table_update(int lw , int rw , Connector *le , Connector *re , int cost , int count___0 ) 
{ 
  Table_connector *t ;
  Table_connector *tmp ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 224
  tmp = table_pointer(lw, rw, le, re, cost);
  }
#line 224
  t = tmp;
  }
#line 226
  if (! ((unsigned long )t != (unsigned long )((void *)0))) {
    {
    {
#line 226
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "This entry is supposed to be in the table.");
    }
    {
#line 226
    exit(1);
    }
    }
  }
#line 227
  t->count = count___0;
#line 228
  return;
}
}
#line 231 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
int pseudocount(int lw , int rw , Connector *le , Connector *re , int cost ) 
{ 
  int count___0 ;

  {
  {
  {
#line 234
  count___0 = table_lookup(lw, rw, le, re, cost);
  }
  }
#line 235
  if (count___0 == 0) {
#line 235
    return (0);
  } else {
#line 235
    return (1);
  }
}
}
#line 238 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
int count(int lw , int rw , Connector *le , Connector *re , int cost ) 
{ 
  Disjunct *d ;
  int total ;
  int pseudototal ;
  int start_word ;
  int end_word ;
  int w ;
  int leftcount ;
  int rightcount ;
  int lcost ;
  int rcost ;
  int Lmatch ;
  int Rmatch ;
  Match_node *m ;
  Match_node *m1 ;
  Table_connector *t ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 248
  if (cost < 0) {
#line 248
    return (0);
  }
  {
  {
#line 250
  t = table_pointer(lw, rw, le, re, cost);
  }
  }
#line 252
  if ((unsigned long )t == (unsigned long )((void *)0)) {
    {
    {
#line 253
    t = table_store(lw, rw, le, re, cost, 0);
    }
    }
  } else {
#line 256
    return (t->count);
  }
#line 259
  if (rw == 1 + lw) {
#line 262
    if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 262
      if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 262
        if (cost == 0) {
#line 263
          t->count = 1;
        } else {
#line 265
          t->count = 0;
        }
      } else {
#line 265
        t->count = 0;
      }
    } else {
#line 265
      t->count = 0;
    }
#line 267
    return (t->count);
  }
#line 270
  if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 270
    if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 275
      if (cost == (rw - lw) - 1) {
#line 276
        t->count = 1;
      } else {
#line 278
        t->count = 0;
      }
#line 280
      return (t->count);
    }
  }
#line 302
  if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 303
    start_word = lw + 1;
  } else {
#line 305
    start_word = (int )le->word;
  }
#line 308
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 309
    if (rw - 1 < lw + maxlinklength) {
#line 309
      end_word = rw - 1;
    } else {
#line 309
      end_word = lw + maxlinklength;
    }
  } else {
#line 311
    end_word = (int )re->word;
  }
#line 314
  total = 0;
#line 316
  w = start_word;
  {
  {
#line 316
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 316
    if (! (w <= end_word)) {
#line 316
      goto while_break;
    }
    {
    {
#line 317
    m = form_match_list(w, le, lw, re, rw);
    }
#line 317
    m1 = m;
    }
    {
    {
#line 318
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 318
      if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 318
        goto while_break___0;
      }
#line 319
      d = m->d;
#line 320
      lcost = 0;
      {
      {
#line 320
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 320
        if (! (lcost <= cost)) {
#line 320
          goto while_break___1;
        }
#line 321
        rcost = cost - lcost;
#line 328
        if ((unsigned long )le != (unsigned long )((void *)0)) {
#line 328
          if ((unsigned long )d->left != (unsigned long )((void *)0)) {
            {
            {
#line 328
            tmp = match(le, d->left);
            }
            }
#line 328
            if (tmp) {
#line 328
              tmp___0 = 1;
            } else {
#line 328
              tmp___0 = 0;
            }
          } else {
#line 328
            tmp___0 = 0;
          }
        } else {
#line 328
          tmp___0 = 0;
        }
#line 328
        Lmatch = tmp___0;
#line 329
        if ((unsigned long )d->right != (unsigned long )((void *)0)) {
#line 329
          if ((unsigned long )re != (unsigned long )((void *)0)) {
            {
            {
#line 329
            tmp___1 = match(d->right, re);
            }
            }
#line 329
            if (tmp___1) {
#line 329
              tmp___2 = 1;
            } else {
#line 329
              tmp___2 = 0;
            }
          } else {
#line 329
            tmp___2 = 0;
          }
        } else {
#line 329
          tmp___2 = 0;
        }
#line 329
        Rmatch = tmp___2;
#line 331
        leftcount = 0;
#line 331
        rightcount = leftcount;
#line 332
        if (Lmatch) {
          {
          {
#line 333
          leftcount = pseudocount(lw, w, le->next, (d->left)->next, lcost);
          }
          }
#line 334
          if (le->multi) {
            {
            {
#line 334
            tmp___3 = pseudocount(lw, w, le, (d->left)->next, lcost);
            }
#line 334
            leftcount += tmp___3;
            }
          }
#line 335
          if ((d->left)->multi) {
            {
            {
#line 335
            tmp___4 = pseudocount(lw, w, le->next, d->left, lcost);
            }
#line 335
            leftcount += tmp___4;
            }
          }
#line 336
          if (le->multi) {
#line 336
            if ((d->left)->multi) {
              {
              {
#line 336
              tmp___5 = pseudocount(lw, w, le, d->left, lcost);
              }
#line 336
              leftcount += tmp___5;
              }
            }
          }
        }
#line 339
        if (Rmatch) {
          {
          {
#line 340
          rightcount = pseudocount(w, rw, (d->right)->next, re->next, rcost);
          }
          }
#line 341
          if ((d->right)->multi) {
            {
            {
#line 341
            tmp___6 = pseudocount(w, rw, d->right, re->next, rcost);
            }
#line 341
            rightcount += tmp___6;
            }
          }
#line 342
          if (re->multi) {
            {
            {
#line 342
            tmp___7 = pseudocount(w, rw, (d->right)->next, re, rcost);
            }
#line 342
            rightcount += tmp___7;
            }
          }
#line 343
          if ((d->right)->multi) {
#line 343
            if (re->multi) {
              {
              {
#line 343
              tmp___8 = pseudocount(w, rw, d->right, re, rcost);
              }
#line 343
              rightcount += tmp___8;
              }
            }
          }
        }
#line 346
        pseudototal = leftcount * rightcount;
#line 348
        if (leftcount > 0) {
          {
          {
#line 350
          tmp___9 = pseudocount(w, rw, d->right, re, rcost);
          }
#line 350
          pseudototal += leftcount * tmp___9;
          }
        }
#line 352
        if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 352
          if (rightcount > 0) {
            {
            {
#line 354
            tmp___10 = pseudocount(lw, w, le, d->left, lcost);
            }
#line 354
            pseudototal += rightcount * tmp___10;
            }
          }
        }
#line 358
        if (pseudototal != 0) {
#line 359
          leftcount = 0;
#line 359
          rightcount = leftcount;
#line 360
          if (Lmatch) {
            {
            {
#line 361
            leftcount = count(lw, w, le->next, (d->left)->next, lcost);
            }
            }
#line 362
            if (le->multi) {
              {
              {
#line 362
              tmp___11 = count(lw, w, le, (d->left)->next, lcost);
              }
#line 362
              leftcount += tmp___11;
              }
            }
#line 363
            if ((d->left)->multi) {
              {
              {
#line 363
              tmp___12 = count(lw, w, le->next, d->left, lcost);
              }
#line 363
              leftcount += tmp___12;
              }
            }
#line 364
            if (le->multi) {
#line 364
              if ((d->left)->multi) {
                {
                {
#line 364
                tmp___13 = count(lw, w, le, d->left, lcost);
                }
#line 364
                leftcount += tmp___13;
                }
              }
            }
          }
#line 367
          if (Rmatch) {
            {
            {
#line 368
            rightcount = count(w, rw, (d->right)->next, re->next, rcost);
            }
            }
#line 369
            if ((d->right)->multi) {
              {
              {
#line 369
              tmp___14 = count(w, rw, d->right, re->next, rcost);
              }
#line 369
              rightcount += tmp___14;
              }
            }
#line 370
            if (re->multi) {
              {
              {
#line 370
              tmp___15 = count(w, rw, (d->right)->next, re, rcost);
              }
#line 370
              rightcount += tmp___15;
              }
            }
#line 371
            if ((d->right)->multi) {
#line 371
              if (re->multi) {
                {
                {
#line 371
                tmp___16 = count(w, rw, d->right, re, rcost);
                }
#line 371
                rightcount += tmp___16;
                }
              }
            }
          }
#line 374
          total += leftcount * rightcount;
#line 376
          if (leftcount > 0) {
            {
            {
#line 378
            tmp___17 = count(w, rw, d->right, re, rcost);
            }
#line 378
            total += leftcount * tmp___17;
            }
          }
#line 380
          if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 380
            if (rightcount > 0) {
              {
              {
#line 382
              tmp___18 = count(lw, w, le, d->left, lcost);
              }
#line 382
              total += rightcount * tmp___18;
              }
            }
          }
        }
#line 320
        lcost ++;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 318
      m = m->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 388
    put_match_list(m1);
    }
#line 316
    w ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  t->count = total;
#line 391
  return (total);
}
}
#line 422 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
int parse(int cost ) 
{ 
  Disjunct *dis ;
  int total ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp6 ;

  {
#line 428
  total = 0;
#line 430
  dis = sentence[0].d;
  {
  {
#line 430
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 430
    if (! ((unsigned long )dis != (unsigned long )((void *)0))) {
#line 430
      goto while_break;
    }
#line 431
    if ((unsigned long )dis->left == (unsigned long )((void *)0)) {
      {
      {
#line 432
      tmp = count(0, N_words, dis->right, (Connector *)((void *)0), cost);
      }
#line 432
      total += tmp;
      }
    }
#line 430
    dis = dis->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 437
  tmp___0 = count(0, N_words, (Connector *)((void *)0), (Connector *)((void *)0),
                  cost);
  }
#line 437
  total += tmp___0;
  }
#line 439
  if (verbosity > 1) {
    {
    {
#line 440
    printf((char const   */* __restrict  */)"Total count with cost %d:   %d\n", cost,
           total);
    }
    }
  }
#line 442
  return (total);
}
}
#line 477 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
int region_valid(int lw , int rw , Connector *le , Connector *re ) 
{ 
  Disjunct *d ;
  int left_valid ;
  int right_valid ;
  int found ;
  int i ;
  int start_word ;
  int end_word ;
  int w ;
  Match_node *m ;
  Match_node *m1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
  {
#line 488
  i = table_lookup(lw, rw, le, re, 0);
  }
  }
#line 489
  if (i >= 0) {
#line 489
    return (i);
  }
#line 491
  if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 491
    if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 491
      if (*(deletable[lw] + rw)) {
        {
        {
#line 492
        table_store(lw, rw, le, re, 0, 1);
        }
        }
#line 493
        return (1);
      }
    }
  }
#line 496
  if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 497
    start_word = lw + 1;
  } else {
#line 499
    start_word = (int )le->word;
  }
#line 501
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 502
    if (rw - 1 < lw + maxlinklength) {
#line 502
      end_word = rw - 1;
    } else {
#line 502
      end_word = lw + maxlinklength;
    }
  } else {
#line 504
    end_word = (int )re->word;
  }
#line 507
  found = 0;
#line 509
  w = start_word;
  {
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 509
    if (! (w <= end_word)) {
#line 509
      goto while_break;
    }
    {
    {
#line 510
    m = form_match_list(w, le, lw, re, rw);
    }
#line 510
    m1 = m;
    }
    {
    {
#line 511
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 511
      if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 511
        goto while_break___0;
      }
#line 512
      d = m->d;
#line 513
      mark_cost ++;
#line 516
      if ((unsigned long )le != (unsigned long )((void *)0)) {
#line 516
        if ((unsigned long )d->left != (unsigned long )((void *)0)) {
          {
          {
#line 516
          tmp = prune_match(le, d->left);
          }
          }
#line 516
          if (tmp) {
            {
            {
#line 516
            tmp___0 = region_valid(lw, w, le->next, (d->left)->next);
            }
            }
#line 516
            if (tmp___0) {
#line 516
              tmp___4 = 1;
            } else
#line 516
            if (le->multi) {
              {
              {
#line 516
              tmp___1 = region_valid(lw, w, le, (d->left)->next);
              }
              }
#line 516
              if (tmp___1) {
#line 516
                tmp___4 = 1;
              } else {
#line 516
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 516
            if ((d->left)->multi) {
              {
              {
#line 516
              tmp___2 = region_valid(lw, w, le->next, d->left);
              }
              }
#line 516
              if (tmp___2) {
#line 516
                tmp___4 = 1;
              } else {
#line 516
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 516
            if (le->multi) {
#line 516
              if ((d->left)->multi) {
                {
                {
#line 516
                tmp___3 = region_valid(lw, w, le, d->left);
                }
                }
#line 516
                if (tmp___3) {
#line 516
                  tmp___4 = 1;
                } else {
#line 516
                  tmp___4 = 0;
                }
              } else {
#line 516
                tmp___4 = 0;
              }
            } else {
#line 516
              tmp___4 = 0;
            }
          } else {
#line 516
            tmp___4 = 0;
          }
        } else {
#line 516
          tmp___4 = 0;
        }
      } else {
#line 516
        tmp___4 = 0;
      }
#line 516
      left_valid = tmp___4;
#line 521
      if (left_valid) {
        {
        {
#line 521
        tmp___5 = region_valid(w, rw, d->right, re);
        }
        }
#line 521
        if (tmp___5) {
#line 522
          found = 1;
#line 523
          goto while_break___0;
        }
      }
#line 525
      if ((unsigned long )d->right != (unsigned long )((void *)0)) {
#line 525
        if ((unsigned long )re != (unsigned long )((void *)0)) {
          {
          {
#line 525
          tmp___6 = prune_match(d->right, re);
          }
          }
#line 525
          if (tmp___6) {
            {
            {
#line 525
            tmp___7 = region_valid(w, rw, (d->right)->next, re->next);
            }
            }
#line 525
            if (tmp___7) {
#line 525
              tmp___11 = 1;
            } else
#line 525
            if ((d->right)->multi) {
              {
              {
#line 525
              tmp___8 = region_valid(w, rw, d->right, re->next);
              }
              }
#line 525
              if (tmp___8) {
#line 525
                tmp___11 = 1;
              } else {
#line 525
                goto _L___2;
              }
            } else
            _L___2: /* CIL Label */ 
#line 525
            if (re->multi) {
              {
              {
#line 525
              tmp___9 = region_valid(w, rw, (d->right)->next, re);
              }
              }
#line 525
              if (tmp___9) {
#line 525
                tmp___11 = 1;
              } else {
#line 525
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 525
            if ((d->right)->multi) {
#line 525
              if (re->multi) {
                {
                {
#line 525
                tmp___10 = region_valid(w, rw, d->right, re);
                }
                }
#line 525
                if (tmp___10) {
#line 525
                  tmp___11 = 1;
                } else {
#line 525
                  tmp___11 = 0;
                }
              } else {
#line 525
                tmp___11 = 0;
              }
            } else {
#line 525
              tmp___11 = 0;
            }
          } else {
#line 525
            tmp___11 = 0;
          }
        } else {
#line 525
          tmp___11 = 0;
        }
      } else {
#line 525
        tmp___11 = 0;
      }
#line 525
      right_valid = tmp___11;
#line 530
      if (left_valid) {
#line 530
        if (right_valid) {
#line 531
          found = 1;
#line 532
          goto while_break___0;
        } else {
#line 530
          goto _L___3;
        }
      } else
      _L___3: /* CIL Label */ 
#line 530
      if (right_valid) {
        {
        {
#line 530
        tmp___12 = region_valid(lw, w, le, d->left);
        }
        }
#line 530
        if (tmp___12) {
#line 531
          found = 1;
#line 532
          goto while_break___0;
        }
      }
#line 511
      m = m->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 535
    put_match_list(m1);
    }
    }
#line 536
    if (found != 0) {
#line 536
      goto while_break;
    }
#line 509
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 538
  table_store(lw, rw, le, re, 0, found);
  }
  }
#line 539
  return (found);
}
}
#line 542 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
void mark_region(int lw , int rw , Connector *le , Connector *re ) 
{ 
  Disjunct *d ;
  int left_valid ;
  int right_valid ;
  int i ;
  int start_word ;
  int end_word ;
  int w ;
  Match_node *m ;
  Match_node *m1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
  {
#line 554
  i = region_valid(lw, rw, le, re);
  }
  }
#line 555
  if (i == 0) {
#line 555
    return;
  } else
#line 555
  if (i == 2) {
#line 555
    return;
  }
  {
  {
#line 557
  table_update(lw, rw, le, re, 0, 2);
  }
  }
#line 559
  if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 559
    if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 559
      if (null_links) {
#line 559
        if (rw != 1 + lw) {
#line 560
          w = lw + 1;
#line 561
          d = sentence[w].d;
          {
          {
#line 561
          while (1) {
            while_continue___2: /* CIL Label */ ;
            while_continue: /* CIL Label */ ;
#line 561
            if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 561
              goto while_break;
            }
#line 562
            if ((unsigned long )d->left == (unsigned long )((void *)0)) {
              {
              {
#line 562
              tmp = region_valid(w, rw, d->right, (Connector *)((void *)0));
              }
              }
#line 562
              if (tmp) {
                {
#line 563
                d->marked = (char)1;
                {
#line 564
                mark_region(w, rw, d->right, (Connector *)((void *)0));
                }
                }
              }
            }
#line 561
            d = d->next;
          }
          while_break___2: /* CIL Label */ ;
          }
          while_break: /* CIL Label */ ;
          }
          {
          {
#line 567
          mark_region(w, rw, (Connector *)((void *)0), (Connector *)((void *)0));
          }
          }
#line 568
          return;
        }
      }
    }
  }
#line 571
  if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 572
    start_word = lw + 1;
  } else {
#line 574
    start_word = (int )le->word;
  }
#line 576
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 577
    if (rw - 1 < lw + maxlinklength) {
#line 577
      end_word = rw - 1;
    } else {
#line 577
      end_word = lw + maxlinklength;
    }
  } else {
#line 579
    end_word = (int )re->word;
  }
#line 582
  w = start_word;
  {
  {
#line 582
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 582
    if (! (w <= end_word)) {
#line 582
      goto while_break___0;
    }
    {
    {
#line 583
    m = form_match_list(w, le, lw, re, rw);
    }
#line 583
    m1 = m;
    }
    {
    {
#line 584
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 584
      if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 584
        goto while_break___1;
      }
#line 585
      d = m->d;
#line 586
      mark_cost ++;
#line 587
      if ((unsigned long )le != (unsigned long )((void *)0)) {
#line 587
        if ((unsigned long )d->left != (unsigned long )((void *)0)) {
          {
          {
#line 587
          tmp___0 = prune_match(le, d->left);
          }
          }
#line 587
          if (tmp___0) {
            {
            {
#line 587
            tmp___1 = region_valid(lw, w, le->next, (d->left)->next);
            }
            }
#line 587
            if (tmp___1) {
#line 587
              tmp___5 = 1;
            } else
#line 587
            if (le->multi) {
              {
              {
#line 587
              tmp___2 = region_valid(lw, w, le, (d->left)->next);
              }
              }
#line 587
              if (tmp___2) {
#line 587
                tmp___5 = 1;
              } else {
#line 587
                goto _L___0;
              }
            } else
            _L___0: /* CIL Label */ 
#line 587
            if ((d->left)->multi) {
              {
              {
#line 587
              tmp___3 = region_valid(lw, w, le->next, d->left);
              }
              }
#line 587
              if (tmp___3) {
#line 587
                tmp___5 = 1;
              } else {
#line 587
                goto _L;
              }
            } else
            _L: /* CIL Label */ 
#line 587
            if (le->multi) {
#line 587
              if ((d->left)->multi) {
                {
                {
#line 587
                tmp___4 = region_valid(lw, w, le, d->left);
                }
                }
#line 587
                if (tmp___4) {
#line 587
                  tmp___5 = 1;
                } else {
#line 587
                  tmp___5 = 0;
                }
              } else {
#line 587
                tmp___5 = 0;
              }
            } else {
#line 587
              tmp___5 = 0;
            }
          } else {
#line 587
            tmp___5 = 0;
          }
        } else {
#line 587
          tmp___5 = 0;
        }
      } else {
#line 587
        tmp___5 = 0;
      }
#line 587
      left_valid = tmp___5;
#line 592
      if ((unsigned long )d->right != (unsigned long )((void *)0)) {
#line 592
        if ((unsigned long )re != (unsigned long )((void *)0)) {
          {
          {
#line 592
          tmp___6 = prune_match(d->right, re);
          }
          }
#line 592
          if (tmp___6) {
            {
            {
#line 592
            tmp___7 = region_valid(w, rw, (d->right)->next, re->next);
            }
            }
#line 592
            if (tmp___7) {
#line 592
              tmp___11 = 1;
            } else
#line 592
            if ((d->right)->multi) {
              {
              {
#line 592
              tmp___8 = region_valid(w, rw, d->right, re->next);
              }
              }
#line 592
              if (tmp___8) {
#line 592
                tmp___11 = 1;
              } else {
#line 592
                goto _L___2;
              }
            } else
            _L___2: /* CIL Label */ 
#line 592
            if (re->multi) {
              {
              {
#line 592
              tmp___9 = region_valid(w, rw, (d->right)->next, re);
              }
              }
#line 592
              if (tmp___9) {
#line 592
                tmp___11 = 1;
              } else {
#line 592
                goto _L___1;
              }
            } else
            _L___1: /* CIL Label */ 
#line 592
            if ((d->right)->multi) {
#line 592
              if (re->multi) {
                {
                {
#line 592
                tmp___10 = region_valid(w, rw, d->right, re);
                }
                }
#line 592
                if (tmp___10) {
#line 592
                  tmp___11 = 1;
                } else {
#line 592
                  tmp___11 = 0;
                }
              } else {
#line 592
                tmp___11 = 0;
              }
            } else {
#line 592
              tmp___11 = 0;
            }
          } else {
#line 592
            tmp___11 = 0;
          }
        } else {
#line 592
          tmp___11 = 0;
        }
      } else {
#line 592
        tmp___11 = 0;
      }
#line 592
      right_valid = tmp___11;
#line 602
      if (left_valid) {
        {
        {
#line 602
        tmp___12 = region_valid(w, rw, d->right, re);
        }
        }
#line 602
        if (tmp___12) {
          {
#line 603
          d->marked = (char)1;
          {
#line 604
          mark_region(w, rw, d->right, re);
          }
          {
#line 605
          mark_region(lw, w, le->next, (d->left)->next);
          }
          }
#line 606
          if (le->multi) {
            {
            {
#line 606
            mark_region(lw, w, le, (d->left)->next);
            }
            }
          }
#line 607
          if ((d->left)->multi) {
            {
            {
#line 607
            mark_region(lw, w, le->next, d->left);
            }
            }
          }
#line 608
          if (le->multi) {
#line 608
            if ((d->left)->multi) {
              {
              {
#line 608
              mark_region(lw, w, le, d->left);
              }
              }
            }
          }
        }
      }
#line 611
      if (right_valid) {
        {
        {
#line 611
        tmp___13 = region_valid(lw, w, le, d->left);
        }
        }
#line 611
        if (tmp___13) {
          {
#line 612
          d->marked = (char)1;
          {
#line 613
          mark_region(lw, w, le, d->left);
          }
          {
#line 614
          mark_region(w, rw, (d->right)->next, re->next);
          }
          }
#line 615
          if ((d->right)->multi) {
            {
            {
#line 615
            mark_region(w, rw, d->right, re->next);
            }
            }
          }
#line 616
          if (re->multi) {
            {
            {
#line 616
            mark_region(w, rw, (d->right)->next, re);
            }
            }
          }
#line 617
          if ((d->right)->multi) {
#line 617
            if (re->multi) {
              {
              {
#line 617
              mark_region(w, rw, d->right, re);
              }
              }
            }
          }
        }
      }
#line 620
      if (left_valid) {
#line 620
        if (right_valid) {
          {
#line 621
          d->marked = (char)1;
          {
#line 622
          mark_region(lw, w, le->next, (d->left)->next);
          }
          }
#line 623
          if (le->multi) {
            {
            {
#line 623
            mark_region(lw, w, le, (d->left)->next);
            }
            }
          }
#line 624
          if ((d->left)->multi) {
            {
            {
#line 624
            mark_region(lw, w, le->next, d->left);
            }
            }
          }
#line 625
          if (le->multi) {
#line 625
            if ((d->left)->multi) {
              {
              {
#line 625
              mark_region(lw, w, le, d->left);
              }
              }
            }
          }
          {
          {
#line 626
          mark_region(w, rw, (d->right)->next, re->next);
          }
          }
#line 627
          if ((d->right)->multi) {
            {
            {
#line 627
            mark_region(w, rw, d->right, re->next);
            }
            }
          }
#line 628
          if (re->multi) {
            {
            {
#line 628
            mark_region(w, rw, (d->right)->next, re);
            }
            }
          }
#line 629
          if ((d->right)->multi) {
#line 629
            if (re->multi) {
              {
              {
#line 629
              mark_region(w, rw, d->right, re);
              }
              }
            }
          }
        }
      }
#line 584
      m = m->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 632
    put_match_list(m1);
    }
#line 582
    w ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 634
  return;
}
}
#line 636 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/parse.c"
void conjunction_prune(void) 
{ 
  Disjunct *d ;
  Disjunct *d_head ;
  Disjunct *dx ;
  int w ;
  int tmp ;

  {
#line 656
  w = 0;
  {
  {
#line 656
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 656
    if (! (w < N_words)) {
#line 656
      goto while_break;
    }
#line 657
    d = sentence[w].d;
    {
    {
#line 657
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 657
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 657
        goto while_break___0;
      }
#line 658
      d->marked = (char)0;
#line 657
      d = d->next;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 656
    w ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 662
  init_fast_matcher();
  }
  {
#line 663
  init_table();
  }
#line 665
  d = sentence[0].d;
  }
  {
  {
#line 665
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 665
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 665
      goto while_break___1;
    }
#line 666
    if ((unsigned long )d->left == (unsigned long )((void *)0)) {
      {
      {
#line 666
      tmp = region_valid(0, N_words, d->right, (Connector *)((void *)0));
      }
      }
#line 666
      if (tmp) {
        {
        {
#line 667
        mark_region(0, N_words, d->right, (Connector *)((void *)0));
        }
#line 668
        d->marked = (char)1;
        }
      }
    }
#line 665
    d = d->next;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 672
  w = 0;
  {
  {
#line 672
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 672
    if (! (w < N_words)) {
#line 672
      goto while_break___2;
    }
#line 673
    d_head = (Disjunct *)((void *)0);
#line 674
    d = sentence[w].d;
    {
    {
#line 674
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 674
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 674
        goto while_break___3;
      }
#line 675
      dx = d->next;
#line 676
      if (d->marked) {
#line 677
        d->next = d_head;
#line 678
        d_head = d;
      } else {
        {
#line 680
        d->next = (Disjunct *)((void *)0);
        {
#line 681
        free_disjuncts(d);
        }
        }
      }
#line 674
      d = dx;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 684
    sentence[w].d = d_head;
#line 672
    w ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
  {
#line 687
  free_fast_matcher();
  }
  {
#line 688
  free_table();
  }
  }
#line 689
  return;
}
}
#line 355 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
char is_conjunction[250] ;
#line 440
void construct_comma(void) ;
#line 441
void construct_either(void) ;
#line 442
void construct_neither(void) ;
#line 443
void construct_notonlybut(void) ;
#line 444
void construct_both(void) ;
#line 447
int sentence_contains(char *s ) ;
#line 40 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
Disjunct *glom_comma_connector(Disjunct *d ) 
{ 
  Disjunct *d_list ;
  Disjunct *d1 ;
  Disjunct *d2 ;
  Connector *c ;
  Connector *c1 ;
  void *tmp ;
  Disjunct *tmp___0 ;
  char *__cil_tmp9 ;

  {
#line 46
  d_list = (Disjunct *)((void *)0);
#line 47
  d1 = d;
  {
  {
#line 47
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 47
      goto while_break;
    }
#line 48
    if ((unsigned long )d1->left == (unsigned long )((void *)0)) {
#line 48
      goto __Cont;
    }
#line 49
    c = d1->left;
    {
    {
#line 49
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 49
      if (! ((unsigned long )c->next != (unsigned long )((void *)0))) {
#line 49
        goto while_break___0;
      }
#line 49
      c = c->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 51
    if ((int )c->label < 0) {
#line 51
      goto __Cont;
    }
    {
    {
#line 53
    d2 = copy_disjunct(d1);
    }
#line 54
    d2->next = d_list;
#line 55
    d_list = d2;
    {
#line 57
    tmp = xalloc((int )sizeof(Connector ));
    }
#line 57
    c1 = (Connector *)tmp;
#line 58
    c1->string = (char *)"";
#line 59
    c1->label = (short)-2;
#line 60
    c1->priority = (char)0;
#line 61
    c1->multi = (char)0;
#line 62
    c1->next = (Connector *)((void *)0);
#line 64
    c->next = c1;
    }
    __Cont: /* CIL Label */ 
#line 47
    d1 = d1->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 66
  tmp___0 = catenate_disjuncts(d, d_list);
  }
  }
#line 66
  return (tmp___0);
}
}
#line 69 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
Disjunct *glom_aux_connector(Disjunct *d , int label , int necessary ) 
{ 
  Disjunct *d_list ;
  Disjunct *d1 ;
  Disjunct *d2 ;
  Connector *c ;
  Connector *c1 ;
  Connector *c2 ;
  void *tmp ;
  Disjunct *tmp___0 ;
  char *__cil_tmp12 ;

  {
#line 80
  d_list = (Disjunct *)((void *)0);
#line 81
  d1 = d;
  {
  {
#line 81
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 81
    if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 81
      goto while_break;
    }
#line 82
    if ((unsigned long )d1->left == (unsigned long )((void *)0)) {
#line 82
      goto __Cont;
    }
#line 83
    c = d1->left;
    {
    {
#line 83
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 83
      if (! ((unsigned long )c->next != (unsigned long )((void *)0))) {
#line 83
        goto while_break___0;
      }
#line 83
      c = c->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 85
    if ((int )c->label < 0) {
#line 85
      goto __Cont;
    }
#line 87
    if (! necessary) {
      {
      {
#line 88
      d2 = copy_disjunct(d1);
      }
#line 89
      d2->next = d_list;
#line 90
      d_list = d2;
      }
    }
    {
    {
#line 93
    tmp = xalloc((int )sizeof(Connector ));
    }
#line 93
    c1 = (Connector *)tmp;
#line 94
    c1->string = (char *)"";
#line 95
    c1->label = (short )label;
#line 96
    c1->priority = (char)0;
#line 97
    c1->multi = (char)0;
#line 98
    c1->next = c;
    }
#line 100
    if ((unsigned long )d1->left == (unsigned long )c) {
#line 101
      d1->left = c1;
    } else {
#line 103
      c2 = d1->left;
      {
      {
#line 103
      while (1) {
        while_continue___4: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 103
        if (! ((unsigned long )c2->next != (unsigned long )c)) {
#line 103
          goto while_break___1;
        }
#line 103
        c2 = c2->next;
      }
      while_break___4: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 105
      c2->next = c1;
    }
    __Cont: /* CIL Label */ 
#line 81
    d1 = d1->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 108
  tmp___0 = catenate_disjuncts(d, d_list);
  }
  }
#line 108
  return (tmp___0);
}
}
#line 111 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
Disjunct *add_one_connector(int label , int dir , char *cs , Disjunct *d ) 
{ 
  Connector *c ;
  void *tmp ;

  {
  {
  {
#line 118
  tmp = xalloc((int )sizeof(Connector ));
  }
#line 118
  c = (Connector *)tmp;
#line 119
  c->string = cs;
#line 120
  c->label = (short )label;
#line 121
  c->priority = (char)0;
#line 122
  c->multi = (char)0;
#line 123
  c->next = (Connector *)((void *)0);
  }
#line 125
  if (dir == 43) {
#line 126
    c->next = d->right;
#line 127
    d->right = c;
  } else {
#line 129
    c->next = d->left;
#line 130
    d->left = c;
  }
#line 132
  return (d);
}
}
#line 135 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
Disjunct *special_disjunct(int label , int dir , char *cs , char *ds ) 
{ 
  Disjunct *d1 ;
  Connector *c ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 144
  tmp = xalloc((int )sizeof(Disjunct ));
  }
#line 144
  d1 = (Disjunct *)tmp;
#line 145
  d1->cost = (short)0;
#line 146
  d1->string = ds;
#line 147
  d1->next = (Disjunct *)((void *)0);
  {
#line 149
  tmp___0 = xalloc((int )sizeof(Connector ));
  }
#line 149
  c = (Connector *)tmp___0;
#line 150
  c->string = cs;
#line 151
  c->label = (short )label;
#line 152
  c->priority = (char)0;
#line 153
  c->multi = (char)0;
#line 154
  c->next = (Connector *)((void *)0);
  }
#line 156
  if (dir == 43) {
#line 157
    d1->left = (Connector *)((void *)0);
#line 158
    d1->right = c;
  } else {
#line 160
    d1->right = (Connector *)((void *)0);
#line 161
    d1->left = c;
  }
#line 163
  return (d1);
}
}
#line 166 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
void construct_comma(void) 
{ 
  int w ;
  Disjunct *tmp ;
  int tmp___0 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 173
  w = 0;
  {
  {
#line 173
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 173
    if (! (w < N_words - 1)) {
#line 173
      goto while_break;
    }
    {
    {
#line 174
    tmp___0 = strcmp((char const   *)(sentence[w].string), ",");
    }
    }
#line 174
    if (tmp___0 == 0) {
#line 174
      if (is_conjunction[w + 1]) {
        {
        {
#line 176
        tmp = special_disjunct(-2, '+', (char *)"", (char *)",");
        }
        {
#line 176
        sentence[w].d = catenate_disjuncts(tmp, sentence[w].d);
        }
        {
#line 179
        sentence[w + 1].d = glom_comma_connector(sentence[w + 1].d);
        }
        }
      }
    }
#line 173
    w ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 182
  return;
}
}
#line 188 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
void construct_either(void) 
{ 
  int w ;
  int tmp ;
  int tmp___0 ;
  Disjunct *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 190
  tmp = sentence_contains((char *)"either");
  }
  }
#line 190
  if (! tmp) {
#line 190
    return;
  }
#line 191
  w = 0;
  {
  {
#line 191
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 191
    if (! (w < N_words)) {
#line 191
      goto while_break;
    }
    {
    {
#line 192
    tmp___0 = strcmp((char const   *)(sentence[w].string), "either");
    }
    }
#line 192
    if (tmp___0 != 0) {
#line 192
      goto __Cont;
    }
    {
    {
#line 193
    tmp___1 = special_disjunct(-3, '+', (char *)"", (char *)"either");
    }
    {
#line 193
    sentence[w].d = catenate_disjuncts(tmp___1, sentence[w].d);
    }
    }
    __Cont: /* CIL Label */ 
#line 191
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  w = 0;
  {
  {
#line 198
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 198
    if (! (w < N_words)) {
#line 198
      goto while_break___0;
    }
    {
    {
#line 199
    tmp___2 = strcmp((char const   *)(sentence[w].string), "or");
    }
    }
#line 199
    if (tmp___2 != 0) {
#line 199
      goto __Cont___0;
    }
    {
    {
#line 200
    sentence[w].d = glom_aux_connector(sentence[w].d, -3, 0);
    }
    }
    __Cont___0: /* CIL Label */ 
#line 198
    w ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 203
  return;
}
}
#line 205 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
void construct_neither(void) 
{ 
  int w ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  Disjunct *tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;

  {
  {
  {
#line 207
  tmp___0 = sentence_contains((char *)"neither");
  }
  }
#line 207
  if (! tmp___0) {
#line 208
    w = 0;
    {
    {
#line 208
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 208
      if (! (w < N_words)) {
#line 208
        goto while_break;
      }
      {
      {
#line 209
      tmp = strcmp((char const   *)(sentence[w].string), "nor");
      }
      }
#line 209
      if (tmp != 0) {
#line 209
        goto __Cont;
      }
      {
      {
#line 210
      free_disjuncts(sentence[w].d);
      }
#line 211
      sentence[w].d = (Disjunct *)((void *)0);
      }
      __Cont: /* CIL Label */ 
#line 208
      w ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 213
    return;
  }
#line 215
  w = 0;
  {
  {
#line 215
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (w < N_words)) {
#line 215
      goto while_break___0;
    }
    {
    {
#line 216
    tmp___1 = strcmp((char const   *)(sentence[w].string), "neither");
    }
    }
#line 216
    if (tmp___1 != 0) {
#line 216
      goto __Cont___0;
    }
    {
    {
#line 217
    tmp___2 = special_disjunct(-4, '+', (char *)"", (char *)"neither");
    }
    {
#line 217
    sentence[w].d = catenate_disjuncts(tmp___2, sentence[w].d);
    }
    }
    __Cont___0: /* CIL Label */ 
#line 215
    w ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 222
  w = 0;
  {
  {
#line 222
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 222
    if (! (w < N_words)) {
#line 222
      goto while_break___1;
    }
    {
    {
#line 223
    tmp___3 = strcmp((char const   *)(sentence[w].string), "nor");
    }
    }
#line 223
    if (tmp___3 != 0) {
#line 223
      goto __Cont___1;
    }
    {
    {
#line 224
    sentence[w].d = glom_aux_connector(sentence[w].d, -4, 1);
    }
    }
    __Cont___1: /* CIL Label */ 
#line 222
    w ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 227
  return;
}
}
#line 229 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
void construct_notonlybut(void) 
{ 
  int w ;
  Disjunct *d ;
  int tmp ;
  int tmp___0 ;
  Disjunct *tmp___1 ;
  Disjunct *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 232
  tmp = sentence_contains((char *)"not");
  }
  }
#line 232
  if (! tmp) {
#line 233
    return;
  }
#line 235
  w = 0;
  {
  {
#line 235
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 235
    if (! (w < N_words)) {
#line 235
      goto while_break;
    }
    {
    {
#line 236
    tmp___0 = strcmp((char const   *)(sentence[w].string), "not");
    }
    }
#line 236
    if (tmp___0 != 0) {
#line 236
      goto __Cont;
    }
    {
    {
#line 237
    tmp___1 = special_disjunct(-5, '+', (char *)"", (char *)"not");
    }
    {
#line 237
    sentence[w].d = catenate_disjuncts(tmp___1, sentence[w].d);
    }
    }
#line 240
    if (w < N_words - 1) {
      {
      {
#line 240
      tmp___3 = strcmp((char const   *)(sentence[w + 1].string), "only");
      }
      }
#line 240
      if (tmp___3 == 0) {
        {
        {
#line 241
        tmp___2 = special_disjunct(-6, '-', (char *)"", (char *)"only");
        }
        {
#line 241
        sentence[w + 1].d = catenate_disjuncts(tmp___2, sentence[w + 1].d);
        }
        {
#line 244
        d = special_disjunct(-6, '+', (char *)"", (char *)"not");
        }
        {
#line 245
        d = add_one_connector(-5, '+', (char *)"", d);
        }
        {
#line 246
        sentence[w].d = catenate_disjuncts(d, sentence[w].d);
        }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 235
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 249
  w = 0;
  {
  {
#line 249
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 249
    if (! (w < N_words)) {
#line 249
      goto while_break___0;
    }
    {
    {
#line 250
    tmp___4 = strcmp((char const   *)(sentence[w].string), "but");
    }
    }
#line 250
    if (tmp___4 != 0) {
#line 250
      goto __Cont___0;
    }
    {
    {
#line 251
    sentence[w].d = glom_aux_connector(sentence[w].d, -5, 1);
    }
    }
    __Cont___0: /* CIL Label */ 
#line 249
    w ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 257 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/massage.c"
void construct_both(void) 
{ 
  int w ;
  int tmp ;
  int tmp___0 ;
  Disjunct *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
  {
  {
#line 259
  tmp = sentence_contains((char *)"both");
  }
  }
#line 259
  if (! tmp) {
#line 259
    return;
  }
#line 260
  w = 0;
  {
  {
#line 260
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 260
    if (! (w < N_words)) {
#line 260
      goto while_break;
    }
    {
    {
#line 261
    tmp___0 = strcmp((char const   *)(sentence[w].string), "both");
    }
    }
#line 261
    if (tmp___0 != 0) {
#line 261
      goto __Cont;
    }
    {
    {
#line 262
    tmp___1 = special_disjunct(-7, '+', (char *)"", (char *)"both");
    }
    {
#line 262
    sentence[w].d = catenate_disjuncts(tmp___1, sentence[w].d);
    }
    }
    __Cont: /* CIL Label */ 
#line 260
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  w = 0;
  {
  {
#line 267
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 267
    if (! (w < N_words)) {
#line 267
      goto while_break___0;
    }
    {
    {
#line 268
    tmp___2 = strcmp((char const   *)(sentence[w].string), "and");
    }
    }
#line 268
    if (tmp___2 != 0) {
#line 268
      goto __Cont___0;
    }
    {
    {
#line 269
    sentence[w].d = glom_aux_connector(sentence[w].d, -7, 0);
    }
    }
    __Cont___0: /* CIL Label */ 
#line 267
    w ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 272
  return;
}
}
#line 142 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 401
extern int sscanf(char const   * __restrict  __s , char const   * __restrict  __format 
                  , ...) ;
#line 526
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 116 "/usr/include/ctype.h"
extern int tolower(int __c ) ;
#line 144 "/usr/include/stdlib.h"
extern int atoi(char const   *__nptr )  __attribute__((__pure__)) ;
#line 312 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
Word sentence[250]  ;
#line 314 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int N_words  ;
#line 315 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int left_wall_defined  ;
#line 316 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int right_wall_defined  ;
#line 317 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int postprocess_defined  ;
#line 318 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int andable_defined  ;
#line 319 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int unknown_word_defined  ;
#line 320 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int capitalized_word_defined  ;
#line 326
int display_on ;
#line 327
int display_links ;
#line 331
int display_bad ;
#line 332
int display_multiple ;
#line 333
int display_fat ;
#line 335
int echo_on ;
#line 336
int www_mode ;
#line 337
int just_one ;
#line 340 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int parse_cost  ;
#line 341 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int mark_cost  ;
#line 342 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int N_in_table  ;
#line 343 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int N_hash_lookups  ;
#line 344 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int work_in_hash_lookups  ;
#line 355 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
char is_conjunction[250]  ;
#line 356 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
char *deletable[250]  ;
#line 374
X_node *build_word_expressions(char *s ) ;
#line 375
int maxcost_of_sentence(void) ;
#line 376
void build_sentence_disjuncts(int cost_cutoff ) ;
#line 377
Disjunct *build_disjuncts_for_dict_node(Dict_node *dn ) ;
#line 389
void extract_links(int index___0 , int cost ) ;
#line 423
Disjunct *build_AND_disjunct_list(char *s ) ;
#line 424
void free_AND_tables(void) ;
#line 427
Disjunct *build_COMMA_disjunct_list(void) ;
#line 428
Disjunct *explode_disjunct_list(Disjunct *d ) ;
#line 429
void print_AND_statistics(void) ;
#line 436
void init_andable_hash_table(void) ;
#line 446
void build_conjunction_tables(void) ;
#line 456
Linkage_info analyze_fat_linkage(int should_print ) ;
#line 457
Linkage_info analyze_thin_linkage(int should_print ) ;
#line 460
int is_canonical_linkage(void) ;
#line 462
int set_has_fat_down(void) ;
#line 140 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int maxlinklength  =    250;
#line 141 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int null_link_search  =    1;
#line 142 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int use_unknown_word  =    1;
#line 143 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int verbosity  =    0;
#line 144 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int screen_width  =    79;
#line 145 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_short  =    1;
#line 146 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_on  =    1;
#line 147 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_links  =    0;
#line 148 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_bad  =    0;
#line 149 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_fat  =    0;
#line 150 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_multiple  =    1;
#line 151 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_postscript  =    0;
#line 152 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_word_subscripts  =    1;
#line 153 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_link_subscripts  =    1;
#line 155 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int display_walls  =    0;
#line 156 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int echo_on  =    0;
#line 157 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int www_mode  =    0;
#line 158 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int just_one  =    0;
#line 161 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int linkage_count_limit  =    5000;
#line 162 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int word_count_limit  =    250;
#line 164 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int null_links  =    1;
#line 175 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
double cumulative_time  ;
#line 177 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int issue_sentence_word(char *s ) 
{ 
  size_t tmp ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
#line 180
  if ((int )*s == 0) {
#line 180
    return (1);
  }
  {
  {
#line 181
  tmp = strlen((char const   *)s);
  }
  }
#line 181
  if (tmp >= 60U) {
    {
    {
#line 182
    printf((char const   */* __restrict  */)"The word \"%s\" is too long.\n", s);
    }
    {
#line 183
    printf((char const   */* __restrict  */)"A word can have a maximum of %d characters.\n",
           59);
    }
    }
#line 184
    return (0);
  }
#line 186
  if (N_words == 250) {
    {
    {
#line 187
    printf((char const   */* __restrict  */)"The sentence has too many words.\n");
    }
    }
#line 188
    return (0);
  }
  {
  {
#line 190
  strcpy((char */* __restrict  */)(sentence[N_words].string), (char const   */* __restrict  */)s);
  }
#line 191
  N_words ++;
  }
#line 192
  return (1);
}
}
#line 246 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
char *strip_left[3]  = {      (char *)"(",      (char *)"$",      (char *)((void *)0)};
#line 247 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
char *strip_right[11]  = 
#line 247
  {      (char *)")",      (char *)"%",      (char *)",",      (char *)".", 
        (char *)":",      (char *)";",      (char *)"?",      (char *)"!", 
        (char *)"\'",      (char *)"\'s",      (char *)((void *)0)};
#line 251 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int separate_word(char *w , char *wend , int is_first_word ) 
{ 
  int i ;
  int len ;
  int n_stripped ;
  int stripped[10] ;
  char word[61] ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  unsigned short const   **tmp___8 ;
  size_t tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *__cil_tmp23 ;
  void *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
  {
  {
#line 261
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 262
    i = 0;
    {
    {
#line 262
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 262
      if (! ((unsigned long )strip_left[i] != (unsigned long )((void *)0))) {
#line 262
        goto while_break___0;
      }
      {
      {
#line 263
      tmp___1 = strlen((char const   *)strip_left[i]);
      }
      {
#line 263
      tmp___2 = strncmp((char const   *)w, (char const   *)strip_left[i], tmp___1);
      }
      }
#line 263
      if (tmp___2 == 0) {
        {
        {
#line 264
        tmp = issue_sentence_word(strip_left[i]);
        }
        }
#line 264
        if (! tmp) {
#line 264
          return (0);
        }
        {
        {
#line 265
        tmp___0 = strlen((char const   *)strip_left[i]);
        }
#line 265
        w += tmp___0;
        }
#line 266
        goto while_break___0;
      }
#line 262
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 269
    if ((unsigned long )strip_left[i] == (unsigned long )((void *)0)) {
#line 269
      goto while_break;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  n_stripped = 0;
  {
  {
#line 272
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 272
    if (! (n_stripped < 10)) {
#line 272
      goto while_break___1;
    }
    {
    {
#line 273
    strncpy((char */* __restrict  */)(word), (char const   */* __restrict  */)w, (size_t )(wend - w));
    }
#line 274
    word[wend - w] = (char )'\000';
    }
#line 275
    if ((unsigned long )wend == (unsigned long )w) {
#line 275
      goto while_break___1;
    }
    {
    {
#line 277
    tmp___3 = boolean_dictionary_lookup(word);
    }
    }
#line 277
    if (tmp___3) {
#line 277
      goto while_break___1;
    }
#line 278
    if (is_first_word) {
      {
      {
#line 278
      tmp___8 = __ctype_b_loc();
      }
      }
#line 278
      if ((int const   )*(*tmp___8 + (int )word[0]) & 256) {
        {
        {
#line 279
        tmp___4 = tolower((int )word[0]);
        }
#line 279
        word[0] = (char )tmp___4;
        {
#line 280
        tmp___6 = boolean_dictionary_lookup(word);
        }
        }
#line 280
        if (tmp___6) {
          {
          {
#line 281
          tmp___5 = toupper((int )word[0]);
          }
#line 281
          word[0] = (char )tmp___5;
          }
#line 282
          goto while_break___1;
        }
        {
        {
#line 284
        tmp___7 = toupper((int )word[0]);
        }
#line 284
        word[0] = (char )tmp___7;
        }
      }
    }
#line 286
    i = 0;
    {
    {
#line 286
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 286
      if (! ((unsigned long )strip_right[i] != (unsigned long )((void *)0))) {
#line 286
        goto while_break___2;
      }
      {
      {
#line 287
      tmp___9 = strlen((char const   *)strip_right[i]);
      }
#line 287
      len = (int )tmp___9;
      }
#line 288
      if (wend - w < (long )len) {
#line 288
        goto __Cont;
      }
      {
      {
#line 289
      tmp___10 = strncmp((char const   *)(wend - len), (char const   *)strip_right[i],
                         (size_t )len);
      }
      }
#line 289
      if (tmp___10 == 0) {
#line 290
        stripped[n_stripped] = i;
#line 291
        wend -= len;
#line 292
        goto while_break___2;
      }
      __Cont: /* CIL Label */ 
#line 286
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 295
    if ((unsigned long )strip_right[i] == (unsigned long )((void *)0)) {
#line 295
      goto while_break___1;
    }
#line 272
    n_stripped ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 300
  if (n_stripped == 10) {
    {
    {
#line 301
    printf((char const   */* __restrict  */)"\"%s\" is followed by too many punctuation marks.\n",
           word);
    }
    }
#line 302
    return (0);
  }
  {
  {
#line 305
  tmp___11 = issue_sentence_word(word);
  }
  }
#line 305
  if (! tmp___11) {
#line 305
    return (0);
  }
#line 306
  i = n_stripped - 1;
  {
  {
#line 306
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 306
    if (! (i >= 0)) {
#line 306
      goto while_break___3;
    }
    {
    {
#line 307
    tmp___12 = issue_sentence_word(strip_right[stripped[i]]);
    }
    }
#line 307
    if (! tmp___12) {
#line 307
      return (0);
    }
#line 306
    i --;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 309
  return (1);
}
}
#line 312 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int separate_sentence(char *s ) 
{ 
  char *t ;
  int is_first ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 322
  N_words = 0;
#line 324
  if (left_wall_defined) {
    {
    {
#line 324
    tmp = issue_sentence_word((char *)"LEFT-WALL");
    }
    }
#line 324
    if (! tmp) {
#line 324
      return (0);
    }
  }
#line 326
  is_first = 1;
  {
  {
#line 327
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 328
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 328
      tmp___0 = __ctype_b_loc();
      }
      }
#line 328
      if (! ((int const   )*(*tmp___0 + (int )*s) & 8192)) {
#line 328
        if (! ((int )*s == 34)) {
#line 328
          goto while_break___0;
        }
      }
#line 328
      s ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 329
    if ((int )*s == 0) {
#line 329
      goto while_break;
    }
#line 330
    t = s;
    {
    {
#line 330
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
      {
      {
#line 330
      tmp___1 = __ctype_b_loc();
      }
      }
#line 330
      if ((int const   )*(*tmp___1 + (int )*t) & 8192) {
#line 330
        goto while_break___1;
      } else
#line 330
      if ((int )*t == 34) {
#line 330
        goto while_break___1;
      } else
#line 330
      if ((int )*t == 0) {
#line 330
        goto while_break___1;
      }
#line 330
      t ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 331
    tmp___2 = separate_word(s, t, is_first);
    }
    }
#line 331
    if (! tmp___2) {
#line 331
      return (0);
    }
#line 332
    is_first = 0;
#line 333
    s = t;
#line 334
    if ((int )*s == 0) {
#line 334
      goto while_break;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 337
  if (right_wall_defined) {
    {
    {
#line 337
    tmp___3 = issue_sentence_word((char *)"RIGHT-WALL");
    }
    }
#line 337
    if (! tmp___3) {
#line 337
      return (0);
    }
  }
#line 339
  return (N_words > left_wall_defined + right_wall_defined);
}
}
#line 343 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int isnumber(char *s ) 
{ 
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
  {
#line 344
  tmp = __ctype_b_loc();
  }
  }
#line 344
  if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 344
    return (0);
  }
  {
  {
#line 345
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 345
    if (! ((int )*s != 0)) {
#line 345
      goto while_break;
    }
    {
    {
#line 346
    tmp___0 = __ctype_b_loc();
    }
    }
#line 346
    if (! ((int const   )*(*tmp___0 + (int )*s) & 2048)) {
#line 346
      if ((int )*s != 46) {
#line 346
        if ((int )*s != 44) {
#line 347
          return (0);
        }
      }
    }
#line 345
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return (1);
}
}
#line 353 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int ishyphenated(char *s ) 
{ 
  int hyp ;
  int nonalpha ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
#line 359
  nonalpha = 0;
#line 359
  hyp = nonalpha;
#line 360
  if ((int )*s == 45) {
#line 360
    return (0);
  }
  {
  {
#line 361
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 361
    if (! ((int )*s != 0)) {
#line 361
      goto while_break;
    }
    {
    {
#line 362
    tmp = __ctype_b_loc();
    }
    }
#line 362
    if (! ((int const   )*(*tmp + (int )*s) & 1024)) {
      {
      {
#line 362
      tmp___0 = __ctype_b_loc();
      }
      }
#line 362
      if (! ((int const   )*(*tmp___0 + (int )*s) & 2048)) {
#line 362
        if ((int )*s != 46) {
#line 362
          if ((int )*s != 44) {
#line 362
            if ((int )*s != 45) {
#line 363
              return (0);
            }
          }
        }
      }
    }
#line 364
    if ((int )*s == 45) {
#line 364
      hyp ++;
    }
#line 365
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 367
  if ((int )*(s - 1) != 45) {
#line 367
    if (hyp > 0) {
#line 367
      tmp___1 = 1;
    } else {
#line 367
      tmp___1 = 0;
    }
  } else {
#line 367
    tmp___1 = 0;
  }
#line 367
  return (tmp___1);
}
}
#line 378 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void free_sentence_disjuncts(void) 
{ 
  int i ;

  {
#line 380
  i = 0;
  {
  {
#line 380
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 380
    if (! (i < N_words)) {
#line 380
      goto while_break;
    }
    {
    {
#line 381
    free_disjuncts(sentence[i].d);
    }
#line 380
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return;
}
}
#line 385 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void free_sentence_expressions(void) 
{ 
  int i ;

  {
#line 387
  i = 0;
  {
  {
#line 387
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 387
    if (! (i < N_words)) {
#line 387
      goto while_break;
    }
    {
    {
#line 388
    free_X_nodes(sentence[i].x);
    }
#line 387
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 390
  return;
}
}
#line 392 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int special_string(int i , char *s ) 
{ 
  X_node *e ;
  int tmp ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 394
  tmp = boolean_dictionary_lookup(s);
  }
  }
#line 394
  if (tmp) {
    {
    {
#line 395
    sentence[i].x = build_word_expressions(s);
    }
#line 396
    e = sentence[i].x;
    }
    {
    {
#line 396
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 396
      if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 396
        goto while_break;
      }
#line 397
      e->string = sentence[i].string;
#line 396
      e = e->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 399
    return (1);
  } else {
    {
    {
#line 401
    printf((char const   */* __restrict  */)"To process this sentence your dictionary ");
    }
    {
#line 402
    printf((char const   */* __restrict  */)"needs the word \"%s\".\n", s);
    }
    }
#line 403
    return (0);
  }
}
}
#line 407 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void handle_unknown_word(int i , char *s ) 
{ 
  char *t ;
  X_node *d ;
  char str[61] ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
  {
  {
#line 417
  sentence[i].x = build_word_expressions((char *)"UNKNOWN-WORD");
  }
  }
#line 418
  if ((unsigned long )sentence[i].x == (unsigned long )((void *)0)) {
    {
    {
#line 418
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "UNKNOWN_WORD should have been there");
    }
    {
#line 418
    exit(1);
    }
    }
  }
#line 420
  d = sentence[i].x;
  {
  {
#line 420
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 420
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 420
      goto while_break;
    }
    {
    {
#line 421
    t = strchr((char const   *)d->string, '.');
    }
    }
#line 422
    if ((unsigned long )t != (unsigned long )((void *)0)) {
      {
      {
#line 423
      sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%.50s[?].%.5s",
              s, t + 1);
      }
      }
    } else {
      {
      {
#line 425
      sprintf((char */* __restrict  */)(str), (char const   */* __restrict  */)"%.50s[?]",
              s);
      }
      }
    }
    {
    {
#line 427
    tmp = strlen((char const   *)(str));
    }
    {
#line 427
    tmp___0 = xalloc((int )(tmp + 1U));
    }
#line 427
    t = (char *)tmp___0;
    {
#line 428
    tmp___1 = strlen((char const   *)(str));
    }
    {
#line 428
    free_this_string_later(t, (int )(tmp___1 + 1U));
    }
    {
#line 429
    strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)(str));
    }
#line 430
    d->string = t;
#line 420
    d = d->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 432
  return;
}
}
#line 434 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int build_sentence_expressions(void) 
{ 
  int i ;
  int first_word ;
  char *s ;
  char *t ;
  X_node *e ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  void *tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  unsigned short const   **tmp___13 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;

  {
#line 456
  if (left_wall_defined) {
#line 457
    first_word = 1;
  } else {
#line 459
    first_word = 0;
  }
#line 463
  i = 0;
  {
  {
#line 463
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 463
    if (! (i < N_words)) {
#line 463
      goto while_break;
    }
    {
#line 464
    s = sentence[i].string;
    {
#line 465
    tmp___5 = boolean_dictionary_lookup(s);
    }
    }
#line 465
    if (tmp___5) {
      {
      {
#line 466
      sentence[i].x = build_word_expressions(s);
      }
      }
    } else {
      {
      {
#line 467
      tmp___4 = __ctype_b_loc();
      }
      }
#line 467
      if ((int const   )*(*tmp___4 + (int )*(s + 0)) & 256) {
#line 467
        if (capitalized_word_defined) {
          {
          {
#line 468
          tmp = special_string(i, (char *)"CAPITALIZED-WORDS");
          }
          }
#line 468
          if (! tmp) {
#line 468
            return (0);
          }
        } else {
#line 467
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 469
        tmp___3 = isnumber(s);
        }
        }
#line 469
        if (tmp___3) {
          {
          {
#line 472
          tmp___0 = special_string(i, (char *)"NUMBERS");
          }
          }
#line 472
          if (! tmp___0) {
#line 472
            return (0);
          }
        } else {
          {
          {
#line 473
          tmp___2 = ishyphenated(s);
          }
          }
#line 473
          if (tmp___2) {
            {
            {
#line 475
            tmp___1 = special_string(i, (char *)"HYPHENATED-WORDS");
            }
            }
#line 475
            if (! tmp___1) {
#line 475
              return (0);
            }
          } else
#line 476
          if (unknown_word_defined) {
#line 476
            if (use_unknown_word) {
              {
              {
#line 478
              handle_unknown_word(i, s);
              }
              }
            } else {
              {
              {
#line 482
              printf((char const   */* __restrict  */)"Assertion failed: %s\n", "I should have found that word.");
              }
              {
#line 482
              exit(1);
              }
              }
            }
          } else {
            {
            {
#line 482
            printf((char const   */* __restrict  */)"Assertion failed: %s\n", "I should have found that word.");
            }
            {
#line 482
            exit(1);
            }
            }
          }
        }
      }
    }
#line 463
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 488
  s = sentence[first_word].string;
  {
#line 489
  tmp___13 = __ctype_b_loc();
  }
  }
#line 489
  if ((int const   )*(*tmp___13 + (int )*(s + 0)) & 256) {
    {
    {
#line 490
    tmp___6 = strlen((char const   *)s);
    }
    {
#line 490
    tmp___7 = xalloc((int )(tmp___6 + 1U));
    }
#line 490
    t = (char *)tmp___7;
    {
#line 491
    tmp___8 = strlen((char const   *)s);
    }
    {
#line 491
    free_this_string_later(t, (int )(tmp___8 + 1U));
    }
    {
#line 492
    strcpy((char */* __restrict  */)t, (char const   */* __restrict  */)s);
    }
    {
#line 493
    tmp___9 = tolower((int )*(t + 0));
    }
#line 493
    *(t + 0) = (char )tmp___9;
    {
#line 494
    tmp___12 = boolean_dictionary_lookup(t);
    }
    }
#line 494
    if (tmp___12) {
      {
      {
#line 495
      tmp___11 = boolean_dictionary_lookup(s);
      }
      }
#line 495
      if (tmp___11) {
        {
        {
#line 496
        e = build_word_expressions(t);
        }
        {
#line 497
        sentence[first_word].x = catenate_X_nodes(sentence[first_word].x, e);
        }
        }
      } else {
        {
        {
#line 499
        tmp___10 = tolower((int )*(s + 0));
        }
#line 499
        *(s + 0) = (char )tmp___10;
        {
#line 500
        e = build_word_expressions(s);
        }
        {
#line 501
        free_X_nodes(sentence[first_word].x);
        }
#line 502
        sentence[first_word].x = e;
        }
      }
    }
  }
#line 533
  return (1);
}
}
#line 538 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void print_statistics(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;

  {
  {
  {
#line 539
  printf((char const   */* __restrict  */)"\n");
  }
  {
#line 540
  printf((char const   */* __restrict  */)"%d parse cost\n", parse_cost);
  }
  {
#line 541
  printf((char const   */* __restrict  */)"%d mark cost\n", mark_cost);
  }
  {
#line 542
  printf((char const   */* __restrict  */)"%d in hash table\n", N_in_table);
  }
  {
#line 543
  printf((char const   */* __restrict  */)"%d hash lookups\n", N_hash_lookups);
  }
  {
#line 544
  printf((char const   */* __restrict  */)"%f cost per lookup\n", (double )((float )work_in_hash_lookups / (float )N_hash_lookups));
  }
  {
#line 546
  printf((char const   */* __restrict  */)"%d maximum bytes ever in use\n", max_space_in_use);
  }
  {
#line 547
  printf((char const   */* __restrict  */)"%d unreclaimed space\n", space_in_use);
  }
  }
#line 549
  return;
}
}
#line 551 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void clean_up_string(char *s ) 
{ 
  char *x ;
  char *y ;
  unsigned short const   **tmp ;

  {
#line 554
  x = s;
#line 554
  y = x;
  {
  {
#line 555
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 555
    if (! ((int )*x != 0)) {
#line 555
      goto while_break;
    }
    {
    {
#line 556
    tmp = __ctype_b_loc();
    }
    }
#line 556
    if ((int const   )*(*tmp + (int )*x) & 8192) {
#line 559
      x ++;
    } else {
#line 557
      *y = *x;
#line 557
      x ++;
#line 557
      y ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 562
  *y = (char )'\000';
#line 563
  return;
}
}
#line 565 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
struct __anonstruct_user_variable_20 user_variable[19]  = 
#line 565
  {      {(char *)"verbosity", & verbosity, 0, (char *)"Level of detail to give about the computation"}, 
        {(char *)"width",
      & screen_width, 0, (char *)"The width of your screen"}, 
        {(char *)"limit", & linkage_count_limit, 0, (char *)"The maximum number of linkages processed"}, 
        {(char *)"graphics",
      & display_on, 1, (char *)"Graphical link display"}, 
        {(char *)"multiple", & display_multiple, 1, (char *)"Expansion of fat (conjunctive) linkages"}, 
        {(char *)"short",
      & display_short, 1, (char *)"Reduced height display"}, 
        {(char *)"postscript", & display_postscript, 1, (char *)"Generating of postscript data"}, 
        {(char *)"links",
      & display_links, 1, (char *)"Showing of complete link data"}, 
        {(char *)"bad", & display_bad, 1, (char *)"Showing of linkages failing postprocessing"}, 
        {(char *)"fat",
      & display_fat, 1, (char *)"Showing of fat (conjunctive) linkages"}, 
        {(char *)"lsubscripts", & display_link_subscripts, 1, (char *)"Showing of complete link labels"}, 
        {(char *)"wsubscripts",
      & display_word_subscripts, 1, (char *)"Showing of word subscripts"}, 
        {(char *)"walls", & display_walls, 1, (char *)"Always show the walls"}, 
        {(char *)"null", & null_link_search, 1, (char *)"Null link search"}, 
        {(char *)"unknown", & use_unknown_word, 1, (char *)"Using of the \"unknown word\" definition"}, 
        {(char *)"echo",
      & echo_on, 1, (char *)"Echoing of input sentence"}, 
        {(char *)"www", & www_mode, 1, (char *)"Suppression of prompt"}, 
        {(char *)"justone", & just_one, 1, (char *)"Displaying of just one linkage"}, 
        {(char *)"",
      (int *)((void *)0), 0, (char *)""}};
#line 589 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
struct __anonstruct_user_command_21 user_command[5]  = {      {(char *)"quit", (char *)"Exit the system"}, 
        {(char *)"save", (char *)"Save your changes to the dictionary"}, 
        {(char *)"variables", (char *)"List user-settable variables and their functions"}, 
        {(char *)"help",
      (char *)"List the commands and what they do"}, 
        {(char *)((void *)0), (char *)((void *)0)}};
#line 597 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int is_numerical_rhs(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
#line 602
  if ((int )*s == 43) {
#line 602
    s ++;
  } else
#line 602
  if ((int )*s == 45) {
#line 602
    s ++;
  }
  {
  {
#line 603
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 604
    tmp = __ctype_b_loc();
    }
    }
#line 604
    if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 604
      return (0);
    }
#line 605
    s ++;
#line 603
    if (! ((int )*s != 0)) {
#line 603
      goto while_break;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 607
  return (1);
}
}
#line 610 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void massage_variables(int j ) 
{ 
  int i ;

  {
#line 615
  i = 0;
  {
  {
#line 615
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 615
    if (! ((unsigned long )user_variable[i].p != (unsigned long )((void *)0))) {
#line 615
      goto while_break;
    }
#line 616
    if (user_variable[i].isboolean) {
#line 617
      *(user_variable[i].p) = ! (! *(user_variable[i].p));
    }
#line 615
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 620
  if (! display_on) {
#line 620
    if (display_multiple) {
#line 620
      goto _L___0;
    } else
#line 620
    if (display_bad) {
#line 620
      goto _L___0;
    } else
#line 620
    if (display_fat) {
      _L___0: /* CIL Label */ 
#line 621
      if ((unsigned long )user_variable[j].p == (unsigned long )(& display_on)) {
#line 622
        display_fat = 0;
#line 622
        display_bad = display_fat;
#line 622
        display_multiple = display_bad;
      } else {
#line 624
        display_on = 1;
      }
    } else {
#line 620
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 626
  if (display_on) {
#line 626
    if (! display_multiple) {
#line 626
      if (! display_bad) {
#line 626
        if (! display_fat) {
#line 627
          if ((unsigned long )user_variable[j].p == (unsigned long )(& display_on)) {
#line 628
            display_multiple = 1;
          } else {
#line 630
            display_on = 0;
          }
        }
      }
    }
  }
#line 633
  return;
}
}
#line 635 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void special_command(char *line ) 
{ 
  char *x ;
  char *y ;
  char *s ;
  char myline[1000] ;
  int i ;
  int count___0 ;
  int j ;
  int k ;
  size_t tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  Dict_node *dn ;
  Disjunct *d1 ;
  Disjunct *d2 ;
  int len ;
  Dict_node *dn___0 ;
  Dict_node *dn1 ;
  int count___1 ;
  int tmp___11 ;
  Dict_node *dn___1 ;
  Dict_node *dn_new ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  size_t tmp___19 ;
  void *tmp___20 ;
  Dict_node *tmp___21 ;
  void *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;
  char *__cil_tmp68 ;
  char *__cil_tmp69 ;
  char *__cil_tmp70 ;
  char *__cil_tmp71 ;
  char *__cil_tmp72 ;
  char *__cil_tmp73 ;
  char *__cil_tmp74 ;
  char *__cil_tmp75 ;
  char *__cil_tmp76 ;
  char *__cil_tmp77 ;
  char *__cil_tmp78 ;
  char *__cil_tmp79 ;
  char *__cil_tmp80 ;
  char *__cil_tmp81 ;
  char *__cil_tmp82 ;
  char *__cil_tmp83 ;
  char *__cil_tmp84 ;
  char *__cil_tmp85 ;
  char *__cil_tmp86 ;
  char *__cil_tmp87 ;
  char *__cil_tmp88 ;
  char *__cil_tmp89 ;
  char *__cil_tmp90 ;
  char *__cil_tmp91 ;
  char *__cil_tmp92 ;
  char *__cil_tmp93 ;
  char *__cil_tmp94 ;
  char *__cil_tmp95 ;
  char *__cil_tmp96 ;
  char *__cil_tmp97 ;
  char *__cil_tmp98 ;
  char *__cil_tmp99 ;
  char *__cil_tmp100 ;
  char *__cil_tmp101 ;
  char *__cil_tmp102 ;
  char *__cil_tmp103 ;
  char *__cil_tmp104 ;
  char *__cil_tmp105 ;
  char *__cil_tmp106 ;
  char *__cil_tmp107 ;
  char *__cil_tmp108 ;
  char *__cil_tmp109 ;
  char *__cil_tmp110 ;
  char *__cil_tmp111 ;
  char *__cil_tmp112 ;
  char *__cil_tmp113 ;
  char *__cil_tmp114 ;
  char *__cil_tmp115 ;
  char *__cil_tmp116 ;
  char *__cil_tmp117 ;
  char *__cil_tmp118 ;
  char *__cil_tmp119 ;
  char *__cil_tmp120 ;
  char *__cil_tmp121 ;

  {
  {
  {
#line 640
  strncpy((char */* __restrict  */)(myline), (char const   */* __restrict  */)line,
          (size_t )sizeof(myline));
  }
#line 641
  myline[sizeof(myline) - 1UL] = (char )'\000';
  {
#line 642
  clean_up_string(myline);
  }
#line 643
  s = myline;
#line 644
  s ++;
#line 651
  k = -1;
#line 651
  j = k;
#line 652
  count___0 = 0;
#line 653
  i = 0;
  }
  {
  {
#line 653
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 653
    if (! ((unsigned long )user_variable[i].p != (unsigned long )((void *)0))) {
#line 653
      goto while_break;
    }
#line 654
    if (user_variable[i].isboolean) {
      {
      {
#line 654
      tmp = strlen((char const   *)s);
      }
      {
#line 654
      tmp___0 = strncasecmp((char const   *)s, (char const   *)user_variable[i].s,
                            tmp);
      }
      }
#line 654
      if (tmp___0 == 0) {
#line 655
        count___0 ++;
#line 656
        j = i;
      }
    }
#line 653
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 659
  i = 0;
  {
  {
#line 659
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 659
    if (! ((unsigned long )user_command[i].s != (unsigned long )((void *)0))) {
#line 659
      goto while_break___0;
    }
    {
    {
#line 660
    tmp___1 = strlen((char const   *)s);
    }
    {
#line 660
    tmp___2 = strncasecmp((char const   *)s, (char const   *)user_command[i].s, tmp___1);
    }
    }
#line 660
    if (tmp___2 == 0) {
#line 661
      count___0 ++;
#line 662
      k = i;
    }
#line 659
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 666
  if (count___0 > 1) {
    {
    {
#line 667
    printf((char const   */* __restrict  */)"Ambiguous command.  Type \"!help\" or \"!variables\"\n");
    }
    }
#line 668
    return;
  } else
#line 669
  if (count___0 == 1) {
#line 670
    if (j >= 0) {
#line 671
      *(user_variable[j].p) = ! *(user_variable[j].p);
#line 672
      if (*(user_variable[j].p)) {
#line 672
        tmp___3 = "on";
      } else {
#line 672
        tmp___3 = "off";
      }
      {
      {
#line 672
      printf((char const   */* __restrict  */)"%s turned %s.\n", user_variable[j].str,
             tmp___3);
      }
      {
#line 673
      massage_variables(j);
      }
      }
#line 674
      return;
    } else {
      {
      {
#line 676
      strcpy((char */* __restrict  */)s, (char const   */* __restrict  */)user_command[k].s);
      }
      }
    }
  }
  {
  {
#line 680
  tmp___5 = strcmp((char const   *)s, "quit");
  }
  }
#line 680
  if (tmp___5 == 0) {
    {
    {
#line 681
    tmp___4 = files_need_saving();
    }
    }
#line 681
    if (tmp___4) {
      {
      {
#line 684
      printf((char const   */* __restrict  */)"You have changed some files and not saved them.\n");
      }
      {
#line 685
      printf((char const   */* __restrict  */)"Either save your files with \"!save\" and then quit,\n");
      }
      {
#line 686
      printf((char const   */* __restrict  */)"or get out without saving your files with control-C.\n");
      }
      }
    } else {
      {
      {
#line 682
      exit(1);
      }
      }
    }
#line 688
    return;
  }
  {
  {
#line 691
  tmp___6 = strncmp((char const   *)s, "mark", (size_t )4);
  }
  }
#line 691
  if (tmp___6 == 0) {
    {
    {
#line 692
    printf((char const   */* __restrict  */)"mark: %s", line + 6);
    }
    {
#line 693
    fflush(stdout);
    }
    }
#line 694
    return;
  }
  {
  {
#line 697
  tmp___8 = strcmp((char const   *)s, "save");
  }
  }
#line 697
  if (tmp___8 == 0) {
    {
    {
#line 698
    tmp___7 = files_need_saving();
    }
    }
#line 698
    if (tmp___7) {
      {
      {
#line 699
      save_files();
      }
      }
    } else {
      {
      {
#line 701
      printf((char const   */* __restrict  */)"No changes to be saved.\n");
      }
      }
    }
#line 703
    return;
  }
  {
  {
#line 705
  tmp___9 = strcmp((char const   *)s, "variables");
  }
  }
#line 705
  if (tmp___9 == 0) {
    {
    {
#line 706
    printf((char const   */* __restrict  */)" Variable     Controls                                      Value\n");
    }
    {
#line 707
    printf((char const   */* __restrict  */)" --------     --------                                      -----\n");
    }
#line 708
    i = 0;
    }
    {
    {
#line 708
    while (1) {
      while_continue___14: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 708
      if (! ((unsigned long )user_variable[i].p != (unsigned long )((void *)0))) {
#line 708
        goto while_break___1;
      }
      {
      {
#line 709
      printf((char const   */* __restrict  */)" ");
      }
      {
#line 710
      left_print_string(stdout, user_variable[i].s, (char *)"             ");
      }
      {
#line 711
      left_print_string(stdout, user_variable[i].str, (char *)"                                              ");
      }
      {
#line 712
      printf((char const   */* __restrict  */)"%5d", *(user_variable[i].p));
      }
      }
#line 713
      if (user_variable[i].isboolean) {
#line 714
        if (*(user_variable[i].p)) {
          {
          {
#line 714
          printf((char const   */* __restrict  */)" (On)");
          }
          }
        } else {
          {
          {
#line 714
          printf((char const   */* __restrict  */)" (Off)");
          }
          }
        }
      }
      {
      {
#line 716
      printf((char const   */* __restrict  */)"\n");
      }
#line 708
      i ++;
      }
    }
    while_break___14: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 718
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 719
    printf((char const   */* __restrict  */)"Toggle a boolean variable as in \"!links\", set a variable as in \"!width=100\".\n");
    }
    }
#line 720
    return;
  }
  {
  {
#line 722
  tmp___10 = strcmp((char const   *)s, "help");
  }
  }
#line 722
  if (tmp___10 == 0) {
    {
    {
#line 723
    printf((char const   */* __restrict  */)"Special commands always begin with \"!\".  Command and variable names\n");
    }
    {
#line 724
    printf((char const   */* __restrict  */)"can be abbreviated.  Here is a list of the commands:\n\n");
    }
#line 725
    i = 0;
    }
    {
    {
#line 725
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 725
      if (! ((unsigned long )user_command[i].s != (unsigned long )((void *)0))) {
#line 725
        goto while_break___2;
      }
      {
      {
#line 726
      printf((char const   */* __restrict  */)" !");
      }
      {
#line 727
      left_print_string(stdout, user_command[i].s, (char *)"                  ");
      }
      {
#line 728
      left_print_string(stdout, user_command[i].str, (char *)"                                                    ");
      }
      {
#line 729
      printf((char const   */* __restrict  */)"\n");
      }
#line 725
      i ++;
      }
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 731
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 732
    printf((char const   */* __restrict  */)" !!<string>         Print all the dictionary words matching <string>.\n");
    }
    {
#line 733
    printf((char const   */* __restrict  */)"                    Also print the number of disjuncts of each.\n");
    }
    {
#line 734
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 735
    printf((char const   */* __restrict  */)" !-<string>         Delete all the dictionary words matching <string>.\n");
    }
    {
#line 736
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 737
    printf((char const   */* __restrict  */)" !<string>=<word>   This indicates that a new word (<string>) is to be\n");
    }
    {
#line 738
    printf((char const   */* __restrict  */)"                    added to the dictionary.  Its definition will be the\n");
    }
    {
#line 739
    printf((char const   */* __restrict  */)"                    same as that of <word>, and, if appropriate, it will\n");
    }
    {
#line 740
    printf((char const   */* __restrict  */)"                    be added to the word file of <word>.\n");
    }
    {
#line 741
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 742
    printf((char const   */* __restrict  */)" !<var>             Toggle the specified boolean variable.\n");
    }
    {
#line 743
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 744
    printf((char const   */* __restrict  */)" !<var>=<val>       Assign that value to that variable.\n");
    }
    }
#line 745
    return;
  }
#line 748
  if ((int )*(s + 0) == 33) {
    {
    {
#line 754
    dn = dictionary_lookup(s + 1);
    }
    }
#line 754
    if ((unsigned long )dn == (unsigned long )((void *)0)) {
      {
      {
#line 755
      printf((char const   */* __restrict  */)"    \"%s\" matches nothing in the dictionary.\n",
             s + 1);
      }
      }
#line 756
      return;
    }
    {
    {
#line 758
    printf((char const   */* __restrict  */)"Matches:\n");
    }
    }
    {
    {
#line 759
    while (1) {
      while_continue___16: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 759
      if (! ((unsigned long )dn != (unsigned long )((void *)0))) {
#line 759
        goto while_break___3;
      }
      {
#line 760
      len = 0;
      {
#line 761
      d1 = build_disjuncts_for_dict_node(dn);
      }
#line 762
      d2 = d1;
      }
      {
      {
#line 762
      while (1) {
        while_continue___17: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
#line 762
        if (! ((unsigned long )d2 != (unsigned long )((void *)0))) {
#line 762
          goto while_break___4;
        }
#line 763
        len ++;
#line 762
        d2 = d2->next;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
      {
#line 765
      free_disjuncts(d1);
      }
      {
#line 766
      printf((char const   */* __restrict  */)"          ");
      }
      {
#line 767
      left_print_string(stdout, dn->string, (char *)"                  ");
      }
      {
#line 768
      printf((char const   */* __restrict  */)" %5d  ", len);
      }
      }
#line 769
      if ((unsigned long )dn->file != (unsigned long )((void *)0)) {
        {
        {
#line 770
        printf((char const   */* __restrict  */)"<%s>", (dn->file)->file);
        }
        }
      }
      {
      {
#line 772
      printf((char const   */* __restrict  */)"\n");
      }
#line 759
      dn = dn->right;
      }
    }
    while_break___16: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 774
    return;
  }
#line 776
  if ((int )*s == 45) {
    {
    {
#line 780
    dn___0 = abridged_lookup(s + 1);
    }
#line 781
    count___1 = 0;
    }
#line 782
    if ((unsigned long )dn___0 == (unsigned long )((void *)0)) {
      {
      {
#line 783
      printf((char const   */* __restrict  */)"    \"%s\" matches nothing in the dictionary.\n",
             s + 1);
      }
      }
#line 784
      return;
    }
#line 803
    dn1 = dn___0;
    {
    {
#line 803
    while (1) {
      while_continue___18: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 803
      if (! ((unsigned long )dn1 != (unsigned long )((void *)0))) {
#line 803
        goto while_break___5;
      }
#line 804
      if ((unsigned long )dn1->file == (unsigned long )((void *)0)) {
#line 804
        count___1 ++;
      }
#line 803
      dn1 = dn1->right;
    }
    while_break___18: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 806
    if (count___1 != 0) {
      {
      {
#line 807
      printf((char const   */* __restrict  */)"Note: \"%s\" ", s + 1);
      }
      {
#line 808
      printf((char const   */* __restrict  */)"matches the following words in the main dictionary:\n");
      }
#line 809
      dn1 = dn___0;
      }
      {
      {
#line 809
      while (1) {
        while_continue___19: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 809
        if (! ((unsigned long )dn1 != (unsigned long )((void *)0))) {
#line 809
          goto while_break___6;
        }
#line 810
        if ((unsigned long )dn1->file == (unsigned long )((void *)0)) {
          {
          {
#line 810
          printf((char const   */* __restrict  */)" %s ", dn1->string);
          }
          }
        }
#line 809
        dn1 = dn1->right;
      }
      while_break___19: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
      {
#line 812
      printf((char const   */* __restrict  */)"\n");
      }
      }
    }
    {
    {
#line 814
    printf((char const   */* __restrict  */)"Deleting:\n");
    }
#line 815
    dn1 = dn___0;
    }
    {
    {
#line 815
    while (1) {
      while_continue___20: /* CIL Label */ ;
      while_continue___7: /* CIL Label */ ;
#line 815
      if (! ((unsigned long )dn1 != (unsigned long )((void *)0))) {
#line 815
        goto while_break___7;
      }
      {
      {
#line 816
      printf((char const   */* __restrict  */)" %s ", dn1->string);
      }
#line 815
      dn1 = dn1->right;
      }
    }
    while_break___20: /* CIL Label */ ;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
    {
#line 819
    tmp___11 = delete_dictionary_words(s + 1);
    }
    }
#line 819
    if (! tmp___11) {
      {
      {
#line 820
      printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Attempt to delete a word not in the dictonary.");
      }
      {
#line 820
      exit(1);
      }
      }
    }
    {
    {
#line 822
    printf((char const   */* __restrict  */)"\n");
    }
    }
#line 823
    return;
  }
#line 826
  x = s;
  {
  {
#line 826
  while (1) {
    while_continue___21: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 826
    if ((int )*x != 61) {
#line 826
      if (! ((int )*x != 0)) {
#line 826
        goto while_break___8;
      }
    } else {
#line 826
      goto while_break___8;
    }
#line 826
    x ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 828
  if ((int )*x == 61) {
    {
#line 830
    *x = (char )'\000';
#line 831
    y = x + 1;
#line 832
    x = s;
    {
#line 835
    tmp___14 = is_numerical_rhs(y);
    }
    }
#line 835
    if (tmp___14) {
#line 836
      i = 0;
      {
      {
#line 836
      while (1) {
        while_continue___22: /* CIL Label */ ;
        while_continue___9: /* CIL Label */ ;
#line 836
        if (! ((unsigned long )user_variable[i].p != (unsigned long )((void *)0))) {
#line 836
          goto while_break___9;
        }
        {
        {
#line 837
        tmp___12 = strcmp((char const   *)x, (char const   *)user_variable[i].s);
        }
        }
#line 837
        if (tmp___12 == 0) {
#line 837
          goto while_break___9;
        }
#line 836
        i ++;
      }
      while_break___22: /* CIL Label */ ;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 839
      if ((unsigned long )user_variable[i].p == (unsigned long )((void *)0)) {
        {
        {
#line 840
        printf((char const   */* __restrict  */)"There is no user variable called \"%s\".\n",
               x);
        }
        }
      } else {
        {
        {
#line 842
        *(user_variable[i].p) = atoi((char const   *)y);
        }
        {
#line 843
        tmp___13 = atoi((char const   *)y);
        }
        {
#line 843
        printf((char const   */* __restrict  */)"%s set to %d\n", x, tmp___13);
        }
        {
#line 844
        massage_variables(i);
        }
        }
      }
#line 846
      return;
    }
    {
    {
#line 848
    tmp___15 = is_idiom_word(x);
    }
    }
#line 848
    if (tmp___15) {
      {
      {
#line 849
      printf((char const   */* __restrict  */)"    words ending \".Ix\" (x a number) ");
      }
      {
#line 850
      printf((char const   */* __restrict  */)"are reserved for idioms\n");
      }
      }
#line 851
      return;
    } else {
      {
      {
#line 848
      tmp___16 = is_idiom_word(y);
      }
      }
#line 848
      if (tmp___16) {
        {
        {
#line 849
        printf((char const   */* __restrict  */)"    words ending \".Ix\" (x a number) ");
        }
        {
#line 850
        printf((char const   */* __restrict  */)"are reserved for idioms\n");
        }
        }
#line 851
        return;
      }
    }
    {
    {
#line 853
    dn___1 = abridged_lookup(x);
    }
    }
#line 853
    if ((unsigned long )dn___1 != (unsigned long )((void *)0)) {
      {
      {
#line 854
      printf((char const   */* __restrict  */)"    \"%s\" matches words already in the dictionary:\n",
             s);
      }
      }
      {
      {
#line 855
      while (1) {
        while_continue___23: /* CIL Label */ ;
        while_continue___10: /* CIL Label */ ;
#line 855
        if (! ((unsigned long )dn___1 != (unsigned long )((void *)0))) {
#line 855
          goto while_break___10;
        }
        {
        {
#line 856
        printf((char const   */* __restrict  */)"%s ", dn___1->string);
        }
#line 855
        dn___1 = dn___1->right;
        }
      }
      while_break___23: /* CIL Label */ ;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
      {
#line 858
      printf((char const   */* __restrict  */)"\n");
      }
      }
#line 859
      return;
    }
    {
    {
#line 861
    dn___1 = abridged_lookup(y);
    }
    }
#line 861
    if ((unsigned long )dn___1 == (unsigned long )((void *)0)) {
      {
      {
#line 862
      printf((char const   */* __restrict  */)"    \"%s\" is not in the dictionary.\n",
             y);
      }
      }
#line 863
      return;
    }
#line 865
    if ((unsigned long )dn___1->right != (unsigned long )((void *)0)) {
#line 865
      goto _L;
    } else {
      {
      {
#line 865
      tmp___17 = strcmp((char const   *)y, (char const   *)dn___1->string);
      }
      }
#line 865
      if (tmp___17 != 0) {
        _L: /* CIL Label */ 
        {
        {
#line 866
        printf((char const   */* __restrict  */)"    Please be more precise.  \"%s\" matches:\n",
               y);
        }
        }
        {
        {
#line 867
        while (1) {
          while_continue___24: /* CIL Label */ ;
          while_continue___11: /* CIL Label */ ;
#line 867
          if (! ((unsigned long )dn___1 != (unsigned long )((void *)0))) {
#line 867
            goto while_break___11;
          }
          {
          {
#line 868
          printf((char const   */* __restrict  */)"%s ", dn___1->string);
          }
#line 867
          dn___1 = dn___1->right;
          }
        }
        while_break___24: /* CIL Label */ ;
        }
        while_break___11: /* CIL Label */ ;
        }
        {
        {
#line 870
        printf((char const   */* __restrict  */)"\n");
        }
        }
#line 871
        return;
      }
    }
#line 873
    if ((unsigned long )dn___1->file == (unsigned long )((void *)0)) {
      {
      {
#line 874
      printf((char const   */* __restrict  */)"    \"%s\" is in the dictionary but not in a file.\n",
             y);
      }
      {
#line 875
      printf((char const   */* __restrict  */)"    This word will not be saved.\n");
      }
      }
    }
    {
    {
#line 877
    tmp___18 = xalloc((int )sizeof(Dict_node ));
    }
#line 877
    dn_new = (Dict_node *)tmp___18;
    {
#line 878
    tmp___19 = strlen((char const   *)x);
    }
    {
#line 878
    tmp___20 = xalloc((int )(tmp___19 + 1U));
    }
#line 878
    dn_new->string = (char *)tmp___20;
    {
#line 879
    strcpy((char */* __restrict  */)dn_new->string, (char const   */* __restrict  */)x);
    }
#line 880
    tmp___21 = (Dict_node *)((void *)0);
#line 880
    dn_new->right = tmp___21;
#line 880
    dn_new->left = tmp___21;
#line 881
    dn_new->file = dn___1->file;
#line 882
    dn_new->exp = dn___1->exp;
    {
#line 883
    dict_root = insert_dict(dict_root, dn_new);
    }
    {
#line 884
    printf((char const   */* __restrict  */)"    \"%s\" added to the dictionary.\n",
           x);
    }
#line 885
    N_dict ++;
    }
#line 886
    if ((unsigned long )dn___1->file != (unsigned long )((void *)0)) {
#line 886
      (dn___1->file)->changed = 1;
    }
#line 887
    return;
  }
  {
  {
#line 889
  printf((char const   */* __restrict  */)"Try \"!help\".\n");
  }
  }
#line 890
  return;
}
}
#line 892 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int sentence_in_dictionary(void) 
{ 
  int w ;
  int ok_so_far ;
  char *s ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;

  {
#line 896
  ok_so_far = 1;
#line 897
  w = 0;
  {
  {
#line 897
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 897
    if (! (w < N_words)) {
#line 897
      goto while_break;
    }
    {
#line 898
    s = sentence[w].string;
    {
#line 899
    tmp = boolean_dictionary_lookup(s);
    }
    }
#line 899
    if (! tmp) {
      {
      {
#line 899
      tmp___0 = __ctype_b_loc();
      }
      }
#line 899
      if ((int const   )*(*tmp___0 + (int )*(s + 0)) & 256) {
#line 899
        if (! capitalized_word_defined) {
#line 899
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
        {
#line 899
        tmp___1 = ishyphenated(s);
        }
        }
#line 899
        if (! tmp___1) {
          {
          {
#line 899
          tmp___2 = isnumber(s);
          }
          }
#line 899
          if (! tmp___2) {
#line 903
            if (ok_so_far) {
              {
              {
#line 904
              printf((char const   */* __restrict  */)"The following words are not in the dictionary:");
              }
#line 905
              ok_so_far = 0;
              }
            }
            {
            {
#line 907
            printf((char const   */* __restrict  */)" \"%s\"", sentence[w].string);
            }
            }
          }
        }
      }
    }
#line 897
    w ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 910
  if (! ok_so_far) {
    {
    {
#line 910
    printf((char const   */* __restrict  */)"\n");
    }
    }
  }
#line 911
  return (ok_so_far);
}
}
#line 914 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int sentence_contains(char *s ) 
{ 
  int w ;
  int tmp ;

  {
#line 917
  w = 0;
  {
  {
#line 917
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 917
    if (! (w < N_words)) {
#line 917
      goto while_break;
    }
    {
    {
#line 918
    tmp = strcmp((char const   *)(sentence[w].string), (char const   *)s);
    }
    }
#line 918
    if (tmp == 0) {
#line 918
      return (1);
    }
#line 917
    w ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return (0);
}
}
#line 923 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void set_is_conjunction(void) 
{ 
  int w ;
  char *s ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
#line 926
  w = 0;
  {
  {
#line 926
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 926
    if (! (w < N_words)) {
#line 926
      goto while_break;
    }
    {
#line 927
    s = sentence[w].string;
    {
#line 928
    tmp = strcmp((char const   *)s, "and");
    }
    }
#line 928
    if (tmp == 0) {
#line 928
      tmp___3 = 1;
    } else {
      {
      {
#line 928
      tmp___0 = strcmp((char const   *)s, "or");
      }
      }
#line 928
      if (tmp___0 == 0) {
#line 928
        tmp___3 = 1;
      } else {
        {
        {
#line 928
        tmp___1 = strcmp((char const   *)s, "but");
        }
        }
#line 928
        if (tmp___1 == 0) {
#line 928
          tmp___3 = 1;
        } else {
          {
          {
#line 928
          tmp___2 = strcmp((char const   *)s, "nor");
          }
          }
#line 928
          if (tmp___2 == 0) {
#line 928
            tmp___3 = 1;
          } else {
#line 928
            tmp___3 = 0;
          }
        }
      }
    }
#line 928
    is_conjunction[w] = (char )tmp___3;
#line 926
    w ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 931
  return;
}
}
#line 933 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int sentence_contains_conjunction(void) 
{ 
  int w ;

  {
#line 938
  w = 0;
  {
  {
#line 938
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 938
    if (! (w < N_words)) {
#line 938
      goto while_break;
    }
#line 939
    if (is_conjunction[w]) {
#line 939
      return (1);
    }
#line 938
    w ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 941
  return (0);
}
}
#line 944 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int conj_in_range(int lw , int rw ) 
{ 


  {
  {
  {
#line 946
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 946
    if (! (lw <= rw)) {
#line 946
      goto while_break;
    }
#line 947
    if (is_conjunction[lw]) {
#line 947
      return (1);
    }
#line 946
    lw ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 949
  return (0);
}
}
#line 968 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void build_deletable(void) 
{ 
  int i ;
  int j ;
  int k ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;

  {
#line 982
  i = 0;
  {
  {
#line 982
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 982
    if (! (i < N_words)) {
#line 982
      goto while_break;
    }
    {
    {
#line 983
    tmp = xalloc(N_words + 1);
    }
#line 983
    deletable[i] = (char *)tmp;
#line 984
    j = 0;
    }
    {
    {
#line 984
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 984
      if (i + maxlinklength < N_words) {
#line 984
        tmp___10 = i + maxlinklength;
      } else {
#line 984
        tmp___10 = N_words;
      }
#line 984
      if (! (j <= tmp___10)) {
#line 984
        goto while_break___0;
      }
#line 985
      if (null_links) {
#line 986
        *(deletable[i] + j) = (char)1;
      } else
#line 987
      if (j == i + 1) {
#line 988
        *(deletable[i] + j) = (char)1;
      } else
#line 989
      if (j > i + 2) {
#line 989
        if (is_conjunction[i + 1]) {
#line 992
          *(deletable[i] + j) = (char)1;
        } else
#line 989
        if (is_conjunction[j - 1]) {
#line 992
          *(deletable[i] + j) = (char)1;
        } else {
          {
          {
#line 989
          tmp___6 = strcmp(",", (char const   *)(sentence[i + 1].string));
          }
          }
#line 989
          if (tmp___6 == 0) {
            {
            {
#line 989
            tmp___7 = conj_in_range(i + 2, j - 1);
            }
            }
#line 989
            if (tmp___7) {
#line 992
              *(deletable[i] + j) = (char)1;
            } else {
#line 989
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
            {
#line 989
            tmp___8 = strcmp(",", (char const   *)(sentence[j - 1].string));
            }
            }
#line 989
            if (tmp___8 == 0) {
              {
              {
#line 989
              tmp___9 = conj_in_range(j, N_words - 1);
              }
              }
#line 989
              if (tmp___9) {
#line 992
                *(deletable[i] + j) = (char)1;
              } else {
#line 989
                goto _L;
              }
            } else {
#line 989
              goto _L;
            }
          }
        }
      } else
      _L: /* CIL Label */ 
#line 993
      if (j > i) {
#line 994
        k = i + 1;
        {
        {
#line 994
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 994
          if (! (k < j)) {
#line 994
            goto while_break___1;
          }
          {
          {
#line 995
          tmp___0 = strcmp("either", (char const   *)(sentence[k].string));
          }
          }
#line 995
          if (tmp___0 == 0) {
#line 998
            goto __Cont;
          } else {
            {
            {
#line 995
            tmp___1 = strcmp("neither", (char const   *)(sentence[k].string));
            }
            }
#line 995
            if (tmp___1 == 0) {
#line 998
              goto __Cont;
            } else {
              {
              {
#line 995
              tmp___2 = strcmp("both", (char const   *)(sentence[k].string));
              }
              }
#line 995
              if (tmp___2 == 0) {
#line 998
                goto __Cont;
              } else {
                {
                {
#line 995
                tmp___3 = strcmp("not", (char const   *)(sentence[k].string));
                }
                }
#line 995
                if (tmp___3 == 0) {
#line 998
                  goto __Cont;
                }
              }
            }
          }
          {
          {
#line 999
          tmp___4 = strcmp("only", (char const   *)(sentence[k].string));
          }
          }
#line 999
          if (tmp___4 == 0) {
#line 999
            if (k > i + 1) {
              {
              {
#line 999
              tmp___5 = strcmp("not", (char const   *)(sentence[k - 1].string));
              }
              }
#line 999
              if (tmp___5 == 0) {
#line 1000
                goto __Cont;
              }
            }
          }
#line 1001
          goto while_break___1;
          __Cont: /* CIL Label */ 
#line 994
          k ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1003
        *(deletable[i] + j) = (char )(k == j);
      } else {
#line 1005
        *(deletable[i] + j) = (char)0;
      }
#line 984
      j ++;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 982
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1009
  return;
}
}
#line 1011 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void free_deletable(void) 
{ 
  int w ;

  {
#line 1013
  w = 0;
  {
  {
#line 1013
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1013
    if (! (w < N_words)) {
#line 1013
      goto while_break;
    }
    {
    {
#line 1014
    xfree(deletable[w], N_words + 1);
    }
#line 1013
    w ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1016
  return;
}
}
#line 1018 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void install_fat_connectors(void) 
{ 
  int i ;
  Disjunct *tmp ;
  Disjunct *tmp___0 ;
  Disjunct *tmp___1 ;
  int tmp___2 ;
  char *__cil_tmp6 ;

  {
#line 1022
  i = 0;
  {
  {
#line 1022
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1022
    if (! (i < N_words)) {
#line 1022
      goto while_break;
    }
#line 1023
    if (is_conjunction[i]) {
      {
      {
#line 1024
      tmp = build_AND_disjunct_list(sentence[i].string);
      }
      {
#line 1024
      sentence[i].d = catenate_disjuncts(sentence[i].d, tmp);
      }
      }
    } else {
      {
      {
#line 1027
      tmp___0 = explode_disjunct_list(sentence[i].d);
      }
      {
#line 1027
      sentence[i].d = catenate_disjuncts(sentence[i].d, tmp___0);
      }
      {
#line 1029
      tmp___2 = strcmp((char const   *)(sentence[i].string), ",");
      }
      }
#line 1029
      if (tmp___2 == 0) {
        {
        {
#line 1030
        tmp___1 = build_COMMA_disjunct_list();
        }
        {
#line 1030
        sentence[i].d = catenate_disjuncts(sentence[i].d, tmp___1);
        }
        }
      }
    }
#line 1022
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1035
  return;
}
}
#line 1037 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int compare_parse(Linkage_info *p1 , Linkage_info *p2 ) 
{ 


  {
#line 1039
  if ((int )p1->N_violations != (int )p2->N_violations) {
#line 1040
    return ((int )p1->N_violations - (int )p2->N_violations);
  } else
#line 1041
  if ((int )p1->disjunct_cost != (int )p2->disjunct_cost) {
#line 1042
    return ((int )p1->disjunct_cost - (int )p2->disjunct_cost);
  } else
#line 1043
  if ((int )p1->and_cost != (int )p2->and_cost) {
#line 1044
    return ((int )p1->and_cost - (int )p2->and_cost);
  } else {
#line 1046
    return ((int )p1->link_cost - (int )p2->link_cost);
  }
}
}
#line 1094 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void clear_time(void) 
{ 


  {
#line 1094
  return;
}
}
#line 1095 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void print_time(char *s ) 
{ 
  char *__cil_tmp2 ;

  {
#line 1096
  if (verbosity > 1) {
    {
    {
#line 1097
    printf((char const   */* __restrict  */)"++++%s\n", s);
    }
    }
  }
#line 1099
  return;
}
}
#line 1100 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void print_total_time(void) 
{ 


  {
#line 1100
  return;
}
}
#line 1118 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void first_prepare_to_parse(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;

  {
#line 1119
  if (echo_on) {
    {
    {
#line 1119
    print_sentence(stdout, 2);
    }
    }
  }
#line 1120
  if (verbosity > 2) {
    {
    {
#line 1121
    printf((char const   */* __restrict  */)"Raw expression sizes:\n");
    }
    {
#line 1122
    print_expression_sizes();
    }
    }
  }
  {
  {
#line 1124
  expression_prune();
  }
  {
#line 1125
  print_time((char *)"Done expression pruning");
  }
  }
#line 1126
  return;
}
}
#line 1128 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void prepare_to_parse(int cost_cutoff ) 
{ 
  int i ;
  int tmp ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
  {
#line 1134
  build_sentence_disjuncts(cost_cutoff);
  }
  }
#line 1135
  if (verbosity > 2) {
    {
    {
#line 1136
    printf((char const   */* __restrict  */)"After expanding expressions into disjuncts:");
    }
    {
#line 1137
    print_disjunct_counts();
    }
    }
  }
  {
  {
#line 1139
  print_time((char *)"Built disjuncts");
  }
#line 1141
  i = 0;
  }
  {
  {
#line 1141
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1141
    if (! (i < N_words)) {
#line 1141
      goto while_break;
    }
    {
    {
#line 1142
    sentence[i].d = eliminate_duplicate_disjuncts(sentence[i].d);
    }
#line 1141
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1144
  print_time((char *)"Eliminated duplicate disjuncts");
  }
  }
#line 1146
  if (verbosity > 2) {
    {
    {
#line 1147
    printf((char const   */* __restrict  */)"\nAfter expression pruning and duplicate elimination:\n");
    }
    {
#line 1148
    print_disjunct_counts();
    }
    }
  }
  {
  {
#line 1151
  set_is_conjunction();
  }
  {
#line 1153
  tmp = sentence_contains_conjunction();
  }
  }
#line 1153
  if (tmp) {
    {
    {
#line 1154
    build_deletable();
    }
    {
#line 1156
    power_prune(1);
    }
    }
#line 1157
    if (verbosity > 2) {
      {
      {
#line 1158
      printf((char const   */* __restrict  */)"\nAfter Gentle power pruning:\n");
      }
      {
#line 1159
      print_disjunct_counts();
      }
      }
    }
    {
    {
#line 1161
    print_time((char *)"Finished gentle power pruning");
    }
#line 1162
    mark_cost = 0;
#line 1162
    work_in_hash_lookups = mark_cost;
#line 1162
    N_hash_lookups = work_in_hash_lookups;
#line 1162
    N_in_table = N_hash_lookups;
    {
#line 1163
    conjunction_prune();
    }
    }
#line 1164
    if (verbosity > 2) {
      {
      {
#line 1165
      printf((char const   */* __restrict  */)"\nAfter conjunction pruning:\n");
      }
      {
#line 1166
      print_disjunct_counts();
      }
      {
#line 1167
      print_statistics();
      }
      }
    }
    {
    {
#line 1169
    free_deletable();
    }
    {
#line 1170
    print_time((char *)"Done conjunction pruning");
    }
    {
#line 1171
    build_conjunction_tables();
    }
    {
#line 1172
    install_fat_connectors();
    }
    {
#line 1173
    construct_either();
    }
    {
#line 1174
    construct_neither();
    }
    {
#line 1175
    construct_notonlybut();
    }
    {
#line 1177
    construct_both();
    }
    {
#line 1178
    construct_comma();
    }
    }
#line 1179
    if (verbosity > 2) {
      {
      {
#line 1180
      printf((char const   */* __restrict  */)"After conjunctions, disjuncts counts:\n");
      }
      {
#line 1181
      print_disjunct_counts();
      }
      }
    }
    {
    {
#line 1183
    print_time((char *)"Constructed fat disjuncts");
    }
    {
#line 1185
    prune();
    }
    {
#line 1186
    print_time((char *)"Pruned fat disjuncts");
    }
#line 1188
    i = 0;
    }
    {
    {
#line 1188
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1188
      if (! (i < N_words)) {
#line 1188
        goto while_break___0;
      }
      {
      {
#line 1189
      sentence[i].d = eliminate_duplicate_disjuncts(sentence[i].d);
      }
#line 1188
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1191
    if (verbosity > 2) {
      {
      {
#line 1192
      printf((char const   */* __restrict  */)"After pruning and duplicate elimination:\n");
      }
      {
#line 1193
      print_disjunct_counts();
      }
      }
    }
    {
    {
#line 1195
    print_time((char *)"Eliminated duplicate disjuncts (again)");
    }
    }
#line 1197
    if (verbosity > 2) {
      {
      {
#line 1197
      print_AND_statistics();
      }
      }
    }
  }
  {
  {
#line 1200
  power_prune(0);
  }
  }
#line 1202
  if (verbosity > 2) {
    {
    {
#line 1203
    printf((char const   */* __restrict  */)"\nAfter power-pruning:\n");
    }
    {
#line 1204
    print_disjunct_counts();
    }
    }
  }
  {
  {
#line 1206
  print_time((char *)"Ruthlessly power pruned");
  }
#line 1208
  parse_cost = 0;
#line 1208
  work_in_hash_lookups = parse_cost;
#line 1208
  N_hash_lookups = work_in_hash_lookups;
#line 1208
  N_in_table = N_hash_lookups;
  {
#line 1210
  init_fast_matcher();
  }
  {
#line 1211
  init_table();
  }
  {
#line 1212
  print_time((char *)"Initialized fast matcher and hash table");
  }
  }
#line 1213
  return;
}
}
#line 1215 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void unprepare_parse(void) 
{ 
  int tmp ;

  {
  {
  {
#line 1216
  free_sentence_disjuncts();
  }
  {
#line 1217
  tmp = sentence_contains_conjunction();
  }
  }
#line 1217
  if (tmp) {
    {
    {
#line 1217
    free_AND_tables();
    }
    }
  }
  {
  {
#line 1218
  free_fast_matcher();
  }
  {
#line 1219
  free_table();
  }
  }
#line 1220
  return;
}
}
#line 1222 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void final_unprepare_parse(void) 
{ 


  {
  {
  {
#line 1224
  free_sentence_expressions();
  }
  {
#line 1225
  free_strings();
  }
  {
#line 1226
  free_lookup_list();
  }
  }
#line 1229
  return;
}
}
#line 1231 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int compute_linkage_arrays(int index___0 , int cost ) 
{ 
  int tmp ;

  {
  {
  {
#line 1236
  extract_links(index___0, cost);
  }
  {
#line 1237
  tmp = set_has_fat_down();
  }
  }
#line 1237
  return (tmp);
}
}
#line 1240 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void summary_line(int N_canonical_linkages , int N_valid_linkages , char *stagen ,
                  int give_up ) 
{ 
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;

  {
#line 1241
  if (N_canonical_linkages == 0) {
#line 1242
    if (give_up) {
      {
      {
#line 1243
      printf((char const   */* __restrict  */)"Not accepted (no linkage exists) at %s",
             stagen);
      }
      }
    } else {
      {
      {
#line 1245
      printf((char const   */* __restrict  */)"No linkages at %s", stagen);
      }
      }
    }
  } else
#line 1247
  if (N_canonical_linkages == 1) {
#line 1248
    if (N_valid_linkages == 0) {
#line 1249
      if (give_up) {
        {
        {
#line 1250
        printf((char const   */* __restrict  */)"Not accepted (unique linkage with P.P. violation) at %s",
               stagen);
        }
        }
      } else {
        {
        {
#line 1252
        printf((char const   */* __restrict  */)"Unique linkage with P.P. violation at %s",
               stagen);
        }
        }
      }
    } else {
      {
      {
#line 1255
      printf((char const   */* __restrict  */)"Accepted at %s", stagen);
      }
      }
    }
  } else
#line 1258
  if (N_valid_linkages == 0) {
#line 1259
    if (give_up) {
      {
      {
#line 1260
      printf((char const   */* __restrict  */)"Not accepted (%d linkages, all with P.P. violations) at %s",
             N_canonical_linkages, stagen);
      }
      }
    } else {
      {
      {
#line 1263
      printf((char const   */* __restrict  */)"%d linkages (all with P.P. violations) at %s",
             N_canonical_linkages, stagen);
      }
      }
    }
  } else {
    {
    {
#line 1266
    printf((char const   */* __restrict  */)"Accepted (%d linkages, %d with no P.P. violations) at %s",
           N_canonical_linkages, N_valid_linkages, stagen);
    }
    }
  }
#line 1269
  if (display_bad) {
    {
    {
#line 1270
    printf((char const   */* __restrict  */)" (shown above)\n\n");
    }
    }
  } else {
    {
    {
#line 1272
    printf((char const   */* __restrict  */)"\n");
    }
    }
  }
#line 1274
  return;
}
}
#line 1277 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
static char answer[100]  ;
#line 1276 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
char *stage_name(int phase , int cost_cutoff , int null_count ) 
{ 
  int stage ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;

  {
#line 1279
  if (phase == 0) {
#line 1280
    if (cost_cutoff <= 1) {
#line 1280
      stage = 1;
    } else {
#line 1280
      stage = 2;
    }
    {
    {
#line 1281
    sprintf((char */* __restrict  */)(answer), (char const   */* __restrict  */)"stage %d",
            stage);
    }
    }
  } else {
    {
    {
#line 1283
    sprintf((char */* __restrict  */)(answer), (char const   */* __restrict  */)"null count %d",
            null_count);
    }
    }
  }
#line 1285
  return (answer);
}
}
#line 1289 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void loop(void) 
{ 
  int i ;
  int N_to_display ;
  int index___0 ;
  int N_linkages ;
  int N_canonical_linkages ;
  int N_valid_linkages ;
  int has_fatlinks ;
  Linkage_info *linkage ;
  char line[1500] ;
  char message[80] ;
  int line_set ;
  int cost_cutoff ;
  int old_cost_cutoff ;
  int maxcost ;
  int success ;
  int give_up ;
  int phase ;
  int just_entered_phase_1 ;
  int null_count ;
  char *stagen ;
  char *tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  int tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  void *__cil_tmp30 ;
  void *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;

  {
#line 1295
  linkage = (Linkage_info *)((void *)0);
#line 1297
  line_set = 0;
  {
  {
#line 1302
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
#line 1303
    null_links = 0;
    {
#line 1305
    free_lookup_list();
    }
    {
#line 1306
    free_strings();
    }
#line 1307
    max_space_in_use = 0;
#line 1308
    space_in_use = 0;
    {
#line 1311
    clear_time();
    }
    }
#line 1315
    if (! line_set) {
#line 1316
      if (! www_mode) {
        {
        {
#line 1316
        printf((char const   */* __restrict  */)"> ");
        }
        }
      }
#line 1317
      if (www_mode) {
        {
        {
#line 1317
        fflush(stdout);
        }
        }
      }
      {
      {
#line 1318
      tmp = fgets((char */* __restrict  */)(line), 1500, (FILE */* __restrict  */)stdin);
      }
      }
#line 1318
      if ((unsigned long )tmp == (unsigned long )((void *)0)) {
        {
        {
#line 1318
        exit(1);
        }
        }
      }
    }
    {
#line 1320
    line_set = 0;
    {
#line 1321
    tmp___0 = strlen((char const   *)(line));
    }
    }
#line 1321
    if ((int )line[tmp___0 - 1U] != 10) {
      {
      {
#line 1322
      printf((char const   */* __restrict  */)"Your sentence is too long\n");
      }
      }
#line 1323
      goto __Cont;
    }
#line 1325
    if ((int )line[0] == 33) {
      {
      {
#line 1326
      special_command(line);
      }
      }
#line 1327
      goto __Cont;
    }
    {
    {
#line 1329
    tmp___1 = separate_sentence(line);
    }
    }
#line 1329
    if (! tmp___1) {
#line 1329
      goto __Cont;
    }
#line 1330
    if ((N_words - left_wall_defined) - right_wall_defined > word_count_limit) {
      {
      {
#line 1331
      printf((char const   */* __restrict  */)"Try a sentence with at most %d words.\n",
             word_count_limit);
      }
      }
#line 1332
      goto __Cont;
    }
#line 1334
    if (unknown_word_defined) {
#line 1334
      if (! use_unknown_word) {
#line 1334
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
      {
#line 1335
      tmp___2 = sentence_in_dictionary();
      }
      }
#line 1335
      if (! tmp___2) {
#line 1335
        goto __Cont;
      }
    }
    {
    {
#line 1337
    tmp___3 = build_sentence_expressions();
    }
    }
#line 1337
    if (! tmp___3) {
#line 1337
      goto __Cont;
    }
    {
    {
#line 1338
    maxcost = maxcost_of_sentence();
    }
    {
#line 1340
    print_time((char *)"Constructed disjunct expressions");
    }
    {
#line 1342
    first_prepare_to_parse();
    }
#line 1343
    old_cost_cutoff = 1;
    {
#line 1344
    prepare_to_parse(1);
    }
#line 1346
    phase = 0;
#line 1347
    give_up = 0;
#line 1347
    success = give_up;
#line 1348
    cost_cutoff = 0;
#line 1349
    null_count = 0;
    }
    {
    {
#line 1350
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1350
      if (success) {
#line 1350
        goto while_break___0;
      } else
#line 1350
      if (give_up) {
#line 1350
        goto while_break___0;
      }
#line 1354
      just_entered_phase_1 = 0;
#line 1355
      if (phase == 0) {
#line 1357
        if (cost_cutoff == 0) {
#line 1358
          cost_cutoff = 1;
        } else
#line 1359
        if (cost_cutoff == 1) {
#line 1359
          if (maxcost > 1) {
#line 1360
            cost_cutoff = maxcost;
          } else {
#line 1362
            phase = 1;
#line 1363
            null_links = 1;
#line 1364
            cost_cutoff = 1000;
#line 1365
            just_entered_phase_1 = 1;
          }
        } else {
#line 1362
          phase = 1;
#line 1363
          null_links = 1;
#line 1364
          cost_cutoff = 1000;
#line 1365
          just_entered_phase_1 = 1;
        }
#line 1367
        if (cost_cutoff == maxcost) {
#line 1367
          if (! null_link_search) {
#line 1367
            give_up = 1;
          }
        }
      } else {
#line 1370
        null_count ++;
#line 1371
        give_up = null_count >= N_words - 1;
      }
#line 1376
      if (verbosity > 2) {
#line 1376
        if (phase == 0) {
          {
          {
#line 1376
          printf((char const   */* __restrict  */)"Cost cutoff: %d\n", cost_cutoff);
          }
          }
        }
      }
#line 1378
      if (cost_cutoff != old_cost_cutoff) {
        {
        {
#line 1379
        unprepare_parse();
        }
        {
#line 1380
        prepare_to_parse(cost_cutoff);
        }
#line 1381
        old_cost_cutoff = cost_cutoff;
        }
      }
#line 1384
      if (just_entered_phase_1) {
#line 1386
        null_count = 1;
      }
      {
      {
#line 1388
      stagen = stage_name(phase, cost_cutoff, null_count);
      }
      }
#line 1390
      if (phase == 0) {
        {
        {
#line 1391
        N_linkages = parse(0);
        }
        }
      } else {
        {
        {
#line 1393
        N_linkages = parse(null_count);
        }
        }
      }
#line 1396
      if (N_linkages > linkage_count_limit) {
        {
        {
#line 1397
        printf((char const   */* __restrict  */)"Warning: only the first %d of %d linkages will be considered.\n",
               linkage_count_limit, N_linkages);
        }
#line 1398
        N_linkages = linkage_count_limit;
        }
      }
      {
      {
#line 1401
      sprintf((char */* __restrict  */)(message), (char const   */* __restrict  */)"Counted %d linkges",
              N_linkages);
      }
      {
#line 1402
      print_time(message);
      }
#line 1404
      N_valid_linkages = 0;
#line 1404
      N_canonical_linkages = N_valid_linkages;
      }
#line 1406
      if (N_linkages != 0) {
        {
        {
#line 1407
        tmp___4 = xalloc((int )((unsigned long )N_linkages * sizeof(Linkage_info )));
        }
#line 1407
        linkage = (Linkage_info *)tmp___4;
#line 1408
        index___0 = 0;
        }
        {
        {
#line 1408
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 1408
          if (! (index___0 < N_linkages)) {
#line 1408
            goto while_break___1;
          }
          {
          {
#line 1409
          has_fatlinks = compute_linkage_arrays(index___0, null_count);
          }
          }
#line 1410
          if (has_fatlinks) {
            {
            {
#line 1411
            tmp___5 = is_canonical_linkage();
            }
            }
#line 1411
            if (! tmp___5) {
#line 1411
              goto __Cont___0;
            }
            {
            {
#line 1412
            *(linkage + N_canonical_linkages) = analyze_fat_linkage(0);
            }
            }
          } else {
            {
            {
#line 1414
            *(linkage + N_canonical_linkages) = analyze_thin_linkage(0);
            }
            }
          }
#line 1416
          if ((int )(linkage + N_canonical_linkages)->N_violations == 0) {
#line 1417
            N_valid_linkages ++;
          }
#line 1419
          (linkage + N_canonical_linkages)->index = index___0;
#line 1420
          N_canonical_linkages ++;
          __Cont___0: /* CIL Label */ 
#line 1408
          index___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
        {
#line 1422
        qsort((void *)linkage, (size_t )N_canonical_linkages, (size_t )sizeof(Linkage_info ),
              (int (*)(void const   * , void const   * ))(& compare_parse));
        }
        }
      }
#line 1427
      if (N_canonical_linkages == 0) {
#line 1427
        if (N_linkages > 0) {
#line 1427
          if (N_linkages < linkage_count_limit) {
            {
            {
#line 1427
            printf((char const   */* __restrict  */)"Assertion failed: %s\n", "None of the linkages is canonical");
            }
            {
#line 1427
            exit(1);
            }
            }
          }
        }
      }
      {
      {
#line 1430
      print_time((char *)"Postprocessed all linkages");
      }
#line 1432
      line_set = 0;
#line 1433
      success = N_valid_linkages > 0;
      }
#line 1436
      if (! display_bad) {
        {
        {
#line 1436
        summary_line(N_canonical_linkages, N_valid_linkages, stagen, give_up);
        }
        }
      }
#line 1438
      if (display_bad) {
#line 1439
        N_to_display = N_canonical_linkages;
      } else {
#line 1441
        N_to_display = N_valid_linkages;
      }
#line 1444
      if (display_on) {
#line 1445
        index___0 = 0;
        {
        {
#line 1445
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 1445
          if (! (index___0 < N_to_display)) {
#line 1445
            goto while_break___2;
          }
          {
          {
#line 1446
          has_fatlinks = compute_linkage_arrays((linkage + index___0)->index, null_count);
          }
          {
#line 1447
          compute_chosen_words();
          }
          }
#line 1448
          if (N_canonical_linkages > 1) {
            {
            {
#line 1449
            printf((char const   */* __restrict  */)"  Linkage %d", index___0 + 1);
            }
            }
          } else {
            {
            {
#line 1451
            printf((char const   */* __restrict  */)"  Unique linkage");
            }
            }
          }
#line 1453
          if ((int )(linkage + index___0)->N_violations > 0) {
            {
            {
#line 1454
            printf((char const   */* __restrict  */)" (bad), ");
            }
            }
          } else {
            {
            {
#line 1456
            printf((char const   */* __restrict  */)", ");
            }
            }
          }
          {
          {
#line 1458
          printf((char const   */* __restrict  */)"cost vector = (%d, %d, %d)\n",
                 (int )(linkage + index___0)->disjunct_cost, (int )(linkage + index___0)->and_cost,
                 (int )(linkage + index___0)->link_cost);
          }
          }
#line 1462
          if (has_fatlinks) {
            {
            {
#line 1463
            analyze_fat_linkage(1);
            }
            }
          } else {
            {
            {
#line 1465
            analyze_thin_linkage(1);
            }
            }
          }
#line 1467
          if (index___0 == N_to_display - 1) {
#line 1467
            goto while_break___2;
          }
#line 1468
          if (just_one) {
#line 1468
            goto while_break___2;
          }
#line 1469
          if (www_mode) {
#line 1469
            goto __Cont___1;
          }
#line 1470
          if (! display_bad) {
            {
            {
#line 1472
            printf((char const   */* __restrict  */)"(press return for another)\n");
            }
            {
#line 1473
            printf((char const   */* __restrict  */)"> ");
            }
            {
#line 1474
            tmp___6 = fgets((char */* __restrict  */)(line), 1500, (FILE */* __restrict  */)stdin);
            }
            }
#line 1474
            if ((unsigned long )tmp___6 == (unsigned long )((void *)0)) {
              {
              {
#line 1474
              exit(1);
              }
              }
            }
#line 1475
            i = 0;
            {
            {
#line 1475
            while (1) {
              while_continue___8: /* CIL Label */ ;
              while_continue___3: /* CIL Label */ ;
#line 1475
              if (! ((int )line[i] != 0)) {
#line 1475
                goto while_break___3;
              }
              {
              {
#line 1475
              tmp___7 = __ctype_b_loc();
              }
              }
#line 1475
              if (! ((int const   )*(*tmp___7 + (int )line[i]) & 8192)) {
#line 1475
                goto while_break___3;
              }
#line 1475
              i ++;
            }
            while_break___8: /* CIL Label */ ;
            }
            while_break___3: /* CIL Label */ ;
            }
#line 1476
            if ((int )line[i] != 0) {
#line 1477
              line_set = 1;
#line 1478
              goto while_break___2;
            }
          }
          __Cont___1: /* CIL Label */ 
#line 1445
          index___0 ++;
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 1484
      if (display_bad) {
        {
        {
#line 1484
        summary_line(N_canonical_linkages, N_valid_linkages, stagen, give_up);
        }
        }
      }
#line 1486
      if (N_linkages != 0) {
        {
        {
#line 1487
        xfree((char *)linkage, (int )((unsigned long )N_linkages * sizeof(Linkage_info )));
        }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 1491
    print_time((char *)"Displayed linkages");
    }
    {
#line 1492
    unprepare_parse();
    }
    {
#line 1493
    final_unprepare_parse();
    }
    {
#line 1494
    print_time((char *)"Freed all data structures");
    }
    }
#line 1496
    if (verbosity > 2) {
      {
      {
#line 1496
      print_statistics();
      }
      }
    }
#line 1497
    if (space_in_use != 0) {
      {
      {
#line 1498
      printf((char const   */* __restrict  */)"Warning: %d bytes of space leaked.\n",
             space_in_use);
      }
      }
    }
    {
    {
#line 1500
    print_total_time();
    }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 1504 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
void batch_process(void) 
{ 
  int i ;
  int N_linkages ;
  int N_canonical_linkages ;
  int N_valid_linkages ;
  int index___0 ;
  int has_fatlinks ;
  Linkage_info *linkage ;
  char s[1500] ;
  int errors ;
  int mc ;
  int cost_cutoff ;
  int old_cost_cutoff ;
  int maxcost ;
  int last_pass ;
  char *tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  char *tmp___16 ;
  void *__cil_tmp35 ;
  char *__cil_tmp36 ;
  char *__cil_tmp37 ;
  char *__cil_tmp38 ;
  char *__cil_tmp39 ;
  char *__cil_tmp40 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;
  char *__cil_tmp47 ;
  char *__cil_tmp48 ;
  char *__cil_tmp49 ;
  char *__cil_tmp50 ;
  char *__cil_tmp51 ;
  char *__cil_tmp52 ;
  char *__cil_tmp53 ;
  char *__cil_tmp54 ;
  char *__cil_tmp55 ;
  char *__cil_tmp56 ;
  char *__cil_tmp57 ;
  char *__cil_tmp58 ;
  char *__cil_tmp59 ;
  char *__cil_tmp60 ;
  char *__cil_tmp61 ;
  char *__cil_tmp62 ;
  char *__cil_tmp63 ;
  char *__cil_tmp64 ;
  char *__cil_tmp65 ;
  char *__cil_tmp66 ;
  char *__cil_tmp67 ;

  {
#line 1511
  linkage = (Linkage_info *)((void *)0);
#line 1518
  null_links = 0;
#line 1519
  errors = 0;
  {
  {
#line 1522
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 1523
    free_lookup_list();
    }
    {
#line 1524
    free_strings();
    }
#line 1525
    max_space_in_use = 0;
#line 1526
    space_in_use = 0;
    {
#line 1527
    clear_time();
    }
    {
#line 1530
    tmp = fgets((char */* __restrict  */)(s), 1500, (FILE */* __restrict  */)stdin);
    }
    }
#line 1530
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 1530
      goto while_break;
    }
    {
    {
#line 1531
    tmp___0 = strlen((char const   *)(s));
    }
    }
#line 1531
    if ((int )s[tmp___0 - 1U] != 10) {
      {
      {
#line 1532
      printf((char const   */* __restrict  */)"Sentence too long\n");
      }
      }
#line 1533
      goto __Cont;
    }
#line 1536
    i = 0;
    {
    {
#line 1536
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
      {
      {
#line 1536
      tmp___1 = __ctype_b_loc();
      }
      }
#line 1536
      if (! ((int const   )*(*tmp___1 + (int )s[i]) & 8192)) {
#line 1536
        goto while_break___0;
      }
#line 1536
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1538
    if ((int )s[i] == 37) {
#line 1538
      goto __Cont;
    }
#line 1539
    if ((int )s[i] == 0) {
#line 1539
      goto __Cont;
    }
#line 1541
    if ((int )s[i] == 42) {
#line 1542
      mc = (int )s[i];
#line 1543
      s[i] = (char )' ';
    } else
#line 1541
    if ((int )s[i] == 43) {
#line 1542
      mc = (int )s[i];
#line 1543
      s[i] = (char )' ';
    } else
#line 1541
    if ((int )s[i] == 35) {
#line 1542
      mc = (int )s[i];
#line 1543
      s[i] = (char )' ';
    } else
#line 1541
    if ((int )s[i] == 58) {
#line 1542
      mc = (int )s[i];
#line 1543
      s[i] = (char )' ';
    } else
#line 1541
    if ((int )s[i] == 45) {
#line 1542
      mc = (int )s[i];
#line 1543
      s[i] = (char )' ';
    } else {
#line 1545
      mc = ' ';
    }
#line 1548
    if ((int )s[0] == 33) {
      {
      {
#line 1549
      special_command(s);
      }
      }
#line 1550
      goto __Cont;
    }
    {
    {
#line 1552
    tmp___2 = separate_sentence(s);
    }
    }
#line 1552
    if (! tmp___2) {
#line 1552
      goto __Cont;
    }
#line 1553
    if (unknown_word_defined) {
#line 1553
      if (! use_unknown_word) {
#line 1553
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
      {
#line 1554
      tmp___3 = sentence_in_dictionary();
      }
      }
#line 1554
      if (! tmp___3) {
        {
#line 1555
        errors ++;
        {
#line 1556
        printf((char const   */* __restrict  */)"--- in the following sentence:\n");
        }
        {
#line 1557
        printf((char const   */* __restrict  */)"%c ", mc);
        }
        {
#line 1558
        print_sentence(stdout, 2);
        }
        {
#line 1559
        printf((char const   */* __restrict  */)"\n");
        }
        }
#line 1560
        goto __Cont;
      }
    }
    {
    {
#line 1563
    tmp___4 = build_sentence_expressions();
    }
    }
#line 1563
    if (! tmp___4) {
#line 1564
      errors ++;
#line 1565
      goto __Cont;
    }
    {
    {
#line 1567
    maxcost = maxcost_of_sentence();
    }
    {
#line 1568
    print_time((char *)"Constructed disjunct expressions");
    }
    }
#line 1569
    if (echo_on) {
      {
      {
#line 1569
      printf((char const   */* __restrict  */)"%c ", mc);
      }
      }
    }
    {
    {
#line 1571
    first_prepare_to_parse();
    }
#line 1573
    last_pass = 0;
#line 1575
    cost_cutoff = 0;
#line 1576
    old_cost_cutoff = 1;
    {
#line 1577
    prepare_to_parse(1);
    }
    }
    {
    {
#line 1579
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1579
      if (! (! last_pass)) {
#line 1579
        goto while_break___1;
      }
#line 1580
      if (cost_cutoff == 0) {
#line 1581
        cost_cutoff = 1;
      } else
#line 1582
      if (cost_cutoff == 1) {
#line 1582
        if (maxcost > 1) {
#line 1583
          cost_cutoff = maxcost;
        }
      }
#line 1586
      last_pass = cost_cutoff >= maxcost;
#line 1588
      if (verbosity > 2) {
        {
        {
#line 1588
        printf((char const   */* __restrict  */)"Cost cutoff: %d  maxcost: %d\n",
               cost_cutoff, maxcost);
        }
        }
      }
#line 1590
      if (cost_cutoff != old_cost_cutoff) {
        {
        {
#line 1591
        unprepare_parse();
        }
        {
#line 1592
        prepare_to_parse(cost_cutoff);
        }
#line 1593
        old_cost_cutoff = cost_cutoff;
        }
      }
      {
      {
#line 1596
      N_linkages = parse(0);
      }
      {
#line 1597
      print_time((char *)"Counted linkages");
      }
#line 1599
      N_valid_linkages = 0;
#line 1599
      N_canonical_linkages = N_valid_linkages;
      }
#line 1601
      if (N_linkages != 0) {
        {
        {
#line 1602
        tmp___5 = xalloc((int )((unsigned long )N_linkages * sizeof(Linkage_info )));
        }
#line 1602
        linkage = (Linkage_info *)tmp___5;
#line 1605
        index___0 = 0;
        }
        {
        {
#line 1605
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 1605
          if (index___0 < N_linkages) {
#line 1605
            if (! (N_valid_linkages == 0)) {
#line 1605
              goto while_break___2;
            }
          } else {
#line 1605
            goto while_break___2;
          }
          {
          {
#line 1609
          has_fatlinks = compute_linkage_arrays(index___0, 0);
          }
          }
#line 1610
          if (has_fatlinks) {
            {
            {
#line 1611
            tmp___6 = is_canonical_linkage();
            }
            }
#line 1611
            if (! tmp___6) {
#line 1611
              goto __Cont___0;
            }
            {
            {
#line 1612
            *(linkage + N_canonical_linkages) = analyze_fat_linkage(0);
            }
            }
          } else {
            {
            {
#line 1615
            *(linkage + N_canonical_linkages) = analyze_thin_linkage(0);
            }
            }
          }
#line 1618
          if ((int )(linkage + N_canonical_linkages)->N_violations == 0) {
#line 1619
            N_valid_linkages ++;
          }
#line 1621
          (linkage + N_canonical_linkages)->index = index___0;
#line 1622
          N_canonical_linkages ++;
          __Cont___0: /* CIL Label */ 
#line 1605
          index___0 ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        {
#line 1624
        qsort((void *)linkage, (size_t )N_canonical_linkages, (size_t )sizeof(Linkage_info ),
              (int (*)(void const   * , void const   * ))(& compare_parse));
        }
        }
      }
      {
      {
#line 1629
      print_time((char *)"Postprocessed some linkages");
      }
      }
#line 1631
      if (N_canonical_linkages == 0) {
#line 1632
        if (! (mc == 42)) {
#line 1632
          if (! (mc == 35)) {
#line 1633
            if (last_pass) {
#line 1634
              errors ++;
#line 1635
              if (! echo_on) {
                {
                {
#line 1636
                tmp___7 = stage_name(0, cost_cutoff, 0);
                }
                {
#line 1636
                printf((char const   */* __restrict  */)"--- No linkage for (%s): ",
                       tmp___7);
                }
                }
#line 1637
                if (echo_on) {
                  {
                  {
#line 1637
                  printf((char const   */* __restrict  */)"%c ", mc);
                  }
                  }
                }
                {
                {
#line 1638
                print_sentence(stdout, 13);
                }
                }
              } else {
                {
                {
#line 1640
                tmp___8 = stage_name(0, cost_cutoff, 0);
                }
                {
#line 1640
                printf((char const   */* __restrict  */)"--- No linkage for this (%s)\n",
                       tmp___8);
                }
                }
              }
            }
          }
        }
      } else
#line 1654
      if (N_valid_linkages == 0) {
#line 1655
        if (! (mc == 43)) {
#line 1655
          if (! (mc == 42)) {
#line 1656
            if (last_pass) {
#line 1657
              if (N_canonical_linkages == 1) {
                {
                {
#line 1658
                tmp___9 = stage_name(0, cost_cutoff, 0);
                }
                {
#line 1658
                printf((char const   */* __restrict  */)"--- unique linkage, with post-processing violation (%s)\n",
                       tmp___9);
                }
                }
              } else {
                {
                {
#line 1660
                printf((char const   */* __restrict  */)"--- %d linkages", N_canonical_linkages);
                }
                {
#line 1661
                printf((char const   */* __restrict  */)", all with post-processing violations");
                }
                {
#line 1662
                tmp___10 = stage_name(0, cost_cutoff, 0);
                }
                {
#line 1662
                printf((char const   */* __restrict  */)" (%s)\n", tmp___10);
                }
                }
              }
              {
#line 1664
              errors ++;
              {
#line 1665
              has_fatlinks = compute_linkage_arrays((linkage + 0)->index, 0);
              }
              {
#line 1667
              compute_chosen_words();
              }
              }
#line 1668
              if (has_fatlinks) {
                {
                {
#line 1669
                analyze_fat_linkage(1);
                }
                }
              } else {
                {
                {
#line 1671
                analyze_thin_linkage(1);
                }
                }
              }
            }
          }
        }
      } else
#line 1684
      if (mc == 43) {
#line 1684
        goto _L___1;
      } else
#line 1684
      if (mc == 42) {
#line 1684
        goto _L___1;
      } else
#line 1684
      if (mc == 35) {
        _L___1: /* CIL Label */ 
#line 1685
        errors ++;
#line 1686
        if (! echo_on) {
          {
          {
#line 1687
          tmp___11 = stage_name(0, cost_cutoff, 0);
          }
          {
#line 1687
          printf((char const   */* __restrict  */)"--- %s Input: ", tmp___11);
          }
          {
#line 1688
          printf((char const   */* __restrict  */)"%c ", mc);
          }
          {
#line 1689
          print_sentence(stdout, 13);
          }
          }
        } else {
          {
          {
#line 1691
          tmp___12 = stage_name(0, cost_cutoff, 0);
          }
          {
#line 1691
          printf((char const   */* __restrict  */)"--- Accepted %s:\n", tmp___12);
          }
          }
        }
        {
#line 1693
        last_pass = 1;
        {
#line 1694
        has_fatlinks = compute_linkage_arrays((linkage + 0)->index, 0);
        }
        {
#line 1695
        compute_chosen_words();
        }
        }
#line 1696
        if (has_fatlinks) {
          {
          {
#line 1697
          analyze_fat_linkage(1);
          }
          }
        } else {
          {
          {
#line 1699
          analyze_thin_linkage(1);
          }
          }
        }
      } else
#line 1701
      if ((int )(linkage + 0)->disjunct_cost == 0) {
#line 1701
        if (mc == 58) {
#line 1702
          errors ++;
#line 1703
          if (! echo_on) {
            {
            {
#line 1704
            tmp___13 = stage_name(0, cost_cutoff, 0);
            }
            {
#line 1704
            printf((char const   */* __restrict  */)"--- %s Input:  ", tmp___13);
            }
            {
#line 1705
            printf((char const   */* __restrict  */)"%c ", mc);
            }
            {
#line 1706
            print_sentence(stdout, 13);
            }
            }
          } else {
            {
            {
#line 1708
            tmp___14 = stage_name(0, cost_cutoff, 0);
            }
            {
#line 1708
            printf((char const   */* __restrict  */)"--- Accepted %s:\n", tmp___14);
            }
            }
          }
          {
#line 1710
          last_pass = 1;
          {
#line 1711
          printf((char const   */* __restrict  */)"p.p. violations: %d, disjunct cost: %d\n",
                 (int )(linkage + 0)->N_violations, (int )(linkage + 0)->disjunct_cost);
          }
          {
#line 1713
          has_fatlinks = compute_linkage_arrays((linkage + 0)->index, 0);
          }
          {
#line 1714
          compute_chosen_words();
          }
          }
#line 1715
          if (has_fatlinks) {
            {
            {
#line 1716
            analyze_fat_linkage(1);
            }
            }
          } else {
            {
            {
#line 1718
            analyze_thin_linkage(1);
            }
            }
          }
        } else {
#line 1701
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1720
      if (cost_cutoff == 1) {
#line 1720
        if (mc == 45) {
#line 1721
          errors ++;
#line 1722
          if (! echo_on) {
            {
            {
#line 1723
            tmp___15 = stage_name(0, cost_cutoff, 0);
            }
            {
#line 1723
            printf((char const   */* __restrict  */)"--- %s Input: ", tmp___15);
            }
            {
#line 1724
            printf((char const   */* __restrict  */)"%c ", mc);
            }
            {
#line 1725
            print_sentence(stdout, 13);
            }
            }
          } else {
            {
            {
#line 1727
            tmp___16 = stage_name(0, cost_cutoff, 0);
            }
            {
#line 1727
            printf((char const   */* __restrict  */)"--- Accepted %s:\n", tmp___16);
            }
            }
          }
          {
#line 1729
          last_pass = 1;
          {
#line 1730
          has_fatlinks = compute_linkage_arrays((linkage + 0)->index, 0);
          }
          {
#line 1731
          compute_chosen_words();
          }
          }
#line 1732
          if (has_fatlinks) {
            {
            {
#line 1733
            analyze_fat_linkage(1);
            }
            }
          } else {
            {
            {
#line 1735
            analyze_thin_linkage(1);
            }
            }
          }
        } else {
#line 1760
          last_pass = 1;
        }
      } else {
#line 1760
        last_pass = 1;
      }
#line 1763
      if (N_linkages != 0) {
        {
        {
#line 1764
        xfree((char *)linkage, (int )((unsigned long )N_linkages * sizeof(Linkage_info )));
        }
        }
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 1768
    fflush(stdout);
    }
    {
#line 1769
    print_time((char *)"Displayed linkages");
    }
    {
#line 1770
    unprepare_parse();
    }
    {
#line 1771
    final_unprepare_parse();
    }
    {
#line 1772
    print_time((char *)"Freed all data structures");
    }
    }
#line 1774
    if (verbosity > 2) {
      {
      {
#line 1774
      print_statistics();
      }
      }
    }
#line 1775
    if (space_in_use != 0) {
      {
      {
#line 1776
      printf((char const   */* __restrict  */)"Warning: %d bytes of space leaked.\n",
             space_in_use);
      }
      }
    }
    {
    {
#line 1778
    print_total_time();
    }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1780
  if (errors == 0) {
    {
    {
#line 1781
    printf((char const   */* __restrict  */)"No errors!\n");
    }
    }
  } else
#line 1782
  if (errors == 1) {
    {
    {
#line 1783
    printf((char const   */* __restrict  */)"One error.\n");
    }
    }
  } else {
    {
    {
#line 1785
    printf((char const   */* __restrict  */)"%d errors.\n", errors);
    }
    }
  }
#line 1787
  return;
}
}
#line 1789 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/main.c"
int main(int argc , char **argv ) 
{ 
  int batch ;
  int prob ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;

  {
  {
  {
#line 1794
  initialize_memory();
  }
#line 1795
  prob = 0;
#line 1796
  batch = 0;
#line 1797
  i = 2;
  }
  {
  {
#line 1797
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1797
    if (i < argc) {
#line 1797
      if (! (! prob)) {
#line 1797
        goto while_break;
      }
    } else {
#line 1797
      goto while_break;
    }
    {
    {
#line 1798
    tmp___5 = strcmp((char const   *)*(argv + i), "-wordlimit");
    }
    }
#line 1798
    if (tmp___5 == 0) {
#line 1799
      if (i == argc - 1) {
#line 1799
        tmp___0 = 1;
      } else {
        {
        {
#line 1799
        tmp = sscanf((char const   */* __restrict  */)*(argv + (i + 1)), (char const   */* __restrict  */)"%d",
                     & word_count_limit);
        }
        }
#line 1799
        if (tmp != 1) {
#line 1799
          tmp___0 = 1;
        } else {
#line 1799
          tmp___0 = 0;
        }
      }
#line 1799
      prob = tmp___0;
#line 1800
      i ++;
    } else {
      {
      {
#line 1801
      tmp___4 = strcmp((char const   *)*(argv + i), "-linklimit");
      }
      }
#line 1801
      if (tmp___4 == 0) {
#line 1802
        if (i == argc - 1) {
#line 1802
          tmp___2 = 1;
        } else {
          {
          {
#line 1802
          tmp___1 = sscanf((char const   */* __restrict  */)*(argv + (i + 1)), (char const   */* __restrict  */)"%d",
                           & linkage_count_limit);
          }
          }
#line 1802
          if (tmp___1 != 1) {
#line 1802
            tmp___2 = 1;
          } else {
#line 1802
            tmp___2 = 0;
          }
        }
#line 1802
        prob = tmp___2;
#line 1803
        i ++;
      } else {
        {
        {
#line 1804
        tmp___3 = strcmp((char const   *)*(argv + i), "-batch");
        }
        }
#line 1804
        if (tmp___3 == 0) {
#line 1805
          batch = 1;
        }
      }
    }
#line 1797
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1808
  if (argc < 2) {
    {
    {
#line 1809
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s dictionary-file [-batch] [-wordlimit number] [-linklimit number]\n",
            *(argv + 0));
    }
    {
#line 1810
    exit(1);
    }
    }
  } else
#line 1808
  if (prob) {
    {
    {
#line 1809
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s dictionary-file [-batch] [-wordlimit number] [-linklimit number]\n",
            *(argv + 0));
    }
    {
#line 1810
    exit(1);
    }
    }
  }
  {
  {
#line 1813
  open_dictionary(*(argv + 1));
  }
  {
#line 1814
  printf((char const   */* __restrict  */)"\n Reading the dictionary files: ");
  }
  {
#line 1815
  read_dictionary();
  }
  {
#line 1817
  printf((char const   */* __restrict  */)"\n %d words stored in %d bytes\n\n\n",
         N_dict, space_in_use);
  }
  {
#line 1822
  printf((char const   */* __restrict  */)"Welcome to the Link Parser -- Version 2.1\n\n");
  }
  {
#line 1823
  printf((char const   */* __restrict  */)"          ");
  }
  {
#line 1824
  printf((char const   */* __restrict  */)"Copyright (C) 1991-1995 Daniel Sleator and Davy Temperley\n\n");
  }
  {
#line 1826
  init_randtable();
  }
  {
#line 1828
  left_wall_defined = boolean_dictionary_lookup((char *)"LEFT-WALL");
  }
  {
#line 1829
  right_wall_defined = boolean_dictionary_lookup((char *)"RIGHT-WALL");
  }
  {
#line 1830
  postprocess_defined = boolean_dictionary_lookup((char *)"POSTPROCESS");
  }
  {
#line 1831
  andable_defined = boolean_dictionary_lookup((char *)"ANDABLE-CONNECTORS");
  }
  {
#line 1832
  unknown_word_defined = boolean_dictionary_lookup((char *)"UNKNOWN-WORD");
  }
  {
#line 1833
  capitalized_word_defined = boolean_dictionary_lookup((char *)"CAPITALIZED-WORDS");
  }
  }
#line 1835
  if (andable_defined) {
    {
    {
#line 1836
    init_andable_hash_table();
    }
    }
  }
#line 1839
  if (batch) {
    {
    {
#line 1840
    printf((char const   */* __restrict  */)"Processing sentences in batch mode\n");
    }
    {
#line 1841
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 1842
    batch_process();
    }
    }
  } else {
    {
    {
#line 1844
    printf((char const   */* __restrict  */)"Type your sentence and press Return ");
    }
    {
#line 1845
    printf((char const   */* __restrict  */)"(\"!help\" for options).\n");
    }
    {
#line 1846
    printf((char const   */* __restrict  */)"\n");
    }
    {
#line 1847
    loop();
    }
    }
  }
#line 1849
  return (0);
}
}
#line 12 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
int contains_underbar(char *s ) 
{ 


  {
  {
  {
#line 15
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 15
    if (! ((int )*s != 0)) {
#line 15
      goto while_break;
    }
#line 16
    if ((int )*s == 95) {
#line 16
      return (1);
    }
#line 17
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 19
  return (0);
}
}
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
int is_idiom_string(char *s ) 
{ 
  char *t ;
  size_t tmp ;

  {
#line 29
  t = s;
  {
  {
#line 29
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 29
    if (! ((int )*t != 0)) {
#line 29
      goto while_break;
    }
#line 30
    if ((int )*t == 46) {
#line 31
      return (0);
    }
#line 29
    t ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 34
  if ((int )*(s + 0) == 95) {
#line 35
    return (0);
  } else {
    {
    {
#line 34
    tmp = strlen((char const   *)s);
    }
    }
#line 34
    if ((int )*(s + (tmp - 1U)) == 95) {
#line 35
      return (0);
    }
  }
#line 37
  t = s;
  {
  {
#line 37
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 37
    if (! ((int )*t != 0)) {
#line 37
      goto while_break___0;
    }
#line 38
    if ((int )*t == 95) {
#line 38
      if ((int )*(t + 1) == 95) {
#line 39
        return (0);
      }
    }
#line 37
    t ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 42
  return (1);
}
}
#line 45 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
int is_number(char *s ) 
{ 
  unsigned short const   **tmp ;

  {
  {
  {
#line 47
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 47
    if (! ((int )*s != 0)) {
#line 47
      goto while_break;
    }
    {
    {
#line 48
    tmp = __ctype_b_loc();
    }
    }
#line 48
    if (! ((int const   )*(*tmp + (int )*s) & 2048)) {
#line 48
      return (0);
    }
#line 49
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 51
  return (1);
}
}
#line 54 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
int numberfy(char *s ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 58
    if ((int )*s != 0) {
#line 58
      if (! ((int )*s != 46)) {
#line 58
        goto while_break;
      }
    } else {
#line 58
      goto while_break;
    }
#line 58
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 60
  tmp = s;
#line 60
  s ++;
#line 60
  if ((int )*tmp != 46) {
#line 60
    return (-1);
  }
#line 61
  tmp___0 = s;
#line 61
  s ++;
#line 61
  if ((int )*tmp___0 != 73) {
#line 61
    return (-1);
  }
  {
  {
#line 62
  tmp___1 = is_number(s);
  }
  }
#line 62
  if (! tmp___1) {
#line 62
    return (-1);
  }
  {
  {
#line 63
  tmp___2 = atoi((char const   *)s);
  }
  }
#line 63
  return (tmp___2);
}
}
#line 66 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
int max_postfix_found(Dict_node *d ) 
{ 
  int i ;
  int j ;

  {
#line 71
  i = 0;
  {
  {
#line 72
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 72
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 72
      goto while_break;
    }
    {
    {
#line 73
    j = numberfy(d->string);
    }
    }
#line 74
    if (j > i) {
#line 74
      i = j;
    }
#line 75
    d = d->right;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 77
  return (i);
}
}
#line 80 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
char *build_idiom_word_name(char *s ) 
{ 
  char *new_s ;
  char *x ;
  int count___0 ;
  Dict_node *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *__cil_tmp9 ;

  {
  {
  {
#line 89
  tmp = dictionary_lookup(s);
  }
  {
#line 89
  tmp___0 = max_postfix_found(tmp);
  }
#line 89
  count___0 = tmp___0 + 1;
  {
#line 90
  tmp___1 = strlen((char const   *)s);
  }
  {
#line 90
  tmp___2 = xalloc((int )(tmp___1 + 10U));
  }
#line 90
  x = (char *)tmp___2;
#line 90
  new_s = x;
  }
  {
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 91
    if ((int )*s != 0) {
#line 91
      if (! ((int )*s != 46)) {
#line 91
        goto while_break;
      }
    } else {
#line 91
      goto while_break;
    }
#line 92
    *x = *s;
#line 93
    x ++;
#line 94
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 96
  sprintf((char */* __restrict  */)x, (char const   */* __restrict  */)".I%d", count___0);
  }
  }
#line 97
  return (new_s);
}
}
#line 100 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
Dict_node *make_idiom_Dict_nodes(char *s ) 
{ 
  Dict_node *dn ;
  Dict_node *dn_new ;
  char *t ;
  int more ;
  void *tmp ;

  {
#line 113
  dn = (Dict_node *)((void *)0);
  {
  {
#line 114
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 114
    if (! ((int )*s != 0)) {
#line 114
      goto while_break;
    }
#line 115
    t = s;
    {
    {
#line 116
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 116
      if ((int )*s != 0) {
#line 116
        if (! ((int )*s != 95)) {
#line 116
          goto while_break___0;
        }
      } else {
#line 116
        goto while_break___0;
      }
#line 116
      s ++;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 117
    if ((int )*s == 95) {
#line 118
      more = 1;
#line 119
      *s = (char )'\000';
    } else {
#line 121
      more = 0;
    }
    {
    {
#line 123
    tmp = xalloc((int )sizeof(Dict_node ));
    }
#line 123
    dn_new = (Dict_node *)tmp;
#line 124
    dn_new->right = dn;
#line 125
    dn = dn_new;
#line 126
    dn->string = t;
#line 127
    dn->file = (Word_file *)((void *)0);
    }
#line 128
    if (more) {
#line 128
      s ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 130
  return (dn);
}
}
#line 133 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
static char current_name[9]  = 
#line 133
  {      (char )'A',      (char )'A',      (char )'A',      (char )'A', 
        (char )'A',      (char )'A',      (char )'A',      (char )'A', 
        (char )'\000'};
#line 136 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
void increment_current_name(void) 
{ 
  int i ;
  int carry ;

  {
#line 138
  i = (int )((sizeof(current_name) - 1UL) - 1UL);
#line 139
  carry = 1;
  {
  {
#line 140
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 140
    if (! (carry == 1)) {
#line 140
      goto while_break;
    }
#line 141
    current_name[i] = (char )((int )current_name[i] + 1);
#line 142
    if ((int )current_name[i] == 91) {
#line 143
      current_name[i] = (char )'A';
#line 144
      carry = 1;
    } else {
#line 146
      carry = 0;
    }
#line 148
    i --;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 150
  return;
}
}
#line 152 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
char *generate_id_connector(void) 
{ 
  unsigned int i ;
  char *t ;
  char *s ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;

  {
#line 161
  i = 0U;
  {
  {
#line 161
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 161
    if (! ((int )current_name[i] == 65)) {
#line 161
      goto while_break;
    }
#line 161
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 164
  tmp = xalloc((int )(((((sizeof(current_name) - 1UL) - (unsigned long )i) + 2UL) + 1UL) + 1UL));
  }
#line 164
  t = (char *)tmp;
#line 164
  s = t;
#line 165
  tmp___0 = t;
#line 165
  t ++;
#line 165
  *tmp___0 = (char )'I';
#line 166
  tmp___1 = t;
#line 166
  t ++;
#line 166
  *tmp___1 = (char )'D';
  }
  {
  {
#line 167
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 167
    if (! ((unsigned long )i < sizeof(current_name) - 1UL)) {
#line 167
      goto while_break___0;
    }
#line 168
    tmp___2 = t;
#line 168
    t ++;
#line 168
    *tmp___2 = current_name[i];
#line 167
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 170
  tmp___3 = t;
#line 170
  t ++;
#line 170
  *tmp___3 = (char )'\000';
#line 171
  return (s);
}
}
#line 174 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
void insert_idiom(Dict_node *dn ) 
{ 
  Exp *nc ;
  Exp *no ;
  Exp *n1 ;
  E_list *ell ;
  E_list *elr ;
  char *s ;
  int s_length ;
  Dict_node *dn_list ;
  Dict_node *xdn ;
  Dict_node *start_dn_list ;
  size_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  void *tmp___11 ;
  void *tmp___12 ;
  Exp *tmp___13 ;
  Dict_node *tmp___14 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;

  {
  {
#line 190
  no = dn->exp;
#line 191
  s = dn->string;
  {
#line 192
  tmp = strlen((char const   *)s);
  }
#line 192
  s_length = (int )tmp;
  {
#line 194
  tmp___0 = is_idiom_string(s);
  }
  }
#line 194
  if (! tmp___0) {
    {
    {
#line 195
    printf((char const   */* __restrict  */)"*** Word \"%s\" on line %d is not", s,
           line_number);
    }
    {
#line 196
    printf((char const   */* __restrict  */)" a correctly formed idiom string.\n");
    }
    {
#line 197
    printf((char const   */* __restrict  */)"    This word will be ignored\n");
    }
    {
#line 198
    xfree(s, s_length + 1);
    }
    {
#line 199
    xfree((char *)dn, (int )sizeof(Dict_node ));
    }
    }
#line 200
    return;
  }
  {
  {
#line 203
  start_dn_list = make_idiom_Dict_nodes(s);
  }
#line 203
  dn_list = start_dn_list;
  {
#line 204
  xfree((char *)dn, (int )sizeof(Dict_node ));
  }
  }
#line 206
  if ((unsigned long )dn_list->right == (unsigned long )((void *)0)) {
    {
    {
#line 207
    error((char *)"Idiom string with only one connector -- should have been caught");
    }
    }
  }
  {
  {
#line 214
  tmp___1 = xalloc((int )sizeof(Exp ));
  }
#line 214
  nc = (Exp *)tmp___1;
  {
#line 215
  nc->u.string = generate_id_connector();
  }
#line 216
  nc->dir = (char )'-';
#line 217
  nc->multi = (char)0;
#line 218
  nc->type = (char)2;
#line 219
  nc->cost = (unsigned char)0;
  {
#line 221
  tmp___2 = xalloc((int )sizeof(Exp ));
  }
#line 221
  n1 = (Exp *)tmp___2;
  {
#line 222
  tmp___3 = xalloc((int )sizeof(E_list ));
  }
#line 222
  ell = (E_list *)tmp___3;
#line 222
  n1->u.l = ell;
  {
#line 223
  tmp___4 = xalloc((int )sizeof(E_list ));
  }
#line 223
  elr = (E_list *)tmp___4;
#line 223
  ell->next = elr;
#line 224
  elr->next = (E_list *)((void *)0);
#line 225
  ell->e = nc;
#line 226
  elr->e = no;
#line 227
  n1->type = (char)1;
#line 228
  n1->cost = (unsigned char)0;
#line 230
  dn_list->exp = n1;
#line 232
  dn_list = dn_list->right;
  }
  {
  {
#line 234
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 234
    if (! ((unsigned long )dn_list->right != (unsigned long )((void *)0))) {
#line 234
      goto while_break;
    }
    {
    {
#line 237
    tmp___5 = xalloc((int )sizeof(Exp ));
    }
#line 237
    n1 = (Exp *)tmp___5;
#line 238
    n1->u.string = (char *)((void *)0);
#line 239
    n1->type = (char)1;
#line 240
    n1->cost = (unsigned char)0;
    {
#line 241
    tmp___6 = xalloc((int )sizeof(E_list ));
    }
#line 241
    ell = (E_list *)tmp___6;
#line 241
    n1->u.l = ell;
    {
#line 242
    tmp___7 = xalloc((int )sizeof(E_list ));
    }
#line 242
    elr = (E_list *)tmp___7;
#line 242
    ell->next = elr;
#line 243
    elr->next = (E_list *)((void *)0);
    {
#line 245
    tmp___8 = xalloc((int )sizeof(Exp ));
    }
#line 245
    nc = (Exp *)tmp___8;
    {
#line 246
    nc->u.string = generate_id_connector();
    }
#line 247
    nc->dir = (char )'+';
#line 248
    nc->multi = (char)0;
#line 249
    nc->type = (char)2;
#line 250
    nc->cost = (unsigned char)0;
#line 251
    elr->e = nc;
    {
#line 253
    increment_current_name();
    }
    {
#line 255
    tmp___9 = xalloc((int )sizeof(Exp ));
    }
#line 255
    nc = (Exp *)tmp___9;
    {
#line 256
    nc->u.string = generate_id_connector();
    }
#line 257
    nc->dir = (char )'-';
#line 258
    nc->multi = (char)0;
#line 259
    nc->type = (char)2;
#line 260
    nc->cost = (unsigned char)0;
#line 262
    ell->e = nc;
#line 264
    dn_list->exp = n1;
#line 266
    dn_list = dn_list->right;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 270
  tmp___10 = xalloc((int )sizeof(Exp ));
  }
#line 270
  nc = (Exp *)tmp___10;
  {
#line 271
  tmp___11 = xalloc((int )sizeof(E_list ));
  }
#line 271
  ell = (E_list *)tmp___11;
#line 271
  nc->u.l = ell;
  {
#line 272
  tmp___12 = xalloc((int )sizeof(E_list ));
  }
#line 272
  elr = (E_list *)tmp___12;
#line 272
  ell->next = elr;
#line 273
  elr->next = (E_list *)((void *)0);
#line 274
  tmp___13 = (Exp *)((void *)0);
#line 274
  elr->e = tmp___13;
#line 274
  ell->e = tmp___13;
  {
#line 275
  nc->u.string = generate_id_connector();
  }
#line 276
  nc->dir = (char )'+';
#line 277
  nc->multi = (char)0;
#line 278
  nc->type = (char)2;
#line 279
  nc->cost = (unsigned char)0;
#line 281
  dn_list->exp = nc;
  {
#line 283
  increment_current_name();
  }
#line 289
  dn_list = start_dn_list;
  }
  {
  {
#line 291
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 291
    if (! ((unsigned long )dn_list != (unsigned long )((void *)0))) {
#line 291
      goto while_break___0;
    }
    {
#line 292
    xdn = dn_list->right;
#line 293
    tmp___14 = (Dict_node *)((void *)0);
#line 293
    dn_list->right = tmp___14;
#line 293
    dn_list->left = tmp___14;
    {
#line 294
    dn_list->string = build_idiom_word_name(dn_list->string);
    }
    {
#line 295
    dict_root = insert_dict(dict_root, dn_list);
    }
#line 296
    N_dict ++;
#line 297
    dn_list = xdn;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 299
  xfree(s, s_length + 1);
  }
  }
#line 300
  return;
}
}
#line 302 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/idiom.c"
int is_idiom_word(char *s ) 
{ 
  int tmp ;

  {
  {
  {
#line 304
  tmp = numberfy(s);
  }
  }
#line 304
  return (tmp != -1);
}
}
#line 12 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
static int match_cost  ;
#line 14 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
int left_disjunct_list_length(Disjunct *d ) 
{ 
  int i ;

  {
#line 18
  i = 0;
  {
  {
#line 18
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 18
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 18
      goto while_break;
    }
#line 19
    if ((unsigned long )d->left != (unsigned long )((void *)0)) {
#line 19
      i ++;
    }
#line 18
    d = d->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 21
  return (i);
}
}
#line 23 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
int right_disjunct_list_length(Disjunct *d ) 
{ 
  int i ;

  {
#line 25
  i = 0;
  {
  {
#line 25
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 25
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 25
      goto while_break;
    }
#line 26
    if ((unsigned long )d->right != (unsigned long )((void *)0)) {
#line 26
      i ++;
    }
#line 25
    d = d->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 28
  return (i);
}
}
#line 31 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
static int l_table_size___0[250]  ;
#line 32 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
static int r_table_size___0[250]  ;
#line 34 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
static Match_node **l_table___0[250]  ;
#line 36 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
static Match_node **r_table___0[250]  ;
#line 38 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
static Match_node *mn_free_list  =    (Match_node *)((void *)0);
#line 41 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
Match_node *get_match_node(void) 
{ 
  Match_node *m ;
  void *tmp ;

  {
#line 44
  if ((unsigned long )mn_free_list != (unsigned long )((void *)0)) {
#line 45
    m = mn_free_list;
#line 46
    mn_free_list = m->next;
  } else {
    {
    {
#line 48
    tmp = xalloc((int )sizeof(Match_node ));
    }
#line 48
    m = (Match_node *)tmp;
    }
  }
#line 50
  return (m);
}
}
#line 53 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
void put_match_list(Match_node *m ) 
{ 
  Match_node *xm ;

  {
  {
  {
#line 56
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 56
      goto while_break;
    }
#line 57
    xm = m->next;
#line 58
    m->next = mn_free_list;
#line 59
    mn_free_list = m;
#line 56
    m = xm;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 61
  return;
}
}
#line 63 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
void free_match_list(Match_node *t ) 
{ 
  Match_node *xt ;

  {
  {
  {
#line 65
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 65
    if (! ((unsigned long )t != (unsigned long )((void *)0))) {
#line 65
      goto while_break;
    }
    {
#line 66
    xt = t->next;
    {
#line 67
    xfree((char *)t, (int )sizeof(Match_node ));
    }
#line 65
    t = xt;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 71 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
void free_fast_matcher(void) 
{ 
  int w ;
  int i ;
  char *__cil_tmp3 ;

  {
#line 75
  if (verbosity > 1) {
    {
    {
#line 75
    printf((char const   */* __restrict  */)"%d Match cost\n", match_cost);
    }
    }
  }
#line 76
  w = 0;
  {
  {
#line 76
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 76
    if (! (w < N_words)) {
#line 76
      goto while_break;
    }
#line 77
    i = 0;
    {
    {
#line 77
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 77
      if (! (i < l_table_size___0[w])) {
#line 77
        goto while_break___0;
      }
      {
      {
#line 78
      free_match_list(*(l_table___0[w] + i));
      }
#line 77
      i ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 80
    xfree((char *)l_table___0[w], (int )((unsigned long )l_table_size___0[w] * sizeof(Match_node *)));
    }
#line 81
    i = 0;
    }
    {
    {
#line 81
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 81
      if (! (i < r_table_size___0[w])) {
#line 81
        goto while_break___1;
      }
      {
      {
#line 82
      free_match_list(*(r_table___0[w] + i));
      }
#line 81
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 84
    xfree((char *)r_table___0[w], (int )((unsigned long )r_table_size___0[w] * sizeof(Match_node *)));
    }
#line 76
    w ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 86
  free_match_list(mn_free_list);
  }
#line 87
  mn_free_list = (Match_node *)((void *)0);
  }
#line 88
  return;
}
}
#line 90 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
int fast_match_hash(Connector *c ) 
{ 
  char *s ;
  int i ;
  unsigned short const   **tmp ;

  {
#line 98
  i = (int )randtable[(int )c->label & 255];
#line 99
  s = c->string;
  {
  {
#line 100
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 100
    tmp = __ctype_b_loc();
    }
    }
#line 100
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
#line 100
      goto while_break;
    }
#line 101
    i = (int )((unsigned int )(i + (i << 1)) + randtable[((int )*s + i) & 255]);
#line 102
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  return (i);
}
}
#line 107 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
Match_node *add_to_right_table_list(Match_node *m , Match_node *l ) 
{ 


  {
#line 112
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 112
    return (m);
  }
#line 113
  if ((int )((m->d)->right)->word <= (int )((l->d)->right)->word) {
#line 114
    m->next = l;
#line 115
    return (m);
  } else {
    {
    {
#line 117
    l->next = add_to_right_table_list(m, l->next);
    }
    }
#line 118
    return (l);
  }
}
}
#line 122 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
Match_node *add_to_left_table_list(Match_node *m , Match_node *l ) 
{ 


  {
#line 127
  if ((unsigned long )l == (unsigned long )((void *)0)) {
#line 127
    return (m);
  }
#line 128
  if ((int )((m->d)->left)->word >= (int )((l->d)->left)->word) {
#line 129
    m->next = l;
#line 130
    return (m);
  } else {
    {
    {
#line 132
    l->next = add_to_left_table_list(m, l->next);
    }
    }
#line 133
    return (l);
  }
}
}
#line 137 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
void put_into_match_table(int size , Match_node **t , Disjunct *d , Connector *c ,
                          int dir ) 
{ 
  int h ;
  Match_node *m ;
  int tmp ;
  void *tmp___0 ;

  {
  {
  {
#line 146
  tmp = fast_match_hash(c);
  }
#line 146
  h = tmp & (size - 1);
  {
#line 147
  tmp___0 = xalloc((int )sizeof(Match_node ));
  }
#line 147
  m = (Match_node *)tmp___0;
#line 148
  m->next = (Match_node *)((void *)0);
#line 149
  m->d = d;
  }
#line 150
  if (dir == 1) {
    {
    {
#line 151
    *(t + h) = add_to_right_table_list(m, *(t + h));
    }
    }
  } else {
    {
    {
#line 153
    *(t + h) = add_to_left_table_list(m, *(t + h));
    }
    }
  }
#line 155
  return;
}
}
#line 157 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
void init_fast_matcher(void) 
{ 
  int w ;
  int len ;
  int size ;
  int i ;
  Match_node **t ;
  Disjunct *d ;
  Match_node **tmp ;
  void *tmp___0 ;
  Match_node **tmp___1 ;
  void *tmp___2 ;

  {
#line 161
  match_cost = 0;
#line 162
  w = 0;
  {
  {
#line 162
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 162
    if (! (w < N_words)) {
#line 162
      goto while_break;
    }
    {
    {
#line 163
    len = left_disjunct_list_length(sentence[w].d);
    }
    {
#line 164
    size = next_power_of_two_up(len);
    }
#line 165
    l_table_size___0[w] = size;
    {
#line 166
    tmp___0 = xalloc((int )((unsigned long )size * sizeof(Match_node *)));
    }
#line 166
    tmp = (Match_node **)tmp___0;
#line 166
    l_table___0[w] = tmp;
#line 166
    t = tmp;
#line 167
    i = 0;
    }
    {
    {
#line 167
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 167
      if (! (i < size)) {
#line 167
        goto while_break___0;
      }
#line 167
      *(t + i) = (Match_node *)((void *)0);
#line 167
      i ++;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 169
    d = sentence[w].d;
    {
    {
#line 169
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 169
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 169
        goto while_break___1;
      }
#line 170
      if ((unsigned long )d->left != (unsigned long )((void *)0)) {
        {
        {
#line 171
        put_into_match_table(size, t, d, d->left, -1);
        }
        }
      }
#line 169
      d = d->next;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 175
    len = right_disjunct_list_length(sentence[w].d);
    }
    {
#line 176
    size = next_power_of_two_up(len);
    }
#line 177
    r_table_size___0[w] = size;
    {
#line 178
    tmp___2 = xalloc((int )((unsigned long )size * sizeof(Match_node *)));
    }
#line 178
    tmp___1 = (Match_node **)tmp___2;
#line 178
    r_table___0[w] = tmp___1;
#line 178
    t = tmp___1;
#line 179
    i = 0;
    }
    {
    {
#line 179
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 179
      if (! (i < size)) {
#line 179
        goto while_break___2;
      }
#line 179
      *(t + i) = (Match_node *)((void *)0);
#line 179
      i ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 181
    d = sentence[w].d;
    {
    {
#line 181
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 181
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 181
        goto while_break___3;
      }
#line 182
      if ((unsigned long )d->right != (unsigned long )((void *)0)) {
        {
        {
#line 183
        put_into_match_table(size, t, d, d->right, 1);
        }
        }
      }
#line 181
      d = d->next;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 162
    w ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 189 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/fast-match.c"
Match_node *form_match_list(int w , Connector *lc , int lw , Connector *rc , int rw ) 
{ 
  Match_node *ml ;
  Match_node *mr ;
  Match_node *mx ;
  Match_node *my ;
  Match_node *mz ;
  Match_node *front ;
  Match_node *free_later ;
  int tmp ;
  int tmp___0 ;

  {
#line 201
  if ((unsigned long )lc != (unsigned long )((void *)0)) {
    {
    {
#line 202
    tmp = fast_match_hash(lc);
    }
#line 202
    ml = *(l_table___0[w] + (tmp & (l_table_size___0[w] - 1)));
    }
  } else {
#line 204
    ml = (Match_node *)((void *)0);
  }
#line 206
  if ((unsigned long )rc != (unsigned long )((void *)0)) {
    {
    {
#line 207
    tmp___0 = fast_match_hash(rc);
    }
#line 207
    mr = *(r_table___0[w] + (tmp___0 & (r_table_size___0[w] - 1)));
    }
  } else {
#line 209
    mr = (Match_node *)((void *)0);
  }
#line 212
  front = (Match_node *)((void *)0);
#line 213
  mx = ml;
  {
  {
#line 213
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 213
    if (! ((unsigned long )mx != (unsigned long )((void *)0))) {
#line 213
      goto while_break;
    }
#line 214
    if ((int )((mx->d)->left)->word < lw) {
#line 214
      goto while_break;
    }
    {
    {
#line 215
    my = get_match_node();
    }
#line 216
    my->d = mx->d;
#line 217
    my->next = front;
#line 218
    front = my;
#line 213
    mx = mx->next;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 220
  ml = front;
#line 222
  front = (Match_node *)((void *)0);
#line 223
  mx = mr;
  {
  {
#line 223
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )mx != (unsigned long )((void *)0))) {
#line 223
      goto while_break___0;
    }
#line 224
    if ((int )((mx->d)->right)->word > rw) {
#line 224
      goto while_break___0;
    }
    {
    {
#line 225
    my = get_match_node();
    }
#line 226
    my->d = mx->d;
#line 227
    my->next = front;
#line 228
    front = my;
#line 223
    mx = mx->next;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 230
  mr = front;
#line 234
  free_later = (Match_node *)((void *)0);
#line 235
  front = (Match_node *)((void *)0);
#line 236
  mx = mr;
  {
  {
#line 236
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 236
    if (! ((unsigned long )mx != (unsigned long )((void *)0))) {
#line 236
      goto while_break___1;
    }
#line 238
    mz = mx->next;
#line 239
    match_cost ++;
#line 240
    my = ml;
    {
    {
#line 240
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 240
      if (! ((unsigned long )my != (unsigned long )((void *)0))) {
#line 240
        goto while_break___2;
      }
#line 241
      match_cost ++;
#line 242
      if ((unsigned long )mx->d == (unsigned long )my->d) {
#line 242
        goto while_break___2;
      }
#line 240
      my = my->next;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 244
    if ((unsigned long )my != (unsigned long )((void *)0)) {
#line 245
      mx->next = free_later;
#line 246
      free_later = mx;
    }
#line 248
    if ((unsigned long )my == (unsigned long )((void *)0)) {
#line 249
      mx->next = front;
#line 250
      front = mx;
    }
#line 236
    mx = mz;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 253
  mr = front;
  {
#line 254
  put_match_list(free_later);
  }
  }
#line 257
  if ((unsigned long )mr == (unsigned long )((void *)0)) {
#line 257
    return (ml);
  }
#line 258
  mx = mr;
  {
  {
#line 258
  while (1) {
    while_continue___8: /* CIL Label */ ;
    while_continue___3: /* CIL Label */ ;
#line 258
    if (! ((unsigned long )mx->next != (unsigned long )((void *)0))) {
#line 258
      goto while_break___3;
    }
#line 258
    mx = mx->next;
  }
  while_break___8: /* CIL Label */ ;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 260
  mx->next = ml;
#line 261
  return (mr);
}
}
#line 349 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
Link link_array[497]  ;
#line 351 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int N_links  ;
#line 353 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
Disjunct *chosen_disjuncts[250]  ;
#line 15 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/extract-links.c"
char forgiving  ;
#line 22 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/extract-links.c"
void issue_link(Disjunct *ld , Disjunct *rd , int lw , int rw , Connector *lc , Connector *rc ) 
{ 


  {
#line 24
  link_array[N_links].l = lw;
#line 25
  link_array[N_links].r = rw;
#line 26
  link_array[N_links].lc = lc;
#line 27
  link_array[N_links].rc = rc;
#line 28
  N_links ++;
#line 30
  chosen_disjuncts[lw] = ld;
#line 31
  chosen_disjuncts[rw] = rd;
#line 32
  return;
}
}
#line 34 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/extract-links.c"
int magic(int lw , int rw , Connector *le , Connector *re , int cost ) 
{ 
  int count___0 ;

  {
#line 46
  if (cost < 0) {
#line 46
    return (0);
  }
  {
  {
#line 48
  count___0 = table_lookup(lw, rw, le, re, cost);
  }
  }
#line 49
  if (count___0 < 0) {
#line 49
    return (0);
  } else {
#line 49
    return (count___0);
  }
}
}
#line 52 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/extract-links.c"
void list_links(Disjunct *ld , Disjunct *rd , int lw , int rw , Connector *le , Connector *re ,
                int cost , int index___0 ) 
{ 
  Disjunct *d ;
  int leftcount ;
  int rightcount ;
  int total ;
  int i ;
  int x ;
  int delta ;
  int lml ;
  int lmr ;
  int rml ;
  int rmr ;
  int lc ;
  int rc ;
  int lindex ;
  int rindex___0 ;
  int lcost ;
  int rcost ;
  int w ;
  int start_word ;
  int end_word ;
  Match_node *m ;
  Match_node *m1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  char *__cil_tmp41 ;
  char *__cil_tmp42 ;
  char *__cil_tmp43 ;
  char *__cil_tmp44 ;
  char *__cil_tmp45 ;
  char *__cil_tmp46 ;

  {
#line 57
  lml = 0;
#line 57
  lmr = 0;
#line 57
  rml = 0;
#line 57
  rmr = 0;
#line 63
  if (rw == 1 + lw) {
#line 64
    if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 64
      if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 64
        if (! (index___0 == 0)) {
          {
          {
#line 64
          printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Error encountered while extracting links.");
          }
          {
#line 64
          exit(1);
          }
          }
        }
      } else {
        {
        {
#line 64
        printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Error encountered while extracting links.");
        }
        {
#line 64
        exit(1);
        }
        }
      }
    } else {
      {
      {
#line 64
      printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Error encountered while extracting links.");
      }
      {
#line 64
      exit(1);
      }
      }
    }
#line 66
    return;
  }
#line 69
  if (cost < 0) {
#line 69
    return;
  }
#line 71
  if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 71
    if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 72
      total = 0;
#line 73
      w = lw + 1;
#line 74
      d = sentence[w].d;
      {
      {
#line 74
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 74
        if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 74
          goto while_break;
        }
#line 75
        if ((unsigned long )d->left == (unsigned long )((void *)0)) {
          {
          {
#line 76
          i = magic(w, rw, d->right, re, cost - 1);
          }
#line 77
          total += i;
          }
#line 78
          if (total - i <= index___0) {
#line 78
            if (total > index___0) {
              {
              {
#line 79
              list_links(d, rd, w, rw, d->right, re, cost - 1, (index___0 - total) + i);
              }
              }
            }
          }
        }
#line 74
        d = d->next;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 83
      i = magic(w, rw, (Connector *)((void *)0), (Connector *)((void *)0), cost - 1);
      }
#line 84
      total += i;
      }
#line 85
      if (total - i <= index___0) {
#line 85
        if (total > index___0) {
          {
          {
#line 86
          list_links((Disjunct *)((void *)0), rd, w, rw, (Connector *)((void *)0),
                     re, cost - 1, (index___0 - total) + i);
          }
          }
        }
      }
#line 88
      return;
    }
  }
#line 92
  total = 0;
#line 93
  if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 94
    start_word = lw + 1;
  } else {
#line 96
    start_word = (int )le->word;
  }
#line 98
  if ((unsigned long )re == (unsigned long )((void *)0)) {
#line 99
    if (rw - 1 < lw + maxlinklength) {
#line 99
      end_word = rw - 1;
    } else {
#line 99
      end_word = lw + maxlinklength;
    }
  } else {
#line 101
    end_word = (int )re->word;
  }
#line 104
  w = start_word;
  {
  {
#line 104
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 104
    if (! (w <= end_word)) {
#line 104
      goto while_break___0;
    }
    {
    {
#line 105
    m = form_match_list(w, le, lw, re, rw);
    }
#line 105
    m1 = m;
    }
    {
    {
#line 106
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 106
      if (! ((unsigned long )m != (unsigned long )((void *)0))) {
#line 106
        goto while_break___1;
      }
#line 107
      d = m->d;
#line 108
      lcost = 0;
      {
      {
#line 108
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 108
        if (! (lcost <= cost)) {
#line 108
          goto while_break___2;
        }
#line 109
        rcost = cost - lcost;
#line 111
        if ((unsigned long )le != (unsigned long )((void *)0)) {
#line 111
          if ((unsigned long )d->left != (unsigned long )((void *)0)) {
            {
            {
#line 111
            tmp___2 = match(le, d->left);
            }
            }
#line 111
            if (tmp___2) {
              {
#line 112
              lml = (int )le->multi;
#line 113
              lmr = (int )(d->left)->multi;
              {
#line 114
              leftcount = magic(lw, w, le->next, (d->left)->next, lcost);
              }
              }
#line 115
              if (lml) {
                {
                {
#line 115
                tmp = magic(lw, w, le, (d->left)->next, lcost);
                }
#line 115
                leftcount += tmp;
                }
              }
#line 116
              if (lmr) {
                {
                {
#line 116
                tmp___0 = magic(lw, w, le->next, d->left, lcost);
                }
#line 116
                leftcount += tmp___0;
                }
              }
#line 117
              if (lml) {
#line 117
                if (lmr) {
                  {
                  {
#line 117
                  tmp___1 = magic(lw, w, le, d->left, lcost);
                  }
#line 117
                  leftcount += tmp___1;
                  }
                }
              }
            } else {
#line 119
              leftcount = 0;
            }
          } else {
#line 119
            leftcount = 0;
          }
        } else {
#line 119
          leftcount = 0;
        }
#line 121
        if ((unsigned long )d->right != (unsigned long )((void *)0)) {
#line 121
          if ((unsigned long )re != (unsigned long )((void *)0)) {
            {
            {
#line 121
            tmp___6 = match(d->right, re);
            }
            }
#line 121
            if (tmp___6) {
              {
#line 122
              rml = (int )(d->right)->multi;
#line 123
              rmr = (int )re->multi;
              {
#line 124
              rightcount = magic(w, rw, (d->right)->next, re->next, rcost);
              }
              }
#line 125
              if (rml) {
                {
                {
#line 125
                tmp___3 = magic(w, rw, d->right, re->next, rcost);
                }
#line 125
                rightcount += tmp___3;
                }
              }
#line 126
              if (rmr) {
                {
                {
#line 126
                tmp___4 = magic(w, rw, (d->right)->next, re, rcost);
                }
#line 126
                rightcount += tmp___4;
                }
              }
#line 127
              if (rml) {
#line 127
                if (rmr) {
                  {
                  {
#line 127
                  tmp___5 = magic(w, rw, d->right, re, rcost);
                  }
#line 127
                  rightcount += tmp___5;
                  }
                }
              }
            } else {
#line 129
              rightcount = 0;
            }
          } else {
#line 129
            rightcount = 0;
          }
        } else {
#line 129
          rightcount = 0;
        }
#line 131
        i = leftcount * rightcount;
#line 132
        total += i;
#line 134
        if (total - i <= index___0) {
#line 134
          if (total > index___0) {
            {
#line 135
            x = (index___0 - total) + i;
#line 136
            lindex = x / rightcount;
#line 137
            rindex___0 = x % rightcount;
#line 138
            lc = 0;
            {
#line 139
            delta = magic(lw, w, le->next, (d->left)->next, lcost);
            }
#line 140
            lc += delta;
            }
#line 141
            if (lc > lindex) {
              {
              {
#line 142
              issue_link(ld, d, lw, w, le, d->left);
              }
              {
#line 143
              list_links(ld, d, lw, w, le->next, (d->left)->next, lcost, (lindex - lc) + delta);
              }
              }
            }
#line 145
            if (lml) {
              {
              {
#line 145
              delta = magic(lw, w, le, (d->left)->next, lcost);
              }
              }
            } else {
#line 146
              delta = 0;
            }
#line 147
            lc += delta;
#line 148
            if (lc - delta <= lindex) {
#line 148
              if (lc > lindex) {
                {
                {
#line 149
                issue_link(ld, d, lw, w, le, d->left);
                }
                {
#line 150
                list_links(ld, d, lw, w, le, (d->left)->next, lcost, (lindex - lc) + delta);
                }
                }
              }
            }
#line 152
            if (lmr) {
              {
              {
#line 152
              delta = magic(lw, w, le->next, d->left, lcost);
              }
              }
            } else {
#line 153
              delta = 0;
            }
#line 154
            lc += delta;
#line 155
            if (lc - delta <= lindex) {
#line 155
              if (lc > lindex) {
                {
                {
#line 156
                issue_link(ld, d, lw, w, le, d->left);
                }
                {
#line 157
                list_links(ld, d, lw, w, le->next, d->left, lcost, (lindex - lc) + delta);
                }
                }
              }
            }
#line 159
            if (lml) {
#line 159
              if (lmr) {
                {
                {
#line 159
                delta = magic(lw, w, le, d->left, lcost);
                }
                }
              } else {
#line 160
                delta = 0;
              }
            } else {
#line 160
              delta = 0;
            }
#line 161
            lc += delta;
#line 162
            if (lc - delta <= lindex) {
#line 162
              if (lc > lindex) {
                {
                {
#line 163
                issue_link(ld, d, lw, w, le, d->left);
                }
                {
#line 164
                list_links(ld, d, lw, w, le, d->left, lcost, (lindex - lc) + delta);
                }
                }
              }
            }
            {
#line 166
            rc = 0;
            {
#line 167
            delta = magic(w, rw, (d->right)->next, re->next, rcost);
            }
#line 168
            rc += delta;
            }
#line 169
            if (rc > rindex___0) {
              {
              {
#line 170
              issue_link(d, rd, w, rw, d->right, re);
              }
              {
#line 171
              list_links(d, rd, w, rw, (d->right)->next, re->next, rcost, (rindex___0 - rc) + delta);
              }
              }
            }
#line 173
            if (rml) {
              {
              {
#line 173
              delta = magic(w, rw, d->right, re->next, rcost);
              }
              }
            } else {
#line 174
              delta = 0;
            }
#line 175
            rc += delta;
#line 176
            if (rc - delta <= rindex___0) {
#line 176
              if (rc > rindex___0) {
                {
                {
#line 177
                issue_link(d, rd, w, rw, d->right, re);
                }
                {
#line 178
                list_links(d, rd, w, rw, d->right, re->next, rcost, (rindex___0 - rc) + delta);
                }
                }
              }
            }
#line 180
            if (rmr) {
              {
              {
#line 180
              delta = magic(w, rw, (d->right)->next, re, rcost);
              }
              }
            } else {
#line 181
              delta = 0;
            }
#line 182
            rc += delta;
#line 183
            if (rc - delta <= rindex___0) {
#line 183
              if (rc > rindex___0) {
                {
                {
#line 184
                issue_link(d, rd, w, rw, d->right, re);
                }
                {
#line 185
                list_links(d, rd, w, rw, (d->right)->next, re, rcost, (rindex___0 - rc) + delta);
                }
                }
              }
            }
#line 187
            if (rml) {
#line 187
              if (rmr) {
                {
                {
#line 187
                delta = magic(w, rw, d->right, re, rcost);
                }
                }
              } else {
#line 188
                delta = 0;
              }
            } else {
#line 188
              delta = 0;
            }
#line 189
            rc += delta;
#line 190
            if (rc - delta <= rindex___0) {
#line 190
              if (rc > rindex___0) {
                {
                {
#line 191
                issue_link(d, rd, w, rw, d->right, re);
                }
                {
#line 192
                list_links(d, rd, w, rw, d->right, re, rcost, (rindex___0 - rc) + delta);
                }
                }
              }
            }
          }
        }
#line 196
        if (leftcount > 0) {
          {
          {
#line 197
          tmp___7 = magic(w, rw, d->right, re, rcost);
          }
#line 197
          i = leftcount * tmp___7;
          }
        } else {
#line 199
          i = 0;
        }
#line 201
        total += i;
#line 202
        if (total - i <= index___0) {
#line 202
          if (total > index___0) {
            {
#line 203
            x = (index___0 - total) + i;
#line 204
            lindex = x % leftcount;
#line 205
            rindex___0 = x / leftcount;
#line 207
            lc = 0;
            {
#line 208
            delta = magic(lw, w, le->next, (d->left)->next, lcost);
            }
#line 209
            lc += delta;
            }
#line 210
            if (lc > lindex) {
              {
              {
#line 211
              issue_link(ld, d, lw, w, le, d->left);
              }
              {
#line 212
              list_links(ld, d, lw, w, le->next, (d->left)->next, lcost, (lindex - lc) + delta);
              }
              }
            }
#line 214
            if (lml) {
              {
              {
#line 214
              delta = magic(lw, w, le, (d->left)->next, lcost);
              }
              }
            } else {
#line 215
              delta = 0;
            }
#line 216
            lc += delta;
#line 217
            if (lc - delta <= lindex) {
#line 217
              if (lc > lindex) {
                {
                {
#line 218
                issue_link(ld, d, lw, w, le, d->left);
                }
                {
#line 219
                list_links(ld, d, lw, w, le, (d->left)->next, lcost, (lindex - lc) + delta);
                }
                }
              }
            }
#line 221
            if (lmr) {
              {
              {
#line 221
              delta = magic(lw, w, le->next, d->left, lcost);
              }
              }
            } else {
#line 222
              delta = 0;
            }
#line 223
            lc += delta;
#line 224
            if (lc - delta <= lindex) {
#line 224
              if (lc > lindex) {
                {
                {
#line 225
                issue_link(ld, d, lw, w, le, d->left);
                }
                {
#line 226
                list_links(ld, d, lw, w, le->next, d->left, lcost, (lindex - lc) + delta);
                }
                }
              }
            }
#line 228
            if (lml) {
#line 228
              if (lmr) {
                {
                {
#line 228
                delta = magic(lw, w, le, d->left, lcost);
                }
                }
              } else {
#line 229
                delta = 0;
              }
            } else {
#line 229
              delta = 0;
            }
#line 230
            lc += delta;
#line 231
            if (lc - delta <= lindex) {
#line 231
              if (lc > lindex) {
                {
                {
#line 232
                issue_link(ld, d, lw, w, le, d->left);
                }
                {
#line 233
                list_links(ld, d, lw, w, le, d->left, lcost, (lindex - lc) + delta);
                }
                }
              }
            }
            {
            {
#line 236
            list_links(d, rd, w, rw, d->right, re, rcost, rindex___0);
            }
            }
          }
        }
#line 238
        if ((unsigned long )le == (unsigned long )((void *)0)) {
#line 238
          if (rightcount > 0) {
            {
            {
#line 239
            tmp___8 = magic(lw, w, le, d->left, lcost);
            }
#line 239
            i = rightcount * tmp___8;
            }
          } else {
#line 241
            i = 0;
          }
        } else {
#line 241
          i = 0;
        }
#line 243
        total += i;
#line 244
        if (total - i <= index___0) {
#line 244
          if (total > index___0) {
            {
#line 245
            x = (index___0 - total) + i;
#line 246
            rindex___0 = x % rightcount;
#line 247
            lindex = x / rightcount;
#line 249
            rc = 0;
            {
#line 250
            delta = magic(w, rw, (d->right)->next, re->next, rcost);
            }
#line 251
            rc += delta;
            }
#line 252
            if (rc > rindex___0) {
              {
              {
#line 253
              issue_link(d, rd, w, rw, d->right, re);
              }
              {
#line 254
              list_links(d, rd, w, rw, (d->right)->next, re->next, rcost, (rindex___0 - rc) + delta);
              }
              }
            }
#line 256
            if (rml) {
              {
              {
#line 256
              delta = magic(w, rw, d->right, re->next, rcost);
              }
              }
            } else {
#line 257
              delta = 0;
            }
#line 258
            rc += delta;
#line 259
            if (rc - delta <= rindex___0) {
#line 259
              if (rc > rindex___0) {
                {
                {
#line 260
                issue_link(d, rd, w, rw, d->right, re);
                }
                {
#line 261
                list_links(d, rd, w, rw, d->right, re->next, rcost, (rindex___0 - rc) + delta);
                }
                }
              }
            }
#line 263
            if (rmr) {
              {
              {
#line 263
              delta = magic(w, rw, (d->right)->next, re, rcost);
              }
              }
            } else {
#line 264
              delta = 0;
            }
#line 265
            rc += delta;
#line 266
            if (rc - delta <= rindex___0) {
#line 266
              if (rc > rindex___0) {
                {
                {
#line 267
                issue_link(d, rd, w, rw, d->right, re);
                }
                {
#line 268
                list_links(d, rd, w, rw, (d->right)->next, re, rcost, (rindex___0 - rc) + delta);
                }
                }
              }
            }
#line 270
            if (rml) {
#line 270
              if (rmr) {
                {
                {
#line 270
                delta = magic(w, rw, d->right, re, rcost);
                }
                }
              } else {
#line 271
                delta = 0;
              }
            } else {
#line 271
              delta = 0;
            }
#line 272
            rc += delta;
#line 273
            if (rc - delta <= rindex___0) {
#line 273
              if (rc > rindex___0) {
                {
                {
#line 274
                issue_link(d, rd, w, rw, d->right, re);
                }
                {
#line 275
                list_links(d, rd, w, rw, d->right, re, rcost, (rindex___0 - rc) + delta);
                }
                }
              }
            }
            {
            {
#line 277
            list_links(ld, d, lw, w, le, d->left, lcost, lindex);
            }
            }
          }
        }
#line 108
        lcost ++;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 106
      m = m->next;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
    {
#line 281
    put_match_list(m1);
    }
#line 104
    w ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 283
  return;
}
}
#line 285 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/extract-links.c"
void initialize_links(void) 
{ 
  int i ;

  {
#line 287
  i = 0;
  {
  {
#line 287
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i < N_words)) {
#line 287
      goto while_break;
    }
#line 288
    chosen_disjuncts[i] = (Disjunct *)((void *)0);
#line 287
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  return;
}
}
#line 292 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/extract-links.c"
void extract_links(int index___0 , int cost ) 
{ 
  Disjunct *dis ;
  int total ;
  int c ;

  {
  {
#line 298
  c = 0;
#line 299
  N_links = 0;
#line 300
  total = 0;
  {
#line 302
  initialize_links();
  }
#line 304
  dis = sentence[0].d;
  }
  {
  {
#line 304
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 304
    if (! ((unsigned long )dis != (unsigned long )((void *)0))) {
#line 304
      goto while_break;
    }
#line 305
    if ((unsigned long )dis->left == (unsigned long )((void *)0)) {
      {
      {
#line 306
      c = magic(0, N_words, dis->right, (Connector *)((void *)0), cost);
      }
#line 307
      total += c;
      }
#line 308
      if (total > index___0) {
#line 308
        goto while_break;
      }
    }
#line 304
    dis = dis->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 311
  if (total > index___0) {
    {
    {
#line 312
    list_links(dis, (Disjunct *)((void *)0), 0, N_words, dis->right, (Connector *)((void *)0),
               cost, (index___0 - total) + c);
    }
    }
  } else {
    {
    {
#line 314
    c = magic(0, N_words, (Connector *)((void *)0), (Connector *)((void *)0), cost);
    }
#line 315
    total += c;
    {
#line 316
    list_links((Disjunct *)((void *)0), (Disjunct *)((void *)0), 0, N_words, (Connector *)((void *)0),
               (Connector *)((void *)0), cost, (index___0 - total) + c);
    }
    }
  }
#line 318
  return;
}
}
#line 411 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
void print_disjunct_list(Disjunct *c ) ;
#line 31 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Tconnector *copy_Tconnectors(Tconnector *c ) 
{ 
  Tconnector *c1 ;
  void *tmp ;

  {
#line 36
  if ((unsigned long )c == (unsigned long )((void *)0)) {
#line 36
    return ((Tconnector *)((void *)0));
  }
  {
  {
#line 37
  tmp = xalloc((int )sizeof(Tconnector ));
  }
#line 37
  c1 = (Tconnector *)tmp;
#line 38
  *c1 = *c;
  {
#line 39
  c1->next = copy_Tconnectors(c->next);
  }
  }
#line 40
  return (c1);
}
}
#line 43 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
void free_Tconnectors(Tconnector *e ) 
{ 
  Tconnector *n ;

  {
  {
  {
#line 45
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 45
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 45
      goto while_break;
    }
    {
#line 46
    n = e->next;
    {
#line 47
    xfree((char *)e, (int )sizeof(Tconnector ));
    }
#line 45
    e = n;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 49
  return;
}
}
#line 51 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
void free_clause_list(Clause *c ) 
{ 
  Clause *c1 ;

  {
  {
  {
#line 53
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 53
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 53
      goto while_break;
    }
    {
#line 54
    c1 = c->next;
    {
#line 55
    free_Tconnectors(c->c);
    }
    {
#line 56
    xfree((char *)c, (int )sizeof(Clause ));
    }
#line 57
    c = c1;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return;
}
}
#line 61 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Clause *copy_clause(Clause *d ) 
{ 
  Clause *d1 ;
  void *tmp ;

  {
#line 66
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 66
    return ((Clause *)((void *)0));
  }
  {
  {
#line 67
  tmp = xalloc((int )sizeof(Clause ));
  }
#line 67
  d1 = (Clause *)tmp;
#line 68
  *d1 = *d;
#line 69
  d1->next = (Clause *)((void *)0);
  {
#line 70
  d1->c = copy_Tconnectors(d->c);
  }
  }
#line 71
  return (d1);
}
}
#line 74 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Tconnector *Treverse(Tconnector *e ) 
{ 
  Tconnector *head ;
  Tconnector *x ;

  {
#line 77
  head = (Tconnector *)((void *)0);
  {
  {
#line 78
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 78
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 78
      goto while_break;
    }
#line 79
    x = e->next;
#line 80
    e->next = head;
#line 81
    head = e;
#line 82
    e = x;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 84
  return (head);
}
}
#line 87 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Connector *reverse(Connector *e ) 
{ 
  Connector *head ;
  Connector *x ;

  {
#line 90
  head = (Connector *)((void *)0);
  {
  {
#line 91
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 91
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 91
      goto while_break;
    }
#line 92
    x = e->next;
#line 93
    e->next = head;
#line 94
    head = e;
#line 95
    e = x;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 97
  return (head);
}
}
#line 100 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Tconnector *catenate(Tconnector *e1 , Tconnector *e2 ) 
{ 
  Tconnector *e ;
  Tconnector *head ;
  void *tmp ;
  void *tmp___0 ;
  Tconnector *tmp___1 ;

  {
#line 105
  head = (Tconnector *)((void *)0);
  {
  {
#line 106
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 106
    if (! ((unsigned long )e1 != (unsigned long )((void *)0))) {
#line 106
      goto while_break;
    }
    {
    {
#line 107
    tmp = xalloc((int )sizeof(Tconnector ));
    }
#line 107
    e = (Tconnector *)tmp;
#line 108
    *e = *e1;
#line 109
    e->next = head;
#line 110
    head = e;
#line 106
    e1 = e1->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 112
    if (! ((unsigned long )e2 != (unsigned long )((void *)0))) {
#line 112
      goto while_break___0;
    }
    {
    {
#line 113
    tmp___0 = xalloc((int )sizeof(Tconnector ));
    }
#line 113
    e = (Tconnector *)tmp___0;
#line 114
    *e = *e2;
#line 115
    e->next = head;
#line 116
    head = e;
#line 112
    e2 = e2->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 118
  tmp___1 = Treverse(head);
  }
  }
#line 118
  return (tmp___1);
}
}
#line 121 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Tconnector *build_terminal(Exp *e ) 
{ 
  Tconnector *c ;
  void *tmp ;

  {
  {
  {
#line 124
  tmp = xalloc((int )sizeof(Tconnector ));
  }
#line 124
  c = (Tconnector *)tmp;
#line 125
  c->string = e->u.string;
#line 126
  c->multi = e->multi;
#line 127
  c->dir = e->dir;
#line 128
  c->next = (Tconnector *)((void *)0);
  }
#line 129
  return (c);
}
}
#line 132 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
int maxcost_of_expression(Exp *e ) 
{ 
  E_list *e_list ;
  int m ;
  int m1 ;

  {
#line 136
  m = 0;
#line 138
  if ((int )e->type == 1) {
#line 138
    goto _L;
  } else
#line 138
  if ((int )e->type == 0) {
    _L: /* CIL Label */ 
#line 139
    e_list = e->u.l;
    {
    {
#line 139
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 139
      if (! ((unsigned long )e_list != (unsigned long )((void *)0))) {
#line 139
        goto while_break;
      }
      {
      {
#line 140
      m1 = maxcost_of_expression(e_list->e);
      }
      }
#line 141
      if (m > m1) {
#line 141
        m = m;
      } else {
#line 141
        m = m1;
      }
#line 139
      e_list = e_list->next;
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 144
  return (m + (int )e->cost);
}
}
#line 147 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
int maxcost_of_sentence(void) 
{ 
  X_node *x ;
  int w ;
  int m ;
  int m1 ;

  {
#line 152
  m = 0;
#line 154
  w = 0;
  {
  {
#line 154
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 154
    if (! (w < N_words)) {
#line 154
      goto while_break;
    }
#line 155
    x = sentence[w].x;
    {
    {
#line 155
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 155
      if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 155
        goto while_break___0;
      }
      {
      {
#line 156
      m1 = maxcost_of_expression(x->exp);
      }
      }
#line 156
      if (m > m1) {
#line 156
        m = m;
      } else {
#line 156
        m = m1;
      }
#line 155
      x = x->next;
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 154
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return (m);
}
}
#line 164 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Clause *build_clause(Exp *e , int cost_cutoff ) 
{ 
  Clause *c ;
  Clause *c1 ;
  Clause *c2 ;
  Clause *c3 ;
  Clause *c4 ;
  Clause *c_head ;
  E_list *e_list ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;

  {
#line 166
  c = (Clause *)((void *)0);
#line 169
  if (! ((unsigned long )e != (unsigned long )((void *)0))) {
    {
    {
#line 169
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "build_clause called with null parameter");
    }
    {
#line 169
    exit(1);
    }
    }
  }
#line 170
  if ((int )e->type == 1) {
    {
    {
#line 171
    tmp = xalloc((int )sizeof(Clause ));
    }
#line 171
    c1 = (Clause *)tmp;
#line 172
    c1->c = (Tconnector *)((void *)0);
#line 173
    c1->next = (Clause *)((void *)0);
#line 174
    c1->cost = 0;
#line 175
    c1->maxcost = 0;
#line 176
    e_list = e->u.l;
    }
    {
    {
#line 176
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 176
      if (! ((unsigned long )e_list != (unsigned long )((void *)0))) {
#line 176
        goto while_break;
      }
      {
      {
#line 177
      c2 = build_clause(e_list->e, cost_cutoff);
      }
#line 178
      c_head = (Clause *)((void *)0);
#line 179
      c3 = c1;
      }
      {
      {
#line 179
      while (1) {
        while_continue___6: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 179
        if (! ((unsigned long )c3 != (unsigned long )((void *)0))) {
#line 179
          goto while_break___0;
        }
#line 180
        c4 = c2;
        {
        {
#line 180
        while (1) {
          while_continue___7: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 180
          if (! ((unsigned long )c4 != (unsigned long )((void *)0))) {
#line 180
            goto while_break___1;
          }
          {
          {
#line 181
          tmp___0 = xalloc((int )sizeof(Clause ));
          }
#line 181
          c = (Clause *)tmp___0;
#line 182
          c->cost = c3->cost + c4->cost;
          }
#line 183
          if (c3->maxcost > c4->maxcost) {
#line 183
            c->maxcost = c3->maxcost;
          } else {
#line 183
            c->maxcost = c4->maxcost;
          }
          {
          {
#line 184
          c->c = catenate(c3->c, c4->c);
          }
#line 185
          c->next = c_head;
#line 186
          c_head = c;
#line 180
          c4 = c4->next;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 179
        c3 = c3->next;
      }
      while_break___6: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
      {
#line 189
      free_clause_list(c1);
      }
      {
#line 190
      free_clause_list(c2);
      }
#line 191
      c1 = c_head;
#line 176
      e_list = e_list->next;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
#line 193
    c = c1;
  } else
#line 194
  if ((int )e->type == 0) {
#line 196
    c = (Clause *)((void *)0);
#line 197
    e_list = e->u.l;
    {
    {
#line 197
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 197
      if (! ((unsigned long )e_list != (unsigned long )((void *)0))) {
#line 197
        goto while_break___2;
      }
      {
      {
#line 198
      c1 = build_clause(e_list->e, cost_cutoff);
      }
      }
      {
      {
#line 199
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 199
        if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 199
          goto while_break___3;
        }
#line 200
        c3 = c1->next;
#line 201
        c1->next = c;
#line 202
        c = c1;
#line 203
        c1 = c3;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 197
      e_list = e_list->next;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else
#line 206
  if ((int )e->type == 2) {
    {
    {
#line 207
    tmp___1 = xalloc((int )sizeof(Clause ));
    }
#line 207
    c = (Clause *)tmp___1;
    {
#line 208
    c->c = build_terminal(e);
    }
#line 209
    c->cost = 0;
#line 210
    c->maxcost = 0;
#line 211
    c->next = (Clause *)((void *)0);
    }
  } else {
    {
    {
#line 213
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "an expression node with no type");
    }
    {
#line 213
    exit(1);
    }
    }
  }
#line 218
  c1 = c;
  {
  {
#line 218
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 218
    if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 218
      goto while_break___4;
    }
#line 219
    c1->cost += (int )e->cost;
#line 222
    c1->maxcost += (int )e->cost;
#line 218
    c1 = c1->next;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 224
  return (c);
}
}
#line 227 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
void print_connector_list(Connector *e ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 228
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 228
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 228
      goto while_break;
    }
    {
    {
#line 229
    printf((char const   */* __restrict  */)"%s", e->string);
    }
    }
#line 230
    if ((int )e->label != -1) {
      {
      {
#line 231
      printf((char const   */* __restrict  */)"%3d", (int )e->label);
      }
      }
    } else {
      {
      {
#line 233
      printf((char const   */* __restrict  */)"   ");
      }
      }
    }
#line 235
    if ((unsigned long )e->next != (unsigned long )((void *)0)) {
      {
      {
#line 235
      printf((char const   */* __restrict  */)" ");
      }
      }
    }
#line 228
    e = e->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 237
  return;
}
}
#line 239 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
void print_Tconnector_list(Tconnector *e ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 240
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 240
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 240
      goto while_break;
    }
#line 241
    if (e->multi) {
      {
      {
#line 241
      printf((char const   */* __restrict  */)"@");
      }
      }
    }
    {
    {
#line 242
    printf((char const   */* __restrict  */)"%s", e->string);
    }
    {
#line 243
    printf((char const   */* __restrict  */)"%c", (int )e->dir);
    }
    }
#line 244
    if ((unsigned long )e->next != (unsigned long )((void *)0)) {
      {
      {
#line 244
      printf((char const   */* __restrict  */)" ");
      }
      }
    }
#line 240
    e = e->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 246
  return;
}
}
#line 248 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
void print_clause_list(Clause *c ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 249
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 249
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 249
      goto while_break;
    }
    {
    {
#line 250
    printf((char const   */* __restrict  */)"  Clause: ");
    }
    {
#line 251
    printf((char const   */* __restrict  */)"(%2d, %2d)", c->cost, c->maxcost);
    }
    {
#line 252
    print_Tconnector_list(c->c);
    }
    {
#line 253
    printf((char const   */* __restrict  */)"\n");
    }
#line 249
    c = c->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 255
  return;
}
}
#line 257 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
void print_disjunct_list(Disjunct *c ) 
{ 
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;

  {
  {
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 258
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 258
      goto while_break;
    }
    {
    {
#line 259
    printf((char const   */* __restrict  */)"%10s: ", c->string);
    }
    {
#line 260
    printf((char const   */* __restrict  */)"(%2d)", (int )c->cost);
    }
    {
#line 261
    print_connector_list(c->left);
    }
    {
#line 262
    printf((char const   */* __restrict  */)" <--> ");
    }
    {
#line 263
    print_connector_list(c->right);
    }
    {
#line 264
    printf((char const   */* __restrict  */)"\n");
    }
#line 258
    c = c->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 266
  return;
}
}
#line 268 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Connector *extract_connectors(Tconnector *e , int c ) 
{ 
  Connector *e1 ;
  void *tmp ;
  Connector *tmp___0 ;

  {
#line 274
  if ((unsigned long )e == (unsigned long )((void *)0)) {
#line 274
    return ((Connector *)((void *)0));
  }
#line 275
  if ((int )e->dir == c) {
    {
    {
#line 276
    tmp = xalloc((int )sizeof(Connector ));
    }
#line 276
    e1 = (Connector *)tmp;
    {
#line 277
    e1->next = extract_connectors(e->next, c);
    }
#line 278
    e1->multi = e->multi;
#line 279
    e1->string = e->string;
#line 280
    e1->label = (short)-1;
#line 281
    e1->priority = (char)0;
#line 282
    e1->word = (short)0;
    }
#line 283
    return (e1);
  } else {
    {
    {
#line 285
    tmp___0 = extract_connectors(e->next, c);
    }
    }
#line 285
    return (tmp___0);
  }
}
}
#line 289 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Disjunct *build_disjunct(Clause *cl , char *string , int cost_cutoff ) 
{ 
  Disjunct *dis ;
  Disjunct *ndis ;
  void *tmp ;
  Connector *tmp___0 ;
  Connector *tmp___1 ;

  {
#line 294
  dis = (Disjunct *)((void *)0);
  {
  {
#line 295
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 295
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 295
      goto while_break;
    }
#line 296
    if (cl->maxcost <= cost_cutoff) {
      {
      {
#line 297
      tmp = xalloc((int )sizeof(Disjunct ));
      }
#line 297
      ndis = (Disjunct *)tmp;
      {
#line 298
      tmp___0 = extract_connectors(cl->c, '-');
      }
      {
#line 298
      ndis->left = reverse(tmp___0);
      }
      {
#line 299
      tmp___1 = extract_connectors(cl->c, '+');
      }
      {
#line 299
      ndis->right = reverse(tmp___1);
      }
#line 300
      ndis->string = string;
#line 301
      ndis->cost = (short )cl->cost;
#line 302
      ndis->next = dis;
#line 303
      dis = ndis;
      }
    }
#line 295
    cl = cl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  return (dis);
}
}
#line 309 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Disjunct *build_disjuncts_for_X_node(X_node *x , int cost_cutoff ) 
{ 
  Clause *c ;
  Disjunct *dis ;

  {
  {
  {
#line 312
  c = build_clause(x->exp, cost_cutoff);
  }
  {
#line 313
  dis = build_disjunct(c, x->string, cost_cutoff);
  }
  {
#line 314
  free_clause_list(c);
  }
  }
#line 315
  return (dis);
}
}
#line 318 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
Disjunct *build_disjuncts_for_dict_node(Dict_node *dn ) 
{ 
  Clause *c ;
  Disjunct *dis ;

  {
  {
  {
#line 324
  c = build_clause(dn->exp, 1000);
  }
  {
#line 326
  dis = build_disjunct(c, dn->string, 1000);
  }
  {
#line 327
  free_clause_list(c);
  }
  }
#line 328
  return (dis);
}
}
#line 364 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
X_node *build_word_expressions(char *s ) 
{ 
  Dict_node *dn ;
  X_node *x ;
  X_node *y ;
  void *tmp ;

  {
  {
  {
#line 372
  dn = dictionary_lookup(s);
  }
#line 374
  x = (X_node *)((void *)0);
  }
  {
  {
#line 375
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 375
    if (! ((unsigned long )dn != (unsigned long )((void *)0))) {
#line 375
      goto while_break;
    }
    {
    {
#line 376
    tmp = xalloc((int )sizeof(X_node ));
    }
#line 376
    y = (X_node *)tmp;
#line 377
    y->next = x;
#line 378
    x = y;
    {
#line 379
    x->exp = copy_Exp(dn->exp);
    }
#line 380
    x->string = dn->string;
#line 381
    dn = dn->right;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 383
  return (x);
}
}
#line 386 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/build-disjuncts.c"
void build_sentence_disjuncts(int cost_cutoff ) 
{ 
  Disjunct *d ;
  X_node *x ;
  int w ;
  Disjunct *tmp ;

  {
#line 393
  w = 0;
  {
  {
#line 393
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 393
    if (! (w < N_words)) {
#line 393
      goto while_break;
    }
#line 394
    d = (Disjunct *)((void *)0);
#line 395
    x = sentence[w].x;
    {
    {
#line 395
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 395
      if (! ((unsigned long )x != (unsigned long )((void *)0))) {
#line 395
        goto while_break___0;
      }
      {
      {
#line 396
      tmp = build_disjuncts_for_X_node(x, cost_cutoff);
      }
      {
#line 396
      d = catenate_disjuncts(tmp, d);
      }
#line 395
      x = x->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 398
    sentence[w].d = d;
#line 393
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return;
}
}
#line 354 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
char has_fat_down[250]  ;
#line 439
char *intersect_strings(char *s , char *t ) ;
#line 461
void compute_pp_link_array_connectors(void) ;
#line 293 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
static Label_node *hash_table[1 << 10]  ;
#line 295 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
static Disjunct **label_table  ;
#line 296 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
static int LT_bound  ;
#line 297 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
static int LT_size  ;
#line 299 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
static int STAT_N_disjuncts  ;
#line 300 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
static int STAT_calls_to_equality_test  ;
#line 302 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void init_LT(void) 
{ 
  void *tmp ;

  {
  {
#line 303
  LT_bound = 200;
#line 304
  LT_size = 0;
  {
#line 305
  tmp = xalloc((int )((unsigned long )LT_bound * sizeof(Disjunct *)));
  }
#line 305
  label_table = (Disjunct **)tmp;
  }
#line 306
  return;
}
}
#line 308 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void grow_LT(void) 
{ 
  int i ;
  Disjunct **new_table ;
  int new_LT_bound ;
  void *tmp ;

  {
  {
#line 312
  new_LT_bound = (3 * LT_bound) / 2;
  {
#line 313
  tmp = xalloc((int )((unsigned long )new_LT_bound * sizeof(Disjunct *)));
  }
#line 313
  new_table = (Disjunct **)tmp;
#line 314
  i = 0;
  }
  {
  {
#line 314
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 314
    if (! (i < LT_bound)) {
#line 314
      goto while_break;
    }
#line 314
    *(new_table + i) = *(label_table + i);
#line 314
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 315
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 315
    if (! (i < new_LT_bound)) {
#line 315
      goto while_break___0;
    }
#line 315
    *(new_table + i) = (Disjunct *)((void *)0);
#line 315
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 316
  xfree((char *)label_table, (int )((unsigned long )LT_bound * sizeof(Disjunct *)));
  }
#line 317
  LT_bound = new_LT_bound;
#line 318
  label_table = new_table;
  }
#line 319
  return;
}
}
#line 321 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void init_HT(void) 
{ 
  int i ;

  {
#line 323
  i = 0;
  {
  {
#line 323
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 323
    if (! (i < 1 << 10)) {
#line 323
      goto while_break;
    }
#line 324
    hash_table[i] = (Label_node *)((void *)0);
#line 323
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  return;
}
}
#line 328 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void free_HT(void) 
{ 
  int i ;
  Label_node *la ;
  Label_node *la1 ;

  {
#line 331
  i = 0;
  {
  {
#line 331
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 331
    if (! (i < 1 << 10)) {
#line 331
      goto while_break;
    }
#line 332
    la = hash_table[i];
    {
    {
#line 332
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 332
      if (! ((unsigned long )la != (unsigned long )((void *)0))) {
#line 332
        goto while_break___0;
      }
      {
#line 333
      la1 = la->next;
      {
#line 334
      xfree((char *)la, (int )sizeof(Label_node ));
      }
#line 332
      la = la1;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 336
    hash_table[i] = (Label_node *)((void *)0);
#line 331
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  return;
}
}
#line 340 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void free_LT(void) 
{ 
  int i ;

  {
#line 342
  i = 0;
  {
  {
#line 342
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 342
    if (! (i < LT_size)) {
#line 342
      goto while_break;
    }
    {
    {
#line 343
    free_disjuncts(*(label_table + i));
    }
#line 342
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 345
  xfree((char *)label_table, (int )((unsigned long )LT_bound * sizeof(Disjunct *)));
  }
#line 346
  LT_bound = 0;
#line 347
  LT_size = 0;
#line 348
  label_table = (Disjunct **)((void *)0);
  }
#line 349
  return;
}
}
#line 351 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void free_AND_tables(void) 
{ 


  {
  {
  {
#line 352
  free_LT();
  }
  {
#line 353
  free_HT();
  }
  }
#line 354
  return;
}
}
#line 356 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int and_connector_hash(Connector *c , int i ) 
{ 
  char *s ;
  unsigned short const   **tmp ;

  {
#line 363
  s = c->string;
#line 365
  i = (int )((unsigned int )(i + (i << 1)) + randtable[((int )c->label + i) & 255]);
  {
  {
#line 366
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 366
    tmp = __ctype_b_loc();
    }
    }
#line 366
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
#line 366
      goto while_break;
    }
#line 367
    i = (int )((unsigned int )(i + (i << 1)) + randtable[((int )*s + i) & 255]);
#line 368
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 370
  return (i & ((1 << 10) - 1));
}
}
#line 373 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int and_hash_disjunct(Disjunct *d ) 
{ 
  int i ;
  Connector *e ;

  {
#line 377
  i = 0;
#line 378
  e = d->left;
  {
  {
#line 378
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 378
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 378
      goto while_break;
    }
    {
    {
#line 379
    i = and_connector_hash(e, i);
    }
#line 378
    e = e->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 381
  i = (int )((unsigned int )(i + (i << 1)) + randtable[i & 255]);
#line 382
  e = d->right;
  {
  {
#line 382
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 382
    if (! ((unsigned long )e != (unsigned long )((void *)0))) {
#line 382
      goto while_break___0;
    }
    {
    {
#line 383
    i = and_connector_hash(e, i);
    }
#line 382
    e = e->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 385
  return (i & ((1 << 10) - 1));
}
}
#line 388 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
static int N_andable_hash_table  ;
#line 389 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
static Connector **andable_hash_table  ;
#line 391 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int andable_hash(char *s , int d ) 
{ 
  int i ;
  unsigned short const   **tmp ;

  {
#line 395
  i = d;
  {
  {
#line 396
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 396
    tmp = __ctype_b_loc();
    }
    }
#line 396
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
#line 396
      goto while_break;
    }
#line 397
    i = (int )((unsigned int )(i + (i << 1)) + randtable[((int )*s + i) & 255]);
#line 398
    s ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return (i & (N_andable_hash_table - 1));
}
}
#line 403 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void fill_andable_hash_table(Exp *e ) 
{ 
  E_list *l ;
  Connector *c ;
  int h ;
  void *tmp ;

  {
#line 407
  if ((int )e->type == 2) {
    {
    {
#line 408
    tmp = xalloc((int )sizeof(Connector ));
    }
#line 408
    c = (Connector *)tmp;
#line 409
    c->string = e->u.string;
#line 410
    c->label = (short)-1;
#line 411
    c->priority = (char)0;
#line 412
    c->word = (short )e->dir;
    {
#line 413
    h = andable_hash(c->string, (int )c->word);
    }
#line 414
    c->next = *(andable_hash_table + h);
#line 415
    *(andable_hash_table + h) = c;
    }
  } else {
#line 417
    l = e->u.l;
    {
    {
#line 417
    while (1) {
      while_continue___0: /* CIL Label */ ;
      while_continue: /* CIL Label */ ;
#line 417
      if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 417
        goto while_break;
      }
      {
      {
#line 418
      fill_andable_hash_table(l->e);
      }
#line 417
      l = l->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 421
  return;
}
}
#line 423 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void init_andable_hash_table(void) 
{ 
  int i ;
  Exp *e ;
  Dict_node *tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *__cil_tmp6 ;

  {
  {
  {
#line 426
  tmp = dictionary_lookup((char *)"ANDABLE-CONNECTORS");
  }
#line 426
  e = tmp->exp;
  {
#line 427
  tmp___0 = size_of_expression(e);
  }
  {
#line 427
  N_andable_hash_table = next_power_of_two_up(tmp___0);
  }
  {
#line 428
  tmp___1 = xalloc((int )((unsigned long )N_andable_hash_table * sizeof(Connector *)));
  }
#line 428
  andable_hash_table = (Connector **)tmp___1;
#line 430
  i = 0;
  }
  {
  {
#line 430
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 430
    if (! (i < N_andable_hash_table)) {
#line 430
      goto while_break;
    }
#line 431
    *(andable_hash_table + i) = (Connector *)((void *)0);
#line 430
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 433
  fill_andable_hash_table(e);
  }
  }
#line 434
  return;
}
}
#line 436 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int is_andable_connector(Connector *c , int d ) 
{ 
  int h ;
  Connector *c1 ;
  int tmp ;

  {
#line 443
  if (! andable_defined) {
#line 443
    return (1);
  }
  {
  {
#line 444
  h = andable_hash(c->string, d);
  }
#line 445
  c1 = *(andable_hash_table + h);
  }
  {
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 445
    if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 445
      goto while_break;
    }
    {
    {
#line 446
    tmp = match(c1, c);
    }
    }
#line 446
    if (tmp) {
#line 446
      if (d == (int )c1->word) {
#line 446
        return (1);
      }
    }
#line 445
    c1 = c1->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 448
  return (0);
}
}
#line 451 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int is_appropriate(Disjunct *d ) 
{ 
  Connector *c ;
  int tmp ;
  int tmp___0 ;

  {
#line 458
  c = d->right;
  {
  {
#line 458
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 458
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 458
      goto while_break;
    }
    {
    {
#line 459
    tmp = is_andable_connector(c, '+');
    }
    }
#line 459
    if (! tmp) {
#line 459
      return (0);
    }
#line 458
    c = c->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 461
  c = d->left;
  {
  {
#line 461
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 461
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 461
      goto while_break___0;
    }
    {
    {
#line 462
    tmp___0 = is_andable_connector(c, '-');
    }
    }
#line 462
    if (! tmp___0) {
#line 462
      return (0);
    }
#line 461
    c = c->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 464
  return (1);
}
}
#line 467 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int connector_types_equal(Connector *c1 , Connector *c2 ) 
{ 
  char *s ;
  char *t ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;

  {
#line 473
  if ((int )c1->label != (int )c2->label) {
#line 473
    return (0);
  }
#line 474
  s = c1->string;
#line 475
  t = c2->string;
  {
  {
#line 476
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 476
    tmp = __ctype_b_loc();
    }
    }
#line 476
    if (! ((int const   )*(*tmp + (int )*s) & 256)) {
      {
      {
#line 476
      tmp___0 = __ctype_b_loc();
      }
      }
#line 476
      if (! ((int const   )*(*tmp___0 + (int )*t) & 256)) {
#line 476
        goto while_break;
      }
    }
#line 477
    if ((int )*s != (int )*t) {
#line 477
      return (0);
    }
#line 478
    s ++;
#line 479
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 481
  return (1);
}
}
#line 484 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int disjunct_types_equal(Disjunct *d1 , Disjunct *d2 ) 
{ 
  Connector *e1 ;
  Connector *e2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 494
  e1 = d1->left;
#line 495
  e2 = d2->left;
  {
  {
#line 496
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 496
    if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 496
      if (! ((unsigned long )e2 != (unsigned long )((void *)0))) {
#line 496
        goto while_break;
      }
    } else {
#line 496
      goto while_break;
    }
    {
    {
#line 497
    tmp = connector_types_equal(e1, e2);
    }
    }
#line 497
    if (! tmp) {
#line 497
      goto while_break;
    }
#line 498
    e1 = e1->next;
#line 499
    e2 = e2->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 501
  if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 501
    return (0);
  } else
#line 501
  if ((unsigned long )e2 != (unsigned long )((void *)0)) {
#line 501
    return (0);
  }
#line 502
  e1 = d1->right;
#line 503
  e2 = d2->right;
  {
  {
#line 504
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 504
    if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 504
      if (! ((unsigned long )e2 != (unsigned long )((void *)0))) {
#line 504
        goto while_break___0;
      }
    } else {
#line 504
      goto while_break___0;
    }
    {
    {
#line 505
    tmp___0 = connector_types_equal(e1, e2);
    }
    }
#line 505
    if (! tmp___0) {
#line 505
      goto while_break___0;
    }
#line 506
    e1 = e1->next;
#line 507
    e2 = e2->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 509
  if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 509
    return (0);
  } else
#line 509
  if ((unsigned long )e2 != (unsigned long )((void *)0)) {
#line 509
    return (0);
  }
#line 510
  return (1);
}
}
#line 513 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
char *intersect_strings(char *s , char *t ) 
{ 
  int len ;
  int i ;
  int j ;
  int d ;
  char *u ;
  char *u0 ;
  char *s0 ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;

  {
  {
  {
#line 521
  tmp = strcmp((char const   *)s, (char const   *)t);
  }
  }
#line 521
  if (tmp == 0) {
#line 521
    return (s);
  }
  {
  {
#line 522
  tmp___0 = strlen((char const   *)s);
  }
#line 522
  i = (int )tmp___0;
  {
#line 523
  tmp___1 = strlen((char const   *)t);
  }
#line 523
  j = (int )tmp___1;
  }
#line 524
  if (j > i) {
#line 525
    u = s;
#line 525
    s = t;
#line 525
    t = u;
#line 526
    len = j;
  } else {
#line 528
    len = i;
  }
  {
  {
#line 532
  tmp___2 = xalloc(len + 1);
  }
#line 532
  u = (char *)tmp___2;
#line 532
  u0 = u;
#line 533
  d = 0;
#line 534
  s0 = s;
  }
  {
  {
#line 535
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 535
    if (! ((int )*t != 0)) {
#line 535
      goto while_break;
    }
#line 536
    if ((int )*s == (int )*t) {
#line 537
      *u = *s;
    } else
#line 536
    if ((int )*t == 42) {
#line 537
      *u = *s;
    } else {
#line 539
      d ++;
#line 540
      if ((int )*s == 42) {
#line 540
        *u = *t;
      } else {
#line 541
        *u = (char )'^';
      }
    }
#line 543
    s ++;
#line 543
    t ++;
#line 543
    u ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 545
  if (d == 0) {
    {
    {
#line 546
    xfree(u0, len + 1);
    }
    }
#line 547
    return (s0);
  } else {
    {
    {
#line 549
    strcpy((char */* __restrict  */)u, (char const   */* __restrict  */)s);
    }
    {
#line 550
    free_this_string_later(u0, len + 1);
    }
    }
#line 551
    return (u0);
  }
}
}
#line 555 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int connectors_equal_AND(Connector *c1 , Connector *c2 ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 561
  if ((int )c1->label == (int )c2->label) {
#line 561
    if ((int )c1->multi == (int )c2->multi) {
      {
      {
#line 561
      tmp = strcmp((char const   *)c1->string, (char const   *)c2->string);
      }
      }
#line 561
      if (tmp == 0) {
#line 561
        tmp___0 = 1;
      } else {
#line 561
        tmp___0 = 0;
      }
    } else {
#line 561
      tmp___0 = 0;
    }
  } else {
#line 561
    tmp___0 = 0;
  }
#line 561
  return (tmp___0);
}
}
#line 567 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int disjuncts_equal_AND(Disjunct *d1 , Disjunct *d2 ) 
{ 
  Connector *e1 ;
  Connector *e2 ;
  int tmp ;
  int tmp___0 ;

  {
#line 572
  STAT_calls_to_equality_test ++;
#line 573
  e1 = d1->left;
#line 574
  e2 = d2->left;
  {
  {
#line 575
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 575
    if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 575
      if (! ((unsigned long )e2 != (unsigned long )((void *)0))) {
#line 575
        goto while_break;
      }
    } else {
#line 575
      goto while_break;
    }
    {
    {
#line 576
    tmp = connectors_equal_AND(e1, e2);
    }
    }
#line 576
    if (! tmp) {
#line 576
      goto while_break;
    }
#line 577
    e1 = e1->next;
#line 578
    e2 = e2->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 580
  if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 580
    return (0);
  } else
#line 580
  if ((unsigned long )e2 != (unsigned long )((void *)0)) {
#line 580
    return (0);
  }
#line 581
  e1 = d1->right;
#line 582
  e2 = d2->right;
  {
  {
#line 583
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 583
    if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 583
      if (! ((unsigned long )e2 != (unsigned long )((void *)0))) {
#line 583
        goto while_break___0;
      }
    } else {
#line 583
      goto while_break___0;
    }
    {
    {
#line 584
    tmp___0 = connectors_equal_AND(e1, e2);
    }
    }
#line 584
    if (! tmp___0) {
#line 584
      goto while_break___0;
    }
#line 585
    e1 = e1->next;
#line 586
    e2 = e2->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 588
  if ((unsigned long )e1 != (unsigned long )((void *)0)) {
#line 588
    return (0);
  } else
#line 588
  if ((unsigned long )e2 != (unsigned long )((void *)0)) {
#line 588
    return (0);
  }
#line 589
  return (1);
}
}
#line 592 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
Disjunct *intersect_disjuncts(Disjunct *d1 , Disjunct *d2 ) 
{ 
  Disjunct *d ;
  Connector *c1 ;
  Connector *c2 ;
  Connector *c ;
  int tmp ;
  int tmp___0 ;

  {
  {
  {
#line 599
  d = copy_disjunct(d1);
  }
#line 600
  c = d->left;
#line 601
  c1 = d1->left;
#line 602
  c2 = d2->left;
  }
  {
  {
#line 603
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 603
    if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 603
      goto while_break;
    }
    {
    {
#line 604
    c->string = intersect_strings(c1->string, c2->string);
    }
    }
#line 605
    if (c1->multi) {
#line 605
      if (c2->multi) {
#line 605
        tmp = 1;
      } else {
#line 605
        tmp = 0;
      }
    } else {
#line 605
      tmp = 0;
    }
#line 605
    c->multi = (char )tmp;
#line 606
    c = c->next;
#line 606
    c1 = c1->next;
#line 606
    c2 = c2->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 608
  c = d->right;
#line 609
  c1 = d1->right;
#line 610
  c2 = d2->right;
  {
  {
#line 611
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 611
    if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 611
      goto while_break___0;
    }
    {
    {
#line 612
    c->string = intersect_strings(c1->string, c2->string);
    }
    }
#line 613
    if (c1->multi) {
#line 613
      if (c2->multi) {
#line 613
        tmp___0 = 1;
      } else {
#line 613
        tmp___0 = 0;
      }
    } else {
#line 613
      tmp___0 = 0;
    }
#line 613
    c->multi = (char )tmp___0;
#line 614
    c = c->next;
#line 614
    c1 = c1->next;
#line 614
    c2 = c2->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 616
  return (d);
}
}
#line 619 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void put_disjunct_into_table(Disjunct *d ) 
{ 
  Disjunct *d1 ;
  Disjunct *d2 ;
  Disjunct *di ;
  Disjunct *d_copy ;
  Label_node *lp ;
  int h ;
  int k ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 629
  d1 = (Disjunct *)((void *)0);
  {
#line 633
  h = and_hash_disjunct(d);
  }
#line 635
  lp = hash_table[h];
  }
  {
  {
#line 635
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 635
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 635
      goto while_break;
    }
    {
#line 636
    d1 = *(label_table + lp->label);
    {
#line 637
    tmp = disjunct_types_equal(d, d1);
    }
    }
#line 637
    if (tmp) {
#line 637
      goto while_break;
    }
#line 635
    lp = lp->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 639
  if ((unsigned long )lp != (unsigned long )((void *)0)) {
    {
    {
#line 642
    while (1) {
      while_continue___5: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 642
      if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 642
        goto while_break___0;
      }
      {
      {
#line 643
      tmp___0 = disjuncts_equal_AND(d1, d);
      }
      }
#line 643
      if (tmp___0) {
#line 643
        return;
      }
#line 644
      d1 = d1->next;
    }
    while_break___5: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 664
    d_copy = copy_disjunct(d);
    }
#line 665
    d_copy->cost = (short)0;
#line 666
    k = lp->label;
#line 667
    d2 = (Disjunct *)((void *)0);
#line 668
    d1 = *(label_table + k);
    }
    {
    {
#line 668
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 668
      if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 668
        goto while_break___1;
      }
      {
      {
#line 669
      di = intersect_disjuncts(d_copy, d1);
      }
#line 670
      di->next = d2;
#line 671
      d2 = di;
#line 668
      d1 = d1->next;
      }
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 673
    d_copy->next = *(label_table + k);
#line 674
    *(label_table + k) = d_copy;
    {
    {
#line 675
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 675
      if (! ((unsigned long )d2 != (unsigned long )((void *)0))) {
#line 675
        goto while_break___2;
      }
#line 676
      di = d2->next;
#line 677
      d1 = *(label_table + k);
      {
      {
#line 677
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 677
        if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 677
          goto while_break___3;
        }
        {
        {
#line 678
        tmp___1 = disjuncts_equal_AND(d1, d2);
        }
        }
#line 678
        if (tmp___1) {
#line 678
          goto while_break___3;
        }
#line 677
        d1 = d1->next;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 680
      if ((unsigned long )d1 == (unsigned long )((void *)0)) {
#line 681
        STAT_N_disjuncts ++;
#line 682
        d2->next = *(label_table + k);
#line 683
        *(label_table + k) = d2;
      } else {
        {
#line 685
        d2->next = (Disjunct *)((void *)0);
        {
#line 686
        free_disjuncts(d2);
        }
        }
      }
#line 675
      d2 = di;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 691
    d_copy = copy_disjunct(d);
    }
#line 692
    d_copy->cost = (short)0;
#line 693
    d_copy->next = (Disjunct *)((void *)0);
    }
#line 694
    if (LT_size == LT_bound) {
      {
      {
#line 694
      grow_LT();
      }
      }
    }
    {
    {
#line 695
    tmp___2 = xalloc((int )sizeof(Label_node ));
    }
#line 695
    lp = (Label_node *)tmp___2;
#line 696
    lp->next = hash_table[h];
#line 697
    hash_table[h] = lp;
#line 698
    lp->label = LT_size;
#line 699
    *(label_table + LT_size) = d_copy;
#line 700
    LT_size ++;
#line 701
    STAT_N_disjuncts ++;
    }
  }
#line 703
  return;
}
}
#line 706 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void extract_all_fat_links(Disjunct *d ) 
{ 
  Connector *cl ;
  Connector *cr ;
  Connector *tl ;
  Connector *tr ;
  int tmp ;
  int tmp___0 ;
  Connector *tmp___1 ;
  int tmp___2 ;

  {
#line 715
  tl = d->left;
#line 716
  d->left = (Connector *)((void *)0);
#line 717
  cr = d->right;
  {
  {
#line 717
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 717
    if (! ((unsigned long )cr != (unsigned long )((void *)0))) {
#line 717
      goto while_break;
    }
    {
#line 718
    tr = cr->next;
#line 719
    cr->next = (Connector *)((void *)0);
    {
#line 720
    tmp = is_appropriate(d);
    }
    }
#line 720
    if (tmp) {
      {
      {
#line 720
      put_disjunct_into_table(d);
      }
      }
    }
#line 721
    cr->next = tr;
#line 717
    cr = cr->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 723
  d->left = tl;
#line 725
  tr = d->right;
#line 726
  d->right = (Connector *)((void *)0);
#line 727
  cl = d->left;
  {
  {
#line 727
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 727
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 727
      goto while_break___0;
    }
    {
#line 728
    tl = cl->next;
#line 729
    cl->next = (Connector *)((void *)0);
    {
#line 730
    tmp___0 = is_appropriate(d);
    }
    }
#line 730
    if (tmp___0) {
      {
      {
#line 730
      put_disjunct_into_table(d);
      }
      }
    }
#line 731
    cl->next = tl;
#line 727
    cl = cl->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 733
  d->right = tr;
#line 735
  cl = d->left;
  {
  {
#line 735
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 735
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 735
      goto while_break___1;
    }
#line 736
    cr = d->right;
    {
    {
#line 736
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 736
      if (! ((unsigned long )cr != (unsigned long )((void *)0))) {
#line 736
        goto while_break___2;
      }
      {
#line 737
      tl = cl->next;
#line 738
      tr = cr->next;
#line 739
      tmp___1 = (Connector *)((void *)0);
#line 739
      cr->next = tmp___1;
#line 739
      cl->next = tmp___1;
      {
#line 741
      tmp___2 = is_appropriate(d);
      }
      }
#line 741
      if (tmp___2) {
        {
        {
#line 741
        put_disjunct_into_table(d);
        }
        }
      }
#line 743
      cl->next = tl;
#line 744
      cr->next = tr;
#line 736
      cr = cr->next;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 735
    cl = cl->next;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 747
  return;
}
}
#line 749 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
char *stick_in_one_connector(char *s , Connector *c , int len ) 
{ 
  char *t ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 756
  t = c->string;
  {
  {
#line 756
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
    {
    {
#line 756
    tmp = __ctype_b_loc();
    }
    }
#line 756
    if (! ((int const   )*(*tmp + (int )*t) & 256)) {
#line 756
      goto while_break;
    }
#line 756
    t ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 758
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 758
    if (! ((int )*t != 0)) {
#line 758
      goto while_break___0;
    }
#line 759
    tmp___0 = s;
#line 759
    s ++;
#line 759
    tmp___1 = t;
#line 759
    t ++;
#line 759
    *tmp___0 = *tmp___1;
#line 760
    len --;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 762
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 762
    if (! (len > 0)) {
#line 762
      goto while_break___1;
    }
#line 763
    tmp___2 = s;
#line 763
    s ++;
#line 763
    *tmp___2 = (char )'*';
#line 764
    len --;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 766
  if (c->multi) {
#line 766
    tmp___3 = s;
#line 766
    s ++;
#line 766
    *tmp___3 = (char )'*';
  } else {
#line 766
    tmp___4 = s;
#line 766
    s ++;
#line 766
    *tmp___4 = (char )'^';
  }
#line 767
  *s = (char )'\000';
#line 768
  return (s);
}
}
#line 771 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void compute_matchers_for_a_label(int k ) 
{ 
  int *lengths ;
  int N_connectors ;
  int i ;
  int j ;
  int tot_len ;
  Connector *c ;
  Disjunct *d ;
  char *s ;
  char *os ;
  void *tmp ;
  unsigned short const   **tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;

  {
#line 786
  d = *(label_table + k);
#line 788
  N_connectors = 0;
#line 789
  c = d->left;
  {
  {
#line 789
  while (1) {
    while_continue___11: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 789
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 789
      goto while_break;
    }
#line 789
    N_connectors ++;
#line 789
    c = c->next;
  }
  while_break___11: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 790
  c = d->right;
  {
  {
#line 790
  while (1) {
    while_continue___12: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 790
    if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 790
      goto while_break___0;
    }
#line 790
    N_connectors ++;
#line 790
    c = c->next;
  }
  while_break___12: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 792
  tmp = xalloc((int )((unsigned long )N_connectors * sizeof(int )));
  }
#line 792
  lengths = (int *)tmp;
#line 793
  i = 0;
  }
  {
  {
#line 793
  while (1) {
    while_continue___13: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 793
    if (! (i < N_connectors)) {
#line 793
      goto while_break___1;
    }
#line 793
    *(lengths + i) = 0;
#line 793
    i ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 794
  while (1) {
    while_continue___14: /* CIL Label */ ;
    while_continue___2: /* CIL Label */ ;
#line 794
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 794
      goto while_break___2;
    }
#line 795
    i = 0;
#line 796
    c = d->left;
    {
    {
#line 796
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 796
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 796
        goto while_break___3;
      }
#line 797
      s = c->string;
      {
      {
#line 798
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___4: /* CIL Label */ ;
        {
        {
#line 798
        tmp___0 = __ctype_b_loc();
        }
        }
#line 798
        if (! ((int const   )*(*tmp___0 + (int )*s) & 256)) {
#line 798
          goto while_break___4;
        }
#line 798
        s ++;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___4: /* CIL Label */ ;
      }
      {
      {
#line 799
      tmp___1 = strlen((char const   *)s);
      }
#line 799
      j = (int )tmp___1;
      }
#line 800
      if (j > *(lengths + i)) {
#line 800
        *(lengths + i) = j;
      }
#line 801
      i ++;
#line 796
      c = c->next;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 803
    c = d->right;
    {
    {
#line 803
    while (1) {
      while_continue___17: /* CIL Label */ ;
      while_continue___5: /* CIL Label */ ;
#line 803
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 803
        goto while_break___5;
      }
#line 804
      s = c->string;
      {
      {
#line 805
      while (1) {
        while_continue___18: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
        {
        {
#line 805
        tmp___2 = __ctype_b_loc();
        }
        }
#line 805
        if (! ((int const   )*(*tmp___2 + (int )*s) & 256)) {
#line 805
          goto while_break___6;
        }
#line 805
        s ++;
      }
      while_break___18: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
      {
      {
#line 806
      tmp___3 = strlen((char const   *)s);
      }
#line 806
      j = (int )tmp___3;
      }
#line 807
      if (j > *(lengths + i)) {
#line 807
        *(lengths + i) = j;
      }
#line 808
      i ++;
#line 803
      c = c->next;
    }
    while_break___17: /* CIL Label */ ;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 810
    d = d->next;
  }
  while_break___14: /* CIL Label */ ;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 813
  tot_len = 0;
#line 814
  i = 0;
  {
  {
#line 814
  while (1) {
    while_continue___19: /* CIL Label */ ;
    while_continue___7: /* CIL Label */ ;
#line 814
    if (! (i < N_connectors)) {
#line 814
      goto while_break___7;
    }
#line 814
    tot_len += *(lengths + i) + 1;
#line 814
    i ++;
  }
  while_break___19: /* CIL Label */ ;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 816
  d = *(label_table + k);
  {
  {
#line 816
  while (1) {
    while_continue___20: /* CIL Label */ ;
    while_continue___8: /* CIL Label */ ;
#line 816
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 816
      goto while_break___8;
    }
    {
#line 817
    i = 0;
    {
#line 818
    tmp___4 = xalloc(tot_len + 1);
    }
#line 818
    s = (char *)tmp___4;
#line 818
    os = s;
    {
#line 819
    free_this_string_later(s, tot_len + 1);
    }
#line 820
    c = d->left;
    }
    {
    {
#line 820
    while (1) {
      while_continue___21: /* CIL Label */ ;
      while_continue___9: /* CIL Label */ ;
#line 820
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 820
        goto while_break___9;
      }
      {
      {
#line 821
      s = stick_in_one_connector(s, c, *(lengths + i));
      }
#line 822
      i ++;
#line 820
      c = c->next;
      }
    }
    while_break___21: /* CIL Label */ ;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 824
    c = d->right;
    {
    {
#line 824
    while (1) {
      while_continue___22: /* CIL Label */ ;
      while_continue___10: /* CIL Label */ ;
#line 824
      if (! ((unsigned long )c != (unsigned long )((void *)0))) {
#line 824
        goto while_break___10;
      }
      {
      {
#line 825
      s = stick_in_one_connector(s, c, *(lengths + i));
      }
#line 826
      i ++;
#line 824
      c = c->next;
      }
    }
    while_break___22: /* CIL Label */ ;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 828
    d->string = os;
#line 816
    d = d->next;
  }
  while_break___20: /* CIL Label */ ;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
  {
#line 830
  xfree((char *)lengths, (int )((unsigned long )N_connectors * sizeof(int )));
  }
  }
#line 831
  return;
}
}
#line 833 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void build_conjunction_tables(void) 
{ 
  int w ;
  int k ;
  Disjunct *d ;

  {
  {
  {
#line 841
  init_HT();
  }
  {
#line 842
  init_LT();
  }
#line 843
  STAT_calls_to_equality_test = 0;
#line 843
  STAT_N_disjuncts = STAT_calls_to_equality_test;
#line 845
  w = 0;
  }
  {
  {
#line 845
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 845
    if (! (w < N_words)) {
#line 845
      goto while_break;
    }
#line 846
    d = sentence[w].d;
    {
    {
#line 846
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 846
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 846
        goto while_break___0;
      }
      {
      {
#line 847
      extract_all_fat_links(d);
      }
#line 846
      d = d->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 845
    w ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 851
  k = 0;
  {
  {
#line 851
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 851
    if (! (k < LT_size)) {
#line 851
      goto while_break___1;
    }
    {
    {
#line 852
    compute_matchers_for_a_label(k);
    }
#line 851
    k ++;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 854
  return;
}
}
#line 856 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void print_AND_statistics(void) 
{ 
  char *__cil_tmp1 ;
  char *__cil_tmp2 ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
  {
  {
#line 857
  printf((char const   */* __restrict  */)"Number of disjunct types (labels): %d\n",
         LT_size);
  }
  {
#line 858
  printf((char const   */* __restrict  */)"Number of disjuncts in the table: %d\n",
         STAT_N_disjuncts);
  }
  {
#line 859
  printf((char const   */* __restrict  */)"average list length: %f\n", (double )((float )STAT_N_disjuncts / (float )LT_size));
  }
  {
#line 861
  printf((char const   */* __restrict  */)"Number of equality tests: %d\n", STAT_calls_to_equality_test);
  }
  }
#line 862
  return;
}
}
#line 864 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void connector_for_disjunct(Disjunct *d , Connector *c ) 
{ 
  int h ;
  Disjunct *d1 ;
  Label_node *lp ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;

  {
  {
#line 870
  d1 = (Disjunct *)((void *)0);
  {
#line 873
  h = and_hash_disjunct(d);
  }
#line 875
  lp = hash_table[h];
  }
  {
  {
#line 875
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 875
    if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
#line 875
      goto while_break;
    }
    {
#line 876
    d1 = *(label_table + lp->label);
    {
#line 877
    tmp = disjunct_types_equal(d, d1);
    }
    }
#line 877
    if (tmp) {
#line 877
      goto while_break;
    }
#line 875
    lp = lp->next;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 879
  if (! ((unsigned long )lp != (unsigned long )((void *)0))) {
    {
    {
#line 879
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "A disjunct I inserted was not there. (1)");
    }
    {
#line 879
    exit(1);
    }
    }
  }
  {
  {
#line 888
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 888
    if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 888
      goto while_break___0;
    }
    {
    {
#line 889
    tmp___0 = disjuncts_equal_AND(d1, d);
    }
    }
#line 889
    if (tmp___0) {
#line 889
      goto while_break___0;
    }
#line 890
    d1 = d1->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 893
  if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
    {
    {
#line 893
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "A disjunct I inserted was not there. (2)");
    }
    {
#line 893
    exit(1);
    }
    }
  }
#line 895
  c->label = (short )lp->label;
#line 896
  c->string = d1->string;
#line 897
  c->priority = (char)1;
#line 898
  c->multi = (char)0;
#line 899
  return;
}
}
#line 902 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
Disjunct *build_fat_link_substitutions(Disjunct *d ) 
{ 
  Connector *cl ;
  Connector *cr ;
  Connector *tl ;
  Connector *tr ;
  Connector *wc ;
  Connector work_connector ;
  Disjunct *d1 ;
  Disjunct *wd ;
  Disjunct work_disjunct ;
  Disjunct *d_list ;
  int tmp ;
  int tmp___0 ;
  Connector *tmp___1 ;
  int tmp___2 ;

  {
#line 911
  if ((unsigned long )d == (unsigned long )((void *)0)) {
#line 911
    return ((Disjunct *)((void *)0));
  }
#line 912
  wd = & work_disjunct;
#line 913
  wc = & work_connector;
#line 914
  d_list = (Disjunct *)((void *)0);
#line 915
  *wd = *d;
#line 916
  tl = d->left;
#line 917
  d->left = (Connector *)((void *)0);
#line 918
  cr = d->right;
  {
  {
#line 918
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 918
    if (! ((unsigned long )cr != (unsigned long )((void *)0))) {
#line 918
      goto while_break;
    }
    {
#line 919
    tr = cr->next;
#line 920
    cr->next = (Connector *)((void *)0);
    {
#line 921
    tmp = is_appropriate(d);
    }
    }
#line 921
    if (tmp) {
      {
      {
#line 922
      connector_for_disjunct(d, wc);
      }
#line 923
      wd->left = tl;
#line 924
      wd->right = wc;
#line 925
      wc->next = tr;
      {
#line 926
      d1 = copy_disjunct(wd);
      }
#line 927
      d1->next = d_list;
#line 928
      d_list = d1;
#line 929
      wd->left = wc;
#line 930
      wc->next = tl;
#line 931
      wd->right = tr;
      {
#line 932
      d1 = copy_disjunct(wd);
      }
#line 933
      d1->next = d_list;
#line 934
      d_list = d1;
      }
    }
#line 936
    cr->next = tr;
#line 918
    cr = cr->next;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 938
  d->left = tl;
#line 940
  tr = d->right;
#line 941
  d->right = (Connector *)((void *)0);
#line 942
  cl = d->left;
  {
  {
#line 942
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 942
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 942
      goto while_break___0;
    }
    {
#line 943
    tl = cl->next;
#line 944
    cl->next = (Connector *)((void *)0);
    {
#line 945
    tmp___0 = is_appropriate(d);
    }
    }
#line 945
    if (tmp___0) {
      {
      {
#line 946
      connector_for_disjunct(d, wc);
      }
#line 947
      wd->left = tl;
#line 948
      wd->right = wc;
#line 949
      wc->next = tr;
      {
#line 950
      d1 = copy_disjunct(wd);
      }
#line 951
      d1->next = d_list;
#line 952
      d_list = d1;
#line 953
      wd->left = wc;
#line 954
      wc->next = tl;
#line 955
      wd->right = tr;
      {
#line 956
      d1 = copy_disjunct(wd);
      }
#line 957
      d1->next = d_list;
#line 958
      d_list = d1;
      }
    }
#line 960
    cl->next = tl;
#line 942
    cl = cl->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 962
  d->right = tr;
#line 964
  cl = d->left;
  {
  {
#line 964
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 964
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 964
      goto while_break___1;
    }
#line 965
    cr = d->right;
    {
    {
#line 965
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 965
      if (! ((unsigned long )cr != (unsigned long )((void *)0))) {
#line 965
        goto while_break___2;
      }
      {
#line 966
      tl = cl->next;
#line 967
      tr = cr->next;
#line 968
      tmp___1 = (Connector *)((void *)0);
#line 968
      cr->next = tmp___1;
#line 968
      cl->next = tmp___1;
      {
#line 969
      tmp___2 = is_appropriate(d);
      }
      }
#line 969
      if (tmp___2) {
        {
        {
#line 970
        connector_for_disjunct(d, wc);
        }
#line 971
        wd->left = tl;
#line 972
        wd->right = wc;
#line 973
        wc->next = tr;
        {
#line 974
        d1 = copy_disjunct(wd);
        }
#line 975
        d1->next = d_list;
#line 976
        d_list = d1;
#line 977
        wd->left = wc;
#line 978
        wc->next = tl;
#line 979
        wd->right = tr;
        {
#line 980
        d1 = copy_disjunct(wd);
        }
#line 981
        d1->next = d_list;
#line 982
        d_list = d1;
        }
      }
#line 984
      cl->next = tl;
#line 985
      cr->next = tr;
#line 965
      cr = cr->next;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 964
    cl = cl->next;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 988
  return (d_list);
}
}
#line 991 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
Disjunct *explode_disjunct_list(Disjunct *d ) 
{ 
  Disjunct *d1 ;
  Disjunct *tmp ;

  {
#line 997
  d1 = (Disjunct *)((void *)0);
  {
  {
#line 999
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 999
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 999
      goto while_break;
    }
    {
    {
#line 1000
    tmp = build_fat_link_substitutions(d);
    }
    {
#line 1000
    d1 = catenate_disjuncts(d1, tmp);
    }
#line 999
    d = d->next;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1002
  return (d1);
}
}
#line 1005 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
Disjunct *build_COMMA_disjunct_list(void) 
{ 
  int lab ;
  Disjunct *d1 ;
  Disjunct *d2 ;
  Disjunct *d ;
  Disjunct work_disjunct ;
  Disjunct *wd ;
  Connector work_connector1 ;
  Connector work_connector2 ;
  Connector *c1 ;
  Connector *c2 ;
  Connector work_connector3 ;
  Connector *c3 ;
  char tmp ;
  char tmp___0 ;
  char tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  short tmp___4 ;
  short tmp___5 ;
  char *__cil_tmp20 ;

  {
#line 1015
  c1 = & work_connector1;
#line 1016
  c2 = & work_connector2;
#line 1017
  c3 = & work_connector3;
#line 1018
  wd = & work_disjunct;
#line 1020
  d1 = (Disjunct *)((void *)0);
#line 1022
  c1->next = (Connector *)((void *)0);
#line 1023
  c2->next = c3;
#line 1024
  c3->next = (Connector *)((void *)0);
#line 1025
  tmp = (char)2;
#line 1025
  c3->priority = tmp;
#line 1025
  c1->priority = tmp;
#line 1026
  c2->priority = (char)1;
#line 1027
  tmp___1 = (char)0;
#line 1027
  c3->multi = tmp___1;
#line 1027
  tmp___0 = tmp___1;
#line 1027
  c2->multi = tmp___0;
#line 1027
  c1->multi = tmp___0;
#line 1028
  wd->left = c1;
#line 1029
  wd->right = c2;
#line 1030
  wd->string = (char *)",";
#line 1031
  wd->next = (Disjunct *)((void *)0);
#line 1032
  wd->cost = (short)0;
#line 1033
  lab = 0;
  {
  {
#line 1033
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1033
    if (! (lab < LT_size)) {
#line 1033
      goto while_break;
    }
#line 1034
    d = *(label_table + lab);
    {
    {
#line 1034
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1034
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1034
        goto while_break___0;
      }
      {
#line 1035
      tmp___3 = d->string;
#line 1035
      c3->string = tmp___3;
#line 1035
      tmp___2 = tmp___3;
#line 1035
      c2->string = tmp___2;
#line 1035
      c1->string = tmp___2;
#line 1036
      tmp___5 = (short )lab;
#line 1036
      c3->label = tmp___5;
#line 1036
      tmp___4 = tmp___5;
#line 1036
      c2->label = tmp___4;
#line 1036
      c1->label = tmp___4;
      {
#line 1037
      d2 = copy_disjunct(wd);
      }
#line 1038
      d2->next = d1;
#line 1039
      d1 = d2;
#line 1034
      d = d->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1033
    lab ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1042
  return (d1);
}
}
#line 1045 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
Disjunct *build_AND_disjunct_list(char *s ) 
{ 
  int lab ;
  Disjunct *d_list ;
  Disjunct *d1 ;
  Disjunct *d3 ;
  Disjunct *d ;
  Disjunct *d_copy ;
  Connector *c1 ;
  Connector *c2 ;
  Connector *c3 ;
  void *tmp ;
  void *tmp___0 ;
  char tmp___1 ;
  char tmp___2 ;
  char *tmp___3 ;
  short tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;
  char *__cil_tmp26 ;
  char *__cil_tmp27 ;
  char *__cil_tmp28 ;
  char *__cil_tmp29 ;
  char *__cil_tmp30 ;
  char *__cil_tmp31 ;
  char *__cil_tmp32 ;
  char *__cil_tmp33 ;
  char *__cil_tmp34 ;
  char *__cil_tmp35 ;
  char *__cil_tmp36 ;

  {
#line 1056
  d_list = (Disjunct *)((void *)0);
#line 1058
  lab = 0;
  {
  {
#line 1058
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1058
    if (! (lab < LT_size)) {
#line 1058
      goto while_break;
    }
#line 1059
    d = *(label_table + lab);
    {
    {
#line 1059
    while (1) {
      while_continue___11: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1059
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1059
        goto while_break___0;
      }
      {
      {
#line 1060
      d1 = build_fat_link_substitutions(d);
      }
      {
#line 1061
      d_copy = copy_disjunct(d);
      }
#line 1062
      d_copy->next = d1;
#line 1063
      d1 = d_copy;
      }
      {
      {
#line 1064
      while (1) {
        while_continue___12: /* CIL Label */ ;
        while_continue___1: /* CIL Label */ ;
#line 1064
        if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 1064
          goto while_break___1;
        }
        {
#line 1065
        d3 = d1->next;
        {
#line 1067
        tmp = xalloc((int )sizeof(Connector ));
        }
#line 1067
        c1 = (Connector *)tmp;
        {
#line 1068
        tmp___0 = xalloc((int )sizeof(Connector ));
        }
#line 1068
        c2 = (Connector *)tmp___0;
#line 1069
        c1->next = (Connector *)((void *)0);
#line 1070
        c2->next = (Connector *)((void *)0);
#line 1071
        tmp___1 = (char)2;
#line 1071
        c2->priority = tmp___1;
#line 1071
        c1->priority = tmp___1;
#line 1072
        tmp___2 = (char)0;
#line 1072
        c2->multi = tmp___2;
#line 1072
        c1->multi = tmp___2;
#line 1073
        tmp___3 = d->string;
#line 1073
        c2->string = tmp___3;
#line 1073
        c1->string = tmp___3;
#line 1074
        tmp___4 = (short )lab;
#line 1074
        c2->label = tmp___4;
#line 1074
        c1->label = tmp___4;
#line 1076
        d1->string = s;
        }
#line 1078
        if ((unsigned long )d1->right == (unsigned long )((void *)0)) {
#line 1079
          d1->right = c2;
        } else {
#line 1081
          c3 = d1->right;
          {
          {
#line 1081
          while (1) {
            while_continue___13: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 1081
            if (! ((unsigned long )c3->next != (unsigned long )((void *)0))) {
#line 1081
              goto while_break___2;
            }
#line 1081
            c3 = c3->next;
          }
          while_break___13: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
#line 1083
          c3->next = c2;
        }
#line 1085
        if ((unsigned long )d1->left == (unsigned long )((void *)0)) {
#line 1086
          d1->left = c1;
        } else {
#line 1088
          c3 = d1->left;
          {
          {
#line 1088
          while (1) {
            while_continue___14: /* CIL Label */ ;
            while_continue___3: /* CIL Label */ ;
#line 1088
            if (! ((unsigned long )c3->next != (unsigned long )((void *)0))) {
#line 1088
              goto while_break___3;
            }
#line 1088
            c3 = c3->next;
          }
          while_break___14: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
#line 1090
          c3->next = c1;
        }
#line 1092
        d1->next = d_list;
#line 1093
        d_list = d1;
#line 1064
        d1 = d3;
      }
      while_break___12: /* CIL Label */ ;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1059
      d = d->next;
    }
    while_break___11: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1058
    lab ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1106
  tmp___7 = strcmp((char const   *)s, "and");
  }
  }
#line 1106
  if (tmp___7 == 0) {
#line 1107
    d1 = d_list;
    {
    {
#line 1107
    while (1) {
      while_continue___15: /* CIL Label */ ;
      while_continue___4: /* CIL Label */ ;
#line 1107
      if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 1107
        goto while_break___4;
      }
#line 1108
      c1 = d1->right;
      {
      {
#line 1108
      while (1) {
        while_continue___16: /* CIL Label */ ;
        while_continue___5: /* CIL Label */ ;
#line 1108
        if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 1108
          goto while_break___5;
        }
#line 1109
        if ((int )*(c1->string + 0) == 83) {
#line 1109
          if ((int )*(c1->string + 1) == 94) {
#line 1114
            c1->string = (char *)"Sp";
          } else
#line 1109
          if ((int )*(c1->string + 1) == 115) {
#line 1114
            c1->string = (char *)"Sp";
          } else
#line 1109
          if ((int )*(c1->string + 1) == 112) {
#line 1114
            c1->string = (char *)"Sp";
          } else
#line 1109
          if ((int )*(c1->string + 1) == 0) {
#line 1114
            c1->string = (char *)"Sp";
          }
        }
#line 1108
        c1 = c1->next;
      }
      while_break___16: /* CIL Label */ ;
      }
      while_break___5: /* CIL Label */ ;
      }
#line 1117
      c1 = d1->left;
      {
      {
#line 1117
      while (1) {
        while_continue___17: /* CIL Label */ ;
        while_continue___6: /* CIL Label */ ;
#line 1117
        if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 1117
          goto while_break___6;
        }
#line 1118
        if ((int )*(c1->string + 0) == 83) {
#line 1118
          if ((int )*(c1->string + 1) == 73) {
#line 1118
            if ((int )*(c1->string + 2) == 94) {
#line 1123
              c1->string = (char *)"SIp";
            } else
#line 1118
            if ((int )*(c1->string + 2) == 115) {
#line 1123
              c1->string = (char *)"SIp";
            } else
#line 1118
            if ((int )*(c1->string + 2) == 112) {
#line 1123
              c1->string = (char *)"SIp";
            } else
#line 1118
            if ((int )*(c1->string + 2) == 0) {
#line 1123
              c1->string = (char *)"SIp";
            }
          }
        }
#line 1117
        c1 = c1->next;
      }
      while_break___17: /* CIL Label */ ;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1107
      d1 = d1->next;
    }
    while_break___15: /* CIL Label */ ;
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
    {
#line 1182
    tmp___5 = strcmp((char const   *)s, "nor");
    }
    }
#line 1182
    if (tmp___5 == 0) {
#line 1182
      goto _L;
    } else {
      {
      {
#line 1182
      tmp___6 = strcmp((char const   *)s, "or");
      }
      }
#line 1182
      if (tmp___6 == 0) {
        _L: /* CIL Label */ 
#line 1183
        d1 = d_list;
        {
        {
#line 1183
        while (1) {
          while_continue___18: /* CIL Label */ ;
          while_continue___7: /* CIL Label */ ;
#line 1183
          if (! ((unsigned long )d1 != (unsigned long )((void *)0))) {
#line 1183
            goto while_break___7;
          }
#line 1184
          c1 = d1->right;
          {
          {
#line 1184
          while (1) {
            while_continue___19: /* CIL Label */ ;
            while_continue___8: /* CIL Label */ ;
#line 1184
            if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 1184
              goto while_break___8;
            }
#line 1185
            if ((int )*(c1->string + 0) == 83) {
#line 1185
              if ((int )*(c1->string + 1) == 94) {
#line 1189
                c1->string = (char *)"S";
              } else
#line 1185
              if ((int )*(c1->string + 1) == 115) {
#line 1189
                c1->string = (char *)"S";
              } else
#line 1185
              if ((int )*(c1->string + 1) == 112) {
#line 1189
                c1->string = (char *)"S";
              }
            }
#line 1184
            c1 = c1->next;
          }
          while_break___19: /* CIL Label */ ;
          }
          while_break___8: /* CIL Label */ ;
          }
#line 1192
          c1 = d1->left;
          {
          {
#line 1192
          while (1) {
            while_continue___20: /* CIL Label */ ;
            while_continue___9: /* CIL Label */ ;
#line 1192
            if (! ((unsigned long )c1 != (unsigned long )((void *)0))) {
#line 1192
              goto while_break___9;
            }
#line 1193
            if ((int )*(c1->string + 0) == 83) {
#line 1193
              if ((int )*(c1->string + 1) == 73) {
#line 1193
                if ((int )*(c1->string + 2) == 94) {
#line 1197
                  c1->string = (char *)"SI";
                } else
#line 1193
                if ((int )*(c1->string + 2) == 115) {
#line 1197
                  c1->string = (char *)"SI";
                } else
#line 1193
                if ((int )*(c1->string + 2) == 112) {
#line 1197
                  c1->string = (char *)"SI";
                }
              }
            }
#line 1192
            c1 = c1->next;
          }
          while_break___20: /* CIL Label */ ;
          }
          while_break___9: /* CIL Label */ ;
          }
#line 1183
          d1 = d1->next;
        }
        while_break___18: /* CIL Label */ ;
        }
        while_break___7: /* CIL Label */ ;
        }
      }
    }
  }
#line 1204
  return (d_list);
}
}
#line 1252 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
Image_node *image_array[250]  ;
#line 1257 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int set_has_fat_down(void) 
{ 
  int link ;
  int w ;
  int N_fat ;

  {
#line 1264
  N_fat = 0;
#line 1266
  w = 0;
  {
  {
#line 1266
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1266
    if (! (w < N_words)) {
#line 1266
      goto while_break;
    }
#line 1267
    has_fat_down[w] = (char)0;
#line 1266
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1270
  link = 0;
  {
  {
#line 1270
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1270
    if (! (link < N_links)) {
#line 1270
      goto while_break___0;
    }
#line 1271
    if ((int )(link_array[link].lc)->priority == 2) {
#line 1272
      N_fat ++;
#line 1273
      has_fat_down[link_array[link].l] = (char)1;
    } else
#line 1274
    if ((int )(link_array[link].rc)->priority == 2) {
#line 1275
      N_fat ++;
#line 1276
      has_fat_down[link_array[link].r] = (char)1;
    }
#line 1270
    link ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1279
  return (N_fat > 0);
}
}
#line 1282 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void free_image_array(void) 
{ 
  int w ;
  Image_node *in ;
  Image_node *inx ;

  {
#line 1285
  w = 0;
  {
  {
#line 1285
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1285
    if (! (w < N_words)) {
#line 1285
      goto while_break;
    }
#line 1286
    in = image_array[w];
    {
    {
#line 1286
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1286
      if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 1286
        goto while_break___0;
      }
      {
#line 1287
      inx = in->next;
      {
#line 1288
      xfree((char *)in, (int )sizeof(Image_node ));
      }
#line 1286
      in = inx;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1285
    w ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1291
  return;
}
}
#line 1293 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void build_image_array(void) 
{ 
  int link ;
  int end ;
  int word ;
  Connector *this_end_con ;
  Connector *other_end_con ;
  Connector *upcon ;
  Connector *updiscon ;
  Connector *clist ;
  Disjunct *dis ;
  Disjunct *updis ;
  Image_node *in ;
  void *tmp ;

  {
#line 1301
  word = 0;
  {
  {
#line 1301
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1301
    if (! (word < N_words)) {
#line 1301
      goto while_break;
    }
#line 1302
    image_array[word] = (Image_node *)((void *)0);
#line 1301
    word ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1305
  end = -1;
  {
  {
#line 1305
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 1305
    if (! (end <= 1)) {
#line 1305
      goto while_break___0;
    }
#line 1306
    link = 0;
    {
    {
#line 1306
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1306
      if (! (link < N_links)) {
#line 1306
        goto while_break___1;
      }
#line 1307
      if (end < 0) {
#line 1308
        word = link_array[link].l;
#line 1309
        if (! has_fat_down[word]) {
#line 1309
          goto __Cont;
        }
#line 1310
        this_end_con = link_array[link].lc;
#line 1311
        other_end_con = link_array[link].rc;
#line 1312
        dis = chosen_disjuncts[word];
#line 1313
        clist = dis->right;
      } else {
#line 1315
        word = link_array[link].r;
#line 1316
        if (! has_fat_down[word]) {
#line 1316
          goto __Cont;
        }
#line 1317
        this_end_con = link_array[link].rc;
#line 1318
        other_end_con = link_array[link].lc;
#line 1319
        dis = chosen_disjuncts[word];
#line 1320
        clist = dis->left;
      }
#line 1323
      if ((int )this_end_con->priority == 2) {
#line 1323
        goto __Cont;
      }
#line 1324
      if ((int )this_end_con->label != -1) {
#line 1324
        if ((int )this_end_con->label < 0) {
#line 1325
          goto __Cont;
        }
      }
      {
      {
#line 1329
      tmp = xalloc((int )sizeof(Image_node ));
      }
#line 1329
      in = (Image_node *)tmp;
#line 1330
      in->next = image_array[word];
#line 1331
      image_array[word] = in;
#line 1332
      in->c = other_end_con;
      }
#line 1334
      if ((int )this_end_con->priority == 1) {
#line 1335
        in->place = 0;
      } else {
#line 1337
        in->place = 1;
#line 1338
        if ((unsigned long )dis->left != (unsigned long )((void *)0)) {
#line 1338
          if ((int )(dis->left)->priority == 1) {
#line 1340
            upcon = dis->left;
          } else {
#line 1338
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1341
        if ((unsigned long )dis->right != (unsigned long )((void *)0)) {
#line 1341
          if ((int )(dis->right)->priority == 1) {
#line 1343
            upcon = dis->right;
          } else {
#line 1345
            upcon = (Connector *)((void *)0);
          }
        } else {
#line 1345
          upcon = (Connector *)((void *)0);
        }
#line 1347
        if ((unsigned long )upcon != (unsigned long )((void *)0)) {
#line 1348
          updis = *(label_table + upcon->label);
#line 1349
          if (end > 0) {
#line 1350
            updiscon = updis->left;
          } else {
#line 1352
            updiscon = updis->right;
          }
          {
          {
#line 1354
          while (1) {
            while_continue___7: /* CIL Label */ ;
            while_continue___2: /* CIL Label */ ;
#line 1354
            if (! ((unsigned long )updiscon != (unsigned long )((void *)0))) {
#line 1354
              goto while_break___2;
            }
#line 1355
            (in->place) ++;
#line 1354
            updiscon = updiscon->next;
          }
          while_break___7: /* CIL Label */ ;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
        {
        {
#line 1358
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___3: /* CIL Label */ ;
#line 1358
          if (! ((unsigned long )clist != (unsigned long )this_end_con)) {
#line 1358
            goto while_break___3;
          }
#line 1359
          if ((int )clist->label < 0) {
#line 1359
            (in->place) ++;
          }
#line 1358
          clist = clist->next;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 1361
        in->place *= - end;
      }
      __Cont: /* CIL Label */ 
#line 1306
      link ++;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1305
    end += 2;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1365
  return;
}
}
#line 1367 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int strictly_smaller(char *s , char *t ) 
{ 
  int strictness ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;

  {
#line 1372
  strictness = 0;
  {
  {
#line 1373
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1373
    if ((int )*s != 0) {
#line 1373
      if (! ((int )*t != 0)) {
#line 1373
        goto while_break;
      }
    } else {
#line 1373
      goto while_break;
    }
#line 1374
    if ((int )*s == (int )*t) {
#line 1374
      goto __Cont;
    }
#line 1375
    if ((int )*t == 42) {
#line 1376
      strictness ++;
    } else
#line 1375
    if ((int )*s == 94) {
#line 1376
      strictness ++;
    } else {
#line 1378
      return (0);
    }
    __Cont: /* CIL Label */ 
#line 1373
    s ++;
#line 1373
    t ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1381
  if ((int )*s != 0) {
    {
    {
#line 1381
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "s and t should be the same length!");
    }
    {
#line 1381
    exit(1);
    }
    }
  } else
#line 1381
  if ((int )*t != 0) {
    {
    {
#line 1381
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "s and t should be the same length!");
    }
    {
#line 1381
    exit(1);
    }
    }
  }
#line 1382
  return (strictness > 0);
}
}
#line 1385 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
Disjunct *find_subdisjunct(Disjunct *dis , int label ) 
{ 
  Disjunct *d ;
  Connector *cx ;
  Connector *cy ;
  int tmp ;
  int tmp___0 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;

  {
#line 1393
  d = *(label_table + label);
  {
  {
#line 1393
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1393
    if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 1393
      goto while_break;
    }
#line 1394
    cx = d->left;
#line 1394
    cy = dis->left;
    {
    {
#line 1394
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1394
      if (! ((unsigned long )cx != (unsigned long )((void *)0))) {
#line 1394
        goto while_break___0;
      }
      {
      {
#line 1396
      tmp = strcmp((char const   *)cx->string, (char const   *)cy->string);
      }
      }
#line 1396
      if (tmp != 0) {
#line 1397
        goto while_break___0;
      } else
#line 1396
      if ((int )cx->multi != (int )cy->multi) {
#line 1397
        goto while_break___0;
      }
#line 1394
      cx = cx->next;
#line 1394
      cy = cy->next;
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1399
    if ((unsigned long )cx != (unsigned long )((void *)0)) {
#line 1399
      goto __Cont;
    }
#line 1400
    cx = d->right;
#line 1400
    cy = dis->right;
    {
    {
#line 1400
    while (1) {
      while_continue___4: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1400
      if (! ((unsigned long )cx != (unsigned long )((void *)0))) {
#line 1400
        goto while_break___1;
      }
      {
      {
#line 1402
      tmp___0 = strcmp((char const   *)cx->string, (char const   *)cy->string);
      }
      }
#line 1402
      if (tmp___0 != 0) {
#line 1403
        goto while_break___1;
      } else
#line 1402
      if ((int )cx->multi != (int )cy->multi) {
#line 1403
        goto while_break___1;
      }
#line 1400
      cx = cx->next;
#line 1400
      cy = cy->next;
    }
    while_break___4: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1405
    if ((unsigned long )cx == (unsigned long )((void *)0)) {
#line 1405
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 1393
    d = d->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1407
  if (! ((unsigned long )d != (unsigned long )((void *)0))) {
    {
    {
#line 1407
    printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Never found subdisjunct");
    }
    {
#line 1407
    exit(1);
    }
    }
  }
#line 1408
  return (d);
}
}
#line 1411 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
int is_canonical_linkage(void) 
{ 
  int w ;
  int d_label ;
  int place ;
  Connector *d_c ;
  Connector *c ;
  Connector dummy_connector ;
  Connector *upcon ;
  Disjunct *dis ;
  Disjunct *chosen_d ;
  Image_node *in ;
  int tmp ;
  Disjunct *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;

  {
  {
#line 1418
  d_label = 0;
#line 1423
  dummy_connector.priority = (char)1;
  {
#line 1425
  build_image_array();
  }
#line 1427
  w = 0;
  }
  {
  {
#line 1427
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1427
    if (! (w < N_words)) {
#line 1427
      goto while_break;
    }
#line 1428
    if (! has_fat_down[w]) {
#line 1428
      goto __Cont;
    }
#line 1429
    chosen_d = chosen_disjuncts[w];
#line 1432
    d_c = chosen_d->left;
    {
    {
#line 1432
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1432
      if (! ((unsigned long )d_c != (unsigned long )((void *)0))) {
#line 1432
        goto while_break___0;
      }
#line 1433
      if ((int )d_c->priority == 2) {
#line 1434
        d_label = (int )d_c->label;
#line 1435
        goto while_break___0;
      }
#line 1432
      d_c = d_c->next;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1438
    if (! ((unsigned long )d_c != (unsigned long )((void *)0))) {
      {
      {
#line 1438
      printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Should have found the down link.");
      }
      {
#line 1438
      exit(1);
      }
      }
    }
#line 1440
    if ((unsigned long )chosen_d->left != (unsigned long )((void *)0)) {
#line 1440
      if ((int )(chosen_d->left)->priority == 1) {
#line 1442
        upcon = chosen_d->left;
      } else {
#line 1440
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1443
    if ((unsigned long )chosen_d->right != (unsigned long )((void *)0)) {
#line 1443
      if ((int )(chosen_d->right)->priority == 1) {
#line 1445
        upcon = chosen_d->right;
      } else {
#line 1447
        upcon = (Connector *)((void *)0);
      }
    } else {
#line 1447
      upcon = (Connector *)((void *)0);
    }
#line 1452
    dis = *(label_table + d_label);
    {
    {
#line 1452
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 1452
      if (! ((unsigned long )dis != (unsigned long )((void *)0))) {
#line 1452
        goto while_break___1;
      }
      {
      {
#line 1455
      tmp = strictly_smaller(dis->string, d_c->string);
      }
      }
#line 1455
      if (! tmp) {
#line 1455
        goto __Cont___0;
      }
#line 1459
      in = image_array[w];
      {
      {
#line 1459
      while (1) {
        while_continue___8: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1459
        if (! ((unsigned long )in != (unsigned long )((void *)0))) {
#line 1459
          goto while_break___2;
        }
#line 1461
        place = in->place;
#line 1462
        if (place == 0) {
#line 1464
          if (! ((unsigned long )upcon != (unsigned long )((void *)0))) {
            {
            {
#line 1464
            printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Should have found an up link");
            }
            {
#line 1464
            exit(1);
            }
            }
          }
#line 1465
          dummy_connector.label = upcon->label;
#line 1471
          if ((int )upcon->label == d_label) {
#line 1472
            dummy_connector.string = dis->string;
          } else {
            {
            {
#line 1474
            tmp___0 = find_subdisjunct(dis, (int )upcon->label);
            }
#line 1474
            dummy_connector.string = tmp___0->string;
            }
          }
          {
          {
#line 1477
          tmp___1 = match(& dummy_connector, in->c);
          }
          }
#line 1477
          if (! tmp___1) {
#line 1477
            goto while_break___2;
          }
        } else
#line 1478
        if (place > 0) {
#line 1479
          c = dis->right;
          {
          {
#line 1479
          while (1) {
            while_continue___9: /* CIL Label */ ;
            while_continue___3: /* CIL Label */ ;
#line 1479
            if (! (place > 1)) {
#line 1479
              goto while_break___3;
            }
#line 1480
            c = c->next;
#line 1479
            place --;
          }
          while_break___9: /* CIL Label */ ;
          }
          while_break___3: /* CIL Label */ ;
          }
          {
          {
#line 1482
          tmp___2 = match(c, in->c);
          }
          }
#line 1482
          if (! tmp___2) {
#line 1482
            goto while_break___2;
          }
        } else {
#line 1484
          c = dis->left;
          {
          {
#line 1484
          while (1) {
            while_continue___10: /* CIL Label */ ;
            while_continue___4: /* CIL Label */ ;
#line 1484
            if (! (place < -1)) {
#line 1484
              goto while_break___4;
            }
#line 1485
            c = c->next;
#line 1484
            place ++;
          }
          while_break___10: /* CIL Label */ ;
          }
          while_break___4: /* CIL Label */ ;
          }
          {
          {
#line 1487
          tmp___3 = match(c, in->c);
          }
          }
#line 1487
          if (! tmp___3) {
#line 1487
            goto while_break___2;
          }
        }
#line 1459
        in = in->next;
      }
      while_break___8: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1491
      if ((unsigned long )in == (unsigned long )((void *)0)) {
#line 1491
        goto while_break___1;
      }
      __Cont___0: /* CIL Label */ 
#line 1452
      dis = dis->next;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1493
    if ((unsigned long )dis != (unsigned long )((void *)0)) {
#line 1493
      goto while_break;
    }
    __Cont: /* CIL Label */ 
#line 1427
    w ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 1497
  free_image_array();
  }
  }
#line 1498
  return (w == N_words);
}
}
#line 1501 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/and.c"
void compute_pp_link_array_connectors(void) 
{ 
  int link ;
  int end ;
  int word ;
  int place ;
  Connector *this_end_con ;
  Connector *upcon ;
  Connector *updiscon ;
  Connector *clist ;
  Connector *con ;
  Connector *mycon ;
  Disjunct *dis ;
  Disjunct *updis ;
  Disjunct *mydis ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;
  char *__cil_tmp22 ;
  char *__cil_tmp23 ;
  char *__cil_tmp24 ;
  char *__cil_tmp25 ;

  {
#line 1514
  end = -1;
  {
  {
#line 1514
  while (1) {
    while_continue___6: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 1514
    if (! (end <= 1)) {
#line 1514
      goto while_break;
    }
#line 1515
    link = 0;
    {
    {
#line 1515
    while (1) {
      while_continue___7: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 1515
      if (! (link < N_links)) {
#line 1515
        goto while_break___0;
      }
#line 1516
      if (pp_link_array[link].l == -1) {
#line 1516
        goto __Cont;
      }
#line 1517
      if (end < 0) {
#line 1518
        word = link_array[link].l;
#line 1519
        if (! has_fat_down[word]) {
#line 1519
          goto __Cont;
        }
#line 1520
        this_end_con = link_array[link].lc;
#line 1521
        dis = chosen_disjuncts[word];
#line 1522
        mydis = chosen_disjuncts[pp_link_array[link].l];
#line 1523
        clist = dis->right;
      } else {
#line 1525
        word = link_array[link].r;
#line 1526
        if (! has_fat_down[word]) {
#line 1526
          goto __Cont;
        }
#line 1527
        this_end_con = link_array[link].rc;
#line 1528
        dis = chosen_disjuncts[word];
#line 1529
        mydis = chosen_disjuncts[pp_link_array[link].r];
#line 1530
        clist = dis->left;
      }
#line 1533
      if ((int )this_end_con->label != -1) {
#line 1533
        goto __Cont;
      }
#line 1538
      place = 0;
#line 1539
      if ((unsigned long )dis->left != (unsigned long )((void *)0)) {
#line 1539
        if ((int )(dis->left)->priority == 1) {
#line 1541
          upcon = dis->left;
        } else {
#line 1539
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 1542
      if ((unsigned long )dis->right != (unsigned long )((void *)0)) {
#line 1542
        if ((int )(dis->right)->priority == 1) {
#line 1544
          upcon = dis->right;
        } else {
#line 1546
          upcon = (Connector *)((void *)0);
        }
      } else {
#line 1546
        upcon = (Connector *)((void *)0);
      }
#line 1548
      if ((unsigned long )upcon != (unsigned long )((void *)0)) {
#line 1549
        updis = *(label_table + upcon->label);
#line 1550
        if (end > 0) {
#line 1551
          updiscon = updis->left;
        } else {
#line 1553
          updiscon = updis->right;
        }
        {
        {
#line 1555
        while (1) {
          while_continue___8: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 1555
          if (! ((unsigned long )updiscon != (unsigned long )((void *)0))) {
#line 1555
            goto while_break___1;
          }
#line 1556
          place ++;
#line 1555
          updiscon = updiscon->next;
        }
        while_break___8: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
      {
      {
#line 1559
      while (1) {
        while_continue___9: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 1559
        if (! ((unsigned long )clist != (unsigned long )this_end_con)) {
#line 1559
          goto while_break___2;
        }
#line 1560
        if ((int )clist->label < 0) {
#line 1560
          place ++;
        }
#line 1559
        clist = clist->next;
      }
      while_break___9: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1565
      if ((unsigned long )mydis->left != (unsigned long )((void *)0)) {
#line 1565
        if ((int )(mydis->left)->priority == 1) {
#line 1567
          mycon = mydis->left;
        } else {
#line 1565
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 1568
      if ((unsigned long )mydis->right != (unsigned long )((void *)0)) {
#line 1568
        if ((int )(mydis->right)->priority == 1) {
#line 1570
          mycon = mydis->right;
        } else {
          {
          {
#line 1572
          printf((char const   */* __restrict  */)"word = %d\n", word);
          }
          {
#line 1573
          printf((char const   */* __restrict  */)"fat link: [%d, %d]\n", link_array[link].l,
                 link_array[link].r);
          }
          {
#line 1574
          printf((char const   */* __restrict  */)"thin link: [%d, %d]\n", pp_link_array[link].l,
                 pp_link_array[link].r);
          }
          {
#line 1575
          printf((char const   */* __restrict  */)"Assertion failed: %s\n", "There should be a fat UP link here");
          }
          {
#line 1575
          exit(1);
          }
          }
        }
      } else {
        {
        {
#line 1572
        printf((char const   */* __restrict  */)"word = %d\n", word);
        }
        {
#line 1573
        printf((char const   */* __restrict  */)"fat link: [%d, %d]\n", link_array[link].l,
               link_array[link].r);
        }
        {
#line 1574
        printf((char const   */* __restrict  */)"thin link: [%d, %d]\n", pp_link_array[link].l,
               pp_link_array[link].r);
        }
        {
#line 1575
        printf((char const   */* __restrict  */)"Assertion failed: %s\n", "There should be a fat UP link here");
        }
        {
#line 1575
        exit(1);
        }
        }
      }
#line 1578
      dis = *(label_table + mycon->label);
      {
      {
#line 1578
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 1578
        if (! ((unsigned long )dis != (unsigned long )((void *)0))) {
#line 1578
          goto while_break___3;
        }
#line 1579
        if ((unsigned long )dis->string == (unsigned long )mycon->string) {
#line 1579
          goto while_break___3;
        }
#line 1578
        dis = dis->next;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 1581
      if (! ((unsigned long )dis != (unsigned long )((void *)0))) {
        {
        {
#line 1581
        printf((char const   */* __restrict  */)"Assertion failed: %s\n", "Should have found this connector string");
        }
        {
#line 1581
        exit(1);
        }
        }
      }
#line 1584
      if (end < 0) {
#line 1585
        con = dis->right;
        {
        {
#line 1585
        while (1) {
          while_continue___11: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 1585
          if (! (place > 0)) {
#line 1585
            goto while_break___4;
          }
#line 1585
          place --;
#line 1585
          con = con->next;
        }
        while_break___11: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 1586
        pp_link_array[link].lc = con;
      } else {
#line 1588
        con = dis->left;
        {
        {
#line 1588
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___5: /* CIL Label */ ;
#line 1588
          if (! (place > 0)) {
#line 1588
            goto while_break___5;
          }
#line 1588
          place --;
#line 1588
          con = con->next;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1589
        pp_link_array[link].rc = con;
      }
      __Cont: /* CIL Label */ 
#line 1515
      link ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1514
    end += 2;
  }
  while_break___6: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 1593
  return;
}
}
#line 313 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
int N_null  ;
#line 350 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/header.h"
Link pp_link_array[497]  ;
#line 388
void print_links(FILE *fp ) ;
#line 62 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
static List_o_links *word_links___0[250]  ;
#line 65 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void build_digraph(void) 
{ 
  int i ;
  int link ;
  int N_fat ;
  Link *lp ;
  List_o_links *lol ;
  void *tmp ;
  void *tmp___0 ;

  {
#line 76
  N_fat = 0;
#line 77
  i = 0;
  {
  {
#line 77
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 77
    if (! (i < N_words)) {
#line 77
      goto while_break;
    }
#line 78
    word_links___0[i] = (List_o_links *)((void *)0);
#line 77
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 80
  link = 0;
  {
  {
#line 80
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 80
    if (! (link < N_links)) {
#line 80
      goto while_break___0;
    }
#line 81
    lp = & link_array[link];
#line 82
    i = (int )(lp->lc)->label;
#line 83
    if (i < -1) {
#line 84
      goto __Cont;
    }
    {
    {
#line 86
    tmp = xalloc((int )sizeof(List_o_links ));
    }
#line 86
    lol = (List_o_links *)tmp;
#line 87
    lol->next = word_links___0[lp->l];
#line 88
    word_links___0[lp->l] = lol;
#line 89
    lol->link = link;
#line 90
    lol->word = lp->r;
#line 91
    i = (int )(lp->lc)->priority;
    }
#line 92
    if (i == 0) {
#line 93
      lol->dir = 0;
    } else
#line 94
    if (i == 2) {
#line 95
      lol->dir = 1;
    } else {
#line 97
      lol->dir = -1;
    }
    {
    {
#line 99
    tmp___0 = xalloc((int )sizeof(List_o_links ));
    }
#line 99
    lol = (List_o_links *)tmp___0;
#line 100
    lol->next = word_links___0[lp->r];
#line 101
    word_links___0[lp->r] = lol;
#line 102
    lol->link = link;
#line 103
    lol->word = lp->l;
#line 104
    i = (int )(lp->rc)->priority;
    }
#line 105
    if (i == 0) {
#line 106
      lol->dir = 0;
    } else
#line 107
    if (i == 2) {
#line 108
      lol->dir = 1;
    } else {
#line 110
      lol->dir = -1;
    }
    __Cont: /* CIL Label */ 
#line 80
    link ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  return;
}
}
#line 115 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
static int structure_violation  ;
#line 116 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
static int dfs_root_word[250]  ;
#line 119 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
int is_CON_word(int w ) 
{ 
  List_o_links *lol ;

  {
#line 122
  lol = word_links___0[w];
  {
  {
#line 122
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 122
      goto while_break;
    }
#line 123
    if (lol->dir == 1) {
#line 124
      return (1);
    }
#line 122
    lol = lol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 127
  return (0);
}
}
#line 130
DIS_node *build_DIS_node(int w ) ;
#line 131
CON_list *c_dfs(int w , DIS_node *start_dn , CON_list *c ) ;
#line 133 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
CON_node *build_CON_node(int w ) 
{ 
  List_o_links *lol ;
  CON_node *a ;
  DIS_list *d ;
  DIS_list *dx ;
  void *tmp ;
  void *tmp___0 ;
  DIS_list *tmp___1 ;

  {
#line 138
  d = (DIS_list *)((void *)0);
#line 139
  lol = word_links___0[w];
  {
  {
#line 139
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 139
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 139
      goto while_break;
    }
#line 140
    if (lol->dir == 1) {
      {
      {
#line 141
      tmp = xalloc((int )sizeof(DIS_list ));
      }
#line 141
      dx = (DIS_list *)tmp;
#line 142
      dx->next = d;
#line 143
      d = dx;
      {
#line 144
      d->dn = build_DIS_node(lol->word);
      }
      }
    }
#line 139
    lol = lol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 147
  tmp___0 = xalloc((int )sizeof(CON_node ));
  }
#line 147
  a = (CON_node *)tmp___0;
#line 148
  tmp___1 = d;
#line 148
  a->current = tmp___1;
#line 148
  a->dl = tmp___1;
#line 149
  a->word = w;
  }
#line 150
  return (a);
}
}
#line 153 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
CON_list *c_dfs(int w , DIS_node *start_dn , CON_list *c ) 
{ 
  CON_list *cx ;
  List_o_links *lol ;
  List_o_links *lolx ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
#line 161
  if (dfs_root_word[w] != -1) {
#line 162
    if (dfs_root_word[w] != start_dn->word) {
#line 163
      structure_violation = 1;
    }
#line 165
    return (c);
  }
#line 167
  dfs_root_word[w] = start_dn->word;
#line 168
  lol = word_links___0[w];
  {
  {
#line 168
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 168
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 168
      goto while_break;
    }
#line 169
    if (lol->dir < 0) {
#line 170
      if (dfs_root_word[lol->word] == -1) {
#line 171
        structure_violation = 1;
      }
    } else
#line 173
    if (lol->dir == 0) {
      {
      {
#line 174
      tmp = xalloc((int )sizeof(List_o_links ));
      }
#line 174
      lolx = (List_o_links *)tmp;
#line 175
      lolx->next = start_dn->lol;
#line 176
      lolx->link = lol->link;
#line 177
      start_dn->lol = lolx;
      {
#line 178
      c = c_dfs(lol->word, start_dn, c);
      }
      }
    }
#line 168
    lol = lol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 181
  tmp___1 = is_CON_word(w);
  }
  }
#line 181
  if (tmp___1) {
    {
    {
#line 182
    tmp___0 = xalloc((int )sizeof(CON_list ));
    }
#line 182
    cx = (CON_list *)tmp___0;
#line 183
    cx->next = c;
#line 184
    c = cx;
    {
#line 185
    c->cn = build_CON_node(w);
    }
    }
  }
#line 187
  return (c);
}
}
#line 190 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
DIS_node *build_DIS_node(int w ) 
{ 
  DIS_node *dn ;
  void *tmp ;

  {
  {
  {
#line 196
  tmp = xalloc((int )sizeof(DIS_node ));
  }
#line 196
  dn = (DIS_node *)tmp;
#line 197
  dn->word = w;
#line 198
  dn->lol = (List_o_links *)((void *)0);
  {
#line 199
  dn->cl = c_dfs(w, dn, (CON_list *)((void *)0));
  }
  }
#line 200
  return (dn);
}
}
#line 203 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
DIS_node *build_DIS_CON_tree(void) 
{ 
  int w ;
  DIS_node *dnroot ;
  DIS_node *dn ;
  CON_list *child ;
  CON_list *xchild ;
  List_o_links *lol ;
  List_o_links *xlol ;

  {
#line 208
  w = 0;
  {
  {
#line 208
  while (1) {
    while_continue___3: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 208
    if (! (w < N_words)) {
#line 208
      goto while_break;
    }
#line 209
    dfs_root_word[w] = -1;
#line 208
    w ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 211
  dnroot = (DIS_node *)((void *)0);
#line 212
  w = 0;
  {
  {
#line 212
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 212
    if (! (w < N_words)) {
#line 212
      goto while_break___0;
    }
#line 213
    if (dfs_root_word[w] == -1) {
      {
      {
#line 214
      dn = build_DIS_node(w);
      }
      }
#line 215
      if ((unsigned long )dnroot == (unsigned long )((void *)0)) {
#line 216
        dnroot = dn;
      } else {
#line 218
        child = dn->cl;
        {
        {
#line 218
        while (1) {
          while_continue___5: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 218
          if (! ((unsigned long )child != (unsigned long )((void *)0))) {
#line 218
            goto while_break___1;
          }
#line 219
          xchild = child->next;
#line 220
          child->next = dnroot->cl;
#line 221
          dnroot->cl = child;
#line 218
          child = xchild;
        }
        while_break___5: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 223
        lol = dn->lol;
        {
        {
#line 223
        while (1) {
          while_continue___6: /* CIL Label */ ;
          while_continue___2: /* CIL Label */ ;
#line 223
          if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 223
            goto while_break___2;
          }
#line 224
          xlol = lol->next;
#line 225
          lol->next = dnroot->lol;
#line 226
          dnroot->lol = lol;
#line 223
          lol = xlol;
        }
        while_break___6: /* CIL Label */ ;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
        {
#line 228
        xfree((char *)((void *)dn), (int )sizeof(DIS_node ));
        }
        }
      }
    }
#line 212
    w ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 232
  return (dnroot);
}
}
#line 235
int advance_CON(CON_node *cn ) ;
#line 236 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
int advance_DIS(DIS_node *dn ) 
{ 
  CON_list *cl ;
  int tmp ;

  {
#line 242
  cl = dn->cl;
  {
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 242
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 242
      goto while_break;
    }
    {
    {
#line 243
    tmp = advance_CON(cl->cn);
    }
    }
#line 243
    if (tmp) {
#line 244
      return (1);
    }
#line 242
    cl = cl->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  return (0);
}
}
#line 250 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
int advance_CON(CON_node *cn ) 
{ 
  int tmp ;

  {
  {
  {
#line 255
  tmp = advance_DIS((cn->current)->dn);
  }
  }
#line 255
  if (tmp) {
#line 256
    return (1);
  } else
#line 258
  if ((unsigned long )(cn->current)->next == (unsigned long )((void *)0)) {
#line 259
    cn->current = cn->dl;
#line 260
    return (0);
  } else {
#line 262
    cn->current = (cn->current)->next;
#line 263
    return (1);
  }
}
}
#line 276 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
static Patch_element patch_array[497]  ;
#line 278
void fill_patch_array_CON(CON_node *cn , Links_to_patch *ltp ) ;
#line 280 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void fill_patch_array_DIS(DIS_node *dn , Links_to_patch *ltp ) 
{ 
  CON_list *cl ;
  List_o_links *lol ;
  Links_to_patch *ltpx ;

  {
#line 286
  lol = dn->lol;
  {
  {
#line 286
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 286
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 286
      goto while_break;
    }
#line 287
    patch_array[lol->link].used = (char)1;
#line 286
    lol = lol->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 289
  if ((unsigned long )dn->cl == (unsigned long )((void *)0)) {
#line 289
    goto _L;
  } else
#line 289
  if (((dn->cl)->cn)->word != dn->word) {
    _L: /* CIL Label */ 
    {
    {
#line 290
    while (1) {
      while_continue___3: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 290
      if (! ((unsigned long )ltp != (unsigned long )((void *)0))) {
#line 290
        goto while_break___0;
      }
#line 291
      ltpx = ltp->next;
#line 292
      patch_array[ltp->link].changed = (char)1;
#line 293
      if ((int )ltp->dir == 108) {
#line 294
        patch_array[ltp->link].newl = dn->word;
      } else {
#line 296
        patch_array[ltp->link].newr = dn->word;
      }
      {
      {
#line 298
      xfree((char *)((void *)ltp), (int )sizeof(Links_to_patch ));
      }
#line 290
      ltp = ltpx;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 303
  cl = dn->cl;
  {
  {
#line 303
  while (1) {
    while_continue___4: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 303
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 303
      goto while_break___1;
    }
    {
    {
#line 304
    fill_patch_array_CON(cl->cn, ltp);
    }
#line 305
    ltp = (Links_to_patch *)((void *)0);
#line 303
    cl = cl->next;
    }
  }
  while_break___4: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 307
  return;
}
}
#line 309 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void fill_patch_array_CON(CON_node *cn , Links_to_patch *ltp ) 
{ 
  List_o_links *lol ;
  Links_to_patch *ltpx ;
  void *tmp ;

  {
#line 312
  lol = word_links___0[cn->word];
  {
  {
#line 312
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 312
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 312
      goto while_break;
    }
#line 313
    if (lol->dir == 0) {
      {
      {
#line 314
      tmp = xalloc((int )sizeof(Links_to_patch ));
      }
#line 314
      ltpx = (Links_to_patch *)tmp;
#line 315
      ltpx->next = ltp;
#line 316
      ltp = ltpx;
#line 317
      ltp->new = cn->word;
#line 318
      ltp->link = lol->link;
      }
#line 319
      if (lol->word > cn->word) {
#line 320
        ltp->dir = (char )'l';
      } else {
#line 322
        ltp->dir = (char )'r';
      }
    }
#line 312
    lol = lol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 326
  fill_patch_array_DIS((cn->current)->dn, ltp);
  }
  }
#line 327
  return;
}
}
#line 329 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void free_digraph(void) 
{ 
  List_o_links *lol ;
  List_o_links *lolx ;
  int i ;

  {
#line 332
  i = 0;
  {
  {
#line 332
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 332
    if (! (i < N_words)) {
#line 332
      goto while_break;
    }
#line 333
    lol = word_links___0[i];
    {
    {
#line 333
    while (1) {
      while_continue___2: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 333
      if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 333
        goto while_break___0;
      }
      {
#line 334
      lolx = lol->next;
      {
#line 335
      xfree((char *)((void *)lol), (int )sizeof(List_o_links ));
      }
#line 333
      lol = lolx;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 332
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 338
  return;
}
}
#line 340
void free_CON_tree(CON_node *cn ) ;
#line 341 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void free_DIS_tree(DIS_node *dn ) 
{ 
  List_o_links *lol ;
  List_o_links *lolx ;
  CON_list *cl ;
  CON_list *clx ;

  {
#line 344
  lol = dn->lol;
  {
  {
#line 344
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 344
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 344
      goto while_break;
    }
    {
#line 345
    lolx = lol->next;
    {
#line 346
    xfree((char *)((void *)lol), (int )sizeof(List_o_links ));
    }
#line 344
    lol = lolx;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 348
  cl = dn->cl;
  {
  {
#line 348
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 348
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 348
      goto while_break___0;
    }
    {
#line 349
    clx = cl->next;
    {
#line 350
    free_CON_tree(cl->cn);
    }
    {
#line 351
    xfree((char *)((void *)cl), (int )sizeof(CON_list ));
    }
#line 348
    cl = clx;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 353
  xfree((char *)((void *)dn), (int )sizeof(DIS_node ));
  }
  }
#line 354
  return;
}
}
#line 356 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void free_CON_tree(CON_node *cn ) 
{ 
  DIS_list *dl ;
  DIS_list *dlx ;

  {
#line 358
  dl = cn->dl;
  {
  {
#line 358
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 358
    if (! ((unsigned long )dl != (unsigned long )((void *)0))) {
#line 358
      goto while_break;
    }
    {
#line 359
    dlx = dl->next;
    {
#line 360
    free_DIS_tree(dl->dn);
    }
    {
#line 361
    xfree((char *)((void *)dl), (int )sizeof(DIS_list ));
    }
#line 358
    dl = dlx;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 363
  xfree((char *)((void *)cn), (int )sizeof(CON_node ));
  }
  }
#line 364
  return;
}
}
#line 366 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void print_a_link(FILE *fp , int link ) 
{ 
  int j ;
  char *__cil_tmp4 ;
  char *__cil_tmp5 ;
  char *__cil_tmp6 ;
  char *__cil_tmp7 ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;
  char *__cil_tmp14 ;
  char *__cil_tmp15 ;
  char *__cil_tmp16 ;
  char *__cil_tmp17 ;
  char *__cil_tmp18 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;

  {
#line 368
  if (pp_link_array[link].l == 0) {
#line 368
    if (left_wall_defined) {
      {
      {
#line 369
      left_print_string(fp, (char *)"/////", (char *)"               ");
      }
      }
    } else {
#line 368
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 370
  if (pp_link_array[link].l == N_words - 1) {
#line 370
    if (right_wall_defined) {
      {
      {
#line 371
      left_print_string(fp, (char *)"/////", (char *)"               ");
      }
      }
    } else {
      {
      {
#line 373
      left_print_string(fp, chosen_words[pp_link_array[link].l], (char *)"               ");
      }
      }
    }
  } else {
    {
    {
#line 373
    left_print_string(fp, chosen_words[pp_link_array[link].l], (char *)"               ");
    }
    }
  }
  {
  {
#line 375
  left_print_string(fp, (pp_link_array[link].lc)->string, (char *)"     ");
  }
#line 376
  j = (int )(pp_link_array[link].lc)->label;
  }
#line 377
  if (j < 0) {
    {
    {
#line 377
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"   ");
    }
    }
  } else {
    {
    {
#line 377
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d", j);
    }
    }
  }
  {
  {
#line 378
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"<---");
  }
  {
#line 379
  left_print_string(fp, pp_link_array[link].name, (char *)"-----");
  }
  {
#line 380
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"->  ");
  }
  {
#line 381
  left_print_string(fp, (pp_link_array[link].rc)->string, (char *)"     ");
  }
#line 382
  j = (int )(pp_link_array[link].rc)->label;
  }
#line 383
  if (j < 0) {
    {
    {
#line 383
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"   ");
    }
    }
  } else {
    {
    {
#line 383
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%3d", j);
    }
    }
  }
  {
  {
#line 384
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"  %s", chosen_words[pp_link_array[link].r]);
  }
  {
#line 385
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
  }
#line 386
  return;
}
}
#line 388 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void print_links(FILE *fp ) 
{ 
  int link ;
  char *__cil_tmp3 ;
  char *__cil_tmp4 ;

  {
#line 390
  link = 0;
  {
  {
#line 390
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 390
    if (! (link < N_links)) {
#line 390
      goto while_break;
    }
#line 391
    if (pp_link_array[link].l == -1) {
#line 391
      goto __Cont;
    }
    {
    {
#line 392
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"       ");
    }
    {
#line 393
    print_a_link(fp, link);
    }
    }
    __Cont: /* CIL Label */ 
#line 390
    link ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 395
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
  }
#line 396
  return;
}
}
#line 398 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void print_links_and_domains(FILE *fp , PP_node *pp ) 
{ 
  int link ;
  int longest ;
  int j ;
  D_type_list *d ;
  Violation_list *v ;
  char *__cil_tmp8 ;
  char *__cil_tmp9 ;
  char *__cil_tmp10 ;
  char *__cil_tmp11 ;
  char *__cil_tmp12 ;
  char *__cil_tmp13 ;

  {
#line 405
  longest = 0;
#line 406
  link = 0;
  {
  {
#line 406
  while (1) {
    while_continue___5: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 406
    if (! (link < N_links)) {
#line 406
      goto while_break;
    }
#line 407
    if (pp_link_array[link].l == -1) {
#line 407
      goto __Cont;
    }
#line 408
    j = 0;
#line 409
    d = *(pp->d_type_array + link);
    {
    {
#line 409
    while (1) {
      while_continue___6: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 409
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 409
        goto while_break___0;
      }
#line 409
      j ++;
#line 409
      d = d->next;
    }
    while_break___6: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 410
    if (j > longest) {
#line 410
      longest = j;
    }
    __Cont: /* CIL Label */ 
#line 406
    link ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  link = 0;
  {
  {
#line 412
  while (1) {
    while_continue___7: /* CIL Label */ ;
    while_continue___1: /* CIL Label */ ;
#line 412
    if (! (link < N_links)) {
#line 412
      goto while_break___1;
    }
#line 413
    if (pp_link_array[link].l == -1) {
#line 413
      goto __Cont___0;
    }
#line 414
    j = 0;
#line 415
    d = *(pp->d_type_array + link);
    {
    {
#line 415
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___2: /* CIL Label */ ;
#line 415
      if (! ((unsigned long )d != (unsigned long )((void *)0))) {
#line 415
        goto while_break___2;
      }
      {
      {
#line 416
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)" (%c)",
              d->type);
      }
#line 417
      j ++;
#line 415
      d = d->next;
      }
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___2: /* CIL Label */ ;
    }
    {
    {
#line 419
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___3: /* CIL Label */ ;
#line 419
      if (! (j < longest)) {
#line 419
        goto while_break___3;
      }
      {
      {
#line 420
      fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"    ");
      }
#line 419
      j ++;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___3: /* CIL Label */ ;
    }
    {
    {
#line 422
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"   ");
    }
    {
#line 423
    print_a_link(fp, link);
    }
    }
    __Cont___0: /* CIL Label */ 
#line 412
    link ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
  {
#line 425
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"\n");
  }
  }
#line 426
  if ((unsigned long )pp->v != (unsigned long )((void *)0)) {
    {
    {
#line 426
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"P.P. violations:\n");
    }
    }
  }
#line 427
  v = pp->v;
  {
  {
#line 427
  while (1) {
    while_continue___10: /* CIL Label */ ;
    while_continue___4: /* CIL Label */ ;
#line 427
    if (! ((unsigned long )v != (unsigned long )((void *)0))) {
#line 427
      goto while_break___4;
    }
    {
    {
#line 428
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"        %s\n",
            v->string);
    }
#line 427
    v = v->next;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 430
  return;
}
}
#line 435 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
static int visited___0[250]  ;
#line 436 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
static int and_element_sizes[250]  ;
#line 437 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
static int N_and_elements  ;
#line 439 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void and_dfs_full(int w ) 
{ 
  List_o_links *lol ;

  {
#line 442
  if (visited___0[w]) {
#line 442
    return;
  }
#line 443
  visited___0[w] = 1;
#line 444
  (and_element_sizes[N_and_elements]) ++;
#line 445
  lol = word_links___0[w];
  {
  {
#line 445
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 445
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 445
      goto while_break;
    }
#line 446
    if (lol->dir >= 0) {
      {
      {
#line 447
      and_dfs_full(lol->word);
      }
      }
    }
#line 445
    lol = lol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 450
  return;
}
}
#line 452 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void and_dfs_commas(int w ) 
{ 
  List_o_links *lol ;
  int tmp ;
  char *__cil_tmp4 ;

  {
#line 455
  if (visited___0[w]) {
#line 455
    return;
  }
#line 456
  visited___0[w] = 1;
#line 457
  lol = word_links___0[w];
  {
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 457
    if (! ((unsigned long )lol != (unsigned long )((void *)0))) {
#line 457
      goto while_break;
    }
#line 458
    if (lol->dir == 1) {
      {
      {
#line 461
      tmp = strcmp((char const   *)(sentence[lol->word].string), ",");
      }
      }
#line 461
      if (tmp == 0) {
        {
        {
#line 463
        and_dfs_commas(lol->word);
        }
        }
      } else {
        {
        {
#line 465
        and_dfs_full(lol->word);
        }
#line 466
        N_and_elements ++;
        }
      }
    }
#line 457
    lol = lol->next;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 470
  return;
}
}
#line 472 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
int and_cost(void) 
{ 
  int w ;
  int i ;
  int min ;
  int max ;
  int j ;
  int cost ;
  char *s ;

  {
#line 477
  cost = 0;
#line 478
  w = 0;
  {
  {
#line 478
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 478
    if (! (w < N_words)) {
#line 478
      goto while_break;
    }
#line 479
    s = sentence[w].string;
#line 480
    if (is_conjunction[w]) {
#line 481
      N_and_elements = 0;
#line 482
      i = 0;
      {
      {
#line 482
      while (1) {
        while_continue___3: /* CIL Label */ ;
        while_continue___0: /* CIL Label */ ;
#line 482
        if (! (i < N_words)) {
#line 482
          goto while_break___0;
        }
#line 483
        visited___0[i] = 0;
#line 484
        and_element_sizes[i] = 0;
#line 482
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 486
      if (left_wall_defined) {
#line 486
        visited___0[0] = 1;
      }
      {
      {
#line 489
      and_dfs_commas(w);
      }
      }
#line 490
      if (N_and_elements > 0) {
#line 491
        min = 250;
#line 492
        max = 0;
#line 493
        i = 0;
        {
        {
#line 493
        while (1) {
          while_continue___4: /* CIL Label */ ;
          while_continue___1: /* CIL Label */ ;
#line 493
          if (! (i < N_and_elements)) {
#line 493
            goto while_break___1;
          }
#line 494
          j = and_element_sizes[i];
#line 495
          if (j < min) {
#line 495
            min = j;
          }
#line 496
          if (j > max) {
#line 496
            max = j;
          }
#line 493
          i ++;
        }
        while_break___4: /* CIL Label */ ;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 498
        cost += max - min;
      }
    }
#line 478
    w ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 502
  return (cost);
}
}
#line 505 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
int cost_for_length(int length ) 
{ 


  {
#line 507
  return (length - 1);
}
}
#line 510 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
int link_cost(void) 
{ 
  int lcost ;
  int i ;
  int tmp ;

  {
#line 514
  lcost = 0;
#line 515
  i = 0;
  {
  {
#line 515
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 515
    if (! (i < N_links)) {
#line 515
      goto while_break;
    }
    {
    {
#line 516
    tmp = cost_for_length(link_array[i].r - link_array[i].l);
    }
#line 516
    lcost += tmp;
#line 515
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 518
  return (lcost);
}
}
#line 522 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
static int null_cost(void) 
{ 


  {
#line 524
  return (N_null);
}
}
#line 527 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
int disjunct_cost(void) 
{ 
  int lcost ;
  int i ;

  {
#line 531
  lcost = 0;
#line 532
  i = 0;
  {
  {
#line 532
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 532
    if (! (i < N_words)) {
#line 532
      goto while_break;
    }
#line 533
    if ((unsigned long )chosen_disjuncts[i] != (unsigned long )((void *)0)) {
#line 534
      lcost += (int )(chosen_disjuncts[i])->cost;
    }
#line 532
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 536
  return (lcost);
}
}
#line 539 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
int strictly_smaller_name(char *s , char *t ) 
{ 
  int strictness ;
  int ss ;
  int tt ;

  {
#line 547
  strictness = 0;
  {
  {
#line 548
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 548
    if (! ((int )*s != 0)) {
#line 548
      if (! ((int )*t != 0)) {
#line 548
        goto while_break;
      }
    }
#line 549
    if ((int )*s == 0) {
#line 550
      ss = '*';
    } else {
#line 552
      ss = (int )*s;
#line 553
      s ++;
    }
#line 555
    if ((int )*t == 0) {
#line 556
      tt = '*';
    } else {
#line 558
      tt = (int )*t;
#line 559
      t ++;
    }
#line 561
    if (ss == tt) {
#line 561
      goto while_continue;
    }
#line 562
    if (tt == 42) {
#line 563
      strictness ++;
    } else
#line 562
    if (ss == 94) {
#line 563
      strictness ++;
    } else {
#line 565
      return (0);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 568
  return (strictness > 0);
}
}
#line 571 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void compute_link_names(void) 
{ 
  int i ;

  {
#line 577
  i = 0;
  {
  {
#line 577
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 577
    if (! (i < N_links)) {
#line 577
      goto while_break;
    }
    {
    {
#line 578
    link_array[i].name = intersect_strings((link_array[i].lc)->string, (link_array[i].rc)->string);
    }
#line 577
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 581
  return;
}
}
#line 583 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
void compute_pp_link_names(void) 
{ 
  int i ;
  char *s ;
  int tmp ;
  int tmp___0 ;

  {
#line 596
  i = 0;
  {
  {
#line 596
  while (1) {
    while_continue___0: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 596
    if (! (i < N_links)) {
#line 596
      goto while_break;
    }
#line 597
    if (pp_link_array[i].l == -1) {
#line 597
      goto __Cont;
    }
    {
    {
#line 598
    tmp___0 = match(pp_link_array[i].lc, pp_link_array[i].rc);
    }
    }
#line 598
    if (tmp___0) {
      {
      {
#line 601
      s = intersect_strings((pp_link_array[i].lc)->string, (pp_link_array[i].rc)->string);
      }
      {
#line 603
      tmp = strictly_smaller_name(s, link_array[i].name);
      }
      }
#line 603
      if (tmp) {
#line 604
        pp_link_array[i].name = link_array[i].name;
      } else {
#line 606
        pp_link_array[i].name = s;
      }
    } else {
#line 599
      pp_link_array[i].name = link_array[i].name;
    }
    __Cont: /* CIL Label */ 
#line 596
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 610
  return;
}
}
#line 612 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
Linkage_info analyze_fat_linkage(int should_print ) 
{ 
  int i ;
  int should_print_messages ;
  Violation_list *v ;
  Linkage_info li ;
  DIS_node *d_root ;
  PP_node *pp ;
  PP_node *accum ;
  D_type_list *dtl0 ;
  D_type_list *dtl1 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  char tmp___5 ;
  int tmp___6 ;
  char *__cil_tmp19 ;
  char *__cil_tmp20 ;
  char *__cil_tmp21 ;

  {
  {
#line 618
  should_print_messages = 1;
  {
#line 625
  build_digraph();
  }
#line 626
  structure_violation = 0;
  {
#line 627
  d_root = build_DIS_CON_tree();
  }
#line 628
  li.N_violations = (short)0;
  {
#line 629
  tmp = disjunct_cost();
  }
#line 629
  li.disjunct_cost = (short )tmp;
  {
#line 630
  tmp___0 = null_cost();
  }
#line 630
  li.null_cost = (short )tmp___0;
  {
#line 631
  tmp___1 = link_cost();
  }
#line 631
  li.link_cost = (short )tmp___1;
  }
#line 633
  if (structure_violation) {
#line 633
    if (should_print) {
#line 633
      if (display_multiple) {
#line 633
        goto _L;
      } else {
#line 633
        goto _L___1;
      }
    } else {
#line 633
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 633
  if (should_print) {
#line 633
    if (display_fat) {
      _L: /* CIL Label */ 
      {
      {
#line 635
      compute_link_names();
      }
#line 636
      i = 0;
      }
      {
      {
#line 636
      while (1) {
        while_continue___7: /* CIL Label */ ;
        while_continue: /* CIL Label */ ;
#line 636
        if (! (i < N_links)) {
#line 636
          goto while_break;
        }
#line 637
        pp_link_array[i] = link_array[i];
#line 636
        i ++;
      }
      while_break___7: /* CIL Label */ ;
      }
      while_break: /* CIL Label */ ;
      }
      {
      {
#line 639
      print_links_graphically(stdout);
      }
      }
#line 640
      if (display_links) {
        {
        {
#line 640
        print_links(stdout);
        }
        }
      }
    }
  }
#line 643
  if (structure_violation) {
#line 645
    if (display_links) {
#line 645
      if (display_bad) {
        {
        {
#line 646
        fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"And structure violation.\n");
        }
        }
      }
    }
#line 648
    li.N_violations = (short )((int )li.N_violations + 1);
#line 649
    li.and_cost = (short)0;
  } else {
    {
    {
#line 651
    tmp___2 = and_cost();
    }
#line 651
    li.and_cost = (short )tmp___2;
    {
#line 652
    compute_link_names();
    }
    {
#line 653
    tmp___3 = xalloc((int )sizeof(PP_node ));
    }
#line 653
    accum = (PP_node *)tmp___3;
    {
#line 654
    tmp___4 = xalloc((int )((unsigned long )N_links * sizeof(D_type_list *)));
    }
#line 654
    accum->d_type_array = (D_type_list **)tmp___4;
#line 655
    accum->v = (Violation_list *)((void *)0);
#line 656
    i = 0;
    }
    {
    {
#line 656
    while (1) {
      while_continue___8: /* CIL Label */ ;
      while_continue___0: /* CIL Label */ ;
#line 656
      if (! (i < N_links)) {
#line 656
        goto while_break___0;
      }
#line 656
      *(accum->d_type_array + i) = (D_type_list *)((void *)0);
#line 656
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
    {
#line 657
    while (1) {
      while_continue___9: /* CIL Label */ ;
      while_continue___1: /* CIL Label */ ;
#line 658
      i = 0;
      {
      {
#line 658
      while (1) {
        while_continue___10: /* CIL Label */ ;
        while_continue___2: /* CIL Label */ ;
#line 658
        if (! (i < N_links)) {
#line 658
          goto while_break___2;
        }
#line 659
        tmp___5 = (char)0;
#line 659
        patch_array[i].changed = tmp___5;
#line 659
        patch_array[i].used = tmp___5;
#line 660
        patch_array[i].newl = link_array[i].l;
#line 661
        patch_array[i].newr = link_array[i].r;
#line 662
        pp_link_array[i] = link_array[i];
#line 658
        i ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      while_break___2: /* CIL Label */ ;
      }
      {
      {
#line 664
      fill_patch_array_DIS(d_root, (Links_to_patch *)((void *)0));
      }
#line 673
      i = 0;
      }
      {
      {
#line 673
      while (1) {
        while_continue___11: /* CIL Label */ ;
        while_continue___3: /* CIL Label */ ;
#line 673
        if (! (i < N_links)) {
#line 673
          goto while_break___3;
        }
#line 674
        if (patch_array[i].changed) {
#line 675
          pp_link_array[i].l = patch_array[i].newl;
#line 676
          pp_link_array[i].r = patch_array[i].newr;
        } else
#line 674
        if (patch_array[i].used) {
#line 675
          pp_link_array[i].l = patch_array[i].newl;
#line 676
          pp_link_array[i].r = patch_array[i].newr;
        } else
#line 677
        if (dfs_root_word[link_array[i].l] != -1) {
#line 677
          if (dfs_root_word[link_array[i].r] != -1) {
#line 679
            pp_link_array[i].l = -1;
          }
        }
#line 673
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
      while_break___3: /* CIL Label */ ;
      }
      {
      {
#line 683
      compute_pp_link_array_connectors();
      }
      {
#line 684
      compute_pp_link_names();
      }
      {
#line 685
      pp = post_process();
      }
      }
#line 686
      if (display_multiple) {
#line 686
        if (should_print) {
          {
          {
#line 689
          print_links_graphically(stdout);
          }
          }
        }
      }
#line 691
      if ((unsigned long )pp->v == (unsigned long )((void *)0)) {
#line 696
        i = 0;
        {
        {
#line 696
        while (1) {
          while_continue___12: /* CIL Label */ ;
          while_continue___4: /* CIL Label */ ;
#line 696
          if (! (i < N_links)) {
#line 696
            goto while_break___4;
          }
#line 697
          if (pp_link_array[i].l == -1) {
#line 697
            goto __Cont;
          }
#line 698
          if ((unsigned long )*(accum->d_type_array + i) == (unsigned long )((void *)0)) {
#line 699
            *(accum->d_type_array + i) = *(pp->d_type_array + i);
#line 700
            *(pp->d_type_array + i) = (D_type_list *)((void *)0);
          } else {
#line 702
            dtl0 = *(pp->d_type_array + i);
#line 703
            dtl1 = *(accum->d_type_array + i);
            {
            {
#line 704
            while (1) {
              while_continue___13: /* CIL Label */ ;
              while_continue___5: /* CIL Label */ ;
#line 704
              if ((unsigned long )dtl0 != (unsigned long )((void *)0)) {
#line 704
                if ((unsigned long )dtl1 != (unsigned long )((void *)0)) {
#line 704
                  if (! (dtl0->type == dtl1->type)) {
#line 704
                    goto while_break___5;
                  }
                } else {
#line 704
                  goto while_break___5;
                }
              } else {
#line 704
                goto while_break___5;
              }
#line 706
              dtl0 = dtl0->next;
#line 707
              dtl1 = dtl1->next;
            }
            while_break___13: /* CIL Label */ ;
            }
            while_break___5: /* CIL Label */ ;
            }
#line 709
            if ((unsigned long )dtl0 != (unsigned long )((void *)0)) {
#line 710
              goto while_break___4;
            } else
#line 709
            if ((unsigned long )dtl1 != (unsigned long )((void *)0)) {
#line 710
              goto while_break___4;
            }
          }
          __Cont: /* CIL Label */ 
#line 696
          i ++;
        }
        while_break___12: /* CIL Label */ ;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 714
        if (i != N_links) {
#line 715
          if (display_links) {
#line 715
            if (should_print_messages) {
              {
              {
#line 716
              fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"Incompatible domain ancestry\n");
              }
#line 717
              li.N_violations = (short )((int )li.N_violations + 1);
              }
            }
          }
          {
          {
#line 719
          free_PP_node(pp);
          }
          }
#line 720
          goto while_break___1;
        }
      } else {
#line 723
        v = pp->v;
        {
        {
#line 723
        while (1) {
          while_continue___14: /* CIL Label */ ;
          while_continue___6: /* CIL Label */ ;
#line 723
          if (! ((unsigned long )v != (unsigned long )((void *)0))) {
#line 723
            goto while_break___6;
          }
#line 724
          li.N_violations = (short )((int )li.N_violations + 1);
#line 723
          v = v->next;
        }
        while_break___14: /* CIL Label */ ;
        }
        while_break___6: /* CIL Label */ ;
        }
      }
      {
      {
#line 727
      free_PP_node(pp);
      }
      {
#line 732
      tmp___6 = advance_DIS(d_root);
      }
      }
#line 732
      if (! tmp___6) {
#line 732
        goto while_break___1;
      }
    }
    while_break___9: /* CIL Label */ ;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 734
    if (display_on) {
#line 734
      if ((int )li.N_violations != 0) {
#line 734
        if (verbosity > 1) {
#line 734
          if (should_print_messages) {
            {
            {
#line 735
            fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"P.P. violation in one part of conjunction.\n");
            }
            }
          }
        }
      }
    }
    {
    {
#line 737
    free_PP_node(accum);
    }
    }
  }
  {
  {
#line 739
  free_digraph();
  }
  {
#line 740
  free_DIS_tree(d_root);
  }
  }
#line 741
  if (should_print) {
    {
    {
#line 741
    fflush(stdout);
    }
    }
  }
#line 742
  return (li);
}
}
#line 745 "/local/sparrow_test/test/SPEC2000/CINT2000/197.parser/src/analyze-linkage.c"
Linkage_info analyze_thin_linkage(int should_print ) 
{ 
  int i ;
  Violation_list *v ;
  Linkage_info li ;
  PP_node *pp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
  {
#line 755
  compute_link_names();
  }
#line 756
  i = 0;
  }
  {
  {
#line 756
  while (1) {
    while_continue___1: /* CIL Label */ ;
    while_continue: /* CIL Label */ ;
#line 756
    if (! (i < N_links)) {
#line 756
      goto while_break;
    }
#line 757
    pp_link_array[i] = link_array[i];
#line 756
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
  {
  {
#line 759
  pp = post_process();
  }
  }
#line 760
  if (display_fat) {
#line 760
    goto _L;
  } else
#line 760
  if (display_multiple) {
    _L: /* CIL Label */ 
#line 760
    if (should_print) {
      {
      {
#line 761
      print_links_graphically(stdout);
      }
      }
#line 762
      if (display_links) {
        {
        {
#line 762
        print_links_and_domains(stdout, pp);
        }
        }
      }
    }
  }
  {
#line 765
  li.N_violations = (short)0;
#line 766
  li.and_cost = (short)0;
  {
#line 767
  tmp = disjunct_cost();
  }
#line 767
  li.disjunct_cost = (short )tmp;
  {
#line 768
  tmp___0 = null_cost();
  }
#line 768
  li.null_cost = (short )tmp___0;
  {
#line 769
  tmp___1 = link_cost();
  }
#line 769
  li.link_cost = (short )tmp___1;
#line 771
  v = pp->v;
  }
  {
  {
#line 771
  while (1) {
    while_continue___2: /* CIL Label */ ;
    while_continue___0: /* CIL Label */ ;
#line 771
    if (! ((unsigned long )v != (unsigned long )((void *)0))) {
#line 771
      goto while_break___0;
    }
#line 771
    li.N_violations = (short )((int )li.N_violations + 1);
#line 771
    v = v->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
  {
#line 772
  free_PP_node(pp);
  }
  }
#line 773
  if (should_print) {
    {
    {
#line 773
    fflush(stdout);
    }
    }
  }
#line 774
  return (li);
}
}
