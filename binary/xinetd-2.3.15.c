/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 195 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef short int16_t;
#line 133 "/usr/include/time.h"
struct tm {
   int tm_sec ;
   int tm_min ;
   int tm_hour ;
   int tm_mday ;
   int tm_mon ;
   int tm_year ;
   int tm_wday ;
   int tm_yday ;
   int tm_isdst ;
   long tm_gmtoff ;
   char const   *tm_zone ;
};
#line 16 "../libs/include/pset.h"
typedef void *__pset_pointer;
#line 18 "../libs/include/pset.h"
struct __pset {
   unsigned int alloc_step ;
   __pset_pointer *ptrs ;
   unsigned int max ;
   unsigned int count ;
};
#line 31 "../libs/include/pset.h"
typedef struct __pset *pset_h;
#line 121 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
enum __anonenum_status_e_33 {
    FAILED = 0,
    OK = 1
} ;
#line 121 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
typedef enum __anonenum_status_e_33 status_e;
#line 137 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
typedef int bool_int;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/time.c"
struct time_interval {
   int16_t min_start ;
   int16_t min_end ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 33 "/usr/include/x86_64-linux-gnu/bits/socket.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 55 "/usr/include/stdint.h"
typedef unsigned long uint64_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 209 "/usr/include/netinet/in.h"
union __anonunion___in6_u_20 {
   uint8_t __u6_addr8[16] ;
   uint16_t __u6_addr16[8] ;
   uint32_t __u6_addr32[4] ;
};
#line 209 "/usr/include/netinet/in.h"
struct in6_addr {
   union __anonunion___in6_u_20 __in6_u ;
};
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 252 "/usr/include/netinet/in.h"
struct sockaddr_in6 {
   sa_family_t sin6_family ;
   in_port_t sin6_port ;
   uint32_t sin6_flowinfo ;
   struct in6_addr sin6_addr ;
   uint32_t sin6_scope_id ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 92 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag sigjmp_buf[1];
#line 23 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
union xsockaddr {
   struct sockaddr sa ;
   struct sockaddr_in sa_in ;
   struct sockaddr_in6 sa_in6 ;
   char pad[128] ;
};
#line 127
enum __anonenum_idresult_e_58 {
    IDR_OK = 0,
    IDR_NOSERVER = 1,
    IDR_TIMEDOUT = 2,
    IDR_RESPERR = 3,
    IDR_BADRESP = 4,
    IDR_ERROR = 5
} ;
#line 127 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
typedef enum __anonenum_idresult_e_58 idresult_e;
#line 175
struct service;
#line 176
struct server;
#line 177
struct connection;
#line 178 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
typedef struct connection connection_s;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.h"
struct server {
   pid_t svr_pid ;
   time_t svr_start_time ;
   connection_s *svr_conn ;
   struct service *svr_sp ;
   int svr_fork_failures ;
   int svr_exit_status ;
   bool_int svr_log_remote_user ;
   bool_int svr_writes_to_log ;
};
#line 24 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/mask.h"
typedef uint64_t mask_t;
#line 56 "../libs/include/xlog.h"
typedef void *xlog_h;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.h"
enum __anonenum_state_e_61 {
    SVC_NOT_STARTED = 0,
    SVC_ACTIVE = 1,
    SVC_SUSPENDED = 2,
    SVC_DISABLED = 3
} ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.h"
typedef enum __anonenum_state_e_61 state_e;
#line 43
struct service_config;
#line 43 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.h"
struct service {
   state_e svc_state ;
   int svc_ref_count ;
   struct service_config *svc_conf ;
   int svc_fd ;
   unsigned int svc_running_servers ;
   unsigned int svc_retry_servers ;
   unsigned int svc_attempts ;
   int svc_not_generic ;
   union xsockaddr *svc_last_dgram_addr ;
   time_t svc_last_dgram_time ;
   xlog_h svc_log ;
};
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.h"
struct connection {
   struct service *co_sp ;
   int co_descriptor ;
   mask_t co_flags ;
   union xsockaddr co_remote_address ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 65 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __gid_t gid_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 80 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __uid_t uid_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 122 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
enum __anonenum_boolean_e_60 {
    NO = 0,
    YES = 1
} ;
#line 122 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
typedef enum __anonenum_boolean_e_60 boolean_e;
#line 161 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
struct protocol_name_value {
   char *name ;
   int value ;
};
#line 167 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
struct debug {
   bool_int on ;
   int fd ;
};
#line 69 "../libs/include/pset.h"
struct __pset_iterator {
   pset_h pset ;
   unsigned int current ;
   int step ;
};
#line 76 "../libs/include/pset.h"
typedef struct __pset_iterator *psi_h;
#line 22 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
enum __anonenum_channel_state_e_62 {
    GOOD_CHANNEL = 0,
    BAD_CHANNEL = 1
} ;
#line 22 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
typedef enum __anonenum_channel_state_e_62 channel_state_e;
#line 24 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
struct channel {
   channel_state_e ch_state ;
   union xsockaddr ch_from ;
   int ch_local_socket ;
   int ch_remote_socket ;
};
#line 32 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
typedef struct channel channel_s;
#line 42 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
struct intercept_common {
   bool_int ic_intercept ;
   int ic_remote_socket ;
   union xsockaddr ic_local_addr ;
   pset_h ic_connections ;
   struct server ic_server ;
};
#line 52 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
struct intercept_ops {
   void (*mux)() ;
   void (*exit)() ;
};
#line 59 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
struct intercept_s {
   int int_socket_type ;
   struct intercept_common int_common ;
   void *int_priv ;
   struct intercept_ops  const  *int_ops ;
};
#line 29 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.h"
enum __anonenum_access_e_67 {
    AC_OK = 0,
    AC_FORK = 1,
    AC_ADDRESS = 2,
    AC_TIME = 3,
    AC_SERVICE_LIMIT = 4,
    AC_PER_SOURCE_LIMIT = 5,
    AC_PROCESS_LIMIT = 6,
    AC_LIBWRAP = 7,
    AC_LOAD = 8,
    AC_CPS = 9
} ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.h"
typedef enum __anonenum_access_e_67 access_e;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.h"
enum __anonenum_logtype_e_68 {
    L_NONE = 0,
    L_FILE = 1,
    L_SYSLOG = 2,
    L_COMMON_FILE = 3
} ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.h"
typedef enum __anonenum_logtype_e_68 logtype_e;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.h"
struct filelog {
   char *fl_filename ;
   unsigned int fl_soft_limit ;
   unsigned int fl_hard_limit ;
};
#line 40 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.h"
struct syslog {
   int sl_facility ;
   int sl_level ;
};
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.h"
struct log {
   logtype_e l_type ;
   struct filelog l_fl ;
   struct syslog l_sl ;
};
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 14 "../libs/include/m_env.h"
struct __env {
   unsigned int max_vars ;
   unsigned int n_vars ;
   char **vars ;
};
#line 21 "../libs/include/m_env.h"
typedef struct __env *env_h;
#line 21 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.h"
struct builtin {
   void (*b_handler)() ;
   boolean_e b_fork_server ;
};
#line 27 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.h"
typedef struct builtin builtin_s;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.h"
struct rpc_data {
   unsigned long rd_min_version ;
   unsigned long rd_max_version ;
   unsigned long rd_program_number ;
};
#line 85
enum __anonenum_environ_e_83 {
    NO_ENV = 0,
    STD_ENV = 1,
    DEF_ENV = 2,
    CUSTOM_ENV = 3
} ;
#line 85 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.h"
typedef enum __anonenum_environ_e_83 environ_e;
#line 87 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.h"
struct environment {
   environ_e env_type ;
   env_h env_handle ;
};
#line 96 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.h"
struct service_config {
   mask_t sc_specified_attributes ;
   mask_t sc_attributes_present ;
   mask_t sc_type ;
   mask_t sc_xflags ;
   char *sc_name ;
   char *sc_id ;
   uint16_t sc_port ;
   int sc_socket_type ;
   struct protocol_name_value sc_protocol ;
   boolean_e sc_wait ;
   uid_t sc_uid ;
   gid_t sc_user_gid ;
   gid_t sc_gid ;
   char *sc_server ;
   char **sc_server_argv ;
   int sc_instances ;
   int sc_nice ;
   pset_h sc_env_var_defs ;
   pset_h sc_pass_env_vars ;
   pset_h sc_access_times ;
   pset_h sc_only_from ;
   pset_h sc_no_access ;
   mask_t sc_log_on_success ;
   mask_t sc_log_on_failure ;
   struct log sc_log ;
   struct rpc_data sc_rd ;
   pset_h sc_disabled ;
   pset_h sc_enabled ;
   struct environment sc_environment ;
   builtin_s const   *sc_builtin ;
   union xsockaddr *sc_redir_addr ;
   char *sc_orig_bind_addr ;
   union xsockaddr *sc_bind_addr ;
   boolean_e sc_v6only ;
   char *sc_banner ;
   int sc_per_source ;
   boolean_e sc_groups ;
   char *sc_banner_success ;
   char *sc_banner_fail ;
   double sc_max_load ;
   time_t sc_time_limit ;
   time_t sc_time_conn ;
   time_t sc_time_conn_max ;
   time_t sc_time_wait ;
   time_t sc_time_reenable ;
   rlim_t sc_rlim_as ;
   rlim_t sc_rlim_cpu ;
   rlim_t sc_rlim_data ;
   rlim_t sc_rlim_rss ;
   rlim_t sc_rlim_stack ;
   mode_t sc_umask ;
   int sc_deny_time ;
};
#line 31 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
enum __anonenum_stream_status_e_84 {
    S_OK = 0,
    S_SERVER_ERR = 1,
    S_CLIENT_ERR = 2
} ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
typedef enum __anonenum_stream_status_e_84 stream_status_e;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
struct istream_private {
   unsigned int accepted_connections ;
};
#line 46 "/usr/include/rpc/netdb.h"
struct rpcent {
   char *r_name ;
   char **r_aliases ;
   int r_number ;
};
#line 257 "/usr/include/netdb.h"
struct servent {
   char *s_name ;
   char **s_aliases ;
   int s_port ;
   char *s_proto ;
};
#line 326 "/usr/include/netdb.h"
struct protoent {
   char *p_name ;
   char **p_aliases ;
   int p_proto ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 20 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.h"
struct configuration {
   pset_h cnf_service_confs ;
   struct service_config *cnf_defaults ;
};
#line 33 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/state.h"
struct read_only_state {
   rlim_t orig_max_descriptors ;
   rlim_t max_descriptors ;
   rlim_t process_limit ;
   int cc_interval ;
   char const   *pid_file ;
   char const   *config_file ;
   int is_superuser ;
   char **Argv ;
   int Argc ;
};
#line 47 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/state.h"
struct defaults {
   struct service_config *def_settings ;
   xlog_h def_log ;
   bool_int def_log_creation_failed ;
};
#line 55 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/state.h"
struct read_write_state {
   int descriptors_free ;
   int available_services ;
   int active_services ;
   fd_set socket_mask ;
   int mask_max ;
   pset_h servers ;
   pset_h retries ;
   pset_h services ;
   struct service *logging ;
   struct defaults defs ;
   xlog_h program_log ;
   sigjmp_buf env ;
   bool_int env_is_valid ;
};
#line 76 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/state.h"
struct program_state {
   struct read_only_state ros ;
   struct read_write_state rws ;
};
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 33 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __u_long;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 36 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_long u_long;
#line 264 "/usr/include/netinet/in.h"
struct ip_mreq {
   struct in_addr imr_multiaddr ;
   struct in_addr imr_interface ;
};
#line 37 "/usr/include/rpc/types.h"
typedef int bool_t;
#line 155 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
struct name_value {
   char const   *name ;
   int value ;
};
#line 41 "../libs/include/xlog.h"
enum __anonenum_xlog_cmd_e_81 {
    XLOG_LINK = 0,
    XLOG_CALLBACK = 1,
    XLOG_GETFLAG = 2,
    XLOG_SETFLAG = 3,
    XLOG_LEVEL = 4,
    XLOG_FACILITY = 5,
    XLOG_PREEXEC = 6,
    XLOG_POSTEXEC = 7,
    XLOG_SIZECHECK = 8,
    XLOG_GETFD = 9,
    XLOG_LIMITS = 10
} ;
#line 41 "../libs/include/xlog.h"
typedef enum __anonenum_xlog_cmd_e_81 xlog_cmd_e;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 159 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
enum check_type {
    PERIODIC = 0,
    USER_REQUESTED = 1
} ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 39 "../libs/include/xlog.h"
enum __anonenum_xlog_e_5 {
    XLOG_SYSLOG = 0,
    XLOG_FILELOG = 1
} ;
#line 39 "../libs/include/xlog.h"
typedef enum __anonenum_xlog_e_5 xlog_e;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 74 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
union __anonunion_80 {
   int __in ;
   int __i ;
};
#line 73 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
union __anonunion_81 {
   int __in ;
   int __i ;
};
#line 71 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
union __anonunion_82 {
   int __in ;
   int __i ;
};
#line 77 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
union __anonunion_83 {
   int __in ;
   int __i ;
};
#line 37 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.h"
struct builtin_service {
   char const   *bs_name ;
   int bs_socket_type ;
   builtin_s bs_handle ;
};
#line 175 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
union __anonunion_83___0 {
   int __in ;
   int __i ;
};
#line 180 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
union __anonunion_84 {
   int __in ;
   int __i ;
};
#line 177 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
union __anonunion_85 {
   int __in ;
   int __i ;
};
#line 172 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
union __anonunion_86 {
   int __in ;
   int __i ;
};
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 42 "/usr/include/grp.h"
struct group {
   char *gr_name ;
   char *gr_passwd ;
   __gid_t gr_gid ;
   char **gr_mem ;
};
#line 27 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.h"
enum assign_op {
    SET_EQ = 0,
    PLUS_EQ = 1,
    MINUS_EQ = 2
} ;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 484 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.c"
union __anonunion_83___1 {
   int __in ;
   int __i ;
};
#line 484 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.c"
union __anonunion_84___0 {
   int __in ;
   int __i ;
};
#line 24 "../libs/include/str.h"
typedef void *str_h;
#line 36 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
struct packet {
   union xsockaddr from ;
   char *data ;
   int size ;
};
#line 43 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
typedef struct packet packet_s;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
struct idgram_private {
   unsigned int received_packets ;
};
#line 36 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
struct module {
   char const   *name ;
   status_e (*initializer)() ;
};
#line 26 "/usr/include/x86_64-linux-gnu/bits/netdb.h"
struct netent {
   char *n_name ;
   char **n_aliases ;
   int n_addrtype ;
   uint32_t n_net ;
};
#line 44 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
enum __anonenum_result_e_64 {
    CANT_PARSE = 0,
    PARSED = 1,
    ERROR = 2
} ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
typedef enum __anonenum_result_e_64 result_e;
#line 45
enum __anonenum_address_e_65 {
    NUMERIC_ADDR = 0,
    NET_ADDR = 1,
    HOST_ADDR = 2
} ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
typedef enum __anonenum_address_e_65 address_e;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
union __anonunion_a_66 {
   struct in6_addr addr6 ;
   uint32_t addr ;
};
#line 53 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
union __anonunion_m_67 {
   struct in6_addr mask6 ;
   uint32_t mask ;
};
#line 53 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
struct comp_addr {
   address_e addr_type ;
   char name[65] ;
   char version ;
   union __anonunion_a_66 a ;
   union __anonunion_m_67 m ;
};
#line 448 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
struct __anonstruct_net_to_mask_68 {
   uint32_t lim ;
   uint32_t mask ;
   uint32_t shift ;
};
#line 284 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
union __anonunion_79 {
   int __in ;
   int __i ;
};
#line 284 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
union __anonunion_80___0 {
   int __in ;
   int __i ;
};
#line 306 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
union __anonunion_81___0 {
   int __in ;
   int __i ;
};
#line 281 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
union __anonunion_82___0 {
   int __in ;
   int __i ;
};
#line 281 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
union __anonunion_83___2 {
   int __in ;
   int __i ;
};
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_16 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_17 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_18 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_19 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_20 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_21 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_22 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_15 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_16 _kill ;
   struct __anonstruct__timer_17 _timer ;
   struct __anonstruct__rt_18 _rt ;
   struct __anonstruct__sigchld_19 _sigchld ;
   struct __anonstruct__sigfault_20 _sigfault ;
   struct __anonstruct__sigpoll_21 _sigpoll ;
   struct __anonstruct__sigsys_22 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_14 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_15 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_14 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_34 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_34 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 58 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
typedef void sigfunc(int  );
#line 19 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.h"
enum __anonenum_entry_e_80 {
    NO_ENTRY = 0,
    BAD_ENTRY = 1,
    SERVICE_ENTRY = 2,
    DEFAULTS_ENTRY = 3,
    INCLUDE_ENTRY = 4,
    INCLUDEDIR_ENTRY = 5
} ;
#line 19 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.h"
typedef enum __anonenum_entry_e_80 entry_e;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.h"
struct attribute {
   char const   *a_name ;
   unsigned int a_id ;
   int a_nvalues ;
   status_e (*a_parser)() ;
};
#line 37 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
typedef struct intercept_s *(*initfunc)();
#line 39 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
struct lookup_table {
   struct intercept_s *(*initializer)() ;
   int socket_type ;
};
#line 216 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
union __anonunion_80___1 {
   int __in ;
   int __i ;
};
#line 13 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.h"
struct xtime {
   void (*timerfunc)(void) ;
   time_t when ;
   int xtid ;
};
#line 18 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.h"
typedef struct xtime xtime_h;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 51 "../libs/include/sio.h"
struct __sio_input_descriptor {
   char *buf ;
   size_t buffer_size ;
   char *start ;
   char *end ;
   char *nextb ;
   unsigned int line_length ;
   int max_line_length ;
   int tied_fd ;
   int memory_mapped ;
};
#line 76 "../libs/include/sio.h"
typedef struct __sio_input_descriptor __sio_id_t;
#line 82 "../libs/include/sio.h"
struct __sio_output_descriptor {
   char *buf ;
   char *buf_end ;
   unsigned int buffer_size ;
   char *start ;
   char *nextb ;
   int buftype ;
};
#line 100 "../libs/include/sio.h"
typedef struct __sio_output_descriptor __sio_od_t;
#line 107
enum __sio_stream {
    __SIO_INPUT_STREAM = 0,
    __SIO_OUTPUT_STREAM = 1
} ;
#line 113 "../libs/include/sio.h"
union __anonunion_descriptor_24 {
   __sio_id_t input_descriptor ;
   __sio_od_t output_descriptor ;
};
#line 113 "../libs/include/sio.h"
struct __sio_descriptor {
   union __anonunion_descriptor_24 descriptor ;
   enum __sio_stream stream_type ;
   int initialized ;
};
#line 124 "../libs/include/sio.h"
typedef struct __sio_descriptor __sio_descriptor_t;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 243
extern  __attribute__((__nothrow__)) struct tm *( __attribute__((__leaf__)) localtime)(time_t const   *__timer ) ;
#line 169 "../libs/include/sio.h"
extern ssize_t ( /* format attribute */  Sprint)(int fd , char const   *format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 37 "../libs/include/pset.h"
extern __pset_pointer pset_add(pset_h pset , __pset_pointer const   ptr ) ;
#line 41
extern void pset_apply(pset_h pset , void (*func)() , void *arg ) ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/timex.h"
bool_int ti_current_time_check(pset_h const   intervals ) ;
#line 13
status_e ti_add(pset_h iset , char const   *interval_str ) ;
#line 14
void ti_dump(pset_h iset , int fd ) ;
#line 15
void ti_free(pset_h iset ) ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.h"
void ( /* format attribute */  parsemsg)(int msg_level , char const   *func , char const   *fmt 
                                         , ...) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
void out_of_memory(char const   *func ) ;
#line 37 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/time.c"
bool_int ti_current_time_check(pset_h const   intervals ) 
{ 
  time_t current_time ;
  unsigned int u ;
  int16_t min_current ;
  struct tm *tmp ;
  struct time_interval *tip ;

  {
  {
#line 44
  time(& current_time);
#line 45
  tmp = localtime((time_t const   *)(& current_time));
#line 46
  min_current = (int16_t )(tmp->tm_hour * 60 + tmp->tm_min);
#line 48
  u = 0U;
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
#line 48
    if (! (u < intervals->count)) {
#line 48
      goto while_break;
    }
#line 52
    tip = (struct time_interval *)*(intervals->ptrs + u);
#line 53
    if ((int )tip->min_start <= (int )min_current) {
#line 53
      if ((int )min_current <= (int )tip->min_end) {
#line 54
        return (1);
      }
    }
#line 48
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (0);
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/time.c"
static int get_num(int *nump , int min_val , int max_val , char const   *s , char stop_char ) 
{ 
  char const   *func ;
  int i ;
  unsigned short const   **tmp ;

  {
#line 66
  func = "get_num";
#line 67
  i = 0;
#line 69
  *nump = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 69
    tmp = __ctype_b_loc();
    }
#line 69
    if (! ((int const   )*(*tmp + (int )*(s + i)) & 2048)) {
#line 69
      goto while_break;
    }
#line 71
    *nump *= 10;
#line 72
    *nump += (int )((int const   )*(s + i) - 48);
#line 69
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  if ((int const   )*(s + i) != (int const   )stop_char) {
    {
#line 77
    parsemsg(3, func, "incorrect time interval");
    }
#line 78
    return (-1);
  }
#line 81
  if (min_val <= *nump) {
#line 81
    if (! (*nump <= max_val)) {
      {
#line 83
      parsemsg(3, func, "invalid time interval");
      }
#line 84
      return (-1);
    }
  } else {
    {
#line 83
    parsemsg(3, func, "invalid time interval");
    }
#line 84
    return (-1);
  }
#line 86
  return (i);
}
}
#line 95 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/time.c"
status_e ti_add(pset_h iset , char const   *interval_str ) 
{ 
  struct time_interval *tip ;
  int hours ;
  int minutes ;
  int min_start ;
  int min_end ;
  int p ;
  int r ;
  char const   *func ;
  int tmp ;
  void *tmp___0 ;
  __pset_pointer tmp___1 ;

  {
#line 102
  r = 0;
#line 103
  func = "add_interval";
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! ((int const   )*(interval_str + r) == 32)) {
#line 105
      goto while_break;
    }
#line 106
    r ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  p = get_num(& hours, 0, 23, interval_str + r, (char )':');
  }
#line 107
  if (p == -1) {
#line 108
    return ((status_e )0);
  }
  {
#line 109
  r += p;
#line 110
  r ++;
#line 111
  p = get_num(& minutes, 0, 59, interval_str + r, (char )'-');
  }
#line 111
  if (p == -1) {
#line 112
    return ((status_e )0);
  }
  {
#line 113
  min_start = hours * 60 + minutes;
#line 115
  r += p;
#line 116
  r ++;
#line 117
  p = get_num(& hours, 0, 23, interval_str + r, (char )':');
  }
#line 117
  if (p == -1) {
#line 118
    return ((status_e )0);
  }
  {
#line 119
  r += p;
#line 120
  r ++;
#line 121
  tmp = get_num(& minutes, 0, 59, interval_str + r, (char )'\000');
  }
#line 121
  if (tmp == -1) {
#line 122
    return ((status_e )0);
  }
#line 123
  min_end = hours * 60 + minutes;
#line 124
  if (min_start >= min_end) {
    {
#line 126
    parsemsg(3, func, "invalid time interval: %s", interval_str);
    }
#line 127
    return ((status_e )0);
  }
  {
#line 130
  tmp___0 = malloc(sizeof(struct time_interval ));
#line 130
  tip = (struct time_interval *)tmp___0;
  }
#line 131
  if ((unsigned long )tip == (unsigned long )((void *)0)) {
    {
#line 133
    out_of_memory(func);
    }
#line 134
    return ((status_e )0);
  }
  {
#line 136
  tip->min_start = (int16_t )min_start;
#line 137
  tip->min_end = (int16_t )min_end;
#line 138
  tmp___1 = pset_add(iset, (__pset_pointer const   )tip);
  }
#line 138
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 140
    free((void *)((char *)tip));
#line 141
    out_of_memory(func);
    }
#line 142
    return ((status_e )0);
  }
#line 144
  return ((status_e )1);
}
}
#line 148 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/time.c"
void ti_dump(pset_h iset , int fd ) 
{ 
  unsigned int u ;
  struct time_interval *tip ;

  {
#line 152
  u = 0U;
  {
#line 152
  while (1) {
    while_continue: /* CIL Label */ ;
#line 152
    if (! (u < iset->count)) {
#line 152
      goto while_break;
    }
    {
#line 154
    tip = (struct time_interval *)*(iset->ptrs + u);
#line 156
    Sprint(fd, " %02d:%02d-%02d:%02d", (int )tip->min_start / 60, (int )tip->min_start % 60,
           (int )tip->min_end / 60, (int )tip->min_end % 60);
#line 152
    u ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  return;
}
}
#line 163 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/time.c"
void ti_free(pset_h iset ) 
{ 


  {
  {
#line 165
  pset_apply(iset, (void (*)())(& free), (void *)0);
  }
#line 166
  return;
}
}
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getsockname)(int __fd ,
                                                                                  struct sockaddr * __restrict  __addr ,
                                                                                  socklen_t * __restrict  __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 59 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int __sigsetjmp(struct __jmp_buf_tag *__env ,
                                                     int __savemask ) ;
#line 102
extern  __attribute__((__nothrow__, __noreturn__)) void siglongjmp(struct __jmp_buf_tag *__env ,
                                                                   int __val ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 360 "/usr/include/unistd.h"
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 31 "../libs/include/str.h"
extern int ( /* format attribute */  strx_nprint)(char *buf , int len , char const   *fmt 
                                                  , ...) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.h"
idresult_e log_remote_user(struct server  const  *serp , unsigned int timeout ) ;
#line 7
char const   *idresult_explain(idresult_e result ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.h"
void ( /* format attribute */  msg)(int level , char const   *func , char const   *fmt 
                                    , ...) ;
#line 188 "../libs/include/sio.h"
extern int Sclose(int fd ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
status_e write_buf(int fd , char const   *buf___0 , int len ) ;
#line 25
int parse_base10(char const   *str , int *res ) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.h"
char const   *xaddrname(union xsockaddr  const  *inaddr ) ;
#line 64
void ( /* format attribute */  svc_logprint)(struct service *sp , char const   *line_id ,
                                             char const   *fmt  , ...) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.c"
static char *get_line(int sd , char *buf___0 , unsigned int bufsize ) ;
#line 37
static char *verify_line(char *line , unsigned int local_port , unsigned int remote_port ) ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.c"
static sigjmp_buf env  ;
#line 50
static  __attribute__((__noreturn__)) void sigalrm_handler(int signum ) ;
#line 50 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.c"
static void sigalrm_handler(int signum ) 
{ 


  {
  {
#line 54
  siglongjmp((struct __jmp_buf_tag *)(env), 1);
  }
}
}
#line 63 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.c"
static char buf[1024]  ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.c"
idresult_e log_remote_user(struct server  const  *serp , unsigned int timeout ) 
{ 
  int cc ;
  union xsockaddr sin_local ;
  union xsockaddr sin_remote ;
  union xsockaddr sin_contact ;
  union xsockaddr sin_bind ;
  unsigned int volatile   local_port ;
  unsigned int volatile   remote_port ;
  int sd ;
  socklen_t sin_len ;
  char *p ;
  char const   *func ;
  __sighandler_t tmp ;
  __pid_t tmp___0 ;
  int tmp___1 ;
  union xsockaddr *tmp___2 ;
  union xsockaddr *tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;
  uint16_t tmp___6 ;
  uint16_t tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  status_e tmp___12 ;
  char const   *tmp___13 ;

  {
#line 71
  func = "log_remote_user";
#line 73
  if (timeout) {
    {
#line 73
    tmp = signal(14, & sigalrm_handler);
    }
#line 73
    if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))-1)) {
      {
#line 75
      msg(3, func, "signal: %m");
      }
#line 76
      return ((idresult_e )5);
    }
  }
  {
#line 82
  sin_len = (socklen_t )sizeof(sin_local);
#line 83
  tmp___1 = getsockname((serp->svr_conn)->co_descriptor, (struct sockaddr */* __restrict  */)(& sin_local.sa),
                        (socklen_t */* __restrict  */)(& sin_len));
  }
#line 83
  if (tmp___1 == -1) {
    {
#line 85
    tmp___0 = getpid();
#line 85
    msg(3, func, "(%d) getsockname: %m", tmp___0);
    }
#line 86
    return ((idresult_e )5);
  }
#line 89
  if (((connection_s *)serp->svr_conn)->co_flags & 1UL) {
#line 89
    tmp___2 = & ((connection_s *)serp->svr_conn)->co_remote_address;
  } else {
#line 89
    tmp___2 = (union xsockaddr *)((void *)0);
  }
#line 89
  if ((unsigned long )tmp___2 == (unsigned long )((void *)0)) {
    {
#line 95
    msg(3, func, "connection has no address");
    }
#line 96
    return ((idresult_e )5);
  }
  {
#line 99
  memset((void *)((char *)(& sin_contact)), 0, sizeof(sin_contact));
  }
#line 100
  if (((connection_s *)serp->svr_conn)->co_flags & 1UL) {
#line 100
    tmp___3 = & ((connection_s *)serp->svr_conn)->co_remote_address;
  } else {
#line 100
    tmp___3 = (union xsockaddr *)((void *)0);
  }
  {
#line 100
  sin_remote = *tmp___3;
#line 101
  sin_contact = sin_remote;
#line 102
  memcpy((void */* __restrict  */)(& sin_bind), (void const   */* __restrict  */)(& sin_local),
         sizeof(sin_bind));
#line 103
  local_port = (unsigned int volatile   )0;
#line 104
  remote_port = (unsigned int volatile   )0;
  }
#line 105
  if ((int )sin_remote.sa.sa_family == 2) {
    {
#line 106
    tmp___4 = ntohs(sin_local.sa_in6.sin6_port);
#line 106
    local_port = (unsigned int volatile   )tmp___4;
#line 107
    tmp___5 = ntohs(sin_remote.sa_in6.sin6_port);
#line 107
    remote_port = (unsigned int volatile   )tmp___5;
#line 108
    sin_contact.sa_in6.sin6_port = htons((uint16_t )113);
#line 109
    sin_bind.sa_in.sin_port = (in_port_t )0;
    }
  } else
#line 110
  if ((int )sin_remote.sa.sa_family == 10) {
    {
#line 111
    tmp___6 = ntohs(sin_local.sa_in.sin_port);
#line 111
    local_port = (unsigned int volatile   )tmp___6;
#line 112
    tmp___7 = ntohs(sin_remote.sa_in.sin_port);
#line 112
    remote_port = (unsigned int volatile   )tmp___7;
#line 113
    sin_contact.sa_in.sin_port = htons((uint16_t )113);
#line 114
    sin_bind.sa_in6.sin6_port = (in_port_t )0;
    }
  }
  {
#line 124
  sd = socket((int )sin_remote.sa.sa_family, 1, 0);
  }
#line 125
  if (sd == -1) {
    {
#line 127
    msg(3, func, "socket creation: %m");
    }
#line 128
    return ((idresult_e )5);
  }
  {
#line 130
  tmp___8 = bind(sd, (struct sockaddr  const  *)(& sin_bind.sa), (socklen_t )sizeof(sin_bind.sa));
  }
#line 130
  if (tmp___8 == -1) {
    {
#line 132
    msg(3, func, "socket bind: %m");
#line 133
    Sclose(sd);
    }
#line 134
    return ((idresult_e )5);
  }
  {
#line 136
  tmp___9 = fcntl(sd, 2, 1);
  }
#line 136
  if (tmp___9 == -1) {
    {
#line 138
    msg(3, func, "fcntl F_SETFD: %m");
#line 139
    Sclose(sd);
    }
#line 140
    return ((idresult_e )5);
  }
#line 143
  if (timeout) {
    {
#line 144
    tmp___10 = __sigsetjmp((struct __jmp_buf_tag *)(env), 1);
    }
#line 144
    if (tmp___10 == 0) {
      {
#line 145
      alarm(timeout);
      }
    } else {
      {
#line 147
      Sclose(sd);
      }
#line 148
      return ((idresult_e )2);
    }
  }
  {
#line 152
  tmp___11 = connect(sd, (struct sockaddr  const  *)(& sin_contact.sa), (socklen_t )sizeof(sin_contact));
  }
#line 152
  if (tmp___11 == -1) {
#line 154
    if (timeout) {
      {
#line 155
      alarm(0U);
#line 156
      signal(14, (void (*)(int  ))0);
      }
    }
    {
#line 158
    Sclose(sd);
    }
#line 159
    return ((idresult_e )1);
  }
  {
#line 162
  cc = strx_nprint(buf, (int )sizeof(buf), "%d,%d\r\n", remote_port, local_port);
#line 164
  tmp___12 = write_buf(sd, (char const   *)(buf), cc);
  }
#line 164
  if ((unsigned int )tmp___12 == 0U) {
#line 166
    if (timeout) {
      {
#line 167
      alarm(0U);
#line 168
      signal(14, (void (*)(int  ))0);
      }
    }
    {
#line 170
    Sclose(sd);
    }
#line 171
    return ((idresult_e )5);
  }
  {
#line 174
  p = get_line(sd, buf, (unsigned int )sizeof(buf));
  }
#line 176
  if (timeout) {
    {
#line 177
    alarm(0U);
#line 178
    signal(14, (void (*)(int  ))0);
    }
  }
#line 181
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 182
    Sclose(sd);
    }
#line 183
    return ((idresult_e )3);
  }
  {
#line 189
  p = verify_line(buf, (unsigned int )local_port, (unsigned int )remote_port);
  }
#line 189
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 191
    tmp___13 = xaddrname((union xsockaddr  const  *)(& sin_remote));
#line 191
    msg(3, func, "Bad line received from identity server at %s: %s", tmp___13, buf);
#line 193
    Sclose(sd);
    }
#line 194
    return ((idresult_e )4);
  }
  {
#line 197
  svc_logprint(((connection_s *)serp->svr_conn)->co_sp, "USERID", "%s", p);
  }
#line 198
  return ((idresult_e )0);
}
}
#line 202 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.c"
static char *verify_line(char *line , unsigned int local_port , unsigned int remote_port ) 
{ 
  char *p ;
  char *start ;
  int port ;
  int tmp ;
  int tmp___0 ;
  char const   *line_id ;
  unsigned int line_id_len ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  int tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;

  {
  {
#line 207
  start = line;
#line 213
  p = strchr((char const   *)start, ',');
  }
#line 214
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 215
    return ((char *)((void *)0));
  }
  {
#line 216
  *p = (char )'\000';
#line 217
  tmp = parse_base10((char const   *)start, & port);
  }
#line 217
  if (tmp) {
#line 219
    *p = (char )',';
#line 220
    return ((char *)((void *)0));
  } else
#line 217
  if (port < 0) {
#line 219
    *p = (char )',';
#line 220
    return ((char *)((void *)0));
  } else
#line 217
  if ((unsigned int )port != remote_port) {
#line 219
    *p = (char )',';
#line 220
    return ((char *)((void *)0));
  }
  {
#line 222
  *p = (char )',';
#line 224
  start = p + 1;
#line 225
  p = strchr((char const   *)start, ':');
  }
#line 226
  if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 227
    return ((char *)((void *)0));
  }
  {
#line 228
  *p = (char )'\000';
#line 229
  tmp___0 = parse_base10((char const   *)start, & port);
  }
#line 229
  if (tmp___0) {
#line 231
    *p = (char )':';
#line 232
    return ((char *)((void *)0));
  } else
#line 229
  if (port < 0) {
#line 231
    *p = (char )':';
#line 232
    return ((char *)((void *)0));
  } else
#line 229
  if ((unsigned int )port != local_port) {
#line 231
    *p = (char )':';
#line 232
    return ((char *)((void *)0));
  }
  {
#line 234
  *p = (char )':';
#line 240
  line_id = "USERID";
#line 241
  tmp___1 = strlen(line_id);
#line 241
  line_id_len = (unsigned int )tmp___1;
#line 243
  start = p + 1;
#line 244
  p = start;
  }
  {
#line 244
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 244
    tmp___2 = __ctype_b_loc();
    }
#line 244
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 244
      goto while_break;
    }
#line 244
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 245
  if ((int )*p == 0) {
#line 246
    return ((char *)((void *)0));
  }
  {
#line 247
  start = p;
#line 248
  tmp___3 = strncmp((char const   *)start, line_id, (size_t )line_id_len);
  }
#line 248
  if (tmp___3 != 0) {
#line 249
    return ((char *)((void *)0));
  }
#line 250
  start += line_id_len;
#line 253
  p = start;
  {
#line 253
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 253
    tmp___4 = __ctype_b_loc();
    }
#line 253
    if (! ((int const   )*(*tmp___4 + (int )*p) & 8192)) {
#line 253
      goto while_break___0;
    }
#line 253
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 254
  if ((int )*p != 58) {
#line 255
    return ((char *)((void *)0));
  }
#line 256
  p ++;
  {
#line 256
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 256
    tmp___5 = __ctype_b_loc();
    }
#line 256
    if (! ((int const   )*(*tmp___5 + (int )*p) & 8192)) {
#line 256
      goto while_break___1;
    }
#line 256
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 257
  if ((int )*p == 0) {
#line 258
    return ((char *)((void *)0));
  }
#line 259
  return (p);
}
}
#line 267 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.c"
static char *get_line(int sd , char *buf___0 , unsigned int bufsize ) 
{ 
  int size ;
  ssize_t cc ;
  char *p ;
  char *s ;
  char const   *func ;
  int *tmp ;

  {
#line 273
  func = "get_line";
#line 275
  p = buf___0;
#line 275
  size = (int )bufsize;
  {
#line 275
  while (1) {
    while_continue: /* CIL Label */ ;
#line 275
    if (! (size > 0)) {
#line 275
      goto while_break;
    }
    {
#line 277
    cc = read(sd, (void *)p, (size_t )size);
    }
#line 278
    if (cc == -1L) {
      {
#line 279
      tmp = __errno_location();
      }
#line 279
      if (*tmp == 4) {
#line 281
        cc = (ssize_t )0;
#line 282
        goto __Cont;
      } else {
        {
#line 286
        msg(3, func, "read: %m");
        }
#line 287
        return ((char *)0);
      }
    }
#line 291
    if (cc == 0L) {
      {
#line 293
      msg(3, func, "identd server reply missing ending CR-LF");
      }
#line 294
      return ((char *)0);
    }
#line 296
    s = p;
    {
#line 296
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 296
      if (! ((unsigned long )s < (unsigned long )(p + cc))) {
#line 296
        goto while_break___0;
      }
#line 298
      if ((int )*s == 10) {
#line 298
        if ((unsigned long )s != (unsigned long )buf___0) {
#line 298
          if ((int )*(s - 1) == 13) {
#line 300
            *(s - 1) = (char )'\000';
#line 301
            return (buf___0);
          }
        }
      }
#line 296
      s ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 275
    p += cc;
#line 275
    size = (int )((ssize_t )size - cc);
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 305
  msg(3, func, "Too much input from identity server");
  }
#line 306
  return ((char *)0);
}
}
#line 310 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/ident.c"
char const   *idresult_explain(idresult_e result ) 
{ 
  char const   *reason ;

  {
#line 312
  reason = "UNKNOWN";
  {
#line 316
  if ((unsigned int )result == 0U) {
#line 316
    goto case_0;
  }
#line 320
  if ((unsigned int )result == 1U) {
#line 320
    goto case_1;
  }
#line 324
  if ((unsigned int )result == 2U) {
#line 324
    goto case_2;
  }
#line 328
  if ((unsigned int )result == 5U) {
#line 328
    goto case_5;
  }
#line 332
  if ((unsigned int )result == 3U) {
#line 332
    goto case_3;
  }
#line 336
  if ((unsigned int )result == 4U) {
#line 336
    goto case_4;
  }
#line 314
  goto switch_break;
  case_0: /* CIL Label */ 
#line 317
  reason = "no error";
#line 318
  goto switch_break;
  case_1: /* CIL Label */ 
#line 321
  reason = "no server";
#line 322
  goto switch_break;
  case_2: /* CIL Label */ 
#line 325
  reason = "timeout";
#line 326
  goto switch_break;
  case_5: /* CIL Label */ 
#line 329
  reason = "system error";
#line 330
  goto switch_break;
  case_3: /* CIL Label */ 
#line 333
  reason = "error while receiving response";
#line 334
  goto switch_break;
  case_4: /* CIL Label */ 
#line 337
  reason = "bad response";
#line 338
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 340
  return (reason);
}
}
#line 149 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 156
extern ssize_t recv(int __fd , void *__buf , size_t __n , int __flags ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 181 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
struct debug debug ;
#line 77 "../libs/include/pset.h"
extern void psi_remove(psi_h iter ) ;
#line 94
extern psi_h psi_create(pset_h pset ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.h"
 __attribute__((__noreturn__)) void si_exit(void) ;
#line 11
struct intercept_s *si_init(struct server *serp ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.h"
void int_fail(struct intercept_s  const  *ip , char const   *lsyscall ) ;
#line 9
int int_select(int max , fd_set *read_mask ) ;
#line 11
 __attribute__((__noreturn__)) void int_exit(struct intercept_s *ip ) ;
#line 14
void int_init(struct intercept_s *ip , struct server *serp ) ;
#line 16
channel_s *int_newconn(struct intercept_s *ip , union xsockaddr *sinp , int remote_socket ) ;
#line 18
channel_s *int_lookupconn(struct intercept_s *ip , union xsockaddr *sinp , bool_int *addr_checked ) ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.h"
access_e access_control(struct service *sp , connection_s const   *cp , mask_t const   *check_mask ) ;
#line 60 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.h"
uint16_t xaddrport(union xsockaddr  const  *inaddr ) ;
#line 61
void svc_log_success(struct service *sp , connection_s const   *cp , pid_t pid ) ;
#line 62
void svc_log_failure(struct service *sp , connection_s const   *cp , access_e access_failure ) ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
static struct istream_private istream  ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
static struct intercept_s stream_intercept_state  ;
#line 42
static void si_mux(void) ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
static struct intercept_ops istream_ops  =    {& si_mux, & si_exit};
#line 53 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
struct intercept_s *si_init(struct server *serp ) 
{ 
  struct intercept_s *ip ;
  __sighandler_t tmp ;

  {
  {
#line 55
  ip = & stream_intercept_state;
#line 57
  ip->int_socket_type = 1;
#line 58
  ip->int_priv = (void *)(& istream);
#line 59
  ip->int_ops = (struct intercept_ops  const  *)(& istream_ops);
#line 60
  int_init(ip, serp);
#line 61
  tmp = signal(13, (void (*)(int  ))1);
  }
#line 61
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 62
    int_fail((struct intercept_s  const  *)ip, "signal");
    }
  }
#line 63
  return (ip);
}
}
#line 66
static status_e handle_io(psi_h iter___0 , channel_s *chp , fd_set *maskp , stream_status_e (*iofunc)() ) ;
#line 67
static stream_status_e tcp_local_to_remote(channel_s *chp ) ;
#line 68
static stream_status_e tcp_remote_to_local(channel_s *chp ) ;
#line 69
static void connection_request(struct intercept_s *ip , channel_s **chpp ) ;
#line 72
 __attribute__((__noreturn__)) void si_exit(void) ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
void si_exit(void) 
{ 
  struct intercept_s *ip ;

  {
#line 74
  ip = & stream_intercept_state;
#line 76
  if (((struct istream_private *)ip->int_priv)->accepted_connections == 0U) {
    {
#line 77
    accept(ip->int_common.ic_remote_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)((void *)0)),
           (socklen_t */* __restrict  */)((void *)0));
    }
  }
  {
#line 78
  int_exit(ip);
  }
}
}
#line 82 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
static void si_mux(void) 
{ 
  struct intercept_s *ip ;
  fd_set socket_mask ;
  int mask_max ;
  psi_h iter___0 ;
  char const   *func ;
  int __d0 ;
  int __d1 ;
  channel_s *chp ;
  fd_set read_mask ;
  int n_ready ;
  __pset_pointer tmp ;
  __pset_pointer tmp___0 ;
  status_e tmp___1 ;
  status_e tmp___2 ;

  {
#line 84
  ip = & stream_intercept_state;
#line 88
  func = "si_mux";
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
#line 90
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& socket_mask.__fds_bits[0]): "memory");
#line 90
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 91
  socket_mask.__fds_bits[ip->int_common.ic_remote_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << ip->int_common.ic_remote_socket % (8 * (int )sizeof(__fd_mask ));
#line 92
  mask_max = ip->int_common.ic_remote_socket;
#line 94
  iter___0 = psi_create(ip->int_common.ic_connections);
  }
#line 95
  if ((unsigned long )iter___0 == (unsigned long )((void *)0)) {
    {
#line 97
    msg(3, func, "out of memory");
    }
#line 98
    return;
  }
  {
#line 101
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 107
    read_mask = socket_mask;
#line 108
    n_ready = int_select(mask_max + 1, & read_mask);
    }
#line 110
    if (n_ready == -1) {
#line 111
      return;
    }
#line 113
    if ((read_mask.__fds_bits[ip->int_common.ic_remote_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << ip->int_common.ic_remote_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 115
      connection_request(ip, & chp);
      }
#line 116
      if ((unsigned long )chp != (unsigned long )((void *)0)) {
#line 118
        socket_mask.__fds_bits[chp->ch_local_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << chp->ch_local_socket % (8 * (int )sizeof(__fd_mask ));
#line 119
        if (chp->ch_local_socket > mask_max) {
#line 120
          mask_max = chp->ch_local_socket;
        }
#line 121
        socket_mask.__fds_bits[chp->ch_remote_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << chp->ch_remote_socket % (8 * (int )sizeof(__fd_mask ));
#line 122
        if (chp->ch_remote_socket > mask_max) {
#line 123
          mask_max = chp->ch_remote_socket;
        }
      }
#line 125
      n_ready --;
#line 125
      if (n_ready == 0) {
#line 126
        goto __Cont;
      }
    }
#line 129
    iter___0->current = 0U;
#line 129
    iter___0->step = 1;
#line 129
    if (iter___0->current < (iter___0->pset)->count) {
#line 129
      tmp = *((iter___0->pset)->ptrs + iter___0->current);
    } else {
#line 129
      tmp = (void *)0;
    }
#line 129
    chp = (struct channel *)tmp;
    {
#line 129
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 129
      if (! chp) {
#line 129
        goto while_break___1;
      }
#line 131
      if ((read_mask.__fds_bits[chp->ch_local_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << chp->ch_local_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 138
        tmp___1 = handle_io(iter___0, chp, & socket_mask, (stream_status_e (*)())(& tcp_local_to_remote));
        }
#line 138
        if ((unsigned int )tmp___1 == 0U) {
#line 139
          return;
        }
#line 140
        n_ready --;
#line 140
        if (n_ready == 0) {
#line 141
          goto while_break___1;
        }
      }
#line 144
      if ((read_mask.__fds_bits[chp->ch_remote_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << chp->ch_remote_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 150
        tmp___2 = handle_io(iter___0, chp, & socket_mask, (stream_status_e (*)())(& tcp_remote_to_local));
        }
#line 150
        if ((unsigned int )tmp___2 == 0U) {
#line 152
          return;
        }
#line 153
        n_ready --;
#line 153
        if (n_ready == 0) {
#line 154
          goto while_break___1;
        }
      }
#line 129
      iter___0->current += (unsigned int )iter___0->step;
#line 129
      iter___0->step = 1;
#line 129
      if (iter___0->current < (iter___0->pset)->count) {
#line 129
        tmp___0 = *((iter___0->pset)->ptrs + iter___0->current);
      } else {
#line 129
        tmp___0 = (void *)0;
      }
#line 129
      chp = (struct channel *)tmp___0;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 161 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
static status_e handle_io(psi_h iter___0 , channel_s *chp , fd_set *maskp , stream_status_e (*iofunc)() ) 
{ 
  char const   *func ;
  stream_status_e tmp ;
  uint16_t tmp___0 ;
  uint16_t tmp___1 ;
  char const   *tmp___2 ;

  {
  {
#line 166
  func = "handle_io";
#line 168
  tmp = (*iofunc)(chp);
  }
  {
#line 170
  if ((unsigned int )tmp == 1U) {
#line 170
    goto case_1;
  }
#line 173
  if ((unsigned int )tmp == 2U) {
#line 173
    goto case_2;
  }
#line 188
  if ((unsigned int )tmp == 0U) {
#line 188
    goto case_0;
  }
#line 168
  goto switch_break;
  case_1: /* CIL Label */ 
#line 171
  return ((status_e )0);
  case_2: /* CIL Label */ 
#line 175
  if (debug.on) {
    {
#line 176
    tmp___0 = xaddrport((union xsockaddr  const  *)(& chp->ch_from));
#line 176
    tmp___1 = ntohs(tmp___0);
#line 176
    tmp___2 = xaddrname((union xsockaddr  const  *)(& chp->ch_from));
#line 176
    msg(7, func, "Closing channel to %s,%d using sockets %d(l),%d(r)", tmp___2, (int )tmp___1,
        chp->ch_local_socket, chp->ch_remote_socket);
    }
  }
  {
#line 181
  maskp->__fds_bits[chp->ch_local_socket / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << chp->ch_local_socket % (8 * (int )sizeof(__fd_mask )));
#line 182
  maskp->__fds_bits[chp->ch_remote_socket / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << chp->ch_remote_socket % (8 * (int )sizeof(__fd_mask )));
#line 183
  Sclose(chp->ch_remote_socket);
#line 184
  Sclose(chp->ch_local_socket);
#line 185
  psi_remove(iter___0);
#line 186
  free((void *)((char *)chp));
  }
#line 187
  goto switch_break;
  case_0: /* CIL Label */ 
#line 189
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 191
  return ((status_e )1);
}
}
#line 195 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
static void connection_request(struct intercept_s *ip , channel_s **chpp ) 
{ 
  union xsockaddr csin ;
  socklen_t sin_len ;
  channel_s *chp ;
  int sd ;
  bool_int addr_checked ;
  char const   *func ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  char const   *tmp___1 ;
  struct server *serp ;
  struct service *sp ;
  connection_s *cop ;
  mask_t check_mask ;
  access_e result ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;

  {
#line 198
  sin_len = (socklen_t )0;
#line 202
  func = "connection_request";
#line 204
  *chpp = (channel_s *)((void *)0);
#line 205
  if (((ip->int_common.ic_server.svr_sp)->svc_conf)->sc_xflags & (1UL << 9)) {
#line 206
    sin_len = (socklen_t )sizeof(struct sockaddr_in );
  }
#line 207
  if (((ip->int_common.ic_server.svr_sp)->svc_conf)->sc_xflags & (1UL << 10)) {
#line 208
    sin_len = (socklen_t )sizeof(struct sockaddr_in6 );
  }
  {
#line 210
  sd = accept(ip->int_common.ic_remote_socket, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& csin)),
              (socklen_t */* __restrict  */)(& sin_len));
  }
#line 210
  if (sd == -1) {
#line 211
    return;
  }
#line 213
  (((struct istream_private *)ip->int_priv)->accepted_connections) ++;
#line 215
  if (debug.on) {
    {
#line 216
    tmp = xaddrport((union xsockaddr  const  *)(& csin));
#line 216
    tmp___0 = ntohs(tmp);
#line 216
    tmp___1 = xaddrname((union xsockaddr  const  *)(& csin));
#line 216
    msg(7, func, "connection request from %s,%d", tmp___1, (int )tmp___0);
    }
  }
  {
#line 219
  chp = int_lookupconn(ip, & csin, & addr_checked);
  }
#line 220
  if ((unsigned long )chp == (unsigned long )((void *)0)) {
    {
#line 222
    serp = & ip->int_common.ic_server;
#line 223
    sp = serp->svr_sp;
#line 224
    cop = serp->svr_conn;
#line 226
    cop->co_flags |= 1UL;
#line 226
    memcpy((void */* __restrict  */)(cop->co_remote_address.pad), (void const   */* __restrict  */)(& csin),
           sizeof(csin));
    }
#line 228
    if (ip->int_common.ic_intercept) {
      {
#line 233
      check_mask = 1UL | (1UL << 1);
#line 234
      result = access_control(sp, (connection_s const   *)cop, (mask_t const   *)(& check_mask));
      }
#line 236
      if ((unsigned int )result != 0U) {
        {
#line 238
        svc_log_failure(sp, (connection_s const   *)cop, result);
#line 239
        Sclose(sd);
        }
#line 240
        return;
      }
    }
    {
#line 244
    chp = int_newconn(ip, & csin, sd);
    }
#line 244
    if ((unsigned long )chp == (unsigned long )((void *)0)) {
      {
#line 246
      Sclose(sd);
      }
#line 247
      return;
    }
#line 250
    if (! addr_checked) {
      {
#line 251
      svc_log_success(sp, (connection_s const   *)cop, serp->svr_pid);
      }
    }
#line 264
    *chpp = chp;
  } else {
    {
#line 267
    tmp___2 = xaddrport((union xsockaddr  const  *)(& csin));
#line 267
    tmp___3 = ntohs(tmp___2);
#line 267
    tmp___4 = xaddrname((union xsockaddr  const  *)(& csin));
#line 267
    msg(3, func, "Received another connection request from %s,%d", tmp___4, (int )tmp___3);
    }
  }
#line 270
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
static stream_status_e tcp_local_to_remote(channel_s *chp ) 
{ 
  char buf___0[2048] ;
  ssize_t rcc ;
  ssize_t wcc ;
  char *p ;
  int left ;
  char const   *func ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 279
  func = "tcp_local_to_remote";
  {
#line 281
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 283
    rcc = recv(chp->ch_local_socket, (void *)(buf___0), sizeof(buf___0), 0);
    }
#line 284
    if (rcc == 0L) {
#line 285
      return ((stream_status_e )1);
    } else
#line 286
    if (rcc == -1L) {
      {
#line 288
      tmp = __errno_location();
      }
#line 288
      if (*tmp != 4) {
        {
#line 290
        msg(3, func, "recv: %m");
        }
#line 291
        return ((stream_status_e )1);
      }
    } else {
#line 295
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  p = buf___0;
#line 298
  left = (int )rcc;
  {
#line 298
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 298
    if (! left) {
#line 298
      goto while_break___0;
    }
    {
#line 300
    wcc = send(chp->ch_remote_socket, (void const   *)p, (size_t )left, 0);
    }
#line 301
    if (wcc == 0L) {
#line 302
      return ((stream_status_e )2);
    } else
#line 303
    if (wcc == -1L) {
      {
#line 305
      tmp___0 = __errno_location();
      }
#line 305
      if (*tmp___0 == 4) {
#line 306
        wcc = (ssize_t )0;
      } else {
        {
#line 309
        msg(3, func, "send: %m");
        }
#line 310
        return ((stream_status_e )2);
      }
    }
#line 298
    p += wcc;
#line 298
    left = (int )((ssize_t )left - wcc);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 322
  return ((stream_status_e )0);
}
}
#line 326 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/tcpint.c"
static stream_status_e tcp_remote_to_local(channel_s *chp ) 
{ 
  char buf___0[2048] ;
  ssize_t rcc ;
  ssize_t wcc ;
  int left ;
  char *p ;
  char const   *func ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 332
  func = "tcp_remote_to_local";
  {
#line 334
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 336
    rcc = recv(chp->ch_remote_socket, (void *)(buf___0), sizeof(buf___0), 0);
    }
#line 337
    if (rcc == 0L) {
#line 338
      return ((stream_status_e )2);
    } else
#line 339
    if (rcc == -1L) {
      {
#line 341
      tmp = __errno_location();
      }
#line 341
      if (*tmp != 4) {
        {
#line 343
        msg(3, func, "recv: %m");
        }
#line 344
        return ((stream_status_e )2);
      }
    } else {
#line 348
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  p = buf___0;
#line 351
  left = (int )rcc;
  {
#line 351
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 351
    if (! left) {
#line 351
      goto while_break___0;
    }
    {
#line 353
    wcc = send(chp->ch_local_socket, (void const   *)p, (size_t )left, 0);
    }
#line 354
    if (wcc == 0L) {
#line 355
      return ((stream_status_e )1);
    } else
#line 356
    if (wcc == -1L) {
      {
#line 357
      tmp___0 = __errno_location();
      }
#line 357
      if (*tmp___0 == 4) {
#line 358
        rcc = (ssize_t )0;
      } else {
        {
#line 360
        msg(3, func, "send: %m");
        }
#line 361
        return ((stream_status_e )1);
      }
    }
#line 351
    p += wcc;
#line 351
    left = (int )((ssize_t )left - wcc);
  }
  while_break___0: /* CIL Label */ ;
  }
#line 373
  return ((stream_status_e )0);
}
}
#line 69 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 54 "/usr/include/rpc/netdb.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) endrpcent)(void) ;
#line 55
extern  __attribute__((__nothrow__)) struct rpcent *( __attribute__((__leaf__)) getrpcbyname)(char const   *__name ) ;
#line 276 "/usr/include/netdb.h"
extern void endservent(void) ;
#line 290
extern struct servent *getservbyname(char const   *__name , char const   *__proto ) ;
#line 344
extern void endprotoent(void) ;
#line 357
extern struct protoent *getprotobyname(char const   *__name ) ;
#line 662
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 70 "../libs/include/str.h"
extern char *new_string(char const   * ) ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.h"
builtin_s const   *builtin_find(char const   *service_name , int type ) ;
#line 301 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.h"
void sc_free(struct service_config *scp ) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.h"
void cnf_free(struct configuration *confp ) ;
#line 31
void cnf_dump(struct configuration *confp , int fd ) ;
#line 32
status_e cnf_init(struct configuration *confp , int *fdp , psi_h *iterp ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.h"
status_e cnf_get(struct configuration *confp ) ;
#line 47 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.h"
char const   *current_file ;
#line 49
char const   *attr_name_lookup(unsigned int id ) ;
#line 50
void parse_end(void) ;
#line 51
void parse_conf_file(int fd , struct configuration *confp , char const   *filename ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.h"
builtin_s const   *spec_find(char const   *service_name , int type ) ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/env.h"
status_e setup_environ(struct service_config *scp , struct service_config *def ) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.h"
void init_sensor(void) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/inet.h"
void parse_inet_conf_file(int fd , struct configuration *confp ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.h"
struct program_state ps ;
#line 43 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
int inetd_compat ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
static psi_h iter  ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
static status_e fix_server_argv(struct service_config *scp ) 
{ 
  char *server_name ;
  char const   *func ;
  void *tmp ;

  {
#line 56
  func = "fix_server_argv";
#line 58
  if ((unsigned long )scp->sc_server == (unsigned long )((void *)0)) {
    {
#line 60
    msg(3, func, "Must specify a server in %s", scp->sc_name);
    }
#line 62
    return ((status_e )0);
  }
#line 65
  if (scp->sc_xflags & (1UL << 4)) {
#line 66
    if (! (scp->sc_specified_attributes & (1UL << 6))) {
      {
#line 67
      msg(3, func, "Must specify server args if using NAMEINARGS flag");
      }
#line 69
      return ((status_e )0);
    }
#line 72
    return ((status_e )1);
  }
#line 81
  if (! (scp->sc_specified_attributes & (1UL << 6))) {
    {
#line 83
    tmp = malloc(2UL * sizeof(char *));
#line 83
    scp->sc_server_argv = (char **)tmp;
    }
#line 84
    if ((unsigned long )scp->sc_server_argv == (unsigned long )((void *)0)) {
      {
#line 86
      out_of_memory(func);
      }
#line 87
      return ((status_e )0);
    }
#line 89
    *(scp->sc_server_argv + 0) = (char *)((void *)0);
#line 90
    *(scp->sc_server_argv + 1) = (char *)((void *)0);
#line 91
    scp->sc_attributes_present |= 1UL << 6;
  }
  {
#line 97
  server_name = strrchr((char const   *)scp->sc_server, '/');
  }
#line 98
  if ((unsigned long )server_name == (unsigned long )((void *)0)) {
#line 99
    server_name = scp->sc_server;
  } else {
#line 101
    server_name ++;
  }
  {
#line 106
  *(scp->sc_server_argv + 0) = new_string((char const   *)server_name);
  }
#line 107
  if ((unsigned long )*(scp->sc_server_argv + 0) == (unsigned long )((void *)0)) {
    {
#line 109
    out_of_memory(func);
    }
#line 110
    return ((status_e )0);
  }
#line 112
  return ((status_e )1);
}
}
#line 128 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
static status_e service_fill(struct service_config *scp , struct service_config *def ) 
{ 
  char const   *func ;
  status_e tmp ;
  void *tmp___0 ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  int tmp___1 ;
  void *tmp___2 ;
  struct protoent *pep ;
  int tmp___3 ;
  int tmp___4 ;
  struct servent *sep ;
  struct servent *tmp___5 ;
  struct log *dlp ;
  struct log *slp ;
  status_e tmp___6 ;

  {
#line 131
  func = "service_fill";
#line 134
  if ((unsigned long )scp->sc_redir_addr != (unsigned long )((void *)0)) {
#line 135
    if (scp->sc_specified_attributes & (1UL << 5)) {
#line 135
      if (scp->sc_server) {
        {
#line 136
        free((void *)scp->sc_server);
        }
      }
    }
    {
#line 137
    scp->sc_server = new_string("/bin/true");
#line 138
    scp->sc_specified_attributes |= 1UL << 5;
#line 138
    scp->sc_attributes_present |= 1UL << 5;
    }
  }
#line 141
  if (! (scp->sc_type & (1UL << 1))) {
    {
#line 141
    tmp = fix_server_argv(scp);
    }
#line 141
    if ((unsigned int )tmp == 0U) {
#line 142
      return ((status_e )0);
    }
  }
#line 150
  if (! (scp->sc_specified_attributes & (1UL << 7))) {
#line 152
    if (def->sc_specified_attributes & (1UL << 7)) {
#line 152
      scp->sc_instances = def->sc_instances;
    } else {
#line 152
      scp->sc_instances = -1;
    }
#line 154
    scp->sc_attributes_present |= 1UL << 7;
  }
#line 157
  if (! (scp->sc_specified_attributes & (1UL << 40))) {
#line 157
    if (def->sc_specified_attributes & (1UL << 40)) {
#line 159
      scp->sc_umask = def->sc_umask;
#line 160
      scp->sc_specified_attributes |= 1UL << 40;
#line 160
      scp->sc_attributes_present |= 1UL << 40;
    }
  }
#line 163
  if (! (scp->sc_specified_attributes & (1UL << 26))) {
#line 165
    if (def->sc_specified_attributes & (1UL << 26)) {
#line 165
      scp->sc_per_source = def->sc_per_source;
    } else {
#line 165
      scp->sc_per_source = -1;
    }
#line 167
    scp->sc_specified_attributes |= 1UL << 26;
#line 167
    scp->sc_attributes_present |= 1UL << 26;
  }
#line 178
  if (! (scp->sc_specified_attributes & (1UL << 27))) {
#line 180
    if (def->sc_specified_attributes & (1UL << 27)) {
#line 180
      scp->sc_groups = def->sc_groups;
    } else {
#line 180
      scp->sc_groups = (boolean_e )0;
    }
#line 181
    scp->sc_specified_attributes |= 1UL << 27;
#line 181
    scp->sc_attributes_present |= 1UL << 27;
  }
#line 184
  if (! (scp->sc_specified_attributes & (1UL << 31))) {
#line 186
    if (def->sc_specified_attributes & (1UL << 31)) {
#line 186
      scp->sc_time_conn_max = def->sc_time_conn_max;
    } else {
#line 186
      scp->sc_time_conn_max = (time_t )50;
    }
#line 188
    if (def->sc_specified_attributes & (1UL << 31)) {
#line 188
      scp->sc_time_wait = def->sc_time_wait;
    } else {
#line 188
      scp->sc_time_wait = (time_t )10;
    }
#line 190
    scp->sc_time_reenable = (time_t )0;
  }
#line 206
  if (scp->sc_specified_attributes & (1UL << 24)) {
#line 206
    if ((unsigned long )scp->sc_bind_addr == (unsigned long )((void *)0)) {
#line 207
      scp->sc_specified_attributes &= ~ (1UL << 24);
    }
  }
#line 209
  if (! (scp->sc_specified_attributes & (1UL << 24))) {
#line 209
    if ((unsigned long )scp->sc_orig_bind_addr == (unsigned long )((char *)0)) {
#line 210
      if (def->sc_specified_attributes & (1UL << 24)) {
        {
#line 211
        tmp___0 = malloc(sizeof(union xsockaddr ));
#line 211
        scp->sc_bind_addr = (union xsockaddr *)tmp___0;
        }
#line 212
        if ((unsigned long )scp->sc_bind_addr == (unsigned long )((void *)0)) {
          {
#line 213
          msg(3, func, "can\'t allocate space for bind addr");
          }
#line 214
          return ((status_e )0);
        }
        {
#line 216
        memcpy((void */* __restrict  */)scp->sc_bind_addr, (void const   */* __restrict  */)def->sc_bind_addr,
               sizeof(union xsockaddr ));
#line 217
        scp->sc_specified_attributes |= 1UL << 24;
#line 217
        scp->sc_attributes_present |= 1UL << 24;
        }
      } else
#line 219
      if (def->sc_orig_bind_addr) {
        {
#line 220
        scp->sc_orig_bind_addr = new_string((char const   *)def->sc_orig_bind_addr);
        }
      }
    }
  }
#line 223
  if (! (scp->sc_specified_attributes & (1UL << 38))) {
#line 224
    if (def->sc_specified_attributes & (1UL << 38)) {
#line 224
      scp->sc_v6only = def->sc_v6only;
    } else {
#line 224
      scp->sc_v6only = (boolean_e )0;
    }
  }
#line 227
  if (! (scp->sc_specified_attributes & (1UL << 39))) {
#line 229
    if (def->sc_specified_attributes & (1UL << 39)) {
#line 229
      scp->sc_deny_time = def->sc_deny_time;
    } else {
#line 229
      scp->sc_deny_time = 0;
    }
#line 231
    scp->sc_specified_attributes |= 1UL << 39;
#line 231
    scp->sc_attributes_present |= 1UL << 39;
  }
#line 234
  if (! (scp->sc_xflags & (1UL << 9))) {
#line 234
    if (! (scp->sc_xflags & (1UL << 10))) {
#line 240
      if (scp->sc_specified_attributes & (1UL << 24)) {
#line 240
        if (! scp->sc_orig_bind_addr) {
#line 242
          if ((int )((struct sockaddr_in *)scp->sc_bind_addr)->sin_family == 2) {
#line 243
            scp->sc_xflags |= 1UL << 9;
          } else {
#line 245
            scp->sc_xflags |= 1UL << 10;
          }
        } else {
#line 248
          scp->sc_xflags |= 1UL << 9;
        }
      } else {
#line 248
        scp->sc_xflags |= 1UL << 9;
      }
    }
  }
#line 251
  if (scp->sc_orig_bind_addr) {
    {
#line 260
    memset((void *)(& hints), 0, sizeof(hints));
#line 261
    hints.ai_flags = 2;
    }
#line 262
    if (scp->sc_xflags & (1UL << 10)) {
#line 263
      hints.ai_family = 10;
    } else {
#line 265
      hints.ai_family = 2;
    }
    {
#line 267
    tmp___1 = getaddrinfo((char const   */* __restrict  */)scp->sc_orig_bind_addr,
                          (char const   */* __restrict  */)((void *)0), (struct addrinfo  const  */* __restrict  */)(& hints),
                          (struct addrinfo **/* __restrict  */)(& res));
    }
#line 267
    if (tmp___1 < 0) {
      {
#line 269
      msg(3, func, "bad address given for: %s", scp->sc_name);
      }
#line 270
      return ((status_e )0);
    }
#line 273
    if ((unsigned long )res == (unsigned long )((void *)0)) {
      {
#line 275
      msg(3, func, "no addresses returned for: %s", scp->sc_name);
      }
#line 276
      return ((status_e )0);
    } else
#line 273
    if ((unsigned long )res->ai_addr == (unsigned long )((void *)0)) {
      {
#line 275
      msg(3, func, "no addresses returned for: %s", scp->sc_name);
      }
#line 276
      return ((status_e )0);
    }
#line 279
    if (res->ai_family == 2) {
#line 279
      goto _L;
    } else
#line 279
    if (res->ai_family == 10) {
      _L: /* CIL Label */ 
      {
#line 281
      tmp___2 = malloc(sizeof(union xsockaddr ));
#line 281
      scp->sc_bind_addr = (union xsockaddr *)tmp___2;
      }
#line 283
      if ((unsigned long )scp->sc_bind_addr == (unsigned long )((void *)0)) {
        {
#line 285
        msg(3, func, "can\'t allocate space for bind addr of: %s", scp->sc_name);
        }
#line 287
        return ((status_e )0);
      }
      {
#line 289
      memset((void *)scp->sc_bind_addr, 0, sizeof(union xsockaddr ));
#line 290
      memcpy((void */* __restrict  */)scp->sc_bind_addr, (void const   */* __restrict  */)res->ai_addr,
             (size_t )res->ai_addrlen);
#line 291
      free((void *)scp->sc_orig_bind_addr);
#line 292
      scp->sc_orig_bind_addr = (char *)0;
#line 293
      scp->sc_specified_attributes |= 1UL << 24;
#line 293
      scp->sc_attributes_present |= 1UL << 24;
      }
    }
    {
#line 295
    freeaddrinfo(res);
    }
  }
#line 301
  if (! (scp->sc_specified_attributes & (1UL << 2))) {
#line 301
    if (scp->sc_specified_attributes & (1UL << 1)) {
#line 306
      if (scp->sc_socket_type == 1) {
        {
#line 307
        pep = getprotobyname("tcp");
        }
#line 307
        if ((unsigned long )pep != (unsigned long )((void *)0)) {
          {
#line 308
          scp->sc_protocol.name = new_string("tcp");
          }
#line 309
          if ((unsigned long )scp->sc_protocol.name == (unsigned long )((void *)0)) {
#line 310
            return ((status_e )0);
          }
#line 311
          scp->sc_protocol.value = pep->p_proto;
#line 312
          scp->sc_specified_attributes |= 1UL << 2;
#line 312
          scp->sc_attributes_present |= 1UL << 2;
        }
      }
#line 316
      if (scp->sc_socket_type == 2) {
        {
#line 317
        pep = getprotobyname("udp");
        }
#line 317
        if ((unsigned long )pep != (unsigned long )((void *)0)) {
          {
#line 318
          scp->sc_protocol.name = new_string("udp");
          }
#line 319
          if ((unsigned long )scp->sc_protocol.name == (unsigned long )((void *)0)) {
#line 320
            return ((status_e )0);
          }
#line 321
          scp->sc_protocol.value = pep->p_proto;
#line 322
          scp->sc_specified_attributes |= 1UL << 2;
#line 322
          scp->sc_attributes_present |= 1UL << 2;
        }
      }
    }
  }
#line 326
  if (scp->sc_specified_attributes & (1UL << 2)) {
#line 326
    if (! (scp->sc_specified_attributes & (1UL << 1))) {
#line 329
      if ((unsigned long )scp->sc_protocol.name != (unsigned long )((void *)0)) {
        {
#line 329
        tmp___3 = strcasecmp("tcp", (char const   *)scp->sc_protocol.name);
        }
#line 329
        if (tmp___3 == 0) {
#line 331
          scp->sc_socket_type = 1;
#line 332
          scp->sc_specified_attributes |= 1UL << 1;
#line 332
          scp->sc_attributes_present |= 1UL << 1;
        }
      }
#line 335
      if ((unsigned long )scp->sc_protocol.name != (unsigned long )((void *)0)) {
        {
#line 335
        tmp___4 = strcasecmp("udp", (char const   *)scp->sc_protocol.name);
        }
#line 335
        if (tmp___4 == 0) {
#line 337
          scp->sc_socket_type = 2;
#line 338
          scp->sc_specified_attributes |= 1UL << 1;
#line 338
          scp->sc_attributes_present |= 1UL << 1;
        }
      }
    }
  }
#line 348
  if (! (scp->sc_specified_attributes & (1UL << 18))) {
#line 348
    if (! (scp->sc_type & (1UL << 5))) {
#line 348
      if (! (scp->sc_type & (1UL << 6))) {
#line 348
        if (! (scp->sc_type & 1UL)) {
#line 350
          if (scp->sc_type & (1UL << 2)) {
            {
#line 351
            msg(3, func, "Unlisted service: %s must have a port entry", scp->sc_name);
            }
#line 353
            return ((status_e )0);
          }
#line 355
          if (scp->sc_specified_attributes & (1UL << 2)) {
            {
#line 361
            tmp___5 = getservbyname((char const   *)scp->sc_name, (char const   *)scp->sc_protocol.name);
#line 361
            sep = tmp___5;
            }
#line 363
            if ((unsigned long )sep != (unsigned long )((void *)0)) {
              {
#line 365
              scp->sc_port = ntohs((uint16_t )sep->s_port);
#line 366
              scp->sc_specified_attributes |= 1UL << 18;
#line 366
              scp->sc_attributes_present |= 1UL << 18;
              }
            } else {
              {
#line 369
              msg(3, func, "Port not specified and can\'t find service: %s with getservbyname",
                  scp->sc_name);
              }
#line 372
              return ((status_e )0);
            }
          } else {
            {
#line 376
            msg(3, func, "Port not specified for service: %s and no protocol given",
                scp->sc_name);
            }
#line 379
            return ((status_e )0);
          }
        }
      }
    }
  }
#line 383
  if (! (scp->sc_specified_attributes & (1UL << 16))) {
#line 383
    if (def->sc_specified_attributes & (1UL << 16)) {
#line 385
      scp->sc_log_on_success = def->sc_log_on_success;
#line 386
      scp->sc_specified_attributes |= 1UL << 16;
#line 386
      scp->sc_attributes_present |= 1UL << 16;
    }
  }
#line 389
  if (! (scp->sc_specified_attributes & (1UL << 15))) {
#line 389
    if (def->sc_specified_attributes & (1UL << 15)) {
#line 391
      scp->sc_log_on_failure = def->sc_log_on_failure;
#line 392
      scp->sc_specified_attributes |= 1UL << 15;
#line 392
      scp->sc_attributes_present |= 1UL << 15;
    }
  }
#line 395
  if (! (scp->sc_specified_attributes & (1UL << 12))) {
#line 395
    if (def->sc_specified_attributes & (1UL << 12)) {
#line 397
      dlp = & def->sc_log;
#line 398
      slp = & scp->sc_log;
      {
#line 402
      if ((unsigned int )dlp->l_type == 0U) {
#line 402
        goto case_0;
      }
#line 406
      if ((unsigned int )dlp->l_type == 2U) {
#line 406
        goto case_2;
      }
#line 410
      if ((unsigned int )dlp->l_type == 1U) {
#line 410
        goto case_1;
      }
#line 414
      goto switch_default;
      case_0: /* CIL Label */ 
#line 403
      slp->l_type = (logtype_e )0;
#line 404
      goto switch_break;
      case_2: /* CIL Label */ 
#line 407
      *slp = *dlp;
#line 408
      goto switch_break;
      case_1: /* CIL Label */ 
#line 411
      slp->l_type = (logtype_e )3;
#line 412
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 415
      msg(3, func, "bad log type: %d", (int )dlp->l_type);
      }
#line 417
      return ((status_e )0);
      switch_break: /* CIL Label */ ;
      }
#line 419
      scp->sc_specified_attributes |= 1UL << 12;
#line 419
      scp->sc_attributes_present |= 1UL << 12;
    }
  }
  {
#line 421
  tmp___6 = setup_environ(scp, def);
  }
#line 421
  if ((unsigned int )tmp___6 == 0U) {
#line 422
    return ((status_e )0);
  }
#line 423
  return ((status_e )1);
}
}
#line 427 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
static void remove_disabled_services(struct configuration *confp ) 
{ 
  pset_h disabled_services ;
  pset_h enabled_services ;
  struct service_config *scp ;
  struct service_config *defaults ;
  __pset_pointer tmp ;
  __pset_pointer tmp___0 ;
  __pset_pointer tmp___1 ;
  __pset_pointer tmp___2 ;
  register char *sid ;
  register unsigned int u ;
  int tmp___3 ;
  __pset_pointer tmp___4 ;
  __pset_pointer tmp___5 ;
  __pset_pointer tmp___6 ;
  __pset_pointer tmp___7 ;
  register char *sid___0 ;
  register unsigned int u___0 ;
  int tmp___8 ;

  {
#line 432
  defaults = confp->cnf_defaults;
#line 434
  if (defaults->sc_specified_attributes & (1UL << 41)) {
#line 435
    enabled_services = defaults->sc_enabled;
#line 439
    iter->current = 0U;
#line 439
    iter->step = 1;
#line 439
    if (iter->current < (iter->pset)->count) {
#line 439
      tmp = *((iter->pset)->ptrs + iter->current);
    } else {
#line 439
      tmp = (void *)0;
    }
#line 439
    scp = (struct service_config *)tmp;
    {
#line 439
    while (1) {
      while_continue: /* CIL Label */ ;
#line 439
      if (! scp) {
#line 439
        goto while_break;
      }
#line 440
      scp->sc_type |= 1UL << 4;
#line 439
      iter->current += (unsigned int )iter->step;
#line 439
      iter->step = 1;
#line 439
      if (iter->current < (iter->pset)->count) {
#line 439
        tmp___0 = *((iter->pset)->ptrs + iter->current);
      } else {
#line 439
        tmp___0 = (void *)0;
      }
#line 439
      scp = (struct service_config *)tmp___0;
    }
    while_break: /* CIL Label */ ;
    }
#line 443
    iter->current = 0U;
#line 443
    iter->step = 1;
#line 443
    if (iter->current < (iter->pset)->count) {
#line 443
      tmp___1 = *((iter->pset)->ptrs + iter->current);
    } else {
#line 443
      tmp___1 = (void *)0;
    }
#line 443
    scp = (struct service_config *)tmp___1;
    {
#line 443
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 443
      if (! scp) {
#line 443
        goto while_break___0;
      }
#line 445
      sid = scp->sc_id;
#line 448
      u = 0U;
      {
#line 448
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 448
        if (! (u < enabled_services->count)) {
#line 448
          goto while_break___1;
        }
        {
#line 449
        tmp___3 = strcasecmp((char const   *)sid, (char const   *)((char *)*(enabled_services->ptrs + u)));
        }
#line 449
        if (tmp___3 == 0) {
#line 450
          scp->sc_type &= ~ (1UL << 4);
#line 451
          goto while_break___1;
        }
#line 448
        u ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 443
      iter->current += (unsigned int )iter->step;
#line 443
      iter->step = 1;
#line 443
      if (iter->current < (iter->pset)->count) {
#line 443
        tmp___2 = *((iter->pset)->ptrs + iter->current);
      } else {
#line 443
        tmp___2 = (void *)0;
      }
#line 443
      scp = (struct service_config *)tmp___2;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 458
  iter->current = 0U;
#line 458
  iter->step = 1;
#line 458
  if (iter->current < (iter->pset)->count) {
#line 458
    tmp___4 = *((iter->pset)->ptrs + iter->current);
  } else {
#line 458
    tmp___4 = (void *)0;
  }
#line 458
  scp = (struct service_config *)tmp___4;
  {
#line 458
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 458
    if (! scp) {
#line 458
      goto while_break___2;
    }
#line 459
    if (scp->sc_type & (1UL << 4)) {
      {
#line 460
      msg(7, "remove_disabled_services", "removing %s", scp->sc_name);
#line 461
      scp->sc_type |= 1UL << 4;
#line 462
      sc_free(scp);
#line 463
      psi_remove(iter);
      }
    }
#line 458
    iter->current += (unsigned int )iter->step;
#line 458
    iter->step = 1;
#line 458
    if (iter->current < (iter->pset)->count) {
#line 458
      tmp___5 = *((iter->pset)->ptrs + iter->current);
    } else {
#line 458
      tmp___5 = (void *)0;
    }
#line 458
    scp = (struct service_config *)tmp___5;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 467
  if (! (defaults->sc_specified_attributes & (1UL << 42))) {
#line 468
    return;
  }
#line 470
  disabled_services = defaults->sc_disabled;
#line 472
  iter->current = 0U;
#line 472
  iter->step = 1;
#line 472
  if (iter->current < (iter->pset)->count) {
#line 472
    tmp___6 = *((iter->pset)->ptrs + iter->current);
  } else {
#line 472
    tmp___6 = (void *)0;
  }
#line 472
  scp = (struct service_config *)tmp___6;
  {
#line 472
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 472
    if (! scp) {
#line 472
      goto while_break___3;
    }
#line 474
    sid___0 = scp->sc_id;
#line 477
    u___0 = 0U;
    {
#line 477
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 477
      if (! (u___0 < disabled_services->count)) {
#line 477
        goto while_break___4;
      }
      {
#line 478
      tmp___8 = strcasecmp((char const   *)sid___0, (char const   *)((char *)*(disabled_services->ptrs + u___0)));
      }
#line 478
      if (tmp___8 == 0) {
        {
#line 480
        sc_free(scp);
#line 481
        psi_remove(iter);
        }
#line 482
        goto while_break___4;
      }
#line 477
      u___0 ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 472
    iter->current += (unsigned int )iter->step;
#line 472
    iter->step = 1;
#line 472
    if (iter->current < (iter->pset)->count) {
#line 472
      tmp___7 = *((iter->pset)->ptrs + iter->current);
    } else {
#line 472
      tmp___7 = (void *)0;
    }
#line 472
    scp = (struct service_config *)tmp___7;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 485
  return;
}
}
#line 491 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
static status_e service_attr_check(struct service_config *scp ) 
{ 
  mask_t necessary_and_specified ;
  mask_t necessary_and_missing ;
  mask_t must_specify ;
  unsigned int attr_id ;
  char const   *attr_name ;
  char const   *func ;

  {
#line 495
  must_specify = (1UL << 1) + 1UL;
#line 498
  func = "service_attr_check";
#line 503
  if (! (scp->sc_type & (1UL << 1))) {
#line 505
    must_specify |= (1UL << 5) + (1UL << 3);
#line 506
    if (scp->sc_type & (1UL << 2)) {
#line 508
      if (scp->sc_type & (1UL << 5)) {
#line 514
        must_specify |= 1UL << 2;
      } else
#line 508
      if (scp->sc_type & (1UL << 6)) {
#line 514
        must_specify |= 1UL << 2;
      } else {
#line 510
        must_specify |= (1UL << 2) + (1UL << 18);
      }
    }
  }
#line 519
  if (scp->sc_type & 1UL) {
#line 521
    must_specify &= ~ (1UL << 18);
#line 523
    must_specify |= (1UL << 2) + (1UL << 11);
#line 524
    if (scp->sc_type & (1UL << 2)) {
#line 525
      must_specify |= 1UL << 21;
    }
  } else
#line 529
  if (scp->sc_specified_attributes & (1UL << 23)) {
#line 530
    must_specify &= ~ (1UL << 5);
  }
#line 533
  if (scp->sc_xflags & (1UL << 9)) {
#line 533
    if (scp->sc_xflags & (1UL << 10)) {
      {
#line 534
      msg(3, func, "Service %s specified as both IPv4 and IPv6 - DISABLING", scp->sc_name);
      }
#line 537
      return ((status_e )0);
    }
  }
#line 548
  necessary_and_specified = scp->sc_specified_attributes & must_specify;
#line 550
  necessary_and_missing = necessary_and_specified ^ must_specify;
#line 552
  if (necessary_and_missing == 0UL) {
#line 553
    return ((status_e )1);
  }
#line 558
  attr_id = 0U;
  {
#line 558
  while (1) {
    while_continue: /* CIL Label */ ;
#line 558
    if (! (attr_id < 45U)) {
#line 558
      goto while_break;
    }
#line 559
    if (necessary_and_missing & (1UL << (attr_id - 1U))) {
      {
#line 559
      attr_name = attr_name_lookup(attr_id);
      }
#line 559
      if ((unsigned long )attr_name != (unsigned long )((void *)0)) {
        {
#line 562
        msg(3, func, "Service %s missing attribute %s - DISABLING", scp->sc_id, attr_name);
        }
      }
    }
#line 558
    attr_id ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 566
  return ((status_e )0);
}
}
#line 581 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
static status_e check_entry(struct service_config *scp , struct configuration  const  *confp ) 
{ 
  char const   *func ;
  unsigned int u ;
  pset_h sconfs ;
  int diff ;
  struct service_config  const  *tmp_scp ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  struct rpc_data  const  *rdp1 ;
  struct rpc_data  const  *rdp2 ;
  int tmp___2 ;
  struct rpcent *rep ;
  struct rpcent *tmp___3 ;
  uint16_t service_port ;
  struct servent *sep ;
  status_e tmp___4 ;

  {
#line 584
  func = "check_entry";
#line 586
  sconfs = (pset_h )confp->cnf_service_confs;
#line 591
  u = 0U;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    if (! (u < sconfs->count)) {
#line 591
      goto while_break;
    }
#line 593
    diff = 1;
#line 594
    tmp_scp = (struct service_config  const  *)((struct service_config *)*(sconfs->ptrs + u));
#line 595
    if ((unsigned long )tmp_scp == (unsigned long )scp) {
#line 596
      goto while_break;
    }
    {
#line 597
    tmp = strcasecmp((char const   *)tmp_scp->sc_id, (char const   *)scp->sc_id);
    }
#line 597
    if (tmp == 0) {
#line 599
      diff = 0;
    }
#line 601
    if ((unsigned long )tmp_scp->sc_bind_addr == (unsigned long )((void *)0)) {
#line 602
      goto __Cont;
    }
#line 603
    if ((int )scp->sc_port != (int )tmp_scp->sc_port) {
#line 605
      goto __Cont;
    } else
#line 603
    if (scp->sc_protocol.value != (int )tmp_scp->sc_protocol.value) {
#line 605
      goto __Cont;
    }
#line 606
    if ((unsigned long )scp->sc_bind_addr != (unsigned long )((void *)0)) {
#line 608
      if ((int )(scp->sc_bind_addr)->sa.sa_family != (int )(tmp_scp->sc_bind_addr)->sa.sa_family) {
#line 610
        goto __Cont;
      }
#line 611
      if ((int )(scp->sc_bind_addr)->sa.sa_family == 2) {
        {
#line 613
        tmp___0 = memcmp((void const   *)(& (scp->sc_bind_addr)->sa_in.sin_addr),
                         (void const   *)(& (tmp_scp->sc_bind_addr)->sa_in.sin_addr),
                         sizeof(struct in_addr ));
        }
#line 613
        if (tmp___0) {
#line 616
          goto __Cont;
        }
      } else {
        {
#line 620
        tmp___1 = memcmp((void const   *)(& (scp->sc_bind_addr)->sa_in6.sin6_addr),
                         (void const   *)(& (tmp_scp->sc_bind_addr)->sa_in6.sin6_addr),
                         sizeof(struct in6_addr ));
        }
#line 620
        if (tmp___1) {
#line 623
          goto __Cont;
        }
      }
    }
#line 626
    if (tmp_scp->sc_type & (unsigned long const   )(1UL << 4)) {
#line 633
      goto __Cont;
    } else
#line 626
    if (scp->sc_type & (1UL << 4)) {
#line 633
      goto __Cont;
    }
#line 636
    if (scp->sc_type & 1UL) {
#line 636
      if (tmp_scp->sc_type & 1UL) {
#line 638
        rdp1 = (struct rpc_data  const  *)(& scp->sc_rd);
#line 639
        rdp2 = & tmp_scp->sc_rd;
#line 640
        if (rdp1->rd_program_number != rdp2->rd_program_number) {
#line 641
          goto __Cont;
        }
#line 642
        if (rdp1->rd_min_version > rdp2->rd_max_version) {
#line 644
          goto __Cont;
        } else
#line 642
        if (rdp1->rd_max_version < rdp2->rd_min_version) {
#line 644
          goto __Cont;
        }
      }
    }
#line 647
    if (diff) {
      {
#line 648
      msg(3, func, "service: %s id: %s is unique but its identical to service: %s id: %s - DISABLING",
          scp->sc_name, scp->sc_id, tmp_scp->sc_name, tmp_scp->sc_id);
      }
    } else {
      {
#line 653
      msg(3, func, "service: %s id: %s not unique or is a duplicate - DISABLING",
          scp->sc_name, scp->sc_id);
      }
    }
#line 656
    return ((status_e )0);
    __Cont: /* CIL Label */ 
#line 591
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 665
  if (scp->sc_xflags & 1UL) {
#line 667
    if (scp->sc_type & (1UL << 1)) {
      {
#line 669
      msg(3, func, "Internal services cannot be intercepted: %s ", scp->sc_id);
#line 671
      scp->sc_xflags &= 0xfffffffffffffffeUL;
      }
    }
#line 673
    if ((unsigned int )scp->sc_wait == 0U) {
      {
#line 675
      msg(3, func, "Multi-threaded services cannot be intercepted: %s", scp->sc_id);
#line 677
      scp->sc_xflags &= 0xfffffffffffffffeUL;
      }
    }
  }
#line 682
  if (scp->sc_xflags & (1UL << 8)) {
#line 683
    scp->sc_type |= 1UL << 1;
  }
#line 685
  if (scp->sc_type & (1UL << 1)) {
#line 687
    if (scp->sc_xflags & (1UL << 8)) {
      {
#line 689
      init_sensor();
#line 690
      scp->sc_builtin = builtin_find("sensor", scp->sc_socket_type);
      }
    } else {
      {
#line 694
      scp->sc_builtin = builtin_find((char const   *)scp->sc_name, scp->sc_socket_type);
      }
    }
#line 696
    if ((unsigned long )scp->sc_builtin == (unsigned long )((void *)0)) {
#line 697
      return ((status_e )0);
    }
  }
#line 729
  if (scp->sc_type & (1UL << 5)) {
#line 729
    goto _L;
  } else
#line 729
  if (scp->sc_type & (1UL << 6)) {
    _L: /* CIL Label */ 
#line 731
    if (! (scp->sc_type & (1UL << 2))) {
      {
#line 733
      msg(3, func, "Service: %s (tcpmux) should have UNLISTED in type.", scp->sc_name);
      }
#line 736
      return ((status_e )0);
    }
    {
#line 739
    tmp___2 = strcasecmp("tcp", (char const   *)scp->sc_protocol.name);
    }
#line 739
    if (! (tmp___2 == 0)) {
      {
#line 741
      msg(3, func, "Service: %s (tcpmux) should have tcp in protocol.", scp->sc_name);
      }
#line 744
      return ((status_e )0);
    }
  }
#line 750
  if (scp->sc_type & 1UL) {
#line 750
    if (! (scp->sc_type & (1UL << 2))) {
      {
#line 752
      tmp___3 = getrpcbyname((char const   *)scp->sc_name);
#line 752
      rep = tmp___3;
      }
#line 754
      if ((unsigned long )rep == (unsigned long )((void *)0)) {
        {
#line 756
        msg(3, func, "unknown RPC service: %s", scp->sc_name);
        }
#line 757
        return ((status_e )0);
      }
#line 759
      scp->sc_rd.rd_program_number = (unsigned long )rep->r_number;
    } else {
#line 750
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 764
  if (! (scp->sc_type & (1UL << 2))) {
#line 777
    if (scp->sc_specified_attributes & (1UL << 2)) {
      {
#line 779
      sep = getservbyname((char const   *)scp->sc_name, (char const   *)scp->sc_protocol.name);
      }
#line 780
      if ((unsigned long )sep == (unsigned long )((void *)0)) {
        {
#line 782
        msg(3, func, "service/protocol combination not in /etc/services: %s/%s", scp->sc_name,
            scp->sc_protocol.name);
        }
#line 785
        return ((status_e )0);
      }
    } else {
      {
#line 790
      msg(3, func, "A protocol or a socket_type must be specified for service: %s.",
          scp->sc_name);
      }
#line 793
      return ((status_e )0);
    }
    {
#line 797
    service_port = ntohs((uint16_t )sep->s_port);
    }
#line 802
    if (scp->sc_specified_attributes & (1UL << 18)) {
#line 802
      if ((int )scp->sc_port != (int )service_port) {
        {
#line 805
        msg(3, func, "Service %s expects port %d, not %d", scp->sc_name, (int )service_port,
            (int )scp->sc_port);
        }
#line 807
        return ((status_e )0);
      }
    }
  }
#line 811
  if (scp->sc_specified_attributes & (1UL << 23)) {
#line 813
    if (scp->sc_socket_type != 1) {
      {
#line 815
      msg(3, func, "Only tcp sockets are supported for redirected service %s", scp->sc_name);
      }
#line 818
      return ((status_e )0);
    }
#line 820
    if ((unsigned int )scp->sc_wait == 1U) {
      {
#line 822
      msg(3, func, "Redirected service %s must not wait", scp->sc_name);
      }
#line 824
      return ((status_e )0);
    }
#line 826
    if (scp->sc_xflags & (1UL << 4)) {
      {
#line 828
      msg(3, func, "Redirected service %s should not have NAMEINARGS flag set", scp->sc_name);
      }
#line 831
      return ((status_e )0);
    }
  } else
#line 836
  if (scp->sc_log_on_success & (1UL << 7)) {
    {
#line 838
    msg(3, func, "Service %s should not have TRAFFIC flag set since its not redirected",
        scp->sc_name);
    }
#line 841
    return ((status_e )0);
  }
#line 845
  if (scp->sc_xflags & (1UL << 4)) {
#line 847
    if (scp->sc_type & (1UL << 1)) {
      {
#line 849
      msg(3, func, "Service %s is INTERNAL and has NAMEINARGS flag set", scp->sc_name);
      }
#line 852
      return ((status_e )0);
    } else
#line 854
    if (! (scp->sc_specified_attributes & (1UL << 6))) {
      {
#line 856
      msg(3, func, "Service %s has NAMEINARGS flag set and no server_args", scp->sc_name);
      }
#line 859
      return ((status_e )0);
    }
  }
  {
#line 863
  tmp___4 = service_attr_check(scp);
  }
#line 863
  if ((unsigned int )tmp___4 == 0U) {
#line 864
    return ((status_e )0);
  }
#line 866
  return ((status_e )1);
}
}
#line 872 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
static status_e get_conf(int fd , struct configuration *confp ) 
{ 


  {
  {
#line 874
  parse_conf_file(fd, confp, ps.ros.config_file);
#line 875
  parse_end();
  }
#line 876
  return ((status_e )1);
}
}
#line 891 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/confparse.c"
status_e cnf_get(struct configuration *confp ) 
{ 
  int config_fd ;
  struct service_config *scp ;
  char const   *func ;
  status_e tmp ;
  status_e tmp___0 ;
  __pset_pointer tmp___1 ;
  __pset_pointer tmp___2 ;
  status_e tmp___3 ;
  status_e tmp___4 ;
  builtin_s const   *bp ;

  {
  {
#line 895
  func = "get_configuration";
#line 897
  tmp___0 = cnf_init(confp, & config_fd, & iter);
  }
#line 897
  if ((unsigned int )tmp___0 == 0U) {
#line 898
    return ((status_e )0);
  } else {
    {
#line 900
    tmp = get_conf(config_fd, confp);
    }
#line 900
    if ((unsigned int )tmp == 0U) {
      {
#line 902
      Sclose(config_fd);
#line 903
      cnf_free(confp);
#line 904
      free((void *)((char *)iter));
      }
#line 905
      return ((status_e )0);
    }
  }
  {
#line 909
  Sclose(config_fd);
  }
#line 910
  if (inetd_compat) {
    {
#line 911
    current_file = "/etc/inetd.conf";
#line 912
    config_fd = open(current_file, 0);
    }
#line 913
    if (config_fd >= 0) {
      {
#line 914
      parse_inet_conf_file(config_fd, confp);
#line 915
      parse_end();
#line 920
      Sclose(config_fd);
      }
    }
  }
  {
#line 924
  remove_disabled_services(confp);
#line 926
  iter->current = 0U;
#line 926
  iter->step = 1;
  }
#line 926
  if (iter->current < (iter->pset)->count) {
#line 926
    tmp___1 = *((iter->pset)->ptrs + iter->current);
  } else {
#line 926
    tmp___1 = (void *)0;
  }
#line 926
  scp = (struct service_config *)tmp___1;
  {
#line 926
  while (1) {
    while_continue: /* CIL Label */ ;
#line 926
    if (! scp) {
#line 926
      goto while_break;
    }
    {
#line 932
    tmp___3 = service_fill(scp, confp->cnf_defaults);
    }
#line 932
    if ((unsigned int )tmp___3 == 0U) {
      {
#line 934
      sc_free(scp);
#line 935
      psi_remove(iter);
      }
#line 936
      goto __Cont;
    }
    {
#line 939
    tmp___4 = check_entry(scp, (struct configuration  const  *)confp);
    }
#line 939
    if ((unsigned int )tmp___4 == 0U) {
      {
#line 941
      sc_free(scp);
#line 942
      psi_remove(iter);
      }
#line 943
      goto __Cont;
    }
#line 950
    if (scp->sc_xflags & 1UL) {
      {
#line 954
      bp = spec_find("intercept", scp->sc_socket_type);
      }
#line 955
      if ((unsigned long )bp == (unsigned long )((void *)0)) {
        {
#line 957
        msg(3, func, "removing service %s", scp->sc_id);
#line 958
        sc_free(scp);
#line 959
        psi_remove(iter);
        }
#line 960
        goto __Cont;
      }
#line 963
      scp->sc_builtin = bp;
#line 964
      scp->sc_type |= 1UL << 1;
    }
#line 973
    if ((int )scp->sc_port == 113) {
#line 973
      if (scp->sc_protocol.value == 6) {
#line 976
        if (scp->sc_log_on_success & (1UL << 6)) {
          {
#line 976
          msg(4, func, "%s service: clearing USERID option from %s", scp->sc_id, "log_on_success");
#line 976
          scp->sc_log_on_success &= ~ (1UL << 6);
          }
        }
#line 977
        if (scp->sc_log_on_failure & (1UL << 6)) {
          {
#line 977
          msg(4, func, "%s service: clearing USERID option from %s", scp->sc_id, "log_on_failure");
#line 977
          scp->sc_log_on_failure &= ~ (1UL << 6);
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 926
    iter->current += (unsigned int )iter->step;
#line 926
    iter->step = 1;
#line 926
    if (iter->current < (iter->pset)->count) {
#line 926
      tmp___2 = *((iter->pset)->ptrs + iter->current);
    } else {
#line 926
      tmp___2 = (void *)0;
    }
#line 926
    scp = (struct service_config *)tmp___2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 981
  free((void *)((char *)iter));
  }
#line 983
  if (debug.on) {
#line 983
    if (debug.fd != -1) {
      {
#line 984
      cnf_dump(confp, debug.fd);
      }
    }
  }
  {
#line 986
  endservent();
#line 987
  endprotoent();
#line 989
  endrpcent();
  }
#line 991
  return ((status_e )1);
}
}
#line 195 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) difftime)(time_t __time1 ,
                                                                                  time_t __time0 )  __attribute__((__const__)) ;
#line 150 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) atol)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 33 "../libs/include/pset.h"
extern pset_h pset_create(unsigned int alloc_start , unsigned int alloc_step ) ;
#line 34
extern void pset_destroy(pset_h pset ) ;
#line 40
extern void pset_compact(pset_h pset ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 22 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.h"
int addrlist_match(pset_h const   addr_list , struct sockaddr  const  *addr ) ;
#line 25
status_e addrlist_add(pset_h addr_list , char const   *str_addr ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.h"
void process_sensor(struct service  const  *sp , union xsockaddr  const  *addr ) ;
#line 15
status_e check_sensor(union xsockaddr  const  *addr ) ;
#line 16
void destroy_global_access_list(void) ;
#line 20 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.h"
int xtimer_add(void (*func)(void) , time_t secs ) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.c"
static pset_h global_no_access  =    (pset_h )((void *)0);
#line 27 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.c"
static pset_h global_no_access_time  =    (pset_h )((void *)0);
#line 28 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.c"
static int timer_id  =    0;
#line 31
static void scrub_global_access_list(void) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.c"
void init_sensor(void) 
{ 


  {
#line 36
  if ((unsigned long )global_no_access == (unsigned long )((void *)0)) {
    {
#line 37
    global_no_access = pset_create(10U, 10U);
    }
  }
#line 38
  if ((unsigned long )global_no_access_time == (unsigned long )((void *)0)) {
    {
#line 39
    global_no_access_time = pset_create(10U, 10U);
    }
  }
#line 40
  return;
}
}
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.c"
void process_sensor(struct service  const  *sp , union xsockaddr  const  *addr ) 
{ 
  char const   *func ;
  int item_matched ;
  int tmp ;
  char *dup_addr ;
  char const   *tmp___0 ;
  char *tmp___1 ;
  time_t nowtime ;
  char time_buf[40] ;
  char *tmp___2 ;
  __pset_pointer tmp___3 ;
  status_e tmp___4 ;
  char *exp_time ;
  time_t stored_time ;
  time_t nowtime___0 ;
  time_t new_time ;
  char time_buf___0[40] ;
  char *new_exp_time ;
  double tmp___5 ;
  int tmp___6 ;

  {
#line 48
  func = "process_sensor";
#line 50
  if ((sp->svc_conf)->sc_deny_time != 0) {
#line 52
    if (global_no_access->count < 10240U) {
      {
#line 54
      tmp = addrlist_match((pset_h const   )global_no_access, (struct sockaddr  const  *)addr);
#line 54
      item_matched = tmp;
      }
#line 56
      if (item_matched == 0) {
        {
#line 58
        tmp___0 = xaddrname(addr);
#line 58
        tmp___1 = new_string(tmp___0);
#line 58
        dup_addr = tmp___1;
        }
#line 60
        if ((unsigned long )dup_addr == (unsigned long )((void *)0)) {
#line 61
          return;
        }
        {
#line 63
        tmp___4 = addrlist_add(global_no_access, (char const   *)dup_addr);
        }
#line 63
        if ((unsigned int )tmp___4 == 0U) {
          {
#line 64
          msg(3, func, "Failed adding %s to the global_no_access list", dup_addr);
          }
        } else {
          {
#line 71
          nowtime = time((time_t *)((void *)0));
#line 72
          msg(2, func, "Adding %s to the global_no_access list for %d minutes", dup_addr,
              (sp->svc_conf)->sc_deny_time);
          }
#line 76
          if ((sp->svc_conf)->sc_deny_time == -1) {
            {
#line 77
            strcpy((char */* __restrict  */)(time_buf), (char const   */* __restrict  */)"-1");
            }
          } else {
            {
#line 79
            strx_nprint(time_buf, 38, "%ld", nowtime + (time_t )(60 * (sp->svc_conf)->sc_deny_time));
            }
          }
          {
#line 82
          tmp___2 = new_string((char const   *)(time_buf));
          }
#line 83
          if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
            {
#line 85
            tmp___3 = pset_add(global_no_access_time, (__pset_pointer const   )tmp___2);
            }
#line 85
            if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
              {
#line 87
              msg(3, func, "Failed adding %s to the global_no_access_time list. global_no_access list is broken, xinetd needs restarting.",
                  dup_addr);
              }
            }
          }
#line 94
          if (global_no_access->count) {
#line 94
            if (timer_id == 0) {
              {
#line 95
              timer_id = xtimer_add(& scrub_global_access_list, (time_t )60);
              }
            }
          }
        }
        {
#line 97
        free((void *)dup_addr);
        }
      } else {
#line 105
        item_matched --;
#line 106
        exp_time = (char *)*(global_no_access_time->ptrs + (unsigned int )item_matched);
#line 107
        if ((unsigned long )exp_time == (unsigned long )((void *)0)) {
#line 108
          return;
        }
        {
#line 110
        tmp___6 = parse_base10((char const   *)exp_time, (int *)(& stored_time));
        }
#line 110
        if (tmp___6) {
#line 112
          if (stored_time != -1L) {
            {
#line 116
            nowtime___0 = time((time_t *)((void *)0));
#line 117
            new_time = nowtime___0 + (time_t )(60 * (sp->svc_conf)->sc_deny_time);
#line 117
            tmp___5 = difftime(new_time, stored_time);
            }
#line 117
            if (tmp___5 > 0.0) {
              {
#line 121
              strx_nprint(time_buf___0, 38, "%ld", new_time);
#line 122
              new_exp_time = new_string((char const   *)(time_buf___0));
              }
#line 123
              if (new_exp_time) {
                {
#line 125
                free((void *)exp_time);
#line 126
                *(global_no_access_time->ptrs + (unsigned int )item_matched) = (__pset_pointer )new_exp_time;
                }
              }
            }
          }
        }
      }
    } else {
      {
#line 135
      msg(3, func, "Maximum global_no_access count reached.");
      }
    }
  }
#line 137
  return;
}
}
#line 140 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.c"
status_e check_sensor(union xsockaddr  const  *addr ) 
{ 
  int tmp ;

  {
#line 143
  if (global_no_access) {
#line 143
    if (global_no_access->count) {
      {
#line 145
      tmp = addrlist_match((pset_h const   )global_no_access, (struct sockaddr  const  *)addr);
      }
#line 145
      if (tmp) {
#line 146
        return ((status_e )0);
      }
    }
  }
#line 148
  return ((status_e )1);
}
}
#line 152 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.c"
static void scrub_global_access_list(void) 
{ 
  unsigned int count ;
  char const   *func ;
  int found_one ;
  unsigned int u ;
  time_t nowtime ;
  time_t tmp ;
  char *exp_time ;
  time_t stored_time ;
  __pset_pointer ptr ;
  double tmp___0 ;

  {
#line 155
  func = "scrub_global_no_access_list";
#line 157
  if ((unsigned long )global_no_access == (unsigned long )((void *)0)) {
#line 158
    count = 0U;
  } else {
#line 160
    count = global_no_access->count;
  }
#line 162
  if (count) {
    {
#line 164
    found_one = 0;
#line 166
    tmp = time((time_t *)((void *)0));
#line 166
    nowtime = tmp;
#line 168
    u = 0U;
    }
    {
#line 168
    while (1) {
      while_continue: /* CIL Label */ ;
#line 168
      if (! (u < count)) {
#line 168
        goto while_break;
      }
      {
#line 173
      exp_time = (char *)*(global_no_access_time->ptrs + u);
#line 174
      stored_time = atol((char const   *)exp_time);
      }
#line 176
      if (stored_time == -1L) {
#line 177
        goto __Cont;
      }
      {
#line 179
      tmp___0 = difftime(nowtime, stored_time);
      }
#line 179
      if (tmp___0 >= 0.0) {
        {
#line 183
        *(global_no_access->ptrs + u) = (void *)0;
#line 184
        ptr = *(global_no_access_time->ptrs + u);
#line 185
        free(ptr);
#line 186
        *(global_no_access_time->ptrs + u) = (void *)0;
#line 187
        found_one = 1;
        }
      }
      __Cont: /* CIL Label */ 
#line 168
      u ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 190
    if (found_one) {
      {
#line 192
      pset_compact(global_no_access);
#line 193
      pset_compact(global_no_access_time);
#line 194
      msg(6, func, "At least 1 DENY_TIME has expired, global_no_access list updated");
      }
    }
#line 199
    count = global_no_access->count;
#line 200
    if (count) {
      {
#line 201
      timer_id = xtimer_add(& scrub_global_access_list, (time_t )60);
      }
    } else {
      {
#line 204
      timer_id = 0;
#line 205
      msg(6, func, "global_no_access list is empty.");
      }
    }
  }
#line 209
  return;
}
}
#line 211 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sensor.c"
void destroy_global_access_list(void) 
{ 


  {
#line 213
  if (global_no_access) {
    {
#line 214
    pset_apply(global_no_access, (void (*)())(& free), (void *)0);
#line 215
    pset_destroy(global_no_access);
    }
  }
#line 218
  if (global_no_access_time) {
    {
#line 219
    pset_apply(global_no_access_time, (void (*)())(& free), (void *)0);
#line 220
    pset_destroy(global_no_access_time);
    }
  }
#line 222
  return;
}
}
#line 226 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 377 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 69 "/usr/include/rpc/pmap_clnt.h"
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) pmap_set)(u_long const   __program ,
                                                                                  u_long const   __vers ,
                                                                                  int __protocol ,
                                                                                  u_short __port ) ;
#line 71
extern  __attribute__((__nothrow__)) bool_t ( __attribute__((__leaf__)) pmap_unset)(u_long const   __program ,
                                                                                    u_long const   __vers ) ;
#line 168 "../libs/include/sio.h"
extern ssize_t Swrite(int fd , char const   *buf , size_t  ) ;
#line 175
extern int Sputchar(int fd , char c ) ;
#line 187
extern int Sflush(int fd ) ;
#line 61 "../libs/include/xlog.h"
extern int xlog_control(xlog_h  , xlog_cmd_e   , ...) ;
#line 84 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.h"
status_e server_run(struct service *sp , connection_s *cp ) ;
#line 142 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.h"
struct service *svc_new(struct service_config *scp ) ;
#line 143
struct service *svc_make_special(struct service_config *scp ) ;
#line 144
void svc_free(struct service *sp ) ;
#line 145
status_e svc_activate(struct service *sp ) ;
#line 146
void svc_deactivate(struct service *sp ) ;
#line 147
void svc_suspend(struct service *sp ) ;
#line 148
void svc_resume(struct service *sp ) ;
#line 149
int svc_release(struct service *sp ) ;
#line 150
void svc_dump(struct service  const  *sp , int fd ) ;
#line 151
void svc_request(struct service *sp ) ;
#line 152
status_e svc_generic_handler(struct service *sp , connection_s *cp ) ;
#line 153
status_e svc_parent_access_control(struct service *sp , connection_s *cp ) ;
#line 154
status_e svc_child_access_control(struct service *sp , connection_s *cp ) ;
#line 155
void svc_postmortem(struct service *sp , struct server *serp ) ;
#line 156
void close_all_svc_descriptors(void) ;
#line 10 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
char const   *nv_get_name(struct name_value  const  *nv_array , int value ) ;
#line 15
void ( /* format attribute */  tabprint)(int fd , int tab_level , char const   *fmt 
                                         , ...) ;
#line 21
void drain(int sd ) ;
#line 86 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.h"
connection_s *conn_new(struct service *sp ) ;
#line 87
void conn_free(connection_s *cp , int release_mem ) ;
#line 53 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.h"
access_e parent_access_control(struct service *sp , connection_s const   *cp ) ;
#line 63 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.h"
void svc_log_exit(struct service *sp , struct server  const  *serp ) ;
#line 303 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.h"
void sc_dump(struct service_config *scp , int fd , int tab_level , bool_int is_defaults ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/logctl.h"
status_e log_start(struct service *sp , xlog_h *xhp ) ;
#line 9
void log_end(struct log *lp , xlog_h xh ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.h"
status_e spec_service_handler(struct service *sp , connection_s *cp ) ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static void deactivate(struct service  const  *sp ) ;
#line 62
static int banner_always(struct service  const  *sp , connection_s const   *cp ) ;
#line 64 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static struct name_value  const  service_states[6]  = {      {"Not started", 0}, 
        {"Active", 1}, 
        {"Disabled", 3}, 
        {"Suspended", 2}, 
        {(char const   *)((void *)0), 1}, 
        {"BAD STATE", 0}};
#line 79 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
struct service *svc_new(struct service_config *scp ) 
{ 
  struct service *sp ;
  char const   *func ;
  void *tmp ;

  {
  {
#line 82
  func = "svc_new";
#line 84
  tmp = malloc(sizeof(struct service ));
#line 84
  sp = (struct service *)tmp;
  }
#line 85
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
    {
#line 87
    out_of_memory(func);
    }
#line 88
    return ((struct service *)((void *)0));
  }
  {
#line 90
  memset((void *)((char *)sp), 0, sizeof(*sp));
#line 92
  sp->svc_conf = scp;
  }
#line 93
  return (sp);
}
}
#line 97 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
struct service *svc_make_special(struct service_config *scp ) 
{ 
  struct service *sp ;
  char const   *func ;

  {
  {
#line 100
  func = "svc_make_special";
#line 102
  sp = svc_new(scp);
  }
#line 102
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
    {
#line 104
    out_of_memory(func);
    }
#line 105
    return ((struct service *)((void *)0));
  }
#line 108
  sp->svc_not_generic = 1;
#line 109
  sp->svc_log = ps.rws.program_log;
#line 110
  sp->svc_ref_count = 1;
#line 111
  sp->svc_state = (state_e )1;
#line 112
  return (sp);
}
}
#line 116 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
void svc_free(struct service *sp ) 
{ 


  {
  {
#line 118
  sc_free(sp->svc_conf);
#line 119
  memset((void *)((char *)sp), 0, sizeof(*sp));
#line 120
  free((void *)((char *)sp));
  }
#line 121
  return;
}
}
#line 124 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static status_e set_fd_modes(struct service *sp ) 
{ 
  int sd ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
#line 126
  sd = sp->svc_fd;
#line 127
  func = "set_fd_modes";
#line 139
  if (! (! ((sp->svc_conf)->sc_type & (1UL << 1)))) {
#line 139
    if (! ((unsigned int const   )((sp->svc_conf)->sc_builtin)->b_fork_server == 1U)) {
#line 139
      if ((unsigned int )(sp->svc_conf)->sc_wait == 0U) {
#line 139
        if (! ((sp->svc_conf)->sc_socket_type == 1)) {
#line 139
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 139
        tmp = fcntl(sd, 4, 2048);
        }
#line 139
        if (tmp == -1) {
          {
#line 142
          msg(3, func, "fcntl failed (%m) for FNDELAY. service = %s", (sp->svc_conf)->sc_id);
          }
#line 144
          return ((status_e )0);
        }
      }
    }
  }
  {
#line 150
  tmp___0 = fcntl(sd, 2, 1);
  }
#line 150
  if (tmp___0 == -1) {
    {
#line 152
    msg(3, func, "fcntl failed (%m) for close-on-exec. service = %s", (sp->svc_conf)->sc_id);
    }
#line 154
    return ((status_e )0);
  }
#line 156
  return ((status_e )1);
}
}
#line 162 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static status_e activate_rpc(struct service *sp ) 
{ 
  union xsockaddr tsin ;
  socklen_t sin_len ;
  unsigned long vers ;
  struct service_config *scp ;
  struct rpc_data *rdp ;
  char *sid ;
  unsigned int registered_versions ;
  int sd ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;
  bool_t tmp___1 ;
  int tmp___2 ;

  {
#line 165
  sin_len = (socklen_t )sizeof(tsin);
#line 167
  scp = sp->svc_conf;
#line 168
  rdp = & scp->sc_rd;
#line 169
  sid = scp->sc_id;
#line 170
  registered_versions = 0U;
#line 171
  sd = sp->svc_fd;
#line 172
  func = "activate_rpc";
#line 174
  if ((unsigned long )scp->sc_bind_addr != (unsigned long )((union xsockaddr *)0)) {
    {
#line 175
    memcpy((void */* __restrict  */)(& tsin), (void const   */* __restrict  */)scp->sc_bind_addr,
           sizeof(tsin));
    }
  } else {
    {
#line 177
    memset((void *)(& tsin), 0, sizeof(tsin));
    }
  }
#line 179
  if (scp->sc_protocol.value == 6) {
#line 180
    scp->sc_xflags |= 1UL << 7;
  }
#line 182
  if (scp->sc_xflags & (1UL << 9)) {
#line 183
    tsin.sa_in.sin_family = (sa_family_t )2;
#line 184
    sin_len = (socklen_t )sizeof(struct sockaddr_in );
  } else
#line 185
  if (scp->sc_xflags & (1UL << 10)) {
#line 186
    tsin.sa_in6.sin6_family = (sa_family_t )10;
#line 187
    sin_len = (socklen_t )sizeof(struct sockaddr_in6 );
  }
  {
#line 190
  tmp = bind(sd, (struct sockaddr  const  *)(& tsin.sa), sin_len);
  }
#line 190
  if (tmp == -1) {
    {
#line 192
    msg(3, func, "bind failed (%m). service = %s", sid);
    }
#line 193
    return ((status_e )0);
  }
  {
#line 199
  tmp___0 = getsockname(sd, (struct sockaddr */* __restrict  */)(& tsin.sa), (socklen_t */* __restrict  */)(& sin_len));
  }
#line 199
  if (tmp___0 == -1) {
    {
#line 201
    msg(3, func, "getsockname failed (%m). service = %s", sid);
    }
#line 203
    return ((status_e )0);
  }
#line 206
  if ((int )tsin.sa.sa_family == 2) {
    {
#line 207
    scp->sc_port = ntohs(tsin.sa_in.sin_port);
    }
  } else
#line 208
  if ((int )tsin.sa.sa_family == 10) {
    {
#line 209
    scp->sc_port = ntohs(tsin.sa_in6.sin6_port);
    }
  }
#line 214
  vers = rdp->rd_min_version;
  {
#line 214
  while (1) {
    while_continue: /* CIL Label */ ;
#line 214
    if (! (vers <= rdp->rd_max_version)) {
#line 214
      goto while_break;
    }
    {
#line 219
    tmp___1 = pmap_set((u_long const   )rdp->rd_program_number, (u_long const   )vers,
                       scp->sc_protocol.value, scp->sc_port);
    }
#line 219
    if (tmp___1) {
#line 221
      registered_versions ++;
    } else {
      {
#line 223
      msg(3, func, "pmap_set failed. service=%s program=%ld version=%ld", sid, rdp->rd_program_number,
          vers);
      }
    }
    {
#line 226
    sleep(1U);
#line 214
    vers ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 229
  if (debug.on) {
    {
#line 230
    msg(7, func, "Registered %d versions of %s", registered_versions, sid);
    }
  }
#line 233
  if (registered_versions == 0U) {
#line 233
    tmp___2 = 0;
  } else {
#line 233
    tmp___2 = 1;
  }
#line 233
  return ((status_e )tmp___2);
}
}
#line 238 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static status_e activate_normal(struct service *sp ) 
{ 
  union xsockaddr tsin ;
  int sd ;
  struct service_config *scp ;
  uint16_t service_port ;
  char *sid ;
  char const   *func ;
  unsigned int sin_len ;
  int on ;
  int v6on ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  struct ip_mreq mreq ;

  {
#line 241
  sd = sp->svc_fd;
#line 242
  scp = sp->svc_conf;
#line 243
  service_port = scp->sc_port;
#line 244
  sid = scp->sc_id;
#line 245
  func = "activate_normal";
#line 246
  sin_len = (unsigned int )sizeof(tsin);
#line 247
  on = 1;
#line 249
  v6on = 0;
#line 252
  if ((unsigned long )scp->sc_bind_addr != (unsigned long )((void *)0)) {
    {
#line 253
    memcpy((void */* __restrict  */)(& tsin), (void const   */* __restrict  */)scp->sc_bind_addr,
           (size_t )sin_len);
    }
  } else {
    {
#line 255
    memset((void *)(& tsin), 0, (size_t )sin_len);
    }
  }
#line 257
  if (scp->sc_xflags & (1UL << 9)) {
    {
#line 258
    tsin.sa_in.sin_family = (sa_family_t )2;
#line 259
    tsin.sa_in.sin_port = htons(service_port);
#line 260
    sin_len = (unsigned int )sizeof(struct sockaddr_in );
    }
  } else
#line 261
  if (scp->sc_xflags & (1UL << 10)) {
    {
#line 262
    tsin.sa_in6.sin6_family = (sa_family_t )10;
#line 263
    tsin.sa_in6.sin6_port = htons(service_port);
#line 264
    sin_len = (unsigned int )sizeof(struct sockaddr_in6 );
    }
  }
#line 268
  if (scp->sc_xflags & (1UL << 10)) {
#line 269
    if (scp->sc_specified_attributes & (1UL << 38)) {
#line 270
      v6on = 1;
    } else {
#line 272
      v6on = 0;
    }
    {
#line 274
    tmp = setsockopt(sd, 41, 26, (void const   *)((char *)(& v6on)), (socklen_t )sizeof(v6on));
    }
#line 274
    if (tmp < 0) {
      {
#line 275
      msg(3, func, "Setting IPV6_V6ONLY option failed (%m)");
      }
    }
  }
  {
#line 280
  tmp___0 = setsockopt(sd, 1, 2, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
  }
#line 280
  if (tmp___0 == -1) {
    {
#line 282
    msg(4, func, "setsockopt SO_REUSEADDR failed (%m). service = %s", sid);
    }
  }
#line 285
  if (scp->sc_xflags & (1UL << 5)) {
#line 285
    if (scp->sc_protocol.value == 6) {
      {
#line 287
      tmp___1 = setsockopt(sd, 6, 1, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
      }
#line 287
      if (tmp___1 == -1) {
        {
#line 289
        msg(4, func, "setsockopt TCP_NODELAY failed (%m). service = %s", sid);
        }
      }
    }
  }
#line 293
  if (scp->sc_xflags & (1UL << 6)) {
#line 293
    if (scp->sc_protocol.value == 6) {
      {
#line 295
      tmp___2 = setsockopt(sd, 1, 9, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
      }
#line 295
      if (tmp___2 < 0) {
        {
#line 297
        msg(4, func, "setsockopt SO_KEEPALIVE failed (%m). service = %s", sid);
        }
      }
    }
  }
  {
#line 301
  tmp___3 = bind(sd, (struct sockaddr  const  *)(& tsin.sa), sin_len);
  }
#line 301
  if (tmp___3 == -1) {
    {
#line 303
    msg(3, func, "bind failed (%m). service = %s", sid);
    }
#line 304
    return ((status_e )0);
  }
#line 308
  if (scp->sc_xflags & (1UL << 9)) {
#line 308
    if ((tsin.sa_in.sin_addr.s_addr & 4026531840U) == 3758096384U) {
      {
#line 310
      mreq.imr_multiaddr.s_addr = tsin.sa_in.sin_addr.s_addr;
#line 311
      mreq.imr_interface.s_addr = htonl((in_addr_t )0);
#line 312
      setsockopt(sd, 0, 35, (void const   *)(& mreq), (socklen_t )sizeof(mreq));
      }
#line 313
      if (debug.on) {
        {
#line 314
        msg(7, func, "Adding multicast membership.");
        }
      }
    }
  }
#line 318
  return ((status_e )1);
}
}
#line 325 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
status_e svc_activate(struct service *sp ) 
{ 
  struct service_config *scp ;
  status_e status ;
  char const   *func ;
  status_e tmp ;
  status_e tmp___0 ;
  unsigned int tmp___1 ;

  {
#line 327
  scp = sp->svc_conf;
#line 329
  func = "svc_activate";
#line 334
  if (scp->sc_type & (1UL << 5)) {
#line 336
    return ((status_e )1);
  } else
#line 334
  if (scp->sc_type & (1UL << 6)) {
#line 336
    return ((status_e )1);
  }
#line 339
  if (scp->sc_xflags & (1UL << 9)) {
    {
#line 340
    sp->svc_fd = socket(2, scp->sc_socket_type, scp->sc_protocol.value);
    }
  } else
#line 342
  if (scp->sc_xflags & (1UL << 10)) {
    {
#line 343
    sp->svc_fd = socket(10, scp->sc_socket_type, scp->sc_protocol.value);
    }
  }
#line 347
  if (sp->svc_fd == -1) {
    {
#line 349
    msg(3, func, "socket creation failed (%m). service = %s", scp->sc_id);
    }
#line 351
    return ((status_e )0);
  }
  {
#line 354
  tmp = set_fd_modes(sp);
  }
#line 354
  if ((unsigned int )tmp == 0U) {
    {
#line 356
    Sclose(sp->svc_fd);
    }
#line 357
    return ((status_e )0);
  }
#line 361
  if (scp->sc_type & 1UL) {
    {
#line 362
    status = activate_rpc(sp);
    }
  } else {
    {
#line 365
    status = activate_normal(sp);
    }
  }
#line 367
  if ((unsigned int )status == 0U) {
    {
#line 369
    Sclose(sp->svc_fd);
    }
#line 370
    return ((status_e )0);
  }
  {
#line 377
  tmp___0 = log_start(sp, & sp->svc_log);
  }
#line 377
  if ((unsigned int )tmp___0 == 0U) {
    {
#line 379
    deactivate((struct service  const  *)sp);
    }
#line 380
    return ((status_e )0);
  }
#line 386
  tmp___1 = 0U;
#line 386
  sp->svc_retry_servers = tmp___1;
#line 386
  sp->svc_running_servers = tmp___1;
#line 388
  if (scp->sc_socket_type == 1) {
    {
#line 389
    listen(sp->svc_fd, 64);
    }
  }
#line 391
  (ps.rws.descriptors_free) --;
#line 393
  sp->svc_state = (state_e )1;
#line 395
  ps.rws.socket_mask.__fds_bits[sp->svc_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sp->svc_fd % (8 * (int )sizeof(__fd_mask ));
#line 396
  if (sp->svc_fd > ps.rws.mask_max) {
#line 397
    ps.rws.mask_max = sp->svc_fd;
  }
#line 399
  (ps.rws.active_services) ++;
#line 400
  (ps.rws.available_services) ++;
#line 402
  return ((status_e )1);
}
}
#line 406 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static void deactivate(struct service  const  *sp ) 
{ 
  __pid_t tmp ;
  unsigned long vers ;
  struct rpc_data  const  *rdp ;

  {
  {
#line 408
  Sclose((int )sp->svc_fd);
  }
#line 414
  if (debug.on) {
    {
#line 415
    tmp = getpid();
#line 415
    msg(7, "deactivate", "%d Service %s deactivated", tmp, (sp->svc_conf)->sc_name);
    }
  }
#line 419
  if ((sp->svc_conf)->sc_type & 1UL) {
#line 422
    rdp = (struct rpc_data  const  *)(& (sp->svc_conf)->sc_rd);
#line 424
    vers = (unsigned long )rdp->rd_min_version;
    {
#line 424
    while (1) {
      while_continue: /* CIL Label */ ;
#line 424
      if (! (vers <= (unsigned long )rdp->rd_max_version)) {
#line 424
        goto while_break;
      }
      {
#line 425
      pmap_unset(rdp->rd_program_number, (u_long const   )vers);
#line 424
      vers ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 429
  return;
}
}
#line 437 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
void svc_deactivate(struct service *sp ) 
{ 


  {
#line 439
  if (! ((unsigned int )sp->svc_state == 1U)) {
#line 439
    if (! ((unsigned int )sp->svc_state == 2U)) {
#line 440
      return;
    }
  }
  {
#line 442
  deactivate((struct service  const  *)sp);
#line 443
  (ps.rws.descriptors_free) ++;
  }
#line 445
  if ((unsigned int )sp->svc_state == 1U) {
#line 447
    ps.rws.socket_mask.__fds_bits[sp->svc_fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << sp->svc_fd % (8 * (int )sizeof(__fd_mask )));
#line 448
    (ps.rws.active_services) --;
  }
#line 451
  (ps.rws.available_services) --;
#line 453
  sp->svc_state = (state_e )3;
#line 454
  return;
}
}
#line 460 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
void svc_suspend(struct service *sp ) 
{ 
  char const   *func ;

  {
#line 462
  func = "svc_suspend";
#line 464
  if (! ((unsigned int )sp->svc_state == 1U)) {
    {
#line 466
    msg(3, func, "service %s is not active", (sp->svc_conf)->sc_id);
    }
#line 467
    return;
  }
#line 470
  ps.rws.socket_mask.__fds_bits[sp->svc_fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << sp->svc_fd % (8 * (int )sizeof(__fd_mask )));
#line 471
  (ps.rws.active_services) --;
#line 472
  if (debug.on) {
    {
#line 473
    msg(7, func, "Suspended service %s", (sp->svc_conf)->sc_id);
    }
  }
#line 475
  sp->svc_state = (state_e )2;
#line 476
  return;
}
}
#line 482 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
void svc_resume(struct service *sp ) 
{ 
  char const   *func ;

  {
#line 484
  func = "svc_resume";
#line 486
  ps.rws.socket_mask.__fds_bits[sp->svc_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sp->svc_fd % (8 * (int )sizeof(__fd_mask ));
#line 487
  (ps.rws.active_services) ++;
#line 488
  if (debug.on) {
    {
#line 489
    msg(7, func, "Resumed service %s", (sp->svc_conf)->sc_id);
    }
  }
#line 490
  sp->svc_state = (state_e )1;
#line 491
  return;
}
}
#line 505 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
int svc_release(struct service *sp ) 
{ 
  char *sid ;
  char const   *func ;

  {
#line 507
  sid = (sp->svc_conf)->sc_id;
#line 508
  func = "svc_release";
#line 510
  if (sp->svc_ref_count == 0) {
    {
#line 512
    msg(3, func, "%s: svc_release with 0 count", sid);
    }
#line 513
    return (0);
  }
#line 516
  (sp->svc_ref_count) --;
#line 517
  if (sp->svc_ref_count == 0) {
#line 519
    if (debug.on) {
      {
#line 520
      msg(7, func, "ref count of service %s dropped to 0", sid);
      }
    }
#line 521
    if (! ((sp->svc_conf)->sc_type & (1UL << 3))) {
#line 523
      if (sp->svc_log) {
        {
#line 524
        log_end(& (sp->svc_conf)->sc_log, sp->svc_log);
        }
      }
      {
#line 525
      svc_deactivate(sp);
#line 526
      svc_free(sp);
#line 527
      sp = (struct service *)((void *)0);
      }
    } else {
      {
#line 530
      msg(4, func, "ref count of special service %s dropped to 0", sid);
      }
    }
#line 532
    return (0);
  } else {
#line 535
    return (sp->svc_ref_count);
  }
}
}
#line 539 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
void svc_dump(struct service  const  *sp , int fd ) 
{ 
  char const   *tmp ;

  {
  {
#line 541
  tabprint(fd, 0, "Service = %s\n", (sp->svc_conf)->sc_name);
#line 542
  tmp = nv_get_name(service_states, (int )sp->svc_state);
#line 542
  tabprint(fd, 1, "State = %s\n", tmp);
#line 545
  sc_dump((struct service_config *)sp->svc_conf, fd, 1, 0);
  }
#line 547
  if ((unsigned int const   )sp->svc_state == 1U) {
    {
#line 549
    tabprint(fd, 1, "running servers = %d\n", sp->svc_running_servers);
#line 550
    tabprint(fd, 1, "retry servers = %d\n", sp->svc_retry_servers);
#line 551
    tabprint(fd, 1, "attempts = %d\n", sp->svc_attempts);
#line 552
    tabprint(fd, 1, "service fd = %d\n", sp->svc_fd);
    }
  }
  {
#line 554
  Sputchar(fd, (char )'\n');
  }
#line 555
  return;
}
}
#line 558 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
void svc_request(struct service *sp ) 
{ 
  connection_s *cp ;
  status_e ret_code ;
  status_e tmp ;

  {
  {
#line 563
  cp = conn_new(sp);
  }
#line 564
  if ((unsigned long )cp == (unsigned long )((connection_s *)((void *)0))) {
#line 565
    return;
  }
  {
#line 571
  banner_always((struct service  const  *)sp, (connection_s const   *)cp);
  }
#line 573
  if (sp->svc_not_generic) {
    {
#line 574
    ret_code = spec_service_handler(sp, cp);
    }
  } else {
    {
#line 576
    ret_code = svc_generic_handler(sp, cp);
    }
  }
#line 578
  if ((sp->svc_conf)->sc_socket_type == 2) {
#line 578
    if ((unsigned int )sp->svc_state == 1U) {
      {
#line 579
      drain(cp->co_descriptor);
      }
    }
  }
#line 581
  if ((unsigned int )ret_code != 1U) {
#line 583
    if ((unsigned long )sp->svc_log != (unsigned long )((void *)0)) {
#line 583
      if ((sp->svc_conf)->sc_log_on_failure & (1UL << 6)) {
#line 583
        if ((unsigned int )(sp->svc_conf)->sc_wait == 0U) {
#line 583
          if ((sp->svc_conf)->sc_socket_type == 1) {
            {
#line 584
            tmp = spec_service_handler(ps.rws.logging, cp);
            }
#line 584
            if ((unsigned int )tmp == 0U) {
              {
#line 585
              conn_free(cp, 1);
              }
            } else
#line 586
            if (! ((unsigned int )(sp->svc_conf)->sc_wait == 1U)) {
              {
#line 588
              Sclose(cp->co_descriptor);
#line 588
              cp->co_descriptor = -1;
              }
            }
#line 590
            return;
          }
        }
      }
    }
#line 592
    if (! ((unsigned int )(sp->svc_conf)->sc_wait == 1U)) {
      {
#line 593
      conn_free(cp, 1);
      }
    } else {
#line 595
      if ((sp->svc_conf)->sc_socket_type == 2) {
#line 595
        if ((unsigned int )sp->svc_state == 1U) {
          {
#line 596
          drain(cp->co_descriptor);
          }
        }
      }
      {
#line 597
      free((void *)cp);
      }
    }
  } else
#line 600
  if (sp->svc_not_generic) {
    {
#line 601
    free((void *)cp);
    }
  } else
#line 600
  if (! (! ((sp->svc_conf)->sc_type & (1UL << 1)))) {
#line 600
    if (! ((unsigned int const   )((sp->svc_conf)->sc_builtin)->b_fork_server == 1U)) {
      {
#line 601
      free((void *)cp);
      }
    }
  }
#line 602
  return;
}
}
#line 605 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
status_e svc_generic_handler(struct service *sp , connection_s *cp ) 
{ 
  status_e tmp ;
  status_e tmp___0 ;

  {
  {
#line 607
  tmp___0 = svc_parent_access_control(sp, cp);
  }
#line 607
  if ((unsigned int )tmp___0 == 1U) {
    {
#line 608
    tmp = server_run(sp, cp);
    }
#line 608
    return (tmp);
  }
#line 611
  return ((status_e )0);
}
}
#line 616 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static int banner_always(struct service  const  *sp , connection_s const   *cp ) 
{ 
  char const   *func ;
  struct service_config  const  *scp ;
  char tmpbuf[1024] ;
  ssize_t retval ;
  int bannerfd ;
  int tmp ;
  int *tmp___0 ;

  {
#line 618
  func = "banner_always";
#line 619
  scp = (struct service_config  const  *)sp->svc_conf;
#line 622
  if ((unsigned long )scp->sc_banner != (unsigned long )((void *)0)) {
    {
#line 625
    tmp = open((char const   *)scp->sc_banner, 0);
#line 625
    bannerfd = tmp;
    }
#line 627
    if (bannerfd < 0) {
      {
#line 628
      msg(3, func, "service = %s, open of banner %s failed", (sp->svc_conf)->sc_id,
          scp->sc_banner);
      }
#line 630
      return (-1);
    }
    {
#line 633
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 633
      retval = read(bannerfd, (void *)(tmpbuf), sizeof(tmpbuf));
      }
#line 633
      if (! retval) {
#line 633
        goto while_break;
      }
#line 634
      if (retval == -1L) {
        {
#line 636
        tmp___0 = __errno_location();
        }
#line 636
        if (*tmp___0 == 4) {
#line 637
          goto while_continue;
        } else {
          {
#line 640
          msg(3, func, "service %s, Error %m reading banner %s", (sp->svc_conf)->sc_id,
              scp->sc_banner);
          }
#line 642
          goto while_break;
        }
      }
      {
#line 645
      Swrite((int )cp->co_descriptor, (char const   *)(tmpbuf), (size_t )retval);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 648
    Sclose(bannerfd);
#line 649
    Sflush((int )cp->co_descriptor);
    }
  }
#line 652
  return (0);
}
}
#line 655 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static int banner_fail(struct service  const  *sp , connection_s const   *cp ) 
{ 
  char const   *func ;
  struct service_config  const  *scp ;
  char tmpbuf[1024] ;
  int retval ;
  int bannerfd ;
  int tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 657
  func = "banner_fail";
#line 658
  scp = (struct service_config  const  *)sp->svc_conf;
#line 661
  if ((unsigned long )scp->sc_banner_fail != (unsigned long )((void *)0)) {
    {
#line 665
    tmp = open((char const   *)scp->sc_banner_fail, 0);
#line 665
    bannerfd = tmp;
    }
#line 667
    if (bannerfd < 0) {
      {
#line 669
      msg(3, func, "service = %s, open of banner %s failed", (sp->svc_conf)->sc_id,
          scp->sc_banner_fail);
      }
#line 671
      return (-1);
    }
    {
#line 674
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 674
      tmp___1 = read(bannerfd, (void *)(tmpbuf), sizeof(tmpbuf));
#line 674
      retval = (int )tmp___1;
      }
#line 674
      if (! retval) {
#line 674
        goto while_break;
      }
#line 675
      if (retval == -1) {
        {
#line 677
        tmp___0 = __errno_location();
        }
#line 677
        if (*tmp___0 == 4) {
#line 678
          goto while_continue;
        } else {
          {
#line 681
          msg(3, func, "service %s, Error %m reading banner %s", (sp->svc_conf)->sc_id,
              scp->sc_banner);
          }
#line 683
          goto while_break;
        }
      }
      {
#line 686
      Swrite((int )cp->co_descriptor, (char const   *)(tmpbuf), (size_t )retval);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 689
    Sclose(bannerfd);
#line 690
    Sflush((int )cp->co_descriptor);
    }
  }
#line 693
  return (0);
}
}
#line 696 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static int banner_success(struct service  const  *sp , connection_s const   *cp ) 
{ 
  char const   *func ;
  struct service_config  const  *scp ;
  char tmpbuf[1024] ;
  int retval ;
  int bannerfd ;
  int tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;

  {
#line 698
  func = "banner_success";
#line 699
  scp = (struct service_config  const  *)sp->svc_conf;
#line 702
  if ((unsigned long )scp->sc_banner_success != (unsigned long )((void *)0)) {
    {
#line 705
    tmp = open((char const   *)scp->sc_banner_success, 0);
#line 705
    bannerfd = tmp;
    }
#line 707
    if (bannerfd < 0) {
      {
#line 708
      msg(3, func, "service = %s, open of banner %s failed", (sp->svc_conf)->sc_id,
          scp->sc_banner_success);
      }
#line 710
      return (-1);
    }
    {
#line 713
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 713
      tmp___1 = read(bannerfd, (void *)(tmpbuf), sizeof(tmpbuf));
#line 713
      retval = (int )tmp___1;
      }
#line 713
      if (! retval) {
#line 713
        goto while_break;
      }
#line 714
      if (retval == -1) {
        {
#line 716
        tmp___0 = __errno_location();
        }
#line 716
        if (*tmp___0 == 4) {
#line 717
          goto while_continue;
        } else {
          {
#line 720
          msg(3, func, "service %s, Error %m reading banner %s", (sp->svc_conf)->sc_id,
              scp->sc_banner);
          }
#line 722
          goto while_break;
        }
      }
      {
#line 725
      Swrite((int )cp->co_descriptor, (char const   *)(tmpbuf), (size_t )retval);
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 728
    Sclose(bannerfd);
#line 729
    Sflush((int )cp->co_descriptor);
    }
  }
#line 731
  return (0);
}
}
#line 734 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
static status_e failed_service(struct service *sp , connection_s *cp , access_e result ) 
{ 
  struct service_config *scp ;
  bool_int report_failure ;
  struct sockaddr_in *sinp ;
  struct sockaddr *tmp ;
  struct sockaddr_in *last ;
  time_t current_time ;
  void *tmp___0 ;
  struct sockaddr_in6 *sinp___0 ;
  struct sockaddr *tmp___1 ;
  struct sockaddr_in6 *last___0 ;
  time_t current_time___0 ;
  void *tmp___2 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___3 ;

  {
#line 738
  scp = sp->svc_conf;
#line 740
  if ((unsigned int )result != 0U) {
#line 742
    report_failure = 1;
#line 751
    if ((unsigned int )result == 2U) {
#line 751
      if ((sp->svc_conf)->sc_socket_type == 2) {
#line 753
        if (scp->sc_xflags & (1UL << 9)) {
#line 754
          if (cp->co_flags & 1UL) {
#line 754
            tmp = & cp->co_remote_address.sa;
          } else {
#line 754
            tmp = (struct sockaddr *)((void *)0);
          }
#line 754
          sinp = (struct sockaddr_in *)tmp;
#line 755
          last = (struct sockaddr_in *)sp->svc_last_dgram_addr;
#line 758
          if ((unsigned long )sinp == (unsigned long )((void *)0)) {
#line 759
            return ((status_e )0);
          }
#line 761
          if ((unsigned long )last == (unsigned long )((void *)0)) {
            {
#line 762
            tmp___0 = calloc((size_t )1, sizeof(union xsockaddr ));
#line 762
            last = (struct sockaddr_in *)tmp___0;
#line 763
            sp->svc_last_dgram_addr = (union xsockaddr *)last;
            }
          }
          {
#line 766
          time(& current_time);
          }
#line 767
          if (sinp->sin_addr.s_addr == last->sin_addr.s_addr) {
#line 767
            if ((int )sinp->sin_port == (int )last->sin_port) {
#line 770
              if (current_time - sp->svc_last_dgram_time <= 60L) {
#line 771
                report_failure = 0;
              } else {
#line 773
                sp->svc_last_dgram_time = current_time;
              }
            } else {
              {
#line 777
              memcpy((void */* __restrict  */)sp->svc_last_dgram_addr, (void const   */* __restrict  */)sinp,
                     sizeof(struct sockaddr_in ));
#line 778
              sp->svc_last_dgram_time = current_time;
              }
            }
          } else {
            {
#line 777
            memcpy((void */* __restrict  */)sp->svc_last_dgram_addr, (void const   */* __restrict  */)sinp,
                   sizeof(struct sockaddr_in ));
#line 778
            sp->svc_last_dgram_time = current_time;
            }
          }
        } else
#line 780
        if (scp->sc_xflags & (1UL << 10)) {
#line 781
          if (cp->co_flags & 1UL) {
#line 781
            tmp___1 = & cp->co_remote_address.sa;
          } else {
#line 781
            tmp___1 = (struct sockaddr *)((void *)0);
          }
#line 781
          sinp___0 = (struct sockaddr_in6 *)tmp___1;
#line 782
          last___0 = (struct sockaddr_in6 *)sp->svc_last_dgram_addr;
#line 785
          if ((unsigned long )sinp___0 == (unsigned long )((void *)0)) {
#line 786
            return ((status_e )0);
          }
#line 788
          if ((unsigned long )last___0 == (unsigned long )((void *)0)) {
            {
#line 789
            tmp___2 = calloc((size_t )1, sizeof(union xsockaddr ));
#line 789
            last___0 = (struct sockaddr_in6 *)tmp___2;
#line 790
            sp->svc_last_dgram_addr = (union xsockaddr *)last___0;
            }
          }
          {
#line 793
          time(& current_time___0);
#line 794
          __a = (struct in6_addr  const  *)(& sinp___0->sin6_addr);
#line 794
          __b = (struct in6_addr  const  *)(& last___0->sin6_addr);
          }
#line 794
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 794
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 794
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 794
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 794
                  tmp___3 = 1;
                } else {
#line 794
                  tmp___3 = 0;
                }
              } else {
#line 794
                tmp___3 = 0;
              }
            } else {
#line 794
              tmp___3 = 0;
            }
          } else {
#line 794
            tmp___3 = 0;
          }
#line 794
          if (tmp___3) {
#line 794
            if ((int )sinp___0->sin6_port == (int )last___0->sin6_port) {
#line 797
              if (current_time___0 - sp->svc_last_dgram_time <= 60L) {
#line 798
                report_failure = 0;
              } else {
#line 800
                sp->svc_last_dgram_time = current_time___0;
              }
            } else {
              {
#line 804
              memcpy((void */* __restrict  */)sp->svc_last_dgram_addr, (void const   */* __restrict  */)sinp___0,
                     sizeof(struct sockaddr_in6 ));
#line 805
              sp->svc_last_dgram_time = current_time___0;
              }
            }
          } else {
            {
#line 804
            memcpy((void */* __restrict  */)sp->svc_last_dgram_addr, (void const   */* __restrict  */)sinp___0,
                   sizeof(struct sockaddr_in6 ));
#line 805
            sp->svc_last_dgram_time = current_time___0;
            }
          }
        }
      }
    }
#line 810
    if (report_failure) {
      {
#line 811
      svc_log_failure(sp, (connection_s const   *)cp, result);
      }
    }
    {
#line 813
    banner_fail((struct service  const  *)sp, (connection_s const   *)cp);
    }
#line 815
    return ((status_e )0);
  }
#line 818
  return ((status_e )1);
}
}
#line 822 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
status_e svc_parent_access_control(struct service *sp , connection_s *cp ) 
{ 
  access_e result ;
  status_e tmp ;

  {
  {
#line 826
  result = parent_access_control(sp, (connection_s const   *)cp);
#line 827
  tmp = failed_service(sp, cp, result);
  }
#line 827
  if ((unsigned int )tmp == 0U) {
#line 828
    return ((status_e )0);
  }
#line 830
  return ((status_e )1);
}
}
#line 833 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
status_e svc_child_access_control(struct service *sp , connection_s *cp ) 
{ 
  access_e result ;
  status_e tmp ;

  {
  {
#line 837
  result = access_control(sp, (connection_s const   *)cp, (mask_t const   *)((mask_t *)0));
#line 838
  tmp = failed_service(sp, cp, result);
  }
#line 838
  if ((unsigned int )tmp == 0U) {
#line 839
    return ((status_e )0);
  }
  {
#line 841
  banner_success((struct service  const  *)sp, (connection_s const   *)cp);
  }
#line 843
  return ((status_e )1);
}
}
#line 849 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
void svc_postmortem(struct service *sp , struct server *serp ) 
{ 
  struct service *co_sp ;
  connection_s *cp ;
  char const   *func ;

  {
#line 851
  co_sp = (serp->svr_conn)->co_sp;
#line 852
  cp = serp->svr_conn;
#line 853
  func = "svc_postmortem";
#line 855
  if (sp->svc_running_servers != 0U) {
#line 855
    (sp->svc_running_servers) --;
  } else {
    {
#line 855
    msg(3, func, "Service %s: server exit with 0 running servers", (sp->svc_conf)->sc_id);
    }
  }
#line 860
  if ((unsigned long )sp->svc_log != (unsigned long )((void *)0)) {
#line 862
    if (serp->svr_writes_to_log) {
#line 864
      if (debug.on) {
        {
#line 865
        msg(7, func, "Checking log size of %s service", (sp->svc_conf)->sc_id);
        }
      }
      {
#line 867
      xlog_control(sp->svc_log, (xlog_cmd_e )8);
      }
    }
    {
#line 869
    svc_log_exit(sp, (struct server  const  *)serp);
    }
  }
#line 876
  if ((unsigned long )co_sp != (unsigned long )sp) {
#line 876
    if ((unsigned long )co_sp->svc_log != (unsigned long )((void *)0)) {
      {
#line 877
      xlog_control(co_sp->svc_log, (xlog_cmd_e )8);
      }
    }
  }
#line 879
  if (! ((unsigned int )(sp->svc_conf)->sc_wait == 1U)) {
    {
#line 880
    conn_free(cp, 1);
#line 881
    cp = (connection_s *)((void *)0);
    }
  } else {
#line 883
    if (cp) {
#line 884
      if ((sp->svc_conf)->sc_socket_type == 2) {
        {
#line 885
        drain(cp->co_descriptor);
        }
      }
      {
#line 886
      free((void *)cp);
#line 887
      cp = (connection_s *)((void *)0);
#line 888
      (sp->svc_ref_count) --;
      }
#line 888
      if (sp->svc_ref_count == 0) {
        {
#line 889
        svc_release(sp);
        }
      }
    }
    {
#line 892
    svc_resume(sp);
    }
  }
#line 894
  return;
}
}
#line 903 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/service.c"
void close_all_svc_descriptors(void) 
{ 
  psi_h iter___0 ;
  struct service *osp ;
  __pset_pointer tmp ;
  __pset_pointer tmp___0 ;

  {
  {
#line 909
  iter___0 = psi_create(ps.rws.services);
  }
#line 910
  if ((unsigned long )iter___0 == (unsigned long )((void *)0)) {
    {
#line 911
    out_of_memory("close_all_svc_descriptors");
    }
  }
#line 913
  iter___0->current = 0U;
#line 913
  iter___0->step = 1;
#line 913
  if (iter___0->current < (iter___0->pset)->count) {
#line 913
    tmp = *((iter___0->pset)->ptrs + iter___0->current);
  } else {
#line 913
    tmp = (void *)0;
  }
#line 913
  osp = (struct service *)tmp;
  {
#line 913
  while (1) {
    while_continue: /* CIL Label */ ;
#line 913
    if (! osp) {
#line 913
      goto while_break;
    }
    {
#line 914
    Sclose(osp->svc_fd);
#line 913
    iter___0->current += (unsigned int )iter___0->step;
#line 913
    iter___0->step = 1;
    }
#line 913
    if (iter___0->current < (iter___0->pset)->count) {
#line 913
      tmp___0 = *((iter___0->pset)->ptrs + iter___0->current);
    } else {
#line 913
      tmp___0 = (void *)0;
    }
#line 913
    osp = (struct service *)tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 916
  free((void *)((char *)iter___0));
  }
#line 917
  return;
}
}
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 189 "../libs/include/sio.h"
extern int Sbuftype(int fd , int type ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.h"
void dump_internal_state(void) ;
#line 8
void user_requested_check(void) ;
#line 9
void enable_periodic_check(unsigned int interval ) ;
#line 86 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.h"
void server_dump(struct server  const  *serp , int fd ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.h"
char program_version[22] ;
#line 9
int signals_pending[2] ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
static unsigned int thread_check(struct service *sp , unsigned int running_servers ,
                                 unsigned int retry_servers ) ;
#line 31
static unsigned int refcount_check(struct service *sp , unsigned int *running_servers ,
                                   unsigned int *retry_servers ) ;
#line 32
static unsigned int service_count_check(struct service *sp , unsigned int running_servers ,
                                        unsigned int retry_servers ) ;
#line 33
static void periodic_check(void) ;
#line 36 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
static void dump_services(int fd ) 
{ 
  unsigned int u ;

  {
  {
#line 43
  Sprint(fd, "Services + defaults:\n");
#line 44
  sc_dump(ps.rws.defs.def_settings, fd, 0, 1);
#line 46
  u = 0U;
  }
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (u < (ps.rws.services)->count)) {
#line 46
      goto while_break;
    }
    {
#line 47
    svc_dump((struct service  const  *)((struct service *)*((ps.rws.services)->ptrs + u)),
             fd);
#line 46
    u ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
void dump_internal_state(void) 
{ 
  int dump_fd ;
  char const   *dump_file ;
  time_t current_time ;
  int fd ;
  unsigned int u ;
  char const   *func ;
  int tmp ;
  char *tmp___0 ;
  struct stat st ;
  int tmp___1 ;
  char const   *tmp___2 ;

  {
#line 53
  dump_file = "/var/run/xinetd.dump";
#line 57
  func = "dump_internal_state";
#line 59
  if (debug.on) {
    {
#line 60
    msg(7, func, "Dumping State");
    }
  }
  {
#line 62
  dump_fd = open(dump_file, 1089, 420);
  }
#line 63
  if (dump_fd == -1) {
    {
#line 65
    msg(3, func, "failed to open %s: %m", dump_file);
    }
#line 66
    return;
  }
  {
#line 69
  tmp = Sbuftype(dump_fd, 1);
  }
#line 69
  if (tmp == -1) {
    {
#line 75
    msg(3, func, "failed setting up sio buffering: %m fd:%d", dump_fd);
#line 77
    Sclose(dump_fd);
    }
#line 78
    return;
  }
  {
#line 85
  time(& current_time);
#line 86
  Sprint(dump_fd, "INTERNAL STATE DUMP: %s\n", program_version);
#line 87
  tmp___0 = ctime((time_t const   *)(& current_time));
#line 87
  Sprint(dump_fd, "Current time: %s\n", tmp___0);
#line 89
  dump_services(dump_fd);
#line 94
  Sprint(dump_fd, "Server table dump:\n");
#line 95
  u = 0U;
  }
  {
#line 95
  while (1) {
    while_continue: /* CIL Label */ ;
#line 95
    if (! (u < (ps.rws.servers)->count)) {
#line 95
      goto while_break;
    }
    {
#line 96
    server_dump((struct server  const  *)((struct server *)*((ps.rws.servers)->ptrs + u)),
                dump_fd);
#line 95
    u ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 97
  Sputchar(dump_fd, (char )'\n');
#line 102
  Sprint(dump_fd, "Retry table dump:\n");
#line 103
  u = 0U;
  }
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (u < (ps.rws.retries)->count)) {
#line 103
      goto while_break___0;
    }
    {
#line 104
    server_dump((struct server  const  *)((struct server *)*((ps.rws.retries)->ptrs + u)),
                dump_fd);
#line 103
    u ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 105
  Sputchar(dump_fd, (char )'\n');
#line 110
  Sprint(dump_fd, "Socket mask:");
#line 111
  fd = 0;
  }
  {
#line 111
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 111
    if (! ((rlim_t )((unsigned int )fd) < ps.ros.max_descriptors)) {
#line 111
      goto while_break___1;
    }
#line 112
    if ((ps.rws.socket_mask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 113
      Sprint(dump_fd, " %d", fd);
      }
    }
#line 111
    fd ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 114
  Sputchar(dump_fd, (char )'\n');
#line 115
  Sprint(dump_fd, "mask_max = %d\n", ps.rws.mask_max);
#line 120
  Sprint(dump_fd, "Open descriptors (not in socket mask):");
#line 121
  fd = 0;
  }
  {
#line 121
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 121
    if (! ((rlim_t )((unsigned int )fd) < ps.ros.max_descriptors)) {
#line 121
      goto while_break___2;
    }
#line 125
    if ((ps.rws.socket_mask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 126
      goto __Cont;
    }
    {
#line 127
    tmp___1 = fstat(fd, & st);
    }
#line 127
    if (tmp___1 == -1) {
#line 128
      goto __Cont;
    }
    {
#line 129
    Sprint(dump_fd, " %d", fd);
    }
    __Cont: /* CIL Label */ 
#line 121
    fd ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 131
  Sputchar(dump_fd, (char )'\n');
#line 132
  Sputchar(dump_fd, (char )'\n');
#line 134
  Sprint(dump_fd, "active_services = %d\n", ps.rws.active_services);
#line 135
  Sprint(dump_fd, "available_services = %d\n", ps.rws.available_services);
#line 136
  Sprint(dump_fd, "descriptors_free = %d\n", ps.rws.descriptors_free);
#line 137
  Sprint(dump_fd, "running_servers = %d\n", (ps.rws.servers)->count);
  }
#line 138
  if ((unsigned long )ps.rws.logging != (unsigned long )((void *)0)) {
#line 138
    tmp___2 = "enabled";
  } else {
#line 138
    tmp___2 = "not enabled";
  }
  {
#line 138
  Sprint(dump_fd, "Logging service = %s\n", tmp___2);
#line 140
  Sputchar(dump_fd, (char )'\n');
#line 142
  Sprint(dump_fd, "max_descriptors = %d\n", (int )ps.ros.max_descriptors);
#line 143
  Sprint(dump_fd, "process_limit = %d\n", (int )ps.ros.process_limit);
#line 144
  Sprint(dump_fd, "config_file = %s\n", ps.ros.config_file);
  }
#line 145
  if (debug.on) {
    {
#line 146
    Sprint(dump_fd, "debug_fd = %d\n", debug.fd);
    }
  }
  {
#line 147
  Sputchar(dump_fd, (char )'\n');
#line 149
  Sprint(dump_fd, "END OF DUMP\n\n");
#line 150
  Sclose(dump_fd);
#line 152
  msg(6, func, "generated state dump in file %s", dump_file);
  }
#line 153
  return;
}
}
#line 162 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
static void consistency_check(enum check_type type ) 
{ 
  int fd ;
  fd_set socket_mask_copy ;
  unsigned int u ;
  int errors ;
  unsigned int total_running_servers ;
  unsigned int total_retry_servers ;
  unsigned int error_count ;
  bool_int service_count_check_failed ;
  char const   *func ;
  register struct service *sp ;
  char *sid ;
  unsigned int running_servers ;
  unsigned int retry_servers ;
  unsigned int tmp ;
  unsigned int tmp___0 ;
  unsigned int tmp___1 ;
  int tmp___2 ;

  {
#line 168
  total_running_servers = 0U;
#line 169
  total_retry_servers = 0U;
#line 170
  error_count = 0U;
#line 171
  service_count_check_failed = 0;
#line 172
  func = "consistency_check";
#line 174
  socket_mask_copy = ps.rws.socket_mask;
#line 176
  u = 0U;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! (u < (ps.rws.services)->count)) {
#line 176
      goto while_break;
    }
    {
#line 178
    sp = (struct service *)*((ps.rws.services)->ptrs + u);
#line 179
    sid = (sp->svc_conf)->sc_id;
#line 183
    tmp = refcount_check(sp, & running_servers, & retry_servers);
#line 183
    error_count += tmp;
    }
#line 185
    if ((unsigned int )sp->svc_state == 1U) {
#line 185
      goto _L;
    } else
#line 185
    if ((unsigned int )sp->svc_state == 2U) {
#line 185
      goto _L;
    } else
#line 185
    if ((unsigned int )sp->svc_state == 3U) {
      _L: /* CIL Label */ 
#line 190
      if ((socket_mask_copy.__fds_bits[sp->svc_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << sp->svc_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 192
        if ((unsigned int )sp->svc_state == 3U) {
          {
#line 194
          msg(3, func, "fd of disabled service %s still in socket mask", sid);
#line 196
          error_count ++;
          }
        }
#line 198
        socket_mask_copy.__fds_bits[sp->svc_fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << sp->svc_fd % (8 * (int )sizeof(__fd_mask )));
      }
      {
#line 200
      tmp___0 = thread_check(sp, running_servers, retry_servers);
#line 200
      error_count += tmp___0;
#line 202
      tmp___1 = service_count_check(sp, running_servers, retry_servers);
#line 202
      errors = (int )tmp___1;
      }
#line 203
      if (! errors) {
#line 203
        if (! service_count_check_failed) {
#line 205
          total_retry_servers += retry_servers;
#line 206
          total_running_servers += running_servers;
        }
      }
#line 208
      if (errors) {
#line 210
        service_count_check_failed = 1;
#line 211
        error_count += (unsigned int )errors;
      }
#line 214
      if ((unsigned int )sp->svc_state == 3U) {
#line 214
        if (sp->svc_running_servers == 0U) {
          {
#line 216
          msg(3, func, "disabled service %s has 0 running servers\n", sid);
#line 218
          error_count ++;
          }
#line 219
          goto __Cont;
        }
      }
    } else
#line 223
    if (! ((sp->svc_conf)->sc_type & (1UL << 5))) {
#line 223
      if (! ((sp->svc_conf)->sc_type & (1UL << 6))) {
        {
#line 225
        msg(3, func, "service %s not started", (sp->svc_conf)->sc_id);
#line 226
        error_count ++;
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 176
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 230
  if (! service_count_check_failed) {
#line 232
    if (total_running_servers != (ps.rws.servers)->count) {
      {
#line 234
      msg(3, func, "total running servers (%d) != number of running servers (%d)",
          total_running_servers, (ps.rws.servers)->count);
#line 237
      error_count ++;
      }
    }
#line 239
    if (total_retry_servers != (ps.rws.retries)->count) {
      {
#line 241
      msg(3, func, "total retry servers (%d) != number of retry servers (%d)", total_retry_servers,
          (ps.rws.retries)->count);
#line 244
      error_count ++;
      }
    }
  }
#line 251
  fd = 0;
  {
#line 251
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 251
    if (! ((rlim_t )((unsigned int )fd) < ps.ros.max_descriptors)) {
#line 251
      goto while_break___0;
    }
#line 252
    if ((socket_mask_copy.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
#line 252
      if (fd != signals_pending[0]) {
#line 252
        if (fd != signals_pending[1]) {
          {
#line 254
          msg(3, func, "descriptor %d set in socket mask but there is no service for it",
              fd);
#line 257
          error_count ++;
          }
        }
      }
    }
#line 251
    fd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  if (error_count != 0U) {
    {
#line 261
    msg(4, func, "Consistency check detected %d errors", error_count);
    }
  } else
#line 264
  if ((unsigned int )type == 1U) {
    {
#line 265
    msg(6, func, "Consistency check passed");
    }
  } else
#line 264
  if (debug.on) {
    {
#line 265
    msg(6, func, "Consistency check passed");
    }
  }
#line 267
  if ((unsigned int )type == 0U) {
    {
#line 268
    tmp___2 = xtimer_add(& periodic_check, (time_t )ps.ros.cc_interval);
    }
#line 268
    if (tmp___2 == -1) {
      {
#line 269
      msg(3, func, "Failed to start consistency timer");
      }
    }
  }
#line 270
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
static unsigned int service_count_check(struct service *sp , unsigned int running_servers ,
                                        unsigned int retry_servers ) 
{ 
  char *sid ;
  int error_count ;
  char const   *func ;

  {
#line 281
  sid = (sp->svc_conf)->sc_id;
#line 282
  error_count = 0;
#line 283
  func = "service_count_check";
#line 285
  if (sp->svc_running_servers != running_servers) {
    {
#line 287
    msg(3, func, "service %s: actual running servers = %d, known running servers = %d",
        sid, running_servers, sp->svc_running_servers);
#line 290
    error_count ++;
    }
  }
#line 292
  if (sp->svc_retry_servers != retry_servers) {
    {
#line 294
    msg(3, func, "service %s: actual retry servers = %d, known retry servers = %d",
        sid, retry_servers, sp->svc_retry_servers);
#line 297
    error_count ++;
    }
  }
#line 300
  if (error_count) {
#line 300
    if (debug.on) {
      {
#line 301
      msg(7, func, "%s: %d errors detected", sid, error_count);
      }
    }
  }
#line 303
  return ((unsigned int )error_count);
}
}
#line 315 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
static unsigned int thread_check(struct service *sp , unsigned int running_servers ,
                                 unsigned int retry_servers ) 
{ 
  unsigned int error_count ;
  int sd ;
  char *sid ;
  char const   *func ;
  bool_int has_servers ;

  {
#line 319
  error_count = 0U;
#line 320
  sd = sp->svc_fd;
#line 321
  sid = (sp->svc_conf)->sc_id;
#line 322
  func = "thread_check";
#line 324
  if ((unsigned int )(sp->svc_conf)->sc_wait == 1U) {
#line 326
    has_servers = running_servers + retry_servers != 0U;
#line 328
    if (has_servers) {
#line 328
      if ((ps.rws.socket_mask.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 330
        msg(3, func, "Active single-threaded service %s: server running, descriptor set",
            sid);
#line 332
        error_count ++;
        }
      }
    }
#line 334
    if (! has_servers) {
#line 334
      if (! ((ps.rws.socket_mask.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
        {
#line 336
        msg(3, func, "Active single-threaded service %s: no server running, descriptor not set",
            sid);
#line 339
        error_count ++;
        }
      }
    }
  } else
#line 343
  if (! ((ps.rws.socket_mask.__fds_bits[sd / (8 * (int )sizeof(__fd_mask ))] & (1L << sd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
    {
#line 345
    msg(3, func, "Active multi-threaded service %s: descriptor not set", sid);
#line 347
    error_count ++;
    }
  }
#line 350
  if (error_count) {
#line 350
    if (debug.on) {
      {
#line 351
      msg(7, func, "%s: %d errors detected", sid, error_count);
      }
    }
  }
#line 353
  return (error_count);
}
}
#line 363 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
static int count_refs(struct service *sp , pset_h servers , unsigned int *countp ) 
{ 
  unsigned int u ;
  struct server *serp ;
  int refs ;
  unsigned int count ;

  {
#line 367
  refs = 0;
#line 368
  count = 0U;
#line 370
  u = 0U;
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! (u < servers->count)) {
#line 370
      goto while_break;
    }
#line 372
    serp = (struct server *)*((ps.rws.servers)->ptrs + u);
#line 373
    if ((unsigned long )serp->svr_sp == (unsigned long )sp) {
#line 375
      refs ++;
#line 376
      count ++;
    }
#line 378
    if ((unsigned long )(serp->svr_conn)->co_sp == (unsigned long )sp) {
#line 379
      refs ++;
    }
#line 370
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 387
  *countp = count;
#line 388
  return (refs);
}
}
#line 397 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
static unsigned int refcount_check(struct service *sp , unsigned int *running_servers ,
                                   unsigned int *retry_servers ) 
{ 
  char *sid ;
  unsigned int errors ;
  int refs ;
  int refcount ;
  char const   *func ;

  {
#line 401
  sid = (sp->svc_conf)->sc_id;
#line 402
  errors = 0U;
#line 404
  refcount = sp->svc_ref_count;
#line 405
  func = "refcount_check";
#line 407
  if (refcount <= 0) {
    {
#line 409
    msg(3, func, "%s service has bad refcount: %d", sid, refcount);
#line 411
    errors ++;
    }
  }
  {
#line 418
  refcount --;
#line 420
  refs = count_refs(sp, ps.rws.servers, running_servers);
  }
#line 421
  if (! errors) {
#line 421
    if (refs > refcount) {
      {
#line 423
      msg(3, func, "running servers: too many references for %s (%d with max=%d)",
          sid, refs, refcount);
#line 426
      errors ++;
      }
    }
  }
  {
#line 429
  refs = count_refs(sp, ps.rws.retries, retry_servers);
  }
#line 430
  if (! errors) {
#line 430
    if (refs > refcount) {
      {
#line 432
      msg(3, func, "retry servers: too many references for %s (%d with max=%d)", sid,
          refs, refcount);
#line 435
      errors ++;
      }
    }
  }
#line 438
  if (errors) {
#line 438
    if (debug.on) {
      {
#line 439
      msg(7, func, "%s: %d errors detected", sid, errors);
      }
    }
  }
#line 441
  return (errors);
}
}
#line 445 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
void user_requested_check(void) 
{ 


  {
  {
#line 447
  consistency_check((enum check_type )1);
  }
#line 448
  return;
}
}
#line 451 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
static void periodic_check(void) 
{ 


  {
  {
#line 453
  consistency_check((enum check_type )0);
  }
#line 454
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/internals.c"
void enable_periodic_check(unsigned int interval ) 
{ 
  char const   *func ;
  int tmp ;

  {
  {
#line 461
  func = "enable_periodic_check";
#line 463
  tmp = xtimer_add(& periodic_check, (time_t )interval);
  }
#line 463
  if (tmp == -1) {
    {
#line 465
    msg(3, func, "Failed to start consistency timer");
    }
#line 466
    return;
  }
#line 468
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 58 "../libs/include/xlog.h"
extern xlog_h xlog_create(xlog_e type , char const   *id , int flags  , ...) ;
#line 59
extern void xlog_destroy(xlog_h  ) ;
#line 60
extern void xlog_write(xlog_h  , char const   *buf , int len , int flags  , ...) ;
#line 36 "../libs/include/str.h"
extern int ( /* format attribute */  strx_nprintv)(char *buf , int len , char const   *fmt ,
                                                   va_list  ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.h"
char const   *msg_init(void) ;
#line 7
void msg_suspend(void) ;
#line 8
void msg_resume(void) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.h"
int filelog_option ;
#line 14
char *filelog_option_arg ;
#line 15
int syslog_option ;
#line 16
char *syslog_option_arg ;
#line 20
char *program_name ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
struct name_value  const  *nv_find_value(struct name_value  const  *nv_array , char const   *name___0 ) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.h"
struct name_value  const  syslog_facilities[19] ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.h"
int line_count ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.c"
static struct name_value  const  priorities[8]  = 
#line 26 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.c"
  {      {"WARNING", 4}, 
        {"ERROR", 3}, 
        {"CRITICAL", 2}, 
        {"NOTICE", 5}, 
        {"DEBUG", 7}, 
        {"INFO", 6}, 
        {(char const   *)((void *)0), 1}, 
        {"UNKNOWN", 0}};
#line 42 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.c"
char const   *msg_init(void) 
{ 
  xlog_h xh ;
  int fd ;
  xlog_e type_of_xlog ;
  bool_int facility_error ;
  char const   *func ;
  int facility ;
  struct name_value  const  *nvp ;
  int tmp ;
  int tmp___0 ;

  {
#line 47
  facility_error = 0;
#line 48
  func = "msg_init";
#line 50
  if (debug.on) {
    {
#line 52
    type_of_xlog = (xlog_e )1;
#line 53
    xh = xlog_create(type_of_xlog, (char const   *)program_name, 0, "/dev/tty", 1025,
                     0);
#line 55
    debug.fd = -1;
    }
  } else
#line 59
  if (filelog_option) {
    {
#line 61
    type_of_xlog = (xlog_e )1;
#line 62
    xh = xlog_create(type_of_xlog, (char const   *)program_name, 48, filelog_option_arg,
                     1089, 420);
    }
  } else {
#line 68
    facility = 3 << 3;
#line 70
    if (syslog_option) {
      {
#line 74
      nvp = nv_find_value(syslog_facilities, (char const   *)syslog_option_arg);
      }
#line 75
      if ((unsigned long )nvp != (unsigned long )((void *)0)) {
#line 76
        facility = (int )nvp->value;
      } else {
#line 78
        facility_error = 1;
      }
    }
    {
#line 81
    type_of_xlog = (xlog_e )0;
#line 82
    xh = xlog_create(type_of_xlog, (char const   *)program_name, 0, facility, 6);
    }
  }
#line 87
  if ((unsigned long )xh == (unsigned long )((void *)0)) {
#line 94
    if ((unsigned int )type_of_xlog == 0U) {
#line 95
      return ("can\'t connect to syslog");
    } else
#line 96
    if ((unsigned int )type_of_xlog == 1U) {
#line 97
      return ("can\'t open log file");
    } else {
#line 99
      return ("unknown reason");
    }
  }
#line 107
  if ((unsigned int )type_of_xlog == 1U) {
    {
#line 107
    tmp___0 = xlog_control(xh, (xlog_cmd_e )9, & fd);
    }
#line 107
    if (tmp___0 == 0) {
      {
#line 110
      tmp = fcntl(fd, 2, 1);
      }
#line 110
      if (tmp == -1) {
        {
#line 112
        xlog_destroy(xh);
        }
#line 113
        return ("can\'t set close-on-exec flag of log file");
      }
#line 115
      if (debug.on) {
#line 116
        debug.fd = fd;
      }
    }
  }
#line 119
  ps.rws.program_log = xh;
#line 121
  if (facility_error) {
    {
#line 122
    msg(3, func, "Bad syslog facility: %s", syslog_option_arg);
    }
  }
#line 123
  return ((char const   *)((char *)0));
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.c"
void msg_suspend(void) 
{ 


  {
  {
#line 129
  xlog_control(ps.rws.program_log, (xlog_cmd_e )6);
  }
#line 130
  return;
}
}
#line 133 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.c"
void msg_resume(void) 
{ 


  {
  {
#line 135
  xlog_control(ps.rws.program_log, (xlog_cmd_e )7);
  }
#line 136
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.c"
static int ( /* format attribute */  prepare_buffer)(int level , char const   *func ,
                                                     char *buf___0 , unsigned int size ,
                                                     char const   *fmt , va_list ap ) 
{ 
  int cc ;
  char *bufstart ;
  unsigned int bytes_left ;
  char const   *tmp ;
  __pid_t tmp___0 ;

  {
#line 154
  bufstart = buf___0;
#line 155
  bytes_left = size;
#line 160
  if (debug.on) {
    {
#line 162
    tmp = nv_get_name(priorities, level);
#line 162
    cc = strx_nprint(bufstart, (int )bytes_left, "%s: ", tmp);
#line 164
    bufstart += cc;
#line 165
    bytes_left -= (unsigned int )cc;
    }
  } else
#line 160
  if (filelog_option) {
    {
#line 162
    tmp = nv_get_name(priorities, level);
#line 162
    cc = strx_nprint(bufstart, (int )bytes_left, "%s: ", tmp);
#line 164
    bufstart += cc;
#line 165
    bytes_left -= (unsigned int )cc;
    }
  }
#line 171
  if (debug.on) {
    {
#line 173
    tmp___0 = getpid();
#line 173
    cc = strx_nprint(bufstart, (int )bytes_left, "%d {%s} ", tmp___0, func);
#line 174
    bufstart += cc;
#line 175
    bytes_left -= (unsigned int )cc;
    }
  } else
#line 171
  if (level == 2) {
    {
#line 173
    tmp___0 = getpid();
#line 173
    cc = strx_nprint(bufstart, (int )bytes_left, "%d {%s} ", tmp___0, func);
#line 174
    bufstart += cc;
#line 175
    bytes_left -= (unsigned int )cc;
    }
  }
  {
#line 178
  cc = strx_nprintv(bufstart, (int )bytes_left, fmt, ap);
#line 180
  bytes_left -= (unsigned int )cc;
  }
#line 182
  return ((int )(size - bytes_left));
}
}
#line 187 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.c"
void ( /* format attribute */  msg)(int level , char const   *func , char const   *fmt 
                                    , ...) 
{ 
  va_list ap ;
  char buf___0[2048] ;
  int len ;

  {
  {
#line 193
  __builtin_va_start(ap, fmt);
#line 194
  len = prepare_buffer(level, func, buf___0, (unsigned int )sizeof(buf___0), fmt,
                       ap);
#line 195
  __builtin_va_end(ap);
#line 197
  xlog_write(ps.rws.program_log, (char const   *)(buf___0), len, 1, level);
  }
#line 198
  return;
}
}
#line 208 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/msg.c"
void ( /* format attribute */  parsemsg)(int msg_level , char const   *func , char const   *fmt 
                                         , ...) 
{ 
  va_list ap ;
  char buf___0[2048] ;
  int cc ;
  int len ;

  {
  {
#line 215
  __builtin_va_start(ap, fmt);
#line 216
  len = prepare_buffer(msg_level, func, buf___0, (unsigned int )sizeof(buf___0), fmt,
                       ap);
#line 217
  __builtin_va_end(ap);
#line 219
  cc = strx_nprint(& buf___0[len], (int )(sizeof(buf___0) - (unsigned long )len),
                   " [file=%s] [line=%d]", current_file, line_count);
#line 221
  len += cc;
#line 223
  xlog_write(ps.rws.program_log, (char const   *)(buf___0), len, 5, msg_level);
  }
#line 225
  return;
}
}
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 181 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/defs.h"
struct debug debug  ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.h"
struct program_state ps  ;
#line 11
 __attribute__((__noreturn__)) void quit_program(void) ;
#line 15
 __attribute__((__noreturn__)) void terminate_program(void) ;
#line 5 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.h"
void init_daemon(int argc , char **argv ) ;
#line 6
void init_services(void) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.h"
void check_pipe(void) ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.h"
int xtimer_poll(void) ;
#line 23
time_t xtimer_nexttime(void) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.c"
static  __attribute__((__noreturn__)) void main_loop(void) ;
#line 33
static void find_bad_fd(void) ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.c"
char program_version[22]  = 
#line 40
  {      (char )'x',      (char )'i',      (char )'n',      (char )'e', 
        (char )'t',      (char )'d',      (char )' ',      (char )'V', 
        (char )'e',      (char )'r',      (char )'s',      (char )'i', 
        (char )'o',      (char )'n',      (char )' ',      (char )'2', 
        (char )'.',      (char )'3',      (char )'.',      (char )'1', 
        (char )'5',      (char )'\000'};
#line 41 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.c"
int signals_pending[2]  = {      -1,      -1};
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.c"
int main(int argc , char **argv ) 
{ 
  char const   *func ;
  int tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 48
  func = "main";
#line 50
  init_daemon(argc, argv);
#line 54
  init_services();
#line 59
  tmp = chdir("/");
  }
#line 59
  if (tmp < 0) {
    {
#line 60
    msg(3, func, "Can\'t chdir to /: %m");
    }
  }
  {
#line 67
  msg(5, func, "%s started with no options compiled in.", "xinetd Version 2.3.15");
  }
#line 92
  if (ps.rws.available_services != 1) {
#line 92
    tmp___0 = "s";
  } else {
#line 92
    tmp___0 = "";
  }
  {
#line 92
  msg(5, func, "Started working: %d available service%s", ps.rws.available_services,
      tmp___0);
#line 101
  tmp___1 = __sigsetjmp((struct __jmp_buf_tag *)(ps.rws.env), 1);
  }
#line 101
  if (tmp___1 == 0) {
#line 102
    ps.rws.env_is_valid = 1;
  }
  {
#line 104
  main_loop();
#line 107
  exit(1);
  }
}
}
#line 118
static  __attribute__((__noreturn__)) void main_loop(void) ;
#line 118 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.c"
static void main_loop(void) 
{ 
  char const   *func ;
  struct timeval tv ;
  struct timeval *tvptr ;
  fd_set read_mask ;
  int n_active ;
  unsigned int u ;
  int *tmp ;
  int *tmp___0 ;
  struct service *sp ;

  {
#line 120
  func = "main_loop";
#line 121
  tvptr = (struct timeval *)((void *)0);
#line 123
  ps.rws.socket_mask.__fds_bits[signals_pending[0] / (8 * (int )sizeof(__fd_mask ))] |= 1L << signals_pending[0] % (8 * (int )sizeof(__fd_mask ));
#line 124
  if (signals_pending[0] > ps.rws.mask_max) {
#line 125
    ps.rws.mask_max = signals_pending[0];
  }
#line 126
  if (signals_pending[1] > ps.rws.mask_max) {
#line 127
    ps.rws.mask_max = signals_pending[1];
  }
  {
#line 129
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (debug.on) {
      {
#line 136
      msg(7, func, "active_services = %d", ps.rws.active_services);
      }
    }
    {
#line 140
    tv.tv_sec = xtimer_nexttime();
    }
#line 140
    if (tv.tv_sec >= 0L) {
#line 141
      tv.tv_usec = (__suseconds_t )0;
#line 142
      tvptr = & tv;
    } else {
#line 144
      tvptr = (struct timeval *)((void *)0);
    }
    {
#line 147
    read_mask = ps.rws.socket_mask;
#line 148
    n_active = select(ps.rws.mask_max + 1, (fd_set */* __restrict  */)(& read_mask),
                      (fd_set */* __restrict  */)((fd_set *)0), (fd_set */* __restrict  */)((fd_set *)0),
                      (struct timeval */* __restrict  */)tvptr);
    }
#line 150
    if (n_active == -1) {
      {
#line 152
      tmp___0 = __errno_location();
      }
#line 152
      if (*tmp___0 == 4) {
#line 153
        goto __Cont;
      } else {
        {
#line 154
        tmp = __errno_location();
        }
#line 154
        if (*tmp == 9) {
          {
#line 155
          find_bad_fd();
          }
        }
      }
#line 156
      goto __Cont;
    } else
#line 158
    if (n_active == 0) {
      {
#line 159
      xtimer_poll();
      }
#line 160
      goto __Cont;
    }
#line 163
    if (debug.on) {
      {
#line 164
      msg(7, func, "select returned %d", n_active);
      }
    }
    {
#line 166
    xtimer_poll();
    }
#line 168
    if ((read_mask.__fds_bits[signals_pending[0] / (8 * (int )sizeof(__fd_mask ))] & (1L << signals_pending[0] % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 169
      check_pipe();
#line 170
      n_active --;
      }
#line 170
      if (n_active == 0) {
#line 171
        goto __Cont;
      }
    }
#line 180
    u = 0U;
    {
#line 180
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 180
      if (! (u < (ps.rws.services)->count)) {
#line 180
        goto while_break___0;
      }
#line 184
      sp = (struct service *)*((ps.rws.services)->ptrs + u);
#line 186
      if (! ((unsigned int )sp->svc_state == 1U)) {
#line 187
        goto __Cont___0;
      }
#line 189
      if ((read_mask.__fds_bits[sp->svc_fd / (8 * (int )sizeof(__fd_mask ))] & (1L << sp->svc_fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 191
        svc_request(sp);
#line 192
        n_active --;
        }
#line 192
        if (n_active == 0) {
#line 193
          goto while_break___0;
        }
      }
      __Cont___0: /* CIL Label */ 
#line 180
      u ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 196
    if (n_active > 0) {
      {
#line 197
      msg(3, func, "%d descriptors still set", n_active);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 208 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.c"
static void find_bad_fd(void) 
{ 
  int fd ;
  struct stat st ;
  unsigned int bad_fd_count ;
  char const   *func ;
  int found ;
  unsigned int u ;
  register struct service *sp ;
  int tmp ;

  {
#line 212
  bad_fd_count = 0U;
#line 213
  func = "find_bad_fd";
#line 215
  fd = 0;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! ((rlim_t )((unsigned int )fd) < ps.ros.max_descriptors)) {
#line 215
      goto while_break;
    }
#line 216
    if ((ps.rws.socket_mask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 216
      tmp = fstat(fd, & st);
      }
#line 216
      if (tmp == -1) {
#line 218
        found = 0;
#line 221
        u = 0U;
        {
#line 221
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 221
          if (! (u < (ps.rws.services)->count)) {
#line 221
            goto while_break___0;
          }
#line 225
          sp = (struct service *)*((ps.rws.services)->ptrs + u);
#line 227
          if (! ((unsigned int )sp->svc_state == 1U)) {
#line 227
            if (! ((unsigned int )sp->svc_state == 2U)) {
#line 228
              goto __Cont;
            }
          }
#line 230
          if (sp->svc_fd == fd) {
            {
#line 232
            msg(3, func, "file descriptor of service %s has been closed", (sp->svc_conf)->sc_id);
#line 235
            svc_deactivate(sp);
#line 236
            found = 1;
            }
#line 237
            goto while_break___0;
          }
          __Cont: /* CIL Label */ 
#line 221
          u ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 240
        if (! found) {
          {
#line 242
          ps.rws.socket_mask.__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] &= ~ (1L << fd % (8 * (int )sizeof(__fd_mask )));
#line 243
          msg(3, func, "No active service for file descriptor %d\n", fd);
#line 245
          bad_fd_count ++;
          }
        }
      }
    }
#line 215
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 248
  if (bad_fd_count == 0U) {
    {
#line 249
    msg(5, func, "select reported EBADF but no bad file descriptors were found");
    }
  }
#line 251
  return;
}
}
#line 259
 __attribute__((__noreturn__)) void quit_program(void) ;
#line 259 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.c"
void quit_program(void) 
{ 
  unsigned int u ;
  struct service_config *scp ;
  char const   *func ;

  {
  {
#line 262
  scp = (struct service_config *)((void *)0);
#line 263
  func = "quit_program";
#line 265
  destroy_global_access_list();
#line 267
  u = 0U;
  }
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! (u < (ps.rws.services)->count)) {
#line 267
      goto while_break;
    }
#line 268
    scp = ((struct service *)*((ps.rws.services)->ptrs + u))->svc_conf;
#line 274
    if (scp->sc_type & (1UL << 1)) {
      {
#line 275
      svc_deactivate((struct service *)*((ps.rws.services)->ptrs + u));
      }
    }
#line 276
    if ((unsigned long )scp->sc_redir_addr != (unsigned long )((void *)0)) {
      {
#line 277
      svc_deactivate((struct service *)*((ps.rws.services)->ptrs + u));
      }
    }
#line 278
    if (scp->sc_type & 1UL) {
      {
#line 279
      svc_deactivate((struct service *)*((ps.rws.services)->ptrs + u));
      }
    }
#line 267
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  if (ps.ros.pid_file) {
    {
#line 283
    unlink(ps.ros.pid_file);
    }
  }
  {
#line 286
  msg(4, func, "Exiting...");
#line 287
  exit(0);
  }
}
}
#line 295
void terminate_servers(struct service *sp ) ;
#line 291
 __attribute__((__noreturn__)) void terminate_program(void) ;
#line 291 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/main.c"
void terminate_program(void) 
{ 
  unsigned int u ;
  struct service_config *scp ;

  {
#line 294
  scp = (struct service_config *)((void *)0);
#line 297
  u = 0U;
  {
#line 297
  while (1) {
    while_continue: /* CIL Label */ ;
#line 297
    if (! (u < (ps.rws.services)->count)) {
#line 297
      goto while_break;
    }
#line 298
    scp = ((struct service *)*((ps.rws.services)->ptrs + u))->svc_conf;
#line 305
    if (scp->sc_type & (1UL << 1)) {
      {
#line 306
      terminate_servers((struct service *)*((ps.rws.services)->ptrs + u));
      }
    }
#line 307
    if ((unsigned long )scp->sc_redir_addr != (unsigned long )((void *)0)) {
      {
#line 308
      terminate_servers((struct service *)*((ps.rws.services)->ptrs + u));
      }
    }
#line 309
    if (scp->sc_type & 1UL) {
      {
#line 310
      terminate_servers((struct service *)*((ps.rws.services)->ptrs + u));
      }
    }
#line 297
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  quit_program();
  }
}
}
#line 603 "/usr/include/unistd.h"
extern  __attribute__((__noreturn__)) void _exit(int __status ) ;
#line 74 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
void int_sighandler(int sig ) ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.h"
char *sig_name(int sig ) ;
#line 28 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
void int_fail(struct intercept_s  const  *ip , char const   *lsyscall ) 
{ 


  {
  {
#line 30
  msg(3, "fail", "%s failed: %m", lsyscall);
#line 31
  (*((ip->int_ops)->exit))();
  }
#line 33
  return;
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
int int_select(int max , fd_set *read_mask ) 
{ 
  char const   *func ;
  int n_ready ;
  int *tmp ;

  {
#line 41
  func = "int_select";
  {
#line 43
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 47
    n_ready = select(max + 1, (fd_set */* __restrict  */)read_mask, (fd_set */* __restrict  */)((fd_set *)0),
                     (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)((struct timeval *)0));
    }
#line 49
    if (n_ready > 0) {
#line 50
      return (n_ready);
    } else
#line 51
    if (n_ready == -1) {
      {
#line 52
      tmp = __errno_location();
      }
#line 52
      if (*tmp == 4) {
#line 53
        goto __Cont;
      } else {
        {
#line 56
        msg(3, func, "select: %m");
        }
#line 57
        return (-1);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 64
 __attribute__((__noreturn__)) void int_exit(struct intercept_s *ip ) ;
#line 64 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
void int_exit(struct intercept_s *ip ) 
{ 
  int status ;
  char const   *func ;
  union __anonunion_80 __constr_expr_0 ;
  char *tmp ;
  union __anonunion_81 __constr_expr_1 ;
  union __anonunion_82 __constr_expr_2 ;
  union __anonunion_83 __constr_expr_3 ;

  {
#line 66
  status = ip->int_common.ic_server.svr_exit_status;
#line 67
  func = "int_exit";
#line 69
  if (debug.on) {
#line 71
    __constr_expr_2.__in = status;
#line 71
    if ((__constr_expr_2.__i & 127) == 0) {
      {
#line 72
      msg(7, func, "intercepted server died");
      }
    } else {
#line 73
      __constr_expr_1.__in = status;
#line 73
      if ((int )((signed char )((__constr_expr_1.__i & 127) + 1)) >> 1 > 0) {
        {
#line 74
        __constr_expr_0.__in = status;
#line 74
        tmp = sig_name(__constr_expr_0.__i & 127);
#line 74
        msg(7, func, "intercepted server received signal %s", tmp);
        }
      }
    }
  }
  {
#line 77
  __constr_expr_3.__in = status;
#line 77
  _exit((__constr_expr_3.__i & 65280) >> 8);
  }
}
}
#line 84 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
void int_init(struct intercept_s *ip , struct server *serp ) 
{ 
  unsigned int u ;
  char const   *func ;
  struct service *sp ;
  __sighandler_t tmp ;
  __sighandler_t tmp___0 ;
  __sighandler_t tmp___1 ;

  {
#line 87
  func = "int_init";
#line 92
  if ((unsigned long )serp->svr_sp != (unsigned long )(serp->svr_conn)->co_sp) {
    {
#line 94
    msg(3, func, "server service (%s) != connection service (%s)", ((serp->svr_sp)->svc_conf)->sc_id,
        (((serp->svr_conn)->co_sp)->svc_conf)->sc_id);
#line 97
    exit(1);
    }
  }
#line 103
  u = 0U;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    if (! (u < (ps.rws.services)->count)) {
#line 103
      goto while_break;
    }
#line 105
    sp = (struct service *)*((ps.rws.services)->ptrs + u);
#line 107
    if ((unsigned long )sp == (unsigned long )serp->svr_sp) {
#line 108
      goto __Cont;
    }
#line 109
    if ((unsigned int )(sp->svc_conf)->sc_log.l_type == 1U) {
      {
#line 110
      xlog_destroy(sp->svc_log);
      }
    }
    {
#line 111
    Sclose(sp->svc_fd);
    }
    __Cont: /* CIL Label */ 
#line 103
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 117
  tmp = signal(17, & int_sighandler);
  }
#line 117
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 118
    int_fail((struct intercept_s  const  *)ip, "signal");
    }
  }
  {
#line 119
  tmp___0 = signal(10, & int_sighandler);
  }
#line 119
  if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 120
    int_fail((struct intercept_s  const  *)ip, "signal");
    }
  }
  {
#line 121
  tmp___1 = signal(15, & int_sighandler);
  }
#line 121
  if ((unsigned long )tmp___1 == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 122
    int_fail((struct intercept_s  const  *)ip, "signal");
    }
  }
  {
#line 127
  ip->int_common.ic_intercept = 1;
#line 128
  ip->int_common.ic_server = *serp;
#line 129
  ip->int_common.ic_remote_socket = (serp->svr_conn)->co_descriptor;
#line 131
  ip->int_common.ic_connections = pset_create(0U, 0U);
  }
#line 132
  if ((unsigned long )ip->int_common.ic_connections == (unsigned long )((void *)0)) {
    {
#line 134
    msg(3, func, "out of memory");
#line 135
    (*((ip->int_ops)->exit))();
    }
  }
#line 137
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
channel_s *int_newconn(struct intercept_s *ip , union xsockaddr *sinp , int remote_socket ) 
{ 
  struct service *sp ;
  int socket_type ;
  union xsockaddr *local ;
  char *sid ;
  channel_s *chp ;
  int sd ;
  char const   *func ;
  int tmp ;
  void *tmp___0 ;
  __pset_pointer tmp___1 ;

  {
  {
#line 147
  sp = ip->int_common.ic_server.svr_sp;
#line 148
  socket_type = (sp->svc_conf)->sc_socket_type;
#line 149
  local = & ip->int_common.ic_local_addr;
#line 150
  sid = (sp->svc_conf)->sc_id;
#line 153
  func = "int_newconn";
#line 159
  sd = socket((int )local->sa.sa_family, socket_type, (sp->svc_conf)->sc_protocol.value);
  }
#line 159
  if (sd == -1) {
    {
#line 161
    msg(3, func, "(intercepting %s) socket creation failed: %m", sid);
    }
#line 162
    return ((struct channel *)((void *)0));
  }
  {
#line 165
  tmp = connect(sd, (struct sockaddr  const  *)((struct sockaddr *)local), (socklen_t )sizeof(*local));
  }
#line 165
  if (tmp == -1) {
    {
#line 167
    msg(3, func, "(intercepting %s) connect failed: %m", sid);
#line 168
    Sclose(sd);
    }
#line 169
    return ((struct channel *)((void *)0));
  }
  {
#line 172
  tmp___0 = malloc(sizeof(channel_s ));
#line 172
  chp = (channel_s *)tmp___0;
  }
#line 173
  if ((unsigned long )chp == (unsigned long )((struct channel *)((void *)0))) {
    {
#line 175
    msg(3, func, "out of memory");
#line 176
    Sclose(sd);
    }
#line 177
    return ((struct channel *)((void *)0));
  }
  {
#line 180
  tmp___1 = pset_add(ip->int_common.ic_connections, (__pset_pointer const   )chp);
  }
#line 180
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 182
    msg(3, func, "out of memory");
#line 183
    free((void *)((char *)chp));
#line 184
    Sclose(sd);
    }
#line 185
    return ((struct channel *)((void *)0));
  }
#line 188
  chp->ch_state = (channel_state_e )0;
#line 189
  chp->ch_from = *sinp;
#line 190
  chp->ch_local_socket = sd;
#line 191
  chp->ch_remote_socket = remote_socket;
#line 192
  return (chp);
}
}
#line 206 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/intcommon.c"
channel_s *int_lookupconn(struct intercept_s *ip , union xsockaddr *sinp , bool_int *addr_checked ) 
{ 
  unsigned int u ;
  pset_h conntab ;
  register channel_s *chp ;
  uint16_t tmp ;
  uint16_t tmp___0 ;
  int tmp___1 ;

  {
#line 211
  conntab = ip->int_common.ic_connections;
#line 213
  *addr_checked = 0;
#line 215
  u = 0U;
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
#line 215
    if (! (u < conntab->count)) {
#line 215
      goto while_break;
    }
    {
#line 217
    chp = (struct channel *)*(conntab->ptrs + u);
#line 219
    tmp___1 = memcmp((void const   *)(& chp->ch_from), (void const   *)sinp, sizeof(*sinp));
    }
#line 219
    if (tmp___1 == 0) {
      {
#line 221
      *addr_checked = 1;
#line 222
      tmp = xaddrport((union xsockaddr  const  *)(& chp->ch_from));
#line 222
      tmp___0 = xaddrport((union xsockaddr  const  *)sinp);
      }
#line 222
      if ((int )tmp == (int )tmp___0) {
#line 223
        return (chp);
      }
    }
#line 215
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 226
  return ((struct channel *)((void *)0));
}
}
#line 163 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t sendto(int __fd , void const   *__buf , size_t __n , int __flags ,
                      struct sockaddr  const  *__addr , socklen_t __addr_len ) ;
#line 174
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 261
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) shutdown)(int __fd ,
                                                                               int __how ) ;
#line 205 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__leaf__)) strftime)(char * __restrict  __s ,
                                                                                  size_t __maxsize ,
                                                                                  char const   * __restrict  __format ,
                                                                                  struct tm  const  * __restrict  __tp ) ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.h"
builtin_s const   *builtin_lookup(struct builtin_service  const  *services , char const   *service_name ,
                                  int type ) ;
#line 89 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.h"
struct server *server_alloc(struct server  const  *init_serp ) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
struct name_value  const  *nv_find_name(struct name_value  const  *nv_array , int value ) ;
#line 50 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.h"
void cps_service_stop(struct service *sp , char const   *reason ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.h"
struct name_value  const  socket_types[6] ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.h"
 __attribute__((__noreturn__)) void child_process(struct server *serp ) ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void stream_echo(struct server  const  *serp ) ;
#line 45
static void dgram_echo(struct server  const  *serp ) ;
#line 46
static void stream_discard(struct server  const  *serp ) ;
#line 47
static void dgram_discard(struct server  const  *serp ) ;
#line 48
static void stream_time(struct server  const  *serp ) ;
#line 49
static void dgram_time(struct server  const  *serp ) ;
#line 50
static void stream_daytime(struct server  const  *serp ) ;
#line 51
static void dgram_daytime(struct server  const  *serp ) ;
#line 52
static void stream_chargen(struct server  const  *serp ) ;
#line 53
static void dgram_chargen(struct server  const  *serp ) ;
#line 54
static void tcpmux_handler(struct server  const  *serp ) ;
#line 69 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static struct builtin_service  const  builtin_services[14]  = 
#line 69
  {      {"echo", 1, {(void (*)())(& stream_echo), (boolean_e )1}}, 
        {"echo", 2, {(void (*)())(& dgram_echo), (boolean_e )0}}, 
        {"discard", 1, {(void (*)())(& stream_discard), (boolean_e )1}}, 
        {"discard", 2, {(void (*)())(& dgram_discard), (boolean_e )0}}, 
        {"time", 1, {(void (*)())(& stream_time), (boolean_e )0}}, 
        {"time", 2, {(void (*)())(& dgram_time), (boolean_e )0}}, 
        {"daytime", 1, {(void (*)())(& stream_daytime), (boolean_e )0}}, 
        {"daytime", 2, {(void (*)())(& dgram_daytime), (boolean_e )0}}, 
        {"chargen", 1, {(void (*)())(& stream_chargen), (boolean_e )1}}, 
        {"chargen", 2, {(void (*)())(& dgram_chargen), (boolean_e )0}}, 
        {"sensor", 1, {(void (*)())(& stream_discard), (boolean_e )0}}, 
        {"sensor", 2, {(void (*)())(& dgram_discard), (boolean_e )0}}, 
        {"tcpmux", 1, {(void (*)())(& tcpmux_handler), (boolean_e )1}}, 
        {(char const   *)((void *)0), 0, {(void (*)())((void *)0), (boolean_e )0}}};
#line 88 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
builtin_s const   *builtin_find(char const   *service_name , int type ) 
{ 
  builtin_s const   *bsp ;
  char const   *func ;
  char const   *type_name ;
  struct name_value  const  *sock_type ;
  struct name_value  const  *tmp ;

  {
  {
#line 91
  func = "builtin_find";
#line 93
  bsp = builtin_lookup(builtin_services, service_name, type);
  }
#line 93
  if (bsp) {
#line 94
    return (bsp);
  } else {
    {
#line 98
    tmp = nv_find_name(socket_types, type);
#line 98
    sock_type = tmp;
    }
#line 99
    if ((unsigned long )sock_type == (unsigned long )((void *)0)) {
#line 100
      type_name = "Unknown socket type";
    } else {
#line 102
      type_name = (char const   *)sock_type->name;
    }
    {
#line 103
    msg(3, func, "No such internal service: %s/%s - DISABLING", service_name, type_name);
    }
#line 105
    return ((builtin_s const   *)((void *)0));
  }
}
}
#line 110 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
builtin_s const   *builtin_lookup(struct builtin_service  const  *services , char const   *service_name ,
                                  int type ) 
{ 
  struct builtin_service  const  *bsp ;
  int tmp ;

  {
#line 116
  bsp = services;
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! ((unsigned long )bsp->bs_name != (unsigned long )((void *)0))) {
#line 116
      goto while_break;
    }
    {
#line 117
    tmp = strcasecmp((char const   *)bsp->bs_name, service_name);
    }
#line 117
    if (tmp == 0) {
#line 117
      if (bsp->bs_socket_type == (int const   )type) {
#line 118
        return (& bsp->bs_handle);
      }
    }
#line 116
    bsp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 119
  return ((builtin_s const   *)((void *)0));
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void stream_echo(struct server  const  *serp ) 
{ 
  char buf___0[1024] ;
  ssize_t cc ;
  int descriptor ;
  struct service *svc ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  status_e tmp___2 ;

  {
#line 133
  descriptor = (serp->svr_conn)->co_descriptor;
#line 134
  svc = (struct service *)serp->svr_sp;
#line 136
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 137
    descriptor = accept(descriptor, (struct sockaddr */* __restrict  */)((void *)0),
                        (socklen_t */* __restrict  */)((void *)0));
    }
#line 138
    if (descriptor == -1) {
      {
#line 139
      tmp = __errno_location();
      }
#line 139
      if (*tmp == 24) {
        {
#line 140
        cps_service_stop(svc, "no available descriptors");
        }
      } else {
        {
#line 139
        tmp___0 = __errno_location();
        }
#line 139
        if (*tmp___0 == 23) {
          {
#line 140
          cps_service_stop(svc, "no available descriptors");
          }
        }
      }
#line 141
      return;
    }
  }
  {
#line 145
  close_all_svc_descriptors();
  }
  {
#line 147
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 149
    cc = read(descriptor, (void *)(buf___0), sizeof(buf___0));
    }
#line 150
    if (cc == 0L) {
#line 151
      goto while_break;
    }
#line 152
    if (cc == -1L) {
      {
#line 153
      tmp___1 = __errno_location();
      }
#line 153
      if (*tmp___1 == 4) {
#line 154
        goto __Cont;
      } else {
#line 156
        goto while_break;
      }
    }
    {
#line 159
    tmp___2 = write_buf(descriptor, (char const   *)(buf___0), (int )cc);
    }
#line 159
    if ((unsigned int )tmp___2 == 0U) {
#line 160
      goto while_break;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 162
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 163
    Sclose(descriptor);
    }
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void dgram_echo(struct server  const  *serp ) 
{ 
  char buf___0[2048] ;
  union xsockaddr lsin ;
  ssize_t cc ;
  socklen_t sin_len ;
  int descriptor ;

  {
#line 171
  sin_len = (socklen_t )0;
#line 172
  descriptor = (serp->svr_conn)->co_descriptor;
#line 174
  if (((serp->svr_sp)->svc_conf)->sc_xflags & (1UL << 9)) {
#line 175
    sin_len = (socklen_t )sizeof(struct sockaddr_in );
  } else
#line 176
  if (((serp->svr_sp)->svc_conf)->sc_xflags & (1UL << 10)) {
#line 177
    sin_len = (socklen_t )sizeof(struct sockaddr_in6 );
  }
  {
#line 179
  cc = recvfrom(descriptor, (void */* __restrict  */)(buf___0), sizeof(buf___0), 0,
                (struct sockaddr */* __restrict  */)((struct sockaddr *)(& lsin)),
                (socklen_t */* __restrict  */)(& sin_len));
  }
#line 180
  if (cc != -1L) {
    {
#line 181
    sendto(descriptor, (void const   *)(buf___0), (size_t )cc, 0, (struct sockaddr  const  *)((struct sockaddr *)(& lsin)),
           (socklen_t )sizeof(lsin));
    }
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void stream_discard(struct server  const  *serp ) 
{ 
  char buf___0[1024] ;
  ssize_t cc ;
  int descriptor ;
  struct service *svc ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 189
  descriptor = (serp->svr_conn)->co_descriptor;
#line 190
  svc = (struct service *)serp->svr_sp;
#line 192
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 193
    descriptor = accept(descriptor, (struct sockaddr */* __restrict  */)((void *)0),
                        (socklen_t */* __restrict  */)((void *)0));
    }
#line 194
    if (descriptor == -1) {
      {
#line 195
      tmp = __errno_location();
      }
#line 195
      if (*tmp == 24) {
        {
#line 196
        cps_service_stop(svc, "no available descriptors");
        }
      } else {
        {
#line 195
        tmp___0 = __errno_location();
        }
#line 195
        if (*tmp___0 == 23) {
          {
#line 196
          cps_service_stop(svc, "no available descriptors");
          }
        }
      }
#line 197
      return;
    }
  }
  {
#line 201
  close_all_svc_descriptors();
  }
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    cc = read(descriptor, (void *)(buf___0), sizeof(buf___0));
    }
#line 206
    if (cc == 0L) {
#line 207
      goto while_break;
    } else
#line 206
    if (cc == -1L) {
      {
#line 206
      tmp___1 = __errno_location();
      }
#line 206
      if (*tmp___1 != 4) {
#line 207
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 210
    Sclose(descriptor);
    }
  }
#line 211
  return;
}
}
#line 214 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void dgram_discard(struct server  const  *serp ) 
{ 
  char buf___0[1] ;

  {
  {
#line 218
  recv((serp->svr_conn)->co_descriptor, (void *)(buf___0), sizeof(buf___0), 0);
  }
#line 219
  return;
}
}
#line 232
static void daytime_protocol(char *buf___0 , unsigned int *buflen ) ;
#line 232 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static char const   *month_name[12]  = 
#line 232
  {      "JAN",      "FEB",      "MAR",      "APR", 
        "MAY",      "JUN",      "JUL",      "AUG", 
        "SEP",      "OCT",      "NOV",      "DEC"};
#line 230 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void daytime_protocol(char *buf___0 , unsigned int *buflen ) 
{ 
  time_t now ;
  struct tm *tmp ;
  int size ;
  int cc ;
  size_t tmp___0 ;

  {
  {
#line 239
  size = (int )*buflen;
#line 244
  time(& now);
#line 245
  tmp = localtime((time_t const   *)(& now));
#line 252
  cc = strx_nprint(buf___0, size, "%02d %s %d %02d:%02d:%02d", tmp->tm_mday, month_name[tmp->tm_mon],
                   1900 + tmp->tm_year, tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
  }
#line 256
  if (cc >= 0) {
    {
#line 257
    *buflen = (unsigned int )cc;
#line 258
    size -= cc;
#line 259
    tmp___0 = strftime((char */* __restrict  */)(buf___0 + *buflen), (size_t )size,
                       (char const   */* __restrict  */)" %Z\r\n", (struct tm  const  */* __restrict  */)tmp);
#line 259
    cc = (int )tmp___0;
#line 260
    *buflen += (unsigned int )cc;
    }
  }
#line 263
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void stream_daytime(struct server  const  *serp ) 
{ 
  char time_buf[1024] ;
  unsigned int buflen ;
  int descriptor ;
  struct service *svc ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 269
  buflen = (unsigned int )sizeof(time_buf);
#line 270
  descriptor = (serp->svr_conn)->co_descriptor;
#line 271
  svc = (struct service *)serp->svr_sp;
#line 273
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 274
    descriptor = accept(descriptor, (struct sockaddr */* __restrict  */)((void *)0),
                        (socklen_t */* __restrict  */)((void *)0));
    }
#line 275
    if (descriptor == -1) {
      {
#line 276
      tmp = __errno_location();
      }
#line 276
      if (*tmp == 24) {
        {
#line 277
        cps_service_stop(svc, "no available descriptors");
        }
      } else {
        {
#line 276
        tmp___0 = __errno_location();
        }
#line 276
        if (*tmp___0 == 23) {
          {
#line 277
          cps_service_stop(svc, "no available descriptors");
          }
        }
      }
#line 278
      return;
    }
  }
  {
#line 281
  daytime_protocol(time_buf, & buflen);
#line 282
  write_buf(descriptor, (char const   *)(time_buf), (int )buflen);
#line 283
  Sclose(descriptor);
  }
#line 284
  return;
}
}
#line 287 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void dgram_daytime(struct server  const  *serp ) 
{ 
  char time_buf[1024] ;
  union xsockaddr lsin ;
  socklen_t sin_len ;
  unsigned int buflen ;
  int descriptor ;
  ssize_t val ;

  {
#line 291
  sin_len = (socklen_t )0;
#line 292
  buflen = (unsigned int )sizeof(time_buf);
#line 293
  descriptor = (serp->svr_conn)->co_descriptor;
#line 296
  if (((serp->svr_sp)->svc_conf)->sc_xflags & (1UL << 9)) {
#line 297
    sin_len = (socklen_t )sizeof(struct sockaddr_in );
  } else
#line 298
  if (((serp->svr_sp)->svc_conf)->sc_xflags & (1UL << 10)) {
#line 299
    sin_len = (socklen_t )sizeof(struct sockaddr_in6 );
  }
  {
#line 301
  val = recvfrom(descriptor, (void */* __restrict  */)(time_buf), sizeof(time_buf),
                 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& lsin)),
                 (socklen_t */* __restrict  */)(& sin_len));
  }
#line 303
  if (val == -1L) {
#line 304
    return;
  }
  {
#line 306
  daytime_protocol(time_buf, & buflen);
#line 308
  sendto(descriptor, (void const   *)(time_buf), (size_t )buflen, 0, (struct sockaddr  const  *)((struct sockaddr *)(& lsin)),
         (socklen_t )sizeof(lsin));
  }
#line 309
  return;
}
}
#line 317 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void time_protocol(unsigned char *timep ) 
{ 
  time_t now ;
  unsigned long base1900 ;

  {
  {
#line 322
  time(& now);
#line 323
  base1900 = (unsigned long )now + 2208988800UL;
#line 324
  *(timep + 0) = (unsigned char )(base1900 >> 24);
#line 325
  *(timep + 1) = (unsigned char )(base1900 >> 16);
#line 326
  *(timep + 2) = (unsigned char )(base1900 >> 8);
#line 327
  *(timep + 3) = (unsigned char )base1900;
  }
#line 329
  return;
}
}
#line 332 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void stream_time(struct server  const  *serp ) 
{ 
  unsigned char time_buf[4] ;
  int descriptor ;
  struct service *svc ;
  int *tmp ;
  int *tmp___0 ;

  {
#line 335
  descriptor = (serp->svr_conn)->co_descriptor;
#line 336
  svc = (struct service *)serp->svr_sp;
#line 338
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 339
    descriptor = accept(descriptor, (struct sockaddr */* __restrict  */)((void *)0),
                        (socklen_t */* __restrict  */)((void *)0));
    }
#line 340
    if (descriptor == -1) {
      {
#line 341
      tmp = __errno_location();
      }
#line 341
      if (*tmp == 24) {
        {
#line 342
        cps_service_stop(svc, "no available descriptors");
        }
      } else {
        {
#line 341
        tmp___0 = __errno_location();
        }
#line 341
        if (*tmp___0 == 23) {
          {
#line 342
          cps_service_stop(svc, "no available descriptors");
          }
        }
      }
#line 343
      return;
    }
  }
  {
#line 347
  time_protocol(time_buf);
#line 348
  write_buf(descriptor, (char const   *)((char *)(time_buf)), 4);
#line 350
  Sclose(descriptor);
  }
#line 351
  return;
}
}
#line 354 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void dgram_time(struct server  const  *serp ) 
{ 
  char buf___0[1] ;
  unsigned char time_buf[4] ;
  union xsockaddr lsin ;
  socklen_t sin_len ;
  int fd ;
  ssize_t val ;

  {
#line 359
  sin_len = (socklen_t )0;
#line 360
  fd = (serp->svr_conn)->co_descriptor;
#line 363
  if (((serp->svr_sp)->svc_conf)->sc_xflags & (1UL << 9)) {
#line 364
    sin_len = (socklen_t )sizeof(struct sockaddr_in );
  } else
#line 365
  if (((serp->svr_sp)->svc_conf)->sc_xflags & (1UL << 10)) {
#line 366
    sin_len = (socklen_t )sizeof(struct sockaddr_in6 );
  }
  {
#line 368
  val = recvfrom(fd, (void */* __restrict  */)(buf___0), sizeof(buf___0), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& lsin)),
                 (socklen_t */* __restrict  */)(& sin_len));
  }
#line 369
  if (val == -1L) {
#line 370
    return;
  }
  {
#line 372
  time_protocol(time_buf);
#line 373
  sendto(fd, (void const   *)((char *)(time_buf)), (size_t )4, 0, (struct sockaddr  const  *)((struct sockaddr *)(& lsin)),
         sin_len);
  }
#line 374
  return;
}
}
#line 382 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static char *ring_buf  =    (char *)((void *)0);
#line 383 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static char *ring  ;
#line 391 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static char *generate_line(char *buf___0 , unsigned int len ) 
{ 
  unsigned int line_len ;
  unsigned int tmp ;
  void *tmp___0 ;
  char ch ;
  char *p ;
  char tmp___1 ;

  {
#line 393
  if (72U < len - 2U) {
#line 393
    tmp = 72U;
  } else {
#line 393
    tmp = len - 2U;
  }
#line 393
  line_len = tmp;
#line 395
  if (len < 2U) {
#line 396
    return ((char *)((void *)0));
  }
#line 401
  if ((unsigned long )ring_buf == (unsigned long )((void *)0)) {
    {
#line 401
    tmp___0 = malloc((size_t )166);
#line 401
    ring_buf = (char *)tmp___0;
    }
#line 401
    if ((unsigned long )ring_buf == (unsigned long )((void *)0)) {
#line 402
      return ((char *)((void *)0));
    }
  }
#line 404
  if ((unsigned long )ring == (unsigned long )((void *)0)) {
#line 409
    p = ring_buf;
#line 409
    ch = (char)33;
    {
#line 409
    while (1) {
      while_continue: /* CIL Label */ ;
#line 409
      if (! ((unsigned long )p <= (unsigned long )(ring_buf + 165))) {
#line 409
        goto while_break;
      }
#line 412
      tmp___1 = ch;
#line 412
      ch = (char )((int )ch + 1);
#line 412
      *p = tmp___1;
#line 413
      if ((int )ch == 126) {
#line 414
        ch = (char)33;
      }
#line 409
      p ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 416
    ring = ring_buf;
  }
  {
#line 418
  memcpy((void */* __restrict  */)buf___0, (void const   */* __restrict  */)ring,
         (size_t )line_len);
#line 419
  *(buf___0 + line_len) = (char )'\r';
#line 420
  *(buf___0 + (line_len + 1U)) = (char )'\n';
#line 422
  ring ++;
  }
#line 423
  if (((ring_buf + 165) - ring) + 1L < 72L) {
#line 424
    ring = ring_buf;
  }
#line 425
  return (buf___0);
}
}
#line 429 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void stream_chargen(struct server  const  *serp ) 
{ 
  char line_buf[74] ;
  int descriptor ;
  struct service *svc ;
  int *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  status_e tmp___2 ;

  {
#line 432
  descriptor = (serp->svr_conn)->co_descriptor;
#line 433
  svc = (struct service *)serp->svr_sp;
#line 435
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 436
    descriptor = accept(descriptor, (struct sockaddr */* __restrict  */)((void *)0),
                        (socklen_t */* __restrict  */)((void *)0));
    }
#line 437
    if (descriptor == -1) {
      {
#line 438
      tmp = __errno_location();
      }
#line 438
      if (*tmp == 24) {
        {
#line 439
        cps_service_stop(svc, "no available descriptors");
        }
      } else {
        {
#line 438
        tmp___0 = __errno_location();
        }
#line 438
        if (*tmp___0 == 23) {
          {
#line 439
          cps_service_stop(svc, "no available descriptors");
          }
        }
      }
#line 440
      return;
    }
  }
  {
#line 444
  shutdown(descriptor, 0);
#line 445
  close_all_svc_descriptors();
  }
  {
#line 447
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 449
    tmp___1 = generate_line(line_buf, (unsigned int )sizeof(line_buf));
    }
#line 449
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
#line 450
      goto while_break;
    }
    {
#line 451
    tmp___2 = write_buf(descriptor, (char const   *)(line_buf), (int )sizeof(line_buf));
    }
#line 451
    if ((unsigned int )tmp___2 == 0U) {
#line 452
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 454
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 455
    Sclose(descriptor);
    }
  }
#line 456
  return;
}
}
#line 459 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void dgram_chargen(struct server  const  *serp ) 
{ 
  char buf___0[1024] ;
  char *p ;
  unsigned int len ;
  union xsockaddr lsin ;
  socklen_t sin_len ;
  int fd ;
  unsigned int left ;
  ssize_t val ;
  char *tmp ;

  {
#line 465
  sin_len = (socklen_t )0;
#line 466
  fd = (serp->svr_conn)->co_descriptor;
#line 467
  left = (unsigned int )sizeof(buf___0);
#line 470
  if (((serp->svr_sp)->svc_conf)->sc_xflags & (1UL << 9)) {
#line 471
    sin_len = (socklen_t )sizeof(struct sockaddr_in );
  } else
#line 472
  if (((serp->svr_sp)->svc_conf)->sc_xflags & (1UL << 10)) {
#line 473
    sin_len = (socklen_t )sizeof(struct sockaddr_in6 );
  }
  {
#line 475
  val = recvfrom(fd, (void */* __restrict  */)(buf___0), sizeof(buf___0), 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& lsin)),
                 (socklen_t */* __restrict  */)(& sin_len));
  }
#line 476
  if (val == -1L) {
#line 477
    return;
  }
#line 483
  p = buf___0;
  {
#line 483
  while (1) {
    while_continue: /* CIL Label */ ;
#line 483
    if (! (left > 2U)) {
#line 483
      goto while_break;
    }
#line 485
    if (74U < left) {
#line 485
      len = 74U;
    } else {
#line 485
      len = left;
    }
    {
#line 486
    tmp = generate_line(p, len);
    }
#line 486
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
#line 487
      goto while_break;
    }
#line 483
    left -= len;
#line 483
    p += len;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 489
  sendto(fd, (void const   *)(buf___0), (size_t )(p - buf___0), 0, (struct sockaddr  const  *)((struct sockaddr *)(& lsin)),
         sin_len);
  }
#line 490
  return;
}
}
#line 501 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/builtins.c"
static void tcpmux_handler(struct server  const  *serp ) 
{ 
  char svc_name[1024] ;
  int cc ;
  int descriptor ;
  struct service  const  *svc ;
  unsigned int u ;
  struct service *sp ;
  struct server server ;
  struct server *nserp ;
  struct service_config *scp ;
  ssize_t tmp ;
  int *tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;
  ssize_t tmp___3 ;

  {
  {
#line 505
  descriptor = (serp->svr_conn)->co_descriptor;
#line 506
  svc = (struct service  const  *)serp->svr_sp;
#line 508
  sp = (struct service *)((void *)0);
#line 510
  scp = (struct service_config *)((void *)0);
#line 512
  close_all_svc_descriptors();
  }
  {
#line 519
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 521
    tmp = read(descriptor, (void *)(svc_name), sizeof(svc_name));
#line 521
    cc = (int )tmp;
    }
#line 519
    if (cc == -1) {
      {
#line 519
      tmp___0 = __errno_location();
      }
#line 519
      if (! (*tmp___0 == 4)) {
#line 519
        goto while_break;
      }
    } else {
#line 519
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 524
  if (cc <= 0) {
    {
#line 526
    msg(3, "tcpmux_handler", "read failed");
#line 527
    exit(0);
    }
  }
#line 530
  if (cc <= 2) {
#line 530
    goto _L___0;
  } else
#line 530
  if ((int )svc_name[cc - 1] != 10) {
#line 530
    goto _L___0;
  } else
#line 530
  if ((int )svc_name[cc - 2] != 13) {
    _L___0: /* CIL Label */ 
#line 533
    if (debug.on) {
      {
#line 534
      msg(7, "tcpmux_handler", "Invalid service name format.");
      }
    }
    {
#line 536
    exit(0);
    }
  }
#line 539
  svc_name[cc - 2] = (char )'\000';
#line 541
  if (debug.on) {
    {
#line 543
    msg(7, "tcpmux_handler", "Input (%d bytes) %s as service name.", cc, svc_name);
    }
  }
#line 550
  u = 0U;
  {
#line 550
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 550
    if (! (u < (ps.rws.services)->count)) {
#line 550
      goto while_break___0;
    }
    {
#line 552
    sp = (struct service *)*((ps.rws.services)->ptrs + u);
#line 554
    tmp___2 = strcasecmp((char const   *)(svc_name), (char const   *)(sp->svc_conf)->sc_name);
    }
#line 554
    if (tmp___2 == 0) {
#line 558
      scp = sp->svc_conf;
#line 560
      if (! ((sp->svc_conf)->sc_type & (1UL << 5))) {
#line 560
        if (! ((sp->svc_conf)->sc_type & (1UL << 6))) {
#line 560
          if (! ((sp->svc_conf)->sc_type & (1UL << 6))) {
#line 562
            if (debug.on) {
              {
#line 564
              msg(7, "tcpmux_handler", "Non-tcpmux service name: %s.", svc_name);
              }
            }
#line 567
            goto __Cont;
          }
        }
      }
#line 573
      if ((sp->svc_conf)->sc_type & (1UL << 6)) {
        {
#line 575
        tmp___1 = Swrite(descriptor, "+Go\r\n", sizeof("+Go\r\n"));
        }
#line 575
        if ((unsigned long )tmp___1 != sizeof("+Go\r\n")) {
          {
#line 578
          msg(3, "tcpmux_handler", "Ack write failed for %s.", svc_name);
#line 580
          exit(0);
          }
        }
      }
#line 583
      goto while_break___0;
    }
#line 585
    goto __Cont;
    __Cont: /* CIL Label */ 
#line 550
    u ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 588
  if (u >= (ps.rws.services)->count) {
#line 590
    if (debug.on) {
      {
#line 592
      msg(7, "tcpmux_handler", "Service name %s not found.", svc_name);
      }
    }
    {
#line 597
    tmp___3 = Swrite(descriptor, "-Service name not found\r\n", sizeof("-Service name not found\r\n"));
    }
#line 597
    if ((unsigned long )tmp___3 != sizeof("-Service name not found\r\n")) {
      {
#line 600
      msg(3, "tcpmux_handler", "Not found write failed for %s.", svc_name);
#line 602
      exit(0);
      }
    }
    {
#line 606
    Sflush(descriptor);
#line 607
    Sclose(descriptor);
#line 608
    exit(0);
    }
  }
#line 611
  if ((unsigned int )(svc->svc_conf)->sc_wait == 1U) {
    {
#line 612
    Sclose(descriptor);
    }
  }
  {
#line 614
  server.svr_sp = sp;
#line 615
  server.svr_conn = (connection_s *)serp->svr_conn;
#line 616
  nserp = server_alloc((struct server  const  *)(& server));
  }
#line 617
  if (scp->sc_type & (1UL << 1)) {
    {
#line 618
    (*((scp->sc_builtin)->b_handler))(nserp);
    }
  } else {
    {
#line 620
    child_process(nserp);
    }
  }
#line 622
  return;
}
}
#line 677 "/usr/include/netdb.h"
extern int getnameinfo(struct sockaddr  const  * __restrict  __sa , socklen_t __salen ,
                       char * __restrict  __host , socklen_t __hostlen , char * __restrict  __serv ,
                       socklen_t __servlen , int __flags ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 89 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.h"
char const   *conn_addrstr(connection_s const   *cp ) ;
#line 49 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.h"
struct name_value  const  access_code_names[11] ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
static char ipv6_ret[1025]  ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
char const   *xaddrname(union xsockaddr  const  *inaddr ) 
{ 
  unsigned int len ;
  int tmp ;

  {
#line 34
  len = 0U;
#line 35
  if ((int const   )inaddr->sa.sa_family == 2) {
#line 35
    len = (unsigned int )sizeof(struct sockaddr_in );
  }
#line 36
  if ((int const   )inaddr->sa.sa_family == 10) {
#line 36
    len = (unsigned int )sizeof(struct sockaddr_in6 );
  }
  {
#line 37
  memset((void *)(ipv6_ret), 0, sizeof(ipv6_ret));
#line 38
  tmp = getnameinfo((struct sockaddr  const  */* __restrict  */)(& inaddr->sa), len,
                    (char */* __restrict  */)(ipv6_ret), (socklen_t )sizeof(ipv6_ret),
                    (char */* __restrict  */)((void *)0), (socklen_t )0, 1);
  }
#line 38
  if (tmp) {
    {
#line 40
    strncpy((char */* __restrict  */)(ipv6_ret), (char const   */* __restrict  */)"<unknown>",
            (size_t )1025);
    }
  }
#line 41
  return ((char const   *)(ipv6_ret));
}
}
#line 44 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
uint16_t xaddrport(union xsockaddr  const  *inaddr ) 
{ 


  {
#line 46
  if ((int const   )inaddr->sa.sa_family == 2) {
#line 46
    return ((uint16_t )inaddr->sa_in.sin_port);
  }
#line 47
  if ((int const   )inaddr->sa.sa_family == 10) {
#line 47
    return ((uint16_t )inaddr->sa_in6.sin6_port);
  }
#line 48
  return ((uint16_t )0);
}
}
#line 51
static int log_common(mask_t *logmask , char *buf___0 , int bufsize , connection_s const   *cp ) ;
#line 58 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
void svc_log_success(struct service *sp , connection_s const   *cp , pid_t pid ) 
{ 
  char buf___0[1024] ;
  int bufsize ;
  struct service_config *scp ;
  int len ;
  int cc ;

  {
#line 62
  scp = sp->svc_conf;
#line 66
  if ((unsigned long )sp->svc_log != (unsigned long )((void *)0)) {
#line 66
    if (! (! ((sp->svc_conf)->sc_log_on_success == 0UL))) {
#line 67
      return;
    }
  } else {
#line 67
    return;
  }
  {
#line 69
  bufsize = (int )sizeof(buf___0);
#line 70
  len = 0;
#line 72
  cc = strx_nprint(buf___0, bufsize, "%s: %s", "START", scp->sc_id);
#line 73
  len += cc;
#line 74
  bufsize -= cc;
  }
#line 76
  if (scp->sc_log_on_success & (1UL << 5)) {
    {
#line 78
    cc = strx_nprint(& buf___0[len], bufsize, " pid=%d", pid);
#line 79
    len += cc;
#line 80
    bufsize -= cc;
    }
  }
  {
#line 83
  cc = log_common(& scp->sc_log_on_success, & buf___0[len], bufsize, cp);
#line 84
  len += cc;
#line 85
  bufsize -= cc;
#line 87
  xlog_write(sp->svc_log, (char const   *)(buf___0), len, 4);
  }
#line 88
  return;
}
}
#line 97 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
void svc_log_failure(struct service *sp , connection_s const   *cp , access_e access_failure ) 
{ 
  char buf___0[1024] ;
  int bufsize ;
  struct service_config *scp ;
  int len ;
  int cc ;
  char const   *tmp ;

  {
#line 103
  scp = sp->svc_conf;
#line 104
  len = 0;
#line 107
  if ((unsigned long )sp->svc_log != (unsigned long )((void *)0)) {
#line 107
    if (! (! ((sp->svc_conf)->sc_log_on_failure == 0UL))) {
#line 108
      return;
    }
  } else {
#line 108
    return;
  }
  {
#line 110
  bufsize = (int )sizeof(buf___0);
#line 111
  cc = strx_nprint(buf___0, bufsize, "%s: %s", "FAIL", scp->sc_id);
#line 112
  len += cc;
#line 113
  bufsize -= cc;
#line 115
  tmp = nv_get_name(access_code_names, (int )access_failure);
#line 115
  cc = strx_nprint(& buf___0[len], bufsize, " %s", tmp);
#line 117
  len += cc;
#line 118
  bufsize -= cc;
#line 120
  cc = log_common(& scp->sc_log_on_failure, & buf___0[len], bufsize, cp);
#line 121
  len += cc;
#line 122
  bufsize -= cc;
#line 124
  xlog_write(sp->svc_log, (char const   *)(buf___0), len, 4);
  }
#line 125
  return;
}
}
#line 129 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
static int log_common(mask_t *logmask , char *buf___0 , int bufsize , connection_s const   *cp ) 
{ 
  int len ;
  char const   *tmp ;

  {
#line 134
  len = 0;
#line 136
  if (*logmask & 1UL) {
    {
#line 137
    tmp = conn_addrstr(cp);
#line 137
    len = strx_nprint(buf___0, bufsize, " from=%s", tmp);
    }
  }
#line 138
  return (len);
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
void svc_log_exit(struct service *sp , struct server  const  *serp ) 
{ 
  char buf___0[1024] ;
  int bufsize ;
  int cc ;
  int len ;
  int exit_status ;
  struct service_config *scp ;
  char const   *func ;
  int num ;
  char const   *s ;
  union __anonunion_83___0 __constr_expr_4 ;
  union __anonunion_84 __constr_expr_5 ;
  union __anonunion_85 __constr_expr_6 ;
  union __anonunion_86 __constr_expr_7 ;
  time_t current_time ;

  {
#line 148
  exit_status = (int )serp->svr_exit_status;
#line 149
  scp = sp->svc_conf;
#line 150
  func = "log_exit";
#line 152
  if ((unsigned long )sp->svc_log != (unsigned long )((void *)0)) {
#line 152
    if (! ((sp->svc_conf)->sc_log_on_success & (1UL << 2))) {
#line 152
      if (! ((sp->svc_conf)->sc_log_on_success & (1UL << 4))) {
#line 153
        return;
      }
    }
  } else {
#line 153
    return;
  }
  {
#line 155
  bufsize = (int )sizeof(buf___0);
#line 156
  len = 0;
#line 158
  cc = strx_nprint(buf___0, bufsize, "%s: %s", "EXIT", scp->sc_id);
#line 159
  bufsize -= cc;
#line 160
  len += cc;
  }
#line 167
  if (scp->sc_log_on_success & (1UL << 4)) {
#line 169
    num = 0;
#line 172
    __constr_expr_7.__in = exit_status;
#line 172
    if ((__constr_expr_7.__i & 127) == 0) {
#line 174
      s = "status";
#line 175
      __constr_expr_4.__in = exit_status;
#line 175
      num = (__constr_expr_4.__i & 65280) >> 8;
    } else {
#line 177
      __constr_expr_6.__in = exit_status;
#line 177
      if ((int )((signed char )((__constr_expr_6.__i & 127) + 1)) >> 1 > 0) {
#line 179
        s = "signal";
#line 180
        __constr_expr_5.__in = exit_status;
#line 180
        num = __constr_expr_5.__i & 127;
      } else {
        {
#line 184
        msg(3, func, "Bad exit status");
#line 185
        s = (char const   *)((void *)0);
        }
      }
    }
#line 188
    if (s) {
      {
#line 190
      cc = strx_nprint(& buf___0[len], bufsize, " %s=%d", s, num);
#line 191
      len += cc;
#line 192
      bufsize -= cc;
      }
    }
  }
#line 196
  if (scp->sc_log_on_success & (1UL << 5)) {
    {
#line 198
    cc = strx_nprint(& buf___0[len], bufsize, " pid=%d", serp->svr_pid);
#line 199
    len += cc;
#line 200
    bufsize -= cc;
    }
  }
#line 203
  if (scp->sc_log_on_success & (1UL << 2)) {
    {
#line 207
    time(& current_time);
#line 208
    cc = strx_nprint(& buf___0[len], bufsize, " duration=%ld(sec)", current_time - (time_t )serp->svr_start_time);
#line 210
    len += cc;
#line 211
    bufsize -= cc;
    }
  }
  {
#line 213
  xlog_write(sp->svc_log, (char const   *)(buf___0), len, 4);
  }
#line 214
  return;
}
}
#line 223 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/log.c"
void ( /* format attribute */  svc_logprint)(struct service *sp , char const   *line_id ,
                                             char const   *fmt  , ...) 
{ 
  char buf___0[1024] ;
  int bufsize ;
  int len ;
  int cc ;
  va_list ap ;

  {
#line 227
  bufsize = (int )sizeof(buf___0);
#line 232
  if (! ((unsigned long )sp->svc_log != (unsigned long )((void *)0))) {
#line 233
    return;
  }
  {
#line 235
  len = strx_nprint(buf___0, bufsize, "%s: %s ", line_id, (sp->svc_conf)->sc_id);
#line 236
  __builtin_va_start(ap, fmt);
#line 237
  cc = strx_nprintv(& buf___0[len], bufsize - len, fmt, ap);
#line 238
  __builtin_va_end(ap);
#line 239
  xlog_write(sp->svc_log, (char const   *)(buf___0), len + cc, 6);
  }
#line 240
  return;
}
}
#line 374 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) ntohl)(uint32_t __netlong )  __attribute__((__const__)) ;
#line 36 "../libs/include/pset.h"
extern void pset_delete(pset_h pset , __pset_pointer const   ptr ) ;
#line 88 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.h"
void conn_dump(connection_s const   *cp , int fd ) ;
#line 35 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.c"
static status_e get_connection(struct service *sp , connection_s *cp ) 
{ 
  struct service_config *scp ;
  socklen_t sin_len ;
  char const   *func ;
  int on ;
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int af ;
  int tmp___3 ;
  struct in6_addr  const  *__a ;
  uint32_t tmp___4 ;
  int tmp___5 ;
  struct in6_addr  const  *__a___0 ;
  uint32_t tmp___6 ;
  int tmp___7 ;
  char t_ch ;
  ssize_t val ;

  {
#line 37
  scp = sp->svc_conf;
#line 39
  func = "get_connection";
#line 40
  on = 1;
#line 42
  if (scp->sc_xflags & (1UL << 9)) {
#line 42
    sin_len = (socklen_t )sizeof(struct sockaddr_in );
  }
#line 43
  if (scp->sc_xflags & (1UL << 10)) {
#line 43
    sin_len = (socklen_t )sizeof(struct sockaddr_in6 );
  }
#line 45
  if ((sp->svc_conf)->sc_socket_type == 1) {
#line 51
    if ((unsigned int )scp->sc_wait == 1U) {
#line 52
      cp->co_descriptor = sp->svc_fd;
    } else {
      {
#line 54
      cp->co_descriptor = accept(sp->svc_fd, (struct sockaddr */* __restrict  */)(& cp->co_remote_address.sa),
                                 (socklen_t */* __restrict  */)(& sin_len));
      }
#line 56
      if (cp->co_descriptor != -1) {
#line 57
        cp->co_flags |= 1UL << 1;
      }
    }
#line 60
    if (cp->co_descriptor == -1) {
      {
#line 62
      tmp = __errno_location();
      }
#line 62
      if (*tmp == 24) {
        {
#line 63
        cps_service_stop(sp, "no available descriptors");
        }
      } else {
        {
#line 62
        tmp___0 = __errno_location();
        }
#line 62
        if (*tmp___0 == 23) {
          {
#line 63
          cps_service_stop(sp, "no available descriptors");
          }
        } else {
          {
#line 65
          msg(3, func, "service %s, accept: %m", (sp->svc_conf)->sc_id);
          }
        }
      }
#line 66
      return ((status_e )0);
    }
#line 69
    if (scp->sc_xflags & (1UL << 5)) {
#line 69
      if (scp->sc_protocol.value == 6) {
        {
#line 70
        tmp___1 = setsockopt(sp->svc_fd, 6, 1, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
        }
#line 70
        if (tmp___1 < 0) {
          {
#line 72
          msg(4, func, "service %s, setsockopt: %m", (sp->svc_conf)->sc_id);
          }
        }
      }
    }
#line 74
    if (scp->sc_xflags & (1UL << 6)) {
#line 74
      if (scp->sc_protocol.value == 6) {
        {
#line 76
        tmp___2 = setsockopt(sp->svc_fd, 1, 9, (void const   *)((char *)(& on)), (socklen_t )sizeof(on));
        }
#line 76
        if (tmp___2 < 0) {
          {
#line 78
          msg(4, func, "service %s, setsockopt: %m", (sp->svc_conf)->sc_id);
          }
        }
      }
    }
#line 83
    if (scp->sc_xflags & (1UL << 10)) {
#line 83
      if (! scp->sc_v6only) {
#line 82
        __a = (struct in6_addr  const  *)(& cp->co_remote_address.sa_in6.sin6_addr);
#line 82
        if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 82
          if (__a->__in6_u.__u6_addr32[1] == 0U) {
            {
#line 82
            tmp___4 = htonl((uint32_t )65535);
            }
#line 82
            if (__a->__in6_u.__u6_addr32[2] == tmp___4) {
#line 82
              tmp___5 = 1;
            } else {
#line 82
              tmp___5 = 0;
            }
          } else {
#line 82
            tmp___5 = 0;
          }
        } else {
#line 82
          tmp___5 = 0;
        }
#line 83
        if (tmp___5) {
#line 83
          goto _L;
        } else {
#line 83
          __a___0 = (struct in6_addr  const  *)(& cp->co_remote_address.sa_in6.sin6_addr);
#line 83
          if (__a___0->__in6_u.__u6_addr32[0] == 0U) {
#line 83
            if (__a___0->__in6_u.__u6_addr32[1] == 0U) {
#line 83
              if (__a___0->__in6_u.__u6_addr32[2] == 0U) {
                {
#line 83
                tmp___6 = ntohl(__a___0->__in6_u.__u6_addr32[3]);
                }
#line 83
                if (tmp___6 > 1U) {
#line 83
                  tmp___7 = 1;
                } else {
#line 83
                  tmp___7 = 0;
                }
              } else {
#line 83
                tmp___7 = 0;
              }
            } else {
#line 83
              tmp___7 = 0;
            }
          } else {
#line 83
            tmp___7 = 0;
          }
#line 83
          if (tmp___7) {
            _L: /* CIL Label */ 
            {
#line 85
            af = 2;
#line 86
            tmp___3 = setsockopt(cp->co_descriptor, 41, 1, (void const   *)(& af),
                                 (socklen_t )sizeof(af));
            }
#line 86
            if (tmp___3) {
#line 88
              if (debug.on) {
                {
#line 88
                msg(4, func, "service %s, IPV6_ADDRFORM setsockopt() failed: %m",
                    (sp->svc_conf)->sc_id);
                }
              }
            }
          }
        }
      }
    }
#line 92
    cp->co_flags |= 1UL;
  } else {
#line 96
    if ((sp->svc_conf)->sc_socket_type == 2) {
      {
#line 105
      val = recvfrom(sp->svc_fd, (void */* __restrict  */)(& t_ch), (size_t )1, 2,
                     (struct sockaddr */* __restrict  */)(& cp->co_remote_address.sa),
                     (socklen_t */* __restrict  */)(& sin_len));
      }
#line 107
      if (val == -1L) {
        {
#line 109
        msg(3, func, "service %s, recvfrom: %m", (sp->svc_conf)->sc_id);
        }
#line 110
        return ((status_e )0);
      }
#line 112
      cp->co_flags |= 1UL;
    }
#line 115
    cp->co_descriptor = sp->svc_fd;
  }
#line 118
  return ((status_e )1);
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.c"
connection_s *conn_new(struct service *sp ) 
{ 
  connection_s new_conn ;
  connection_s *cp ;
  char const   *func ;
  status_e tmp ;
  void *tmp___0 ;

  {
  {
#line 131
  func = "conn_new";
#line 133
  memset((void *)((char *)(& new_conn)), 0, sizeof(new_conn));
#line 139
  tmp = get_connection(sp, & new_conn);
  }
#line 139
  if ((unsigned int )tmp == 0U) {
#line 140
    return ((connection_s *)((void *)0));
  }
#line 142
  new_conn.co_sp = sp;
#line 143
  (sp->svc_ref_count) ++;
#line 145
  if ((unsigned int )(sp->svc_conf)->sc_wait == 1U) {
    {
#line 146
    svc_suspend(sp);
    }
  }
  {
#line 148
  tmp___0 = malloc(sizeof(connection_s ));
#line 148
  cp = (connection_s *)tmp___0;
  }
#line 149
  if ((unsigned long )cp == (unsigned long )((connection_s *)((void *)0))) {
    {
#line 151
    out_of_memory(func);
#line 152
    conn_free(& new_conn, 0);
#line 153
    memset((void *)((char *)(& new_conn)), 0, sizeof(new_conn));
    }
#line 154
    return ((connection_s *)((void *)0));
  }
  {
#line 156
  memcpy((void */* __restrict  */)cp, (void const   */* __restrict  */)(& new_conn),
         sizeof(connection_s ));
  }
#line 157
  return (cp);
}
}
#line 166 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.c"
void conn_free(connection_s *cp , int release_mem ) 
{ 
  struct service *sp ;

  {
#line 168
  sp = cp->co_sp;
#line 170
  if ((unsigned long )cp == (unsigned long )((void *)0)) {
#line 171
    return;
  }
#line 172
  if (debug.on) {
    {
#line 173
    msg(6, "conn_free", "freeing connection");
    }
  }
#line 175
  if ((sp->svc_conf)->sc_socket_type == 2) {
#line 175
    if ((unsigned int )sp->svc_state == 1U) {
      {
#line 176
      drain(cp->co_descriptor);
      }
    }
  }
#line 178
  (sp->svc_ref_count) --;
#line 178
  if (sp->svc_ref_count == 0) {
    {
#line 179
    pset_delete(ps.rws.services, (__pset_pointer const   )((__pset_pointer )sp));
#line 180
    svc_release(sp);
    }
  }
  {
#line 182
  cp->co_sp = (struct service *)((void *)0);
#line 184
  Sclose(cp->co_descriptor);
#line 184
  cp->co_descriptor = -1;
#line 186
  memset((void *)((char *)cp), 0, sizeof(*cp));
  }
#line 187
  if (release_mem) {
    {
#line 188
    free((void *)((char *)cp));
    }
  }
#line 190
  return;
}
}
#line 197 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.c"
static char name[1025]  ;
#line 195 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.c"
char const   *conn_addrstr(connection_s const   *cp ) 
{ 
  unsigned int len ;
  int tmp ;

  {
#line 198
  len = 0U;
#line 200
  if (! (cp->co_flags & 1UL)) {
#line 201
    return ("<no address>");
  }
#line 203
  if ((int const   )cp->co_remote_address.sa.sa_family == 2) {
#line 204
    len = (unsigned int )sizeof(struct sockaddr_in );
  } else
#line 205
  if ((int const   )cp->co_remote_address.sa.sa_family == 10) {
#line 206
    len = (unsigned int )sizeof(struct sockaddr_in6 );
  }
  {
#line 208
  tmp = getnameinfo((struct sockaddr  const  */* __restrict  */)(& cp->co_remote_address.sa),
                    len, (char */* __restrict  */)(name), (socklen_t )1025, (char */* __restrict  */)((void *)0),
                    (socklen_t )0, 1);
  }
#line 208
  if (tmp) {
#line 210
    return ("<no address>");
  }
#line 212
  return ((char const   *)(name));
}
}
#line 215 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/connection.c"
void conn_dump(connection_s const   *cp , int fd ) 
{ 
  char const   *name___0 ;
  char const   *tmp ;
  uint16_t tmp___0 ;

  {
  {
#line 217
  tmp = conn_addrstr(cp);
#line 217
  name___0 = tmp;
#line 219
  tabprint(fd, 1, "service = %s\n", ((cp->co_sp)->svc_conf)->sc_id);
#line 220
  tabprint(fd, 1, "descriptor = %d\n", cp->co_descriptor);
#line 222
  tabprint(fd, 1, "flags = %#llx\n", cp->co_flags);
#line 226
  tmp___0 = ntohs((uint16_t )cp->co_remote_address.sa_in.sin_port);
#line 226
  tabprint(fd, 1, "remote_address = %s,%d\n", name___0, (int )tmp___0);
  }
#line 228
  return;
}
}
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.h"
int filelog_option  ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.h"
char *filelog_option_arg  ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.h"
int syslog_option  ;
#line 16 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.h"
char *syslog_option_arg  ;
#line 17 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.h"
int logprocs_option  ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.h"
unsigned int logprocs_option_arg  ;
#line 19
int stayalive_option ;
#line 20 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.h"
char *program_name  ;
#line 21
int dont_fork ;
#line 23
int opt_recognize(int argc , char **argv ) ;
#line 22 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
int parse_int(char const   *str , int base , int term , int *res ) ;
#line 23
int parse_uint(char const   *str , int base , int term , unsigned int *res ) ;
#line 24
int parse_ull(char const   *str , int base , int term , unsigned long long *res ) ;
#line 31 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.c"
int stayalive_option  =    0;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.c"
int inetd_compat  =    0;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.c"
int dont_fork  =    0;
#line 37
static  __attribute__((__noreturn__)) void usage(void) ;
#line 41 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.c"
int opt_recognize(int argc , char **argv ) 
{ 
  int arg ;
  int arg_1 ;
  unsigned int uarg_1 ;
  unsigned long long ullarg_1 ;
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 47
  program_name = strrchr((char const   *)*(argv + 0), '/');
  }
#line 48
  if ((unsigned long )program_name == (unsigned long )((void *)0)) {
#line 48
    program_name = *(argv + 0);
  } else {
#line 48
    program_name ++;
  }
#line 50
  arg = 1;
  {
#line 50
  while (1) {
    while_continue: /* CIL Label */ ;
#line 50
    if (! (arg < argc)) {
#line 50
      goto while_break;
    }
#line 51
    if ((int )*(*(argv + arg) + 0) == 45) {
#line 51
      if ((int )*(*(argv + arg) + 1) != 0) {
        {
#line 53
        tmp___16 = strcmp((char const   *)(*(argv + arg) + 1), "d");
        }
#line 53
        if (tmp___16 == 0) {
#line 54
          debug.on = 1;
        } else {
          {
#line 55
          tmp___15 = strcmp((char const   *)(*(argv + arg) + 1), "f");
          }
#line 55
          if (tmp___15 == 0) {
#line 57
            arg ++;
#line 57
            if (arg == argc) {
              {
#line 58
              usage();
              }
            }
#line 59
            ps.ros.config_file = (char const   *)*(argv + arg);
          } else {
            {
#line 61
            tmp___14 = strcmp((char const   *)(*(argv + arg) + 1), "filelog");
            }
#line 61
            if (tmp___14 == 0) {
#line 63
              arg ++;
#line 63
              if (arg == argc) {
                {
#line 64
                usage();
                }
              }
#line 65
              filelog_option_arg = *(argv + arg);
#line 66
              filelog_option = 1;
            } else {
              {
#line 68
              tmp___13 = strcmp((char const   *)(*(argv + arg) + 1), "syslog");
              }
#line 68
              if (tmp___13 == 0) {
#line 70
                arg ++;
#line 70
                if (arg == argc) {
                  {
#line 71
                  usage();
                  }
                }
#line 72
                syslog_option_arg = *(argv + arg);
#line 73
                syslog_option = 1;
              } else {
                {
#line 75
                tmp___12 = strcmp((char const   *)(*(argv + arg) + 1), "reuse");
                }
#line 75
                if (! (tmp___12 == 0)) {
                  {
#line 77
                  tmp___11 = strcmp((char const   *)(*(argv + arg) + 1), "limit");
                  }
#line 77
                  if (tmp___11 == 0) {
#line 79
                    arg ++;
#line 79
                    if (arg == argc) {
                      {
#line 80
                      usage();
                      }
                    }
                    {
#line 81
                    tmp = parse_ull((char const   *)*(argv + arg), 10, '\000', & ullarg_1);
                    }
#line 81
                    if (tmp < 0) {
                      {
#line 82
                      usage();
                      }
                    }
#line 83
                    ps.ros.process_limit = (rlim_t )ullarg_1;
#line 84
                    if ((unsigned long long )ps.ros.process_limit != ullarg_1) {
                      {
#line 85
                      usage();
                      }
                    }
                  } else {
                    {
#line 87
                    tmp___10 = strcmp((char const   *)(*(argv + arg) + 1), "pidfile");
                    }
#line 87
                    if (tmp___10 == 0) {
#line 88
                      arg ++;
#line 88
                      if (arg == argc) {
                        {
#line 89
                        usage();
                        }
                      }
                      {
#line 90
                      tmp___0 = new_string((char const   *)*(argv + arg));
#line 90
                      ps.ros.pid_file = (char const   *)tmp___0;
                      }
                    } else {
                      {
#line 92
                      tmp___9 = strcmp((char const   *)(*(argv + arg) + 1), "stayalive");
                      }
#line 92
                      if (tmp___9 == 0) {
#line 93
                        stayalive_option = 1;
                      } else {
                        {
#line 94
                        tmp___8 = strcmp((char const   *)(*(argv + arg) + 1), "dontfork");
                        }
#line 94
                        if (tmp___8 == 0) {
#line 95
                          dont_fork = 1;
#line 96
                          stayalive_option = 1;
                        } else {
                          {
#line 98
                          tmp___7 = strcmp((char const   *)(*(argv + arg) + 1), "logprocs");
                          }
#line 98
                          if (tmp___7 == 0) {
#line 99
                            arg ++;
#line 99
                            if (arg == argc) {
                              {
#line 100
                              usage();
                              }
                            }
                            {
#line 101
                            tmp___1 = parse_uint((char const   *)*(argv + arg), 10,
                                                 '\000', & uarg_1);
                            }
#line 101
                            if (tmp___1 < 0) {
                              {
#line 102
                              usage();
                              }
                            }
#line 103
                            logprocs_option_arg = uarg_1;
#line 104
                            logprocs_option = 1;
                          } else {
                            {
#line 106
                            tmp___6 = strcmp((char const   *)(*(argv + arg) + 1),
                                             "shutdownprocs");
                            }
#line 106
                            if (tmp___6 == 0) {
#line 108
                              arg ++;
#line 108
                              if (arg == argc) {
                                {
#line 109
                                usage();
                                }
                              }
                              {
#line 110
                              Sprint(2, "The shutdownprocs option has been deprecated.\n");
                              }
                            } else {
                              {
#line 112
                              tmp___5 = strcmp((char const   *)(*(argv + arg) + 1),
                                               "cc");
                              }
#line 112
                              if (tmp___5 == 0) {
#line 113
                                arg ++;
#line 113
                                if (arg == argc) {
                                  {
#line 114
                                  usage();
                                  }
                                }
                                {
#line 115
                                tmp___2 = parse_int((char const   *)*(argv + arg),
                                                    10, '\000', & arg_1);
                                }
#line 115
                                if (tmp___2) {
                                  {
#line 116
                                  usage();
                                  }
                                } else
#line 115
                                if (arg_1 < 0) {
                                  {
#line 116
                                  usage();
                                  }
                                }
                                {
#line 117
                                ps.ros.cc_interval = arg_1;
#line 118
                                enable_periodic_check((unsigned int )arg_1);
                                }
                              } else {
                                {
#line 120
                                tmp___4 = strcmp((char const   *)(*(argv + arg) + 1),
                                                 "version");
                                }
#line 120
                                if (tmp___4 == 0) {
                                  {
#line 121
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s",
                                          program_version);
#line 128
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 129
                                  exit(0);
                                  }
                                } else {
                                  {
#line 131
                                  tmp___3 = strcmp((char const   *)(*(argv + arg) + 1),
                                                   "inetd_compat");
                                  }
#line 131
                                  if (tmp___3 == 0) {
#line 132
                                    inetd_compat = 1;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      } else {
#line 135
        goto while_break;
      }
    } else {
#line 135
      goto while_break;
    }
#line 50
    arg ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  if (filelog_option + syslog_option > 1) {
    {
#line 138
    usage();
    }
  }
#line 140
  if (argc - arg != 0) {
    {
#line 141
    usage();
    }
  }
#line 142
  return (arg);
}
}
#line 145
static  __attribute__((__noreturn__)) void usage(void) ;
#line 145 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/options.c"
static void usage(void) 
{ 


  {
  {
#line 147
  Sprint(2, "Usage: %s [-d] [-f config_file] [-filelog filename] [-syslog facility] [-reuse] [-limit proc_limit] [-pidfile filename] [-logprocs limit] [-shutdownprocs limit] [-cc interval]\n",
         program_name);
#line 148
  exit(1);
  }
}
}
#line 39 "../libs/include/m_env.h"
extern env_h env_create(env_h const    ) ;
#line 40
extern void env_destroy(env_h  ) ;
#line 41
extern env_h env_make(char **env_strings ) ;
#line 42
extern int env_addvar(env_h  , env_h from_env , char *var ) ;
#line 43
extern int env_addstr(env_h  , char *str ) ;
#line 48
extern int env_errno ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/env.h"
env_h std_env  ;
#line 9
status_e initenv(void) ;
#line 18 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/env.c"
extern char **environ ;
#line 21 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/env.c"
status_e initenv(void) 
{ 
  int tmp ;

  {
  {
#line 23
  std_env = env_make(environ);
  }
#line 24
  if ((unsigned long )std_env == (unsigned long )((void *)0)) {
#line 24
    tmp = 0;
  } else {
#line 24
    tmp = 1;
  }
#line 24
  return ((status_e )tmp);
}
}
#line 27
static status_e make_env_with_strings(struct environment *ep , env_h env___0 , pset_h env_strings ) ;
#line 28
static status_e make_env_from_vars(struct environment *ep , env_h env___0 , pset_h vars ) ;
#line 29
static status_e update_env_with_strings(env_h env___0 , pset_h strings ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/env.c"
status_e setup_environ(struct service_config *scp , struct service_config *def ) 
{ 
  struct environment *ep ;
  status_e tmp ;
  struct environment *dep ;
  status_e tmp___0 ;
  status_e tmp___1 ;
  status_e tmp___2 ;
  status_e tmp___3 ;

  {
#line 34
  ep = & scp->sc_environment;
#line 36
  if (! (scp->sc_specified_attributes & (1UL << 19))) {
#line 38
    if (! (def->sc_specified_attributes & (1UL << 19))) {
#line 40
      if (! (scp->sc_specified_attributes & (1UL << 17))) {
#line 42
        ep->env_type = (environ_e )1;
#line 43
        ep->env_handle = std_env;
#line 44
        return ((status_e )1);
      } else {
        {
#line 47
        tmp = make_env_with_strings(ep, std_env, scp->sc_env_var_defs);
        }
#line 47
        return (tmp);
      }
    } else {
#line 52
      dep = & def->sc_environment;
#line 54
      if ((unsigned int )dep->env_type == 0U) {
        {
#line 54
        tmp___0 = make_env_from_vars(dep, std_env, def->sc_pass_env_vars);
        }
#line 54
        if ((unsigned int )tmp___0 == 0U) {
#line 57
          return ((status_e )0);
        }
      }
#line 59
      if (! (scp->sc_specified_attributes & (1UL << 17))) {
#line 61
        ep->env_type = (environ_e )2;
#line 62
        ep->env_handle = dep->env_handle;
#line 63
        return ((status_e )1);
      } else {
        {
#line 66
        tmp___1 = make_env_with_strings(ep, dep->env_handle, scp->sc_env_var_defs);
        }
#line 66
        return (tmp___1);
      }
    }
  } else {
    {
#line 72
    tmp___2 = make_env_from_vars(ep, std_env, scp->sc_pass_env_vars);
    }
#line 72
    if ((unsigned int )tmp___2 == 0U) {
#line 73
      return ((status_e )0);
    }
#line 75
    if (! (scp->sc_specified_attributes & (1UL << 17))) {
#line 76
      return ((status_e )1);
    } else {
      {
#line 79
      tmp___3 = update_env_with_strings(ep->env_handle, scp->sc_env_var_defs);
      }
#line 79
      if ((unsigned int )tmp___3 == 0U) {
        {
#line 82
        env_destroy(ep->env_handle);
        }
#line 83
        return ((status_e )0);
      }
#line 85
      return ((status_e )1);
    }
  }
}
}
#line 95 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/env.c"
static status_e make_env_with_strings(struct environment *ep , env_h env___0 , pset_h env_strings ) 
{ 
  env_h new_env ;
  char const   *func ;
  status_e tmp ;

  {
  {
#line 100
  func = "make_env_with_strings";
#line 102
  new_env = env_create((env_h const   )env___0);
  }
#line 102
  if ((unsigned long )new_env == (unsigned long )((env_h )0)) {
    {
#line 104
    out_of_memory(func);
    }
#line 105
    return ((status_e )0);
  }
  {
#line 108
  tmp = update_env_with_strings(new_env, env_strings);
  }
#line 108
  if ((unsigned int )tmp == 0U) {
    {
#line 110
    env_destroy(new_env);
    }
#line 111
    return ((status_e )0);
  }
#line 114
  ep->env_type = (environ_e )3;
#line 115
  ep->env_handle = new_env;
#line 116
  return ((status_e )1);
}
}
#line 120 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/env.c"
static status_e make_env_from_vars(struct environment *ep , env_h env___0 , pset_h vars ) 
{ 
  env_h new_env ;
  char *varname ;
  unsigned int u ;
  char const   *func ;
  int tmp ;

  {
  {
#line 127
  func = "make_env_from_vars";
#line 129
  new_env = env_create((env_h const   )((env_h )0));
  }
#line 129
  if ((unsigned long )new_env == (unsigned long )((env_h )0)) {
    {
#line 131
    out_of_memory(func);
    }
#line 132
    return ((status_e )0);
  }
#line 135
  u = 0U;
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! (u < vars->count)) {
#line 135
      goto while_break;
    }
    {
#line 137
    varname = (char *)*(vars->ptrs + u);
#line 138
    tmp = env_addvar(new_env, env___0, varname);
    }
#line 138
    if (tmp == -1) {
      {
#line 141
      if (env_errno == 2) {
#line 141
        goto case_2;
      }
#line 145
      if (env_errno == 1) {
#line 145
        goto case_1;
      }
#line 139
      goto switch_break;
      case_2: /* CIL Label */ 
      {
#line 142
      msg(3, func, "Unknown variable %s", varname);
      }
#line 143
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 146
      out_of_memory(func);
#line 147
      env_destroy(new_env);
      }
#line 148
      return ((status_e )0);
      switch_break: /* CIL Label */ ;
      }
    }
#line 135
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  ep->env_type = (environ_e )3;
#line 153
  ep->env_handle = new_env;
#line 154
  return ((status_e )1);
}
}
#line 158 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/env.c"
static status_e update_env_with_strings(env_h env___0 , pset_h strings ) 
{ 
  unsigned int u ;
  char const   *func ;
  char *p ;
  int tmp ;

  {
#line 161
  func = "update_env_with_strings";
#line 163
  u = 0U;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (u < strings->count)) {
#line 163
      goto while_break;
    }
    {
#line 165
    p = (char *)*(strings->ptrs + u);
#line 167
    tmp = env_addstr(env___0, p);
    }
#line 167
    if (tmp == -1) {
      {
#line 170
      if (env_errno == 1) {
#line 170
        goto case_1;
      }
#line 174
      if (env_errno == 3) {
#line 174
        goto case_3;
      }
#line 168
      goto switch_break;
      case_1: /* CIL Label */ 
      {
#line 171
      out_of_memory(func);
      }
#line 172
      return ((status_e )0);
      case_3: /* CIL Label */ 
      {
#line 175
      msg(3, func, "Bad environment string: %s", p);
      }
#line 176
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 163
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  return ((status_e )1);
}
}
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 111 "/usr/include/grp.h"
extern struct group *getgrnam(char const   *__name ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 80 "../libs/include/str.h"
extern void str_fill(char *s , char c ) ;
#line 44 "../libs/include/m_env.h"
extern char *env_lookup(env_h  , char const   *var ) ;
#line 11 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
char **argv_alloc(unsigned int count ) ;
#line 26
int parse_ubase10(char const   *str , unsigned int *res ) ;
#line 27
bool_int parse_all_digits(char const   *ptr ) ;
#line 14 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.h"
status_e socket_type_parser(pset_h const   values , struct service_config *scp , enum assign_op op ) ;
#line 15
status_e protocol_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 16
status_e wait_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 17
status_e user_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 18
status_e group_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 19
status_e server_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 20
status_e server_args_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 21
status_e instances_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 22
status_e log_on_success_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 23
status_e log_on_failure_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 24
status_e log_type_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 25
status_e only_from_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 26
status_e no_access_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 27
status_e access_times_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 28
status_e type_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 29
status_e id_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 30
status_e env_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 31
status_e port_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 32
status_e rpc_version_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 33
status_e passenv_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 34
status_e flags_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 35
status_e disabled_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 36
status_e rpc_number_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 37
status_e nice_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 38
status_e redir_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 39
status_e bind_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 40
status_e banner_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 41
status_e per_source_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 42
status_e groups_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 43
status_e banner_success_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 44
status_e banner_fail_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 45
status_e cps_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 46
status_e enabled_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 47
status_e svcdisable_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 52
status_e rlim_as_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 55
status_e rlim_cpu_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 58
status_e rlim_data_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 61
status_e rlim_rss_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 64
status_e rlim_stack_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 66
status_e v6only_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 67
status_e deny_time_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 68
status_e umask_parser(pset_h values , struct service_config *scp , enum assign_op op ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.h"
struct name_value  const  service_types[7] ;
#line 7
struct name_value  const  service_flags[13] ;
#line 9
struct name_value  const  success_log_options[7] ;
#line 10
struct name_value  const  failure_log_options[4] ;
#line 12
struct name_value  const  syslog_levels[10] ;
#line 24 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.h"
void addrlist_free(pset_h addr_list ) ;
#line 26
status_e addrlist_remove(pset_h addr_list , char const   *str_addr ) ;
#line 28
int check_hostname(char const   *addr ) ;
#line 51 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
static void missing_attr_msg(char const   *par , char const   *item ) 
{ 


  {
  {
#line 53
  parsemsg(4, par, "attribute %s expects at least 1 value and none were given.", item);
  }
#line 56
  return;
}
}
#line 64 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
static status_e parse_value_list(pset_h values , mask_t *maskp , struct name_value  const  *list ,
                                 enum assign_op op , char const   *description ) 
{ 
  unsigned int u ;
  struct name_value  const  *nvp ;
  char const   *func ;
  char const   *name___0 ;

  {
#line 72
  func = "parse_value_list";
#line 74
  u = 0U;
  {
#line 74
  while (1) {
    while_continue: /* CIL Label */ ;
#line 74
    if (! (u < values->count)) {
#line 74
      goto while_break;
    }
    {
#line 76
    name___0 = (char const   *)((char *)*(values->ptrs + u));
#line 78
    nvp = nv_find_value(list, name___0);
    }
#line 79
    if ((unsigned long )nvp != (unsigned long )((void *)0)) {
#line 81
      if ((unsigned int )op == 1U) {
#line 82
        *maskp |= 1UL << (nvp->value - 1);
      } else {
#line 84
        *maskp &= ~ (1UL << (nvp->value - 1));
      }
    } else {
      {
#line 88
      parsemsg(4, func, "Bad %s: %s", description, name___0);
      }
#line 89
      return ((status_e )0);
    }
#line 74
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 92
  return ((status_e )1);
}
}
#line 96 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e type_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  status_e tmp ;

  {
#line 100
  if (values->count >= 1U) {
    {
#line 102
    tmp = parse_value_list(values, & scp->sc_type, service_types, (enum assign_op )1,
                           "service type");
    }
#line 102
    return (tmp);
  } else {
    {
#line 107
    missing_attr_msg("type_parser", "type");
    }
#line 108
    return ((status_e )0);
  }
}
}
#line 113 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e flags_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  status_e tmp ;

  {
#line 117
  if (values->count >= 1U) {
    {
#line 119
    tmp = parse_value_list(values, & scp->sc_xflags, service_flags, (enum assign_op )1,
                           "service flag");
    }
#line 119
    return (tmp);
  } else {
    {
#line 124
    missing_attr_msg("flags_parser", "flags");
    }
#line 125
    return ((status_e )0);
  }
}
}
#line 130 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e socket_type_parser(pset_h const   values , struct service_config *scp , enum assign_op op ) 
{ 
  struct name_value  const  *nvp ;
  char const   *type ;
  char const   *func ;

  {
  {
#line 135
  type = (char const   *)((char *)*(values->ptrs + 0U));
#line 136
  func = "socket_type_parser";
#line 138
  nvp = nv_find_value(socket_types, type);
  }
#line 139
  if ((unsigned long )nvp != (unsigned long )((void *)0)) {
#line 141
    scp->sc_socket_type = (int )nvp->value;
#line 142
    return ((status_e )1);
  } else {
    {
#line 146
    parsemsg(3, func, "Bad socket type: %s", type);
    }
#line 147
    return ((status_e )0);
  }
}
}
#line 152 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e rpc_version_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  struct rpc_data *rdp ;
  char *version ;
  int min_version ;
  int max_version ;
  char *p ;
  char *tmp ;
  char const   *func ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 156
  rdp = & scp->sc_rd;
#line 157
  version = (char *)*(values->ptrs + 0U);
#line 158
  min_version = 0;
#line 158
  max_version = 0;
#line 159
  tmp = strchr((char const   *)version, '-');
#line 159
  p = tmp;
#line 160
  func = "rpc_version_parser";
  }
#line 162
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 164
    tmp___0 = parse_base10((char const   *)version, & min_version);
    }
#line 164
    if (tmp___0) {
#line 165
      max_version = min_version - 1;
    } else {
#line 167
      max_version = min_version;
    }
  } else {
    {
#line 171
    *p = (char )'\000';
#line 172
    tmp___1 = parse_base10((char const   *)version, & min_version);
    }
#line 172
    if (tmp___1) {
#line 174
      max_version = min_version - 1;
    } else {
      {
#line 172
      tmp___2 = parse_base10((char const   *)(p + 1), & max_version);
      }
#line 172
      if (tmp___2) {
#line 174
        max_version = min_version - 1;
      }
    }
  }
#line 176
  if (min_version > max_version) {
    {
#line 178
    parsemsg(3, func, "bad version range: %s", version);
    }
#line 179
    return ((status_e )0);
  }
#line 181
  rdp->rd_min_version = (unsigned long )min_version;
#line 182
  rdp->rd_max_version = (unsigned long )max_version;
#line 183
  return ((status_e )1);
}
}
#line 187 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e rpc_number_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  int num ;
  int tmp ;

  {
  {
#line 193
  tmp = parse_base10((char const   *)((char *)*(values->ptrs + 0U)), & num);
  }
#line 193
  if (tmp) {
    {
#line 194
    parsemsg(3, "rpc_number_parser", "Error parsing: %s", (char *)*(values->ptrs + 0U));
    }
#line 196
    return ((status_e )0);
  }
#line 198
  scp->sc_rd.rd_program_number = (unsigned long )num;
#line 199
  return ((status_e )1);
}
}
#line 203 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e protocol_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *proto_name ;
  struct protoent *pep ;
  char const   *func ;

  {
#line 207
  proto_name = (char *)*(values->ptrs + 0U);
#line 209
  func = "protocol_parser";
#line 211
  if ((unsigned long )proto_name == (unsigned long )((void *)0)) {
    {
#line 212
    parsemsg(3, func, "Protocol name is null in %s", scp->sc_name);
    }
#line 213
    return ((status_e )0);
  }
  {
#line 216
  pep = getprotobyname((char const   *)proto_name);
  }
#line 216
  if ((unsigned long )pep == (unsigned long )((void *)0)) {
    {
#line 218
    parsemsg(3, func, "Protocol %s not in /etc/protocols", proto_name);
    }
#line 220
    return ((status_e )0);
  }
  {
#line 223
  scp->sc_protocol.name = new_string((char const   *)proto_name);
  }
#line 224
  if ((unsigned long )scp->sc_protocol.name == (unsigned long )((void *)0)) {
    {
#line 226
    out_of_memory(func);
    }
#line 227
    return ((status_e )0);
  }
#line 229
  scp->sc_protocol.value = pep->p_proto;
#line 230
  return ((status_e )1);
}
}
#line 234 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e wait_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *val ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 238
  val = (char *)*(values->ptrs + 0U);
#line 239
  func = "wait_parser";
#line 241
  tmp___0 = strcasecmp((char const   *)val, "yes");
  }
#line 241
  if (tmp___0 == 0) {
#line 242
    scp->sc_wait = (boolean_e )1;
  } else {
    {
#line 243
    tmp = strcasecmp((char const   *)val, "no");
    }
#line 243
    if (tmp == 0) {
#line 244
      scp->sc_wait = (boolean_e )0;
    } else {
      {
#line 247
      parsemsg(3, func, "Bad value for wait: %s", val);
      }
#line 248
      return ((status_e )0);
    }
  }
#line 250
  return ((status_e )1);
}
}
#line 274 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e user_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *user ;
  char const   *func ;
  int tmp ;
  struct passwd *pw ;
  bool_int tmp___0 ;

  {
  {
#line 278
  user = (char *)*(values->ptrs + 0U);
#line 279
  func = "user_parser";
#line 281
  tmp___0 = parse_all_digits((char const   *)user);
  }
#line 281
  if (tmp___0 == 1) {
    {
#line 284
    tmp = parse_ubase10((char const   *)user, & scp->sc_uid);
    }
#line 284
    if (tmp) {
      {
#line 286
      parsemsg(3, func, "Error parsing user as a number: %s", user);
      }
#line 287
      return ((status_e )0);
    }
#line 289
    scp->sc_user_gid = scp->sc_uid;
  } else {
    {
#line 295
    pw = getpwnam((char const   *)user);
    }
#line 296
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 298
      parsemsg(3, func, "Unknown user: %s", user);
      }
#line 299
      return ((status_e )0);
    }
    {
#line 301
    str_fill(pw->pw_passwd, (char )' ');
#line 302
    scp->sc_uid = pw->pw_uid;
#line 303
    scp->sc_user_gid = pw->pw_gid;
    }
  }
#line 305
  return ((status_e )1);
}
}
#line 309 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e group_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char const   *func ;
  char *group_ptr ;
  int tmp ;
  struct group *grp ;
  struct group *tmp___0 ;
  bool_int tmp___1 ;

  {
  {
#line 313
  func = "group_parser";
#line 314
  group_ptr = (char *)*(values->ptrs + 0U);
#line 316
  tmp___1 = parse_all_digits((char const   *)group_ptr);
  }
#line 316
  if (tmp___1 == 1) {
    {
#line 319
    tmp = parse_ubase10((char const   *)group_ptr, & scp->sc_gid);
    }
#line 319
    if (tmp) {
      {
#line 321
      parsemsg(3, func, "Error parsing group as a number: %s", group_ptr);
      }
#line 322
      return ((status_e )0);
    }
  } else {
    {
#line 327
    tmp___0 = getgrnam((char const   *)group_ptr);
#line 327
    grp = tmp___0;
    }
#line 328
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
      {
#line 330
      parsemsg(3, func, "Unknown group: %s", group_ptr);
      }
#line 331
      return ((status_e )0);
    }
#line 334
    scp->sc_gid = grp->gr_gid;
  }
#line 336
  return ((status_e )1);
}
}
#line 340 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e svcdisable_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char const   *func ;
  char *val ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 344
  func = "svcdisable_parser";
#line 345
  val = (char *)*(values->ptrs + 0U);
#line 347
  tmp___0 = strcasecmp((char const   *)val, "yes");
  }
#line 347
  if (tmp___0 == 0) {
#line 348
    scp->sc_type |= 1UL << 4;
  } else {
    {
#line 349
    tmp = strcasecmp((char const   *)val, "no");
    }
#line 349
    if (tmp == 0) {
#line 350
      scp->sc_type &= ~ (1UL << 4);
    } else {
      {
#line 353
      parsemsg(3, func, "Bad value: %s", val);
      }
#line 354
      return ((status_e )0);
    }
  }
#line 357
  return ((status_e )1);
}
}
#line 361 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e groups_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *val ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 365
  val = (char *)*(values->ptrs + 0U);
#line 366
  func = "groups_parser";
#line 368
  tmp___0 = strcasecmp((char const   *)val, "yes");
  }
#line 368
  if (tmp___0 == 0) {
#line 369
    scp->sc_groups = (boolean_e )1;
  } else {
    {
#line 370
    tmp = strcasecmp((char const   *)val, "no");
    }
#line 370
    if (tmp == 0) {
#line 371
      scp->sc_groups = (boolean_e )0;
    } else {
      {
#line 374
      parsemsg(3, func, "Bad value for groups: %s", val);
      }
#line 375
      return ((status_e )0);
    }
  }
#line 378
  return ((status_e )1);
}
}
#line 382 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e v6only_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *val ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 386
  val = (char *)*(values->ptrs + 0U);
#line 387
  func = "v6only_parser";
#line 389
  tmp___0 = strcasecmp((char const   *)val, "yes");
  }
#line 389
  if (tmp___0 == 0) {
#line 390
    scp->sc_v6only = (boolean_e )1;
  } else {
    {
#line 391
    tmp = strcasecmp((char const   *)val, "no");
    }
#line 391
    if (tmp == 0) {
#line 392
      scp->sc_v6only = (boolean_e )0;
    } else {
      {
#line 395
      parsemsg(3, func, "Bad value for v6only: %s", val);
      }
#line 396
      return ((status_e )0);
    }
  }
#line 398
  return ((status_e )1);
}
}
#line 402 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e server_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *server ;
  char const   *func ;
  struct stat sb ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 406
  server = (char *)*(values->ptrs + 0U);
#line 407
  func = "server_parser";
#line 414
  tmp = access((char const   *)server, 1);
  }
#line 414
  if (tmp == -1) {
    {
#line 416
    parsemsg(3, func, "Server %s is not executable", server);
    }
#line 417
    return ((status_e )0);
  }
  {
#line 419
  tmp___0 = stat((char const   */* __restrict  */)server, (struct stat */* __restrict  */)(& sb));
  }
#line 419
  if (tmp___0 == -1) {
    {
#line 421
    parsemsg(3, func, "Unable to stat: %s.", server);
    }
#line 422
    return ((status_e )0);
  }
  {
#line 425
  scp->sc_server = new_string((char const   *)server);
  }
#line 426
  if ((unsigned long )scp->sc_server == (unsigned long )((void *)0)) {
    {
#line 428
    out_of_memory(func);
    }
#line 429
    return ((status_e )0);
  }
#line 431
  return ((status_e )1);
}
}
#line 435 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e server_args_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char **argv ;
  unsigned int u ;
  unsigned int i ;
  unsigned int count ;
  unsigned int argv_index ;
  unsigned int n_args ;
  char const   *func ;
  register char *s ;
  char *tmp ;
  register char *s___0 ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 444
  n_args = values->count;
#line 445
  func = "server_args_parser";
#line 452
  argv = argv_alloc(n_args + 1U);
#line 453
  count = values->count;
  }
#line 454
  if (count == 0U) {
    {
#line 456
    missing_attr_msg("server_args_parser", "server_args");
#line 457
    free((void *)((char *)argv));
    }
#line 458
    return ((status_e )0);
  }
#line 461
  if (scp->sc_xflags & (1UL << 4)) {
#line 463
    u = 0U;
    {
#line 463
    while (1) {
      while_continue: /* CIL Label */ ;
#line 463
      if (! (u < count)) {
#line 463
        goto while_break;
      }
      {
#line 465
      tmp = new_string((char const   *)((char *)*(values->ptrs + u)));
#line 465
      s = tmp;
      }
#line 467
      if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 469
        i = 1U;
        {
#line 469
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 469
          if (! (i < u)) {
#line 469
            goto while_break___0;
          }
          {
#line 470
          free((void *)*(argv + i));
#line 469
          i ++;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 471
        free((void *)((char *)argv));
#line 472
        out_of_memory(func);
        }
#line 473
        return ((status_e )0);
      }
#line 475
      *(argv + u) = s;
#line 463
      u ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 480
    u = 0U;
#line 480
    argv_index = 1U;
    {
#line 480
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 480
      if (! (u < count)) {
#line 480
        goto while_break___1;
      }
      {
#line 482
      tmp___0 = new_string((char const   *)((char *)*(values->ptrs + u)));
#line 482
      s___0 = tmp___0;
      }
#line 484
      if ((unsigned long )s___0 == (unsigned long )((void *)0)) {
#line 486
        i = 1U;
        {
#line 486
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 486
          if (! (i < argv_index)) {
#line 486
            goto while_break___2;
          }
          {
#line 487
          free((void *)*(argv + i));
#line 486
          i ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 488
        free((void *)((char *)argv));
#line 489
        out_of_memory(func);
        }
#line 490
        return ((status_e )0);
      }
#line 492
      *(argv + argv_index) = s___0;
#line 480
      u ++;
#line 480
      argv_index ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 494
    tmp___1 = (char *)((void *)0);
#line 494
    *(argv + 0) = tmp___1;
#line 494
    *(argv + argv_index) = tmp___1;
  }
#line 496
  scp->sc_server_argv = argv;
#line 497
  return ((status_e )1);
}
}
#line 501 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e instances_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *instances ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 505
  instances = (char *)*(values->ptrs + 0U);
#line 506
  func = "instances_parser";
#line 508
  tmp___0 = strcasecmp((char const   *)instances, "UNLIMITED");
  }
#line 508
  if (tmp___0 == 0) {
#line 509
    scp->sc_instances = -1;
  } else {
    {
#line 512
    tmp = parse_base10((char const   *)instances, & scp->sc_instances);
    }
#line 512
    if (tmp) {
      {
#line 515
      parsemsg(3, func, "Number of instances is invalid: %s", instances);
      }
#line 517
      return ((status_e )0);
    } else
#line 512
    if (scp->sc_instances < 0) {
      {
#line 515
      parsemsg(3, func, "Number of instances is invalid: %s", instances);
      }
#line 517
      return ((status_e )0);
    }
  }
#line 520
  return ((status_e )1);
}
}
#line 524 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e per_source_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *per_source ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 528
  per_source = (char *)*(values->ptrs + 0U);
#line 529
  func = "per_source_parser";
#line 531
  tmp___0 = strcasecmp((char const   *)per_source, "UNLIMITED");
  }
#line 531
  if (tmp___0 == 0) {
#line 532
    scp->sc_per_source = -1;
  } else {
    {
#line 535
    tmp = parse_base10((char const   *)per_source, & scp->sc_per_source);
    }
#line 535
    if (tmp) {
      {
#line 538
      parsemsg(3, func, "Number of per source instances is invalid: %s", per_source);
      }
#line 539
      return ((status_e )0);
    } else
#line 535
    if (scp->sc_per_source < 0) {
      {
#line 538
      parsemsg(3, func, "Number of per source instances is invalid: %s", per_source);
      }
#line 539
      return ((status_e )0);
    }
  }
#line 542
  return ((status_e )1);
}
}
#line 546 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e cps_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *cps ;
  char *waittime ;
  unsigned int waittime_int ;
  unsigned int conn_max ;
  int tmp ;
  int tmp___0 ;

  {
#line 550
  cps = (char *)*(values->ptrs + 0U);
#line 551
  waittime = (char *)*(values->ptrs + 1U);
#line 554
  if ((unsigned long )cps == (unsigned long )((void *)0)) {
    {
#line 555
    parsemsg(3, "cps_parser", "NULL options specified in cps");
    }
#line 556
    return ((status_e )0);
  } else
#line 554
  if ((unsigned long )waittime == (unsigned long )((void *)0)) {
    {
#line 555
    parsemsg(3, "cps_parser", "NULL options specified in cps");
    }
#line 556
    return ((status_e )0);
  }
  {
#line 558
  tmp = parse_ubase10((char const   *)cps, & conn_max);
  }
#line 558
  if (tmp) {
    {
#line 559
    parsemsg(3, "cps_parser", "cps argument not a number");
#line 560
    scp->sc_time_conn_max = (time_t )0;
#line 561
    scp->sc_time_wait = (time_t )0;
    }
#line 562
    return ((status_e )0);
  }
  {
#line 564
  tmp___0 = parse_ubase10((char const   *)waittime, & waittime_int);
  }
#line 564
  if (tmp___0) {
    {
#line 565
    parsemsg(3, "cps_parser", "cps time argument not a number");
#line 566
    scp->sc_time_conn_max = (time_t )0;
#line 567
    scp->sc_time_wait = (time_t )0;
    }
#line 568
    return ((status_e )0);
  }
#line 570
  scp->sc_time_wait = (time_t )waittime_int;
#line 571
  scp->sc_time_conn_max = (time_t )conn_max;
#line 573
  if (scp->sc_time_conn_max < 0L) {
    {
#line 574
    parsemsg(3, "cps_parser", "cps arguments invalid");
#line 575
    scp->sc_time_conn_max = (time_t )0;
#line 576
    scp->sc_time_wait = (time_t )0;
    }
#line 577
    return ((status_e )0);
  } else
#line 573
  if (scp->sc_time_wait < 0L) {
    {
#line 574
    parsemsg(3, "cps_parser", "cps arguments invalid");
#line 575
    scp->sc_time_conn_max = (time_t )0;
#line 576
    scp->sc_time_wait = (time_t )0;
    }
#line 577
    return ((status_e )0);
  }
#line 580
  return ((status_e )1);
}
}
#line 583 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e id_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char const   *func ;

  {
  {
#line 587
  func = "id_parser";
#line 589
  scp->sc_id = new_string((char const   *)((char *)*(values->ptrs + 0U)));
  }
#line 590
  if ((unsigned long )scp->sc_id != (unsigned long )((void *)0)) {
#line 591
    return ((status_e )1);
  }
  {
#line 592
  out_of_memory(func);
  }
#line 593
  return ((status_e )0);
}
}
#line 601 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e port_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  int port ;
  char const   *func ;
  int tmp ;

  {
  {
#line 606
  func = "port_parser";
#line 608
  tmp = parse_base10((char const   *)((char *)*(values->ptrs + 0U)), & port);
  }
#line 608
  if (tmp) {
    {
#line 611
    parsemsg(3, func, "port number is invalid");
    }
#line 612
    return ((status_e )0);
  } else
#line 608
  if (port < 0) {
    {
#line 611
    parsemsg(3, func, "port number is invalid");
    }
#line 612
    return ((status_e )0);
  } else
#line 608
  if (port >= 1 << 16) {
    {
#line 611
    parsemsg(3, func, "port number is invalid");
    }
#line 612
    return ((status_e )0);
  }
#line 614
  scp->sc_port = (uint16_t )port;
#line 615
  return ((status_e )1);
}
}
#line 619 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
static status_e add_new_string(pset_h set , char *str ) 
{ 
  char *p ;
  char *tmp ;
  char const   *func ;
  __pset_pointer tmp___0 ;

  {
  {
#line 621
  tmp = new_string((char const   *)str);
#line 621
  p = tmp;
#line 622
  func = "add_new_string";
  }
#line 624
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 626
    parsemsg(2, func, "out of memory");
    }
#line 627
    return ((status_e )0);
  }
  {
#line 629
  tmp___0 = pset_add(set, (__pset_pointer const   )p);
  }
#line 629
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 631
    free((void *)p);
#line 632
    parsemsg(2, func, "out of memory");
    }
#line 633
    return ((status_e )0);
  }
#line 635
  return ((status_e )1);
}
}
#line 639 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e env_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  unsigned int u ;
  char const   *func ;
  pset_h tmp ;
  char *str ;
  char *tmp___0 ;
  status_e tmp___1 ;

  {
#line 644
  func = "env_parser";
#line 646
  if ((unsigned int )op == 2U) {
    {
#line 648
    parsemsg(4, func, "operator \'-=\' not supported for env attribute");
    }
#line 650
    return ((status_e )0);
  }
#line 653
  if ((unsigned long )scp->sc_env_var_defs == (unsigned long )((void *)0)) {
    {
#line 653
    tmp = pset_create(5U, 5U);
#line 653
    scp->sc_env_var_defs = tmp;
    }
#line 653
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 653
      out_of_memory(func);
      }
#line 653
      return ((status_e )0);
    }
  }
#line 655
  if ((unsigned int )op == 0U) {
#line 655
    if ((scp->sc_env_var_defs)->count != 0U) {
      {
#line 657
      pset_apply(scp->sc_env_var_defs, (void (*)())(& free), (void *)0);
#line 658
      (scp->sc_env_var_defs)->count = 0U;
      }
    }
  }
#line 661
  u = 0U;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (u < values->count)) {
#line 661
      goto while_break;
    }
    {
#line 663
    str = (char *)*(values->ptrs + u);
#line 668
    tmp___0 = strchr((char const   *)str, '=');
    }
#line 668
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 670
      parsemsg(3, func, "%s has no \'=\'", str);
      }
#line 671
      return ((status_e )0);
    }
    {
#line 674
    tmp___1 = add_new_string(scp->sc_env_var_defs, str);
    }
#line 674
    if ((unsigned int )tmp___1 == 0U) {
#line 675
      return ((status_e )0);
    }
#line 661
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 677
  return ((status_e )1);
}
}
#line 681 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e passenv_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  pset_h var_set ;
  unsigned int u ;
  char const   *func ;
  pset_h tmp ;
  char *env_var ;
  unsigned int v ;
  boolean_e found ;
  int tmp___0 ;
  char *tmp___1 ;
  status_e tmp___2 ;

  {
#line 687
  func = "passenv_parser";
#line 689
  if ((unsigned long )scp->sc_pass_env_vars == (unsigned long )((void *)0)) {
    {
#line 689
    tmp = pset_create(0U, 0U);
#line 689
    scp->sc_pass_env_vars = tmp;
    }
#line 689
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 689
      out_of_memory(func);
      }
#line 689
      return ((status_e )0);
    }
  }
#line 691
  var_set = scp->sc_pass_env_vars;
#line 693
  if ((unsigned int )op == 0U) {
    {
#line 695
    pset_apply(var_set, (void (*)())(& free), (void *)0);
#line 696
    var_set->count = 0U;
#line 697
    op = (enum assign_op )1;
    }
  }
#line 700
  u = 0U;
  {
#line 700
  while (1) {
    while_continue: /* CIL Label */ ;
#line 700
    if (! (u < values->count)) {
#line 700
      goto while_break;
    }
#line 702
    env_var = (char *)*(values->ptrs + u);
#line 709
    found = (boolean_e )0;
#line 709
    v = 0U;
    {
#line 709
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 709
      if (! (v < var_set->count)) {
#line 709
        goto while_break___0;
      }
      {
#line 710
      tmp___0 = strcasecmp((char const   *)env_var, (char const   *)((char *)*(var_set->ptrs + v)));
      }
#line 710
      if (tmp___0 == 0) {
#line 712
        found = (boolean_e )1;
#line 713
        goto while_break___0;
      }
#line 709
      v ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 716
    if ((unsigned int )op == 2U) {
#line 716
      if ((unsigned int )found == 0U) {
#line 717
        goto __Cont;
      } else {
#line 716
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 716
    if ((unsigned int )op != 2U) {
#line 716
      if ((unsigned int )found == 1U) {
#line 717
        goto __Cont;
      }
    }
#line 719
    if ((unsigned int )op == 2U) {
      {
#line 721
      free((void *)((char *)*(var_set->ptrs + v)));
      }
#line 722
      if (v < var_set->count) {
        {
#line 722
        pset_delete(var_set, (__pset_pointer const   )*(var_set->ptrs + v));
        }
      }
    } else {
      {
#line 726
      tmp___1 = env_lookup(std_env, (char const   *)env_var);
      }
#line 726
      if ((unsigned long )tmp___1 == (unsigned long )((char *)0)) {
        {
#line 728
        parsemsg(4, func, "undefined environment variable: %s", env_var);
        }
#line 730
        goto __Cont;
      }
      {
#line 733
      tmp___2 = add_new_string(var_set, env_var);
      }
#line 733
      if ((unsigned int )tmp___2 == 0U) {
#line 734
        return ((status_e )0);
      }
    }
    __Cont: /* CIL Label */ 
#line 700
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  return ((status_e )1);
}
}
#line 741 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e disabled_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  unsigned int u ;
  char const   *func ;
  pset_h tmp ;
  char *name___0 ;
  status_e tmp___0 ;

  {
#line 746
  func = "disabled_parser";
#line 748
  if ((unsigned long )scp->sc_disabled == (unsigned long )((void *)0)) {
    {
#line 748
    tmp = pset_create(values->count, 0U);
#line 748
    scp->sc_disabled = tmp;
    }
#line 748
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 748
      out_of_memory(func);
      }
#line 748
      return ((status_e )0);
    }
  }
#line 750
  u = 0U;
  {
#line 750
  while (1) {
    while_continue: /* CIL Label */ ;
#line 750
    if (! (u < values->count)) {
#line 750
      goto while_break;
    }
    {
#line 752
    name___0 = (char *)*(values->ptrs + u);
#line 754
    tmp___0 = add_new_string(scp->sc_disabled, name___0);
    }
#line 754
    if ((unsigned int )tmp___0 == 0U) {
#line 755
      return ((status_e )0);
    }
#line 750
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 757
  return ((status_e )1);
}
}
#line 761 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e enabled_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  unsigned int u ;
  char const   *func ;
  pset_h tmp ;
  char *name___0 ;
  status_e tmp___0 ;

  {
#line 766
  func = "enabled_parser";
#line 768
  if ((unsigned long )scp->sc_enabled == (unsigned long )((void *)0)) {
    {
#line 768
    tmp = pset_create(values->count, 0U);
#line 768
    scp->sc_enabled = tmp;
    }
#line 768
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 768
      out_of_memory(func);
      }
#line 768
      return ((status_e )0);
    }
  }
#line 770
  u = 0U;
  {
#line 770
  while (1) {
    while_continue: /* CIL Label */ ;
#line 770
    if (! (u < values->count)) {
#line 770
      goto while_break;
    }
    {
#line 772
    name___0 = (char *)*(values->ptrs + u);
#line 774
    tmp___0 = add_new_string(scp->sc_enabled, name___0);
    }
#line 774
    if ((unsigned int )tmp___0 == 0U) {
#line 775
      return ((status_e )0);
    }
#line 770
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 777
  return ((status_e )1);
}
}
#line 784 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
static int get_limit(char *limit_str , rlim_t *res ) 
{ 
  unsigned long long limit_int ;
  int multiplier ;
  char *p ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;

  {
#line 790
  if ((int )*limit_str == 0) {
#line 791
    *res = (rlim_t )0;
#line 792
    return (-1);
  }
  {
#line 795
  tmp = strlen((char const   *)limit_str);
#line 795
  p = (limit_str + tmp) - 1;
  }
  {
#line 796
  while (1) {
    while_continue: /* CIL Label */ ;
#line 796
    if ((unsigned long )p > (unsigned long )limit_str) {
      {
#line 796
      tmp___0 = __ctype_b_loc();
      }
#line 796
      if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 796
        goto while_break;
      }
    } else {
#line 796
      goto while_break;
    }
#line 797
    p --;
  }
  while_break: /* CIL Label */ ;
  }
#line 799
  if ((int )*p == 107) {
#line 800
    *p = (char )'\000';
#line 801
    multiplier = 1024;
  } else
#line 799
  if ((int )*p == 75) {
#line 800
    *p = (char )'\000';
#line 801
    multiplier = 1024;
  } else
#line 802
  if ((int )*p == 109) {
#line 803
    *p = (char )'\000';
#line 804
    multiplier = 1048576;
  } else
#line 802
  if ((int )*p == 77) {
#line 803
    *p = (char )'\000';
#line 804
    multiplier = 1048576;
  } else {
#line 806
    multiplier = 1;
  }
  {
#line 808
  tmp___1 = parse_ull((char const   *)limit_str, 10, -1, & limit_int);
  }
#line 808
  if (tmp___1) {
#line 809
    *res = (rlim_t )0;
#line 810
    return (-1);
  }
#line 813
  *res = (rlim_t )limit_int;
#line 814
  if ((unsigned long long )*res != limit_int) {
#line 815
    *res = (rlim_t )0;
#line 816
    return (-1);
  }
#line 819
  *res = (rlim_t )limit_int * (rlim_t )multiplier;
#line 820
  if (*res / (rlim_t )multiplier != (rlim_t )limit_int) {
#line 821
    *res = (rlim_t )0;
#line 822
    return (-1);
  }
#line 825
  return (0);
}
}
#line 829 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
static status_e parse_filelog(struct filelog *flp , pset_h values ) 
{ 
  rlim_t soft_limit ;
  rlim_t hard_limit ;
  char *file ;
  unsigned int count ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;
  unsigned int extra ;

  {
#line 834
  count = values->count;
#line 835
  func = "parse_filelog";
#line 837
  if (count < 2U) {
    {
#line 839
    parsemsg(3, func, "wrong number of arguments");
    }
#line 840
    return ((status_e )0);
  } else
#line 837
  if (count > 4U) {
    {
#line 839
    parsemsg(3, func, "wrong number of arguments");
    }
#line 840
    return ((status_e )0);
  }
  {
#line 843
  file = new_string((char const   *)((char *)*(values->ptrs + 1U)));
  }
#line 844
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 846
    out_of_memory(func);
    }
#line 847
    return ((status_e )0);
  }
#line 853
  if (count > 2U) {
    {
#line 855
    tmp = get_limit((char *)*(values->ptrs + 2U), & soft_limit);
    }
#line 855
    if (tmp) {
      {
#line 857
      parsemsg(3, func, "soft limit is invalid");
#line 858
      free((void *)file);
      }
#line 859
      return ((status_e )0);
    }
#line 870
    if (count == 4U) {
      {
#line 872
      tmp___0 = get_limit((char *)*(values->ptrs + 3U), & hard_limit);
      }
#line 872
      if (tmp___0) {
        {
#line 874
        parsemsg(3, func, "hard limit is invalid");
#line 875
        free((void *)file);
        }
#line 876
        return ((status_e )0);
      }
#line 878
      if (hard_limit < soft_limit) {
        {
#line 880
        parsemsg(3, func, "hard limit (%lu) is less than soft limit (%lu)", hard_limit,
                 soft_limit);
#line 883
        free((void *)file);
        }
#line 884
        return ((status_e )0);
      }
    } else {
#line 889
      extra = (unsigned int )(soft_limit / 100UL);
#line 891
      if (extra < 5120U) {
#line 892
        extra = 5120U;
      } else
#line 893
      if (extra > 20480U) {
#line 894
        extra = 20480U;
      }
#line 895
      hard_limit = soft_limit + (rlim_t )extra;
    }
#line 897
    flp->fl_soft_limit = (unsigned int )soft_limit;
#line 898
    flp->fl_hard_limit = (unsigned int )hard_limit;
  }
#line 900
  flp->fl_filename = file;
#line 901
  return ((status_e )1);
}
}
#line 905 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
static status_e parse_syslog(struct syslog *slp , pset_h values ) 
{ 
  char const   *facility ;
  char const   *level ;
  struct name_value  const  *nvp ;
  unsigned int count ;
  char const   *func ;

  {
#line 910
  count = values->count;
#line 911
  func = "parse_syslog";
#line 913
  if (count < 2U) {
    {
#line 915
    parsemsg(3, func, "wrong number of arguments");
    }
#line 916
    return ((status_e )0);
  } else
#line 913
  if (count > 3U) {
    {
#line 915
    parsemsg(3, func, "wrong number of arguments");
    }
#line 916
    return ((status_e )0);
  }
  {
#line 919
  facility = (char const   *)((char *)*(values->ptrs + 1U));
#line 920
  nvp = nv_find_value(syslog_facilities, facility);
  }
#line 920
  if ((unsigned long )nvp == (unsigned long )((void *)0)) {
    {
#line 922
    parsemsg(3, func, "Unknown syslog facility: %s", facility);
    }
#line 923
    return ((status_e )0);
  }
#line 925
  slp->sl_facility = (int )nvp->value;
#line 927
  if (count == 3U) {
    {
#line 929
    level = (char const   *)((char *)*(values->ptrs + 2U));
#line 930
    nvp = nv_find_value(syslog_levels, level);
    }
#line 930
    if ((unsigned long )nvp == (unsigned long )((void *)0)) {
      {
#line 932
      parsemsg(3, func, "Unknown syslog level: %s", level);
      }
#line 933
      return ((status_e )0);
    }
#line 935
    slp->sl_level = (int )nvp->value;
  } else {
#line 938
    slp->sl_level = 6;
  }
#line 940
  return ((status_e )1);
}
}
#line 944 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e log_type_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  struct log *lp ;
  char *type ;
  char const   *func ;
  int count ;
  status_e tmp ;
  status_e tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 948
  lp = & scp->sc_log;
#line 950
  func = "parse_log_type";
#line 951
  count = (int )values->count;
#line 953
  if (count == 0) {
    {
#line 955
    missing_attr_msg(func, "log_type");
    }
#line 956
    return ((status_e )0);
  }
  {
#line 959
  type = (char *)*(values->ptrs + 0U);
#line 961
  tmp___2 = strcasecmp((char const   *)type, "FILE");
  }
#line 961
  if (tmp___2 == 0) {
    {
#line 963
    tmp = parse_filelog(& lp->l_fl, values);
    }
#line 963
    if ((unsigned int )tmp == 0U) {
#line 964
      return ((status_e )0);
    }
#line 965
    lp->l_type = (logtype_e )1;
  } else {
    {
#line 967
    tmp___1 = strcasecmp((char const   *)type, "SYSLOG");
    }
#line 967
    if (tmp___1 == 0) {
      {
#line 969
      tmp___0 = parse_syslog(& lp->l_sl, values);
      }
#line 969
      if ((unsigned int )tmp___0 == 0U) {
#line 970
        return ((status_e )0);
      }
#line 971
      lp->l_type = (logtype_e )2;
    } else {
      {
#line 975
      parsemsg(3, func, "Unknown log type: %s", type);
      }
#line 976
      return ((status_e )0);
    }
  }
#line 978
  return ((status_e )1);
}
}
#line 982 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
static status_e parse_log_flags(pset_h values , enum assign_op op , mask_t *maskp ,
                                struct name_value  const  *options , char const   *name___0 ) 
{ 
  status_e tmp ;

  {
#line 988
  if ((unsigned int )op == 0U) {
#line 990
    *maskp = (mask_t )0;
#line 991
    op = (enum assign_op )1;
  }
  {
#line 994
  tmp = parse_value_list(values, maskp, options, op, name___0);
  }
#line 994
  return (tmp);
}
}
#line 998 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e log_on_success_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  status_e tmp ;

  {
  {
#line 1002
  tmp = parse_log_flags(values, op, & scp->sc_log_on_success, success_log_options,
                        "log_on_success flag");
  }
#line 1002
  return (tmp);
}
}
#line 1007 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e log_on_failure_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  status_e tmp ;

  {
  {
#line 1011
  tmp = parse_log_flags(values, op, & scp->sc_log_on_failure, failure_log_options,
                        "log_on_failure flag");
  }
#line 1011
  return (tmp);
}
}
#line 1016 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
static status_e parse_inet_addresses(pset_h values , enum assign_op op , pset_h *addr_list ) 
{ 
  unsigned int u ;
  pset_h addr_set ;
  status_e (*addrlist_func)() ;
  char const   *func ;
  pset_h tmp ;
  register char *str_addr ;
  char *tmp___0 ;
  char *tmp___1 ;
  status_e tmp___2 ;

  {
#line 1023
  func = "parse_inet_addresses";
#line 1025
  if ((unsigned long )*addr_list == (unsigned long )((void *)0)) {
    {
#line 1025
    tmp = pset_create(0U, 0U);
#line 1025
    *addr_list = tmp;
    }
#line 1025
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 1025
      out_of_memory(func);
      }
#line 1025
      return ((status_e )0);
    }
  }
#line 1027
  addr_set = *addr_list;
#line 1032
  if ((unsigned int )op == 0U) {
    {
#line 1034
    op = (enum assign_op )1;
#line 1035
    addrlist_free(addr_set);
#line 1036
    addr_set->count = 0U;
    }
  }
#line 1039
  if ((unsigned int )op == 1U) {
#line 1039
    addrlist_func = (status_e (*)())(& addrlist_add);
  } else {
#line 1039
    addrlist_func = (status_e (*)())(& addrlist_remove);
  }
#line 1041
  u = 0U;
  {
#line 1041
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1041
    if (! (u < values->count)) {
#line 1041
      goto while_break;
    }
    {
#line 1043
    str_addr = (char *)*(values->ptrs + u);
#line 1046
    tmp___0 = strchr((char const   *)str_addr, ',');
    }
#line 1046
    if (tmp___0) {
      {
#line 1046
      tmp___1 = strchr((char const   *)str_addr, '{');
      }
#line 1046
      if (! tmp___1) {
        {
#line 1048
        parsemsg(3, func, "Address: %s has a comma in it - remove the comma", str_addr);
        }
#line 1051
        return ((status_e )0);
      }
    }
    {
#line 1054
    tmp___2 = (*addrlist_func)(addr_set, str_addr);
    }
#line 1054
    if ((unsigned int )tmp___2 == 0U) {
      {
#line 1056
      parsemsg(3, func, "Failed adding: %s", str_addr);
      }
#line 1057
      return ((status_e )0);
    }
#line 1041
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1060
  return ((status_e )1);
}
}
#line 1064 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e only_from_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  status_e tmp ;

  {
  {
#line 1068
  tmp = parse_inet_addresses(values, op, & scp->sc_only_from);
  }
#line 1068
  return (tmp);
}
}
#line 1072 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e no_access_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  status_e tmp ;

  {
  {
#line 1076
  tmp = parse_inet_addresses(values, op, & scp->sc_no_access);
  }
#line 1076
  return (tmp);
}
}
#line 1080 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e banner_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char const   *func ;

  {
#line 1084
  func = "banner_parser";
#line 1086
  if ((unsigned long )*(values->ptrs + 0U) == (unsigned long )((void *)0)) {
    {
#line 1088
    msg(3, func, "pset_pointer returned NULL");
    }
#line 1089
    return ((status_e )0);
  }
  {
#line 1092
  scp->sc_banner = new_string((char const   *)*(values->ptrs + 0U));
  }
#line 1093
  if ((unsigned long )scp->sc_banner == (unsigned long )((void *)0)) {
    {
#line 1094
    msg(3, func, "out of memory");
    }
#line 1095
    return ((status_e )0);
  }
#line 1098
  return ((status_e )1);
}
}
#line 1101 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e banner_success_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char const   *func ;

  {
#line 1105
  func = "banner_success_parser";
#line 1107
  if ((unsigned long )*(values->ptrs + 0U) == (unsigned long )((void *)0)) {
    {
#line 1108
    msg(3, func, "pset_pointer returned NULL");
    }
#line 1109
    return ((status_e )0);
  }
  {
#line 1112
  scp->sc_banner_success = new_string((char const   *)*(values->ptrs + 0U));
  }
#line 1113
  if ((unsigned long )scp->sc_banner_success == (unsigned long )((void *)0)) {
    {
#line 1114
    msg(3, func, "out of memory");
    }
#line 1115
    return ((status_e )0);
  }
#line 1118
  return ((status_e )1);
}
}
#line 1121 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e banner_fail_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char const   *func ;

  {
#line 1125
  func = "banner_fail_parser";
#line 1127
  if ((unsigned long )*(values->ptrs + 0U) == (unsigned long )((void *)0)) {
    {
#line 1128
    msg(3, func, "pset_pointer returned NULL");
    }
#line 1129
    return ((status_e )0);
  }
  {
#line 1132
  scp->sc_banner_fail = new_string((char const   *)*(values->ptrs + 0U));
  }
#line 1133
  if ((unsigned long )scp->sc_banner_fail == (unsigned long )((void *)0)) {
    {
#line 1134
    msg(3, func, "out of memory");
    }
#line 1135
    return ((status_e )0);
  }
#line 1138
  return ((status_e )1);
}
}
#line 1163 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e redir_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *adr ;
  char const   *func ;
  char *port_char ;
  int port_int ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct servent *entry ;
  uint16_t tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 1167
  adr = (char *)*(values->ptrs + 0U);
#line 1168
  func = "redir_parser";
#line 1173
  port_char = (char *)*(values->ptrs + 1U);
#line 1174
  tmp___0 = parse_base10((char const   *)port_char, & port_int);
  }
#line 1174
  if (tmp___0) {
#line 1174
    goto _L;
  } else
#line 1174
  if (port_int <= 0) {
    _L: /* CIL Label */ 
    {
#line 1177
    entry = getservbyname((char const   *)port_char, "tcp");
    }
#line 1178
    if ((unsigned long )entry == (unsigned long )((struct servent *)0)) {
      {
#line 1180
      parsemsg(3, func, "port number invalid");
      }
#line 1181
      return ((status_e )0);
    }
    {
#line 1183
    tmp = ntohs((uint16_t )entry->s_port);
#line 1183
    port_int = (int )tmp;
    }
  }
#line 1185
  if (port_int >= 1 << 16) {
    {
#line 1187
    parsemsg(3, func, "port number too large");
    }
#line 1188
    return ((status_e )0);
  }
  {
#line 1191
  tmp___1 = malloc(sizeof(union xsockaddr ));
#line 1191
  scp->sc_redir_addr = (union xsockaddr *)tmp___1;
  }
#line 1192
  if ((unsigned long )scp->sc_redir_addr == (unsigned long )((void *)0)) {
    {
#line 1194
    parsemsg(3, func, "can\'t allocate space for redir addr");
    }
#line 1195
    return ((status_e )0);
  }
  {
#line 1198
  memset((void *)(& hints), 0, sizeof(hints));
#line 1199
  hints.ai_flags = 2;
#line 1200
  hints.ai_socktype = 1;
#line 1201
  tmp___2 = strchr((char const   *)adr, ':');
  }
#line 1201
  if (tmp___2) {
#line 1202
    hints.ai_family = 10;
  } else {
#line 1204
    hints.ai_family = 2;
  }
  {
#line 1206
  tmp___3 = getaddrinfo((char const   */* __restrict  */)adr, (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 1206
  if (tmp___3 < 0) {
    {
#line 1207
    parsemsg(3, func, "bad address");
#line 1208
    free((void *)scp->sc_redir_addr);
#line 1209
    scp->sc_redir_addr = (union xsockaddr *)((void *)0);
    }
#line 1210
    return ((status_e )0);
  }
#line 1213
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 1214
    parsemsg(3, func, "no addresses returned");
#line 1215
    free((void *)scp->sc_redir_addr);
#line 1216
    scp->sc_redir_addr = (union xsockaddr *)((void *)0);
    }
#line 1217
    return ((status_e )0);
  } else
#line 1213
  if ((unsigned long )res->ai_addr == (unsigned long )((void *)0)) {
    {
#line 1214
    parsemsg(3, func, "no addresses returned");
#line 1215
    free((void *)scp->sc_redir_addr);
#line 1216
    scp->sc_redir_addr = (union xsockaddr *)((void *)0);
    }
#line 1217
    return ((status_e )0);
  }
#line 1220
  if (res->ai_family == 2) {
    {
#line 1221
    memcpy((void */* __restrict  */)scp->sc_redir_addr, (void const   */* __restrict  */)res->ai_addr,
           (size_t )res->ai_addrlen);
    }
  } else
#line 1220
  if (res->ai_family == 10) {
    {
#line 1221
    memcpy((void */* __restrict  */)scp->sc_redir_addr, (void const   */* __restrict  */)res->ai_addr,
           (size_t )res->ai_addrlen);
    }
  }
#line 1222
  if ((int )(scp->sc_redir_addr)->sa.sa_family == 2) {
#line 1223
    (scp->sc_redir_addr)->sa_in.sin_port = (in_port_t )port_int;
  }
#line 1224
  if ((int )(scp->sc_redir_addr)->sa.sa_family == 10) {
#line 1225
    (scp->sc_redir_addr)->sa_in6.sin6_port = (in_port_t )port_int;
  }
  {
#line 1227
  freeaddrinfo(res);
  }
#line 1228
  return ((status_e )1);
}
}
#line 1231 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e bind_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *adr ;
  char const   *func ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct addrinfo *ressave ;
  int addr_cnt ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 1235
  adr = (char *)*(values->ptrs + 0U);
#line 1236
  func = "bind_parser";
#line 1238
  addr_cnt = 0;
#line 1240
  memset((void *)(& hints), 0, sizeof(hints));
#line 1241
  hints.ai_flags = 2;
#line 1247
  hints.ai_socktype = 1;
#line 1249
  tmp___0 = check_hostname((char const   *)adr);
  }
#line 1249
  if (tmp___0 == 0) {
#line 1251
    hints.ai_family = 2;
#line 1252
    hints.ai_flags |= 4;
  } else {
    {
#line 1254
    tmp = strchr((char const   *)adr, ':');
    }
#line 1254
    if (tmp) {
#line 1256
      hints.ai_family = 10;
#line 1257
      hints.ai_flags |= 4;
    } else {
#line 1261
      hints.ai_family = 0;
    }
  }
  {
#line 1264
  tmp___1 = getaddrinfo((char const   */* __restrict  */)adr, (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 1264
  if (tmp___1 < 0) {
    {
#line 1265
    parsemsg(3, func, "bad address");
    }
#line 1266
    return ((status_e )0);
  }
#line 1269
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 1270
    parsemsg(3, func, "no addresses returned");
    }
#line 1271
    return ((status_e )0);
  } else
#line 1269
  if ((unsigned long )res->ai_addr == (unsigned long )((void *)0)) {
    {
#line 1270
    parsemsg(3, func, "no addresses returned");
    }
#line 1271
    return ((status_e )0);
  }
#line 1279
  ressave = res;
  {
#line 1280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1280
    if (! res) {
#line 1280
      goto while_break;
    }
#line 1282
    addr_cnt ++;
#line 1283
    res = res->ai_next;
  }
  while_break: /* CIL Label */ ;
  }
#line 1285
  res = ressave;
#line 1287
  if (addr_cnt == 1) {
    {
#line 1289
    tmp___2 = malloc(sizeof(union xsockaddr ));
#line 1289
    scp->sc_bind_addr = (union xsockaddr *)tmp___2;
    }
#line 1290
    if ((unsigned long )scp->sc_bind_addr == (unsigned long )((void *)0)) {
      {
#line 1292
      parsemsg(3, func, "can\'t allocate space for bind addr");
      }
#line 1293
      return ((status_e )0);
    }
    {
#line 1295
    memcpy((void */* __restrict  */)scp->sc_bind_addr, (void const   */* __restrict  */)res->ai_addr,
           (size_t )res->ai_addrlen);
    }
  } else {
    {
#line 1298
    scp->sc_orig_bind_addr = new_string((char const   *)adr);
    }
  }
  {
#line 1300
  freeaddrinfo(res);
  }
#line 1301
  return ((status_e )1);
}
}
#line 1304 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e access_times_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  unsigned int u ;
  unsigned int count ;
  char const   *func ;
  pset_h tmp ;
  register char *interval ;
  status_e tmp___0 ;

  {
#line 1309
  func = "access_times_parser";
#line 1311
  if ((unsigned long )scp->sc_access_times == (unsigned long )((void *)0)) {
    {
#line 1311
    tmp = pset_create(0U, 0U);
#line 1311
    scp->sc_access_times = tmp;
    }
#line 1311
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 1311
      out_of_memory(func);
      }
#line 1311
      return ((status_e )0);
    }
  }
#line 1312
  count = values->count;
#line 1314
  if (count == 0U) {
    {
#line 1316
    missing_attr_msg("access_times_parser", "access_times");
    }
#line 1317
    return ((status_e )0);
  }
#line 1320
  u = 0U;
  {
#line 1320
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1320
    if (! (u < count)) {
#line 1320
      goto while_break;
    }
    {
#line 1322
    interval = (char *)*(values->ptrs + u);
#line 1324
    tmp___0 = ti_add(scp->sc_access_times, (char const   *)interval);
    }
#line 1324
    if ((unsigned int )tmp___0 == 0U) {
#line 1325
      return ((status_e )0);
    }
#line 1320
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1327
  return ((status_e )1);
}
}
#line 1331 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e nice_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  int tmp ;

  {
  {
#line 1335
  tmp = parse_base10((char const   *)((char *)*(values->ptrs + 0U)), & scp->sc_nice);
  }
#line 1335
  if (tmp) {
    {
#line 1336
    parsemsg(3, "nice_parser", "Error parsing: %s", (char *)*(values->ptrs + 0U));
    }
#line 1337
    return ((status_e )0);
  }
#line 1339
  return ((status_e )1);
}
}
#line 1343 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e rlim_as_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *mem ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1347
  mem = (char *)*(values->ptrs + 0U);
#line 1348
  func = "rlim_as_parser";
#line 1350
  tmp___0 = strcasecmp((char const   *)mem, "UNLIMITED");
  }
#line 1350
  if (tmp___0 == 0) {
#line 1351
    scp->sc_rlim_as = (__rlim_t )-1;
  } else {
    {
#line 1354
    tmp = get_limit(mem, & scp->sc_rlim_as);
    }
#line 1354
    if (tmp) {
      {
#line 1356
      parsemsg(3, func, "Address space limit is invalid: %s", mem);
      }
#line 1358
      return ((status_e )0);
    }
  }
#line 1361
  return ((status_e )1);
}
}
#line 1366 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e rlim_cpu_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *cpu_str ;
  unsigned long long cpu_int ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1370
  cpu_str = (char *)*(values->ptrs + 0U);
#line 1372
  func = "rlim_cpu_parser";
#line 1374
  tmp___0 = strcasecmp((char const   *)cpu_str, "UNLIMITED");
  }
#line 1374
  if (tmp___0 == 0) {
#line 1375
    scp->sc_rlim_cpu = (__rlim_t )-1;
  } else {
    {
#line 1378
    tmp = parse_ull((char const   *)cpu_str, 10, -1, & cpu_int);
    }
#line 1378
    if (tmp < 0) {
      {
#line 1380
      parsemsg(3, func, "CPU limit is invalid: %s", cpu_str);
      }
#line 1382
      return ((status_e )0);
    }
#line 1384
    scp->sc_rlim_cpu = (rlim_t )cpu_int;
#line 1385
    if ((unsigned long long )scp->sc_rlim_cpu != cpu_int) {
      {
#line 1387
      parsemsg(3, func, "CPU limit is invalid: %s", cpu_str);
      }
#line 1388
      return ((status_e )0);
    }
  }
#line 1391
  return ((status_e )1);
}
}
#line 1396 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e rlim_data_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *mem ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1400
  mem = (char *)*(values->ptrs + 0U);
#line 1401
  func = "rlim_data_parser";
#line 1403
  tmp___0 = strcasecmp((char const   *)mem, "UNLIMITED");
  }
#line 1403
  if (tmp___0 == 0) {
#line 1404
    scp->sc_rlim_data = (__rlim_t )-1;
  } else {
    {
#line 1407
    tmp = get_limit(mem, & scp->sc_rlim_data);
    }
#line 1407
    if (tmp) {
      {
#line 1409
      parsemsg(3, func, "Data limit is invalid: %s", mem);
      }
#line 1411
      return ((status_e )0);
    }
  }
#line 1414
  return ((status_e )1);
}
}
#line 1419 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e rlim_rss_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *mem ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1423
  mem = (char *)*(values->ptrs + 0U);
#line 1424
  func = "rlim_rss_parser";
#line 1426
  tmp___0 = strcasecmp((char const   *)mem, "UNLIMITED");
  }
#line 1426
  if (tmp___0 == 0) {
#line 1427
    scp->sc_rlim_rss = (__rlim_t )-1;
  } else {
    {
#line 1430
    tmp = get_limit(mem, & scp->sc_rlim_rss);
    }
#line 1430
    if (tmp) {
      {
#line 1432
      parsemsg(3, func, "RSS limit is invalid: %s", mem);
      }
#line 1434
      return ((status_e )0);
    }
  }
#line 1437
  return ((status_e )1);
}
}
#line 1442 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e rlim_stack_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *mem ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1446
  mem = (char *)*(values->ptrs + 0U);
#line 1447
  func = "rlim_stack_parser";
#line 1449
  tmp___0 = strcasecmp((char const   *)mem, "UNLIMITED");
  }
#line 1449
  if (tmp___0 == 0) {
#line 1450
    scp->sc_rlim_stack = (__rlim_t )-1;
  } else {
    {
#line 1453
    tmp = get_limit(mem, & scp->sc_rlim_stack);
    }
#line 1453
    if (tmp) {
      {
#line 1455
      parsemsg(3, func, "Stack limit is invalid: %s", mem);
      }
#line 1457
      return ((status_e )0);
    }
  }
#line 1460
  return ((status_e )1);
}
}
#line 1464 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e deny_time_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *deny_time ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1468
  deny_time = (char *)*(values->ptrs + 0U);
#line 1470
  tmp___1 = strcasecmp((char const   *)deny_time, "FOREVER");
  }
#line 1470
  if (tmp___1 == 0) {
#line 1471
    scp->sc_deny_time = -1;
  } else {
    {
#line 1472
    tmp___0 = strcasecmp((char const   *)deny_time, "NEVER");
    }
#line 1472
    if (tmp___0 == 0) {
#line 1473
      scp->sc_deny_time = 0;
    } else {
      {
#line 1474
      tmp = parse_base10((char const   *)deny_time, & scp->sc_deny_time);
      }
#line 1474
      if (tmp) {
        {
#line 1475
        parsemsg(3, "deny_time_parser", "Error parsing: %s", deny_time);
        }
#line 1476
        return ((status_e )0);
      }
    }
  }
#line 1478
  return ((status_e )1);
}
}
#line 1481 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsers.c"
status_e umask_parser(pset_h values , struct service_config *scp , enum assign_op op ) 
{ 
  char *umask_str ;
  int umask_int ;
  int tmp ;

  {
  {
#line 1485
  umask_str = (char *)*(values->ptrs + 0U);
#line 1488
  tmp = parse_int((char const   *)umask_str, 8, -1, & umask_int);
  }
#line 1488
  if (tmp) {
    {
#line 1491
    parsemsg(3, "umask_parser", "umask argument is invalid.\n");
    }
#line 1492
    return ((status_e )0);
  } else
#line 1488
  if (umask_int < 0) {
    {
#line 1491
    parsemsg(3, "umask_parser", "umask argument is invalid.\n");
    }
#line 1492
    return ((status_e )0);
  } else
#line 1488
  if (umask_int > 511) {
    {
#line 1491
    parsemsg(3, "umask_parser", "umask argument is invalid.\n");
    }
#line 1492
    return ((status_e )0);
  }
#line 1494
  scp->sc_umask = (mode_t )umask_int;
#line 1495
  return ((status_e )1);
}
}
#line 69 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 125 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern __pid_t waitpid(__pid_t __pid , int *__stat_loc , int __options ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 534 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 551
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execve)(char const   *__path ,
                                                                                               char * const  *__argv ,
                                                                                               char * const  *__envp ) ;
#line 598
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) nice)(int __inc ) ;
#line 700
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setuid)(__uid_t __uid ) ;
#line 717
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgid)(__gid_t __gid ) ;
#line 180 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 201
extern int initgroups(char const   *__user , __gid_t __group ) ;
#line 29 "../libs/include/str.h"
extern char *( /* format attribute */  strx_sprint)(char *buf , int len , char const   *fmt 
                                                    , ...) ;
#line 33
extern void ( /* format attribute */  strx_print)(int *count , char *buf , int len ,
                                                  char const   *fmt  , ...) ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.h"
void child_exit(void) ;
#line 17
 __attribute__((__noreturn__)) void exec_server(struct server  const  *serp ) ;
#line 13 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
void no_control_tty(void) ;
#line 87 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.h"
void server_end(struct server *serp ) ;
#line 88
struct server *server_lookup(pid_t pid ) ;
#line 17 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.h"
void signal_default_state(void) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/redirect.h"
 __attribute__((__noreturn__)) void redir_handler(struct server *serp ) ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.c"
 __attribute__((__noreturn__)) void exec_server(struct server  const  *serp ) ;
#line 61 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.c"
void exec_server(struct server  const  *serp ) 
{ 
  struct service_config  const  *scp ;
  struct rlimit rl ;
  int fd ;
  int descriptor ;
  char const   *server ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 63
  scp = (struct service_config  const  *)(serp->svr_sp)->svc_conf;
#line 66
  descriptor = (serp->svr_conn)->co_descriptor;
#line 67
  server = (char const   *)scp->sc_server;
#line 68
  func = "exec_server";
#line 84
  tmp = fcntl(descriptor, 2, 0);
  }
#line 84
  if (tmp == -1) {
    {
#line 85
    msg(4, func, "fcntl( %d, clear close-on-exec ) failed: %m", descriptor);
    }
  }
#line 88
  if (debug.on) {
    {
#line 89
    msg(7, func, "duping %d", descriptor);
    }
  }
  {
#line 97
  msg_suspend();
#line 99
  fd = 0;
  }
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (fd <= 2)) {
#line 99
      goto while_break;
    }
    {
#line 101
    tmp___0 = dup2(descriptor, fd);
    }
#line 101
    if (tmp___0 == -1) {
      {
#line 103
      msg_resume();
#line 104
      msg(3, func, "dup2( %d, %d ) failed: %m", descriptor, fd);
#line 106
      _exit(1);
      }
    }
#line 99
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 112
  rl.rlim_max = ps.ros.orig_max_descriptors;
#line 113
  rl.rlim_cur = ps.ros.max_descriptors;
#line 114
  setrlimit(7, (struct rlimit  const  *)(& rl));
  }
#line 117
  if (scp->sc_rlim_as) {
    {
#line 119
    rl.rlim_cur = (rlim_t )scp->sc_rlim_as;
#line 120
    rl.rlim_max = (rlim_t )scp->sc_rlim_as;
#line 121
    setrlimit(9, (struct rlimit  const  *)(& rl));
    }
  }
#line 125
  if (scp->sc_rlim_cpu) {
    {
#line 127
    rl.rlim_cur = (rlim_t )scp->sc_rlim_cpu;
#line 128
    rl.rlim_max = (rlim_t )scp->sc_rlim_cpu;
#line 129
    setrlimit(0, (struct rlimit  const  *)(& rl));
    }
  }
#line 133
  if (scp->sc_rlim_data) {
    {
#line 135
    rl.rlim_cur = (rlim_t )scp->sc_rlim_data;
#line 136
    rl.rlim_max = (rlim_t )scp->sc_rlim_data;
#line 137
    setrlimit(2, (struct rlimit  const  *)(& rl));
    }
  }
#line 141
  if (scp->sc_rlim_rss) {
    {
#line 143
    rl.rlim_cur = (rlim_t )scp->sc_rlim_rss;
#line 144
    rl.rlim_max = (rlim_t )scp->sc_rlim_rss;
#line 145
    setrlimit(5, (struct rlimit  const  *)(& rl));
    }
  }
#line 149
  if (scp->sc_rlim_stack) {
    {
#line 151
    rl.rlim_cur = (rlim_t )scp->sc_rlim_stack;
#line 152
    rl.rlim_max = (rlim_t )scp->sc_rlim_stack;
#line 153
    setrlimit(3, (struct rlimit  const  *)(& rl));
    }
  }
  {
#line 171
  Sclose(descriptor);
#line 177
  no_control_tty();
#line 183
  execve(server, (char * const  *)scp->sc_server_argv, (char * const  *)(scp->sc_environment.env_handle)->vars);
#line 189
  msg_resume();
#line 190
  msg(3, func, "execv( %s ) failed: %m", server);
#line 191
  _exit(0);
  }
}
}
#line 202 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.c"
static void rename_process(char const   *name___0 ) 
{ 
  char const   *from ;
  char *to ;
  int tmp_index ;
  char *tmp ;
  char const   *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 204
  from = name___0;
#line 205
  to = *(ps.ros.Argv + 0);
#line 206
  tmp_index = 1;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! ((int const   )*from != 0)) {
#line 208
      goto while_break;
    }
#line 210
    if ((int )*to != 0) {
#line 211
      tmp = to;
#line 211
      to ++;
#line 211
      tmp___0 = from;
#line 211
      from ++;
#line 211
      *tmp = (char )*tmp___0;
    } else
#line 213
    if (tmp_index < ps.ros.Argc) {
#line 214
      tmp___1 = tmp_index;
#line 214
      tmp_index ++;
#line 214
      to = *(ps.ros.Argv + tmp___1);
    } else {
#line 216
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 218
  str_fill(to, (char )' ');
  }
  {
#line 219
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 219
    if (! (tmp_index < ps.ros.Argc)) {
#line 219
      goto while_break___0;
    }
    {
#line 220
    tmp___2 = tmp_index;
#line 220
    tmp_index ++;
#line 220
    str_fill(*(ps.ros.Argv + tmp___2), (char )' ');
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 221
  return;
}
}
#line 224 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.c"
static void set_credentials(struct service_config  const  *scp ) 
{ 
  char const   *func ;
  gid_t gid ;
  gid_t tmp ;
  int tmp___0 ;
  struct passwd *pwd ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 226
  func = "set_credentials";
#line 228
  if (scp->sc_specified_attributes & (unsigned long const   )(1UL << 4)) {
#line 228
    goto _L___1;
  } else
#line 228
  if (scp->sc_specified_attributes & (unsigned long const   )(1UL << 3)) {
    _L___1: /* CIL Label */ 
#line 229
    if (ps.ros.is_superuser) {
#line 231
      if (scp->sc_specified_attributes & (unsigned long const   )(1UL << 4)) {
#line 231
        tmp = scp->sc_gid;
      } else {
#line 231
        tmp = scp->sc_user_gid;
      }
      {
#line 231
      gid = (gid_t )tmp;
#line 233
      tmp___0 = setgid(gid);
      }
#line 233
      if (tmp___0 == -1) {
        {
#line 235
        msg(3, func, "setgid failed: %m");
#line 236
        _exit(1);
        }
      }
#line 247
      if (scp->sc_specified_attributes & (unsigned long const   )(1UL << 3)) {
#line 247
        if (scp->sc_specified_attributes & (unsigned long const   )(1UL << 27)) {
#line 247
          if ((unsigned int const   )scp->sc_groups == 1U) {
            {
#line 258
            pwd = getpwuid((__uid_t )scp->sc_uid);
            }
#line 258
            if ((unsigned long )pwd == (unsigned long )((void *)0)) {
              {
#line 260
              msg(3, func, "getpwuid( %d ) (service=%s) failed: %m", scp->sc_uid,
                  scp->sc_id);
#line 262
              _exit(1);
              }
            }
            {
#line 264
            str_fill(pwd->pw_passwd, (char )' ');
#line 266
            tmp___1 = initgroups((char const   *)pwd->pw_name, pwd->pw_gid);
            }
#line 266
            if (tmp___1 == -1) {
              {
#line 268
              msg(3, func, "initgroups( %s, %d ) failed: %m", pwd->pw_name, pwd->pw_gid);
#line 270
              _exit(1);
              }
            }
          } else {
#line 247
            goto _L___0;
          }
        } else {
#line 247
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 275
        tmp___2 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
        }
#line 275
        if (tmp___2) {
          {
#line 277
          msg(3, func, "setgroups( 0, NULL ) failed: %m");
#line 278
          msg(3, func, "Your system may require that \'groups = yes\' be defined for this service: %s",
              scp->sc_name);
#line 279
          _exit(1);
          }
        }
      }
    }
  }
#line 286
  if (scp->sc_specified_attributes & (unsigned long const   )(1UL << 3)) {
    {
#line 287
    tmp___3 = setuid((__uid_t )scp->sc_uid);
    }
#line 287
    if (tmp___3 == -1) {
      {
#line 289
      msg(3, func, "setuid failed: %m");
#line 290
      _exit(1);
      }
    }
  }
#line 294
  if (scp->sc_specified_attributes & (unsigned long const   )(1UL << 40)) {
    {
#line 295
    umask((__mode_t )scp->sc_umask);
    }
  }
#line 296
  return;
}
}
#line 306
 __attribute__((__noreturn__)) void child_process(struct server *serp ) ;
#line 306 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.c"
void child_process(struct server *serp ) 
{ 
  struct service *sp ;
  connection_s *cp ;
  struct service_config *scp ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;
  status_e tmp___1 ;
  unsigned int timeout ;
  idresult_e result ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char buff[1024] ;
  char const   *tmp___4 ;
  int tmp___5 ;
  char name___0[180] ;
  int namelen ;
  char host[1025] ;
  size_t hostlen ;
  socklen_t addrlen ;
  union xsockaddr *sinp ;
  union xsockaddr *tmp___6 ;
  int len ;
  int tmp___7 ;
  struct in6_addr  const  *__a ;
  int tmp___8 ;

  {
  {
#line 308
  sp = serp->svr_sp;
#line 309
  cp = serp->svr_conn;
#line 310
  scp = sp->svc_conf;
#line 311
  func = "child_process";
#line 313
  signal_default_state();
  }
#line 315
  if (signals_pending[0] >= 0) {
    {
#line 315
    tmp = Sclose(signals_pending[0]);
    }
#line 315
    if (tmp) {
      {
#line 318
      msg(3, func, "Failed to close the signal pipe: %m");
#line 319
      _exit(1);
      }
    } else {
#line 315
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 315
  if (signals_pending[1] >= 0) {
    {
#line 315
    tmp___0 = Sclose(signals_pending[1]);
    }
#line 315
    if (tmp___0) {
      {
#line 318
      msg(3, func, "Failed to close the signal pipe: %m");
#line 319
      _exit(1);
      }
    }
  }
  {
#line 321
  signals_pending[0] = -1;
#line 322
  signals_pending[1] = -1;
#line 324
  Sclose(0);
#line 325
  Sclose(1);
#line 326
  Sclose(2);
  }
#line 337
  if (! (scp->sc_xflags & 1UL)) {
    {
#line 339
    set_credentials((struct service_config  const  *)scp);
    }
#line 340
    if (scp->sc_specified_attributes & (1UL << 22)) {
      {
#line 341
      nice(scp->sc_nice);
      }
    }
  }
  {
#line 344
  tmp___1 = svc_child_access_control(sp, cp);
  }
#line 344
  if ((unsigned int )tmp___1 != 1U) {
    {
#line 345
    exit(0);
    }
  }
#line 347
  if (serp->svr_log_remote_user) {
#line 356
    if (scp->sc_xflags & (1UL << 3)) {
#line 356
      timeout = 0U;
    } else {
#line 356
      timeout = 30U;
    }
    {
#line 357
    result = log_remote_user((struct server  const  *)serp, timeout);
    }
#line 359
    if ((unsigned int )result != 0U) {
#line 359
      if (scp->sc_xflags & (1UL << 3)) {
        {
#line 361
        tmp___2 = idresult_explain(result);
#line 361
        tmp___3 = conn_addrstr((connection_s const   *)serp->svr_conn);
#line 361
        svc_logprint(sp, "NOID", "%s %s", tmp___3, tmp___2);
#line 364
        _exit(0);
        }
      }
    }
  }
#line 370
  if (! (scp->sc_type & (1UL << 1))) {
#line 372
    if ((unsigned long )scp->sc_redir_addr != (unsigned long )((void *)0)) {
      {
#line 374
      redir_handler(serp);
      }
    } else {
      {
#line 381
      tmp___4 = conn_addrstr((connection_s const   *)cp);
#line 381
      strx_sprint(buff, (int )(sizeof(buff) - 1UL), "REMOTE_HOST=%s", tmp___4);
#line 382
      tmp___5 = env_addstr(scp->sc_environment.env_handle, buff);
      }
#line 382
      if (tmp___5 != 0) {
        {
#line 383
        msg(3, func, "Error adding REMOTE_HOST variable for %s: %m", scp->sc_name);
#line 384
        _exit(1);
        }
      }
      {
#line 387
      exec_server((struct server  const  *)serp);
      }
    }
  } else {
#line 400
    if (scp->sc_xflags & 1UL) {
      {
#line 401
      strx_print((int *)0, name___0, (int )(sizeof(name___0) - 1UL), "%s %s interceptor",
                 program_name, scp->sc_id);
      }
    } else {
#line 405
      namelen = (int )(sizeof(name___0) - 1UL);
#line 407
      hostlen = (size_t )1025;
#line 408
      addrlen = (socklen_t )0;
#line 409
      if ((serp->svr_conn)->co_flags & 1UL) {
#line 409
        tmp___6 = & (serp->svr_conn)->co_remote_address;
      } else {
#line 409
        tmp___6 = (union xsockaddr *)((void *)0);
      }
#line 409
      sinp = tmp___6;
#line 412
      if ((unsigned long )sinp == (unsigned long )((void *)0)) {
        {
#line 413
        exit(0);
        }
      }
#line 415
      if (scp->sc_xflags & (1UL << 10)) {
#line 415
        addrlen = (socklen_t )sizeof(struct sockaddr_in6 );
      } else
#line 416
      if (scp->sc_xflags & (1UL << 9)) {
#line 416
        addrlen = (socklen_t )sizeof(struct sockaddr_in );
      }
      {
#line 418
      len = strx_nprint(name___0, namelen, "(%s service) %s", program_name, scp->sc_id);
#line 421
      tmp___7 = getnameinfo((struct sockaddr  const  */* __restrict  */)((struct sockaddr *)sinp),
                            addrlen, (char */* __restrict  */)(host), (socklen_t )hostlen,
                            (char */* __restrict  */)((void *)0), (socklen_t )0, 0);
      }
#line 421
      if (tmp___7 != 0) {
        {
#line 422
        strcpy((char */* __restrict  */)(host), (char const   */* __restrict  */)"unknown");
        }
      }
#line 425
      if (scp->sc_xflags & (1UL << 10)) {
#line 425
        if ((unsigned int )scp->sc_wait == 0U) {
#line 425
          if (scp->sc_socket_type == 1) {
#line 425
            __a = (struct in6_addr  const  *)(& sinp->sa_in6.sin6_addr);
#line 425
            if (__a->__in6_u.__u6_addr32[0] == 0U) {
#line 425
              if (__a->__in6_u.__u6_addr32[1] == 0U) {
#line 425
                if (__a->__in6_u.__u6_addr32[2] == 0U) {
#line 425
                  if (__a->__in6_u.__u6_addr32[3] == 0U) {
#line 425
                    tmp___8 = 1;
                  } else {
#line 425
                    tmp___8 = 0;
                  }
                } else {
#line 425
                  tmp___8 = 0;
                }
              } else {
#line 425
                tmp___8 = 0;
              }
            } else {
#line 425
              tmp___8 = 0;
            }
#line 425
            if (! tmp___8) {
              {
#line 426
              strx_print((int *)0, & name___0[len], namelen - len, " %s", host);
              }
            }
          }
        }
      }
#line 427
      if (scp->sc_xflags & (1UL << 9)) {
#line 427
        if ((unsigned int )scp->sc_wait == 0U) {
#line 427
          if (scp->sc_socket_type == 1) {
            {
#line 428
            strx_print((int *)0, & name___0[len], namelen - len, " %s", host);
            }
          }
        }
      }
    }
    {
#line 430
    rename_process((char const   *)(name___0));
#line 431
    (*(((sp->svc_conf)->sc_builtin)->b_handler))(serp);
    }
  }
  {
#line 433
  _exit(0);
  }
}
}
#line 441 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/child.c"
void child_exit(void) 
{ 
  char const   *func ;
  int status ;
  pid_t pid ;
  struct server *serp ;
  int *tmp ;
  char const   *tmp___0 ;
  union __anonunion_84___0 __constr_expr_9 ;

  {
#line 443
  func = "child_exit";
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 452
    pid = waitpid(-1, & status, 1);
    }
#line 461
    if (debug.on) {
      {
#line 463
      msg(7, func, "waitpid returned = %d", pid);
      }
    }
#line 468
    if (pid == -1) {
      {
#line 469
      tmp = __errno_location();
      }
#line 469
      if (*tmp == 4) {
#line 470
        goto __Cont;
      } else {
#line 472
        goto while_break;
      }
    }
#line 475
    if (pid == 0) {
#line 476
      goto while_break;
    }
    {
#line 478
    serp = server_lookup(pid);
    }
#line 478
    if ((unsigned long )serp != (unsigned long )((void *)0)) {
      {
#line 480
      serp->svr_exit_status = status;
#line 481
      server_end(serp);
      }
    } else {
#line 484
      __constr_expr_9.__in = status;
#line 484
      if ((__constr_expr_9.__i & 255) == 127) {
#line 484
        tmp___0 = "stopped";
      } else {
#line 484
        tmp___0 = "died";
      }
      {
#line 484
      msg(5, func, "unknown child process %d %s", pid, tmp___0);
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 487
  return;
}
}
#line 300 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.h"
struct service_config *sc_alloc(char const   *name___0 ) ;
#line 302
struct service_config *sc_make_special(char const   *service_name , builtin_s const   *bp ,
                                       int instances ) ;
#line 304
bool_int sc_different_confs(struct service_config *scp1 , struct service_config *scp2 ) ;
#line 23 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.h"
void addrlist_dump(pset_h const   addr_list , int fd ) ;
#line 40 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.c"
struct service_config *sc_alloc(char const   *name___0 ) 
{ 
  struct service_config *scp ;
  char const   *func ;
  void *tmp ;

  {
  {
#line 43
  func = "sc_alloc";
#line 45
  tmp = malloc(sizeof(struct service_config ));
#line 45
  scp = (struct service_config *)tmp;
  }
#line 46
  if ((unsigned long )scp == (unsigned long )((void *)0)) {
    {
#line 48
    out_of_memory(func);
    }
#line 49
    return ((struct service_config *)((void *)0));
  }
  {
#line 51
  memset((void *)((char *)scp), 0, sizeof(*scp));
#line 52
  scp->sc_name = new_string(name___0);
  }
#line 56
  return (scp);
}
}
#line 60 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.c"
static void release_string_pset(pset_h pset ) 
{ 


  {
  {
#line 62
  pset_apply(pset, (void (*)())(& free), (void *)0);
#line 63
  pset_destroy(pset);
  }
#line 64
  return;
}
}
#line 70 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.c"
void sc_free(struct service_config *scp ) 
{ 
  char **pp ;

  {
#line 79
  if (scp->sc_name) {
    {
#line 79
    *(scp->sc_name) = (char )'\000';
#line 79
    free((void *)scp->sc_name);
    }
  }
#line 80
  if (scp->sc_id) {
    {
#line 80
    *(scp->sc_id) = (char )'\000';
#line 80
    free((void *)scp->sc_id);
    }
  }
#line 81
  if (scp->sc_protocol.name) {
    {
#line 81
    *(scp->sc_protocol.name) = (char )'\000';
#line 81
    free((void *)scp->sc_protocol.name);
    }
  }
#line 82
  if (scp->sc_server) {
    {
#line 82
    *(scp->sc_server) = (char )'\000';
#line 82
    free((void *)scp->sc_server);
    }
  }
#line 83
  if ((char *)scp->sc_redir_addr) {
    {
#line 83
    *((char *)scp->sc_redir_addr) = (char )'\000';
#line 83
    free((void *)((char *)scp->sc_redir_addr));
    }
  }
#line 84
  if ((char *)scp->sc_bind_addr) {
    {
#line 84
    *((char *)scp->sc_bind_addr) = (char )'\000';
#line 84
    free((void *)((char *)scp->sc_bind_addr));
    }
  }
#line 85
  if (scp->sc_orig_bind_addr) {
    {
#line 85
    *(scp->sc_orig_bind_addr) = (char )'\000';
#line 85
    free((void *)scp->sc_orig_bind_addr);
    }
  }
#line 86
  if (scp->sc_banner) {
    {
#line 86
    *(scp->sc_banner) = (char )'\000';
#line 86
    free((void *)scp->sc_banner);
    }
  }
#line 87
  if (scp->sc_banner_success) {
    {
#line 87
    *(scp->sc_banner_success) = (char )'\000';
#line 87
    free((void *)scp->sc_banner_success);
    }
  }
#line 88
  if (scp->sc_banner_fail) {
    {
#line 88
    *(scp->sc_banner_fail) = (char )'\000';
#line 88
    free((void *)scp->sc_banner_fail);
    }
  }
#line 89
  if (scp->sc_server_argv) {
#line 96
    if ((unsigned long )*(scp->sc_server_argv + 0) != (unsigned long )((void *)0)) {
      {
#line 97
      free((void *)*(scp->sc_server_argv + 0));
      }
    }
#line 98
    pp = scp->sc_server_argv + 1;
    {
#line 98
    while (1) {
      while_continue: /* CIL Label */ ;
#line 98
      if (! ((unsigned long )*pp != (unsigned long )((void *)0))) {
#line 98
        goto while_break;
      }
      {
#line 99
      free((void *)*pp);
#line 98
      pp ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 100
    free((void *)((char *)scp->sc_server_argv));
    }
  }
#line 102
  if (scp->sc_log.l_fl.fl_filename) {
    {
#line 102
    *(scp->sc_log.l_fl.fl_filename) = (char )'\000';
#line 102
    free((void *)scp->sc_log.l_fl.fl_filename);
    }
  }
#line 104
  if ((unsigned long )scp->sc_access_times != (unsigned long )((void *)0)) {
    {
#line 106
    ti_free(scp->sc_access_times);
#line 107
    pset_destroy(scp->sc_access_times);
    }
  }
#line 110
  if ((unsigned long )scp->sc_only_from != (unsigned long )((void *)0)) {
    {
#line 112
    addrlist_free(scp->sc_only_from);
#line 113
    pset_destroy(scp->sc_only_from);
    }
  }
#line 116
  if ((unsigned long )scp->sc_no_access != (unsigned long )((void *)0)) {
    {
#line 118
    addrlist_free(scp->sc_no_access);
#line 119
    pset_destroy(scp->sc_no_access);
    }
  }
#line 122
  if ((unsigned long )scp->sc_env_var_defs != (unsigned long )((void *)0)) {
    {
#line 123
    release_string_pset(scp->sc_env_var_defs);
    }
  }
#line 124
  if ((unsigned long )scp->sc_pass_env_vars != (unsigned long )((void *)0)) {
    {
#line 125
    release_string_pset(scp->sc_pass_env_vars);
    }
  }
#line 126
  if ((unsigned int )scp->sc_environment.env_type == 3U) {
#line 126
    if ((unsigned long )scp->sc_environment.env_handle != (unsigned long )((env_h )0)) {
      {
#line 128
      env_destroy(scp->sc_environment.env_handle);
      }
    }
  }
#line 129
  if (scp->sc_disabled) {
    {
#line 130
    release_string_pset(scp->sc_disabled);
    }
  }
#line 131
  if (scp->sc_enabled) {
    {
#line 132
    release_string_pset(scp->sc_enabled);
    }
  }
  {
#line 134
  memset((void *)((char *)scp), 0, sizeof(*scp));
#line 135
  free((void *)((char *)scp));
  }
#line 136
  return;
}
}
#line 142 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.c"
struct service_config *sc_make_special(char const   *service_name , builtin_s const   *bp ,
                                       int instances ) 
{ 
  struct service_config *scp ;
  char const   *func ;

  {
  {
#line 147
  func = "sc_make";
#line 149
  scp = sc_alloc(service_name);
  }
#line 149
  if ((unsigned long )scp == (unsigned long )((void *)0)) {
#line 150
    return ((struct service_config *)((void *)0));
  }
  {
#line 152
  scp->sc_id = new_string((char const   *)scp->sc_name);
  }
#line 153
  if ((unsigned long )scp->sc_id == (unsigned long )((void *)0)) {
    {
#line 155
    out_of_memory(func);
    }
#line 156
    return ((struct service_config *)((void *)0));
  }
#line 158
  scp->sc_specified_attributes |= 1UL << 8;
#line 158
  scp->sc_attributes_present |= 1UL << 8;
#line 163
  scp->sc_type |= 1UL << 3;
#line 164
  scp->sc_type |= 1UL << 1;
#line 165
  scp->sc_builtin = bp;
#line 166
  scp->sc_specified_attributes |= 1UL << 14;
#line 166
  scp->sc_attributes_present |= 1UL << 14;
#line 168
  scp->sc_xflags |= 1UL << 2;
#line 169
  scp->sc_specified_attributes |= 1UL << 20;
#line 169
  scp->sc_attributes_present |= 1UL << 20;
#line 171
  scp->sc_instances = instances;
#line 172
  scp->sc_specified_attributes |= 1UL << 7;
#line 172
  scp->sc_attributes_present |= 1UL << 7;
#line 174
  scp->sc_wait = (boolean_e )0;
#line 175
  scp->sc_specified_attributes |= 1UL;
#line 175
  scp->sc_attributes_present |= 1UL;
#line 177
  return (scp);
}
}
#line 181 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.c"
static void dump_log_data(int fd , struct service_config *scp , int tab_level ) 
{ 
  struct log *lp ;
  struct filelog *flp ;
  int i ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
#line 183
  lp = & scp->sc_log;
  {
#line 189
  if ((unsigned int )lp->l_type == 0U) {
#line 189
    goto case_0;
  }
#line 193
  if ((unsigned int )lp->l_type == 3U) {
#line 193
    goto case_3;
  }
#line 197
  if ((unsigned int )lp->l_type == 1U) {
#line 197
    goto case_1;
  }
#line 208
  if ((unsigned int )lp->l_type == 2U) {
#line 208
    goto case_2;
  }
#line 187
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 190
  tabprint(fd, tab_level, "No logging\n");
  }
#line 191
  return;
  case_3: /* CIL Label */ 
  {
#line 194
  tabprint(fd, tab_level, "Logging to common log file\n");
  }
#line 195
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 198
  flp = & lp->l_fl;
#line 199
  tabprint(fd, tab_level, "Logging to file: %s", flp->fl_filename);
  }
#line 201
  if (flp->fl_soft_limit != 0U) {
    {
#line 202
    Sprint(fd, " (soft=%d hard=%d)\n", flp->fl_soft_limit, flp->fl_hard_limit);
    }
  } else {
    {
#line 205
    Sprint(fd, " (no limits)\n");
    }
  }
#line 206
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 209
  tmp = nv_get_name(syslog_levels, lp->l_sl.sl_level);
#line 209
  tmp___0 = nv_get_name(syslog_facilities, lp->l_sl.sl_facility);
#line 209
  tabprint(fd, tab_level, "Logging to syslog. Facility = %s, level = %s\n", tmp___0,
           tmp);
  }
#line 213
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 216
  tabprint(fd, tab_level, "Log_on_success flags =");
#line 217
  i = 0;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((unsigned long )success_log_options[i].name != (unsigned long )((void *)0))) {
#line 217
      goto while_break;
    }
#line 218
    if (scp->sc_log_on_success & (1UL << (success_log_options[i].value - 1))) {
      {
#line 219
      Sprint(fd, " %s", success_log_options[i].name);
      }
    }
#line 217
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  Sputchar(fd, (char )'\n');
#line 222
  tabprint(fd, tab_level, "Log_on_failure flags =");
#line 223
  i = 0;
  }
  {
#line 223
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 223
    if (! ((unsigned long )failure_log_options[i].name != (unsigned long )((void *)0))) {
#line 223
      goto while_break___0;
    }
#line 224
    if (scp->sc_log_on_failure & (1UL << (failure_log_options[i].value - 1))) {
      {
#line 225
      Sprint(fd, " %s", failure_log_options[i].name);
      }
    }
#line 223
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 226
  Sputchar(fd, (char )'\n');
  }
#line 227
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.c"
void sc_dump(struct service_config *scp , int fd , int tab_level , bool_int is_defaults ) 
{ 
  struct name_value  const  *nvp ;
  unsigned int u ;
  char **pp ;
  char const   *tmp ;
  char bindname[1025] ;
  unsigned int len ;
  int tmp___0 ;
  char redirname[1025] ;
  unsigned int len___0 ;
  int tmp___1 ;
  struct rpc_data *rdp ;

  {
#line 242
  if (is_defaults) {
    {
#line 243
    tabprint(fd, tab_level, "Service defaults\n");
    }
  } else {
    {
#line 245
    tabprint(fd, tab_level, "Service configuration: %s\n", scp->sc_name);
    }
  }
#line 247
  if (! is_defaults) {
    {
#line 249
    tabprint(fd, tab_level + 1, "id = %s\n", scp->sc_id);
    }
#line 251
    if (! (scp->sc_xflags == 0UL)) {
      {
#line 253
      tabprint(fd, tab_level + 1, "flags =");
#line 254
      nvp = & service_flags[0];
      }
      {
#line 254
      while (1) {
        while_continue: /* CIL Label */ ;
#line 254
        if (! ((unsigned long )nvp->name != (unsigned long )((void *)0))) {
#line 254
          goto while_break;
        }
#line 255
        if (scp->sc_xflags & (1UL << (nvp->value - 1))) {
          {
#line 256
          Sprint(fd, " %s", nvp->name);
          }
        }
#line 254
        nvp ++;
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 257
      Sputchar(fd, (char )'\n');
      }
    }
#line 260
    if (! (scp->sc_type == 0UL)) {
      {
#line 262
      tabprint(fd, tab_level + 1, "type =");
#line 263
      nvp = & service_types[0];
      }
      {
#line 263
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 263
        if (! ((unsigned long )nvp->name != (unsigned long )((void *)0))) {
#line 263
          goto while_break___0;
        }
#line 264
        if (scp->sc_type & (1UL << (nvp->value - 1))) {
          {
#line 265
          Sprint(fd, " %s", nvp->name);
          }
        }
#line 263
        nvp ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 266
      Sputchar(fd, (char )'\n');
      }
    }
    {
#line 269
    tmp = nv_get_name(socket_types, scp->sc_socket_type);
#line 269
    tabprint(fd, tab_level + 1, "socket_type = %s\n", tmp);
#line 272
    tabprint(fd, tab_level + 1, "Protocol (name,number) = (%s,%d)\n", scp->sc_protocol.name,
             scp->sc_protocol.value);
    }
#line 275
    if (scp->sc_specified_attributes & (1UL << 18)) {
      {
#line 276
      tabprint(fd, tab_level + 1, "port = %d\n", (int )scp->sc_port);
      }
    }
  }
#line 279
  if (scp->sc_specified_attributes & (1UL << 7)) {
#line 280
    if (scp->sc_instances == -1) {
      {
#line 281
      tabprint(fd, tab_level + 1, "Instances = UNLIMITED\n");
      }
    } else {
      {
#line 283
      tabprint(fd, tab_level + 1, "Instances = %d\n", scp->sc_instances);
      }
    }
  }
#line 286
  if (scp->sc_specified_attributes & 1UL) {
#line 287
    if (scp->sc_wait) {
      {
#line 288
      tabprint(fd, tab_level + 1, "wait = yes\n");
      }
    } else {
      {
#line 290
      tabprint(fd, tab_level + 1, "wait = no\n");
      }
    }
  }
#line 293
  if (scp->sc_specified_attributes & (1UL << 3)) {
    {
#line 294
    tabprint(fd, tab_level + 1, "user = %d\n", scp->sc_uid);
    }
  }
#line 296
  if (scp->sc_specified_attributes & (1UL << 4)) {
    {
#line 297
    tabprint(fd, tab_level + 1, "group = %d\n", scp->sc_gid);
    }
  }
#line 299
  if (scp->sc_specified_attributes & (1UL << 27)) {
#line 301
    if ((unsigned int )scp->sc_groups == 1U) {
      {
#line 302
      tabprint(fd, tab_level + 1, "Groups = yes\n");
      }
    } else {
      {
#line 304
      tabprint(fd, tab_level + 1, "Groups = no\n");
      }
    }
  }
#line 307
  if (scp->sc_specified_attributes & (1UL << 40)) {
    {
#line 308
    tabprint(fd, tab_level + 1, "umask = %o\n", scp->sc_umask);
    }
  }
#line 310
  if (scp->sc_specified_attributes & (1UL << 22)) {
    {
#line 311
    tabprint(fd, tab_level + 1, "Nice = %d\n", scp->sc_nice);
    }
  }
#line 313
  if (scp->sc_specified_attributes & (1UL << 31)) {
    {
#line 314
    tabprint(fd, tab_level + 1, "CPS = max conn:%lu wait:%lu\n", scp->sc_time_conn_max,
             scp->sc_time_wait);
    }
  }
#line 317
  if (scp->sc_specified_attributes & (1UL << 26)) {
    {
#line 318
    tabprint(fd, tab_level + 1, "PER_SOURCE = %d\n", scp->sc_per_source);
    }
  }
#line 321
  if (scp->sc_specified_attributes & (1UL << 24)) {
#line 322
    if (scp->sc_bind_addr) {
#line 324
      len = 0U;
#line 325
      if ((int )(scp->sc_bind_addr)->sa.sa_family == 2) {
#line 326
        len = (unsigned int )sizeof(struct sockaddr_in );
      } else {
#line 328
        len = (unsigned int )sizeof(struct sockaddr_in6 );
      }
      {
#line 329
      memset((void *)(bindname), 0, sizeof(bindname));
#line 330
      tmp___0 = getnameinfo((struct sockaddr  const  */* __restrict  */)(& (scp->sc_bind_addr)->sa),
                            len, (char */* __restrict  */)(bindname), (socklen_t )1025,
                            (char */* __restrict  */)((void *)0), (socklen_t )0, 0);
      }
#line 330
      if (tmp___0 != 0) {
        {
#line 332
        strcpy((char */* __restrict  */)(bindname), (char const   */* __restrict  */)"unknown");
        }
      }
      {
#line 333
      tabprint(fd, tab_level + 1, "Bind = %s\n", bindname);
      }
    } else
#line 335
    if (scp->sc_orig_bind_addr) {
      {
#line 336
      tabprint(fd, tab_level + 1, "Bind = %s\n", scp->sc_orig_bind_addr);
      }
    } else {
      {
#line 340
      msg(3, "sc_dump", "bad configuration for %s:", scp->sc_name);
      }
    }
  } else {
    {
#line 345
    tabprint(fd, tab_level + 1, "Bind = All addresses.\n");
    }
  }
#line 347
  if (! is_defaults) {
#line 349
    if (! (scp->sc_type & (1UL << 1))) {
#line 349
      if ((unsigned long )scp->sc_redir_addr == (unsigned long )((void *)0)) {
        {
#line 351
        tabprint(fd, tab_level + 1, "Server = %s\n", scp->sc_server);
#line 352
        tabprint(fd, tab_level + 1, "Server argv =");
        }
#line 353
        if (scp->sc_server_argv) {
#line 355
          pp = scp->sc_server_argv;
          {
#line 355
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 355
            if (! *pp) {
#line 355
              goto while_break___1;
            }
            {
#line 356
            Sprint(fd, " %s", *pp);
#line 355
            pp ++;
            }
          }
          while_break___1: /* CIL Label */ ;
          }
        } else {
          {
#line 359
          Sprint(fd, " (NULL)");
          }
        }
        {
#line 360
        Sputchar(fd, (char )'\n');
        }
      }
    }
#line 370
    if ((unsigned long )scp->sc_redir_addr != (unsigned long )((void *)0)) {
#line 373
      len___0 = 0U;
#line 374
      if ((int )(scp->sc_redir_addr)->sa.sa_family == 2) {
#line 375
        len___0 = (unsigned int )sizeof(struct sockaddr_in );
      }
#line 376
      if ((int )(scp->sc_redir_addr)->sa.sa_family == 10) {
#line 377
        len___0 = (unsigned int )sizeof(struct sockaddr_in6 );
      }
      {
#line 378
      memset((void *)(redirname), 0, sizeof(redirname));
#line 379
      tmp___1 = getnameinfo((struct sockaddr  const  */* __restrict  */)(& (scp->sc_redir_addr)->sa),
                            len___0, (char */* __restrict  */)(redirname), (socklen_t )1025,
                            (char */* __restrict  */)((void *)0), (socklen_t )0, 0);
      }
#line 379
      if (tmp___1 != 0) {
        {
#line 381
        strcpy((char */* __restrict  */)(redirname), (char const   */* __restrict  */)"unknown");
        }
      }
      {
#line 382
      tabprint(fd, tab_level + 1, "Redirect = %s:%d\n", redirname, (int )(scp->sc_redir_addr)->sa_in.sin_port);
      }
    }
#line 386
    if (scp->sc_type & 1UL) {
      {
#line 388
      rdp = & scp->sc_rd;
#line 390
      tabprint(fd, tab_level + 1, "RPC data\n");
#line 391
      tabprint(fd, tab_level + 2, "program number = %ld\n", rdp->rd_program_number);
#line 393
      tabprint(fd, tab_level + 2, "rpc_version = ");
      }
#line 394
      if (rdp->rd_min_version == rdp->rd_max_version) {
        {
#line 395
        Sprint(fd, "%ld\n", rdp->rd_min_version);
        }
      } else {
        {
#line 397
        Sprint(fd, "%ld-%ld\n", rdp->rd_min_version, rdp->rd_max_version);
        }
      }
    }
#line 401
    if (scp->sc_specified_attributes & (1UL << 10)) {
      {
#line 403
      tabprint(fd, tab_level + 1, "Access times =");
#line 404
      ti_dump(scp->sc_access_times, fd);
#line 405
      Sputchar(fd, (char )'\n');
      }
    }
  }
  {
#line 410
  tabprint(fd, tab_level + 1, "Only from: ");
  }
#line 411
  if (scp->sc_only_from) {
#line 413
    if ((scp->sc_only_from)->count == 0U) {
      {
#line 414
      Sprint(fd, "All sites");
      }
    } else {
      {
#line 416
      addrlist_dump((pset_h const   )scp->sc_only_from, fd);
      }
    }
  } else {
    {
#line 419
    Sprint(fd, "All sites");
    }
  }
  {
#line 420
  Sputchar(fd, (char )'\n');
#line 423
  tabprint(fd, tab_level + 1, "No access: ");
  }
#line 424
  if (scp->sc_no_access) {
#line 426
    if ((scp->sc_no_access)->count == 0U) {
      {
#line 427
      Sprint(fd, "No blocked sites");
      }
    } else {
      {
#line 429
      addrlist_dump((pset_h const   )scp->sc_no_access, fd);
      }
    }
  } else {
    {
#line 432
    Sprint(fd, "No blocked sites");
    }
  }
  {
#line 433
  Sputchar(fd, (char )'\n');
  }
#line 435
  if (scp->sc_xflags & (1UL << 8)) {
    {
#line 437
    tabprint(fd, tab_level + 1, "Deny Time: ");
#line 438
    Sprint(fd, "%d\n", scp->sc_deny_time);
    }
  }
  {
#line 441
  dump_log_data(fd, scp, tab_level + 1);
  }
#line 443
  if (scp->sc_attributes_present & (1UL << 19)) {
    {
#line 445
    tabprint(fd, tab_level + 1, "Passenv =");
#line 446
    u = 0U;
    }
    {
#line 446
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 446
      if (! (u < (scp->sc_pass_env_vars)->count)) {
#line 446
        goto while_break___2;
      }
      {
#line 447
      Sprint(fd, " %s", (char *)*((scp->sc_pass_env_vars)->ptrs + u));
#line 446
      u ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 449
    Sputchar(fd, (char )'\n');
    }
  }
#line 452
  if (! is_defaults) {
#line 453
    if (scp->sc_specified_attributes & (1UL << 17)) {
      {
#line 455
      tabprint(fd, tab_level + 1, "Environment additions:\n");
#line 456
      u = 0U;
      }
      {
#line 456
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 456
        if (! (u < (scp->sc_env_var_defs)->count)) {
#line 456
          goto while_break___3;
        }
        {
#line 457
        tabprint(fd, tab_level + 2, "%s\n", (char *)*((scp->sc_env_var_defs)->ptrs + u));
#line 456
        u ++;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
    }
  }
#line 461
  if ((unsigned int )scp->sc_environment.env_type == 3U) {
    {
#line 463
    tabprint(fd, tab_level + 1, "Environment strings:\n");
#line 464
    pp = (scp->sc_environment.env_handle)->vars;
    }
    {
#line 464
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 464
      if (! *pp) {
#line 464
        goto while_break___4;
      }
      {
#line 465
      tabprint(fd, tab_level + 2, "%s\n", *pp);
#line 464
      pp ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  {
#line 467
  Sflush(fd);
  }
#line 468
  return;
}
}
#line 495 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/sconf.c"
bool_int sc_different_confs(struct service_config *scp1 , struct service_config *scp2 ) 
{ 


  {
#line 498
  if ((scp1->sc_type & (1UL << 2)) != (scp2->sc_type & (1UL << 2))) {
#line 501
    return (1);
  } else
#line 498
  if ((scp1->sc_type & (1UL << 1)) != (scp2->sc_type & (1UL << 1))) {
#line 501
    return (1);
  } else
#line 498
  if ((scp1->sc_type & 1UL) != (scp2->sc_type & 1UL)) {
#line 501
    return (1);
  }
#line 503
  if ((unsigned int )scp1->sc_wait != (unsigned int )scp2->sc_wait) {
#line 504
    return (1);
  }
#line 506
  if (scp1->sc_protocol.value != scp2->sc_protocol.value) {
#line 507
    return (1);
  }
#line 509
  if (scp1->sc_type & 1UL) {
#line 511
    if (! (scp1->sc_rd.rd_program_number == scp2->sc_rd.rd_program_number)) {
#line 512
      return (1);
    }
  } else
#line 516
  if (scp1->sc_socket_type == scp2->sc_socket_type) {
#line 516
    if (! ((int )scp1->sc_port == (int )scp2->sc_port)) {
#line 517
      return (1);
    }
  } else {
#line 517
    return (1);
  }
#line 519
  return (0);
}
}
#line 54 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.c"
struct name_value  const  access_code_names[11]  = 
#line 54 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.c"
  {      {"address", 2}, 
        {"time", 3}, 
        {"fork", 1}, 
        {"service_limit", 4}, 
        {"per_source_limit", 5}, 
        {"process_limit", 6}, 
        {"libwrap", 7}, 
        {"load", 8}, 
        {"connections per second", 9}, 
        {(char const   *)((char *)0), 1}, 
        {"UNKNOWN", 0}};
#line 71 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.c"
static void cps_service_restart(void) 
{ 
  unsigned int i ;
  time_t nowtime ;
  char const   *func ;
  struct service *sp ;
  struct service_config *scp ;
  status_e tmp ;

  {
  {
#line 75
  func = "cps_service_restart";
#line 77
  nowtime = time((time_t *)((void *)0));
#line 78
  i = 0U;
  }
  {
#line 78
  while (1) {
    while_continue: /* CIL Label */ ;
#line 78
    if (! (i < (ps.rws.services)->count)) {
#line 78
      goto while_break;
    }
#line 82
    sp = (struct service *)*((ps.rws.services)->ptrs + i);
#line 84
    if ((unsigned int )sp->svc_state == 3U) {
#line 85
      scp = sp->svc_conf;
#line 86
      if (scp->sc_time_reenable <= nowtime) {
        {
#line 88
        tmp = svc_activate(sp);
        }
#line 88
        if ((unsigned int )tmp == 1U) {
          {
#line 89
          msg(3, func, "Activating service %s", scp->sc_name);
          }
        } else {
          {
#line 92
          msg(3, func, "Error activating service %s", scp->sc_name);
          }
        }
      }
    }
#line 78
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  return;
}
}
#line 102 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.c"
void cps_service_stop(struct service *sp , char const   *reason ) 
{ 
  struct service_config *scp ;
  time_t nowtime ;

  {
  {
#line 104
  scp = sp->svc_conf;
#line 107
  svc_deactivate(sp);
#line 108
  msg(3, "service_stop", "Deactivating service %s due to %s.  Restarting in %d seconds.",
      scp->sc_name, reason, (int )scp->sc_time_wait);
#line 111
  nowtime = time((time_t *)((void *)0));
#line 112
  scp->sc_time_reenable = nowtime + scp->sc_time_wait;
#line 113
  xtimer_add(& cps_service_restart, scp->sc_time_wait);
  }
#line 114
  return;
}
}
#line 121 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.c"
static status_e remote_address_check(struct service  const  *sp , union xsockaddr  const  *sinp ) 
{ 
  char const   *func ;
  bool_int of_matched ;
  bool_int na_matched ;
  status_e tmp ;
  char const   *tmp___0 ;

  {
#line 127
  func = "remote_addr_chk";
#line 128
  of_matched = 0;
#line 129
  na_matched = 0;
#line 131
  if ((unsigned long )sinp == (unsigned long )((void *)0)) {
#line 132
    return ((status_e )0);
  }
#line 134
  if ((sp->svc_conf)->sc_xflags & (1UL << 8)) {
    {
#line 136
    process_sensor(sp, sinp);
    }
#line 137
    return ((status_e )0);
  } else {
    {
#line 140
    tmp = check_sensor(sinp);
    }
#line 140
    if ((unsigned int )tmp == 0U) {
#line 141
      return ((status_e )0);
    }
  }
#line 147
  if ((unsigned long )(sp->svc_conf)->sc_no_access != (unsigned long )((void *)0)) {
    {
#line 148
    na_matched = addrlist_match((pset_h const   )(sp->svc_conf)->sc_no_access, (struct sockaddr  const  *)sinp);
    }
  }
#line 150
  if ((unsigned long )(sp->svc_conf)->sc_only_from != (unsigned long )((void *)0)) {
    {
#line 151
    of_matched = addrlist_match((pset_h const   )(sp->svc_conf)->sc_only_from, (struct sockaddr  const  *)sinp);
    }
  }
#line 156
  if (na_matched) {
#line 156
    if (of_matched) {
      {
#line 163
      tmp___0 = xaddrname(sinp);
#line 163
      msg(3, func, "Service=%s: only_from list and no_access list match equally the address %s",
          (sp->svc_conf)->sc_id, tmp___0);
      }
#line 167
      return ((status_e )0);
    }
  }
#line 171
  if ((unsigned long )(sp->svc_conf)->sc_no_access != (unsigned long )((void *)0)) {
#line 171
    if (na_matched != 0) {
#line 172
      return ((status_e )0);
    }
  }
#line 175
  if ((unsigned long )(sp->svc_conf)->sc_only_from != (unsigned long )((void *)0)) {
#line 175
    if (of_matched == 0) {
#line 176
      return ((status_e )0);
    }
  }
#line 179
  return ((status_e )1);
}
}
#line 191 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.c"
access_e access_control(struct service *sp , connection_s const   *cp , mask_t const   *check_mask ) 
{ 
  struct service_config *scp ;
  int tmp ;
  int tmp___0 ;
  union xsockaddr  const  *tmp___1 ;
  status_e tmp___2 ;

  {
  {
#line 195
  scp = sp->svc_conf;
#line 201
  tmp = strncmp((char const   *)scp->sc_name, "intercept", sizeof("intercept"));
  }
#line 201
  if (tmp == 0) {
#line 202
    return ((access_e )0);
  } else {
    {
#line 201
    tmp___0 = strncmp((char const   *)scp->sc_name, "logging", sizeof("logging"));
    }
#line 201
    if (tmp___0 == 0) {
#line 202
      return ((access_e )0);
    }
  }
#line 207
  if ((unsigned long )check_mask == (unsigned long )((void *)0)) {
#line 207
    goto _L;
  } else
#line 207
  if (*check_mask & 1UL) {
    _L: /* CIL Label */ 
#line 207
    if (cp->co_flags & 1UL) {
#line 207
      tmp___1 = & cp->co_remote_address;
    } else {
#line 207
      tmp___1 = (union xsockaddr  const  *)((void *)0);
    }
    {
#line 207
    tmp___2 = remote_address_check((struct service  const  *)sp, tmp___1);
    }
#line 207
    if ((unsigned int )tmp___2 == 0U) {
#line 209
      return ((access_e )2);
    }
  }
#line 272
  return ((access_e )0);
}
}
#line 277 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/access.c"
access_e parent_access_control(struct service *sp , connection_s const   *cp ) 
{ 
  struct service_config *scp ;
  int n ;
  time_t nowtime ;
  int tmp ;
  int tmp___0 ;
  int time_diff ;
  bool_int tmp___1 ;
  unsigned int u ;
  struct server *serp ;
  connection_s *cop ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  union xsockaddr  const  *tmp___2 ;
  int tmp___3 ;
  union xsockaddr  const  *tmp___4 ;
  union xsockaddr  const  *tmp___5 ;
  unsigned int processes_to_create ;
  int tmp___6 ;

  {
  {
#line 279
  scp = sp->svc_conf;
#line 284
  tmp = strncmp((char const   *)scp->sc_name, "intercept", sizeof("intercept"));
  }
#line 284
  if (tmp == 0) {
#line 285
    return ((access_e )0);
  } else {
    {
#line 284
    tmp___0 = strncmp((char const   *)scp->sc_name, "logging", sizeof("logging"));
    }
#line 284
    if (tmp___0 == 0) {
#line 285
      return ((access_e )0);
    }
  }
#line 288
  if (scp->sc_time_conn_max != 0L) {
    {
#line 290
    nowtime = time((time_t *)((void *)0));
#line 291
    time_diff = (int )(nowtime - scp->sc_time_limit);
    }
#line 293
    if (scp->sc_time_conn == 0L) {
#line 294
      (scp->sc_time_conn) ++;
#line 295
      scp->sc_time_limit = nowtime;
    } else
#line 296
    if ((time_t )time_diff < scp->sc_time_conn_max) {
#line 297
      (scp->sc_time_conn) ++;
#line 298
      if (time_diff == 0) {
#line 298
        time_diff = 1;
      }
#line 299
      if (scp->sc_time_conn / (time_t )time_diff > scp->sc_time_conn_max) {
        {
#line 300
        cps_service_stop(sp, "excessive incoming connections");
        }
#line 301
        return ((access_e )9);
      }
    } else {
#line 304
      scp->sc_time_limit = nowtime;
#line 305
      scp->sc_time_conn = (time_t )1;
    }
  }
#line 320
  if ((unsigned long )scp->sc_access_times != (unsigned long )((void *)0)) {
    {
#line 320
    tmp___1 = ti_current_time_check((pset_h const   )scp->sc_access_times);
    }
#line 320
    if (! tmp___1) {
#line 322
      return ((access_e )3);
    }
  }
#line 324
  if (scp->sc_instances != -1) {
#line 324
    if (sp->svc_running_servers >= (unsigned int )scp->sc_instances) {
#line 326
      return ((access_e )4);
    }
  }
#line 328
  if (scp->sc_per_source != -1) {
#line 329
    if (cp->co_flags & 1UL) {
#line 329
      tmp___5 = & cp->co_remote_address;
    } else {
#line 329
      tmp___5 = (union xsockaddr  const  *)((void *)0);
    }
#line 329
    if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 331
      n = 0;
#line 332
      u = 0U;
      {
#line 332
      while (1) {
        while_continue: /* CIL Label */ ;
#line 332
        if (! (u < (ps.rws.servers)->count)) {
#line 332
          goto while_break;
        }
#line 333
        serp = (struct server *)((void *)0);
#line 334
        cop = (connection_s *)((void *)0);
#line 335
        serp = (struct server *)*((ps.rws.servers)->ptrs + u);
#line 336
        if ((unsigned long )serp->svr_sp == (unsigned long )sp) {
#line 336
          cop = serp->svr_conn;
#line 336
          if (cop) {
#line 340
            if (scp->sc_xflags & (1UL << 10)) {
#line 340
              __a = (struct in6_addr  const  *)(& cop->co_remote_address.sa_in6.sin6_addr);
#line 340
              if (cp->co_flags & 1UL) {
#line 340
                tmp___2 = & cp->co_remote_address;
              } else {
#line 340
                tmp___2 = (union xsockaddr  const  *)((void *)0);
              }
#line 340
              __b = & tmp___2->sa_in6.sin6_addr;
#line 340
              if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 340
                if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 340
                  if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 340
                    if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 340
                      tmp___3 = 1;
                    } else {
#line 340
                      tmp___3 = 0;
                    }
                  } else {
#line 340
                    tmp___3 = 0;
                  }
                } else {
#line 340
                  tmp___3 = 0;
                }
              } else {
#line 340
                tmp___3 = 0;
              }
#line 340
              if (tmp___3) {
#line 342
                n ++;
              }
            }
#line 343
            if (scp->sc_xflags & (1UL << 9)) {
#line 343
              if (cp->co_flags & 1UL) {
#line 343
                tmp___4 = & cp->co_remote_address;
              } else {
#line 343
                tmp___4 = (union xsockaddr  const  *)((void *)0);
              }
#line 343
              if (cop->co_remote_address.sa_in.sin_addr.s_addr == (in_addr_t )tmp___4->sa_in.sin_addr.s_addr) {
#line 346
                n ++;
              }
            }
          }
        }
#line 332
        u ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 350
      if (n >= scp->sc_per_source) {
#line 351
        return ((access_e )5);
      }
    }
  }
#line 355
  if (ps.ros.process_limit) {
#line 356
    if (scp->sc_xflags & 1UL) {
#line 356
      tmp___6 = 2;
    } else {
#line 356
      tmp___6 = 1;
    }
#line 356
    processes_to_create = (unsigned int )tmp___6;
#line 358
    if ((rlim_t )((ps.rws.servers)->count + processes_to_create) > ps.ros.process_limit) {
#line 360
      return ((access_e )6);
    }
  }
#line 364
  return ((access_e )0);
}
}
#line 22 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.c"
struct name_value  const  service_types[7]  = {      {"RPC", 1}, 
        {"INTERNAL", 2}, 
        {"UNLISTED", 3}, 
        {"SPECIAL", 4}, 
        {"TCPMUX", 6}, 
        {"TCPMUXPLUS", 7}, 
        {(char const   *)((char *)0), 0}};
#line 37 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.c"
struct name_value  const  service_flags[13]  = 
#line 37
  {      {"REUSE", 2}, 
        {"INTERCEPT", 1}, 
        {"NORETRY", 3}, 
        {"IDONLY", 4}, 
        {"NAMEINARGS", 5}, 
        {"NODELAY", 6}, 
        {"KEEPALIVE", 7}, 
        {"NOLIBWRAP", 8}, 
        {"SENSOR", 9}, 
        {"IPv4", 10}, 
        {"IPv6", 11}, 
        {"LABELED", 12}, 
        {(char const   *)((char *)0), 0}};
#line 55 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.c"
struct name_value  const  socket_types[6]  = {      {"stream", 1}, 
        {"dgram", 2}, 
        {"raw", 3}, 
        {"seqpacket", 5}, 
        {(char const   *)((char *)0), 1}, 
        {"BAD SOCKET TYPE", 0}};
#line 66 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.c"
struct name_value  const  success_log_options[7]  = {      {"HOST", 1}, 
        {"DURATION", 3}, 
        {"EXIT", 5}, 
        {"PID", 6}, 
        {"USERID", 7}, 
        {"TRAFFIC", 8}, 
        {(char const   *)((char *)0), 0}};
#line 78 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.c"
struct name_value  const  failure_log_options[4]  = {      {"HOST", 1}, 
        {"ATTEMPT", 4}, 
        {"USERID", 7}, 
        {(char const   *)((char *)0), 0}};
#line 88 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.c"
struct name_value  const  syslog_facilities[19]  = 
#line 88
  {      {"daemon", 3 << 3}, 
        {"auth", 4 << 3}, 
        {"authpriv", 10 << 3}, 
        {"user", 1 << 3}, 
        {"mail", 2 << 3}, 
        {"lpr", 6 << 3}, 
        {"news", 7 << 3}, 
        {"uucp", 8 << 3}, 
        {"ftp", 11 << 3}, 
        {"local0", 16 << 3}, 
        {"local1", 17 << 3}, 
        {"local2", 18 << 3}, 
        {"local3", 19 << 3}, 
        {"local4", 20 << 3}, 
        {"local5", 21 << 3}, 
        {"local6", 22 << 3}, 
        {"local7", 23 << 3}, 
        {(char const   *)((char *)0), 1}, 
        {"BAD FACILITY", 0}};
#line 124 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/nvlists.c"
struct name_value  const  syslog_levels[10]  = 
#line 124
  {      {"emerg", 0}, 
        {"alert", 1}, 
        {"crit", 2}, 
        {"err", 3}, 
        {"warning", 4}, 
        {"notice", 5}, 
        {"info", 6}, 
        {"debug", 7}, 
        {(char const   *)((char *)0), 1}, 
        {"BAD LEVEL", 0}};
#line 163 "../libs/include/sio.h"
extern char *Srdline(int fd ) ;
#line 71 "../libs/include/str.h"
extern str_h str_parse(char *str , char const   *separ , int flags , int *errnop ) ;
#line 72
extern void str_endparse(str_h handle ) ;
#line 73
extern char *str_component(str_h handle ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsesup.h"
char *next_line(int fd ) ;
#line 7
status_e parse_line(char *line , char **namep , enum assign_op *opp , pset_h values ) ;
#line 9
void skip_entry(int fd ) ;
#line 10
int line_has_only_1_char(char const   *line , char ch ) ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsesup.c"
char *next_line(int fd ) 
{ 
  char *p ;
  char *line ;
  char *tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 29
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 32
    tmp = Srdline(fd);
#line 32
    line = tmp;
    }
#line 34
    if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 35
      return ((char *)((void *)0));
    }
#line 37
    line_count ++;
#line 39
    p = line;
    {
#line 39
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 40
      if ((int )*p == 0) {
#line 41
        goto while_break___0;
      } else
#line 40
      if ((int )*p == 35) {
#line 41
        goto while_break___0;
      } else {
        {
#line 42
        tmp___0 = __ctype_b_loc();
        }
#line 42
        if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 43
          goto __Cont;
        } else {
#line 45
          return (line);
        }
      }
      __Cont: /* CIL Label */ 
#line 39
      p ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsesup.c"
static char *get_attr_op(char *line , char **attrp , enum assign_op *opp ) 
{ 
  char *p ;
  char *attr ;
  enum assign_op op ;
  char const   *func ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___4 ;

  {
#line 67
  func = "get_attr_op";
#line 72
  p = line;
  {
#line 72
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 72
    tmp = __ctype_b_loc();
    }
#line 72
    if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 72
      goto while_break;
    }
#line 72
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 73
  if ((int )*p == 0) {
    {
#line 75
    parsemsg(3, func, "Empty line");
    }
#line 76
    return ((char *)((void *)0));
  }
#line 79
  attr = p;
  {
#line 80
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 80
    tmp___0 = __ctype_b_loc();
    }
#line 80
    if ((int const   )*(*tmp___0 + (int )*p) & 8192) {
#line 80
      goto while_break___0;
    } else
#line 80
    if (! ((int )*p != 61)) {
#line 80
      goto while_break___0;
    }
#line 80
    p ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 81
  if ((int )*p == 0) {
    {
#line 83
    parsemsg(3, func, "Nothing after attribute: %s", attr);
    }
#line 84
    return ((char *)((void *)0));
  }
#line 86
  if ((int )*p == 61) {
    {
#line 87
    *p = (char )'\000';
#line 88
    parsemsg(3, func, "Attribute %s needs a space before operator", attr);
    }
#line 89
    return ((char *)((void *)0));
  }
#line 91
  tmp___1 = p;
#line 91
  p ++;
#line 91
  *tmp___1 = (char )'\000';
  {
#line 93
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 93
    tmp___2 = __ctype_b_loc();
    }
#line 93
    if (! ((int const   )*(*tmp___2 + (int )*p) & 8192)) {
#line 93
      goto while_break___1;
    }
#line 93
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 97
  if ((int )*p == 0) {
#line 97
    goto case_0;
  }
#line 101
  if ((int )*p == 61) {
#line 101
    goto case_61;
  }
#line 106
  if ((int )*p == 45) {
#line 106
    goto case_45;
  }
#line 106
  if ((int )*p == 43) {
#line 106
    goto case_45;
  }
#line 113
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 98
  parsemsg(3, func, "Nothing after attribute: %s", attr);
  }
#line 99
  return ((char *)((void *)0));
  case_61: /* CIL Label */ 
#line 102
  op = (enum assign_op )0;
#line 103
  goto switch_break;
  case_45: /* CIL Label */ 
  case_43: /* CIL Label */ 
#line 107
  tmp___4 = p;
#line 107
  p ++;
#line 107
  if ((int )*tmp___4 == 43) {
#line 107
    op = (enum assign_op )1;
  } else {
#line 107
    op = (enum assign_op )2;
  }
#line 108
  if ((int )*p == 61) {
#line 109
    goto switch_break;
  }
  switch_default: /* CIL Label */ 
  {
#line 114
  parsemsg(3, func, "Bad operator for attribute: %s", attr);
  }
#line 115
  return ((char *)((void *)0));
  switch_break: /* CIL Label */ ;
  }
#line 117
  *attrp = attr;
#line 118
  *opp = op;
#line 119
  p ++;
#line 119
  return (p);
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsesup.c"
status_e parse_line(char *line , char **namep , enum assign_op *opp , pset_h values ) 
{ 
  char *value ;
  char *values_string ;
  char *attribute ;
  str_h strp___0 ;
  char const   *func ;
  __pset_pointer tmp ;

  {
  {
#line 140
  func = "parse_line";
#line 142
  values_string = get_attr_op(line, & attribute, opp);
  }
#line 142
  if ((unsigned long )values_string == (unsigned long )((void *)0)) {
#line 143
    return ((status_e )0);
  }
  {
#line 148
  strp___0 = str_parse(values_string, " \t", 1, (int *)0);
  }
#line 149
  if ((unsigned long )strp___0 == (unsigned long )((void *)0)) {
    {
#line 151
    parsemsg(2, func, "out of memory");
    }
#line 152
    return ((status_e )0);
  }
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 155
    value = str_component(strp___0);
    }
#line 155
    if (! value) {
#line 155
      goto while_break;
    }
    {
#line 157
    tmp = pset_add(values, (__pset_pointer const   )value);
    }
#line 157
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 159
      parsemsg(2, func, "out of memory");
#line 160
      str_endparse(strp___0);
      }
#line 161
      return ((status_e )0);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 165
  str_endparse(strp___0);
#line 166
  *namep = attribute;
  }
#line 167
  return ((status_e )1);
}
}
#line 171 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsesup.c"
void skip_entry(int fd ) 
{ 
  char *line ;
  char *tmp ;
  int tmp___0 ;

  {
  {
#line 173
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 175
    tmp = next_line(fd);
#line 175
    line = tmp;
    }
#line 177
    if ((unsigned long )line == (unsigned long )((void *)0)) {
      {
#line 179
      parsemsg(4, "skip_entry", "missing %c in last service entry", '}');
      }
#line 181
      goto while_break;
    }
    {
#line 184
    tmp___0 = line_has_only_1_char((char const   *)line, (char )'}');
    }
#line 184
    if (tmp___0) {
#line 185
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parsesup.c"
int line_has_only_1_char(char const   *line , char ch ) 
{ 
  char const   *p ;
  char target_char ;
  unsigned short const   **tmp ;

  {
#line 198
  target_char = ch;
#line 200
  p = line;
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! *p) {
#line 200
      goto while_break;
    }
#line 201
    if ((int const   )*p == (int const   )target_char) {
#line 202
      target_char = (char )'\000';
    } else {
      {
#line 203
      tmp = __ctype_b_loc();
      }
#line 203
      if (! ((int const   )*(*tmp + (int )*p) & 8192)) {
#line 204
        return (0);
      }
    }
#line 200
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 205
  return ((int )target_char != (int )ch);
}
}
#line 342 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 26 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/inet.c"
static int get_next_inet_entry(int fd , pset_h sconfs , struct service_config *defaults ) ;
#line 29 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/inet.c"
void parse_inet_conf_file(int fd , struct configuration *confp ) 
{ 
  pset_h sconfs ;
  struct service_config *default_config ;
  int tmp ;

  {
#line 31
  sconfs = confp->cnf_service_confs;
#line 32
  default_config = confp->cnf_defaults;
#line 34
  line_count = 0;
  {
#line 36
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 38
    tmp = get_next_inet_entry(fd, sconfs, default_config);
    }
#line 38
    if (tmp == -2) {
#line 39
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 41
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/inet.c"
static int get_next_inet_entry(int fd , pset_h sconfs , struct service_config *defaults ) 
{ 
  char *p ;
  str_h strp___0 ;
  char *line ;
  char *tmp ;
  struct service_config *scp ;
  unsigned int u ;
  unsigned int i ;
  char const   *func ;
  char *name___0 ;
  char *rpcvers ;
  char *rpcproto ;
  char *group ;
  char *proto ;
  char *stype ;
  struct name_value  const  *nvp ;
  struct protoent *pep ;
  struct passwd *pw ;
  struct group *grp ;
  char const   *dot ;
  char const   *slash ;
  pset_h args ;
  __pset_pointer tmp___0 ;
  int rpcmin ;
  int rpcmax ;
  struct rpc_data *rdp ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  struct group *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  char **tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  __pset_pointer tmp___20 ;

  {
  {
#line 48
  tmp = next_line(fd);
#line 48
  line = tmp;
#line 51
  func = "get_next_inet_entry";
#line 52
  name___0 = (char *)((void *)0);
#line 52
  rpcvers = (char *)((void *)0);
#line 52
  rpcproto = (char *)((void *)0);
#line 58
  dot = ".";
#line 59
  slash = "/";
  }
#line 62
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 63
    return (-2);
  }
  {
#line 65
  strp___0 = str_parse(line, " \t", 1, (int *)0);
  }
#line 66
  if ((unsigned long )strp___0 == (unsigned long )((void *)0)) {
    {
#line 68
    parsemsg(2, func, "inetd.conf - str_parse failed");
    }
#line 69
    return (-1);
  }
  {
#line 72
  args = pset_create(10U, 10U);
  }
#line 72
  if ((unsigned long )args == (unsigned long )((void *)0)) {
    {
#line 74
    out_of_memory(func);
    }
#line 75
    return (-1);
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 79
    p = str_component(strp___0);
    }
#line 79
    if (! p) {
#line 79
      goto while_break;
    }
    {
#line 81
    tmp___0 = pset_add(args, (__pset_pointer const   )p);
    }
#line 81
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 83
      parsemsg(2, func, "out of memory");
#line 84
      pset_destroy(args);
      }
#line 85
      return (-1);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 88
  str_endparse(strp___0);
#line 91
  name___0 = new_string((char const   *)((char *)*(args->ptrs + 0U)));
  }
#line 92
  if ((unsigned long )name___0 == (unsigned long )((void *)0)) {
    {
#line 93
    parsemsg(3, func, "inetd.conf - Invalid service name");
#line 94
    pset_destroy(args);
    }
#line 95
    return (-1);
  }
  {
#line 99
  rpcvers = strstr((char const   *)name___0, slash);
  }
#line 99
  if ((unsigned long )rpcvers != (unsigned long )((void *)0)) {
#line 100
    *rpcvers = (char )'\000';
#line 101
    rpcvers ++;
  }
  {
#line 104
  scp = sc_alloc((char const   *)name___0);
  }
#line 105
  if ((unsigned long )scp == (unsigned long )((void *)0)) {
    {
#line 107
    pset_destroy(args);
#line 108
    free((void *)name___0);
    }
#line 109
    return (-1);
  }
  {
#line 115
  free((void *)name___0);
#line 121
  scp->sc_groups = (boolean_e )1;
#line 122
  scp->sc_specified_attributes |= 1UL << 27;
#line 122
  scp->sc_attributes_present |= 1UL << 27;
#line 125
  stype = (char *)*(args->ptrs + 1U);
  }
#line 126
  if ((unsigned long )stype == (unsigned long )((void *)0)) {
    {
#line 127
    parsemsg(3, func, "inetd.conf - Invalid socket type");
#line 128
    pset_destroy(args);
#line 129
    sc_free(scp);
    }
#line 130
    return (-1);
  }
  {
#line 132
  nvp = nv_find_value(socket_types, (char const   *)stype);
  }
#line 133
  if ((unsigned long )nvp == (unsigned long )((void *)0)) {
    {
#line 135
    parsemsg(3, func, "inetd.conf - Bad socket type: %s", p);
#line 136
    pset_destroy(args);
#line 137
    sc_free(scp);
    }
#line 138
    return (-1);
  }
  {
#line 141
  scp->sc_socket_type = (int )nvp->value;
#line 144
  proto = (char *)*(args->ptrs + 2U);
#line 145
  tmp___4 = strstr((char const   *)proto, "rpc");
  }
#line 145
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 148
    rdp = & scp->sc_rd;
#line 150
    if ((unsigned long )rpcvers == (unsigned long )((void *)0)) {
      {
#line 151
      pset_destroy(args);
#line 152
      sc_free(scp);
      }
#line 153
      return (-1);
    }
    {
#line 157
    p = strchr((char const   *)rpcvers, '-');
    }
#line 158
    if (p) {
      {
#line 158
      tmp___3 = parse_int((char const   *)rpcvers, 10, '-', & rpcmin);
      }
#line 158
      if (tmp___3 == 0) {
        {
#line 159
        tmp___1 = parse_base10((char const   *)(p + 1), & rpcmax);
        }
#line 159
        if (tmp___1) {
          {
#line 160
          pset_destroy(args);
#line 161
          sc_free(scp);
          }
#line 162
          return (-1);
        } else
#line 159
        if (rpcmin > rpcmax) {
          {
#line 160
          pset_destroy(args);
#line 161
          sc_free(scp);
          }
#line 162
          return (-1);
        }
      } else {
#line 158
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 165
      tmp___2 = parse_base10((char const   *)rpcvers, & rpcmin);
      }
#line 165
      if (tmp___2) {
        {
#line 166
        pset_destroy(args);
#line 167
        sc_free(scp);
        }
#line 168
        return (-1);
      }
#line 171
      rpcmax = rpcmin;
    }
    {
#line 175
    rdp->rd_min_version = (unsigned long )rpcmin;
#line 176
    rdp->rd_max_version = (unsigned long )rpcmax;
#line 178
    rpcproto = strstr((char const   *)proto, slash);
    }
#line 179
    if ((unsigned long )rpcproto == (unsigned long )((void *)0)) {
      {
#line 180
      parsemsg(3, func, "inetd.conf - bad rpc version numbers");
#line 181
      pset_destroy(args);
#line 182
      sc_free(scp);
      }
#line 183
      return (-1);
    }
    {
#line 185
    *rpcproto = (char )'\000';
#line 186
    rpcproto ++;
#line 187
    proto = rpcproto;
#line 190
    nvp = nv_find_value(service_types, "RPC");
    }
#line 191
    if ((unsigned long )nvp == (unsigned long )((void *)0)) {
      {
#line 193
      parsemsg(4, func, "inetd.conf - Bad foo %s", name___0);
#line 194
      pset_destroy(args);
#line 195
      sc_free(scp);
      }
#line 196
      return (-1);
    }
#line 199
    scp->sc_type |= 1UL << (nvp->value - 1);
  }
  {
#line 201
  pep = getprotobyname((char const   *)proto);
  }
#line 201
  if ((unsigned long )pep == (unsigned long )((void *)0)) {
    {
#line 203
    parsemsg(3, func, "inetd.conf - Protocol %s not in /etc/protocols", proto);
#line 205
    pset_destroy(args);
#line 206
    sc_free(scp);
    }
#line 207
    return (-1);
  }
  {
#line 210
  scp->sc_protocol.name = new_string((char const   *)proto);
  }
#line 211
  if ((unsigned long )scp->sc_protocol.name == (unsigned long )((void *)0)) {
    {
#line 213
    out_of_memory(func);
#line 214
    pset_destroy(args);
#line 215
    sc_free(scp);
    }
#line 216
    return (-1);
  }
#line 218
  scp->sc_protocol.value = pep->p_proto;
#line 219
  scp->sc_specified_attributes |= 1UL << 2;
#line 219
  scp->sc_attributes_present |= 1UL << 2;
#line 222
  p = (char *)*(args->ptrs + 3U);
#line 223
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 224
    parsemsg(3, func, "inetd.conf - No value specified for wait");
#line 225
    sc_free(scp);
    }
#line 226
    return (-1);
  }
  {
#line 228
  tmp___6 = strcasecmp((char const   *)p, "wait");
  }
#line 228
  if (tmp___6 == 0) {
#line 229
    scp->sc_wait = (boolean_e )1;
  } else {
    {
#line 230
    tmp___5 = strcasecmp((char const   *)p, "nowait");
    }
#line 230
    if (tmp___5 == 0) {
#line 231
      scp->sc_wait = (boolean_e )0;
    } else {
      {
#line 233
      parsemsg(3, func, "inetd.conf - Bad value for wait: %s", p);
      }
    }
  }
#line 236
  p = (char *)*(args->ptrs + 4U);
#line 237
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 238
    parsemsg(3, func, "inetd.conf - No value specified for user");
#line 239
    sc_free(scp);
    }
#line 240
    return (-1);
  }
  {
#line 242
  group = strstr((char const   *)p, dot);
  }
#line 242
  if (group) {
    {
#line 244
    *group = (char )'\000';
#line 245
    group ++;
#line 247
    tmp___7 = getgrnam((char const   *)group);
#line 247
    grp = tmp___7;
    }
#line 248
    if ((unsigned long )grp == (unsigned long )((void *)0)) {
      {
#line 250
      parsemsg(3, func, "inetd.conf - Unknown group: %s", group);
#line 251
      pset_destroy(args);
#line 252
      sc_free(scp);
      }
#line 253
      return (-1);
    }
#line 256
    scp->sc_gid = grp->gr_gid;
#line 257
    scp->sc_specified_attributes |= 1UL << 4;
#line 257
    scp->sc_attributes_present |= 1UL << 4;
  }
  {
#line 260
  pw = getpwnam((char const   *)p);
  }
#line 261
  if ((unsigned long )pw == (unsigned long )((void *)0)) {
    {
#line 263
    parsemsg(3, func, "inetd.conf - Unknown user: %s", p);
#line 264
    pset_destroy(args);
#line 265
    sc_free(scp);
    }
#line 266
    return (-1);
  }
  {
#line 268
  str_fill(pw->pw_passwd, (char )' ');
#line 269
  scp->sc_uid = pw->pw_uid;
#line 270
  scp->sc_user_gid = pw->pw_gid;
#line 273
  p = (char *)*(args->ptrs + 5U);
  }
#line 274
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 275
    parsemsg(3, func, "inetd.conf - No value specified for user");
#line 276
    sc_free(scp);
    }
#line 277
    return (-1);
  }
  {
#line 279
  tmp___19 = strcasecmp((char const   *)p, "internal");
  }
#line 279
  if (tmp___19 == 0) {
    {
#line 281
    nvp = nv_find_value(service_types, "INTERNAL");
    }
#line 282
    if ((unsigned long )nvp == (unsigned long )((void *)0)) {
      {
#line 284
      parsemsg(4, func, "inetd.conf - Bad foo %s", name___0);
#line 285
      pset_destroy(args);
#line 286
      sc_free(scp);
      }
#line 287
      return (-1);
    }
    {
#line 290
    scp->sc_type |= 1UL << (nvp->value - 1);
#line 292
    tmp___9 = strcasecmp((char const   *)scp->sc_name, "time");
    }
#line 292
    if (tmp___9 == 0) {
      {
#line 293
      tmp___8 = strcasecmp((char const   *)proto, "stream");
      }
#line 293
      if (tmp___8 == 0) {
        {
#line 294
        scp->sc_id = new_string("time-stream");
        }
      } else {
        {
#line 296
        scp->sc_id = new_string("time-dgram");
        }
      }
    }
    {
#line 299
    tmp___11 = strcasecmp((char const   *)scp->sc_name, "daytime");
    }
#line 299
    if (tmp___11 == 0) {
      {
#line 300
      tmp___10 = strcasecmp((char const   *)proto, "stream");
      }
#line 300
      if (tmp___10 == 0) {
        {
#line 301
        scp->sc_id = new_string("daytime-stream");
        }
      } else {
        {
#line 303
        scp->sc_id = new_string("daytime-dgram");
        }
      }
    }
    {
#line 306
    tmp___13 = strcasecmp((char const   *)scp->sc_name, "chargen");
    }
#line 306
    if (tmp___13 == 0) {
      {
#line 307
      tmp___12 = strcasecmp((char const   *)proto, "stream");
      }
#line 307
      if (tmp___12 == 0) {
        {
#line 308
        scp->sc_id = new_string("chargen-stream");
        }
      } else {
        {
#line 310
        scp->sc_id = new_string("chargen-dgram");
        }
      }
    }
    {
#line 313
    tmp___15 = strcasecmp((char const   *)scp->sc_name, "echo");
    }
#line 313
    if (tmp___15 == 0) {
      {
#line 314
      tmp___14 = strcasecmp((char const   *)proto, "stream");
      }
#line 314
      if (tmp___14 == 0) {
        {
#line 315
        scp->sc_id = new_string("echo-stream");
        }
      } else {
        {
#line 317
        scp->sc_id = new_string("echo-dgram");
        }
      }
    }
    {
#line 320
    tmp___16 = strcasecmp((char const   *)scp->sc_name, "discard");
    }
#line 320
    if (tmp___16 == 0) {
      {
#line 322
      parsemsg(4, func, "inetd.conf - service discard not supported");
#line 324
      pset_destroy(args);
#line 325
      sc_free(scp);
      }
#line 326
      return (-1);
    }
  } else {
    {
#line 331
    scp->sc_server = new_string((char const   *)p);
    }
#line 332
    if ((unsigned long )scp->sc_server == (unsigned long )((void *)0)) {
      {
#line 334
      out_of_memory(func);
#line 335
      pset_destroy(args);
#line 336
      sc_free(scp);
      }
#line 337
      return (-1);
    }
    {
#line 339
    scp->sc_specified_attributes |= 1UL << 5;
#line 339
    scp->sc_attributes_present |= 1UL << 5;
#line 342
    tmp___17 = argv_alloc(args->count + 1U);
#line 342
    scp->sc_server_argv = tmp___17;
#line 344
    u = 0U;
    }
    {
#line 344
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 344
      if (! (u < args->count - 6U)) {
#line 344
        goto while_break___0;
      }
      {
#line 346
      p = new_string((char const   *)((char *)*(args->ptrs + (u + 6U))));
      }
#line 347
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 349
        i = 1U;
        {
#line 349
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 349
          if (! (i < u)) {
#line 349
            goto while_break___1;
          }
          {
#line 350
          free((void *)*(scp->sc_server_argv + i));
#line 349
          i ++;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 351
        free((void *)scp->sc_server_argv);
#line 352
        pset_destroy(args);
#line 353
        sc_free(scp);
        }
#line 354
        return (-1);
      }
#line 356
      *(scp->sc_server_argv + u) = p;
#line 344
      u ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 359
    nvp = nv_find_value(service_flags, "REUSE");
    }
#line 360
    if ((unsigned long )nvp == (unsigned long )((void *)0)) {
      {
#line 362
      parsemsg(4, func, "inetd.conf - Bad foo %s", name___0);
#line 363
      pset_destroy(args);
#line 364
      sc_free(scp);
      }
#line 365
      return (-1);
    }
    {
#line 367
    scp->sc_xflags |= 1UL << (nvp->value - 1);
#line 370
    nvp = nv_find_value(service_flags, "NOLIBWRAP");
    }
#line 371
    if ((unsigned long )nvp == (unsigned long )((void *)0)) {
      {
#line 373
      parsemsg(4, func, "inetd.conf - Bad foo %s", name___0);
#line 374
      pset_destroy(args);
#line 375
      sc_free(scp);
      }
#line 376
      return (-1);
    }
    {
#line 378
    scp->sc_xflags |= 1UL << (nvp->value - 1);
#line 381
    nvp = nv_find_value(service_flags, "NAMEINARGS");
    }
#line 382
    if ((unsigned long )nvp == (unsigned long )((void *)0)) {
      {
#line 384
      parsemsg(4, func, "inetd.conf - Bad foo %s", name___0);
#line 385
      pset_destroy(args);
#line 386
      sc_free(scp);
      }
#line 387
      return (-1);
    }
    {
#line 389
    scp->sc_xflags |= 1UL << (nvp->value - 1);
#line 390
    scp->sc_specified_attributes |= 1UL << 6;
#line 390
    scp->sc_attributes_present |= 1UL << 6;
#line 392
    tmp___18 = new_string((char const   *)scp->sc_name);
#line 392
    scp->sc_id = tmp___18;
    }
#line 392
    if (tmp___18) {
#line 393
      scp->sc_attributes_present |= 1UL << 8;
    } else {
      {
#line 396
      out_of_memory(func);
#line 397
      pset_destroy(args);
#line 398
      sc_free(scp);
      }
#line 399
      return (-1);
    }
  }
  {
#line 403
  scp->sc_specified_attributes |= 1UL << 2;
#line 403
  scp->sc_attributes_present |= 1UL << 2;
#line 404
  scp->sc_specified_attributes |= 1UL << 3;
#line 404
  scp->sc_attributes_present |= 1UL << 3;
#line 405
  scp->sc_specified_attributes |= 1UL << 1;
#line 405
  scp->sc_attributes_present |= 1UL << 1;
#line 406
  scp->sc_specified_attributes |= 1UL;
#line 406
  scp->sc_attributes_present |= 1UL;
#line 408
  tmp___20 = pset_add(sconfs, (__pset_pointer const   )scp);
  }
#line 408
  if (! tmp___20) {
    {
#line 410
    out_of_memory(func);
#line 411
    pset_destroy(args);
#line 412
    sc_free(scp);
    }
#line 413
    return (-1);
  }
  {
#line 416
  pset_destroy(args);
#line 417
  parsemsg(7, func, "added service %s", scp->sc_name);
  }
#line 418
  return (0);
}
}
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.h"
 __attribute__((__noreturn__)) void di_exit(void) ;
#line 11
struct intercept_s *di_init(struct server *serp ) ;
#line 54 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
static struct idgram_private idgram  ;
#line 56
static void di_mux(void) ;
#line 57
static void udp_remote_to_local(struct intercept_s *ip , channel_s **chpp ) ;
#line 58
static status_e udp_local_to_remote(channel_s *chp ) ;
#line 59
static void send_data(int sd , char *buf___0 , int len , union xsockaddr *addr ) ;
#line 60
static status_e get_incoming_packet(struct intercept_s *ip , packet_s *pp ) ;
#line 62 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
static struct intercept_ops  const  idgram_ops  =    {& di_mux, & di_exit};
#line 69 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
static struct intercept_s dgram_intercept_state  ;
#line 72 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
struct intercept_s *di_init(struct server *serp ) 
{ 
  struct intercept_s *ip ;

  {
  {
#line 74
  ip = & dgram_intercept_state;
#line 76
  ip->int_socket_type = 2;
#line 77
  ip->int_priv = (void *)(& idgram);
#line 78
  ip->int_ops = & idgram_ops;
#line 79
  int_init(ip, serp);
  }
#line 80
  return (ip);
}
}
#line 84
 __attribute__((__noreturn__)) void di_exit(void) ;
#line 84 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
void di_exit(void) 
{ 
  struct intercept_s *ip ;

  {
#line 86
  ip = & dgram_intercept_state;
#line 88
  if (((struct idgram_private *)ip->int_priv)->received_packets == 0U) {
    {
#line 89
    drain(ip->int_common.ic_remote_socket);
    }
  }
  {
#line 90
  int_exit(ip);
  }
}
}
#line 97 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
static void di_mux(void) 
{ 
  struct intercept_s *ip ;
  fd_set socket_mask ;
  int mask_max ;
  int __d0 ;
  int __d1 ;
  unsigned int u ;
  channel_s *chp ;
  fd_set read_mask ;
  int n_ready ;
  status_e tmp ;

  {
#line 99
  ip = & dgram_intercept_state;
  {
#line 103
  while (1) {
    while_continue: /* CIL Label */ ;
#line 103
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& socket_mask.__fds_bits[0]): "memory");
#line 103
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 104
  socket_mask.__fds_bits[ip->int_common.ic_remote_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << ip->int_common.ic_remote_socket % (8 * (int )sizeof(__fd_mask ));
#line 105
  mask_max = ip->int_common.ic_remote_socket;
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 114
    read_mask = socket_mask;
#line 115
    n_ready = int_select(mask_max + 1, & read_mask);
    }
#line 117
    if (n_ready == -1) {
#line 118
      return;
    }
#line 120
    if ((read_mask.__fds_bits[ip->int_common.ic_remote_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << ip->int_common.ic_remote_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 122
      udp_remote_to_local(ip, & chp);
      }
#line 123
      if ((unsigned long )chp != (unsigned long )((void *)0)) {
#line 125
        socket_mask.__fds_bits[chp->ch_local_socket / (8 * (int )sizeof(__fd_mask ))] |= 1L << chp->ch_local_socket % (8 * (int )sizeof(__fd_mask ));
#line 126
        if (chp->ch_local_socket > mask_max) {
#line 127
          mask_max = chp->ch_local_socket;
        }
      }
#line 129
      n_ready --;
#line 129
      if (n_ready == 0) {
#line 130
        goto __Cont;
      }
    }
#line 133
    u = 0U;
    {
#line 133
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 133
      if (! (u < (ip->int_common.ic_connections)->count)) {
#line 133
        goto while_break___1;
      }
#line 135
      chp = (struct channel *)*((ip->int_common.ic_connections)->ptrs + u);
#line 137
      if ((read_mask.__fds_bits[chp->ch_local_socket / (8 * (int )sizeof(__fd_mask ))] & (1L << chp->ch_local_socket % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 139
        tmp = udp_local_to_remote(chp);
        }
#line 139
        if ((unsigned int )tmp == 0U) {
#line 140
          return;
        }
#line 141
        n_ready --;
#line 141
        if (n_ready == 0) {
#line 142
          goto while_break___1;
        }
      }
#line 133
      u ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 155 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
static void udp_remote_to_local(struct intercept_s *ip , channel_s **chpp ) 
{ 
  char buf___0[32768] ;
  packet_s packet ;
  channel_s *chp ;
  bool_int addr_checked ;
  status_e tmp ;
  struct server *serp ;
  struct service *sp ;
  connection_s *cop ;
  mask_t check_mask ;
  access_e result ;

  {
  {
#line 162
  *chpp = (struct channel *)((void *)0);
#line 164
  packet.data = buf___0;
#line 165
  packet.size = (int )sizeof(buf___0);
#line 166
  tmp = get_incoming_packet(ip, & packet);
  }
#line 166
  if ((unsigned int )tmp == 0U) {
#line 167
    return;
  }
  {
#line 169
  chp = int_lookupconn(ip, & packet.from, & addr_checked);
  }
#line 170
  if ((unsigned long )chp == (unsigned long )((struct channel *)((void *)0))) {
    {
#line 172
    serp = & ip->int_common.ic_server;
#line 173
    sp = serp->svr_sp;
#line 174
    cop = serp->svr_conn;
#line 176
    chp = int_newconn(ip, & packet.from, ip->int_common.ic_remote_socket);
    }
#line 176
    if ((unsigned long )chp == (unsigned long )((void *)0)) {
#line 177
      return;
    }
    {
#line 179
    cop->co_flags |= 1UL;
#line 179
    memcpy((void */* __restrict  */)(cop->co_remote_address.pad), (void const   */* __restrict  */)(& packet.from),
           sizeof(packet.from));
    }
#line 181
    if (ip->int_common.ic_intercept) {
      {
#line 186
      check_mask = 1UL | (1UL << 1);
#line 187
      result = access_control(sp, (connection_s const   *)cop, (mask_t const   *)(& check_mask));
      }
#line 189
      if ((unsigned int )result != 0U) {
        {
#line 191
        svc_log_failure(sp, (connection_s const   *)cop, result);
#line 192
        chp->ch_state = (channel_state_e )1;
        }
#line 193
        return;
      }
    }
#line 201
    if (! addr_checked) {
      {
#line 202
      svc_log_success(sp, (connection_s const   *)cop, serp->svr_pid);
      }
    }
#line 204
    *chpp = chp;
  } else
#line 206
  if ((unsigned int )chp->ch_state == 1U) {
#line 207
    return;
  }
  {
#line 216
  send_data(chp->ch_local_socket, packet.data, packet.size, (union xsockaddr *)((void *)0));
  }
#line 218
  return;
}
}
#line 225 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
static void send_data(int sd , char *buf___0 , int len , union xsockaddr *addr ) 
{ 
  char *p ;
  int left ;
  ssize_t cc ;
  char const   *func ;
  char const   *tmp ;
  int *tmp___0 ;

  {
#line 230
  func = "send_data";
#line 232
  p = buf___0;
#line 232
  left = len;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    if (! (left > 0)) {
#line 232
      goto while_break;
    }
#line 234
    if ((unsigned long )addr == (unsigned long )((void *)0)) {
      {
#line 235
      cc = send(sd, (void const   *)p, (size_t )left, 0);
      }
    } else {
      {
#line 237
      cc = sendto(sd, (void const   *)p, (size_t )left, 0, (struct sockaddr  const  *)((struct sockaddr *)addr),
                  (socklen_t )sizeof(*addr));
      }
    }
#line 239
    if (cc == -1L) {
      {
#line 240
      tmp___0 = __errno_location();
      }
#line 240
      if (*tmp___0 == 4) {
#line 242
        cc = (ssize_t )0;
#line 243
        goto __Cont;
      } else {
#line 247
        if (addr) {
#line 247
          tmp = "sendto";
        } else {
#line 247
          tmp = "send";
        }
        {
#line 247
        msg(3, func, "%s: %m", tmp);
        }
#line 248
        return;
      }
    }
    __Cont: /* CIL Label */ 
#line 232
    left = (int )((ssize_t )left - cc);
#line 232
    p += cc;
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 255 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
static status_e get_incoming_packet(struct intercept_s *ip , packet_s *pp ) 
{ 
  socklen_t from_len ;
  char const   *func ;
  ssize_t cc ;
  int *tmp ;

  {
#line 257
  from_len = (socklen_t )0;
#line 258
  func = "get_incoming_packet";
#line 260
  if (((ip->int_common.ic_server.svr_sp)->svc_conf)->sc_xflags & (1UL << 9)) {
#line 261
    from_len = (socklen_t )sizeof(struct sockaddr_in );
  }
#line 262
  if (((ip->int_common.ic_server.svr_sp)->svc_conf)->sc_xflags & (1UL << 10)) {
#line 263
    from_len = (socklen_t )sizeof(struct sockaddr_in6 );
  }
  {
#line 265
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 269
    from_len = (socklen_t )sizeof(pp->from);
#line 270
    cc = recvfrom(ip->int_common.ic_remote_socket, (void */* __restrict  */)pp->data,
                  (size_t )pp->size, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& pp->from)),
                  (socklen_t */* __restrict  */)(& from_len));
    }
#line 272
    if (cc == -1L) {
      {
#line 274
      tmp = __errno_location();
      }
#line 274
      if (*tmp != 4) {
        {
#line 276
        msg(3, func, "recvfrom error: %m");
        }
#line 277
        return ((status_e )0);
      }
    } else
#line 280
    if (cc == 0L) {
#line 281
      return ((status_e )0);
    } else {
#line 284
      pp->size = (int )cc;
#line 285
      (((struct idgram_private *)ip->int_priv)->received_packets) ++;
#line 286
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 290
  if (from_len == 0U) {
    {
#line 292
    msg(3, func, "incoming packet had 0 length address");
    }
#line 293
    return ((status_e )0);
  }
#line 302
  return ((status_e )1);
}
}
#line 306 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/udpint.c"
static status_e udp_local_to_remote(channel_s *chp ) 
{ 
  char buf___0[32768] ;
  ssize_t cc ;
  char const   *func ;
  int *tmp ;

  {
#line 310
  func = "udp_local_to_remote";
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 314
    cc = recv(chp->ch_local_socket, (void *)(buf___0), sizeof(buf___0), 0);
    }
#line 316
    if (cc == -1L) {
      {
#line 318
      tmp = __errno_location();
      }
#line 318
      if (*tmp != 4) {
        {
#line 320
        msg(3, func, "recv from daemon: %m");
        }
#line 321
        return ((status_e )0);
      }
    } else
#line 324
    if (cc == 0L) {
#line 325
      return ((status_e )0);
    } else {
#line 327
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 336
  send_data(chp->ch_remote_socket, buf___0, (int )cc, & chp->ch_from);
  }
#line 337
  return ((status_e )1);
}
}
#line 127 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.h"
void hard_reconfig(void) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.h"
struct service_config *cnf_extract(struct configuration *confp , struct service_config *scp ) ;
#line 33
unsigned int cnf_start_services(struct configuration *confp ) ;
#line 8 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.h"
void cancel_service_retries(struct service *sp ) ;
#line 45 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static status_e readjust(struct service *sp , struct service_config **new_conf_ptr ) ;
#line 47
static void swap_defaults(struct configuration *new_conf ) ;
#line 48
static void close_default_log(struct configuration *confp , xlog_h def_log ) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
void hard_reconfig(void) 
{ 
  struct service *osp ;
  struct service_config *nscp ;
  struct configuration new_conf ;
  psi_h iter___0 ;
  unsigned int new_services ;
  unsigned int old_services ;
  unsigned int dropped_services ;
  xlog_h def_log ;
  char const   *func ;
  status_e tmp ;
  __pset_pointer tmp___0 ;
  __pset_pointer tmp___1 ;
  char *sid ;
  boolean_e drop_service ;
  status_e tmp___2 ;

  {
  {
#line 66
  old_services = 0U;
#line 67
  dropped_services = 0U;
#line 68
  def_log = ps.rws.defs.def_log;
#line 69
  func = "hard_reconfig";
#line 72
  msg(5, func, "Starting reconfiguration");
#line 74
  tmp = cnf_get(& new_conf);
  }
#line 74
  if ((unsigned int )tmp == 0U) {
    {
#line 76
    msg(4, func, "reconfiguration failed");
    }
#line 77
    return;
  }
  {
#line 80
  iter___0 = psi_create(ps.rws.services);
  }
#line 81
  if ((unsigned long )iter___0 == (unsigned long )((void *)0)) {
    {
#line 83
    out_of_memory(func);
#line 84
    cnf_free(& new_conf);
    }
#line 85
    return;
  }
  {
#line 89
  msg(5, func, "Swapping defaults");
#line 90
  swap_defaults(& new_conf);
#line 102
  iter___0->current = 0U;
#line 102
  iter___0->step = 1;
  }
#line 102
  if (iter___0->current < (iter___0->pset)->count) {
#line 102
    tmp___0 = *((iter___0->pset)->ptrs + iter___0->current);
  } else {
#line 102
    tmp___0 = (void *)0;
  }
#line 102
  osp = (struct service *)tmp___0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! osp) {
#line 102
      goto while_break;
    }
    {
#line 104
    sid = (osp->svc_conf)->sc_id;
#line 112
    nscp = cnf_extract(& new_conf, osp->svc_conf);
    }
#line 112
    if (nscp) {
      {
#line 120
      tmp___2 = readjust(osp, & nscp);
      }
#line 120
      if ((unsigned int )tmp___2 == 1U) {
#line 122
        old_services ++;
#line 123
        drop_service = (boolean_e )0;
      } else {
#line 126
        drop_service = (boolean_e )1;
      }
      {
#line 127
      sc_free(nscp);
      }
    } else {
#line 130
      drop_service = (boolean_e )1;
    }
#line 132
    if ((unsigned int )drop_service == 1U) {
      {
#line 141
      svc_deactivate(osp);
#line 142
      terminate_servers(osp);
#line 143
      cancel_service_retries(osp);
#line 152
      psi_remove(iter___0);
#line 153
      msg(5, func, "service %s deactivated", sid);
#line 154
      (osp->svc_ref_count) --;
      }
#line 154
      if (osp->svc_ref_count == 0) {
        {
#line 155
        svc_release(osp);
        }
      } else {
        {
#line 157
        msg(3, func, "Errors deactivating service %s", sid);
        }
      }
#line 158
      dropped_services ++;
    }
#line 102
    iter___0->current += (unsigned int )iter___0->step;
#line 102
    iter___0->step = 1;
#line 102
    if (iter___0->current < (iter___0->pset)->count) {
#line 102
      tmp___1 = *((iter___0->pset)->ptrs + iter___0->current);
    } else {
#line 102
      tmp___1 = (void *)0;
    }
#line 102
    osp = (struct service *)tmp___1;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  free((void *)((char *)iter___0));
#line 168
  close_default_log(& new_conf, def_log);
#line 174
  new_services = cnf_start_services(& new_conf);
#line 175
  msg(5, func, "Reconfigured: new=%d old=%d dropped=%d (services)", new_services,
      old_services, dropped_services);
  }
#line 179
  if (stayalive_option == 0) {
#line 180
    if (ps.rws.available_services == 0) {
      {
#line 182
      msg(2, func, "No available services. Exiting");
      }
#line 183
      if (ps.ros.pid_file) {
        {
#line 184
        unlink(ps.ros.pid_file);
        }
      }
      {
#line 186
      exit(1);
      }
    }
  }
  {
#line 190
  cnf_free(& new_conf);
  }
#line 191
  return;
}
}
#line 194 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static void swap_defaults(struct configuration *new_conf ) 
{ 
  struct service_config *temp ;

  {
#line 198
  ps.rws.defs.def_log_creation_failed = 0;
#line 199
  ps.rws.defs.def_log = (void *)0;
#line 200
  temp = ps.rws.defs.def_settings;
#line 200
  ps.rws.defs.def_settings = new_conf->cnf_defaults;
#line 200
  new_conf->cnf_defaults = temp;
#line 201
  return;
}
}
#line 204 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static void close_default_log(struct configuration *confp , xlog_h def_log ) 
{ 


  {
#line 207
  if ((unsigned long )def_log != (unsigned long )((void *)0)) {
    {
#line 208
    log_end(& (confp->cnf_defaults)->sc_log, def_log);
    }
  }
#line 209
  return;
}
}
#line 212 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static void sendsig(struct server *serp , int sig ) 
{ 
  char *sid ;
  pid_t pid ;
  char const   *func ;
  int i ;
  int killed ;
  struct timeval tv ;
  int wret ;
  __pid_t tmp ;
  struct server *tmp___0 ;

  {
#line 214
  sid = ((serp->svr_sp)->svc_conf)->sc_id;
#line 215
  pid = serp->svr_pid;
#line 216
  func = "sendsig";
#line 221
  if (pid > 0) {
    {
#line 223
    msg(4, func, "Sending signal %d to %s server %d", sig, sid, pid);
#line 225
    kill(pid, sig);
    }
#line 226
    if (sig == 15) {
#line 226
      goto _L;
    } else
#line 226
    if (sig == 9) {
      _L: /* CIL Label */ 
#line 228
      killed = 0;
#line 237
      tv.tv_sec = (__time_t )0;
#line 238
      tv.tv_usec = (__suseconds_t )500000;
#line 239
      i = 0;
      {
#line 239
      while (1) {
        while_continue: /* CIL Label */ ;
#line 239
        if (! (i < 8)) {
#line 239
          goto while_break;
        }
        {
#line 241
        tmp___0 = server_lookup(pid);
        }
#line 241
        if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
#line 243
          killed = 1;
#line 244
          goto while_break;
        } else {
          {
#line 246
          tmp = waitpid(pid, (int *)((void *)0), 1);
#line 246
          wret = tmp;
          }
#line 247
          if (wret == pid) {
#line 248
            killed = 1;
#line 249
            goto while_break;
          }
          {
#line 251
          server_end(serp);
          }
        }
#line 255
        if (i == 5) {
          {
#line 256
          kill(pid, 9);
          }
        }
        {
#line 259
        select(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
               (fd_set */* __restrict  */)((void *)0), (struct timeval */* __restrict  */)(& tv));
#line 239
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
#line 266
      if (! killed) {
        {
#line 267
        msg(3, func, "Server %d did not exit after SIGKILL", pid);
        }
      }
    }
  } else
#line 275
  if (pid != 0) {
    {
#line 276
    msg(3, func, "Negative server pid = %d. Service %s", pid, sid);
    }
  }
#line 277
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static void deliver_signal(struct service *sp , int sig ) 
{ 
  unsigned int u ;
  struct server *serp ;

  {
#line 287
  u = 0U;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (u < (ps.rws.servers)->count)) {
#line 287
      goto while_break;
    }
#line 291
    serp = (struct server *)*((ps.rws.servers)->ptrs + u);
#line 292
    if ((unsigned long )serp->svr_sp == (unsigned long )sp) {
      {
#line 293
      sendsig(serp, sig);
      }
#line 294
      if (sig == 15) {
#line 295
        u --;
      } else
#line 294
      if (sig == 9) {
#line 295
        u --;
      }
    }
#line 287
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 298
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
void terminate_servers(struct service *sp ) 
{ 
  int sig ;
  int tmp ;

  {
#line 306
  if ((sp->svc_conf)->sc_type & (1UL << 1)) {
#line 306
    tmp = 15;
  } else {
#line 306
    tmp = 9;
  }
  {
#line 306
  sig = tmp;
#line 308
  deliver_signal(sp, sig);
  }
#line 309
  return;
}
}
#line 312 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static void stop_interception(struct service *sp ) 
{ 


  {
  {
#line 314
  deliver_signal(sp, 10);
  }
#line 315
  return;
}
}
#line 321 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static void stop_log(struct service *sp , struct service_config *old_conf ) 
{ 
  struct log *lp ;

  {
#line 324
  lp = & old_conf->sc_log;
#line 326
  if ((unsigned int )lp->l_type != 0U) {
#line 326
    if ((unsigned long )sp->svc_log != (unsigned long )((void *)0)) {
      {
#line 327
      log_end(lp, sp->svc_log);
      }
    }
  }
#line 328
  sp->svc_log = (void *)0;
#line 329
  return;
}
}
#line 336 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static status_e restart_log(struct service *sp , struct service_config *old_conf ) 
{ 
  status_e tmp ;

  {
  {
#line 339
  stop_log(sp, old_conf);
#line 340
  tmp = log_start(sp, & sp->svc_log);
  }
#line 340
  return (tmp);
}
}
#line 351 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static status_e readjust_rpc_service(struct service_config *old_scp , struct service_config *new_scp ) 
{ 
  unsigned long vers ;
  uint16_t port ;
  struct rpc_data *new_rdp ;
  struct rpc_data *old_rdp ;
  unsigned int registered_versions ;
  char const   *func ;
  bool_t tmp ;

  {
#line 355
  port = old_scp->sc_port;
#line 356
  new_rdp = & new_scp->sc_rd;
#line 357
  old_rdp = & old_scp->sc_rd;
#line 358
  registered_versions = 0U;
#line 359
  func = "readjust_rpc_service";
#line 362
  new_scp->sc_port = old_scp->sc_port;
#line 364
  if (old_rdp->rd_min_version == new_rdp->rd_min_version) {
#line 364
    if (old_rdp->rd_max_version == new_rdp->rd_max_version) {
#line 366
      return ((status_e )1);
    }
  }
#line 368
  vers = old_rdp->rd_min_version;
  {
#line 368
  while (1) {
    while_continue: /* CIL Label */ ;
#line 368
    if (! (vers <= old_rdp->rd_max_version)) {
#line 368
      goto while_break;
    }
    {
#line 369
    pmap_unset((u_long const   )old_rdp->rd_program_number, (u_long const   )vers);
#line 368
    vers ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 371
  vers = new_rdp->rd_min_version;
  {
#line 371
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 371
    if (! (vers <= new_rdp->rd_max_version)) {
#line 371
      goto while_break___0;
    }
    {
#line 372
    tmp = pmap_set((u_long const   )new_rdp->rd_program_number, (u_long const   )vers,
                   new_scp->sc_protocol.value, port);
    }
#line 372
    if (tmp) {
#line 374
      registered_versions ++;
    } else {
      {
#line 376
      msg(3, func, "pmap_set failed. service=%s, program=%ld, version = %ld", new_scp->sc_id,
          new_rdp->rd_program_number, vers);
      }
    }
#line 371
    vers ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 380
  if (registered_versions == 0U) {
    {
#line 382
    msg(3, func, "No versions registered for RPC service %s", new_scp->sc_id);
#line 387
    new_rdp->rd_min_version = new_rdp->rd_max_version + 1UL;
    }
#line 388
    return ((status_e )0);
  }
#line 391
  return ((status_e )1);
}
}
#line 414 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/reconfig.c"
static status_e readjust(struct service *sp , struct service_config **new_conf_ptr ) 
{ 
  struct service_config *temp_conf ;
  struct service_config *old_conf ;
  struct service_config *new_conf ;
  char *sid ;
  char const   *func ;
  status_e tmp ;
  int same ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___0 ;
  status_e tmp___1 ;

  {
  {
#line 418
  old_conf = sp->svc_conf;
#line 419
  new_conf = *new_conf_ptr;
#line 420
  sid = (sp->svc_conf)->sc_id;
#line 421
  func = "readjust";
#line 423
  msg(5, func, "readjusting service %s", sid);
#line 425
  temp_conf = sp->svc_conf;
#line 425
  sp->svc_conf = *new_conf_ptr;
#line 425
  *new_conf_ptr = temp_conf;
  }
#line 427
  if (old_conf->sc_type & 1UL) {
    {
#line 427
    tmp = readjust_rpc_service(old_conf, new_conf);
    }
#line 427
    if ((unsigned int )tmp == 0U) {
#line 429
      return ((status_e )0);
    }
  }
#line 442
  if ((old_conf->sc_xflags & 1UL) != (new_conf->sc_xflags & 1UL)) {
#line 444
    if (new_conf->sc_xflags & 1UL) {
      {
#line 445
      terminate_servers(sp);
      }
    } else {
      {
#line 448
      stop_interception(sp);
#line 449
      msg(5, func, "Stopping interception for %s", sid);
      }
    }
  }
#line 461
  if ((unsigned long )old_conf->sc_bind_addr != (unsigned long )((void *)0)) {
#line 461
    if ((unsigned long )new_conf->sc_bind_addr != (unsigned long )((void *)0)) {
#line 462
      same = 0;
#line 464
      if ((int )((struct sockaddr *)old_conf->sc_bind_addr)->sa_family == (int )((struct sockaddr *)new_conf->sc_bind_addr)->sa_family) {
#line 466
        if ((int )((struct sockaddr *)old_conf->sc_bind_addr)->sa_family == 2) {
#line 467
          if (((struct sockaddr_in *)old_conf->sc_bind_addr)->sin_addr.s_addr == ((struct sockaddr_in *)new_conf->sc_bind_addr)->sin_addr.s_addr) {
#line 469
            same = 1;
          }
        } else {
#line 471
          __a = (struct in6_addr  const  *)(& ((struct sockaddr_in6 *)old_conf->sc_bind_addr)->sin6_addr);
#line 471
          __b = (struct in6_addr  const  *)(& ((struct sockaddr_in6 *)new_conf->sc_bind_addr)->sin6_addr);
#line 471
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 471
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 471
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 471
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 471
                  tmp___0 = 1;
                } else {
#line 471
                  tmp___0 = 0;
                }
              } else {
#line 471
                tmp___0 = 0;
              }
            } else {
#line 471
              tmp___0 = 0;
            }
          } else {
#line 471
            tmp___0 = 0;
          }
#line 471
          if (tmp___0) {
#line 474
            same = 1;
          }
        }
      }
#line 477
      if (! same) {
        {
#line 478
        terminate_servers(sp);
#line 479
        svc_deactivate(sp);
#line 480
        stop_log(sp, old_conf);
#line 481
        svc_activate(sp);
        }
#line 482
        return ((status_e )1);
      }
    }
  }
#line 489
  if ((unsigned long )old_conf->sc_bind_addr == (unsigned long )((void *)0)) {
#line 489
    if ((unsigned long )new_conf->sc_bind_addr != (unsigned long )((void *)0)) {
      {
#line 490
      terminate_servers(sp);
#line 491
      svc_deactivate(sp);
#line 492
      stop_log(sp, old_conf);
#line 493
      svc_activate(sp);
      }
#line 494
      return ((status_e )1);
    }
  }
#line 497
  if (old_conf->sc_xflags & (1UL << 9)) {
#line 497
    if (new_conf->sc_xflags & (1UL << 10)) {
      {
#line 499
      terminate_servers(sp);
#line 500
      svc_deactivate(sp);
#line 501
      stop_log(sp, old_conf);
#line 502
      svc_activate(sp);
      }
#line 503
      return ((status_e )1);
    } else {
#line 497
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 497
  if (old_conf->sc_xflags & (1UL << 10)) {
#line 497
    if (new_conf->sc_xflags & (1UL << 9)) {
      {
#line 499
      terminate_servers(sp);
#line 500
      svc_deactivate(sp);
#line 501
      stop_log(sp, old_conf);
#line 502
      svc_activate(sp);
      }
#line 503
      return ((status_e )1);
    }
  }
  {
#line 506
  tmp___1 = restart_log(sp, old_conf);
  }
#line 506
  return (tmp___1);
}
}
#line 25 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.c"
void cnf_free(struct configuration *confp ) 
{ 
  unsigned int u ;
  pset_h sconfs ;

  {
#line 28
  sconfs = confp->cnf_service_confs;
#line 30
  u = 0U;
  {
#line 30
  while (1) {
    while_continue: /* CIL Label */ ;
#line 30
    if (! (u < sconfs->count)) {
#line 30
      goto while_break;
    }
    {
#line 31
    sc_free((struct service_config *)*(sconfs->ptrs + u));
#line 30
    u ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 32
  pset_destroy(sconfs);
  }
#line 33
  if (confp->cnf_defaults) {
    {
#line 34
    sc_free(confp->cnf_defaults);
    }
  }
  {
#line 36
  memset((void *)((char *)confp), 0, sizeof(*confp));
  }
#line 37
  return;
}
}
#line 43 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.c"
struct service_config *cnf_extract(struct configuration *confp , struct service_config *scp ) 
{ 
  pset_h stab ;
  unsigned int u ;
  struct service_config *iscp ;
  int tmp ;
  bool_int tmp___0 ;

  {
#line 46
  stab = confp->cnf_service_confs;
#line 49
  u = 0U;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
#line 49
    if (! (u < stab->count)) {
#line 49
      goto while_break;
    }
    {
#line 51
    iscp = (struct service_config *)*(stab->ptrs + u);
#line 53
    tmp = strcasecmp((char const   *)scp->sc_id, (char const   *)iscp->sc_id);
    }
#line 53
    if (tmp == 0) {
      {
#line 53
      tmp___0 = sc_different_confs(scp, iscp);
      }
#line 53
      if (tmp___0) {
#line 54
        goto __Cont;
      }
    } else {
#line 54
      goto __Cont;
    }
#line 56
    if (u < stab->count) {
      {
#line 56
      pset_delete(stab, (__pset_pointer const   )*(stab->ptrs + u));
      }
    }
#line 57
    return (iscp);
    __Cont: /* CIL Label */ 
#line 49
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 59
  return ((struct service_config *)((void *)0));
}
}
#line 63 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.c"
void cnf_dump(struct configuration *confp , int fd ) 
{ 
  pset_h stab ;
  unsigned int u ;

  {
  {
#line 68
  stab = confp->cnf_service_confs;
#line 70
  sc_dump(confp->cnf_defaults, fd, 0, 1);
#line 71
  tabprint(fd, 0, "\n");
#line 73
  u = 0U;
  }
  {
#line 73
  while (1) {
    while_continue: /* CIL Label */ ;
#line 73
    if (! (u < stab->count)) {
#line 73
      goto while_break;
    }
    {
#line 75
    sc_dump((struct service_config *)*(stab->ptrs + u), fd, 0, 0);
#line 76
    Sputchar(fd, (char )'\n');
#line 73
    u ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.c"
status_e cnf_init(struct configuration *confp , int *fdp , psi_h *iterp ) 
{ 
  int fd ;
  pset_h pset ;
  psi_h pset_iter ;
  struct service_config *scp ;
  char const   *func ;

  {
  {
#line 87
  func = "cnf_init";
#line 92
  fd = open(ps.ros.config_file, 0);
  }
#line 94
  if (fd == -1) {
    {
#line 95
    msg(3, func, "open( %s ) failed: %m", ps.ros.config_file);
    }
#line 96
    return ((status_e )0);
  }
  {
#line 99
  pset = pset_create(0U, 0U);
  }
#line 99
  if ((unsigned long )pset == (unsigned long )((void *)0)) {
    {
#line 101
    msg(2, func, "can\'t create service table");
#line 102
    Sclose(fd);
    }
#line 103
    return ((status_e )0);
  }
  {
#line 106
  scp = sc_alloc((char const   *)((char *)0));
  }
#line 106
  if ((unsigned long )scp == (unsigned long )((void *)0)) {
    {
#line 108
    msg(3, func, "can\'t allocate defaults service");
#line 109
    pset_destroy(pset);
#line 110
    Sclose(fd);
    }
#line 111
    return ((status_e )0);
  }
  {
#line 114
  pset_iter = psi_create(pset);
  }
#line 114
  if ((unsigned long )pset_iter == (unsigned long )((void *)0)) {
    {
#line 116
    msg(3, func, "can\'t create service table iterator");
#line 117
    sc_free(scp);
#line 118
    pset_destroy(pset);
#line 119
    Sclose(fd);
    }
#line 120
    return ((status_e )0);
  }
#line 123
  *fdp = fd;
#line 124
  confp->cnf_service_confs = pset;
#line 125
  confp->cnf_defaults = scp;
#line 126
  *iterp = pset_iter;
#line 127
  return ((status_e )1);
}
}
#line 131 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.c"
static void destroy_service(struct service *sp ) 
{ 


  {
  {
#line 133
  svc_deactivate(sp);
#line 134
  svc_free(sp);
#line 135
  sp = (struct service *)((void *)0);
  }
#line 136
  return;
}
}
#line 143 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/conf.c"
unsigned int cnf_start_services(struct configuration *confp ) 
{ 
  pset_h sconfs ;
  unsigned int services_started ;
  unsigned int u ;
  char const   *func ;
  struct service_config *scp ;
  struct service *sp ;
  status_e tmp ;
  __pset_pointer tmp___0 ;

  {
#line 145
  sconfs = confp->cnf_service_confs;
#line 146
  services_started = 0U;
#line 148
  func = "cnf_start_services";
#line 150
  u = 0U;
  {
#line 150
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (! (u < sconfs->count)) {
#line 150
      goto while_break;
    }
    {
#line 152
    scp = (struct service_config *)*(sconfs->ptrs + u);
#line 155
    sp = svc_new(scp);
    }
#line 155
    if ((unsigned long )sp == (unsigned long )((void *)0)) {
      {
#line 157
      sc_free(scp);
#line 158
      scp = (struct service_config *)((void *)0);
      }
#line 159
      goto __Cont;
    }
    {
#line 162
    tmp = svc_activate(sp);
    }
#line 162
    if ((unsigned int )tmp == 0U) {
      {
#line 164
      msg(3, func, "Service %s failed to start and is deactivated.", (sp->svc_conf)->sc_id);
#line 167
      svc_free(sp);
#line 168
      scp = (struct service_config *)((void *)0);
      }
#line 169
      goto __Cont;
    }
#line 177
    if (ps.rws.descriptors_free < 0) {
      {
#line 179
      msg(3, func, "Service %s disabled because of lack of file descriptors", (sp->svc_conf)->sc_id);
#line 182
      destroy_service(sp);
      }
#line 183
      goto __Cont;
    }
    {
#line 189
    tmp___0 = pset_add(ps.rws.services, (__pset_pointer const   )sp);
    }
#line 189
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 191
      out_of_memory(func);
#line 192
      destroy_service(sp);
      }
#line 193
      goto while_break;
    }
#line 196
    (sp->svc_ref_count) ++;
#line 198
    services_started ++;
#line 200
    if (debug.on) {
      {
#line 201
      msg(7, func, "Started service: %s", (sp->svc_conf)->sc_id);
      }
    }
    __Cont: /* CIL Label */ 
#line 150
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  sconfs->count = 0U;
#line 211
  if (debug.on) {
    {
#line 212
    msg(7, func, "mask_max = %d, services_started = %d", ps.rws.mask_max, services_started);
    }
  }
#line 215
  return (services_started);
}
}
#line 297 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fchmod)(int __fd ,
                                                                             __mode_t __mode ) ;
#line 50 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit *__rlimits ) ;
#line 531 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 678
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) geteuid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 190 "../libs/include/sio.h"
extern int Smorefds(int  ) ;
#line 15 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.h"
status_e signal_init(void) ;
#line 62 "../libs/include/xlog.h"
extern int xlog_parms(xlog_e type  , ...) ;
#line 9 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.h"
void spec_include(void) ;
#line 44 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static struct module  const  program_modules[3]  = {      {"signal", & signal_init}, 
        {"environment", & initenv}, 
        {(char const   *)((char *)0), (status_e (*)())((void *)0)}};
#line 52 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static bool_int have_stderr  ;
#line 56
static void set_fd_limit(void) ;
#line 63
static  __attribute__((__noreturn__)) void syscall_failed(char const   *call ) ;
#line 63 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static void syscall_failed(char const   *call ) 
{ 
  char *err ;
  int *tmp ;

  {
#line 69
  if (have_stderr) {
    {
#line 71
    tmp = __errno_location();
#line 71
    err = strerror(*tmp);
#line 72
    Sprint(2, "%s: %s failed: %s\n", program_name, call, err);
    }
  }
  {
#line 74
  exit(1);
  }
}
}
#line 88 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static void setup_file_descriptors(void) 
{ 
  int fd ;
  int new_fd ;
  int null_fd ;
  int tmp ;
  int tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 94
  tmp = Smorefds(3);
  }
#line 94
  if (tmp == -1) {
    {
#line 96
    syscall_failed("Smorefds");
#line 97
    exit(1);
    }
  }
  {
#line 100
  set_fd_limit();
#line 105
  fd = 3;
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! ((rlim_t )((unsigned int )fd) < ps.ros.max_descriptors)) {
#line 105
      goto while_break;
    }
    {
#line 106
    tmp___0 = Sclose(fd);
    }
#line 106
    if (tmp___0) {
      {
#line 106
      tmp___1 = __errno_location();
      }
#line 106
      if (*tmp___1 != 9) {
        {
#line 108
        syscall_failed("Sclose");
#line 109
        exit(1);
        }
      }
    }
#line 105
    fd ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 115
  new_fd = dup(2);
  }
#line 116
  if (new_fd != -1) {
    {
#line 118
    have_stderr = 1;
#line 119
    Sclose(new_fd);
    }
  }
  {
#line 122
  null_fd = open("/dev/null", 0);
  }
#line 122
  if (null_fd == -1) {
    {
#line 123
    syscall_failed("open of \'/dev/null\'");
    }
  }
#line 125
  fd = 0;
  {
#line 125
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 125
    if (! (fd <= 2)) {
#line 125
      goto while_break___0;
    }
#line 127
    if (have_stderr) {
#line 127
      if (fd == 2) {
#line 128
        goto __Cont;
      }
    }
#line 129
    if (fd != null_fd) {
      {
#line 129
      tmp___2 = dup2(null_fd, fd);
      }
#line 129
      if (tmp___2 == -1) {
        {
#line 130
        syscall_failed("dup2");
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 125
    fd ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 133
  if (null_fd > 2) {
    {
#line 134
    Sclose(null_fd);
    }
  }
#line 135
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static void set_fd_limit(void) 
{ 
  struct rlimit rl ;
  rlim_t maxfd ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 148
  tmp = getrlimit(7, & rl);
  }
#line 148
  if (tmp == -1) {
    {
#line 150
    syscall_failed("getrlimit(RLIMIT_NOFILE)");
#line 151
    exit(1);
    }
  }
#line 154
  maxfd = rl.rlim_max;
#line 155
  if (rl.rlim_max == 0xffffffffffffffffUL) {
#line 156
    rl.rlim_max = (rlim_t )1024;
  }
#line 160
  if (rl.rlim_max > 1024UL) {
#line 161
    rl.rlim_max = (rlim_t )1024;
  }
  {
#line 163
  rl.rlim_cur = rl.rlim_max;
#line 164
  tmp___0 = setrlimit(7, (struct rlimit  const  *)(& rl));
  }
#line 164
  if (tmp___0 == -1) {
    {
#line 166
    syscall_failed("setrlimit(RLIMIT_NOFILE)");
#line 167
    ps.ros.max_descriptors = (rlim_t )1024;
#line 168
    ps.ros.orig_max_descriptors = (rlim_t )1024;
    }
#line 169
    return;
  }
#line 172
  ps.ros.orig_max_descriptors = maxfd;
#line 173
  ps.ros.max_descriptors = rl.rlim_max;
#line 177
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static void init_common(int argc , char **argv ) 
{ 
  struct module  const  *mp ;
  char const   *func ;
  __uid_t tmp ;
  status_e tmp___0 ;
  __mode_t tmp___1 ;

  {
  {
#line 182
  mp = (struct module  const  *)((void *)0);
#line 183
  func = "init_common";
#line 189
  ps.ros.Argv = argv;
#line 190
  ps.ros.Argc = argc;
#line 191
  tmp = geteuid();
#line 191
  ps.ros.is_superuser = tmp == 0U;
#line 196
  mp = program_modules;
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! mp->name) {
#line 196
      goto while_break;
    }
    {
#line 197
    tmp___0 = (*(mp->initializer))();
    }
#line 197
    if ((unsigned int )tmp___0 == 0U) {
      {
#line 199
      msg(2, func, "Initialization of %s facility failed. Exiting...", mp->name);
#line 201
      exit(1);
      }
    }
#line 196
    mp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 203
  tmp___1 = umask((__mode_t )63);
#line 203
  umask(tmp___1 | 18U);
  }
#line 204
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static void create_pidfile(void) 
{ 
  int pidfd ;
  FILE *pidfile ;
  __pid_t tmp ;

  {
#line 215
  if (ps.ros.pid_file) {
    {
#line 216
    unlink(ps.ros.pid_file);
#line 217
    pidfd = open(ps.ros.pid_file, 193, (384 | (256 >> 3)) | ((256 >> 3) >> 3));
    }
#line 219
    if (pidfd >= 0) {
      {
#line 220
      pidfile = fdopen(pidfd, "w");
      }
#line 221
      if (pidfile) {
        {
#line 222
        fchmod(pidfd, (__mode_t )((384 | (256 >> 3)) | ((256 >> 3) >> 3)));
#line 223
        tmp = getpid();
#line 223
        fprintf((FILE */* __restrict  */)pidfile, (char const   */* __restrict  */)"%d\n",
                tmp);
#line 224
        fclose(pidfile);
        }
      } else {
        {
#line 226
        msg(7, "create_pidfile", "fdopen failed: %m");
#line 227
        Sclose(pidfd);
        }
      }
    } else {
      {
#line 230
      msg(7, "create_pidfile", "open failed: %m");
      }
    }
  }
#line 232
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static void become_daemon(void) 
{ 
  int tries ;
  int pid ;
  char const   *func ;

  {
#line 241
  func = "become_daemon";
#line 246
  tries = 0;
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    if (tries == 5) {
      {
#line 250
      msg(2, func, "fork: %m. Exiting...");
#line 251
      exit(0);
      }
    }
    {
#line 254
    pid = fork();
    }
#line 256
    if (pid == -1) {
      {
#line 258
      sleep(1U);
      }
#line 259
      goto __Cont;
    } else
#line 261
    if (pid == 0) {
#line 262
      goto while_break;
    } else {
      {
#line 264
      exit(0);
      }
    }
    __Cont: /* CIL Label */ 
#line 246
    tries ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 267
  dup2(0, 2);
#line 268
  no_control_tty();
  }
#line 273
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static pset_h new_table(unsigned int size ) 
{ 
  char const   *func ;
  pset_h tab ;
  pset_h tmp ;

  {
  {
#line 278
  func = "new_table";
#line 279
  tmp = pset_create(size, 0U);
#line 279
  tab = tmp;
  }
#line 281
  if ((unsigned long )tab == (unsigned long )((void *)0)) {
    {
#line 283
    msg(2, func, "Failed to create table");
#line 284
    exit(1);
    }
  }
#line 286
  return (tab);
}
}
#line 293 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
static void init_rw_state(void) 
{ 
  int __d0 ;
  int __d1 ;

  {
  {
#line 295
  ps.rws.servers = new_table(0U);
#line 296
  ps.rws.retries = new_table(0U);
#line 297
  ps.rws.services = new_table(0U);
#line 299
  ps.rws.descriptors_free = (int )(ps.ros.max_descriptors - 8UL);
  }
  {
#line 301
  while (1) {
    while_continue: /* CIL Label */ ;
#line 301
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& ps.rws.socket_mask.__fds_bits[0]): "memory");
#line 301
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
#line 302
  ps.rws.mask_max = 0;
#line 304
  return;
}
}
#line 310 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
void init_daemon(int argc , char **argv ) 
{ 
  char const   *fail ;

  {
  {
#line 312
  fail = (char const   *)((void *)0);
#line 314
  debug.on = 0;
#line 315
  memset((void *)(& ps), 0, sizeof(ps));
#line 317
  setup_file_descriptors();
#line 318
  ps.ros.config_file = "/etc/xinetd.conf";
#line 319
  opt_recognize(argc, argv);
#line 326
  xlog_parms((xlog_e )0, program_name, 17, 3 << 3);
#line 333
  fail = msg_init();
  }
#line 333
  if (fail) {
#line 335
    if (have_stderr) {
      {
#line 336
      Sprint(2, "%s: msg_init failed: %s\n", program_name, fail);
      }
    }
    {
#line 337
    exit(1);
    }
  }
  {
#line 340
  init_common(argc, argv);
  }
#line 342
  if (! debug.on) {
#line 342
    if (! dont_fork) {
      {
#line 343
      become_daemon();
      }
    }
  }
  {
#line 344
  create_pidfile();
#line 346
  init_rw_state();
  }
#line 347
  return;
}
}
#line 356 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/init.c"
void init_services(void) 
{ 
  struct configuration conf ;
  char const   *func ;
  status_e tmp ;

  {
  {
#line 359
  func = "init_services";
#line 361
  tmp = cnf_get(& conf);
  }
#line 361
  if ((unsigned int )tmp == 0U) {
    {
#line 363
    msg(2, func, "couldn\'t get configuration. Exiting...");
#line 364
    exit(1);
    }
  }
  {
#line 367
  ps.rws.defs.def_settings = conf.cnf_defaults;
#line 368
  cnf_start_services(& conf);
#line 369
  conf.cnf_defaults = (struct service_config *)((void *)0);
#line 370
  cnf_free(& conf);
  }
#line 375
  if (stayalive_option == 0) {
#line 376
    if (ps.rws.available_services == 0) {
      {
#line 378
      msg(2, func, "no services. Exiting...");
      }
#line 379
      if (ps.ros.pid_file) {
        {
#line 380
        unlink(ps.ros.pid_file);
        }
      }
      {
#line 382
      exit(1);
      }
    }
  }
  {
#line 386
  spec_include();
  }
#line 387
  return;
}
}
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 214
extern  __attribute__((__nothrow__)) unsigned long long ( __attribute__((__nonnull__(1),
__leaf__)) strtoull)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                     int __base ) ;
#line 366 "/usr/include/unistd.h"
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 176 "../libs/include/sio.h"
extern ssize_t ( /* format attribute */  Sprintv)(int fd , char const   *format ,
                                                  va_list ap ) ;
#line 12 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.h"
status_e copy_pset(pset_h const   from , pset_h *to , unsigned int size ) ;
#line 48 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
void out_of_memory(char const   *func ) 
{ 


  {
  {
#line 50
  msg(2, func, "out of memory");
  }
#line 51
  return;
}
}
#line 54 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
struct name_value  const  *nv_find_value(struct name_value  const  *nv_array , char const   *name___0 ) 
{ 
  struct name_value  const  *nvp ;
  int tmp ;

  {
#line 58
  nvp = nv_array;
  {
#line 58
  while (1) {
    while_continue: /* CIL Label */ ;
#line 58
    if (! nvp->name) {
#line 58
      goto while_break;
    }
    {
#line 60
    tmp = strcasecmp(name___0, (char const   *)nvp->name);
    }
#line 60
    if (tmp == 0) {
#line 61
      return (nvp);
    }
#line 58
    nvp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return ((struct name_value  const  *)((void *)0));
}
}
#line 67 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
struct name_value  const  *nv_find_name(struct name_value  const  *nv_array , int value ) 
{ 
  struct name_value  const  *nvp ;

  {
#line 71
  nvp = nv_array;
  {
#line 71
  while (1) {
    while_continue: /* CIL Label */ ;
#line 71
    if (! nvp->name) {
#line 71
      goto while_break;
    }
#line 73
    if (value == (int )nvp->value) {
#line 74
      return (nvp);
    }
#line 71
    nvp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 76
  return ((struct name_value  const  *)((void *)0));
}
}
#line 93 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
char const   *nv_get_name(struct name_value  const  *nv_array , int value ) 
{ 
  struct name_value  const  *nvp ;
  char const   *tmp ;

  {
#line 97
  nvp = nv_array;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! nvp->name) {
#line 97
      goto while_break;
    }
#line 99
    if (value == (int )nvp->value) {
#line 100
      return ((char const   *)nvp->name);
    }
#line 97
    nvp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (nvp->value) {
#line 102
    tmp = (nvp + 1)->name;
  } else {
#line 102
    tmp = (char const   */* const  */)((void *)0);
  }
#line 102
  return ((char const   *)tmp);
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
char **argv_alloc(unsigned int count ) 
{ 
  unsigned int argv_size ;
  char **argv ;
  char const   *func ;
  void *tmp ;

  {
  {
#line 109
  argv_size = (unsigned int )((unsigned long )(count + 1U) * sizeof(char *));
#line 111
  func = "new_argv";
#line 113
  tmp = malloc((size_t )argv_size);
#line 113
  argv = (char **)tmp;
  }
#line 114
  if ((unsigned long )argv == (unsigned long )((void *)0)) {
    {
#line 116
    out_of_memory(func);
    }
#line 117
    return ((char **)((void *)0));
  }
  {
#line 119
  memset((void *)((char *)argv), 0, (size_t )argv_size);
  }
#line 120
  return (argv);
}
}
#line 127 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
status_e copy_pset(pset_h const   from , pset_h *to , unsigned int size ) 
{ 
  unsigned int u ;
  char const   *func ;
  char *p ;
  char *new_s ;
  void *tmp ;
  __pset_pointer tmp___0 ;

  {
#line 130
  func = "copy_pset";
#line 132
  if ((unsigned long )*to == (unsigned long )((void *)0)) {
    {
#line 134
    *to = pset_create(from->count, 0U);
    }
#line 135
    if ((unsigned long )*to == (unsigned long )((void *)0)) {
      {
#line 137
      out_of_memory(func);
      }
#line 138
      return ((status_e )0);
    }
  }
#line 142
  u = 0U;
  {
#line 142
  while (1) {
    while_continue: /* CIL Label */ ;
#line 142
    if (! (u < from->count)) {
#line 142
      goto while_break;
    }
#line 144
    p = (char *)*(from->ptrs + u);
#line 147
    if (size == 0U) {
      {
#line 148
      new_s = new_string((char const   *)p);
      }
    } else {
      {
#line 150
      tmp = malloc((size_t )size);
#line 150
      new_s = (char *)tmp;
      }
    }
#line 152
    if ((unsigned long )new_s == (unsigned long )((void *)0)) {
      {
#line 154
      out_of_memory(func);
      }
#line 155
      return ((status_e )0);
    }
#line 158
    if (size != 0U) {
      {
#line 159
      memcpy((void */* __restrict  */)new_s, (void const   */* __restrict  */)p, (size_t )size);
      }
    }
    {
#line 161
    tmp___0 = pset_add(*to, (__pset_pointer const   )new_s);
    }
#line 161
    if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
      {
#line 163
      free((void *)new_s);
#line 164
      out_of_memory(func);
      }
#line 165
      return ((status_e )0);
    }
#line 142
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 168
  return ((status_e )1);
}
}
#line 175 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
void no_control_tty(void) 
{ 


  {
  {
#line 191
  setsid();
  }
#line 193
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
status_e write_buf(int fd , char const   *buf___0 , int len ) 
{ 
  int i ;
  ssize_t cc ;
  int *tmp ;

  {
#line 204
  i = 0;
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! (len > 0)) {
#line 204
      goto while_break;
    }
    {
#line 206
    cc = write(fd, (void const   *)(buf___0 + i), (size_t )len);
    }
#line 207
    if (cc == -1L) {
      {
#line 209
      tmp = __errno_location();
      }
#line 209
      if (*tmp != 4) {
#line 210
        return ((status_e )0);
      }
#line 211
      cc = (ssize_t )0;
    }
#line 204
    i = (int )((ssize_t )i + cc);
#line 204
    len = (int )((ssize_t )len - cc);
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  return ((status_e )1);
}
}
#line 218 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
void ( /* format attribute */  tabprint)(int fd , int tab_level , char const   *fmt 
                                         , ...) 
{ 
  va_list ap ;
  int i ;

  {
#line 223
  i = 0;
  {
#line 223
  while (1) {
    while_continue: /* CIL Label */ ;
#line 223
    if (! (i < tab_level)) {
#line 223
      goto while_break;
    }
    {
#line 224
    Sputchar(fd, (char )'\t');
#line 223
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 226
  __builtin_va_start(ap, fmt);
#line 227
  Sprintv(fd, fmt, ap);
#line 228
  __builtin_va_end(ap);
  }
#line 229
  return;
}
}
#line 235 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
void drain(int sd ) 
{ 
  char buf___0[256] ;
  ssize_t ret ;
  int old_val ;
  int tmp ;

  {
  {
#line 242
  old_val = fcntl(sd, 3, 2048);
#line 243
  tmp = fcntl(sd, 4, 2048);
  }
#line 243
  if (tmp < 0) {
#line 245
    if (debug.on) {
      {
#line 246
      msg(7, "drain", "UDP socket could not be made non-blocking: %m");
      }
    }
#line 248
    return;
  }
  {
#line 251
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 252
    ret = recv(sd, (void *)(buf___0), sizeof(buf___0), 0);
    }
#line 251
    if (! (ret > 0L)) {
#line 251
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 256
  if (old_val >= 0) {
    {
#line 257
    fcntl(sd, 4, old_val);
    }
  }
#line 259
  if (debug.on) {
    {
#line 260
    msg(7, "drain", "UDP socket should be empty");
    }
  }
#line 261
  return;
}
}
#line 266 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
int parse_int(char const   *str , int base , int term , int *res ) 
{ 
  char *endptr ;
  long strtol_res ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 275
  tmp = __errno_location();
#line 275
  *tmp = 0;
#line 276
  strtol_res = strtol((char const   */* __restrict  */)str, (char **/* __restrict  */)(& endptr),
                      base);
#line 278
  tmp___1 = __errno_location();
  }
#line 278
  if (*tmp___1 == 0) {
#line 278
    if ((int const   )*str != 0) {
#line 280
      if (term == -1) {
        {
#line 281
        while (1) {
          while_continue: /* CIL Label */ ;
#line 281
          if ((int )*endptr != 0) {
            {
#line 281
            tmp___0 = __ctype_b_loc();
            }
#line 281
            if (! ((int const   )*(*tmp___0 + (int )*endptr) & 8192)) {
#line 281
              goto while_break;
            }
          } else {
#line 281
            goto while_break;
          }
#line 282
          endptr ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 283
        term = '\000';
      }
#line 286
      if ((int )*endptr == term) {
#line 287
        *res = (int )strtol_res;
#line 288
        return (0);
      }
    }
  }
#line 292
  *res = 0;
#line 293
  return (-1);
}
}
#line 296 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
int parse_uint(char const   *str , int base , int term , unsigned int *res ) 
{ 
  unsigned long long tmp ;
  int ret ;

  {
  {
#line 300
  ret = parse_ull(str, base, term, & tmp);
#line 301
  *res = (unsigned int )tmp;
  }
#line 302
  return (ret);
}
}
#line 305 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
int parse_ull(char const   *str , int base , int term , unsigned long long *res ) 
{ 
  char *endptr ;
  unsigned long long strtol_res ;
  int *tmp ;
  unsigned short const   **tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 314
  tmp = __errno_location();
#line 314
  *tmp = 0;
#line 315
  strtol_res = strtoull((char const   */* __restrict  */)str, (char **/* __restrict  */)(& endptr),
                        base);
#line 317
  tmp___1 = __errno_location();
  }
#line 317
  if (*tmp___1 == 0) {
#line 317
    if ((int const   )*str != 0) {
#line 319
      if (term == -1) {
        {
#line 320
        while (1) {
          while_continue: /* CIL Label */ ;
#line 320
          if ((int )*endptr != 0) {
            {
#line 320
            tmp___0 = __ctype_b_loc();
            }
#line 320
            if (! ((int const   )*(*tmp___0 + (int )*endptr) & 8192)) {
#line 320
              goto while_break;
            }
          } else {
#line 320
            goto while_break;
          }
#line 321
          endptr ++;
        }
        while_break: /* CIL Label */ ;
        }
#line 322
        term = '\000';
      }
#line 325
      if ((int )*endptr == term) {
#line 326
        *res = strtol_res;
#line 327
        return (0);
      }
    }
  }
#line 331
  *res = 0ULL;
#line 332
  return (-1);
}
}
#line 335 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
int parse_ubase10(char const   *str , unsigned int *res ) 
{ 
  int tmp ;

  {
  {
#line 337
  tmp = parse_uint(str, 10, -1, res);
  }
#line 337
  return (tmp);
}
}
#line 340 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
int parse_base10(char const   *str , int *res ) 
{ 
  int tmp ;

  {
  {
#line 342
  tmp = parse_int(str, 10, -1, res);
  }
#line 342
  return (tmp);
}
}
#line 345 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/util.c"
bool_int parse_all_digits(char const   *ptr ) 
{ 
  size_t num ;
  size_t len ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 347
  num = (size_t )0;
#line 347
  tmp = strlen(ptr);
#line 347
  len = tmp;
  }
  {
#line 349
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 349
    tmp___0 = __ctype_b_loc();
#line 349
    tmp___1 = ptr;
#line 349
    ptr ++;
    }
#line 349
    if (! ((int const   )*(*tmp___0 + (int )*tmp___1) & 2048)) {
#line 349
      goto while_break;
    }
#line 350
    num ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 351
  if (num == len) {
#line 352
    return (1);
  } else {
#line 354
    return (0);
  }
}
}
#line 39 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/redirect.c"
static int RedirServerFd  =    -1;
#line 46
static  __attribute__((__noreturn__)) void redir_sigpipe(int signum ) ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/redirect.c"
static void redir_sigpipe(int signum ) 
{ 


  {
  {
#line 50
  Sclose(RedirServerFd);
#line 51
  _exit(0);
  }
}
}
#line 56
 __attribute__((__noreturn__)) void redir_handler(struct server *serp ) ;
#line 56 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/redirect.c"
void redir_handler(struct server *serp ) 
{ 
  struct service *sp ;
  struct service_config *scp ;
  int RedirDescrip ;
  int maxfd ;
  ssize_t num_read ;
  ssize_t num_wrote ;
  ssize_t ret ;
  unsigned int sin_len ;
  unsigned long bytes_in ;
  unsigned long bytes_out ;
  int no_to_nagle ;
  int on ;
  int v6on ;
  char buff[1500] ;
  fd_set rdfd ;
  fd_set msfd ;
  struct timeval *timep ;
  char const   *func ;
  union xsockaddr serveraddr ;
  __sighandler_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int __d0 ;
  int __d1 ;
  int tmp___6 ;
  int *tmp___7 ;
  int *tmp___8 ;
  int *tmp___9 ;
  int *tmp___10 ;

  {
  {
#line 58
  sp = serp->svr_sp;
#line 59
  scp = sp->svc_conf;
#line 60
  RedirDescrip = (serp->svr_conn)->co_descriptor;
#line 62
  num_wrote = (ssize_t )0;
#line 62
  ret = (ssize_t )0;
#line 63
  sin_len = 0U;
#line 64
  bytes_in = 0UL;
#line 64
  bytes_out = 0UL;
#line 65
  no_to_nagle = 1;
#line 66
  on = 1;
#line 69
  timep = (struct timeval *)((void *)0);
#line 70
  func = "redir_handler";
#line 73
  tmp = signal(13, & redir_sigpipe);
  }
#line 73
  if ((unsigned long )tmp == (unsigned long )((void (*)(int  ))-1)) {
    {
#line 74
    msg(3, func, "unable to setup signal handler");
    }
  }
  {
#line 76
  close_all_svc_descriptors();
  }
#line 79
  if (scp->sc_protocol.value == 6) {
    {
#line 81
    memcpy((void */* __restrict  */)(& serveraddr), (void const   */* __restrict  */)scp->sc_redir_addr,
           sizeof(serveraddr));
    }
#line 82
    if ((int )serveraddr.sa_in.sin_family == 2) {
      {
#line 83
      sin_len = (unsigned int )sizeof(struct sockaddr_in );
#line 84
      RedirServerFd = socket(2, 1, 0);
      }
    } else
#line 85
    if ((int )serveraddr.sa_in.sin_family == 10) {
      {
#line 86
      sin_len = (unsigned int )sizeof(struct sockaddr_in6 );
#line 87
      RedirServerFd = socket(10, 1, 0);
      }
    } else {
      {
#line 89
      msg(3, func, "not a valid protocol. Use IPv4 or IPv6.");
#line 90
      exit(0);
      }
    }
#line 93
    if (RedirServerFd < 0) {
      {
#line 95
      msg(3, func, "cannot create socket: %m");
#line 96
      exit(0);
      }
    }
#line 99
    if (scp->sc_xflags & (1UL << 10)) {
#line 100
      if (scp->sc_v6only) {
#line 101
        v6on = 1;
      } else {
#line 103
        v6on = 0;
      }
      {
#line 106
      tmp___0 = setsockopt(RedirServerFd, 41, 26, (void const   *)((char *)(& v6on)),
                           (socklen_t )sizeof(v6on));
      }
#line 106
      if (tmp___0 < 0) {
        {
#line 107
        msg(3, func, "Setting IPV6_V6ONLY option failed (%m)");
        }
      }
    }
#line 112
    if (scp->sc_xflags & (1UL << 6)) {
      {
#line 113
      tmp___1 = setsockopt(RedirServerFd, 1, 9, (void const   *)((char *)(& on)),
                           (socklen_t )sizeof(on));
      }
#line 113
      if (tmp___1 < 0) {
        {
#line 115
        msg(3, func, "setsockopt SO_KEEPALIVE RedirServerFd failed: %m");
        }
      }
    }
#line 118
    if ((int )serveraddr.sa_in.sin_family == 2) {
      {
#line 119
      serveraddr.sa_in.sin_port = htons(serveraddr.sa_in.sin_port);
      }
    }
#line 120
    if ((int )serveraddr.sa_in.sin_family == 10) {
      {
#line 121
      serveraddr.sa_in6.sin6_port = htons(serveraddr.sa_in6.sin6_port);
      }
    }
    {
#line 123
    tmp___3 = connect(RedirServerFd, (struct sockaddr  const  *)(& serveraddr.sa),
                      sin_len);
    }
#line 123
    if (tmp___3 < 0) {
      {
#line 125
      tmp___2 = xaddrname((union xsockaddr  const  *)(& serveraddr));
#line 125
      msg(3, func, "can\'t connect to remote host %s: %m", tmp___2);
#line 127
      exit(0);
      }
    }
    {
#line 132
    tmp___4 = setsockopt(RedirServerFd, 6, 1, (void const   *)((char *)(& no_to_nagle)),
                         (socklen_t )sizeof(on));
    }
#line 132
    if (tmp___4 < 0) {
      {
#line 135
      msg(3, func, "setsockopt RedirServerFd failed: %m");
      }
    }
    {
#line 138
    tmp___5 = setsockopt(RedirDescrip, 6, 1, (void const   *)((char *)(& no_to_nagle)),
                         (socklen_t )sizeof(on));
    }
#line 138
    if (tmp___5 < 0) {
      {
#line 141
      msg(3, func, "setsockopt RedirDescrip failed: %m");
      }
    }
#line 144
    if (RedirServerFd > RedirDescrip) {
#line 144
      maxfd = RedirServerFd;
    } else {
#line 144
      maxfd = RedirDescrip;
    }
    {
#line 145
    while (1) {
      while_continue: /* CIL Label */ ;
#line 145
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& msfd.__fds_bits[0]): "memory");
#line 145
      goto while_break;
    }
    while_break: /* CIL Label */ ;
    }
#line 146
    msfd.__fds_bits[RedirDescrip / (8 * (int )sizeof(__fd_mask ))] |= 1L << RedirDescrip % (8 * (int )sizeof(__fd_mask ));
#line 147
    msfd.__fds_bits[RedirServerFd / (8 * (int )sizeof(__fd_mask ))] |= 1L << RedirServerFd % (8 * (int )sizeof(__fd_mask ));
    {
#line 149
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 150
      memcpy((void */* __restrict  */)(& rdfd), (void const   */* __restrict  */)(& msfd),
             sizeof(rdfd));
#line 151
      tmp___6 = select(maxfd + 1, (fd_set */* __restrict  */)(& rdfd), (fd_set */* __restrict  */)((fd_set *)0),
                       (fd_set */* __restrict  */)((fd_set *)0), (struct timeval */* __restrict  */)timep);
      }
#line 151
      if (tmp___6 <= 0) {
#line 153
        goto while_break___0;
      }
#line 156
      if ((rdfd.__fds_bits[RedirDescrip / (8 * (int )sizeof(__fd_mask ))] & (1L << RedirDescrip % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 157
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 158
          num_read = read(RedirDescrip, (void *)(buff), sizeof(buff));
          }
#line 160
          if (num_read == -1L) {
            {
#line 160
            tmp___7 = __errno_location();
            }
#line 160
            if (*tmp___7 == 4) {
#line 161
              goto __Cont;
            }
          }
#line 162
          if (num_read <= 0L) {
#line 163
            goto REDIROUT;
          }
#line 164
          bytes_in += (unsigned long )num_read;
          __Cont: /* CIL Label */ 
#line 157
          if (! (num_read < 0L)) {
#line 157
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
#line 169
        num_wrote = (ssize_t )0;
        {
#line 170
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 170
          if (! (num_wrote < num_read)) {
#line 170
            goto while_break___2;
          }
          {
#line 171
          ret = write(RedirServerFd, (void const   *)(buff + num_wrote), (size_t )(num_read - num_wrote));
          }
#line 174
          if (ret == -1L) {
            {
#line 174
            tmp___8 = __errno_location();
            }
#line 174
            if (*tmp___8 == 4) {
#line 175
              goto while_continue___2;
            }
          }
#line 176
          if (ret <= 0L) {
#line 177
            goto REDIROUT;
          }
#line 178
          num_wrote += ret;
        }
        while_break___2: /* CIL Label */ ;
        }
      }
#line 182
      if ((rdfd.__fds_bits[RedirServerFd / (8 * (int )sizeof(__fd_mask ))] & (1L << RedirServerFd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 183
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 184
          num_read = read(RedirServerFd, (void *)(buff), sizeof(buff));
          }
#line 186
          if (num_read == -1L) {
            {
#line 186
            tmp___9 = __errno_location();
            }
#line 186
            if (*tmp___9 == 4) {
#line 187
              goto __Cont___0;
            }
          }
#line 188
          if (num_read <= 0L) {
#line 189
            goto REDIROUT;
          }
#line 190
          bytes_out += (unsigned long )num_read;
          __Cont___0: /* CIL Label */ 
#line 183
          if (! (num_read < 0L)) {
#line 183
            goto while_break___3;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 195
        num_wrote = (ssize_t )0;
        {
#line 196
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 196
          if (! (num_wrote < num_read)) {
#line 196
            goto while_break___4;
          }
          {
#line 197
          ret = write(RedirDescrip, (void const   *)(buff + num_wrote), (size_t )(num_read - num_wrote));
          }
#line 200
          if (ret == -1L) {
            {
#line 200
            tmp___10 = __errno_location();
            }
#line 200
            if (*tmp___10 == 4) {
#line 201
              goto while_continue___4;
            }
          }
#line 202
          if (ret <= 0L) {
#line 203
            goto REDIROUT;
          }
#line 204
          num_wrote += ret;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    REDIROUT: 
#line 209
    if (scp->sc_log_on_success & (1UL << 7)) {
      {
#line 210
      svc_logprint((serp->svr_conn)->co_sp, "TRAFFIC", "in=%lu(bytes) out=%lu(bytes)",
                   bytes_in, bytes_out);
      }
    }
    {
#line 214
    exit(0);
    }
  }
  {
#line 217
  msg(3, func, "redirect with any protocol other than tcp is not supported at this time.");
#line 219
  exit(0);
  }
}
}
#line 22 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/logctl.c"
static xlog_h start_filelog(char const   *id , struct filelog *flp ) 
{ 
  xlog_h xh ;
  int fd ;
  int log_file_mode ;
  int tmp ;
  char const   *func ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 26
  if (debug.on) {
#line 26
    tmp = 420;
  } else {
#line 26
    tmp = 420;
  }
  {
#line 26
  log_file_mode = tmp;
#line 27
  func = "start_filelog";
#line 29
  xh = xlog_create((xlog_e )1, id, 0, flp->fl_filename, 1089, log_file_mode);
  }
#line 31
  if ((unsigned long )xh == (unsigned long )((void *)0)) {
    {
#line 33
    msg(3, func, "creation of %s log failed", id);
    }
#line 34
    return ((void *)0);
  }
  {
#line 37
  tmp___0 = xlog_control(xh, (xlog_cmd_e )9, & fd);
  }
#line 37
  if (tmp___0 != 0) {
    {
#line 40
    msg(3, func, "Failed to set close-on-exec flag for log file");
#line 41
    xlog_destroy(xh);
    }
#line 42
    return ((void *)0);
  } else {
    {
#line 37
    tmp___1 = fcntl(fd, 2, 1);
    }
#line 37
    if (tmp___1 == -1) {
      {
#line 40
      msg(3, func, "Failed to set close-on-exec flag for log file");
#line 41
      xlog_destroy(xh);
      }
#line 42
      return ((void *)0);
    }
  }
#line 45
  (ps.rws.descriptors_free) --;
#line 47
  if (flp->fl_soft_limit != 0U) {
    {
#line 48
    xlog_control(xh, (xlog_cmd_e )10, flp->fl_soft_limit, flp->fl_hard_limit);
    }
  }
#line 51
  return (xh);
}
}
#line 62 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/logctl.c"
static void log_in_error(xlog_h xh , int error_code , void *arg ) 
{ 
  struct service *sp ;
  char const   *log_id ;
  char const   *tmp ;
  char const   *func ;

  {
#line 64
  sp = (struct service *)arg;
#line 65
  if ((unsigned long )sp == (unsigned long )((void *)0)) {
#line 65
    tmp = "common";
  } else {
#line 65
    tmp = (char const   *)(sp->svc_conf)->sc_id;
  }
#line 65
  log_id = tmp;
#line 66
  func = "log_in_error";
#line 71
  if (error_code == 1) {
    {
#line 72
    msg(3, func, "Size of %s log exceeded hard limit", log_id);
    }
  } else {
    {
#line 74
    msg(3, func, "Error in %s log: %d", log_id, error_code);
    }
  }
#line 75
  return;
}
}
#line 81 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/logctl.c"
status_e log_start(struct service *sp , xlog_h *xhp ) 
{ 
  xlog_h xh ;
  char const   *sid ;
  struct log *lp ;
  char const   *func ;

  {
#line 84
  sid = (char const   *)(sp->svc_conf)->sc_id;
#line 85
  lp = & (sp->svc_conf)->sc_log;
#line 86
  func = "log_start";
  {
#line 90
  if ((unsigned int )lp->l_type == 0U) {
#line 90
    goto case_0;
  }
#line 94
  if ((unsigned int )lp->l_type == 2U) {
#line 94
    goto case_2;
  }
#line 106
  if ((unsigned int )lp->l_type == 1U) {
#line 106
    goto case_1;
  }
#line 118
  if ((unsigned int )lp->l_type == 3U) {
#line 118
    goto case_3;
  }
#line 139
  goto switch_default;
  case_0: /* CIL Label */ 
#line 91
  xh = (void *)0;
#line 92
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 95
  xh = xlog_create((xlog_e )0, sid, 0, lp->l_sl.sl_facility, lp->l_sl.sl_level);
  }
#line 98
  if ((unsigned long )xh == (unsigned long )((void *)0)) {
    {
#line 100
    msg(3, func, "failed to create a log for service %s", sid);
    }
#line 101
    return ((status_e )0);
  }
  {
#line 103
  xlog_control(xh, (xlog_cmd_e )1, & log_in_error, (void *)sp);
  }
#line 104
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 112
  xh = start_filelog(sid, & lp->l_fl);
  }
#line 113
  if ((unsigned long )xh == (unsigned long )((void *)0)) {
#line 114
    return ((status_e )0);
  }
  {
#line 115
  xlog_control(xh, (xlog_cmd_e )1, & log_in_error, (void *)sp);
  }
#line 116
  goto switch_break;
  case_3: /* CIL Label */ 
#line 119
  if ((unsigned long )ps.rws.defs.def_log == (unsigned long )((void *)0)) {
#line 120
    if (ps.rws.defs.def_log_creation_failed) {
#line 121
      return ((status_e )0);
    } else {
      {
#line 124
      xh = start_filelog("default", & (ps.rws.defs.def_settings)->sc_log.l_fl);
      }
#line 126
      if ((unsigned long )xh == (unsigned long )((void *)0)) {
#line 128
        ps.rws.defs.def_log_creation_failed = 1;
#line 129
        return ((status_e )0);
      }
      {
#line 131
      ps.rws.defs.def_log = xh;
#line 132
      xlog_control(xh, (xlog_cmd_e )1, & log_in_error, (void *)0);
      }
    }
  } else {
#line 136
    xh = ps.rws.defs.def_log;
  }
#line 137
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 140
  msg(3, func, "bad log type (%d) for service %s", (int )lp->l_type, sid);
  }
#line 142
  return ((status_e )0);
  switch_break: /* CIL Label */ ;
  }
#line 144
  *xhp = xh;
#line 145
  return ((status_e )1);
}
}
#line 149 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/logctl.c"
void log_end(struct log *lp , xlog_h xh ) 
{ 
  char const   *func ;

  {
#line 151
  func = "log_end";
#line 153
  if ((unsigned long )xh == (unsigned long )((void *)0)) {
    {
#line 155
    msg(5, func, "called with NULL handle");
    }
#line 156
    return;
  }
  {
#line 161
  if ((unsigned int )lp->l_type == 1U) {
#line 161
    goto case_1;
  }
#line 165
  if ((unsigned int )lp->l_type == 2U) {
#line 165
    goto case_2;
  }
#line 168
  if ((unsigned int )lp->l_type == 3U) {
#line 168
    goto case_3;
  }
#line 168
  if ((unsigned int )lp->l_type == 0U) {
#line 168
    goto case_3;
  }
#line 159
  goto switch_break;
  case_1: /* CIL Label */ 
#line 162
  (ps.rws.descriptors_free) ++;
  case_2: /* CIL Label */ 
  {
#line 166
  xlog_destroy(xh);
  }
  case_3: /* CIL Label */ 
  case_0: /* CIL Label */ ;
  switch_break: /* CIL Label */ ;
  }
#line 171
  return;
}
}
#line 73 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.h"
void intercept(struct server *serp ) ;
#line 32 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.c"
static void stream_logging(struct server *serp ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.c"
static struct builtin_service  const  special_services[4]  = {      {"logging", 1, {(void (*)())(& stream_logging), (boolean_e )1}}, 
        {"intercept", 1, {(void (*)())(& intercept), (boolean_e )1}}, 
        {"intercept", 2, {(void (*)())(& intercept), (boolean_e )1}}, 
        {(char const   *)((void *)0), 0, {(void (*)())((void *)0), (boolean_e )0}}};
#line 43 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.c"
builtin_s const   *spec_find(char const   *service_name , int type ) 
{ 
  builtin_s const   *bp ;
  struct name_value  const  *nvp ;
  char const   *func ;

  {
  {
#line 47
  func = "spec_find";
#line 49
  bp = builtin_lookup(special_services, service_name, type);
  }
#line 49
  if (bp) {
#line 50
    return (bp);
  }
  {
#line 52
  nvp = nv_find_name(socket_types, type);
  }
#line 53
  if ((unsigned long )nvp == (unsigned long )((void *)0)) {
    {
#line 55
    msg(3, func, "unknown socket type: %d", type);
    }
#line 56
    return ((builtin_s const   *)((void *)0));
  }
  {
#line 59
  msg(3, func, "special service %s,%s not supported", service_name, nvp->name);
  }
#line 61
  return ((builtin_s const   *)((void *)0));
}
}
#line 65 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.c"
status_e spec_service_handler(struct service *sp , connection_s *cp ) 
{ 
  status_e tmp ;

  {
  {
#line 67
  tmp = server_run(sp, cp);
  }
#line 67
  return (tmp);
}
}
#line 71 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.c"
static struct service *spec_setup(char const   *name___0 , int socket_type , int instances ) 
{ 
  builtin_s const   *bp ;
  struct service_config *scp ;
  struct service *tmp ;

  {
  {
#line 77
  bp = spec_find(name___0, socket_type);
  }
#line 78
  if ((unsigned long )bp == (unsigned long )((void *)0)) {
#line 79
    return ((struct service *)((void *)0));
  }
  {
#line 81
  scp = sc_make_special(name___0, bp, instances);
  }
#line 81
  if ((unsigned long )scp == (unsigned long )((void *)0)) {
#line 82
    return ((struct service *)((void *)0));
  }
  {
#line 84
  tmp = svc_make_special(scp);
  }
#line 84
  return (tmp);
}
}
#line 92 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.c"
void spec_include(void) 
{ 
  int instances ;

  {
#line 96
  if (logprocs_option) {
#line 96
    instances = (int )logprocs_option_arg;
  } else {
#line 96
    instances = 15;
  }
  {
#line 97
  ps.rws.logging = spec_setup("logging", 1, instances);
  }
#line 98
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/special.c"
static void stream_logging(struct server *serp ) 
{ 
  char const   *func ;
  idresult_e result ;
  char const   *tmp ;
  char const   *tmp___0 ;

  {
  {
#line 103
  func = "stream_logging";
#line 114
  result = log_remote_user((struct server  const  *)serp, 30U);
  }
#line 115
  if ((unsigned int )result != 0U) {
#line 115
    if ((unsigned int )result != 1U) {
      {
#line 116
      tmp = idresult_explain(result);
#line 116
      tmp___0 = conn_addrstr((connection_s const   *)serp->svr_conn);
#line 116
      msg(3, func, "Failed to contact identity server at %s: %s", tmp___0, tmp);
      }
    }
  }
#line 117
  return;
}
}
#line 224 "/usr/include/netdb.h"
extern struct netent *getnetbyname(char const   *__name ) ;
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 64 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char const   *( __attribute__((__leaf__)) inet_ntop)(int __af ,
                                                                                          void const   * __restrict  __cp ,
                                                                                          char * __restrict  __buf ,
                                                                                          socklen_t __len ) ;
#line 79 "../libs/include/str.h"
extern char *str_casefind(char *s1 , char const   *s2 ) ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.h"
status_e addrlist_copy(pset_h const   from , pset_h *to ) ;
#line 77 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static void xsetmask(char *mask , unsigned int bits , unsigned int len ) 
{ 
  int i ;
  int bytes ;
  int remain ;

  {
  {
#line 80
  bytes = (int )(bits / 8U);
#line 81
  remain = (int )(bits - (unsigned int )(bytes * 8));
#line 83
  memset((void *)mask, 0, (size_t )len);
#line 86
  i = 0;
  }
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < bytes)) {
#line 86
      goto while_break;
    }
#line 87
    *(mask + i) = (char)-1;
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  if (remain > 0) {
#line 91
    *(mask + i) = (char )(255 << (8 - remain));
  }
#line 93
  return;
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static bool_int xmatch(char const   *addr1 , char const   *mask1 , char const   *addr2 ,
                       int len ) 
{ 
  int i ;

  {
#line 106
  i = 0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (i < len)) {
#line 106
      goto while_break;
    }
#line 107
    if (((int const   )*(addr1 + i) & (int const   )*(mask1 + i)) != ((int const   )*(addr2 + i) & (int const   )*(mask1 + i))) {
#line 108
      return (0);
    }
#line 106
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 110
  return (1);
}
}
#line 119 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
int addrlist_match(pset_h const   addr_list , struct sockaddr  const  *addr ) 
{ 
  unsigned int u ;
  unsigned int addr_count ;
  unsigned int length ;
  char hname[1025] ;
  struct comp_addr *cap ;
  char *tmpname ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  char *tmp___4 ;
  struct sockaddr_in  const  *inp ;
  uint32_t tmp___5 ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___6 ;
  bool_int tmp___7 ;
  uint32_t tmp_addr ;
  uint32_t tmp___8 ;
  struct in6_addr  const  *__a___0 ;
  uint32_t tmp___9 ;
  int tmp___10 ;

  {
#line 125
  if ((unsigned long )addr == (unsigned long )((void *)0)) {
#line 126
    return (0);
  }
#line 128
  if ((int const   )addr->sa_family == 2) {
#line 128
    length = (unsigned int )sizeof(struct sockaddr_in );
  } else {
#line 128
    length = (unsigned int )sizeof(struct sockaddr_in6 );
  }
#line 131
  addr_count = addr_list->count;
#line 132
  if (addr_count == 0U) {
#line 133
    return (0);
  }
#line 135
  hname[0] = (char)0;
#line 137
  u = 0U;
  {
#line 137
  while (1) {
    while_continue: /* CIL Label */ ;
#line 137
    if (! (u < addr_count)) {
#line 137
      goto while_break;
    }
#line 139
    cap = (struct comp_addr *)*(addr_list->ptrs + u);
#line 140
    if ((unsigned long )cap == (unsigned long )((void *)0)) {
#line 141
      goto __Cont;
    }
#line 143
    if ((unsigned int )cap->addr_type == 2U) {
#line 145
      tmpname = (char *)((void *)0);
#line 146
      if ((int )hname[0] == 0) {
        {
#line 148
        memset((void *)(hname), 0, (size_t )1025);
#line 149
        tmp = getnameinfo((struct sockaddr  const  */* __restrict  */)addr, length,
                          (char */* __restrict  */)(hname), (socklen_t )1025, (char */* __restrict  */)((void *)0),
                          (socklen_t )0, 8);
        }
#line 149
        if (tmp) {
#line 155
          hname[0] = (char)0;
#line 156
          goto __Cont;
        }
      }
#line 161
      if ((int )cap->name[0] == 46) {
        {
#line 163
        tmpname = str_casefind(hname, (char const   *)(cap->name));
        }
#line 164
        if ((unsigned long )tmpname != (unsigned long )((void *)0)) {
          {
#line 166
          tmp___0 = strlen((char const   *)(cap->name));
#line 166
          tmp___1 = strlen((char const   *)tmpname);
          }
#line 166
          if (tmp___0 == tmp___1) {
#line 167
            return ((int )(u + 1U));
          }
        }
      } else {
        {
#line 172
        tmp___2 = strlen((char const   *)(hname));
#line 172
        tmp___3 = strlen((char const   *)(cap->name));
        }
#line 172
        if (tmp___2 == tmp___3) {
          {
#line 172
          tmp___4 = str_casefind(hname, (char const   *)(cap->name));
          }
#line 172
          if ((unsigned long )tmp___4 == (unsigned long )(hname)) {
#line 174
            return ((int )(u + 1U));
          }
        }
      }
    } else
#line 179
    if ((int const   )addr->sa_family == 2) {
#line 179
      if ((int )cap->version == 4) {
        {
#line 181
        inp = (struct sockaddr_in  const  *)addr;
#line 182
        tmp___5 = ntohl((uint32_t )inp->sin_addr.s_addr);
        }
#line 182
        if ((tmp___5 & cap->m.mask) == (cap->a.addr & cap->m.mask)) {
#line 184
          return ((int )(u + 1U));
        }
      } else {
#line 179
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 186
    if ((int const   )addr->sa_family == 10) {
#line 186
      if ((int )cap->version == 6) {
#line 188
        if ((unsigned int )cap->addr_type == 0U) {
#line 189
          __a = & ((struct sockaddr_in6  const  *)addr)->sin6_addr;
#line 189
          __b = (struct in6_addr  const  *)(& cap->a.addr6);
#line 189
          if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 189
            if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 189
              if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 189
                if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 189
                  tmp___6 = 1;
                } else {
#line 189
                  tmp___6 = 0;
                }
              } else {
#line 189
                tmp___6 = 0;
              }
            } else {
#line 189
              tmp___6 = 0;
            }
          } else {
#line 189
            tmp___6 = 0;
          }
#line 189
          if (tmp___6) {
#line 190
            return ((int )(u + 1U));
          }
        } else {
          {
#line 193
          tmp___7 = xmatch((char const   *)(((struct sockaddr_in6  const  *)addr)->sin6_addr.__in6_u.__u6_addr8),
                           (char const   *)(& cap->m.mask6), (char const   *)(& cap->a.addr6),
                           16);
          }
#line 193
          if (tmp___7 == 1) {
#line 196
            return ((int )(u + 1U));
          }
        }
      } else {
#line 186
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 199
    if ((int const   )addr->sa_family == 10) {
#line 199
      if ((int )cap->version == 4) {
#line 204
        __a___0 = & ((struct sockaddr_in6  const  *)addr)->sin6_addr;
#line 204
        if (__a___0->__in6_u.__u6_addr32[0] == 0U) {
#line 204
          if (__a___0->__in6_u.__u6_addr32[1] == 0U) {
            {
#line 204
            tmp___9 = htonl((uint32_t )65535);
            }
#line 204
            if (__a___0->__in6_u.__u6_addr32[2] == tmp___9) {
#line 204
              tmp___10 = 1;
            } else {
#line 204
              tmp___10 = 0;
            }
          } else {
#line 204
            tmp___10 = 0;
          }
        } else {
#line 204
          tmp___10 = 0;
        }
#line 204
        if (tmp___10) {
          {
#line 207
          memcpy((void */* __restrict  */)(& tmp_addr), (void const   */* __restrict  */)(& ((struct sockaddr_in6  const  *)addr)->sin6_addr.__in6_u.__u6_addr8[12]),
                 sizeof(tmp_addr));
#line 208
          tmp___8 = ntohl(tmp_addr);
          }
#line 208
          if ((tmp___8 & cap->m.mask) == (cap->a.addr & cap->m.mask)) {
#line 210
            return ((int )(u + 1U));
          }
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 137
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (0);
}
}
#line 219 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
void addrlist_dump(pset_h const   addr_list , int fd ) 
{ 
  unsigned int u ;
  unsigned int num ;
  char addrstring[1025] ;
  char maskstring[1025] ;
  struct comp_addr *cap ;
  char const   *type ;
  uint32_t addr ;
  uint32_t tmp ;
  uint32_t mask ;
  uint32_t tmp___0 ;

  {
#line 225
  num = addr_list->count;
#line 226
  u = 0U;
  {
#line 226
  while (1) {
    while_continue: /* CIL Label */ ;
#line 226
    if (! (u < num)) {
#line 226
      goto while_break;
    }
#line 228
    cap = (struct comp_addr *)*(addr_list->ptrs + u);
#line 231
    if ((unsigned int )cap->addr_type == 0U) {
#line 232
      type = "NUMERIC";
    } else
#line 233
    if ((unsigned int )cap->addr_type == 1U) {
#line 234
      type = "NET";
    } else
#line 235
    if ((unsigned int )cap->addr_type == 2U) {
#line 236
      type = "HOST";
    } else {
#line 238
      type = "BAD";
    }
    {
#line 240
    memset((void *)(addrstring), 0, sizeof(addrstring));
#line 241
    memset((void *)(maskstring), 0, sizeof(maskstring));
    }
#line 242
    if ((int )cap->version == 4) {
      {
#line 243
      tmp = htonl(cap->a.addr);
#line 243
      addr = tmp;
#line 244
      tmp___0 = htonl(cap->m.mask);
#line 244
      mask = tmp___0;
#line 245
      inet_ntop(2, (void const   */* __restrict  */)(& addr), (char */* __restrict  */)(addrstring),
                (socklen_t )sizeof(addrstring));
#line 246
      inet_ntop(2, (void const   */* __restrict  */)(& mask), (char */* __restrict  */)(maskstring),
                (socklen_t )sizeof(maskstring));
      }
    } else
#line 248
    if ((int )cap->version == 6) {
      {
#line 249
      inet_ntop(10, (void const   */* __restrict  */)(& cap->a.addr6), (char */* __restrict  */)(addrstring),
                (socklen_t )sizeof(addrstring));
#line 250
      inet_ntop(10, (void const   */* __restrict  */)(& cap->m.mask6), (char */* __restrict  */)(maskstring),
                (socklen_t )sizeof(maskstring));
      }
    }
#line 253
    if ((unsigned int )cap->addr_type == 1U) {
      {
#line 254
      Sprint(fd, " %s/%s(%s)", addrstring, maskstring, type);
      }
    } else
#line 255
    if ((unsigned int )cap->addr_type == 2U) {
      {
#line 256
      Sprint(fd, " %s(%s)", cap->name, type);
      }
    } else {
      {
#line 258
      Sprint(fd, " %s(%s)", addrstring, type);
      }
    }
#line 226
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
void addrlist_free(pset_h addr_list ) 
{ 


  {
  {
#line 265
  pset_apply(addr_list, (void (*)())(& free), (void *)0);
  }
#line 266
  return;
}
}
#line 273 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
int check_hostname(char const   *addr ) 
{ 
  int i ;
  unsigned short const   **tmp ;

  {
#line 277
  i = 0;
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! *(addr + i)) {
#line 277
      goto while_break;
    }
    {
#line 279
    tmp = __ctype_b_loc();
    }
#line 279
    if (! ((int const   )*(*tmp + (int )*(addr + i)) & 2048)) {
#line 279
      if ((int const   )*(addr + i) != 46) {
#line 280
        return (1);
      }
    }
#line 277
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return (0);
}
}
#line 289 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static status_e add(pset_h addr_list , struct comp_addr  const  *cap ) 
{ 
  struct comp_addr *new_cap ;
  char const   *func ;
  void *tmp ;
  __pset_pointer tmp___0 ;

  {
  {
#line 291
  new_cap = (struct comp_addr *)((void *)0);
#line 292
  func = "add";
#line 294
  tmp = malloc(sizeof(struct comp_addr ));
#line 294
  new_cap = (struct comp_addr *)tmp;
  }
#line 295
  if ((unsigned long )new_cap == (unsigned long )((void *)0)) {
    {
#line 297
    out_of_memory(func);
    }
#line 298
    return ((status_e )0);
  }
  {
#line 301
  *new_cap = (struct comp_addr )*cap;
#line 302
  tmp___0 = pset_add(addr_list, (__pset_pointer const   )new_cap);
  }
#line 302
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 304
    out_of_memory(func);
#line 305
    free((void *)((char *)new_cap));
    }
#line 306
    return ((status_e )0);
  }
#line 308
  return ((status_e )1);
}
}
#line 320 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static status_e xremove(pset_h addr_list , struct comp_addr  const  *cap ) 
{ 
  unsigned int u ;
  struct comp_addr *old_cap ;
  int tmp ;
  struct in6_addr  const  *__a ;
  struct in6_addr  const  *__b ;
  int tmp___0 ;
  struct in6_addr  const  *__a___0 ;
  struct in6_addr  const  *__b___0 ;
  int tmp___1 ;

  {
#line 322
  u = 0U;
#line 325
  u = 0U;
  {
#line 325
  while (1) {
    while_continue: /* CIL Label */ ;
#line 325
    if (! (u < addr_list->count)) {
#line 325
      goto while_break;
    }
#line 327
    old_cap = (struct comp_addr *)*(addr_list->ptrs + u);
#line 329
    if ((unsigned int const   )cap->addr_type == 2U) {
#line 329
      if ((unsigned int )old_cap->addr_type == 2U) {
        {
#line 331
        tmp = strcasecmp((char const   *)(cap->name), (char const   *)(old_cap->name));
        }
#line 331
        if (tmp == 0) {
          {
#line 333
          *(addr_list->ptrs + u) = (void *)0;
#line 334
          free((void *)((char *)old_cap));
          }
        }
      } else {
#line 329
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 343
    if ((int )old_cap->version == (int )cap->version) {
#line 343
      if ((int )old_cap->version == 6) {
#line 342
        __a = (struct in6_addr  const  *)(& old_cap->a.addr6);
#line 342
        __b = & cap->a.addr6;
#line 342
        if (__a->__in6_u.__u6_addr32[0] == __b->__in6_u.__u6_addr32[0]) {
#line 342
          if (__a->__in6_u.__u6_addr32[1] == __b->__in6_u.__u6_addr32[1]) {
#line 342
            if (__a->__in6_u.__u6_addr32[2] == __b->__in6_u.__u6_addr32[2]) {
#line 342
              if (__a->__in6_u.__u6_addr32[3] == __b->__in6_u.__u6_addr32[3]) {
#line 342
                tmp___0 = 1;
              } else {
#line 342
                tmp___0 = 0;
              }
            } else {
#line 342
              tmp___0 = 0;
            }
          } else {
#line 342
            tmp___0 = 0;
          }
        } else {
#line 342
          tmp___0 = 0;
        }
#line 343
        if (tmp___0) {
#line 343
          __a___0 = (struct in6_addr  const  *)(& old_cap->m.mask6);
#line 343
          __b___0 = & cap->m.mask6;
#line 343
          if (__a___0->__in6_u.__u6_addr32[0] == __b___0->__in6_u.__u6_addr32[0]) {
#line 343
            if (__a___0->__in6_u.__u6_addr32[1] == __b___0->__in6_u.__u6_addr32[1]) {
#line 343
              if (__a___0->__in6_u.__u6_addr32[2] == __b___0->__in6_u.__u6_addr32[2]) {
#line 343
                if (__a___0->__in6_u.__u6_addr32[3] == __b___0->__in6_u.__u6_addr32[3]) {
#line 343
                  tmp___1 = 1;
                } else {
#line 343
                  tmp___1 = 0;
                }
              } else {
#line 343
                tmp___1 = 0;
              }
            } else {
#line 343
              tmp___1 = 0;
            }
          } else {
#line 343
            tmp___1 = 0;
          }
#line 343
          if (tmp___1) {
            {
#line 347
            *(addr_list->ptrs + u) = (void *)0;
#line 348
            free((void *)((char *)old_cap));
            }
          } else {
#line 343
            goto _L___0;
          }
        } else {
#line 343
          goto _L___0;
        }
      } else
      _L___0: /* CIL Label */ 
#line 343
      if ((int )old_cap->version == (int )cap->version) {
#line 343
        if ((int )old_cap->version == 4) {
#line 343
          if (old_cap->a.addr == (uint32_t )cap->a.addr) {
#line 343
            if (old_cap->m.mask == (uint32_t )cap->m.mask) {
              {
#line 347
              *(addr_list->ptrs + u) = (void *)0;
#line 348
              free((void *)((char *)old_cap));
              }
            }
          }
        }
      }
    }
#line 325
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 351
  pset_compact(addr_list);
  }
#line 352
  return ((status_e )1);
}
}
#line 361 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static result_e explicit_mask(char const   *str_addr , status_e (*op)() , pset_h addr_list ) 
{ 
  struct comp_addr ca ;
  int val ;
  unsigned int mask ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  char saddr[46] ;
  char *tmp ;
  int tmp___0 ;
  uint32_t i ;
  unsigned int n ;
  int tmp___2 ;
  status_e tmp___3 ;

  {
  {
#line 370
  memset((void *)(saddr), 0, (size_t )46);
#line 372
  tmp = strchr(str_addr, '{');
  }
#line 372
  if (tmp) {
#line 373
    return ((result_e )0);
  }
#line 375
  if (sizeof(saddr) < 46UL) {
#line 376
    return ((result_e )0);
  }
  {
#line 377
  val = sscanf((char const   */* __restrict  */)str_addr, (char const   */* __restrict  */)"%45[^/]/%u",
               saddr, & mask);
  }
#line 378
  if (val < 2) {
#line 379
    return ((result_e )0);
  }
  {
#line 381
  memset((void *)(& hints), 0, sizeof(hints));
#line 382
  hints.ai_family = 0;
#line 383
  hints.ai_flags = 4;
#line 384
  tmp___0 = getaddrinfo((char const   */* __restrict  */)(saddr), (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 384
  if (tmp___0) {
#line 385
    return ((result_e )0);
  }
#line 388
  if (res->ai_family == 2) {
    {
#line 389
    ca.version = (char)4;
#line 390
    ca.a.addr = ntohl(((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr);
    }
#line 391
    if (mask == 32U) {
#line 392
      ca.addr_type = (address_e )0;
#line 393
      ca.m.mask = 4294967295U;
    } else {
#line 398
      ca.addr_type = (address_e )1;
#line 400
      i = 2147483648U;
#line 401
      ca.m.mask = (uint32_t )0;
#line 403
      n = mask;
      {
#line 403
      while (1) {
        while_continue: /* CIL Label */ ;
#line 403
        if (! (n != 0U)) {
#line 403
          goto while_break;
        }
#line 405
        ca.m.mask |= i;
#line 406
        i /= 2U;
#line 403
        n --;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else
#line 411
  if (res->ai_family == 10) {
#line 412
    ca.version = (char)6;
#line 413
    if (mask >= 128U) {
#line 414
      ca.addr_type = (address_e )2;
    } else {
#line 416
      ca.addr_type = (address_e )1;
    }
    {
#line 418
    memcpy((void */* __restrict  */)(& ca.a.addr6), (void const   */* __restrict  */)(& ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr),
           sizeof(struct in6_addr ));
#line 420
    xsetmask((char *)(& ca.m.mask6), mask, (unsigned int )sizeof(ca.m.mask6));
    }
  }
  {
#line 423
  freeaddrinfo(res);
#line 425
  tmp___3 = (*op)(addr_list, & ca);
  }
#line 425
  if ((unsigned int )tmp___3 == 1U) {
#line 425
    tmp___2 = 1;
  } else {
#line 425
    tmp___2 = 2;
  }
#line 425
  return ((result_e )tmp___2);
}
}
#line 448
static result_e net_addr(char const   *str_addr , status_e (*op)() , pset_h addr_list ) ;
#line 448 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static struct __anonstruct_net_to_mask_68 net_to_mask[5]  = {      {(uint32_t )0, 4278190080U, (uint32_t )24}, 
        {(uint32_t )255, 4294901760U, (uint32_t )16}, 
        {(uint32_t )65535, 4294967040U, (uint32_t )8}, 
        {(uint32_t )16777215, 4294967295U, (uint32_t )0}, 
        {4294967295U, (uint32_t )0, (uint32_t )0}};
#line 433 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static result_e net_addr(char const   *str_addr , status_e (*op)() , pset_h addr_list ) 
{ 
  struct comp_addr ca ;
  struct netent *nep ;
  uint32_t net_num ;
  int i ;
  char const   *func ;
  int tmp___0 ;
  status_e tmp___1 ;

  {
  {
#line 460
  func = "net_addr";
#line 462
  nep = getnetbyname(str_addr);
  }
#line 463
  if ((unsigned long )nep == (unsigned long )((void *)0)) {
#line 464
    return ((result_e )0);
  } else
#line 463
  if (nep->n_addrtype != 2) {
#line 464
    return ((result_e )0);
  } else
#line 463
  if (nep->n_net == 0U) {
#line 464
    return ((result_e )0);
  }
#line 466
  i = 0;
#line 466
  net_num = nep->n_net;
  {
#line 466
  while (1) {
    while_continue: /* CIL Label */ ;
#line 468
    if (net_to_mask[i].mask == 0U) {
      {
#line 470
      msg(2, func, "INTERNAL ERROR: Cannot process net number %u", net_num);
      }
#line 472
      return ((result_e )2);
    }
#line 474
    if (net_to_mask[i].lim < net_num) {
#line 474
      if (net_num <= net_to_mask[i + 1].lim) {
        {
#line 476
        ca.addr_type = (address_e )1;
#line 477
        ca.a.addr = net_num << net_to_mask[i].shift;
#line 478
        ca.m.mask = net_to_mask[i].mask;
#line 479
        ca.version = (char)4;
#line 480
        tmp___1 = (*op)(addr_list, & ca);
        }
#line 480
        if ((unsigned int )tmp___1 == 1U) {
#line 480
          tmp___0 = 1;
        } else {
#line 480
          tmp___0 = 2;
        }
#line 480
        return ((result_e )tmp___0);
      }
    }
#line 466
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 489 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static result_e numeric_addr(char const   *str_addr , status_e (*op)() , pset_h addr_list ) 
{ 
  struct comp_addr ca ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct in6_addr zero ;
  uint32_t mask ;
  uint32_t addr ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  uint32_t tmp___4 ;
  int tmp___6 ;
  status_e tmp___7 ;

  {
  {
#line 494
  res = (struct addrinfo *)((void *)0);
#line 498
  tmp = strchr(str_addr, '/');
  }
#line 498
  if (tmp) {
#line 499
    return ((result_e )0);
  }
  {
#line 500
  tmp___0 = strchr(str_addr, '{');
  }
#line 500
  if (tmp___0) {
#line 501
    return ((result_e )0);
  }
  {
#line 503
  memset((void *)(& zero), 0, sizeof(zero));
#line 504
  memset((void *)(& hints), 0, sizeof(hints));
#line 506
  hints.ai_flags = 4;
#line 507
  tmp___1 = strchr(str_addr, ':');
  }
#line 507
  if (tmp___1) {
#line 508
    hints.ai_family = 10;
  } else {
#line 510
    hints.ai_family = 2;
  }
  {
#line 512
  tmp___2 = getaddrinfo((char const   */* __restrict  */)str_addr, (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 512
  if (tmp___2 != 0) {
#line 513
    return ((result_e )0);
  }
#line 515
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 516
    return ((result_e )0);
  }
#line 518
  if ((unsigned long )res->ai_addr == (unsigned long )((void *)0)) {
    {
#line 519
    freeaddrinfo(res);
    }
#line 520
    return ((result_e )0);
  }
#line 523
  if (res->ai_family == 10) {
    {
#line 524
    ca.version = (char)6;
#line 525
    ca.addr_type = (address_e )0;
#line 526
    tmp___3 = memcmp((void const   *)(& ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr),
                     (void const   *)(& zero), sizeof(struct in6_addr ));
    }
#line 526
    if (tmp___3 == 0) {
      {
#line 528
      memset((void *)(& ca.a.addr6), 0, sizeof(struct in6_addr ));
#line 529
      memset((void *)(& ca.m.mask6), 0, sizeof(struct in6_addr ));
      }
    } else {
      {
#line 531
      memcpy((void */* __restrict  */)(& ca.a.addr6), (void const   */* __restrict  */)(& ((struct sockaddr_in6 *)res->ai_addr)->sin6_addr),
             sizeof(struct in6_addr ));
#line 533
      memset((void *)(& ca.m.mask6), 255, sizeof(struct in6_addr ));
      }
    }
  } else
#line 535
  if (res->ai_family == 2) {
#line 536
    ca.version = (char)4;
#line 537
    ca.addr_type = (address_e )0;
#line 538
    if (((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr == 0U) {
#line 539
      ca.a.addr = (uint32_t )0;
#line 540
      ca.m.mask = (uint32_t )0;
    } else {
      {
#line 542
      tmp___4 = ntohl(((struct sockaddr_in *)res->ai_addr)->sin_addr.s_addr);
#line 542
      addr = tmp___4;
#line 543
      mask = (uint32_t )255;
      }
      {
#line 543
      while (1) {
        while_continue: /* CIL Label */ ;
#line 545
        if (addr & mask) {
#line 546
          goto while_break;
        }
#line 547
        mask <<= 8;
#line 548
        mask |= 255U;
      }
      while_break: /* CIL Label */ ;
      }
#line 550
      mask = ~ (mask >> 8);
#line 552
      ca.a.addr = addr;
#line 553
      ca.m.mask = mask;
    }
  }
  {
#line 558
  freeaddrinfo(res);
#line 559
  tmp___7 = (*op)(addr_list, & ca);
  }
#line 559
  if ((unsigned int )tmp___7 == 1U) {
#line 559
    tmp___6 = 1;
  } else {
#line 559
    tmp___6 = 2;
  }
#line 559
  return ((result_e )tmp___6);
}
}
#line 567 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static result_e host_addr(char const   *str_addr , status_e (*op)() , pset_h addr_list ) 
{ 
  struct comp_addr ca ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  char addr[46] ;
  char *tmp ;
  char *tmp___0 ;
  status_e tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  status_e tmp___4 ;

  {
  {
#line 570
  res = (struct addrinfo *)((void *)0);
#line 573
  tmp = strchr(str_addr, '/');
  }
#line 573
  if (tmp) {
#line 574
    return ((result_e )0);
  }
  {
#line 575
  tmp___0 = strchr(str_addr, '{');
  }
#line 575
  if (tmp___0) {
#line 576
    return ((result_e )0);
  }
#line 578
  if ((int const   )*(str_addr + 0) == 46) {
    {
#line 580
    tmp___2 = check_hostname(str_addr);
    }
#line 580
    if (tmp___2) {
      {
#line 582
      ca.version = (char)-1;
#line 583
      ca.addr_type = (address_e )2;
#line 585
      strncpy((char */* __restrict  */)(ca.name), (char const   */* __restrict  */)str_addr,
              sizeof(ca.name) - 1UL);
#line 586
      ca.name[sizeof(ca.name) - 1UL] = (char )'\000';
#line 587
      tmp___1 = (*op)(addr_list, & ca);
      }
#line 587
      if ((unsigned int )tmp___1 == 0U) {
#line 588
        return ((result_e )2);
      }
#line 589
      return ((result_e )1);
    } else {
#line 592
      return ((result_e )0);
    }
  }
  {
#line 595
  memset((void *)(& hints), 0, sizeof(hints));
#line 596
  memset((void *)(addr), 0, sizeof(addr));
#line 598
  hints.ai_flags = 2;
#line 599
  hints.ai_family = 0;
#line 601
  tmp___3 = getaddrinfo((char const   */* __restrict  */)str_addr, (char const   */* __restrict  */)((void *)0),
                        (struct addrinfo  const  */* __restrict  */)(& hints), (struct addrinfo **/* __restrict  */)(& res));
  }
#line 601
  if (tmp___3 != 0) {
#line 602
    return ((result_e )0);
  }
#line 604
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 605
    return ((result_e )0);
  }
  {
#line 607
  strncpy((char */* __restrict  */)(ca.name), (char const   */* __restrict  */)str_addr,
          sizeof(ca.name) - 1UL);
#line 608
  ca.name[sizeof(ca.name) - 1UL] = (char )'\000';
#line 609
  ca.addr_type = (address_e )2;
#line 610
  ca.version = (char)-1;
#line 611
  freeaddrinfo(res);
#line 613
  tmp___4 = (*op)(addr_list, & ca);
  }
#line 613
  if ((unsigned int )tmp___4 == 0U) {
#line 614
    return ((result_e )2);
  } else {
#line 616
    return ((result_e )1);
  }
}
}
#line 629 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static result_e factorized_addr(char const   *str_addr , status_e (*op)() , pset_h addr_list ) 
{ 
  int pass ;
  char last ;
  unsigned int num ;
  int shift ;
  uint32_t addr ;
  struct comp_addr ca ;
  char const   *func ;
  int i ;
  int j ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  status_e tmp___3 ;

  {
#line 634
  last = (char )'.';
#line 635
  num = 0U;
#line 636
  shift = 24;
#line 637
  addr = (uint32_t )0;
#line 639
  func = "factorized_addr";
#line 642
  i = 0;
  {
#line 642
  while (1) {
    while_continue: /* CIL Label */ ;
#line 642
    if (! ((int const   )*(str_addr + i) != 123)) {
#line 642
      goto while_break;
    }
    {
#line 644
    tmp___0 = __ctype_b_loc();
    }
#line 644
    if ((int const   )*(*tmp___0 + (int )*(str_addr + i)) & 2048) {
#line 646
      num = (num * 10U + (unsigned int )*(str_addr + i)) - 48U;
#line 647
      goto __Cont;
    }
    {
#line 651
    if ((int const   )*(str_addr + i) == 46) {
#line 651
      goto case_46;
    }
#line 663
    goto switch_default;
    case_46: /* CIL Label */ 
#line 652
    if ((int )last == 46) {
      {
#line 654
      parsemsg(3, func, "Bad address: %s. Consecutive dots", str_addr);
      }
#line 656
      return ((result_e )2);
    }
#line 658
    addr = addr * 256U + num;
#line 659
    num = 0U;
#line 660
    shift -= 8;
#line 661
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 664
    return ((result_e )0);
    switch_break: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 642
    tmp = i;
#line 642
    i ++;
#line 642
    last = (char )*(str_addr + tmp);
  }
  while_break: /* CIL Label */ ;
  }
#line 668
  ca.addr_type = (address_e )0;
#line 669
  ca.version = (char)4;
#line 670
  if (addr != 0U) {
#line 671
    addr <<= shift + 8;
  }
#line 676
  j = i;
#line 677
  pass = 0;
  {
#line 677
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 677
    if (! (pass < 2)) {
#line 677
      goto while_break___0;
    }
#line 679
    i = j;
#line 680
    num = 0U;
#line 681
    i ++;
#line 681
    last = (char )',';
    {
#line 681
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 683
      tmp___2 = __ctype_b_loc();
      }
#line 683
      if ((int const   )*(*tmp___2 + (int )*(str_addr + i)) & 2048) {
#line 685
        num = (num * 10U + (unsigned int )*(str_addr + i)) - 48U;
#line 686
        goto __Cont___0;
      }
      {
#line 691
      if ((int const   )*(str_addr + i) == 125) {
#line 691
        goto case_125;
      }
#line 691
      if ((int const   )*(str_addr + i) == 44) {
#line 691
        goto case_125;
      }
#line 709
      goto switch_default___0;
      case_125: /* CIL Label */ 
      case_44: /* CIL Label */ 
#line 692
      if ((int )last == 44) {
        {
#line 694
        parsemsg(3, func, "Bad address: %s. Consecutive commas", str_addr);
        }
#line 696
        return ((result_e )2);
      }
#line 699
      if (pass == 1) {
        {
#line 701
        ca.a.addr = addr + (num << shift);
#line 702
        ca.m.mask = (uint32_t )(~ ((1 << shift) - 1));
#line 703
        tmp___3 = (*op)(addr_list, & ca);
        }
#line 703
        if ((unsigned int )tmp___3 == 0U) {
#line 704
          return ((result_e )2);
        }
#line 705
        num = 0U;
      }
#line 707
      goto switch_break___0;
      switch_default___0: /* CIL Label */ 
      {
#line 710
      parsemsg(3, func, "Bad address: %s", str_addr);
      }
#line 711
      return ((result_e )2);
      switch_break___0: /* CIL Label */ ;
      }
#line 713
      if ((int const   )*(str_addr + i) == 125) {
#line 715
        if ((int const   )*(str_addr + (i + 1)) != 0) {
          {
#line 717
          parsemsg(3, func, "Bad address: %s", str_addr);
          }
#line 718
          return ((result_e )2);
        }
#line 721
        if (pass == 0) {
#line 722
          goto while_break___1;
        } else {
#line 724
          return ((result_e )1);
        }
      }
      __Cont___0: /* CIL Label */ 
#line 681
      tmp___1 = i;
#line 681
      i ++;
#line 681
      last = (char )*(str_addr + tmp___1);
    }
    while_break___1: /* CIL Label */ ;
    }
#line 677
    pass ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 730
  return ((result_e )2);
}
}
#line 747
static status_e addrlist_op(pset_h addr_list , status_e (*op)() , char const   *str_addr ) ;
#line 747 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static result_e (*addr_parser[6])()  = {      (result_e (*)())(& numeric_addr),      (result_e (*)())(& host_addr),      (result_e (*)())(& explicit_mask),      (result_e (*)())(& factorized_addr), 
        (result_e (*)())(& net_addr),      (result_e (*)())((void *)0)};
#line 742 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
static status_e addrlist_op(pset_h addr_list , status_e (*op)() , char const   *str_addr ) 
{ 
  int i ;
  char const   *func ;
  result_e tmp ;

  {
#line 756
  func = "addrlist_op";
#line 758
  if ((unsigned long )str_addr == (unsigned long )((void *)0)) {
#line 759
    return ((status_e )0);
  }
#line 761
  if ((int const   )*(str_addr + 0) == 0) {
#line 762
    return ((status_e )1);
  }
#line 764
  i = 0;
  {
#line 764
  while (1) {
    while_continue: /* CIL Label */ ;
#line 764
    if (! ((unsigned long )addr_parser[i] != (unsigned long )((void *)0))) {
#line 764
      goto while_break;
    }
    {
#line 765
    tmp = (*(addr_parser[i]))(str_addr, op, addr_list);
    }
    {
#line 767
    if ((unsigned int )tmp == 1U) {
#line 767
      goto case_1;
    }
#line 769
    if ((unsigned int )tmp == 2U) {
#line 769
      goto case_2;
    }
#line 771
    if ((unsigned int )tmp == 0U) {
#line 771
      goto case_0;
    }
#line 765
    goto switch_break;
    case_1: /* CIL Label */ 
#line 768
    return ((status_e )1);
    case_2: /* CIL Label */ 
#line 770
    return ((status_e )0);
    case_0: /* CIL Label */ 
#line 772
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 764
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 775
  parsemsg(3, func, "failed to parse %s", str_addr);
  }
#line 776
  return ((status_e )1);
}
}
#line 780 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
status_e addrlist_add(pset_h addr_list , char const   *str_addr ) 
{ 
  status_e tmp ;

  {
  {
#line 782
  tmp = addrlist_op(addr_list, (status_e (*)())(& add), str_addr);
  }
#line 782
  return (tmp);
}
}
#line 786 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
status_e addrlist_remove(pset_h addr_list , char const   *str_addr ) 
{ 
  status_e tmp ;

  {
  {
#line 788
  tmp = addrlist_op(addr_list, (status_e (*)())(& xremove), str_addr);
  }
#line 788
  return (tmp);
}
}
#line 792 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/addr.c"
status_e addrlist_copy(pset_h const   from , pset_h *to ) 
{ 
  status_e tmp ;

  {
  {
#line 794
  tmp = copy_pset(from, to, (unsigned int )sizeof(struct comp_addr ));
  }
#line 794
  return (tmp);
}
}
#line 83 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.h"
void server_release(struct server *serp ) ;
#line 85
status_e server_start(struct server *serp ) ;
#line 7 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.h"
status_e schedule_retry(struct server *serp ) ;
#line 59 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
struct server *server_alloc(struct server  const  *init_serp ) 
{ 
  struct server *serp ;
  char const   *func ;
  void *tmp ;
  __pset_pointer tmp___0 ;

  {
  {
#line 62
  func = "server_alloc";
#line 64
  tmp = malloc(sizeof(struct server ));
#line 64
  serp = (struct server *)tmp;
  }
#line 65
  if ((unsigned long )serp == (unsigned long )((void *)0)) {
    {
#line 67
    out_of_memory(func);
    }
#line 68
    return ((struct server *)((void *)0));
  }
  {
#line 71
  tmp___0 = pset_add(ps.rws.servers, (__pset_pointer const   )serp);
  }
#line 71
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 73
    msg(2, func, "couldn\'t insert server in server table");
#line 74
    memset((void *)((char *)serp), 0, sizeof(*serp));
#line 75
    free((void *)((char *)serp));
    }
#line 76
    return ((struct server *)((void *)0));
  }
#line 79
  *serp = (struct server )*init_serp;
#line 80
  ((serp->svr_sp)->svc_ref_count) ++;
#line 82
  return (serp);
}
}
#line 86 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
void server_release(struct server *serp ) 
{ 
  struct service *sp ;
  int count ;

  {
  {
#line 88
  sp = serp->svr_sp;
#line 89
  (sp->svc_ref_count) --;
#line 89
  count = sp->svc_ref_count;
#line 91
  pset_delete(ps.rws.servers, (__pset_pointer const   )((__pset_pointer )serp));
  }
#line 92
  if (count == 0) {
#line 93
    if (! ((sp->svc_conf)->sc_type & (1UL << 3))) {
      {
#line 94
      pset_delete(ps.rws.services, (__pset_pointer const   )((__pset_pointer )sp));
      }
    }
    {
#line 95
    svc_release(sp);
    }
  }
  {
#line 98
  memset((void *)((char *)serp), 0, sizeof(*serp));
#line 99
  free((void *)((char *)serp));
  }
#line 100
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
static void server_internal(struct server *serp ) 
{ 
  struct service *sp ;
  char const   *func ;
  int tmp ;

  {
#line 114
  sp = serp->svr_sp;
#line 115
  func = "server_internal";
#line 117
  serp->svr_pid = 0;
#line 118
  if ((unsigned int )(sp->svc_conf)->sc_wait == 0U) {
#line 118
    if ((sp->svc_conf)->sc_socket_type == 1) {
      {
#line 118
      tmp = fcntl((serp->svr_conn)->co_descriptor, 4, 2048);
      }
#line 118
      if (tmp == -1) {
        {
#line 121
        msg(3, func, "%s: fcntl F_SETFL failed: %m", (sp->svc_conf)->sc_id);
        }
#line 122
        return;
      }
    }
  }
  {
#line 124
  svc_log_success(sp, (connection_s const   *)serp->svr_conn, serp->svr_pid);
#line 125
  (*(((sp->svc_conf)->sc_builtin)->b_handler))(serp);
  }
#line 126
  return;
}
}
#line 136 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
status_e server_run(struct service *sp , connection_s *cp ) 
{ 
  struct server server ;
  struct server *serp ;
  char const   *func ;
  status_e tmp ;
  status_e tmp___0 ;
  status_e tmp___1 ;

  {
  {
#line 139
  serp = (struct server *)((void *)0);
#line 140
  func = "server_run";
#line 142
  memset((void *)((char *)(& server)), 0, sizeof(server));
#line 143
  server.svr_sp = sp;
#line 144
  server.svr_conn = cp;
  }
#line 146
  if (! (! ((sp->svc_conf)->sc_type & (1UL << 1)))) {
#line 146
    if (! ((unsigned int const   )((sp->svc_conf)->sc_builtin)->b_fork_server == 1U)) {
      {
#line 153
      tmp = svc_child_access_control(sp, cp);
      }
#line 153
      if ((unsigned int )tmp == 1U) {
        {
#line 154
        server_internal(& server);
        }
      } else {
#line 156
        if ((unsigned int )(sp->svc_conf)->sc_wait == 1U) {
          {
#line 157
          svc_resume(sp);
          }
        }
#line 158
        return ((status_e )0);
      }
#line 160
      if ((unsigned int )(sp->svc_conf)->sc_wait == 1U) {
        {
#line 161
        svc_resume(sp);
        }
      }
#line 162
      return ((status_e )1);
    }
  }
  {
#line 169
  serp = server_alloc((struct server  const  *)(& server));
  }
#line 170
  if ((unsigned long )serp == (unsigned long )((void *)0)) {
#line 171
    return ((status_e )0);
  }
  {
#line 173
  tmp___0 = server_start(serp);
  }
#line 173
  if ((unsigned int )tmp___0 == 1U) {
#line 175
    if (! ((unsigned int )(sp->svc_conf)->sc_wait == 1U)) {
      {
#line 176
      Sclose(cp->co_descriptor);
#line 176
      cp->co_descriptor = -1;
      }
    }
#line 177
    return ((status_e )1);
  }
#line 186
  if (! (serp->svr_fork_failures >= 5)) {
#line 186
    if (! ((sp->svc_conf)->sc_xflags & (1UL << 2))) {
      {
#line 188
      tmp___1 = schedule_retry(serp);
      }
#line 188
      if ((unsigned int )tmp___1 == 1U) {
#line 189
        return ((status_e )1);
      } else {
        {
#line 191
        msg(3, func, "Retry failure for %s service", (sp->svc_conf)->sc_id);
        }
      }
    } else {
      {
#line 194
      svc_log_failure(sp, (connection_s const   *)cp, (access_e )1);
      }
    }
  } else {
    {
#line 194
    svc_log_failure(sp, (connection_s const   *)cp, (access_e )1);
    }
  }
  {
#line 196
  server_release(serp);
  }
#line 197
  return ((status_e )0);
}
}
#line 207 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
status_e server_start(struct server *serp ) 
{ 
  struct service *sp ;
  char const   *func ;
  int tmp ;

  {
#line 209
  sp = serp->svr_sp;
#line 210
  func = "server_start";
#line 212
  if (debug.on) {
    {
#line 213
    msg(7, func, "Starting service %s", (sp->svc_conf)->sc_name);
    }
  }
#line 214
  if ((unsigned long )sp->svc_log != (unsigned long )((void *)0)) {
#line 214
    if ((sp->svc_conf)->sc_log_on_success & (1UL << 6)) {
#line 214
      if ((unsigned int )(sp->svc_conf)->sc_wait == 0U) {
#line 214
        if ((sp->svc_conf)->sc_socket_type == 1) {
#line 214
          tmp = 1;
        } else {
#line 214
          tmp = 0;
        }
      } else {
#line 214
        tmp = 0;
      }
    } else {
#line 214
      tmp = 0;
    }
  } else {
#line 214
    tmp = 0;
  }
  {
#line 214
  serp->svr_log_remote_user = tmp;
#line 216
  serp->svr_pid = fork();
  }
  {
#line 220
  if (serp->svr_pid == 0) {
#line 220
    goto case_0;
  }
#line 228
  if (serp->svr_pid == -1) {
#line 228
    goto case_neg_1;
  }
#line 233
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 221
  ps.rws.env_is_valid = 0;
#line 222
  child_process(serp);
#line 224
  msg(3, func, "INTERNAL ERROR: child_process returned");
#line 225
  _exit(0);
  }
  case_neg_1: /* CIL Label */ 
  {
#line 229
  msg(3, func, "%s: fork failed: %m", (sp->svc_conf)->sc_id);
#line 230
  (serp->svr_fork_failures) ++;
  }
#line 231
  return ((status_e )0);
  switch_default: /* CIL Label */ 
  {
#line 234
  time(& serp->svr_start_time);
#line 235
  (sp->svc_running_servers) ++;
  }
#line 242
  if (! ((sp->svc_conf)->sc_xflags & 1UL)) {
    {
#line 243
    svc_log_success(sp, (connection_s const   *)serp->svr_conn, serp->svr_pid);
    }
  } else {
#line 245
    serp->svr_writes_to_log = (unsigned long )sp->svc_log != (unsigned long )((void *)0);
  }
#line 246
  serp->svr_writes_to_log |= serp->svr_log_remote_user;
#line 247
  return ((status_e )1);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 252 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
void server_dump(struct server  const  *serp , int fd ) 
{ 
  struct service  const  *sp ;
  char *tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;

  {
  {
#line 254
  sp = (struct service  const  *)serp->svr_sp;
#line 256
  Sprint(fd, "%s server\n", (sp->svc_conf)->sc_id);
#line 257
  Sprint(fd, "pid = %d\n", serp->svr_pid);
#line 258
  tmp = ctime(& serp->svr_start_time);
#line 258
  Sprint(fd, "start_time = %s", tmp);
#line 259
  Sprint(fd, "Connection info:\n");
#line 260
  conn_dump((connection_s const   *)((connection_s *)serp->svr_conn), fd);
  }
#line 261
  if (serp->svr_fork_failures) {
    {
#line 262
    Sprint(fd, "fork_failures = %d\n", serp->svr_fork_failures);
    }
  }
#line 263
  if (serp->svr_log_remote_user) {
#line 263
    tmp___0 = "YES";
  } else {
#line 263
    tmp___0 = "NO";
  }
  {
#line 263
  Sprint(fd, "log_remote_user = %s\n", tmp___0);
  }
#line 265
  if (serp->svr_writes_to_log) {
#line 265
    tmp___1 = "YES";
  } else {
#line 265
    tmp___1 = "NO";
  }
  {
#line 265
  Sprint(fd, "writes_to_log = %s\n", tmp___1);
#line 267
  Sputchar(fd, (char )'\n');
#line 268
  Sflush(fd);
  }
#line 269
  return;
}
}
#line 276 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
void server_end(struct server *serp ) 
{ 
  struct service *sp ;
  char const   *func ;
  char const   *death_type ;
  char const   *tmp ;
  union __anonunion_80___0 __constr_expr_11 ;
  struct service *conn_sp ;
  union __anonunion_81___0 __constr_expr_12 ;
  union __anonunion_82___0 __constr_expr_13 ;
  union __anonunion_83___2 __constr_expr_14 ;

  {
#line 278
  sp = serp->svr_sp;
#line 279
  func = "server_end";
#line 281
  __constr_expr_13.__in = serp->svr_exit_status;
#line 281
  if ((__constr_expr_13.__i & 127) == 0) {
#line 281
    goto _L;
  } else {
#line 281
    __constr_expr_14.__in = serp->svr_exit_status;
#line 281
    if ((int )((signed char )((__constr_expr_14.__i & 127) + 1)) >> 1 > 0) {
      _L: /* CIL Label */ 
#line 284
      __constr_expr_11.__in = serp->svr_exit_status;
#line 284
      if ((__constr_expr_11.__i & 127) == 0) {
#line 284
        tmp = "exited";
      } else {
#line 284
        tmp = "died";
      }
#line 284
      death_type = tmp;
#line 286
      if (debug.on) {
#line 288
        conn_sp = (serp->svr_conn)->co_sp;
#line 290
        if ((unsigned long )conn_sp == (unsigned long )sp) {
          {
#line 291
          msg(7, func, "%s server %d %s", (sp->svc_conf)->sc_id, serp->svr_pid, death_type);
          }
        } else {
          {
#line 294
          msg(7, func, "%s server %d running on behalf of service %s %s", (sp->svc_conf)->sc_id,
              serp->svr_pid, (conn_sp->svc_conf)->sc_id, death_type);
          }
        }
      }
#line 300
      if ((unsigned int )(sp->svc_conf)->sc_wait == 1U) {
#line 301
        ps.rws.socket_mask.__fds_bits[sp->svc_fd / (8 * (int )sizeof(__fd_mask ))] |= 1L << sp->svc_fd % (8 * (int )sizeof(__fd_mask ));
      }
      {
#line 303
      svc_postmortem(sp, serp);
#line 304
      server_release(serp);
      }
    } else {
#line 306
      __constr_expr_12.__in = serp->svr_exit_status;
#line 306
      if ((__constr_expr_12.__i & 255) == 127) {
        {
#line 307
        msg(4, func, "service %s: server with pid %d stopped", (sp->svc_conf)->sc_id,
            serp->svr_pid);
        }
      }
    }
  }
#line 309
  return;
}
}
#line 315 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/server.c"
struct server *server_lookup(pid_t pid ) 
{ 
  unsigned int u ;
  register struct server *serp ;

  {
#line 319
  u = 0U;
  {
#line 319
  while (1) {
    while_continue: /* CIL Label */ ;
#line 319
    if (! (u < (ps.rws.servers)->count)) {
#line 319
      goto while_break;
    }
#line 323
    serp = (struct server *)*((ps.rws.servers)->ptrs + u);
#line 324
    if (serp->svr_pid == pid) {
#line 325
      return (serp);
    }
#line 319
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  return ((struct server *)((void *)0));
}
}
#line 22 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.h"
int xtimer_remove(int xtid ) ;
#line 25 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.c"
static int retry_timer_running  ;
#line 26
static void cancel_retry(struct server *serp ) ;
#line 27
static void stop_retry_timer(void) ;
#line 28
static void start_retry_timer(void) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.c"
static void server_retry(void) 
{ 
  unsigned int servers_started ;
  unsigned int u ;
  char const   *func ;
  struct server *retry ;
  struct service *sp ;
  connection_s *cp ;
  status_e tmp ;
  status_e tmp___0 ;
  __pset_pointer tmp___1 ;
  status_e tmp___2 ;

  {
#line 36
  servers_started = 0U;
#line 38
  func = "server_retry";
#line 40
  u = 0U;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (u < (ps.rws.retries)->count)) {
#line 40
      goto while_break;
    }
    {
#line 42
    retry = (struct server *)*((ps.rws.retries)->ptrs + u);
#line 43
    sp = retry->svr_sp;
#line 44
    cp = retry->svr_conn;
#line 50
    tmp = svc_parent_access_control(sp, cp);
    }
#line 50
    if ((unsigned int )tmp == 0U) {
      {
#line 54
      cancel_retry(retry);
#line 55
      *((ps.rws.retries)->ptrs + u) = (void *)0;
      }
#line 56
      goto __Cont;
    } else {
      {
#line 50
      tmp___0 = svc_child_access_control(sp, cp);
      }
#line 50
      if ((unsigned int )tmp___0 == 0U) {
        {
#line 54
        cancel_retry(retry);
#line 55
        *((ps.rws.retries)->ptrs + u) = (void *)0;
        }
#line 56
        goto __Cont;
      } else {
        {
#line 50
        tmp___1 = pset_add(ps.rws.servers, (__pset_pointer const   )retry);
        }
#line 50
        if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
          {
#line 54
          cancel_retry(retry);
#line 55
          *((ps.rws.retries)->ptrs + u) = (void *)0;
          }
#line 56
          goto __Cont;
        }
      }
    }
    {
#line 59
    tmp___2 = server_start(retry);
    }
#line 59
    if ((unsigned int )tmp___2 == 1U) {
#line 61
      servers_started ++;
#line 62
      (sp->svc_retry_servers) --;
#line 63
      if (! ((unsigned int )(sp->svc_conf)->sc_wait == 1U)) {
        {
#line 64
        Sclose(cp->co_descriptor);
#line 64
        cp->co_descriptor = -1;
        }
      }
#line 65
      *((ps.rws.retries)->ptrs + u) = (void *)0;
#line 66
      goto __Cont;
    } else {
      {
#line 70
      pset_delete(ps.rws.servers, (__pset_pointer const   )((__pset_pointer )retry));
      }
#line 71
      if (retry->svr_fork_failures >= 5) {
        {
#line 76
        msg(3, func, "service %s: too many consecutive fork failures", (sp->svc_conf)->sc_id);
#line 78
        svc_log_failure(sp, (connection_s const   *)cp, (access_e )1);
#line 79
        cancel_retry(retry);
#line 80
        *((ps.rws.retries)->ptrs + u) = (void *)0;
        }
#line 81
        goto __Cont;
      } else
#line 85
      if (debug.on) {
        {
#line 86
        msg(7, func, "fork failed for service %s. Retrying...", (sp->svc_conf)->sc_id);
        }
      }
    }
    __Cont: /* CIL Label */ 
#line 40
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 92
  pset_compact(ps.rws.retries);
  }
#line 94
  if (debug.on) {
    {
#line 95
    msg(7, func, "%d servers started, %d left to retry", servers_started, (ps.rws.retries)->count);
    }
  }
#line 100
  if ((ps.rws.retries)->count > 0U) {
    {
#line 101
    retry_timer_running = xtimer_add(& server_retry, (time_t )5);
    }
#line 101
    if (retry_timer_running == -1) {
      {
#line 103
      msg(3, func, "xtimer_add: %m");
#line 104
      retry_timer_running = 0;
      }
    }
  } else {
#line 108
    retry_timer_running = 0;
  }
#line 109
  return;
}
}
#line 116 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.c"
status_e schedule_retry(struct server *serp ) 
{ 
  struct service *sp ;
  char const   *func ;
  __pset_pointer tmp ;

  {
  {
#line 118
  sp = serp->svr_sp;
#line 119
  func = "schedule_retry";
#line 121
  tmp = pset_add(ps.rws.retries, (__pset_pointer const   )serp);
  }
#line 121
  if ((unsigned long )tmp == (unsigned long )((void *)0)) {
    {
#line 123
    out_of_memory(func);
    }
#line 124
    return ((status_e )0);
  }
  {
#line 126
  (sp->svc_retry_servers) ++;
#line 127
  start_retry_timer();
  }
#line 128
  if (debug.on) {
    {
#line 129
    msg(7, func, "Scheduled retry attempt for %s", (sp->svc_conf)->sc_id);
    }
  }
#line 130
  return ((status_e )1);
}
}
#line 140 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.c"
static void cancel_retry(struct server *serp ) 
{ 
  struct service *sp ;

  {
  {
#line 142
  sp = serp->svr_sp;
#line 144
  conn_free(serp->svr_conn, 1);
#line 145
  (sp->svc_retry_servers) --;
#line 146
  server_release(serp);
  }
#line 147
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.c"
void cancel_service_retries(struct service *sp ) 
{ 
  unsigned int u ;
  char const   *func ;
  struct server *serp ;

  {
#line 157
  func = "cancel_service_retries";
#line 159
  if (sp->svc_retry_servers == 0U) {
#line 160
    return;
  }
#line 162
  u = 0U;
  {
#line 163
  while (1) {
    while_continue: /* CIL Label */ ;
#line 163
    if (! (u < (ps.rws.retries)->count)) {
#line 163
      goto while_break;
    }
#line 167
    serp = (struct server *)*((ps.rws.retries)->ptrs + u);
#line 168
    if ((unsigned long )serp->svr_sp == (unsigned long )sp) {
      {
#line 170
      msg(5, func, "dropping retry attempt for service %s", (sp->svc_conf)->sc_id);
#line 172
      cancel_retry(serp);
      }
#line 173
      if (u < (ps.rws.retries)->count) {
        {
#line 173
        pset_delete(ps.rws.retries, (__pset_pointer const   )*((ps.rws.retries)->ptrs + u));
        }
      }
#line 174
      goto while_continue;
    }
#line 176
    u ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 179
  if ((ps.rws.retries)->count == 0U) {
    {
#line 180
    stop_retry_timer();
    }
  }
#line 181
  return;
}
}
#line 184 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.c"
static void start_retry_timer(void) 
{ 
  char const   *func ;

  {
#line 186
  func = "start_retry_timer";
#line 192
  if (retry_timer_running == 0) {
    {
#line 193
    retry_timer_running = xtimer_add(& server_retry, (time_t )5);
    }
#line 193
    if (retry_timer_running == -1) {
      {
#line 194
      msg(3, func, "xtimer_add: %m");
#line 195
      retry_timer_running = 0;
      }
    }
  }
#line 197
  return;
}
}
#line 200 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/retry.c"
static void stop_retry_timer(void) 
{ 


  {
#line 202
  if (retry_timer_running != 0) {
    {
#line 204
    xtimer_remove(retry_timer_running);
#line 205
    retry_timer_running = 0;
    }
  }
#line 207
  return;
}
}
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 227
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigismember)(sigset_t const   *__set ,
                                                                                                  int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 564 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strsignal)(int __sig ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 55 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static void my_handler(int sig ) ;
#line 56
static void general_handler(int sig ) ;
#line 150 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static sigset_t reset_sigs  ;
#line 155 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static int nsig  ;
#line 163 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static status_e handle_signal(int sig ) 
{ 
  struct sigaction sa ;
  sigfunc *sig_handler ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 168
  sa.sa_flags = 0;
  {
#line 178
  if (sig == 3) {
#line 178
    goto case_3;
  }
#line 178
  if (sig == 17) {
#line 178
    goto case_3;
  }
#line 178
  if (sig == 6) {
#line 178
    goto case_3;
  }
#line 178
  if (sig == 10) {
#line 178
    goto case_3;
  }
#line 178
  if (sig == 15) {
#line 178
    goto case_3;
  }
#line 178
  if (sig == 12) {
#line 178
    goto case_3;
  }
#line 178
  if (sig == 1) {
#line 178
    goto case_3;
  }
#line 184
  if (sig == 20) {
#line 184
    goto case_20;
  }
#line 184
  if (sig == 22) {
#line 184
    goto case_20;
  }
#line 184
  if (sig == 21) {
#line 184
    goto case_20;
  }
#line 194
  if (sig == 13) {
#line 194
    goto case_13;
  }
#line 200
  if (sig == 19) {
#line 200
    goto case_19;
  }
#line 200
  if (sig == 9) {
#line 200
    goto case_19;
  }
#line 210
  if (sig == 7) {
#line 210
    goto case_7;
  }
#line 210
  if (sig == 11) {
#line 210
    goto case_7;
  }
#line 217
  if (sig == 5) {
#line 217
    goto case_5;
  }
#line 221
  goto switch_default;
  case_3: /* CIL Label */ 
  case_17: /* CIL Label */ 
  case_6: /* CIL Label */ 
  case_10: /* CIL Label */ 
  case_15: /* CIL Label */ 
  case_12: /* CIL Label */ 
  case_1: /* CIL Label */ 
#line 179
  sig_handler = & my_handler;
#line 180
  goto switch_break;
  case_20: /* CIL Label */ 
  case_22: /* CIL Label */ 
  case_21: /* CIL Label */ 
#line 185
  if (debug.on) {
#line 186
    return ((status_e )1);
  }
  case_13: /* CIL Label */ 
  {
#line 195
  sig_handler = (void (*)(int  ))1;
#line 196
  sigaddset(& reset_sigs, sig);
  }
#line 197
  goto switch_break;
  case_19: /* CIL Label */ 
  case_9: /* CIL Label */ 
#line 201
  return ((status_e )1);
  case_7: /* CIL Label */ 
  case_11: /* CIL Label */ 
#line 214
  sig_handler = & general_handler;
#line 215
  goto switch_break;
  case_5: /* CIL Label */ 
#line 218
  if (debug.on) {
#line 219
    return ((status_e )1);
  }
  switch_default: /* CIL Label */ 
#line 222
  sig_handler = & general_handler;
  switch_break: /* CIL Label */ ;
  }
  {
#line 225
  sigemptyset(& sa.sa_mask);
#line 226
  sa.__sigaction_handler.sa_handler = sig_handler;
#line 227
  tmp___1 = sigaction(sig, (struct sigaction  const  */* __restrict  */)(& sa), (struct sigaction */* __restrict  */)((struct sigaction *)0));
  }
#line 227
  if (tmp___1 == -1) {
#line 227
    tmp___0 = 0;
  } else {
#line 227
    tmp___0 = 1;
  }
#line 227
  return ((status_e )tmp___0);
}
}
#line 235 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
status_e signal_init(void) 
{ 
  int sig ;
  char const   *func ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;
  int *tmp___3 ;
  status_e tmp___4 ;

  {
  {
#line 238
  func = "install_signal_handlers";
#line 240
  sigemptyset(& reset_sigs);
#line 242
  tmp = pipe((int *)(signals_pending));
  }
#line 242
  if (tmp) {
    {
#line 245
    msg(2, func, "Failed to create signal pipe: %m");
    }
#line 246
    return ((status_e )0);
  } else {
    {
#line 242
    tmp___0 = fcntl(signals_pending[0], 2, 1);
    }
#line 242
    if (tmp___0) {
      {
#line 245
      msg(2, func, "Failed to create signal pipe: %m");
      }
#line 246
      return ((status_e )0);
    } else {
      {
#line 242
      tmp___1 = fcntl(signals_pending[1], 2, 1);
      }
#line 242
      if (tmp___1) {
        {
#line 245
        msg(2, func, "Failed to create signal pipe: %m");
        }
#line 246
        return ((status_e )0);
      }
    }
  }
#line 249
  sig = 1;
  {
#line 249
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 250
    tmp___4 = handle_signal(sig);
    }
#line 250
    if ((unsigned int )tmp___4 == 0U) {
      {
#line 251
      tmp___3 = __errno_location();
      }
#line 251
      if (*tmp___3 == 22) {
#line 253
        nsig = sig;
#line 254
        goto while_break;
      } else {
        {
#line 258
        tmp___2 = sig_name(sig);
#line 258
        msg(2, func, "Failed to install signal handler for signal %s: %m", tmp___2);
        }
#line 261
        return ((status_e )0);
      }
    }
#line 249
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 264
  return ((status_e )1);
}
}
#line 288 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static time_t interval_start  ;
#line 289 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static int volatile   interval_signal_count  ;
#line 290 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static int volatile   total_signal_count  ;
#line 286 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static void bad_signal(void) 
{ 
  time_t current_time ;
  char const   *func ;

  {
#line 292
  func = "bad_signal";
#line 294
  total_signal_count += (int volatile   )1;
#line 295
  if (total_signal_count == (int volatile   )50) {
    {
#line 297
    msg(2, func, "Received %d bad signals. Exiting...", total_signal_count);
#line 299
    exit(1);
    }
  } else
#line 301
  if (total_signal_count > (int volatile   )50) {
    {
#line 302
    _exit(1);
    }
  }
  {
#line 304
  time(& current_time);
  }
#line 306
  if (interval_signal_count > (int volatile   )0) {
#line 306
    if (current_time - interval_start <= 1L) {
#line 309
      interval_signal_count += (int volatile   )1;
#line 310
      if (interval_signal_count == (int volatile   )10) {
#line 312
        if (ps.rws.env_is_valid) {
          {
#line 314
          interval_start = current_time;
#line 315
          interval_signal_count = (int volatile   )1;
#line 316
          msg(3, func, "Resetting...");
#line 317
          siglongjmp((struct __jmp_buf_tag *)(ps.rws.env), 1);
          }
        }
        {
#line 320
        msg(2, func, "Received %d signals in %d seconds. Exiting...", interval_signal_count,
            1);
#line 323
        exit(1);
        }
      } else
#line 325
      if (interval_signal_count > (int volatile   )10) {
        {
#line 326
        _exit(1);
        }
      }
    } else {
#line 330
      interval_start = current_time;
#line 331
      interval_signal_count = (int volatile   )1;
    }
  } else {
#line 330
    interval_start = current_time;
#line 331
    interval_signal_count = (int volatile   )1;
  }
#line 333
  return;
}
}
#line 337 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static char signame_buf[30]  ;
#line 335 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
char *sig_name(int sig ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
#line 341
  if (sig < 65) {
    {
#line 342
    tmp = strsignal(sig);
#line 342
    tmp___0 = strx_sprint(signame_buf, (int )(sizeof(signame_buf) - 1UL), "%d (%s)",
                          sig, tmp);
    }
#line 342
    return (tmp___0);
  }
  {
#line 351
  tmp___1 = strx_sprint(signame_buf, (int )(sizeof(signame_buf) - 1UL), "%d", sig);
  }
#line 351
  return (tmp___1);
}
}
#line 363 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static void general_handler(int sig ) 
{ 
  sigset_t badsigs ;
  char const   *func ;
  char *tmp ;
  __pid_t tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 366
  func = "general_handler";
#line 371
  sigemptyset(& badsigs);
#line 372
  sigaddset(& badsigs, sig);
#line 373
  sigprocmask(1, (sigset_t const   */* __restrict  */)(& badsigs), (sigset_t */* __restrict  */)((sigset_t *)0));
  }
  {
#line 378
  if (sig == 11) {
#line 378
    goto case_11;
  }
#line 378
  if (sig == 7) {
#line 378
    goto case_11;
  }
#line 391
  goto switch_default;
  case_11: /* CIL Label */ 
  case_7: /* CIL Label */ 
  {
#line 379
  tmp = sig_name(sig);
#line 379
  tmp___0 = getpid();
#line 379
  msg(2, func, "(%d) Unexpected signal: %s", tmp___0, tmp);
  }
#line 381
  if (debug.on) {
    {
#line 384
    signal(6, (void (*)(int  ))0);
#line 385
    abort();
    }
  } else {
    {
#line 388
    bad_signal();
    }
  }
#line 389
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 392
  tmp___1 = sig_name(sig);
#line 392
  msg(5, func, "Unexpected signal %s", tmp___1);
  }
#line 393
  if (debug.on) {
#line 393
    if (sig == 2) {
      {
#line 394
      exit(1);
      }
    }
  }
  switch_break: /* CIL Label */ ;
  }
#line 396
  return;
}
}
#line 403 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
static void my_handler(int sig ) 
{ 
  ssize_t ret_val ;
  int saved_errno ;
  int *tmp ;
  unsigned char sig_byte ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
  {
#line 406
  tmp = __errno_location();
#line 406
  saved_errno = *tmp;
  }
#line 409
  if (signals_pending[1] < 0) {
#line 409
    return;
  }
#line 410
  if (sig >= 256) {
#line 410
    return;
  }
#line 411
  sig_byte = (unsigned char )sig;
  {
#line 412
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 414
    ret_val = write(signals_pending[1], (void const   *)(& sig_byte), (size_t )1);
    }
#line 412
    if (ret_val == -1L) {
      {
#line 412
      tmp___0 = __errno_location();
      }
#line 412
      if (! (*tmp___0 == 4)) {
#line 412
        goto while_break;
      }
    } else {
#line 412
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 423
  tmp___1 = __errno_location();
#line 423
  *tmp___1 = saved_errno;
  }
#line 424
  return;
}
}
#line 433 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
void signal_default_state(void) 
{ 
  int sig ;
  sigset_t empty ;
  char *tmp ;
  __sighandler_t tmp___0 ;
  int tmp___1 ;

  {
#line 438
  sig = 1;
  {
#line 438
  while (1) {
    while_continue: /* CIL Label */ ;
#line 438
    if (! (sig < nsig)) {
#line 438
      goto while_break;
    }
    {
#line 439
    tmp___1 = sigismember((sigset_t const   *)(& reset_sigs), sig);
    }
#line 439
    if (tmp___1 == 1) {
      {
#line 440
      tmp___0 = signal(sig, (void (*)(int  ))0);
      }
#line 440
      if ((unsigned long )tmp___0 == (unsigned long )((void (*)(int  ))-1)) {
        {
#line 442
        tmp = sig_name(sig);
#line 442
        msg(3, "reset_signals", "signal failed for signal %s: %m", tmp);
        }
#line 444
        if (debug.on) {
          {
#line 445
          _exit(1);
          }
        }
      }
    }
#line 438
    sig ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 448
  sigemptyset(& empty);
#line 449
  sigprocmask(2, (sigset_t const   */* __restrict  */)(& empty), (sigset_t */* __restrict  */)((sigset_t *)0));
  }
#line 450
  return;
}
}
#line 452 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/signals.c"
void check_pipe(void) 
{ 
  int i ;
  unsigned char sig ;
  char const   *func ;
  int tmp ;
  ssize_t ret_val ;
  int *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 460
  func = "check_pipe";
#line 462
  if (signals_pending[0] < 0) {
#line 462
    return;
  }
  {
#line 464
  tmp = ioctl(signals_pending[0], 21531UL, & i);
  }
#line 464
  if (tmp != 0) {
    {
#line 465
    msg(3, func, "Can\'t get the number of pending signals: %m");
    }
#line 466
    return;
  }
  {
#line 472
  while (1) {
    while_continue: /* CIL Label */ ;
#line 472
    i --;
#line 472
    if (! (i >= 0)) {
#line 472
      goto while_break;
    }
    {
#line 474
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 476
      ret_val = read(signals_pending[0], (void *)(& sig), sizeof(sig));
      }
#line 474
      if (ret_val == -1L) {
        {
#line 474
        tmp___0 = __errno_location();
        }
#line 474
        if (! (*tmp___0 == 4)) {
#line 474
          goto while_break___0;
        }
      } else {
#line 474
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 478
    if (ret_val != (ssize_t )sizeof(sig)) {
      {
#line 479
      msg(3, func, "Error retrieving pending signal: %m");
      }
#line 480
      return;
    }
#line 483
    if (debug.on) {
      {
#line 484
      tmp___1 = sig_name((int )sig);
#line 484
      msg(7, func, "Got signal %s", tmp___1);
      }
    }
    {
#line 488
    if ((int )sig == 17) {
#line 488
      goto case_17;
    }
#line 489
    if ((int )sig == 1) {
#line 489
      goto case_1;
    }
#line 490
    if ((int )sig == 12) {
#line 490
      goto case_12;
    }
#line 491
    if ((int )sig == 15) {
#line 491
      goto case_15;
    }
#line 492
    if ((int )sig == 10) {
#line 492
      goto case_10;
    }
#line 493
    if ((int )sig == 6) {
#line 493
      goto case_6;
    }
#line 494
    if ((int )sig == 3) {
#line 494
      goto case_3;
    }
#line 495
    goto switch_default;
    case_17: /* CIL Label */ 
    {
#line 488
    child_exit();
    }
#line 488
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 489
    hard_reconfig();
    }
#line 489
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 490
    hard_reconfig();
    }
#line 490
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 491
    terminate_program();
    }
#line 491
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 492
    dump_internal_state();
    }
#line 492
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 493
    user_requested_check();
    }
#line 493
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 494
    quit_program();
    }
#line 494
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 496
    tmp___2 = sig_name((int )sig);
#line 496
    msg(3, func, "unexpected signal: %s in signal pipe", tmp___2);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 500
  return;
}
}
#line 123 "/usr/include/netdb.h"
extern void endhostent(void) ;
#line 204
extern void endnetent(void) ;
#line 71 "/usr/include/grp.h"
extern void endgrent(void) ;
#line 78 "/usr/include/pwd.h"
extern void endpwent(void) ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.h"
int line_count  ;
#line 6 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/includedir.h"
void handle_includedir(char const   *service_name , struct configuration *confp ) ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static struct attribute  const  service_attributes[42]  = 
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
  {      {"socket_type", 2U, 1, (status_e (*)())(& socket_type_parser)}, 
        {"protocol", 3U, 1, (status_e (*)())(& protocol_parser)}, 
        {"wait", 1U, 1, (status_e (*)())(& wait_parser)}, 
        {"user", 4U, 1, (status_e (*)())(& user_parser)}, 
        {"group", 5U, 1, (status_e (*)())(& group_parser)}, 
        {"server", 6U, 1, (status_e (*)())(& server_parser)}, 
        {"server_args", 7U, -1, (status_e (*)())(& server_args_parser)}, 
        {"instances", 8U, 1, (status_e (*)())(& instances_parser)}, 
        {"log_on_success", 17U, -2, (status_e (*)())(& log_on_success_parser)}, 
        {"log_on_failure", 16U, -2, (status_e (*)())(& log_on_failure_parser)}, 
        {"log_type", 13U, -1, (status_e (*)())(& log_type_parser)}, 
        {"only_from", 10U, -2, (status_e (*)())(& only_from_parser)}, 
        {"no_access", 14U, -2, (status_e (*)())(& no_access_parser)}, 
        {"access_times", 11U, -1, (status_e (*)())(& access_times_parser)}, 
        {"type", 15U, -1, (status_e (*)())(& type_parser)}, 
        {"rpc_version", 12U, 1, (status_e (*)())(& rpc_version_parser)}, 
        {"rpc_number", 22U, 1, (status_e (*)())(& rpc_number_parser)}, 
        {"id", 9U, 1, (status_e (*)())(& id_parser)}, 
        {"env", 18U, -2, (status_e (*)())(& env_parser)}, 
        {"port", 19U, 1, (status_e (*)())(& port_parser)}, 
        {"passenv", 20U, -2, (status_e (*)())(& passenv_parser)}, 
        {"flags", 21U, -1, (status_e (*)())(& flags_parser)}, 
        {"nice", 23U, 1, (status_e (*)())(& nice_parser)}, 
        {"redirect", 24U, 2, (status_e (*)())(& redir_parser)}, 
        {"banner", 26U, 1, (status_e (*)())(& banner_parser)}, 
        {"bind", 25U, 1, (status_e (*)())(& bind_parser)}, 
        {"interface", 25U, 1, (status_e (*)())(& bind_parser)}, 
        {"per_source", 27U, 1, (status_e (*)())(& per_source_parser)}, 
        {"groups", 28U, 1, (status_e (*)())(& groups_parser)}, 
        {"banner_success", 29U, 1, (status_e (*)())(& banner_success_parser)}, 
        {"banner_fail", 30U, 1, (status_e (*)())(& banner_fail_parser)}, 
        {"cps", 32U, 2, (status_e (*)())(& cps_parser)}, 
        {"disable", 33U, 1, (status_e (*)())(& svcdisable_parser)}, 
        {"rlimit_as", 34U, 1, (status_e (*)())(& rlim_as_parser)}, 
        {"rlimit_cpu", 35U, 1, (status_e (*)())(& rlim_cpu_parser)}, 
        {"rlimit_data", 36U, 1, (status_e (*)())(& rlim_data_parser)}, 
        {"rlimit_rss", 37U, 1, (status_e (*)())(& rlim_rss_parser)}, 
        {"rlimit_stack", 38U, 1, (status_e (*)())(& rlim_stack_parser)}, 
        {"v6only", 39U, 1, (status_e (*)())(& v6only_parser)}, 
        {"deny_time", 40U, 1, (status_e (*)())(& deny_time_parser)}, 
        {"umask", 41U, 1, (status_e (*)())(& umask_parser)}, 
        {(char const   *)((void *)0), 0U, -1, (status_e (*)())((void *)0)}};
#line 113 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static struct attribute  const  default_attributes[20]  = 
#line 113
  {      {"log_type", 13U, -2, (status_e (*)())(& log_type_parser)}, 
        {"log_on_success", 17U, -2, (status_e (*)())(& log_on_success_parser)}, 
        {"log_on_failure", 16U, -2, (status_e (*)())(& log_on_failure_parser)}, 
        {"disabled", 43U, -2, (status_e (*)())(& disabled_parser)}, 
        {"no_access", 14U, -2, (status_e (*)())(& no_access_parser)}, 
        {"only_from", 10U, -2, (status_e (*)())(& only_from_parser)}, 
        {"instances", 8U, 1, (status_e (*)())(& instances_parser)}, 
        {"passenv", 20U, -2, (status_e (*)())(& passenv_parser)}, 
        {"banner", 26U, 1, (status_e (*)())(& banner_parser)}, 
        {"bind", 25U, 1, (status_e (*)())(& bind_parser)}, 
        {"interface", 25U, 1, (status_e (*)())(& bind_parser)}, 
        {"per_source", 27U, 1, (status_e (*)())(& per_source_parser)}, 
        {"groups", 28U, 1, (status_e (*)())(& groups_parser)}, 
        {"banner_success", 29U, 1, (status_e (*)())(& banner_success_parser)}, 
        {"banner_fail", 30U, 1, (status_e (*)())(& banner_fail_parser)}, 
        {"cps", 32U, 2, (status_e (*)())(& cps_parser)}, 
        {"enabled", 42U, -2, (status_e (*)())(& enabled_parser)}, 
        {"v6only", 39U, 1, (status_e (*)())(& v6only_parser)}, 
        {"umask", 41U, 1, (status_e (*)())(& umask_parser)}, 
        {(char const   *)((void *)0), 0U, 0, (status_e (*)())((void *)0)}};
#line 148 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
char const   *current_file  =    (char const   *)((void *)0);
#line 150
static void get_service_entry(int fd , pset_h sconfs , char const   *name___0 , struct service_config *defaults ) ;
#line 152
static void fill_attribute(unsigned int attr_id , struct service_config *scp , struct service_config *def ) ;
#line 154
static entry_e find_next_entry(int fd , char **snamep ) ;
#line 155
static status_e parse_entry(entry_e entry_type , int fd , struct service_config *scp ) ;
#line 160 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
char const   *attr_name_lookup(unsigned int id ) 
{ 
  struct attribute  const  *ap ;

  {
#line 164
  ap = & service_attributes[0];
  {
#line 164
  while (1) {
    while_continue: /* CIL Label */ ;
#line 164
    if (! ap->a_name) {
#line 164
      goto while_break;
    }
#line 165
    if (id == (unsigned int )ap->a_id) {
#line 166
      return ((char const   *)ap->a_name);
    }
#line 164
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 167
  return ((char const   *)((char *)0));
}
}
#line 171 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
void parse_end(void) 
{ 


  {
  {
#line 173
  endprotoent();
#line 174
  endpwent();
#line 175
  endgrent();
#line 176
  endnetent();
#line 177
  endhostent();
  }
#line 178
  return;
}
}
#line 202 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
void parse_conf_file(int fd , struct configuration *confp , char const   *filename ) 
{ 
  pset_h sconfs ;
  struct service_config *default_config ;
  boolean_e found_defaults ;
  struct service_config default_default_config ;
  char const   *func ;
  int incfd ;
  entry_e entry_type ;
  char *service_name ;
  int saved_line_count ;
  int saved_line_count___0 ;
  status_e tmp ;

  {
  {
#line 204
  sconfs = confp->cnf_service_confs;
#line 205
  default_config = confp->cnf_defaults;
#line 206
  found_defaults = (boolean_e )0;
#line 208
  func = "parse_conf_file";
#line 211
  line_count = 0;
#line 212
  current_file = filename;
#line 213
  memset((void *)((char *)(& default_default_config)), 0, sizeof(default_default_config));
  }
  {
#line 215
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 218
    service_name = (char *)((void *)0);
#line 224
    entry_type = find_next_entry(fd, & service_name);
    }
    {
#line 227
    if ((unsigned int )entry_type == 4U) {
#line 227
      goto case_4;
    }
#line 250
    if ((unsigned int )entry_type == 5U) {
#line 250
      goto case_5;
    }
#line 258
    if ((unsigned int )entry_type == 2U) {
#line 258
      goto case_2;
    }
#line 261
    if ((unsigned int )entry_type == 3U) {
#line 261
      goto case_3;
    }
#line 280
    if ((unsigned int )entry_type == 1U) {
#line 280
      goto case_1;
    }
#line 284
    if ((unsigned int )entry_type == 0U) {
#line 284
      goto case_0;
    }
#line 225
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 229
    saved_line_count = line_count;
#line 230
    incfd = open((char const   *)service_name, 0);
    }
#line 231
    if (incfd < 0) {
      {
#line 232
      parsemsg(3, func, "Unable to open included configuration file: %s", service_name);
      }
#line 235
      goto switch_break;
    }
    {
#line 237
    parsemsg(7, func, "Reading included configuration file: %s", service_name);
#line 239
    parse_conf_file(incfd, confp, (char const   *)service_name);
#line 244
    Sclose(incfd);
#line 246
    current_file = filename;
#line 247
    line_count = saved_line_count;
    }
#line 249
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 252
    saved_line_count___0 = line_count;
#line 253
    handle_includedir((char const   *)service_name, confp);
#line 254
    current_file = filename;
#line 255
    line_count = saved_line_count___0;
    }
#line 257
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 259
    get_service_entry(fd, sconfs, (char const   *)service_name, default_config);
    }
#line 260
    goto switch_break;
    case_3: /* CIL Label */ 
#line 262
    if ((unsigned int )found_defaults == 1U) {
      {
#line 264
      parsemsg(3, func, "only 1 defaults entry is allowed. This entry will be ignored");
#line 266
      skip_entry(fd);
      }
    } else {
      {
#line 268
      tmp = parse_entry((entry_e )3, fd, default_config);
      }
#line 268
      if ((unsigned int )tmp == 1U) {
#line 270
        found_defaults = (boolean_e )1;
#line 274
        if (default_config->sc_specified_attributes & (1UL << 24)) {
#line 274
          if ((unsigned long )default_config->sc_bind_addr == (unsigned long )((void *)0)) {
#line 276
            default_config->sc_specified_attributes &= ~ (1UL << 24);
          }
        }
      }
    }
#line 278
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 281
    skip_entry(fd);
    }
#line 282
    goto switch_break;
    case_0: /* CIL Label */ 
#line 285
    return;
    switch_break: /* CIL Label */ ;
    }
#line 287
    if (service_name) {
      {
#line 288
      free((void *)service_name);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 301 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static entry_e find_next_entry(int fd , char **snamep ) 
{ 
  char *p ;
  str_h strp___0 ;
  char *sname ;
  entry_e entry_type ;
  char *line ;
  char *tmp ;
  char const   *func ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 305
  sname = (char *)((void *)0);
#line 306
  entry_type = (entry_e )0;
#line 307
  tmp = next_line(fd);
#line 307
  line = tmp;
#line 308
  func = "find_next_entry";
  }
#line 310
  if ((unsigned long )line == (unsigned long )((char *)0)) {
#line 311
    return ((entry_e )0);
  }
  {
#line 313
  strp___0 = str_parse(line, " \t", 1, (int *)0);
  }
#line 314
  if ((unsigned long )strp___0 == (unsigned long )((void *)0)) {
    {
#line 316
    parsemsg(2, func, "str_parse failed");
    }
#line 317
    return ((entry_e )1);
  }
  {
#line 320
  p = str_component(strp___0);
  }
#line 320
  if ((unsigned long )p == (unsigned long )((char *)0)) {
    {
#line 326
    parsemsg(4, func, "empty line");
#line 327
    str_endparse(strp___0);
    }
#line 328
    return ((entry_e )1);
  }
  {
#line 334
  tmp___3 = strcasecmp((char const   *)p, "service");
  }
#line 334
  if (tmp___3 == 0) {
#line 334
    goto _L;
  } else {
    {
#line 334
    tmp___4 = strcasecmp((char const   *)p, "include");
    }
#line 334
    if (tmp___4 == 0) {
#line 334
      goto _L;
    } else {
      {
#line 334
      tmp___5 = strcasecmp((char const   *)p, "includedir");
      }
#line 334
      if (tmp___5 == 0) {
        _L: /* CIL Label */ 
        {
#line 336
        tmp___1 = strcasecmp((char const   *)p, "include");
        }
#line 336
        if (tmp___1 == 0) {
#line 337
          entry_type = (entry_e )4;
        } else {
          {
#line 338
          tmp___0 = strcasecmp((char const   *)p, "includedir");
          }
#line 338
          if (tmp___0 == 0) {
#line 339
            entry_type = (entry_e )5;
          }
        }
        {
#line 344
        p = str_component(strp___0);
        }
#line 344
        if ((unsigned long )p == (unsigned long )((char *)0)) {
          {
#line 346
          parsemsg(3, func, "service name missing");
#line 347
          str_endparse(strp___0);
          }
#line 348
          return ((entry_e )1);
        }
        {
#line 351
        sname = new_string((char const   *)p);
        }
#line 352
        if ((unsigned long )sname == (unsigned long )((char *)0)) {
          {
#line 354
          out_of_memory(func);
#line 355
          str_endparse(strp___0);
          }
#line 356
          return ((entry_e )1);
        }
        {
#line 358
        str_endparse(strp___0);
        }
#line 360
        if ((unsigned int )entry_type == 4U) {
#line 363
          *snamep = sname;
#line 364
          return (entry_type);
        } else
#line 360
        if ((unsigned int )entry_type == 5U) {
#line 363
          *snamep = sname;
#line 364
          return (entry_type);
        } else {
#line 367
          entry_type = (entry_e )2;
        }
      } else {
        {
#line 369
        tmp___2 = strcasecmp((char const   *)p, "defaults");
        }
#line 369
        if (tmp___2 == 0) {
          {
#line 371
          str_endparse(strp___0);
#line 372
          entry_type = (entry_e )3;
          }
        } else {
          {
#line 376
          parsemsg(3, func, "missing service keyword");
#line 377
          str_endparse(strp___0);
          }
#line 378
          return ((entry_e )1);
        }
      }
    }
  }
  {
#line 384
  line = next_line(fd);
  }
#line 385
  if ((unsigned long )line == (unsigned long )((void *)0)) {
#line 385
    goto _L___0;
  } else {
    {
#line 385
    tmp___6 = line_has_only_1_char((char const   *)line, (char )'{');
    }
#line 385
    if (! tmp___6) {
      _L___0: /* CIL Label */ 
      {
#line 387
      parsemsg(3, func, "Service %s: missing \'%c\'", sname, '{');
      }
#line 389
      if ((unsigned int )entry_type == 2U) {
        {
#line 390
        free((void *)sname);
        }
      }
#line 391
      return ((entry_e )1);
    }
  }
#line 393
  *snamep = sname;
#line 394
  return (entry_type);
}
}
#line 405 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static void get_service_entry(int fd , pset_h sconfs , char const   *name___0 , struct service_config *defaults ) 
{ 
  struct service_config *scp ;
  char const   *func ;
  status_e tmp ;
  char *tmp___0 ;
  __pset_pointer tmp___1 ;

  {
  {
#line 411
  func = "get_service_entry";
#line 413
  scp = sc_alloc(name___0);
  }
#line 414
  if ((unsigned long )scp == (unsigned long )((void *)0)) {
    {
#line 416
    skip_entry(fd);
    }
#line 417
    return;
  }
#line 421
  if (defaults->sc_specified_attributes & (1UL << 16)) {
#line 421
    if (! (scp->sc_attributes_present & (1UL << 16))) {
      {
#line 423
      fill_attribute(17U, scp, defaults);
      }
    }
  }
#line 424
  if (defaults->sc_specified_attributes & (1UL << 15)) {
#line 424
    if (! (scp->sc_attributes_present & (1UL << 15))) {
      {
#line 426
      fill_attribute(16U, scp, defaults);
      }
    }
  }
#line 427
  if (defaults->sc_specified_attributes & (1UL << 9)) {
#line 427
    if (! (scp->sc_attributes_present & (1UL << 9))) {
      {
#line 429
      fill_attribute(10U, scp, defaults);
      }
    }
  }
#line 430
  if (defaults->sc_specified_attributes & (1UL << 13)) {
#line 430
    if (! (scp->sc_attributes_present & (1UL << 13))) {
      {
#line 432
      fill_attribute(14U, scp, defaults);
      }
    }
  }
#line 433
  if (defaults->sc_specified_attributes & (1UL << 19)) {
#line 433
    if (! (scp->sc_attributes_present & (1UL << 19))) {
      {
#line 435
      fill_attribute(20U, scp, defaults);
      }
    }
  }
#line 436
  if (defaults->sc_specified_attributes & (1UL << 10)) {
#line 436
    if (! (scp->sc_attributes_present & (1UL << 10))) {
      {
#line 438
      fill_attribute(11U, scp, defaults);
      }
    }
  }
#line 439
  if (defaults->sc_specified_attributes & (1UL << 25)) {
#line 439
    if (! (scp->sc_attributes_present & (1UL << 25))) {
      {
#line 441
      fill_attribute(26U, scp, defaults);
      }
    }
  }
#line 442
  if (defaults->sc_specified_attributes & (1UL << 28)) {
#line 442
    if (! (scp->sc_attributes_present & (1UL << 28))) {
      {
#line 444
      fill_attribute(29U, scp, defaults);
      }
    }
  }
#line 445
  if (defaults->sc_specified_attributes & (1UL << 29)) {
#line 445
    if (! (scp->sc_attributes_present & (1UL << 29))) {
      {
#line 447
      fill_attribute(30U, scp, defaults);
      }
    }
  }
  {
#line 449
  tmp = parse_entry((entry_e )2, fd, scp);
  }
#line 449
  if ((unsigned int )tmp == 0U) {
    {
#line 451
    sc_free(scp);
#line 452
    skip_entry(fd);
    }
#line 453
    return;
  }
#line 459
  if (! (scp->sc_specified_attributes & (1UL << 8))) {
    {
#line 460
    tmp___0 = new_string((char const   *)scp->sc_name);
#line 460
    scp->sc_id = tmp___0;
    }
#line 460
    if (tmp___0) {
#line 461
      scp->sc_attributes_present |= 1UL << 8;
    } else {
      {
#line 464
      out_of_memory(func);
#line 465
      sc_free(scp);
      }
#line 466
      return;
    }
  }
  {
#line 470
  tmp___1 = pset_add(sconfs, (__pset_pointer const   )scp);
  }
#line 470
  if (! tmp___1) {
    {
#line 472
    out_of_memory(func);
#line 473
    sc_free(scp);
    }
#line 474
    return;
  }
#line 477
  return;
}
}
#line 488 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static void fill_attribute(unsigned int attr_id , struct service_config *scp , struct service_config *def ) 
{ 
  status_e tmp ;
  status_e tmp___0 ;
  status_e tmp___1 ;
  status_e tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;

  {
  {
#line 494
  if (attr_id == 17U) {
#line 494
    goto case_17;
  }
#line 499
  if (attr_id == 16U) {
#line 499
    goto case_16;
  }
#line 504
  if (attr_id == 10U) {
#line 504
    goto case_10;
  }
#line 509
  if (attr_id == 14U) {
#line 509
    goto case_14;
  }
#line 514
  if (attr_id == 20U) {
#line 514
    goto case_20;
  }
#line 520
  if (attr_id == 11U) {
#line 520
    goto case_11;
  }
#line 526
  if (attr_id == 26U) {
#line 526
    goto case_26;
  }
#line 531
  if (attr_id == 29U) {
#line 531
    goto case_29;
  }
#line 537
  if (attr_id == 30U) {
#line 537
    goto case_30;
  }
#line 492
  goto switch_break;
  case_17: /* CIL Label */ 
#line 495
  scp->sc_log_on_success = def->sc_log_on_success;
#line 496
  scp->sc_attributes_present |= 1UL << 16;
#line 497
  goto switch_break;
  case_16: /* CIL Label */ 
#line 500
  scp->sc_log_on_failure = def->sc_log_on_failure;
#line 501
  scp->sc_attributes_present |= 1UL << 15;
#line 502
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 505
  tmp = addrlist_copy((pset_h const   )def->sc_only_from, & scp->sc_only_from);
  }
#line 505
  if ((unsigned int )tmp == 1U) {
#line 506
    scp->sc_attributes_present |= 1UL << 9;
  }
#line 507
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 510
  tmp___0 = addrlist_copy((pset_h const   )def->sc_no_access, & scp->sc_no_access);
  }
#line 510
  if ((unsigned int )tmp___0 == 1U) {
#line 511
    scp->sc_attributes_present |= 1UL << 13;
  }
#line 512
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 515
  tmp___1 = copy_pset((pset_h const   )def->sc_pass_env_vars, & scp->sc_pass_env_vars,
                      0U);
  }
#line 515
  if ((unsigned int )tmp___1 == 1U) {
#line 517
    scp->sc_attributes_present |= 1UL << 19;
  }
#line 518
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 521
  tmp___2 = copy_pset((pset_h const   )def->sc_access_times, & scp->sc_access_times,
                      0U);
  }
#line 521
  if ((unsigned int )tmp___2 == 1U) {
#line 523
    scp->sc_attributes_present |= 1UL << 10;
  }
#line 524
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 527
  tmp___3 = new_string((char const   *)def->sc_banner);
#line 527
  scp->sc_banner = tmp___3;
  }
#line 527
  if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 528
    scp->sc_attributes_present |= 1UL << 25;
  }
#line 529
  goto switch_break;
  case_29: /* CIL Label */ 
  {
#line 532
  tmp___4 = new_string((char const   *)def->sc_banner_success);
#line 532
  scp->sc_banner_success = tmp___4;
  }
#line 532
  if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 534
    scp->sc_attributes_present |= 1UL << 28;
  }
#line 535
  goto switch_break;
  case_30: /* CIL Label */ 
  {
#line 538
  tmp___5 = new_string((char const   *)def->sc_banner_fail);
#line 538
  scp->sc_banner_fail = tmp___5;
  }
#line 538
  if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 539
    scp->sc_attributes_present |= 1UL << 29;
  }
#line 540
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 542
  return;
}
}
#line 548 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static struct attribute  const  *attr_lookup(struct attribute  const  *attr_array ,
                                             char const   *attr_name ) 
{ 
  struct attribute  const  *ap ;
  char const   *func ;
  int tmp ;

  {
#line 552
  func = "attr_lookup";
#line 554
  ap = attr_array + 0;
  {
#line 554
  while (1) {
    while_continue: /* CIL Label */ ;
#line 554
    if (! ap->a_name) {
#line 554
      goto while_break;
    }
    {
#line 555
    tmp = strcasecmp(attr_name, (char const   *)ap->a_name);
    }
#line 555
    if (tmp == 0) {
#line 556
      return (ap);
    }
#line 554
    ap ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 557
  if ((unsigned long )attr_array == (unsigned long )(service_attributes)) {
    {
#line 558
    parsemsg(4, func, "bad service attribute: %s", attr_name);
    }
  } else {
    {
#line 560
    parsemsg(4, func, "attribute: %s should not be in default section", attr_name);
    }
  }
#line 562
  return ((struct attribute  const  *)((void *)0));
}
}
#line 579 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static status_e identify_attribute(entry_e entry_type , struct service_config *scp ,
                                   char const   *attr_name , enum assign_op op , pset_h attr_values___0 ) 
{ 
  struct attribute  const  *ap ;
  char const   *func ;
  char const   *tmp ;
  status_e tmp___0 ;

  {
#line 586
  func = "identify_attribute";
#line 588
  if ((unsigned int )entry_type == 2U) {
    {
#line 589
    ap = attr_lookup(service_attributes, attr_name);
    }
  } else {
    {
#line 591
    ap = attr_lookup(default_attributes, attr_name);
    }
  }
#line 593
  if ((unsigned long )ap == (unsigned long )((void *)0)) {
#line 594
    return ((status_e )1);
  }
#line 596
  if (! (ap->a_nvalues == -2)) {
#line 598
    if (scp->sc_specified_attributes & (1UL << (ap->a_id - 1U))) {
      {
#line 600
      parsemsg(4, func, "Service %s: attribute already set: %s", scp->sc_name, attr_name);
      }
#line 602
      return ((status_e )1);
    }
#line 605
    if ((unsigned int )op != 0U) {
#line 607
      if ((unsigned int )op == 1U) {
#line 607
        tmp = "+=";
      } else {
#line 607
        tmp = "-=";
      }
      {
#line 607
      parsemsg(4, func, "Service %s: operator \'%s\' cannot be used for attribute \'%s\'",
               scp->sc_name, tmp, attr_name);
      }
#line 610
      return ((status_e )1);
    }
  } else
#line 618
  if ((unsigned int )entry_type == 3U) {
#line 618
    if ((unsigned int )op == 0U) {
#line 619
      op = (enum assign_op )1;
    }
  }
#line 622
  if (ap->a_nvalues > 0) {
#line 622
    if ((unsigned int )ap->a_nvalues != attr_values___0->count) {
      {
#line 625
      parsemsg(4, func, "attribute %s expects %d values and %d values were specified",
               attr_name, ap->a_nvalues, attr_values___0->count);
      }
#line 628
      return ((status_e )1);
    }
  }
  {
#line 631
  tmp___0 = (*(ap->a_parser))(attr_values___0, scp, (unsigned int )op);
  }
#line 631
  if ((unsigned int )tmp___0 == 1U) {
#line 633
    scp->sc_specified_attributes |= 1UL << (ap->a_id - 1U);
#line 633
    scp->sc_attributes_present |= 1UL << (ap->a_id - 1U);
  } else
#line 635
  if ((unsigned int )entry_type == 2U) {
    {
#line 637
    parsemsg(3, func, "Error parsing attribute %s - DISABLING SERVICE", attr_name);
#line 639
    scp->sc_type |= 1UL << 4;
    }
  } else
#line 646
  if (! debug.on) {
#line 647
    return ((status_e )0);
  }
#line 649
  return ((status_e )1);
}
}
#line 661 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static pset_h attr_values  =    (pset_h )((void *)0);
#line 657 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/parse.c"
static status_e parse_entry(entry_e entry_type , int fd , struct service_config *scp ) 
{ 
  char *line ;
  char *attr_name ;
  enum assign_op op ;
  char const   *func ;
  int tmp ;
  status_e tmp___0 ;
  status_e tmp___1 ;

  {
#line 665
  func = "get_attributes";
#line 667
  if (! attr_values) {
    {
#line 667
    attr_values = pset_create(10U, 10U);
    }
#line 667
    if ((unsigned long )attr_values == (unsigned long )((void *)0)) {
      {
#line 669
      out_of_memory(func);
      }
#line 670
      return ((status_e )0);
    }
  }
  {
#line 673
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 675
    line = next_line(fd);
    }
#line 676
    if ((unsigned long )line == (unsigned long )((char *)0)) {
      {
#line 678
      parsemsg(3, func, "incomplete entry");
      }
#line 679
      return ((status_e )0);
    }
    {
#line 682
    tmp = line_has_only_1_char((char const   *)line, (char )'}');
    }
#line 682
    if (tmp) {
#line 683
      return ((status_e )1);
    }
    {
#line 685
    tmp___0 = parse_line(line, & attr_name, & op, attr_values);
    }
#line 685
    if ((unsigned int )tmp___0 == 0U) {
#line 687
      attr_values->count = 0U;
#line 688
      return ((status_e )0);
    }
    {
#line 691
    tmp___1 = identify_attribute(entry_type, scp, (char const   *)attr_name, op, attr_values);
    }
#line 691
    if ((unsigned int )tmp___1 == 0U) {
      {
#line 698
      msg(3, func, "A fatal error was encountered while parsing the default section. xinetd will exit.");
#line 701
      Sclose(fd);
#line 702
      terminate_program();
      }
    }
#line 704
    attr_values->count = 0U;
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 34 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) in_addr_t ( __attribute__((__leaf__)) inet_addr)(char const   *__cp ) ;
#line 34 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
static void start_server(struct intercept_s *ip ) ;
#line 35
static void terminate_server(struct intercept_s *ip ) ;
#line 46 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
static struct lookup_table intercept_lookup_table[3]  = {      {(struct intercept_s *(*)())(& di_init), 2}, 
        {(struct intercept_s *(*)())(& si_init), 1}, 
        {(struct intercept_s *(*)())((void *)0), 0}};
#line 57 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
static struct intercept_s *intp  =    (struct intercept_s *)((void *)0);
#line 61 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
static initfunc find_initializer(int type ) 
{ 
  struct lookup_table *ltp ;

  {
#line 65
  ltp = intercept_lookup_table;
  {
#line 65
  while (1) {
    while_continue: /* CIL Label */ ;
#line 65
    if (! ltp->initializer) {
#line 65
      goto while_break;
    }
#line 66
    if (ltp->socket_type == type) {
#line 67
      return (ltp->initializer);
    }
#line 65
    ltp ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 68
  msg(3, "find_initializer", "No initializer for type %d", type);
#line 69
  _exit(0);
  }
#line 71
  return ((struct intercept_s *(*)())0);
}
}
#line 79 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
void intercept(struct server *serp ) 
{ 
  struct service *sp ;
  struct intercept_s *(*initializer)() ;

  {
  {
#line 81
  sp = serp->svr_sp;
#line 92
  initializer = find_initializer((sp->svc_conf)->sc_socket_type);
#line 93
  intp = (*initializer)(serp);
#line 94
  start_server(intp);
#line 95
  (*((intp->int_ops)->mux))();
#line 96
  terminate_server(intp);
  }
#line 101
  return;
}
}
#line 107 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
static int get_server_socket(struct intercept_s *ip ) 
{ 
  struct service *sp ;
  union xsockaddr *sinp ;
  int sd ;
  socklen_t size ;
  char const   *func ;
  struct addrinfo hint ;
  struct addrinfo *res ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  char const   *tmp___4 ;

  {
#line 109
  sp = ip->int_common.ic_server.svr_sp;
#line 110
  sinp = & ip->int_common.ic_local_addr;
#line 113
  func = "get_server_socket";
#line 115
  if ((sp->svc_conf)->sc_xflags & (1UL << 10)) {
    {
#line 116
    res = (struct addrinfo *)((void *)0);
#line 117
    memset((void *)(& hint), 0, sizeof(struct addrinfo ));
#line 118
    hint.ai_family = 10;
#line 119
    hint.ai_flags = 4;
#line 120
    sinp->sa_in6.sin6_family = (sa_family_t )10;
#line 121
    sinp->sa_in6.sin6_port = (in_port_t )0;
#line 122
    tmp = getaddrinfo((char const   */* __restrict  */)"::1", (char const   */* __restrict  */)((void *)0),
                      (struct addrinfo  const  */* __restrict  */)(& hint), (struct addrinfo **/* __restrict  */)(& res));
    }
#line 122
    if (tmp != 0) {
      {
#line 123
      int_fail((struct intercept_s  const  *)ip, "can\'t find ::1");
      }
    }
#line 124
    if ((unsigned long )res == (unsigned long )((void *)0)) {
      {
#line 125
      int_fail((struct intercept_s  const  *)ip, "no results for ::1");
      }
    }
#line 126
    if (res->ai_family != 10) {
      {
#line 127
      int_fail((struct intercept_s  const  *)ip, "non IPv6 result for ::1");
      }
    }
    {
#line 128
    memcpy((void */* __restrict  */)sinp, (void const   */* __restrict  */)res->ai_addr,
           sizeof(struct sockaddr_in6 ));
#line 129
    freeaddrinfo(res);
#line 130
    size = (socklen_t )sizeof(struct sockaddr_in6 );
    }
  } else
#line 131
  if ((sp->svc_conf)->sc_xflags & (1UL << 9)) {
    {
#line 132
    sinp->sa_in.sin_family = (sa_family_t )2;
#line 133
    sinp->sa_in.sin_port = (in_port_t )0;
#line 134
    sinp->sa_in.sin_addr.s_addr = inet_addr("127.0.0.1");
#line 135
    size = (socklen_t )sizeof(struct sockaddr_in );
    }
  } else {
    {
#line 137
    int_fail((struct intercept_s  const  *)ip, "unknown socket family");
    }
  }
  {
#line 139
  sd = socket((int )sinp->sa.sa_family, (sp->svc_conf)->sc_socket_type, (sp->svc_conf)->sc_protocol.value);
  }
#line 139
  if (sd == -1) {
    {
#line 140
    int_fail((struct intercept_s  const  *)ip, "socket creation");
    }
  }
  {
#line 142
  tmp___0 = bind(sd, (struct sockaddr  const  *)((struct sockaddr *)sinp), size);
  }
#line 142
  if (tmp___0 == -1) {
    {
#line 143
    int_fail((struct intercept_s  const  *)ip, "bind");
    }
  }
  {
#line 145
  size = (socklen_t )sizeof(*sinp);
#line 146
  tmp___1 = getsockname(sd, (struct sockaddr */* __restrict  */)((struct sockaddr *)sinp),
                        (socklen_t */* __restrict  */)(& size));
  }
#line 146
  if (tmp___1 == -1) {
    {
#line 147
    int_fail((struct intercept_s  const  *)ip, "getsockname");
    }
  }
#line 149
  if (debug.on) {
    {
#line 150
    tmp___2 = xaddrport((union xsockaddr  const  *)sinp);
#line 150
    tmp___3 = ntohs(tmp___2);
#line 150
    tmp___4 = xaddrname((union xsockaddr  const  *)sinp);
#line 150
    msg(7, func, "address = %s, port = %d", tmp___4, (int )tmp___3);
    }
  }
#line 153
  if (ip->int_socket_type == 1) {
    {
#line 154
    listen(sd, 64);
    }
  }
#line 156
  return (sd);
}
}
#line 160 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
static void start_server(struct intercept_s *ip ) 
{ 
  struct server *serp ;
  struct service *sp ;
  int server_socket ;
  pid_t pid ;

  {
  {
#line 162
  serp = & ip->int_common.ic_server;
#line 163
  sp = serp->svr_sp;
#line 167
  server_socket = get_server_socket(ip);
#line 169
  pid = fork();
  }
  {
#line 173
  if (pid == -1) {
#line 173
    goto case_neg_1;
  }
#line 177
  if (pid == 0) {
#line 177
    goto case_0;
  }
#line 183
  goto switch_default;
  case_neg_1: /* CIL Label */ 
  {
#line 174
  int_fail((struct intercept_s  const  *)ip, "fork");
  }
  case_0: /* CIL Label */ 
  {
#line 178
  (serp->svr_conn)->co_descriptor = server_socket;
#line 179
  (sp->svc_conf)->sc_type &= ~ (1UL << 1);
#line 180
  child_process(serp);
  }
  switch_default: /* CIL Label */ 
  {
#line 184
  serp->svr_pid = pid;
#line 185
  Sclose(server_socket);
  }
  switch_break: /* CIL Label */ ;
  }
#line 187
  return;
}
}
#line 196 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
static status_e wait_child(struct intercept_s *ip ) 
{ 
  char const   *func ;
  int status ;
  status_e ret ;
  pid_t pid ;
  int *tmp ;
  union __anonunion_80___1 __constr_expr_15 ;
  unsigned int u ;
  struct server *p ;
  struct service *sp ;
  struct service_config *scp ;

  {
#line 198
  func = "wait_child";
#line 200
  ret = (status_e )0;
  {
#line 203
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 203
    pid = waitpid(-1, & status, 1);
    }
#line 203
    if (! (pid != 0)) {
#line 203
      goto while_break;
    }
#line 206
    if (pid == -1) {
      {
#line 208
      tmp = __errno_location();
      }
#line 208
      if (*tmp != 4) {
        {
#line 210
        msg(3, func, "wait: %m");
        }
#line 211
        return (ret);
      }
    } else
#line 214
    if (pid == ip->int_common.ic_server.svr_pid) {
#line 216
      __constr_expr_15.__in = status;
#line 216
      if ((__constr_expr_15.__i & 255) == 127) {
#line 217
        ret = (status_e )0;
      }
#line 218
      ip->int_common.ic_server.svr_exit_status = status;
#line 219
      ret = (status_e )1;
    } else {
      {
#line 226
      msg(3, func, "wait returned pid of unknown process: %d", pid);
#line 232
      u = 0U;
      }
      {
#line 232
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 232
        if (! (u < (ps.rws.servers)->count)) {
#line 232
          goto while_break___0;
        }
#line 233
        p = (struct server *)*((ps.rws.servers)->ptrs + u);
#line 235
        if ((unsigned long )p != (unsigned long )((void *)0)) {
#line 235
          if (p->svr_pid == pid) {
#line 236
            sp = p->svr_sp;
#line 237
            scp = sp->svc_conf;
#line 239
            if (scp->sc_protocol.value == 6) {
              {
#line 240
              p->svr_exit_status = status;
#line 241
              si_exit();
              }
            } else
#line 242
            if (scp->sc_protocol.value == 17) {
              {
#line 243
              p->svr_exit_status = status;
#line 244
              di_exit();
              }
            } else {
              {
#line 246
              msg(3, func, "Don\'t know how to exit %d", pid);
              }
            }
#line 248
            goto while_break___0;
          }
        }
#line 232
        u ++;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 254
  return (ret);
}
}
#line 258 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
static void terminate_server(struct intercept_s *ip ) 
{ 
  pid_t pid ;
  status_e tmp ;

  {
#line 260
  pid = intp->int_common.ic_server.svr_pid;
#line 262
  if (pid > 0) {
    {
#line 263
    kill(pid, 9);
    }
  }
  {
#line 269
  tmp = wait_child(ip);
  }
#line 269
  if ((unsigned int )tmp == 1U) {
    {
#line 270
    (*((intp->int_ops)->exit))();
    }
  }
#line 271
  return;
}
}
#line 274 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/int.c"
void int_sighandler(int sig ) 
{ 
  char const   *func ;
  char *tmp ;
  status_e tmp___0 ;

  {
#line 276
  func = "int_sighandler";
#line 278
  if (debug.on) {
    {
#line 279
    tmp = sig_name(sig);
#line 279
    msg(7, func, "Received signal %s", tmp);
    }
  }
#line 281
  if (sig == 17) {
    {
#line 283
    tmp___0 = wait_child(intp);
    }
#line 283
    if ((unsigned int )tmp___0 == 1U) {
      {
#line 284
      (*((intp->int_ops)->exit))();
      }
    }
  } else
#line 286
  if (sig == 10) {
#line 287
    intp->int_common.ic_intercept = 0;
  } else
#line 288
  if (sig == 15) {
    {
#line 289
    terminate_server(intp);
    }
  }
#line 290
  return;
}
}
#line 765 "/usr/include/stdlib.h"
extern void ( __attribute__((__nonnull__(1,4))) qsort)(void *__base , size_t __nmemb ,
                                                       size_t __size , int (*__compar)(void const   * ,
                                                                                       void const   * ) ) ;
#line 27 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.c"
static pset_h xtimer_list  =    (pset_h )((void *)0);
#line 29 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.c"
static int xtimer_init(void) 
{ 


  {
#line 31
  if ((unsigned long )xtimer_list != (unsigned long )((void *)0)) {
#line 32
    return (0);
  }
  {
#line 34
  xtimer_list = pset_create(0U, 0U);
  }
#line 35
  if ((unsigned long )xtimer_list == (unsigned long )((void *)0)) {
#line 36
    return (-1);
  }
#line 38
  return (0);
}
}
#line 41 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.c"
static int xtimer_compfunc(void const   *_a , void const   *_b ) 
{ 
  xtime_h * const  *a ;
  xtime_h * const  *b ;

  {
#line 43
  a = (xtime_h * const  *)_a;
#line 44
  b = (xtime_h * const  *)_b;
#line 45
  return ((int )((*a)->when - (*b)->when));
}
}
#line 55 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.c"
int xtimer_add(void (*func)(void) , time_t secs ) 
{ 
  xtime_h *new_xtimer ;
  time_t tmptime ;
  unsigned int count ;
  int tmp ;
  void *tmp___0 ;
  __pset_pointer tmp___1 ;

  {
#line 57
  new_xtimer = (xtime_h *)((void *)0);
#line 61
  if ((unsigned long )xtimer_list == (unsigned long )((void *)0)) {
    {
#line 62
    tmp = xtimer_init();
    }
#line 62
    if (tmp < 0) {
#line 63
      return (-1);
    }
  }
  {
#line 66
  tmp___0 = malloc(sizeof(xtime_h ));
#line 66
  new_xtimer = (xtime_h *)tmp___0;
  }
#line 67
  if ((unsigned long )new_xtimer == (unsigned long )((void *)0)) {
#line 68
    return (-1);
  }
  {
#line 71
  tmptime = time((time_t *)((void *)0));
  }
#line 72
  if (tmptime == -1L) {
    {
#line 73
    free((void *)new_xtimer);
    }
#line 74
    return (-1);
  }
#line 77
  new_xtimer->timerfunc = func;
#line 78
  new_xtimer->when = tmptime + secs;
#line 80
  count = xtimer_list->count;
#line 80
  if (count == 0U) {
#line 81
    new_xtimer->xtid = 1;
  } else {
#line 83
    new_xtimer->xtid = ((xtime_h *)*(xtimer_list->ptrs + (count - 1U)))->xtid + 1;
  }
  {
#line 86
  tmp___1 = pset_add(xtimer_list, (__pset_pointer const   )new_xtimer);
  }
#line 86
  if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
    {
#line 87
    free((void *)new_xtimer);
    }
#line 88
    return (-1);
  }
  {
#line 91
  qsort((void *)((char *)(xtimer_list->ptrs + 0U)), (size_t )xtimer_list->count, sizeof(__pset_pointer ),
        & xtimer_compfunc);
  }
#line 93
  return (new_xtimer->xtid);
}
}
#line 101 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.c"
int xtimer_poll(void) 
{ 
  unsigned int i ;
  xtime_h *cur_timer ;
  time_t cur_time ;
  time_t tmp ;

  {
#line 105
  if ((unsigned long )xtimer_list == (unsigned long )((void *)0)) {
#line 106
    return (0);
  }
#line 108
  i = 0U;
  {
#line 108
  while (1) {
    while_continue: /* CIL Label */ ;
#line 108
    if (! (i < xtimer_list->count)) {
#line 108
      goto while_break;
    }
    {
#line 109
    cur_timer = (xtime_h *)*(xtimer_list->ptrs + i);
#line 110
    tmp = time((time_t *)((void *)0));
#line 110
    cur_time = tmp;
    }
#line 115
    if (cur_timer->when > cur_time) {
#line 116
      return (0);
    }
    {
#line 118
    (*(cur_timer->timerfunc))();
#line 119
    pset_delete(xtimer_list, (__pset_pointer const   )cur_timer);
#line 120
    free((void *)cur_timer);
#line 121
    i --;
#line 122
    cur_timer = (xtime_h *)((void *)0);
#line 108
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 125
  return (0);
}
}
#line 134 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.c"
int xtimer_remove(int xtid ) 
{ 
  unsigned int i ;
  int ret ;
  xtime_h *cur_timer ;

  {
#line 137
  ret = -1;
#line 139
  i = 0U;
  {
#line 139
  while (1) {
    while_continue: /* CIL Label */ ;
#line 139
    if (! (i < xtimer_list->count)) {
#line 139
      goto while_break;
    }
#line 140
    cur_timer = (xtime_h *)*(xtimer_list->ptrs + i);
#line 141
    if (cur_timer->xtid == xtid) {
      {
#line 142
      pset_delete(xtimer_list, (__pset_pointer const   )cur_timer);
#line 143
      free((void *)cur_timer);
#line 144
      cur_timer = (xtime_h *)((void *)0);
#line 145
      ret = 0;
      }
    }
#line 139
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 149
  return (ret);
}
}
#line 156 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/xtimer.c"
time_t xtimer_nexttime(void) 
{ 
  time_t ret ;
  time_t tmp ;

  {
#line 160
  if ((unsigned long )xtimer_list == (unsigned long )((void *)0)) {
#line 161
    return ((time_t )-1);
  }
#line 163
  if (xtimer_list->count == 0U) {
#line 164
    return ((time_t )-1);
  }
  {
#line 166
  tmp = time((time_t *)((void *)0));
#line 166
  ret = ((xtime_h *)*(xtimer_list->ptrs + 0U))->when - tmp;
  }
#line 167
  if (ret < 0L) {
#line 168
    ret = (time_t )0;
  }
#line 169
  return (ret);
}
}
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 33 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/includedir.c"
static int compfunc(void const   *_a , void const   *_b ) 
{ 
  char const   * const  *a ;
  char const   * const  *b ;
  int tmp ;

  {
#line 35
  a = (char const   * const  *)_a;
#line 36
  b = (char const   * const  *)_b;
#line 38
  if ((unsigned long )a == (unsigned long )((void *)0)) {
#line 39
    return (-1);
  } else
#line 38
  if ((unsigned long )*(a + 0) == (unsigned long )((void *)0)) {
#line 39
    return (-1);
  }
#line 40
  if ((unsigned long )b == (unsigned long )((void *)0)) {
#line 41
    return (1);
  } else
#line 40
  if ((unsigned long )*(b + 0) == (unsigned long )((void *)0)) {
#line 41
    return (1);
  }
  {
#line 42
  tmp = strcmp((char const   *)*(a + 0), (char const   *)*(b + 0));
  }
#line 42
  return (tmp);
}
}
#line 45 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/includedir.c"
void handle_includedir(char const   *service_name , struct configuration *confp ) 
{ 
  char *filename ;
  pset_h dir_list ;
  DIR *dirfp ;
  struct dirent *direntry ;
  char *storename ;
  struct stat sb ;
  int u ;
  int incfd ;
  int len_sn ;
  char const   *func ;
  size_t tmp ;
  void *tmp___0 ;
  int *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;

  {
#line 54
  func = "handle_includedir";
#line 56
  if ((unsigned long )service_name == (unsigned long )((void *)0)) {
#line 57
    return;
  }
  {
#line 59
  dir_list = pset_create(0U, 0U);
  }
#line 60
  if ((unsigned long )dir_list == (unsigned long )((void *)0)) {
#line 61
    return;
  }
  {
#line 63
  tmp = strlen(service_name);
#line 63
  len_sn = (int )tmp;
#line 64
  tmp___0 = malloc((size_t )((len_sn + 255) + 2));
#line 64
  filename = (char *)tmp___0;
  }
#line 65
  if (! filename) {
    {
#line 66
    parsemsg(3, func, "out of memory");
    }
#line 67
    return;
  }
  {
#line 69
  tmp___1 = __errno_location();
#line 69
  *tmp___1 = 0;
#line 70
  dirfp = opendir(service_name);
  }
#line 71
  if (! dirfp) {
    {
#line 72
    parsemsg(3, func, "Unable to read included directory: %s", service_name);
#line 73
    free((void *)filename);
    }
#line 74
    return;
  }
  {
#line 77
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 77
    direntry = readdir(dirfp);
    }
#line 77
    if (! ((unsigned long )direntry != (unsigned long )((struct dirent *)0))) {
#line 77
      goto while_break;
    }
    {
#line 78
    storename = new_string((char const   *)(direntry->d_name));
    }
#line 79
    if ((unsigned long )storename == (unsigned long )((void *)0)) {
      {
#line 80
      parsemsg(3, func, "out of memory");
#line 81
      free((void *)filename);
      }
#line 82
      return;
    }
    {
#line 84
    pset_add(dir_list, (__pset_pointer const   )storename);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 86
  closedir(dirfp);
#line 89
  qsort((void *)((char *)(dir_list->ptrs + 0U)), (size_t )dir_list->count, sizeof(__pset_pointer ),
        & compfunc);
#line 94
  u = 0;
  }
  {
#line 94
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 94
    if (! ((unsigned int )u < dir_list->count)) {
#line 94
      goto while_break___0;
    }
#line 95
    storename = (char *)*(dir_list->ptrs + (unsigned int )u);
#line 103
    if (! *(storename + 0)) {
      {
#line 106
      pset_delete(dir_list, (__pset_pointer const   )((__pset_pointer )storename));
#line 107
      free((void *)storename);
#line 108
      u --;
      }
#line 109
      goto __Cont;
    } else {
      {
#line 103
      tmp___2 = strchr((char const   *)storename, '.');
      }
#line 103
      if (tmp___2) {
        {
#line 106
        pset_delete(dir_list, (__pset_pointer const   )((__pset_pointer )storename));
#line 107
        free((void *)storename);
#line 108
        u --;
        }
#line 109
        goto __Cont;
      } else {
        {
#line 103
        tmp___3 = strlen((char const   *)storename);
        }
#line 103
        if ((int )*(storename + (tmp___3 - 1UL)) == 126) {
          {
#line 106
          pset_delete(dir_list, (__pset_pointer const   )((__pset_pointer )storename));
#line 107
          free((void *)storename);
#line 108
          u --;
          }
#line 109
          goto __Cont;
        }
      }
    }
    {
#line 112
    strx_sprint(filename, (len_sn + 255) + 1, "%s/%s", service_name, storename);
#line 115
    tmp___4 = stat((char const   */* __restrict  */)filename, (struct stat */* __restrict  */)(& sb));
    }
#line 115
    if (tmp___4 < 0) {
      {
#line 116
      parsemsg(3, func, "Unable to stat includedir file %s", filename);
#line 117
      pset_delete(dir_list, (__pset_pointer const   )((__pset_pointer )storename));
#line 118
      free((void *)storename);
#line 119
      u --;
      }
#line 120
      goto __Cont;
    }
#line 124
    if (! ((sb.st_mode & 61440U) == 32768U)) {
      {
#line 125
      msg(3, func, "%s is not a regular file. It is being skipped.", filename);
#line 128
      pset_delete(dir_list, (__pset_pointer const   )((__pset_pointer )storename));
#line 129
      free((void *)storename);
#line 130
      u --;
      }
#line 131
      goto __Cont;
    }
    {
#line 133
    incfd = open((char const   *)filename, 0);
    }
#line 134
    if (incfd < 0) {
      {
#line 135
      parsemsg(3, func, "Unable to open included configuration file: %s", filename);
#line 136
      pset_delete(dir_list, (__pset_pointer const   )((__pset_pointer )storename));
#line 137
      free((void *)storename);
#line 138
      u --;
      }
#line 139
      goto __Cont;
    }
    {
#line 141
    parsemsg(7, func, "Reading included configuration file: %s", filename);
#line 142
    parse_conf_file(incfd, confp, (char const   *)filename);
#line 148
    Sclose(incfd);
#line 149
    pset_delete(dir_list, (__pset_pointer const   )((__pset_pointer )storename));
#line 150
    free((void *)storename);
#line 151
    u --;
    }
    __Cont: /* CIL Label */ 
#line 94
    u ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 153
  tmp___5 = __errno_location();
  }
#line 153
  if (*tmp___5 != 0) {
    {
#line 154
    parsemsg(3, func, "Error reading included directory: %s", service_name);
    }
  }
  {
#line 156
  pset_destroy(dir_list);
#line 157
  free((void *)filename);
  }
#line 158
  return;
}
}
/* compiler builtin: 
   void __builtin_va_arg(__builtin_va_list  , unsigned long  , void * ) ;  */
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 131 "../libs/include/sio.h"
extern __sio_descriptor_t *__sio_descriptors ;
#line 45 "../libs/include/str.h"
extern int str_setstr(str_h handle , char *newstr ) ;
#line 34 "/usr/include/libgen.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) __xpg_basename)(char *__path ) ;
#line 30 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/./itox.c"
str_h strp  ;
#line 32
static void print_line(char const   *name___0 , char const   *value ) ;
#line 33
static char *next_word(char const   *description ) ;
#line 34
static char *make_string_cat(unsigned int count  , ...) ;
#line 35
static char *make_pathname(unsigned int count  , ...) ;
#line 204 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/./itox.c"
static void print_line(char const   *name___0 , char const   *value ) 
{ 


  {
  {
#line 206
  Sprint(1, "\t%-*s = %s\n", 15, name___0, value);
  }
#line 207
  return;
}
}
#line 210 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/./itox.c"
static char *next_word(char const   *description ) 
{ 
  char *word ;
  char *tmp ;

  {
  {
#line 212
  tmp = str_component(strp);
#line 212
  word = tmp;
  }
#line 214
  if ((unsigned long )word == (unsigned long )((void *)0)) {
    {
#line 216
    Sprint(2, "Line %d: %s missing \n", line_count, description);
#line 217
    exit(1);
    }
  }
#line 219
  return (word);
}
}
#line 222 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/./itox.c"
static char *make_string_cat(unsigned int count  , ...) 
{ 
  va_list ap ;
  register unsigned int i ;
  register unsigned int len ;
  register char *s ;
  register char *p ;
  char *newstring ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char tmp___7 ;
  char *tmp___8 ;

  {
#line 226
  len = 0U;
#line 230
  if (count == 0U) {
#line 231
    return ((char *)((void *)0));
  }
  {
#line 233
  __builtin_va_start(ap, count);
  }
#line 234
  if (count == 1U) {
    {
#line 236
    tmp = __builtin_va_arg(ap, char *);
#line 236
    s = tmp;
#line 237
    __builtin_va_end(ap);
    }
#line 238
    if ((unsigned long )s == (unsigned long )((void *)0)) {
      {
#line 239
      tmp___0 = strdup("");
      }
#line 239
      return (tmp___0);
    } else {
      {
#line 241
      tmp___1 = strdup((char const   *)s);
      }
#line 241
      return (tmp___1);
    }
  }
#line 243
  i = 0U;
  {
#line 243
  while (1) {
    while_continue: /* CIL Label */ ;
#line 243
    if (! (i < count)) {
#line 243
      goto while_break;
    }
    {
#line 245
    tmp___2 = __builtin_va_arg(ap, char *);
#line 245
    s = tmp___2;
    }
#line 246
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 247
      goto __Cont;
    }
    {
#line 248
    tmp___3 = strlen((char const   *)s);
#line 248
    len = (unsigned int )((size_t )len + tmp___3);
    }
    __Cont: /* CIL Label */ 
#line 243
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 250
  __builtin_va_end(ap);
#line 252
  tmp___4 = malloc((size_t )(len + 1U));
#line 252
  newstring = (char *)tmp___4;
  }
#line 253
  if ((unsigned long )newstring == (unsigned long )((void *)0)) {
#line 254
    return ((char *)((void *)0));
  }
  {
#line 256
  p = newstring;
#line 257
  __builtin_va_start(ap, count);
#line 258
  i = 0U;
  }
  {
#line 258
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 258
    if (! (i < count)) {
#line 258
      goto while_break___0;
    }
    {
#line 260
    tmp___5 = __builtin_va_arg(ap, char *);
#line 260
    s = tmp___5;
    }
#line 261
    if ((unsigned long )s == (unsigned long )((void *)0)) {
#line 262
      goto __Cont___0;
    }
    {
#line 263
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 263
      tmp___6 = p;
#line 263
      p ++;
#line 263
      tmp___8 = s;
#line 263
      s ++;
#line 263
      tmp___7 = *tmp___8;
#line 263
      *tmp___6 = tmp___7;
#line 263
      if (! tmp___7) {
#line 263
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 264
    p --;
    __Cont___0: /* CIL Label */ 
#line 258
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 266
  __builtin_va_end(ap);
#line 267
  *(newstring + len) = (char)0;
  }
#line 268
  return (newstring);
}
}
#line 271 "/home/june/repo/benchmarks/collector2/temp/xinetd-2.3.15/xinetd/./itox.c"
static char *make_pathname(unsigned int count  , ...) 
{ 
  va_list ap ;
  register unsigned int i ;
  register unsigned int len ;
  register char *s ;
  register char *p ;
  char *pathname ;
  char *tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char tmp___4 ;
  char *tmp___5 ;

  {
#line 275
  len = 0U;
#line 279
  if (count == 0U) {
#line 280
    return ((char *)((void *)0));
  }
  {
#line 282
  __builtin_va_start(ap, count);
#line 283
  i = 0U;
  }
  {
#line 283
  while (1) {
    while_continue: /* CIL Label */ ;
#line 283
    if (! (i < count)) {
#line 283
      goto while_break;
    }
    {
#line 285
    tmp = __builtin_va_arg(ap, char *);
#line 285
    s = tmp;
#line 286
    tmp___0 = strlen((char const   *)s);
#line 286
    len = (unsigned int )((size_t )len + tmp___0);
#line 283
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 288
  __builtin_va_end(ap);
#line 290
  tmp___1 = malloc((size_t )(len + count));
#line 290
  pathname = (char *)tmp___1;
  }
#line 291
  if ((unsigned long )pathname == (unsigned long )((void *)0)) {
#line 292
    return ((char *)((void *)0));
  }
  {
#line 294
  p = pathname;
#line 295
  __builtin_va_start(ap, count);
#line 296
  i = 0U;
  }
  {
#line 296
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 296
    if (! (i < count)) {
#line 296
      goto while_break___0;
    }
    {
#line 298
    tmp___2 = __builtin_va_arg(ap, char *);
#line 298
    s = tmp___2;
    }
    {
#line 299
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 299
      tmp___3 = p;
#line 299
      p ++;
#line 299
      tmp___5 = s;
#line 299
      s ++;
#line 299
      tmp___4 = *tmp___5;
#line 299
      *tmp___3 = tmp___4;
#line 299
      if (! tmp___4) {
#line 299
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 300
    *(p - 1) = (char )'/';
#line 296
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 302
  *(p - 1) = (char )'\000';
#line 303
  __builtin_va_end(ap);
  }
#line 304
  return (pathname);
}
}
