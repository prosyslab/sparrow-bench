/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 136 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_2 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_2 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_3 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_3 fd_set;
#line 109 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/resource.h"
typedef __rlim_t rlim_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rlimit {
   rlim_t rlim_cur ;
   rlim_t rlim_max ;
};
#line 42 "/usr/include/x86_64-linux-gnu/sys/resource.h"
typedef int __rlimit_resource_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_35 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_36 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_37 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_38 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_39 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_40 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_41 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_34 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_35 _kill ;
   struct __anonstruct__timer_36 _timer ;
   struct __anonstruct__rt_37 _rt ;
   struct __anonstruct__sigchld_38 _sigchld ;
   struct __anonstruct__sigfault_39 _sigfault ;
   struct __anonstruct__sigpoll_40 _sigpoll ;
   struct __anonstruct__sigsys_41 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_33 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_34 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_33 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_53 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_53 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 118 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int pselect(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                   fd_set * __restrict  __exceptfds , struct timespec  const  * __restrict  __timeout ,
                   __sigset_t const   * __restrict  __sigmask ) ;
#line 69 "/usr/include/x86_64-linux-gnu/sys/resource.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setrlimit)(__rlimit_resource_t __resource ,
                                                                                struct rlimit  const  *__rlimits ) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 208
extern  __attribute__((__nothrow__)) void ( __attribute__((__nonnull__(1), __leaf__)) rewinddir)(DIR *__dirp ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 248
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigprocmask)(int __how ,
                                                                                  sigset_t const   * __restrict  __set ,
                                                                                  sigset_t * __restrict  __oset ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 187 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) unsigned long ( __attribute__((__nonnull__(1),
__leaf__)) strtoul)(char const   * __restrict  __nptr , char ** __restrict  __endptr ,
                    int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 353
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 497
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 40 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
int append_buf(char const   *str , size_t len , int outfd , char *outbuf , size_t *outlen ) ;
#line 42
int copy_buf(int fd , int outfd , char *outbuf , size_t *outlen ) ;
#line 43
int flush_buf(int outfd , char *outbuf , size_t *outlen ) ;
#line 45
int read_file(int fd , char const   *uptime , size_t uptimelen , int outfd , char *outbuf ,
              size_t *outlen ) ;
#line 47
int read_proc(DIR *proc , char const   *uptime , size_t uptimelen , int outfd , char *outbuf ,
              size_t *outlen ) ;
#line 50
unsigned long get_uptime(int fd ) ;
#line 51
void sig_handler(int signum ) ;
#line 54 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
int append_buf(char const   *str , size_t len , int outfd , char *outbuf , size_t *outlen ) 
{ 
  int tmp ;

  {
#line 61
  if (! (len <= 524288UL)) {
    {
#line 61
    __assert_fail("len <= 524288", "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c",
                  61U, "append_buf");
    }
  }
#line 63
  if (*outlen + len > 524288UL) {
    {
#line 64
    tmp = flush_buf(outfd, outbuf, outlen);
    }
#line 64
    if (tmp < 0) {
#line 65
      return (-1);
    }
  }
  {
#line 67
  memcpy((void */* __restrict  */)(outbuf + *outlen), (void const   */* __restrict  */)str,
         len);
#line 68
  *outlen += len;
  }
#line 70
  return (0);
}
}
#line 73 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
int copy_buf(int fd , int outfd , char *outbuf , size_t *outlen ) 
{ 
  ssize_t len ;
  int tmp ;

  {
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (*outlen == 524288UL) {
      {
#line 83
      tmp = flush_buf(outfd, outbuf, outlen);
      }
#line 83
      if (tmp < 0) {
#line 84
        return (-1);
      }
    }
    {
#line 86
    len = read(fd, (void *)(outbuf + *outlen), 524288UL - *outlen);
    }
#line 87
    if (len < 0L) {
      {
#line 88
      perror("read");
      }
#line 89
      return (-1);
    } else
#line 90
    if (len == 0L) {
#line 91
      goto while_break;
    }
#line 93
    *outlen += (size_t )len;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  return (0);
}
}
#line 99 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
int flush_buf(int outfd , char *outbuf , size_t *outlen ) 
{ 
  size_t writelen ;
  ssize_t len ;

  {
#line 104
  writelen = (size_t )0;
  {
#line 106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 106
    if (! (writelen < *outlen)) {
#line 106
      goto while_break;
    }
    {
#line 109
    len = write(outfd, (void const   *)(outbuf + writelen), *outlen - writelen);
    }
#line 110
    if (len < 0L) {
      {
#line 111
      perror("write");
#line 112
      exit(1);
      }
    }
#line 115
    writelen += (size_t )len;
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  *outlen = (size_t )0;
#line 120
  return (0);
}
}
#line 124 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
int read_file(int fd , char const   *uptime , size_t uptimelen , int outfd , char *outbuf ,
              size_t *outlen ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 132
  lseek(fd, (__off_t )0, 0);
#line 134
  tmp = append_buf(uptime, uptimelen, outfd, outbuf, outlen);
  }
#line 134
  if (tmp < 0) {
#line 135
    return (-1);
  }
  {
#line 137
  tmp___0 = copy_buf(fd, outfd, outbuf, outlen);
  }
#line 137
  if (tmp___0 < 0) {
#line 138
    return (-1);
  }
  {
#line 140
  tmp___1 = append_buf("\n", (size_t )1, outfd, outbuf, outlen);
  }
#line 140
  if (tmp___1 < 0) {
#line 141
    return (-1);
  }
#line 143
  return (0);
}
}
#line 146 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
int read_proc(DIR *proc , char const   *uptime , size_t uptimelen , int outfd , char *outbuf ,
              size_t *outlen ) 
{ 
  struct dirent *ent ;
  int tmp ;
  char filename[4096] ;
  int fd ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 156
  rewinddir(proc);
#line 158
  tmp = append_buf(uptime, uptimelen, outfd, outbuf, outlen);
  }
#line 158
  if (tmp < 0) {
#line 159
    return (-1);
  }
  {
#line 161
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 161
    ent = readdir(proc);
    }
#line 161
    if (! ((unsigned long )ent != (unsigned long )((void *)0))) {
#line 161
      goto while_break;
    }
#line 165
    if ((int )ent->d_name[0] < 48) {
#line 166
      goto while_continue;
    } else
#line 165
    if ((int )ent->d_name[0] > 57) {
#line 166
      goto while_continue;
    }
    {
#line 168
    sprintf((char */* __restrict  */)(filename), (char const   */* __restrict  */)"/proc/%s/stat",
            ent->d_name);
#line 170
    fd = open((char const   *)(filename), 0);
    }
#line 171
    if (fd < 0) {
#line 172
      goto while_continue;
    }
    {
#line 174
    tmp___0 = copy_buf(fd, outfd, outbuf, outlen);
#line 177
    tmp___1 = close(fd);
    }
#line 177
    if (tmp___1 < 0) {
#line 178
      goto while_continue;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  tmp___2 = append_buf("\n", (size_t )1, outfd, outbuf, outlen);
  }
#line 181
  if (tmp___2 < 0) {
#line 182
    return (-1);
  }
#line 184
  return (0);
}
}
#line 188 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
unsigned long get_uptime(int fd ) 
{ 
  char buf[80] ;
  ssize_t len ;
  unsigned long u1 ;
  unsigned long u2 ;
  int tmp ;

  {
  {
#line 195
  lseek(fd, (__off_t )0, 0);
#line 197
  len = read(fd, (void *)(buf), sizeof(buf));
  }
#line 198
  if (len < 0L) {
    {
#line 199
    perror("read");
    }
#line 200
    return (0UL);
  }
  {
#line 203
  buf[len] = (char )'\000';
#line 205
  tmp = sscanf((char const   */* __restrict  */)(buf), (char const   */* __restrict  */)"%lu.%lu",
               & u1, & u2);
  }
#line 205
  if (tmp != 2) {
    {
#line 206
    perror("sscanf");
    }
#line 207
    return (0UL);
  }
#line 210
  return (u1 * 100UL + u2);
}
}
#line 214 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
void sig_handler(int signum ) 
{ 


  {
#line 217
  return;
}
}
#line 219 "/home/june/collector/temp/bootchart-0.90.2/bootchart-collector.c"
int main(int argc , char **argv ) 
{ 
  struct sigaction act ;
  sigset_t mask ;
  sigset_t oldmask ;
  struct rlimit rlim ;
  struct timespec timeout ;
  char const   *output_dir ;
  char filename[4096] ;
  int sfd ;
  int dfd ;
  int ufd ;
  DIR *proc ;
  int statfd ;
  int diskfd ;
  int procfd ;
  char statbuf[524288] ;
  char diskbuf[524288] ;
  char procbuf[524288] ;
  size_t statlen ;
  size_t disklen ;
  size_t proclen ;
  unsigned long reltime ;
  int arg ;
  int rel ;
  int tmp ;
  unsigned long hz ;
  char *endptr ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char uptime[80] ;
  size_t uptimelen ;
  unsigned long u ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
#line 227
  output_dir = ".";
#line 233
  statlen = (size_t )0;
#line 233
  disklen = (size_t )0;
#line 233
  proclen = (size_t )0;
#line 234
  reltime = 0UL;
#line 235
  arg = 1;
#line 235
  rel = 0;
#line 237
  if (argc > arg) {
    {
#line 237
    tmp = strcmp((char const   *)*(argv + arg), "-r");
    }
#line 237
    if (! tmp) {
#line 238
      rel = 1;
#line 239
      arg ++;
    }
  }
#line 242
  if (argc <= arg) {
    {
#line 243
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-r] HZ [DIR]\n",
            *(argv + 0));
#line 244
    exit(1);
    }
  }
#line 247
  if (argc > arg) {
    {
#line 251
    hz = strtoul((char const   */* __restrict  */)*(argv + arg), (char **/* __restrict  */)(& endptr),
                 10);
    }
#line 252
    if (*endptr) {
      {
#line 253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: HZ not an integer\n",
              *(argv + 0));
#line 254
      exit(1);
      }
    }
#line 257
    if (hz > 1UL) {
#line 258
      timeout.tv_sec = (__time_t )0;
#line 259
      timeout.tv_nsec = (__syscall_slong_t )(1000000000UL / hz);
    } else {
#line 261
      timeout.tv_sec = (__time_t )1;
#line 262
      timeout.tv_nsec = (__syscall_slong_t )0;
    }
#line 265
    arg ++;
  }
#line 268
  if (argc > arg) {
#line 269
    output_dir = (char const   *)*(argv + arg);
#line 270
    arg ++;
  }
  {
#line 274
  sigemptyset(& mask);
#line 275
  sigaddset(& mask, 15);
#line 276
  sigaddset(& mask, 2);
#line 278
  tmp___0 = sigprocmask(0, (sigset_t const   */* __restrict  */)(& mask), (sigset_t */* __restrict  */)(& oldmask));
  }
#line 278
  if (tmp___0 < 0) {
    {
#line 279
    perror("sigprocmask");
#line 280
    exit(1);
    }
  }
  {
#line 283
  act.__sigaction_handler.sa_handler = & sig_handler;
#line 284
  act.sa_flags = 0;
#line 285
  sigemptyset(& act.sa_mask);
#line 287
  tmp___1 = sigaction(15, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 287
  if (tmp___1 < 0) {
    {
#line 288
    perror("sigaction SIGTERM");
#line 289
    exit(1);
    }
  }
  {
#line 292
  tmp___2 = sigaction(2, (struct sigaction  const  */* __restrict  */)(& act), (struct sigaction */* __restrict  */)((void *)0));
  }
#line 292
  if (tmp___2 < 0) {
    {
#line 293
    perror("sigaction SIGINT");
#line 294
    exit(1);
    }
  }
  {
#line 298
  chdir("/");
#line 301
  rlim.rlim_cur = (__rlim_t )-1;
#line 302
  rlim.rlim_max = (__rlim_t )-1;
#line 304
  setrlimit(4, (struct rlimit  const  *)(& rlim));
#line 307
  proc = opendir("/proc");
  }
#line 308
  if (! proc) {
    {
#line 309
    perror("opendir /proc");
#line 310
    exit(1);
    }
  }
  {
#line 313
  sfd = open("/proc/stat", 0);
  }
#line 314
  if (sfd < 0) {
    {
#line 315
    perror("open /proc/stat");
#line 316
    exit(1);
    }
  }
  {
#line 319
  dfd = open("/proc/diskstats", 0);
  }
#line 320
  if (dfd < 0) {
    {
#line 321
    perror("open /proc/diskstats");
#line 322
    exit(1);
    }
  }
  {
#line 325
  ufd = open("/proc/uptime", 0);
  }
#line 326
  if (ufd < 0) {
    {
#line 327
    perror("open /proc/uptime");
#line 328
    exit(1);
    }
  }
  {
#line 332
  sprintf((char */* __restrict  */)(filename), (char const   */* __restrict  */)"%s/proc_stat.log",
          output_dir);
#line 333
  statfd = open((char const   *)(filename), 577, 420);
  }
#line 334
  if (statfd < 0) {
    {
#line 335
    perror("open proc_stat.log");
#line 336
    exit(1);
    }
  }
  {
#line 339
  sprintf((char */* __restrict  */)(filename), (char const   */* __restrict  */)"%s/proc_diskstats.log",
          output_dir);
#line 340
  diskfd = open((char const   *)(filename), 577, 420);
  }
#line 341
  if (diskfd < 0) {
    {
#line 342
    perror("open proc_diskstats.log");
#line 343
    exit(1);
    }
  }
  {
#line 346
  sprintf((char */* __restrict  */)(filename), (char const   */* __restrict  */)"%s/proc_ps.log",
          output_dir);
#line 347
  procfd = open((char const   *)(filename), 577, 420);
  }
#line 348
  if (procfd < 0) {
    {
#line 349
    perror("open proc_ps.log");
#line 350
    exit(1);
    }
  }
#line 354
  if (rel) {
    {
#line 355
    reltime = get_uptime(ufd);
    }
#line 356
    if (! reltime) {
      {
#line 357
      exit(1);
      }
    }
  }
  {
#line 360
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 365
    u = get_uptime(ufd);
    }
#line 366
    if (! u) {
      {
#line 367
      exit(1);
      }
    }
    {
#line 369
    tmp___3 = sprintf((char */* __restrict  */)(uptime), (char const   */* __restrict  */)"%lu\n",
                      u - reltime);
#line 369
    uptimelen = (size_t )tmp___3;
#line 372
    tmp___4 = read_file(sfd, (char const   *)(uptime), uptimelen, statfd, statbuf,
                        & statlen);
    }
#line 372
    if (tmp___4 < 0) {
      {
#line 374
      exit(1);
      }
    }
    {
#line 376
    tmp___5 = read_file(dfd, (char const   *)(uptime), uptimelen, diskfd, diskbuf,
                        & disklen);
    }
#line 376
    if (tmp___5 < 0) {
      {
#line 378
      exit(1);
      }
    }
    {
#line 380
    tmp___6 = read_proc(proc, (char const   *)(uptime), uptimelen, procfd, procbuf,
                        & proclen);
    }
#line 380
    if (tmp___6 < 0) {
      {
#line 382
      exit(1);
      }
    }
    {
#line 384
    tmp___8 = pselect(0, (fd_set */* __restrict  */)((void *)0), (fd_set */* __restrict  */)((void *)0),
                      (fd_set */* __restrict  */)((void *)0), (struct timespec  const  */* __restrict  */)(& timeout),
                      (__sigset_t const   */* __restrict  */)(& oldmask));
    }
#line 384
    if (tmp___8 < 0) {
      {
#line 385
      tmp___7 = __errno_location();
      }
#line 385
      if (*tmp___7 == 4) {
#line 386
        goto while_break;
      } else {
        {
#line 388
        perror("pselect");
#line 389
        exit(1);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 395
  tmp___9 = flush_buf(statfd, statbuf, & statlen);
  }
#line 395
  if (tmp___9 < 0) {
    {
#line 396
    exit(1);
    }
  }
  {
#line 397
  tmp___10 = close(statfd);
  }
#line 397
  if (tmp___10 < 0) {
    {
#line 398
    perror("close proc_stat.log");
#line 399
    exit(1);
    }
  }
  {
#line 402
  tmp___11 = flush_buf(diskfd, diskbuf, & disklen);
  }
#line 402
  if (tmp___11 < 0) {
    {
#line 403
    exit(1);
    }
  }
  {
#line 404
  tmp___12 = close(diskfd);
  }
#line 404
  if (tmp___12 < 0) {
    {
#line 405
    perror("close proc_diskstats.log");
#line 406
    exit(1);
    }
  }
  {
#line 409
  tmp___13 = flush_buf(procfd, procbuf, & proclen);
  }
#line 409
  if (tmp___13 < 0) {
    {
#line 410
    exit(1);
    }
  }
  {
#line 411
  tmp___14 = close(procfd);
  }
#line 411
  if (tmp___14 < 0) {
    {
#line 412
    perror("close proc_ps.log");
#line 413
    exit(1);
    }
  }
  {
#line 417
  tmp___15 = close(ufd);
  }
#line 417
  if (tmp___15 < 0) {
    {
#line 418
    perror("close /proc/uptime");
#line 419
    exit(1);
    }
  }
  {
#line 422
  tmp___16 = close(dfd);
  }
#line 422
  if (tmp___16 < 0) {
    {
#line 423
    perror("close /proc/diskstats");
#line 424
    exit(1);
    }
  }
  {
#line 427
  tmp___17 = close(sfd);
  }
#line 427
  if (tmp___17 < 0) {
    {
#line 428
    perror("close /proc/stat");
#line 429
    exit(1);
    }
  }
  {
#line 432
  tmp___18 = closedir(proc);
  }
#line 432
  if (tmp___18 < 0) {
    {
#line 433
    perror("close /proc");
#line 434
    exit(1);
    }
  }
#line 437
  return (0);
}
}
