/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned char __u_char;
#line 31 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned short __u_short;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 135 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __clock_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 33 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_char u_char;
#line 34 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __u_short u_short;
#line 98 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __pid_t pid_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 200 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned char u_int8_t;
#line 201 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned short u_int16_t;
#line 202 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef unsigned int u_int32_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 37 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef __sigset_t sigset_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 60 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef unsigned long pthread_t;
#line 63 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union pthread_attr_t {
   char __size[56] ;
   long __align ;
};
#line 69 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union pthread_attr_t pthread_attr_t;
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_internal_list {
   struct __pthread_internal_list *__prev ;
   struct __pthread_internal_list *__next ;
};
#line 75 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef struct __pthread_internal_list __pthread_list_t;
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __pthread_mutex_s {
   int __lock ;
   unsigned int __count ;
   int __owner ;
   unsigned int __nusers ;
   int __kind ;
   short __spins ;
   short __elision ;
   __pthread_list_t __list ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutex_t_15 {
   struct __pthread_mutex_s __data ;
   char __size[40] ;
   long __align ;
};
#line 90 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutex_t_15 pthread_mutex_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_mutexattr_t_16 {
   char __size[4] ;
   int __align ;
};
#line 129 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_mutexattr_t_16 pthread_mutexattr_t;
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
struct __anonstruct___data_18 {
   int __lock ;
   unsigned int __futex ;
   unsigned long long __total_seq ;
   unsigned long long __wakeup_seq ;
   unsigned long long __woken_seq ;
   void *__mutex ;
   unsigned int __nwaiters ;
   unsigned int __broadcast_seq ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
union __anonunion_pthread_cond_t_17 {
   struct __anonstruct___data_18 __data ;
   char __size[48] ;
   long long __align ;
};
#line 138 "/usr/include/x86_64-linux-gnu/bits/pthreadtypes.h"
typedef union __anonunion_pthread_cond_t_17 pthread_cond_t;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union sigval {
   int sival_int ;
   void *sival_ptr ;
};
#line 32 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef union sigval sigval_t;
#line 58 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef __clock_t __sigchld_clock_t;
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__kill_30 {
   __pid_t si_pid ;
   __uid_t si_uid ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__timer_31 {
   int si_tid ;
   int si_overrun ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__rt_32 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   sigval_t si_sigval ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigchld_33 {
   __pid_t si_pid ;
   __uid_t si_uid ;
   int si_status ;
   __sigchld_clock_t si_utime ;
   __sigchld_clock_t si_stime ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigfault_34 {
   void *si_addr ;
   short si_addr_lsb ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigpoll_35 {
   long si_band ;
   int si_fd ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct__sigsys_36 {
   void *_call_addr ;
   int _syscall ;
   unsigned int _arch ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
union __anonunion__sifields_29 {
   int _pad[128UL / sizeof(int ) - 4UL] ;
   struct __anonstruct__kill_30 _kill ;
   struct __anonstruct__timer_31 _timer ;
   struct __anonstruct__rt_32 _rt ;
   struct __anonstruct__sigchld_33 _sigchld ;
   struct __anonstruct__sigfault_34 _sigfault ;
   struct __anonstruct__sigpoll_35 _sigpoll ;
   struct __anonstruct__sigsys_36 _sigsys ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
struct __anonstruct_siginfo_t_28 {
   int si_signo ;
   int si_errno ;
   int si_code ;
   union __anonunion__sifields_29 _sifields ;
};
#line 62 "/usr/include/x86_64-linux-gnu/bits/siginfo.h"
typedef struct __anonstruct_siginfo_t_28 siginfo_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
union __anonunion___sigaction_handler_48 {
   void (*sa_handler)(int  ) ;
   void (*sa_sigaction)(int  , siginfo_t * , void * ) ;
};
#line 24 "/usr/include/x86_64-linux-gnu/bits/sigaction.h"
struct sigaction {
   union __anonunion___sigaction_handler_48 __sigaction_handler ;
   __sigset_t sa_mask ;
   int sa_flags ;
   void (*sa_restorer)(void) ;
};
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 42 "/usr/include/linux/netlink.h"
struct nlmsghdr {
   __u32 nlmsg_len ;
   __u16 nlmsg_type ;
   __u16 nlmsg_flags ;
   __u32 nlmsg_seq ;
   __u32 nlmsg_pid ;
};
#line 35 "/usr/include/linux/netfilter_ipv4/ipt_ULOG.h"
struct ulog_packet_msg {
   unsigned long mark ;
   long timestamp_sec ;
   long timestamp_usec ;
   unsigned int hook ;
   char indev_name[16] ;
   char outdev_name[16] ;
   size_t data_len ;
   char prefix[32] ;
   unsigned char mac_len ;
   unsigned char mac[80] ;
   unsigned char payload[0] ;
};
#line 35 "/usr/include/linux/netfilter_ipv4/ipt_ULOG.h"
typedef struct ulog_packet_msg ulog_packet_msg_t;
#line 22 "../src/libipulog/include/libipulog/libipulog.h"
struct ipulog_handle;
#line 28 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
struct ipulog_handle {
   int fd ;
   u_int8_t blocking ;
   struct sockaddr_nl local ;
   struct sockaddr_nl peer ;
   struct nlmsghdr *last_nlhdr ;
};
#line 48 "/usr/include/stdint.h"
typedef unsigned char uint8_t;
#line 49 "/usr/include/stdint.h"
typedef unsigned short uint16_t;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 30 "/usr/include/netinet/in.h"
typedef uint32_t in_addr_t;
#line 31 "/usr/include/netinet/in.h"
struct in_addr {
   in_addr_t s_addr ;
};
#line 117 "/usr/include/netinet/in.h"
typedef uint16_t in_port_t;
#line 237 "/usr/include/netinet/in.h"
struct sockaddr_in {
   sa_family_t sin_family ;
   in_port_t sin_port ;
   struct in_addr sin_addr ;
   unsigned char sin_zero[((sizeof(struct sockaddr ) - sizeof(unsigned short )) - sizeof(in_port_t )) - sizeof(struct in_addr )] ;
};
#line 107 "/usr/include/netinet/ip.h"
struct ip {
   unsigned int ip_hl : 4 ;
   unsigned int ip_v : 4 ;
   u_int8_t ip_tos ;
   u_short ip_len ;
   u_short ip_id ;
   u_short ip_off ;
   u_int8_t ip_ttl ;
   u_int8_t ip_p ;
   u_short ip_sum ;
   struct in_addr ip_src ;
   struct in_addr ip_dst ;
};
#line 56 "/usr/include/netinet/udp.h"
struct __anonstruct____missing_field_name_74 {
   u_int16_t uh_sport ;
   u_int16_t uh_dport ;
   u_int16_t uh_ulen ;
   u_int16_t uh_sum ;
};
#line 56 "/usr/include/netinet/udp.h"
struct __anonstruct____missing_field_name_75 {
   u_int16_t source ;
   u_int16_t dest ;
   u_int16_t len ;
   u_int16_t check ;
};
#line 56 "/usr/include/netinet/udp.h"
union __anonunion____missing_field_name_73 {
   struct __anonstruct____missing_field_name_74 __annonCompField5 ;
   struct __anonstruct____missing_field_name_75 __annonCompField6 ;
};
#line 56 "/usr/include/netinet/udp.h"
struct udphdr {
   union __anonunion____missing_field_name_73 __annonCompField7 ;
};
#line 131 "/usr/include/netinet/ip_icmp.h"
struct icmp_ra_addr {
   u_int32_t ira_addr ;
   u_int32_t ira_preference ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_idseq {
   u_int16_t icd_id ;
   u_int16_t icd_seq ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_pmtu {
   u_int16_t ipm_void ;
   u_int16_t ipm_nextmtu ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct ih_rtradv {
   u_int8_t irt_num_addrs ;
   u_int8_t irt_wpa ;
   u_int16_t irt_lifetime ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
union __anonunion_icmp_hun_79 {
   u_char ih_pptr ;
   struct in_addr ih_gwaddr ;
   struct ih_idseq ih_idseq ;
   u_int32_t ih_void ;
   struct ih_pmtu ih_pmtu ;
   struct ih_rtradv ih_rtradv ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct __anonstruct_id_ts_81 {
   u_int32_t its_otime ;
   u_int32_t its_rtime ;
   u_int32_t its_ttime ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct __anonstruct_id_ip_82 {
   struct ip idi_ip ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
union __anonunion_icmp_dun_80 {
   struct __anonstruct_id_ts_81 id_ts ;
   struct __anonstruct_id_ip_82 id_ip ;
   struct icmp_ra_addr id_radv ;
   u_int32_t id_mask ;
   u_int8_t id_data[1] ;
};
#line 137 "/usr/include/netinet/ip_icmp.h"
struct icmp {
   u_int8_t icmp_type ;
   u_int8_t icmp_code ;
   u_int16_t icmp_cksum ;
   union __anonunion_icmp_hun_79 icmp_hun ;
   union __anonunion_icmp_dun_80 icmp_dun ;
};
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/sched.h"
struct sched_param {
   int __sched_priority ;
};
#line 567 "/usr/include/netdb.h"
struct addrinfo {
   int ai_flags ;
   int ai_family ;
   int ai_socktype ;
   int ai_protocol ;
   socklen_t ai_addrlen ;
   struct sockaddr *ai_addr ;
   char *ai_canonname ;
   struct addrinfo *ai_next ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 27 "./fprobe-ulog.h"
struct Time {
   time_t sec ;
   long usec ;
};
#line 32 "./fprobe-ulog.h"
struct Flow {
   uint16_t iif ;
   uint16_t oif ;
   struct in_addr sip ;
   struct in_addr dip ;
   uint8_t proto ;
   uint16_t id ;
   uint16_t sp ;
   uint16_t dp ;
   uint8_t tos ;
   uint8_t tcp_flags ;
   unsigned long pkts ;
   unsigned long size ;
   unsigned long sizeF ;
   unsigned long sizeP ;
   struct Time ctime ;
   struct Time mtime ;
   int flags ;
   struct Flow *next ;
};
#line 74 "./fprobe-ulog.h"
struct Flow_F {
   uint16_t iif ;
   uint16_t oif ;
   struct in_addr sip ;
   struct in_addr dip ;
   uint8_t proto ;
   uint16_t id ;
};
#line 89 "./fprobe-ulog.h"
struct Flow_TL {
   uint16_t iif ;
   uint16_t oif ;
   struct in_addr sip ;
   struct in_addr dip ;
   uint8_t proto ;
   uint16_t id ;
   uint16_t sp ;
   uint16_t dp ;
};
#line 112 "./fprobe-ulog.h"
struct peer {
   int sock ;
   struct sockaddr_in addr ;
   struct sockaddr_in laddr ;
   int type ;
   uint32_t seq ;
};
#line 120 "./fprobe-ulog.h"
struct snmp_rule {
   char basename[16] ;
   int len ;
   int base ;
};
#line 19 "./my_getopt.h"
struct getopt_parms {
   char name ;
   int flag ;
   int count ;
   char *arg ;
};
#line 233 "./netflow.h"
struct NetFlow {
   unsigned int Version ;
   unsigned int HeaderSize ;
   unsigned int MaxFlows ;
   unsigned int FlowSize ;
   unsigned int SeqOffset ;
   unsigned int HeaderFields ;
   uint16_t *HeaderFormat ;
   unsigned int FlowFields ;
   uint16_t *FlowFormat ;
};
#line 39 "./hash.h"
typedef uint16_t hash_t;
#line 24 "./mem.h"
typedef void *mem_index_t;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 98 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __gnuc_va_list va_list;
#line 99 "/usr/include/linux/netlink.h"
struct nlmsgerr {
   int error ;
   struct nlmsghdr msg ;
};
#line 48 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
struct ipulog_errmap_t {
   int errcode ;
   char *message ;
};
#line 37 "./mem.h"
struct Mem {
   struct Mem *next ;
   unsigned int free ;
   void *first ;
   void *last ;
};
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 278
extern FILE *freopen(char const   * __restrict  __filename , char const   * __restrict  __modes ,
                     FILE * __restrict  __stream ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 705
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setreuid)(__uid_t __ruid ,
                                                                               __uid_t __euid ) ;
#line 722
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setregid)(__gid_t __rgid ,
                                                                               __gid_t __egid ) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 71 "/usr/include/getopt.h"
extern int optind ;
#line 76
extern int opterr ;
#line 944 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chroot)(char const   *__path ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 215 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigemptyset)(sigset_t *__set ) ;
#line 221
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) sigaddset)(sigset_t *__set ,
                                                                                                int __signo ) ;
#line 259
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sigaction)(int __sig ,
                                                                                struct sigaction  const  * __restrict  __act ,
                                                                                struct sigaction * __restrict  __oact ) ;
#line 30 "/usr/include/x86_64-linux-gnu/bits/sigthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_sigmask)(int __how ,
                                                                                      __sigset_t const   * __restrict  __newmask ,
                                                                                      __sigset_t * __restrict  __oldmask ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 137
extern int connect(int __fd , struct sockaddr  const  *__addr , socklen_t __len ) ;
#line 149
extern ssize_t send(int __fd , void const   *__buf , size_t __n , int __flags ) ;
#line 226
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setsockopt)(int __fd ,
                                                                                 int __level ,
                                                                                 int __optname ,
                                                                                 void const   *__optval ,
                                                                                 socklen_t __optlen ) ;
#line 193 "/usr/include/net/if.h"
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) if_nametoindex)(char const   *__ifname ) ;
#line 23 "../src/libipulog/include/libipulog/libipulog.h"
int ipulog_errno ;
#line 27
struct ipulog_handle *ipulog_create_handle(u_int32_t gmask , u_int32_t rcvbufsize ) ;
#line 31
ssize_t ipulog_read(struct ipulog_handle *h , unsigned char *buf , size_t len , int timeout ) ;
#line 34
ulog_packet_msg_t *ipulog_get_packet(struct ipulog_handle *h , unsigned char const   *buf ,
                                     size_t len ) ;
#line 38
char *ipulog_strerror(int errcode ) ;
#line 375 "/usr/include/netinet/in.h"
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) ntohs)(uint16_t __netshort )  __attribute__((__const__)) ;
#line 377
extern  __attribute__((__nothrow__)) uint32_t ( __attribute__((__leaf__)) htonl)(uint32_t __hostlong )  __attribute__((__const__)) ;
#line 379
extern  __attribute__((__nothrow__)) uint16_t ( __attribute__((__leaf__)) htons)(uint16_t __hostshort )  __attribute__((__const__)) ;
#line 53 "/usr/include/arpa/inet.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) inet_ntoa)(struct in_addr __in ) ;
#line 116 "/usr/include/pwd.h"
extern struct passwd *getpwnam(char const   *__name ) ;
#line 180 "/usr/include/grp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setgroups)(size_t __n ,
                                                                                __gid_t const   *__groups ) ;
#line 66 "/usr/include/sched.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_max)(int __algorithm ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sched_get_priority_min)(int __algorithm ) ;
#line 334 "/usr/include/time.h"
extern int nanosleep(struct timespec  const  *__requested_time , struct timespec *__remaining ) ;
#line 244 "/usr/include/pthread.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,3))) pthread_create)(pthread_t * __restrict  __newthread ,
                                                                                             pthread_attr_t const   * __restrict  __attr ,
                                                                                             void *(*__start_routine)(void * ) ,
                                                                                             void * __restrict  __arg ) ;
#line 282
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pthread_detach)(pthread_t __th ) ;
#line 298
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_init)(pthread_attr_t *__attr ) ;
#line 332
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) pthread_attr_setschedparam)(pthread_attr_t * __restrict  __attr ,
                                                                                                                   struct sched_param  const  * __restrict  __param ) ;
#line 342
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_attr_setschedpolicy)(pthread_attr_t *__attr ,
                                                                                                                  int __policy ) ;
#line 760
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) pthread_mutex_init)(pthread_mutex_t *__mutex ,
                                                                                                         pthread_mutexattr_t const   *__mutexattr ) ;
#line 773
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_lock)(pthread_mutex_t *__mutex ) ;
#line 784
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_mutex_unlock)(pthread_mutex_t *__mutex ) ;
#line 988
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1))) pthread_cond_signal)(pthread_cond_t *__cond ) ;
#line 1011
extern int ( __attribute__((__nonnull__(1,2,3))) pthread_cond_timedwait)(pthread_cond_t * __restrict  __cond ,
                                                                         pthread_mutex_t * __restrict  __mutex ,
                                                                         struct timespec  const  * __restrict  __abstime ) ;
#line 662 "/usr/include/netdb.h"
extern int getaddrinfo(char const   * __restrict  __name , char const   * __restrict  __service ,
                       struct addrinfo  const  * __restrict  __req , struct addrinfo ** __restrict  __pai ) ;
#line 668
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) freeaddrinfo)(struct addrinfo *__ai ) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 120 "./fprobe-ulog.h"
struct snmp_rule snmp_rule_t  ;
#line 20 "./my_log.h"
void my_log_open(char *indent , unsigned int min_level , unsigned int flags ) ;
#line 22
void my_log(unsigned int level , char const   *format  , ...) ;
#line 26 "./my_getopt.h"
int my_getopt(int argc , char * const  *argv , struct getopt_parms *parms___0 ) ;
#line 49 "./hash.h"
hash_t hash(void *p , int size ) ;
#line 50
void hash_init(void) ;
#line 33 "./mem.h"
void *mem_alloc(void) ;
#line 34
void mem_free(void *eptr ) ;
#line 35
int mem_init(unsigned int element , unsigned int bulk , unsigned int limit ) ;
#line 109 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct getopt_parms parms[21]  = 
#line 109 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
  {      {(char )'a', 1, 0, (char *)0}, 
        {(char )'B', 1, 0, (char *)0}, 
        {(char )'b', 1, 0, (char *)0}, 
        {(char )'c', 1, 0, (char *)0}, 
        {(char )'d', 1, 0, (char *)0}, 
        {(char )'e', 1, 0, (char *)0}, 
        {(char )'g', 1, 0, (char *)0}, 
        {(char )'h', 0, 0, (char *)0}, 
        {(char )'l', 1, 0, (char *)0}, 
        {(char )'m', 1, 0, (char *)0}, 
        {(char )'M', 0, 0, (char *)0}, 
        {(char )'n', 1, 0, (char *)0}, 
        {(char )'q', 1, 0, (char *)0}, 
        {(char )'r', 1, 0, (char *)0}, 
        {(char )'s', 1, 0, (char *)0}, 
        {(char )'t', 1, 0, (char *)0}, 
        {(char )'U', 1, 0, (char *)0}, 
        {(char )'u', 1, 0, (char *)0}, 
        {(char )'v', 1, 0, (char *)0}, 
        {(char )'X', 1, 0, (char *)0}, 
        {(char)0, 0, 0, (char *)0}};
#line 137
struct NetFlow NetFlow1 ;
#line 138
struct NetFlow NetFlow5 ;
#line 139
struct NetFlow NetFlow7 ;
#line 142 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static unsigned int scan_interval  =    5U;
#line 143 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int frag_lifetime  =    30;
#line 144 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int inactive_lifetime  =    60;
#line 145 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int active_lifetime  =    300;
#line 146 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int sockbufsize  ;
#line 153 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static unsigned int bulk_quantity  =    10000U;
#line 154 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static unsigned int pending_queue_length  =    100U;
#line 155 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct NetFlow *netflow  =    & NetFlow5;
#line 156 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static unsigned int verbosity  =    6U;
#line 157 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static unsigned int log_dest  =    1U;
#line 158 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct Time start_time  ;
#line 159 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static long start_time_offset  ;
#line 160 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int off_tl  ;
#line 162
unsigned int total_elements ;
#line 163
unsigned int free_elements ;
#line 174 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static unsigned int emit_count  ;
#line 175 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static uint32_t emit_sequence  ;
#line 176 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static unsigned int emit_rate_bytes  ;
#line 176 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static unsigned int emit_rate_delay  ;
#line 177 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct Time emit_time  ;
#line 178 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static uint8_t emit_packet[1500]  ;
#line 179 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pthread_t thid  ;
#line 180 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static sigset_t sig_mask  ;
#line 181 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct sched_param schedp  ;
#line 182 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int sched_min  ;
#line 182 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int sched_max  ;
#line 183 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int npeers  ;
#line 183 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int npeers_rot  ;
#line 184 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct peer *peers  ;
#line 185 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int sigs  ;
#line 187 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct Flow *flows[1 << 16]  ;
#line 188 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pthread_mutex_t flows_mutex[1 << 16]  ;
#line 190 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pthread_mutex_t unpending_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 191 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pthread_cond_t unpending_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 193 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pthread_mutex_t scan_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 194 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pthread_cond_t scan_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 195 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct Flow *pending_head  ;
#line 195 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct Flow *pending_tail  ;
#line 196 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct Flow *scan_frag_dreg  ;
#line 198 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pthread_mutex_t emit_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 199 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pthread_cond_t emit_cond  =    {{0, 0U, 0ULL, 0ULL, 0ULL, (void *)0, 0U, 0U}};
#line 200 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct Flow *flows_emit  ;
#line 202 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static char ident[256]  = 
#line 202
  {      (char )'f',      (char )'p',      (char )'r',      (char )'o', 
        (char )'b',      (char )'e',      (char )'-',      (char )'u', 
        (char )'l',      (char )'o',      (char )'g',      (char )'\000'};
#line 203 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static FILE *pidfile  ;
#line 204 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static char *pidfilepath  ;
#line 205 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static pid_t pid  ;
#line 206 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int killed  ;
#line 207 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int emit_timeout  =    5;
#line 207 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int unpending_timeout  =    5;
#line 208 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct ipulog_handle *ulog_handle  ;
#line 209 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static uint32_t ulog_gmask  =    (uint32_t )1;
#line 210 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static char *cap_buf  ;
#line 211 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static int nsnmp_rules  ;
#line 212 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct snmp_rule *snmp_rules  ;
#line 213 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static struct passwd *pw  =    (struct passwd *)0;
#line 215 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void usage(void) 
{ 


  {
  {
#line 217
  fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"fprobe-ulog: a NetFlow probe. Version %s\nUsage: fprobe-ulog [options] remote:port[/[local][/type]] ...\n\n-h\t\tDisplay this help\n-U <mask>\tULOG group bitwise mask [1]\n-s <seconds>\tHow often scan for expired flows [5]\n-g <seconds>\tFragmented flow lifetime [30]\n-d <seconds>\tIdle flow lifetime (inactive timer) [60]\n-e <seconds>\tActive flow lifetime (active timer) [300]\n-n <version>\tNetFlow version for use (1, 5 or 7) [5]\n-a <address>\tUse <address> as source for NetFlow flow\n-X <rules>\tInterface name to SNMP-index conversion rules\n-M\t\tUse netfilter mark value as ToS flag\n-b <flows>\tMemory bulk size (1..%u) [%u]\n-m <kilobytes>\tMemory limit (0=no limit) [0]\n-q <flows>\tPending queue length [100]\n-B <kilobytes>\tKernel capture buffer size [0]\n-r <priority>\tReal-time priority (0=disabled, %d..%d) [0]\n-t <B:N>\tProduce <N> nanosecond delay after each <B> bytes sent [0:0]\n-c <directory>\tDirectory to chroot to\n-u <user>\tUser to run as\n-v <level>\tMaximum log level (0=EMERG, ..., 6=INFO, 7=DEBUG) [6]\n-l <[dst][:id]>\tLog destination and log/pidfile idetifier [1]\nremote:port\tAddress of the NetFlow collector\n",
          "1.1", (unsigned int )((mem_index_t )-1), bulk_quantity, sched_min, sched_max);
#line 243
  exit(0);
  }
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void sighandler(int sig ) 
{ 


  {
  {
#line 264
  if (sig == 15) {
#line 264
    goto case_15;
  }
#line 263
  goto switch_break;
  case_15: /* CIL Label */ 
#line 265
  sigs |= 2;
#line 266
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void gettime(struct Time *now ) 
{ 
  struct timeval t ;

  {
  {
#line 279
  gettimeofday((struct timeval */* __restrict  */)(& t), (__timezone_ptr_t )0);
#line 280
  now->sec = t.tv_sec;
#line 281
  now->usec = t.tv_usec;
  }
#line 282
  return;
}
}
#line 284 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
__inline time_t cmpmtime(struct Time *t1 , struct Time *t2 ) 
{ 


  {
#line 286
  return ((t1->sec - t2->sec) * 1000L + (t1->usec - t2->usec) / 1000L);
}
}
#line 290 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
uint32_t getuptime(struct Time *t ) 
{ 
  time_t tmp ;

  {
  {
#line 293
  tmp = cmpmtime(t, & start_time);
  }
#line 293
  return ((uint32_t )tmp);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
hash_t hash_flow(struct Flow *flow ) 
{ 
  hash_t tmp ;
  hash_t tmp___0 ;

  {
#line 298
  if (flow->flags & 1) {
    {
#line 298
    tmp = hash((void *)flow, (int )sizeof(struct Flow_F ));
    }
#line 298
    return (tmp);
  } else {
    {
#line 299
    tmp___0 = hash((void *)flow, (int )sizeof(struct Flow_TL ));
    }
#line 299
    return (tmp___0);
  }
}
}
#line 302 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
uint16_t snmp_index(char *name ) 
{ 
  uint32_t i ;
  int tmp ;
  int tmp___0 ;

  {
#line 305
  if (! *name) {
#line 305
    return ((uint16_t )0);
  }
#line 307
  i = (uint32_t )0;
  {
#line 307
  while (1) {
    while_continue: /* CIL Label */ ;
#line 307
    if (! ((int )i < nsnmp_rules)) {
#line 307
      goto while_break;
    }
    {
#line 308
    tmp = strncmp((char const   *)((snmp_rules + i)->basename), (char const   *)name,
                  (size_t )(snmp_rules + i)->len);
    }
#line 308
    if (tmp) {
#line 308
      goto __Cont;
    }
    {
#line 309
    tmp___0 = atoi((char const   *)(name + (snmp_rules + i)->len));
    }
#line 309
    return ((uint16_t )(tmp___0 + (snmp_rules + i)->base));
    __Cont: /* CIL Label */ 
#line 307
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 312
  i = if_nametoindex((char const   *)name);
  }
#line 312
  if (i) {
#line 312
    return ((uint16_t )i);
  }
#line 314
  return ((uint16_t )-1);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
__inline void copy_flow(struct Flow *src , struct Flow *dst ) 
{ 


  {
#line 319
  dst->iif = src->iif;
#line 320
  dst->oif = src->oif;
#line 321
  dst->sip = src->sip;
#line 322
  dst->dip = src->dip;
#line 323
  dst->tos = src->tos;
#line 324
  dst->proto = src->proto;
#line 325
  dst->tcp_flags = src->tcp_flags;
#line 326
  dst->id = src->id;
#line 327
  dst->sp = src->sp;
#line 328
  dst->dp = src->dp;
#line 329
  dst->pkts = src->pkts;
#line 330
  dst->size = src->size;
#line 331
  dst->sizeF = src->sizeF;
#line 332
  dst->sizeP = src->sizeP;
#line 333
  dst->ctime = src->ctime;
#line 334
  dst->mtime = src->mtime;
#line 335
  dst->flags = src->flags;
#line 336
  return;
}
}
#line 338 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
struct Flow *find(struct Flow *where , struct Flow *what , struct Flow ***prev ) 
{ 
  struct Flow **flowpp ;

  {
#line 343
  flowpp = (struct Flow **)0;
#line 346
  if (prev) {
#line 346
    flowpp = *prev;
  }
  {
#line 348
  while (1) {
    while_continue: /* CIL Label */ ;
#line 348
    if (! where) {
#line 348
      goto while_break;
    }
#line 349
    if (where->sip.s_addr == what->sip.s_addr) {
#line 349
      if (where->dip.s_addr == what->dip.s_addr) {
#line 349
        if ((int )where->proto == (int )what->proto) {
          {
#line 353
          if (((what->flags + where->flags) & 3) == 0) {
#line 353
            goto case_0;
          }
#line 358
          if (((what->flags + where->flags) & 3) == 2) {
#line 358
            goto case_2;
          }
#line 352
          goto switch_break;
          case_0: /* CIL Label */ 
#line 355
          if ((int )what->sp == (int )where->sp) {
#line 355
            if ((int )what->dp == (int )where->dp) {
#line 356
              goto done;
            }
          }
#line 357
          goto switch_break;
          case_2: /* CIL Label */ 
#line 360
          if ((int )where->id == (int )what->id) {
#line 360
            goto done;
          }
#line 361
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
#line 364
    flowpp = & where->next;
#line 365
    where = where->next;
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 368
  if (prev) {
#line 368
    *prev = flowpp;
  }
#line 369
  return (where);
}
}
#line 372 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
int put_into(struct Flow *flow , int flag___0 ) 
{ 
  int ret ;
  hash_t h ;
  struct Flow *flown ;
  struct Flow **flowpp ;
  void *tmp ;
  time_t tmp___0 ;
  time_t tmp___1 ;

  {
  {
#line 378
  ret = 0;
#line 385
  h = hash_flow(flow);
#line 390
  pthread_mutex_lock(& flows_mutex[h]);
#line 391
  flowpp = & flows[h];
#line 392
  flown = find(flows[h], flow, & flowpp);
  }
#line 392
  if (flown) {
    {
#line 424
    tmp___0 = cmpmtime(& flow->mtime, & flown->mtime);
    }
#line 424
    if (tmp___0 > 0L) {
#line 425
      flown->mtime = flow->mtime;
    }
    {
#line 426
    tmp___1 = cmpmtime(& flow->ctime, & flown->ctime);
    }
#line 426
    if (tmp___1 < 0L) {
#line 427
      flown->ctime = flow->ctime;
    }
#line 428
    flown->tcp_flags = (uint8_t )((int )flown->tcp_flags | (int )flow->tcp_flags);
#line 429
    flown->size += flow->size;
#line 430
    flown->pkts += flow->pkts;
#line 431
    if (flow->flags & 1) {
#line 433
      if (flow->flags & 4) {
#line 438
        flown->sp = flow->sp;
#line 439
        flown->dp = flow->dp;
      }
#line 441
      if (flow->flags & 8) {
#line 446
        flown->sizeP = flow->sizeP;
      }
#line 448
      flown->flags |= flow->flags;
#line 449
      flown->sizeF += flow->sizeF;
#line 450
      if (flown->flags & 8) {
#line 450
        if (flown->sizeF >= flown->sizeP) {
          {
#line 453
          *flowpp = flown->next;
#line 454
          pthread_mutex_unlock(& flows_mutex[h]);
#line 459
          flown->id = (uint16_t )0;
#line 460
          flown->flags &= -2;
#line 464
          ret = put_into(flown, 1);
          }
        }
      }
    }
#line 471
    if (flag___0 == 1) {
      {
#line 471
      mem_free((void *)flow);
      }
    }
  } else {
#line 394
    if (flag___0 == 0) {
      {
#line 395
      tmp = mem_alloc();
#line 395
      flown = (struct Flow *)tmp;
      }
#line 395
      if (flown) {
        {
#line 396
        copy_flow(flow, flown);
#line 397
        flow = flown;
        }
      } else {
#line 403
        return (-1);
      }
    }
#line 406
    flow->next = flows[h];
#line 407
    flows[h] = flow;
  }
  {
#line 473
  pthread_mutex_unlock(& flows_mutex[h]);
  }
#line 474
  return (ret);
}
}
#line 477 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void *fill(int fields , uint16_t *format , struct Flow *flow , void *p ) 
{ 
  int i ;
  uint32_t tmp ;
  uint32_t tmp___0 ;
  uint32_t tmp___1 ;

  {
#line 481
  i = 0;
  {
#line 481
  while (1) {
    while_continue: /* CIL Label */ ;
#line 481
    if (! (i < fields)) {
#line 481
      goto while_break;
    }
    {
#line 486
    if ((int )*(format + i) == 8) {
#line 486
      goto case_8;
    }
#line 491
    if ((int )*(format + i) == 12) {
#line 491
      goto case_12;
    }
#line 496
    if ((int )*(format + i) == 10) {
#line 496
      goto case_10;
    }
#line 501
    if ((int )*(format + i) == 14) {
#line 501
      goto case_14;
    }
#line 506
    if ((int )*(format + i) == 2) {
#line 506
      goto case_2;
    }
#line 511
    if ((int )*(format + i) == 1) {
#line 511
      goto case_1;
    }
#line 516
    if ((int )*(format + i) == 22) {
#line 516
      goto case_22;
    }
#line 521
    if ((int )*(format + i) == 21) {
#line 521
      goto case_21;
    }
#line 526
    if ((int )*(format + i) == 7) {
#line 526
      goto case_7;
    }
#line 531
    if ((int )*(format + i) == 11) {
#line 531
      goto case_11;
    }
#line 536
    if ((int )*(format + i) == 4) {
#line 536
      goto case_4;
    }
#line 541
    if ((int )*(format + i) == 5) {
#line 541
      goto case_5;
    }
#line 546
    if ((int )*(format + i) == 6) {
#line 546
      goto case_6;
    }
#line 551
    if ((int )*(format + i) == 1001) {
#line 551
      goto case_1001;
    }
#line 556
    if ((int )*(format + i) == 1002) {
#line 556
      goto case_1002;
    }
#line 561
    if ((int )*(format + i) == 1003) {
#line 561
      goto case_1003;
    }
#line 566
    if ((int )*(format + i) == 1004) {
#line 566
      goto case_1004;
    }
#line 571
    if ((int )*(format + i) == 1005) {
#line 571
      goto case_1005;
    }
#line 576
    if ((int )*(format + i) == 1006) {
#line 576
      goto case_1006;
    }
#line 588
    if ((int )*(format + i) == 13) {
#line 588
      goto case_13;
    }
#line 588
    if ((int )*(format + i) == 9) {
#line 588
      goto case_13;
    }
#line 588
    if ((int )*(format + i) == 1010) {
#line 588
      goto case_13;
    }
#line 588
    if ((int )*(format + i) == 39) {
#line 588
      goto case_13;
    }
#line 588
    if ((int )*(format + i) == 38) {
#line 588
      goto case_13;
    }
#line 588
    if ((int )*(format + i) == 9001) {
#line 588
      goto case_13;
    }
#line 597
    if ((int )*(format + i) == 1011) {
#line 597
      goto case_1011;
    }
#line 597
    if ((int )*(format + i) == 17) {
#line 597
      goto case_1011;
    }
#line 597
    if ((int )*(format + i) == 16) {
#line 597
      goto case_1011;
    }
#line 597
    if ((int )*(format + i) == 9002) {
#line 597
      goto case_1011;
    }
#line 605
    if ((int )*(format + i) == 1012) {
#line 605
      goto case_1012;
    }
#line 605
    if ((int )*(format + i) == 15) {
#line 605
      goto case_1012;
    }
#line 605
    if ((int )*(format + i) == 9003) {
#line 605
      goto case_1012;
    }
#line 610
    goto switch_default;
    case_8: /* CIL Label */ 
#line 487
    ((struct in_addr *)p)->s_addr = flow->sip.s_addr;
#line 488
    p += 4;
#line 489
    goto switch_break;
    case_12: /* CIL Label */ 
#line 492
    ((struct in_addr *)p)->s_addr = flow->dip.s_addr;
#line 493
    p += 4;
#line 494
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 497
    *((uint16_t *)p) = htons(flow->iif);
#line 498
    p += 2;
    }
#line 499
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 502
    *((uint16_t *)p) = htons(flow->oif);
#line 503
    p += 2;
    }
#line 504
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 507
    *((uint32_t *)p) = htonl((uint32_t )flow->pkts);
#line 508
    p += 4;
    }
#line 509
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 512
    *((uint32_t *)p) = htonl((uint32_t )flow->size);
#line 513
    p += 4;
    }
#line 514
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 517
    tmp = getuptime(& flow->ctime);
#line 517
    *((uint32_t *)p) = htonl(tmp);
#line 518
    p += 4;
    }
#line 519
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 522
    tmp___0 = getuptime(& flow->mtime);
#line 522
    *((uint32_t *)p) = htonl(tmp___0);
#line 523
    p += 4;
    }
#line 524
    goto switch_break;
    case_7: /* CIL Label */ 
#line 527
    *((uint16_t *)p) = flow->sp;
#line 528
    p += 2;
#line 529
    goto switch_break;
    case_11: /* CIL Label */ 
#line 532
    *((uint16_t *)p) = flow->dp;
#line 533
    p += 2;
#line 534
    goto switch_break;
    case_4: /* CIL Label */ 
#line 537
    *((uint8_t *)p) = flow->proto;
#line 538
    p ++;
#line 539
    goto switch_break;
    case_5: /* CIL Label */ 
#line 542
    *((uint8_t *)p) = flow->tos;
#line 543
    p ++;
#line 544
    goto switch_break;
    case_6: /* CIL Label */ 
#line 547
    *((uint8_t *)p) = flow->tcp_flags;
#line 548
    p ++;
#line 549
    goto switch_break;
    case_1001: /* CIL Label */ 
    {
#line 552
    *((uint16_t *)p) = htons((uint16_t )netflow->Version);
#line 553
    p += 2;
    }
#line 554
    goto switch_break;
    case_1002: /* CIL Label */ 
    {
#line 557
    *((uint16_t *)p) = htons((uint16_t )emit_count);
#line 558
    p += 2;
    }
#line 559
    goto switch_break;
    case_1003: /* CIL Label */ 
    {
#line 562
    tmp___1 = getuptime(& emit_time);
#line 562
    *((uint32_t *)p) = htonl(tmp___1);
#line 563
    p += 4;
    }
#line 564
    goto switch_break;
    case_1004: /* CIL Label */ 
    {
#line 567
    *((uint32_t *)p) = htonl((uint32_t )emit_time.sec);
#line 568
    p += 4;
    }
#line 569
    goto switch_break;
    case_1005: /* CIL Label */ 
    {
#line 572
    *((uint32_t *)p) = htonl((uint32_t )(emit_time.usec * 1000L));
#line 573
    p += 4;
    }
#line 574
    goto switch_break;
    case_1006: /* CIL Label */ 
#line 578
    *((uint32_t *)p) = (uint32_t )0;
#line 579
    p += 4;
#line 580
    goto switch_break;
    case_13: /* CIL Label */ 
    case_9: /* CIL Label */ 
    case_1010: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_9001: /* CIL Label */ 
#line 589
    *((uint8_t *)p) = (uint8_t )0;
#line 590
    p ++;
#line 591
    goto switch_break;
    case_1011: /* CIL Label */ 
    case_17: /* CIL Label */ 
    case_16: /* CIL Label */ 
    case_9002: /* CIL Label */ 
#line 598
    *((uint16_t *)p) = (uint16_t )0;
#line 599
    p += 2;
#line 600
    goto switch_break;
    case_1012: /* CIL Label */ 
    case_15: /* CIL Label */ 
    case_9003: /* CIL Label */ 
#line 606
    *((uint32_t *)p) = (uint32_t )0;
#line 607
    p += 4;
#line 608
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 611
    my_log(2U, "fill(): Unknown format at %x[%d]: %d", format, i, (int )*(format + i));
#line 613
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
#line 481
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 619
  return (p);
}
}
#line 622 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void setuser(void) 
{ 


  {
#line 627
  if (pw) {
    {
#line 628
    setgroups((size_t )0, (__gid_t const   *)((void *)0));
#line 629
    setregid(pw->pw_gid, pw->pw_gid);
#line 630
    setreuid(pw->pw_uid, pw->pw_uid);
    }
  }
#line 632
  return;
}
}
#line 634 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void *emit_thread(void) 
{ 
  struct Flow *flow ;
  void *p ;
  struct timeval now ;
  struct timespec timeout ;
  int i ;
  int ret ;
  int sent ;
  int size ;
  int delay ;
  int peer_rot_cur ;
  int peer_rot_work ;
  int tmp ;
  ssize_t tmp___0 ;
  int tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;

  {
  {
#line 640
  sent = 0;
#line 640
  peer_rot_work = 0;
#line 642
  p = (void *)(& emit_packet) + netflow->HeaderSize;
#line 643
  timeout.tv_nsec = (__syscall_slong_t )0;
#line 645
  setuser();
  }
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 648
    pthread_mutex_lock(& emit_mutex);
    }
    {
#line 649
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 649
      if (! (! flows_emit)) {
#line 649
        goto while_break___0;
      }
      {
#line 650
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )0);
#line 651
      timeout.tv_sec = now.tv_sec + (__time_t )emit_timeout;
#line 653
      tmp = pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& emit_cond),
                                   (pthread_mutex_t */* __restrict  */)(& emit_mutex),
                                   (struct timespec  const  */* __restrict  */)(& timeout));
      }
#line 653
      if (tmp) {
#line 653
        if (emit_count) {
          {
#line 654
          pthread_mutex_unlock(& emit_mutex);
          }
#line 655
          goto sendit;
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 658
    flow = flows_emit;
#line 659
    flows_emit = flows_emit->next;
#line 663
    pthread_mutex_unlock(& emit_mutex);
    }
#line 666
    if (! emit_count) {
      {
#line 667
      gettime(& start_time);
#line 668
      start_time.sec -= start_time_offset;
      }
    }
    {
#line 671
    p = fill((int )netflow->FlowFields, netflow->FlowFormat, flow, p);
#line 672
    mem_free((void *)flow);
#line 673
    emit_count ++;
    }
#line 674
    if (emit_count == netflow->MaxFlows) {
      sendit: 
      {
#line 676
      gettime(& emit_time);
#line 677
      p = fill((int )netflow->HeaderFields, netflow->HeaderFormat, (struct Flow *)0,
               (void *)(& emit_packet));
#line 678
      size = (int )(netflow->HeaderSize + emit_count * netflow->FlowSize);
#line 679
      peer_rot_cur = 0;
#line 680
      i = 0;
      }
      {
#line 680
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 680
        if (! (i < npeers)) {
#line 680
          goto while_break___1;
        }
#line 681
        if ((peers + i)->type == 0) {
#line 681
          goto sendreal;
        }
#line 682
        if ((peers + i)->type == 1) {
#line 683
          tmp___3 = peer_rot_cur;
#line 683
          peer_rot_cur ++;
#line 683
          if (tmp___3 == peer_rot_work) {
            sendreal: 
#line 685
            if (netflow->SeqOffset) {
              {
#line 686
              *((uint32_t *)(emit_packet + netflow->SeqOffset)) = htonl((peers + i)->seq);
              }
            }
            {
#line 687
            tmp___0 = send((peers + i)->sock, (void const   *)(emit_packet), (size_t )size,
                           0);
#line 687
            ret = (int )tmp___0;
#line 700
            (peers + i)->seq += emit_count;
            }
#line 703
            if (emit_rate_bytes) {
#line 704
              sent += size;
#line 705
              delay = (int )((unsigned int )sent / emit_rate_bytes);
#line 706
              if (delay) {
#line 707
                sent = (int )((unsigned int )sent % emit_rate_bytes);
#line 708
                timeout.tv_sec = (__time_t )0;
#line 709
                timeout.tv_nsec = (__syscall_slong_t )(emit_rate_delay * (unsigned int )delay);
                {
#line 710
                while (1) {
                  while_continue___2: /* CIL Label */ ;
                  {
#line 710
                  tmp___1 = nanosleep((struct timespec  const  *)(& timeout), & timeout);
                  }
#line 710
                  if (tmp___1 == -1) {
                    {
#line 710
                    tmp___2 = __errno_location();
                    }
#line 710
                    if (! (*tmp___2 == 4)) {
#line 710
                      goto while_break___2;
                    }
                  } else {
#line 710
                    goto while_break___2;
                  }
                }
                while_break___2: /* CIL Label */ ;
                }
              }
            }
          }
        }
#line 680
        i ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 715
      if (npeers_rot) {
#line 715
        peer_rot_work = (peer_rot_work + 1) % npeers_rot;
      }
#line 716
      emit_sequence += emit_count;
#line 717
      emit_count = 0U;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void *unpending_thread(void) 
{ 
  struct timeval now ;
  struct timespec timeout ;
  int tmp ;

  {
  {
#line 733
  setuser();
#line 735
  timeout.tv_nsec = (__syscall_slong_t )0;
#line 736
  pthread_mutex_lock(& unpending_mutex);
  }
  {
#line 738
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 739
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 739
      if (! (! (pending_tail->flags & 32768))) {
#line 739
        goto while_break___0;
      }
      {
#line 740
      gettimeofday((struct timeval */* __restrict  */)(& now), (__timezone_ptr_t )0);
#line 741
      timeout.tv_sec = now.tv_sec + (__time_t )unpending_timeout;
#line 742
      pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& unpending_cond),
                             (pthread_mutex_t */* __restrict  */)(& unpending_mutex),
                             (struct timespec  const  */* __restrict  */)(& timeout));
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 748
    tmp = put_into(pending_tail, 0);
#line 762
    pending_tail->flags = 0;
#line 763
    pending_tail = pending_tail->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 770 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void *scan_thread(void) 
{ 
  int i ;
  struct Flow *flow ;
  struct Flow **flowpp ;
  struct Time now ;
  struct timespec timeout ;

  {
  {
#line 780
  setuser();
#line 782
  timeout.tv_nsec = (__syscall_slong_t )0;
#line 783
  pthread_mutex_lock(& scan_mutex);
  }
  {
#line 785
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 786
    gettime(& now);
#line 787
    timeout.tv_sec = now.sec + (time_t )scan_interval;
#line 788
    pthread_cond_timedwait((pthread_cond_t */* __restrict  */)(& scan_cond), (pthread_mutex_t */* __restrict  */)(& scan_mutex),
                           (struct timespec  const  */* __restrict  */)(& timeout));
#line 790
    gettime(& now);
#line 794
    i = 0;
    }
    {
#line 794
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 794
      if (! (i < 1 << 16)) {
#line 794
        goto while_break___0;
      }
      {
#line 795
      pthread_mutex_lock(& flows_mutex[i]);
#line 796
      flow = flows[i];
#line 797
      flowpp = & flows[i];
      }
      {
#line 798
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 798
        if (! flow) {
#line 798
          goto while_break___1;
        }
#line 799
        if (flow->flags & 1) {
#line 801
          if (now.sec - flow->mtime.sec > (time_t )frag_lifetime) {
#line 807
            *flowpp = flow->next;
#line 808
            flow->id = (uint16_t )0;
#line 809
            flow->flags &= -2;
#line 810
            flow->next = scan_frag_dreg;
#line 811
            scan_frag_dreg = flow;
#line 812
            flow = *flowpp;
#line 813
            goto while_continue___1;
          }
        } else
#line 817
        if (now.sec - flow->mtime.sec > (time_t )inactive_lifetime) {
#line 817
          goto _L;
        } else
#line 817
        if (flow->mtime.sec - flow->ctime.sec > (time_t )active_lifetime) {
          _L: /* CIL Label */ 
          {
#line 826
          *flowpp = flow->next;
#line 827
          pthread_mutex_lock(& emit_mutex);
#line 828
          flow->next = flows_emit;
#line 829
          flows_emit = flow;
#line 833
          pthread_mutex_unlock(& emit_mutex);
#line 834
          flow = *flowpp;
          }
#line 835
          goto while_continue___1;
        }
#line 838
        flowpp = & flow->next;
#line 839
        flow = flow->next;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 841
      pthread_mutex_unlock(& flows_mutex[i]);
#line 794
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 843
    if (flows_emit) {
      {
#line 843
      pthread_cond_signal(& emit_cond);
      }
    }
    {
#line 845
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 845
      if (! scan_frag_dreg) {
#line 845
        goto while_break___2;
      }
      {
#line 846
      flow = scan_frag_dreg;
#line 847
      scan_frag_dreg = flow->next;
#line 851
      put_into(flow, 1);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
void *cap_thread(void) 
{ 
  struct ulog_packet_msg *ulog_msg ;
  struct ip *nl ;
  void *tl ;
  struct Flow *flow ;
  int len ;
  int off_frag ;
  int psize ;
  ssize_t tmp ;
  char *tmp___0 ;
  uint16_t tmp___1 ;
  uint16_t tmp___2 ;
  uint16_t tmp___3 ;
  uint16_t tmp___4 ;
  uint16_t tmp___5 ;

  {
  {
#line 875
  setuser();
  }
  {
#line 877
  while (1) {
    while_continue: /* CIL Label */ ;
#line 877
    if (! (! killed)) {
#line 877
      goto while_break;
    }
    {
#line 878
    tmp = ipulog_read(ulog_handle, (unsigned char *)cap_buf, (size_t )131072, 1);
#line 878
    len = (int )tmp;
    }
#line 879
    if (len <= 0) {
      {
#line 880
      tmp___0 = ipulog_strerror(ipulog_errno);
#line 880
      my_log(3U, "ipulog_read(): %s", tmp___0);
      }
#line 881
      goto while_continue;
    }
    {
#line 883
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 883
      ulog_msg = ipulog_get_packet(ulog_handle, (unsigned char const   *)cap_buf,
                                   (size_t )len);
      }
#line 883
      if (! ulog_msg) {
#line 883
        goto while_break___0;
      }
#line 889
      nl = (struct ip *)((void *)(& ulog_msg->payload));
#line 890
      psize = (int )ulog_msg->data_len;
#line 893
      if (psize < (int )sizeof(struct ip )) {
#line 901
        goto while_continue___0;
      } else
#line 893
      if (nl->ip_v != 4U) {
#line 901
        goto while_continue___0;
      }
#line 904
      if (pending_head->flags) {
#line 917
        goto done;
      }
      {
#line 924
      flow = pending_head;
#line 927
      tmp___1 = ntohs(nl->ip_len);
#line 927
      flow->size = (unsigned long )tmp___1;
#line 932
      flow->sip = nl->ip_src;
#line 933
      flow->dip = nl->ip_dst;
#line 934
      flow->iif = snmp_index(ulog_msg->indev_name);
#line 935
      flow->oif = snmp_index(ulog_msg->outdev_name);
      }
#line 936
      if (parms[10].count) {
#line 936
        flow->tos = (uint8_t )ulog_msg->mark;
      } else {
#line 936
        flow->tos = nl->ip_tos;
      }
#line 937
      flow->proto = nl->ip_p;
#line 938
      flow->id = (uint16_t )0;
#line 939
      flow->tcp_flags = (uint8_t )0;
#line 940
      flow->pkts = 1UL;
#line 941
      flow->sizeF = 0UL;
#line 942
      flow->sizeP = 0UL;
#line 944
      if (ulog_msg->timestamp_sec) {
#line 945
        flow->ctime.sec = ulog_msg->timestamp_sec;
#line 946
        flow->ctime.usec = ulog_msg->timestamp_usec;
      } else {
        {
#line 947
        gettime(& flow->ctime);
        }
      }
      {
#line 948
      flow->mtime = flow->ctime;
#line 950
      tmp___2 = ntohs(nl->ip_off);
#line 950
      off_frag = ((int )tmp___2 & 8191) << 3;
#line 959
      off_tl = (int )(nl->ip_hl << 2);
#line 960
      tl = (void *)nl + off_tl;
#line 963
      tmp___3 = ntohs(nl->ip_len);
#line 963
      flow->sizeF = (unsigned long )((int )tmp___3 - off_tl);
#line 964
      psize -= off_tl;
      }
#line 965
      if ((int )flow->sizeF < 0) {
#line 965
        flow->sizeF = 0UL;
      }
#line 966
      if (psize > (int )flow->sizeF) {
#line 966
        psize = (int )flow->sizeF;
      }
      {
#line 968
      tmp___5 = ntohs(nl->ip_off);
      }
#line 968
      if ((int )tmp___5 & 16383) {
        {
#line 976
        flow->flags |= 1;
#line 977
        flow->id = nl->ip_id;
#line 979
        tmp___4 = ntohs(nl->ip_off);
        }
#line 979
        if (! ((int )tmp___4 & 8192)) {
#line 981
          flow->flags |= 8;
#line 983
          flow->sizeP = (unsigned long )off_frag + flow->sizeF;
        }
      }
#line 1001
      if (! off_frag) {
#line 1001
        if (psize >= 8) {
          {
#line 1004
          if ((int )flow->proto == 17) {
#line 1004
            goto case_17;
          }
#line 1004
          if ((int )flow->proto == 6) {
#line 1004
            goto case_17;
          }
#line 1010
          if ((int )flow->proto == 1) {
#line 1010
            goto case_1;
          }
#line 1021
          goto switch_default;
          case_17: /* CIL Label */ 
          case_6: /* CIL Label */ 
#line 1005
          flow->sp = ((struct udphdr *)tl)->__annonCompField7.__annonCompField5.uh_sport;
#line 1006
          flow->dp = ((struct udphdr *)tl)->__annonCompField7.__annonCompField5.uh_dport;
#line 1007
          goto tl_known;
          case_1: /* CIL Label */ 
          {
#line 1011
          flow->sp = htons((uint16_t )((struct icmp *)tl)->icmp_type);
#line 1012
          flow->dp = htons((uint16_t )((struct icmp *)tl)->icmp_code);
          }
#line 1013
          goto tl_known;
          switch_default: /* CIL Label */ 
#line 1026
          flow->sp = (uint16_t )0;
#line 1027
          flow->dp = (uint16_t )0;
#line 1028
          goto switch_break;
          tl_known: 
#line 1035
          flow->flags |= 4;
          switch_break: /* CIL Label */ ;
          }
        }
      }
#line 1040
      if ((int )flow->proto == 6) {
#line 1040
        if (off_frag < 16) {
#line 1040
          if (psize >= 16 - off_frag) {
#line 1043
            flow->tcp_flags = *((uint8_t *)((tl + 13) - off_frag));
          }
        }
      }
#line 1064
      pending_head->flags |= 32768;
#line 1065
      pending_head = pending_head->next;
      done: 
      {
#line 1067
      pthread_cond_signal(& unpending_cond);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1070
  return ((void *)0);
}
}
#line 1082
int main(int argc , char **argv ) ;
#line 1082 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
static void *threads[4]  = {      (void *)(& emit_thread),      (void *)(& scan_thread),      (void *)(& unpending_thread),      (void *)(& cap_thread)};
#line 1073 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/fprobe-ulog.c"
int main(int argc , char **argv ) 
{ 
  char errpbuf[512] ;
  char *dhost ;
  char *dport ;
  char *lhost ;
  char *type ;
  char *log_suffix ;
  char *rule ;
  int c ;
  int i ;
  int sock ;
  int memory_limit ;
  struct addrinfo hints ;
  struct addrinfo *res ;
  struct sockaddr_in saddr ;
  pthread_attr_t tattr ;
  struct sigaction sigact ;
  struct timeval timeout ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  void *tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  int *tmp___17 ;
  char *tmp___18 ;
  char const   *tmp___19 ;
  int *tmp___20 ;
  void *tmp___21 ;
  char *tmp___22 ;
  int *tmp___23 ;
  char *tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  int *tmp___28 ;
  char *tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  void *tmp___35 ;
  char *tmp___36 ;
  int *tmp___37 ;
  char *tmp___38 ;
  int tmp___39 ;
  __pid_t tmp___40 ;
  int *tmp___41 ;
  char *tmp___42 ;
  void *tmp___43 ;
  int *tmp___44 ;
  char *tmp___45 ;
  struct Flow *tmp___46 ;
  void *tmp___47 ;
  int tmp___48 ;
  int *tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  int *tmp___52 ;
  char *tmp___53 ;
  int tmp___54 ;
  int tmp___55 ;
  int *tmp___56 ;
  char *tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int *tmp___60 ;
  char *tmp___61 ;
  int tmp___62 ;
  int *tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  int *tmp___66 ;
  char *tmp___67 ;
  int tmp___68 ;
  int *tmp___69 ;
  char *tmp___70 ;
  int tmp___71 ;
  int *tmp___72 ;
  char *tmp___73 ;
  char const   *tmp___74 ;
  char const   *tmp___75 ;
  char const   *tmp___76 ;
  char *tmp___77 ;
  char *tmp___78 ;
  uint16_t tmp___79 ;
  char *tmp___80 ;

  {
  {
#line 1076
  type = (char *)0;
#line 1076
  log_suffix = (char *)0;
#line 1077
  memory_limit = 0;
#line 1085
  sched_min = sched_get_priority_min(1);
#line 1086
  sched_max = sched_get_priority_max(1);
#line 1088
  memset((void *)(& saddr), 0, sizeof(saddr));
#line 1089
  memset((void *)(& hints), 0, sizeof(hints));
#line 1090
  hints.ai_flags = 1;
#line 1091
  hints.ai_family = 2;
#line 1092
  hints.ai_socktype = 2;
#line 1096
  opterr = 0;
  }
  {
#line 1097
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1097
    c = my_getopt(argc, (char * const  *)argv, parms);
    }
#line 1097
    if (! (c != -1)) {
#line 1097
      goto while_break;
    }
    {
#line 1099
    if (c == 63) {
#line 1099
      goto case_63;
    }
#line 1102
    if (c == 104) {
#line 1102
      goto case_104;
    }
#line 1098
    goto switch_break;
    case_63: /* CIL Label */ 
    {
#line 1100
    usage();
    }
    case_104: /* CIL Label */ 
    {
#line 1103
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1107
  if (parms[16].count) {
    {
#line 1107
    tmp = atoi((char const   *)parms[16].arg);
#line 1107
    ulog_gmask = (uint32_t )tmp;
    }
  }
#line 1108
  if (parms[14].count) {
    {
#line 1108
    tmp___0 = atoi((char const   *)parms[14].arg);
#line 1108
    scan_interval = (unsigned int )tmp___0;
    }
  }
#line 1109
  if (parms[6].count) {
    {
#line 1109
    frag_lifetime = atoi((char const   *)parms[6].arg);
    }
  }
#line 1110
  if (parms[4].count) {
    {
#line 1110
    inactive_lifetime = atoi((char const   *)parms[4].arg);
    }
  }
#line 1111
  if (parms[5].count) {
    {
#line 1111
    active_lifetime = atoi((char const   *)parms[5].arg);
    }
  }
#line 1112
  if (parms[11].count) {
    {
#line 1113
    tmp___1 = atoi((char const   *)parms[11].arg);
    }
    {
#line 1114
    if (tmp___1 == 1) {
#line 1114
      goto case_1;
    }
#line 1118
    if (tmp___1 == 5) {
#line 1118
      goto case_5;
    }
#line 1121
    if (tmp___1 == 7) {
#line 1121
      goto case_7;
    }
#line 1125
    goto switch_default;
    case_1: /* CIL Label */ 
#line 1115
    netflow = & NetFlow1;
#line 1116
    goto switch_break___0;
    case_5: /* CIL Label */ 
#line 1119
    goto switch_break___0;
    case_7: /* CIL Label */ 
#line 1122
    netflow = & NetFlow7;
#line 1123
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 1126
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
            "NetFlow version");
#line 1127
    exit(1);
    }
    switch_break___0: /* CIL Label */ ;
    }
  }
#line 1130
  if (parms[18].count) {
    {
#line 1130
    tmp___2 = atoi((char const   *)parms[18].arg);
#line 1130
    verbosity = (unsigned int )tmp___2;
    }
  }
#line 1131
  if (parms[8].count) {
    {
#line 1132
    log_suffix = strchr((char const   *)parms[8].arg, ':');
    }
#line 1132
    if (log_suffix) {
#line 1133
      tmp___3 = log_suffix;
#line 1133
      log_suffix ++;
#line 1133
      *tmp___3 = (char)0;
#line 1134
      if (*log_suffix) {
        {
#line 1135
        sprintf((char */* __restrict  */)(errpbuf), (char const   */* __restrict  */)"[%s]",
                log_suffix);
#line 1136
        strcat((char */* __restrict  */)(ident), (char const   */* __restrict  */)(errpbuf));
        }
      }
    }
#line 1139
    if (*(parms[8].arg)) {
      {
#line 1139
      tmp___4 = atoi((char const   *)parms[8].arg);
#line 1139
      log_dest = (unsigned int )tmp___4;
      }
    }
#line 1140
    if (log_suffix) {
#line 1140
      log_suffix --;
#line 1140
      *log_suffix = (char )':';
    }
  }
  {
#line 1142
  tmp___7 = strlen((char const   *)(ident));
#line 1142
  tmp___8 = malloc(((((sizeof("/var/run") + 1UL) + tmp___7) + 1UL) + 3UL) + 1UL);
#line 1142
  pidfilepath = (char *)tmp___8;
  }
#line 1142
  if (! pidfilepath) {
    err_malloc: 
    {
#line 1144
    tmp___5 = __errno_location();
#line 1144
    tmp___6 = strerror(*tmp___5);
#line 1144
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"malloc(): %s\n",
            tmp___6);
#line 1145
    exit(1);
    }
  }
  {
#line 1147
  sprintf((char */* __restrict  */)pidfilepath, (char const   */* __restrict  */)"%s/%s.pid",
          "/var/run", ident);
  }
#line 1148
  if (parms[12].count) {
    {
#line 1149
    tmp___9 = atoi((char const   *)parms[12].arg);
#line 1149
    pending_queue_length = (unsigned int )tmp___9;
    }
#line 1150
    if (pending_queue_length < 1U) {
      {
#line 1151
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
              "pending queue length");
#line 1152
      exit(1);
      }
    }
  }
#line 1155
  if (parms[13].count) {
    {
#line 1156
    schedp.__sched_priority = atoi((char const   *)parms[13].arg);
    }
#line 1157
    if (schedp.__sched_priority) {
#line 1157
      if (schedp.__sched_priority < sched_min) {
        {
#line 1160
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
                "realtime priority");
#line 1161
        exit(1);
        }
      } else
#line 1157
      if (schedp.__sched_priority > sched_max) {
        {
#line 1160
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
                "realtime priority");
#line 1161
        exit(1);
        }
      }
    }
  }
#line 1164
  if (parms[1].count) {
    {
#line 1165
    tmp___10 = atoi((char const   *)parms[1].arg);
#line 1165
    sockbufsize = tmp___10 << 10;
    }
  }
#line 1167
  if (parms[2].count) {
    {
#line 1168
    tmp___11 = atoi((char const   *)parms[2].arg);
#line 1168
    bulk_quantity = (unsigned int )tmp___11;
    }
#line 1169
    if (bulk_quantity < 1U) {
      {
#line 1170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
              "bulk size");
#line 1171
      exit(1);
      }
    } else
#line 1169
    if (bulk_quantity > (unsigned int )((mem_index_t )-1)) {
      {
#line 1170
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
              "bulk size");
#line 1171
      exit(1);
      }
    }
  }
#line 1174
  if (parms[9].count) {
    {
#line 1174
    tmp___12 = atoi((char const   *)parms[9].arg);
#line 1174
    memory_limit = tmp___12 << 10;
    }
  }
#line 1175
  if (parms[19].count) {
#line 1176
    i = 0;
    {
#line 1176
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1176
      if (! *(parms[19].arg + i)) {
#line 1176
        goto while_break___0;
      }
#line 1177
      if ((int )*(parms[19].arg + i) == 58) {
#line 1177
        nsnmp_rules ++;
      }
#line 1176
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1178
    tmp___13 = malloc((unsigned long )nsnmp_rules * sizeof(struct snmp_rule ));
#line 1178
    snmp_rules = (struct snmp_rule *)tmp___13;
    }
#line 1178
    if (! snmp_rules) {
#line 1179
      goto err_malloc;
    }
    {
#line 1180
    rule = strtok((char */* __restrict  */)parms[19].arg, (char const   */* __restrict  */)":");
#line 1181
    i = 0;
    }
    {
#line 1181
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1181
      if (! rule) {
#line 1181
        goto while_break___1;
      }
      {
#line 1182
      tmp___14 = strlen((char const   *)rule);
#line 1182
      (snmp_rules + i)->len = (int )tmp___14;
      }
#line 1183
      if ((snmp_rules + i)->len > 16) {
        {
#line 1184
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
                "interface basename");
#line 1185
        exit(1);
        }
      }
      {
#line 1187
      strncpy((char */* __restrict  */)((snmp_rules + i)->basename), (char const   */* __restrict  */)rule,
              (size_t )(snmp_rules + i)->len);
      }
#line 1188
      if (! *(rule - 1)) {
#line 1188
        *(rule - 1) = (char )',';
      }
      {
#line 1189
      rule = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)",");
      }
#line 1190
      if (! rule) {
        {
#line 1191
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
                "SNMP rule");
#line 1192
        exit(1);
        }
      }
      {
#line 1194
      (snmp_rules + i)->base = atoi((char const   *)rule);
#line 1195
      *(rule - 1) = (char )':';
#line 1196
      rule = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)":");
#line 1181
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1198
    nsnmp_rules = i;
  }
#line 1200
  if (parms[15].count) {
    {
#line 1201
    sscanf((char const   */* __restrict  */)parms[15].arg, (char const   */* __restrict  */)"%d:%d",
           & emit_rate_bytes, & emit_rate_delay);
    }
  }
#line 1202
  if (parms[0].count) {
    {
#line 1203
    tmp___15 = getaddrinfo((char const   */* __restrict  */)parms[0].arg, (char const   */* __restrict  */)0,
                           (struct addrinfo  const  */* __restrict  */)(& hints),
                           (struct addrinfo **/* __restrict  */)(& res));
    }
#line 1203
    if (tmp___15) {
      bad_lhost: 
      {
#line 1205
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Illegal %s\n",
              "source address");
#line 1206
      exit(1);
      }
    } else {
      {
#line 1208
      saddr = *((struct sockaddr_in *)res->ai_addr);
#line 1209
      freeaddrinfo(res);
      }
    }
  }
#line 1212
  if (parms[17].count) {
    {
#line 1213
    pw = getpwnam((char const   *)parms[17].arg);
    }
#line 1213
    if ((unsigned long )pw == (unsigned long )((void *)0)) {
      {
#line 1214
      tmp___20 = __errno_location();
      }
#line 1214
      if (*tmp___20) {
        {
#line 1214
        tmp___17 = __errno_location();
#line 1214
        tmp___18 = strerror(*tmp___17);
#line 1214
        tmp___19 = (char const   *)tmp___18;
        }
      } else {
#line 1214
        tmp___19 = "Unknown user";
      }
      {
#line 1214
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"getpwnam(%s): %s\n",
              parms[17].arg, tmp___19);
#line 1215
      exit(1);
      }
    }
  }
#line 1221
  npeers = argc - optind;
#line 1222
  if (npeers < 1) {
    {
#line 1222
    usage();
    }
  }
  {
#line 1223
  tmp___21 = malloc((unsigned long )npeers * sizeof(struct peer ));
#line 1223
  peers = (struct peer *)tmp___21;
  }
#line 1223
  if (! peers) {
#line 1223
    goto err_malloc;
  }
#line 1224
  i = optind;
#line 1224
  npeers = 0;
  {
#line 1224
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1224
    if (! (i < argc)) {
#line 1224
      goto while_break___2;
    }
    {
#line 1225
    dhost = *(argv + i);
#line 1226
    dport = strchr((char const   *)dhost, ':');
    }
#line 1226
    if (! dport) {
#line 1226
      goto bad_collector;
    }
    {
#line 1227
    tmp___22 = dport;
#line 1227
    dport ++;
#line 1227
    *tmp___22 = (char)0;
#line 1228
    sock = socket(2, 2, 0);
    }
#line 1228
    if (sock < 0) {
      {
#line 1229
      tmp___23 = __errno_location();
#line 1229
      tmp___24 = strerror(*tmp___23);
#line 1229
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"socket(): %s\n",
              tmp___24);
#line 1230
      exit(1);
      }
    }
    {
#line 1232
    (peers + npeers)->sock = sock;
#line 1233
    (peers + npeers)->type = 0;
#line 1234
    (peers + npeers)->laddr = saddr;
#line 1235
    (peers + npeers)->seq = (uint32_t )0;
#line 1236
    lhost = strchr((char const   *)dport, '/');
    }
#line 1236
    if (lhost) {
      {
#line 1237
      tmp___25 = lhost;
#line 1237
      lhost ++;
#line 1237
      *tmp___25 = (char)0;
#line 1238
      type = strchr((char const   *)lhost, '/');
      }
#line 1238
      if (type) {
#line 1239
        tmp___26 = type;
#line 1239
        type ++;
#line 1239
        *tmp___26 = (char)0;
        {
#line 1242
        if ((int )*type == 109) {
#line 1242
          goto case_109;
        }
#line 1242
        if ((int )*type == 0) {
#line 1242
          goto case_109;
        }
#line 1245
        if ((int )*type == 114) {
#line 1245
          goto case_114;
        }
#line 1250
        goto switch_default___0;
        case_109: /* CIL Label */ 
        case_0: /* CIL Label */ 
#line 1243
        goto switch_break___1;
        case_114: /* CIL Label */ 
#line 1246
        (peers + npeers)->type = 1;
#line 1247
        npeers_rot ++;
#line 1248
        goto switch_break___1;
        switch_default___0: /* CIL Label */ 
#line 1251
        goto bad_collector;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 1254
      if (*lhost) {
        {
#line 1255
        tmp___27 = getaddrinfo((char const   */* __restrict  */)lhost, (char const   */* __restrict  */)0,
                               (struct addrinfo  const  */* __restrict  */)(& hints),
                               (struct addrinfo **/* __restrict  */)(& res));
        }
#line 1255
        if (tmp___27) {
#line 1255
          goto bad_lhost;
        }
        {
#line 1256
        (peers + npeers)->laddr = *((struct sockaddr_in *)res->ai_addr);
#line 1257
        freeaddrinfo(res);
        }
      }
    }
    {
#line 1260
    tmp___30 = bind(sock, (struct sockaddr  const  *)((struct sockaddr *)(& (peers + npeers)->laddr)),
                    (socklen_t )sizeof(struct sockaddr_in ));
    }
#line 1260
    if (tmp___30) {
      {
#line 1262
      tmp___28 = __errno_location();
#line 1262
      tmp___29 = strerror(*tmp___28);
#line 1262
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bind(): %s\n",
              tmp___29);
#line 1263
      exit(1);
      }
    }
    {
#line 1265
    tmp___31 = getaddrinfo((char const   */* __restrict  */)dhost, (char const   */* __restrict  */)dport,
                           (struct addrinfo  const  */* __restrict  */)(& hints),
                           (struct addrinfo **/* __restrict  */)(& res));
    }
#line 1265
    if (tmp___31) {
      bad_collector: 
      {
#line 1267
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Error in collector #%d parameters\n",
              npeers + 1);
#line 1268
      exit(1);
      }
    }
    {
#line 1270
    (peers + npeers)->addr = *((struct sockaddr_in *)res->ai_addr);
#line 1271
    freeaddrinfo(res);
#line 1272
    tmp___34 = connect(sock, (struct sockaddr  const  *)((struct sockaddr *)(& (peers + npeers)->addr)),
                       (socklen_t )sizeof(struct sockaddr_in ));
    }
#line 1272
    if (tmp___34) {
      {
#line 1274
      tmp___32 = __errno_location();
#line 1274
      tmp___33 = strerror(*tmp___32);
#line 1274
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"connect(): %s\n",
              tmp___33);
#line 1275
      exit(1);
      }
    }
#line 1279
    if (type) {
#line 1279
      type --;
#line 1279
      *type = (char )'/';
    }
#line 1280
    if (lhost) {
#line 1280
      lhost --;
#line 1280
      *lhost = (char )'/';
    }
#line 1281
    dport --;
#line 1281
    *dport = (char )':';
#line 1224
    i ++;
#line 1224
    npeers ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1284
  tmp___35 = malloc((size_t )131072);
#line 1284
  cap_buf = (char *)tmp___35;
  }
#line 1284
  if (! cap_buf) {
#line 1284
    goto err_malloc;
  }
  {
#line 1285
  ulog_handle = ipulog_create_handle(ulog_gmask, (u_int32_t )131072);
  }
#line 1286
  if (! ulog_handle) {
    {
#line 1287
    tmp___36 = ipulog_strerror(ipulog_errno);
#line 1287
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"libipulog initialization error: %s",
            tmp___36);
#line 1289
    exit(1);
    }
  }
#line 1291
  if (sockbufsize) {
    {
#line 1292
    tmp___39 = setsockopt(ulog_handle->fd, 1, 8, (void const   *)(& sockbufsize),
                          (socklen_t )sizeof(sockbufsize));
    }
#line 1292
    if (tmp___39 < 0) {
      {
#line 1294
      tmp___37 = __errno_location();
#line 1294
      tmp___38 = strerror(*tmp___37);
#line 1294
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"setsockopt(): %s",
              tmp___38);
      }
    }
  }
  {
#line 1298
  my_log_open(ident, verbosity, log_dest);
  }
#line 1299
  if (! (log_dest & 2U)) {
    {
#line 1300
    tmp___40 = fork();
    }
    {
#line 1301
    if (tmp___40 == -1) {
#line 1301
      goto case_neg_1;
    }
#line 1305
    if (tmp___40 == 0) {
#line 1305
      goto case_0___0;
    }
#line 1312
    goto switch_default___1;
    case_neg_1: /* CIL Label */ 
    {
#line 1302
    tmp___41 = __errno_location();
#line 1302
    tmp___42 = strerror(*tmp___41);
#line 1302
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fork(): %s",
            tmp___42);
#line 1303
    exit(1);
    }
    case_0___0: /* CIL Label */ 
    {
#line 1306
    setsid();
#line 1307
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"r",
            (FILE */* __restrict  */)stdin);
#line 1308
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            (FILE */* __restrict  */)stdout);
#line 1309
    freopen((char const   */* __restrict  */)"/dev/null", (char const   */* __restrict  */)"w",
            (FILE */* __restrict  */)stderr);
    }
#line 1310
    goto switch_break___2;
    switch_default___1: /* CIL Label */ 
    {
#line 1313
    exit(0);
    }
    switch_break___2: /* CIL Label */ ;
    }
  } else {
    {
#line 1316
    setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)((char *)0),
            2, (size_t )0);
#line 1317
    setvbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)((char *)0),
            2, (size_t )0);
    }
  }
  {
#line 1320
  pid = getpid();
#line 1321
  sprintf((char */* __restrict  */)(errpbuf), (char const   */* __restrict  */)"[%ld]",
          (long )pid);
#line 1322
  strcat((char */* __restrict  */)(ident), (char const   */* __restrict  */)(errpbuf));
#line 1326
  hash_init();
#line 1327
  mem_init((unsigned int )sizeof(struct Flow ), bulk_quantity, (unsigned int )memory_limit);
#line 1328
  i = 0;
  }
  {
#line 1328
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1328
    if (! (i < 1 << 16)) {
#line 1328
      goto while_break___3;
    }
    {
#line 1328
    pthread_mutex_init(& flows_mutex[i], (pthread_mutexattr_t const   *)0);
#line 1328
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1332
  start_time_offset = (long )(1 << 20);
#line 1336
  gettime(& start_time);
#line 1341
  tmp___43 = mem_alloc();
#line 1341
  pending_head = (struct Flow *)tmp___43;
  }
#line 1341
  if (! pending_head) {
#line 1341
    goto err_mem_alloc;
  }
#line 1342
  pending_tail = pending_head;
#line 1343
  i = (int )(pending_queue_length - 1U);
  {
#line 1343
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 1343
    tmp___48 = i;
#line 1343
    i --;
#line 1343
    if (! tmp___48) {
#line 1343
      goto while_break___4;
    }
    {
#line 1344
    tmp___47 = mem_alloc();
#line 1344
    tmp___46 = (struct Flow *)tmp___47;
#line 1344
    pending_tail->next = tmp___46;
    }
#line 1344
    if (! tmp___46) {
      err_mem_alloc: 
      {
#line 1346
      tmp___44 = __errno_location();
#line 1346
      tmp___45 = strerror(*tmp___44);
#line 1346
      my_log(2U, "mem_alloc(): %s", tmp___45);
#line 1347
      exit(1);
      }
    }
#line 1349
    pending_tail = pending_tail->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 1351
  pending_tail->next = pending_head;
#line 1352
  pending_tail = pending_head;
#line 1354
  sigemptyset(& sig_mask);
#line 1355
  sigact.__sigaction_handler.sa_handler = & sighandler;
#line 1356
  sigact.sa_mask = sig_mask;
#line 1357
  sigact.sa_flags = 0;
#line 1358
  sigaddset(& sig_mask, 15);
#line 1359
  sigaction(15, (struct sigaction  const  */* __restrict  */)(& sigact), (struct sigaction */* __restrict  */)0);
#line 1364
  tmp___51 = pthread_sigmask(0, (__sigset_t const   */* __restrict  */)(& sig_mask),
                             (__sigset_t */* __restrict  */)0);
  }
#line 1364
  if (tmp___51) {
    {
#line 1365
    tmp___49 = __errno_location();
#line 1365
    tmp___50 = strerror(*tmp___49);
#line 1365
    my_log(2U, "pthread_sigmask(): %s", tmp___50);
#line 1366
    exit(1);
    }
  }
  {
#line 1369
  my_log(6U, "Starting %s...", "1.1");
  }
#line 1371
  if (parms[3].count) {
    {
#line 1372
    tmp___54 = chdir((char const   *)parms[3].arg);
    }
#line 1372
    if (tmp___54) {
      {
#line 1373
      tmp___52 = __errno_location();
#line 1373
      tmp___53 = strerror(*tmp___52);
#line 1373
      my_log(2U, "could not chroot to %s: %s", parms[3].arg, tmp___53);
#line 1374
      exit(1);
      }
    } else {
      {
#line 1372
      tmp___55 = chroot(".");
      }
#line 1372
      if (tmp___55) {
        {
#line 1373
        tmp___52 = __errno_location();
#line 1373
        tmp___53 = strerror(*tmp___52);
#line 1373
        my_log(2U, "could not chroot to %s: %s", parms[3].arg, tmp___53);
#line 1374
        exit(1);
        }
      }
    }
  }
  {
#line 1378
  schedp.__sched_priority = (schedp.__sched_priority - 5) + 2;
#line 1379
  pthread_attr_init(& tattr);
#line 1380
  i = 0;
  }
  {
#line 1380
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1380
    if (! (i < 4)) {
#line 1380
      goto while_break___5;
    }
#line 1381
    if (schedp.__sched_priority > 0) {
      {
#line 1382
      tmp___58 = pthread_attr_setschedpolicy(& tattr, 1);
      }
#line 1382
      if (tmp___58) {
        {
#line 1384
        tmp___56 = __errno_location();
#line 1384
        tmp___57 = strerror(*tmp___56);
#line 1384
        my_log(2U, "pthread_attr_setschedpolicy(): %s", tmp___57);
#line 1385
        exit(1);
        }
      } else {
        {
#line 1382
        tmp___59 = pthread_attr_setschedparam((pthread_attr_t */* __restrict  */)(& tattr),
                                              (struct sched_param  const  */* __restrict  */)(& schedp));
        }
#line 1382
        if (tmp___59) {
          {
#line 1384
          tmp___56 = __errno_location();
#line 1384
          tmp___57 = strerror(*tmp___56);
#line 1384
          my_log(2U, "pthread_attr_setschedpolicy(): %s", tmp___57);
#line 1385
          exit(1);
          }
        }
      }
    }
    {
#line 1388
    tmp___62 = pthread_create((pthread_t */* __restrict  */)(& thid), (pthread_attr_t const   */* __restrict  */)(& tattr),
                              (void *(*)(void * ))threads[i], (void */* __restrict  */)0);
    }
#line 1388
    if (tmp___62) {
      {
#line 1389
      tmp___60 = __errno_location();
#line 1389
      tmp___61 = strerror(*tmp___60);
#line 1389
      my_log(2U, "pthread_create(): %s", tmp___61);
#line 1390
      exit(1);
      }
    }
    {
#line 1392
    pthread_detach(thid);
#line 1393
    (schedp.__sched_priority) ++;
#line 1380
    i ++;
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1396
  if (pw) {
    {
#line 1397
    tmp___65 = setgroups((size_t )0, (__gid_t const   *)((void *)0));
    }
#line 1397
    if (tmp___65) {
      {
#line 1398
      tmp___63 = __errno_location();
#line 1398
      tmp___64 = strerror(*tmp___63);
#line 1398
      my_log(2U, "setgroups(): %s", tmp___64);
#line 1399
      exit(1);
      }
    }
    {
#line 1401
    tmp___68 = setregid(pw->pw_gid, pw->pw_gid);
    }
#line 1401
    if (tmp___68) {
      {
#line 1402
      tmp___66 = __errno_location();
#line 1402
      tmp___67 = strerror(*tmp___66);
#line 1402
      my_log(2U, "setregid(%u): %s", pw->pw_gid, tmp___67);
#line 1403
      exit(1);
      }
    }
    {
#line 1405
    tmp___71 = setreuid(pw->pw_uid, pw->pw_uid);
    }
#line 1405
    if (tmp___71) {
      {
#line 1406
      tmp___69 = __errno_location();
#line 1406
      tmp___70 = strerror(*tmp___69);
#line 1406
      my_log(2U, "setreuid(%u): %s", pw->pw_uid, tmp___70);
#line 1407
      exit(1);
      }
    }
  }
  {
#line 1411
  pidfile = fopen((char const   */* __restrict  */)pidfilepath, (char const   */* __restrict  */)"w");
  }
#line 1411
  if (pidfile) {
    {
#line 1414
    fprintf((FILE */* __restrict  */)pidfile, (char const   */* __restrict  */)"%ld\n",
            (long )pid);
#line 1415
    fclose(pidfile);
    }
  } else {
    {
#line 1412
    tmp___72 = __errno_location();
#line 1412
    tmp___73 = strerror(*tmp___72);
#line 1412
    my_log(3U, "Can\'t create pid file. fopen(): %s", tmp___73);
    }
  }
  {
#line 1418
  my_log(6U, "pid: %d", pid);
  }
#line 1419
  if (log_suffix) {
#line 1419
    tmp___74 = (char const   *)log_suffix;
  } else {
#line 1419
    tmp___74 = "";
  }
#line 1419
  if (parms[17].count) {
#line 1419
    tmp___75 = (char const   *)parms[17].arg;
  } else {
#line 1419
    tmp___75 = "";
  }
#line 1419
  if (parms[3].count) {
#line 1419
    tmp___76 = (char const   *)parms[3].arg;
  } else {
#line 1419
    tmp___76 = "";
  }
  {
#line 1419
  tmp___77 = inet_ntoa(saddr.sin_addr);
#line 1419
  my_log(6U, "options: u=%u s=%u g=%u d=%u e=%u n=%u a=%s M=%d b=%u m=%u q=%u B=%u r=%u t=%u:%u c=%s u=%s v=%u l=%u%s",
         ulog_gmask, scan_interval, frag_lifetime, inactive_lifetime, active_lifetime,
         netflow->Version, tmp___77, parms[10].count, bulk_quantity, memory_limit >> 10,
         pending_queue_length, sockbufsize >> 10, schedp.__sched_priority - 1, emit_rate_bytes,
         emit_rate_delay, tmp___76, tmp___75, verbosity, log_dest, tmp___74);
#line 1426
  i = 0;
  }
  {
#line 1426
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1426
    if (! (i < nsnmp_rules)) {
#line 1426
      goto while_break___6;
    }
    {
#line 1427
    my_log(6U, "SNMP rule #%d %s:%d", i + 1, (snmp_rules + i)->basename, (snmp_rules + i)->base);
#line 1426
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 1430
  i = 0;
  {
#line 1430
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1430
    if (! (i < npeers)) {
#line 1430
      goto while_break___7;
    }
    {
#line 1432
    if ((peers + i)->type == 0) {
#line 1432
      goto case_0___1;
    }
#line 1435
    if ((peers + i)->type == 1) {
#line 1435
      goto case_1___0;
    }
#line 1431
    goto switch_break___3;
    case_0___1: /* CIL Label */ 
#line 1433
    c = 'm';
#line 1434
    goto switch_break___3;
    case_1___0: /* CIL Label */ 
#line 1436
    c = 'r';
#line 1437
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
    {
#line 1439
    tmp___78 = inet_ntoa((peers + i)->laddr.sin_addr);
#line 1439
    snprintf((char */* __restrict  */)(errpbuf), sizeof(errpbuf), (char const   */* __restrict  */)"%s",
             tmp___78);
#line 1440
    tmp___79 = ntohs((peers + i)->addr.sin_port);
#line 1440
    tmp___80 = inet_ntoa((peers + i)->addr.sin_addr);
#line 1440
    my_log(6U, "collector #%d: %s:%u/%s/%c", i + 1, tmp___80, (int )tmp___79, errpbuf,
           c);
#line 1430
    i ++;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1444
  pthread_sigmask(1, (__sigset_t const   */* __restrict  */)(& sig_mask), (__sigset_t */* __restrict  */)0);
#line 1446
  timeout.tv_usec = (__suseconds_t )0;
  }
  {
#line 1447
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 1447
    if (! (! killed)) {
#line 1447
      if (! ((total_elements - free_elements) - pending_queue_length)) {
#line 1447
        if (! emit_count) {
#line 1447
          if (! pending_tail->flags) {
#line 1447
            goto while_break___8;
          }
        }
      }
    }
#line 1452
    if (! sigs) {
      {
#line 1453
      timeout.tv_sec = (__time_t )scan_interval;
#line 1454
      select(0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0, (fd_set */* __restrict  */)0,
             (struct timeval */* __restrict  */)(& timeout));
      }
    }
#line 1457
    if (sigs & 2) {
#line 1457
      if (! killed) {
        {
#line 1458
        sigs &= -3;
#line 1459
        my_log(6U, "SIGTERM received. Emitting flows cache...");
#line 1460
        scan_interval = 1U;
#line 1461
        frag_lifetime = -1;
#line 1462
        active_lifetime = -1;
#line 1463
        inactive_lifetime = -1;
#line 1464
        emit_timeout = 1;
#line 1465
        unpending_timeout = 1;
#line 1466
        killed = 1;
#line 1467
        pthread_cond_signal(& scan_cond);
#line 1468
        pthread_cond_signal(& unpending_cond);
        }
      }
    }
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 1478
  remove((char const   *)pidfilepath);
#line 1482
  my_log(6U, "Done.");
  }
#line 1484
  return (0);
}
}
#line 709 "/usr/include/stdio.h"
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 374 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 376
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) srand)(unsigned int __seed ) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 48 "./hash.h"
uint16_t crc16(uint16_t crc , uint8_t val ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/hash.c"
static uint16_t crc16_poly  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/hash.c"
static uint8_t shuffle_table[256]  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/hash.c"
static uint16_t crc16_table[256]  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/hash.c"
uint16_t crc16(uint16_t crc , uint8_t val ) 
{ 
  int i ;
  int tmp ;

  {
#line 30
  crc = (uint16_t )((int )crc ^ ((int )val << 8));
#line 31
  i = 8;
  {
#line 31
  while (1) {
    while_continue: /* CIL Label */ ;
#line 31
    tmp = i;
#line 31
    i --;
#line 31
    if (! tmp) {
#line 31
      goto while_break;
    }
#line 32
    if ((int )crc & 32768) {
#line 32
      crc = (uint16_t )(((int )crc << 1) ^ (int )crc16_poly);
    } else {
#line 32
      crc = (uint16_t )((int )crc << 1);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 33
  return (crc);
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/hash.c"
hash_t hash(void *p , int size ) 
{ 
  hash_t hash___0 ;
  void *tmp ;
  int tmp___0 ;

  {
#line 44
  hash___0 = (hash_t )0;
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
#line 51
    tmp___0 = size;
#line 51
    size --;
#line 51
    if (! tmp___0) {
#line 51
      goto while_break;
    }
#line 59
    tmp = p;
#line 59
    p ++;
#line 59
    hash___0 = (hash_t )((int )crc16_table[(int )shuffle_table[*((uint8_t *)tmp)] ^ ((int )hash___0 >> 8)] ^ ((int )hash___0 << 8));
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  return (hash___0);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/hash.c"
void hash_init(void) 
{ 
  int rnd ;
  int i ;
  int j ;
  int m ;
  FILE *rnddev ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  time_t tmp___2 ;
  __pid_t tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 73
  rnddev = fopen((char const   */* __restrict  */)"/dev/random", (char const   */* __restrict  */)"r");
  }
#line 73
  if (rnddev) {
    {
#line 74
    tmp = fileno(rnddev);
#line 74
    tmp___0 = fcntl(tmp, 3);
#line 74
    tmp___1 = fileno(rnddev);
#line 74
    fcntl(tmp___1, 4, tmp___0 | 2048);
#line 76
    fread((void */* __restrict  */)(& rnd), sizeof(rnd), (size_t )1, (FILE */* __restrict  */)rnddev);
#line 77
    fclose(rnddev);
    }
  }
  {
#line 79
  tmp___2 = time((time_t *)((void *)0));
#line 79
  tmp___3 = getpid();
#line 79
  srand((unsigned int )((tmp___2 ^ (long )tmp___3) ^ (long )rnd));
#line 80
  tmp___4 = rand();
#line 80
  crc16_poly = (uint16_t )(tmp___4 | 1);
#line 82
  i = 0;
  }
  {
#line 82
  while (1) {
    while_continue: /* CIL Label */ ;
#line 82
    if (! (i < 256)) {
#line 82
      goto while_break;
    }
    {
#line 83
    crc16_table[i] = crc16((uint16_t )0, (uint8_t )i);
#line 84
    shuffle_table[i] = (uint8_t )i;
#line 82
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 87
  i = 0;
  {
#line 87
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 87
    if (! (i < 256)) {
#line 87
      goto while_break___0;
    }
    {
#line 88
    tmp___5 = rand();
#line 88
    j = (int )((256.0 * (double )tmp___5) / ((double )2147483647 + 1.0));
#line 89
    m = (int )shuffle_table[i];
#line 90
    shuffle_table[i] = shuffle_table[j];
#line 91
    shuffle_table[j] = (uint8_t )m;
#line 87
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 94
  return;
}
}
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_getopt.c"
static int flag  =    0;
#line 27 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_getopt.c"
static int my_opterr  =    1;
#line 28 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_getopt.c"
static char optstring[4096]  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_getopt.c"
int my_getopt(int argc , char * const  *argv , struct getopt_parms *parms___0 ) 
{ 
  int c ;
  int i ;
  int p ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 30
  tmp___1 = flag;
#line 30
  flag ++;
#line 30
  if (tmp___1 == 0) {
#line 31
    p = 0;
#line 31
    i = 0;
    {
#line 32
    while (1) {
      while_continue: /* CIL Label */ ;
#line 32
      if ((int )(parms___0 + i)->name != 0) {
#line 32
        if (! (p < 4095)) {
#line 32
          goto while_break;
        }
      } else {
#line 32
        goto while_break;
      }
#line 33
      tmp = p;
#line 33
      p ++;
#line 33
      optstring[tmp] = (parms___0 + i)->name;
#line 34
      if ((parms___0 + i)->flag & 1) {
#line 34
        tmp___0 = p;
#line 34
        p ++;
#line 34
        optstring[tmp___0] = (char )':';
      }
#line 35
      optstring[p] = (char)0;
#line 36
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 38
    flag = 1;
  }
  {
#line 41
  c = getopt(argc, argv, (char const   *)(optstring));
  }
  {
#line 43
  if (c == 63) {
#line 43
    goto case_63;
  }
#line 47
  if (c == -1) {
#line 47
    goto case_neg_1;
  }
#line 59
  goto switch_default;
  case_63: /* CIL Label */ 
#line 44
  if (my_opterr) {
    {
#line 44
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong parameters\n");
    }
  }
#line 45
  goto switch_break;
  case_neg_1: /* CIL Label */ 
#line 48
  flag = 0;
#line 49
  i = 0;
  {
#line 50
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 50
    if (! ((int )(parms___0 + i)->name != 0)) {
#line 50
      goto while_break___0;
    }
#line 51
    if ((parms___0 + i)->flag & 2) {
#line 51
      if ((parms___0 + i)->count == 0) {
#line 52
        if (my_opterr) {
          {
#line 52
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing required option\n");
          }
        }
#line 53
        return ('?');
      }
    }
#line 55
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 57
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 60
  i = 0;
  {
#line 61
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 61
    if ((int )(parms___0 + i)->name != 0) {
#line 61
      if (! ((int )(parms___0 + i)->name != c)) {
#line 61
        goto while_break___1;
      }
    } else {
#line 61
      goto while_break___1;
    }
#line 62
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 64
  if ((parms___0 + i)->flag & 1) {
#line 65
    if ((unsigned long )optarg == (unsigned long )((char *)0)) {
#line 66
      if (my_opterr) {
        {
#line 66
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option `-%c\': %s\n",
                c, "require parameter");
        }
      }
#line 68
      return ('?');
    } else {
#line 69
      (parms___0 + i)->arg = optarg;
    }
  }
#line 71
  ((parms___0 + i)->count) ++;
#line 71
  if ((parms___0 + i)->count > 1) {
#line 71
    if (! ((parms___0 + i)->flag & 4)) {
#line 72
      if (my_opterr) {
        {
#line 72
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option `-%c\': %s\n",
                c, "repeat not allowed");
        }
      }
#line 74
      return ('?');
    }
  }
#line 76
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 78
  return (c);
}
}
#line 14 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
static uint16_t NetFlow1_Header[5]  = {      (uint16_t )1001,      (uint16_t )1002,      (uint16_t )1003,      (uint16_t )1004, 
        (uint16_t )1005};
#line 22 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
static uint16_t NetFlow1_Flow[19]  = 
#line 22
  {      (uint16_t )8,      (uint16_t )12,      (uint16_t )15,      (uint16_t )10, 
        (uint16_t )14,      (uint16_t )2,      (uint16_t )1,      (uint16_t )22, 
        (uint16_t )21,      (uint16_t )7,      (uint16_t )11,      (uint16_t )9002, 
        (uint16_t )4,      (uint16_t )5,      (uint16_t )6,      (uint16_t )9001, 
        (uint16_t )9001,      (uint16_t )9001,      (uint16_t )9003};
#line 42 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
static uint16_t NetFlow5_Header[9]  = 
#line 42
  {      (uint16_t )1001,      (uint16_t )1002,      (uint16_t )1003,      (uint16_t )1004, 
        (uint16_t )1005,      (uint16_t )1006,      (uint16_t )38,      (uint16_t )39, 
        (uint16_t )9002};
#line 54 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
static uint16_t NetFlow5_Flow[20]  = 
#line 54
  {      (uint16_t )8,      (uint16_t )12,      (uint16_t )15,      (uint16_t )10, 
        (uint16_t )14,      (uint16_t )2,      (uint16_t )1,      (uint16_t )22, 
        (uint16_t )21,      (uint16_t )7,      (uint16_t )11,      (uint16_t )9001, 
        (uint16_t )6,      (uint16_t )4,      (uint16_t )5,      (uint16_t )16, 
        (uint16_t )17,      (uint16_t )9,      (uint16_t )13,      (uint16_t )9002};
#line 77 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
static uint16_t NetFlow7_Header[7]  = {      (uint16_t )1001,      (uint16_t )1002,      (uint16_t )1003,      (uint16_t )1004, 
        (uint16_t )1005,      (uint16_t )1006,      (uint16_t )9003};
#line 87 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
static uint16_t NetFlow7_Flow[21]  = 
#line 87
  {      (uint16_t )8,      (uint16_t )12,      (uint16_t )15,      (uint16_t )10, 
        (uint16_t )14,      (uint16_t )2,      (uint16_t )1,      (uint16_t )22, 
        (uint16_t )21,      (uint16_t )7,      (uint16_t )11,      (uint16_t )1010, 
        (uint16_t )6,      (uint16_t )4,      (uint16_t )5,      (uint16_t )16, 
        (uint16_t )17,      (uint16_t )9,      (uint16_t )13,      (uint16_t )1011, 
        (uint16_t )1012};
#line 111 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
struct NetFlow NetFlow1  = 
#line 111
     {1U, 16U, 24U, 48U, 0U, (unsigned int )(sizeof(NetFlow1_Header) / sizeof(uint16_t )),
    NetFlow1_Header, (unsigned int )(sizeof(NetFlow1_Flow) / sizeof(uint16_t )), NetFlow1_Flow};
#line 123 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
struct NetFlow NetFlow5  = 
#line 123
     {5U, 24U, 30U, 48U, 16U, (unsigned int )(sizeof(NetFlow5_Header) / sizeof(uint16_t )),
    NetFlow5_Header, (unsigned int )(sizeof(NetFlow5_Flow) / sizeof(uint16_t )), NetFlow5_Flow};
#line 135 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/netflow.c"
struct NetFlow NetFlow7  = 
#line 135
     {7U, 24U, 27U, 52U, 16U, (unsigned int )(sizeof(NetFlow7_Header) / sizeof(uint16_t )),
    NetFlow7_Header, (unsigned int )(sizeof(NetFlow7_Flow) / sizeof(uint16_t )), NetFlow7_Flow};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 390 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 21 "./my_log.h"
void my_log_close(void) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_log.c"
static char *my_log_indent  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_log.c"
static unsigned int my_log_min_level  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_log.c"
static unsigned int my_log_flags  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_log.c"
static char *my_log_names[8]  = 
#line 22
  {      (char *)"EMERG",      (char *)"ALERT",      (char *)"CRIT",      (char *)"ERR", 
        (char *)"WARNING",      (char *)"NOTICE",      (char *)"INFO",      (char *)"DEBUG"};
#line 26 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_log.c"
void my_log_open(char *indent , unsigned int min_level , unsigned int flags ) 
{ 


  {
  {
#line 28
  my_log_indent = indent;
#line 29
  my_log_min_level = min_level;
#line 30
  my_log_flags = flags;
#line 32
  openlog((char const   *)my_log_indent, 0, 3 << 3);
  }
#line 33
  return;
}
}
#line 35 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_log.c"
void my_log_close(void) 
{ 


  {
  {
#line 37
  closelog();
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/my_log.c"
void my_log(unsigned int level , char const   *format  , ...) 
{ 
  va_list args ;
  char msg[256] ;
  char msg_prefix[64] ;

  {
#line 46
  if (level <= my_log_min_level) {
    {
#line 47
    __builtin_va_start(args, format);
#line 48
    vsnprintf((char */* __restrict  */)(msg), sizeof(msg), (char const   */* __restrict  */)format,
              args);
#line 49
    snprintf((char */* __restrict  */)(msg_prefix), sizeof(msg_prefix), (char const   */* __restrict  */)"[%s]: ",
             my_log_names[level]);
    }
#line 51
    if (my_log_flags & 1U) {
      {
#line 52
      syslog((int )level, "%s%s", msg_prefix, msg);
      }
    }
#line 54
    if (my_log_flags & 2U) {
      {
#line 55
      fprintf((FILE */* __restrict  */)stdout, (char const   */* __restrict  */)"%s%s\n",
              msg_prefix, msg);
      }
    }
  }
#line 57
  return;
}
}
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 174 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern ssize_t recvfrom(int __fd , void * __restrict  __buf , size_t __n , int __flags ,
                        struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 25 "../../src/libipulog/include/libipulog/libipulog.h"
u_int32_t ipulog_group2gmask(u_int32_t group ) ;
#line 29
void ipulog_destroy_handle(struct ipulog_handle *h ) ;
#line 40
void ipulog_perror(char const   *s ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
int ipulog_errno  =    0;
#line 48 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
struct ipulog_errmap_t ipulog_errmap[11]  = 
#line 48
  {      {0, (char *)"No error"}, 
        {1, (char *)"Not implemented yet"}, 
        {2, (char *)"Unable to create netlink handle"}, 
        {3, (char *)"Unable to create netlink socket"}, 
        {4, (char *)"Unable to bind netlink socket"}, 
        {5, (char *)"Receive buffer size invalid"}, 
        {6, (char *)"Error during netlink receive"}, 
        {7, (char *)"Received EOF on netlink socket"}, 
        {8, (char *)"Receive message truncated"}, 
        {9, (char *)"Invalid group specified"}, 
        {10, (char *)"Invalid netlink message"}};
#line 67 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
static ssize_t ipulog_netlink_recvfrom(struct ipulog_handle  const  *h , unsigned char *buf ,
                                       size_t len ) 
{ 
  int addrlen ;
  int status ;
  struct nlmsghdr *nlh ;
  ssize_t tmp ;

  {
#line 74
  if (len < sizeof(struct nlmsgerr )) {
#line 75
    ipulog_errno = 5;
#line 76
    return ((ssize_t )-1);
  }
  {
#line 78
  addrlen = (int )sizeof(h->peer);
#line 79
  tmp = recvfrom((int )h->fd, (void */* __restrict  */)buf, len, 0, (struct sockaddr */* __restrict  */)((struct sockaddr *)(& h->peer)),
                 (socklen_t */* __restrict  */)(& addrlen));
#line 79
  status = (int )tmp;
  }
#line 81
  if (status < 0) {
#line 83
    ipulog_errno = 6;
#line 84
    return ((ssize_t )status);
  }
#line 86
  if ((unsigned long )addrlen != sizeof(h->peer)) {
#line 88
    ipulog_errno = 6;
#line 89
    return ((ssize_t )-1);
  }
#line 91
  if (status == 0) {
#line 93
    ipulog_errno = 7;
#line 94
    return ((ssize_t )-1);
  }
#line 96
  nlh = (struct nlmsghdr *)buf;
#line 97
  if ((int )nlh->nlmsg_flags & 32) {
#line 99
    ipulog_errno = 8;
#line 100
    return ((ssize_t )-1);
  } else
#line 97
  if ((size_t )status > len) {
#line 99
    ipulog_errno = 8;
#line 100
    return ((ssize_t )-1);
  }
#line 102
  return ((ssize_t )status);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
char *ipulog_strerror(int errcode ) 
{ 


  {
#line 109
  if (errcode < 0) {
#line 110
    errcode = 1;
  } else
#line 109
  if (errcode > 10) {
#line 110
    errcode = 1;
  }
#line 111
  return (ipulog_errmap[errcode].message);
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
u_int32_t ipulog_group2gmask(u_int32_t group ) 
{ 


  {
#line 117
  if (group < 1U) {
#line 119
    ipulog_errno = 9;
#line 120
    return ((u_int32_t )0);
  } else
#line 117
  if (group > 32U) {
#line 119
    ipulog_errno = 9;
#line 120
    return ((u_int32_t )0);
  }
#line 122
  return ((u_int32_t )(1 << (group - 1U)));
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
struct ipulog_handle *ipulog_create_handle(u_int32_t gmask , u_int32_t rcvbufsize ) 
{ 
  struct ipulog_handle *h ;
  int status ;
  void *tmp ;
  __pid_t tmp___0 ;

  {
  {
#line 132
  tmp = malloc(sizeof(struct ipulog_handle ));
#line 132
  h = (struct ipulog_handle *)tmp;
  }
#line 133
  if ((unsigned long )h == (unsigned long )((void *)0)) {
#line 135
    ipulog_errno = 2;
#line 136
    return ((struct ipulog_handle *)((void *)0));
  }
  {
#line 138
  memset((void *)h, 0, sizeof(struct ipulog_handle ));
#line 139
  h->fd = socket(16, 3, 5);
  }
#line 140
  if (h->fd == -1) {
    {
#line 142
    ipulog_errno = 3;
#line 143
    close(h->fd);
#line 144
    free((void *)h);
    }
#line 145
    return ((struct ipulog_handle *)((void *)0));
  }
  {
#line 147
  memset((void *)(& h->local), 0, sizeof(struct sockaddr_nl ));
#line 148
  h->local.nl_family = (__kernel_sa_family_t )16;
#line 149
  tmp___0 = getpid();
#line 149
  h->local.nl_pid = (__u32 )tmp___0;
#line 150
  h->local.nl_groups = gmask;
#line 151
  status = bind(h->fd, (struct sockaddr  const  *)((struct sockaddr *)(& h->local)),
                (socklen_t )sizeof(h->local));
  }
#line 152
  if (status == -1) {
    {
#line 154
    ipulog_errno = 4;
#line 155
    close(h->fd);
#line 156
    free((void *)h);
    }
#line 157
    return ((struct ipulog_handle *)((void *)0));
  }
  {
#line 159
  memset((void *)(& h->peer), 0, sizeof(struct sockaddr_nl ));
#line 160
  h->peer.nl_family = (__kernel_sa_family_t )16;
#line 161
  h->peer.nl_pid = (__u32 )0;
#line 162
  h->peer.nl_groups = gmask;
#line 164
  status = setsockopt(h->fd, 1, 8, (void const   *)(& rcvbufsize), (socklen_t )sizeof(rcvbufsize));
  }
#line 166
  if (status == -1) {
    {
#line 168
    ipulog_errno = 5;
#line 169
    close(h->fd);
#line 170
    free((void *)h);
    }
#line 171
    return ((struct ipulog_handle *)((void *)0));
  }
#line 174
  return (h);
}
}
#line 178 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
void ipulog_destroy_handle(struct ipulog_handle *h ) 
{ 


  {
  {
#line 180
  close(h->fd);
#line 181
  free((void *)h);
  }
#line 182
  return;
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
ssize_t ipulog_read(struct ipulog_handle *h , unsigned char *buf , size_t len , int timeout ) 
{ 
  ssize_t tmp ;

  {
  {
#line 194
  tmp = ipulog_netlink_recvfrom((struct ipulog_handle  const  *)h, buf, len);
  }
#line 194
  return (tmp);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
ulog_packet_msg_t *ipulog_get_packet(struct ipulog_handle *h , unsigned char const   *buf ,
                                     size_t len ) 
{ 
  struct nlmsghdr *nlh ;
  size_t remain_len ;

  {
#line 208
  if ((unsigned long )((unsigned char *)h->last_nlhdr) > (unsigned long )(buf + len)) {
#line 210
    h->last_nlhdr = (struct nlmsghdr *)((void *)0);
  } else
#line 208
  if ((unsigned long )((unsigned char *)h->last_nlhdr) < (unsigned long )buf) {
#line 210
    h->last_nlhdr = (struct nlmsghdr *)((void *)0);
  }
#line 213
  if (! h->last_nlhdr) {
#line 215
    nlh = (struct nlmsghdr *)buf;
#line 216
    if (len >= (size_t )((int )sizeof(struct nlmsghdr ))) {
#line 216
      if ((unsigned long )nlh->nlmsg_len >= sizeof(struct nlmsghdr )) {
#line 216
        if (! ((size_t )nlh->nlmsg_len <= len)) {
#line 218
          ipulog_errno = 10;
#line 219
          return ((ulog_packet_msg_t *)((void *)0));
        }
      } else {
#line 218
        ipulog_errno = 10;
#line 219
        return ((ulog_packet_msg_t *)((void *)0));
      }
    } else {
#line 218
      ipulog_errno = 10;
#line 219
      return ((ulog_packet_msg_t *)((void *)0));
    }
  } else {
#line 223
    if ((int )(h->last_nlhdr)->nlmsg_type == 3) {
#line 227
      h->last_nlhdr = (struct nlmsghdr *)((void *)0);
#line 228
      return ((ulog_packet_msg_t *)((void *)0));
    } else
#line 223
    if (! ((int )(h->last_nlhdr)->nlmsg_flags & 2)) {
#line 227
      h->last_nlhdr = (struct nlmsghdr *)((void *)0);
#line 228
      return ((ulog_packet_msg_t *)((void *)0));
    }
#line 232
    remain_len = len - (size_t )((unsigned char *)h->last_nlhdr - (unsigned char *)buf);
#line 234
    remain_len -= (size_t )((((h->last_nlhdr)->nlmsg_len + 4U) - 1U) & 4294967292U);
#line 234
    nlh = (struct nlmsghdr *)((char *)h->last_nlhdr + ((((h->last_nlhdr)->nlmsg_len + 4U) - 1U) & 4294967292U));
  }
#line 237
  h->last_nlhdr = nlh;
#line 239
  return ((ulog_packet_msg_t *)((void *)((char *)nlh + (int )(((sizeof(struct nlmsghdr ) + 4UL) - 1UL) & 4294967292UL))));
}
}
#line 243 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/libipulog/libipulog.c"
void ipulog_perror(char const   *s ) 
{ 
  char *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  int *tmp___2 ;

  {
#line 245
  if (s) {
    {
#line 246
    fputs((char const   */* __restrict  */)s, (FILE */* __restrict  */)stderr);
    }
  } else {
    {
#line 248
    fputs((char const   */* __restrict  */)"ERROR", (FILE */* __restrict  */)stderr);
    }
  }
#line 249
  if (ipulog_errno) {
    {
#line 250
    tmp = ipulog_strerror(ipulog_errno);
#line 250
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp);
    }
  }
  {
#line 251
  tmp___2 = __errno_location();
  }
#line 251
  if (*tmp___2) {
    {
#line 252
    tmp___0 = __errno_location();
#line 252
    tmp___1 = strerror(*tmp___0);
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s",
            tmp___1);
    }
  }
  {
#line 253
  fputc('\n', stderr);
  }
#line 254
  return;
}
}
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
static pthread_mutex_t mem_mutex  =    {{0, 0U, 0, 0U, 0, (short)0, (short)0, {(struct __pthread_internal_list *)0, (struct __pthread_internal_list *)0}}};
#line 25 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
static struct Mem *root  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
unsigned int total_elements  ;
#line 27 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
unsigned int free_elements  ;
#line 28 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
static unsigned int element_size  ;
#line 29 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
static unsigned int bulk_quantity___0  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
static unsigned int limit_memory  ;
#line 31 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
unsigned int total_memory  ;
#line 32 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
static unsigned int mem_index_table_size  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
static unsigned int element_table_size  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
static unsigned int malloc_size  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
void *mem_alloc(void) 
{ 
  unsigned int i ;
  struct Mem *mptr ;
  mem_index_t *iptr ;
  void *eptr ;
  int *tmp ;
  void *tmp___0 ;
  mem_index_t *tmp___1 ;

  {
  {
#line 46
  pthread_mutex_lock(& mem_mutex);
  }
#line 48
  if (! free_elements) {
#line 49
    if (limit_memory) {
#line 49
      if (total_memory + malloc_size > limit_memory) {
        {
#line 53
        mptr = (struct Mem *)0;
#line 54
        tmp = __errno_location();
#line 54
        *tmp = 12;
        }
#line 55
        goto done;
      }
    }
    {
#line 57
    tmp___0 = calloc((size_t )malloc_size, (size_t )1);
#line 57
    mptr = (struct Mem *)tmp___0;
    }
#line 57
    if (! mptr) {
#line 57
      goto done;
    }
#line 58
    iptr = (mem_index_t *)((void *)mptr + sizeof(struct Mem ));
#line 60
    eptr = (void *)iptr + mem_index_table_size;
#line 62
    i = 0U;
    {
#line 62
    while (1) {
      while_continue: /* CIL Label */ ;
#line 62
      if (! (i < bulk_quantity___0)) {
#line 62
        goto while_break;
      }
#line 64
      tmp___1 = iptr;
#line 64
      iptr ++;
#line 64
      *tmp___1 = eptr;
#line 65
      eptr += element_size;
#line 62
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
#line 70
    mptr->free = bulk_quantity___0 - 1U;
#line 71
    free_elements += mptr->free;
#line 72
    total_elements += bulk_quantity___0;
#line 73
    total_memory += malloc_size;
#line 74
    mptr->first = (void *)iptr;
#line 75
    mptr->last = ((void *)iptr + element_table_size) - element_size;
#line 76
    mptr->next = root;
#line 77
    root = mptr;
#line 84
    mptr = (struct Mem *)mptr->last;
#line 85
    goto done;
  }
#line 88
  mptr = root;
  {
#line 89
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 89
    if (! (mptr->free == 0U)) {
#line 89
      goto while_break___0;
    }
#line 89
    mptr = mptr->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 90
  (mptr->free) --;
#line 91
  free_elements --;
#line 92
  iptr = (mem_index_t *)((void *)mptr + sizeof(struct Mem ));
#line 94
  mptr = (struct Mem *)*(iptr + mptr->free);
  done: 
  {
#line 104
  pthread_mutex_unlock(& mem_mutex);
  }
#line 106
  return ((void *)mptr);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
void mem_free(void *eptr ) 
{ 
  mem_index_t *iptr ;
  struct Mem *mptr ;
  struct Mem **pptr ;

  {
  {
#line 115
  pthread_mutex_lock(& mem_mutex);
#line 120
  mptr = root;
#line 121
  pptr = & root;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! ((unsigned long )mptr->first > (unsigned long )eptr)) {
#line 122
      if (! ((unsigned long )mptr->last < (unsigned long )eptr)) {
#line 122
        goto while_break;
      }
    }
#line 123
    pptr = & mptr->next;
#line 124
    mptr = mptr->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 126
  iptr = (mem_index_t *)((void *)mptr + sizeof(struct Mem ));
#line 128
  *(iptr + mptr->free) = eptr;
#line 132
  (mptr->free) ++;
#line 133
  free_elements ++;
#line 134
  if (mptr->free == bulk_quantity___0) {
    {
#line 139
    *pptr = mptr->next;
#line 140
    free((void *)mptr);
#line 141
    total_elements -= bulk_quantity___0;
#line 142
    free_elements -= bulk_quantity___0;
#line 143
    total_memory -= malloc_size;
    }
  }
  {
#line 150
  pthread_mutex_unlock(& mem_mutex);
  }
#line 152
  return;
}
}
#line 154 "/home/june/repo/benchmarks/collector/temp/fprobe-ulog-1.1/src/mem.c"
int mem_init(unsigned int element , unsigned int bulk , unsigned int limit ) 
{ 


  {
#line 156
  bulk_quantity___0 = (unsigned int )((mem_index_t )bulk);
#line 157
  mem_index_table_size = (unsigned int )(sizeof(mem_index_t ) * (unsigned long )bulk_quantity___0);
#line 158
  element_size = element;
#line 159
  element_table_size = element_size * bulk_quantity___0;
#line 160
  malloc_size = (unsigned int )((sizeof(struct Mem ) + (unsigned long )mem_index_table_size) + (unsigned long )element_table_size);
#line 161
  limit_memory = limit;
#line 166
  return (0);
}
}
