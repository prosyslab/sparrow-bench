/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 189 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __socklen_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 102 "/usr/include/stdio.h"
typedef __ssize_t ssize_t;
#line 70 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __mode_t mode_t;
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_14 {
   __fd_mask __fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_14 fd_set;
#line 274 "/usr/include/unistd.h"
typedef __socklen_t socklen_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/sockaddr.h"
typedef unsigned short sa_family_t;
#line 149 "/usr/include/x86_64-linux-gnu/bits/socket.h"
struct sockaddr {
   sa_family_t sa_family ;
   char sa_data[14] ;
};
#line 29 "/usr/include/x86_64-linux-gnu/sys/un.h"
struct sockaddr_un {
   sa_family_t sun_family ;
   char sun_path[108] ;
};
#line 30 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.h"
struct event_motion {
   int type ;
   int x ;
   int y ;
   int z ;
   int rx ;
   int ry ;
   int rz ;
   unsigned int period ;
   int *data ;
};
#line 38 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.h"
struct event_button {
   int type ;
   int press ;
   int bnum ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.h"
union spnav_event {
   int type ;
   struct event_motion motion ;
   struct event_button button ;
};
#line 44 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.h"
typedef union spnav_event spnav_event;
#line 35 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.h"
struct client;
#line 26 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/cfgfile.h"
struct cfg {
   float sensitivity ;
   float sens_trans ;
   float sens_rot ;
   int dead_threshold ;
   int invert[6] ;
   int map_axis[6] ;
   int map_button[64] ;
   int led ;
   char serial_dev[4096] ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 23 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned short __u16;
#line 25 "/usr/include/asm-generic/int-ll64.h"
typedef int __s32;
#line 26 "/usr/include/asm-generic/int-ll64.h"
typedef unsigned int __u32;
#line 11 "/usr/include/linux/socket.h"
typedef unsigned short __kernel_sa_family_t;
#line 35 "/usr/include/linux/netlink.h"
struct sockaddr_nl {
   __kernel_sa_family_t nl_family ;
   unsigned short nl_pad ;
   __u32 nl_pid ;
   __u32 nl_groups ;
};
#line 22 "/usr/include/linux/input.h"
struct input_event {
   struct timeval time ;
   __u16 type ;
   __u16 code ;
   __s32 value ;
};
#line 58 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.h"
struct dev_input {
   int type ;
   struct timeval tm ;
   int idx ;
   int val ;
};
#line 66 "/usr/include/X11/X.h"
typedef unsigned long XID;
#line 96 "/usr/include/X11/X.h"
typedef XID Window;
#line 29 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
struct client {
   int type ;
   int sock ;
   Window win ;
   float sens ;
   struct client *next ;
};
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
struct __anonstruct___sigset_t_13 {
   unsigned long __val[1024UL / (8UL * sizeof(unsigned long ))] ;
};
#line 27 "/usr/include/x86_64-linux-gnu/bits/sigset.h"
typedef struct __anonstruct___sigset_t_13 __sigset_t;
#line 31 "/usr/include/x86_64-linux-gnu/bits/setjmp.h"
typedef long __jmp_buf[8];
#line 34 "/usr/include/setjmp.h"
struct __jmp_buf_tag {
   __jmp_buf __jmpbuf ;
   int __mask_was_saved ;
   __sigset_t __saved_mask ;
};
#line 48 "/usr/include/setjmp.h"
typedef struct __jmp_buf_tag jmp_buf[1];
#line 49 "/usr/include/pwd.h"
struct passwd {
   char *pw_name ;
   char *pw_passwd ;
   __uid_t pw_uid ;
   __gid_t pw_gid ;
   char *pw_gecos ;
   char *pw_dir ;
   char *pw_shell ;
};
#line 74 "/usr/include/X11/X.h"
typedef unsigned long Atom;
#line 76 "/usr/include/X11/X.h"
typedef unsigned long VisualID;
#line 77 "/usr/include/X11/X.h"
typedef unsigned long Time;
#line 97 "/usr/include/X11/X.h"
typedef XID Drawable;
#line 102 "/usr/include/X11/X.h"
typedef XID Pixmap;
#line 103 "/usr/include/X11/X.h"
typedef XID Cursor;
#line 104 "/usr/include/X11/X.h"
typedef XID Colormap;
#line 92 "/usr/include/X11/Xlib.h"
typedef char *XPointer;
#line 160 "/usr/include/X11/Xlib.h"
struct _XExtData {
   int number ;
   struct _XExtData *next ;
   int (*free_private)(struct _XExtData *extension ) ;
   XPointer private_data ;
};
#line 160 "/usr/include/X11/Xlib.h"
typedef struct _XExtData XExtData;
#line 226
struct _XGC;
#line 226 "/usr/include/X11/Xlib.h"
typedef struct _XGC *GC;
#line 239 "/usr/include/X11/Xlib.h"
struct __anonstruct_Visual_31 {
   XExtData *ext_data ;
   VisualID visualid ;
   int class ;
   unsigned long red_mask ;
   unsigned long green_mask ;
   unsigned long blue_mask ;
   int bits_per_rgb ;
   int map_entries ;
};
#line 239 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Visual_31 Visual;
#line 255 "/usr/include/X11/Xlib.h"
struct __anonstruct_Depth_32 {
   int depth ;
   int nvisuals ;
   Visual *visuals ;
};
#line 255 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Depth_32 Depth;
#line 267
struct _XDisplay;
#line 269 "/usr/include/X11/Xlib.h"
struct __anonstruct_Screen_33 {
   XExtData *ext_data ;
   struct _XDisplay *display ;
   Window root ;
   int width ;
   int height ;
   int mwidth ;
   int mheight ;
   int ndepths ;
   Depth *depths ;
   int root_depth ;
   Visual *root_visual ;
   GC default_gc ;
   Colormap cmap ;
   unsigned long white_pixel ;
   unsigned long black_pixel ;
   int max_maps ;
   int min_maps ;
   int backing_store ;
   int save_unders ;
   long root_input_mask ;
};
#line 269 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_Screen_33 Screen;
#line 292 "/usr/include/X11/Xlib.h"
struct __anonstruct_ScreenFormat_34 {
   XExtData *ext_data ;
   int depth ;
   int bits_per_pixel ;
   int scanline_pad ;
};
#line 292 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_ScreenFormat_34 ScreenFormat;
#line 302 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSetWindowAttributes_35 {
   Pixmap background_pixmap ;
   unsigned long background_pixel ;
   Pixmap border_pixmap ;
   unsigned long border_pixel ;
   int bit_gravity ;
   int win_gravity ;
   int backing_store ;
   unsigned long backing_planes ;
   unsigned long backing_pixel ;
   int save_under ;
   long event_mask ;
   long do_not_propagate_mask ;
   int override_redirect ;
   Colormap colormap ;
   Cursor cursor ;
};
#line 302 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSetWindowAttributes_35 XSetWindowAttributes;
#line 499 "/usr/include/X11/Xlib.h"
typedef struct _XDisplay Display;
#line 502
struct _XPrivate;
#line 503
struct _XrmHashBucketRec;
#line 505 "/usr/include/X11/Xlib.h"
struct __anonstruct__XPrivDisplay_49 {
   XExtData *ext_data ;
   struct _XPrivate *private1 ;
   int fd ;
   int private2 ;
   int proto_major_version ;
   int proto_minor_version ;
   char *vendor ;
   XID private3 ;
   XID private4 ;
   XID private5 ;
   int private6 ;
   XID (*resource_alloc)(struct _XDisplay * ) ;
   int byte_order ;
   int bitmap_unit ;
   int bitmap_pad ;
   int bitmap_bit_order ;
   int nformats ;
   ScreenFormat *pixmap_format ;
   int private8 ;
   int release ;
   struct _XPrivate *private9 ;
   struct _XPrivate *private10 ;
   int qlen ;
   unsigned long last_request_read ;
   unsigned long request ;
   XPointer private11 ;
   XPointer private12 ;
   XPointer private13 ;
   XPointer private14 ;
   unsigned int max_request_size ;
   struct _XrmHashBucketRec *db ;
   int (*private15)(struct _XDisplay * ) ;
   char *display_name ;
   int default_screen ;
   int nscreens ;
   Screen *screens ;
   unsigned long motion_buffer ;
   unsigned long private16 ;
   int min_keycode ;
   int max_keycode ;
   XPointer private17 ;
   XPointer private18 ;
   int private19 ;
   char *xdefaults ;
};
#line 505 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct__XPrivDisplay_49 *_XPrivDisplay;
#line 569 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeyEvent_50 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int keycode ;
   int same_screen ;
};
#line 569 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeyEvent_50 XKeyEvent;
#line 587 "/usr/include/X11/Xlib.h"
struct __anonstruct_XButtonEvent_51 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   unsigned int button ;
   int same_screen ;
};
#line 587 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XButtonEvent_51 XButtonEvent;
#line 605 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMotionEvent_52 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   unsigned int state ;
   char is_hint ;
   int same_screen ;
};
#line 605 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMotionEvent_52 XMotionEvent;
#line 622 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCrossingEvent_53 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Window root ;
   Window subwindow ;
   Time time ;
   int x ;
   int y ;
   int x_root ;
   int y_root ;
   int mode ;
   int detail ;
   int same_screen ;
   int focus ;
   unsigned int state ;
};
#line 622 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCrossingEvent_53 XCrossingEvent;
#line 646 "/usr/include/X11/Xlib.h"
struct __anonstruct_XFocusChangeEvent_54 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int mode ;
   int detail ;
};
#line 646 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XFocusChangeEvent_54 XFocusChangeEvent;
#line 665 "/usr/include/X11/Xlib.h"
struct __anonstruct_XKeymapEvent_55 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   char key_vector[32] ;
};
#line 665 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XKeymapEvent_55 XKeymapEvent;
#line 674 "/usr/include/X11/Xlib.h"
struct __anonstruct_XExposeEvent_56 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
};
#line 674 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XExposeEvent_56 XExposeEvent;
#line 685 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGraphicsExposeEvent_57 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int x ;
   int y ;
   int width ;
   int height ;
   int count ;
   int major_code ;
   int minor_code ;
};
#line 685 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGraphicsExposeEvent_57 XGraphicsExposeEvent;
#line 698 "/usr/include/X11/Xlib.h"
struct __anonstruct_XNoExposeEvent_58 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Drawable drawable ;
   int major_code ;
   int minor_code ;
};
#line 698 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XNoExposeEvent_58 XNoExposeEvent;
#line 708 "/usr/include/X11/Xlib.h"
struct __anonstruct_XVisibilityEvent_59 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int state ;
};
#line 708 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XVisibilityEvent_59 XVisibilityEvent;
#line 717 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCreateWindowEvent_60 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   int override_redirect ;
};
#line 717 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCreateWindowEvent_60 XCreateWindowEvent;
#line 730 "/usr/include/X11/Xlib.h"
struct __anonstruct_XDestroyWindowEvent_61 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
};
#line 730 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XDestroyWindowEvent_61 XDestroyWindowEvent;
#line 739 "/usr/include/X11/Xlib.h"
struct __anonstruct_XUnmapEvent_62 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int from_configure ;
};
#line 739 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XUnmapEvent_62 XUnmapEvent;
#line 749 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapEvent_63 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int override_redirect ;
};
#line 749 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapEvent_63 XMapEvent;
#line 759 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMapRequestEvent_64 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
};
#line 759 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMapRequestEvent_64 XMapRequestEvent;
#line 768 "/usr/include/X11/Xlib.h"
struct __anonstruct_XReparentEvent_65 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   Window parent ;
   int x ;
   int y ;
   int override_redirect ;
};
#line 768 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XReparentEvent_65 XReparentEvent;
#line 780 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureEvent_66 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int override_redirect ;
};
#line 780 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureEvent_66 XConfigureEvent;
#line 794 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGravityEvent_67 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int x ;
   int y ;
};
#line 794 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGravityEvent_67 XGravityEvent;
#line 804 "/usr/include/X11/Xlib.h"
struct __anonstruct_XResizeRequestEvent_68 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int width ;
   int height ;
};
#line 804 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XResizeRequestEvent_68 XResizeRequestEvent;
#line 813 "/usr/include/X11/Xlib.h"
struct __anonstruct_XConfigureRequestEvent_69 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int x ;
   int y ;
   int width ;
   int height ;
   int border_width ;
   Window above ;
   int detail ;
   unsigned long value_mask ;
};
#line 813 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XConfigureRequestEvent_69 XConfigureRequestEvent;
#line 828 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateEvent_70 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window event ;
   Window window ;
   int place ;
};
#line 828 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateEvent_70 XCirculateEvent;
#line 838 "/usr/include/X11/Xlib.h"
struct __anonstruct_XCirculateRequestEvent_71 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window parent ;
   Window window ;
   int place ;
};
#line 838 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XCirculateRequestEvent_71 XCirculateRequestEvent;
#line 848 "/usr/include/X11/Xlib.h"
struct __anonstruct_XPropertyEvent_72 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom atom ;
   Time time ;
   int state ;
};
#line 848 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XPropertyEvent_72 XPropertyEvent;
#line 859 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionClearEvent_73 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom selection ;
   Time time ;
};
#line 859 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionClearEvent_73 XSelectionClearEvent;
#line 869 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionRequestEvent_74 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window owner ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 869 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionRequestEvent_74 XSelectionRequestEvent;
#line 882 "/usr/include/X11/Xlib.h"
struct __anonstruct_XSelectionEvent_75 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window requestor ;
   Atom selection ;
   Atom target ;
   Atom property ;
   Time time ;
};
#line 882 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XSelectionEvent_75 XSelectionEvent;
#line 894 "/usr/include/X11/Xlib.h"
struct __anonstruct_XColormapEvent_76 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Colormap colormap ;
   int new ;
   int state ;
};
#line 894 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XColormapEvent_76 XColormapEvent;
#line 909 "/usr/include/X11/Xlib.h"
union __anonunion_data_78 {
   char b[20] ;
   short s[10] ;
   long l[5] ;
};
#line 909 "/usr/include/X11/Xlib.h"
struct __anonstruct_XClientMessageEvent_77 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   Atom message_type ;
   int format ;
   union __anonunion_data_78 data ;
};
#line 909 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XClientMessageEvent_77 XClientMessageEvent;
#line 924 "/usr/include/X11/Xlib.h"
struct __anonstruct_XMappingEvent_79 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
   int request ;
   int first_keycode ;
   int count ;
};
#line 924 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XMappingEvent_79 XMappingEvent;
#line 936 "/usr/include/X11/Xlib.h"
struct __anonstruct_XErrorEvent_80 {
   int type ;
   Display *display ;
   XID resourceid ;
   unsigned long serial ;
   unsigned char error_code ;
   unsigned char request_code ;
   unsigned char minor_code ;
};
#line 936 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XErrorEvent_80 XErrorEvent;
#line 946 "/usr/include/X11/Xlib.h"
struct __anonstruct_XAnyEvent_81 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   Window window ;
};
#line 946 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XAnyEvent_81 XAnyEvent;
#line 960 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEvent_82 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
};
#line 960 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEvent_82 XGenericEvent;
#line 970 "/usr/include/X11/Xlib.h"
struct __anonstruct_XGenericEventCookie_83 {
   int type ;
   unsigned long serial ;
   int send_event ;
   Display *display ;
   int extension ;
   int evtype ;
   unsigned int cookie ;
   void *data ;
};
#line 970 "/usr/include/X11/Xlib.h"
typedef struct __anonstruct_XGenericEventCookie_83 XGenericEventCookie;
#line 985 "/usr/include/X11/Xlib.h"
union _XEvent {
   int type ;
   XAnyEvent xany ;
   XKeyEvent xkey ;
   XButtonEvent xbutton ;
   XMotionEvent xmotion ;
   XCrossingEvent xcrossing ;
   XFocusChangeEvent xfocus ;
   XExposeEvent xexpose ;
   XGraphicsExposeEvent xgraphicsexpose ;
   XNoExposeEvent xnoexpose ;
   XVisibilityEvent xvisibility ;
   XCreateWindowEvent xcreatewindow ;
   XDestroyWindowEvent xdestroywindow ;
   XUnmapEvent xunmap ;
   XMapEvent xmap ;
   XMapRequestEvent xmaprequest ;
   XReparentEvent xreparent ;
   XConfigureEvent xconfigure ;
   XGravityEvent xgravity ;
   XResizeRequestEvent xresizerequest ;
   XConfigureRequestEvent xconfigurerequest ;
   XCirculateEvent xcirculate ;
   XCirculateRequestEvent xcirculaterequest ;
   XPropertyEvent xproperty ;
   XSelectionClearEvent xselectionclear ;
   XSelectionRequestEvent xselectionrequest ;
   XSelectionEvent xselection ;
   XColormapEvent xcolormap ;
   XClientMessageEvent xclient ;
   XMappingEvent xmapping ;
   XErrorEvent xerror ;
   XKeymapEvent xkeymap ;
   XGenericEvent xgeneric ;
   XGenericEventCookie xcookie ;
   long pad[24] ;
};
#line 985 "/usr/include/X11/Xlib.h"
typedef union _XEvent XEvent;
#line 1855 "/usr/include/X11/Xlib.h"
typedef int (*XErrorHandler)(Display * , XErrorEvent * );
#line 1865 "/usr/include/X11/Xlib.h"
typedef int (*XIOErrorHandler)(Display * );
#line 163 "/usr/include/X11/Xutil.h"
struct __anonstruct_XTextProperty_111 {
   unsigned char *value ;
   Atom encoding ;
   int format ;
   unsigned long nitems ;
};
#line 163 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XTextProperty_111 XTextProperty;
#line 189 "/usr/include/X11/Xutil.h"
struct __anonstruct_XClassHint_114 {
   char *res_name ;
   char *res_class ;
};
#line 189 "/usr/include/X11/Xutil.h"
typedef struct __anonstruct_XClassHint_114 XClassHint;
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.h"
typedef void *SBallCommHandle;
#line 56 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.c"
struct __anonstruct_commstruct_11 {
   int fd ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.c"
typedef struct __anonstruct_commstruct_11 commstruct;
#line 55 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.h"
typedef void *SBallHandle;
#line 35 "/usr/include/x86_64-linux-gnu/bits/fcntl.h"
struct flock {
   short l_type ;
   short l_whence ;
   __off_t l_start ;
   __off_t l_len ;
   __pid_t l_pid ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
struct event {
   struct dev_input data ;
   struct event *next ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
struct __anonstruct_sballhandle_16 {
   SBallCommHandle commhandle ;
   unsigned char buf[256] ;
   char resetstring[256] ;
   int bufpos ;
   int packtype ;
   int packlen ;
   int escapedchar ;
   int erroroccured ;
   int resetoccured ;
   int spaceball4000 ;
   int leftymode4000 ;
   int trans[3] ;
   int rot[3] ;
   int buttons ;
   int timer ;
   int usenullregion ;
   int nulltrans[3] ;
   int nullrot[3] ;
   struct event *evhead ;
   struct event *evtail ;
};
#line 69 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
typedef struct __anonstruct_sballhandle_16 sballhandle;
#line 51 "/usr/include/stdint.h"
typedef unsigned int uint32_t;
#line 28 "/usr/include/x86_64-linux-gnu/sys/inotify.h"
struct inotify_event {
   int wd ;
   uint32_t mask ;
   uint32_t cookie ;
   uint32_t len ;
   char name[] ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 413
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 113 "/usr/include/x86_64-linux-gnu/sys/socket.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) socket)(int __domain ,
                                                                             int __type ,
                                                                             int __protocol ) ;
#line 123
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) bind)(int __fd ,
                                                                           struct sockaddr  const  *__addr ,
                                                                           socklen_t __len ) ;
#line 233
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) listen)(int __fd ,
                                                                             int __n ) ;
#line 243
extern int accept(int __fd , struct sockaddr * __restrict  __addr , socklen_t * __restrict  __addr_len ) ;
#line 312 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) __mode_t ( __attribute__((__leaf__)) umask)(__mode_t __mask ) ;
#line 39 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.h"
struct client *add_client(int type , void *cdata ) ;
#line 40
void remove_client(struct client *client ) ;
#line 42
int get_client_type(struct client *client ) ;
#line 43
int get_client_socket(struct client *client ) ;
#line 48
void set_client_sensitivity(struct client *client , float sens ) ;
#line 49
float get_client_sensitivity(struct client *client ) ;
#line 52
struct client *first_client(void) ;
#line 53
struct client *next_client(void) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_unix.h"
int init_unix(void) ;
#line 27
void close_unix(void) ;
#line 28
int get_unix_socket(void) ;
#line 30
void send_uevent(spnav_event *ev___0 , struct client *c ) ;
#line 32
int handle_uevents(fd_set *rset ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.h"
struct cfg cfg  ;
#line 30 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.h"
int verbose  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_unix.c"
static int lsock  ;
#line 39 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_unix.c"
int init_unix(void) 
{ 
  int s ;
  mode_t prev_umask ;
  struct sockaddr_un addr ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 45
  if (lsock) {
#line 45
    return (0);
  }
  {
#line 47
  s = socket(1, 1, 0);
  }
#line 47
  if (s == -1) {
    {
#line 48
    perror("failed to create socket");
    }
#line 49
    return (-1);
  }
  {
#line 52
  unlink("/var/run/spnav.sock");
#line 54
  memset((void *)(& addr), 0, sizeof(addr));
#line 55
  addr.sun_family = (sa_family_t )1;
#line 56
  strcpy((char */* __restrict  */)(addr.sun_path), (char const   */* __restrict  */)"/var/run/spnav.sock");
#line 58
  prev_umask = umask((__mode_t )0);
#line 60
  tmp___1 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 60
  if (tmp___1 == -1) {
    {
#line 61
    tmp = __errno_location();
#line 61
    tmp___0 = strerror(*tmp);
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to bind unix socket: %s: %s\n",
            "/var/run/spnav.sock", tmp___0);
    }
#line 62
    return (-1);
  }
  {
#line 65
  umask(prev_umask);
#line 67
  tmp___2 = listen(s, 8);
  }
#line 67
  if (tmp___2 == -1) {
    {
#line 68
    perror("listen failed");
    }
#line 69
    return (-1);
  }
#line 72
  lsock = s;
#line 73
  return (0);
}
}
#line 76 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_unix.c"
void close_unix(void) 
{ 


  {
#line 78
  if (lsock != -1) {
    {
#line 79
    close(lsock);
#line 80
    lsock = -1;
#line 82
    unlink("/var/run/spnav.sock");
    }
  }
#line 84
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_unix.c"
int get_unix_socket(void) 
{ 


  {
#line 88
  return (lsock);
}
}
#line 91 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_unix.c"
void send_uevent(spnav_event *ev___0 , struct client *c ) 
{ 
  int i ;
  int data[8] ;
  unsigned int tmp ;
  float motion_mul ;
  float val ;
  int tmp___0 ;
  ssize_t tmp___1 ;
  int *tmp___2 ;

  {
#line 93
  data[0] = 0;
#line 93
  tmp = 1U;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (tmp >= 8U) {
#line 93
      goto while_break;
    }
#line 93
    data[tmp] = 0;
#line 93
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 96
  if (! lsock) {
#line 96
    return;
  }
  {
#line 99
  if (ev___0->type == 0) {
#line 99
    goto case_0;
  }
#line 110
  if (ev___0->type == 1) {
#line 110
    goto case_1;
  }
#line 115
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 100
  data[0] = 0;
#line 102
  motion_mul = get_client_sensitivity(c);
#line 103
  i = 0;
  }
  {
#line 103
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 103
    if (! (i < 6)) {
#line 103
      goto while_break___0;
    }
#line 104
    val = (float )*(ev___0->motion.data + i) * motion_mul;
#line 105
    data[i + 1] = (int )val;
#line 103
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 107
  data[7] = (int )ev___0->motion.period;
#line 108
  goto switch_break;
  case_1: /* CIL Label */ 
#line 111
  if (ev___0->button.press) {
#line 111
    data[0] = 1;
  } else {
#line 111
    data[0] = 2;
  }
#line 112
  data[1] = ev___0->button.bnum;
#line 113
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 116
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 119
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 119
    tmp___0 = get_client_socket(c);
#line 119
    tmp___1 = write(tmp___0, (void const   *)(data), sizeof(data));
    }
#line 119
    if (tmp___1 == -1L) {
      {
#line 119
      tmp___2 = __errno_location();
      }
#line 119
      if (! (*tmp___2 == 4)) {
#line 119
        goto while_break___1;
      }
    } else {
#line 119
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_unix.c"
int handle_uevents(fd_set *rset ) 
{ 
  struct client *citer___0 ;
  int s ;
  struct client *tmp ;
  struct client *c ;
  int s___0 ;
  int tmp___0 ;
  int rdbytes ;
  float sens ;
  ssize_t tmp___1 ;
  int *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 126
  if (lsock == -1) {
#line 127
    return (-1);
  }
#line 130
  if ((rset->__fds_bits[lsock / (8 * (int )sizeof(__fd_mask ))] & (1L << lsock % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 134
    s = accept(lsock, (struct sockaddr */* __restrict  */)0, (socklen_t */* __restrict  */)0);
    }
#line 134
    if (s == -1) {
      {
#line 135
      perror("error while accepting connection on the UNIX socket");
      }
    } else {
      {
#line 137
      tmp = add_client(1, (void *)(& s));
      }
#line 137
      if (! tmp) {
        {
#line 138
        perror("failed to add client");
        }
      }
    }
  }
  {
#line 144
  citer___0 = first_client();
  }
  {
#line 145
  while (1) {
    while_continue: /* CIL Label */ ;
#line 145
    if (! citer___0) {
#line 145
      goto while_break;
    }
    {
#line 146
    c = citer___0;
#line 147
    citer___0 = next_client();
#line 149
    tmp___4 = get_client_type(c);
    }
#line 149
    if (tmp___4 == 1) {
      {
#line 150
      tmp___0 = get_client_socket(c);
#line 150
      s___0 = tmp___0;
      }
#line 152
      if ((rset->__fds_bits[s___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << s___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 159
        while (1) {
          while_continue___0: /* CIL Label */ ;
          {
#line 159
          tmp___1 = read(s___0, (void *)(& sens), sizeof(sens));
#line 159
          rdbytes = (int )tmp___1;
          }
#line 159
          if (rdbytes <= 0) {
            {
#line 159
            tmp___2 = __errno_location();
            }
#line 159
            if (! (*tmp___2 == 4)) {
#line 159
              goto while_break___0;
            }
          } else {
#line 159
            goto while_break___0;
          }
        }
        while_break___0: /* CIL Label */ ;
        }
#line 160
        if (rdbytes <= 0) {
          {
#line 161
          tmp___3 = get_client_socket(c);
#line 161
          close(tmp___3);
#line 162
          remove_client(c);
          }
#line 163
          goto while_continue;
        }
        {
#line 166
        set_client_sensitivity(c, sens);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 171
  return (0);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 417 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 432
extern  __attribute__((__nothrow__)) unsigned int ( __attribute__((__leaf__)) alarm)(unsigned int __seconds ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 137 "/usr/include/fcntl.h"
extern int fcntl(int __fd , int __cmd  , ...) ;
#line 146
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 26 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev.h"
int init_hotplug(void) ;
#line 27
void shutdown_hotplug(void) ;
#line 28
int get_hotplug_fd(void) ;
#line 30
int handle_hotplug(void) ;
#line 34
int init_dev(void) ;
#line 35
void shutdown_dev(void) ;
#line 36
int get_dev_fd(void) ;
#line 38
int read_dev(struct dev_input *inp ) ;
#line 40
void set_led(int state ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_serial.h"
int open_dev_serial(char const   *devfile ) ;
#line 25
void close_dev_serial(void) ;
#line 26
int read_dev_serial(struct dev_input *inp ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int open_dev_usb(char const   *path___0 ) ;
#line 57
static int read_dev_usb(struct dev_input *inp ) ;
#line 58
static char *get_dev_path(void) ;
#line 59
static int con_hotplug(void) ;
#line 60
static void poll_timeout(int sig ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int dev_fd  =    -1;
#line 63 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static char dev_name[128]  ;
#line 64 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static unsigned char evtype_mask[4]  ;
#line 67 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int hotplug_fd  =    -1;
#line 68 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int poll_time  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int poll_pipe  ;
#line 71 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int dev_is_serial  ;
#line 75 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
int init_hotplug(void) 
{ 
  int pfd[2] ;
  int tmp ;

  {
  {
#line 77
  hotplug_fd = con_hotplug();
  }
#line 77
  if (hotplug_fd == -1) {
#line 80
    if (verbose) {
      {
#line 81
      printf((char const   */* __restrict  */)"hotplug failed will resort to polling\n");
      }
    }
    {
#line 84
    tmp = pipe((int *)(pfd));
    }
#line 84
    if (tmp == -1) {
      {
#line 85
      perror("failed to open polling self-pipe");
      }
#line 86
      return (-1);
    }
    {
#line 88
    poll_pipe = pfd[1];
#line 89
    hotplug_fd = pfd[0];
#line 91
    poll_time = 1;
#line 92
    signal(14, & poll_timeout);
#line 93
    alarm((unsigned int )poll_time);
    }
  }
#line 96
  return (hotplug_fd);
}
}
#line 99 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
void shutdown_hotplug(void) 
{ 


  {
#line 101
  if (hotplug_fd != -1) {
    {
#line 102
    close(hotplug_fd);
#line 103
    hotplug_fd = -1;
    }
  }
#line 106
  if (poll_pipe != -1) {
    {
#line 107
    close(poll_pipe);
#line 108
    poll_pipe = -1;
    }
  }
#line 110
  return;
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
int get_hotplug_fd(void) 
{ 


  {
#line 114
  return (hotplug_fd);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
int handle_hotplug(void) 
{ 
  char buf[512] ;
  int tmp ;

  {
  {
#line 120
  read(hotplug_fd, (void *)(buf), sizeof(buf));
  }
#line 122
  if (dev_fd == -1) {
    {
#line 123
    tmp = init_dev();
    }
#line 123
    if (tmp == -1) {
#line 124
      return (-1);
    }
    {
#line 126
    shutdown_hotplug();
    }
  }
#line 129
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int con_hotplug(void) 
{ 
  int s ;
  struct sockaddr_nl addr ;
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 134
  s = -1;
#line 139
  s = socket(16, 2, 15);
  }
#line 139
  if (s == -1) {
    {
#line 140
    perror("failed to open hotplug netlink socket");
    }
#line 141
    return (-1);
  }
  {
#line 144
  memset((void *)(& addr), 0, sizeof(addr));
#line 145
  addr.nl_family = (__kernel_sa_family_t )16;
#line 146
  tmp = getpid();
#line 146
  addr.nl_pid = (__u32 )tmp;
#line 147
  addr.nl_groups = (__u32 )-1;
#line 149
  tmp___0 = bind(s, (struct sockaddr  const  *)((struct sockaddr *)(& addr)), (socklen_t )sizeof(addr));
  }
#line 149
  if (tmp___0 == -1) {
    {
#line 150
    perror("failed to bind to hotplug netlink socket");
#line 151
    close(s);
    }
#line 152
    return (-1);
  }
#line 156
  return (s);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static void poll_timeout(int sig ) 
{ 


  {
  {
#line 161
  signal(sig, & poll_timeout);
  }
#line 163
  if (sig == 14) {
#line 164
    if (poll_pipe != -1) {
      {
#line 165
      write(poll_pipe, (void const   *)(& sig), (size_t )1);
#line 166
      poll_time *= 2;
#line 167
      alarm((unsigned int )poll_time);
      }
    }
  }
#line 170
  return;
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
int init_dev(void) 
{ 
  char *dev_path ;

  {
#line 177
  if (cfg.serial_dev[0]) {
    {
#line 179
    printf((char const   */* __restrict  */)"using device: %s\n", cfg.serial_dev);
#line 181
    dev_fd = open_dev_serial((char const   *)(cfg.serial_dev));
    }
#line 181
    if (dev_fd == -1) {
#line 182
      return (-1);
    }
#line 184
    dev_is_serial = 1;
  } else {
    {
#line 188
    dev_path = get_dev_path();
    }
#line 188
    if (! dev_path) {
      {
#line 189
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to find the spaceball device file\n");
      }
#line 190
      return (-1);
    }
    {
#line 192
    printf((char const   */* __restrict  */)"using device: %s\n", dev_path);
#line 194
    dev_fd = open_dev_usb((char const   *)dev_path);
    }
#line 194
    if (dev_fd == -1) {
#line 195
      return (-1);
    }
    {
#line 197
    dev_is_serial = 0;
#line 199
    printf((char const   */* __restrict  */)"device name: %s\n", dev_name);
    }
  }
#line 201
  return (0);
}
}
#line 204 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
void shutdown_dev(void) 
{ 


  {
#line 206
  if (dev_is_serial) {
    {
#line 207
    close_dev_serial();
    }
  } else
#line 209
  if (dev_fd != -1) {
    {
#line 210
    set_led(0);
#line 211
    close(dev_fd);
    }
  }
#line 214
  dev_fd = -1;
#line 215
  return;
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
int get_dev_fd(void) 
{ 


  {
#line 219
  return (dev_fd);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
int read_dev(struct dev_input *inp ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 224
  if (dev_is_serial) {
    {
#line 224
    tmp = read_dev_serial(inp);
#line 224
    tmp___1 = tmp;
    }
  } else {
    {
#line 224
    tmp___0 = read_dev_usb(inp);
#line 224
    tmp___1 = tmp___0;
    }
  }
#line 224
  return (tmp___1);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int read_dev_usb(struct dev_input *inp ) 
{ 
  struct input_event iev ;
  int rdbytes ;
  ssize_t tmp ;
  int *tmp___0 ;
  int *tmp___1 ;

  {
#line 232
  if (dev_fd == -1) {
#line 233
    return (-1);
  }
  {
#line 236
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 237
    tmp = read(dev_fd, (void *)(& iev), sizeof(iev));
#line 237
    rdbytes = (int )tmp;
    }
#line 236
    if (rdbytes == -1) {
      {
#line 236
      tmp___0 = __errno_location();
      }
#line 236
      if (! (*tmp___0 == 4)) {
#line 236
        goto while_break;
      }
    } else {
#line 236
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  if (rdbytes == -1) {
    {
#line 242
    tmp___1 = __errno_location();
    }
#line 242
    if (*tmp___1 != 11) {
      {
#line 243
      perror("read error");
#line 244
      close(dev_fd);
#line 245
      dev_fd = -1;
#line 247
      init_hotplug();
      }
    }
#line 249
    return (-1);
  }
#line 252
  if (rdbytes > 0) {
#line 253
    inp->tm = iev.time;
    {
#line 256
    if ((int )iev.type == 2) {
#line 256
      goto case_2;
    }
#line 262
    if ((int )iev.type == 3) {
#line 262
      goto case_3;
    }
#line 268
    if ((int )iev.type == 1) {
#line 268
      goto case_1;
    }
#line 274
    if ((int )iev.type == 0) {
#line 274
      goto case_0;
    }
#line 278
    goto switch_default;
    case_2: /* CIL Label */ 
#line 257
    inp->type = 0;
#line 258
    inp->idx = (int )iev.code;
#line 259
    inp->val = iev.value;
#line 260
    goto switch_break;
    case_3: /* CIL Label */ 
#line 263
    inp->type = 0;
#line 264
    inp->idx = (int )iev.code;
#line 265
    inp->val = iev.value;
#line 266
    goto switch_break;
    case_1: /* CIL Label */ 
#line 269
    inp->type = 1;
#line 270
    inp->idx = (int )iev.code - 256;
#line 271
    inp->val = iev.value;
#line 272
    goto switch_break;
    case_0: /* CIL Label */ 
#line 275
    inp->type = 2;
#line 276
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 279
    return (-1);
    switch_break: /* CIL Label */ ;
    }
  }
#line 283
  return (0);
}
}
#line 286 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
void set_led(int state ) 
{ 
  struct input_event ev___0 ;
  char const   *tmp ;
  ssize_t tmp___0 ;

  {
#line 290
  if (dev_fd == -1) {
    {
#line 291
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"set_led failed, invalid dev_fd\n");
    }
#line 292
    return;
  }
  {
#line 295
  memset((void *)(& ev___0), 0, sizeof(ev___0));
#line 296
  ev___0.type = (__u16 )17;
#line 297
  ev___0.code = (__u16 )8;
#line 298
  ev___0.value = state;
#line 300
  tmp___0 = write(dev_fd, (void const   *)(& ev___0), sizeof(ev___0));
  }
#line 300
  if (tmp___0 == -1L) {
#line 301
    if (state) {
#line 301
      tmp = "on";
    } else {
#line 301
      tmp = "off";
    }
    {
#line 301
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to turn LED %s\n",
            tmp);
    }
  }
#line 303
  return;
}
}
#line 305 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static int open_dev_usb(char const   *path___0 ) 
{ 
  int grab ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 307
  grab = 1;
#line 309
  dev_fd = open(path___0, 2);
  }
#line 309
  if (dev_fd == -1) {
    {
#line 310
    dev_fd = open(path___0, 0);
    }
#line 310
    if (dev_fd == -1) {
      {
#line 311
      perror("failed to open device");
      }
#line 312
      return (-1);
    }
    {
#line 314
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"opened device read-only, LEDs won\'t work\n");
    }
  }
  {
#line 317
  tmp = ioctl(dev_fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 6U) | (sizeof(dev_name) << 16),
              dev_name);
  }
#line 317
  if (tmp == -1) {
    {
#line 318
    perror("EVIOCGNAME ioctl failed\n");
#line 319
    strcpy((char */* __restrict  */)(dev_name), (char const   */* __restrict  */)"unknown");
    }
  }
  {
#line 322
  tmp___0 = ioctl(dev_fd, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 32U) | (sizeof(evtype_mask) << 16),
                  evtype_mask);
  }
#line 322
  if (tmp___0 == -1) {
    {
#line 323
    perror("EVIOCGBIT ioctl failed\n");
#line 324
    close(dev_fd);
    }
#line 325
    return (-1);
  }
  {
#line 329
  tmp___1 = ioctl(dev_fd, (unsigned long )(((1U << 30) | (unsigned int )(69 << 8)) | 144U) | (sizeof(int ) << 16),
                  & grab);
  }
#line 329
  if (tmp___1 == -1) {
    {
#line 330
    perror("failed to grab the spacenav device");
    }
  }
  {
#line 334
  tmp___2 = fcntl(dev_fd, 3);
#line 334
  fcntl(dev_fd, 4, tmp___2 | 2048);
  }
#line 336
  if (cfg.led) {
    {
#line 337
    set_led(1);
    }
  }
#line 339
  return (dev_fd);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static char path[128]  ;
#line 344 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_linux.c"
static char *get_dev_path(void) 
{ 
  int i ;
  int valid_vendor ;
  int valid_str ;
  char buf[1024] ;
  FILE *fp ;
  char *tmp ;
  char *tmp___0 ;
  char *ptr ;
  char *start ;
  char *tmp___1 ;
  int fd___0 ;
  int *tmp___2 ;
  char *tmp___3 ;
  int *tmp___4 ;
  int *tmp___5 ;
  char *tmp___6 ;
  int tmp___7 ;
  char const   *tmp___8 ;
  char *tmp___9 ;

  {
#line 347
  valid_vendor = 0;
#line 347
  valid_str = 0;
#line 351
  if (verbose) {
    {
#line 352
    printf((char const   */* __restrict  */)"Device detection, parsing /proc/bus/input/devices\n");
    }
  }
  {
#line 355
  fp = fopen((char const   */* __restrict  */)"/proc/bus/input/devices", (char const   */* __restrict  */)"r");
  }
#line 355
  if (fp) {
    {
#line 356
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 356
      tmp___1 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
      }
#line 356
      if (! tmp___1) {
#line 356
        goto while_break;
      }
      {
#line 358
      if ((int )buf[0] == 73) {
#line 358
        goto case_73;
      }
#line 362
      if ((int )buf[0] == 78) {
#line 362
        goto case_78;
      }
#line 366
      if ((int )buf[0] == 72) {
#line 366
        goto case_72;
      }
#line 392
      if ((int )buf[0] == 10) {
#line 392
        goto case_10;
      }
#line 396
      goto switch_default;
      case_73: /* CIL Label */ 
      {
#line 359
      tmp = strstr((char const   *)(buf), "Vendor=046d");
#line 359
      valid_vendor = (unsigned long )tmp != (unsigned long )((char *)0);
      }
#line 360
      goto switch_break;
      case_78: /* CIL Label */ 
      {
#line 363
      tmp___0 = strstr((char const   *)(buf), "3Dconnexion");
#line 363
      valid_str = (unsigned long )tmp___0 != (unsigned long )((char *)0);
      }
#line 364
      goto switch_break;
      case_72: /* CIL Label */ 
#line 367
      if (valid_str) {
#line 367
        if (valid_vendor) {
          {
#line 370
          start = strchr((char const   *)(buf), '=');
          }
#line 370
          if (! start) {
#line 371
            goto while_continue;
          }
          {
#line 373
          start ++;
#line 375
          ptr = strstr((char const   *)start, "event");
          }
#line 375
          if (ptr) {
#line 376
            start = ptr;
          }
          {
#line 379
          ptr = strchr((char const   *)start, ' ');
          }
#line 379
          if (ptr) {
#line 380
            *ptr = (char)0;
          }
          {
#line 382
          ptr = strchr((char const   *)start, '\n');
          }
#line 382
          if (ptr) {
#line 383
            *ptr = (char)0;
          }
          {
#line 386
          snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/dev/input/%s",
                   start);
#line 387
          fclose(fp);
          }
#line 388
          return (path);
        }
      }
#line 390
      goto switch_break;
      case_10: /* CIL Label */ 
#line 393
      valid_str = 0;
#line 393
      valid_vendor = valid_str;
#line 394
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 397
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 400
    fclose(fp);
    }
  } else
#line 402
  if (verbose) {
    {
#line 403
    perror("failed to open /proc/bus/input/devices");
    }
  }
#line 407
  if (verbose) {
    {
#line 408
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"trying alternative detection, querying /dev/input/eventX device names...\n");
    }
  }
#line 415
  i = 0;
  {
#line 416
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 419
    i ++;
#line 419
    snprintf((char */* __restrict  */)(path), sizeof(path), (char const   */* __restrict  */)"/dev/input/event%d",
             i);
    }
#line 421
    if (verbose) {
      {
#line 422
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  trying \"%s\" ... ",
              path);
      }
    }
    {
#line 425
    fd___0 = open((char const   *)(path), 0);
    }
#line 425
    if (fd___0 == -1) {
      {
#line 426
      tmp___4 = __errno_location();
      }
#line 426
      if (*tmp___4 != 2) {
        {
#line 427
        tmp___2 = __errno_location();
#line 427
        tmp___3 = strerror(*tmp___2);
#line 427
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open %s: %s. this might hinder device detection\n",
                path, tmp___3);
        }
#line 429
        goto __Cont;
      } else {
#line 431
        goto while_break___0;
      }
    }
    {
#line 435
    tmp___7 = ioctl(fd___0, (unsigned long )(((2U << 30) | (unsigned int )(69 << 8)) | 6U) | (sizeof(buf) << 16),
                    buf);
    }
#line 435
    if (tmp___7 == -1) {
      {
#line 436
      tmp___5 = __errno_location();
#line 436
      tmp___6 = strerror(*tmp___5);
#line 436
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to get device name for device %s: %s. this might hinder device detection\n",
              path, tmp___6);
#line 438
      buf[0] = (char)0;
      }
    }
#line 441
    if (verbose) {
#line 442
      if (buf[0]) {
#line 442
        tmp___8 = (char const   *)(buf);
      } else {
#line 442
        tmp___8 = "unknown";
      }
      {
#line 442
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              tmp___8);
      }
    }
    {
#line 445
    tmp___9 = strstr((char const   *)(buf), "3Dconnexion");
    }
#line 445
    if (tmp___9) {
      {
#line 446
      close(fd___0);
      }
#line 447
      return (path);
    }
    {
#line 449
    close(fd___0);
    }
    __Cont: /* CIL Label */ ;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 452
  return ((char *)0);
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.h"
int init_clients(void) ;
#line 45
Window get_client_window(struct client *client ) ;
#line 43 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
static struct client *client_list  ;
#line 44 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
static struct client *citer  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
int init_clients(void) 
{ 
  void *tmp ;

  {
  {
#line 48
  tmp = malloc(sizeof(*client_list));
#line 48
  client_list = (struct client *)tmp;
  }
#line 48
  if (! client_list) {
    {
#line 49
    perror("failed to allocate client list");
    }
#line 50
    return (-1);
  }
#line 52
  client_list->next = (struct client *)0;
#line 53
  return (0);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
struct client *add_client(int type , void *cdata ) 
{ 
  struct client *client ;
  void *tmp ;

  {
#line 66
  if (! cdata) {
#line 71
    return ((struct client *)0);
  } else
#line 66
  if (type != 1) {
#line 66
    if (type != 0) {
#line 71
      return ((struct client *)0);
    }
  }
  {
#line 74
  tmp = malloc(sizeof(*client));
#line 74
  client = (struct client *)tmp;
  }
#line 74
  if (! client) {
#line 75
    return ((struct client *)0);
  }
#line 78
  client->type = type;
#line 79
  if (type == 1) {
#line 80
    client->sock = *((int *)cdata);
  } else {
#line 83
    client->win = *((Window *)cdata);
  }
#line 87
  client->sens = 1.0f;
#line 88
  client->next = client_list->next;
#line 89
  client_list->next = client;
#line 91
  return (client);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
void remove_client(struct client *client ) 
{ 
  struct client *iter ;
  struct client *tmp ;

  {
#line 96
  iter = client_list;
  {
#line 98
  while (1) {
    while_continue: /* CIL Label */ ;
#line 98
    if (! iter->next) {
#line 98
      goto while_break;
    }
#line 99
    if ((unsigned long )iter->next == (unsigned long )client) {
      {
#line 100
      tmp = iter->next;
#line 101
      iter->next = tmp->next;
#line 102
      free((void *)tmp);
      }
    } else {
#line 104
      iter = iter->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return;
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
int get_client_type(struct client *client ) 
{ 


  {
#line 111
  return (client->type);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
int get_client_socket(struct client *client ) 
{ 


  {
#line 116
  return (client->sock);
}
}
#line 120 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
Window get_client_window(struct client *client ) 
{ 


  {
#line 122
  return (client->win);
}
}
#line 126 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
void set_client_sensitivity(struct client *client , float sens ) 
{ 


  {
#line 128
  client->sens = sens;
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
float get_client_sensitivity(struct client *client ) 
{ 


  {
#line 133
  return (client->sens);
}
}
#line 136 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
struct client *first_client(void) 
{ 


  {
#line 138
  citer = client_list->next;
#line 138
  return (citer);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/client.c"
struct client *next_client(void) 
{ 


  {
#line 143
  citer = citer->next;
#line 144
  return (citer);
}
}
/* compiler builtin: 
   void *__builtin_alloca(unsigned long  ) ;  */
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 564 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 399 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 63 "/usr/include/setjmp.h"
extern  __attribute__((__nothrow__)) int _setjmp(struct __jmp_buf_tag *__env ) ;
#line 74
extern  __attribute__((__nothrow__, __noreturn__)) void longjmp(struct __jmp_buf_tag *__env ,
                                                                int __val ) ;
#line 675 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __uid_t ( __attribute__((__leaf__)) getuid)(void) ;
#line 110 "/usr/include/pwd.h"
extern struct passwd *getpwuid(__uid_t __uid ) ;
#line 1495 "/usr/include/X11/Xlib.h"
extern Display *XOpenDisplay(char const   * ) ;
#line 1548
extern Atom XInternAtom(Display * , char const   * , int  ) ;
#line 1648
extern Window XCreateWindow(Display * , Window  , int  , int  , unsigned int  , unsigned int  ,
                            unsigned int  , int  , unsigned int  , Visual * , unsigned long  ,
                            XSetWindowAttributes * ) ;
#line 1860
extern XErrorHandler XSetErrorHandler(int (*)(Display * , XErrorEvent * ) ) ;
#line 1869
extern XIOErrorHandler XSetIOErrorHandler(int (*)(Display * ) ) ;
#line 1900
extern int XSetWMProtocols(Display * , Window  , Atom * , int  ) ;
#line 2080
extern int XChangeProperty(Display * , Window  , Atom  , Atom  , int  , int  , unsigned char const   * ,
                           int  ) ;
#line 2172
extern int XCloseDisplay(Display * ) ;
#line 2249
extern int XDeleteProperty(Display * , Window  , Atom  ) ;
#line 2255
extern int XDestroyWindow(Display * , Window  ) ;
#line 2519
extern int XFlush(Display * ) ;
#line 2528
extern int XFree(void * ) ;
#line 2612
extern int XGetErrorText(Display * , int  , char * , int  ) ;
#line 2853
extern int XNextEvent(Display * , XEvent * ) ;
#line 2893
extern int XPending(Display * ) ;
#line 3147
extern int XSendEvent(Display * , Window  , int  , long  , XEvent * ) ;
#line 583 "/usr/include/X11/Xutil.h"
extern int XSetClassHint(Display * , Window  , XClassHint * ) ;
#line 653
extern void XSetWMName(Display * , Window  , XTextProperty * ) ;
#line 733
extern int XStringListToTextProperty(char ** , int  , XTextProperty * ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.h"
int init_x11(void) ;
#line 30
void close_x11(void) ;
#line 32
int get_x11_socket(void) ;
#line 34
void send_xevent(spnav_event *ev___0 , struct client *c ) ;
#line 35
int handle_xevents(fd_set *rset ) ;
#line 37
void set_client_window(Window win___0 ) ;
#line 38
void remove_client_window(Window win___0 ) ;
#line 24 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/xdetect.h"
int xdet_start(void) ;
#line 25
void xdet_stop(void) ;
#line 27
int xdet_get_fd(void) ;
#line 29
int handle_xdet_events(fd_set *rset ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static int xerr(Display *dpy___0 , XErrorEvent *err ) ;
#line 43
static int xioerr(Display *display ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static Display *dpy  ;
#line 46 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static Window win  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static Atom xa_event_motion  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static Atom xa_event_bpress  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static Atom xa_event_brelease  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static Atom xa_event_cmd  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static float x11_sens  =    (float )1.0;
#line 56 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static jmp_buf jbuf  ;
#line 59 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
int init_x11(void) 
{ 
  int i ;
  int screen ;
  int scr_count ;
  Window root ;
  XSetWindowAttributes xattr ;
  Atom wm_delete ;
  Atom cmd_type ;
  XTextProperty tp_wname ;
  XClassHint class_hint ;
  char *win_title ;
  char *tmp ;
  struct passwd *p ;
  __uid_t tmp___0 ;
  struct passwd *tmp___1 ;
  char *home ;
  char const   *tmp___2 ;
  char *buf ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  Window root___0 ;

  {
#line 67
  win_title = (char *)"Magellan Window";
#line 69
  if (dpy) {
#line 69
    return (0);
  }
  {
#line 74
  tmp = getenv("DISPLAY");
  }
#line 74
  if (! tmp) {
    {
#line 75
    putenv((char *)"DISPLAY=:0.0");
    }
  }
  {
#line 79
  tmp___7 = getenv("XAUTHORITY");
  }
#line 79
  if (! tmp___7) {
    {
#line 80
    tmp___0 = getuid();
#line 80
    tmp___1 = getpwuid(tmp___0);
#line 80
    p = tmp___1;
    }
#line 81
    if (p->pw_dir) {
#line 81
      tmp___2 = (char const   *)p->pw_dir;
    } else {
#line 81
      tmp___2 = "/tmp";
    }
    {
#line 81
    home = (char *)tmp___2;
#line 82
    tmp___3 = strlen("XAUTHORITY=");
#line 82
    tmp___4 = strlen((char const   *)home);
#line 82
    tmp___5 = strlen("/.Xauthority");
#line 82
    tmp___6 = __builtin_alloca(((tmp___3 + tmp___4) + tmp___5) + 1UL);
#line 82
    buf = (char *)tmp___6;
#line 83
    sprintf((char */* __restrict  */)buf, (char const   */* __restrict  */)"XAUTHORITY=%s/.Xauthority",
            home);
#line 84
    putenv(buf);
    }
  }
#line 87
  if (verbose) {
    {
#line 88
    tmp___8 = getenv("DISPLAY");
#line 88
    printf((char const   */* __restrict  */)"trying to open X11 display \"%s\"\n",
           tmp___8);
#line 89
    tmp___9 = getenv("XAUTHORITY");
#line 89
    printf((char const   */* __restrict  */)"   XAUTHORITY=%s\n", tmp___9);
    }
  }
  {
#line 92
  dpy = XOpenDisplay((char const   *)0);
  }
#line 92
  if (! dpy) {
    {
#line 93
    tmp___10 = getenv("DISPLAY");
#line 93
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open X11 display \"%s\"\n",
            tmp___10);
#line 95
    xdet_start();
    }
#line 96
    return (-1);
  }
  {
#line 99
  XSetErrorHandler(& xerr);
#line 100
  XSetIOErrorHandler(& xioerr);
#line 102
  tmp___11 = _setjmp((struct __jmp_buf_tag *)(jbuf));
  }
#line 102
  if (tmp___11) {
#line 103
    return (-1);
  }
  {
#line 106
  scr_count = ((_XPrivDisplay )dpy)->nscreens;
#line 107
  screen = ((_XPrivDisplay )dpy)->default_screen;
#line 108
  root = (((_XPrivDisplay )dpy)->screens + screen)->root;
#line 111
  xa_event_motion = XInternAtom(dpy, "MotionEvent", 0);
#line 112
  xa_event_bpress = XInternAtom(dpy, "ButtonPressEvent", 0);
#line 113
  xa_event_brelease = XInternAtom(dpy, "ButtonReleaseEvent", 0);
#line 114
  xa_event_cmd = XInternAtom(dpy, "CommandEvent", 0);
#line 119
  xattr.border_pixel = (((_XPrivDisplay )dpy)->screens + screen)->black_pixel;
#line 119
  xattr.background_pixel = xattr.border_pixel;
#line 120
  xattr.colormap = (((_XPrivDisplay )dpy)->screens + screen)->cmap;
#line 122
  win = XCreateWindow(dpy, root, 0, 0, 10U, 10U, 0U, 0, 1U, (((_XPrivDisplay )dpy)->screens + screen)->root_visual,
                      (unsigned long )(((1L << 13) | (1L << 1)) | (1L << 3)), & xattr);
#line 125
  wm_delete = XInternAtom(dpy, "WM_DELETE_WINDOW", 0);
#line 126
  XSetWMProtocols(dpy, win, & wm_delete, 1);
#line 128
  XStringListToTextProperty(& win_title, 1, & tp_wname);
#line 129
  XSetWMName(dpy, win, & tp_wname);
#line 130
  XFree((void *)tp_wname.value);
#line 132
  class_hint.res_name = (char *)"magellan";
#line 133
  class_hint.res_class = (char *)"magellan_win";
#line 134
  XSetClassHint(dpy, win, & class_hint);
#line 140
  cmd_type = XInternAtom(dpy, "MagellanCmdType", 0);
#line 141
  i = 0;
  }
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < scr_count)) {
#line 141
      goto while_break;
    }
    {
#line 142
    root___0 = (((_XPrivDisplay )dpy)->screens + i)->root;
#line 143
    XChangeProperty(dpy, root___0, xa_event_cmd, cmd_type, 32, 0, (unsigned char const   *)((unsigned char *)(& win)),
                    1);
#line 141
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 145
  XFlush(dpy);
#line 147
  xdet_stop();
  }
#line 148
  return (0);
}
}
#line 151 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
void close_x11(void) 
{ 
  int i ;
  int scr_count ;
  struct client *cnode ;
  char *tmp ;
  Window root ;
  int tmp___0 ;
  struct client *c ;
  int tmp___1 ;

  {
#line 156
  if (dpy) {
    {
#line 156
    tmp___0 = _setjmp((struct __jmp_buf_tag *)(jbuf));
    }
#line 156
    if (tmp___0 == 0) {
#line 157
      if (verbose) {
        {
#line 158
        tmp = getenv("DISPLAY");
#line 158
        printf((char const   */* __restrict  */)"closing X11 connection to display \"%s\"\n",
               tmp);
        }
      }
#line 162
      scr_count = ((_XPrivDisplay )dpy)->nscreens;
#line 163
      i = 0;
      {
#line 163
      while (1) {
        while_continue: /* CIL Label */ ;
#line 163
        if (! (i < scr_count)) {
#line 163
          goto while_break;
        }
        {
#line 164
        root = (((_XPrivDisplay )dpy)->screens + i)->root;
#line 165
        XDeleteProperty(dpy, root, xa_event_cmd);
#line 163
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 168
      XDestroyWindow(dpy, win);
#line 169
      XCloseDisplay(dpy);
#line 170
      dpy = (Display *)0;
      }
    }
  }
  {
#line 174
  cnode = first_client();
  }
  {
#line 175
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 175
    if (! cnode) {
#line 175
      goto while_break___0;
    }
    {
#line 176
    c = cnode;
#line 177
    cnode = next_client();
#line 179
    tmp___1 = get_client_type(c);
    }
#line 179
    if (tmp___1 == 0) {
      {
#line 180
      remove_client(c);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
int get_x11_socket(void) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 187
  if (dpy) {
#line 187
    tmp___0 = ((_XPrivDisplay )dpy)->fd;
  } else {
    {
#line 187
    tmp = xdet_get_fd();
#line 187
    tmp___0 = tmp;
    }
  }
#line 187
  return (tmp___0);
}
}
#line 190 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
void send_xevent(spnav_event *ev___0 , struct client *c ) 
{ 
  int i ;
  XEvent xevent ;
  int tmp ;
  float val ;
  Window tmp___0 ;

  {
#line 195
  if (! dpy) {
#line 195
    return;
  }
  {
#line 197
  tmp = _setjmp((struct __jmp_buf_tag *)(jbuf));
  }
#line 197
  if (tmp) {
#line 198
    return;
  }
  {
#line 201
  xevent.type = 33;
#line 202
  xevent.xclient.send_event = 0;
#line 203
  xevent.xclient.display = dpy;
#line 204
  xevent.xclient.window = get_client_window(c);
  }
  {
#line 207
  if (ev___0->type == 0) {
#line 207
    goto case_0;
  }
#line 219
  if (ev___0->type == 1) {
#line 219
    goto case_1;
  }
#line 225
  goto switch_default;
  case_0: /* CIL Label */ 
#line 208
  xevent.xclient.message_type = xa_event_motion;
#line 209
  xevent.xclient.format = 16;
#line 211
  i = 0;
  {
#line 211
  while (1) {
    while_continue: /* CIL Label */ ;
#line 211
    if (! (i < 6)) {
#line 211
      goto while_break;
    }
#line 212
    val = (float )*(ev___0->motion.data + i) * x11_sens;
#line 213
    xevent.xclient.data.s[i + 2] = (short )val;
#line 211
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  xevent.xclient.data.s[1] = (short)0;
#line 215
  xevent.xclient.data.s[0] = xevent.xclient.data.s[1];
#line 216
  xevent.xclient.data.s[8] = (short )ev___0->motion.period;
#line 217
  goto switch_break;
  case_1: /* CIL Label */ 
#line 220
  if (ev___0->button.press) {
#line 220
    xevent.xclient.message_type = xa_event_bpress;
  } else {
#line 220
    xevent.xclient.message_type = xa_event_brelease;
  }
#line 221
  xevent.xclient.format = 16;
#line 222
  xevent.xclient.data.s[2] = (short )ev___0->button.bnum;
#line 223
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 226
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 229
  tmp___0 = get_client_window(c);
#line 229
  XSendEvent(dpy, tmp___0, 0, 0L, & xevent);
#line 230
  XFlush(dpy);
  }
#line 231
  return;
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
int handle_xevents(fd_set *rset ) 
{ 
  int tmp ;
  int tmp___0 ;
  XEvent xev ;
  unsigned int win_id ;
  int tmp___1 ;

  {
#line 235
  if (! dpy) {
    {
#line 236
    tmp = xdet_get_fd();
    }
#line 236
    if (tmp != -1) {
      {
#line 237
      handle_xdet_events(rset);
      }
    }
#line 239
    return (-1);
  }
#line 243
  if ((rset->__fds_bits[((_XPrivDisplay )dpy)->fd / (8 * (int )sizeof(__fd_mask ))] & (1L << ((_XPrivDisplay )dpy)->fd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
    {
#line 244
    tmp___0 = _setjmp((struct __jmp_buf_tag *)(jbuf));
    }
#line 244
    if (tmp___0) {
#line 245
      return (0);
    }
    {
#line 248
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 248
      tmp___1 = XPending(dpy);
      }
#line 248
      if (! tmp___1) {
#line 248
        goto while_break;
      }
      {
#line 250
      XNextEvent(dpy, & xev);
      }
#line 252
      if (xev.type == 33) {
#line 252
        if (xev.xclient.message_type == xa_event_cmd) {
          {
#line 256
          if ((int )xev.xclient.data.s[2] == 27695) {
#line 256
            goto case_27695;
          }
#line 263
          if ((int )xev.xclient.data.s[2] == 27696) {
#line 263
            goto case_27696;
          }
#line 267
          goto switch_default;
          case_27695: /* CIL Label */ 
          {
#line 257
          win_id = (unsigned int )xev.xclient.data.s[1];
#line 258
          win_id |= (unsigned int )xev.xclient.data.s[0] << 16;
#line 260
          set_client_window((Window )win_id);
          }
#line 261
          goto switch_break;
          case_27696: /* CIL Label */ 
#line 264
          x11_sens = *((float *)(xev.xclient.data.s));
#line 265
          goto switch_break;
          switch_default: /* CIL Label */ 
#line 268
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
        }
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 274
  return (0);
}
}
#line 278 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
void set_client_window(Window win___0 ) 
{ 
  int i ;
  int scr_count ;
  struct client *cnode ;
  Window tmp ;

  {
#line 288
  scr_count = ((_XPrivDisplay )dpy)->nscreens;
#line 289
  i = 0;
  {
#line 289
  while (1) {
    while_continue: /* CIL Label */ ;
#line 289
    if (! (i < scr_count)) {
#line 289
      goto while_break;
    }
#line 290
    if (win___0 == (((_XPrivDisplay )dpy)->screens + i)->root) {
#line 291
      return;
    }
#line 289
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 296
  cnode = first_client();
  }
  {
#line 297
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 297
    if (! cnode) {
#line 297
      goto while_break___0;
    }
    {
#line 298
    tmp = get_client_window(cnode);
    }
#line 298
    if (tmp == win___0) {
#line 299
      return;
    }
    {
#line 301
    cnode = next_client();
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 304
  add_client(0, (void *)(& win___0));
  }
#line 305
  return;
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
void remove_client_window(Window win___0 ) 
{ 
  struct client *c ;
  struct client *cnode ;
  Window tmp ;

  {
  {
#line 311
  cnode = first_client();
  }
  {
#line 312
  while (1) {
    while_continue: /* CIL Label */ ;
#line 312
    if (! cnode) {
#line 312
      goto while_break;
    }
    {
#line 313
    c = cnode;
#line 314
    cnode = next_client();
#line 316
    tmp = get_client_window(c);
    }
#line 316
    if (tmp == win___0) {
      {
#line 317
      remove_client(c);
      }
#line 318
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 321
  return;
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static int xerr(Display *dpy___0 , XErrorEvent *err ) 
{ 
  char buf[512] ;

  {
#line 329
  if (verbose) {
    {
#line 330
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"xerr(%p, %p)\n",
            (void *)dpy___0, (void *)err);
    }
  }
#line 333
  if ((int )err->error_code == 3) {
    {
#line 337
    remove_client_window(err->resourceid);
    }
  } else {
    {
#line 339
    XGetErrorText(dpy___0, (int )err->error_code, buf, (int )sizeof(buf));
#line 340
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Caught unexpected X error: %s\n",
            buf);
    }
  }
#line 342
  return (0);
}
}
#line 348 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/proto_x11.c"
static int xioerr(Display *display ) 
{ 


  {
  {
#line 350
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Lost the X server!\n");
#line 351
  dpy = (Display *)0;
#line 352
  close_x11();
#line 353
  xdet_start();
#line 355
  longjmp((struct __jmp_buf_tag *)(jbuf), 1);
  }
#line 357
  return (0);
}
}
#line 775 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 66 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.h"
void process_input(struct dev_input *inp ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.c"
static void dispatch_event(spnav_event *ev___0 ) ;
#line 33
static void send_event(spnav_event *ev___0 , struct client *c ) ;
#line 34
static unsigned int msec_dif(struct timeval tv1 , struct timeval tv2 ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.c"
static spnav_event ev  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.c"
static int ev_pending  ;
#line 45 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.c"
void process_input(struct dev_input *inp ) 
{ 
  int sign ;
  int tmp ;
  float tmp___0 ;

  {
  {
#line 50
  if (inp->type == 0) {
#line 50
    goto case_0;
  }
#line 66
  if (inp->type == 1) {
#line 66
    goto case_1;
  }
#line 79
  if (inp->type == 2) {
#line 79
    goto case_2;
  }
#line 86
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 51
  tmp = abs(inp->val);
  }
#line 51
  if (tmp < cfg.dead_threshold) {
#line 52
    goto switch_break;
  }
#line 55
  inp->idx = cfg.map_axis[inp->idx];
#line 56
  if (cfg.invert[inp->idx]) {
#line 56
    sign = -1;
  } else {
#line 56
    sign = 1;
  }
#line 58
  if (inp->idx < 3) {
#line 58
    tmp___0 = cfg.sens_trans;
  } else {
#line 58
    tmp___0 = cfg.sens_rot;
  }
#line 58
  inp->val = (int )(((float )inp->val * cfg.sensitivity) * tmp___0);
#line 60
  ev.type = 0;
#line 61
  ev.motion.data = & ev.motion.x;
#line 62
  *(ev.motion.data + inp->idx) = sign * inp->val;
#line 63
  ev_pending = 1;
#line 64
  goto switch_break;
  case_1: /* CIL Label */ 
#line 67
  if (ev_pending) {
    {
#line 68
    dispatch_event(& ev);
#line 69
    ev_pending = 0;
    }
  }
  {
#line 71
  inp->idx = cfg.map_button[inp->idx];
#line 73
  ev.type = 1;
#line 74
  ev.button.press = inp->val;
#line 75
  ev.button.bnum = inp->idx;
#line 76
  dispatch_event(& ev);
  }
#line 77
  goto switch_break;
  case_2: /* CIL Label */ 
#line 80
  if (ev_pending) {
    {
#line 81
    dispatch_event(& ev);
#line 82
    ev_pending = 0;
    }
  }
#line 84
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 87
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 89
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.c"
static struct timeval prev_motion_time  ;
#line 91 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.c"
static void dispatch_event(spnav_event *ev___0 ) 
{ 
  struct client *c ;
  struct client *citer___0 ;
  struct timeval tv ;

  {
#line 96
  if (ev___0->type == 0) {
    {
#line 98
    gettimeofday((struct timeval */* __restrict  */)(& tv), (__timezone_ptr_t )0);
#line 100
    ev___0->motion.period = msec_dif(tv, prev_motion_time);
#line 101
    prev_motion_time = tv;
    }
  }
  {
#line 104
  citer___0 = first_client();
  }
  {
#line 105
  while (1) {
    while_continue: /* CIL Label */ ;
#line 105
    if (! citer___0) {
#line 105
      goto while_break;
    }
    {
#line 106
    c = citer___0;
#line 107
    citer___0 = next_client();
#line 109
    send_event(ev___0, c);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.c"
static void send_event(spnav_event *ev___0 , struct client *c ) 
{ 
  int tmp ;

  {
  {
#line 115
  tmp = get_client_type(c);
  }
  {
#line 117
  if (tmp == 0) {
#line 117
    goto case_0;
  }
#line 122
  if (tmp == 1) {
#line 122
    goto case_1;
  }
#line 126
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 118
  send_xevent(ev___0, c);
  }
#line 119
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 123
  send_uevent(ev___0, c);
  }
#line 124
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 127
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 129
  return;
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/event.c"
static unsigned int msec_dif(struct timeval tv1 , struct timeval tv2 ) 
{ 
  unsigned int ds ;
  unsigned int du ;

  {
#line 135
  ds = (unsigned int )(tv2.tv_sec - tv1.tv_sec);
#line 136
  du = (unsigned int )(tv2.tv_usec - tv1.tv_usec);
#line 137
  return (ds * 1000U + du / 1000U);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 178
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) remove)(char const   *__filename ) ;
#line 336
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) setvbuf)(FILE * __restrict  __stream ,
                                                                              char * __restrict  __buf ,
                                                                              int __modes ,
                                                                              size_t __n ) ;
#line 695
extern int puts(char const   *__s ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 519 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atexit)(void (*__func)(void) ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 497 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) chdir)(char const   *__path ) ;
#line 531
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup)(int __fd ) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/cfgfile.h"
int read_cfg(char const   *fname , struct cfg *cfg___0 ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.c"
static void cleanup(void) ;
#line 36
static void daemonize(void) ;
#line 37
static int write_pid_file(void) ;
#line 38
static void handle_events(fd_set *rset ) ;
#line 39
static void sig_handler(int s ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int ret ;
  int become_daemon ;
  int tmp ;
  int tmp___0 ;
  fd_set rset ;
  int fd___0 ;
  int max_fd ;
  struct client *c ;
  int __d0 ;
  int __d1 ;
  int s ;
  int tmp___1 ;
  int tmp___2 ;
  int *tmp___3 ;

  {
#line 44
  become_daemon = 1;
#line 46
  i = 1;
  {
#line 46
  while (1) {
    while_continue: /* CIL Label */ ;
#line 46
    if (! (i < argc)) {
#line 46
      goto while_break;
    }
#line 47
    if ((int )*(*(argv + i) + 0) == 45) {
#line 47
      if ((int )*(*(argv + i) + 2) == 0) {
        {
#line 49
        if ((int )*(*(argv + i) + 1) == 100) {
#line 49
          goto case_100;
        }
#line 53
        if ((int )*(*(argv + i) + 1) == 118) {
#line 53
          goto case_118;
        }
#line 57
        if ((int )*(*(argv + i) + 1) == 104) {
#line 57
          goto case_104;
        }
#line 65
        goto switch_default;
        case_100: /* CIL Label */ 
#line 50
        become_daemon = ! become_daemon;
#line 51
        goto switch_break;
        case_118: /* CIL Label */ 
#line 54
        verbose = 1;
#line 55
        goto switch_break;
        case_104: /* CIL Label */ 
        {
#line 58
        printf((char const   */* __restrict  */)"usage: %s [options]\n", *(argv + 0));
#line 59
        printf((char const   */* __restrict  */)"options:\n");
#line 60
        printf((char const   */* __restrict  */)"  -d\tdo not daemonize\n");
#line 61
        printf((char const   */* __restrict  */)"  -v\tverbose output\n");
#line 62
        printf((char const   */* __restrict  */)"  -h\tprint this usage information\n");
        }
#line 63
        return (0);
        switch_default: /* CIL Label */ 
        {
#line 66
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unrecognized argument: %s\n",
                *(argv + i));
        }
#line 67
        return (1);
        switch_break: /* CIL Label */ ;
        }
      } else {
        {
#line 70
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected argument: %s\n",
                *(argv + i));
        }
#line 71
        return (1);
      }
    } else {
      {
#line 70
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unexpected argument: %s\n",
              *(argv + i));
      }
#line 71
      return (1);
    }
#line 46
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 75
  if (become_daemon) {
    {
#line 76
    daemonize();
    }
  }
  {
#line 78
  write_pid_file();
#line 80
  puts("Spacenav daemon 0.5");
#line 82
  read_cfg("/etc/spnavrc", & cfg);
#line 84
  tmp = init_clients();
  }
#line 84
  if (tmp == -1) {
#line 85
    return (1);
  }
  {
#line 88
  signal(2, & sig_handler);
#line 89
  signal(15, & sig_handler);
#line 90
  signal(11, & sig_handler);
#line 91
  signal(1, & sig_handler);
#line 92
  signal(10, & sig_handler);
#line 93
  signal(12, & sig_handler);
#line 95
  tmp___0 = init_dev();
  }
#line 95
  if (tmp___0 == -1) {
    {
#line 96
    init_hotplug();
    }
  }
  {
#line 98
  init_unix();
#line 100
  init_x11();
#line 103
  atexit(& cleanup);
  }
  {
#line 105
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    max_fd = 0;
    {
#line 110
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 110
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rset.__fds_bits[0]): "memory");
#line 110
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 113
    fd___0 = get_dev_fd();
    }
#line 113
    if (fd___0 != -1) {
#line 113
      goto _L;
    } else {
      {
#line 113
      fd___0 = get_hotplug_fd();
      }
#line 113
      if (fd___0 != -1) {
        _L: /* CIL Label */ 
#line 114
        rset.__fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd___0 % (8 * (int )sizeof(__fd_mask ));
#line 115
        if (fd___0 > max_fd) {
#line 115
          max_fd = fd___0;
        }
      }
    }
    {
#line 119
    fd___0 = get_unix_socket();
    }
#line 119
    if (fd___0 != -1) {
#line 120
      rset.__fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd___0 % (8 * (int )sizeof(__fd_mask ));
#line 121
      if (fd___0 > max_fd) {
#line 121
        max_fd = fd___0;
      }
    }
    {
#line 125
    c = first_client();
    }
    {
#line 126
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 126
      if (! c) {
#line 126
        goto while_break___2;
      }
      {
#line 127
      tmp___2 = get_client_type(c);
      }
#line 127
      if (tmp___2 == 1) {
        {
#line 128
        tmp___1 = get_client_socket(c);
#line 128
        s = tmp___1;
        }
#line 129
        if (! (s >= 0)) {
          {
#line 129
          __assert_fail("s >= 0", "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.c",
                        129U, "main");
          }
        }
#line 131
        rset.__fds_bits[s / (8 * (int )sizeof(__fd_mask ))] |= 1L << s % (8 * (int )sizeof(__fd_mask ));
#line 132
        if (s > max_fd) {
#line 132
          max_fd = s;
        }
      }
      {
#line 134
      c = next_client();
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 139
    fd___0 = get_x11_socket();
    }
#line 139
    if (fd___0 != -1) {
#line 140
      rset.__fds_bits[fd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << fd___0 % (8 * (int )sizeof(__fd_mask ));
#line 141
      if (fd___0 > max_fd) {
#line 141
        max_fd = fd___0;
      }
    }
    {
#line 145
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 146
      ret = select(max_fd + 1, (fd_set */* __restrict  */)(& rset), (fd_set */* __restrict  */)0,
                   (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)0);
      }
#line 145
      if (ret == -1) {
        {
#line 145
        tmp___3 = __errno_location();
        }
#line 145
        if (! (*tmp___3 == 4)) {
#line 145
          goto while_break___3;
        }
      } else {
#line 145
        goto while_break___3;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 149
    if (ret > 0) {
      {
#line 150
      handle_events(& rset);
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 153
  return (0);
}
}
#line 156 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.c"
static void cleanup(void) 
{ 


  {
  {
#line 159
  close_x11();
#line 161
  close_unix();
#line 162
  shutdown_dev();
#line 163
  remove("/var/run/spnavd.pid");
  }
#line 164
  return;
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.c"
static void daemonize(void) 
{ 
  int i ;
  int pid ;
  int tmp ;

  {
  {
#line 170
  pid = fork();
  }
#line 170
  if (pid == -1) {
    {
#line 171
    perror("failed to fork");
#line 172
    exit(1);
    }
  } else
#line 173
  if (pid) {
    {
#line 174
    exit(0);
    }
  }
  {
#line 177
  setsid();
#line 178
  chdir("/");
#line 181
  i = 0;
  }
  {
#line 181
  while (1) {
    while_continue: /* CIL Label */ ;
#line 181
    if (! (i < 3)) {
#line 181
      goto while_break;
    }
    {
#line 182
    close(i);
#line 181
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 185
  open("/dev/zero", 0);
#line 186
  tmp = open("/var/log/spnavd.log", 577, 420);
  }
#line 186
  if (tmp == -1) {
    {
#line 187
    open("/dev/null", 1);
    }
  }
  {
#line 189
  dup(1);
#line 191
  setvbuf((FILE */* __restrict  */)stdout, (char */* __restrict  */)0, 1, (size_t )0);
#line 192
  setvbuf((FILE */* __restrict  */)stderr, (char */* __restrict  */)0, 2, (size_t )0);
  }
#line 193
  return;
}
}
#line 195 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.c"
static int write_pid_file(void) 
{ 
  FILE *fp ;
  int pid ;
  __pid_t tmp ;

  {
  {
#line 198
  tmp = getpid();
#line 198
  pid = tmp;
#line 200
  fp = fopen((char const   */* __restrict  */)"/var/run/spnavd.pid", (char const   */* __restrict  */)"w");
  }
#line 200
  if (! fp) {
#line 201
    return (-1);
  }
  {
#line 203
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"%d\n", pid);
#line 204
  fclose(fp);
  }
#line 205
  return (0);
}
}
#line 208 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.c"
static void handle_events(fd_set *rset ) 
{ 
  int dev_fd___0 ;
  int hotplug_fd___0 ;
  struct dev_input inp ;
  int tmp ;

  {
  {
#line 213
  handle_uevents(rset);
#line 217
  handle_xevents(rset);
#line 221
  dev_fd___0 = get_dev_fd();
  }
#line 221
  if (dev_fd___0 != -1) {
#line 222
    if ((rset->__fds_bits[dev_fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << dev_fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
      {
#line 226
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 226
        tmp = read_dev(& inp);
        }
#line 226
        if (! (tmp != -1)) {
#line 226
          goto while_break;
        }
        {
#line 228
        process_input(& inp);
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 232
    hotplug_fd___0 = get_hotplug_fd();
    }
#line 232
    if (hotplug_fd___0 != -1) {
#line 233
      if ((rset->__fds_bits[hotplug_fd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << hotplug_fd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 234
        handle_hotplug();
        }
      }
    }
  }
#line 237
  return;
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/spnavd.c"
static void sig_handler(int s ) 
{ 
  int tmp ;

  {
  {
#line 247
  if (s == 1) {
#line 247
    goto case_1;
  }
#line 255
  if (s == 11) {
#line 255
    goto case_11;
  }
#line 258
  if (s == 15) {
#line 258
    goto case_15;
  }
#line 258
  if (s == 2) {
#line 258
    goto case_15;
  }
#line 262
  if (s == 10) {
#line 262
    goto case_10;
  }
#line 266
  if (s == 12) {
#line 266
    goto case_12;
  }
#line 271
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 248
  tmp = cfg.led;
#line 249
  read_cfg("/etc/spnavrc", & cfg);
  }
#line 250
  if (cfg.led != tmp) {
    {
#line 251
    set_led(cfg.led);
    }
  }
#line 253
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 256
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Segmentation fault caught, trying to exit gracefully\n");
  }
  case_15: /* CIL Label */ 
  case_2: /* CIL Label */ 
  {
#line 259
  exit(0);
  }
  case_10: /* CIL Label */ 
  {
#line 263
  init_x11();
  }
#line 264
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 267
  close_x11();
  }
#line 268
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 272
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 54 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetospeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 57
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) cfsetispeed)(struct termios *__termios_p ,
                                                                                  speed_t __speed ) ;
#line 66
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 59 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.h"
int sball_comm_open(char const   *commname , SBallCommHandle *commhandleptr ) ;
#line 61
int sball_comm_write(SBallCommHandle commhandle , char const   *buf ) ;
#line 63
int sball_comm_read(SBallCommHandle commhandle , char *buf , int sz ) ;
#line 65
int sball_comm_close(SBallCommHandle *commhandleptr ) ;
#line 67
int sball_comm_fd(SBallCommHandle commhandle ) ;
#line 60 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.c"
int sball_comm_open(char const   *commname , SBallCommHandle *commhandleptr ) 
{ 
  struct termios sballtermio ;
  commstruct *comm ;
  void *tmp ;

  {
  {
#line 66
  *commhandleptr = (void *)0;
#line 68
  tmp = malloc(sizeof(commstruct ));
#line 68
  comm = (commstruct *)tmp;
  }
#line 69
  if ((unsigned long )comm == (unsigned long )((void *)0)) {
#line 70
    return (-1);
  }
  {
#line 72
  comm->fd = open(commname, 2306);
  }
#line 74
  if (comm->fd == -1) {
    {
#line 75
    free((void *)comm);
    }
#line 76
    return (-1);
  }
  {
#line 78
  tcgetattr(comm->fd, & sballtermio);
#line 89
  sballtermio.c_lflag = (tcflag_t )0;
#line 90
  sballtermio.c_lflag = (tcflag_t )0;
#line 91
  sballtermio.c_iflag = (tcflag_t )5;
#line 92
  sballtermio.c_oflag = (tcflag_t )0;
#line 93
  sballtermio.c_cflag = (tcflag_t )3248;
#line 94
  sballtermio.c_cc[11] = (cc_t )'\r';
#line 95
  sballtermio.c_cc[2] = (cc_t )0;
#line 96
  sballtermio.c_cc[3] = (cc_t )0;
#line 97
  sballtermio.c_cc[6] = (cc_t )0;
#line 98
  sballtermio.c_cc[5] = (cc_t )0;
#line 102
  cfsetispeed(& sballtermio, (speed_t )13);
#line 103
  cfsetospeed(& sballtermio, (speed_t )13);
#line 105
  tcsetattr(comm->fd, 2, (struct termios  const  *)(& sballtermio));
#line 107
  *commhandleptr = (SBallCommHandle )comm;
  }
#line 109
  return (0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.c"
int sball_comm_write(SBallCommHandle commhandle , char const   *buf ) 
{ 
  commstruct *comm ;
  size_t tmp ;
  ssize_t tmp___0 ;

  {
#line 114
  comm = (commstruct *)commhandle;
#line 116
  if ((unsigned long )comm == (unsigned long )((void *)0)) {
#line 117
    return (-1);
  }
  {
#line 119
  tmp = strlen(buf);
#line 119
  tmp___0 = write(comm->fd, (void const   *)buf, tmp);
  }
#line 119
  return ((int )tmp___0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.c"
int sball_comm_read(SBallCommHandle commhandle , char *buf , int sz ) 
{ 
  commstruct *comm ;
  ssize_t tmp ;

  {
#line 124
  comm = (commstruct *)commhandle;
#line 126
  if ((unsigned long )comm == (unsigned long )((void *)0)) {
#line 127
    return (-1);
  }
  {
#line 129
  tmp = read(comm->fd, (void *)buf, (size_t )sz);
  }
#line 129
  return ((int )tmp);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.c"
int sball_comm_close(SBallCommHandle *commhandleptr ) 
{ 
  commstruct *comm ;

  {
#line 134
  comm = (commstruct *)*commhandleptr;
#line 136
  if ((unsigned long )comm == (unsigned long )((void *)0)) {
#line 137
    return (-1);
  }
  {
#line 139
  close(comm->fd);
#line 141
  free(*commhandleptr);
#line 142
  *commhandleptr = (void *)0;
  }
#line 144
  return (0);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sballserial.c"
int sball_comm_fd(SBallCommHandle commhandle ) 
{ 


  {
#line 149
  return (((commstruct *)commhandle)->fd);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.h"
SBallHandle sball_open(char const   *sballname ) ;
#line 110
int sball_close(SBallHandle voidhandle ) ;
#line 129
int sball_get_input(SBallHandle voidhandle , struct dev_input *inp ) ;
#line 134
int sball_get_fd(SBallHandle voidhandle ) ;
#line 22 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_serial.c"
static void *dev  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_serial.c"
int open_dev_serial(char const   *devfile ) 
{ 
  int tmp ;

  {
  {
#line 26
  dev = sball_open(devfile);
  }
#line 26
  if (! dev) {
#line 27
    return (-1);
  }
  {
#line 29
  tmp = sball_get_fd(dev);
  }
#line 29
  return (tmp);
}
}
#line 32 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_serial.c"
void close_dev_serial(void) 
{ 


  {
  {
#line 34
  sball_close(dev);
  }
#line 35
  return;
}
}
#line 37 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/dev_serial.c"
int read_dev_serial(struct dev_input *inp ) 
{ 
  int tmp ;

  {
  {
#line 39
  tmp = sball_get_input(dev, inp);
  }
#line 39
  if (! tmp) {
#line 40
    return (-1);
  }
#line 42
  return (0);
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 858
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) fileno)(FILE *__stream ) ;
#line 144 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) atof)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/cfgfile.h"
void default_cfg(struct cfg *cfg___0 ) ;
#line 38
int write_cfg(char const   *fname , struct cfg *cfg___0 ) ;
#line 29 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/cfgfile.c"
static int const   def_axmap[6]  = {      (int const   )0,      (int const   )2,      (int const   )1,      (int const   )3, 
        (int const   )5,      (int const   )4};
#line 30 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/cfgfile.c"
static int const   def_axinv[6]  = {      (int const   )0,      (int const   )1,      (int const   )1,      (int const   )0, 
        (int const   )1,      (int const   )1};
#line 32 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/cfgfile.c"
void default_cfg(struct cfg *cfg___0 ) 
{ 
  int i ;
  float tmp ;
  float tmp___0 ;

  {
#line 36
  tmp___0 = (float )1.0;
#line 36
  cfg___0->sens_rot = tmp___0;
#line 36
  tmp = tmp___0;
#line 36
  cfg___0->sens_trans = tmp;
#line 36
  cfg___0->sensitivity = tmp;
#line 37
  cfg___0->dead_threshold = 2;
#line 38
  cfg___0->led = 1;
#line 40
  i = 0;
  {
#line 40
  while (1) {
    while_continue: /* CIL Label */ ;
#line 40
    if (! (i < 6)) {
#line 40
      goto while_break;
    }
#line 41
    cfg___0->invert[i] = (int )def_axinv[i];
#line 42
    cfg___0->map_axis[i] = (int )def_axmap[i];
#line 40
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 45
  i = 0;
  {
#line 45
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 45
    if (! (i < 64)) {
#line 45
      goto while_break___0;
    }
#line 46
    cfg___0->map_button[i] = i;
#line 45
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 48
  return;
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/cfgfile.c"
int read_cfg(char const   *fname , struct cfg *cfg___0 ) 
{ 
  FILE *fp ;
  char buf[512] ;
  struct flock flk ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int isnum ;
  char *key_str ;
  char *val_str ;
  char *line ;
  unsigned short const   **tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  int i ;
  int swap_yz ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;

  {
  {
#line 56
  default_cfg(cfg___0);
#line 58
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"r");
  }
#line 58
  if (! fp) {
    {
#line 59
    tmp = __errno_location();
#line 59
    tmp___0 = strerror(*tmp);
#line 59
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to open config file %s: %s. using defaults.\n",
            fname, tmp___0);
    }
#line 60
    return (-1);
  }
#line 64
  flk.l_type = (short)0;
#line 65
  flk.l_len = (__off_t )0;
#line 65
  flk.l_start = flk.l_len;
#line 66
  flk.l_whence = (short)0;
  {
#line 67
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 67
    tmp___1 = fileno(fp);
#line 67
    tmp___2 = fcntl(tmp___1, 7, & flk);
    }
#line 67
    if (! (tmp___2 == -1)) {
#line 67
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 69
    tmp___34 = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)fp);
    }
#line 69
    if (! tmp___34) {
#line 69
      goto while_break___0;
    }
#line 71
    line = buf;
    {
#line 72
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 72
      if (! ((int )*line == 32)) {
#line 72
        if (! ((int )*line == 9)) {
#line 72
          goto while_break___1;
        }
      }
#line 72
      line ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 74
    if (! *line) {
#line 75
      goto while_continue___0;
    } else
#line 74
    if ((int )*line == 10) {
#line 75
      goto while_continue___0;
    } else
#line 74
    if ((int )*line == 13) {
#line 75
      goto while_continue___0;
    } else
#line 74
    if ((int )*line == 35) {
#line 75
      goto while_continue___0;
    }
    {
#line 78
    key_str = strtok((char */* __restrict  */)line, (char const   */* __restrict  */)" :=\n\t\r");
    }
#line 78
    if (! key_str) {
      {
#line 79
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid config line: %s, skipping.\n",
              line);
      }
#line 80
      goto while_continue___0;
    }
    {
#line 82
    val_str = strtok((char */* __restrict  */)0, (char const   */* __restrict  */)" :=\n\t\r");
    }
#line 82
    if (! val_str) {
      {
#line 83
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"missing value for config key: %s\n",
              key_str);
      }
#line 84
      goto while_continue___0;
    }
    {
#line 87
    tmp___3 = __ctype_b_loc();
#line 87
    isnum = (int )((int const   )*(*tmp___3 + (int )*(val_str + 0)) & 2048);
#line 89
    tmp___33 = strcmp((char const   *)key_str, "dead-zone");
    }
#line 89
    if (tmp___33 == 0) {
#line 90
      if (! isnum) {
        {
#line 91
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid configuration value for %s, expected a number.\n",
                key_str);
        }
#line 92
        goto while_continue___0;
      }
      {
#line 94
      cfg___0->dead_threshold = atoi((char const   *)val_str);
      }
    } else {
      {
#line 96
      tmp___32 = strcmp((char const   *)key_str, "sensitivity");
      }
#line 96
      if (tmp___32 == 0) {
#line 97
        if (! isnum) {
          {
#line 98
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid configuration value for %s, expected a number.\n",
                  key_str);
          }
#line 99
          goto while_continue___0;
        }
        {
#line 101
        tmp___4 = atof((char const   *)val_str);
#line 101
        cfg___0->sensitivity = (float )tmp___4;
        }
      } else {
        {
#line 103
        tmp___31 = strcmp((char const   *)key_str, "sensitivity-translation");
        }
#line 103
        if (tmp___31 == 0) {
#line 104
          if (! isnum) {
            {
#line 105
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid configuration value for %s, expected a number.\n",
                    key_str);
            }
#line 106
            goto while_continue___0;
          }
          {
#line 108
          tmp___5 = atof((char const   *)val_str);
#line 108
          cfg___0->sens_trans = (float )tmp___5;
          }
        } else {
          {
#line 110
          tmp___30 = strcmp((char const   *)key_str, "sensitivity-rotation");
          }
#line 110
          if (tmp___30 == 0) {
#line 111
            if (! isnum) {
              {
#line 112
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid configuration value for %s, expected a number.\n",
                      key_str);
              }
#line 113
              goto while_continue___0;
            }
            {
#line 115
            tmp___6 = atof((char const   *)val_str);
#line 115
            cfg___0->sens_rot = (float )tmp___6;
            }
          } else {
            {
#line 117
            tmp___29 = strcmp((char const   *)key_str, "invert-rot");
            }
#line 117
            if (tmp___29 == 0) {
              {
#line 118
              tmp___7 = strchr((char const   *)val_str, 'x');
              }
#line 118
              if (tmp___7) {
#line 119
                cfg___0->invert[3] = ! def_axinv[3];
              }
              {
#line 121
              tmp___8 = strchr((char const   *)val_str, 'y');
              }
#line 121
              if (tmp___8) {
#line 122
                cfg___0->invert[4] = ! def_axinv[4];
              }
              {
#line 124
              tmp___9 = strchr((char const   *)val_str, 'z');
              }
#line 124
              if (tmp___9) {
#line 125
                cfg___0->invert[5] = ! def_axinv[5];
              }
            } else {
              {
#line 128
              tmp___28 = strcmp((char const   *)key_str, "invert-trans");
              }
#line 128
              if (tmp___28 == 0) {
                {
#line 129
                tmp___10 = strchr((char const   *)val_str, 'x');
                }
#line 129
                if (tmp___10) {
#line 130
                  cfg___0->invert[0] = ! def_axinv[0];
                }
                {
#line 132
                tmp___11 = strchr((char const   *)val_str, 'y');
                }
#line 132
                if (tmp___11) {
#line 133
                  cfg___0->invert[1] = ! def_axinv[1];
                }
                {
#line 135
                tmp___12 = strchr((char const   *)val_str, 'z');
                }
#line 135
                if (tmp___12) {
#line 136
                  cfg___0->invert[2] = ! def_axinv[2];
                }
              } else {
                {
#line 139
                tmp___27 = strcmp((char const   *)key_str, "swap-yz");
                }
#line 139
                if (tmp___27 == 0) {
#line 140
                  swap_yz = 0;
#line 142
                  if (isnum) {
                    {
#line 143
                    swap_yz = atoi((char const   *)val_str);
                    }
                  } else {
                    {
#line 145
                    tmp___16 = strcmp((char const   *)val_str, "true");
                    }
#line 145
                    if (tmp___16 == 0) {
#line 146
                      swap_yz = 1;
                    } else {
                      {
#line 145
                      tmp___17 = strcmp((char const   *)val_str, "on");
                      }
#line 145
                      if (tmp___17 == 0) {
#line 146
                        swap_yz = 1;
                      } else {
                        {
#line 145
                        tmp___18 = strcmp((char const   *)val_str, "yes");
                        }
#line 145
                        if (tmp___18 == 0) {
#line 146
                          swap_yz = 1;
                        } else {
                          {
#line 147
                          tmp___13 = strcmp((char const   *)val_str, "false");
                          }
#line 147
                          if (tmp___13 == 0) {
#line 148
                            swap_yz = 0;
                          } else {
                            {
#line 147
                            tmp___14 = strcmp((char const   *)val_str, "off");
                            }
#line 147
                            if (tmp___14 == 0) {
#line 148
                              swap_yz = 0;
                            } else {
                              {
#line 147
                              tmp___15 = strcmp((char const   *)val_str, "no");
                              }
#line 147
                              if (tmp___15 == 0) {
#line 148
                                swap_yz = 0;
                              } else {
                                {
#line 150
                                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid configuration value for %s, expected a boolean value.\n",
                                        key_str);
                                }
#line 151
                                goto while_continue___0;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
#line 155
                  i = 0;
                  {
#line 155
                  while (1) {
                    while_continue___2: /* CIL Label */ ;
#line 155
                    if (! (i < 6)) {
#line 155
                      goto while_break___2;
                    }
#line 156
                    if (swap_yz) {
#line 156
                      cfg___0->map_axis[i] = i;
                    } else {
#line 156
                      cfg___0->map_axis[i] = (int )def_axmap[i];
                    }
#line 155
                    i ++;
                  }
                  while_break___2: /* CIL Label */ ;
                  }
                } else {
                  {
#line 159
                  tmp___26 = strcmp((char const   *)key_str, "led");
                  }
#line 159
                  if (tmp___26 == 0) {
#line 160
                    if (isnum) {
                      {
#line 161
                      cfg___0->led = atoi((char const   *)val_str);
                      }
                    } else {
                      {
#line 163
                      tmp___22 = strcmp((char const   *)val_str, "true");
                      }
#line 163
                      if (tmp___22 == 0) {
#line 164
                        cfg___0->led = 1;
                      } else {
                        {
#line 163
                        tmp___23 = strcmp((char const   *)val_str, "on");
                        }
#line 163
                        if (tmp___23 == 0) {
#line 164
                          cfg___0->led = 1;
                        } else {
                          {
#line 163
                          tmp___24 = strcmp((char const   *)val_str, "yes");
                          }
#line 163
                          if (tmp___24 == 0) {
#line 164
                            cfg___0->led = 1;
                          } else {
                            {
#line 165
                            tmp___19 = strcmp((char const   *)val_str, "false");
                            }
#line 165
                            if (tmp___19 == 0) {
#line 166
                              cfg___0->led = 0;
                            } else {
                              {
#line 165
                              tmp___20 = strcmp((char const   *)val_str, "off");
                              }
#line 165
                              if (tmp___20 == 0) {
#line 166
                                cfg___0->led = 0;
                              } else {
                                {
#line 165
                                tmp___21 = strcmp((char const   *)val_str, "no");
                                }
#line 165
                                if (tmp___21 == 0) {
#line 166
                                  cfg___0->led = 0;
                                } else {
                                  {
#line 168
                                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"invalid configuration value for %s, expected a boolean value.\n",
                                          key_str);
                                  }
#line 169
                                  goto while_continue___0;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  } else {
                    {
#line 173
                    tmp___25 = strcmp((char const   *)key_str, "serial");
                    }
#line 173
                    if (tmp___25 == 0) {
                      {
#line 174
                      strncpy((char */* __restrict  */)(cfg___0->serial_dev), (char const   */* __restrict  */)val_str,
                              (size_t )4096);
                      }
                    } else {
                      {
#line 177
                      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unrecognized config option: %s\n",
                              key_str);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 182
  flk.l_type = (short)2;
#line 183
  flk.l_len = (__off_t )0;
#line 183
  flk.l_start = flk.l_len;
#line 184
  flk.l_whence = (short)0;
#line 185
  tmp___35 = fileno(fp);
#line 185
  fcntl(tmp___35, 6, & flk);
#line 187
  fclose(fp);
  }
#line 188
  return (0);
}
}
#line 191 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/cfgfile.c"
int write_cfg(char const   *fname , struct cfg *cfg___0 ) 
{ 
  FILE *fp ;
  struct flock flk ;
  int *tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char const   *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 196
  fp = fopen((char const   */* __restrict  */)fname, (char const   */* __restrict  */)"w");
  }
#line 196
  if (! fp) {
    {
#line 197
    tmp = __errno_location();
#line 197
    tmp___0 = strerror(*tmp);
#line 197
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"failed to write config file %s: %s\n",
            fname, tmp___0);
    }
#line 198
    return (-1);
  }
#line 202
  flk.l_type = (short)1;
#line 203
  flk.l_len = (__off_t )0;
#line 203
  flk.l_start = flk.l_len;
#line 204
  flk.l_whence = (short)0;
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 205
    tmp___1 = fileno(fp);
#line 205
    tmp___2 = fcntl(tmp___1, 7, & flk);
    }
#line 205
    if (! (tmp___2 == -1)) {
#line 205
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 207
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# sensitivity is multiplied with every motion (1.0 normal).\n");
#line 208
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"sensitivity = %.3f\n\n",
          (double )cfg___0->sensitivity);
#line 210
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# separate sensitivity for rotation and translation.\n");
#line 211
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"sensitivity-translation = %.3f\n",
          (double )cfg___0->sens_trans);
#line 212
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"sensitivity-rotation = %.3f\n\n",
          (double )cfg___0->sens_rot);
#line 214
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# dead zone; any motion less than this number, is discarded as noise.\n");
#line 215
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"dead-zone = %d\n\n",
          cfg___0->dead_threshold);
  }
#line 217
  if (cfg___0->invert[0] != (int )def_axinv[0]) {
#line 217
    goto _L;
  } else
#line 217
  if (cfg___0->invert[1] != (int )def_axinv[1]) {
#line 217
    goto _L;
  } else
#line 217
  if (cfg___0->invert[2] != (int )def_axinv[2]) {
    _L: /* CIL Label */ 
    {
#line 218
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# invert translations on some axes.\n");
#line 219
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"invert-trans = ");
    }
#line 220
    if (cfg___0->invert[0] != (int )def_axinv[0]) {
      {
#line 220
      fputc('x', fp);
      }
    }
#line 221
    if (cfg___0->invert[1] != (int )def_axinv[1]) {
      {
#line 221
      fputc('y', fp);
      }
    }
#line 222
    if (cfg___0->invert[2] != (int )def_axinv[2]) {
      {
#line 222
      fputc('z', fp);
      }
    }
    {
#line 223
    fputs((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)fp);
    }
  }
#line 226
  if (cfg___0->invert[3] != (int )def_axinv[3]) {
#line 226
    goto _L___0;
  } else
#line 226
  if (cfg___0->invert[4] != (int )def_axinv[4]) {
#line 226
    goto _L___0;
  } else
#line 226
  if (cfg___0->invert[5] != (int )def_axinv[5]) {
    _L___0: /* CIL Label */ 
    {
#line 227
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# invert rotations around some axes.\n");
#line 228
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"invert-rot = ");
    }
#line 229
    if (cfg___0->invert[3] != (int )def_axinv[3]) {
      {
#line 229
      fputc('x', fp);
      }
    }
#line 230
    if (cfg___0->invert[4] != (int )def_axinv[4]) {
      {
#line 230
      fputc('y', fp);
      }
    }
#line 231
    if (cfg___0->invert[5] != (int )def_axinv[5]) {
      {
#line 231
      fputc('z', fp);
      }
    }
    {
#line 232
    fputs((char const   */* __restrict  */)"\n\n", (FILE */* __restrict  */)fp);
    }
  }
  {
#line 235
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# swap translation along Y and Z axes\n");
  }
#line 236
  if (cfg___0->map_axis[1] == (int )def_axmap[1]) {
#line 236
    tmp___3 = "false";
  } else {
#line 236
    tmp___3 = "true";
  }
  {
#line 236
  fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"swap-yz = %s\n\n",
          tmp___3);
  }
#line 238
  if (! cfg___0->led) {
    {
#line 239
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# disable led\n");
#line 240
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"led = 0\n\n");
    }
  }
#line 243
  if (cfg___0->serial_dev[0]) {
    {
#line 244
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"# serial device\n");
#line 245
    fprintf((FILE */* __restrict  */)fp, (char const   */* __restrict  */)"serial = %s\n\n",
            cfg___0->serial_dev);
    }
  }
  {
#line 249
  flk.l_type = (short)2;
#line 250
  flk.l_len = (__off_t )0;
#line 250
  flk.l_start = flk.l_len;
#line 251
  flk.l_whence = (short)0;
#line 252
  tmp___4 = fileno(fp);
#line 252
  fcntl(tmp___4, 6, & flk);
#line 254
  fclose(fp);
  }
#line 255
  return (0);
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.h"
int sball_getstatus(SBallHandle voidhandle , int *tx , int *ty , int *tz , int *rx ,
                    int *ry , int *rz , int *buttons ) ;
#line 141
int sball_rezero(SBallHandle voidhandle ) ;
#line 149
int sball_init(SBallHandle voidhandle ) ;
#line 170
void sball_set_nullregion(SBallHandle voidhandle , int nulltx , int nullty , int nulltz ,
                          int nullrx , int nullry , int nullrz ) ;
#line 62 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static struct event *ev_free_list  ;
#line 63 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
int evpool_size  ;
#line 65
static struct event *alloc_event(void) ;
#line 66
static void free_event(struct event *ev___0 ) ;
#line 94
static void generate_motion_events(sballhandle *handle , int *prev_val , int *new_val ,
                                   int timer ) ;
#line 95
static void generate_button_events(sballhandle *handle , int prevstate , int newstate ) ;
#line 103 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static char *initstring  =    (char *)"CB\rNT\rFTp\rFRp\rP@r@r\rMSSV\rZ\rBcCcC\r";
#line 106 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static void sball_hwreset(sballhandle *handle ) 
{ 


  {
#line 109
  handle->spaceball4000 = 0;
#line 110
  handle->leftymode4000 = 0;
#line 112
  if (! handle->resetoccured) {
    {
#line 116
    handle->resetoccured = 1;
#line 117
    sball_comm_write(handle->commhandle, "@\r");
    }
  }
  {
#line 128
  sball_comm_write(handle->commhandle, (char const   *)initstring);
  }
#line 129
  return;
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
SBallHandle sball_open(char const   *sballname ) 
{ 
  sballhandle *handle ;
  void *tmp ;
  int tmp___0 ;

  {
#line 136
  if ((unsigned long )sballname == (unsigned long )((void *)0)) {
#line 137
    return ((void *)0);
  }
  {
#line 139
  tmp = malloc(sizeof(sballhandle ));
#line 139
  handle = (sballhandle *)tmp;
  }
#line 140
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
#line 141
    return ((void *)0);
  }
  {
#line 144
  memset((void *)handle, 0, sizeof(sballhandle ));
#line 145
  handle->packlen = 1;
#line 146
  handle->resetoccured = 0;
#line 148
  tmp___0 = sball_comm_open(sballname, & handle->commhandle);
  }
#line 148
  if (tmp___0 == -1) {
    {
#line 149
    free((void *)handle);
    }
#line 150
    return ((void *)0);
  }
  {
#line 153
  sball_hwreset(handle);
  }
#line 155
  return ((SBallHandle )handle);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
int sball_close(SBallHandle voidhandle ) 
{ 
  sballhandle *handle ;

  {
#line 161
  handle = (sballhandle *)voidhandle;
#line 163
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
#line 164
    return (-1);
  }
  {
#line 166
  sball_comm_close(& handle->commhandle);
#line 167
  free((void *)handle);
  }
#line 168
  return (0);
}
}
#line 172 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static int sball_update(SBallHandle voidhandle ) 
{ 
  int i ;
  int num ;
  int packs ;
  unsigned char rawbuf[1024] ;
  sballhandle *handle ;
  unsigned int tx ;
  unsigned int ty ;
  unsigned int tz ;
  unsigned int rx ;
  unsigned int ry ;
  unsigned int rz ;
  int i___0 ;
  int prev_val[6] ;
  int new_val[6] ;
  int newstate ;
  int newstate___0 ;

  {
#line 178
  handle = (sballhandle *)voidhandle;
#line 180
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
#line 181
    return (-1);
  }
  {
#line 183
  packs = 0;
#line 185
  num = sball_comm_read(handle->commhandle, (char *)(rawbuf), 1023);
  }
#line 187
  if (num > 0) {
#line 188
    i = 0;
    {
#line 188
    while (1) {
      while_continue: /* CIL Label */ ;
#line 188
      if (! (i < num)) {
#line 188
        goto while_break;
      }
#line 192
      if ((int )rawbuf[i] == 94) {
#line 193
        if (! handle->escapedchar) {
#line 194
          handle->escapedchar = 1;
#line 195
          goto __Cont;
        }
      }
#line 199
      if (handle->escapedchar) {
#line 200
        handle->escapedchar = 0;
        {
#line 203
        if ((int )rawbuf[i] == 94) {
#line 203
          goto case_94;
        }
#line 208
        if ((int )rawbuf[i] == 77) {
#line 208
          goto case_77;
        }
#line 208
        if ((int )rawbuf[i] == 83) {
#line 208
          goto case_77;
        }
#line 208
        if ((int )rawbuf[i] == 81) {
#line 208
          goto case_77;
        }
#line 212
        goto switch_default;
        case_94: /* CIL Label */ 
#line 204
        goto switch_break;
        case_77: /* CIL Label */ 
        case_83: /* CIL Label */ 
        case_81: /* CIL Label */ 
#line 209
        rawbuf[i] = (unsigned char )((int )rawbuf[i] & 31);
#line 210
        goto switch_break;
        switch_default: /* CIL Label */ 
#line 221
        goto switch_break;
        switch_break: /* CIL Label */ ;
        }
      }
#line 227
      if (handle->bufpos == 0) {
        {
#line 229
        if ((int )rawbuf[i] == 68) {
#line 229
          goto case_68;
        }
#line 234
        if ((int )rawbuf[i] == 75) {
#line 234
          goto case_75;
        }
#line 239
        if ((int )rawbuf[i] == 46) {
#line 239
          goto case_46;
        }
#line 244
        if ((int )rawbuf[i] == 67) {
#line 244
          goto case_67;
        }
#line 249
        if ((int )rawbuf[i] == 70) {
#line 249
          goto case_70;
        }
#line 254
        if ((int )rawbuf[i] == 77) {
#line 254
          goto case_77___0;
        }
#line 259
        if ((int )rawbuf[i] == 78) {
#line 259
          goto case_78;
        }
#line 264
        if ((int )rawbuf[i] == 80) {
#line 264
          goto case_80;
        }
#line 269
        if ((int )rawbuf[i] == 11) {
#line 269
          goto case_11;
        }
#line 275
        if ((int )rawbuf[i] == 13) {
#line 275
          goto case_13;
        }
#line 275
        if ((int )rawbuf[i] == 10) {
#line 275
          goto case_13;
        }
#line 280
        if ((int )rawbuf[i] == 64) {
#line 280
          goto case_64;
        }
#line 286
        if ((int )rawbuf[i] == 69) {
#line 286
          goto case_69;
        }
#line 291
        if ((int )rawbuf[i] == 90) {
#line 291
          goto case_90;
        }
#line 296
        goto switch_default___0;
        case_68: /* CIL Label */ 
#line 230
        handle->packtype = 'D';
#line 231
        handle->packlen = 16;
#line 232
        goto switch_break___0;
        case_75: /* CIL Label */ 
#line 235
        handle->packtype = 'K';
#line 236
        handle->packlen = 4;
#line 237
        goto switch_break___0;
        case_46: /* CIL Label */ 
#line 240
        handle->packtype = '.';
#line 241
        handle->packlen = 4;
#line 242
        goto switch_break___0;
        case_67: /* CIL Label */ 
#line 245
        handle->packtype = 'C';
#line 246
        handle->packlen = 4;
#line 247
        goto switch_break___0;
        case_70: /* CIL Label */ 
#line 250
        handle->packtype = 'F';
#line 251
        handle->packlen = 4;
#line 252
        goto switch_break___0;
        case_77___0: /* CIL Label */ 
#line 255
        handle->packtype = 'M';
#line 256
        handle->packlen = 5;
#line 257
        goto switch_break___0;
        case_78: /* CIL Label */ 
#line 260
        handle->packtype = 'N';
#line 261
        handle->packlen = 3;
#line 262
        goto switch_break___0;
        case_80: /* CIL Label */ 
#line 265
        handle->packtype = 'P';
#line 266
        handle->packlen = 6;
#line 267
        goto switch_break___0;
        case_11: /* CIL Label */ 
#line 270
        handle->packtype = '\v';
#line 271
        handle->packlen = 1;
#line 272
        goto switch_break___0;
        case_13: /* CIL Label */ 
        case_10: /* CIL Label */ 
#line 276
        handle->packtype = '\r';
#line 277
        handle->packlen = 1;
#line 278
        goto switch_break___0;
        case_64: /* CIL Label */ 
#line 281
        handle->resetoccured = 1;
#line 282
        handle->packtype = '@';
#line 283
        handle->packlen = 62;
#line 284
        goto switch_break___0;
        case_69: /* CIL Label */ 
#line 287
        handle->packtype = 'E';
#line 288
        handle->packlen = 8;
#line 289
        goto switch_break___0;
        case_90: /* CIL Label */ 
#line 292
        handle->packtype = 'Z';
#line 293
        handle->packlen = 14;
#line 294
        goto switch_break___0;
        switch_default___0: /* CIL Label */ 
#line 306
        goto __Cont;
        switch_break___0: /* CIL Label */ ;
        }
      }
#line 311
      handle->buf[handle->bufpos] = rawbuf[i];
#line 312
      (handle->bufpos) ++;
#line 315
      if (handle->packtype == 64) {
#line 316
        if ((int )rawbuf[i] != 13) {
#line 317
          goto __Cont;
        } else {
#line 319
          handle->packlen = handle->bufpos;
        }
      }
#line 323
      if (handle->packtype == 69) {
#line 324
        if ((int )rawbuf[i] != 13) {
#line 325
          goto __Cont;
        } else {
#line 327
          handle->packlen = handle->bufpos;
        }
      } else
#line 328
      if (handle->bufpos != handle->packlen) {
#line 329
        goto __Cont;
      }
      {
#line 332
      if (handle->packtype == 68) {
#line 332
        goto case_68___0;
      }
#line 370
      if (handle->packtype == 75) {
#line 370
        goto case_75___0;
      }
#line 403
      if (handle->packtype == 46) {
#line 403
        goto case_46___0;
      }
#line 453
      if (handle->packtype == 11) {
#line 453
        goto case_11___0;
      }
#line 453
      if (handle->packtype == 13) {
#line 453
        goto case_11___0;
      }
#line 453
      if (handle->packtype == 78) {
#line 453
        goto case_11___0;
      }
#line 453
      if (handle->packtype == 77) {
#line 453
        goto case_11___0;
      }
#line 453
      if (handle->packtype == 80) {
#line 453
        goto case_11___0;
      }
#line 453
      if (handle->packtype == 70) {
#line 453
        goto case_11___0;
      }
#line 453
      if (handle->packtype == 67) {
#line 453
        goto case_11___0;
      }
#line 457
      if (handle->packtype == 64) {
#line 457
        goto case_64___0;
      }
#line 474
      if (handle->packtype == 69) {
#line 474
        goto case_69___0;
      }
#line 486
      if (handle->packtype == 90) {
#line 486
        goto case_90___0;
      }
#line 490
      goto switch_default___1;
      case_68___0: /* CIL Label */ 
#line 340
      handle->timer = ((int )handle->buf[1] << 8) | (int )handle->buf[2];
#line 342
      tx = (unsigned int )(((int )handle->buf[3] << 8) | (int )handle->buf[4]);
#line 343
      ty = (unsigned int )(((int )handle->buf[5] << 8) | (int )handle->buf[6]);
#line 344
      tz = (unsigned int )(((int )handle->buf[7] << 8) | (int )handle->buf[8]);
#line 345
      rx = (unsigned int )(((int )handle->buf[9] << 8) | (int )handle->buf[10]);
#line 346
      ry = (unsigned int )(((int )handle->buf[11] << 8) | (int )handle->buf[12]);
#line 347
      rz = (unsigned int )(((int )handle->buf[13] << 8) | (int )handle->buf[14]);
#line 349
      i___0 = 0;
      {
#line 349
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 349
        if (! (i___0 < 3)) {
#line 349
          goto while_break___0;
        }
#line 350
        prev_val[i___0] = handle->trans[i___0];
#line 351
        prev_val[i___0 + 3] = handle->rot[i___0];
#line 349
        i___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 354
      new_val[0] = ((int )tx << 16) >> 16;
#line 355
      new_val[1] = ((int )ty << 16) >> 16;
#line 356
      new_val[2] = ((int )tz << 16) >> 16;
#line 357
      new_val[3] = ((int )rx << 16) >> 16;
#line 358
      new_val[4] = ((int )ry << 16) >> 16;
#line 359
      new_val[5] = ((int )rz << 16) >> 16;
#line 361
      generate_motion_events(handle, prev_val, new_val, handle->timer);
#line 363
      i___0 = 0;
      }
      {
#line 363
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 363
        if (! (i___0 < 3)) {
#line 363
          goto while_break___1;
        }
#line 364
        handle->trans[i___0] = new_val[i___0];
#line 365
        handle->rot[i___0] = new_val[i___0 + 3];
#line 363
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 368
      goto switch_break___1;
      case_75___0: /* CIL Label */ 
#line 388
      if (handle->spaceball4000) {
#line 389
        goto switch_break___1;
      }
      {
#line 391
      newstate = (((((((int )handle->buf[1] & 16) << 3) | (((int )handle->buf[1] & 32) << 9)) | (((int )handle->buf[1] & 8) << 11)) | (((int )handle->buf[1] & 7) << 4)) | (((int )handle->buf[2] & 48) << 8)) | ((int )handle->buf[2] & 15);
#line 398
      generate_button_events(handle, handle->buttons, newstate);
#line 399
      handle->buttons = newstate;
      }
#line 401
      goto switch_break___1;
      case_46___0: /* CIL Label */ 
#line 412
      if ((int )handle->buf[3] != 13) {
#line 413
        goto switch_break___1;
      }
      {
#line 421
      handle->spaceball4000 = 1;
#line 425
      newstate___0 = ((((~ ((int )handle->buf[1]) & 32) << 10) | (((int )handle->buf[1] & 31) << 7)) | ((int )handle->buf[2] & 63)) | (((int )handle->buf[2] & 128) >> 1);
#line 430
      generate_button_events(handle, handle->buttons, newstate___0);
#line 431
      handle->buttons = newstate___0;
      }
#line 440
      if (((int )handle->buf[1] & 32) == 0) {
#line 441
        handle->leftymode4000 = 1;
      } else {
#line 443
        handle->leftymode4000 = 0;
      }
#line 445
      goto switch_break___1;
      case_11___0: /* CIL Label */ 
      case_13___0: /* CIL Label */ 
      case_78___0: /* CIL Label */ 
      case_77___1: /* CIL Label */ 
      case_80___0: /* CIL Label */ 
      case_70___0: /* CIL Label */ 
      case_67___0: /* CIL Label */ 
#line 455
      goto switch_break___1;
      case_64___0: /* CIL Label */ 
      {
#line 469
      handle->resetoccured = 1;
#line 470
      sball_hwreset(handle);
      }
#line 471
      goto switch_break___1;
      case_69___0: /* CIL Label */ 
#line 475
      (handle->erroroccured) ++;
#line 484
      goto switch_break___1;
      case_90___0: /* CIL Label */ 
#line 488
      goto switch_break___1;
      switch_default___1: /* CIL Label */ 
#line 500
      goto switch_break___1;
      switch_break___1: /* CIL Label */ ;
      }
#line 504
      handle->bufpos = 0;
#line 505
      handle->packtype = 0;
#line 506
      handle->packlen = 1;
#line 507
      packs ++;
      __Cont: /* CIL Label */ 
#line 188
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 511
  return (packs);
}
}
#line 515 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
int sball_rezero(SBallHandle voidhandle ) 
{ 
  sballhandle *handle ;
  char outbuf[200] ;

  {
#line 517
  handle = (sballhandle *)voidhandle;
#line 521
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
#line 522
    return (-1);
  }
  {
#line 524
  sprintf((char */* __restrict  */)(outbuf), (char const   */* __restrict  */)"\rZ\r");
#line 525
  sball_comm_write(handle->commhandle, (char const   *)(outbuf));
  }
#line 527
  return (0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
int sball_init(SBallHandle voidhandle ) 
{ 
  sballhandle *handle ;

  {
#line 532
  handle = (sballhandle *)voidhandle;
#line 536
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
#line 537
    return (-1);
  }
  {
#line 539
  sball_update((SBallHandle )handle);
  }
#line 548
  return (0);
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
void sball_set_nullregion(SBallHandle voidhandle , int nulltx , int nullty , int nulltz ,
                          int nullrx , int nullry , int nullrz ) 
{ 
  sballhandle *handle ;

  {
  {
#line 555
  handle = (sballhandle *)voidhandle;
#line 557
  handle->nulltrans[0] = abs(nulltx);
#line 558
  handle->nulltrans[1] = abs(nullty);
#line 559
  handle->nulltrans[2] = abs(nulltz);
#line 561
  handle->nullrot[0] = abs(nullrx);
#line 562
  handle->nullrot[1] = abs(nullry);
#line 563
  handle->nullrot[2] = abs(nullrz);
#line 565
  handle->usenullregion = 1;
  }
#line 566
  return;
}
}
#line 569 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static int nullregion(int null , int val ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 571
  tmp___0 = abs(val);
  }
#line 571
  if (tmp___0 > null) {
#line 572
    if (val > 0) {
#line 572
      tmp = val - null;
    } else {
#line 572
      tmp = val + null;
    }
#line 572
    return (tmp);
  }
#line 574
  return (0);
}
}
#line 577 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static void sball_do_nullregion(SBallHandle voidhandle ) 
{ 
  sballhandle *handle ;

  {
  {
#line 579
  handle = (sballhandle *)voidhandle;
#line 581
  handle->trans[0] = nullregion(handle->nulltrans[0], handle->trans[0]);
#line 582
  handle->trans[1] = nullregion(handle->nulltrans[1], handle->trans[1]);
#line 583
  handle->trans[2] = nullregion(handle->nulltrans[2], handle->trans[2]);
#line 584
  handle->rot[0] = nullregion(handle->nullrot[0], handle->rot[0]);
#line 585
  handle->rot[1] = nullregion(handle->nullrot[1], handle->rot[1]);
#line 586
  handle->rot[2] = nullregion(handle->nullrot[2], handle->rot[2]);
  }
#line 587
  return;
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
int sball_getstatus(SBallHandle voidhandle , int *tx , int *ty , int *tz , int *rx ,
                    int *ry , int *rz , int *buttons ) 
{ 
  sballhandle *handle ;
  int events ;

  {
#line 592
  handle = (sballhandle *)voidhandle;
#line 596
  if ((unsigned long )handle == (unsigned long )((void *)0)) {
#line 597
    return (-1);
  }
  {
#line 599
  events = sball_update((SBallHandle )handle);
  }
#line 602
  if (handle->usenullregion) {
    {
#line 603
    sball_do_nullregion(voidhandle);
    }
  }
#line 605
  if ((unsigned long )tx != (unsigned long )((void *)0)) {
#line 606
    *tx = handle->trans[0];
  }
#line 607
  if ((unsigned long )ty != (unsigned long )((void *)0)) {
#line 608
    *ty = handle->trans[1];
  }
#line 609
  if ((unsigned long )tz != (unsigned long )((void *)0)) {
#line 610
    *tz = handle->trans[2];
  }
#line 612
  if ((unsigned long )rx != (unsigned long )((void *)0)) {
#line 613
    *rx = handle->rot[0];
  }
#line 614
  if ((unsigned long )ry != (unsigned long )((void *)0)) {
#line 615
    *ry = handle->rot[1];
  }
#line 616
  if ((unsigned long )rz != (unsigned long )((void *)0)) {
#line 617
    *rz = handle->rot[2];
  }
#line 619
  if ((unsigned long )buttons != (unsigned long )((void *)0)) {
#line 620
    *buttons = handle->buttons;
  }
#line 624
  return (events);
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
int sball_get_input(SBallHandle voidhandle , struct dev_input *inp ) 
{ 
  struct event *ev___0 ;
  sballhandle *handle ;

  {
  {
#line 633
  handle = (sballhandle *)voidhandle;
#line 636
  sball_update((SBallHandle )handle);
#line 639
  ev___0 = handle->evhead;
  }
#line 639
  if (ev___0) {
    {
#line 640
    handle->evhead = (handle->evhead)->next;
#line 642
    *inp = ev___0->data;
#line 643
    free_event(ev___0);
    }
#line 644
    return (1);
  }
#line 646
  return (0);
}
}
#line 649 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
int sball_get_fd(SBallHandle voidhandle ) 
{ 
  sballhandle *sball ;
  int tmp ;

  {
  {
#line 651
  sball = (sballhandle *)voidhandle;
#line 653
  tmp = sball_comm_fd(sball->commhandle);
  }
#line 653
  return (tmp);
}
}
#line 656 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static struct event *alloc_event(void) 
{ 
  struct event *ev___0 ;
  void *tmp ;

  {
#line 660
  if (ev_free_list) {
#line 661
    ev___0 = ev_free_list;
#line 662
    ev_free_list = ev___0->next;
  } else {
    {
#line 664
    tmp = malloc(sizeof(*ev___0));
#line 664
    ev___0 = (struct event *)tmp;
#line 665
    evpool_size ++;
    }
  }
#line 667
  return (ev___0);
}
}
#line 670 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static void free_event(struct event *ev___0 ) 
{ 


  {
#line 672
  if (evpool_size > 512) {
    {
#line 673
    free((void *)ev___0);
#line 674
    evpool_size --;
    }
  } else {
#line 676
    ev___0->next = ev_free_list;
#line 677
    ev_free_list = ev___0;
  }
#line 679
  return;
}
}
#line 681 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static void generate_motion_events(sballhandle *handle , int *prev_val , int *new_val ,
                                   int timer ) 
{ 
  int i ;
  int pending ;
  struct event *ev___0 ;
  struct event *tmp ;
  struct event *tmp___0 ;

  {
#line 683
  pending = 0;
#line 686
  i = 0;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
#line 686
    if (! (i < 6)) {
#line 686
      goto while_break;
    }
#line 687
    if (*(prev_val + i) == *(new_val + i)) {
#line 688
      goto __Cont;
    }
    {
#line 691
    ev___0 = alloc_event();
    }
#line 691
    if (ev___0) {
#line 692
      ev___0->data.type = 0;
#line 693
      ev___0->data.idx = i;
#line 694
      ev___0->data.val = *(new_val + i);
#line 695
      ev___0->next = (struct event *)0;
#line 697
      if (handle->evhead) {
#line 698
        (handle->evtail)->next = ev___0;
#line 699
        handle->evtail = ev___0;
      } else {
#line 701
        tmp = ev___0;
#line 701
        handle->evtail = tmp;
#line 701
        handle->evhead = tmp;
      }
#line 703
      pending = 1;
    }
    __Cont: /* CIL Label */ 
#line 686
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 707
  if (pending) {
    {
#line 708
    ev___0 = alloc_event();
    }
#line 708
    if (ev___0) {
#line 709
      ev___0->data.type = 2;
#line 710
      ev___0->next = (struct event *)0;
    }
#line 713
    if (handle->evhead) {
#line 714
      (handle->evtail)->next = ev___0;
#line 715
      handle->evtail = ev___0;
    } else {
#line 717
      tmp___0 = ev___0;
#line 717
      handle->evtail = tmp___0;
#line 717
      handle->evhead = tmp___0;
    }
  }
#line 720
  return;
}
}
#line 722 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/serial/sball.c"
static void generate_button_events(sballhandle *handle , int prevstate , int newstate ) 
{ 
  int i ;
  int newbit ;
  struct event *ev___0 ;
  struct event *tmp ;
  struct event *tmp___0 ;

  {
#line 726
  i = 0;
  {
#line 726
  while (1) {
    while_continue: /* CIL Label */ ;
#line 726
    if (! (i < 16)) {
#line 726
      goto while_break;
    }
#line 727
    newbit = (newstate >> i) & 1;
#line 728
    if (newbit != ((prevstate >> i) & 1)) {
      {
#line 730
      tmp = alloc_event();
#line 730
      ev___0 = tmp;
      }
#line 731
      if (! ev___0) {
#line 731
        goto __Cont;
      }
#line 733
      ev___0->data.type = 1;
#line 734
      ev___0->data.idx = i;
#line 735
      ev___0->data.val = newbit;
#line 736
      ev___0->next = (struct event *)0;
#line 738
      if (handle->evhead) {
#line 739
        (handle->evtail)->next = ev___0;
#line 740
        handle->evtail = ev___0;
      } else {
#line 742
        tmp___0 = ev___0;
#line 742
        handle->evtail = tmp___0;
#line 742
        handle->evhead = tmp___0;
      }
    }
    __Cont: /* CIL Label */ 
#line 726
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 746
  return;
}
}
#line 444 "/usr/include/unistd.h"
extern unsigned int sleep(unsigned int __seconds ) ;
#line 84 "/usr/include/x86_64-linux-gnu/sys/inotify.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_init)(void) ;
#line 91
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_add_watch)(int __fd ,
                                                                                        char const   *__name ,
                                                                                        uint32_t __mask ) ;
#line 95
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) inotify_rm_watch)(int __fd ,
                                                                                       int __wd ) ;
#line 35 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/xdetect_linux.c"
static int fd  =    -1;
#line 36 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/xdetect_linux.c"
static int watch_tmp  =    -1;
#line 36 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/xdetect_linux.c"
static int watch_x11  =    -1;
#line 38 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/xdetect_linux.c"
int xdet_start(void) 
{ 
  int tmp ;

  {
  {
#line 40
  fd = inotify_init();
  }
#line 40
  if (fd == -1) {
    {
#line 41
    perror("failed to create inotify queue");
    }
#line 42
    return (-1);
  }
  {
#line 44
  tmp = fcntl(fd, 3, 0);
#line 44
  fcntl(fd, 4, tmp | 2048);
#line 46
  watch_x11 = inotify_add_watch(fd, "/tmp/.X11-unix", (uint32_t )256);
  }
#line 46
  if (watch_x11 == -1) {
    {
#line 47
    watch_tmp = inotify_add_watch(fd, "/tmp", (uint32_t )256);
    }
#line 47
    if (watch_tmp == -1) {
      {
#line 48
      perror("failed to watch /tmp for file events");
#line 49
      close(fd);
#line 50
      fd = -1;
      }
#line 51
      return (-1);
    }
  }
#line 55
  if (verbose) {
    {
#line 56
    printf((char const   */* __restrict  */)"waiting for X socket file to appear\n");
    }
  }
#line 59
  return (fd);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/xdetect_linux.c"
void xdet_stop(void) 
{ 


  {
#line 65
  if (fd != -1) {
#line 66
    if (verbose) {
      {
#line 67
      printf((char const   */* __restrict  */)"stopping X watch\n");
      }
    }
    {
#line 70
    close(fd);
#line 71
    watch_x11 = -1;
#line 71
    watch_tmp = watch_x11;
#line 71
    fd = watch_tmp;
    }
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/xdetect_linux.c"
int xdet_get_fd(void) 
{ 


  {
#line 77
  return (fd);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/spacenavd-0.5/src/xdetect_linux.c"
int handle_xdet_events(fd_set *rset ) 
{ 
  char buf[512] ;
  struct inotify_event *ev___0 ;
  ssize_t res ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  char *dpystr ;
  char sock_file[64] ;
  int dpynum ;
  char *tmp___3 ;
  char *tmp___4 ;
  unsigned short const   **tmp___5 ;
  int i ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 83
  ev___0 = (struct inotify_event *)(buf);
#line 86
  if (fd == -1) {
#line 87
    return (-1);
  } else
#line 86
  if (! ((rset->__fds_bits[fd / (8 * (int )sizeof(__fd_mask ))] & (1L << fd % (8 * (int )sizeof(__fd_mask )))) != 0L)) {
#line 87
    return (-1);
  }
  {
#line 90
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 91
    res = read(fd, (void *)(buf), sizeof(buf));
    }
#line 91
    if (res <= 0L) {
#line 92
      if (res == 0L) {
        {
#line 94
        tmp = __errno_location();
#line 94
        *tmp = 22;
        }
      }
      {
#line 96
      tmp___0 = __errno_location();
      }
#line 96
      if (*tmp___0 == 4) {
#line 96
        goto __Cont;
      }
      {
#line 97
      tmp___1 = __errno_location();
      }
#line 97
      if (*tmp___1 != 11) {
        {
#line 98
        perror("failed to read inotify event");
        }
      }
#line 100
      return (-1);
    }
#line 103
    if (ev___0->wd == watch_tmp) {
#line 104
      if (watch_x11 != -1) {
        {
#line 105
        inotify_rm_watch(fd, watch_tmp);
        }
#line 106
        goto __Cont;
      }
#line 109
      if (ev___0->len > 0U) {
        {
#line 109
        tmp___2 = strcmp((char const   *)(ev___0->name), ".X11-unix");
        }
#line 109
        if (tmp___2 == 0) {
          {
#line 110
          watch_x11 = inotify_add_watch(fd, "/tmp/.X11-unix", (uint32_t )256);
          }
#line 110
          if (watch_x11 == -1) {
            {
#line 111
            perror("failed to add /tmp/.X11-unix to the watch queue");
            }
#line 112
            goto __Cont;
          }
        }
      }
    } else
#line 116
    if (ev___0->wd == watch_x11) {
      {
#line 118
      dpynum = 0;
#line 120
      dpystr = getenv("DISPLAY");
      }
#line 120
      if (dpystr) {
        {
#line 121
        tmp___4 = strchr((char const   *)dpystr, ':');
#line 121
        tmp___3 = tmp___4;
        }
#line 122
        if (tmp___3) {
          {
#line 122
          tmp___5 = __ctype_b_loc();
          }
#line 122
          if ((int const   )*(*tmp___5 + (int )*(tmp___3 + 1)) & 2048) {
            {
#line 123
            dpynum = atoi((char const   *)(tmp___3 + 1));
            }
          }
        }
      }
      {
#line 126
      sprintf((char */* __restrict  */)(sock_file), (char const   */* __restrict  */)"X%d",
              dpynum);
      }
#line 128
      if (ev___0->len > 0U) {
        {
#line 128
        tmp___7 = strcmp((char const   *)(ev___0->name), (char const   *)(sock_file));
        }
#line 128
        if (tmp___7 == 0) {
#line 131
          if (verbose) {
            {
#line 132
            printf((char const   */* __restrict  */)"found X socket, will now attempt to connect to the X server\n");
            }
          }
#line 136
          i = 0;
          {
#line 136
          while (1) {
            while_continue___0: /* CIL Label */ ;
#line 136
            if (! (i < 30)) {
#line 136
              goto while_break___0;
            }
            {
#line 137
            sleep(1U);
#line 138
            tmp___6 = init_x11();
            }
#line 138
            if (tmp___6 != -1) {
#line 139
              return (0);
            }
#line 136
            i ++;
          }
          while_break___0: /* CIL Label */ ;
          }
          {
#line 143
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found X socket yet failed to connect\n");
          }
        }
      }
    }
    __Cont: /* CIL Label */ ;
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  return (-1);
}
}
