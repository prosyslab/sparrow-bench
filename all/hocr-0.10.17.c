/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 49 "./ho_bitmap.h"
struct __anonstruct_ho_bitmap_27 {
   unsigned char type ;
   int font_height ;
   int font_width ;
   int font_spacing ;
   int line_spacing ;
   int avg_line_fill ;
   int com_line_fill ;
   unsigned char nikud ;
   int x ;
   int y ;
   int height ;
   int width ;
   int rowstride ;
   unsigned char *data ;
};
#line 49 "./ho_bitmap.h"
typedef struct __anonstruct_ho_bitmap_27 ho_bitmap;
#line 49 "./ho_objmap.h"
struct __anonstruct_ho_obj_28 {
   int index ;
   int reading_index ;
   double weight ;
   int x ;
   int y ;
   int width ;
   int height ;
};
#line 49 "./ho_objmap.h"
typedef struct __anonstruct_ho_obj_28 ho_obj;
#line 63 "./ho_objmap.h"
struct __anonstruct_ho_objlist_29 {
   int size ;
   int allocated_size ;
   ho_obj *objects ;
};
#line 63 "./ho_objmap.h"
typedef struct __anonstruct_ho_objlist_29 ho_objlist;
#line 73 "./ho_objmap.h"
struct __anonstruct_ho_objmap_30 {
   int x ;
   int y ;
   int height ;
   int width ;
   int *map ;
   ho_objlist *obj_list ;
};
#line 73 "./ho_objmap.h"
typedef struct __anonstruct_ho_objmap_30 ho_objmap;
#line 40 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.h"
struct __anonstruct_ho_layout_31 {
   char font_spacing_code ;
   unsigned char type ;
   unsigned char dir ;
   int number_of_fonts ;
   ho_bitmap *m_page_text ;
   ho_bitmap *m_page_blocks_mask ;
   int n_blocks ;
   ho_bitmap **m_blocks_text ;
   ho_bitmap **m_blocks_lines_mask ;
   int *n_lines ;
   ho_bitmap ***m_lines_text ;
   ho_bitmap ***m_lines_line_mask ;
   ho_bitmap ***m_lines_words_mask ;
   int **n_words ;
   ho_bitmap ****m_words_text ;
   ho_bitmap ****m_words_line_mask ;
   ho_bitmap ****m_words_font_mask ;
   int ***n_fonts ;
};
#line 40 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.h"
typedef struct __anonstruct_ho_layout_31 ho_layout;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 64 "./ho_pixbuf.h"
struct __anonstruct_ho_pixbuf_13 {
   unsigned char n_channels ;
   int height ;
   int width ;
   int rowstride ;
   unsigned char *data ;
};
#line 64 "./ho_pixbuf.h"
typedef struct __anonstruct_ho_pixbuf_13 ho_pixbuf;
#line 37 "./ho_string.h"
struct __anonstruct_ho_string_18 {
   char *string ;
   int size ;
   int allocated_size ;
};
#line 37 "./ho_string.h"
typedef struct __anonstruct_ho_string_18 ho_string;
#line 50 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap_hist.h"
struct __anonstruct_ho_bitmap_hist_28 {
   int height ;
   int width ;
   int fill ;
   int max_x ;
   int max_y ;
   int max_x_index ;
   int max_y_index ;
   unsigned int *data_x ;
   unsigned int *data_y ;
};
#line 50 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap_hist.h"
typedef struct __anonstruct_ho_bitmap_hist_28 ho_bitmap_hist;
#line 48 "./ho_array.h"
struct __anonstruct_ho_array_33 {
   int height ;
   int width ;
   double *data ;
};
#line 48 "./ho_array.h"
typedef struct __anonstruct_ho_array_33 ho_array;
#line 41 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.h"
struct __anonstruct_ho_array_hist_34 {
   int size ;
   double *data ;
};
#line 41 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.h"
typedef struct __anonstruct_ho_array_hist_34 ho_array_hist;
#line 57 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.h"
struct __anonstruct_ho_array_stat_34 {
   int height ;
   int width ;
   int size ;
   double threshold ;
   double *data_sums ;
   double *data_squre_sums ;
};
#line 57 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.h"
typedef struct __anonstruct_ho_array_stat_34 ho_array_stat;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 55 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.h"
struct string_data {
   int size ;
   char *data ;
};
#line 55 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.h"
typedef struct string_data string_data;
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 77 "./ho_bitmap.h"
ho_bitmap *ho_bitmap_new(int const   width , int const   height ) ;
#line 85
int ho_bitmap_free(ho_bitmap *m ) ;
#line 83 "./ho_objmap.h"
ho_objlist *ho_objlist_new(void) ;
#line 85
int ho_objlist_free(ho_objlist *object_list ) ;
#line 87
int ho_objlist_add(ho_objlist *object_list , double weight , int x , int y , int width ,
                   int height ) ;
#line 91
int ho_objlist_get_index(ho_objlist *object_list , int index___0 ) ;
#line 93
ho_obj *ho_objlist_get_object(ho_objlist *object_list , int index___0 ) ;
#line 95
int ho_objlist_add_pixel(ho_objlist *object_list , int index___0 , int x , int y ) ;
#line 97
int ho_objlist_link(ho_objlist *object_list , int index1 , int index2 ) ;
#line 99
int ho_objlist_clean(ho_objlist *object_list , int **map ) ;
#line 101
int ho_objlist_clean_by_reading_index(ho_objlist *object_list , int **map ) ;
#line 103
int ho_objlist_print(ho_objlist *object_list ) ;
#line 105
int ho_objlist_statistics(ho_objlist *object_list , int min_height , int max_height ,
                          int min_width , int max_width , int *counter , double *weight_avg ,
                          double *weight_com , double *weight_min , double *weight_max ,
                          int *height_avg , int *height_com , int *height_min , int *height_max ,
                          int *width_avg , int *width_com , int *width_min , int *width_max ) ;
#line 122
ho_objmap *ho_objmap_new(int const   width , int const   height ) ;
#line 129
int ho_objmap_free(ho_objmap *m ) ;
#line 136
int ho_objmap_clean(ho_objmap *m ) ;
#line 145
int ho_objmap_sort_by_reading_index(ho_objmap *m , unsigned char const   col , unsigned char const   dir_ltr ) ;
#line 153
ho_objmap *ho_objmap_new_from_bitmap(ho_bitmap const   *bit_in ) ;
#line 167
int ho_objmap_font_metrix(ho_objmap const   *m , int const   min_height , int const   max_height ,
                          int const   min_width , int const   max_width , int *height ,
                          int *width , unsigned char *nikud ) ;
#line 178
ho_bitmap *ho_objmap_to_bitmap(ho_objmap const   *obj_in ) ;
#line 189
ho_bitmap *ho_objmap_to_bitmap_by_size(ho_objmap const   *m , int min_height , int max_height ,
                                       int min_width , int max_width ) ;
#line 198
ho_bitmap *ho_objmap_to_bitmap_by_index(ho_objmap const   *m , int const   index___0 ) ;
#line 207
ho_bitmap *ho_objmap_to_bitmap_by_index_window(ho_objmap const   *m , int const   index___0 ,
                                               int const   frame ) ;
#line 217
int ho_objmap_update_reading_index(ho_objmap *m , unsigned char const   n_columns ,
                                   unsigned char const   dir_ltr ) ;
#line 226
ho_obj *ho_objmap_get_object_by_index(ho_objmap *m , int index___0 ) ;
#line 86 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.h"
int ho_dimentions_get_columns_with_x_start(ho_bitmap const   *m , int **column_start_list ) ;
#line 44 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_objlist *ho_objlist_new(void) 
{ 
  ho_objlist *new_hocr_object_list ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 50
  tmp = malloc(sizeof(ho_objlist ));
#line 50
  new_hocr_object_list = (ho_objlist *)tmp;
  }
#line 53
  if (! new_hocr_object_list) {
#line 54
    return ((ho_objlist *)((void *)0));
  }
  {
#line 57
  new_hocr_object_list->size = 0;
#line 58
  new_hocr_object_list->allocated_size = 1000;
#line 61
  tmp___0 = malloc(sizeof(ho_obj ) * (unsigned long )new_hocr_object_list->allocated_size);
#line 61
  new_hocr_object_list->objects = (ho_obj *)tmp___0;
  }
#line 65
  if (! new_hocr_object_list->objects) {
    {
#line 67
    free((void *)new_hocr_object_list);
    }
#line 68
    return ((ho_objlist *)((void *)0));
  }
#line 71
  return (new_hocr_object_list);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_free(ho_objlist *object_list ) 
{ 


  {
#line 77
  if (! object_list) {
#line 78
    return (-1);
  }
#line 81
  if (object_list->objects) {
    {
#line 82
    free((void *)object_list->objects);
    }
  }
  {
#line 85
  free((void *)object_list);
  }
#line 87
  return (0);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_add(ho_objlist *object_list , double weight , int x , int y , int width ,
                   int height ) 
{ 
  ho_obj *new_object_list_objects ;
  void *tmp ;

  {
#line 96
  if (object_list->size + 1 > 2000000000) {
#line 97
    return (-1);
  }
#line 100
  if (object_list->size + 1 >= object_list->allocated_size) {
    {
#line 102
    tmp = realloc((void *)object_list->objects, sizeof(ho_obj ) * (unsigned long )(object_list->allocated_size + 1000));
#line 102
    new_object_list_objects = (ho_obj *)tmp;
    }
#line 107
    if (new_object_list_objects) {
#line 109
      object_list->objects = new_object_list_objects;
#line 110
      object_list->allocated_size += 1000;
    } else {
#line 115
      return (-1);
    }
  }
#line 120
  (object_list->objects + object_list->size)->index = object_list->size;
#line 121
  (object_list->objects + object_list->size)->reading_index = object_list->size;
#line 122
  (object_list->objects + object_list->size)->weight = weight;
#line 123
  (object_list->objects + object_list->size)->x = x;
#line 124
  (object_list->objects + object_list->size)->y = y;
#line 125
  (object_list->objects + object_list->size)->height = height;
#line 126
  (object_list->objects + object_list->size)->width = width;
#line 127
  (object_list->size) ++;
#line 129
  return (0);
}
}
#line 132 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_get_index(ho_objlist *object_list , int index___0 ) 
{ 


  {
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! ((object_list->objects + index___0)->index != index___0)) {
#line 135
      goto while_break;
    }
#line 136
    index___0 = (object_list->objects + index___0)->index;
  }
  while_break: /* CIL Label */ ;
  }
#line 138
  return (index___0);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_obj *ho_objlist_get_object(ho_objlist *object_list , int index___0 ) 
{ 


  {
#line 144
  return (object_list->objects + index___0);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_add_pixel(ho_objlist *object_list , int index___0 , int x , int y ) 
{ 
  int x1 ;
  int x2 ;
  int y1___0 ;
  int y2 ;

  {
#line 150
  x1 = (object_list->objects + index___0)->x;
#line 151
  x2 = (object_list->objects + index___0)->x + (object_list->objects + index___0)->width;
#line 153
  y1___0 = (object_list->objects + index___0)->y;
#line 154
  y2 = (object_list->objects + index___0)->y + (object_list->objects + index___0)->height;
#line 157
  (object_list->objects + index___0)->weight += (double )1;
#line 158
  if (x1 > x) {
#line 159
    x1 = x;
  }
#line 160
  if (y1___0 > y) {
#line 161
    y1___0 = y;
  }
#line 162
  if (x2 <= x) {
#line 163
    x2 = x + 1;
  }
#line 164
  if (y2 <= y) {
#line 165
    y2 = y + 1;
  }
#line 167
  (object_list->objects + index___0)->x = x1;
#line 168
  (object_list->objects + index___0)->y = y1___0;
#line 169
  (object_list->objects + index___0)->height = y2 - y1___0;
#line 170
  (object_list->objects + index___0)->width = x2 - x1;
#line 172
  return (0);
}
}
#line 175 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_link(ho_objlist *object_list , int index1 , int index2 ) 
{ 
  int index___0 ;
  int x11 ;
  int x12 ;
  int y11 ;
  int y12 ;
  int x21 ;
  int x22 ;
  int y21 ;
  int y22 ;

  {
#line 183
  if (index1 == index2) {
#line 184
    return (-1);
  }
#line 187
  if (index2 < index1) {
#line 189
    index___0 = index1;
#line 190
    index1 = index2;
#line 191
    index2 = index___0;
  }
#line 195
  x11 = (object_list->objects + index1)->x;
#line 196
  x12 = (object_list->objects + index1)->x + (object_list->objects + index1)->width;
#line 197
  y11 = (object_list->objects + index1)->y;
#line 198
  y12 = (object_list->objects + index1)->y + (object_list->objects + index1)->height;
#line 202
  x21 = (object_list->objects + index2)->x;
#line 203
  x22 = (object_list->objects + index2)->x + (object_list->objects + index2)->width;
#line 204
  y21 = (object_list->objects + index2)->y;
#line 205
  y22 = (object_list->objects + index2)->y + (object_list->objects + index2)->height;
#line 209
  (object_list->objects + index2)->index = index1;
#line 212
  (object_list->objects + index1)->weight += (object_list->objects + index2)->weight;
#line 216
  if (x21 < x11) {
#line 217
    x11 = x21;
  }
#line 218
  if (y21 < y11) {
#line 219
    y11 = y21;
  }
#line 220
  if (x22 > x12) {
#line 221
    x12 = x22;
  }
#line 222
  if (y22 > y12) {
#line 223
    y12 = y22;
  }
#line 225
  (object_list->objects + index1)->x = x11;
#line 226
  (object_list->objects + index1)->y = y11;
#line 227
  (object_list->objects + index1)->height = y12 - y11;
#line 228
  (object_list->objects + index1)->width = x12 - x11;
#line 230
  return (0);
}
}
#line 233 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_clean(ho_objlist *object_list , int **map ) 
{ 
  ho_objlist *temp_object_list ;
  int new_index ;
  int i ;
  void *tmp ;

  {
  {
#line 240
  temp_object_list = ho_objlist_new();
  }
#line 241
  if (! temp_object_list) {
#line 242
    return (-1);
  }
  {
#line 244
  tmp = calloc((size_t )object_list->size, sizeof(int ));
#line 244
  *map = (int *)tmp;
  }
#line 245
  if (! *map) {
    {
#line 247
    ho_objlist_free(temp_object_list);
    }
#line 248
    return (-1);
  }
#line 252
  new_index = 0;
#line 253
  i = 0;
  {
#line 253
  while (1) {
    while_continue: /* CIL Label */ ;
#line 253
    if (! (i < object_list->size)) {
#line 253
      goto while_break;
    }
#line 256
    *(*map + i) = 0;
#line 257
    if ((object_list->objects + i)->index == i) {
      {
#line 259
      ho_objlist_add(temp_object_list, (object_list->objects + i)->weight, (object_list->objects + i)->x,
                     (object_list->objects + i)->y, (object_list->objects + i)->width,
                     (object_list->objects + i)->height);
#line 265
      *(*map + i) = new_index;
#line 267
      new_index ++;
      }
    }
#line 253
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 272
  object_list->size = 0;
#line 273
  i = 0;
  {
#line 273
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 273
    if (! (i < temp_object_list->size)) {
#line 273
      goto while_break___0;
    }
    {
#line 275
    ho_objlist_add(object_list, (temp_object_list->objects + i)->weight, (temp_object_list->objects + i)->x,
                   (temp_object_list->objects + i)->y, (temp_object_list->objects + i)->width,
                   (temp_object_list->objects + i)->height);
#line 273
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 284
  ho_objlist_free(temp_object_list);
  }
#line 286
  return (0);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_clean_by_reading_index(ho_objlist *object_list , int **map ) 
{ 
  ho_objlist *temp_object_list ;
  int new_index ;
  int i ;
  int j ;
  void *tmp ;

  {
  {
#line 296
  temp_object_list = ho_objlist_new();
  }
#line 297
  if (! temp_object_list) {
#line 298
    return (-1);
  }
  {
#line 300
  tmp = calloc((size_t )object_list->size, sizeof(int ));
#line 300
  *map = (int *)tmp;
  }
#line 301
  if (! *map) {
    {
#line 303
    ho_objlist_free(temp_object_list);
    }
#line 304
    return (-1);
  }
#line 308
  new_index = 0;
#line 309
  i = 0;
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! (i < object_list->size)) {
#line 309
      goto while_break;
    }
#line 311
    j = 0;
    {
#line 311
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 311
      if (! (j < object_list->size)) {
#line 311
        goto while_break___0;
      }
#line 312
      if ((object_list->objects + j)->reading_index == i) {
        {
#line 315
        *(*map + j) = i;
#line 317
        ho_objlist_add(temp_object_list, (object_list->objects + j)->weight, (object_list->objects + j)->x,
                       (object_list->objects + j)->y, (object_list->objects + j)->width,
                       (object_list->objects + j)->height);
        }
      }
#line 311
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 309
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  object_list->size = 0;
#line 328
  i = 0;
  {
#line 328
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 328
    if (! (i < temp_object_list->size)) {
#line 328
      goto while_break___1;
    }
    {
#line 330
    ho_objlist_add(object_list, (temp_object_list->objects + i)->weight, (temp_object_list->objects + i)->x,
                   (temp_object_list->objects + i)->y, (temp_object_list->objects + i)->width,
                   (temp_object_list->objects + i)->height);
#line 328
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 339
  ho_objlist_free(temp_object_list);
  }
#line 341
  return (0);
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_print(ho_objlist *object_list ) 
{ 
  int i ;

  {
  {
#line 349
  printf((char const   */* __restrict  */)"list has %d objects\n---w\th\tw\n---\n",
         object_list->size);
#line 351
  i = 1;
  }
  {
#line 351
  while (1) {
    while_continue: /* CIL Label */ ;
#line 351
    if (! (i < object_list->size)) {
#line 351
      goto while_break;
    }
    {
#line 353
    printf((char const   */* __restrict  */)"%0.0f\t%d\t%d\n", (object_list->objects + i)->weight,
           (object_list->objects + i)->height, (object_list->objects + i)->width);
#line 351
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 357
  return (0);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objlist_statistics(ho_objlist *object_list , int min_height , int max_height ,
                          int min_width , int max_width , int *counter , double *weight_avg ,
                          double *weight_com , double *weight_min , double *weight_max ,
                          int *height_avg , int *height_com , int *height_min , int *height_max ,
                          int *width_avg , int *width_com , int *width_min , int *width_max ) 
{ 
  double weight_histogram[60] ;
  int height_histogram[60] ;
  int width_histogram[60] ;
  double weight ;
  double weight_sum ;
  int height ;
  double height_sum ;
  int width ;
  double width_sum ;
  int i ;
  int histogram_index ;
  int histogram_index_weight ;
  int histogram_index_height ;
  int histogram_index_width ;
  double tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 383
  histogram_index_weight = 0;
#line 384
  histogram_index_height = 0;
#line 385
  histogram_index_width = 0;
#line 388
  i = 0;
  {
#line 388
  while (1) {
    while_continue: /* CIL Label */ ;
#line 388
    if (! (i < 60)) {
#line 388
      goto while_break;
    }
#line 390
    weight_histogram[i] = 0.0;
#line 391
    height_histogram[i] = 0;
#line 392
    width_histogram[i] = 0;
#line 388
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  weight = (object_list->objects + 0)->weight;
#line 397
  width = (object_list->objects + 0)->width;
#line 398
  height = (object_list->objects + 0)->height;
#line 400
  weight_sum = weight;
#line 400
  tmp = weight_sum;
#line 400
  *weight_max = tmp;
#line 400
  *weight_min = tmp;
#line 401
  width_sum = (double )width;
#line 401
  tmp___0 = (int )width_sum;
#line 401
  *width_max = tmp___0;
#line 401
  *width_min = tmp___0;
#line 402
  height_sum = (double )height;
#line 402
  tmp___1 = (int )height_sum;
#line 402
  *height_max = tmp___1;
#line 402
  *height_min = tmp___1;
#line 404
  *counter = 0;
#line 406
  i = 1;
  {
#line 406
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 406
    if (! (i < object_list->size)) {
#line 406
      goto while_break___0;
    }
#line 409
    weight = (object_list->objects + i)->weight;
#line 410
    width = (object_list->objects + i)->width;
#line 411
    height = (object_list->objects + i)->height;
#line 413
    if (width > min_width) {
#line 413
      if (width < max_width) {
#line 413
        if (height > min_height) {
#line 413
          if (height < max_height) {
#line 417
            (*counter) ++;
#line 420
            weight_sum += weight;
#line 421
            if (*weight_min > weight) {
#line 422
              *weight_min = weight;
            }
#line 423
            if (*weight_max < weight) {
#line 424
              *weight_max = weight;
            }
#line 426
            width_sum += (double )width;
#line 427
            if (*width_min > width) {
#line 428
              *width_min = width;
            }
#line 429
            if (*width_max < width) {
#line 430
              *width_max = width;
            }
#line 432
            height_sum += (double )height;
#line 433
            if (*height_min > height) {
#line 434
              *height_min = height;
            }
#line 435
            if (*height_max < height) {
#line 436
              *height_max = height;
            }
#line 439
            histogram_index = (int )(weight / (double )25);
#line 440
            if (histogram_index < 60) {
#line 441
              weight_histogram[histogram_index] += (double )1;
            }
#line 442
            histogram_index = height / 5;
#line 443
            if (histogram_index < 60) {
#line 444
              (height_histogram[histogram_index]) ++;
            }
#line 445
            histogram_index = width / 5;
#line 446
            if (histogram_index < 60) {
#line 447
              (width_histogram[histogram_index]) ++;
            }
          }
        }
      }
    }
#line 406
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 453
  if (*counter) {
#line 455
    *weight_avg = weight_sum / (double )*counter;
#line 456
    *height_avg = (int )(height_sum / (double )*counter);
#line 457
    *width_avg = (int )(width_sum / (double )*counter);
  }
#line 461
  i = 0;
  {
#line 461
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 461
    if (! (i < 60)) {
#line 461
      goto while_break___1;
    }
#line 463
    if (weight_histogram[histogram_index_weight] < weight_histogram[i]) {
#line 464
      histogram_index_weight = i;
    }
#line 465
    if (height_histogram[histogram_index_height] < height_histogram[i]) {
#line 466
      histogram_index_height = i;
    }
#line 467
    if (width_histogram[histogram_index_width] < width_histogram[i]) {
#line 468
      histogram_index_width = i;
    }
#line 461
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 472
  *weight_com = (double )histogram_index_weight * 25.0 + (double )12;
#line 474
  *height_com = histogram_index_height * 5 + 2;
#line 475
  *width_com = histogram_index_width * 5 + 2;
#line 478
  if (height_histogram[histogram_index_height] > 0) {
#line 481
    i = 0;
    {
#line 481
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 481
      if (! (i < 60)) {
#line 481
        goto while_break___2;
      }
#line 483
      height_histogram[i] = 0;
#line 484
      width_histogram[i] = 0;
#line 481
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 487
    i = 1;
    {
#line 487
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 487
      if (! (i < object_list->size)) {
#line 487
        goto while_break___3;
      }
#line 490
      height = (object_list->objects + i)->height;
#line 491
      width = (object_list->objects + i)->width;
#line 493
      if (width > min_width) {
#line 493
        if (width < max_width) {
#line 493
          if (height > min_height) {
#line 493
            if (height < max_height) {
#line 498
              if (height >= *height_com - 2) {
#line 498
                if (height <= *height_com + 2) {
#line 500
                  (height_histogram[(height - *height_com) + 2]) ++;
                }
              }
#line 504
              if (width >= *width_com - 2) {
#line 504
                if (width <= *width_com + 2) {
#line 506
                  (width_histogram[(width - *width_com) + 2]) ++;
                }
              }
            }
          }
        }
      }
#line 487
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 512
    histogram_index_height = 0;
#line 513
    histogram_index_width = 0;
#line 514
    i = 0;
    {
#line 514
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 514
      if (! (i < 5)) {
#line 514
        goto while_break___4;
      }
#line 516
      if (height_histogram[histogram_index_height] < height_histogram[i]) {
#line 517
        histogram_index_height = i;
      }
#line 518
      if (width_histogram[histogram_index_width] < width_histogram[i]) {
#line 519
        histogram_index_width = i;
      }
#line 514
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 523
    *height_com = (histogram_index_height + *height_com) - 2;
#line 524
    *width_com = (histogram_index_width + *width_com) - 2;
  }
#line 527
  return (0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_objmap *ho_objmap_new(int const   width , int const   height ) 
{ 
  ho_objmap *m_new ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 533
  m_new = (ho_objmap *)((void *)0);
#line 538
  tmp = malloc(sizeof(ho_objmap ));
#line 538
  m_new = (ho_objmap *)tmp;
  }
#line 539
  if (! m_new) {
#line 541
    return ((ho_objmap *)((void *)0));
  }
  {
#line 545
  m_new->x = 0;
#line 546
  m_new->y = 0;
#line 547
  m_new->width = (int )width;
#line 548
  m_new->height = (int )height;
#line 551
  tmp___0 = calloc((size_t )(m_new->height * m_new->width), sizeof(int ));
#line 551
  m_new->map = (int *)tmp___0;
  }
#line 552
  if (! m_new->map) {
    {
#line 554
    free((void *)m_new);
    }
#line 555
    return ((ho_objmap *)((void *)0));
  }
  {
#line 559
  m_new->obj_list = ho_objlist_new();
  }
#line 560
  if (! m_new->obj_list) {
    {
#line 562
    free((void *)m_new->map);
#line 563
    free((void *)m_new);
    }
#line 564
    return ((ho_objmap *)((void *)0));
  }
#line 567
  return (m_new);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objmap_free(ho_objmap *m ) 
{ 


  {
#line 573
  if (! m) {
#line 574
    return (-1);
  }
  {
#line 576
  ho_objlist_free(m->obj_list);
  }
#line 577
  if (m->map) {
    {
#line 578
    free((void *)m->map);
    }
  }
  {
#line 579
  free((void *)m);
  }
#line 581
  return (0);
}
}
#line 584 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objmap_clean(ho_objmap *m ) 
{ 
  int x ;
  int y ;
  int k ;
  int index___0 ;
  int *map ;

  {
#line 589
  map = (int *)((void *)0);
#line 592
  x = 0;
  {
#line 592
  while (1) {
    while_continue: /* CIL Label */ ;
#line 592
    if (! (x < m->width)) {
#line 592
      goto while_break;
    }
#line 593
    y = 0;
    {
#line 593
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 593
      if (! (y < m->height)) {
#line 593
        goto while_break___0;
      }
#line 596
      k = *(m->map + (x + y * m->width));
#line 597
      if (k) {
        {
#line 599
        index___0 = ho_objlist_get_index(m->obj_list, k - 1);
#line 600
        *(m->map + (x + y * m->width)) = index___0 + 1;
        }
      }
#line 593
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 592
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 605
  ho_objlist_clean(m->obj_list, & map);
#line 608
  x = 0;
  }
  {
#line 608
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 608
    if (! (x < m->width)) {
#line 608
      goto while_break___1;
    }
#line 609
    y = 0;
    {
#line 609
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 609
      if (! (y < m->height)) {
#line 609
        goto while_break___2;
      }
#line 611
      k = *(m->map + (x + y * m->width));
#line 612
      if (k) {
#line 614
        index___0 = *(map + (k - 1));
#line 615
        *(m->map + (x + y * m->width)) = index___0 + 1;
      }
#line 609
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 608
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 620
  if (map) {
    {
#line 621
    free((void *)map);
    }
  }
#line 623
  return (0);
}
}
#line 626 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objmap_sort_by_reading_index(ho_objmap *m , unsigned char const   col , unsigned char const   dir_ltr ) 
{ 
  int x ;
  int y ;
  int k ;
  int index___0 ;
  int *map ;

  {
  {
#line 632
  map = (int *)((void *)0);
#line 635
  ho_objmap_update_reading_index(m, col, dir_ltr);
#line 638
  ho_objlist_clean_by_reading_index(m->obj_list, & map);
#line 641
  x = 0;
  }
  {
#line 641
  while (1) {
    while_continue: /* CIL Label */ ;
#line 641
    if (! (x < m->width)) {
#line 641
      goto while_break;
    }
#line 642
    y = 0;
    {
#line 642
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 642
      if (! (y < m->height)) {
#line 642
        goto while_break___0;
      }
#line 644
      k = *(m->map + (x + y * m->width));
#line 645
      if (k) {
#line 647
        index___0 = *(map + (k - 1));
#line 648
        *(m->map + (x + y * m->width)) = index___0 + 1;
      }
#line 642
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 641
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 653
  if (map) {
    {
#line 654
    free((void *)map);
    }
  }
#line 656
  return (0);
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_objmap *ho_objmap_new_from_bitmap(ho_bitmap const   *bit_in ) 
{ 
  ho_objmap *m_new ;
  int x ;
  int y ;
  int k ;
  double sum ;
  double neigbors[4] ;
  int min ;
  int indexes[4] ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 662
  m_new = (ho_objmap *)((void *)0);
#line 671
  m_new = ho_objmap_new(bit_in->width, bit_in->height);
  }
#line 672
  if (! m_new) {
#line 673
    return ((ho_objmap *)((void *)0));
  }
#line 674
  m_new->x = (int )bit_in->x;
#line 675
  m_new->y = (int )bit_in->y;
#line 678
  x = 1;
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 678
    if (! (x < (int )bit_in->width)) {
#line 678
      goto while_break;
    }
#line 679
    y = 1;
    {
#line 679
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 679
      if (! (y < (int )(bit_in->height - 1))) {
#line 679
        goto while_break___0;
      }
#line 682
      if (((int )*(bit_in->data + (x / 8 + y * (int )bit_in->rowstride)) & (128 >> x % 8)) > 0) {
#line 682
        tmp___0 = 1;
      } else {
#line 682
        tmp___0 = 0;
      }
#line 682
      if (tmp___0) {
#line 685
        neigbors[0] = (double )*(m_new->map + ((x - 1) + (y - 1) * m_new->width));
#line 686
        neigbors[1] = (double )*(m_new->map + ((x - 1) + y * m_new->width));
#line 687
        neigbors[2] = (double )*(m_new->map + ((x - 1) + (y + 1) * m_new->width));
#line 688
        neigbors[3] = (double )*(m_new->map + (x + (y - 1) * m_new->width));
#line 690
        sum = ((neigbors[0] + neigbors[1]) + neigbors[2]) + neigbors[3];
#line 693
        if (sum == (double )0) {
          {
#line 695
          tmp = ho_objlist_add(m_new->obj_list, (double )1, x, y, 1, 1);
          }
#line 695
          if (tmp) {
            {
#line 698
            ho_objmap_free(m_new);
            }
#line 699
            return ((ho_objmap *)((void *)0));
          }
#line 703
          *(m_new->map + (x + y * m_new->width)) = (m_new->obj_list)->size;
        } else {
#line 709
          min = 0;
#line 710
          k = 0;
          {
#line 710
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 710
            if (! (k < 4)) {
#line 710
              goto while_break___1;
            }
#line 712
            if (neigbors[k]) {
              {
#line 714
              indexes[k] = ho_objlist_get_index(m_new->obj_list, (int )(neigbors[k] - (double )1));
              }
#line 716
              if (! min) {
#line 718
                min = indexes[k] + 1;
              } else
#line 716
              if (indexes[k] < min - 1) {
#line 718
                min = indexes[k] + 1;
              }
            } else {
#line 721
              indexes[k] = 0;
            }
#line 710
            k ++;
          }
          while_break___1: /* CIL Label */ ;
          }
          {
#line 724
          min --;
#line 727
          *(m_new->map + (x + y * m_new->width)) = min + 1;
#line 728
          ho_objlist_add_pixel(m_new->obj_list, min, x, y);
#line 731
          k = 0;
          }
          {
#line 731
          while (1) {
            while_continue___2: /* CIL Label */ ;
#line 731
            if (! (k < 4)) {
#line 731
              goto while_break___2;
            }
#line 733
            if (indexes[k]) {
              {
#line 734
              ho_objlist_link(m_new->obj_list, min, indexes[k]);
              }
            }
#line 731
            k ++;
          }
          while_break___2: /* CIL Label */ ;
          }
        }
      }
#line 679
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 678
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 741
  ho_objmap_clean(m_new);
  }
#line 743
  return (m_new);
}
}
#line 746 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objmap_font_metrix(ho_objmap const   *m , int const   min_height , int const   max_height ,
                          int const   min_width , int const   max_width , int *height ,
                          int *width , unsigned char *nikud ) 
{ 
  int counter ;
  double weight_avg ;
  double weight_com ;
  double weight_min ;
  double weight_max ;
  int height_avg ;
  int height_com ;
  int height_min ;
  int height_max ;
  int width_avg ;
  int width_com ;
  int width_min ;
  int width_max ;

  {
  {
#line 766
  *nikud = (unsigned char)0;
#line 769
  ho_objlist_statistics((ho_objlist *)m->obj_list, (int )min_height, (int )max_height,
                        (int )min_width, (int )max_width, & counter, & weight_avg,
                        & weight_com, & weight_min, & weight_max, & height_avg, & height_com,
                        & height_min, & height_max, & width_avg, & width_com, & width_min,
                        & width_max);
  }
#line 779
  if (height_avg < (2 * height_com) / 3) {
#line 781
    *nikud = (unsigned char)255;
  }
#line 785
  if (height_com < (2 * height_avg) / 3) {
    {
#line 787
    *nikud = (unsigned char)255;
#line 790
    ho_objlist_statistics((ho_objlist *)m->obj_list, (3 * height_avg) / 2, 300, (3 * width_avg) / 2,
                          300, & counter, & weight_avg, & weight_com, & weight_min,
                          & weight_max, & height_avg, & height_com, & height_min,
                          & height_max, & width_avg, & width_com, & width_min, & width_max);
    }
  }
#line 798
  if (height_com > (3 * width_com) / 2) {
#line 799
    width_com = (2 * height_com) / 3;
  }
#line 801
  *height = height_com;
#line 802
  *width = width_com;
#line 804
  return (0);
}
}
#line 807 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_bitmap *ho_objmap_to_bitmap(ho_objmap const   *obj_in ) 
{ 
  int x ;
  int y ;
  ho_bitmap *pix ;
  int index___0 ;

  {
  {
#line 811
  pix = (ho_bitmap *)((void *)0);
#line 812
  index___0 = 0;
#line 815
  pix = ho_bitmap_new(obj_in->width, obj_in->height);
  }
#line 816
  if (! pix) {
#line 817
    return ((ho_bitmap *)((void *)0));
  }
#line 820
  x = 0;
  {
#line 820
  while (1) {
    while_continue: /* CIL Label */ ;
#line 820
    if (! (x < (int )obj_in->width)) {
#line 820
      goto while_break;
    }
#line 821
    y = 0;
    {
#line 821
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 821
      if (! (y < (int )obj_in->height)) {
#line 821
        goto while_break___0;
      }
#line 823
      index___0 = *(obj_in->map + (x + y * (int )obj_in->width));
#line 825
      if (index___0) {
#line 828
        *(pix->data + (x / 8 + y * pix->rowstride)) = (unsigned char )((int )*(pix->data + (x / 8 + y * pix->rowstride)) | (128 >> x % 8));
      }
#line 821
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 820
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 832
  return (pix);
}
}
#line 835 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_bitmap *ho_objmap_to_bitmap_by_size(ho_objmap const   *m , int min_height , int max_height ,
                                       int min_width , int max_width ) 
{ 
  int x ;
  int y ;
  int index___0 ;
  int height ;
  int width ;
  ho_bitmap *m_out ;

  {
  {
#line 846
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 847
  if (! m_out) {
#line 848
    return ((ho_bitmap *)((void *)0));
  }
#line 850
  m_out->x = (int )m->x;
#line 851
  m_out->y = (int )m->y;
#line 853
  x = 0;
  {
#line 853
  while (1) {
    while_continue: /* CIL Label */ ;
#line 853
    if (! (x < (int )m->width)) {
#line 853
      goto while_break;
    }
#line 854
    y = 0;
    {
#line 854
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 854
      if (! (y < (int )m->height)) {
#line 854
        goto while_break___0;
      }
#line 856
      index___0 = *(m->map + (x + y * (int )m->width));
#line 858
      if (index___0) {
#line 861
        index___0 --;
#line 863
        width = ((m->obj_list)->objects + index___0)->width;
#line 864
        height = ((m->obj_list)->objects + index___0)->height;
#line 866
        if (width < min_width) {
#line 868
          goto __Cont;
        } else
#line 866
        if (width > max_width) {
#line 868
          goto __Cont;
        } else
#line 866
        if (height < min_height) {
#line 868
          goto __Cont;
        } else
#line 866
        if (height > max_height) {
#line 868
          goto __Cont;
        }
#line 870
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
      __Cont: /* CIL Label */ 
#line 854
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 853
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 874
  return (m_out);
}
}
#line 877 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_bitmap *ho_objmap_to_bitmap_by_index(ho_objmap const   *m , int const   index___0 ) 
{ 
  int x ;
  int y ;
  ho_bitmap *m_out ;
  int current_index ;
  int height ;
  int width ;

  {
#line 887
  if (index___0 >= (int const   )(m->obj_list)->size) {
#line 888
    return ((ho_bitmap *)((void *)0));
  }
#line 890
  width = ((m->obj_list)->objects + index___0)->width;
#line 891
  height = ((m->obj_list)->objects + index___0)->height;
#line 894
  if (width < 2) {
#line 895
    return ((ho_bitmap *)((void *)0));
  } else
#line 894
  if (height < 2) {
#line 895
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 898
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 899
  if (! m_out) {
#line 900
    return ((ho_bitmap *)((void *)0));
  }
#line 902
  m_out->x = (int )m->x;
#line 903
  m_out->y = (int )m->y;
#line 905
  x = 0;
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 905
    if (! (x < (int )m->width)) {
#line 905
      goto while_break;
    }
#line 906
    y = 0;
    {
#line 906
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 906
      if (! (y < (int )m->height)) {
#line 906
        goto while_break___0;
      }
#line 908
      current_index = *(m->map + (x + y * (int )m->width));
#line 910
      if (current_index - 1 == (int )index___0) {
#line 912
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
#line 906
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 905
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 916
  return (m_out);
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_bitmap *ho_objmap_to_bitmap_by_index_window(ho_objmap const   *m , int const   index___0 ,
                                               int const   frame ) 
{ 
  int x ;
  int y ;
  int x1 ;
  int y1___0 ;
  ho_bitmap *m_out ;
  int current_index ;
  int height ;
  int width ;

  {
#line 931
  if (index___0 >= (int const   )(m->obj_list)->size) {
#line 932
    return ((ho_bitmap *)((void *)0));
  }
#line 934
  width = ((m->obj_list)->objects + index___0)->width;
#line 935
  height = ((m->obj_list)->objects + index___0)->height;
#line 938
  if (width < 2) {
#line 939
    return ((ho_bitmap *)((void *)0));
  } else
#line 938
  if (height < 2) {
#line 939
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 942
  m_out = ho_bitmap_new((int const   )(width + 2 * (int )frame), (int const   )(height + 2 * (int )frame));
  }
#line 943
  if (! m_out) {
#line 944
    return ((ho_bitmap *)((void *)0));
  }
#line 946
  x1 = ((m->obj_list)->objects + index___0)->x;
#line 947
  y1___0 = ((m->obj_list)->objects + index___0)->y;
#line 949
  m_out->x = (int )((m->x + (int const   )x1) - frame);
#line 950
  m_out->y = (int )((m->y + (int const   )y1___0) - frame);
#line 952
  x = 0;
  {
#line 952
  while (1) {
    while_continue: /* CIL Label */ ;
#line 952
    if (! (x < width)) {
#line 952
      goto while_break;
    }
#line 953
    y = 0;
    {
#line 953
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 953
      if (! (y < height)) {
#line 953
        goto while_break___0;
      }
#line 955
      current_index = *(m->map + ((x + x1) + (y + y1___0) * (int )m->width));
#line 957
      if (current_index - 1 == (int )index___0) {
#line 959
        *(m_out->data + ((x + (int )frame) / 8 + (y + (int )frame) * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + ((x + (int )frame) / 8 + (y + (int )frame) * m_out->rowstride)) | (128 >> (x + (int )frame) % 8));
      }
#line 953
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 952
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 963
  return (m_out);
}
}
#line 966 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objmap_update_reading_index_line(ho_objmap *m , unsigned char const   n_columns ,
                                        unsigned char const   dir_ltr ) 
{ 
  int index___0 ;
  int reading_index ;
  int x ;

  {
#line 975
  if ((int const   )n_columns != 253) {
#line 976
    return (-1);
  }
#line 978
  reading_index = 0;
#line 980
  if (dir_ltr) {
#line 982
    x = 0;
    {
#line 982
    while (1) {
      while_continue: /* CIL Label */ ;
#line 982
      if (! (x < m->width)) {
#line 982
        goto while_break;
      }
#line 984
      index___0 = 0;
      {
#line 984
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 984
        if (! (index___0 < (m->obj_list)->size)) {
#line 984
          goto while_break___0;
        }
#line 986
        if ((((m->obj_list)->objects + index___0)->x + ((m->obj_list)->objects + index___0)->width) - 1 == x) {
#line 989
          ((m->obj_list)->objects + index___0)->reading_index = reading_index;
#line 990
          reading_index ++;
        }
#line 984
        index___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 982
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 997
    x = m->width;
    {
#line 997
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 997
      if (! (x >= 0)) {
#line 997
        goto while_break___1;
      }
#line 999
      index___0 = 0;
      {
#line 999
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 999
        if (! (index___0 < (m->obj_list)->size)) {
#line 999
          goto while_break___2;
        }
#line 1001
        if ((((m->obj_list)->objects + index___0)->x + ((m->obj_list)->objects + index___0)->width) - 1 == x) {
#line 1004
          ((m->obj_list)->objects + index___0)->reading_index = reading_index;
#line 1005
          reading_index ++;
        }
#line 999
        index___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 997
      x --;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1011
  return (0);
}
}
#line 1014 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objmap_update_reading_index_column(ho_objmap *m , unsigned char const   n_columns ,
                                          unsigned char const   dir_ltr ) 
{ 
  int index___0 ;
  int reading_index ;
  int y ;

  {
#line 1023
  if ((int const   )n_columns != 1) {
#line 1024
    return (-1);
  }
#line 1026
  reading_index = 0;
#line 1028
  y = 0;
  {
#line 1028
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1028
    if (! (y < m->height)) {
#line 1028
      goto while_break;
    }
#line 1030
    index___0 = 0;
    {
#line 1030
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1030
      if (! (index___0 < (m->obj_list)->size)) {
#line 1030
        goto while_break___0;
      }
#line 1032
      if (((m->obj_list)->objects + index___0)->y == y) {
#line 1034
        ((m->obj_list)->objects + index___0)->reading_index = reading_index;
#line 1035
        reading_index ++;
      }
#line 1030
      index___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1028
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1040
  return (0);
}
}
#line 1043 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objmap_update_reading_index_multi_columns(ho_objmap *m , unsigned char const   n_columns ,
                                                 unsigned char const   dir_ltr ) 
{ 
  int index___0 ;
  int column ;
  int reading_index ;
  int y ;
  int x_start ;
  int x_end ;
  int column_start_list_size ;
  int *column_start_list ;
  ho_bitmap *m_bitmap ;

  {
#line 1054
  m_bitmap = (ho_bitmap *)((void *)0);
#line 1057
  if ((int const   )n_columns < 2) {
#line 1058
    return (-1);
  } else
#line 1057
  if ((int const   )n_columns > 6) {
#line 1058
    return (-1);
  }
  {
#line 1060
  reading_index = 0;
#line 1063
  m_bitmap = ho_objmap_to_bitmap((ho_objmap const   *)m);
  }
#line 1064
  if (! m_bitmap) {
#line 1065
    return (-1);
  }
  {
#line 1067
  column_start_list_size = ho_dimentions_get_columns_with_x_start((ho_bitmap const   *)m_bitmap,
                                                                  & column_start_list);
#line 1071
  ho_bitmap_free(m_bitmap);
#line 1074
  x_start = m->width;
#line 1075
  column = 0;
  }
  {
#line 1075
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1075
    if (! (column < column_start_list_size)) {
#line 1075
      goto while_break;
    }
#line 1078
    x_end = x_start;
#line 1079
    x_start = *(column_start_list + column);
#line 1082
    y = 0;
    {
#line 1082
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1082
      if (! (y < m->height)) {
#line 1082
        goto while_break___0;
      }
#line 1085
      index___0 = 0;
      {
#line 1085
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 1085
        if (! (index___0 < (m->obj_list)->size)) {
#line 1085
          goto while_break___1;
        }
#line 1087
        if (((m->obj_list)->objects + index___0)->y == y) {
#line 1087
          if (((m->obj_list)->objects + index___0)->x >= x_start) {
#line 1087
            if (((m->obj_list)->objects + index___0)->x < x_end) {
#line 1091
              ((m->obj_list)->objects + index___0)->reading_index = reading_index;
#line 1092
              reading_index ++;
            }
          }
        }
#line 1085
        index___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 1082
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1075
    column ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1099
  free((void *)column_start_list);
  }
#line 1101
  return (0);
}
}
#line 1104 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
int ho_objmap_update_reading_index(ho_objmap *m , unsigned char const   n_columns ,
                                   unsigned char const   dir_ltr ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1109
  if ((int const   )n_columns == 1) {
    {
#line 1111
    tmp = ho_objmap_update_reading_index_column(m, n_columns, dir_ltr);
    }
#line 1111
    return (tmp);
  }
#line 1115
  if ((int const   )n_columns == 253) {
    {
#line 1117
    tmp___0 = ho_objmap_update_reading_index_line(m, n_columns, dir_ltr);
    }
#line 1117
    return (tmp___0);
  }
  {
#line 1121
  tmp___1 = ho_objmap_update_reading_index_multi_columns(m, n_columns, dir_ltr);
  }
#line 1121
  return (tmp___1);
#line 1123
  return (0);
}
}
#line 1126 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_objmap.c"
ho_obj *ho_objmap_get_object_by_index(ho_objmap *m , int index___0 ) 
{ 


  {
#line 1129
  return ((m->obj_list)->objects + index___0);
}
}
#line 60 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) atan2)(double __y ,
                                                                               double __x ) ;
#line 93 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.h"
ho_bitmap *ho_bitmap_clone(ho_bitmap const   *m ) ;
#line 105
ho_bitmap *ho_bitmap_clone_window(ho_bitmap const   *m , int const   x , int const   y ,
                                  int const   width , int const   height ) ;
#line 115
int ho_bitmap_and(ho_bitmap *m_left , ho_bitmap const   *m_right ) ;
#line 142
int ho_bitmap_andnot(ho_bitmap *m_left , ho_bitmap const   *m_right ) ;
#line 188
ho_bitmap *ho_bitmap_set_height(ho_bitmap const   *m , int const   height , int const   top ,
                                int const   bottom ) ;
#line 242
ho_bitmap *ho_bitmap_hlink(ho_bitmap const   *m , int const   size ) ;
#line 260
ho_bitmap *ho_bitmap_vlink(ho_bitmap const   *m , int const   size ) ;
#line 305
ho_bitmap *ho_bitmap_filter_by_size(ho_bitmap const   *m , int min_height , int max_height ,
                                    int min_width , int max_width ) ;
#line 378
int ho_bitmap_filter_count_objects(ho_bitmap const   *m ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.h"
int ho_dimentions_font_width_height_nikud(ho_bitmap *m , int const   min_height ,
                                          int const   max_height , int const   min_width ,
                                          int const   max_width ) ;
#line 55
int ho_dimentions_line_spacing(ho_bitmap *m ) ;
#line 63
int ho_dimentions_font_spacing(ho_bitmap *m , ho_bitmap const   *m_line_map ) ;
#line 71
int ho_dimentions_line_fill(ho_bitmap *m , ho_bitmap const   *m_line_map ) ;
#line 78
int ho_dimentions_get_columns(ho_bitmap const   *m ) ;
#line 95
double ho_dimentions_get_lines_angle(ho_bitmap const   *m ) ;
#line 90 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.h"
ho_bitmap *ho_segment_lines(ho_bitmap const   *m ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.c"
int ho_dimentions_font_width_height_nikud(ho_bitmap *m , int const   min_height ,
                                          int const   max_height , int const   min_width ,
                                          int const   max_width ) 
{ 
  int return_val ;
  ho_objmap *m_obj ;
  int height ;
  int width ;
  unsigned char nikud ;

  {
  {
#line 51
  m_obj = (ho_objmap *)((void *)0);
#line 57
  m_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m);
  }
#line 58
  if (! m_obj) {
#line 59
    return (-1);
  }
  {
#line 62
  return_val = ho_objmap_font_metrix((ho_objmap const   *)m_obj, min_height, max_height,
                                     min_width, max_width, & height, & width, & nikud);
#line 66
  ho_objmap_free(m_obj);
#line 68
  m->font_width = width;
#line 69
  m->font_height = height;
#line 70
  m->nikud = nikud;
  }
#line 72
  return (return_val);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.c"
int ho_dimentions_line_spacing(ho_bitmap *m ) 
{ 
  int return_val ;
  ho_objmap *m_obj ;
  ho_bitmap *m_clean ;
  ho_bitmap *m_temp1 ;
  ho_bitmap *m_temp2 ;
  int x ;
  int y ;
  int width ;
  int height ;
  unsigned char nikud_ret ;
  int font_height ;
  int font_width ;
  unsigned char nikud ;

  {
#line 79
  m_obj = (ho_objmap *)((void *)0);
#line 81
  m_clean = (ho_bitmap *)((void *)0);
#line 82
  m_temp1 = (ho_bitmap *)((void *)0);
#line 83
  m_temp2 = (ho_bitmap *)((void *)0);
#line 90
  font_height = m->font_height;
#line 91
  font_width = m->font_width;
#line 92
  nikud = m->nikud;
#line 95
  if (nikud) {
    {
#line 96
    m_clean = ho_bitmap_filter_by_size((ho_bitmap const   *)m, font_height / 2, font_height * 4,
                                       font_width / 3, font_width * 5);
    }
  } else {
    {
#line 99
    m_clean = ho_bitmap_filter_by_size((ho_bitmap const   *)m, font_height / 4, font_height * 4,
                                       font_width / 4, font_width * 5);
    }
  }
  {
#line 103
  m_temp1 = ho_bitmap_hlink((ho_bitmap const   *)m_clean, (int const   )(font_width * 4));
  }
#line 104
  if (! m_temp1) {
#line 105
    return (-1);
  }
  {
#line 106
  ho_bitmap_free(m_clean);
#line 108
  m_temp2 = ho_bitmap_vlink((ho_bitmap const   *)m_temp1, (int const   )(font_height * 4));
  }
#line 109
  if (! m_temp2) {
#line 110
    return (-1);
  }
  {
#line 112
  ho_bitmap_andnot(m_temp2, (ho_bitmap const   *)m_temp1);
#line 113
  ho_bitmap_free(m_temp1);
#line 116
  x = font_width * 3;
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (x < m->width)) {
#line 116
      goto while_break;
    }
#line 117
    y = 0;
    {
#line 117
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 117
      if (! (y < m->height)) {
#line 117
        goto while_break___0;
      }
#line 118
      *(m_temp2->data + (x / 8 + y * m_temp2->rowstride)) = (unsigned char )((int )*(m_temp2->data + (x / 8 + y * m_temp2->rowstride)) & ~ (128 >> x % 8));
#line 117
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 116
    x += font_width * 3 + 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 121
  m_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_temp2);
#line 122
  ho_bitmap_free(m_temp2);
#line 125
  return_val = ho_objmap_font_metrix((ho_objmap const   *)m_obj, (int const   )(font_height / 2),
                                     (int const   )(font_height * 4), (int const   )(font_width * 2),
                                     (int const   )(font_width * 4), & height, & width,
                                     & nikud_ret);
#line 129
  ho_objmap_free(m_obj);
  }
#line 132
  if (height < font_height) {
#line 133
    height = (int )((double )font_height * 1.5);
  } else
#line 132
  if (height > font_height * 4) {
#line 133
    height = (int )((double )font_height * 1.5);
  }
#line 135
  m->line_spacing = height;
#line 137
  return (return_val);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.c"
int ho_dimentions_font_spacing(ho_bitmap *m , ho_bitmap const   *m_line_map ) 
{ 
  int font_spacing ;
  ho_objmap *o_obj ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_out ;
  int n_fonts_free ;
  int n_fonts_block ;
  int x ;
  int y ;
  int i ;

  {
  {
#line 143
  font_spacing = 0;
#line 144
  o_obj = (ho_objmap *)((void *)0);
#line 155
  m_temp = ho_bitmap_filter_by_size((ho_bitmap const   *)m, m->font_height / 6, m->font_height * 3,
                                    m->font_width / 8, 3 * m->font_width);
  }
#line 158
  if (! m_temp) {
#line 159
    return (-1);
  }
  {
#line 160
  ho_bitmap_and(m_temp, m_line_map);
#line 161
  m_out = m_temp;
#line 164
  n_fonts_free = ho_bitmap_filter_count_objects((ho_bitmap const   *)m_out);
#line 167
  m_temp = ho_bitmap_set_height((ho_bitmap const   *)m_out, (int const   )(m->font_height * 2),
                                (int const   )m->font_height, (int const   )m->font_height);
#line 170
  ho_bitmap_free(m_out);
  }
#line 171
  if (! m_temp) {
#line 172
    return (-1);
  }
  {
#line 173
  m_out = m_temp;
#line 175
  m_temp = ho_bitmap_clone(m_line_map);
  }
#line 176
  if (! m_temp) {
#line 177
    return (-1);
  }
  {
#line 178
  ho_bitmap_and(m_temp, (ho_bitmap const   *)m_out);
#line 179
  ho_bitmap_free(m_out);
#line 180
  m_out = m_temp;
#line 182
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )(m->font_width / 4));
  }
#line 183
  if (! m_temp) {
#line 184
    return (-1);
  }
  {
#line 185
  ho_bitmap_free(m_out);
#line 186
  m_out = m_temp;
#line 189
  n_fonts_block = ho_bitmap_filter_count_objects((ho_bitmap const   *)m_out);
  }
#line 190
  if (n_fonts_block < (4 * n_fonts_free) / 5) {
    {
#line 193
    m->font_spacing = 0;
#line 194
    ho_bitmap_free(m_out);
    }
#line 195
    return (0);
  }
  {
#line 198
  m_temp = ho_bitmap_clone(m_line_map);
#line 199
  ho_bitmap_andnot(m_temp, (ho_bitmap const   *)m_out);
#line 200
  ho_bitmap_free(m_out);
  }
#line 201
  if (! m_temp) {
#line 202
    return (-1);
  }
  {
#line 203
  m_out = m_temp;
#line 205
  m_temp = ho_bitmap_filter_by_size((ho_bitmap const   *)m_out, 5, m->height, 1, m->font_width / 2);
#line 206
  ho_bitmap_free(m_out);
  }
#line 207
  if (! m_temp) {
#line 208
    return (-1);
  }
#line 209
  m_out = m_temp;
#line 212
  y = m->font_height;
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! (y < m->height)) {
#line 212
      goto while_break;
    }
#line 213
    x = 0;
    {
#line 213
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 213
      if (! (x < m->width)) {
#line 213
        goto while_break___0;
      }
#line 214
      *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) & ~ (128 >> x % 8));
#line 213
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 212
    y += m->font_height / 5 + 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 217
  o_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_out);
#line 218
  ho_bitmap_free(m_out);
  }
#line 219
  if (! o_obj) {
#line 220
    return (-1);
  }
#line 222
  if ((o_obj->obj_list)->size < 4) {
    {
#line 225
    m->font_spacing = 255;
#line 226
    ho_objmap_free(o_obj);
    }
#line 227
    return (0);
  }
#line 231
  i = 0;
  {
#line 231
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 231
    if (! (i < (o_obj->obj_list)->size)) {
#line 231
      goto while_break___1;
    }
#line 232
    if (font_spacing < ((o_obj->obj_list)->objects + i)->width) {
#line 233
      font_spacing = ((o_obj->obj_list)->objects + i)->width;
    }
#line 231
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 235
  if (font_spacing < m->font_width / 5) {
#line 236
    font_spacing = m->font_width / 5;
  }
  {
#line 238
  m->font_spacing = font_spacing;
#line 240
  ho_objmap_free(o_obj);
  }
#line 242
  return (0);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.c"
int ho_dimentions_line_fill(ho_bitmap *m , ho_bitmap const   *m_line_map ) 
{ 
  ho_bitmap *m_temp ;
  int avg_line_fill ;
  int com_line_fill ;
  int *line_fill ;
  int *line_fill_hist ;
  int counter ;
  int x ;
  int y ;
  int line_height ;
  int cell_size_for_common_fill_hist ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;

  {
#line 256
  cell_size_for_common_fill_hist = 3;
#line 259
  x = (int )(m_line_map->width / 2);
#line 260
  y = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (y < (int )m_line_map->height) {
#line 260
      if (((int )*(m_line_map->data + (x / 8 + y * (int )m_line_map->rowstride)) & (128 >> x % 8)) > 0) {
#line 260
        tmp = 1;
      } else {
#line 260
        tmp = 0;
      }
#line 260
      if (tmp) {
#line 260
        goto while_break;
      }
    } else {
#line 260
      goto while_break;
    }
#line 260
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 262
  line_height = y;
  {
#line 263
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 263
    if (y < (int )m_line_map->height) {
#line 263
      if (((int )*(m_line_map->data + (x / 8 + y * (int )m_line_map->rowstride)) & (128 >> x % 8)) > 0) {
#line 263
        tmp___0 = 1;
      } else {
#line 263
        tmp___0 = 0;
      }
#line 263
      if (! tmp___0) {
#line 263
        goto while_break___0;
      }
    } else {
#line 263
      goto while_break___0;
    }
#line 263
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 264
  line_height = y - line_height;
#line 267
  tmp___1 = calloc((size_t )m->width, sizeof(int ));
#line 267
  line_fill = (int *)tmp___1;
  }
#line 268
  if (! line_fill) {
#line 269
    return (-1);
  }
  {
#line 270
  tmp___2 = malloc((unsigned long )(m->height / cell_size_for_common_fill_hist) * sizeof(int ));
#line 270
  line_fill_hist = (int *)tmp___2;
  }
#line 272
  if (! line_fill_hist) {
#line 273
    return (-1);
  }
#line 276
  y = 0;
  {
#line 276
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 276
    if (! (y < m->height / cell_size_for_common_fill_hist)) {
#line 276
      goto while_break___1;
    }
#line 278
    *(line_fill_hist + y) = line_height;
#line 276
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 282
  m_temp = ho_bitmap_clone((ho_bitmap const   *)m);
  }
#line 283
  if (! m_temp) {
#line 284
    return (-1);
  }
  {
#line 285
  ho_bitmap_and(m_temp, m_line_map);
#line 288
  avg_line_fill = 0;
#line 289
  counter = 0;
#line 290
  x = 0;
  }
  {
#line 290
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 290
    if (! (x < m->width)) {
#line 290
      goto while_break___2;
    }
#line 292
    y = 0;
    {
#line 292
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 292
      if (! (y < m->height)) {
#line 292
        goto while_break___3;
      }
#line 294
      if (((int )*(m_temp->data + (x / 8 + y * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 294
        tmp___3 = 1;
      } else {
#line 294
        tmp___3 = 0;
      }
#line 294
      *(line_fill + x) += tmp___3;
#line 292
      y ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 296
    avg_line_fill += *(line_fill + x);
#line 297
    if (*(line_fill + x)) {
#line 298
      counter ++;
    }
#line 290
    x ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 302
  ho_bitmap_free(m_temp);
  }
#line 304
  if (! counter) {
#line 306
    return (-1);
  }
#line 310
  y = cell_size_for_common_fill_hist + 1;
  {
#line 310
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 310
    if (! (y < m->height)) {
#line 310
      goto while_break___4;
    }
#line 312
    x = 0;
    {
#line 312
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 312
      if (! (x < m->width)) {
#line 312
        goto while_break___5;
      }
#line 313
      if (*(line_fill + x) / cell_size_for_common_fill_hist == y / cell_size_for_common_fill_hist) {
#line 315
        (*(line_fill_hist + y / cell_size_for_common_fill_hist)) ++;
      }
#line 312
      x ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 310
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 319
  com_line_fill = 1;
#line 320
  y = 1;
  {
#line 320
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 320
    if (! (y < line_height / cell_size_for_common_fill_hist)) {
#line 320
      goto while_break___6;
    }
#line 322
    if (*(line_fill_hist + com_line_fill) < *(line_fill_hist + y)) {
#line 323
      com_line_fill = y;
    }
#line 320
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 325
  com_line_fill *= cell_size_for_common_fill_hist;
#line 328
  avg_line_fill /= counter;
#line 331
  free((void *)line_fill);
#line 332
  free((void *)line_fill_hist);
  }
#line 335
  if (! line_height) {
#line 337
    m->avg_line_fill = 0;
#line 338
    m->com_line_fill = 0;
  } else {
#line 342
    m->avg_line_fill = (100 * avg_line_fill) / line_height;
#line 343
    m->com_line_fill = (100 * com_line_fill) / line_height;
  }
#line 346
  return (0);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.c"
int ho_dimentions_get_columns(ho_bitmap const   *m ) 
{ 
  int i ;
  int return_val ;
  int hlink_value ;
  ho_bitmap *m_cols ;
  ho_bitmap *m_temp ;
  ho_objmap *m_obj ;
  ho_bitmap *m_clean ;

  {
#line 354
  m_cols = (ho_bitmap *)((void *)0);
#line 355
  m_temp = (ho_bitmap *)((void *)0);
#line 356
  m_obj = (ho_objmap *)((void *)0);
#line 360
  if (m->width > 120) {
#line 360
    if (m->height > 120) {
      {
#line 362
      m_clean = ho_bitmap_clone_window(m, (int const   )30, (int const   )30, m->width - 60,
                                       m->height - 60);
      }
#line 363
      if (! m_clean) {
#line 364
        return (1);
      }
    } else {
#line 369
      return (1);
    }
  } else {
#line 369
    return (1);
  }
  {
#line 373
  m_temp = ho_bitmap_vlink((ho_bitmap const   *)m_clean, m->height / 3);
#line 374
  ho_bitmap_free(m_clean);
  }
#line 375
  if (! m_temp) {
#line 376
    return (1);
  }
#line 379
  if (m->width / 100 < 30) {
#line 379
    hlink_value = 30;
  } else {
#line 379
    hlink_value = (int )(m->width / 100);
  }
  {
#line 380
  m_cols = ho_bitmap_hlink((ho_bitmap const   *)m_temp, (int const   )hlink_value);
#line 381
  ho_bitmap_free(m_temp);
  }
#line 382
  if (! m_cols) {
#line 383
    return (1);
  }
  {
#line 386
  m_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_cols);
#line 387
  ho_bitmap_free(m_cols);
  }
#line 388
  if (! m_obj) {
#line 389
    return (1);
  }
#line 392
  return_val = 0;
#line 393
  i = 0;
  {
#line 393
  while (1) {
    while_continue: /* CIL Label */ ;
#line 393
    if (! (i < (m_obj->obj_list)->size)) {
#line 393
      goto while_break;
    }
#line 394
    if (((m_obj->obj_list)->objects + i)->width > (int )(m->width / 8)) {
#line 395
      return_val ++;
    }
#line 393
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 397
  ho_objmap_free(m_obj);
  }
#line 399
  return (return_val);
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.c"
int ho_dimentions_get_columns_with_x_start(ho_bitmap const   *m , int **column_start_list ) 
{ 
  int i ;
  int index___0 ;
  int return_val ;
  int x ;
  int hlink_value ;
  ho_bitmap *m_cols ;
  ho_bitmap *m_temp ;
  ho_objmap *m_obj ;
  ho_bitmap *m_clean ;
  void *tmp ;

  {
#line 409
  m_cols = (ho_bitmap *)((void *)0);
#line 410
  m_temp = (ho_bitmap *)((void *)0);
#line 411
  m_obj = (ho_objmap *)((void *)0);
#line 415
  if (m->width > 120) {
#line 415
    if (m->height > 120) {
      {
#line 417
      m_clean = ho_bitmap_clone_window(m, (int const   )30, (int const   )30, m->width - 60,
                                       m->height - 60);
      }
#line 418
      if (! m_clean) {
#line 419
        return (1);
      }
    } else {
#line 424
      return (1);
    }
  } else {
#line 424
    return (1);
  }
  {
#line 428
  m_temp = ho_bitmap_vlink((ho_bitmap const   *)m_clean, m->height / 2);
#line 429
  ho_bitmap_free(m_clean);
  }
#line 432
  if (m->width / 100 < 30) {
#line 432
    hlink_value = 30;
  } else {
#line 432
    hlink_value = (int )(m->width / 100);
  }
  {
#line 433
  m_cols = ho_bitmap_hlink((ho_bitmap const   *)m_temp, (int const   )hlink_value);
#line 434
  ho_bitmap_free(m_temp);
  }
#line 435
  if (! m_cols) {
#line 436
    return (1);
  }
  {
#line 439
  m_temp = ho_bitmap_filter_by_size((ho_bitmap const   *)m_cols, (int )(m->height / 8),
                                    (int )m->height, (int )(m->width / 8), (int )m->width);
#line 441
  ho_bitmap_free(m_cols);
  }
#line 442
  if (! m_temp) {
#line 443
    return (1);
  }
  {
#line 444
  m_cols = m_temp;
#line 447
  m_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_cols);
#line 448
  ho_bitmap_free(m_cols);
  }
#line 449
  if (! m_obj) {
#line 450
    return (1);
  }
#line 453
  return_val = (m_obj->obj_list)->size;
#line 456
  if (return_val > 1) {
    {
#line 458
    tmp = calloc((size_t )return_val, sizeof(int ));
#line 458
    *column_start_list = (int *)tmp;
    }
#line 461
    if (*column_start_list) {
#line 464
      i = 0;
      {
#line 464
      while (1) {
        while_continue: /* CIL Label */ ;
#line 464
        if (! (i < return_val)) {
#line 464
          goto while_break;
        }
#line 465
        *(*column_start_list + i) = 0;
#line 464
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
#line 468
      index___0 = 0;
#line 469
      x = (int )m->width;
      {
#line 469
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 469
        if (x >= 0) {
#line 469
          if (! (index___0 < return_val)) {
#line 469
            goto while_break___0;
          }
        } else {
#line 469
          goto while_break___0;
        }
#line 471
        i = 0;
        {
#line 471
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 471
          if (! (i < return_val)) {
#line 471
            goto while_break___1;
          }
#line 473
          if (((m_obj->obj_list)->objects + i)->x == x) {
#line 475
            *(*column_start_list + index___0) = x;
#line 476
            index___0 ++;
          }
#line 471
          i ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 469
        x --;
      }
      while_break___0: /* CIL Label */ ;
      }
    }
  }
  {
#line 483
  ho_objmap_free(m_obj);
  }
#line 485
  return (return_val);
}
}
#line 488 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_dimentions.c"
double ho_dimentions_get_lines_angle(ho_bitmap const   *m ) 
{ 
  int i ;
  int number_of_lines ;
  int y_left ;
  int y_right ;
  int width ;
  double angle ;
  ho_bitmap *m_lines ;
  ho_bitmap *m_temp ;
  ho_objmap *m_obj ;
  int tmp ;
  int tmp___0 ;
  double tmp___1 ;

  {
  {
#line 495
  m_lines = (ho_bitmap *)((void *)0);
#line 496
  m_temp = (ho_bitmap *)((void *)0);
#line 497
  m_obj = (ho_objmap *)((void *)0);
#line 500
  m_lines = ho_segment_lines(m);
  }
#line 501
  if (! m_lines) {
#line 502
    return ((double )0);
  }
  {
#line 505
  m_temp = ho_bitmap_filter_by_size((ho_bitmap const   *)m_lines, 10, m_lines->height / 2,
                                    (2 * m_lines->width) / 3, m_lines->width);
#line 507
  ho_bitmap_free(m_lines);
  }
#line 508
  if (! m_temp) {
#line 509
    return ((double )0);
  }
  {
#line 510
  m_lines = m_temp;
#line 513
  m_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_lines);
#line 514
  ho_bitmap_free(m_lines);
  }
#line 515
  if (! m_obj) {
#line 516
    return ((double )0);
  }
#line 519
  number_of_lines = (m_obj->obj_list)->size;
#line 522
  if (number_of_lines < 1) {
#line 523
    return ((double )0);
  }
  {
#line 526
  m_temp = ho_objmap_to_bitmap_by_index_window((ho_objmap const   *)m_obj, (int const   )0,
                                               (int const   )(number_of_lines / 2));
#line 527
  ho_objmap_free(m_obj);
  }
#line 528
  if (! m_temp) {
#line 529
    return ((double )0);
  }
#line 532
  y_left = 0;
#line 533
  i = 0;
  {
#line 533
  while (1) {
    while_continue: /* CIL Label */ ;
#line 533
    if (! (i < m_temp->height)) {
#line 533
      goto while_break;
    }
#line 535
    if (((int )*(m_temp->data + ((m_temp->width / 4) / 8 + i * m_temp->rowstride)) & (128 >> (m_temp->width / 4) % 8)) > 0) {
#line 535
      tmp = 1;
    } else {
#line 535
      tmp = 0;
    }
#line 535
    if (tmp) {
#line 537
      y_left = i;
#line 538
      i = m_temp->height;
    }
#line 533
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  y_right = 0;
#line 543
  i = 0;
  {
#line 543
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 543
    if (! (i < m_temp->height)) {
#line 543
      goto while_break___0;
    }
#line 545
    if (((int )*(m_temp->data + (((3 * m_temp->width) / 4) / 8 + i * m_temp->rowstride)) & (128 >> ((3 * m_temp->width) / 4) % 8)) > 0) {
#line 545
      tmp___0 = 1;
    } else {
#line 545
      tmp___0 = 0;
    }
#line 545
    if (tmp___0) {
#line 547
      y_right = i;
#line 548
      i = m_temp->height;
    }
#line 543
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 552
  ho_bitmap_free(m_temp);
#line 554
  width = (2 * m_temp->width) / 4;
  }
#line 557
  if (y_left - y_right == 0) {
#line 558
    return ((double )0);
  } else
#line 557
  if (width < 10) {
#line 558
    return ((double )0);
  }
  {
#line 561
  tmp___1 = atan2((double )(y_left - y_right), (double )width);
#line 561
  angle = (180.0 * tmp___1) / 3.14159265358979323846;
  }
#line 563
  return (angle);
}
}
#line 41 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.h"
static char const   *ho_nikud_array[16]  = 
#line 41 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.h"
  {      "",      "\326\270",      "\326\267",      "\326\265", 
        "\326\266",      "\326\271",      "\326\274",      "\326\273", 
        "\326\264",      "\326\260",      "\326\261",      "\326\262", 
        "\326\263",      "\326\274",      "\327\201",      "\327\202"};
#line 59
int ho_recognize_nikud_array_in_size(void) ;
#line 60
int ho_recognize_nikud_array_out_size(void) ;
#line 62
int ho_recognize_nikud_array_in(ho_bitmap const   *m_nikud , ho_bitmap const   *m_mask ,
                                double *array_in ) ;
#line 66
int ho_recognize_nikud_array_out(double const   *array_in , double *array_out , int font_code ) ;
#line 69
char const   *ho_recognize_array_out_to_nikud(double const   *array_out ) ;
#line 71
char const   *ho_recognize_nikud(ho_bitmap const   *m_nikud , ho_bitmap const   *m_mask ,
                                 int font_code , char const   **dagesh , char const   **shin ) ;
#line 75
int ho_recognize_nikud_dimentions(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                  double *height , double *width , double *top , double *bottom ,
                                  double *top_left , double *top_mid , double *top_right ,
                                  double *mid_left , double *mid_right , double *bottom_left ,
                                  double *bottom_mid , double *bottom_right , double *dots_above ,
                                  double *dots_below , double *dots_inside , double *objs_above ,
                                  double *objs_below , double *objs_inside , double *main_obj_height ,
                                  double *main_obj_width , double *top_dot_x , double *inside_dot_x ,
                                  double *font_width_by_height ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.c"
int ho_recognize_nikud_array_in_size(void) 
{ 


  {
#line 50
  return (24);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.c"
int ho_recognize_nikud_array_out_size(void) 
{ 


  {
#line 56
  return (16);
}
}
#line 59 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.c"
int ho_recognize_nikud_dimentions(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                  double *height , double *width , double *top , double *bottom ,
                                  double *top_left , double *top_mid , double *top_right ,
                                  double *mid_left , double *mid_right , double *bottom_left ,
                                  double *bottom_mid , double *bottom_right , double *dots_above ,
                                  double *dots_below , double *dots_inside , double *objs_above ,
                                  double *objs_below , double *objs_inside , double *main_obj_height ,
                                  double *main_obj_width , double *top_dot_x , double *inside_dot_x ,
                                  double *font_width_by_height ) 
{ 
  int i ;
  int x ;
  int y ;
  int obj_width ;
  int obj_height ;
  int obj_x ;
  int obj_y ;
  int obj_w ;
  int obj_h ;
  int line_start ;
  int line_end ;
  int line_height ;
  int sum ;
  int font_start_x ;
  int font_end_x ;
  int font_height ;
  int font_width ;
  int font_start_y ;
  int font_end_y ;
  ho_objmap *o_obj ;
  unsigned char is_dot ;
  unsigned char is_obj ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;

  {
#line 79
  o_obj = (ho_objmap *)((void *)0);
#line 83
  *height = 0.0;
#line 84
  *width = 0.0;
#line 85
  *top = 0.0;
#line 86
  *bottom = 0.0;
#line 87
  *top_left = 0.0;
#line 88
  *top_mid = 0.0;
#line 89
  *top_right = 0.0;
#line 90
  *mid_left = 0.0;
#line 91
  *mid_right = 0.0;
#line 92
  *bottom_left = 0.0;
#line 93
  *bottom_mid = 0.0;
#line 94
  *bottom_right = 0.0;
#line 95
  *dots_above = 0.0;
#line 96
  *dots_below = 0.0;
#line 97
  *dots_inside = 0.0;
#line 98
  *objs_above = 0.0;
#line 99
  *objs_below = 0.0;
#line 100
  *objs_inside = 0.0;
#line 101
  *top_dot_x = 0.0;
#line 102
  *inside_dot_x = 0.0;
#line 103
  *font_width_by_height = 0.0;
#line 106
  x = (int )(m_mask->width / 2);
#line 107
  y = 0;
  {
#line 107
  while (1) {
    while_continue: /* CIL Label */ ;
#line 107
    if (y < (int )m_mask->height) {
#line 107
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 107
        tmp = 1;
      } else {
#line 107
        tmp = 0;
      }
#line 107
      if (tmp) {
#line 107
        goto while_break;
      }
    } else {
#line 107
      goto while_break;
    }
#line 107
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  line_start = y - 1;
  {
#line 109
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 109
    if (y < (int )m_mask->height) {
#line 109
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 109
        tmp___0 = 1;
      } else {
#line 109
        tmp___0 = 0;
      }
#line 109
      if (! tmp___0) {
#line 109
        goto while_break___0;
      }
    } else {
#line 109
      goto while_break___0;
    }
#line 109
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 110
  line_end = y;
#line 111
  line_height = line_end - line_start;
#line 113
  if (line_height < 4) {
#line 114
    return (-1);
  } else
#line 113
  if (m_text->width < 4) {
#line 114
    return (-1);
  }
  {
#line 116
  *font_width_by_height = (double )m_mask->width / (double )line_height;
#line 119
  o_obj = ho_objmap_new_from_bitmap(m_text);
  }
#line 120
  if (! o_obj) {
#line 121
    return (-1);
  }
#line 124
  if ((o_obj->obj_list)->size == 0) {
    {
#line 126
    ho_objmap_free(o_obj);
    }
#line 128
    return (0);
  }
#line 132
  obj_x = 0;
#line 133
  obj_y = 0;
#line 134
  obj_w = 0;
#line 135
  obj_h = 0;
#line 137
  i = 0;
  {
#line 137
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 137
    if (! (i < (o_obj->obj_list)->size)) {
#line 137
      goto while_break___1;
    }
#line 140
    y = ((o_obj->obj_list)->objects + i)->y;
#line 141
    x = ((o_obj->obj_list)->objects + i)->x;
#line 142
    obj_width = ((o_obj->obj_list)->objects + i)->width;
#line 143
    obj_height = ((o_obj->obj_list)->objects + i)->height;
#line 145
    if (obj_height < line_height / 4) {
#line 145
      if (obj_height > line_height / 16) {
#line 145
        if (obj_width < line_height / 4) {
#line 145
          if (obj_width > line_height / 16) {
#line 145
            tmp___1 = 1;
          } else {
#line 145
            tmp___1 = 0;
          }
        } else {
#line 145
          tmp___1 = 0;
        }
      } else {
#line 145
        tmp___1 = 0;
      }
    } else {
#line 145
      tmp___1 = 0;
    }
#line 145
    is_dot = (unsigned char )tmp___1;
#line 148
    if (obj_height > line_height / 4) {
#line 148
      tmp___2 = 1;
    } else
#line 148
    if (obj_width > line_height / 4) {
#line 148
      tmp___2 = 1;
    } else {
#line 148
      tmp___2 = 0;
    }
#line 148
    is_obj = (unsigned char )tmp___2;
#line 150
    if (is_dot) {
#line 153
      if (y + obj_height / 2 < line_start) {
#line 155
        *dots_above += 0.1;
#line 156
        *top_dot_x = (double )x / (double )m_text->width;
      } else
#line 158
      if (y + obj_height / 2 > line_end) {
#line 160
        *dots_below += 0.1;
      } else {
#line 164
        *dots_inside += 0.1;
#line 165
        *inside_dot_x = (double )x / (double )m_text->width;
      }
    } else
#line 168
    if (is_obj) {
#line 171
      if (y + obj_height / 2 < line_start) {
#line 173
        *objs_above += 0.1;
      } else
#line 175
      if (y + obj_height / 2 > line_end) {
#line 177
        *objs_below += 0.1;
#line 180
        if ((double )obj_width > *width) {
#line 182
          obj_x = x;
#line 183
          obj_y = y;
#line 184
          obj_w = obj_width;
#line 185
          obj_h = obj_height;
        }
      } else {
#line 190
        *objs_inside += 0.1;
      }
    }
#line 137
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 196
  ho_objmap_free(o_obj);
  }
#line 199
  if (! *objs_below) {
#line 199
    if (! *dots_below) {
#line 200
      return (0);
    }
  }
#line 203
  *main_obj_height = (2.0 * (double )obj_h) / (double )line_height;
#line 204
  *main_obj_width = (2.0 * (double )obj_w) / (double )line_height;
#line 206
  if (obj_y) {
#line 206
    if (obj_h) {
#line 208
      *top = (2.0 * (double )(obj_y - line_end)) / (double )line_height;
#line 209
      *bottom = (2.0 * (double )((obj_y + obj_h) - line_end)) / (double )line_height;
    }
  }
#line 214
  sum = 0;
#line 215
  y = line_end + 1;
  {
#line 215
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 215
    if (y < (int )m_text->height) {
#line 215
      if (! (sum == 0)) {
#line 215
        goto while_break___2;
      }
    } else {
#line 215
      goto while_break___2;
    }
#line 216
    sum = 0;
#line 216
    x = 1;
    {
#line 216
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 216
      if (! (x < (int )(m_text->width - 1))) {
#line 216
        goto while_break___3;
      }
#line 217
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 217
        tmp___3 = 1;
      } else {
#line 217
        tmp___3 = 0;
      }
#line 217
      sum += tmp___3;
#line 216
      x ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 215
    y ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 218
  font_start_y = y - 1;
#line 219
  sum = 0;
#line 220
  y = (int )(m_text->height - 1);
  {
#line 220
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 220
    if (y > font_start_y) {
#line 220
      if (! (sum == 0)) {
#line 220
        goto while_break___4;
      }
    } else {
#line 220
      goto while_break___4;
    }
#line 221
    sum = 0;
#line 221
    x = 1;
    {
#line 221
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 221
      if (! (x < (int )(m_text->width - 1))) {
#line 221
        goto while_break___5;
      }
#line 222
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 222
        tmp___4 = 1;
      } else {
#line 222
        tmp___4 = 0;
      }
#line 222
      sum += tmp___4;
#line 221
      x ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 220
    y --;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 223
  font_end_y = y + 1;
#line 224
  font_height = font_end_y - font_start_y;
#line 226
  if (! font_height) {
#line 227
    return (-1);
  }
#line 229
  *height = (2.0 * (double )font_height) / (double )line_height;
#line 231
  sum = 0;
#line 232
  x = 2;
  {
#line 232
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 232
    if (x < (int )m_text->width) {
#line 232
      if (! (sum == 0)) {
#line 232
        goto while_break___6;
      }
    } else {
#line 232
      goto while_break___6;
    }
#line 233
    sum = 0;
#line 233
    y = line_end;
    {
#line 233
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 233
      if (! (y < (int )(m_text->height - 1))) {
#line 233
        goto while_break___7;
      }
#line 234
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 234
        tmp___5 = 1;
      } else {
#line 234
        tmp___5 = 0;
      }
#line 234
      sum += tmp___5;
#line 233
      y ++;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 232
    x ++;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 235
  font_start_x = x - 1;
#line 236
  sum = 0;
#line 238
  sum = 0;
#line 238
  x = (int )(m_text->width - 2);
  {
#line 238
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 238
    if (x > font_start_x + 1) {
#line 238
      if (! (sum == 0)) {
#line 238
        goto while_break___8;
      }
    } else {
#line 238
      goto while_break___8;
    }
#line 239
    sum = 0;
#line 239
    y = line_end;
    {
#line 239
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 239
      if (! (y < (int )(m_text->height - 1))) {
#line 239
        goto while_break___9;
      }
#line 240
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 240
        tmp___6 = 1;
      } else {
#line 240
        tmp___6 = 0;
      }
#line 240
      sum += tmp___6;
#line 239
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 238
    x --;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 241
  font_end_x = x + 1;
#line 242
  font_width = font_end_x - font_start_x;
#line 244
  if (! font_width) {
#line 245
    return (-1);
  }
#line 247
  *width = (2.0 * (double )font_width) / (double )line_height;
#line 250
  y = font_start_y;
#line 250
  x = font_start_x;
  {
#line 250
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 250
    if (x < font_end_x) {
#line 250
      if (y < font_end_y) {
#line 250
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 250
          tmp___7 = 1;
        } else {
#line 250
          tmp___7 = 0;
        }
#line 250
        if (tmp___7) {
#line 250
          goto while_break___10;
        }
      } else {
#line 250
        goto while_break___10;
      }
    } else {
#line 250
      goto while_break___10;
    }
#line 250
    x ++;
#line 250
    y ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 253
  *top_left = (double )(x - font_start_x) / (double )(line_height / 4);
#line 255
  if (*top_left > 1.0) {
#line 256
    *top_left = 1.0;
  }
#line 258
  y = font_end_y;
#line 258
  x = font_start_x;
  {
#line 258
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 258
    if (x < font_end_x) {
#line 258
      if (y > font_start_y) {
#line 258
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 258
          tmp___8 = 1;
        } else {
#line 258
          tmp___8 = 0;
        }
#line 258
        if (tmp___8) {
#line 258
          goto while_break___11;
        }
      } else {
#line 258
        goto while_break___11;
      }
    } else {
#line 258
      goto while_break___11;
    }
#line 258
    x ++;
#line 258
    y --;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 261
  *bottom_left = (double )(x - font_start_x) / (double )(line_height / 4);
#line 263
  if (*bottom_left > 1.0) {
#line 264
    *bottom_left = 1.0;
  }
#line 266
  y = font_start_y;
#line 266
  x = font_end_x - 1;
  {
#line 266
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 266
    if (x > font_start_x) {
#line 266
      if (y < font_end_y) {
#line 266
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 266
          tmp___9 = 1;
        } else {
#line 266
          tmp___9 = 0;
        }
#line 266
        if (tmp___9) {
#line 266
          goto while_break___12;
        }
      } else {
#line 266
        goto while_break___12;
      }
    } else {
#line 266
      goto while_break___12;
    }
#line 266
    x --;
#line 266
    y ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 269
  *top_right = (double )(font_end_x - x) / (double )(line_height / 4);
#line 271
  if (*top_right > 1.0) {
#line 272
    *top_right = 1.0;
  }
#line 274
  y = font_end_y;
#line 274
  x = font_end_x - 1;
  {
#line 274
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 274
    if (x > font_start_x) {
#line 274
      if (y > font_start_y) {
#line 274
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 274
          tmp___10 = 1;
        } else {
#line 274
          tmp___10 = 0;
        }
#line 274
        if (tmp___10) {
#line 274
          goto while_break___13;
        }
      } else {
#line 274
        goto while_break___13;
      }
    } else {
#line 274
      goto while_break___13;
    }
#line 274
    x --;
#line 274
    y --;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 277
  *bottom_right = (double )(font_end_x - x) / (double )(line_height / 4);
#line 279
  if (*bottom_right > 1.0) {
#line 280
    *bottom_right = 1.0;
  }
#line 282
  y = font_start_y;
#line 282
  x = font_start_x + font_width / 2;
  {
#line 282
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 282
    if (y < font_start_y + font_height) {
#line 282
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 282
        tmp___11 = 1;
      } else {
#line 282
        tmp___11 = 0;
      }
#line 282
      if (tmp___11) {
#line 282
        goto while_break___14;
      }
    } else {
#line 282
      goto while_break___14;
    }
#line 282
    y ++;
  }
  while_break___14: /* CIL Label */ ;
  }
#line 284
  *top_mid = (double )(y - font_start_y) / (double )(line_height / 4);
#line 286
  if (*top_mid > 1.0) {
#line 287
    *top_mid = 1.0;
  }
#line 289
  y = font_end_y;
#line 289
  x = font_start_x + font_width / 2;
  {
#line 289
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 289
    if (y > font_start_y + font_height) {
#line 289
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 289
        tmp___12 = 1;
      } else {
#line 289
        tmp___12 = 0;
      }
#line 289
      if (tmp___12) {
#line 289
        goto while_break___15;
      }
    } else {
#line 289
      goto while_break___15;
    }
#line 289
    y --;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 291
  *bottom_mid = (double )(font_end_y - y) / (double )(line_height / 4);
#line 293
  if (*bottom_mid > 1.0) {
#line 294
    *bottom_mid = 1.0;
  }
#line 296
  y = font_start_y + font_height / 2;
#line 296
  x = font_start_x;
  {
#line 296
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 296
    if (x < font_end_x) {
#line 296
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 296
        tmp___13 = 1;
      } else {
#line 296
        tmp___13 = 0;
      }
#line 296
      if (tmp___13) {
#line 296
        goto while_break___16;
      }
    } else {
#line 296
      goto while_break___16;
    }
#line 296
    x ++;
  }
  while_break___16: /* CIL Label */ ;
  }
#line 298
  *mid_left = (double )(x - font_start_x) / (double )(line_height / 4);
#line 300
  if (*mid_left > 1.0) {
#line 301
    *mid_left = 1.0;
  }
#line 303
  y = font_start_y + font_height / 2;
#line 303
  x = font_end_x - 1;
  {
#line 303
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 303
    if (x > font_start_x) {
#line 303
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 303
        tmp___14 = 1;
      } else {
#line 303
        tmp___14 = 0;
      }
#line 303
      if (tmp___14) {
#line 303
        goto while_break___17;
      }
    } else {
#line 303
      goto while_break___17;
    }
#line 303
    x --;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 305
  *mid_right = (double )(font_end_x - x) / (double )(line_height / 4);
#line 307
  if (*mid_right > 1.0) {
#line 308
    *mid_right = 1.0;
  }
#line 310
  return (0);
}
}
#line 313 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.c"
int ho_recognize_nikud_array_in(ho_bitmap const   *m_nikud , ho_bitmap const   *m_mask ,
                                double *array_in ) 
{ 
  double height ;
  double width ;
  double top ;
  double bottom ;
  double top_left ;
  double top_mid ;
  double top_right ;
  double mid_left ;
  double mid_right ;
  double bottom_left ;
  double bottom_mid ;
  double bottom_right ;
  double dots_above ;
  double dots_below ;
  double dots_inside ;
  double objs_above ;
  double objs_below ;
  double objs_inside ;
  double main_obj_height ;
  double main_obj_width ;
  double top_dot_x ;
  double inside_dot_x ;
  double font_width_by_height ;

  {
  {
#line 342
  ho_recognize_nikud_dimentions(m_nikud, m_mask, & height, & width, & top, & bottom,
                                & top_left, & top_mid, & top_right, & mid_left, & mid_right,
                                & bottom_left, & bottom_mid, & bottom_right, & dots_above,
                                & dots_below, & dots_inside, & objs_above, & objs_below,
                                & objs_inside, & main_obj_height, & main_obj_width,
                                & top_dot_x, & inside_dot_x, & font_width_by_height);
#line 353
  *(array_in + 0) = height;
#line 354
  *(array_in + 1) = width;
  }
#line 355
  if (height) {
#line 356
    *(array_in + 2) = width / height;
  } else {
#line 358
    *(array_in + 2) = 0.0;
  }
#line 359
  if (*(array_in + 2) > 1.0) {
#line 360
    *(array_in + 2) = 1.0;
  }
#line 361
  *(array_in + 3) = top;
#line 362
  *(array_in + 4) = bottom;
#line 363
  *(array_in + 5) = top_left;
#line 364
  *(array_in + 6) = top_mid;
#line 365
  *(array_in + 7) = top_right;
#line 366
  *(array_in + 8) = mid_left;
#line 367
  *(array_in + 9) = mid_right;
#line 368
  *(array_in + 10) = bottom_left;
#line 369
  *(array_in + 11) = bottom_mid;
#line 370
  *(array_in + 12) = bottom_right;
#line 372
  *(array_in + 13) = dots_above;
#line 373
  *(array_in + 14) = dots_inside;
#line 374
  *(array_in + 15) = dots_below;
#line 375
  *(array_in + 16) = objs_above;
#line 376
  *(array_in + 17) = objs_inside;
#line 377
  *(array_in + 18) = objs_below;
#line 379
  *(array_in + 19) = main_obj_width;
#line 380
  *(array_in + 20) = main_obj_height;
#line 382
  *(array_in + 21) = top_dot_x;
#line 383
  *(array_in + 22) = inside_dot_x;
#line 384
  *(array_in + 23) = font_width_by_height;
#line 386
  return (0);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.c"
int ho_recognize_nikud_array_out(double const   *array_in , double *array_out , int font_code ) 
{ 
  int i ;

  {
#line 396
  *(array_out + 0) = 0.1;
#line 398
  i = 1;
  {
#line 398
  while (1) {
    while_continue: /* CIL Label */ ;
#line 398
    if (! (i < 16)) {
#line 398
      goto while_break;
    }
#line 399
    *(array_out + i) = 0.0;
#line 398
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  if (*(array_in + 13) == (double const   )0.1) {
#line 404
    if (*(array_in + 23) < (double const   )0.53) {
#line 407
      *(array_out + 5) = 1.0;
    } else
#line 411
    if (*(array_in + 21) > (double const   )0.5) {
#line 414
      *(array_out + 14) = - 1.0;
    } else {
#line 419
      *(array_out + 15) = - 1.0;
    }
  }
#line 425
  if (*(array_in + 14) == (double const   )0.1) {
#line 427
    if (*(array_in + 23) < (double const   )0.53) {
#line 430
      *(array_out + 6) = 1.0;
    } else {
#line 435
      *(array_out + 13) = - 1.0;
    }
  }
#line 440
  if (*(array_in + 14) > (double const   )0.1) {
#line 440
    if (*(array_in + 14) < (double const   )0.3) {
#line 443
      *(array_out + 9) = 1.0;
    }
  }
#line 447
  if (*(array_in + 18) == (double const   )0.1) {
#line 447
    if (*(array_in + 15) == (double const   )0.0) {
#line 450
      if (*(array_in + 1) > (double const   )(1.8 * (double )*(array_in + 0))) {
#line 452
        if (*(array_in + 6) > (double const   )0.25) {
#line 455
          *(array_out + 3) = 1.0;
        } else {
#line 460
          *(array_out + 2) = 1.0;
        }
      } else
#line 463
      if (*(array_in + 0) > (double const   )(1.8 * (double )*(array_in + 1))) {
#line 466
        *(array_out + 9) = 1.0;
      } else
#line 470
      if (*(array_in + 12) > (double const   )0.1) {
#line 472
        if (*(array_in + 6) < (double const   )0.2) {
#line 475
          *(array_out + 1) = 1.0;
        } else {
#line 480
          *(array_out + 4) = 1.0;
        }
      } else {
#line 486
        *(array_out + 7) = 1.0;
      }
    }
  }
#line 492
  if (*(array_in + 15) > (double const   )0.0) {
#line 492
    if (*(array_in + 15) < (double const   )0.2) {
#line 492
      if (*(array_in + 18) == (double const   )0.0) {
#line 495
        *(array_out + 8) = 1.0;
      }
    }
  }
#line 499
  if (*(array_in + 15) > (double const   )0.1) {
#line 499
    if (*(array_in + 15) < (double const   )0.3) {
#line 501
      if (*(array_in + 18) != (double const   )0.1) {
#line 503
        if (*(array_in + 1) > (double const   )(1.8 * (double )*(array_in + 0))) {
#line 503
          if (*(array_in + 1) > (double const   )0.65) {
#line 506
            *(array_out + 3) = 1.0;
          } else {
#line 511
            *(array_out + 9) = 1.0;
          }
        } else {
#line 511
          *(array_out + 9) = 1.0;
        }
      } else
#line 516
      if (*(array_in + 19) > (double const   )(2.0 * (double )*(array_in + 20))) {
#line 519
        *(array_out + 11) = 1.0;
      } else {
#line 524
        *(array_out + 12) = 1.0;
      }
    }
  }
#line 530
  if (*(array_in + 15) > (double const   )0.2) {
#line 530
    if (*(array_in + 15) < (double const   )0.4) {
#line 532
      if (*(array_in + 11) > (double const   )0.1) {
#line 535
        *(array_out + 7) = 1.0;
      } else
#line 532
      if (*(array_in + 7) > (double const   )0.5) {
#line 535
        *(array_out + 7) = 1.0;
      } else {
#line 540
        *(array_out + 4) = 1.0;
      }
    }
  }
#line 545
  if (*(array_in + 15) > (double const   )0.4) {
#line 545
    if (*(array_in + 15) < (double const   )0.6) {
#line 548
      *(array_out + 10) = 1.0;
    }
  }
#line 551
  return (0);
}
}
#line 554 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.c"
char const   *ho_recognize_array_out_to_nikud(double const   *array_out ) 
{ 
  int i ;
  int max_i ;

  {
#line 557
  i = 0;
#line 558
  max_i = 0;
#line 561
  i = 1;
  {
#line 561
  while (1) {
    while_continue: /* CIL Label */ ;
#line 561
    if (! (i < 16)) {
#line 561
      goto while_break;
    }
#line 562
    if (*(array_out + i) > *(array_out + max_i)) {
#line 563
      max_i = i;
    }
#line 561
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 564
  return (ho_nikud_array[max_i]);
}
}
#line 567 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize_nikud.c"
char const   *ho_recognize_nikud(ho_bitmap const   *m_nikud , ho_bitmap const   *m_mask ,
                                 int font_code , char const   **dagesh , char const   **shin ) 
{ 
  double array_in[24] ;
  double array_out[16] ;
  char const   *font ;

  {
  {
#line 575
  *dagesh = ho_nikud_array[0];
#line 576
  *shin = ho_nikud_array[0];
#line 578
  ho_recognize_nikud_array_in(m_nikud, m_mask, array_in);
#line 579
  ho_recognize_nikud_array_out((double const   *)(array_in), array_out, font_code);
#line 580
  font = ho_recognize_array_out_to_nikud((double const   *)(array_out));
  }
#line 583
  if (array_out[13] == - 1.0) {
#line 584
    *dagesh = ho_nikud_array[13];
  }
#line 587
  if (array_out[14] == - 1.0) {
#line 588
    *shin = ho_nikud_array[14];
  }
#line 589
  if (array_out[15] == - 1.0) {
#line 590
    *shin = ho_nikud_array[15];
  }
#line 592
  return (font);
}
}
#line 63 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.h"
ho_bitmap *ho_segment_paragraphs(ho_bitmap const   *m , unsigned char const   box ) ;
#line 112
ho_bitmap *ho_segment_words(ho_bitmap const   *m , ho_bitmap const   *m_line_map ,
                            char const   font_spacing_code ) ;
#line 124
ho_bitmap *ho_segment_fonts(ho_bitmap const   *m , ho_bitmap const   *m_line_map ,
                            unsigned char const   slicing_threshold , unsigned char const   slicing_width ,
                            unsigned char const   line_leeway ) ;
#line 82 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.h"
ho_layout *ho_layout_new(ho_bitmap const   *m_page_text , char const   font_spacing_code ,
                         unsigned char const   type , unsigned char const   dir ) ;
#line 90
int ho_layout_free(ho_layout *l_page ) ;
#line 97
int ho_layout_create_block_mask(ho_layout *l_page ) ;
#line 105
int ho_layout_create_line_mask(ho_layout *l_page , int const   block_index ) ;
#line 114
int ho_layout_create_word_mask(ho_layout *l_page , int const   block_index , int const   line_index ) ;
#line 128
int ho_layout_create_font_mask(ho_layout *l_page , int const   block_index , int const   line_index ,
                               int const   word_index , unsigned char const   slicing_threshold ,
                               unsigned char const   slicing_width , unsigned char const   line_leeway ) ;
#line 140
ho_bitmap *ho_layout_get_block_text(ho_layout const   *l_page , int block_index ) ;
#line 150
ho_bitmap *ho_layout_get_line_text(ho_layout const   *l_page , int block_index , int line_index ) ;
#line 162
ho_bitmap *ho_layout_get_word_text(ho_layout const   *l_page , int block_index , int line_index ,
                                   int word_index ) ;
#line 175
ho_bitmap *ho_layout_get_font_text(ho_layout const   *l_page , int block_index , int line_index ,
                                   int word_index , int font_index ) ;
#line 186
ho_bitmap *ho_layout_get_line_line_mask(ho_layout const   *l_page , int block_index ,
                                        int line_index ) ;
#line 198
ho_bitmap *ho_layout_get_word_line_mask(ho_layout const   *l_page , int block_index ,
                                        int line_index , int word_index ) ;
#line 211
ho_bitmap *ho_layout_get_font_line_mask(ho_layout const   *l_page , int block_index ,
                                        int line_index , int word_index , int font_index ) ;
#line 45 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
ho_layout *ho_layout_new(ho_bitmap const   *m_page_text , char const   font_spacing_code ,
                         unsigned char const   type , unsigned char const   dir ) 
{ 
  ho_layout *l_new ;
  void *tmp ;

  {
  {
#line 52
  tmp = malloc(sizeof(ho_layout ));
#line 52
  l_new = (ho_layout *)tmp;
  }
#line 53
  if (! l_new) {
#line 55
    return ((ho_layout *)((void *)0));
  }
  {
#line 58
  l_new->m_page_text = ho_bitmap_clone(m_page_text);
  }
#line 59
  if (! l_new->m_page_text) {
    {
#line 61
    free((void *)l_new);
    }
#line 62
    return ((ho_layout *)((void *)0));
  }
#line 65
  l_new->font_spacing_code = (char )font_spacing_code;
#line 66
  l_new->type = (unsigned char )type;
#line 67
  l_new->dir = (unsigned char )dir;
#line 71
  l_new->m_page_blocks_mask = (ho_bitmap *)((void *)0);
#line 73
  l_new->n_blocks = 0;
#line 74
  l_new->m_blocks_text = (ho_bitmap **)((void *)0);
#line 75
  l_new->m_blocks_lines_mask = (ho_bitmap **)((void *)0);
#line 77
  l_new->n_lines = (int *)((void *)0);
#line 78
  l_new->m_lines_text = (ho_bitmap ***)((void *)0);
#line 79
  l_new->m_lines_line_mask = (ho_bitmap ***)((void *)0);
#line 80
  l_new->m_lines_words_mask = (ho_bitmap ***)((void *)0);
#line 82
  l_new->n_words = (int **)((void *)0);
#line 83
  l_new->m_words_text = (ho_bitmap ****)((void *)0);
#line 84
  l_new->m_words_line_mask = (ho_bitmap ****)((void *)0);
#line 85
  l_new->m_words_font_mask = (ho_bitmap ****)((void *)0);
#line 87
  l_new->n_fonts = (int ***)((void *)0);
#line 89
  l_new->number_of_fonts = 0;
#line 91
  return (l_new);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
int ho_layout_free(ho_layout *l_page ) 
{ 
  int block_index ;
  int line_index ;
  int word_index ;

  {
#line 99
  if (! l_page) {
#line 100
    return (-1);
  }
#line 102
  block_index = 0;
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! (block_index < l_page->n_blocks)) {
#line 102
      goto while_break;
    }
#line 104
    line_index = 0;
    {
#line 104
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 104
      if (! (line_index < *(l_page->n_lines + block_index))) {
#line 104
        goto while_break___0;
      }
#line 107
      word_index = 0;
      {
#line 107
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 107
        if (! (word_index < *(*(l_page->n_words + block_index) + line_index))) {
#line 107
          goto while_break___1;
        }
#line 111
        if (*(*(*(l_page->m_words_line_mask + block_index) + line_index) + word_index)) {
          {
#line 112
          ho_bitmap_free(*(*(*(l_page->m_words_line_mask + block_index) + line_index) + word_index));
          }
        }
#line 114
        if (*(*(*(l_page->m_words_text + block_index) + line_index) + word_index)) {
          {
#line 115
          ho_bitmap_free(*(*(*(l_page->m_words_text + block_index) + line_index) + word_index));
          }
        }
#line 117
        if (*(*(*(l_page->m_words_font_mask + block_index) + line_index) + word_index)) {
          {
#line 118
          ho_bitmap_free(*(*(*(l_page->m_words_font_mask + block_index) + line_index) + word_index));
          }
        }
#line 107
        word_index ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 123
      if (*(*(l_page->m_lines_words_mask + block_index) + line_index)) {
        {
#line 124
        ho_bitmap_free(*(*(l_page->m_lines_words_mask + block_index) + line_index));
        }
      }
#line 125
      if (*(*(l_page->m_lines_text + block_index) + line_index)) {
        {
#line 126
        ho_bitmap_free(*(*(l_page->m_lines_text + block_index) + line_index));
        }
      }
#line 127
      if (*(*(l_page->m_lines_line_mask + block_index) + line_index)) {
        {
#line 128
        ho_bitmap_free(*(*(l_page->m_lines_line_mask + block_index) + line_index));
        }
      }
#line 131
      if (*(*(l_page->m_words_font_mask + block_index) + line_index)) {
        {
#line 132
        free((void *)*(*(l_page->m_words_font_mask + block_index) + line_index));
        }
      }
#line 133
      if (*(*(l_page->m_words_text + block_index) + line_index)) {
        {
#line 134
        free((void *)*(*(l_page->m_words_text + block_index) + line_index));
        }
      }
#line 135
      if (*(*(l_page->m_words_line_mask + block_index) + line_index)) {
        {
#line 136
        free((void *)*(*(l_page->m_words_line_mask + block_index) + line_index));
        }
      }
#line 139
      if (*(*(l_page->n_fonts + block_index) + line_index)) {
        {
#line 140
        free((void *)*(*(l_page->n_fonts + block_index) + line_index));
        }
      }
#line 104
      line_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 144
    if (*(l_page->m_blocks_lines_mask + block_index)) {
      {
#line 145
      ho_bitmap_free(*(l_page->m_blocks_lines_mask + block_index));
      }
    }
#line 146
    if (*(l_page->m_blocks_text + block_index)) {
      {
#line 147
      ho_bitmap_free(*(l_page->m_blocks_text + block_index));
      }
    }
#line 150
    if (*(l_page->m_lines_words_mask + block_index)) {
      {
#line 151
      free((void *)*(l_page->m_lines_words_mask + block_index));
      }
    }
#line 152
    if (*(l_page->m_lines_text + block_index)) {
      {
#line 153
      free((void *)*(l_page->m_lines_text + block_index));
      }
    }
#line 154
    if (*(l_page->m_lines_line_mask + block_index)) {
      {
#line 155
      free((void *)*(l_page->m_lines_line_mask + block_index));
      }
    }
#line 158
    if (*(l_page->n_words + block_index)) {
      {
#line 159
      free((void *)*(l_page->n_words + block_index));
      }
    }
#line 160
    if (*(l_page->m_words_font_mask + block_index)) {
      {
#line 161
      free((void *)*(l_page->m_words_font_mask + block_index));
      }
    }
#line 162
    if (*(l_page->m_words_text + block_index)) {
      {
#line 163
      free((void *)*(l_page->m_words_text + block_index));
      }
    }
#line 164
    if (*(l_page->m_words_line_mask + block_index)) {
      {
#line 165
      free((void *)*(l_page->m_words_line_mask + block_index));
      }
    }
#line 168
    if (*(l_page->n_fonts + block_index)) {
      {
#line 169
      free((void *)*(l_page->n_fonts + block_index));
      }
    }
#line 102
    block_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 173
  if (l_page->m_page_text) {
    {
#line 174
    ho_bitmap_free(l_page->m_page_text);
    }
  }
#line 175
  if (l_page->m_page_blocks_mask) {
    {
#line 176
    ho_bitmap_free(l_page->m_page_blocks_mask);
    }
  }
#line 179
  if (l_page->m_blocks_text) {
    {
#line 180
    free((void *)l_page->m_blocks_text);
    }
  }
#line 181
  if (l_page->m_blocks_lines_mask) {
    {
#line 182
    free((void *)l_page->m_blocks_lines_mask);
    }
  }
#line 185
  if (l_page->n_lines) {
    {
#line 186
    free((void *)l_page->n_lines);
    }
  }
#line 187
  if (l_page->m_lines_text) {
    {
#line 188
    free((void *)l_page->m_lines_text);
    }
  }
#line 189
  if (l_page->m_lines_line_mask) {
    {
#line 190
    free((void *)l_page->m_lines_line_mask);
    }
  }
#line 191
  if (l_page->m_lines_words_mask) {
    {
#line 192
    free((void *)l_page->m_lines_words_mask);
    }
  }
#line 195
  if (l_page->n_words) {
    {
#line 196
    free((void *)l_page->n_words);
    }
  }
#line 197
  if (l_page->m_words_font_mask) {
    {
#line 198
    free((void *)l_page->m_words_font_mask);
    }
  }
#line 199
  if (l_page->m_words_text) {
    {
#line 200
    free((void *)l_page->m_words_text);
    }
  }
#line 201
  if (l_page->m_words_line_mask) {
    {
#line 202
    free((void *)l_page->m_words_line_mask);
    }
  }
#line 205
  if (l_page->n_fonts) {
    {
#line 206
    free((void *)l_page->n_fonts);
    }
  }
#line 209
  if (l_page) {
    {
#line 210
    free((void *)l_page);
    }
  }
#line 212
  return (0);
}
}
#line 215 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
int ho_layout_create_block_mask(ho_layout *l_page ) 
{ 
  ho_objmap *o_map_blocks ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;
  void *tmp___7 ;
  void *tmp___8 ;
  void *tmp___9 ;

  {
  {
#line 218
  o_map_blocks = (ho_objmap *)((void *)0);
#line 222
  ho_dimentions_font_width_height_nikud(l_page->m_page_text, (int const   )12, (int const   )350,
                                        (int const   )12, (int const   )350);
#line 224
  ho_dimentions_line_spacing(l_page->m_page_text);
#line 226
  l_page->m_page_blocks_mask = ho_segment_paragraphs((ho_bitmap const   *)l_page->m_page_text,
                                                     (unsigned char const   )l_page->type);
#line 230
  o_map_blocks = ho_objmap_new_from_bitmap((ho_bitmap const   *)l_page->m_page_blocks_mask);
#line 233
  l_page->n_blocks = (o_map_blocks->obj_list)->size;
#line 235
  ho_objmap_free(o_map_blocks);
#line 238
  tmp = malloc((unsigned long )l_page->n_blocks * sizeof(ho_bitmap *));
#line 238
  l_page->m_blocks_text = (ho_bitmap **)tmp;
  }
#line 240
  if (! l_page->m_blocks_text) {
#line 241
    return (-1);
  }
  {
#line 242
  tmp___0 = malloc((unsigned long )l_page->n_blocks * sizeof(ho_bitmap *));
#line 242
  l_page->m_blocks_lines_mask = (ho_bitmap **)tmp___0;
  }
#line 244
  if (! l_page->m_blocks_lines_mask) {
#line 245
    return (-1);
  }
  {
#line 248
  tmp___1 = malloc((unsigned long )l_page->n_blocks * sizeof(int ));
#line 248
  l_page->n_lines = (int *)tmp___1;
  }
#line 249
  if (! l_page->n_lines) {
#line 250
    return (-1);
  }
  {
#line 251
  tmp___2 = malloc((unsigned long )l_page->n_blocks * sizeof(ho_bitmap **));
#line 251
  l_page->m_lines_text = (ho_bitmap ***)tmp___2;
  }
#line 253
  if (! l_page->m_lines_text) {
#line 254
    return (-1);
  }
  {
#line 255
  tmp___3 = malloc((unsigned long )l_page->n_blocks * sizeof(ho_bitmap **));
#line 255
  l_page->m_lines_line_mask = (ho_bitmap ***)tmp___3;
  }
#line 257
  if (! l_page->m_lines_line_mask) {
#line 258
    return (-1);
  }
  {
#line 259
  tmp___4 = malloc((unsigned long )l_page->n_blocks * sizeof(ho_bitmap **));
#line 259
  l_page->m_lines_words_mask = (ho_bitmap ***)tmp___4;
  }
#line 261
  if (! l_page->m_lines_words_mask) {
#line 262
    return (-1);
  }
  {
#line 265
  tmp___5 = malloc((unsigned long )l_page->n_blocks * sizeof(int *));
#line 265
  l_page->n_words = (int **)tmp___5;
  }
#line 266
  if (! l_page->n_words) {
#line 267
    return (-1);
  }
  {
#line 268
  tmp___6 = malloc((unsigned long )l_page->n_blocks * sizeof(ho_bitmap ***));
#line 268
  l_page->m_words_text = (ho_bitmap ****)tmp___6;
  }
#line 270
  if (! l_page->m_words_text) {
#line 271
    return (-1);
  }
  {
#line 272
  tmp___7 = malloc((unsigned long )l_page->n_blocks * sizeof(ho_bitmap ***));
#line 272
  l_page->m_words_line_mask = (ho_bitmap ****)tmp___7;
  }
#line 274
  if (! l_page->m_words_line_mask) {
#line 275
    return (-1);
  }
  {
#line 276
  tmp___8 = malloc((unsigned long )l_page->n_blocks * sizeof(ho_bitmap ***));
#line 276
  l_page->m_words_font_mask = (ho_bitmap ****)tmp___8;
  }
#line 278
  if (! l_page->m_words_font_mask) {
#line 279
    return (-1);
  }
  {
#line 282
  tmp___9 = malloc((unsigned long )l_page->n_blocks * sizeof(int **));
#line 282
  l_page->n_fonts = (int ***)tmp___9;
  }
#line 283
  if (! l_page->n_fonts) {
#line 284
    return (-1);
  }
#line 287
  i = 0;
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i < l_page->n_blocks)) {
#line 287
      goto while_break;
    }
#line 289
    *(l_page->m_blocks_lines_mask + i) = (ho_bitmap *)((void *)0);
#line 290
    *(l_page->m_blocks_text + i) = (ho_bitmap *)((void *)0);
#line 292
    *(l_page->n_lines + i) = 0;
#line 293
    *(l_page->m_lines_words_mask + i) = (ho_bitmap **)((void *)0);
#line 294
    *(l_page->m_lines_text + i) = (ho_bitmap **)((void *)0);
#line 295
    *(l_page->m_lines_line_mask + i) = (ho_bitmap **)((void *)0);
#line 297
    *(l_page->n_words + i) = (int *)((void *)0);
#line 298
    *(l_page->m_words_text + i) = (ho_bitmap ***)((void *)0);
#line 299
    *(l_page->m_words_line_mask + i) = (ho_bitmap ***)((void *)0);
#line 300
    *(l_page->m_words_font_mask + i) = (ho_bitmap ***)((void *)0);
#line 302
    *(l_page->n_fonts + i) = (int **)((void *)0);
#line 287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 305
  return (0);
}
}
#line 308 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
int ho_layout_create_line_mask(ho_layout *l_page , int const   block_index ) 
{ 
  ho_bitmap *m_block_text ;
  ho_objmap *o_map_blocks ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;
  void *tmp___6 ;

  {
  {
#line 311
  m_block_text = (ho_bitmap *)((void *)0);
#line 313
  o_map_blocks = (ho_objmap *)((void *)0);
#line 317
  m_block_text = ho_layout_get_block_text((ho_layout const   *)l_page, (int )block_index);
#line 320
  ho_dimentions_font_width_height_nikud(m_block_text, (int const   )12, (int const   )350,
                                        (int const   )12, (int const   )350);
#line 322
  ho_dimentions_line_spacing(m_block_text);
#line 324
  *(l_page->m_blocks_lines_mask + block_index) = ho_segment_lines((ho_bitmap const   *)m_block_text);
#line 326
  *(l_page->m_blocks_text + block_index) = m_block_text;
#line 329
  o_map_blocks = ho_objmap_new_from_bitmap((ho_bitmap const   *)*(l_page->m_blocks_lines_mask + block_index));
#line 333
  *(l_page->n_lines + block_index) = (o_map_blocks->obj_list)->size;
#line 335
  ho_objmap_free(o_map_blocks);
#line 338
  tmp = malloc((unsigned long )*(l_page->n_lines + block_index) * sizeof(ho_bitmap *));
#line 338
  *(l_page->m_lines_text + block_index) = (ho_bitmap **)tmp;
  }
#line 340
  if (! *(l_page->m_lines_text + block_index)) {
#line 341
    return (-1);
  }
  {
#line 342
  tmp___0 = malloc((unsigned long )*(l_page->n_lines + block_index) * sizeof(ho_bitmap *));
#line 342
  *(l_page->m_lines_line_mask + block_index) = (ho_bitmap **)tmp___0;
  }
#line 344
  if (! *(l_page->m_lines_line_mask + block_index)) {
#line 345
    return (-1);
  }
  {
#line 346
  tmp___1 = malloc((unsigned long )*(l_page->n_lines + block_index) * sizeof(ho_bitmap *));
#line 346
  *(l_page->m_lines_words_mask + block_index) = (ho_bitmap **)tmp___1;
  }
#line 348
  if (! *(l_page->m_lines_words_mask + block_index)) {
#line 349
    return (-1);
  }
  {
#line 352
  tmp___2 = malloc((unsigned long )*(l_page->n_lines + block_index) * sizeof(int ));
#line 352
  *(l_page->n_words + block_index) = (int *)tmp___2;
  }
#line 354
  if (! *(l_page->n_words + block_index)) {
#line 355
    return (-1);
  }
  {
#line 356
  tmp___3 = malloc((unsigned long )*(l_page->n_lines + block_index) * sizeof(ho_bitmap **));
#line 356
  *(l_page->m_words_text + block_index) = (ho_bitmap ***)tmp___3;
  }
#line 359
  if (! *(l_page->m_words_text + block_index)) {
#line 360
    return (-1);
  }
  {
#line 361
  tmp___4 = malloc((unsigned long )*(l_page->n_lines + block_index) * sizeof(ho_bitmap **));
#line 361
  *(l_page->m_words_line_mask + block_index) = (ho_bitmap ***)tmp___4;
  }
#line 364
  if (! *(l_page->m_words_line_mask + block_index)) {
#line 365
    return (-1);
  }
  {
#line 366
  tmp___5 = malloc((unsigned long )*(l_page->n_lines + block_index) * sizeof(ho_bitmap **));
#line 366
  *(l_page->m_words_font_mask + block_index) = (ho_bitmap ***)tmp___5;
  }
#line 369
  if (! *(l_page->m_words_font_mask + block_index)) {
#line 370
    return (-1);
  }
  {
#line 373
  tmp___6 = malloc((unsigned long )*(l_page->n_lines + block_index) * sizeof(int *));
#line 373
  *(l_page->n_fonts + block_index) = (int **)tmp___6;
  }
#line 375
  if (! l_page->n_fonts) {
#line 376
    return (-1);
  }
#line 379
  i = 0;
  {
#line 379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 379
    if (! (i < *(l_page->n_lines + block_index))) {
#line 379
      goto while_break;
    }
#line 381
    *(*(l_page->m_lines_words_mask + block_index) + i) = (ho_bitmap *)((void *)0);
#line 382
    *(*(l_page->m_lines_text + block_index) + i) = (ho_bitmap *)((void *)0);
#line 383
    *(*(l_page->m_lines_line_mask + block_index) + i) = (ho_bitmap *)((void *)0);
#line 385
    *(*(l_page->n_words + block_index) + i) = 0;
#line 386
    *(*(l_page->m_words_text + block_index) + i) = (ho_bitmap **)((void *)0);
#line 387
    *(*(l_page->m_words_line_mask + block_index) + i) = (ho_bitmap **)((void *)0);
#line 388
    *(*(l_page->m_words_font_mask + block_index) + i) = (ho_bitmap **)((void *)0);
#line 390
    *(*(l_page->n_fonts + block_index) + i) = (int *)((void *)0);
#line 379
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 393
  return (0);
}
}
#line 396 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
int ho_layout_create_word_mask(ho_layout *l_page , int const   block_index , int const   line_index ) 
{ 
  ho_objmap *o_map_blocks ;
  ho_bitmap *m_line_text ;
  ho_bitmap *m_line_line_mask ;
  int i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;

  {
  {
#line 400
  o_map_blocks = (ho_objmap *)((void *)0);
#line 401
  m_line_text = (ho_bitmap *)((void *)0);
#line 402
  m_line_line_mask = (ho_bitmap *)((void *)0);
#line 406
  m_line_text = ho_layout_get_line_text((ho_layout const   *)l_page, (int )block_index,
                                        (int )line_index);
  }
#line 407
  if (! m_line_text) {
#line 408
    return (-1);
  }
  {
#line 410
  ho_dimentions_font_width_height_nikud(m_line_text, (int const   )12, (int const   )350,
                                        (int const   )12, (int const   )350);
#line 411
  *(*(l_page->m_lines_text + block_index) + line_index) = m_line_text;
#line 414
  m_line_line_mask = ho_layout_get_line_line_mask((ho_layout const   *)l_page, (int )block_index,
                                                  (int )line_index);
  }
#line 416
  if (! m_line_line_mask) {
#line 417
    return (-1);
  }
  {
#line 419
  *(*(l_page->m_lines_line_mask + block_index) + line_index) = m_line_line_mask;
#line 421
  m_line_text->line_spacing = (*(l_page->m_blocks_text + block_index))->line_spacing;
#line 422
  ho_dimentions_font_spacing(m_line_text, (ho_bitmap const   *)m_line_line_mask);
#line 424
  ho_dimentions_line_fill(m_line_text, (ho_bitmap const   *)m_line_line_mask);
#line 426
  *(*(l_page->m_lines_words_mask + block_index) + line_index) = ho_segment_words((ho_bitmap const   *)m_line_text,
                                                                                 (ho_bitmap const   *)m_line_line_mask,
                                                                                 (char const   )l_page->font_spacing_code);
#line 430
  o_map_blocks = ho_objmap_new_from_bitmap((ho_bitmap const   *)*(*(l_page->m_lines_words_mask + block_index) + line_index));
#line 435
  *(*(l_page->n_words + block_index) + line_index) = (o_map_blocks->obj_list)->size;
#line 437
  ho_objmap_free(o_map_blocks);
#line 440
  tmp = malloc((unsigned long )*(*(l_page->n_words + block_index) + line_index) * sizeof(ho_bitmap *));
#line 440
  *(*(l_page->m_words_text + block_index) + line_index) = (ho_bitmap **)tmp;
  }
#line 443
  if (! *(*(l_page->m_words_text + block_index) + line_index)) {
#line 444
    return (-1);
  }
  {
#line 445
  tmp___0 = malloc((unsigned long )*(*(l_page->n_words + block_index) + line_index) * sizeof(ho_bitmap *));
#line 445
  *(*(l_page->m_words_line_mask + block_index) + line_index) = (ho_bitmap **)tmp___0;
  }
#line 448
  if (! *(*(l_page->m_words_line_mask + block_index) + line_index)) {
#line 449
    return (-1);
  }
  {
#line 450
  tmp___1 = malloc((unsigned long )*(*(l_page->n_words + block_index) + line_index) * sizeof(ho_bitmap *));
#line 450
  *(*(l_page->m_words_font_mask + block_index) + line_index) = (ho_bitmap **)tmp___1;
  }
#line 453
  if (! *(*(l_page->m_words_font_mask + block_index) + line_index)) {
#line 454
    return (-1);
  }
  {
#line 457
  tmp___2 = malloc((unsigned long )*(*(l_page->n_words + block_index) + line_index) * sizeof(int ));
#line 457
  *(*(l_page->n_fonts + block_index) + line_index) = (int *)tmp___2;
  }
#line 459
  if (! l_page->n_fonts) {
#line 460
    return (-1);
  }
#line 463
  i = 0;
  {
#line 463
  while (1) {
    while_continue: /* CIL Label */ ;
#line 463
    if (! (i < *(*(l_page->n_words + block_index) + line_index))) {
#line 463
      goto while_break;
    }
#line 465
    *(*(*(l_page->m_words_text + block_index) + line_index) + i) = (ho_bitmap *)((void *)0);
#line 466
    *(*(*(l_page->m_words_line_mask + block_index) + line_index) + i) = (ho_bitmap *)((void *)0);
#line 467
    *(*(*(l_page->m_words_font_mask + block_index) + line_index) + i) = (ho_bitmap *)((void *)0);
#line 469
    *(*(*(l_page->n_fonts + block_index) + line_index) + i) = 0;
#line 463
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 472
  return (0);
}
}
#line 475 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
int ho_layout_create_font_mask(ho_layout *l_page , int const   block_index , int const   line_index ,
                               int const   word_index , unsigned char const   slicing_threshold ,
                               unsigned char const   slicing_width , unsigned char const   line_leeway ) 
{ 
  ho_bitmap *m_word_text ;
  ho_bitmap *m_word_line_mask ;
  ho_bitmap *m_word_font_mask ;
  int x ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 482
  m_word_text = (ho_bitmap *)((void *)0);
#line 483
  m_word_line_mask = (ho_bitmap *)((void *)0);
#line 484
  m_word_font_mask = (ho_bitmap *)((void *)0);
#line 488
  m_word_text = ho_layout_get_word_text((ho_layout const   *)l_page, (int )block_index,
                                        (int )line_index, (int )word_index);
#line 491
  *(*(*(l_page->m_words_text + block_index) + line_index) + word_index) = m_word_text;
#line 494
  m_word_line_mask = ho_layout_get_word_line_mask((ho_layout const   *)l_page, (int )block_index,
                                                  (int )line_index, (int )word_index);
#line 496
  *(*(*(l_page->m_words_line_mask + block_index) + line_index) + word_index) = m_word_line_mask;
#line 502
  m_word_text->font_width = (*(l_page->m_blocks_text + block_index))->font_width;
#line 504
  m_word_font_mask = ho_segment_fonts((ho_bitmap const   *)m_word_text, (ho_bitmap const   *)m_word_line_mask,
                                      slicing_threshold, slicing_width, line_leeway);
#line 508
  *(*(*(l_page->m_words_font_mask + block_index) + line_index) + word_index) = m_word_font_mask;
#line 512
  i = 0;
#line 513
  x = 0;
  }
  {
#line 514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 514
    if (! (x < m_word_font_mask->width)) {
#line 514
      goto while_break;
    }
    {
#line 517
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 517
      if (x < m_word_font_mask->width) {
#line 517
        if (((int )*(m_word_font_mask->data + (x / 8 + 2 * m_word_font_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 517
          tmp = 1;
        } else {
#line 517
          tmp = 0;
        }
#line 517
        if (! tmp) {
#line 517
          goto while_break___0;
        }
      } else {
#line 517
        goto while_break___0;
      }
#line 517
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 520
    i ++;
    {
#line 521
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 521
      if (x < m_word_font_mask->width) {
#line 521
        if (((int )*(m_word_font_mask->data + (x / 8 + 2 * m_word_font_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 521
          tmp___0 = 1;
        } else {
#line 521
          tmp___0 = 0;
        }
#line 521
        if (tmp___0) {
#line 521
          goto while_break___1;
        }
      } else {
#line 521
        goto while_break___1;
      }
#line 521
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 527
  *(*(*(l_page->n_fonts + block_index) + line_index) + word_index) = i;
#line 531
  l_page->number_of_fonts += i;
#line 533
  return (0);
}
}
#line 536 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
ho_bitmap *ho_layout_get_block_text(ho_layout const   *l_page , int block_index ) 
{ 
  ho_bitmap *m_block_text ;
  ho_bitmap *m_temp ;
  ho_objmap *o_map_blocks ;
  int x ;
  int y ;
  int height ;
  int width ;

  {
  {
#line 539
  m_block_text = (ho_bitmap *)((void *)0);
#line 540
  m_temp = (ho_bitmap *)((void *)0);
#line 541
  o_map_blocks = (ho_objmap *)((void *)0);
#line 545
  o_map_blocks = ho_objmap_new_from_bitmap((ho_bitmap const   *)l_page->m_page_blocks_mask);
#line 548
  ho_objmap_sort_by_reading_index(o_map_blocks, l_page->type, l_page->dir);
#line 550
  x = ((o_map_blocks->obj_list)->objects + block_index)->x;
#line 551
  y = ((o_map_blocks->obj_list)->objects + block_index)->y;
#line 552
  width = ((o_map_blocks->obj_list)->objects + block_index)->width;
#line 553
  height = ((o_map_blocks->obj_list)->objects + block_index)->height;
#line 556
  x -= (l_page->m_page_text)->font_width;
#line 557
  y -= (l_page->m_page_text)->font_height;
#line 558
  width += 2 * (l_page->m_page_text)->font_width;
#line 559
  height += 2 * (l_page->m_page_text)->font_height;
  }
#line 562
  if (x < 0) {
#line 563
    x = 0;
  }
#line 564
  if (x + width > (l_page->m_page_text)->width) {
#line 565
    width = (l_page->m_page_text)->width - x;
  }
#line 566
  if (y < 0) {
#line 567
    y = 0;
  }
#line 568
  if (y + height > (l_page->m_page_text)->height) {
#line 569
    height = (l_page->m_page_text)->height - y;
  }
#line 571
  if (l_page->type) {
    {
#line 573
    m_block_text = ho_bitmap_clone_window((ho_bitmap const   *)l_page->m_page_text,
                                          (int const   )x, (int const   )y, (int const   )width,
                                          (int const   )height);
    }
  } else {
    {
#line 578
    m_temp = ho_objmap_to_bitmap_by_index((ho_objmap const   *)o_map_blocks, (int const   )block_index);
#line 579
    ho_bitmap_and(m_temp, (ho_bitmap const   *)l_page->m_page_text);
#line 580
    m_block_text = ho_bitmap_clone_window((ho_bitmap const   *)m_temp, (int const   )x,
                                          (int const   )y, (int const   )width, (int const   )height);
#line 581
    ho_bitmap_free(m_temp);
    }
  }
  {
#line 584
  ho_objmap_free(o_map_blocks);
  }
#line 586
  return (m_block_text);
}
}
#line 589 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
ho_bitmap *ho_layout_get_line_text(ho_layout const   *l_page , int block_index , int line_index ) 
{ 
  ho_bitmap *m_line_text ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_temp2 ;
  ho_objmap *o_map_lines ;
  int x ;
  int y ;
  int height ;
  int width ;
  double vertical_leeway ;

  {
  {
#line 592
  m_line_text = (ho_bitmap *)((void *)0);
#line 593
  m_temp = (ho_bitmap *)((void *)0);
#line 594
  m_temp2 = (ho_bitmap *)((void *)0);
#line 595
  o_map_lines = (ho_objmap *)((void *)0);
#line 597
  vertical_leeway = 0.8;
#line 600
  o_map_lines = ho_objmap_new_from_bitmap((ho_bitmap const   *)*(l_page->m_blocks_lines_mask + block_index));
#line 604
  ho_objmap_sort_by_reading_index(o_map_lines, (unsigned char const   )1, l_page->dir);
#line 606
  x = ((o_map_lines->obj_list)->objects + line_index)->x;
#line 607
  y = ((o_map_lines->obj_list)->objects + line_index)->y;
#line 608
  width = ((o_map_lines->obj_list)->objects + line_index)->width;
#line 609
  height = ((o_map_lines->obj_list)->objects + line_index)->height;
#line 612
  x -= (*(l_page->m_blocks_text + block_index))->font_width;
#line 613
  y -= (int )(vertical_leeway * (double )height);
#line 614
  width += 2 * (*(l_page->m_blocks_text + block_index))->font_width;
#line 615
  height += 2 * (int )(vertical_leeway * (double )height);
  }
#line 618
  if (x < 0) {
#line 619
    x = 0;
  }
#line 620
  if (y < 0) {
#line 621
    y = 0;
  }
#line 622
  if (x + width > (*(l_page->m_blocks_text + block_index))->width) {
#line 623
    width = (*(l_page->m_blocks_text + block_index))->width - x;
  }
#line 624
  if (y < 0) {
#line 625
    y = 0;
  }
#line 626
  if (y + height > (*(l_page->m_blocks_text + block_index))->height) {
#line 627
    height = (*(l_page->m_blocks_text + block_index))->height - y;
  }
  {
#line 629
  m_temp = ho_objmap_to_bitmap_by_index((ho_objmap const   *)o_map_lines, (int const   )line_index);
#line 630
  m_temp2 = ho_bitmap_set_height((ho_bitmap const   *)m_temp, (int const   )((4 * (*(l_page->m_blocks_text + block_index))->font_height) / 3),
                                 (int const   )((2 * (*(l_page->m_blocks_text + block_index))->font_height) / 3),
                                 (int const   )((2 * (*(l_page->m_blocks_text + block_index))->font_height) / 3));
#line 635
  ho_bitmap_free(m_temp);
#line 637
  ho_objmap_free(o_map_lines);
#line 638
  ho_bitmap_and(m_temp2, (ho_bitmap const   *)*(l_page->m_blocks_text + block_index));
#line 640
  m_line_text = ho_bitmap_clone_window((ho_bitmap const   *)m_temp2, (int const   )x,
                                       (int const   )y, (int const   )width, (int const   )height);
#line 642
  ho_bitmap_free(m_temp2);
  }
#line 644
  return (m_line_text);
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
ho_bitmap *ho_layout_get_line_line_mask(ho_layout const   *l_page , int block_index ,
                                        int line_index ) 
{ 
  ho_bitmap *m_line_mask ;
  ho_bitmap *m_temp ;
  ho_objmap *o_map_lines ;
  int x ;
  int y ;
  int height ;
  int width ;
  double vertical_leeway ;

  {
  {
#line 651
  m_line_mask = (ho_bitmap *)((void *)0);
#line 652
  m_temp = (ho_bitmap *)((void *)0);
#line 653
  o_map_lines = (ho_objmap *)((void *)0);
#line 655
  vertical_leeway = 0.8;
#line 658
  o_map_lines = ho_objmap_new_from_bitmap((ho_bitmap const   *)*(l_page->m_blocks_lines_mask + block_index));
#line 662
  ho_objmap_sort_by_reading_index(o_map_lines, (unsigned char const   )1, l_page->dir);
#line 664
  x = ((o_map_lines->obj_list)->objects + line_index)->x;
#line 665
  y = ((o_map_lines->obj_list)->objects + line_index)->y;
#line 666
  width = ((o_map_lines->obj_list)->objects + line_index)->width;
#line 667
  height = ((o_map_lines->obj_list)->objects + line_index)->height;
#line 670
  x -= (*(l_page->m_blocks_text + block_index))->font_width;
#line 671
  y -= (int )(vertical_leeway * (double )height);
#line 672
  width += 2 * (*(l_page->m_blocks_text + block_index))->font_width;
#line 673
  height += 2 * (int )(vertical_leeway * (double )height);
  }
#line 676
  if (x < 0) {
#line 677
    x = 0;
  }
#line 678
  if (y < 0) {
#line 679
    y = 0;
  }
#line 680
  if (x + width > (*(l_page->m_blocks_text + block_index))->width) {
#line 681
    width = (*(l_page->m_blocks_text + block_index))->width - x;
  }
#line 682
  if (y + height > (*(l_page->m_blocks_text + block_index))->height) {
#line 683
    height = (*(l_page->m_blocks_text + block_index))->height - y;
  }
  {
#line 685
  m_temp = ho_objmap_to_bitmap_by_index((ho_objmap const   *)o_map_lines, (int const   )line_index);
#line 687
  ho_objmap_free(o_map_lines);
#line 689
  m_line_mask = ho_bitmap_clone_window((ho_bitmap const   *)m_temp, (int const   )x,
                                       (int const   )y, (int const   )width, (int const   )height);
#line 690
  ho_bitmap_free(m_temp);
  }
#line 692
  return (m_line_mask);
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
ho_bitmap *ho_layout_get_word_text(ho_layout const   *l_page , int block_index , int line_index ,
                                   int word_index ) 
{ 
  ho_bitmap *m_word_text ;
  ho_bitmap *m_line_text ;
  ho_objmap *o_map_words ;
  int x ;
  int y ;
  int width ;
  int height ;
  int x_start ;
  int y_start ;

  {
  {
#line 699
  m_word_text = (ho_bitmap *)((void *)0);
#line 700
  m_line_text = (ho_bitmap *)((void *)0);
#line 701
  o_map_words = (ho_objmap *)((void *)0);
#line 706
  o_map_words = ho_objmap_new_from_bitmap((ho_bitmap const   *)*(*(l_page->m_lines_words_mask + block_index) + line_index));
#line 709
  x_start = (*(*(l_page->m_lines_words_mask + block_index) + line_index))->x;
#line 710
  y_start = (*(*(l_page->m_lines_words_mask + block_index) + line_index))->y;
#line 713
  ho_objmap_sort_by_reading_index(o_map_words, (unsigned char const   )253, l_page->dir);
#line 715
  x = ((o_map_words->obj_list)->objects + word_index)->x + x_start;
#line 716
  y = ((o_map_words->obj_list)->objects + word_index)->y + y_start;
#line 717
  width = ((o_map_words->obj_list)->objects + word_index)->width;
#line 718
  height = ((o_map_words->obj_list)->objects + word_index)->height;
#line 719
  ho_objmap_free(o_map_words);
#line 721
  m_line_text = *(*(l_page->m_lines_text + block_index) + line_index);
#line 722
  m_word_text = ho_bitmap_clone_window((ho_bitmap const   *)l_page->m_page_text, (int const   )x,
                                       (int const   )y, (int const   )width, (int const   )height);
#line 726
  m_word_text->avg_line_fill = m_line_text->avg_line_fill;
#line 727
  m_word_text->com_line_fill = m_line_text->com_line_fill;
#line 728
  m_word_text->font_height = m_line_text->font_height;
#line 729
  m_word_text->font_width = m_line_text->font_width;
#line 730
  m_word_text->font_spacing = m_line_text->font_spacing;
#line 731
  m_word_text->line_spacing = m_line_text->line_spacing;
  }
#line 733
  return (m_word_text);
}
}
#line 736 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
ho_bitmap *ho_layout_get_word_line_mask(ho_layout const   *l_page , int block_index ,
                                        int line_index , int word_index ) 
{ 
  ho_bitmap *m_word_line_mask ;
  ho_bitmap *m_line_mask ;
  ho_objmap *o_map_words ;
  int x ;
  int y ;
  int width ;
  int height ;
  int x_start ;
  int y_start ;

  {
  {
#line 740
  m_word_line_mask = (ho_bitmap *)((void *)0);
#line 741
  m_line_mask = (ho_bitmap *)((void *)0);
#line 742
  o_map_words = (ho_objmap *)((void *)0);
#line 747
  o_map_words = ho_objmap_new_from_bitmap((ho_bitmap const   *)*(*(l_page->m_lines_words_mask + block_index) + line_index));
#line 750
  x_start = (*(*(l_page->m_lines_words_mask + block_index) + line_index))->x;
#line 751
  y_start = (*(*(l_page->m_lines_words_mask + block_index) + line_index))->y;
#line 754
  ho_objmap_sort_by_reading_index(o_map_words, (unsigned char const   )253, l_page->dir);
#line 756
  x = ((o_map_words->obj_list)->objects + word_index)->x;
#line 757
  y = ((o_map_words->obj_list)->objects + word_index)->y;
#line 758
  width = ((o_map_words->obj_list)->objects + word_index)->width;
#line 759
  height = ((o_map_words->obj_list)->objects + word_index)->height;
#line 760
  ho_objmap_free(o_map_words);
#line 762
  m_line_mask = *(*(l_page->m_lines_line_mask + block_index) + line_index);
#line 763
  m_word_line_mask = ho_bitmap_clone_window((ho_bitmap const   *)m_line_mask, (int const   )x,
                                            (int const   )y, (int const   )width,
                                            (int const   )height);
  }
#line 765
  return (m_word_line_mask);
}
}
#line 768 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
ho_bitmap *ho_layout_get_font_text(ho_layout const   *l_page , int block_index , int line_index ,
                                   int word_index , int font_index ) 
{ 
  ho_bitmap *m_font_text ;
  ho_bitmap *m_word_text ;
  ho_bitmap *m_word_font_mask ;
  int x ;
  int y ;
  int width ;
  int height ;
  int x_start ;
  int x_end ;
  int i ;
  int index___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 772
  m_font_text = (ho_bitmap *)((void *)0);
#line 773
  m_word_text = (ho_bitmap *)((void *)0);
#line 774
  m_word_font_mask = (ho_bitmap *)((void *)0);
#line 781
  if (l_page->dir) {
#line 783
    index___0 = (*(*(*(l_page->n_fonts + block_index) + line_index) + word_index) - font_index) - 1;
  } else {
#line 787
    index___0 = font_index;
  }
#line 789
  m_word_text = *(*(*(l_page->m_words_text + block_index) + line_index) + word_index);
#line 790
  m_word_font_mask = *(*(*(l_page->m_words_font_mask + block_index) + line_index) + word_index);
#line 795
  i = -1;
#line 796
  x = m_word_font_mask->width - 1;
  {
#line 797
  while (1) {
    while_continue: /* CIL Label */ ;
#line 797
    if (x >= 0) {
#line 797
      if (! (i < index___0)) {
#line 797
        goto while_break;
      }
    } else {
#line 797
      goto while_break;
    }
    {
#line 800
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 800
      if (x >= 0) {
#line 800
        if (((int )*(m_word_font_mask->data + (x / 8 + 2 * m_word_font_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 800
          tmp = 1;
        } else {
#line 800
          tmp = 0;
        }
#line 800
        if (! tmp) {
#line 800
          goto while_break___0;
        }
      } else {
#line 800
        goto while_break___0;
      }
#line 800
      x --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 801
    x_end = x + 1;
#line 802
    i ++;
    {
#line 803
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 803
      if (x >= 0) {
#line 803
        if (((int )*(m_word_font_mask->data + (x / 8 + 2 * m_word_font_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 803
          tmp___0 = 1;
        } else {
#line 803
          tmp___0 = 0;
        }
#line 803
        if (tmp___0) {
#line 803
          goto while_break___1;
        }
      } else {
#line 803
        goto while_break___1;
      }
#line 803
      x --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 804
    x_start = x;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 808
  y = m_word_text->y;
#line 809
  x = m_word_text->x + x_start;
#line 810
  height = m_word_text->height;
#line 811
  width = (x_end - x_start) + 1;
#line 813
  m_font_text = ho_bitmap_clone_window((ho_bitmap const   *)l_page->m_page_text, (int const   )x,
                                       (int const   )y, (int const   )width, (int const   )height);
#line 817
  m_font_text->avg_line_fill = m_word_text->avg_line_fill;
#line 818
  m_font_text->com_line_fill = m_word_text->com_line_fill;
#line 819
  m_font_text->font_height = m_word_text->font_height;
#line 820
  m_font_text->font_width = m_word_text->font_width;
#line 821
  m_font_text->font_spacing = m_word_text->font_spacing;
#line 822
  m_font_text->line_spacing = m_word_text->line_spacing;
  }
#line 824
  return (m_font_text);
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_layout.c"
ho_bitmap *ho_layout_get_font_line_mask(ho_layout const   *l_page , int block_index ,
                                        int line_index , int word_index , int font_index ) 
{ 
  ho_bitmap *m_font_line_mask ;
  ho_bitmap *m_word_line_mask ;
  ho_bitmap *m_word_font_mask ;
  int x ;
  int width ;
  int height ;
  int x_start ;
  int x_end ;
  int i ;
  int index___0 ;
  int tmp ;
  int tmp___0 ;

  {
#line 831
  m_font_line_mask = (ho_bitmap *)((void *)0);
#line 832
  m_word_line_mask = (ho_bitmap *)((void *)0);
#line 833
  m_word_font_mask = (ho_bitmap *)((void *)0);
#line 840
  if (l_page->dir) {
#line 842
    index___0 = (*(*(*(l_page->n_fonts + block_index) + line_index) + word_index) - font_index) - 1;
  } else {
#line 846
    index___0 = font_index;
  }
#line 848
  m_word_line_mask = *(*(*(l_page->m_words_line_mask + block_index) + line_index) + word_index);
#line 850
  m_word_font_mask = *(*(*(l_page->m_words_font_mask + block_index) + line_index) + word_index);
#line 855
  i = -1;
#line 856
  x = m_word_font_mask->width - 1;
  {
#line 857
  while (1) {
    while_continue: /* CIL Label */ ;
#line 857
    if (x >= 0) {
#line 857
      if (! (i < index___0)) {
#line 857
        goto while_break;
      }
    } else {
#line 857
      goto while_break;
    }
    {
#line 860
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 860
      if (x >= 0) {
#line 860
        if (((int )*(m_word_font_mask->data + (x / 8 + 2 * m_word_font_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 860
          tmp = 1;
        } else {
#line 860
          tmp = 0;
        }
#line 860
        if (! tmp) {
#line 860
          goto while_break___0;
        }
      } else {
#line 860
        goto while_break___0;
      }
#line 860
      x --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 861
    x_end = x + 1;
#line 862
    i ++;
    {
#line 863
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 863
      if (x >= 0) {
#line 863
        if (((int )*(m_word_font_mask->data + (x / 8 + 2 * m_word_font_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 863
          tmp___0 = 1;
        } else {
#line 863
          tmp___0 = 0;
        }
#line 863
        if (tmp___0) {
#line 863
          goto while_break___1;
        }
      } else {
#line 863
        goto while_break___1;
      }
#line 863
      x --;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 864
    x_start = x;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 868
  height = m_word_line_mask->height;
#line 869
  width = (x_end - x_start) + 1;
#line 871
  m_font_line_mask = ho_bitmap_clone_window((ho_bitmap const   *)m_word_line_mask,
                                            (int const   )x_start, (int const   )0,
                                            (int const   )width, (int const   )height);
  }
#line 874
  return (m_font_line_mask);
}
}
#line 237 "/usr/include/stdio.h"
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 715
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 63 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) cos)(double __x ) ;
#line 65
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sin)(double __x ) ;
#line 124 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.h"
int ho_bitmap_or(ho_bitmap *m_left , ho_bitmap const   *m_right ) ;
#line 133
int ho_bitmap_xor(ho_bitmap *m_left , ho_bitmap const   *m_right ) ;
#line 151
int ho_bitmap_copy(ho_bitmap *m_left , ho_bitmap const   *m_right ) ;
#line 159
ho_bitmap *ho_bitmap_not(ho_bitmap const   *m ) ;
#line 168
ho_bitmap *ho_bitmap_dilation_n(ho_bitmap const   *m , unsigned char const   n ) ;
#line 177
ho_bitmap *ho_bitmap_erosion_n(ho_bitmap const   *m , unsigned char const   n ) ;
#line 200
ho_bitmap *ho_bitmap_set_height_from_bottom(ho_bitmap const   *m , int const   height ,
                                            int const   top , int const   bottom ) ;
#line 209
ho_bitmap *ho_bitmap_dilation(ho_bitmap const   *m ) ;
#line 217
ho_bitmap *ho_bitmap_erosion(ho_bitmap const   *m ) ;
#line 225
ho_bitmap *ho_bitmap_opening(ho_bitmap const   *m ) ;
#line 233
ho_bitmap *ho_bitmap_closing(ho_bitmap const   *m ) ;
#line 251
ho_bitmap *ho_bitmap_herode(ho_bitmap const   *m , int const   size ) ;
#line 269
ho_bitmap *ho_bitmap_edge(ho_bitmap const   *m , int const   n ) ;
#line 281
double ho_bitmap_get_fill(ho_bitmap const   *m , int const   x , int const   y , int const   width ,
                          int const   height ) ;
#line 293
ho_bitmap *ho_bitmap_filter_hlink(ho_bitmap *m , int size , int max_height ) ;
#line 316
ho_bitmap *ho_bitmap_filter_boxes(ho_bitmap const   *m , int const   leeway_down ,
                                  int const   leeway_up ) ;
#line 325
ho_bitmap *ho_bitmap_filter_fill(ho_bitmap const   *m ) ;
#line 336
ho_bitmap *ho_bitmap_filter_set_height(ho_bitmap const   *m , int const   height ,
                                       int const   top , int const   bottom ) ;
#line 348
ho_bitmap *ho_bitmap_filter_set_height_from_bottom(ho_bitmap const   *m , int const   height ,
                                                   int const   top , int const   bottom ) ;
#line 358
ho_bitmap *ho_bitmap_filter_obj_extend_lateraly(ho_bitmap const   *m , int const   ext_width ) ;
#line 369
ho_bitmap *ho_bitmap_filter_remove_dots(ho_bitmap const   *m , unsigned char const   erosion_n ,
                                        unsigned char const   dilation_n ) ;
#line 390
int ho_bitmap_draw_box(ho_bitmap *m , int const   x , int const   y , int const   width ,
                       int const   height ) ;
#line 404
int ho_bitmap_draw_box_empty(ho_bitmap *m , int const   x , int const   y , int const   width ,
                             int const   height ) ;
#line 417
int ho_bitmap_draw_vline(ho_bitmap *m , int const   x , int const   y , int const   height ) ;
#line 430
int ho_bitmap_delete_vline(ho_bitmap *m , int const   x , int const   y , int const   height ) ;
#line 443
int ho_bitmap_draw_hline(ho_bitmap *m , int const   x , int const   y , int const   width ) ;
#line 455
int ho_bitmap_delete_hline(ho_bitmap *m , int const   x , int const   y , int const   width ) ;
#line 466
ho_bitmap *ho_bitmap_rotate(ho_bitmap const   *m , double const   angle ) ;
#line 476
int ho_bitmap_pnm_save(ho_bitmap const   *m , char const   *filename ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_new(int const   width , int const   height ) 
{ 
  ho_bitmap *m_new ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 50
  m_new = (ho_bitmap *)((void *)0);
#line 55
  tmp = malloc(sizeof(ho_bitmap ));
#line 55
  m_new = (ho_bitmap *)tmp;
  }
#line 56
  if (! m_new) {
#line 58
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 64
  m_new->x = 0;
#line 65
  m_new->y = 0;
#line 66
  m_new->width = (int )width;
#line 67
  m_new->height = (int )height;
#line 68
  m_new->rowstride = (int )((width - 1) / 8 + 1);
#line 70
  m_new->type = (unsigned char)0;
#line 71
  m_new->font_height = 0;
#line 72
  m_new->font_width = 0;
#line 73
  m_new->line_spacing = 0;
#line 74
  m_new->font_spacing = 0;
#line 75
  m_new->avg_line_fill = 0;
#line 76
  m_new->com_line_fill = 0;
#line 77
  m_new->nikud = (unsigned char)0;
#line 82
  tmp___0 = calloc((size_t )(m_new->height * m_new->rowstride), sizeof(unsigned char ));
#line 82
  m_new->data = (unsigned char *)tmp___0;
  }
#line 84
  if (! m_new->data) {
    {
#line 86
    free((void *)m_new);
    }
#line 87
    return ((ho_bitmap *)((void *)0));
  }
#line 90
  return (m_new);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_free(ho_bitmap *m ) 
{ 


  {
#line 96
  if (! m) {
#line 97
    return (-1);
  }
#line 99
  if (m->data) {
    {
#line 100
    free((void *)m->data);
    }
  }
  {
#line 102
  free((void *)m);
  }
#line 104
  return (0);
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_clone(ho_bitmap const   *m ) 
{ 
  ho_bitmap *m_out ;

  {
  {
#line 115
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 116
  if (! m_out) {
#line 117
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 118
  m_out->x = (int )m->x;
#line 119
  m_out->y = (int )m->y;
#line 121
  m_out->type = (unsigned char )m->type;
#line 122
  m_out->font_height = (int )m->font_height;
#line 123
  m_out->font_width = (int )m->font_width;
#line 124
  m_out->font_spacing = (int )m->font_spacing;
#line 125
  m_out->line_spacing = (int )m->line_spacing;
#line 126
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 127
  m_out->com_line_fill = (int )m->com_line_fill;
#line 128
  m_out->nikud = (unsigned char )m->nikud;
#line 133
  memcpy((void */* __restrict  */)m_out->data, (void const   */* __restrict  */)m->data,
         (size_t )(m_out->height * m_out->rowstride));
  }
#line 135
  return (m_out);
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_clone_window(ho_bitmap const   *m , int const   x , int const   y ,
                                  int const   width , int const   height ) 
{ 
  ho_bitmap *m_out ;
  int x1 ;
  int y1___0 ;
  int tmp ;

  {
  {
#line 148
  m_out = ho_bitmap_new(width, height);
  }
#line 149
  if (! m_out) {
#line 150
    return ((ho_bitmap *)((void *)0));
  }
#line 155
  m_out->x = (int )(m->x + x);
#line 156
  m_out->y = (int )(m->y + y);
#line 158
  m_out->type = (unsigned char )m->type;
#line 159
  m_out->font_height = (int )m->font_height;
#line 160
  m_out->font_width = (int )m->font_width;
#line 161
  m_out->font_spacing = (int )m->font_spacing;
#line 162
  m_out->line_spacing = (int )m->line_spacing;
#line 163
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 164
  m_out->com_line_fill = (int )m->com_line_fill;
#line 165
  m_out->nikud = (unsigned char )m->nikud;
#line 170
  x1 = 0;
  {
#line 170
  while (1) {
    while_continue: /* CIL Label */ ;
#line 170
    if (x1 < (int )width) {
#line 170
      if (! (x1 < (int )m->width)) {
#line 170
        goto while_break;
      }
    } else {
#line 170
      goto while_break;
    }
#line 171
    y1___0 = 0;
    {
#line 171
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 171
      if (y1___0 < (int )height) {
#line 171
        if (! (y1___0 < (int )m->height)) {
#line 171
          goto while_break___0;
        }
      } else {
#line 171
        goto while_break___0;
      }
#line 173
      if (x + (int const   )x1 > 0) {
#line 173
        if (y + (int const   )y1___0 > 0) {
#line 173
          if (((int )*(m->data + ((x + (int const   )x1) / 8 + (y + (int const   )y1___0) * m->rowstride)) & (128 >> (x + (int const   )x1) % 8)) > 0) {
#line 173
            tmp = 1;
          } else {
#line 173
            tmp = 0;
          }
#line 173
          if (tmp) {
#line 174
            *(m_out->data + (x1 / 8 + y1___0 * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x1 / 8 + y1___0 * m_out->rowstride)) | (128 >> x1 % 8));
          }
        }
      }
#line 171
      y1___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 170
    x1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 177
  return (m_out);
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_binop_window(ho_bitmap *m_left , ho_bitmap const   *m_right , unsigned char op ) 
{ 
  ho_bitmap *m_temp ;
  int i ;

  {
  {
#line 184
  m_temp = (ho_bitmap *)((void *)0);
#line 187
  m_temp = ho_bitmap_clone_window(m_right, m_right->x, m_right->y, m_right->width,
                                  m_right->height);
  }
#line 190
  if (! m_temp) {
#line 191
    return (-1);
  }
  {
#line 195
  if ((int )op == 0) {
#line 195
    goto case_0;
  }
#line 199
  if ((int )op == 1) {
#line 199
    goto case_1;
  }
#line 203
  if ((int )op == 2) {
#line 203
    goto case_2;
  }
#line 207
  if ((int )op == 3) {
#line 207
    goto case_3;
  }
#line 193
  goto switch_break;
  case_0: /* CIL Label */ 
#line 196
  i = 0;
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
#line 196
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 196
      goto while_break;
    }
#line 197
    *(m_left->data + i) = (unsigned char )((int )*(m_left->data + i) & (int )*(m_temp->data + i));
#line 196
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 198
  goto switch_break;
  case_1: /* CIL Label */ 
#line 200
  i = 0;
  {
#line 200
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 200
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 200
      goto while_break___0;
    }
#line 201
    *(m_left->data + i) = (unsigned char )((int )*(m_left->data + i) | (int )*(m_temp->data + i));
#line 200
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 202
  goto switch_break;
  case_2: /* CIL Label */ 
#line 204
  i = 0;
  {
#line 204
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 204
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 204
      goto while_break___1;
    }
#line 205
    *(m_left->data + i) = (unsigned char )((int )*(m_left->data + i) ^ (int )*(m_temp->data + i));
#line 204
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 206
  goto switch_break;
  case_3: /* CIL Label */ 
#line 208
  i = 0;
  {
#line 208
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 208
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 208
      goto while_break___2;
    }
#line 209
    *(m_left->data + i) = (unsigned char )((int )*(m_left->data + i) & ~ ((int )*(m_temp->data + i)));
#line 208
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 210
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 212
  ho_bitmap_free(m_temp);
  }
#line 213
  return (0);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_and(ho_bitmap *m_left , ho_bitmap const   *m_right ) 
{ 
  int i ;

  {
#line 224
  if (m_left->width != (int )m_right->width) {
#line 225
    return (-1);
  } else
#line 224
  if (m_left->height != (int )m_right->height) {
#line 225
    return (-1);
  }
#line 230
  i = 0;
  {
#line 230
  while (1) {
    while_continue: /* CIL Label */ ;
#line 230
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 230
      goto while_break;
    }
#line 231
    *(m_left->data + i) = (unsigned char )((int )*(m_left->data + i) & (int )*(m_right->data + i));
#line 230
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 233
  return (0);
}
}
#line 236 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_or(ho_bitmap *m_left , ho_bitmap const   *m_right ) 
{ 
  int i ;

  {
#line 244
  if (m_left->width != (int )m_right->width) {
#line 245
    return (-1);
  } else
#line 244
  if (m_left->height != (int )m_right->height) {
#line 245
    return (-1);
  }
#line 250
  i = 0;
  {
#line 250
  while (1) {
    while_continue: /* CIL Label */ ;
#line 250
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 250
      goto while_break;
    }
#line 251
    *(m_left->data + i) = (unsigned char )((int )*(m_left->data + i) | (int )*(m_right->data + i));
#line 250
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 253
  return (0);
}
}
#line 256 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_xor(ho_bitmap *m_left , ho_bitmap const   *m_right ) 
{ 
  int i ;

  {
#line 264
  if (m_left->width != (int )m_right->width) {
#line 265
    return (-1);
  } else
#line 264
  if (m_left->height != (int )m_right->height) {
#line 265
    return (-1);
  }
#line 270
  i = 0;
  {
#line 270
  while (1) {
    while_continue: /* CIL Label */ ;
#line 270
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 270
      goto while_break;
    }
#line 271
    *(m_left->data + i) = (unsigned char )((int )*(m_left->data + i) ^ (int )*(m_right->data + i));
#line 270
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 273
  return (0);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_andnot(ho_bitmap *m_left , ho_bitmap const   *m_right ) 
{ 
  int i ;

  {
#line 284
  if (m_left->width != (int )m_right->width) {
#line 285
    return (-1);
  } else
#line 284
  if (m_left->height != (int )m_right->height) {
#line 285
    return (-1);
  }
#line 290
  i = 0;
  {
#line 290
  while (1) {
    while_continue: /* CIL Label */ ;
#line 290
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 290
      goto while_break;
    }
#line 291
    *(m_left->data + i) = (unsigned char )((int )*(m_left->data + i) & ~ ((int )*(m_right->data + i)));
#line 290
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return (0);
}
}
#line 296 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_copy(ho_bitmap *m_left , ho_bitmap const   *m_right ) 
{ 
  int i ;

  {
#line 304
  if (m_left->width != (int )m_right->width) {
#line 305
    return (-1);
  } else
#line 304
  if (m_left->height != (int )m_right->height) {
#line 305
    return (-1);
  }
#line 310
  i = 0;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! (i < (int )(m_right->height * m_right->rowstride))) {
#line 310
      goto while_break;
    }
#line 311
    *(m_left->data + i) = *(m_right->data + i);
#line 310
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 313
  return (0);
}
}
#line 316 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_not(ho_bitmap const   *m ) 
{ 
  int i ;
  ho_bitmap *m_out ;

  {
  {
#line 326
  m_out = ho_bitmap_new(m->width, m->height);
#line 331
  m_out->x = (int )m->x;
#line 332
  m_out->y = (int )m->y;
#line 334
  m_out->type = (unsigned char )m->type;
#line 335
  m_out->font_height = (int )m->font_height;
#line 336
  m_out->font_width = (int )m->font_width;
#line 337
  m_out->font_spacing = (int )m->font_spacing;
#line 338
  m_out->line_spacing = (int )m->line_spacing;
#line 339
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 340
  m_out->com_line_fill = (int )m->com_line_fill;
#line 341
  m_out->nikud = (unsigned char )m->nikud;
  }
#line 346
  if (! m_out) {
#line 347
    return ((ho_bitmap *)((void *)0));
  }
#line 352
  i = 0;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! (i < (int )(m->height * m->rowstride))) {
#line 352
      goto while_break;
    }
#line 353
    *(m_out->data + i) = (unsigned char )(~ ((int )*(m->data + i)));
#line 352
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return (m_out);
}
}
#line 358 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_dilation_n(ho_bitmap const   *m , unsigned char const   n ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  unsigned char sum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 365
  if (! m) {
#line 366
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 371
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 372
  if (! m_out) {
#line 373
    return ((ho_bitmap *)((void *)0));
  }
#line 374
  m_out->x = (int )m->x;
#line 375
  m_out->y = (int )m->y;
#line 377
  m_out->type = (unsigned char )m->type;
#line 378
  m_out->font_height = (int )m->font_height;
#line 379
  m_out->font_width = (int )m->font_width;
#line 380
  m_out->font_spacing = (int )m->font_spacing;
#line 381
  m_out->line_spacing = (int )m->line_spacing;
#line 382
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 383
  m_out->com_line_fill = (int )m->com_line_fill;
#line 384
  m_out->nikud = (unsigned char )m->nikud;
#line 389
  x = 1;
  {
#line 389
  while (1) {
    while_continue: /* CIL Label */ ;
#line 389
    if (! (x < (int )(m->width - 1))) {
#line 389
      goto while_break;
    }
#line 390
    y = 1;
    {
#line 390
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 390
      if (! (y < (int )(m->height - 1))) {
#line 390
        goto while_break___0;
      }
#line 395
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 395
        tmp___7 = 1;
      } else {
#line 395
        tmp___7 = 0;
      }
#line 395
      if (tmp___7) {
#line 408
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      } else {
#line 397
        if (((int )*(m->data + ((x - 1) / 8 + (y - 1) * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 397
          tmp = 1;
        } else {
#line 397
          tmp = 0;
        }
#line 397
        if (((int )*(m->data + ((x - 1) / 8 + y * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 397
          tmp___0 = 1;
        } else {
#line 397
          tmp___0 = 0;
        }
#line 397
        if (((int )*(m->data + ((x - 1) / 8 + (y + 1) * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 397
          tmp___1 = 1;
        } else {
#line 397
          tmp___1 = 0;
        }
#line 397
        if (((int )*(m->data + (x / 8 + (y - 1) * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 397
          tmp___2 = 1;
        } else {
#line 397
          tmp___2 = 0;
        }
#line 397
        if (((int )*(m->data + (x / 8 + (y + 1) * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 397
          tmp___3 = 1;
        } else {
#line 397
          tmp___3 = 0;
        }
#line 397
        if (((int )*(m->data + ((x + 1) / 8 + (y - 1) * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 397
          tmp___4 = 1;
        } else {
#line 397
          tmp___4 = 0;
        }
#line 397
        if (((int )*(m->data + ((x + 1) / 8 + y * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 397
          tmp___5 = 1;
        } else {
#line 397
          tmp___5 = 0;
        }
#line 397
        if (((int )*(m->data + ((x + 1) / 8 + (y + 1) * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 397
          tmp___6 = 1;
        } else {
#line 397
          tmp___6 = 0;
        }
#line 397
        sum = (unsigned char )(((((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) + tmp___4) + tmp___5) + tmp___6);
#line 404
        if ((int )sum >= (int )n) {
#line 405
          *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
        }
      }
#line 390
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 389
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 411
  return (m_out);
}
}
#line 414 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_erosion_n(ho_bitmap const   *m , unsigned char const   n ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  unsigned char sum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 421
  if (! m) {
#line 422
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 427
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 428
  if (! m_out) {
#line 429
    return ((ho_bitmap *)((void *)0));
  }
#line 430
  m_out->x = (int )m->x;
#line 431
  m_out->y = (int )m->y;
#line 433
  m_out->type = (unsigned char )m->type;
#line 434
  m_out->font_height = (int )m->font_height;
#line 435
  m_out->font_width = (int )m->font_width;
#line 436
  m_out->font_spacing = (int )m->font_spacing;
#line 437
  m_out->line_spacing = (int )m->line_spacing;
#line 438
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 439
  m_out->com_line_fill = (int )m->com_line_fill;
#line 440
  m_out->nikud = (unsigned char )m->nikud;
#line 445
  x = 1;
  {
#line 445
  while (1) {
    while_continue: /* CIL Label */ ;
#line 445
    if (! (x < (int )(m->width - 1))) {
#line 445
      goto while_break;
    }
#line 446
    y = 1;
    {
#line 446
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 446
      if (! (y < (int )(m->height - 1))) {
#line 446
        goto while_break___0;
      }
#line 451
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 451
        tmp___7 = 1;
      } else {
#line 451
        tmp___7 = 0;
      }
#line 451
      if (tmp___7) {
#line 453
        if (((int )*(m->data + ((x - 1) / 8 + (y - 1) * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 453
          tmp = 1;
        } else {
#line 453
          tmp = 0;
        }
#line 453
        if (((int )*(m->data + ((x - 1) / 8 + y * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 453
          tmp___0 = 1;
        } else {
#line 453
          tmp___0 = 0;
        }
#line 453
        if (((int )*(m->data + ((x - 1) / 8 + (y + 1) * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 453
          tmp___1 = 1;
        } else {
#line 453
          tmp___1 = 0;
        }
#line 453
        if (((int )*(m->data + (x / 8 + (y - 1) * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 453
          tmp___2 = 1;
        } else {
#line 453
          tmp___2 = 0;
        }
#line 453
        if (((int )*(m->data + (x / 8 + (y + 1) * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 453
          tmp___3 = 1;
        } else {
#line 453
          tmp___3 = 0;
        }
#line 453
        if (((int )*(m->data + ((x + 1) / 8 + (y - 1) * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 453
          tmp___4 = 1;
        } else {
#line 453
          tmp___4 = 0;
        }
#line 453
        if (((int )*(m->data + ((x + 1) / 8 + y * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 453
          tmp___5 = 1;
        } else {
#line 453
          tmp___5 = 0;
        }
#line 453
        if (((int )*(m->data + ((x + 1) / 8 + (y + 1) * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 453
          tmp___6 = 1;
        } else {
#line 453
          tmp___6 = 0;
        }
#line 453
        sum = (unsigned char )(((((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) + tmp___4) + tmp___5) + tmp___6);
#line 460
        if (8 - (int )sum < (int )n) {
#line 461
          *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
        }
      }
#line 446
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 445
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 465
  return (m_out);
}
}
#line 468 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_set_height(ho_bitmap const   *m , int const   height , int const   top ,
                                int const   bottom ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int locale_top ;
  int locale_bottom ;
  int locale_height ;
  int tmp ;

  {
  {
#line 478
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 479
  if (! m_out) {
#line 480
    return ((ho_bitmap *)((void *)0));
  }
#line 482
  m_out->x = (int )m->x;
#line 483
  m_out->y = (int )m->y;
#line 485
  m_out->type = (unsigned char )m->type;
#line 486
  m_out->font_height = (int )m->font_height;
#line 487
  m_out->font_width = (int )m->font_width;
#line 488
  m_out->font_spacing = (int )m->font_spacing;
#line 489
  m_out->line_spacing = (int )m->line_spacing;
#line 490
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 491
  m_out->com_line_fill = (int )m->com_line_fill;
#line 492
  m_out->nikud = (unsigned char )m->nikud;
#line 497
  x = 0;
  {
#line 497
  while (1) {
    while_continue: /* CIL Label */ ;
#line 497
    if (! (x < (int )m->width)) {
#line 497
      goto while_break;
    }
#line 498
    y = 0;
    {
#line 498
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 498
      if (! (y < (int )m->height)) {
#line 498
        goto while_break___0;
      }
#line 503
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 503
        tmp = 1;
      } else {
#line 503
        tmp = 0;
      }
#line 503
      if (tmp) {
#line 505
        locale_height = (int )height;
#line 506
        locale_top = (int )top;
#line 507
        locale_bottom = (int )bottom;
#line 509
        if (y - (int )top < 0) {
#line 510
          locale_top = y;
        }
#line 511
        if ((y + (int )height) + (int )bottom > (int )m->height) {
#line 513
          locale_bottom = 0;
#line 514
          locale_height = (int )((m->height - (int const   )y) - 1);
        }
        {
#line 517
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )(y - locale_top),
                             (int const   )(locale_height + locale_bottom));
#line 519
        y = (int )m->height;
        }
      }
#line 498
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 497
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 523
  return (m_out);
}
}
#line 526 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_set_height_from_bottom(ho_bitmap const   *m , int const   height ,
                                            int const   top , int const   bottom ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int locale_top ;
  int locale_bottom ;
  int locale_height ;
  int tmp ;

  {
  {
#line 536
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 537
  if (! m_out) {
#line 538
    return ((ho_bitmap *)((void *)0));
  }
#line 540
  m_out->x = (int )m->x;
#line 541
  m_out->y = (int )m->y;
#line 543
  m_out->type = (unsigned char )m->type;
#line 544
  m_out->font_height = (int )m->font_height;
#line 545
  m_out->font_width = (int )m->font_width;
#line 546
  m_out->font_spacing = (int )m->font_spacing;
#line 547
  m_out->line_spacing = (int )m->line_spacing;
#line 548
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 549
  m_out->com_line_fill = (int )m->com_line_fill;
#line 550
  m_out->nikud = (unsigned char )m->nikud;
#line 555
  x = 0;
  {
#line 555
  while (1) {
    while_continue: /* CIL Label */ ;
#line 555
    if (! (x < (int )m->width)) {
#line 555
      goto while_break;
    }
#line 556
    y = (int )(m->height - 1);
    {
#line 556
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 556
      if (! (y >= 0)) {
#line 556
        goto while_break___0;
      }
#line 561
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 561
        tmp = 1;
      } else {
#line 561
        tmp = 0;
      }
#line 561
      if (tmp) {
#line 563
        y -= (int )height;
#line 564
        locale_height = (int )height;
#line 565
        locale_top = (int )top;
#line 566
        locale_bottom = (int )bottom;
#line 568
        if (y - (int )top < 0) {
#line 569
          locale_top = y;
        }
#line 570
        if ((y + (int )height) + (int )bottom > (int )m->height) {
#line 572
          locale_bottom = 0;
#line 573
          locale_height = (int )((m->height - (int const   )y) - 1);
        }
        {
#line 576
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )(y - locale_top),
                             (int const   )(locale_height + locale_bottom));
#line 578
        y = -1;
        }
      }
#line 556
      y --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 555
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 582
  return (m_out);
}
}
#line 585 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_dilation(ho_bitmap const   *m ) 
{ 
  ho_bitmap *tmp ;

  {
#line 588
  if (! m) {
#line 589
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 591
  tmp = ho_bitmap_dilation_n(m, (unsigned char const   )1);
  }
#line 591
  return (tmp);
}
}
#line 594 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_erosion(ho_bitmap const   *m ) 
{ 
  ho_bitmap *tmp ;

  {
#line 597
  if (! m) {
#line 598
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 600
  tmp = ho_bitmap_erosion_n(m, (unsigned char const   )1);
  }
#line 600
  return (tmp);
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_opening(ho_bitmap const   *m ) 
{ 
  ho_bitmap *m_temp ;
  ho_bitmap *m_out ;

  {
#line 609
  if (! m) {
#line 610
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 612
  m_temp = ho_bitmap_erosion(m);
#line 613
  m_out = ho_bitmap_dilation((ho_bitmap const   *)m_temp);
#line 614
  ho_bitmap_free(m_temp);
  }
#line 616
  return (m_out);
}
}
#line 619 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_closing(ho_bitmap const   *m ) 
{ 
  ho_bitmap *m_temp ;
  ho_bitmap *m_out ;

  {
#line 625
  if (! m) {
#line 626
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 628
  m_temp = ho_bitmap_dilation(m);
#line 629
  m_out = ho_bitmap_erosion((ho_bitmap const   *)m_temp);
#line 630
  ho_bitmap_free(m_temp);
  }
#line 632
  return (m_out);
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_hlink(ho_bitmap const   *m , int const   size ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int k ;
  int l ;
  int last ;
  int tmp ;

  {
  {
#line 646
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 647
  if (! m_out) {
#line 648
    return ((ho_bitmap *)((void *)0));
  }
#line 649
  m_out->x = (int )m->x;
#line 650
  m_out->y = (int )m->y;
#line 652
  m_out->type = (unsigned char )m->type;
#line 653
  m_out->font_height = (int )m->font_height;
#line 654
  m_out->font_width = (int )m->font_width;
#line 655
  m_out->font_spacing = (int )m->font_spacing;
#line 656
  m_out->line_spacing = (int )m->line_spacing;
#line 657
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 658
  m_out->com_line_fill = (int )m->com_line_fill;
#line 659
  m_out->nikud = (unsigned char )m->nikud;
#line 661
  y = 0;
  {
#line 661
  while (1) {
    while_continue: /* CIL Label */ ;
#line 661
    if (! (y < (int )m->height)) {
#line 661
      goto while_break;
    }
#line 663
    last = (int )(- size);
#line 664
    x = 0;
    {
#line 664
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 664
      if (! (x < (int )m->width)) {
#line 664
        goto while_break___0;
      }
#line 666
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 666
        tmp = 1;
      } else {
#line 666
        tmp = 0;
      }
#line 666
      if (tmp) {
#line 668
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
#line 669
        l = x - last;
#line 670
        if (l > 1) {
#line 670
          if (l < (int )size) {
#line 672
            if (last < 0) {
#line 673
              last = 0;
            }
#line 674
            k = last;
            {
#line 674
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 674
              if (! (k < x)) {
#line 674
                goto while_break___1;
              }
#line 675
              *(m_out->data + (k / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (k / 8 + y * m_out->rowstride)) | (128 >> k % 8));
#line 674
              k ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 677
        last = x;
      }
#line 664
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 661
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 682
  return (m_out);
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_herode(ho_bitmap const   *m , int const   size ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int k ;
  int l ;
  int last ;
  int tmp ;

  {
  {
#line 696
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 697
  if (! m_out) {
#line 698
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 699
  m_out->x = (int )m->x;
#line 700
  m_out->y = (int )m->y;
#line 702
  m_out->type = (unsigned char )m->type;
#line 703
  m_out->font_height = (int )m->font_height;
#line 704
  m_out->font_width = (int )m->font_width;
#line 705
  m_out->font_spacing = (int )m->font_spacing;
#line 706
  m_out->line_spacing = (int )m->line_spacing;
#line 707
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 708
  m_out->com_line_fill = (int )m->com_line_fill;
#line 709
  m_out->nikud = (unsigned char )m->nikud;
#line 714
  memset((void *)m_out->data, 255, (size_t )(m_out->height * m_out->rowstride));
#line 716
  y = 0;
  }
  {
#line 716
  while (1) {
    while_continue: /* CIL Label */ ;
#line 716
    if (! (y < (int )m->height)) {
#line 716
      goto while_break;
    }
#line 718
    last = (int )(- size);
#line 719
    x = 0;
    {
#line 719
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 719
      if (! (x < (int )m->width)) {
#line 719
        goto while_break___0;
      }
#line 721
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 721
        tmp = 1;
      } else {
#line 721
        tmp = 0;
      }
#line 721
      if (! tmp) {
#line 723
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) & ~ (128 >> x % 8));
#line 724
        l = x - last;
#line 725
        if (l > 1) {
#line 725
          if (l < (int )size) {
#line 727
            if (last < 0) {
#line 728
              last = 0;
            }
#line 729
            k = last;
            {
#line 729
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 729
              if (! (k < x)) {
#line 729
                goto while_break___1;
              }
#line 730
              *(m_out->data + (k / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (k / 8 + y * m_out->rowstride)) & ~ (128 >> k % 8));
#line 729
              k ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 732
        last = x;
      }
#line 719
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 716
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 737
  return (m_out);
}
}
#line 740 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_vlink(ho_bitmap const   *m , int const   size ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int k ;
  int l ;
  int last ;
  int tmp ;

  {
  {
#line 751
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 752
  if (! m_out) {
#line 753
    return ((ho_bitmap *)((void *)0));
  }
#line 754
  m_out->x = (int )m->x;
#line 755
  m_out->y = (int )m->y;
#line 757
  m_out->type = (unsigned char )m->type;
#line 758
  m_out->font_height = (int )m->font_height;
#line 759
  m_out->font_width = (int )m->font_width;
#line 760
  m_out->font_spacing = (int )m->font_spacing;
#line 761
  m_out->line_spacing = (int )m->line_spacing;
#line 762
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 763
  m_out->com_line_fill = (int )m->com_line_fill;
#line 764
  m_out->nikud = (unsigned char )m->nikud;
#line 766
  x = 0;
  {
#line 766
  while (1) {
    while_continue: /* CIL Label */ ;
#line 766
    if (! (x < (int )m->width)) {
#line 766
      goto while_break;
    }
#line 768
    last = (int )(- size);
#line 769
    y = 0;
    {
#line 769
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 769
      if (! (y < (int )m->height)) {
#line 769
        goto while_break___0;
      }
#line 771
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 771
        tmp = 1;
      } else {
#line 771
        tmp = 0;
      }
#line 771
      if (tmp) {
#line 773
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
#line 774
        l = y - last;
#line 775
        if (l > 1) {
#line 775
          if (l < (int )size) {
#line 777
            k = last;
            {
#line 777
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 777
              if (! (k < y)) {
#line 777
                goto while_break___1;
              }
#line 778
              *(m_out->data + (x / 8 + k * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + k * m_out->rowstride)) | (128 >> x % 8));
#line 777
              k ++;
            }
            while_break___1: /* CIL Label */ ;
            }
          }
        }
#line 780
        last = y;
      }
#line 769
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 766
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 785
  return (m_out);
}
}
#line 788 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_edge(ho_bitmap const   *m , int const   n ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp1 ;
  ho_bitmap *m_temp2 ;
  int i ;

  {
  {
#line 796
  m_temp1 = ho_bitmap_clone(m);
  }
#line 797
  if (! m_temp1) {
#line 798
    return ((ho_bitmap *)((void *)0));
  }
#line 800
  i = 0;
  {
#line 800
  while (1) {
    while_continue: /* CIL Label */ ;
#line 800
    if (! (i < (int )n)) {
#line 800
      goto while_break;
    }
    {
#line 802
    m_temp2 = ho_bitmap_erosion((ho_bitmap const   *)m_temp1);
#line 803
    ho_bitmap_free(m_temp1);
    }
#line 804
    if (! m_temp2) {
#line 805
      return ((ho_bitmap *)((void *)0));
    }
#line 806
    m_temp1 = m_temp2;
#line 800
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 809
  m_out = ho_bitmap_clone(m);
  }
#line 810
  if (! m_out) {
#line 811
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 812
  m_out->x = (int )m->x;
#line 813
  m_out->y = (int )m->y;
#line 815
  m_out->type = (unsigned char )m->type;
#line 816
  m_out->font_height = (int )m->font_height;
#line 817
  m_out->font_width = (int )m->font_width;
#line 818
  m_out->font_spacing = (int )m->font_spacing;
#line 819
  m_out->line_spacing = (int )m->line_spacing;
#line 820
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 821
  m_out->com_line_fill = (int )m->com_line_fill;
#line 822
  m_out->nikud = (unsigned char )m->nikud;
#line 824
  ho_bitmap_andnot(m_out, (ho_bitmap const   *)m_temp1);
#line 825
  ho_bitmap_free(m_temp1);
  }
#line 827
  return (m_out);
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
double ho_bitmap_get_fill(ho_bitmap const   *m , int const   x , int const   y , int const   width ,
                          int const   height ) 
{ 
  int current_x ;
  int current_y ;
  int fill ;
  int tmp ;

  {
#line 837
  if (! width) {
#line 839
    return (- 1.0);
  } else
#line 837
  if (! height) {
#line 839
    return (- 1.0);
  } else
#line 837
  if (x < 0) {
#line 839
    return (- 1.0);
  } else
#line 837
  if (y < 0) {
#line 839
    return (- 1.0);
  } else
#line 837
  if (x + width > m->width) {
#line 839
    return (- 1.0);
  } else
#line 837
  if (y + height > m->height) {
#line 839
    return (- 1.0);
  }
#line 841
  fill = 0;
#line 842
  current_y = (int )y;
  {
#line 842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 842
    if (! (current_y < (int )(y + height))) {
#line 842
      goto while_break;
    }
#line 843
    current_x = (int )x;
    {
#line 843
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 843
      if (! (current_x < (int )(x + width))) {
#line 843
        goto while_break___0;
      }
#line 844
      if (((int )*(m->data + (current_x / 8 + current_y * (int )m->rowstride)) & (128 >> current_x % 8)) > 0) {
#line 844
        tmp = 1;
      } else {
#line 844
        tmp = 0;
      }
#line 844
      fill += tmp;
#line 843
      current_x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 842
    current_y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 846
  return ((double )fill / (double )(width * height));
}
}
#line 849 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_draw_box(ho_bitmap *m , int const   x , int const   y , int const   width ,
                       int const   height ) 
{ 
  int x1 ;
  int y1___0 ;

  {
#line 856
  x1 = (int )x;
  {
#line 856
  while (1) {
    while_continue: /* CIL Label */ ;
#line 856
    if (x1 < (int )(x + width)) {
#line 856
      if (! (x1 < m->width)) {
#line 856
        goto while_break;
      }
    } else {
#line 856
      goto while_break;
    }
#line 857
    y1___0 = (int )y;
    {
#line 857
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 857
      if (y1___0 < (int )(y + height)) {
#line 857
        if (! (y1___0 < m->height)) {
#line 857
          goto while_break___0;
        }
      } else {
#line 857
        goto while_break___0;
      }
#line 858
      *(m->data + (x1 / 8 + y1___0 * m->rowstride)) = (unsigned char )((int )*(m->data + (x1 / 8 + y1___0 * m->rowstride)) | (128 >> x1 % 8));
#line 857
      y1___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 856
    x1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 860
  return (0);
}
}
#line 863 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_draw_vline(ho_bitmap *m , int const   x , int const   y , int const   height ) 
{ 
  int ix ;
  int iy ;
  int y1___0 ;

  {
#line 866
  ix = (int )x;
#line 866
  iy = (int )y;
#line 870
  if (ix > m->width) {
#line 871
    ix = m->width - 1;
  }
#line 872
  if (iy > m->height) {
#line 873
    iy = m->height - 1;
  }
#line 876
  y1___0 = iy;
  {
#line 876
  while (1) {
    while_continue: /* CIL Label */ ;
#line 876
    if (y1___0 < iy + (int )height) {
#line 876
      if (! (y1___0 < m->height)) {
#line 876
        goto while_break;
      }
    } else {
#line 876
      goto while_break;
    }
#line 878
    *(m->data + (ix / 8 + y1___0 * m->rowstride)) = (unsigned char )((int )*(m->data + (ix / 8 + y1___0 * m->rowstride)) | (128 >> ix % 8));
#line 876
    y1___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 881
  return (0);
}
}
#line 884 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_delete_vline(ho_bitmap *m , int const   x , int const   y , int const   height ) 
{ 
  int ix ;
  int iy ;
  int y1___0 ;

  {
#line 888
  ix = (int )x;
#line 888
  iy = (int )y;
#line 892
  if (ix > m->width) {
#line 893
    ix = m->width - 1;
  }
#line 894
  if (iy > m->height) {
#line 895
    iy = m->height - 1;
  }
#line 898
  y1___0 = iy;
  {
#line 898
  while (1) {
    while_continue: /* CIL Label */ ;
#line 898
    if (y1___0 < iy + (int )height) {
#line 898
      if (! (y1___0 < m->height - 1)) {
#line 898
        goto while_break;
      }
    } else {
#line 898
      goto while_break;
    }
#line 899
    *(m->data + (ix / 8 + y1___0 * m->rowstride)) = (unsigned char )((int )*(m->data + (ix / 8 + y1___0 * m->rowstride)) & ~ (128 >> ix % 8));
#line 898
    y1___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 901
  return (0);
}
}
#line 904 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_draw_hline(ho_bitmap *m , int const   x , int const   y , int const   width ) 
{ 
  int ix ;
  int iy ;
  int x1 ;

  {
#line 907
  ix = (int )x;
#line 907
  iy = (int )y;
#line 911
  if (ix > m->width) {
#line 912
    ix = m->width - 1;
  }
#line 913
  if (iy > m->height) {
#line 914
    iy = m->height - 1;
  }
#line 917
  x1 = (int )x;
  {
#line 917
  while (1) {
    while_continue: /* CIL Label */ ;
#line 917
    if (x1 < (int )(x + width)) {
#line 917
      if (! (x1 < m->width)) {
#line 917
        goto while_break;
      }
    } else {
#line 917
      goto while_break;
    }
#line 918
    *(m->data + (x1 / 8 + (int )(y * (int const   )m->rowstride))) = (unsigned char )((int )*(m->data + (x1 / 8 + (int )(y * (int const   )m->rowstride))) | (128 >> x1 % 8));
#line 917
    x1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 920
  return (0);
}
}
#line 923 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_delete_hline(ho_bitmap *m , int const   x , int const   y , int const   width ) 
{ 
  int ix ;
  int iy ;
  int x1 ;

  {
#line 927
  ix = (int )x;
#line 927
  iy = (int )y;
#line 931
  if (ix > m->width) {
#line 932
    ix = m->width - 1;
  }
#line 933
  if (iy > m->height) {
#line 934
    iy = m->height - 1;
  }
#line 937
  x1 = (int )x;
  {
#line 937
  while (1) {
    while_continue: /* CIL Label */ ;
#line 937
    if (x1 < (int )(x + width)) {
#line 937
      if (! (x1 < m->width)) {
#line 937
        goto while_break;
      }
    } else {
#line 937
      goto while_break;
    }
#line 938
    *(m->data + (x1 / 8 + (int )(y * (int const   )m->rowstride))) = (unsigned char )((int )*(m->data + (x1 / 8 + (int )(y * (int const   )m->rowstride))) & ~ (128 >> x1 % 8));
#line 937
    x1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 940
  return (0);
}
}
#line 943 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_draw_box_empty(ho_bitmap *m , int const   x , int const   y , int const   width ,
                             int const   height ) 
{ 


  {
  {
#line 947
  ho_bitmap_draw_hline(m, x, y, width);
#line 948
  ho_bitmap_draw_hline(m, x, (y + (int const   )m->height) - 1, width);
#line 949
  ho_bitmap_draw_vline(m, x, y, height);
#line 950
  ho_bitmap_draw_vline(m, (x + (int const   )m->width) - 1, y, height);
  }
#line 952
  return (0);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_filter_by_size(ho_bitmap const   *m , int min_height , int max_height ,
                                    int min_width , int max_width ) 
{ 
  ho_objmap *m_obj ;
  ho_bitmap *m_out ;

  {
  {
#line 963
  m_obj = ho_objmap_new_from_bitmap(m);
  }
#line 965
  if (! m_obj) {
#line 966
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 968
  m_out = ho_objmap_to_bitmap_by_size((ho_objmap const   *)m_obj, min_height, max_height,
                                      min_width, max_width);
#line 972
  ho_objmap_free(m_obj);
  }
#line 974
  return (m_out);
}
}
#line 977 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_filter_boxes(ho_bitmap const   *m , int const   leeway_down ,
                                  int const   leeway_up ) 
{ 
  ho_objmap *m_obj ;
  ho_bitmap *m_out ;
  int index___0 ;
  int x ;
  int y ;
  int width ;
  int height ;

  {
  {
#line 987
  m_obj = ho_objmap_new_from_bitmap(m);
  }
#line 988
  if (! m_obj) {
#line 989
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 990
  m_out = ho_bitmap_new(m->width, m->height);
#line 991
  m_out->x = (int )m->x;
#line 992
  m_out->y = (int )m->y;
#line 994
  m_out->type = (unsigned char )m->type;
#line 995
  m_out->font_height = (int )m->font_height;
#line 996
  m_out->font_width = (int )m->font_width;
#line 997
  m_out->font_spacing = (int )m->font_spacing;
#line 998
  m_out->line_spacing = (int )m->line_spacing;
#line 999
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 1000
  m_out->com_line_fill = (int )m->com_line_fill;
#line 1001
  m_out->nikud = (unsigned char )m->nikud;
  }
#line 1003
  if (! m_out) {
    {
#line 1005
    ho_objmap_free(m_obj);
    }
#line 1006
    return ((ho_bitmap *)((void *)0));
  }
#line 1010
  index___0 = 0;
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1010
    if (! (index___0 < (m_obj->obj_list)->size)) {
#line 1010
      goto while_break;
    }
#line 1012
    x = ((m_obj->obj_list)->objects + index___0)->x;
#line 1013
    y = ((m_obj->obj_list)->objects + index___0)->y;
#line 1014
    width = ((m_obj->obj_list)->objects + index___0)->width;
#line 1015
    height = ((m_obj->obj_list)->objects + index___0)->height;
#line 1017
    y -= (int )leeway_up;
#line 1018
    height += (int )(leeway_up + leeway_down);
#line 1019
    if (y < 0) {
#line 1020
      y = 0;
    }
#line 1021
    if (y + height >= (int )m->height) {
#line 1022
      height = (int )((m->height - (int const   )y) - 1);
    }
    {
#line 1024
    ho_bitmap_draw_box(m_out, (int const   )x, (int const   )y, (int const   )width,
                       (int const   )height);
#line 1010
    index___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1027
  return (m_out);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_filter_fill(ho_bitmap const   *m ) 
{ 
  ho_objmap *m_obj ;
  ho_bitmap *m_out ;
  ho_bitmap *m_temp1 ;
  ho_bitmap *m_temp2 ;
  int index___0 ;
  int width ;
  int height ;

  {
  {
#line 1041
  m_obj = ho_objmap_new_from_bitmap(m);
  }
#line 1042
  if (! m_obj) {
#line 1043
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1045
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 1046
  if (! m_out) {
    {
#line 1048
    ho_objmap_free(m_obj);
    }
#line 1049
    return ((ho_bitmap *)((void *)0));
  }
#line 1051
  m_out->x = (int )m->x;
#line 1052
  m_out->y = (int )m->y;
#line 1054
  m_out->type = (unsigned char )m->type;
#line 1055
  m_out->font_height = (int )m->font_height;
#line 1056
  m_out->font_width = (int )m->font_width;
#line 1057
  m_out->font_spacing = (int )m->font_spacing;
#line 1058
  m_out->line_spacing = (int )m->line_spacing;
#line 1059
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 1060
  m_out->com_line_fill = (int )m->com_line_fill;
#line 1061
  m_out->nikud = (unsigned char )m->nikud;
#line 1064
  index___0 = 0;
  {
#line 1064
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1064
    if (! (index___0 < (m_obj->obj_list)->size)) {
#line 1064
      goto while_break;
    }
    {
#line 1067
    width = ((m_obj->obj_list)->objects + index___0)->width;
#line 1068
    height = ((m_obj->obj_list)->objects + index___0)->height;
#line 1071
    m_temp1 = ho_objmap_to_bitmap_by_index((ho_objmap const   *)m_obj, (int const   )index___0);
#line 1074
    m_temp2 = ho_bitmap_hlink((ho_bitmap const   *)m_temp1, (int const   )(width / 4));
#line 1075
    ho_bitmap_free(m_temp1);
#line 1076
    m_temp1 = ho_bitmap_vlink((ho_bitmap const   *)m_temp2, (int const   )(height / 4));
#line 1077
    ho_bitmap_free(m_temp2);
#line 1080
    ho_bitmap_or(m_out, (ho_bitmap const   *)m_temp1);
#line 1081
    ho_bitmap_free(m_temp1);
#line 1064
    index___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1084
  return (m_out);
}
}
#line 1087 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_filter_set_height(ho_bitmap const   *m , int const   height ,
                                       int const   top , int const   bottom ) 
{ 
  ho_objmap *m_obj ;
  ho_bitmap *m_out ;
  ho_bitmap *m_temp1 ;
  ho_bitmap *m_temp2 ;
  int index___0 ;

  {
  {
#line 1098
  m_obj = ho_objmap_new_from_bitmap(m);
  }
#line 1099
  if (! m_obj) {
#line 1100
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1102
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 1103
  if (! m_out) {
    {
#line 1105
    ho_objmap_free(m_obj);
    }
#line 1106
    return ((ho_bitmap *)((void *)0));
  }
#line 1108
  m_out->x = (int )m->x;
#line 1109
  m_out->y = (int )m->y;
#line 1111
  m_out->type = (unsigned char )m->type;
#line 1112
  m_out->font_height = (int )m->font_height;
#line 1113
  m_out->font_width = (int )m->font_width;
#line 1114
  m_out->font_spacing = (int )m->font_spacing;
#line 1115
  m_out->line_spacing = (int )m->line_spacing;
#line 1116
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 1117
  m_out->com_line_fill = (int )m->com_line_fill;
#line 1118
  m_out->nikud = (unsigned char )m->nikud;
#line 1121
  index___0 = 0;
  {
#line 1121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1121
    if (! (index___0 < (m_obj->obj_list)->size)) {
#line 1121
      goto while_break;
    }
    {
#line 1124
    m_temp1 = ho_objmap_to_bitmap_by_index((ho_objmap const   *)m_obj, (int const   )index___0);
    }
#line 1125
    if (! m_temp1) {
#line 1126
      goto __Cont;
    }
    {
#line 1129
    m_temp2 = ho_bitmap_set_height((ho_bitmap const   *)m_temp1, height, top, bottom);
#line 1130
    ho_bitmap_free(m_temp1);
    }
#line 1131
    if (! m_temp2) {
#line 1132
      goto __Cont;
    }
    {
#line 1135
    ho_bitmap_or(m_out, (ho_bitmap const   *)m_temp2);
#line 1136
    ho_bitmap_free(m_temp2);
    }
    __Cont: /* CIL Label */ 
#line 1121
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1139
  return (m_out);
}
}
#line 1142 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_filter_set_height_from_bottom(ho_bitmap const   *m , int const   height ,
                                                   int const   top , int const   bottom ) 
{ 
  ho_objmap *m_obj ;
  ho_bitmap *m_out ;
  ho_bitmap *m_temp1 ;
  ho_bitmap *m_temp2 ;
  int index___0 ;

  {
  {
#line 1153
  m_obj = ho_objmap_new_from_bitmap(m);
  }
#line 1154
  if (! m_obj) {
#line 1155
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1157
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 1158
  if (! m_out) {
    {
#line 1160
    ho_objmap_free(m_obj);
    }
#line 1161
    return ((ho_bitmap *)((void *)0));
  }
#line 1163
  m_out->x = (int )m->x;
#line 1164
  m_out->y = (int )m->y;
#line 1166
  m_out->type = (unsigned char )m->type;
#line 1167
  m_out->font_height = (int )m->font_height;
#line 1168
  m_out->font_width = (int )m->font_width;
#line 1169
  m_out->font_spacing = (int )m->font_spacing;
#line 1170
  m_out->line_spacing = (int )m->line_spacing;
#line 1171
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 1172
  m_out->com_line_fill = (int )m->com_line_fill;
#line 1173
  m_out->nikud = (unsigned char )m->nikud;
#line 1176
  index___0 = 0;
  {
#line 1176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1176
    if (! (index___0 < (m_obj->obj_list)->size)) {
#line 1176
      goto while_break;
    }
    {
#line 1179
    m_temp1 = ho_objmap_to_bitmap_by_index((ho_objmap const   *)m_obj, (int const   )index___0);
    }
#line 1180
    if (! m_temp1) {
#line 1181
      goto __Cont;
    }
    {
#line 1184
    m_temp2 = ho_bitmap_set_height_from_bottom((ho_bitmap const   *)m_temp1, height,
                                               top, bottom);
#line 1185
    ho_bitmap_free(m_temp1);
    }
#line 1186
    if (! m_temp2) {
#line 1187
      goto __Cont;
    }
    {
#line 1190
    ho_bitmap_or(m_out, (ho_bitmap const   *)m_temp2);
#line 1191
    ho_bitmap_free(m_temp2);
    }
    __Cont: /* CIL Label */ 
#line 1176
    index___0 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1194
  return (m_out);
}
}
#line 1197 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_filter_hlink(ho_bitmap *m , int size , int max_height ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;

  {
  {
#line 1207
  m_temp = ho_bitmap_filter_by_size((ho_bitmap const   *)m, 5, max_height, 5, m->width / 2);
#line 1210
  m_out = ho_bitmap_hlink((ho_bitmap const   *)m_temp, (int const   )size);
#line 1213
  ho_bitmap_or(m_out, (ho_bitmap const   *)m);
#line 1215
  ho_bitmap_free(m_temp);
  }
#line 1217
  return (m_out);
}
}
#line 1220 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_filter_remove_dots(ho_bitmap const   *m , unsigned char const   erosion_n ,
                                        unsigned char const   dilation_n ) 
{ 
  int x ;
  int y ;
  unsigned char sum ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_out ;
  ho_objmap *m_obj ;
  int index___0 ;
  int width ;
  int height ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;

  {
  {
#line 1233
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 1234
  if (! m_out) {
#line 1235
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1236
  m_out->x = (int )m->x;
#line 1237
  m_out->y = (int )m->y;
#line 1239
  m_out->type = (unsigned char )m->type;
#line 1240
  m_out->font_height = (int )m->font_height;
#line 1241
  m_out->font_width = (int )m->font_width;
#line 1242
  m_out->font_spacing = (int )m->font_spacing;
#line 1243
  m_out->line_spacing = (int )m->line_spacing;
#line 1244
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 1245
  m_out->com_line_fill = (int )m->com_line_fill;
#line 1246
  m_out->nikud = (unsigned char )m->nikud;
#line 1249
  m_temp = ho_bitmap_dilation(m);
#line 1252
  m_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_temp);
#line 1253
  ho_bitmap_free(m_temp);
#line 1255
  x = 1;
  }
  {
#line 1255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1255
    if (! (x < (int )(m->width - 1))) {
#line 1255
      goto while_break;
    }
#line 1256
    y = 1;
    {
#line 1256
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1256
      if (! (y < (int )(m->height - 1))) {
#line 1256
        goto while_break___0;
      }
#line 1260
      index___0 = *(m_obj->map + (x + y * m_obj->width));
#line 1261
      if (index___0) {
#line 1263
        width = ((m_obj->obj_list)->objects + (index___0 - 1))->width;
#line 1264
        height = ((m_obj->obj_list)->objects + (index___0 - 1))->height;
      } else {
#line 1268
        width = 0;
#line 1269
        height = 0;
      }
#line 1273
      if (width > (int )(m->width / 4)) {
#line 1273
        goto _L;
      } else
#line 1273
      if (height > (int )(m->height / 4)) {
        _L: /* CIL Label */ 
#line 1275
        if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 1275
          tmp___7 = 1;
        } else {
#line 1275
          tmp___7 = 0;
        }
#line 1275
        if (tmp___7) {
#line 1277
          if (((int )*(m->data + ((x - 1) / 8 + (y - 1) * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 1277
            tmp = 1;
          } else {
#line 1277
            tmp = 0;
          }
#line 1277
          if (((int )*(m->data + ((x - 1) / 8 + y * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 1277
            tmp___0 = 1;
          } else {
#line 1277
            tmp___0 = 0;
          }
#line 1277
          if (((int )*(m->data + ((x - 1) / 8 + (y + 1) * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 1277
            tmp___1 = 1;
          } else {
#line 1277
            tmp___1 = 0;
          }
#line 1277
          if (((int )*(m->data + (x / 8 + (y - 1) * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 1277
            tmp___2 = 1;
          } else {
#line 1277
            tmp___2 = 0;
          }
#line 1277
          if (((int )*(m->data + (x / 8 + (y + 1) * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 1277
            tmp___3 = 1;
          } else {
#line 1277
            tmp___3 = 0;
          }
#line 1277
          if (((int )*(m->data + ((x + 1) / 8 + (y - 1) * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 1277
            tmp___4 = 1;
          } else {
#line 1277
            tmp___4 = 0;
          }
#line 1277
          if (((int )*(m->data + ((x + 1) / 8 + y * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 1277
            tmp___5 = 1;
          } else {
#line 1277
            tmp___5 = 0;
          }
#line 1277
          if (((int )*(m->data + ((x + 1) / 8 + (y + 1) * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 1277
            tmp___6 = 1;
          } else {
#line 1277
            tmp___6 = 0;
          }
#line 1277
          sum = (unsigned char )(((((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) + tmp___4) + tmp___5) + tmp___6);
#line 1285
          if (8 - (int )sum < (int )erosion_n) {
#line 1286
            *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
          }
        }
      } else {
#line 1291
        if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 1291
          tmp___16 = 1;
        } else {
#line 1291
          tmp___16 = 0;
        }
#line 1291
        if (tmp___16) {
#line 1305
          *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
        } else {
#line 1293
          if (((int )*(m->data + ((x - 1) / 8 + (y - 1) * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 1293
            tmp___8 = 1;
          } else {
#line 1293
            tmp___8 = 0;
          }
#line 1293
          if (((int )*(m->data + ((x - 1) / 8 + y * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 1293
            tmp___9 = 1;
          } else {
#line 1293
            tmp___9 = 0;
          }
#line 1293
          if (((int )*(m->data + ((x - 1) / 8 + (y + 1) * (int )m->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 1293
            tmp___10 = 1;
          } else {
#line 1293
            tmp___10 = 0;
          }
#line 1293
          if (((int )*(m->data + (x / 8 + (y - 1) * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 1293
            tmp___11 = 1;
          } else {
#line 1293
            tmp___11 = 0;
          }
#line 1293
          if (((int )*(m->data + (x / 8 + (y + 1) * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 1293
            tmp___12 = 1;
          } else {
#line 1293
            tmp___12 = 0;
          }
#line 1293
          if (((int )*(m->data + ((x + 1) / 8 + (y - 1) * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 1293
            tmp___13 = 1;
          } else {
#line 1293
            tmp___13 = 0;
          }
#line 1293
          if (((int )*(m->data + ((x + 1) / 8 + y * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 1293
            tmp___14 = 1;
          } else {
#line 1293
            tmp___14 = 0;
          }
#line 1293
          if (((int )*(m->data + ((x + 1) / 8 + (y + 1) * (int )m->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 1293
            tmp___15 = 1;
          } else {
#line 1293
            tmp___15 = 0;
          }
#line 1293
          sum = (unsigned char )(((((((tmp___8 + tmp___9) + tmp___10) + tmp___11) + tmp___12) + tmp___13) + tmp___14) + tmp___15);
#line 1301
          if ((int )sum >= (int )dilation_n) {
#line 1302
            *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
          }
        }
      }
#line 1256
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1255
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1309
  ho_objmap_free(m_obj);
  }
#line 1311
  return (m_out);
}
}
#line 1314 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_filter_obj_extend_lateraly(ho_bitmap const   *m , int const   ext_width ) 
{ 
  ho_objmap *m_obj ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int index___0 ;
  int width ;
  int height ;

  {
  {
#line 1326
  m_temp = ho_bitmap_clone(m);
  }
#line 1327
  if (! m_temp) {
#line 1328
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1332
  m_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_temp);
  }
#line 1333
  if (! m_obj) {
    {
#line 1335
    ho_bitmap_free(m_temp);
    }
#line 1336
    return ((ho_bitmap *)((void *)0));
  }
#line 1340
  index___0 = 0;
  {
#line 1340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1340
    if (! (index___0 < (m_obj->obj_list)->size)) {
#line 1340
      goto while_break;
    }
#line 1342
    x = ((m_obj->obj_list)->objects + index___0)->x;
#line 1343
    y = ((m_obj->obj_list)->objects + index___0)->y;
#line 1344
    width = ((m_obj->obj_list)->objects + index___0)->width;
#line 1345
    height = ((m_obj->obj_list)->objects + index___0)->height;
#line 1347
    if (x - (int )ext_width < 0) {
#line 1348
      x = (int )ext_width;
    }
#line 1349
    if ((x + width) + (int )ext_width >= (int )m->width) {
#line 1350
      width = (int )(((m->width - (int const   )x) - ext_width) - 1);
    }
    {
#line 1352
    ho_bitmap_draw_vline(m_temp, (int const   )(x - (int )ext_width), (int const   )y,
                         (int const   )height);
#line 1353
    ho_bitmap_draw_vline(m_temp, (int const   )((x + width) + (int )ext_width), (int const   )y,
                         (int const   )height);
#line 1340
    index___0 ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1357
  m_out = ho_bitmap_hlink((ho_bitmap const   *)m_temp, (int const   )((7 * (int )ext_width) / 4));
#line 1359
  ho_bitmap_free(m_temp);
  }
#line 1360
  if (! m_out) {
#line 1361
    return ((ho_bitmap *)((void *)0));
  }
#line 1364
  index___0 = 0;
  {
#line 1364
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1364
    if (! (index___0 < (m_obj->obj_list)->size)) {
#line 1364
      goto while_break___0;
    }
#line 1366
    x = ((m_obj->obj_list)->objects + index___0)->x;
#line 1367
    y = ((m_obj->obj_list)->objects + index___0)->y;
#line 1368
    width = ((m_obj->obj_list)->objects + index___0)->width;
#line 1369
    height = ((m_obj->obj_list)->objects + index___0)->height;
#line 1371
    if (x - (int )ext_width < 0) {
#line 1372
      x = (int )ext_width;
    }
#line 1373
    if ((x + width) + (int )ext_width >= (int )m->width) {
#line 1374
      width = (int )(((m->width - (int const   )x) - ext_width) - 1);
    }
    {
#line 1375
    ho_bitmap_delete_vline(m_out, (int const   )(x - (int )ext_width), (int const   )y,
                           (int const   )height);
#line 1376
    ho_bitmap_delete_vline(m_out, (int const   )((x + width) + (int )ext_width), (int const   )y,
                           (int const   )height);
#line 1364
    index___0 ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1380
  m_out->x = (int )m->x;
#line 1381
  m_out->y = (int )m->y;
#line 1383
  m_out->type = (unsigned char )m->type;
#line 1384
  m_out->font_height = (int )m->font_height;
#line 1385
  m_out->font_width = (int )m->font_width;
#line 1386
  m_out->font_spacing = (int )m->font_spacing;
#line 1387
  m_out->line_spacing = (int )m->line_spacing;
#line 1388
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 1389
  m_out->com_line_fill = (int )m->com_line_fill;
#line 1390
  m_out->nikud = (unsigned char )m->nikud;
#line 1392
  ho_objmap_free(m_obj);
  }
#line 1394
  return (m_out);
}
}
#line 1397 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_filter_count_objects(ho_bitmap const   *m ) 
{ 
  ho_objmap *o_obj ;
  int count ;

  {
  {
#line 1403
  o_obj = ho_objmap_new_from_bitmap(m);
  }
#line 1404
  if (! o_obj) {
#line 1405
    return (-1);
  }
  {
#line 1407
  count = (o_obj->obj_list)->size;
#line 1408
  ho_objmap_free(o_obj);
  }
#line 1410
  return (count);
}
}
#line 1413 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
ho_bitmap *ho_bitmap_rotate(ho_bitmap const   *m , double const   angle ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int xtag ;
  int ytag ;
  double xtag_part ;
  double ytag_part ;
  double angle_rads ;
  double new_point ;
  unsigned char neighbors[2][2] ;
  double affine_matrix[2][2] ;

  {
  {
#line 1428
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 1429
  if (! m_out) {
#line 1430
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1431
  m_out->x = (int )m->x;
#line 1432
  m_out->y = (int )m->y;
#line 1434
  m_out->type = (unsigned char )m->type;
#line 1435
  m_out->font_height = (int )m->font_height;
#line 1436
  m_out->font_width = (int )m->font_width;
#line 1437
  m_out->font_spacing = (int )m->font_spacing;
#line 1438
  m_out->line_spacing = (int )m->line_spacing;
#line 1439
  m_out->avg_line_fill = (int )m->avg_line_fill;
#line 1440
  m_out->com_line_fill = (int )m->com_line_fill;
#line 1441
  m_out->nikud = (unsigned char )m->nikud;
#line 1444
  angle_rads = (double )(angle * (double const   )((2.0 * 3.14159265358979323846) / (double )360));
#line 1447
  affine_matrix[0][0] = cos(angle_rads);
#line 1448
  affine_matrix[0][1] = sin(angle_rads);
#line 1449
  affine_matrix[1][0] = - affine_matrix[0][1];
#line 1450
  affine_matrix[1][1] = affine_matrix[0][0];
#line 1455
  x = 0;
  }
  {
#line 1455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1455
    if (! (x < (int )m->width)) {
#line 1455
      goto while_break;
    }
#line 1456
    y = 0;
    {
#line 1456
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1456
      if (! (y < (int )m->height)) {
#line 1456
        goto while_break___0;
      }
#line 1459
      xtag_part = (double )x * affine_matrix[0][0] + (double )y * affine_matrix[0][1];
#line 1460
      ytag_part = (double )x * affine_matrix[1][0] + (double )y * affine_matrix[1][1];
#line 1461
      xtag = (int )xtag_part;
#line 1462
      ytag = (int )ytag_part;
#line 1463
      xtag_part -= (double )xtag;
#line 1464
      ytag_part -= (double )ytag;
#line 1467
      if (xtag < 1) {
#line 1469
        new_point = (double )0;
      } else
#line 1467
      if (ytag < 1) {
#line 1469
        new_point = (double )0;
      } else
#line 1467
      if (xtag >= (int )m->width) {
#line 1469
        new_point = (double )0;
      } else
#line 1467
      if (ytag >= (int )m->height) {
#line 1469
        new_point = (double )0;
      } else {
#line 1473
        if (((int )*(m->data + ((xtag - 1) / 8 + (ytag - 1) * (int )m->rowstride)) & (128 >> (xtag - 1) % 8)) > 0) {
#line 1473
          neighbors[0][0] = (unsigned char)1;
        } else {
#line 1473
          neighbors[0][0] = (unsigned char)0;
        }
#line 1474
        if (((int )*(m->data + ((xtag - 1) / 8 + ytag * (int )m->rowstride)) & (128 >> (xtag - 1) % 8)) > 0) {
#line 1474
          neighbors[0][1] = (unsigned char)1;
        } else {
#line 1474
          neighbors[0][1] = (unsigned char)0;
        }
#line 1475
        if (((int )*(m->data + (xtag / 8 + (ytag - 1) * (int )m->rowstride)) & (128 >> xtag % 8)) > 0) {
#line 1475
          neighbors[1][0] = (unsigned char)1;
        } else {
#line 1475
          neighbors[1][0] = (unsigned char)0;
        }
#line 1476
        if (((int )*(m->data + (xtag / 8 + ytag * (int )m->rowstride)) & (128 >> xtag % 8)) > 0) {
#line 1476
          neighbors[1][1] = (unsigned char)1;
        } else {
#line 1476
          neighbors[1][1] = (unsigned char)0;
        }
#line 1478
        new_point = ((((double )neighbors[0][0] * (1.0 - xtag_part)) * (1.0 - ytag_part) + ((double )neighbors[0][1] * (1.0 - xtag_part)) * ytag_part) + ((double )neighbors[1][0] * xtag_part) * (1.0 - ytag_part)) + ((double )neighbors[1][1] * xtag_part) * ytag_part;
      }
#line 1486
      if (new_point > 0.5) {
#line 1487
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
#line 1456
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1455
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1490
  return (m_out);
}
}
#line 1493 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap.c"
int ho_bitmap_pnm_save(ho_bitmap const   *m , char const   *filename ) 
{ 
  FILE *file ;

  {
  {
#line 1496
  file = (FILE *)((void *)0);
#line 1498
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
  }
#line 1500
  if (! file) {
#line 1501
    return (-1);
  }
  {
#line 1504
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"P4 %d %d\n",
          m->width, m->height);
#line 1507
  fwrite((void const   */* __restrict  */)m->data, (size_t )1, (size_t )(m->height * m->rowstride),
         (FILE */* __restrict  */)file);
#line 1508
  fclose(file);
  }
#line 1510
  return (0);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 331 "./ho_pixbuf.h"
ho_bitmap *ho_pixbuf_to_bitmap_wrapper(ho_pixbuf const   *pix_in , unsigned char const   scale ,
                                       unsigned char const   adaptive , unsigned char const   threshold ,
                                       unsigned char const   a_threshold , unsigned char const   size ) ;
#line 43 "./ho_font.h"
ho_bitmap *ho_font_main_sign(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 205 "./ho_recognize.h"
char const   *ho_recognize_font(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                int font_code , unsigned char do_linguistics , unsigned char word_end ,
                                unsigned char word_start , int *this_char_i , int last_char_i ) ;
#line 66 "./ho_string.h"
int ho_string_cat(ho_string *string_buffer , char const   *new_string ) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/hocr.h"
ho_bitmap *hocr_image_processing(ho_pixbuf const   *pix_in , unsigned char const   scale ,
                                 unsigned char const   no_auto_scale , double rotate ,
                                 unsigned char const   no_auto_rotate , unsigned char const   adaptive ,
                                 unsigned char const   threshold , unsigned char const   a_threshold ,
                                 int *progress ) ;
#line 128
ho_layout *hocr_layout_analysis(ho_bitmap const   *m_in , int const   font_spacing_code ,
                                int const   paragraph_setup , int const   slicing_threshold ,
                                int const   slicing_width , int const   line_leeway ,
                                unsigned char const   dir_ltr , int *progress ) ;
#line 144
int hocr_font_recognition(ho_layout const   *l_page , ho_string *s_text_out , unsigned char const   html ,
                          int font_code , unsigned char const   nikud , unsigned char do_linguistics ,
                          int *progress ) ;
#line 173
int hocr_do_ocr_fine(ho_pixbuf const   *pix_in , ho_string *s_text_out , unsigned char const   scale ,
                     unsigned char const   no_auto_scale , double rotate , unsigned char const   no_auto_rotate ,
                     unsigned char const   adaptive , unsigned char const   threshold ,
                     unsigned char const   a_threshold , int const   font_spacing_code ,
                     int const   paragraph_setup , int const   slicing_threshold ,
                     int const   slicing_width , int const   line_leeway , unsigned char const   dir_ltr ,
                     unsigned char const   html , int font_code , unsigned char const   nikud ,
                     unsigned char const   do_linguistics , int *progress ) ;
#line 197
int hocr_do_ocr(ho_pixbuf const   *pix_in , ho_string *s_text_out , unsigned char const   html ,
                int font_code , unsigned char const   do_linguistics , int *progress ) ;
#line 206
char const   *hocr_get_build_string(void) ;
#line 213
char const   *hocr_get_version_string(void) ;
#line 54 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/hocr.c"
ho_bitmap *hocr_image_processing(ho_pixbuf const   *pix_in , unsigned char const   scale ,
                                 unsigned char const   no_auto_scale , double rotate ,
                                 unsigned char const   no_auto_rotate , unsigned char const   adaptive ,
                                 unsigned char const   threshold , unsigned char const   a_threshold ,
                                 int *progress ) 
{ 
  ho_bitmap *bitmap_out ;
  ho_bitmap *bitmap_temp ;
  double angle ;
  int scale_by ;
  unsigned char size ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 64
  bitmap_out = (ho_bitmap *)((void *)0);
#line 66
  bitmap_temp = (ho_bitmap *)((void *)0);
#line 68
  angle = 0.0;
#line 70
  scale_by = 0;
#line 72
  size = (unsigned char)0;
#line 75
  *progress = 0;
#line 78
  bitmap_temp = ho_pixbuf_to_bitmap_wrapper(pix_in, scale, adaptive, threshold, a_threshold,
                                            (unsigned char const   )size);
  }
#line 80
  if (! bitmap_temp) {
#line 81
    return ((ho_bitmap *)((void *)0));
  }
#line 84
  *progress = 25;
#line 87
  if (! scale) {
#line 87
    if (! no_auto_scale) {
      {
#line 90
      tmp = ho_dimentions_font_width_height_nikud(bitmap_temp, (int const   )6, (int const   )200,
                                                  (int const   )6, (int const   )200);
      }
#line 90
      if (tmp) {
#line 91
        return ((ho_bitmap *)((void *)0));
      }
#line 94
      if (bitmap_temp->font_height < 15) {
#line 95
        scale_by = 3;
      } else
#line 96
      if (bitmap_temp->font_height < 30) {
#line 97
        scale_by = 2;
      } else {
#line 99
        scale_by = 1;
      }
#line 101
      if (scale_by > 1) {
        {
#line 104
        ho_bitmap_free(bitmap_temp);
#line 105
        bitmap_temp = ho_pixbuf_to_bitmap_wrapper(pix_in, (unsigned char const   )scale_by,
                                                  adaptive, threshold, a_threshold,
                                                  (unsigned char const   )size);
        }
#line 107
        if (! bitmap_temp) {
#line 108
          return ((ho_bitmap *)((void *)0));
        }
      }
    }
  }
  {
#line 113
  *progress = 50;
#line 116
  bitmap_out = ho_bitmap_filter_by_size((ho_bitmap const   *)bitmap_temp, 3, (3 * bitmap_temp->height) / 4,
                                        3, (3 * bitmap_temp->width) / 4);
#line 119
  ho_bitmap_free(bitmap_temp);
  }
#line 120
  if (! bitmap_out) {
#line 121
    return ((ho_bitmap *)((void *)0));
  }
#line 124
  *progress = 75;
#line 127
  if (rotate) {
    {
#line 129
    bitmap_temp = ho_bitmap_rotate((ho_bitmap const   *)bitmap_out, (double const   )rotate);
#line 130
    ho_bitmap_free(bitmap_out);
    }
#line 131
    if (! bitmap_temp) {
#line 132
      return ((ho_bitmap *)((void *)0));
    }
#line 134
    bitmap_out = bitmap_temp;
  } else
#line 136
  if (! no_auto_rotate) {
    {
#line 139
    tmp___0 = ho_dimentions_font_width_height_nikud(bitmap_out, (int const   )6, (int const   )200,
                                                    (int const   )6, (int const   )200);
    }
#line 139
    if (tmp___0) {
#line 140
      return ((ho_bitmap *)((void *)0));
    }
    {
#line 142
    angle = ho_dimentions_get_lines_angle((ho_bitmap const   *)bitmap_out);
    }
#line 143
    if (angle) {
      {
#line 145
      bitmap_temp = ho_bitmap_rotate((ho_bitmap const   *)bitmap_out, (double const   )angle);
#line 146
      ho_bitmap_free(bitmap_out);
      }
#line 147
      if (! bitmap_temp) {
#line 148
        return ((ho_bitmap *)((void *)0));
      }
#line 150
      bitmap_out = bitmap_temp;
    }
  }
#line 154
  return (bitmap_out);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/hocr.c"
ho_layout *hocr_layout_analysis(ho_bitmap const   *m_in , int const   font_spacing_code ,
                                int const   paragraph_setup , int const   slicing_threshold ,
                                int const   slicing_width , int const   line_leeway ,
                                unsigned char const   dir_ltr , int *progress ) 
{ 
  int cols ;
  int block_index ;
  int line_index ;
  int word_index ;
  ho_layout *layout_out ;

  {
#line 174
  cols = (int )paragraph_setup;
#line 182
  layout_out = (ho_layout *)((void *)0);
#line 185
  *progress = 0;
#line 188
  if (! cols) {
    {
#line 189
    cols = ho_dimentions_get_columns(m_in);
    }
  }
  {
#line 192
  layout_out = ho_layout_new(m_in, (char const   )font_spacing_code, (unsigned char const   )cols,
                             dir_ltr);
  }
#line 193
  if (! layout_out) {
#line 194
    return ((ho_layout *)((void *)0));
  }
  {
#line 196
  *progress = 10;
#line 197
  ho_layout_create_block_mask(layout_out);
#line 200
  block_index = 0;
  }
  {
#line 200
  while (1) {
    while_continue: /* CIL Label */ ;
#line 200
    if (! (block_index < layout_out->n_blocks)) {
#line 200
      goto while_break;
    }
    {
#line 202
    ho_layout_create_line_mask(layout_out, (int const   )block_index);
#line 205
    line_index = 0;
    }
    {
#line 205
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 205
      if (! (line_index < *(layout_out->n_lines + block_index))) {
#line 205
        goto while_break___0;
      }
      {
#line 208
      ho_layout_create_word_mask(layout_out, (int const   )block_index, (int const   )line_index);
#line 211
      word_index = 0;
      }
      {
#line 211
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 211
        if (! (word_index < *(*(layout_out->n_words + block_index) + line_index))) {
#line 211
          goto while_break___1;
        }
        {
#line 214
        ho_layout_create_font_mask(layout_out, (int const   )block_index, (int const   )line_index,
                                   (int const   )word_index, (unsigned char const   )slicing_threshold,
                                   (unsigned char const   )slicing_width, (unsigned char const   )line_leeway);
#line 211
        word_index ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 219
      *progress = (int )((double )100 * ((double )block_index / (double )layout_out->n_blocks + (double )line_index / (double )(*(layout_out->n_lines + block_index) * layout_out->n_blocks)));
#line 205
      line_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    block_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 227
  return (layout_out);
}
}
#line 241 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/hocr.c"
int hocr_font_recognition(ho_layout const   *l_page , ho_string *s_text_out , unsigned char const   html ,
                          int font_code , unsigned char const   nikud , unsigned char do_linguistics ,
                          int *progress ) 
{ 
  int block_index ;
  int line_index ;
  int word_index ;
  int font_index ;
  int current_font_number ;
  int number_of_fonts ;
  ho_bitmap *m_text ;
  ho_bitmap *m_mask ;
  ho_bitmap *m_font_main_sign ;
  ho_bitmap *m_font_nikud ;
  char text_out[200] ;
  char const   *font ;
  char const   *font_nikud ;
  char const   *font_dagesh ;
  char const   *font_shin ;
  int word_length ;
  unsigned char word_end ;
  unsigned char word_start ;
  int last_char_i ;
  int char_i ;

  {
#line 254
  current_font_number = 0;
#line 256
  number_of_fonts = (int )l_page->number_of_fonts;
#line 258
  m_text = (ho_bitmap *)((void *)0);
#line 260
  m_mask = (ho_bitmap *)((void *)0);
#line 262
  m_font_main_sign = (ho_bitmap *)((void *)0);
#line 264
  m_font_nikud = (ho_bitmap *)((void *)0);
#line 277
  *progress = 0;
#line 280
  if (! s_text_out) {
#line 281
    return (-1);
  } else
#line 280
  if (! l_page) {
#line 281
    return (-1);
  }
#line 284
  block_index = 0;
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if (! (block_index < (int )l_page->n_blocks)) {
#line 284
      goto while_break;
    }
#line 287
    if (html) {
      {
#line 290
      sprintf((char */* __restrict  */)(text_out), (char const   */* __restrict  */)"    <div class=\"ocr_par\" id=\"par_%d\" title=\"bbox %d %d %d %d\">\n",
              block_index + 1, (*(l_page->m_blocks_text + block_index))->x, (*(l_page->m_blocks_text + block_index))->y,
              (*(l_page->m_blocks_text + block_index))->x + (*(l_page->m_blocks_text + block_index))->width,
              (*(l_page->m_blocks_text + block_index))->y + (*(l_page->m_blocks_text + block_index))->height);
#line 298
      ho_string_cat(s_text_out, (char const   *)(text_out));
      }
    }
#line 301
    line_index = 0;
    {
#line 301
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 301
      if (! (line_index < *(l_page->n_lines + block_index))) {
#line 301
        goto while_break___0;
      }
#line 307
      word_index = 0;
      {
#line 307
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 307
        if (! (word_index < *(*(l_page->n_words + block_index) + line_index))) {
#line 307
          goto while_break___1;
        }
#line 310
        word_length = *(*(*(l_page->n_fonts + block_index) + line_index) + word_index);
#line 312
        word_end = (unsigned char)0;
#line 314
        word_start = (unsigned char)255;
#line 316
        last_char_i = 0;
#line 318
        char_i = 0;
#line 321
        font_index = 0;
        {
#line 321
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 321
          if (! (font_index < word_length)) {
#line 321
            goto while_break___2;
          }
          {
#line 323
          word_end = (unsigned char )(font_index == word_length - 1);
#line 324
          word_start = (unsigned char )(font_index == 0);
#line 329
          m_text = ho_layout_get_font_text(l_page, block_index, line_index, word_index,
                                           font_index);
          }
#line 332
          if (! m_text) {
#line 333
            return (-1);
          }
          {
#line 336
          m_mask = ho_layout_get_font_line_mask(l_page, block_index, line_index, word_index,
                                                font_index);
          }
#line 339
          if (! m_mask) {
#line 340
            return (-1);
          }
          {
#line 343
          m_font_main_sign = ho_font_main_sign((ho_bitmap const   *)m_text, (ho_bitmap const   *)m_mask);
          }
#line 344
          if (! m_font_main_sign) {
#line 345
            return (-1);
          }
          {
#line 348
          last_char_i = char_i;
#line 349
          font = ho_recognize_font((ho_bitmap const   *)m_font_main_sign, (ho_bitmap const   *)m_mask,
                                   font_code, do_linguistics, word_end, word_start,
                                   & char_i, last_char_i);
#line 355
          ho_string_cat(s_text_out, font);
          }
#line 358
          if (nikud) {
            {
#line 360
            m_font_nikud = ho_bitmap_clone((ho_bitmap const   *)m_text);
            }
#line 361
            if (! m_font_nikud) {
#line 362
              return (-1);
            }
            {
#line 363
            ho_bitmap_andnot(m_font_nikud, (ho_bitmap const   *)m_font_main_sign);
#line 366
            font_nikud = ho_recognize_nikud((ho_bitmap const   *)m_font_nikud, (ho_bitmap const   *)m_mask,
                                            font_code, & font_dagesh, & font_shin);
#line 370
            ho_bitmap_free(m_font_nikud);
#line 371
            m_font_nikud = (ho_bitmap *)((void *)0);
#line 374
            ho_string_cat(s_text_out, font_shin);
#line 375
            ho_string_cat(s_text_out, font_dagesh);
#line 376
            ho_string_cat(s_text_out, font_nikud);
            }
          }
          {
#line 380
          ho_bitmap_free(m_font_main_sign);
#line 381
          ho_bitmap_free(m_text);
#line 382
          ho_bitmap_free(m_mask);
#line 385
          m_font_main_sign = (ho_bitmap *)((void *)0);
#line 385
          m_mask = m_font_main_sign;
#line 385
          m_text = m_mask;
#line 388
          current_font_number ++;
#line 389
          *progress = (100 * current_font_number) / number_of_fonts;
#line 321
          font_index ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 393
        ho_string_cat(s_text_out, " ");
#line 307
        word_index ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 397
      if (html) {
        {
#line 398
        ho_string_cat(s_text_out, "<br/>\n");
        }
      } else {
        {
#line 400
        ho_string_cat(s_text_out, "\n");
        }
      }
#line 301
      line_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 404
    if (html) {
      {
#line 405
      ho_string_cat(s_text_out, "<br/>\n    </div>\n");
      }
    } else {
      {
#line 407
      ho_string_cat(s_text_out, "\n");
      }
    }
#line 284
    block_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 410
  return (0);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/hocr.c"
int hocr_do_ocr_fine(ho_pixbuf const   *pix_in , ho_string *s_text_out , unsigned char const   scale ,
                     unsigned char const   no_auto_scale , double rotate , unsigned char const   no_auto_rotate ,
                     unsigned char const   adaptive , unsigned char const   threshold ,
                     unsigned char const   a_threshold , int const   font_spacing_code ,
                     int const   paragraph_setup , int const   slicing_threshold ,
                     int const   slicing_width , int const   line_leeway , unsigned char const   dir_ltr ,
                     unsigned char const   html , int font_code , unsigned char const   nikud ,
                     unsigned char const   do_linguistics , int *progress ) 
{ 
  ho_bitmap *m_in ;
  ho_layout *l_page ;
  int return_val ;

  {
#line 428
  m_in = (ho_bitmap *)((void *)0);
#line 430
  l_page = (ho_layout *)((void *)0);
#line 434
  if (! pix_in) {
#line 435
    return (-1);
  }
  {
#line 437
  m_in = hocr_image_processing(pix_in, scale, no_auto_scale, rotate, no_auto_rotate,
                               adaptive, threshold, a_threshold, progress);
  }
#line 442
  if (! m_in) {
#line 443
    return (-1);
  }
  {
#line 445
  l_page = hocr_layout_analysis((ho_bitmap const   *)m_in, font_spacing_code, paragraph_setup,
                                slicing_threshold, slicing_width, line_leeway, dir_ltr,
                                progress);
  }
#line 449
  if (! l_page) {
    {
#line 451
    ho_bitmap_free(m_in);
    }
#line 452
    return (-1);
  }
  {
#line 455
  return_val = hocr_font_recognition((ho_layout const   *)l_page, s_text_out, html,
                                     font_code, nikud, (unsigned char )do_linguistics,
                                     progress);
  }
#line 458
  return (return_val);
}
}
#line 461 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/hocr.c"
int hocr_do_ocr(ho_pixbuf const   *pix_in , ho_string *s_text_out , unsigned char const   html ,
                int font_code , unsigned char const   do_linguistics , int *progress ) 
{ 
  int tmp ;

  {
  {
#line 467
  tmp = hocr_do_ocr_fine(pix_in, s_text_out, (unsigned char const   )0, (unsigned char const   )0,
                         (double )0, (unsigned char const   )0, (unsigned char const   )0,
                         (unsigned char const   )0, (unsigned char const   )0, (int const   )0,
                         (int const   )0, (int const   )0, (int const   )0, (int const   )0,
                         (unsigned char const   )0, html, font_code, (unsigned char const   )1,
                         do_linguistics, progress);
  }
#line 467
  return (tmp);
}
}
#line 473 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/hocr.c"
char const   *hocr_get_build_string(void) 
{ 


  {
#line 476
  return ("libhocr-0.10.17-x86_64-unknown-linux-gnu-04032016");
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/hocr.c"
char const   *hocr_get_version_string(void) 
{ 


  {
#line 482
  return ("0.10.17");
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap_hist.h"
ho_bitmap_hist *ho_bitmap_hist_new(int const   width , int const   height ) ;
#line 83
int ho_bitmap_hist_free(ho_bitmap_hist *m ) ;
#line 92
int ho_bitmap_hist_update(ho_bitmap_hist *hist , ho_bitmap const   *m ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap_hist.c"
ho_bitmap_hist *ho_bitmap_hist_new(int const   width , int const   height ) 
{ 
  ho_bitmap_hist *m_new ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 50
  m_new = (ho_bitmap_hist *)((void *)0);
#line 55
  tmp = malloc(sizeof(ho_bitmap_hist ));
#line 55
  m_new = (ho_bitmap_hist *)tmp;
  }
#line 56
  if (! m_new) {
#line 58
    return ((ho_bitmap_hist *)((void *)0));
  }
  {
#line 64
  m_new->fill = 0;
#line 65
  m_new->max_x = 0;
#line 66
  m_new->max_y = 0;
#line 67
  m_new->max_x_index = 0;
#line 68
  m_new->max_y_index = 0;
#line 69
  m_new->width = (int )width;
#line 70
  m_new->height = (int )height;
#line 75
  tmp___0 = calloc((size_t )m_new->width, sizeof(unsigned int ));
#line 75
  m_new->data_x = (unsigned int *)tmp___0;
  }
#line 77
  if (! m_new->data_x) {
    {
#line 79
    free((void *)m_new);
    }
#line 80
    return ((ho_bitmap_hist *)((void *)0));
  }
  {
#line 83
  tmp___1 = calloc((size_t )m_new->height, sizeof(unsigned int ));
#line 83
  m_new->data_y = (unsigned int *)tmp___1;
  }
#line 85
  if (! m_new->data_y) {
    {
#line 87
    free((void *)m_new->data_x);
#line 88
    free((void *)m_new);
    }
#line 89
    return ((ho_bitmap_hist *)((void *)0));
  }
#line 92
  return (m_new);
}
}
#line 95 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap_hist.c"
int ho_bitmap_hist_free(ho_bitmap_hist *m ) 
{ 


  {
#line 98
  if (! m) {
#line 99
    return (-1);
  }
#line 101
  if (m->data_x) {
    {
#line 102
    free((void *)m->data_x);
    }
  }
#line 104
  if (m->data_y) {
    {
#line 105
    free((void *)m->data_y);
    }
  }
  {
#line 107
  free((void *)m);
  }
#line 109
  return (0);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_bitmap_hist.c"
int ho_bitmap_hist_update(ho_bitmap_hist *hist , ho_bitmap const   *m ) 
{ 
  int x ;
  int y ;
  int tmp ;

  {
#line 118
  if (! hist) {
#line 119
    return (-1);
  } else
#line 118
  if (! m) {
#line 119
    return (-1);
  }
#line 122
  if (hist->width != (int )m->width) {
#line 123
    return (-1);
  } else
#line 122
  if (hist->height != (int )m->height) {
#line 123
    return (-1);
  }
#line 125
  hist->fill = 0;
#line 126
  hist->max_x = 0;
#line 127
  hist->max_y = 0;
#line 128
  hist->max_x_index = 0;
#line 129
  hist->max_y_index = 0;
#line 132
  x = 0;
  {
#line 132
  while (1) {
    while_continue: /* CIL Label */ ;
#line 132
    if (! (x < hist->width)) {
#line 132
      goto while_break;
    }
#line 133
    *(hist->data_x + x) = 0U;
#line 132
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  y = 0;
  {
#line 134
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 134
    if (! (y < hist->height)) {
#line 134
      goto while_break___0;
    }
#line 135
    *(hist->data_y + y) = 0U;
#line 134
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 138
  x = 0;
  {
#line 138
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 138
    if (! (x < hist->width)) {
#line 138
      goto while_break___1;
    }
#line 139
    y = 0;
    {
#line 139
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 139
      if (! (y < hist->height)) {
#line 139
        goto while_break___2;
      }
#line 142
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 142
        tmp = 1;
      } else {
#line 142
        tmp = 0;
      }
#line 142
      if (tmp) {
#line 144
        (hist->fill) ++;
#line 145
        (*(hist->data_x + x)) ++;
#line 146
        (*(hist->data_y + y)) ++;
#line 148
        if (*(hist->data_x + x) > (unsigned int )hist->max_x) {
#line 150
          hist->max_x = (int )*(hist->data_x + x);
#line 151
          hist->max_x_index = x;
        }
#line 154
        if (*(hist->data_y + y) > (unsigned int )hist->max_y) {
#line 156
          hist->max_y = (int )*(hist->data_y + y);
#line 157
          hist->max_y_index = y;
        }
      }
#line 139
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 138
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 162
  return (0);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.h"
double ho_recognize_font_3_zero(double const   *array_in ) ;
#line 36
double ho_recognize_font_3_one(double const   *array_in ) ;
#line 38
double ho_recognize_font_3_two(double const   *array_in ) ;
#line 40
double ho_recognize_font_3_three(double const   *array_in ) ;
#line 42
double ho_recognize_font_3_four(double const   *array_in ) ;
#line 44
double ho_recognize_font_3_five(double const   *array_in ) ;
#line 46
double ho_recognize_font_3_six(double const   *array_in ) ;
#line 48
double ho_recognize_font_3_seven(double const   *array_in ) ;
#line 50
double ho_recognize_font_3_eight(double const   *array_in ) ;
#line 52
double ho_recognize_font_3_nine(double const   *array_in ) ;
#line 54
double ho_recognize_font_3_dot(double const   *array_in ) ;
#line 56
double ho_recognize_font_3_comma(double const   *array_in ) ;
#line 58
double ho_recognize_font_3_open(double const   *array_in ) ;
#line 60
double ho_recognize_font_3_close(double const   *array_in ) ;
#line 62
double ho_recognize_font_3_minus(double const   *array_in ) ;
#line 64
double ho_recognize_font_3_plus(double const   *array_in ) ;
#line 66
double ho_recognize_font_3_div(double const   *array_in ) ;
#line 68
double ho_recognize_font_3_tag(double const   *array_in ) ;
#line 70
double ho_recognize_font_3_two_tags(double const   *array_in ) ;
#line 72
double ho_recognize_font_3_question(double const   *array_in ) ;
#line 74
double ho_recognize_font_3_exclem(double const   *array_in ) ;
#line 76
double ho_recognize_font_3_dot_dot(double const   *array_in ) ;
#line 78
double ho_recognize_font_3_dot_comma(double const   *array_in ) ;
#line 80
double ho_recognize_font_3_alef(double const   *array_in ) ;
#line 82
double ho_recognize_font_3_bet(double const   *array_in ) ;
#line 84
double ho_recognize_font_3_gimal(double const   *array_in ) ;
#line 86
double ho_recognize_font_3_dalet(double const   *array_in ) ;
#line 88
double ho_recognize_font_3_hey(double const   *array_in ) ;
#line 90
double ho_recognize_font_3_vav(double const   *array_in ) ;
#line 92
double ho_recognize_font_3_zayin(double const   *array_in ) ;
#line 94
double ho_recognize_font_3_het(double const   *array_in ) ;
#line 96
double ho_recognize_font_3_tet(double const   *array_in ) ;
#line 98
double ho_recognize_font_3_yud(double const   *array_in ) ;
#line 100
double ho_recognize_font_3_caf(double const   *array_in ) ;
#line 102
double ho_recognize_font_3_caf_sofit(double const   *array_in ) ;
#line 104
double ho_recognize_font_3_lamed(double const   *array_in ) ;
#line 106
double ho_recognize_font_3_mem(double const   *array_in ) ;
#line 108
double ho_recognize_font_3_mem_sofit(double const   *array_in ) ;
#line 110
double ho_recognize_font_3_nun(double const   *array_in ) ;
#line 112
double ho_recognize_font_3_nun_sofit(double const   *array_in ) ;
#line 114
double ho_recognize_font_3_samech(double const   *array_in ) ;
#line 116
double ho_recognize_font_3_ayin(double const   *array_in ) ;
#line 118
double ho_recognize_font_3_pey(double const   *array_in ) ;
#line 120
double ho_recognize_font_3_pey_sofit(double const   *array_in ) ;
#line 122
double ho_recognize_font_3_tzadi(double const   *array_in ) ;
#line 124
double ho_recognize_font_3_tzadi_sofit(double const   *array_in ) ;
#line 126
double ho_recognize_font_3_kuf(double const   *array_in ) ;
#line 128
double ho_recognize_font_3_resh(double const   *array_in ) ;
#line 130
double ho_recognize_font_3_shin(double const   *array_in ) ;
#line 132
double ho_recognize_font_3_tav(double const   *array_in ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_zero(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 56
  return_value = 0.0;
#line 58
  return (return_value);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_one(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 64
  return_value = 0.0;
#line 66
  return (return_value);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_two(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 72
  return_value = 0.0;
#line 74
  return (return_value);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_three(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 80
  return_value = 0.0;
#line 82
  return (return_value);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_four(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 88
  return_value = 0.0;
#line 90
  return (return_value);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_five(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 96
  return_value = 0.0;
#line 98
  return (return_value);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_six(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 104
  return_value = 0.0;
#line 106
  return (return_value);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_seven(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 112
  return_value = 0.0;
#line 114
  return (return_value);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_eight(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 120
  return_value = 0.0;
#line 122
  return (return_value);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_nine(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 128
  return_value = 0.0;
#line 130
  return (return_value);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 136
  return_value = 0.0;
#line 138
  return (return_value);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 144
  return_value = 0.0;
#line 146
  return (return_value);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_minus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 152
  return_value = 0.0;
#line 154
  return (return_value);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_plus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 160
  return_value = 0.0;
#line 162
  return (return_value);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_div(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 168
  return_value = 0.0;
#line 170
  return (return_value);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_open(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 176
  return_value = 0.0;
#line 178
  return (return_value);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_close(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 184
  return_value = 0.0;
#line 186
  return (return_value);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_tag(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 192
  return_value = 0.0;
#line 194
  return (return_value);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_two_tags(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 200
  return_value = 0.0;
#line 202
  return (return_value);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_question(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 208
  return_value = 0.0;
#line 210
  return (return_value);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_exclem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 216
  return_value = 0.0;
#line 218
  return (return_value);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_dot_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 224
  return_value = 0.0;
#line 226
  return (return_value);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_dot_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 232
  return_value = 0.0;
#line 234
  return (return_value);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_alef(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 240
  return_value = 0.0;
#line 242
  return (return_value);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_bet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 248
  return_value = 0.0;
#line 250
  return (return_value);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_gimal(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 256
  return_value = 0.0;
#line 258
  return (return_value);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_dalet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 264
  return_value = 0.0;
#line 266
  return (return_value);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_hey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 272
  return_value = 0.0;
#line 274
  return (return_value);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_vav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 280
  return_value = 0.0;
#line 282
  return (return_value);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_zayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 288
  return_value = 0.0;
#line 290
  return (return_value);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_het(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 296
  return_value = 0.0;
#line 298
  return (return_value);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_tet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 304
  return_value = 0.0;
#line 306
  return (return_value);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_yud(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 312
  return_value = 0.0;
#line 314
  return (return_value);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_caf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 320
  return_value = 0.0;
#line 322
  return (return_value);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_caf_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 328
  return_value = 0.0;
#line 330
  return (return_value);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_lamed(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 336
  return_value = 0.0;
#line 338
  return (return_value);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_mem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 344
  return_value = 0.0;
#line 346
  return (return_value);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_mem_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 352
  return_value = 0.0;
#line 354
  return (return_value);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_nun(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 360
  return_value = 0.0;
#line 362
  return (return_value);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_nun_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 368
  return_value = 0.0;
#line 370
  return (return_value);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_samech(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 376
  return_value = 0.0;
#line 378
  return (return_value);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_ayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 384
  return_value = 0.0;
#line 386
  return (return_value);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_pey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 392
  return_value = 0.0;
#line 394
  return (return_value);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_pey_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 400
  return_value = 0.0;
#line 402
  return (return_value);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_tzadi(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 408
  return_value = 0.0;
#line 410
  return (return_value);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_tzadi_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 416
  return_value = 0.0;
#line 418
  return (return_value);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_kuf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 424
  return_value = 0.0;
#line 426
  return (return_value);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_resh(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 432
  return_value = 0.0;
#line 434
  return (return_value);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_shin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 440
  return_value = 0.0;
#line 442
  return (return_value);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_3.c"
double ho_recognize_font_3_tav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 448
  return_value = 0.0;
#line 450
  return (return_value);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.h"
double ho_recognize_font_5_zero(double const   *array_in ) ;
#line 36
double ho_recognize_font_5_one(double const   *array_in ) ;
#line 38
double ho_recognize_font_5_two(double const   *array_in ) ;
#line 40
double ho_recognize_font_5_three(double const   *array_in ) ;
#line 42
double ho_recognize_font_5_four(double const   *array_in ) ;
#line 44
double ho_recognize_font_5_five(double const   *array_in ) ;
#line 46
double ho_recognize_font_5_six(double const   *array_in ) ;
#line 48
double ho_recognize_font_5_seven(double const   *array_in ) ;
#line 50
double ho_recognize_font_5_eight(double const   *array_in ) ;
#line 52
double ho_recognize_font_5_nine(double const   *array_in ) ;
#line 54
double ho_recognize_font_5_dot(double const   *array_in ) ;
#line 56
double ho_recognize_font_5_comma(double const   *array_in ) ;
#line 58
double ho_recognize_font_5_open(double const   *array_in ) ;
#line 60
double ho_recognize_font_5_close(double const   *array_in ) ;
#line 62
double ho_recognize_font_5_minus(double const   *array_in ) ;
#line 64
double ho_recognize_font_5_plus(double const   *array_in ) ;
#line 66
double ho_recognize_font_5_div(double const   *array_in ) ;
#line 68
double ho_recognize_font_5_tag(double const   *array_in ) ;
#line 70
double ho_recognize_font_5_two_tags(double const   *array_in ) ;
#line 72
double ho_recognize_font_5_question(double const   *array_in ) ;
#line 74
double ho_recognize_font_5_exclem(double const   *array_in ) ;
#line 76
double ho_recognize_font_5_dot_dot(double const   *array_in ) ;
#line 78
double ho_recognize_font_5_dot_comma(double const   *array_in ) ;
#line 80
double ho_recognize_font_5_alef(double const   *array_in ) ;
#line 82
double ho_recognize_font_5_bet(double const   *array_in ) ;
#line 84
double ho_recognize_font_5_gimal(double const   *array_in ) ;
#line 86
double ho_recognize_font_5_dalet(double const   *array_in ) ;
#line 88
double ho_recognize_font_5_hey(double const   *array_in ) ;
#line 90
double ho_recognize_font_5_vav(double const   *array_in ) ;
#line 92
double ho_recognize_font_5_zayin(double const   *array_in ) ;
#line 94
double ho_recognize_font_5_het(double const   *array_in ) ;
#line 96
double ho_recognize_font_5_tet(double const   *array_in ) ;
#line 98
double ho_recognize_font_5_yud(double const   *array_in ) ;
#line 100
double ho_recognize_font_5_caf(double const   *array_in ) ;
#line 102
double ho_recognize_font_5_caf_sofit(double const   *array_in ) ;
#line 104
double ho_recognize_font_5_lamed(double const   *array_in ) ;
#line 106
double ho_recognize_font_5_mem(double const   *array_in ) ;
#line 108
double ho_recognize_font_5_mem_sofit(double const   *array_in ) ;
#line 110
double ho_recognize_font_5_nun(double const   *array_in ) ;
#line 112
double ho_recognize_font_5_nun_sofit(double const   *array_in ) ;
#line 114
double ho_recognize_font_5_samech(double const   *array_in ) ;
#line 116
double ho_recognize_font_5_ayin(double const   *array_in ) ;
#line 118
double ho_recognize_font_5_pey(double const   *array_in ) ;
#line 120
double ho_recognize_font_5_pey_sofit(double const   *array_in ) ;
#line 122
double ho_recognize_font_5_tzadi(double const   *array_in ) ;
#line 124
double ho_recognize_font_5_tzadi_sofit(double const   *array_in ) ;
#line 126
double ho_recognize_font_5_kuf(double const   *array_in ) ;
#line 128
double ho_recognize_font_5_resh(double const   *array_in ) ;
#line 130
double ho_recognize_font_5_shin(double const   *array_in ) ;
#line 132
double ho_recognize_font_5_tav(double const   *array_in ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_zero(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 56
  return_value = 0.0;
#line 58
  return (return_value);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_one(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 64
  return_value = 0.0;
#line 66
  return (return_value);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_two(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 72
  return_value = 0.0;
#line 74
  return (return_value);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_three(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 80
  return_value = 0.0;
#line 82
  return (return_value);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_four(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 88
  return_value = 0.0;
#line 90
  return (return_value);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_five(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 96
  return_value = 0.0;
#line 98
  return (return_value);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_six(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 104
  return_value = 0.0;
#line 106
  return (return_value);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_seven(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 112
  return_value = 0.0;
#line 114
  return (return_value);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_eight(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 120
  return_value = 0.0;
#line 122
  return (return_value);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_nine(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 128
  return_value = 0.0;
#line 130
  return (return_value);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 136
  return_value = 0.0;
#line 138
  return (return_value);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 144
  return_value = 0.0;
#line 146
  return (return_value);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_minus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 152
  return_value = 0.0;
#line 154
  return (return_value);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_plus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 160
  return_value = 0.0;
#line 162
  return (return_value);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_div(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 168
  return_value = 0.0;
#line 170
  return (return_value);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_open(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 176
  return_value = 0.0;
#line 178
  return (return_value);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_close(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 184
  return_value = 0.0;
#line 186
  return (return_value);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_tag(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 192
  return_value = 0.0;
#line 194
  return (return_value);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_two_tags(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 200
  return_value = 0.0;
#line 202
  return (return_value);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_question(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 208
  return_value = 0.0;
#line 210
  return (return_value);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_exclem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 216
  return_value = 0.0;
#line 218
  return (return_value);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_dot_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 224
  return_value = 0.0;
#line 226
  return (return_value);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_dot_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 232
  return_value = 0.0;
#line 234
  return (return_value);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_alef(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 240
  return_value = 0.0;
#line 242
  return (return_value);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_bet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 248
  return_value = 0.0;
#line 250
  return (return_value);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_gimal(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 256
  return_value = 0.0;
#line 258
  return (return_value);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_dalet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 264
  return_value = 0.0;
#line 266
  return (return_value);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_hey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 272
  return_value = 0.0;
#line 274
  return (return_value);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_vav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 280
  return_value = 0.0;
#line 282
  return (return_value);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_zayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 288
  return_value = 0.0;
#line 290
  return (return_value);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_het(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 296
  return_value = 0.0;
#line 298
  return (return_value);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_tet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 304
  return_value = 0.0;
#line 306
  return (return_value);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_yud(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 312
  return_value = 0.0;
#line 314
  return (return_value);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_caf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 320
  return_value = 0.0;
#line 322
  return (return_value);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_caf_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 328
  return_value = 0.0;
#line 330
  return (return_value);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_lamed(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 336
  return_value = 0.0;
#line 338
  return (return_value);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_mem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 344
  return_value = 0.0;
#line 346
  return (return_value);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_mem_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 352
  return_value = 0.0;
#line 354
  return (return_value);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_nun(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 360
  return_value = 0.0;
#line 362
  return (return_value);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_nun_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 368
  return_value = 0.0;
#line 370
  return (return_value);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_samech(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 376
  return_value = 0.0;
#line 378
  return (return_value);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_ayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 384
  return_value = 0.0;
#line 386
  return (return_value);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_pey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 392
  return_value = 0.0;
#line 394
  return (return_value);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_pey_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 400
  return_value = 0.0;
#line 402
  return (return_value);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_tzadi(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 408
  return_value = 0.0;
#line 410
  return (return_value);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_tzadi_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 416
  return_value = 0.0;
#line 418
  return (return_value);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_kuf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 424
  return_value = 0.0;
#line 426
  return (return_value);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_resh(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 432
  return_value = 0.0;
#line 434
  return (return_value);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_shin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 440
  return_value = 0.0;
#line 442
  return (return_value);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_5.c"
double ho_recognize_font_5_tav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 448
  return_value = 0.0;
#line 450
  return (return_value);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.h"
double ho_recognize_font_1_zero(double const   *array_in ) ;
#line 36
double ho_recognize_font_1_one(double const   *array_in ) ;
#line 38
double ho_recognize_font_1_two(double const   *array_in ) ;
#line 40
double ho_recognize_font_1_three(double const   *array_in ) ;
#line 42
double ho_recognize_font_1_four(double const   *array_in ) ;
#line 44
double ho_recognize_font_1_five(double const   *array_in ) ;
#line 46
double ho_recognize_font_1_six(double const   *array_in ) ;
#line 48
double ho_recognize_font_1_seven(double const   *array_in ) ;
#line 50
double ho_recognize_font_1_eight(double const   *array_in ) ;
#line 52
double ho_recognize_font_1_nine(double const   *array_in ) ;
#line 54
double ho_recognize_font_1_dot(double const   *array_in ) ;
#line 56
double ho_recognize_font_1_comma(double const   *array_in ) ;
#line 58
double ho_recognize_font_1_open(double const   *array_in ) ;
#line 60
double ho_recognize_font_1_close(double const   *array_in ) ;
#line 62
double ho_recognize_font_1_minus(double const   *array_in ) ;
#line 64
double ho_recognize_font_1_plus(double const   *array_in ) ;
#line 66
double ho_recognize_font_1_div(double const   *array_in ) ;
#line 68
double ho_recognize_font_1_tag(double const   *array_in ) ;
#line 70
double ho_recognize_font_1_two_tags(double const   *array_in ) ;
#line 72
double ho_recognize_font_1_question(double const   *array_in ) ;
#line 74
double ho_recognize_font_1_exclem(double const   *array_in ) ;
#line 76
double ho_recognize_font_1_dot_dot(double const   *array_in ) ;
#line 78
double ho_recognize_font_1_dot_comma(double const   *array_in ) ;
#line 80
double ho_recognize_font_1_alef(double const   *array_in ) ;
#line 82
double ho_recognize_font_1_bet(double const   *array_in ) ;
#line 84
double ho_recognize_font_1_gimal(double const   *array_in ) ;
#line 86
double ho_recognize_font_1_dalet(double const   *array_in ) ;
#line 88
double ho_recognize_font_1_hey(double const   *array_in ) ;
#line 90
double ho_recognize_font_1_vav(double const   *array_in ) ;
#line 92
double ho_recognize_font_1_zayin(double const   *array_in ) ;
#line 94
double ho_recognize_font_1_het(double const   *array_in ) ;
#line 96
double ho_recognize_font_1_tet(double const   *array_in ) ;
#line 98
double ho_recognize_font_1_yud(double const   *array_in ) ;
#line 100
double ho_recognize_font_1_caf(double const   *array_in ) ;
#line 102
double ho_recognize_font_1_caf_sofit(double const   *array_in ) ;
#line 104
double ho_recognize_font_1_lamed(double const   *array_in ) ;
#line 106
double ho_recognize_font_1_mem(double const   *array_in ) ;
#line 108
double ho_recognize_font_1_mem_sofit(double const   *array_in ) ;
#line 110
double ho_recognize_font_1_nun(double const   *array_in ) ;
#line 112
double ho_recognize_font_1_nun_sofit(double const   *array_in ) ;
#line 114
double ho_recognize_font_1_samech(double const   *array_in ) ;
#line 116
double ho_recognize_font_1_ayin(double const   *array_in ) ;
#line 118
double ho_recognize_font_1_pey(double const   *array_in ) ;
#line 120
double ho_recognize_font_1_pey_sofit(double const   *array_in ) ;
#line 122
double ho_recognize_font_1_tzadi(double const   *array_in ) ;
#line 124
double ho_recognize_font_1_tzadi_sofit(double const   *array_in ) ;
#line 126
double ho_recognize_font_1_kuf(double const   *array_in ) ;
#line 128
double ho_recognize_font_1_resh(double const   *array_in ) ;
#line 130
double ho_recognize_font_1_shin(double const   *array_in ) ;
#line 132
double ho_recognize_font_1_tav(double const   *array_in ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_zero(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 56
  return_value = 0.0;
#line 58
  return (return_value);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_one(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 64
  return_value = 0.0;
#line 66
  return (return_value);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_two(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 72
  return_value = 0.0;
#line 74
  return (return_value);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_three(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 80
  return_value = 0.0;
#line 82
  return (return_value);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_four(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 88
  return_value = 0.0;
#line 90
  return (return_value);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_five(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 96
  return_value = 0.0;
#line 98
  return (return_value);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_six(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 104
  return_value = 0.0;
#line 106
  return (return_value);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_seven(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 112
  return_value = 0.0;
#line 114
  return (return_value);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_eight(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 120
  return_value = 0.0;
#line 122
  return (return_value);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_nine(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 128
  return_value = 0.0;
#line 130
  return (return_value);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 136
  return_value = 0.0;
#line 138
  if (*(array_in + 3) < (double const   )0.3) {
#line 139
    return_value += 0.1;
  }
#line 140
  if (*(array_in + 4) < (double const   )0.53) {
#line 140
    if (*(array_in + 4) > (double const   )0.47) {
#line 141
      return_value += 0.2;
    }
  }
#line 142
  if (*(array_in + 1) < (double const   )0.3) {
#line 143
    return_value += 0.1;
  }
#line 144
  if (*(array_in + 0) < (double const   )0.3) {
#line 145
    return_value += 0.2;
  }
#line 147
  if (*(array_in + 27)) {
#line 148
    return_value -= 0.3;
  }
#line 149
  if (*(array_in + 1) > (double const   )0.3) {
#line 150
    return_value -= 0.3;
  }
#line 151
  if (*(array_in + 0) > (double const   )0.36) {
#line 152
    return_value -= 0.3;
  }
#line 153
  if (*(array_in + 3) > (double const   )0.3) {
#line 154
    return_value -= 0.3;
  }
#line 156
  return (return_value);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 162
  return_value = 0.0;
#line 164
  if (*(array_in + 3) < (double const   )0.3) {
#line 165
    return_value += 0.1;
  }
#line 166
  if (*(array_in + 4) < (double const   )0.53) {
#line 166
    if (*(array_in + 4) > (double const   )0.47) {
#line 167
      return_value += 0.2;
    }
  }
#line 168
  if (*(array_in + 1) < (double const   )0.3) {
#line 169
    return_value += 0.1;
  }
#line 170
  if (*(array_in + 0) < (double const   )0.36) {
#line 171
    return_value += 0.2;
  }
#line 172
  if (*(array_in + 27)) {
#line 173
    return_value += 0.2;
  }
#line 175
  if (*(array_in + 1) > (double const   )0.3) {
#line 176
    return_value -= 0.3;
  }
#line 177
  if (*(array_in + 0) > (double const   )0.36) {
#line 178
    return_value -= 0.3;
  }
#line 179
  if (*(array_in + 3) > (double const   )0.3) {
#line 180
    return_value -= 0.3;
  }
#line 181
  if (*(array_in + 4) > (double const   )0.55) {
#line 182
    return_value -= 0.2;
  }
#line 184
  return (return_value);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_minus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 190
  return_value = 0.0;
#line 192
  if (*(array_in + 0) < (double const   )0.15) {
#line 193
    return_value += 0.2;
  }
#line 194
  if (*(array_in + 3) < (double const   )0.3) {
#line 195
    return_value += 0.2;
  }
#line 196
  if (*(array_in + 4) > (double const   )0.7) {
#line 197
    return_value += 0.2;
  }
#line 198
  if (*(array_in + 2) == (double const   )1.0) {
#line 198
    if (*(array_in + 0) < (double const   )0.1) {
#line 199
      return_value += 0.2;
    }
  }
#line 201
  if (*(array_in + 0) > (double const   )0.2) {
#line 202
    return_value -= 0.3;
  }
#line 203
  if (*(array_in + 1) < (double const   )0.15) {
#line 204
    return_value -= 0.3;
  }
#line 205
  if (*(array_in + 2) < (double const   )0.1) {
#line 206
    return_value -= 0.3;
  }
#line 208
  return (return_value);
}
}
#line 211 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_plus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 214
  return_value = 0.0;
#line 216
  return (return_value);
}
}
#line 219 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_div(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 222
  return_value = 0.0;
#line 224
  if (*(array_in + 24)) {
#line 225
    return_value += 0.1;
  }
#line 226
  if (*(array_in + 7) < (double const   )0.32) {
#line 227
    return_value += 0.1;
  }
#line 228
  if (*(array_in + 5) > (double const   )0.8) {
#line 229
    return_value += 0.1;
  }
#line 230
  if (*(array_in + 12) > (double const   )0.9) {
#line 231
    return_value += 0.1;
  }
#line 232
  if (*(array_in + 10) < (double const   )0.11) {
#line 233
    return_value += 0.1;
  }
#line 235
  if (*(array_in + 23)) {
#line 236
    return_value -= 0.2;
  }
#line 237
  if (*(array_in + 7) > (double const   )0.4) {
#line 238
    return_value -= 0.2;
  }
#line 239
  if (*(array_in + 5) < (double const   )0.7) {
#line 240
    return_value -= 0.2;
  }
#line 241
  if (*(array_in + 12) < (double const   )0.8) {
#line 242
    return_value -= 0.2;
  }
#line 243
  if (*(array_in + 10) > (double const   )0.21) {
#line 244
    return_value -= 0.2;
  }
#line 246
  return (return_value);
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_open(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 252
  return_value = 0.0;
#line 254
  if (*(array_in + 7) < (double const   )0.25) {
#line 255
    return_value += 0.1;
  }
#line 256
  if (*(array_in + 5) > (double const   )0.75) {
#line 257
    return_value += 0.1;
  }
#line 258
  if (*(array_in + 12) < (double const   )0.25) {
#line 259
    return_value += 0.1;
  }
#line 260
  if (*(array_in + 10) > (double const   )0.75) {
#line 261
    return_value += 0.1;
  }
#line 262
  if (*(array_in + 9) > (double const   )0.75) {
#line 263
    return_value += 0.1;
  }
#line 264
  if (*(array_in + 8) < (double const   )0.25) {
#line 265
    return_value += 0.1;
  }
#line 267
  if (*(array_in + 1) > (double const   )0.3) {
#line 268
    return_value -= 0.2;
  }
#line 269
  if (*(array_in + 2) > (double const   )0.35) {
#line 270
    return_value -= 0.2;
  }
#line 271
  if (*(array_in + 22)) {
#line 272
    return_value -= 0.2;
  }
#line 273
  if (*(array_in + 13)) {
#line 274
    return_value -= 0.2;
  }
#line 275
  if (*(array_in + 14)) {
#line 276
    return_value -= 0.2;
  }
#line 277
  if (*(array_in + 31)) {
#line 278
    return_value -= 0.2;
  }
#line 279
  if (*(array_in + 34)) {
#line 280
    return_value -= 0.2;
  }
#line 281
  if (*(array_in + 70)) {
#line 282
    return_value -= 0.2;
  }
#line 283
  if (*(array_in + 71)) {
#line 284
    return_value -= 0.2;
  }
#line 285
  if (*(array_in + 8) > (double const   )0.25) {
#line 286
    return_value -= 0.2;
  }
#line 288
  return (return_value);
}
}
#line 291 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_close(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 294
  return_value = 0.0;
#line 296
  if (*(array_in + 7) > (double const   )0.75) {
#line 297
    return_value += 0.1;
  }
#line 298
  if (*(array_in + 5) < (double const   )0.25) {
#line 299
    return_value += 0.1;
  }
#line 300
  if (*(array_in + 12) > (double const   )0.75) {
#line 301
    return_value += 0.1;
  }
#line 302
  if (*(array_in + 10) < (double const   )0.25) {
#line 303
    return_value += 0.1;
  }
#line 304
  if (*(array_in + 9) < (double const   )0.25) {
#line 305
    return_value += 0.1;
  }
#line 306
  if (*(array_in + 8) > (double const   )0.75) {
#line 307
    return_value += 0.1;
  }
#line 309
  if (*(array_in + 1) > (double const   )0.3) {
#line 310
    return_value -= 0.2;
  }
#line 311
  if (*(array_in + 2) > (double const   )0.35) {
#line 312
    return_value -= 0.2;
  }
#line 313
  if (*(array_in + 20)) {
#line 314
    return_value -= 0.2;
  }
#line 315
  if (*(array_in + 13)) {
#line 316
    return_value -= 0.2;
  }
#line 317
  if (*(array_in + 14)) {
#line 318
    return_value -= 0.2;
  }
#line 319
  if (*(array_in + 33)) {
#line 320
    return_value -= 0.2;
  }
#line 321
  if (*(array_in + 36)) {
#line 322
    return_value -= 0.2;
  }
#line 323
  if (*(array_in + 70)) {
#line 324
    return_value -= 0.2;
  }
#line 325
  if (*(array_in + 71)) {
#line 326
    return_value -= 0.2;
  }
#line 327
  if (*(array_in + 9) > (double const   )0.25) {
#line 328
    return_value -= 0.2;
  }
#line 330
  return (return_value);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_tag(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 336
  return_value = 0.0;
#line 338
  if (*(array_in + 3) < (double const   )0.53) {
#line 338
    if (*(array_in + 3) > (double const   )0.47) {
#line 339
      return_value += 0.1;
    }
  }
#line 340
  if (*(array_in + 4) > (double const   )0.60) {
#line 341
    return_value += 0.15;
  }
#line 342
  if (*(array_in + 1) < (double const   )0.3) {
#line 343
    return_value += 0.1;
  }
#line 344
  if (*(array_in + 0) < (double const   )0.37) {
#line 345
    return_value += 0.15;
  }
#line 346
  if (*(array_in + 5) > (double const   )0.8) {
#line 347
    return_value += 0.2;
  }
#line 348
  if (*(array_in + 33)) {
#line 349
    return_value += 0.1;
  }
#line 351
  if (*(array_in + 25)) {
#line 352
    return_value -= 0.2;
  }
#line 353
  if (*(array_in + 4) < (double const   )0.60) {
#line 354
    return_value -= 0.2;
  }
#line 355
  if (*(array_in + 3) < (double const   )0.3) {
#line 356
    return_value -= 0.2;
  }
#line 357
  if (*(array_in + 1) > (double const   )0.23) {
#line 358
    return_value -= 0.3;
  }
#line 359
  if (*(array_in + 2) > (double const   )0.95) {
#line 360
    return_value -= 0.2;
  }
#line 362
  return (return_value);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_two_tags(double const   *array_in ) 
{ 
  int count_edges_top ;
  int count_edges_bottom ;
  double return_value ;

  {
#line 370
  return_value = 0.0;
#line 372
  count_edges_top = (int )((*(array_in + 33) * (double const   )10.0 + *(array_in + 32) * (double const   )10.0) + *(array_in + 31) * (double const   )10);
#line 374
  count_edges_bottom = (int )((*(array_in + 36) * (double const   )10.0 + *(array_in + 35) * (double const   )10.0) + *(array_in + 34) * (double const   )10);
#line 377
  if (*(array_in + 3) < (double const   )0.53) {
#line 377
    if (*(array_in + 3) > (double const   )0.45) {
#line 378
      return_value += 0.1;
    }
  }
#line 379
  if (*(array_in + 4) > (double const   )0.60) {
#line 380
    return_value += 0.15;
  }
#line 381
  if (*(array_in + 1) < (double const   )0.8) {
#line 381
    if (*(array_in + 1) > (double const   )0.15) {
#line 382
      return_value += 0.1;
    }
  }
#line 383
  if (*(array_in + 0) < (double const   )0.37) {
#line 384
    return_value += 0.15;
  }
#line 385
  if (*(array_in + 5) > (double const   )0.8) {
#line 386
    return_value += 0.2;
  }
#line 387
  if (*(array_in + 33)) {
#line 388
    return_value += 0.1;
  }
#line 389
  if (count_edges_top == 2) {
#line 390
    return_value += 0.1;
  }
#line 391
  if (count_edges_bottom == 2) {
#line 392
    return_value += 0.1;
  }
#line 394
  if (*(array_in + 25)) {
#line 395
    return_value -= 0.2;
  }
#line 396
  if (*(array_in + 4) < (double const   )0.60) {
#line 397
    return_value -= 0.2;
  }
#line 398
  if (*(array_in + 3) < (double const   )0.3) {
#line 399
    return_value -= 0.2;
  }
#line 400
  if (*(array_in + 1) > (double const   )0.23) {
#line 401
    return_value -= 0.3;
  }
#line 402
  if (count_edges_top != 2) {
#line 403
    return_value -= 0.1;
  }
#line 404
  if (count_edges_bottom != 2) {
#line 405
    return_value -= 0.1;
  }
#line 407
  return (return_value);
}
}
#line 410 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_question(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 413
  return_value = 0.0;
#line 415
  if (*(array_in + 52)) {
#line 416
    return_value += 0.1;
  } else
#line 415
  if (*(array_in + 49)) {
#line 416
    return_value += 0.1;
  }
#line 417
  if (*(array_in + 1) < (double const   )0.3) {
#line 418
    return_value += 0.1;
  }
#line 419
  if (*(array_in + 70)) {
#line 420
    return_value += 0.2;
  }
#line 421
  if (*(array_in + 28)) {
#line 422
    return_value += 0.1;
  } else
#line 421
  if (*(array_in + 29)) {
#line 422
    return_value += 0.1;
  }
#line 424
  if (*(array_in + 54)) {
#line 425
    return_value -= 0.2;
  } else
#line 424
  if (*(array_in + 50)) {
#line 425
    return_value -= 0.2;
  }
#line 426
  if (*(array_in + 19)) {
#line 427
    return_value -= 0.2;
  }
#line 428
  if (! *(array_in + 70)) {
#line 429
    return_value -= 0.1;
  }
#line 430
  if (*(array_in + 4) < (double const   )0.45) {
#line 431
    return_value -= 0.2;
  } else
#line 430
  if (*(array_in + 4) > (double const   )0.60) {
#line 431
    return_value -= 0.2;
  }
#line 432
  if (*(array_in + 3) < (double const   )0.45) {
#line 433
    return_value -= 0.2;
  } else
#line 432
  if (*(array_in + 3) > (double const   )0.58) {
#line 433
    return_value -= 0.2;
  }
#line 435
  return (return_value);
}
}
#line 438 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_exclem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 441
  return_value = 0.0;
#line 443
  if (*(array_in + 2) < (double const   )0.4) {
#line 444
    return_value += 0.1;
  }
#line 445
  if (*(array_in + 1) < (double const   )0.2) {
#line 446
    return_value += 0.1;
  }
#line 447
  if (*(array_in + 70)) {
#line 448
    return_value += 0.2;
  }
#line 450
  if (*(array_in + 2) > (double const   )0.4) {
#line 451
    return_value -= 0.1;
  }
#line 452
  if (*(array_in + 1) > (double const   )0.25) {
#line 453
    return_value -= 0.1;
  }
#line 454
  if (! *(array_in + 70)) {
#line 455
    return_value -= 0.1;
  }
#line 456
  if (*(array_in + 4) < (double const   )0.45) {
#line 457
    return_value -= 0.2;
  } else
#line 456
  if (*(array_in + 4) > (double const   )0.6) {
#line 457
    return_value -= 0.2;
  }
#line 458
  if (*(array_in + 3) < (double const   )0.45) {
#line 459
    return_value -= 0.2;
  } else
#line 458
  if (*(array_in + 3) > (double const   )0.6) {
#line 459
    return_value -= 0.2;
  }
#line 461
  return (return_value);
}
}
#line 464 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_dot_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 467
  return_value = 0.0;
#line 469
  if (*(array_in + 17)) {
#line 470
    return_value += 0.1;
  }
#line 471
  if (*(array_in + 19)) {
#line 472
    return_value += 0.1;
  }
#line 473
  if (*(array_in + 9) > (double const   )0.9) {
#line 473
    if (*(array_in + 8) > (double const   )0.9) {
#line 474
      return_value += 0.1;
    }
  }
#line 475
  if (*(array_in + 2) < (double const   )0.6) {
#line 476
    return_value += 0.1;
  }
#line 477
  if (*(array_in + 70)) {
#line 478
    return_value += 0.2;
  }
#line 480
  if (! *(array_in + 17)) {
#line 481
    return_value -= 0.2;
  }
#line 482
  if (! *(array_in + 19)) {
#line 483
    return_value -= 0.2;
  }
#line 484
  if (! (*(array_in + 9) > (double const   )0.9)) {
#line 485
    return_value -= 0.2;
  } else
#line 484
  if (! (*(array_in + 8) > (double const   )0.9)) {
#line 485
    return_value -= 0.2;
  }
#line 486
  if (*(array_in + 2) > (double const   )0.6) {
#line 487
    return_value -= 0.1;
  }
#line 488
  if (*(array_in + 2) > (double const   )0.4) {
#line 489
    return_value -= 0.1;
  }
#line 490
  if (*(array_in + 1) > (double const   )0.25) {
#line 491
    return_value -= 0.1;
  }
#line 493
  return (return_value);
}
}
#line 496 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_dot_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 499
  return_value = 0.0;
#line 501
  return (return_value);
}
}
#line 504 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_alef(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 507
  return_value = 0.0;
#line 509
  if (*(array_in + 23) > (double const   )0.5) {
#line 510
    return_value += 0.2;
  }
#line 511
  if (*(array_in + 34)) {
#line 512
    return_value += 0.1;
  }
#line 513
  if (*(array_in + 46)) {
#line 514
    return_value += 0.1;
  } else
#line 513
  if (*(array_in + 47)) {
#line 514
    return_value += 0.1;
  }
#line 515
  if (*(array_in + 47)) {
#line 516
    return_value += 0.1;
  }
#line 517
  if (*(array_in + 62)) {
#line 518
    return_value += 0.1;
  }
#line 519
  if (*(array_in + 37)) {
#line 520
    return_value += 0.1;
  } else
#line 519
  if (*(array_in + 38)) {
#line 520
    return_value += 0.1;
  }
#line 521
  if (*(array_in + 41)) {
#line 522
    return_value += 0.1;
  }
#line 523
  if (*(array_in + 55)) {
#line 523
    if (*(array_in + 57)) {
#line 524
      return_value += 0.1;
    }
  }
#line 526
  if (*(array_in + 23) < (double const   )0.5) {
#line 527
    return_value -= 0.1;
  }
#line 528
  if (*(array_in + 1) < (double const   )0.45) {
#line 529
    return_value -= 0.1;
  }
#line 530
  if (*(array_in + 1) < (double const   )0.40) {
#line 531
    return_value -= 0.2;
  } else
#line 530
  if (*(array_in + 0) < (double const   )0.40) {
#line 531
    return_value -= 0.2;
  }
#line 532
  if (*(array_in + 0) > (double const   )0.55) {
#line 533
    return_value -= 0.2;
  }
#line 534
  if (*(array_in + 22)) {
#line 535
    return_value -= 0.1;
  }
#line 536
  if (*(array_in + 19)) {
#line 537
    return_value -= 0.1;
  }
#line 538
  if (*(array_in + 11) == (double const   )1.0) {
#line 539
    return_value -= 0.2;
  }
#line 540
  if (*(array_in + 29)) {
#line 541
    return_value -= 0.1;
  }
#line 543
  return (return_value);
}
}
#line 546 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_bet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 549
  return_value = 0.0;
#line 551
  if (*(array_in + 17)) {
#line 552
    return_value += 0.1;
  }
#line 553
  if (*(array_in + 19)) {
#line 554
    return_value += 0.1;
  }
#line 555
  if (*(array_in + 22)) {
#line 556
    return_value += 0.1;
  }
#line 557
  if (*(array_in + 38)) {
#line 558
    return_value += 0.1;
  }
#line 559
  if (*(array_in + 8) > (double const   )0.9) {
#line 560
    return_value += 0.1;
  }
#line 561
  if (*(array_in + 2) > (double const   )0.8) {
#line 562
    return_value += 0.1;
  }
#line 563
  if (*(array_in + 97)) {
#line 564
    return_value += 0.2;
  }
#line 565
  if (*(array_in + 30)) {
#line 565
    if (*(array_in + 12) < (double const   )0.25) {
#line 566
      return_value += 0.1;
    }
  }
#line 567
  if (*(array_in + 55)) {
#line 567
    if (*(array_in + 49)) {
#line 567
      if (! *(array_in + 51)) {
#line 568
        return_value += 0.1;
      }
    }
  }
#line 570
  if (! *(array_in + 30)) {
#line 571
    return_value -= 0.3;
  }
#line 572
  if (*(array_in + 47)) {
#line 573
    return_value -= 0.3;
  } else
#line 572
  if (*(array_in + 48)) {
#line 573
    return_value -= 0.3;
  }
#line 574
  if (*(array_in + 19) < (double const   )0.5) {
#line 575
    return_value -= 0.2;
  }
#line 576
  if (*(array_in + 20)) {
#line 577
    return_value -= 0.2;
  }
#line 578
  if (*(array_in + 1) < (double const   )0.3) {
#line 579
    return_value -= 0.3;
  }
#line 580
  if (*(array_in + 5) > *(array_in + 10) + (double const   )0.25) {
#line 581
    return_value -= 0.3;
  }
#line 582
  if (*(array_in + 8) < (double const   )0.3) {
#line 583
    return_value -= 0.3;
  }
#line 584
  if (*(array_in + 47)) {
#line 584
    goto _L;
  } else
#line 584
  if (*(array_in + 48)) {
    _L: /* CIL Label */ 
#line 584
    if (*(array_in + 2) < (double const   )0.6) {
#line 585
      return_value -= 0.2;
    }
  }
#line 586
  if (*(array_in + 4) > (double const   )0.57) {
#line 587
    return_value -= 0.20;
  } else
#line 586
  if (*(array_in + 4) < (double const   )43) {
#line 587
    return_value -= 0.20;
  }
#line 588
  if (*(array_in + 2) < (double const   )0.50) {
#line 589
    return_value -= 0.3;
  }
#line 590
  if (*(array_in + 12) > (double const   )0.33) {
#line 591
    return_value -= 0.3;
  }
#line 592
  if (*(array_in + 69)) {
#line 593
    return_value -= 0.2;
  }
#line 595
  return (return_value);
}
}
#line 598 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_gimal(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 601
  return_value = 0.0;
#line 603
  if (*(array_in + 34)) {
#line 604
    return_value += 0.1;
  }
#line 605
  if (*(array_in + 36)) {
#line 606
    return_value += 0.1;
  }
#line 607
  if (*(array_in + 103)) {
#line 608
    return_value += 0.1;
  }
#line 609
  if (*(array_in + 47)) {
#line 610
    return_value += 0.1;
  } else
#line 609
  if (*(array_in + 48)) {
#line 610
    return_value += 0.1;
  }
#line 611
  if (*(array_in + 5) > *(array_in + 10)) {
#line 612
    return_value += 0.1;
  }
#line 613
  if (*(array_in + 7) > *(array_in + 12)) {
#line 614
    return_value += 0.1;
  }
#line 615
  if (*(array_in + 11) > (double const   )0.25) {
#line 615
    if (*(array_in + 11) < (double const   )0.45) {
#line 616
      return_value += 0.1;
    }
  }
#line 617
  if (*(array_in + 5) > *(array_in + 10) + (double const   )0.25) {
#line 618
    return_value += 0.2;
  }
#line 619
  if (*(array_in + 1) < (double const   )0.3) {
#line 620
    return_value += 0.2;
  }
#line 621
  if (*(array_in + 1) < (double const   )0.3) {
#line 621
    if (*(array_in + 19)) {
#line 621
      if (*(array_in + 65) == (double const   )0.1) {
#line 623
        return_value += 0.2;
      } else
#line 621
      if (*(array_in + 66) == (double const   )0.1) {
#line 623
        return_value += 0.2;
      }
    }
  }
#line 625
  if (*(array_in + 11) > (double const   )0.5) {
#line 626
    return_value -= 0.3;
  }
#line 627
  if (*(array_in + 4) > (double const   )0.57) {
#line 628
    return_value -= 0.10;
  } else
#line 627
  if (*(array_in + 4) < (double const   )43) {
#line 628
    return_value -= 0.10;
  }
#line 629
  if (*(array_in + 4) < (double const   )0.43) {
#line 630
    return_value -= 0.3;
  }
#line 631
  if (! *(array_in + 47)) {
#line 631
    if (! *(array_in + 48)) {
#line 632
      return_value -= 0.2;
    }
  }
#line 633
  if (*(array_in + 20)) {
#line 634
    return_value -= 0.3;
  }
#line 635
  if (*(array_in + 1) > (double const   )0.34) {
#line 636
    return_value -= 0.2;
  }
#line 637
  if (*(array_in + 2) > (double const   )0.8) {
#line 638
    return_value -= 0.2;
  }
#line 639
  if (*(array_in + 0) < (double const   )0.3) {
#line 640
    return_value -= 0.3;
  }
#line 641
  if (! *(array_in + 36)) {
#line 642
    return_value -= 0.2;
  }
#line 644
  return (return_value);
}
}
#line 647 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_dalet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 650
  return_value = 0.0;
#line 652
  if (*(array_in + 17)) {
#line 653
    return_value += 0.1;
  }
#line 654
  if (*(array_in + 22)) {
#line 655
    return_value += 0.2;
  } else
#line 654
  if (*(array_in + 21)) {
#line 655
    return_value += 0.2;
  }
#line 656
  if (*(array_in + 28)) {
#line 657
    return_value += 0.1;
  }
#line 658
  if (*(array_in + 95)) {
#line 659
    return_value += 0.1;
  }
#line 660
  if (*(array_in + 36)) {
#line 661
    return_value += 0.1;
  }
#line 662
  if (*(array_in + 8) > (double const   )0.9) {
#line 663
    return_value += 0.1;
  }
#line 665
  if (*(array_in + 19)) {
#line 666
    return_value -= 0.3;
  }
#line 667
  if (*(array_in + 20)) {
#line 668
    return_value -= 0.3;
  }
#line 669
  if (*(array_in + 69)) {
#line 670
    return_value -= 0.3;
  }
#line 671
  if (*(array_in + 4) < (double const   )0.43) {
#line 672
    return_value -= 0.3;
  }
#line 673
  if (! *(array_in + 28)) {
#line 674
    return_value -= 0.2;
  }
#line 675
  if (*(array_in + 4) > (double const   )0.57) {
#line 676
    return_value -= 0.10;
  } else
#line 675
  if (*(array_in + 4) < (double const   )43) {
#line 676
    return_value -= 0.10;
  }
#line 677
  if (*(array_in + 2) < (double const   )0.60) {
#line 678
    return_value -= 0.3;
  }
#line 679
  if (*(array_in + 47)) {
#line 680
    return_value -= 0.3;
  } else
#line 679
  if (*(array_in + 48)) {
#line 680
    return_value -= 0.3;
  }
#line 681
  if (*(array_in + 0) < (double const   )0.35) {
#line 682
    return_value -= 0.3;
  }
#line 683
  if (*(array_in + 10) < (double const   )0.9) {
#line 684
    return_value -= 0.3;
  }
#line 685
  if (*(array_in + 1) < (double const   )0.3) {
#line 686
    return_value -= 0.3;
  }
#line 687
  if (*(array_in + 7) > *(array_in + 12)) {
#line 688
    return_value -= 0.1;
  }
#line 689
  if (*(array_in + 7) > *(array_in + 9)) {
#line 690
    return_value -= 0.1;
  }
#line 692
  return (return_value);
}
}
#line 695 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_hey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 698
  return_value = 0.0;
#line 700
  if (*(array_in + 69)) {
#line 701
    return_value += 0.2;
  }
#line 702
  if (*(array_in + 37)) {
#line 703
    return_value += 0.15;
  } else
#line 702
  if (*(array_in + 38)) {
#line 703
    return_value += 0.15;
  }
#line 704
  if (*(array_in + 17)) {
#line 705
    return_value += 0.1;
  }
#line 706
  if (*(array_in + 22)) {
#line 707
    return_value += 0.1;
  }
#line 709
  if (*(array_in + 4) < (double const   )0.45) {
#line 710
    return_value -= 0.3;
  }
#line 711
  if (*(array_in + 4) > (double const   )0.6) {
#line 712
    return_value -= 0.10;
  } else
#line 711
  if (*(array_in + 4) < (double const   )40) {
#line 712
    return_value -= 0.10;
  }
#line 713
  if (*(array_in + 19)) {
#line 714
    return_value -= 0.2;
  }
#line 715
  if (! *(array_in + 69)) {
#line 716
    return_value -= 0.2;
  }
#line 717
  if (! *(array_in + 17)) {
#line 718
    return_value -= 0.1;
  }
#line 719
  if (*(array_in + 94)) {
#line 720
    return_value -= 0.2;
  }
#line 722
  return (return_value);
}
}
#line 725 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_vav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 728
  return_value = 0.0;
#line 730
  if (*(array_in + 1) < (double const   )0.4) {
#line 731
    return_value += 0.2;
  }
#line 732
  if (*(array_in + 1) < (double const   )0.27) {
#line 733
    return_value += 0.2;
  } else
#line 732
  if (*(array_in + 0) > (double const   )0.40) {
#line 733
    return_value += 0.2;
  }
#line 734
  if (*(array_in + 2) < (double const   )0.53) {
#line 735
    return_value += 0.1;
  }
#line 736
  if (*(array_in + 22)) {
#line 737
    return_value += 0.1;
  } else
#line 736
  if (*(array_in + 21)) {
#line 737
    return_value += 0.1;
  }
#line 738
  if (*(array_in + 4) < (double const   )0.58) {
#line 738
    if (*(array_in + 4) > (double const   )0.42) {
#line 739
      return_value += 0.1;
    }
  }
#line 740
  if (*(array_in + 7) > *(array_in + 9) + (double const   )0.1) {
#line 741
    return_value += 0.1;
  }
#line 742
  if (! *(array_in + 59)) {
#line 742
    if (! *(array_in + 60)) {
#line 743
      return_value += 0.1;
    }
  }
#line 745
  if (*(array_in + 28)) {
#line 746
    return_value -= 0.1;
  }
#line 747
  if (*(array_in + 95)) {
#line 748
    return_value -= 0.1;
  }
#line 749
  if (*(array_in + 34)) {
#line 750
    return_value -= 0.1;
  }
#line 751
  if (*(array_in + 30)) {
#line 752
    return_value -= 0.1;
  }
#line 753
  if (*(array_in + 47)) {
#line 754
    return_value -= 0.2;
  } else
#line 753
  if (*(array_in + 48)) {
#line 754
    return_value -= 0.2;
  }
#line 755
  if (*(array_in + 19)) {
#line 756
    return_value -= 0.2;
  }
#line 757
  if (*(array_in + 19)) {
#line 757
    if (*(array_in + 2) > (double const   )0.35) {
#line 758
      return_value -= 0.2;
    }
  }
#line 759
  if (*(array_in + 4) > (double const   )0.57) {
#line 760
    return_value -= 0.1;
  } else
#line 759
  if (*(array_in + 4) < (double const   )47) {
#line 760
    return_value -= 0.1;
  }
#line 761
  if (*(array_in + 4) < (double const   )0.43) {
#line 762
    return_value -= 0.3;
  }
#line 763
  if (*(array_in + 3) < (double const   )0.35) {
#line 764
    return_value -= 0.3;
  }
#line 765
  if (*(array_in + 3) > (double const   )0.65) {
#line 766
    return_value -= 0.3;
  }
#line 767
  if (*(array_in + 1) > (double const   )0.25) {
#line 767
    if (*(array_in + 8) > *(array_in + 10) + (double const   )0.2) {
#line 768
      return_value -= 0.2;
    }
  }
#line 769
  if (*(array_in + 1) > (double const   )0.35) {
#line 770
    return_value -= 0.2;
  }
#line 771
  if (*(array_in + 2) > (double const   )0.53) {
#line 772
    return_value -= 0.1;
  }
#line 773
  if (*(array_in + 2) > (double const   )0.60) {
#line 774
    return_value -= 0.2;
  }
#line 775
  if (*(array_in + 70)) {
#line 776
    return_value -= 0.2;
  }
#line 777
  if (! *(array_in + 56)) {
#line 777
    if (! *(array_in + 57)) {
#line 778
      return_value -= 0.2;
    }
  }
#line 779
  if (*(array_in + 0) < (double const   )0.35) {
#line 780
    return_value -= 0.3;
  }
#line 781
  if (*(array_in + 2) > (double const   )0.55) {
#line 782
    return_value -= 0.2;
  }
#line 783
  if (*(array_in + 67)) {
#line 784
    return_value -= 0.2;
  }
#line 785
  if (*(array_in + 70)) {
#line 786
    return_value -= 0.2;
  }
#line 787
  if (! *(array_in + 22)) {
#line 788
    return_value -= 0.2;
  }
#line 790
  return (return_value);
}
}
#line 793 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_zayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 796
  return_value = 0.0;
#line 798
  if (*(array_in + 1) < (double const   )0.3) {
#line 799
    return_value += 0.2;
  }
#line 800
  if (*(array_in + 2) < (double const   )0.53) {
#line 801
    return_value += 0.1;
  }
#line 802
  if (*(array_in + 22)) {
#line 803
    return_value += 0.1;
  }
#line 804
  if (*(array_in + 21)) {
#line 805
    return_value += 0.2;
  }
#line 806
  if (*(array_in + 28)) {
#line 807
    return_value += 0.2;
  }
#line 808
  if (*(array_in + 59)) {
#line 809
    return_value += 0.1;
  } else
#line 808
  if (*(array_in + 60)) {
#line 809
    return_value += 0.1;
  }
#line 810
  if (*(array_in + 9) > *(array_in + 8)) {
#line 811
    return_value += 0.1;
  }
#line 813
  if (*(array_in + 4) > (double const   )0.60) {
#line 814
    return_value -= 0.2;
  }
#line 815
  if (*(array_in + 3) < (double const   )0.35) {
#line 816
    return_value -= 0.3;
  }
#line 817
  if (*(array_in + 4) > (double const   )0.57) {
#line 818
    return_value -= 0.10;
  } else
#line 817
  if (*(array_in + 4) < (double const   )47) {
#line 818
    return_value -= 0.10;
  }
#line 819
  if (*(array_in + 4) < (double const   )0.43) {
#line 820
    return_value -= 0.3;
  }
#line 821
  if (*(array_in + 19)) {
#line 822
    return_value -= 0.3;
  }
#line 823
  if (*(array_in + 34)) {
#line 824
    return_value -= 0.1;
  }
#line 825
  if (*(array_in + 47)) {
#line 826
    return_value -= 0.2;
  } else
#line 825
  if (*(array_in + 48)) {
#line 826
    return_value -= 0.2;
  }
#line 827
  if (*(array_in + 19)) {
#line 828
    return_value -= 0.2;
  }
#line 829
  if (*(array_in + 10) < (double const   )0.2) {
#line 830
    return_value -= 0.2;
  }
#line 831
  if (*(array_in + 8) > (double const   )0.9) {
#line 832
    return_value -= 0.2;
  }
#line 833
  if (*(array_in + 7) > *(array_in + 9)) {
#line 834
    return_value -= 0.2;
  }
#line 835
  if (*(array_in + 70)) {
#line 836
    return_value -= 0.3;
  }
#line 837
  if (*(array_in + 67)) {
#line 838
    return_value -= 0.3;
  } else
#line 837
  if (*(array_in + 68)) {
#line 838
    return_value -= 0.3;
  }
#line 839
  if (*(array_in + 2) > (double const   )0.63) {
#line 840
    return_value -= 0.2;
  }
#line 841
  if (*(array_in + 59) < (double const   )0.1) {
#line 841
    if (*(array_in + 60) < (double const   )0.1) {
#line 842
      return_value -= 0.1;
    }
  }
#line 843
  if (*(array_in + 0) < (double const   )0.3) {
#line 844
    return_value -= 0.2;
  }
#line 846
  return (return_value);
}
}
#line 849 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_het(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 852
  return_value = 0.0;
#line 854
  if (*(array_in + 17)) {
#line 855
    return_value += 0.1;
  }
#line 856
  if (*(array_in + 20)) {
#line 857
    return_value += 0.1;
  }
#line 858
  if (*(array_in + 22)) {
#line 859
    return_value += 0.1;
  }
#line 860
  if (! *(array_in + 19)) {
#line 861
    return_value += 0.1;
  }
#line 862
  if (*(array_in + 10) < *(array_in + 8) + (double const   )0.1) {
#line 863
    return_value += 0.1;
  }
#line 864
  if (*(array_in + 14)) {
#line 865
    return_value += 0.1;
  }
#line 867
  if (! *(array_in + 17)) {
#line 868
    return_value -= 0.1;
  }
#line 869
  if (! *(array_in + 20)) {
#line 870
    return_value -= 0.1;
  }
#line 871
  if (! *(array_in + 22)) {
#line 872
    return_value -= 0.1;
  }
#line 873
  if (*(array_in + 19)) {
#line 874
    return_value -= 0.2;
  }
#line 875
  if (*(array_in + 27)) {
#line 876
    return_value -= 0.2;
  }
#line 877
  if (*(array_in + 11) < (double const   )0.9) {
#line 878
    return_value -= 0.2;
  }
#line 879
  if (*(array_in + 44)) {
#line 879
    if (*(array_in + 6) > (double const   )0.2) {
#line 880
      return_value -= 0.3;
    }
  }
#line 881
  if (*(array_in + 10) < *(array_in + 8) + (double const   )0.1) {
#line 882
    return_value -= 0.1;
  }
#line 883
  if (! *(array_in + 14)) {
#line 884
    return_value -= 0.3;
  }
#line 885
  if (*(array_in + 33)) {
#line 886
    return_value -= 0.2;
  }
#line 887
  if (*(array_in + 69)) {
#line 888
    return_value -= 0.2;
  }
#line 889
  if (*(array_in + 67)) {
#line 890
    return_value -= 0.3;
  }
#line 891
  if (*(array_in + 5) > *(array_in + 10) + (double const   )0.1) {
#line 892
    return_value -= 0.1;
  }
#line 893
  if (! *(array_in + 57)) {
#line 894
    return_value -= 0.2;
  }
#line 896
  return (return_value);
}
}
#line 899 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_tet(double const   *array_in ) 
{ 
  int count_edges ;
  int count_notches ;
  double return_value ;

  {
#line 904
  return_value = 0.0;
#line 906
  count_edges = (int )((*(array_in + 33) * (double const   )10.0 + *(array_in + 32) * (double const   )10.0) + *(array_in + 31) * (double const   )10);
#line 908
  count_notches = (int )((*(array_in + 45) * (double const   )10.0 + *(array_in + 44) * (double const   )10.0) + *(array_in + 43) * (double const   )10);
#line 911
  if (*(array_in + 19)) {
#line 912
    return_value += 0.1;
  }
#line 913
  if (*(array_in + 20)) {
#line 914
    return_value += 0.1;
  }
#line 915
  if (*(array_in + 22)) {
#line 916
    return_value += 0.1;
  }
#line 917
  if (*(array_in + 44)) {
#line 918
    return_value += 0.2;
  } else
#line 917
  if (*(array_in + 43)) {
#line 918
    return_value += 0.2;
  }
#line 919
  if (*(array_in + 35)) {
#line 920
    return_value += 0.1;
  }
#line 921
  if (! *(array_in + 51)) {
#line 922
    return_value += 0.1;
  }
#line 923
  if (count_edges == 2) {
#line 924
    return_value += 0.1;
  }
#line 926
  if (*(array_in + 17)) {
#line 926
    if (! *(array_in + 44)) {
#line 927
      return_value -= 0.1;
    }
  }
#line 928
  if (*(array_in + 27)) {
#line 929
    return_value -= 0.2;
  }
#line 930
  if (! *(array_in + 44)) {
#line 931
    return_value -= 0.2;
  }
#line 932
  if (*(array_in + 47)) {
#line 933
    return_value -= 0.2;
  }
#line 934
  if (*(array_in + 45)) {
#line 934
    if (*(array_in + 43)) {
#line 935
      return_value -= 0.2;
    }
  }
#line 936
  if (! *(array_in + 44)) {
#line 936
    if (! *(array_in + 43)) {
#line 937
      return_value -= 0.2;
    }
  }
#line 938
  if (*(array_in + 46)) {
#line 939
    return_value -= 0.2;
  }
#line 940
  if (*(array_in + 47)) {
#line 941
    return_value -= 0.2;
  }
#line 942
  if (count_edges != 2) {
#line 943
    return_value -= 0.1;
  }
#line 944
  if (count_edges == 3) {
#line 945
    return_value -= 0.1;
  }
#line 946
  if (count_notches > 1) {
#line 947
    return_value -= 0.2;
  }
#line 948
  if (*(array_in + 0) > (double const   )0.55) {
#line 949
    return_value -= 0.2;
  }
#line 950
  if (*(array_in + 55)) {
#line 951
    return_value -= 0.2;
  }
#line 952
  if (*(array_in + 68)) {
#line 953
    return_value -= 0.2;
  }
#line 954
  if (*(array_in + 67)) {
#line 954
    if (! *(array_in + 80)) {
#line 955
      return_value -= 0.2;
    }
  }
#line 956
  if (*(array_in + 67)) {
#line 956
    if (*(array_in + 85) < (double const   )0.3) {
#line 957
      return_value -= 0.2;
    }
  }
#line 958
  if (*(array_in + 67)) {
#line 958
    if (*(array_in + 74)) {
#line 959
      return_value -= 0.2;
    }
  }
#line 960
  if (*(array_in + 64)) {
#line 961
    return_value -= 0.1;
  } else
#line 960
  if (*(array_in + 65)) {
#line 961
    return_value -= 0.1;
  }
#line 962
  if (*(array_in + 8) > (double const   )0.5) {
#line 963
    return_value -= 0.2;
  }
#line 965
  return (return_value);
}
}
#line 968 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_yud(double const   *array_in ) 
{ 
  double return_value ;
  double height_by_width ;

  {
#line 971
  return_value = 0.0;
#line 972
  height_by_width = (double )(*(array_in + 0) / *(array_in + 1));
#line 974
  if (*(array_in + 3) < (double const   )0.53) {
#line 974
    if (*(array_in + 3) > (double const   )0.47) {
#line 975
      return_value += 0.1;
    }
  }
#line 976
  if (*(array_in + 4) > (double const   )0.55) {
#line 977
    return_value += 0.1;
  }
#line 978
  if (*(array_in + 1) < (double const   )0.3) {
#line 979
    return_value += 0.1;
  }
#line 980
  if (*(array_in + 0) < (double const   )0.35) {
#line 981
    return_value += 0.1;
  }
#line 982
  if (*(array_in + 5) < (double const   )0.4) {
#line 983
    return_value += 0.1;
  }
#line 984
  if (*(array_in + 17)) {
#line 985
    return_value += 0.1;
  }
#line 986
  if (*(array_in + 38)) {
#line 987
    return_value += 0.1;
  }
#line 989
  if (*(array_in + 0) > (double const   )0.38) {
#line 990
    return_value -= 0.2;
  }
#line 991
  if (*(array_in + 1) > (double const   )0.4) {
#line 992
    return_value -= 0.2;
  }
#line 993
  if (*(array_in + 5) > (double const   )0.8) {
#line 994
    return_value -= 0.1;
  }
#line 995
  if (*(array_in + 4) < (double const   )0.58) {
#line 996
    return_value -= 0.2;
  }
#line 997
  if (*(array_in + 5) > *(array_in + 10) * (double const   )1.5) {
#line 998
    return_value -= 0.3;
  }
#line 999
  if (*(array_in + 34)) {
#line 1000
    return_value -= 0.1;
  }
#line 1001
  if (*(array_in + 3) < (double const   )0.3) {
#line 1002
    return_value -= 0.2;
  }
#line 1003
  if (height_by_width < 0.55) {
#line 1004
    return_value -= 0.1;
  }
#line 1005
  if (height_by_width < 0.35) {
#line 1006
    return_value -= 0.2;
  }
#line 1008
  return (return_value);
}
}
#line 1011 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_caf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1014
  return_value = 0.0;
#line 1016
  if (*(array_in + 17)) {
#line 1017
    return_value += 0.1;
  }
#line 1018
  if (*(array_in + 19)) {
#line 1019
    return_value += 0.1;
  }
#line 1020
  if (*(array_in + 22)) {
#line 1021
    return_value += 0.1;
  }
#line 1022
  if (*(array_in + 8) == (double const   )1) {
#line 1022
    if (*(array_in + 9) < (double const   )0.2) {
#line 1023
      return_value += 0.1;
    }
  }
#line 1024
  if (*(array_in + 38)) {
#line 1025
    return_value += 0.1;
  }
#line 1026
  if (! *(array_in + 30)) {
#line 1027
    return_value += 0.1;
  }
#line 1028
  if (*(array_in + 19)) {
#line 1028
    if (*(array_in + 55)) {
#line 1028
      if (! *(array_in + 57)) {
#line 1029
        return_value += 0.1;
      }
    }
  }
#line 1031
  if (*(array_in + 97)) {
#line 1032
    return_value -= 0.3;
  }
#line 1033
  if (*(array_in + 30)) {
#line 1034
    return_value -= 0.1;
  }
#line 1035
  if (*(array_in + 47)) {
#line 1035
    goto _L;
  } else
#line 1035
  if (*(array_in + 48)) {
    _L: /* CIL Label */ 
#line 1035
    if (*(array_in + 12) < (double const   )0.25) {
#line 1037
      return_value -= 0.2;
    }
  }
#line 1038
  if (*(array_in + 19) < (double const   )0.5) {
#line 1039
    return_value -= 0.2;
  }
#line 1040
  if (*(array_in + 20)) {
#line 1041
    return_value -= 0.2;
  }
#line 1042
  if (*(array_in + 5) > *(array_in + 10) + (double const   )0.25) {
#line 1043
    return_value -= 0.2;
  }
#line 1044
  if (*(array_in + 2) < (double const   )0.50) {
#line 1045
    return_value -= 0.3;
  }
#line 1046
  if (*(array_in + 8) < (double const   )0.8) {
#line 1047
    return_value -= 0.2;
  }
#line 1048
  if (! *(array_in + 55)) {
#line 1048
    if (*(array_in + 10) > (double const   )0.2) {
#line 1049
      return_value -= 0.2;
    }
  }
#line 1050
  if (*(array_in + 1) < (double const   )0.3) {
#line 1051
    return_value -= 0.3;
  }
#line 1052
  if (*(array_in + 51)) {
#line 1053
    return_value -= 0.2;
  }
#line 1054
  if (*(array_in + 44)) {
#line 1055
    return_value -= 0.2;
  } else
#line 1054
  if (*(array_in + 45)) {
#line 1055
    return_value -= 0.2;
  }
#line 1056
  if (*(array_in + 4) > (double const   )0.57) {
#line 1057
    return_value -= 0.20;
  } else
#line 1056
  if (*(array_in + 4) < (double const   )43) {
#line 1057
    return_value -= 0.20;
  }
#line 1059
  return (return_value);
}
}
#line 1062 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_caf_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1065
  return_value = 0.0;
#line 1067
  if (*(array_in + 17)) {
#line 1068
    return_value += 0.1;
  }
#line 1069
  if (*(array_in + 22)) {
#line 1070
    return_value += 0.1;
  }
#line 1071
  if (*(array_in + 36)) {
#line 1072
    return_value += 0.1;
  }
#line 1073
  if (*(array_in + 8) > (double const   )0.9) {
#line 1074
    return_value += 0.1;
  }
#line 1075
  if (*(array_in + 4) < (double const   )0.45) {
#line 1076
    return_value += 0.3;
  }
#line 1078
  if (*(array_in + 19)) {
#line 1079
    return_value -= 0.3;
  }
#line 1080
  if (*(array_in + 18)) {
#line 1081
    return_value -= 0.3;
  }
#line 1082
  if (*(array_in + 62)) {
#line 1083
    return_value -= 0.3;
  }
#line 1084
  if (*(array_in + 20)) {
#line 1085
    return_value -= 0.3;
  }
#line 1086
  if (*(array_in + 21)) {
#line 1087
    return_value -= 0.1;
  }
#line 1088
  if (*(array_in + 69)) {
#line 1089
    return_value -= 0.3;
  }
#line 1090
  if (*(array_in + 4) > (double const   )0.50) {
#line 1091
    return_value -= 0.3;
  }
#line 1092
  if (*(array_in + 1) < (double const   )0.3) {
#line 1093
    return_value -= 0.3;
  }
#line 1094
  if (*(array_in + 0) < (double const   )0.52) {
#line 1095
    return_value -= 0.3;
  }
#line 1096
  if (*(array_in + 67)) {
#line 1097
    return_value -= 0.2;
  }
#line 1098
  if (*(array_in + 8) < (double const   )0.9) {
#line 1099
    return_value -= 0.2;
  }
#line 1100
  if (*(array_in + 10) < (double const   )0.8) {
#line 1101
    return_value -= 0.2;
  }
#line 1102
  if (*(array_in + 6) > (double const   )0.4) {
#line 1103
    return_value -= 0.2;
  }
#line 1104
  if (*(array_in + 13)) {
#line 1105
    return_value -= 0.2;
  }
#line 1107
  return (return_value);
}
}
#line 1110 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_lamed(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1113
  return_value = 0.0;
#line 1115
  if (*(array_in + 3) > (double const   )0.6) {
#line 1116
    return_value += 0.2;
  }
#line 1117
  if (*(array_in + 17)) {
#line 1118
    return_value += 0.1;
  } else
#line 1117
  if (*(array_in + 18)) {
#line 1118
    return_value += 0.1;
  }
#line 1119
  if (*(array_in + 0) > (double const   )0.6) {
#line 1120
    return_value += 0.2;
  }
#line 1121
  if (*(array_in + 7) > (double const   )0.5) {
#line 1122
    return_value += 0.2;
  }
#line 1123
  if (*(array_in + 5) < (double const   )0.2) {
#line 1124
    return_value += 0.1;
  }
#line 1126
  if (*(array_in + 20)) {
#line 1127
    return_value -= 0.2;
  }
#line 1128
  if (*(array_in + 3) < (double const   )0.51) {
#line 1129
    return_value -= 0.2;
  }
#line 1130
  if (! *(array_in + 17)) {
#line 1130
    if (! *(array_in + 18)) {
#line 1131
      return_value -= 0.2;
    }
  }
#line 1132
  if (*(array_in + 4) > (double const   )0.52) {
#line 1133
    return_value -= 0.2;
  }
#line 1134
  if (*(array_in + 2) < (double const   )0.35) {
#line 1135
    return_value -= 0.2;
  }
#line 1136
  if (*(array_in + 1) < (double const   )0.25) {
#line 1137
    return_value -= 0.2;
  }
#line 1138
  if (*(array_in + 4) < (double const   )0.47) {
#line 1139
    return_value -= 0.2;
  }
#line 1140
  if (*(array_in + 70)) {
#line 1141
    return_value -= 0.2;
  }
#line 1142
  if (*(array_in + 69)) {
#line 1143
    return_value -= 0.2;
  }
#line 1145
  return (return_value);
}
}
#line 1148 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_mem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1151
  return_value = 0.0;
#line 1153
  if (*(array_in + 25)) {
#line 1154
    return_value += 0.1;
  }
#line 1155
  if (*(array_in + 31)) {
#line 1156
    return_value += 0.1;
  }
#line 1157
  if (*(array_in + 46)) {
#line 1158
    return_value += 0.1;
  } else
#line 1157
  if (*(array_in + 47)) {
#line 1158
    return_value += 0.1;
  }
#line 1159
  if (*(array_in + 38)) {
#line 1160
    return_value += 0.1;
  }
#line 1161
  if (*(array_in + 49)) {
#line 1162
    return_value += 0.1;
  }
#line 1163
  if (*(array_in + 55)) {
#line 1164
    return_value += 0.1;
  }
#line 1165
  if (*(array_in + 56)) {
#line 1166
    return_value += 0.1;
  }
#line 1167
  if (*(array_in + 59)) {
#line 1168
    return_value += 0.1;
  }
#line 1169
  if (*(array_in + 52)) {
#line 1169
    goto _L;
  } else
#line 1169
  if (*(array_in + 55)) {
    _L: /* CIL Label */ 
#line 1169
    if (*(array_in + 56)) {
#line 1170
      return_value += 0.1;
    }
  }
#line 1172
  if (*(array_in + 23)) {
#line 1173
    return_value -= 0.1;
  }
#line 1174
  if (*(array_in + 17)) {
#line 1175
    return_value -= 0.1;
  }
#line 1176
  if (*(array_in + 41)) {
#line 1177
    return_value -= 0.2;
  } else
#line 1176
  if (*(array_in + 42)) {
#line 1177
    return_value -= 0.2;
  }
#line 1178
  if (*(array_in + 57)) {
#line 1179
    return_value -= 0.2;
  }
#line 1180
  if (*(array_in + 4) > (double const   )0.60) {
#line 1181
    return_value -= 0.2;
  }
#line 1182
  if (*(array_in + 12) > (double const   )0.35) {
#line 1183
    return_value -= 0.3;
  }
#line 1184
  if (*(array_in + 11) == (double const   )1) {
#line 1185
    return_value -= 0.1;
  }
#line 1186
  if (*(array_in + 8) > (double const   )0.9) {
#line 1187
    return_value -= 0.2;
  }
#line 1189
  return (return_value);
}
}
#line 1192 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_mem_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1195
  return_value = 0.0;
#line 1197
  if (*(array_in + 17)) {
#line 1198
    return_value += 0.1;
  }
#line 1199
  if (*(array_in + 19)) {
#line 1200
    return_value += 0.2;
  }
#line 1201
  if (*(array_in + 20)) {
#line 1202
    return_value += 0.1;
  }
#line 1203
  if (*(array_in + 22)) {
#line 1204
    return_value += 0.1;
  }
#line 1205
  if (*(array_in + 10) < (double const   )0.25) {
#line 1205
    if (*(array_in + 12) < (double const   )0.25) {
#line 1205
      if (*(array_in + 19)) {
#line 1206
        return_value += 0.1;
      }
    }
  }
#line 1207
  if (*(array_in + 10) > *(array_in + 12) + (double const   )0.2) {
#line 1208
    return_value += 0.1;
  }
#line 1209
  if (*(array_in + 10) < (double const   )0.3) {
#line 1209
    if (*(array_in + 12) < (double const   )0.3) {
#line 1210
      return_value += 0.2;
    }
  }
#line 1211
  if (*(array_in + 67)) {
#line 1212
    return_value += 0.2;
  }
#line 1214
  if (*(array_in + 10) + (double const   )0.1 < *(array_in + 12)) {
#line 1215
    return_value -= 0.3;
  }
#line 1216
  if (! *(array_in + 67)) {
#line 1217
    return_value -= 0.2;
  }
#line 1218
  if (*(array_in + 8) > (double const   )0.7) {
#line 1219
    return_value -= 0.3;
  }
#line 1220
  if (*(array_in + 10) > (double const   )0.25) {
#line 1220
    if (*(array_in + 12) > (double const   )0.30) {
#line 1221
      return_value -= 0.1;
    }
  }
#line 1222
  if (*(array_in + 10) > (double const   )0.42) {
#line 1223
    return_value -= 0.2;
  } else
#line 1222
  if (*(array_in + 12) > (double const   )0.45) {
#line 1223
    return_value -= 0.2;
  }
#line 1224
  if (*(array_in + 12) > (double const   )0.42) {
#line 1225
    return_value -= 0.1;
  }
#line 1226
  if (*(array_in + 4) > (double const   )0.57) {
#line 1227
    return_value -= 0.10;
  } else
#line 1226
  if (*(array_in + 4) < (double const   )43) {
#line 1227
    return_value -= 0.10;
  }
#line 1228
  if (*(array_in + 44)) {
#line 1229
    return_value -= 0.2;
  }
#line 1230
  if (! *(array_in + 17)) {
#line 1231
    return_value -= 0.3;
  }
#line 1232
  if (*(array_in + 5) > (double const   )0.4) {
#line 1233
    return_value -= 0.2;
  }
#line 1235
  return (return_value);
}
}
#line 1238 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_nun(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1241
  return_value = 0.0;
#line 1243
  if (*(array_in + 17)) {
#line 1244
    return_value += 0.1;
  }
#line 1245
  if (*(array_in + 19)) {
#line 1246
    return_value += 0.1;
  }
#line 1247
  if (*(array_in + 22)) {
#line 1248
    return_value += 0.1;
  }
#line 1249
  if (*(array_in + 38)) {
#line 1250
    return_value += 0.1;
  }
#line 1251
  if (*(array_in + 8) == (double const   )1) {
#line 1251
    if (*(array_in + 1) < (double const   )0.3) {
#line 1252
      return_value += 0.1;
    }
  }
#line 1253
  if (! *(array_in + 30)) {
#line 1254
    return_value += 0.1;
  }
#line 1255
  if (*(array_in + 5) > *(array_in + 10) + (double const   )0.25) {
#line 1256
    return_value += 0.2;
  }
#line 1257
  if (*(array_in + 1) < (double const   )0.3) {
#line 1258
    return_value += 0.2;
  }
#line 1259
  if (*(array_in + 1) < (double const   )0.3) {
#line 1259
    if (*(array_in + 19)) {
#line 1259
      if (*(array_in + 65) < (double const   )0.1) {
#line 1259
        if (*(array_in + 66) < (double const   )0.1) {
#line 1261
          return_value += 0.2;
        }
      }
    }
  }
#line 1263
  if (*(array_in + 11) > (double const   )0.25) {
#line 1264
    return_value -= 0.2;
  }
#line 1265
  if (*(array_in + 47)) {
#line 1266
    return_value -= 0.3;
  } else
#line 1265
  if (*(array_in + 48)) {
#line 1266
    return_value -= 0.3;
  }
#line 1267
  if (*(array_in + 19) < (double const   )0.5) {
#line 1268
    return_value -= 0.2;
  }
#line 1269
  if (*(array_in + 20)) {
#line 1270
    return_value -= 0.2;
  }
#line 1271
  if (*(array_in + 26)) {
#line 1272
    return_value -= 0.2;
  }
#line 1273
  if (*(array_in + 95)) {
#line 1274
    return_value -= 0.2;
  }
#line 1275
  if (*(array_in + 103)) {
#line 1276
    return_value -= 0.2;
  }
#line 1277
  if (*(array_in + 1) > (double const   )0.33) {
#line 1277
    if (*(array_in + 5) < *(array_in + 10) + (double const   )0.2) {
#line 1278
      return_value -= 0.35;
    }
  }
#line 1279
  if (*(array_in + 5) < *(array_in + 10)) {
#line 1280
    return_value -= 0.2;
  }
#line 1281
  if (*(array_in + 5) < *(array_in + 10) + (double const   )0.2) {
#line 1282
    return_value -= 0.2;
  }
#line 1283
  if (*(array_in + 8) < (double const   )0.6) {
#line 1284
    return_value -= 0.3;
  }
#line 1285
  if (*(array_in + 4) > (double const   )0.60) {
#line 1286
    return_value -= 0.2;
  }
#line 1287
  if (*(array_in + 4) < (double const   )0.43) {
#line 1288
    return_value -= 0.2;
  }
#line 1289
  if (*(array_in + 52)) {
#line 1290
    return_value -= 0.3;
  } else
#line 1289
  if (*(array_in + 53)) {
#line 1290
    return_value -= 0.3;
  }
#line 1291
  if (*(array_in + 0) > (double const   )0.55) {
#line 1292
    return_value -= 0.2;
  }
#line 1293
  if (*(array_in + 0) < (double const   )0.3) {
#line 1294
    return_value -= 0.2;
  }
#line 1295
  if (*(array_in + 2) < (double const   )0.25) {
#line 1296
    return_value -= 0.3;
  }
#line 1297
  if (*(array_in + 1) < (double const   )0.15) {
#line 1298
    return_value -= 0.3;
  }
#line 1299
  if (*(array_in + 9) > (double const   )0.9) {
#line 1300
    return_value -= 0.3;
  }
#line 1302
  return (return_value);
}
}
#line 1305 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_nun_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1308
  return_value = 0.0;
#line 1310
  if (*(array_in + 1) < (double const   )0.3) {
#line 1311
    return_value += 0.2;
  }
#line 1312
  if (*(array_in + 2) < (double const   )0.45) {
#line 1313
    return_value += 0.2;
  }
#line 1314
  if (*(array_in + 22)) {
#line 1315
    return_value += 0.2;
  } else
#line 1314
  if (*(array_in + 21)) {
#line 1315
    return_value += 0.2;
  }
#line 1316
  if (*(array_in + 4) < (double const   )0.45) {
#line 1317
    return_value += 0.3;
  }
#line 1318
  if (*(array_in + 0) > (double const   )0.53) {
#line 1319
    return_value += 0.1;
  }
#line 1320
  if (*(array_in + 0) > (double const   )0.63) {
#line 1321
    return_value += 0.1;
  }
#line 1322
  if (*(array_in + 30)) {
#line 1323
    return_value += 0.1;
  }
#line 1325
  if (*(array_in + 28)) {
#line 1326
    return_value -= 0.1;
  }
#line 1327
  if (*(array_in + 34)) {
#line 1328
    return_value -= 0.1;
  }
#line 1329
  if (*(array_in + 47)) {
#line 1330
    return_value -= 0.2;
  } else
#line 1329
  if (*(array_in + 48)) {
#line 1330
    return_value -= 0.2;
  }
#line 1331
  if (*(array_in + 19)) {
#line 1332
    return_value -= 0.2;
  }
#line 1333
  if (*(array_in + 0) < (double const   )0.5) {
#line 1334
    return_value -= 0.3;
  }
#line 1335
  if (*(array_in + 4) > (double const   )0.0) {
#line 1336
    return_value -= 0.2;
  }
#line 1337
  if (*(array_in + 2) > (double const   )0.38) {
#line 1338
    return_value -= 0.3;
  }
#line 1339
  if (*(array_in + 10) < (double const   )0.15) {
#line 1340
    return_value -= 0.1;
  }
#line 1341
  if (*(array_in + 9) > (double const   )0.75) {
#line 1342
    return_value += 0.1;
  }
#line 1343
  if (*(array_in + 5) > (double const   )0.75) {
#line 1344
    return_value -= 0.1;
  }
#line 1345
  if (*(array_in + 10) + (double const   )0.2 < *(array_in + 12)) {
#line 1346
    return_value -= 0.2;
  }
#line 1348
  return (return_value);
}
}
#line 1351 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_samech(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1354
  return_value = 0.0;
#line 1356
  if (*(array_in + 17)) {
#line 1357
    return_value += 0.1;
  }
#line 1358
  if (*(array_in + 19)) {
#line 1359
    return_value += 0.1;
  }
#line 1360
  if (*(array_in + 20)) {
#line 1361
    return_value += 0.1;
  }
#line 1362
  if (*(array_in + 22)) {
#line 1363
    return_value += 0.1;
  }
#line 1364
  if (*(array_in + 12) > (double const   )0.45) {
#line 1365
    return_value += 0.1;
  }
#line 1366
  if (*(array_in + 10) > (double const   )0.45) {
#line 1367
    return_value += 0.1;
  } else
#line 1366
  if (*(array_in + 12) > (double const   )0.45) {
#line 1367
    return_value += 0.1;
  }
#line 1368
  if (*(array_in + 10) + (double const   )0.3 < *(array_in + 12)) {
#line 1369
    return_value += 0.1;
  }
#line 1370
  if (*(array_in + 10) > (double const   )0.30) {
#line 1370
    if (*(array_in + 12) > (double const   )0.30) {
#line 1371
      return_value += 0.1;
    }
  }
#line 1372
  if (*(array_in + 67)) {
#line 1373
    return_value += 0.2;
  }
#line 1375
  if (*(array_in + 10) > *(array_in + 12)) {
#line 1376
    return_value -= 0.3;
  }
#line 1377
  if (*(array_in + 10) < (double const   )0.2) {
#line 1377
    if (*(array_in + 12) < (double const   )0.2) {
#line 1378
      return_value -= 0.3;
    }
  }
#line 1379
  if (*(array_in + 10) < (double const   )0.12) {
#line 1380
    return_value -= 0.3;
  }
#line 1381
  if (! *(array_in + 67)) {
#line 1382
    return_value -= 0.3;
  }
#line 1383
  if (*(array_in + 67)) {
#line 1383
    if (*(array_in + 85) < (double const   )0.17) {
#line 1384
      return_value -= 0.3;
    }
  }
#line 1385
  if (*(array_in + 68)) {
#line 1386
    return_value -= 0.3;
  }
#line 1387
  if (*(array_in + 34)) {
#line 1387
    if (*(array_in + 36)) {
#line 1388
      return_value -= 0.2;
    }
  }
#line 1389
  if (*(array_in + 44)) {
#line 1390
    return_value -= 0.2;
  }
#line 1391
  if (*(array_in + 2) < (double const   )0.60) {
#line 1392
    return_value -= 0.3;
  }
#line 1393
  if (! *(array_in + 17)) {
#line 1394
    return_value -= 0.3;
  }
#line 1395
  if (*(array_in + 5) > (double const   )0.4) {
#line 1396
    return_value -= 0.2;
  }
#line 1397
  if (*(array_in + 8) > (double const   )0.4) {
#line 1398
    return_value -= 0.2;
  }
#line 1399
  if (*(array_in + 38)) {
#line 1399
    if (*(array_in + 10) < (double const   )0.15) {
#line 1400
      return_value -= 0.1;
    }
  }
#line 1401
  if (*(array_in + 44)) {
#line 1402
    return_value -= 0.1;
  }
#line 1403
  if (*(array_in + 39)) {
#line 1404
    return_value -= 0.1;
  }
#line 1405
  if (*(array_in + 65)) {
#line 1406
    return_value -= 0.2;
  }
#line 1407
  if (*(array_in + 55)) {
#line 1408
    return_value -= 0.2;
  }
#line 1409
  if (*(array_in + 12) < (double const   )0.32) {
#line 1410
    return_value -= 0.3;
  }
#line 1411
  if (*(array_in + 3) < (double const   )0.35) {
#line 1412
    return_value -= 0.2;
  }
#line 1414
  return (return_value);
}
}
#line 1417 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_ayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1420
  return_value = 0.0;
#line 1422
  if (*(array_in + 13)) {
#line 1423
    return_value += 0.1;
  }
#line 1424
  if (*(array_in + 27)) {
#line 1425
    return_value += 0.1;
  }
#line 1426
  if (*(array_in + 10) < *(array_in + 12)) {
#line 1427
    return_value += 0.1;
  }
#line 1428
  if (*(array_in + 44)) {
#line 1429
    return_value += 0.1;
  }
#line 1430
  if (*(array_in + 38)) {
#line 1431
    return_value += 0.1;
  } else
#line 1430
  if (*(array_in + 39)) {
#line 1431
    return_value += 0.1;
  }
#line 1432
  if (*(array_in + 44)) {
#line 1433
    return_value += 0.1;
  }
#line 1434
  if (*(array_in + 7) + (double const   )0.15 < *(array_in + 12)) {
#line 1435
    return_value += 0.1;
  }
#line 1436
  if (*(array_in + 55)) {
#line 1437
    return_value += 0.1;
  }
#line 1439
  if (*(array_in + 47)) {
#line 1440
    return_value -= 0.2;
  }
#line 1441
  if (*(array_in + 41)) {
#line 1442
    return_value -= 0.2;
  } else
#line 1441
  if (*(array_in + 42)) {
#line 1442
    return_value -= 0.2;
  }
#line 1443
  if (*(array_in + 17)) {
#line 1444
    return_value -= 0.3;
  }
#line 1445
  if (*(array_in + 46)) {
#line 1446
    return_value -= 0.2;
  }
#line 1447
  if (! *(array_in + 55)) {
#line 1448
    return_value -= 0.2;
  }
#line 1449
  if (*(array_in + 41)) {
#line 1450
    return_value -= 0.1;
  }
#line 1451
  if (*(array_in + 9) > (double const   )0.51) {
#line 1451
    if (*(array_in + 12) < (double const   )0.2) {
#line 1452
      return_value -= 0.1;
    }
  }
#line 1453
  if (*(array_in + 4) > (double const   )0.55) {
#line 1454
    return_value -= 0.2;
  }
#line 1455
  if (*(array_in + 69)) {
#line 1456
    return_value -= 0.2;
  }
#line 1457
  if (*(array_in + 10) > (double const   )0.3) {
#line 1458
    return_value -= 0.2;
  }
#line 1459
  if (*(array_in + 12) < (double const   )0.3) {
#line 1460
    return_value -= 0.1;
  }
#line 1461
  if (*(array_in + 11) > (double const   )0.85) {
#line 1462
    return_value -= 0.1;
  }
#line 1463
  if (*(array_in + 3) > (double const   )0.56) {
#line 1464
    return_value -= 0.2;
  }
#line 1465
  if (*(array_in + 8) > (double const   )0.9) {
#line 1466
    return_value -= 0.2;
  }
#line 1467
  if (*(array_in + 1) < (double const   )0.3) {
#line 1468
    return_value -= 0.2;
  }
#line 1469
  if (*(array_in + 0) < (double const   )0.35) {
#line 1470
    return_value -= 0.2;
  }
#line 1472
  return (return_value);
}
}
#line 1475 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_pey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1478
  return_value = 0.0;
#line 1480
  if (*(array_in + 17)) {
#line 1481
    return_value += 0.15;
  }
#line 1482
  if (*(array_in + 19)) {
#line 1483
    return_value += 0.15;
  }
#line 1484
  if (*(array_in + 22)) {
#line 1485
    return_value += 0.15;
  }
#line 1486
  if (*(array_in + 39)) {
#line 1487
    return_value += 0.15;
  }
#line 1488
  if (*(array_in + 8) < (double const   )0.3) {
#line 1489
    return_value += 0.15;
  }
#line 1490
  if (*(array_in + 52)) {
#line 1491
    return_value += 0.2;
  } else
#line 1490
  if (*(array_in + 53)) {
#line 1491
    return_value += 0.2;
  }
#line 1492
  if (*(array_in + 61)) {
#line 1492
    if (*(array_in + 53)) {
#line 1493
      return_value += 0.2;
    }
  }
#line 1494
  if (*(array_in + 55)) {
#line 1495
    return_value += 0.1;
  }
#line 1496
  if (*(array_in + 67)) {
#line 1496
    if (*(array_in + 74)) {
#line 1497
      return_value += 0.1;
    }
  }
#line 1499
  if (*(array_in + 0) < (double const   )0.45) {
#line 1500
    return_value -= 0.3;
  }
#line 1501
  if (*(array_in + 20)) {
#line 1502
    return_value -= 0.1;
  }
#line 1503
  if (*(array_in + 30)) {
#line 1504
    return_value -= 0.3;
  }
#line 1505
  if (*(array_in + 47)) {
#line 1506
    return_value -= 0.3;
  } else
#line 1505
  if (*(array_in + 48)) {
#line 1506
    return_value -= 0.3;
  }
#line 1507
  if (*(array_in + 19) < (double const   )0.5) {
#line 1508
    return_value -= 0.2;
  }
#line 1509
  if (*(array_in + 49)) {
#line 1509
    if (! *(array_in + 58)) {
#line 1510
      return_value -= 0.3;
    }
  }
#line 1511
  if (*(array_in + 2) < (double const   )0.60) {
#line 1512
    return_value -= 0.3;
  }
#line 1513
  if (! *(array_in + 39)) {
#line 1514
    return_value -= 0.3;
  }
#line 1515
  if (*(array_in + 44)) {
#line 1516
    return_value -= 0.3;
  }
#line 1517
  if (*(array_in + 7) + (double const   )0.2 < *(array_in + 12)) {
#line 1518
    return_value -= 0.2;
  }
#line 1519
  if (*(array_in + 67)) {
#line 1519
    if (*(array_in + 88) > *(array_in + 90) + (double const   )0.1) {
#line 1520
      return_value -= 0.2;
    }
  }
#line 1521
  if (*(array_in + 67)) {
#line 1521
    if (! *(array_in + 72)) {
#line 1521
      if (! *(array_in + 74)) {
#line 1522
        return_value -= 0.2;
      }
    }
  }
#line 1523
  if (! *(array_in + 52)) {
#line 1523
    if (! *(array_in + 53)) {
#line 1523
      if (! *(array_in + 63)) {
#line 1524
        return_value -= 0.2;
      }
    }
  }
#line 1526
  return (return_value);
}
}
#line 1529 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_pey_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1532
  return_value = 0.0;
#line 1534
  if (*(array_in + 17)) {
#line 1535
    return_value += 0.1;
  }
#line 1536
  if (*(array_in + 22)) {
#line 1537
    return_value += 0.1;
  }
#line 1538
  if (*(array_in + 36)) {
#line 1539
    return_value += 0.1;
  }
#line 1540
  if (*(array_in + 4) < (double const   )0.47) {
#line 1541
    return_value += 0.2;
  }
#line 1542
  if (! *(array_in + 49)) {
#line 1542
    if (! *(array_in + 50)) {
#line 1543
      return_value += 0.2;
    } else {
#line 1542
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1542
  if (*(array_in + 58)) {
#line 1543
    return_value += 0.2;
  }
#line 1544
  if (*(array_in + 0) > (double const   )0.51) {
#line 1545
    return_value += 0.1;
  }
#line 1546
  if (*(array_in + 13)) {
#line 1547
    return_value += 0.1;
  }
#line 1549
  if (*(array_in + 19)) {
#line 1550
    return_value -= 0.3;
  }
#line 1551
  if (*(array_in + 20)) {
#line 1552
    return_value -= 0.3;
  }
#line 1553
  if (*(array_in + 21)) {
#line 1554
    return_value -= 0.1;
  }
#line 1555
  if (*(array_in + 8) == (double const   )1.0) {
#line 1556
    return_value -= 0.2;
  }
#line 1557
  if (*(array_in + 69)) {
#line 1558
    return_value -= 0.3;
  }
#line 1559
  if (*(array_in + 4) > (double const   )0.50) {
#line 1560
    return_value -= 0.3;
  }
#line 1561
  if (*(array_in + 1) < (double const   )0.3) {
#line 1562
    return_value -= 0.3;
  }
#line 1563
  if (*(array_in + 49)) {
#line 1563
    if (! *(array_in + 58)) {
#line 1564
      return_value -= 0.3;
    }
  }
#line 1565
  if (*(array_in + 0) < (double const   )0.5) {
#line 1566
    return_value -= 0.3;
  }
#line 1567
  if (*(array_in + 4) > (double const   )0.50) {
#line 1568
    return_value -= 0.2;
  }
#line 1569
  if (*(array_in + 2) < (double const   )0.45) {
#line 1570
    return_value -= 0.3;
  }
#line 1571
  if (*(array_in + 10) < (double const   )0.75) {
#line 1572
    return_value -= 0.3;
  }
#line 1573
  if (! *(array_in + 57)) {
#line 1574
    return_value -= 0.2;
  }
#line 1575
  if (*(array_in + 56)) {
#line 1576
    return_value -= 0.2;
  }
#line 1578
  return (return_value);
}
}
#line 1581 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_tzadi(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1584
  return_value = 0.0;
#line 1586
  if (*(array_in + 23)) {
#line 1587
    return_value += 0.2;
  }
#line 1588
  if (*(array_in + 13)) {
#line 1589
    return_value += 0.1;
  }
#line 1590
  if (*(array_in + 27)) {
#line 1591
    return_value += 0.1;
  }
#line 1592
  if (*(array_in + 30)) {
#line 1593
    return_value += 0.1;
  }
#line 1594
  if (*(array_in + 10) < *(array_in + 12)) {
#line 1595
    return_value += 0.1;
  }
#line 1596
  if (*(array_in + 41)) {
#line 1597
    return_value += 0.2;
  } else
#line 1596
  if (*(array_in + 42)) {
#line 1597
    return_value += 0.2;
  }
#line 1598
  if (*(array_in + 62)) {
#line 1599
    return_value += 0.1;
  }
#line 1601
  if (*(array_in + 10) < *(array_in + 12)) {
#line 1602
    return_value -= 0.1;
  }
#line 1603
  if (*(array_in + 47)) {
#line 1604
    return_value -= 0.2;
  }
#line 1605
  if (! *(array_in + 19)) {
#line 1606
    return_value -= 0.2;
  }
#line 1607
  if (*(array_in + 46)) {
#line 1608
    return_value -= 0.2;
  }
#line 1609
  if (*(array_in + 57)) {
#line 1610
    return_value -= 0.2;
  }
#line 1611
  if (! *(array_in + 55)) {
#line 1612
    return_value -= 0.2;
  }
#line 1613
  if (! *(array_in + 41)) {
#line 1613
    if (! *(array_in + 42)) {
#line 1614
      return_value -= 0.2;
    }
  }
#line 1615
  if (! *(array_in + 62)) {
#line 1615
    if (! *(array_in + 66)) {
#line 1616
      return_value -= 0.2;
    }
  }
#line 1617
  if (*(array_in + 1) < (double const   )0.3) {
#line 1618
    return_value -= 0.2;
  }
#line 1619
  if (! *(array_in + 51)) {
#line 1620
    return_value -= 0.2;
  }
#line 1621
  if (*(array_in + 52)) {
#line 1622
    return_value -= 0.2;
  }
#line 1624
  return (return_value);
}
}
#line 1627 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_tzadi_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1630
  return_value = 0.0;
#line 1632
  if (*(array_in + 22)) {
#line 1633
    return_value += 0.1;
  } else
#line 1632
  if (*(array_in + 20)) {
#line 1633
    return_value += 0.1;
  }
#line 1634
  if (*(array_in + 4) < (double const   )0.47) {
#line 1635
    return_value += 0.3;
  }
#line 1636
  if (*(array_in + 31)) {
#line 1637
    return_value += 0.1;
  }
#line 1638
  if (*(array_in + 33)) {
#line 1639
    return_value += 0.1;
  }
#line 1640
  if (*(array_in + 59)) {
#line 1641
    return_value += 0.1;
  } else
#line 1640
  if (*(array_in + 62)) {
#line 1641
    return_value += 0.1;
  }
#line 1643
  if (*(array_in + 19)) {
#line 1644
    return_value -= 0.3;
  }
#line 1645
  if (*(array_in + 69)) {
#line 1646
    return_value -= 0.3;
  }
#line 1647
  if (*(array_in + 4) > (double const   )0.51) {
#line 1648
    return_value -= 0.3;
  }
#line 1649
  if (*(array_in + 1) < (double const   )0.3) {
#line 1650
    return_value -= 0.3;
  }
#line 1651
  if (*(array_in + 27)) {
#line 1652
    return_value -= 0.3;
  }
#line 1653
  if (*(array_in + 14)) {
#line 1654
    return_value -= 0.3;
  }
#line 1655
  if (*(array_in + 0) < (double const   )0.5) {
#line 1656
    return_value -= 0.3;
  }
#line 1657
  if (*(array_in + 17)) {
#line 1658
    return_value -= 0.2;
  }
#line 1660
  return (return_value);
}
}
#line 1663 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_kuf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1666
  return_value = 0.0;
#line 1668
  if (*(array_in + 69)) {
#line 1669
    return_value += 0.2;
  }
#line 1670
  if (*(array_in + 37)) {
#line 1671
    return_value += 0.1;
  }
#line 1672
  if (*(array_in + 17)) {
#line 1673
    return_value += 0.1;
  }
#line 1674
  if (*(array_in + 4) < (double const   )0.47) {
#line 1675
    return_value += 0.3;
  }
#line 1676
  if (*(array_in + 55)) {
#line 1677
    return_value += 0.1;
  }
#line 1679
  if (*(array_in + 10) > *(array_in + 12) - (double const   )0.2) {
#line 1680
    return_value -= 0.2;
  }
#line 1681
  if (*(array_in + 12) < (double const   )0.3) {
#line 1682
    return_value -= 0.2;
  }
#line 1683
  if (*(array_in + 0) < (double const   )0.53) {
#line 1684
    return_value -= 0.2;
  }
#line 1685
  if (*(array_in + 4) > (double const   )0.45) {
#line 1686
    return_value -= 0.3;
  }
#line 1687
  if (*(array_in + 2) < (double const   )0.60) {
#line 1688
    return_value -= 0.3;
  }
#line 1689
  if (! *(array_in + 17)) {
#line 1690
    return_value -= 0.1;
  }
#line 1691
  if (*(array_in + 30) > (double const   )0.1) {
#line 1692
    return_value -= 0.1;
  }
#line 1693
  if (*(array_in + 19)) {
#line 1694
    return_value -= 0.1;
  }
#line 1695
  if (! *(array_in + 17)) {
#line 1696
    return_value -= 0.15;
  }
#line 1698
  return (return_value);
}
}
#line 1701 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_resh(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1704
  return_value = 0.0;
#line 1706
  if (*(array_in + 17)) {
#line 1707
    return_value += 0.1;
  }
#line 1708
  if (*(array_in + 22)) {
#line 1709
    return_value += 0.1;
  }
#line 1710
  if (! *(array_in + 19)) {
#line 1711
    return_value += 0.1;
  }
#line 1712
  if (! *(array_in + 20)) {
#line 1713
    return_value += 0.1;
  }
#line 1714
  if (! *(array_in + 28)) {
#line 1715
    return_value += 0.1;
  }
#line 1716
  if (*(array_in + 36)) {
#line 1717
    return_value += 0.1;
  }
#line 1719
  if (*(array_in + 19)) {
#line 1720
    return_value -= 0.3;
  }
#line 1721
  if (*(array_in + 47)) {
#line 1722
    return_value -= 0.2;
  } else
#line 1721
  if (*(array_in + 48)) {
#line 1722
    return_value -= 0.2;
  }
#line 1723
  if (*(array_in + 20)) {
#line 1724
    return_value -= 0.3;
  }
#line 1725
  if (*(array_in + 21)) {
#line 1726
    return_value -= 0.1;
  }
#line 1727
  if (*(array_in + 69)) {
#line 1728
    return_value -= 0.3;
  }
#line 1729
  if (*(array_in + 4) > (double const   )0.60) {
#line 1730
    return_value -= 0.3;
  }
#line 1731
  if (*(array_in + 4) < (double const   )0.45) {
#line 1732
    return_value -= 0.3;
  }
#line 1733
  if (*(array_in + 28)) {
#line 1734
    return_value -= 0.1;
  }
#line 1735
  if (*(array_in + 1) < (double const   )0.3) {
#line 1736
    return_value -= 0.3;
  }
#line 1737
  if (*(array_in + 2) < (double const   )0.6) {
#line 1738
    return_value -= 0.3;
  }
#line 1739
  if (*(array_in + 14)) {
#line 1740
    return_value -= 0.3;
  }
#line 1741
  if (*(array_in + 10) < (double const   )0.9) {
#line 1742
    return_value -= 0.3;
  }
#line 1743
  if (*(array_in + 8) < (double const   )0.9) {
#line 1744
    return_value -= 0.3;
  }
#line 1745
  if (*(array_in + 1) < (double const   )0.35) {
#line 1746
    return_value -= 0.2;
  } else
#line 1745
  if (*(array_in + 0) < (double const   )0.35) {
#line 1746
    return_value -= 0.2;
  }
#line 1747
  if (*(array_in + 1) < (double const   )0.25) {
#line 1748
    return_value -= 0.2;
  }
#line 1750
  return (return_value);
}
}
#line 1753 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_shin(double const   *array_in ) 
{ 
  int count_edges ;
  int count_notches ;
  double return_value ;

  {
#line 1758
  return_value = 0.0;
#line 1760
  count_edges = (int )((*(array_in + 33) * (double const   )10.0 + *(array_in + 32) * (double const   )10.0) + *(array_in + 31) * (double const   )10);
#line 1762
  count_notches = (int )((*(array_in + 45) * (double const   )10.0 + *(array_in + 44) * (double const   )10.0) + *(array_in + 43) * (double const   )10);
#line 1765
  if (*(array_in + 68)) {
#line 1766
    return_value += 0.3;
  }
#line 1767
  if (*(array_in + 15)) {
#line 1768
    return_value += 0.3;
  }
#line 1769
  if (*(array_in + 43)) {
#line 1770
    return_value += 0.1;
  }
#line 1771
  if (*(array_in + 45)) {
#line 1772
    return_value += 0.1;
  }
#line 1773
  if (*(array_in + 31)) {
#line 1774
    return_value += 0.1;
  }
#line 1775
  if (*(array_in + 33)) {
#line 1776
    return_value += 0.1;
  }
#line 1777
  if (count_edges == 3) {
#line 1778
    return_value += 0.2;
  }
#line 1779
  if (count_notches == 2) {
#line 1780
    return_value += 0.2;
  }
#line 1781
  if (*(array_in + 65)) {
#line 1782
    return_value += 0.2;
  }
#line 1783
  if (*(array_in + 64)) {
#line 1784
    return_value += 0.2;
  }
#line 1786
  if (*(array_in + 47)) {
#line 1787
    return_value -= 0.2;
  }
#line 1788
  if (! *(array_in + 45)) {
#line 1788
    if (! *(array_in + 44)) {
#line 1789
      return_value -= 0.2;
    }
  }
#line 1790
  if (count_edges != 3) {
#line 1791
    return_value -= 0.1;
  }
#line 1793
  return (return_value);
}
}
#line 1796 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_1.c"
double ho_recognize_font_1_tav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 1799
  return_value = 0.0;
#line 1801
  if (*(array_in + 17)) {
#line 1802
    return_value += 0.1;
  }
#line 1803
  if (*(array_in + 20)) {
#line 1804
    return_value += 0.1;
  }
#line 1805
  if (*(array_in + 22)) {
#line 1806
    return_value += 0.1;
  }
#line 1807
  if (*(array_in + 94)) {
#line 1808
    return_value += 0.2;
  }
#line 1809
  if (*(array_in + 27)) {
#line 1810
    return_value += 0.2;
  }
#line 1811
  if (*(array_in + 5) > *(array_in + 10) + (double const   )0.15) {
#line 1812
    return_value += 0.1;
  }
#line 1814
  if (*(array_in + 19)) {
#line 1815
    return_value -= 0.2;
  }
#line 1816
  if (! *(array_in + 27)) {
#line 1817
    return_value -= 0.3;
  }
#line 1818
  if (*(array_in + 11) < (double const   )0.9) {
#line 1819
    return_value -= 0.2;
  }
#line 1820
  if (*(array_in + 44)) {
#line 1821
    return_value -= 0.1;
  } else
#line 1820
  if (*(array_in + 45)) {
#line 1821
    return_value -= 0.1;
  }
#line 1822
  if (*(array_in + 40)) {
#line 1823
    return_value -= 0.1;
  } else
#line 1822
  if (*(array_in + 41)) {
#line 1823
    return_value -= 0.1;
  }
#line 1824
  if (*(array_in + 2) < (double const   )0.3) {
#line 1825
    return_value -= 0.3;
  }
#line 1826
  if (*(array_in + 10) > (double const   )0.8) {
#line 1827
    return_value -= 0.3;
  }
#line 1828
  if (*(array_in + 10) < *(array_in + 8) + (double const   )0.1) {
#line 1829
    return_value -= 0.2;
  }
#line 1830
  if (*(array_in + 69)) {
#line 1831
    return_value -= 0.1;
  }
#line 1832
  if (*(array_in + 1) < (double const   )0.3) {
#line 1833
    return_value -= 0.2;
  }
#line 1834
  if (*(array_in + 0) < (double const   )0.35) {
#line 1835
    return_value -= 0.2;
  }
#line 1837
  return (return_value);
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.h"
ho_pixbuf *ho_pixbuf_new(unsigned char const   n_channels , int const   width , int const   height ,
                         int const   rowstride ) ;
#line 189
int ho_pixbuf_free(ho_pixbuf *pix ) ;
#line 505
ho_pixbuf *ho_pixbuf_pnm_load(char const   *filename ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.h"
ho_bitmap *ho_font_second_object(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 61
ho_bitmap *ho_font_holes(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 69
ho_bitmap *ho_font_hbars(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 77
ho_bitmap *ho_font_vbars(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 85
ho_bitmap *ho_font_diagonal(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 94
ho_bitmap *ho_font_diagonal_left(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 103
ho_bitmap *ho_font_thin_naive(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 112
ho_bitmap *ho_font_thin(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 120
ho_bitmap *ho_font_cross(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 128
ho_bitmap *ho_font_ends(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 136
ho_bitmap *ho_font_edges_top(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 145
ho_bitmap *ho_font_edges_top_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 154
ho_bitmap *ho_font_edges_bottom(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 164
ho_bitmap *ho_font_edges_bottom_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 173
ho_bitmap *ho_font_edges_left(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 182
ho_bitmap *ho_font_edges_left_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 191
ho_bitmap *ho_font_edges_right(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 200
ho_bitmap *ho_font_edges_right_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 209
ho_bitmap *ho_font_notch_top(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 218
ho_bitmap *ho_font_notch_bottom(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 227
ho_bitmap *ho_font_notch_left(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 236
ho_bitmap *ho_font_notch_right(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) ;
#line 246
ho_bitmap *ho_font_filter(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                          int filter_index ) ;
#line 256
ho_bitmap *ho_font_holes_filter(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                int filter_index ) ;
#line 268
int ho_font_pnm_save(ho_bitmap const   *m_text , ho_bitmap const   *m_nikud , ho_bitmap const   *m_mask ,
                     char const   *filename ) ;
#line 281
int ho_font_pnm_load(ho_bitmap **m_text , ho_bitmap **m_nikud , ho_bitmap **m_mask ,
                     char const   *filename ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_main_sign(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_objmap *o_obj ;
  ho_bitmap *m_sign_mask ;
  ho_bitmap *m_current_object ;
  int x ;
  int y ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int i ;
  int line_start ;
  int line_end ;
  int line_height ;
  unsigned char is_inside ;
  unsigned char is_dot ;
  int count_dots ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 50
  o_obj = (ho_objmap *)((void *)0);
#line 51
  m_sign_mask = (ho_bitmap *)((void *)0);
#line 52
  m_current_object = (ho_bitmap *)((void *)0);
#line 61
  x = (int )(m_mask->width / 2);
#line 62
  y = 0;
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
#line 62
    if (y < (int )m_mask->height) {
#line 62
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 62
        tmp = 1;
      } else {
#line 62
        tmp = 0;
      }
#line 62
      if (tmp) {
#line 62
        goto while_break;
      }
    } else {
#line 62
      goto while_break;
    }
#line 62
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  line_start = y - 1;
  {
#line 64
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 64
    if (y < (int )m_mask->height) {
#line 64
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 64
        tmp___0 = 1;
      } else {
#line 64
        tmp___0 = 0;
      }
#line 64
      if (! tmp___0) {
#line 64
        goto while_break___0;
      }
    } else {
#line 64
      goto while_break___0;
    }
#line 64
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 65
  line_end = y;
#line 66
  line_height = line_end - line_start;
#line 69
  o_obj = ho_objmap_new_from_bitmap(m_text);
  }
#line 70
  if (! o_obj) {
#line 71
    return ((ho_bitmap *)((void *)0));
  }
#line 74
  if ((o_obj->obj_list)->size == 1) {
    {
#line 76
    ho_objmap_free(o_obj);
#line 77
    m_sign_mask = ho_bitmap_clone(m_text);
#line 80
    ho_bitmap_delete_hline(m_sign_mask, (int const   )0, (int const   )0, (int const   )m_sign_mask->width);
#line 81
    ho_bitmap_delete_hline(m_sign_mask, (int const   )0, (int const   )(m_sign_mask->height - 1),
                           (int const   )m_sign_mask->width);
    }
#line 84
    return (m_sign_mask);
  }
  {
#line 88
  m_sign_mask = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 89
  if (! m_sign_mask) {
#line 90
    return ((ho_bitmap *)((void *)0));
  }
#line 93
  count_dots = 0;
#line 94
  i = 0;
  {
#line 94
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 94
    if (! (i < (o_obj->obj_list)->size)) {
#line 94
      goto while_break___1;
    }
#line 97
    y1___0 = ((o_obj->obj_list)->objects + i)->y;
#line 98
    y2 = ((o_obj->obj_list)->objects + i)->y + ((o_obj->obj_list)->objects + i)->height;
#line 102
    x1 = ((o_obj->obj_list)->objects + i)->x;
#line 103
    x2 = ((o_obj->obj_list)->objects + i)->x + ((o_obj->obj_list)->objects + i)->width;
#line 106
    if (y1___0 >= line_start) {
#line 106
      if (y1___0 < line_end - line_height / 10) {
#line 106
        tmp___1 = 1;
      } else {
#line 106
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 106
    if (y2 > line_start + line_height / 10) {
#line 106
      if (y2 <= line_end) {
#line 106
        tmp___1 = 1;
      } else {
#line 106
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 106
    if (y1___0 <= line_start) {
#line 106
      if (y2 >= line_end) {
#line 106
        tmp___1 = 1;
      } else {
#line 106
        tmp___1 = 0;
      }
    } else {
#line 106
      tmp___1 = 0;
    }
#line 106
    is_inside = (unsigned char )tmp___1;
#line 111
    if (y2 - y1___0 < line_height / 4) {
#line 111
      if (y2 - y1___0 > line_height / 16) {
#line 111
        if (x2 - x1 < line_height / 4) {
#line 111
          if (x2 - x1 > line_height / 16) {
#line 111
            tmp___2 = 1;
          } else {
#line 111
            tmp___2 = 0;
          }
        } else {
#line 111
          tmp___2 = 0;
        }
      } else {
#line 111
        tmp___2 = 0;
      }
    } else {
#line 111
      tmp___2 = 0;
    }
#line 111
    is_dot = (unsigned char )tmp___2;
#line 115
    if (is_dot) {
#line 115
      if (is_inside) {
#line 116
        count_dots ++;
      }
    }
#line 117
    if (count_dots > 2) {
#line 118
      is_dot = (unsigned char)0;
    }
#line 120
    if (is_inside) {
#line 120
      if (! is_dot) {
        {
#line 123
        m_current_object = ho_objmap_to_bitmap_by_index((ho_objmap const   *)o_obj,
                                                        (int const   )i);
        }
#line 124
        if (m_current_object) {
          {
#line 126
          ho_bitmap_or(m_sign_mask, (ho_bitmap const   *)m_current_object);
#line 128
          ho_bitmap_free(m_current_object);
          }
        }
      }
    }
#line 94
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 134
  ho_bitmap_delete_hline(m_sign_mask, (int const   )0, (int const   )0, (int const   )m_sign_mask->width);
#line 135
  ho_bitmap_delete_hline(m_sign_mask, (int const   )0, (int const   )(m_sign_mask->height - 1),
                         (int const   )m_sign_mask->width);
#line 138
  ho_objmap_free(o_obj);
  }
#line 140
  return (m_sign_mask);
}
}
#line 143 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_second_object(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_objmap *o_obj ;
  ho_bitmap *m_sign_mask ;
  ho_bitmap *m_current_object ;
  int x ;
  int y ;
  int i ;
  int dy ;
  int line_start ;
  int line_end ;
  int line_height ;
  int tmp ;
  int tmp___0 ;

  {
#line 146
  o_obj = (ho_objmap *)((void *)0);
#line 147
  m_sign_mask = (ho_bitmap *)((void *)0);
#line 148
  m_current_object = (ho_bitmap *)((void *)0);
#line 154
  x = (int )(m_mask->width / 2);
#line 155
  y = 0;
  {
#line 155
  while (1) {
    while_continue: /* CIL Label */ ;
#line 155
    if (y < (int )m_mask->height) {
#line 155
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 155
        tmp = 1;
      } else {
#line 155
        tmp = 0;
      }
#line 155
      if (tmp) {
#line 155
        goto while_break;
      }
    } else {
#line 155
      goto while_break;
    }
#line 155
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 156
  line_start = y - 1;
  {
#line 157
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 157
    if (y < (int )m_mask->height) {
#line 157
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 157
        tmp___0 = 1;
      } else {
#line 157
        tmp___0 = 0;
      }
#line 157
      if (! tmp___0) {
#line 157
        goto while_break___0;
      }
    } else {
#line 157
      goto while_break___0;
    }
#line 157
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 158
  line_end = y;
#line 159
  line_height = line_end - line_start;
#line 162
  o_obj = ho_objmap_new_from_bitmap(m_text);
  }
#line 163
  if (! o_obj) {
#line 164
    return ((ho_bitmap *)((void *)0));
  }
#line 167
  if ((o_obj->obj_list)->size < 2) {
    {
#line 169
    ho_objmap_free(o_obj);
    }
#line 171
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 175
  m_sign_mask = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 176
  if (! m_sign_mask) {
#line 177
    return ((ho_bitmap *)((void *)0));
  }
#line 180
  dy = line_height / 10;
#line 181
  if (dy == 0) {
#line 182
    dy = 1;
  }
#line 183
  i = 0;
#line 183
  y = line_end - 1;
#line 183
  x = 1;
  {
#line 183
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 183
    if (x < o_obj->width) {
#line 183
      if (y > 0) {
#line 183
        if (! (! i)) {
#line 183
          goto while_break___1;
        }
      } else {
#line 183
        goto while_break___1;
      }
    } else {
#line 183
      goto while_break___1;
    }
#line 186
    i = *(o_obj->map + (x + y * o_obj->width));
#line 187
    if (! i) {
#line 187
      if (y > dy) {
#line 188
        i = *(o_obj->map + (x + (y - dy) * o_obj->width));
      }
    }
#line 189
    if (! i) {
#line 189
      if (y < o_obj->height - dy) {
#line 190
        i = *(o_obj->map + (x + (y + dy) * o_obj->width));
      }
    }
#line 183
    x ++;
#line 183
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 193
  if (i) {
    {
#line 194
    m_current_object = ho_objmap_to_bitmap_by_index((ho_objmap const   *)o_obj, (int const   )(i - 1));
    }
  }
#line 195
  if (m_current_object) {
    {
#line 197
    ho_bitmap_or(m_sign_mask, (ho_bitmap const   *)m_current_object);
#line 199
    ho_bitmap_free(m_current_object);
    }
  }
  {
#line 202
  ho_objmap_free(o_obj);
  }
#line 204
  return (m_sign_mask);
}
}
#line 207 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_holes(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_negative ;
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int line_height ;
  int tmp ;
  int tmp___0 ;

  {
#line 210
  m_negative = (ho_bitmap *)((void *)0);
#line 211
  m_out = (ho_bitmap *)((void *)0);
#line 215
  x = (int )(m_mask->width / 2);
#line 216
  y = 0;
  {
#line 216
  while (1) {
    while_continue: /* CIL Label */ ;
#line 216
    if (y < (int )m_mask->height) {
#line 216
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 216
        tmp = 1;
      } else {
#line 216
        tmp = 0;
      }
#line 216
      if (tmp) {
#line 216
        goto while_break;
      }
    } else {
#line 216
      goto while_break;
    }
#line 216
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 217
  line_height = y - 1;
  {
#line 218
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 218
    if (y < (int )m_mask->height) {
#line 218
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 218
        tmp___0 = 1;
      } else {
#line 218
        tmp___0 = 0;
      }
#line 218
      if (! tmp___0) {
#line 218
        goto while_break___0;
      }
    } else {
#line 218
      goto while_break___0;
    }
#line 218
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 219
  line_height = y - line_height;
#line 221
  m_negative = ho_bitmap_not(m_text);
  }
#line 222
  if (! m_negative) {
#line 223
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 226
  ho_bitmap_draw_vline(m_negative, (int const   )1, (int const   )0, (int const   )(m_negative->height - 1));
#line 227
  ho_bitmap_draw_vline(m_negative, (int const   )(m_negative->width - 1), (int const   )0,
                       (int const   )(m_negative->height - 1));
#line 229
  ho_bitmap_draw_hline(m_negative, (int const   )0, (int const   )0, (int const   )(m_negative->width - 1));
#line 230
  ho_bitmap_draw_hline(m_negative, (int const   )0, (int const   )(m_negative->height - 2),
                       (int const   )(m_negative->width - 1));
#line 233
  m_out = ho_bitmap_filter_by_size((ho_bitmap const   *)m_negative, line_height / 5,
                                   m_negative->height - 2, line_height / 10, m_negative->width - 2);
#line 237
  ho_bitmap_free(m_negative);
  }
#line 239
  return (m_out);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_hbars(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_main_font ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_bars ;
  ho_bitmap *m_out ;
  int i ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int number_of_parts ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int min_y ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 245
  m_main_font = (ho_bitmap *)((void *)0);
#line 246
  m_temp = (ho_bitmap *)((void *)0);
#line 247
  m_bars = (ho_bitmap *)((void *)0);
#line 248
  m_out = (ho_bitmap *)((void *)0);
#line 250
  number_of_parts = 20;
#line 251
  threshold = 65;
#line 255
  sum = 0;
#line 256
  y = 0;
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (y < (int )m_mask->height) {
#line 256
      if (! (sum == 0)) {
#line 256
        goto while_break;
      }
    } else {
#line 256
      goto while_break;
    }
#line 257
    sum = 0;
#line 257
    x = 0;
    {
#line 257
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 257
      if (! (x < (int )m_text->width)) {
#line 257
        goto while_break___0;
      }
#line 258
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 258
        tmp = 1;
      } else {
#line 258
        tmp = 0;
      }
#line 258
      sum += tmp;
#line 257
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 256
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 259
  y_start = y - 1;
#line 260
  sum = 0;
#line 261
  y = (int )(m_mask->height - 1);
  {
#line 261
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 261
    if (y > y_start) {
#line 261
      if (! (sum == 0)) {
#line 261
        goto while_break___1;
      }
    } else {
#line 261
      goto while_break___1;
    }
#line 262
    sum = 0;
#line 262
    x = 0;
    {
#line 262
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 262
      if (! (x < (int )m_text->width)) {
#line 262
        goto while_break___2;
      }
#line 263
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 263
        tmp___0 = 1;
      } else {
#line 263
        tmp___0 = 0;
      }
#line 263
      sum += tmp___0;
#line 262
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 261
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 264
  line_height = (y - y_start) + 1;
#line 266
  if (! line_height) {
#line 267
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 270
  m_temp = ho_bitmap_clone(m_text);
  }
#line 271
  if (! m_temp) {
#line 272
    return ((ho_bitmap *)((void *)0));
  }
#line 273
  m_main_font = m_temp;
#line 276
  if (line_height / number_of_parts < 3) {
#line 277
    number_of_parts = line_height / 3;
  }
#line 280
  i = 1;
  {
#line 280
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 280
    if (! (i < number_of_parts)) {
#line 280
      goto while_break___3;
    }
    {
#line 281
    ho_bitmap_delete_hline(m_main_font, (int const   )0, (int const   )(y_start + (i * line_height) / number_of_parts),
                           m_text->width);
#line 280
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 285
  m_bars = ho_bitmap_filter_by_size((ho_bitmap const   *)m_main_font, 1, line_height * 2,
                                    (threshold * (int )m_text->width) / 100, (int )(m_text->width + 5));
#line 288
  ho_bitmap_free(m_main_font);
  }
#line 289
  if (! m_bars) {
#line 290
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 293
  m_out = ho_bitmap_vlink((ho_bitmap const   *)m_bars, (int const   )3);
#line 294
  ho_bitmap_free(m_bars);
#line 295
  ho_bitmap_and(m_out, m_text);
#line 298
  y = y_start;
  }
  {
#line 298
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 298
    if (! (y < y_start + line_height)) {
#line 298
      goto while_break___4;
    }
#line 299
    x = 0;
    {
#line 299
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 299
      if (! (x < (int )m_text->width)) {
#line 299
        goto while_break___5;
      }
#line 301
      if (((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 301
        tmp___1 = 1;
      } else {
#line 301
        tmp___1 = 0;
      }
#line 301
      if (tmp___1) {
        {
#line 303
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
#line 304
        goto __Cont;
      }
      __Cont: /* CIL Label */ 
#line 299
      x ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 298
    y ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 308
  m_temp = m_out;
#line 309
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 310
  if (! m_out) {
#line 311
    return ((ho_bitmap *)((void *)0));
  }
#line 316
  y = 1;
  {
#line 317
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 317
    if (y < (int )m_text->height) {
#line 317
      if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 317
        tmp___2 = 1;
      } else {
#line 317
        tmp___2 = 0;
      }
#line 317
      if (tmp___2) {
#line 317
        goto while_break___6;
      }
    } else {
#line 317
      goto while_break___6;
    }
#line 317
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 318
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 318
    if (! (y < (int )m_text->height)) {
#line 318
      goto while_break___7;
    }
#line 321
    min_y = y - 1;
    {
#line 322
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 322
      if (y < (int )m_text->height) {
#line 322
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 322
          tmp___3 = 1;
        } else {
#line 322
          tmp___3 = 0;
        }
#line 322
        if (! tmp___3) {
#line 322
          goto while_break___8;
        }
      } else {
#line 322
        goto while_break___8;
      }
#line 322
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 325
    ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )((y + min_y) / 2),
                         (int const   )m_out->width);
    }
    {
#line 327
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 327
      if (y < (int )m_text->height) {
#line 327
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 327
          tmp___4 = 1;
        } else {
#line 327
          tmp___4 = 0;
        }
#line 327
        if (tmp___4) {
#line 327
          goto while_break___9;
        }
      } else {
#line 327
        goto while_break___9;
      }
#line 327
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 331
  ho_bitmap_free(m_temp);
#line 334
  m_out->x = (int )m_text->x;
#line 335
  m_out->y = (int )m_text->y;
  }
#line 337
  return (m_out);
}
}
#line 340 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_vbars(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_main_font ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_bars ;
  ho_bitmap *m_out ;
  int sum ;
  int i ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int number_of_parts ;
  int threshold ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int min_x ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 343
  m_main_font = (ho_bitmap *)((void *)0);
#line 344
  m_temp = (ho_bitmap *)((void *)0);
#line 345
  m_bars = (ho_bitmap *)((void *)0);
#line 346
  m_out = (ho_bitmap *)((void *)0);
#line 348
  number_of_parts = 12;
#line 349
  threshold = 70;
#line 352
  sum = 0;
#line 353
  y = 0;
  {
#line 353
  while (1) {
    while_continue: /* CIL Label */ ;
#line 353
    if (y < (int )m_mask->height) {
#line 353
      if (! (sum == 0)) {
#line 353
        goto while_break;
      }
    } else {
#line 353
      goto while_break;
    }
#line 354
    sum = 0;
#line 354
    x = 0;
    {
#line 354
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 354
      if (! (x < (int )m_text->width)) {
#line 354
        goto while_break___0;
      }
#line 355
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 355
        tmp = 1;
      } else {
#line 355
        tmp = 0;
      }
#line 355
      sum += tmp;
#line 354
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 353
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 356
  y_start = y - 1;
#line 357
  sum = 0;
#line 358
  y = (int )(m_mask->height - 1);
  {
#line 358
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 358
    if (y > y_start) {
#line 358
      if (! (sum == 0)) {
#line 358
        goto while_break___1;
      }
    } else {
#line 358
      goto while_break___1;
    }
#line 359
    sum = 0;
#line 359
    x = 0;
    {
#line 359
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 359
      if (! (x < (int )m_text->width)) {
#line 359
        goto while_break___2;
      }
#line 360
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 360
        tmp___0 = 1;
      } else {
#line 360
        tmp___0 = 0;
      }
#line 360
      sum += tmp___0;
#line 359
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 358
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 361
  line_height = (y - y_start) + 1;
#line 363
  if (! line_height) {
#line 364
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 366
  m_temp = ho_bitmap_clone(m_text);
  }
#line 367
  if (! m_temp) {
#line 368
    return ((ho_bitmap *)((void *)0));
  }
#line 369
  m_main_font = m_temp;
#line 372
  if (m_text->width / (int const   )number_of_parts < 3) {
#line 373
    number_of_parts = (int )(m_text->width / 3);
  }
#line 376
  i = 1;
  {
#line 376
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 376
    if (! (i < number_of_parts)) {
#line 376
      goto while_break___3;
    }
    {
#line 377
    ho_bitmap_delete_vline(m_main_font, (int const   )((i * (int )m_text->width) / number_of_parts),
                           (int const   )0, m_text->height);
#line 376
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 381
  m_bars = ho_bitmap_filter_by_size((ho_bitmap const   *)m_main_font, (threshold * line_height) / 100,
                                    line_height * 2, 1, (int )m_text->width);
#line 384
  ho_bitmap_free(m_main_font);
  }
#line 385
  if (! m_bars) {
#line 386
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 389
  m_out = ho_bitmap_hlink((ho_bitmap const   *)m_bars, (int const   )3);
#line 390
  ho_bitmap_free(m_bars);
#line 391
  ho_bitmap_and(m_out, m_text);
#line 394
  x = 0;
  }
  {
#line 394
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 394
    if (! (x < (int )m_text->width)) {
#line 394
      goto while_break___4;
    }
#line 395
    y = y_start;
    {
#line 395
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 395
      if (! (y < y_start + line_height)) {
#line 395
        goto while_break___5;
      }
#line 397
      if (((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 397
        tmp___1 = 1;
      } else {
#line 397
        tmp___1 = 0;
      }
#line 397
      if (tmp___1) {
        {
#line 399
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, m_text->height);
        }
#line 400
        goto __Cont;
      }
      __Cont: /* CIL Label */ 
#line 395
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 394
    x ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 404
  m_temp = m_out;
#line 405
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 406
  if (! m_out) {
#line 407
    return ((ho_bitmap *)((void *)0));
  }
#line 412
  x = 1;
  {
#line 413
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 413
    if (x < (int )m_text->width) {
#line 413
      if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 413
        tmp___2 = 1;
      } else {
#line 413
        tmp___2 = 0;
      }
#line 413
      if (tmp___2) {
#line 413
        goto while_break___6;
      }
    } else {
#line 413
      goto while_break___6;
    }
#line 413
    x ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 414
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 414
    if (! (x < (int )m_text->width)) {
#line 414
      goto while_break___7;
    }
#line 417
    min_x = x - 1;
    {
#line 418
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 418
      if (x < (int )m_text->width) {
#line 418
        if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 418
          tmp___3 = 1;
        } else {
#line 418
          tmp___3 = 0;
        }
#line 418
        if (! tmp___3) {
#line 418
          goto while_break___8;
        }
      } else {
#line 418
        goto while_break___8;
      }
#line 418
      x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 421
    ho_bitmap_draw_vline(m_out, (int const   )((x + min_x) / 2), (int const   )0,
                         (int const   )m_out->height);
    }
    {
#line 423
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 423
      if (x < (int )m_text->width) {
#line 423
        if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 423
          tmp___4 = 1;
        } else {
#line 423
          tmp___4 = 0;
        }
#line 423
        if (tmp___4) {
#line 423
          goto while_break___9;
        }
      } else {
#line 423
        goto while_break___9;
      }
#line 423
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 427
  ho_bitmap_free(m_temp);
#line 430
  m_out->x = (int )m_text->x;
#line 431
  m_out->y = (int )m_text->y;
  }
#line 433
  return (m_out);
}
}
#line 436 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_diagonal(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_diagonal_mask ;
  ho_bitmap *m_main_font ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_bars ;
  int sum ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int threshold ;
  int tmp ;
  int tmp___0 ;

  {
#line 439
  m_diagonal_mask = (ho_bitmap *)((void *)0);
#line 440
  m_main_font = (ho_bitmap *)((void *)0);
#line 441
  m_temp = (ho_bitmap *)((void *)0);
#line 442
  m_bars = (ho_bitmap *)((void *)0);
#line 444
  threshold = 90;
#line 447
  sum = 0;
#line 448
  y = 0;
  {
#line 448
  while (1) {
    while_continue: /* CIL Label */ ;
#line 448
    if (y < (int )m_mask->height) {
#line 448
      if (! (sum == 0)) {
#line 448
        goto while_break;
      }
    } else {
#line 448
      goto while_break;
    }
#line 449
    sum = 0;
#line 449
    x = 0;
    {
#line 449
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 449
      if (! (x < (int )m_text->width)) {
#line 449
        goto while_break___0;
      }
#line 450
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 450
        tmp = 1;
      } else {
#line 450
        tmp = 0;
      }
#line 450
      sum += tmp;
#line 449
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 451
  y_start = y - 1;
#line 452
  sum = 0;
#line 453
  y = (int )(m_mask->height - 1);
  {
#line 453
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 453
    if (y > y_start) {
#line 453
      if (! (sum == 0)) {
#line 453
        goto while_break___1;
      }
    } else {
#line 453
      goto while_break___1;
    }
#line 454
    sum = 0;
#line 454
    x = 0;
    {
#line 454
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 454
      if (! (x < (int )m_text->width)) {
#line 454
        goto while_break___2;
      }
#line 455
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 455
        tmp___0 = 1;
      } else {
#line 455
        tmp___0 = 0;
      }
#line 455
      sum += tmp___0;
#line 454
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 453
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 456
  line_height = (y - y_start) + 1;
#line 458
  if (! line_height) {
#line 459
    return ((ho_bitmap *)((void *)0));
  } else
#line 458
  if (! m_mask->width) {
#line 459
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 462
  m_temp = ho_bitmap_clone(m_text);
  }
#line 463
  if (! m_temp) {
#line 464
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 465
  m_main_font = m_temp;
#line 468
  m_diagonal_mask = ho_bitmap_clone(m_mask);
  }
#line 469
  if (! m_diagonal_mask) {
    {
#line 471
    ho_bitmap_free(m_temp);
    }
#line 472
    return ((ho_bitmap *)((void *)0));
  }
#line 474
  x = 0;
  {
#line 474
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 474
    if (! (x < (int )m_mask->width)) {
#line 474
      goto while_break___3;
    }
    {
#line 476
    ho_bitmap_delete_vline(m_diagonal_mask, (int const   )x, (int const   )y_start,
                           (int const   )((x * line_height) / (int )m_mask->width - line_height / 6));
#line 478
    ho_bitmap_delete_vline(m_diagonal_mask, (int const   )x, (int const   )((y_start + (x * line_height) / (int )m_mask->width) + line_height / 6),
                           (int const   )line_height);
#line 474
    x ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 482
  ho_bitmap_and(m_main_font, (ho_bitmap const   *)m_diagonal_mask);
#line 483
  ho_bitmap_free(m_diagonal_mask);
#line 486
  m_bars = ho_bitmap_filter_by_size((ho_bitmap const   *)m_main_font, (threshold * line_height) / 100,
                                    line_height * 2, 1, (int )m_text->width);
#line 489
  ho_bitmap_free(m_main_font);
  }
#line 490
  if (! m_bars) {
#line 491
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 494
  ho_bitmap_and(m_bars, m_text);
#line 497
  m_bars->x = (int )m_text->x;
#line 498
  m_bars->y = (int )m_text->y;
  }
#line 500
  return (m_bars);
}
}
#line 503 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_diagonal_left(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_diagonal_mask ;
  ho_bitmap *m_main_font ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_bars ;
  int sum ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int threshold ;
  int tmp ;
  int tmp___0 ;

  {
#line 506
  m_diagonal_mask = (ho_bitmap *)((void *)0);
#line 507
  m_main_font = (ho_bitmap *)((void *)0);
#line 508
  m_temp = (ho_bitmap *)((void *)0);
#line 509
  m_bars = (ho_bitmap *)((void *)0);
#line 511
  threshold = 90;
#line 514
  sum = 0;
#line 515
  y = 0;
  {
#line 515
  while (1) {
    while_continue: /* CIL Label */ ;
#line 515
    if (y < (int )m_mask->height) {
#line 515
      if (! (sum == 0)) {
#line 515
        goto while_break;
      }
    } else {
#line 515
      goto while_break;
    }
#line 516
    sum = 0;
#line 516
    x = 0;
    {
#line 516
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 516
      if (! (x < (int )m_text->width)) {
#line 516
        goto while_break___0;
      }
#line 517
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 517
        tmp = 1;
      } else {
#line 517
        tmp = 0;
      }
#line 517
      sum += tmp;
#line 516
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 515
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 518
  y_start = y - 1;
#line 519
  sum = 0;
#line 520
  y = (int )(m_mask->height - 1);
  {
#line 520
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 520
    if (y > y_start) {
#line 520
      if (! (sum == 0)) {
#line 520
        goto while_break___1;
      }
    } else {
#line 520
      goto while_break___1;
    }
#line 521
    sum = 0;
#line 521
    x = 0;
    {
#line 521
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 521
      if (! (x < (int )m_text->width)) {
#line 521
        goto while_break___2;
      }
#line 522
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 522
        tmp___0 = 1;
      } else {
#line 522
        tmp___0 = 0;
      }
#line 522
      sum += tmp___0;
#line 521
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 520
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 523
  line_height = (y - y_start) + 1;
#line 525
  if (! line_height) {
#line 526
    return ((ho_bitmap *)((void *)0));
  } else
#line 525
  if (! m_mask->width) {
#line 526
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 529
  m_temp = ho_bitmap_clone(m_text);
  }
#line 530
  if (! m_temp) {
#line 531
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 532
  m_main_font = m_temp;
#line 535
  m_diagonal_mask = ho_bitmap_clone(m_mask);
  }
#line 536
  if (! m_diagonal_mask) {
    {
#line 538
    ho_bitmap_free(m_temp);
    }
#line 539
    return ((ho_bitmap *)((void *)0));
  }
#line 541
  x = 0;
  {
#line 541
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 541
    if (! (x < (int )m_mask->width)) {
#line 541
      goto while_break___3;
    }
    {
#line 543
    ho_bitmap_delete_vline(m_diagonal_mask, (m_mask->width - (int const   )x) - 1,
                           (int const   )y_start, (int const   )((x * line_height) / (int )m_mask->width - line_height / 6));
#line 545
    ho_bitmap_delete_vline(m_diagonal_mask, (m_mask->width - (int const   )x) - 1,
                           (int const   )((y_start + (x * line_height) / (int )m_mask->width) + line_height / 6),
                           (int const   )line_height);
#line 541
    x ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 549
  ho_bitmap_and(m_main_font, (ho_bitmap const   *)m_diagonal_mask);
#line 550
  ho_bitmap_free(m_diagonal_mask);
#line 553
  m_bars = ho_bitmap_filter_by_size((ho_bitmap const   *)m_main_font, (threshold * line_height) / 100,
                                    line_height * 2, 1, (int )m_text->width);
#line 556
  ho_bitmap_free(m_main_font);
  }
#line 557
  if (! m_bars) {
#line 558
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 561
  ho_bitmap_and(m_bars, m_text);
#line 564
  m_bars->x = (int )m_text->x;
#line 565
  m_bars->y = (int )m_text->y;
  }
#line 567
  return (m_bars);
}
}
#line 570 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_thin_naive(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int sum ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  unsigned char direction ;
  unsigned char thin ;
  unsigned char thinned ;
  unsigned char edge_pixel ;
  unsigned char neighbors ;
  unsigned char neighbors_up ;
  unsigned char neighbors_down ;
  unsigned char neighbors_right ;
  unsigned char neighbors_left ;
  unsigned char neighbors_horizontal ;
  unsigned char neighbors_vertical ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  int tmp___49 ;
  int tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;

  {
#line 573
  m_out = (ho_bitmap *)((void *)0);
#line 574
  m_temp = (ho_bitmap *)((void *)0);
#line 578
  thin = (unsigned char)255;
#line 579
  thinned = (unsigned char)255;
#line 580
  edge_pixel = (unsigned char)0;
#line 590
  sum = 0;
#line 591
  y = 0;
  {
#line 591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 591
    if (y < (int )m_mask->height) {
#line 591
      if (! (sum == 0)) {
#line 591
        goto while_break;
      }
    } else {
#line 591
      goto while_break;
    }
#line 592
    sum = 0;
#line 592
    x = 0;
    {
#line 592
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 592
      if (! (x < (int )m_text->width)) {
#line 592
        goto while_break___0;
      }
#line 593
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 593
        tmp = 1;
      } else {
#line 593
        tmp = 0;
      }
#line 593
      sum += tmp;
#line 592
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 591
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 594
  y_start = y - 1;
#line 595
  sum = 0;
#line 596
  y = (int )(m_mask->height - 1);
  {
#line 596
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 596
    if (y > y_start) {
#line 596
      if (! (sum == 0)) {
#line 596
        goto while_break___1;
      }
    } else {
#line 596
      goto while_break___1;
    }
#line 597
    sum = 0;
#line 597
    x = 0;
    {
#line 597
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 597
      if (! (x < (int )m_text->width)) {
#line 597
        goto while_break___2;
      }
#line 598
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 598
        tmp___0 = 1;
      } else {
#line 598
        tmp___0 = 0;
      }
#line 598
      sum += tmp___0;
#line 597
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 596
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 599
  line_height = (y - y_start) + 1;
#line 601
  if (! line_height) {
#line 602
    return ((ho_bitmap *)((void *)0));
  } else
#line 601
  if (! m_mask->width) {
#line 602
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 605
  m_out = ho_bitmap_dilation_n(m_text, (unsigned char const   )6);
  }
#line 606
  if (! m_out) {
#line 607
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 609
  m_temp = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 610
  if (! m_temp) {
#line 611
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 614
  ho_bitmap_delete_vline(m_out, (int const   )0, (int const   )0, (int const   )(m_out->height - 1));
#line 615
  ho_bitmap_delete_vline(m_out, (int const   )(m_out->width - 1), (int const   )0,
                         (int const   )(m_out->height - 1));
#line 616
  ho_bitmap_delete_hline(m_out, (int const   )0, (int const   )0, (int const   )(m_out->width - 1));
#line 617
  ho_bitmap_delete_hline(m_out, (int const   )0, (int const   )(m_out->height - 1),
                         (int const   )(m_out->width - 1));
  }
  {
#line 620
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 620
    if (! thinned) {
#line 620
      goto while_break___3;
    }
#line 622
    thinned = (unsigned char)0;
#line 624
    direction = (unsigned char)0;
    {
#line 624
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 624
      if (! ((int )direction < 4)) {
#line 624
        goto while_break___4;
      }
      {
#line 627
      ho_bitmap_copy(m_temp, (ho_bitmap const   *)m_out);
#line 630
      x = 1;
      }
      {
#line 630
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 630
        if (! (x < (int )(m_text->width - 1))) {
#line 630
          goto while_break___5;
        }
#line 631
        y = 1;
        {
#line 631
        while (1) {
          while_continue___6: /* CIL Label */ ;
#line 631
          if (! (y < (int )(m_text->height - 1))) {
#line 631
            goto while_break___6;
          }
          {
#line 636
          if ((int )direction == 0) {
#line 636
            goto case_0;
          }
#line 640
          if ((int )direction == 1) {
#line 640
            goto case_1;
          }
#line 644
          if ((int )direction == 2) {
#line 644
            goto case_2;
          }
#line 648
          if ((int )direction == 3) {
#line 648
            goto case_3;
          }
#line 634
          goto switch_break;
          case_0: /* CIL Label */ 
#line 637
          if (((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 637
            tmp___1 = 1;
          } else {
#line 637
            tmp___1 = 0;
          }
#line 637
          if (tmp___1) {
#line 637
            if (((int )*(m_out->data + (x / 8 + (y + 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 637
              tmp___2 = 1;
            } else {
#line 637
              tmp___2 = 0;
            }
#line 637
            if (tmp___2) {
#line 637
              tmp___3 = 0;
            } else {
#line 637
              tmp___3 = 1;
            }
          } else {
#line 637
            tmp___3 = 0;
          }
#line 637
          edge_pixel = (unsigned char )tmp___3;
#line 639
          goto switch_break;
          case_1: /* CIL Label */ 
#line 641
          if (((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 641
            tmp___4 = 1;
          } else {
#line 641
            tmp___4 = 0;
          }
#line 641
          if (tmp___4) {
#line 641
            if (((int )*(m_out->data + ((x + 1) / 8 + y * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 641
              tmp___5 = 1;
            } else {
#line 641
              tmp___5 = 0;
            }
#line 641
            if (tmp___5) {
#line 641
              tmp___6 = 0;
            } else {
#line 641
              tmp___6 = 1;
            }
          } else {
#line 641
            tmp___6 = 0;
          }
#line 641
          edge_pixel = (unsigned char )tmp___6;
#line 643
          goto switch_break;
          case_2: /* CIL Label */ 
#line 645
          if (((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 645
            tmp___7 = 1;
          } else {
#line 645
            tmp___7 = 0;
          }
#line 645
          if (tmp___7) {
#line 645
            if (((int )*(m_out->data + (x / 8 + (y - 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 645
              tmp___8 = 1;
            } else {
#line 645
              tmp___8 = 0;
            }
#line 645
            if (tmp___8) {
#line 645
              tmp___9 = 0;
            } else {
#line 645
              tmp___9 = 1;
            }
          } else {
#line 645
            tmp___9 = 0;
          }
#line 645
          edge_pixel = (unsigned char )tmp___9;
#line 647
          goto switch_break;
          case_3: /* CIL Label */ 
#line 649
          if (((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 649
            tmp___10 = 1;
          } else {
#line 649
            tmp___10 = 0;
          }
#line 649
          if (tmp___10) {
#line 649
            if (((int )*(m_out->data + ((x - 1) / 8 + y * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 649
              tmp___11 = 1;
            } else {
#line 649
              tmp___11 = 0;
            }
#line 649
            if (tmp___11) {
#line 649
              tmp___12 = 0;
            } else {
#line 649
              tmp___12 = 1;
            }
          } else {
#line 649
            tmp___12 = 0;
          }
#line 649
          edge_pixel = (unsigned char )tmp___12;
#line 651
          goto switch_break;
          switch_break: /* CIL Label */ ;
          }
#line 655
          if (edge_pixel) {
#line 658
            if (((int )*(m_out->data + ((x + 1) / 8 + (y + 1) * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 658
              tmp___13 = 1;
            } else {
#line 658
              tmp___13 = 0;
            }
#line 658
            if (((int )*(m_out->data + ((x + 1) / 8 + y * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 658
              tmp___14 = 1;
            } else {
#line 658
              tmp___14 = 0;
            }
#line 658
            if (((int )*(m_out->data + ((x + 1) / 8 + (y - 1) * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 658
              tmp___15 = 1;
            } else {
#line 658
              tmp___15 = 0;
            }
#line 658
            if (((int )*(m_out->data + ((x - 1) / 8 + (y + 1) * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 658
              tmp___16 = 1;
            } else {
#line 658
              tmp___16 = 0;
            }
#line 658
            if (((int )*(m_out->data + ((x - 1) / 8 + y * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 658
              tmp___17 = 1;
            } else {
#line 658
              tmp___17 = 0;
            }
#line 658
            if (((int )*(m_out->data + ((x - 1) / 8 + (y - 1) * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 658
              tmp___18 = 1;
            } else {
#line 658
              tmp___18 = 0;
            }
#line 658
            if (((int )*(m_out->data + (x / 8 + (y - 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 658
              tmp___19 = 1;
            } else {
#line 658
              tmp___19 = 0;
            }
#line 658
            if (((int )*(m_out->data + (x / 8 + (y + 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 658
              tmp___20 = 1;
            } else {
#line 658
              tmp___20 = 0;
            }
#line 658
            neighbors = (unsigned char )(((((((tmp___13 + tmp___14) + tmp___15) + tmp___16) + tmp___17) + tmp___18) + tmp___19) + tmp___20);
#line 666
            if (((int )*(m_out->data + ((x + 1) / 8 + (y - 1) * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 666
              tmp___21 = 1;
            } else {
#line 666
              tmp___21 = 0;
            }
#line 666
            if (((int )*(m_out->data + ((x - 1) / 8 + (y - 1) * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 666
              tmp___22 = 1;
            } else {
#line 666
              tmp___22 = 0;
            }
#line 666
            if (((int )*(m_out->data + (x / 8 + (y - 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 666
              tmp___23 = 1;
            } else {
#line 666
              tmp___23 = 0;
            }
#line 666
            neighbors_up = (unsigned char )((tmp___21 + tmp___22) + tmp___23);
#line 671
            if (((int )*(m_out->data + ((x + 1) / 8 + (y + 1) * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 671
              tmp___24 = 1;
            } else {
#line 671
              tmp___24 = 0;
            }
#line 671
            if (((int )*(m_out->data + ((x - 1) / 8 + (y + 1) * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 671
              tmp___25 = 1;
            } else {
#line 671
              tmp___25 = 0;
            }
#line 671
            if (((int )*(m_out->data + (x / 8 + (y + 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 671
              tmp___26 = 1;
            } else {
#line 671
              tmp___26 = 0;
            }
#line 671
            neighbors_down = (unsigned char )((tmp___24 + tmp___25) + tmp___26);
#line 676
            if (((int )*(m_out->data + ((x - 1) / 8 + (y - 1) * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 676
              tmp___27 = 1;
            } else {
#line 676
              tmp___27 = 0;
            }
#line 676
            if (((int )*(m_out->data + ((x - 1) / 8 + y * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 676
              tmp___28 = 1;
            } else {
#line 676
              tmp___28 = 0;
            }
#line 676
            if (((int )*(m_out->data + ((x - 1) / 8 + (y + 1) * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 676
              tmp___29 = 1;
            } else {
#line 676
              tmp___29 = 0;
            }
#line 676
            neighbors_right = (unsigned char )((tmp___27 + tmp___28) + tmp___29);
#line 681
            if (((int )*(m_out->data + ((x + 1) / 8 + (y - 1) * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 681
              tmp___30 = 1;
            } else {
#line 681
              tmp___30 = 0;
            }
#line 681
            if (((int )*(m_out->data + ((x + 1) / 8 + y * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 681
              tmp___31 = 1;
            } else {
#line 681
              tmp___31 = 0;
            }
#line 681
            if (((int )*(m_out->data + ((x + 1) / 8 + (y + 1) * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 681
              tmp___32 = 1;
            } else {
#line 681
              tmp___32 = 0;
            }
#line 681
            neighbors_left = (unsigned char )((tmp___30 + tmp___31) + tmp___32);
#line 686
            if (((int )*(m_out->data + ((x - 1) / 8 + y * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 686
              tmp___33 = 1;
            } else {
#line 686
              tmp___33 = 0;
            }
#line 686
            if (((int )*(m_out->data + ((x + 1) / 8 + y * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 686
              tmp___34 = 1;
            } else {
#line 686
              tmp___34 = 0;
            }
#line 686
            neighbors_horizontal = (unsigned char )(tmp___33 + tmp___34);
#line 689
            if (((int )*(m_out->data + (x / 8 + (y - 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 689
              tmp___35 = 1;
            } else {
#line 689
              tmp___35 = 0;
            }
#line 689
            if (((int )*(m_out->data + (x / 8 + (y + 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 689
              tmp___36 = 1;
            } else {
#line 689
              tmp___36 = 0;
            }
#line 689
            neighbors_vertical = (unsigned char )(tmp___35 + tmp___36);
#line 693
            thin = (unsigned char )((int )neighbors > 1);
#line 696
            if (thin) {
#line 696
              if (neighbors_up) {
#line 696
                if (neighbors_down) {
#line 696
                  if (! neighbors_horizontal) {
#line 696
                    tmp___37 = 0;
                  } else {
#line 696
                    goto _L___0;
                  }
                } else {
#line 696
                  goto _L___0;
                }
              } else
              _L___0: /* CIL Label */ 
#line 696
              if (neighbors_right) {
#line 696
                if (neighbors_left) {
#line 696
                  if (! neighbors_vertical) {
#line 696
                    tmp___37 = 0;
                  } else {
#line 696
                    tmp___37 = 1;
                  }
                } else {
#line 696
                  tmp___37 = 1;
                }
              } else {
#line 696
                tmp___37 = 1;
              }
            } else {
#line 696
              tmp___37 = 0;
            }
#line 696
            thin = (unsigned char )tmp___37;
#line 701
            if (thin) {
#line 701
              if (((int )*(m_out->data + ((x - 1) / 8 + (y - 1) * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 701
                tmp___38 = 1;
              } else {
#line 701
                tmp___38 = 0;
              }
#line 701
              if (tmp___38) {
#line 701
                if (((int )*(m_out->data + (x / 8 + (y - 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 701
                  tmp___39 = 1;
                } else {
#line 701
                  tmp___39 = 0;
                }
#line 701
                if (tmp___39) {
#line 701
                  tmp___41 = 1;
                } else {
#line 701
                  if (((int )*(m_out->data + ((x - 1) / 8 + y * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 701
                    tmp___40 = 1;
                  } else {
#line 701
                    tmp___40 = 0;
                  }
#line 701
                  if (tmp___40) {
#line 701
                    tmp___41 = 1;
                  } else {
#line 701
                    tmp___41 = 0;
                  }
                }
              } else {
#line 701
                tmp___41 = 1;
              }
            } else {
#line 701
              tmp___41 = 0;
            }
#line 701
            thin = (unsigned char )tmp___41;
#line 704
            if (thin) {
#line 704
              if (((int )*(m_out->data + ((x + 1) / 8 + (y + 1) * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 704
                tmp___42 = 1;
              } else {
#line 704
                tmp___42 = 0;
              }
#line 704
              if (tmp___42) {
#line 704
                if (((int )*(m_out->data + (x / 8 + (y + 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 704
                  tmp___43 = 1;
                } else {
#line 704
                  tmp___43 = 0;
                }
#line 704
                if (tmp___43) {
#line 704
                  tmp___45 = 1;
                } else {
#line 704
                  if (((int )*(m_out->data + ((x + 1) / 8 + y * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 704
                    tmp___44 = 1;
                  } else {
#line 704
                    tmp___44 = 0;
                  }
#line 704
                  if (tmp___44) {
#line 704
                    tmp___45 = 1;
                  } else {
#line 704
                    tmp___45 = 0;
                  }
                }
              } else {
#line 704
                tmp___45 = 1;
              }
            } else {
#line 704
              tmp___45 = 0;
            }
#line 704
            thin = (unsigned char )tmp___45;
#line 708
            if (thin) {
#line 708
              if (((int )*(m_out->data + ((x - 1) / 8 + (y + 1) * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 708
                tmp___46 = 1;
              } else {
#line 708
                tmp___46 = 0;
              }
#line 708
              if (tmp___46) {
#line 708
                if (((int )*(m_out->data + (x / 8 + (y + 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 708
                  tmp___47 = 1;
                } else {
#line 708
                  tmp___47 = 0;
                }
#line 708
                if (tmp___47) {
#line 708
                  tmp___49 = 1;
                } else {
#line 708
                  if (((int )*(m_out->data + ((x - 1) / 8 + y * m_out->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 708
                    tmp___48 = 1;
                  } else {
#line 708
                    tmp___48 = 0;
                  }
#line 708
                  if (tmp___48) {
#line 708
                    tmp___49 = 1;
                  } else {
#line 708
                    tmp___49 = 0;
                  }
                }
              } else {
#line 708
                tmp___49 = 1;
              }
            } else {
#line 708
              tmp___49 = 0;
            }
#line 708
            thin = (unsigned char )tmp___49;
#line 712
            if (thin) {
#line 712
              if (((int )*(m_out->data + ((x + 1) / 8 + (y - 1) * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 712
                tmp___50 = 1;
              } else {
#line 712
                tmp___50 = 0;
              }
#line 712
              if (tmp___50) {
#line 712
                if (((int )*(m_out->data + (x / 8 + (y - 1) * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 712
                  tmp___51 = 1;
                } else {
#line 712
                  tmp___51 = 0;
                }
#line 712
                if (tmp___51) {
#line 712
                  tmp___53 = 1;
                } else {
#line 712
                  if (((int )*(m_out->data + ((x + 1) / 8 + y * m_out->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 712
                    tmp___52 = 1;
                  } else {
#line 712
                    tmp___52 = 0;
                  }
#line 712
                  if (tmp___52) {
#line 712
                    tmp___53 = 1;
                  } else {
#line 712
                    tmp___53 = 0;
                  }
                }
              } else {
#line 712
                tmp___53 = 1;
              }
            } else {
#line 712
              tmp___53 = 0;
            }
#line 712
            thin = (unsigned char )tmp___53;
#line 717
            if (thin) {
#line 719
              *(m_temp->data + (x / 8 + y * m_temp->rowstride)) = (unsigned char )((int )*(m_temp->data + (x / 8 + y * m_temp->rowstride)) & ~ (128 >> x % 8));
#line 720
              thinned = (unsigned char)255;
            }
          }
#line 631
          y ++;
        }
        while_break___6: /* CIL Label */ ;
        }
#line 630
        x ++;
      }
      while_break___5: /* CIL Label */ ;
      }
      {
#line 726
      ho_bitmap_copy(m_out, (ho_bitmap const   *)m_temp);
#line 624
      direction = (unsigned char )((int )direction + 1);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 730
  ho_bitmap_free(m_temp);
  }
#line 732
  return (m_out);
}
}
#line 735 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_ends(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int x ;
  int y ;
  unsigned char neighbors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 738
  m_out = (ho_bitmap *)((void *)0);
#line 739
  m_temp = (ho_bitmap *)((void *)0);
#line 744
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 745
  if (! m_out) {
#line 746
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 748
  m_temp = ho_font_thin(m_text, m_mask);
  }
#line 749
  if (! m_temp) {
#line 750
    return ((ho_bitmap *)((void *)0));
  }
#line 753
  x = 1;
  {
#line 753
  while (1) {
    while_continue: /* CIL Label */ ;
#line 753
    if (! (x < (int )(m_text->width - 1))) {
#line 753
      goto while_break;
    }
#line 754
    y = 1;
    {
#line 754
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 754
      if (! (y < (int )(m_text->height - 1))) {
#line 754
        goto while_break___0;
      }
#line 757
      if (((int )*(m_temp->data + (x / 8 + y * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 757
        tmp___7 = 1;
      } else {
#line 757
        tmp___7 = 0;
      }
#line 757
      if (tmp___7) {
#line 760
        if (((int )*(m_temp->data + ((x + 1) / 8 + (y + 1) * m_temp->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 760
          tmp = 1;
        } else {
#line 760
          tmp = 0;
        }
#line 760
        if (((int )*(m_temp->data + ((x + 1) / 8 + y * m_temp->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 760
          tmp___0 = 1;
        } else {
#line 760
          tmp___0 = 0;
        }
#line 760
        if (((int )*(m_temp->data + ((x + 1) / 8 + (y - 1) * m_temp->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 760
          tmp___1 = 1;
        } else {
#line 760
          tmp___1 = 0;
        }
#line 760
        if (((int )*(m_temp->data + ((x - 1) / 8 + (y + 1) * m_temp->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 760
          tmp___2 = 1;
        } else {
#line 760
          tmp___2 = 0;
        }
#line 760
        if (((int )*(m_temp->data + ((x - 1) / 8 + y * m_temp->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 760
          tmp___3 = 1;
        } else {
#line 760
          tmp___3 = 0;
        }
#line 760
        if (((int )*(m_temp->data + ((x - 1) / 8 + (y - 1) * m_temp->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 760
          tmp___4 = 1;
        } else {
#line 760
          tmp___4 = 0;
        }
#line 760
        if (((int )*(m_temp->data + (x / 8 + (y - 1) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 760
          tmp___5 = 1;
        } else {
#line 760
          tmp___5 = 0;
        }
#line 760
        if (((int )*(m_temp->data + (x / 8 + (y + 1) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 760
          tmp___6 = 1;
        } else {
#line 760
          tmp___6 = 0;
        }
#line 760
        neighbors = (unsigned char )(((((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) + tmp___4) + tmp___5) + tmp___6);
#line 769
        if ((int )neighbors < 2) {
#line 771
          *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
        }
      }
#line 754
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 753
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 776
  ho_bitmap_free(m_temp);
  }
#line 778
  return (m_out);
}
}
#line 781 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_cross(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int x ;
  int y ;
  unsigned char neighbors ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
  {
#line 784
  m_out = (ho_bitmap *)((void *)0);
#line 785
  m_temp = (ho_bitmap *)((void *)0);
#line 790
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 791
  if (! m_out) {
#line 792
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 794
  m_temp = ho_font_thin(m_text, m_mask);
  }
#line 795
  if (! m_temp) {
#line 796
    return ((ho_bitmap *)((void *)0));
  }
#line 799
  x = 1;
  {
#line 799
  while (1) {
    while_continue: /* CIL Label */ ;
#line 799
    if (! (x < (int )(m_text->width - 1))) {
#line 799
      goto while_break;
    }
#line 800
    y = 1;
    {
#line 800
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 800
      if (! (y < (int )(m_text->height - 1))) {
#line 800
        goto while_break___0;
      }
#line 803
      if (((int )*(m_temp->data + (x / 8 + y * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 803
        tmp___7 = 1;
      } else {
#line 803
        tmp___7 = 0;
      }
#line 803
      if (tmp___7) {
#line 806
        if (((int )*(m_temp->data + ((x + 1) / 8 + (y + 1) * m_temp->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 806
          tmp = 1;
        } else {
#line 806
          tmp = 0;
        }
#line 806
        if (((int )*(m_temp->data + ((x + 1) / 8 + y * m_temp->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 806
          tmp___0 = 1;
        } else {
#line 806
          tmp___0 = 0;
        }
#line 806
        if (((int )*(m_temp->data + ((x + 1) / 8 + (y - 1) * m_temp->rowstride)) & (128 >> (x + 1) % 8)) > 0) {
#line 806
          tmp___1 = 1;
        } else {
#line 806
          tmp___1 = 0;
        }
#line 806
        if (((int )*(m_temp->data + ((x - 1) / 8 + (y + 1) * m_temp->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 806
          tmp___2 = 1;
        } else {
#line 806
          tmp___2 = 0;
        }
#line 806
        if (((int )*(m_temp->data + ((x - 1) / 8 + y * m_temp->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 806
          tmp___3 = 1;
        } else {
#line 806
          tmp___3 = 0;
        }
#line 806
        if (((int )*(m_temp->data + ((x - 1) / 8 + (y - 1) * m_temp->rowstride)) & (128 >> (x - 1) % 8)) > 0) {
#line 806
          tmp___4 = 1;
        } else {
#line 806
          tmp___4 = 0;
        }
#line 806
        if (((int )*(m_temp->data + (x / 8 + (y - 1) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 806
          tmp___5 = 1;
        } else {
#line 806
          tmp___5 = 0;
        }
#line 806
        if (((int )*(m_temp->data + (x / 8 + (y + 1) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 806
          tmp___6 = 1;
        } else {
#line 806
          tmp___6 = 0;
        }
#line 806
        neighbors = (unsigned char )(((((((tmp + tmp___0) + tmp___1) + tmp___2) + tmp___3) + tmp___4) + tmp___5) + tmp___6);
#line 815
        if ((int )neighbors > 2) {
#line 817
          *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
        }
      }
#line 800
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 799
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 822
  ho_bitmap_free(m_temp);
  }
#line 824
  return (m_out);
}
}
#line 827 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_thin(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int sum ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int tmp ;
  int tmp___0 ;

  {
#line 830
  m_out = (ho_bitmap *)((void *)0);
#line 831
  m_temp = (ho_bitmap *)((void *)0);
#line 835
  sum = 0;
#line 836
  y = 0;
  {
#line 836
  while (1) {
    while_continue: /* CIL Label */ ;
#line 836
    if (y < (int )m_mask->height) {
#line 836
      if (! (sum == 0)) {
#line 836
        goto while_break;
      }
    } else {
#line 836
      goto while_break;
    }
#line 837
    sum = 0;
#line 837
    x = 0;
    {
#line 837
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 837
      if (! (x < (int )m_text->width)) {
#line 837
        goto while_break___0;
      }
#line 838
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 838
        tmp = 1;
      } else {
#line 838
        tmp = 0;
      }
#line 838
      sum += tmp;
#line 837
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 836
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 839
  y_start = y - 1;
#line 840
  sum = 0;
#line 841
  y = (int )(m_mask->height - 1);
  {
#line 841
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 841
    if (y > y_start) {
#line 841
      if (! (sum == 0)) {
#line 841
        goto while_break___1;
      }
    } else {
#line 841
      goto while_break___1;
    }
#line 842
    sum = 0;
#line 842
    x = 0;
    {
#line 842
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 842
      if (! (x < (int )m_text->width)) {
#line 842
        goto while_break___2;
      }
#line 843
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 843
        tmp___0 = 1;
      } else {
#line 843
        tmp___0 = 0;
      }
#line 843
      sum += tmp___0;
#line 842
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 841
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 844
  line_height = (y - y_start) + 1;
#line 846
  if (! line_height) {
#line 847
    return ((ho_bitmap *)((void *)0));
  } else
#line 846
  if (! m_mask->width) {
#line 847
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 850
  m_temp = ho_bitmap_erosion_n(m_text, (unsigned char const   )6);
  }
#line 851
  if (! m_temp) {
#line 852
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 854
  m_out = ho_bitmap_dilation_n((ho_bitmap const   *)m_temp, (unsigned char const   )6);
#line 855
  ho_bitmap_free(m_temp);
  }
#line 856
  if (! m_out) {
#line 857
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 860
  m_temp = ho_font_thin_naive((ho_bitmap const   *)m_out, m_mask);
#line 861
  ho_bitmap_free(m_out);
  }
#line 862
  if (! m_temp) {
#line 863
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 864
  m_out = m_temp;
#line 872
  m_temp = ho_bitmap_closing((ho_bitmap const   *)m_out);
#line 873
  ho_bitmap_free(m_out);
  }
#line 874
  if (! m_temp) {
#line 875
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 878
  m_out = ho_font_thin_naive((ho_bitmap const   *)m_temp, m_mask);
#line 879
  ho_bitmap_free(m_temp);
#line 882
  ho_bitmap_and(m_out, m_text);
  }
#line 884
  return (m_out);
}
}
#line 887 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_edges_top(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int sum ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_x ;
  int min_x_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 890
  m_out = (ho_bitmap *)((void *)0);
#line 891
  m_temp = (ho_bitmap *)((void *)0);
#line 896
  threshold = 10;
#line 899
  sum = 0;
#line 900
  y = 0;
  {
#line 900
  while (1) {
    while_continue: /* CIL Label */ ;
#line 900
    if (y < (int )m_mask->height) {
#line 900
      if (! (sum == 0)) {
#line 900
        goto while_break;
      }
    } else {
#line 900
      goto while_break;
    }
#line 901
    sum = 0;
#line 901
    x = 0;
    {
#line 901
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 901
      if (! (x < (int )m_mask->width)) {
#line 901
        goto while_break___0;
      }
#line 902
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 902
        tmp = 1;
      } else {
#line 902
        tmp = 0;
      }
#line 902
      sum += tmp;
#line 901
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 900
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 903
  y_start = y - 1;
#line 904
  sum = 0;
#line 905
  y = (int )(m_mask->height - 1);
  {
#line 905
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 905
    if (y > y_start) {
#line 905
      if (! (sum == 0)) {
#line 905
        goto while_break___1;
      }
    } else {
#line 905
      goto while_break___1;
    }
#line 906
    sum = 0;
#line 906
    x = 0;
    {
#line 906
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 906
      if (! (x < (int )m_mask->width)) {
#line 906
        goto while_break___2;
      }
#line 907
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 907
        tmp___0 = 1;
      } else {
#line 907
        tmp___0 = 0;
      }
#line 907
      sum += tmp___0;
#line 906
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 905
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 908
  line_height = (y - y_start) + 1;
#line 910
  if (! line_height) {
#line 911
    return ((ho_bitmap *)((void *)0));
  } else
#line 910
  if (m_mask->width < 2) {
#line 911
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 914
  tmp___1 = calloc((size_t )m_text->width, sizeof(int ));
#line 914
  a_height = (int *)tmp___1;
  }
#line 915
  if (! a_height) {
#line 916
    return ((ho_bitmap *)((void *)0));
  }
#line 919
  dy = (threshold * line_height) / 100;
#line 920
  y1___0 = (y_start - line_height / 6) - 3;
#line 921
  y2 = (y_start + line_height / 2) + 3;
#line 922
  if (y1___0 < 0) {
#line 923
    y1___0 = 0;
  }
#line 924
  dx = (int )(m_text->width / 20 + 1);
#line 925
  x1 = dx + 1;
#line 926
  x2 = (int )(m_text->width - (int const   )x1);
#line 928
  x = 0;
  {
#line 928
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 928
    if (! (x < (int )m_text->width)) {
#line 928
      goto while_break___3;
    }
#line 930
    y = y1___0;
    {
#line 930
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 930
      if (y < y2) {
#line 930
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 930
          tmp___2 = 1;
        } else {
#line 930
          tmp___2 = 0;
        }
#line 930
        if (tmp___2) {
#line 930
          goto while_break___4;
        }
      } else {
#line 930
        goto while_break___4;
      }
#line 930
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 931
    *(a_height + x) = y - y1___0;
#line 928
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 935
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 936
  if (! m_out) {
#line 937
    return ((ho_bitmap *)((void *)0));
  }
#line 940
  x = 0;
  {
#line 940
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 940
    if (! (x < m_out->width)) {
#line 940
      goto while_break___5;
    }
#line 942
    if (x < dx) {
#line 942
      goto _L___3;
    } else
#line 942
    if (*(a_height + (x - dx)) > *(a_height + x) + dy) {
      _L___3: /* CIL Label */ 
#line 942
      if (x > m_out->width - dx) {
        {
#line 950
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else
#line 942
      if (*(a_height + (x + dx)) > *(a_height + x) + dy) {
        {
#line 950
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else {
#line 942
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 942
    if (x < 2 * dx) {
#line 942
      goto _L___1;
    } else
#line 942
    if (*(a_height + (x - dx * 2)) > *(a_height + x) + dy) {
      _L___1: /* CIL Label */ 
#line 942
      if (x > m_out->width - 2 * dx) {
        {
#line 950
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else
#line 942
      if (*(a_height + (x + dx * 2)) > *(a_height + x) + dy) {
        {
#line 950
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else {
#line 942
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 942
    if (x < 3 * dx) {
#line 942
      goto _L;
    } else
#line 942
    if (*(a_height + (x - dx * 3)) > *(a_height + x) + dy) {
      _L: /* CIL Label */ 
#line 942
      if (x > m_out->width - 3 * dx) {
        {
#line 950
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else
#line 942
      if (*(a_height + (x + dx * 3)) > *(a_height + x) + dy) {
        {
#line 950
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      }
    }
#line 940
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 954
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )(dx * 2));
#line 955
  ho_bitmap_free(m_out);
#line 958
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 959
  if (! m_out) {
#line 960
    return ((ho_bitmap *)((void *)0));
  }
#line 966
  x = 1;
  {
#line 967
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 967
    if (x < m_temp->width) {
#line 967
      if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 967
        tmp___3 = 1;
      } else {
#line 967
        tmp___3 = 0;
      }
#line 967
      if (tmp___3) {
#line 967
        goto while_break___6;
      }
    } else {
#line 967
      goto while_break___6;
    }
#line 967
    x ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 968
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 968
    if (! (x < m_temp->width)) {
#line 968
      goto while_break___7;
    }
#line 971
    min_x = x - 1;
#line 972
    min_x_start = min_x;
    {
#line 973
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 973
      if (x < m_temp->width) {
#line 973
        if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 973
          tmp___4 = 1;
        } else {
#line 973
          tmp___4 = 0;
        }
#line 973
        if (! tmp___4) {
#line 973
          goto while_break___8;
        }
      } else {
#line 973
        goto while_break___8;
      }
#line 975
      if (*(a_height + min_x) >= *(a_height + x)) {
#line 976
        min_x = x;
      }
#line 977
      if (*(a_height + min_x_start) > *(a_height + x)) {
#line 978
        min_x_start = x;
      }
#line 973
      x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 981
    ho_bitmap_draw_vline(m_out, (int const   )((min_x_start + min_x) / 2), (int const   )0,
                         (int const   )m_out->height);
    }
    {
#line 983
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 983
      if (x < m_temp->width) {
#line 983
        if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 983
          tmp___5 = 1;
        } else {
#line 983
          tmp___5 = 0;
        }
#line 983
        if (tmp___5) {
#line 983
          goto while_break___9;
        }
      } else {
#line 983
        goto while_break___9;
      }
#line 983
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 987
  free((void *)a_height);
#line 988
  ho_bitmap_free(m_temp);
#line 991
  m_out->x = (int )m_text->x;
#line 992
  m_out->y = (int )m_text->y;
  }
#line 994
  return (m_out);
}
}
#line 997 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_edges_top_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int sum ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_x ;
  int min_x_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1000
  m_out = (ho_bitmap *)((void *)0);
#line 1001
  m_temp = (ho_bitmap *)((void *)0);
#line 1006
  threshold = 20;
#line 1009
  sum = 0;
#line 1010
  y = 0;
  {
#line 1010
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1010
    if (y < (int )m_mask->height) {
#line 1010
      if (! (sum == 0)) {
#line 1010
        goto while_break;
      }
    } else {
#line 1010
      goto while_break;
    }
#line 1011
    sum = 0;
#line 1011
    x = 0;
    {
#line 1011
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1011
      if (! (x < (int )m_mask->width)) {
#line 1011
        goto while_break___0;
      }
#line 1012
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1012
        tmp = 1;
      } else {
#line 1012
        tmp = 0;
      }
#line 1012
      sum += tmp;
#line 1011
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1010
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1013
  y_start = y - 1;
#line 1014
  sum = 0;
#line 1015
  y = (int )(m_mask->height - 1);
  {
#line 1015
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1015
    if (y > y_start) {
#line 1015
      if (! (sum == 0)) {
#line 1015
        goto while_break___1;
      }
    } else {
#line 1015
      goto while_break___1;
    }
#line 1016
    sum = 0;
#line 1016
    x = 0;
    {
#line 1016
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1016
      if (! (x < (int )m_mask->width)) {
#line 1016
        goto while_break___2;
      }
#line 1017
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1017
        tmp___0 = 1;
      } else {
#line 1017
        tmp___0 = 0;
      }
#line 1017
      sum += tmp___0;
#line 1016
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1015
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1018
  line_height = (y - y_start) + 1;
#line 1020
  if (! line_height) {
#line 1021
    return ((ho_bitmap *)((void *)0));
  } else
#line 1020
  if (m_mask->width < 2) {
#line 1021
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1024
  tmp___1 = calloc((size_t )m_text->width, sizeof(int ));
#line 1024
  a_height = (int *)tmp___1;
  }
#line 1025
  if (! a_height) {
#line 1026
    return ((ho_bitmap *)((void *)0));
  }
#line 1029
  dy = (threshold * line_height) / 100;
#line 1030
  y1___0 = (y_start - line_height / 6) - 3;
#line 1031
  y2 = (y_start + line_height / 2) + 3;
#line 1032
  if (y1___0 < 0) {
#line 1033
    y1___0 = 0;
  }
#line 1034
  dx = (int )(m_text->width / 20 + 1);
#line 1035
  x1 = dx + 1;
#line 1036
  x2 = (int )(m_text->width - (int const   )x1);
#line 1038
  x = 0;
  {
#line 1038
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1038
    if (! (x < (int )m_text->width)) {
#line 1038
      goto while_break___3;
    }
#line 1040
    y = y1___0;
    {
#line 1040
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1040
      if (y < y2) {
#line 1040
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1040
          tmp___2 = 1;
        } else {
#line 1040
          tmp___2 = 0;
        }
#line 1040
        if (tmp___2) {
#line 1040
          goto while_break___4;
        }
      } else {
#line 1040
        goto while_break___4;
      }
#line 1040
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1041
    *(a_height + x) = y - y1___0;
#line 1038
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1045
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1046
  if (! m_out) {
#line 1047
    return ((ho_bitmap *)((void *)0));
  }
#line 1050
  x = 0;
  {
#line 1050
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1050
    if (! (x < m_out->width)) {
#line 1050
      goto while_break___5;
    }
#line 1052
    if (x < dx) {
#line 1052
      goto _L___3;
    } else
#line 1052
    if (*(a_height + (x - dx)) > *(a_height + x) + dy) {
      _L___3: /* CIL Label */ 
#line 1052
      if (x > m_out->width - dx) {
        {
#line 1060
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else
#line 1052
      if (*(a_height + (x + dx)) > *(a_height + x) + dy) {
        {
#line 1060
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else {
#line 1052
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1052
    if (x < 2 * dx) {
#line 1052
      goto _L___1;
    } else
#line 1052
    if (*(a_height + (x - dx * 2)) > *(a_height + x) + dy) {
      _L___1: /* CIL Label */ 
#line 1052
      if (x > m_out->width - 2 * dx) {
        {
#line 1060
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else
#line 1052
      if (*(a_height + (x + dx * 2)) > *(a_height + x) + dy) {
        {
#line 1060
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else {
#line 1052
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1052
    if (x < 3 * dx) {
#line 1052
      goto _L;
    } else
#line 1052
    if (*(a_height + (x - dx * 3)) > *(a_height + x) + dy) {
      _L: /* CIL Label */ 
#line 1052
      if (x > m_out->width - 3 * dx) {
        {
#line 1060
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      } else
#line 1052
      if (*(a_height + (x + dx * 3)) > *(a_height + x) + dy) {
        {
#line 1060
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
        }
      }
    }
#line 1050
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1064
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )(dx * 2));
#line 1065
  ho_bitmap_free(m_out);
#line 1068
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1069
  if (! m_out) {
#line 1070
    return ((ho_bitmap *)((void *)0));
  }
#line 1076
  x = 1;
  {
#line 1077
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1077
    if (x < m_temp->width) {
#line 1077
      if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1077
        tmp___3 = 1;
      } else {
#line 1077
        tmp___3 = 0;
      }
#line 1077
      if (tmp___3) {
#line 1077
        goto while_break___6;
      }
    } else {
#line 1077
      goto while_break___6;
    }
#line 1077
    x ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1078
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1078
    if (! (x < m_temp->width)) {
#line 1078
      goto while_break___7;
    }
#line 1081
    min_x = x - 1;
#line 1082
    min_x_start = min_x;
    {
#line 1083
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1083
      if (x < m_temp->width) {
#line 1083
        if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1083
          tmp___4 = 1;
        } else {
#line 1083
          tmp___4 = 0;
        }
#line 1083
        if (! tmp___4) {
#line 1083
          goto while_break___8;
        }
      } else {
#line 1083
        goto while_break___8;
      }
#line 1085
      if (*(a_height + min_x) >= *(a_height + x)) {
#line 1086
        min_x = x;
      }
#line 1087
      if (*(a_height + min_x_start) > *(a_height + x)) {
#line 1088
        min_x_start = x;
      }
#line 1083
      x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1091
    ho_bitmap_draw_vline(m_out, (int const   )((min_x_start + min_x) / 2), (int const   )0,
                         (int const   )m_out->height);
    }
    {
#line 1093
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1093
      if (x < m_temp->width) {
#line 1093
        if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1093
          tmp___5 = 1;
        } else {
#line 1093
          tmp___5 = 0;
        }
#line 1093
        if (tmp___5) {
#line 1093
          goto while_break___9;
        }
      } else {
#line 1093
        goto while_break___9;
      }
#line 1093
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1097
  free((void *)a_height);
#line 1098
  ho_bitmap_free(m_temp);
#line 1101
  m_out->x = (int )m_text->x;
#line 1102
  m_out->y = (int )m_text->y;
  }
#line 1104
  return (m_out);
}
}
#line 1107 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_edges_bottom(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_x ;
  int min_x_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1110
  m_out = (ho_bitmap *)((void *)0);
#line 1111
  m_temp = (ho_bitmap *)((void *)0);
#line 1116
  threshold = 0;
#line 1120
  sum = 0;
#line 1121
  y = 0;
  {
#line 1121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1121
    if (y < (int )m_mask->height) {
#line 1121
      if (! (sum == 0)) {
#line 1121
        goto while_break;
      }
    } else {
#line 1121
      goto while_break;
    }
#line 1122
    sum = 0;
#line 1122
    x = 0;
    {
#line 1122
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1122
      if (! (x < (int )m_mask->width)) {
#line 1122
        goto while_break___0;
      }
#line 1123
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1123
        tmp = 1;
      } else {
#line 1123
        tmp = 0;
      }
#line 1123
      sum += tmp;
#line 1122
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1121
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1124
  y_start = y - 1;
#line 1125
  sum = 0;
#line 1126
  y = (int )(m_mask->height - 1);
  {
#line 1126
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1126
    if (y > y_start) {
#line 1126
      if (! (sum == 0)) {
#line 1126
        goto while_break___1;
      }
    } else {
#line 1126
      goto while_break___1;
    }
#line 1127
    sum = 0;
#line 1127
    x = 0;
    {
#line 1127
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1127
      if (! (x < (int )m_mask->width)) {
#line 1127
        goto while_break___2;
      }
#line 1128
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1128
        tmp___0 = 1;
      } else {
#line 1128
        tmp___0 = 0;
      }
#line 1128
      sum += tmp___0;
#line 1127
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1126
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1129
  line_height = (y - y_start) + 1;
#line 1131
  if (! line_height) {
#line 1132
    return ((ho_bitmap *)((void *)0));
  } else
#line 1131
  if (m_mask->width < 2) {
#line 1132
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1135
  tmp___1 = calloc((size_t )m_text->width, sizeof(int ));
#line 1135
  a_height = (int *)tmp___1;
  }
#line 1136
  if (! a_height) {
#line 1137
    return ((ho_bitmap *)((void *)0));
  }
#line 1140
  dy = (threshold * line_height) / 100;
#line 1141
  y1___0 = ((y_start + line_height) - line_height / 2) - 3;
#line 1142
  y2 = ((y_start + line_height) + line_height / 6) + 3;
#line 1143
  if (y2 > (int )(m_text->height - 1)) {
#line 1144
    y2 = (int )(m_text->height - 1);
  }
#line 1146
  dx = (int )(m_text->width / 20 + 1);
#line 1147
  x1 = dx + 1;
#line 1148
  x2 = (int )(m_text->width - (int const   )x1);
#line 1150
  x = 0;
  {
#line 1150
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1150
    if (! (x < (int )m_text->width)) {
#line 1150
      goto while_break___3;
    }
#line 1152
    y = y2;
    {
#line 1152
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1152
      if (y > y1___0) {
#line 1152
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1152
          tmp___2 = 1;
        } else {
#line 1152
          tmp___2 = 0;
        }
#line 1152
        if (tmp___2) {
#line 1152
          goto while_break___4;
        }
      } else {
#line 1152
        goto while_break___4;
      }
#line 1152
      y --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1153
    *(a_height + x) = y2 - y;
#line 1150
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1157
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1158
  if (! m_out) {
#line 1159
    return ((ho_bitmap *)((void *)0));
  }
#line 1162
  x = 0;
  {
#line 1162
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1162
    if (! (x < m_out->width)) {
#line 1162
      goto while_break___5;
    }
#line 1164
    if (x < dx) {
#line 1164
      goto _L___3;
    } else
#line 1164
    if (*(a_height + (x - dx)) > *(a_height + x) + dy) {
      _L___3: /* CIL Label */ 
#line 1164
      if (x + dx >= m_out->width - dx) {
        {
#line 1174
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else
#line 1164
      if (*(a_height + (x + dx)) > *(a_height + x) + dy) {
        {
#line 1174
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else {
#line 1164
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1164
    if (x < 2 * dx) {
#line 1164
      goto _L___1;
    } else
#line 1164
    if (*(a_height + (x - dx * 2)) > *(a_height + x) + dy) {
      _L___1: /* CIL Label */ 
#line 1164
      if (x > m_out->width - 2 * dx) {
        {
#line 1174
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else
#line 1164
      if (*(a_height + (x + dx * 2)) > *(a_height + x) + dy) {
        {
#line 1174
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else {
#line 1164
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1164
    if (x < 3 * dx) {
#line 1164
      goto _L;
    } else
#line 1164
    if (*(a_height + (x - dx * 3)) > *(a_height + x) + dy) {
      _L: /* CIL Label */ 
#line 1164
      if (x > m_out->width - 3 * dx) {
        {
#line 1174
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else
#line 1164
      if (*(a_height + (x + dx * 3)) > *(a_height + x) + dy) {
        {
#line 1174
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      }
    }
#line 1162
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1178
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )(dx * 2));
#line 1179
  ho_bitmap_free(m_out);
#line 1182
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1183
  if (! m_out) {
#line 1184
    return ((ho_bitmap *)((void *)0));
  }
#line 1190
  x = 1;
  {
#line 1191
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1191
    if (x < m_temp->width) {
#line 1191
      if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1191
        tmp___3 = 1;
      } else {
#line 1191
        tmp___3 = 0;
      }
#line 1191
      if (tmp___3) {
#line 1191
        goto while_break___6;
      }
    } else {
#line 1191
      goto while_break___6;
    }
#line 1191
    x ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1194
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1194
    if (! (x < m_temp->width)) {
#line 1194
      goto while_break___7;
    }
#line 1197
    min_x = x - 1;
#line 1198
    min_x_start = min_x;
    {
#line 1199
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1199
      if (x < m_temp->width) {
#line 1199
        if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1199
          tmp___4 = 1;
        } else {
#line 1199
          tmp___4 = 0;
        }
#line 1199
        if (! tmp___4) {
#line 1199
          goto while_break___8;
        }
      } else {
#line 1199
        goto while_break___8;
      }
#line 1202
      if (*(a_height + min_x) >= *(a_height + x)) {
#line 1203
        min_x = x;
      }
#line 1204
      if (*(a_height + min_x_start) > *(a_height + x)) {
#line 1205
        min_x_start = x;
      }
#line 1199
      x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1208
    ho_bitmap_draw_vline(m_out, (int const   )((min_x_start + min_x) / 2), (int const   )0,
                         (int const   )m_out->height);
    }
    {
#line 1210
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1210
      if (x < m_temp->width) {
#line 1210
        if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1210
          tmp___5 = 1;
        } else {
#line 1210
          tmp___5 = 0;
        }
#line 1210
        if (tmp___5) {
#line 1210
          goto while_break___9;
        }
      } else {
#line 1210
        goto while_break___9;
      }
#line 1210
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1216
  free((void *)a_height);
#line 1217
  ho_bitmap_free(m_temp);
#line 1220
  m_out->x = (int )m_text->x;
#line 1221
  m_out->y = (int )m_text->y;
  }
#line 1223
  return (m_out);
}
}
#line 1226 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_edges_bottom_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_x ;
  int min_x_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1229
  m_out = (ho_bitmap *)((void *)0);
#line 1230
  m_temp = (ho_bitmap *)((void *)0);
#line 1235
  threshold = 10;
#line 1239
  sum = 0;
#line 1240
  y = 0;
  {
#line 1240
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1240
    if (y < (int )m_mask->height) {
#line 1240
      if (! (sum == 0)) {
#line 1240
        goto while_break;
      }
    } else {
#line 1240
      goto while_break;
    }
#line 1241
    sum = 0;
#line 1241
    x = 0;
    {
#line 1241
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1241
      if (! (x < (int )m_mask->width)) {
#line 1241
        goto while_break___0;
      }
#line 1242
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1242
        tmp = 1;
      } else {
#line 1242
        tmp = 0;
      }
#line 1242
      sum += tmp;
#line 1241
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1240
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1243
  y_start = y - 1;
#line 1244
  sum = 0;
#line 1245
  y = (int )(m_mask->height - 1);
  {
#line 1245
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1245
    if (y > y_start) {
#line 1245
      if (! (sum == 0)) {
#line 1245
        goto while_break___1;
      }
    } else {
#line 1245
      goto while_break___1;
    }
#line 1246
    sum = 0;
#line 1246
    x = 0;
    {
#line 1246
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1246
      if (! (x < (int )m_mask->width)) {
#line 1246
        goto while_break___2;
      }
#line 1247
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1247
        tmp___0 = 1;
      } else {
#line 1247
        tmp___0 = 0;
      }
#line 1247
      sum += tmp___0;
#line 1246
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1245
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1248
  line_height = (y - y_start) + 1;
#line 1250
  if (! line_height) {
#line 1251
    return ((ho_bitmap *)((void *)0));
  } else
#line 1250
  if (m_mask->width < 2) {
#line 1251
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1254
  tmp___1 = calloc((size_t )m_text->width, sizeof(int ));
#line 1254
  a_height = (int *)tmp___1;
  }
#line 1255
  if (! a_height) {
#line 1256
    return ((ho_bitmap *)((void *)0));
  }
#line 1259
  dy = (threshold * line_height) / 100;
#line 1260
  y1___0 = ((y_start + line_height) - line_height / 2) - 3;
#line 1261
  y2 = ((y_start + line_height) + line_height / 6) + 3;
#line 1262
  if (y2 > (int )(m_text->height - 1)) {
#line 1263
    y2 = (int )(m_text->height - 1);
  }
#line 1265
  dx = (int )(m_text->width / 20 + 1);
#line 1266
  x1 = dx + 1;
#line 1267
  x2 = (int )(m_text->width - (int const   )x1);
#line 1269
  x = 0;
  {
#line 1269
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1269
    if (! (x < (int )m_text->width)) {
#line 1269
      goto while_break___3;
    }
#line 1271
    y = y2;
    {
#line 1271
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1271
      if (y > y1___0) {
#line 1271
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1271
          tmp___2 = 1;
        } else {
#line 1271
          tmp___2 = 0;
        }
#line 1271
        if (tmp___2) {
#line 1271
          goto while_break___4;
        }
      } else {
#line 1271
        goto while_break___4;
      }
#line 1271
      y --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1272
    *(a_height + x) = y2 - y;
#line 1269
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1276
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1277
  if (! m_out) {
#line 1278
    return ((ho_bitmap *)((void *)0));
  }
#line 1281
  x = 0;
  {
#line 1281
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1281
    if (! (x < m_out->width)) {
#line 1281
      goto while_break___5;
    }
#line 1283
    if (x < dx) {
#line 1283
      goto _L___3;
    } else
#line 1283
    if (*(a_height + (x - dx)) > *(a_height + x) + dy) {
      _L___3: /* CIL Label */ 
#line 1283
      if (x > m_out->width - dx) {
        {
#line 1293
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else
#line 1283
      if (*(a_height + (x + dx)) > *(a_height + x) + dy) {
        {
#line 1293
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else {
#line 1283
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1283
    if (x < 2 * dx) {
#line 1283
      goto _L___1;
    } else
#line 1283
    if (*(a_height + (x - dx * 2)) > *(a_height + x) + dy) {
      _L___1: /* CIL Label */ 
#line 1283
      if (x > m_out->width - 2 * dx) {
        {
#line 1293
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else
#line 1283
      if (*(a_height + (x + dx * 2)) > *(a_height + x) + dy) {
        {
#line 1293
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else {
#line 1283
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1283
    if (x < 3 * dx) {
#line 1283
      goto _L;
    } else
#line 1283
    if (*(a_height + (x - dx * 3)) > *(a_height + x) + dy) {
      _L: /* CIL Label */ 
#line 1283
      if (x > m_out->width - 3 * dx) {
        {
#line 1293
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      } else
#line 1283
      if (*(a_height + (x + dx * 3)) > *(a_height + x) + dy) {
        {
#line 1293
        ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
        }
      }
    }
#line 1281
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1297
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )(dx * 2));
#line 1298
  ho_bitmap_free(m_out);
#line 1301
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1302
  if (! m_out) {
#line 1303
    return ((ho_bitmap *)((void *)0));
  }
#line 1309
  x = 1;
  {
#line 1310
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1310
    if (x < m_temp->width) {
#line 1310
      if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1310
        tmp___3 = 1;
      } else {
#line 1310
        tmp___3 = 0;
      }
#line 1310
      if (tmp___3) {
#line 1310
        goto while_break___6;
      }
    } else {
#line 1310
      goto while_break___6;
    }
#line 1310
    x ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1313
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1313
    if (! (x < m_temp->width)) {
#line 1313
      goto while_break___7;
    }
#line 1316
    min_x = x - 1;
#line 1317
    min_x_start = min_x;
    {
#line 1318
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1318
      if (x < m_temp->width) {
#line 1318
        if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1318
          tmp___4 = 1;
        } else {
#line 1318
          tmp___4 = 0;
        }
#line 1318
        if (! tmp___4) {
#line 1318
          goto while_break___8;
        }
      } else {
#line 1318
        goto while_break___8;
      }
#line 1321
      if (*(a_height + min_x) >= *(a_height + x)) {
#line 1322
        min_x = x;
      }
#line 1323
      if (*(a_height + min_x_start) > *(a_height + x)) {
#line 1324
        min_x_start = x;
      }
#line 1318
      x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1327
    ho_bitmap_draw_vline(m_out, (int const   )((min_x_start + min_x) / 2), (int const   )0,
                         (int const   )m_out->height);
    }
    {
#line 1329
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1329
      if (x < m_temp->width) {
#line 1329
        if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1329
          tmp___5 = 1;
        } else {
#line 1329
          tmp___5 = 0;
        }
#line 1329
        if (tmp___5) {
#line 1329
          goto while_break___9;
        }
      } else {
#line 1329
        goto while_break___9;
      }
#line 1329
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1335
  free((void *)a_height);
#line 1336
  ho_bitmap_free(m_temp);
#line 1339
  m_out->x = (int )m_text->x;
#line 1340
  m_out->y = (int )m_text->y;
  }
#line 1342
  return (m_out);
}
}
#line 1345 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_edges_left(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_y ;
  int min_y_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1348
  m_out = (ho_bitmap *)((void *)0);
#line 1349
  m_temp = (ho_bitmap *)((void *)0);
#line 1354
  threshold = 3;
#line 1358
  sum = 0;
#line 1359
  y = 0;
  {
#line 1359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1359
    if (y < (int )m_mask->height) {
#line 1359
      if (! (sum == 0)) {
#line 1359
        goto while_break;
      }
    } else {
#line 1359
      goto while_break;
    }
#line 1360
    sum = 0;
#line 1360
    x = 0;
    {
#line 1360
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1360
      if (! (x < (int )m_mask->width)) {
#line 1360
        goto while_break___0;
      }
#line 1361
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1361
        tmp = 1;
      } else {
#line 1361
        tmp = 0;
      }
#line 1361
      sum += tmp;
#line 1360
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1359
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1362
  y_start = y - 1;
#line 1363
  sum = 0;
#line 1364
  y = (int )(m_mask->height - 1);
  {
#line 1364
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1364
    if (y > y_start) {
#line 1364
      if (! (sum == 0)) {
#line 1364
        goto while_break___1;
      }
    } else {
#line 1364
      goto while_break___1;
    }
#line 1365
    sum = 0;
#line 1365
    x = 0;
    {
#line 1365
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1365
      if (! (x < (int )m_mask->width)) {
#line 1365
        goto while_break___2;
      }
#line 1366
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1366
        tmp___0 = 1;
      } else {
#line 1366
        tmp___0 = 0;
      }
#line 1366
      sum += tmp___0;
#line 1365
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1364
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1367
  line_height = (y - y_start) + 1;
#line 1369
  if (! line_height) {
#line 1370
    return ((ho_bitmap *)((void *)0));
  } else
#line 1369
  if (m_mask->width < 2) {
#line 1370
    return ((ho_bitmap *)((void *)0));
  }
#line 1373
  dx = (threshold * line_height) / 100;
#line 1374
  x1 = 0;
#line 1375
  x2 = (3 * (int )m_text->width) / 4 + 1;
#line 1377
  dy = line_height / 20 + 1;
#line 1378
  y1___0 = y_start;
#line 1379
  y2 = (y_start + line_height) + 1;
#line 1380
  if (y2 > (int )m_text->height) {
#line 1381
    y2 = (int )m_text->height;
  }
  {
#line 1384
  tmp___1 = calloc((size_t )(line_height + 1), sizeof(int ));
#line 1384
  a_height = (int *)tmp___1;
  }
#line 1385
  if (! a_height) {
#line 1386
    return ((ho_bitmap *)((void *)0));
  }
#line 1388
  y = y1___0;
  {
#line 1388
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1388
    if (! (y < y2)) {
#line 1388
      goto while_break___3;
    }
#line 1390
    x = x1;
    {
#line 1390
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1390
      if (x < x2) {
#line 1390
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1390
          tmp___2 = 1;
        } else {
#line 1390
          tmp___2 = 0;
        }
#line 1390
        if (tmp___2) {
#line 1390
          goto while_break___4;
        }
      } else {
#line 1390
        goto while_break___4;
      }
#line 1390
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1391
    *(a_height + (y - y1___0)) = x - x1;
#line 1388
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1395
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1396
  if (! m_out) {
#line 1397
    return ((ho_bitmap *)((void *)0));
  }
#line 1400
  y = y1___0;
  {
#line 1400
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1400
    if (y < y2) {
#line 1400
      if (! (y < m_out->height)) {
#line 1400
        goto while_break___5;
      }
    } else {
#line 1400
      goto while_break___5;
    }
#line 1402
    if (y < y1___0 + dy) {
#line 1402
      goto _L___3;
    } else
#line 1402
    if (*(a_height + ((y - dy) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L___3: /* CIL Label */ 
#line 1402
      if (y > y2 - dy) {
        {
#line 1413
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else
#line 1402
      if (*(a_height + ((y + dy) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1413
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else {
#line 1402
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1402
    if (y < y1___0 + 2 * dy) {
#line 1402
      goto _L___1;
    } else
#line 1402
    if (*(a_height + ((y - dy * 2) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L___1: /* CIL Label */ 
#line 1402
      if (y > y2 - 2 * dy) {
        {
#line 1413
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else
#line 1402
      if (*(a_height + ((y + dy * 2) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1413
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else {
#line 1402
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1402
    if (y < y1___0 + 3 * dy) {
#line 1402
      goto _L;
    } else
#line 1402
    if (*(a_height + ((y - dy * 3) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L: /* CIL Label */ 
#line 1402
      if (y > y2 - 3 * dy) {
        {
#line 1413
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else
#line 1402
      if (*(a_height + ((y + dy * 3) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1413
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      }
    }
#line 1400
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1417
  m_temp = ho_bitmap_vlink((ho_bitmap const   *)m_out, (int const   )(dy * 2));
#line 1418
  ho_bitmap_free(m_out);
#line 1421
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1422
  if (! m_out) {
#line 1423
    return ((ho_bitmap *)((void *)0));
  }
#line 1429
  y = y1___0 + 1;
  {
#line 1430
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1430
    if (y < y2) {
#line 1430
      if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 1430
        tmp___3 = 1;
      } else {
#line 1430
        tmp___3 = 0;
      }
#line 1430
      if (tmp___3) {
#line 1430
        goto while_break___6;
      }
    } else {
#line 1430
      goto while_break___6;
    }
#line 1430
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1431
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1431
    if (! (y < y2)) {
#line 1431
      goto while_break___7;
    }
#line 1434
    min_y = y - 1;
#line 1435
    min_y_start = min_y;
    {
#line 1436
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1436
      if (y < y2) {
#line 1436
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 1436
          tmp___4 = 1;
        } else {
#line 1436
          tmp___4 = 0;
        }
#line 1436
        if (! tmp___4) {
#line 1436
          goto while_break___8;
        }
      } else {
#line 1436
        goto while_break___8;
      }
#line 1438
      if (*(a_height + (min_y - y1___0)) >= *(a_height + (y - y1___0))) {
#line 1439
        min_y = y;
      }
#line 1440
      if (*(a_height + (min_y_start - y1___0)) > *(a_height + (y - y1___0))) {
#line 1441
        min_y_start = y;
      }
#line 1436
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1444
    ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )((min_y_start + min_y) / 2),
                         (int const   )m_out->width);
    }
    {
#line 1446
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1446
      if (y < y2) {
#line 1446
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 1446
          tmp___5 = 1;
        } else {
#line 1446
          tmp___5 = 0;
        }
#line 1446
        if (tmp___5) {
#line 1446
          goto while_break___9;
        }
      } else {
#line 1446
        goto while_break___9;
      }
#line 1446
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1450
  free((void *)a_height);
#line 1451
  ho_bitmap_free(m_temp);
#line 1454
  m_out->x = (int )m_text->x;
#line 1455
  m_out->y = (int )m_text->y;
  }
#line 1457
  return (m_out);
}
}
#line 1460 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_edges_left_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_y ;
  int min_y_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1463
  m_out = (ho_bitmap *)((void *)0);
#line 1464
  m_temp = (ho_bitmap *)((void *)0);
#line 1469
  threshold = 10;
#line 1473
  sum = 0;
#line 1474
  y = 0;
  {
#line 1474
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1474
    if (y < (int )m_mask->height) {
#line 1474
      if (! (sum == 0)) {
#line 1474
        goto while_break;
      }
    } else {
#line 1474
      goto while_break;
    }
#line 1475
    sum = 0;
#line 1475
    x = 0;
    {
#line 1475
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1475
      if (! (x < (int )m_mask->width)) {
#line 1475
        goto while_break___0;
      }
#line 1476
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1476
        tmp = 1;
      } else {
#line 1476
        tmp = 0;
      }
#line 1476
      sum += tmp;
#line 1475
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1474
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1477
  y_start = y - 1;
#line 1478
  sum = 0;
#line 1479
  y = (int )(m_mask->height - 1);
  {
#line 1479
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1479
    if (y > y_start) {
#line 1479
      if (! (sum == 0)) {
#line 1479
        goto while_break___1;
      }
    } else {
#line 1479
      goto while_break___1;
    }
#line 1480
    sum = 0;
#line 1480
    x = 0;
    {
#line 1480
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1480
      if (! (x < (int )m_mask->width)) {
#line 1480
        goto while_break___2;
      }
#line 1481
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1481
        tmp___0 = 1;
      } else {
#line 1481
        tmp___0 = 0;
      }
#line 1481
      sum += tmp___0;
#line 1480
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1479
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1482
  line_height = (y - y_start) + 1;
#line 1484
  if (! line_height) {
#line 1485
    return ((ho_bitmap *)((void *)0));
  } else
#line 1484
  if (m_mask->width < 2) {
#line 1485
    return ((ho_bitmap *)((void *)0));
  }
#line 1488
  dx = (threshold * line_height) / 100;
#line 1489
  x1 = 0;
#line 1490
  x2 = (3 * (int )m_text->width) / 4 + 1;
#line 1492
  dy = line_height / 20 + 1;
#line 1493
  y1___0 = y_start;
#line 1494
  y2 = (y_start + line_height) + 1;
#line 1495
  if (y2 > (int )m_text->height) {
#line 1496
    y2 = (int )m_text->height;
  }
  {
#line 1499
  tmp___1 = calloc((size_t )(line_height + 1), sizeof(int ));
#line 1499
  a_height = (int *)tmp___1;
  }
#line 1500
  if (! a_height) {
#line 1501
    return ((ho_bitmap *)((void *)0));
  }
#line 1503
  y = y1___0;
  {
#line 1503
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1503
    if (! (y < y2)) {
#line 1503
      goto while_break___3;
    }
#line 1505
    x = x1;
    {
#line 1505
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1505
      if (x < x2) {
#line 1505
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1505
          tmp___2 = 1;
        } else {
#line 1505
          tmp___2 = 0;
        }
#line 1505
        if (tmp___2) {
#line 1505
          goto while_break___4;
        }
      } else {
#line 1505
        goto while_break___4;
      }
#line 1505
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1506
    *(a_height + (y - y1___0)) = x - x1;
#line 1503
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1510
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1511
  if (! m_out) {
#line 1512
    return ((ho_bitmap *)((void *)0));
  }
#line 1515
  y = y1___0;
  {
#line 1515
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1515
    if (y < y2) {
#line 1515
      if (! (y < m_out->height)) {
#line 1515
        goto while_break___5;
      }
    } else {
#line 1515
      goto while_break___5;
    }
#line 1517
    if (y < y1___0 + dy) {
#line 1517
      goto _L___3;
    } else
#line 1517
    if (*(a_height + ((y - dy) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L___3: /* CIL Label */ 
#line 1517
      if (y > y2 - dy) {
        {
#line 1530
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else
#line 1517
      if (*(a_height + ((y + dy) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1530
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else {
#line 1517
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1517
    if (y < y1___0 + 2 * dy) {
#line 1517
      goto _L___1;
    } else
#line 1517
    if (*(a_height + ((y - dy * 2) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L___1: /* CIL Label */ 
#line 1517
      if (y > y2 - 2 * dy) {
        {
#line 1530
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else
#line 1517
      if (*(a_height + ((y + dy * 2) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1530
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else {
#line 1517
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1517
    if (y < y1___0 + 3 * dy) {
#line 1517
      goto _L;
    } else
#line 1517
    if (*(a_height + ((y - dy * 3) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L: /* CIL Label */ 
#line 1517
      if (y > y2 - 3 * dy) {
        {
#line 1530
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      } else
#line 1517
      if (*(a_height + ((y + dy * 3) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1530
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
        }
      }
    }
#line 1515
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1534
  m_temp = ho_bitmap_vlink((ho_bitmap const   *)m_out, (int const   )(dy * 2));
#line 1535
  ho_bitmap_free(m_out);
#line 1538
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1539
  if (! m_out) {
#line 1540
    return ((ho_bitmap *)((void *)0));
  }
#line 1546
  y = y1___0 + 1;
  {
#line 1547
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1547
    if (y < y2) {
#line 1547
      if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 1547
        tmp___3 = 1;
      } else {
#line 1547
        tmp___3 = 0;
      }
#line 1547
      if (tmp___3) {
#line 1547
        goto while_break___6;
      }
    } else {
#line 1547
      goto while_break___6;
    }
#line 1547
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1548
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1548
    if (! (y < y2)) {
#line 1548
      goto while_break___7;
    }
#line 1551
    min_y = y - 1;
#line 1552
    min_y_start = min_y;
    {
#line 1553
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1553
      if (y < y2) {
#line 1553
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 1553
          tmp___4 = 1;
        } else {
#line 1553
          tmp___4 = 0;
        }
#line 1553
        if (! tmp___4) {
#line 1553
          goto while_break___8;
        }
      } else {
#line 1553
        goto while_break___8;
      }
#line 1555
      if (*(a_height + (min_y - y1___0)) >= *(a_height + (y - y1___0))) {
#line 1556
        min_y = y;
      }
#line 1557
      if (*(a_height + (min_y_start - y1___0)) > *(a_height + (y - y1___0))) {
#line 1558
        min_y_start = y;
      }
#line 1553
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1561
    ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )((min_y_start + min_y) / 2),
                         (int const   )m_out->width);
    }
    {
#line 1563
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1563
      if (y < y2) {
#line 1563
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 1563
          tmp___5 = 1;
        } else {
#line 1563
          tmp___5 = 0;
        }
#line 1563
        if (tmp___5) {
#line 1563
          goto while_break___9;
        }
      } else {
#line 1563
        goto while_break___9;
      }
#line 1563
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1567
  free((void *)a_height);
#line 1568
  ho_bitmap_free(m_temp);
#line 1571
  m_out->x = (int )m_text->x;
#line 1572
  m_out->y = (int )m_text->y;
  }
#line 1574
  return (m_out);
}
}
#line 1577 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_edges_right(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_y ;
  int min_y_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1580
  m_out = (ho_bitmap *)((void *)0);
#line 1581
  m_temp = (ho_bitmap *)((void *)0);
#line 1586
  threshold = 5;
#line 1590
  sum = 0;
#line 1591
  y = 0;
  {
#line 1591
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1591
    if (y < (int )m_mask->height) {
#line 1591
      if (! (sum == 0)) {
#line 1591
        goto while_break;
      }
    } else {
#line 1591
      goto while_break;
    }
#line 1592
    sum = 0;
#line 1592
    x = 0;
    {
#line 1592
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1592
      if (! (x < (int )m_mask->width)) {
#line 1592
        goto while_break___0;
      }
#line 1593
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1593
        tmp = 1;
      } else {
#line 1593
        tmp = 0;
      }
#line 1593
      sum += tmp;
#line 1592
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1591
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1594
  y_start = y - 1;
#line 1595
  sum = 0;
#line 1596
  y = (int )(m_mask->height - 1);
  {
#line 1596
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1596
    if (y > y_start) {
#line 1596
      if (! (sum == 0)) {
#line 1596
        goto while_break___1;
      }
    } else {
#line 1596
      goto while_break___1;
    }
#line 1597
    sum = 0;
#line 1597
    x = 0;
    {
#line 1597
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1597
      if (! (x < (int )m_mask->width)) {
#line 1597
        goto while_break___2;
      }
#line 1598
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1598
        tmp___0 = 1;
      } else {
#line 1598
        tmp___0 = 0;
      }
#line 1598
      sum += tmp___0;
#line 1597
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1596
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1599
  line_height = (y - y_start) + 1;
#line 1601
  if (! line_height) {
#line 1602
    return ((ho_bitmap *)((void *)0));
  } else
#line 1601
  if (m_mask->width < 2) {
#line 1602
    return ((ho_bitmap *)((void *)0));
  }
#line 1605
  dx = (threshold * (int )m_text->width) / 100;
#line 1606
  x1 = (int )((m_text->width - (int const   )((3 * (int )m_text->width) / 4)) - 1);
#line 1607
  x2 = (int )m_text->width;
#line 1609
  dy = line_height / 20 + 1;
#line 1610
  y1___0 = y_start;
#line 1611
  y2 = (y_start + line_height) + 1;
#line 1612
  if (y2 > (int )m_text->height) {
#line 1613
    y2 = (int )m_text->height;
  }
  {
#line 1616
  tmp___1 = calloc((size_t )(line_height + 1), sizeof(int ));
#line 1616
  a_height = (int *)tmp___1;
  }
#line 1617
  if (! a_height) {
#line 1618
    return ((ho_bitmap *)((void *)0));
  }
#line 1620
  y = y1___0;
  {
#line 1620
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1620
    if (! (y < y2)) {
#line 1620
      goto while_break___3;
    }
#line 1622
    x = x2 - 1;
    {
#line 1622
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1622
      if (x >= x1) {
#line 1622
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1622
          tmp___2 = 1;
        } else {
#line 1622
          tmp___2 = 0;
        }
#line 1622
        if (tmp___2) {
#line 1622
          goto while_break___4;
        }
      } else {
#line 1622
        goto while_break___4;
      }
#line 1622
      x --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1623
    *(a_height + (y - y1___0)) = x2 - x;
#line 1620
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1627
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1628
  if (! m_out) {
#line 1629
    return ((ho_bitmap *)((void *)0));
  }
#line 1632
  y = y1___0;
  {
#line 1632
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1632
    if (! (y < y2)) {
#line 1632
      goto while_break___5;
    }
#line 1634
    if (y < y1___0 + dy) {
#line 1634
      goto _L___3;
    } else
#line 1634
    if (*(a_height + ((y - dy) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L___3: /* CIL Label */ 
#line 1634
      if (y > y2 - dy) {
        {
#line 1646
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else
#line 1634
      if (*(a_height + ((y + dy) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1646
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else {
#line 1634
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1634
    if (y < y1___0 + 2 * dy) {
#line 1634
      goto _L___1;
    } else
#line 1634
    if (*(a_height + ((y - dy * 2) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L___1: /* CIL Label */ 
#line 1634
      if (y > y2 - 2 * dy) {
        {
#line 1646
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else
#line 1634
      if (*(a_height + ((y + dy * 2) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1646
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else {
#line 1634
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1634
    if (y < y1___0 + 3 * dy) {
#line 1634
      goto _L;
    } else
#line 1634
    if (*(a_height + ((y - dy * 3) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L: /* CIL Label */ 
#line 1634
      if (y > y2 - 3 * dy) {
        {
#line 1646
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else
#line 1634
      if (*(a_height + ((y + dy * 3) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1646
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      }
    }
#line 1632
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1650
  m_temp = ho_bitmap_vlink((ho_bitmap const   *)m_out, (int const   )(dy * 2));
#line 1651
  ho_bitmap_free(m_out);
#line 1654
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1655
  if (! m_out) {
#line 1656
    return ((ho_bitmap *)((void *)0));
  }
#line 1662
  y = y1___0 + 1;
  {
#line 1663
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1663
    if (y < y2) {
#line 1663
      if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 1663
        tmp___3 = 1;
      } else {
#line 1663
        tmp___3 = 0;
      }
#line 1663
      if (tmp___3) {
#line 1663
        goto while_break___6;
      }
    } else {
#line 1663
      goto while_break___6;
    }
#line 1663
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1664
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1664
    if (! (y < y2)) {
#line 1664
      goto while_break___7;
    }
#line 1667
    min_y = y - 2;
#line 1668
    min_y_start = min_y;
    {
#line 1669
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1669
      if (y < y2) {
#line 1669
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 1669
          tmp___4 = 1;
        } else {
#line 1669
          tmp___4 = 0;
        }
#line 1669
        if (! tmp___4) {
#line 1669
          goto while_break___8;
        }
      } else {
#line 1669
        goto while_break___8;
      }
#line 1671
      if (*(a_height + (min_y - y1___0)) >= *(a_height + (y - y1___0))) {
#line 1672
        min_y = y;
      }
#line 1673
      if (*(a_height + (min_y_start - y1___0)) > *(a_height + (y - y1___0))) {
#line 1674
        min_y_start = y;
      }
#line 1669
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1677
    ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )((min_y_start + min_y) / 2),
                         (int const   )m_out->width);
    }
    {
#line 1679
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1679
      if (y < y2) {
#line 1679
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 1679
          tmp___5 = 1;
        } else {
#line 1679
          tmp___5 = 0;
        }
#line 1679
        if (tmp___5) {
#line 1679
          goto while_break___9;
        }
      } else {
#line 1679
        goto while_break___9;
      }
#line 1679
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1683
  free((void *)a_height);
#line 1684
  ho_bitmap_free(m_temp);
#line 1687
  m_out->x = (int )m_text->x;
#line 1688
  m_out->y = (int )m_text->y;
  }
#line 1690
  return (m_out);
}
}
#line 1693 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_edges_right_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_y ;
  int min_y_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1696
  m_out = (ho_bitmap *)((void *)0);
#line 1697
  m_temp = (ho_bitmap *)((void *)0);
#line 1702
  threshold = 10;
#line 1706
  sum = 0;
#line 1707
  y = 0;
  {
#line 1707
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1707
    if (y < (int )m_mask->height) {
#line 1707
      if (! (sum == 0)) {
#line 1707
        goto while_break;
      }
    } else {
#line 1707
      goto while_break;
    }
#line 1708
    sum = 0;
#line 1708
    x = 0;
    {
#line 1708
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1708
      if (! (x < (int )m_mask->width)) {
#line 1708
        goto while_break___0;
      }
#line 1709
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1709
        tmp = 1;
      } else {
#line 1709
        tmp = 0;
      }
#line 1709
      sum += tmp;
#line 1708
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1707
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1710
  y_start = y - 1;
#line 1711
  sum = 0;
#line 1712
  y = (int )(m_mask->height - 1);
  {
#line 1712
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1712
    if (y > y_start) {
#line 1712
      if (! (sum == 0)) {
#line 1712
        goto while_break___1;
      }
    } else {
#line 1712
      goto while_break___1;
    }
#line 1713
    sum = 0;
#line 1713
    x = 0;
    {
#line 1713
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1713
      if (! (x < (int )m_mask->width)) {
#line 1713
        goto while_break___2;
      }
#line 1714
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1714
        tmp___0 = 1;
      } else {
#line 1714
        tmp___0 = 0;
      }
#line 1714
      sum += tmp___0;
#line 1713
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1712
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1715
  line_height = (y - y_start) + 1;
#line 1717
  if (! line_height) {
#line 1718
    return ((ho_bitmap *)((void *)0));
  } else
#line 1717
  if (m_mask->width < 2) {
#line 1718
    return ((ho_bitmap *)((void *)0));
  }
#line 1721
  dx = (threshold * (int )m_text->width) / 100;
#line 1722
  x1 = (int )((m_text->width - (int const   )((3 * (int )m_text->width) / 4)) - 1);
#line 1723
  x2 = (int )m_text->width;
#line 1725
  dy = line_height / 20 + 1;
#line 1726
  y1___0 = y_start;
#line 1727
  y2 = (y_start + line_height) + 1;
#line 1728
  if (y2 > (int )m_text->height) {
#line 1729
    y2 = (int )m_text->height;
  }
  {
#line 1732
  tmp___1 = calloc((size_t )(line_height + 1), sizeof(int ));
#line 1732
  a_height = (int *)tmp___1;
  }
#line 1733
  if (! a_height) {
#line 1734
    return ((ho_bitmap *)((void *)0));
  }
#line 1736
  y = y1___0;
  {
#line 1736
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1736
    if (! (y < y2)) {
#line 1736
      goto while_break___3;
    }
#line 1738
    x = x2 - 1;
    {
#line 1738
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1738
      if (x >= x1) {
#line 1738
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1738
          tmp___2 = 1;
        } else {
#line 1738
          tmp___2 = 0;
        }
#line 1738
        if (tmp___2) {
#line 1738
          goto while_break___4;
        }
      } else {
#line 1738
        goto while_break___4;
      }
#line 1738
      x --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1739
    *(a_height + (y - y1___0)) = x2 - x;
#line 1736
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1743
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1744
  if (! m_out) {
#line 1745
    return ((ho_bitmap *)((void *)0));
  }
#line 1748
  y = y1___0;
  {
#line 1748
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1748
    if (! (y < y2)) {
#line 1748
      goto while_break___5;
    }
#line 1750
    if (y < y1___0 + dy) {
#line 1750
      goto _L___3;
    } else
#line 1750
    if (*(a_height + ((y - dy) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L___3: /* CIL Label */ 
#line 1750
      if (y > y2 - dy) {
        {
#line 1762
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else
#line 1750
      if (*(a_height + ((y + dy) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1762
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else {
#line 1750
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 1750
    if (y < y1___0 + 2 * dy) {
#line 1750
      goto _L___1;
    } else
#line 1750
    if (*(a_height + ((y - dy * 2) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L___1: /* CIL Label */ 
#line 1750
      if (y > y2 - 2 * dy) {
        {
#line 1762
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else
#line 1750
      if (*(a_height + ((y + dy * 2) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1762
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else {
#line 1750
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1750
    if (y < y1___0 + 3 * dy) {
#line 1750
      goto _L;
    } else
#line 1750
    if (*(a_height + ((y - dy * 3) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
      _L: /* CIL Label */ 
#line 1750
      if (y > y2 - 3 * dy) {
        {
#line 1762
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      } else
#line 1750
      if (*(a_height + ((y + dy * 3) - y1___0)) > *(a_height + (y - y1___0)) + dx) {
        {
#line 1762
        ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, m_text->width);
        }
      }
    }
#line 1748
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1766
  m_temp = ho_bitmap_vlink((ho_bitmap const   *)m_out, (int const   )(dy * 2));
#line 1767
  ho_bitmap_free(m_out);
#line 1770
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1771
  if (! m_out) {
#line 1772
    return ((ho_bitmap *)((void *)0));
  }
#line 1778
  y = y1___0 + 1;
  {
#line 1779
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1779
    if (y < y2) {
#line 1779
      if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 1779
        tmp___3 = 1;
      } else {
#line 1779
        tmp___3 = 0;
      }
#line 1779
      if (tmp___3) {
#line 1779
        goto while_break___6;
      }
    } else {
#line 1779
      goto while_break___6;
    }
#line 1779
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1780
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1780
    if (! (y < y2)) {
#line 1780
      goto while_break___7;
    }
#line 1783
    min_y = y - 2;
#line 1784
    min_y_start = min_y;
    {
#line 1785
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1785
      if (y < y2) {
#line 1785
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 1785
          tmp___4 = 1;
        } else {
#line 1785
          tmp___4 = 0;
        }
#line 1785
        if (! tmp___4) {
#line 1785
          goto while_break___8;
        }
      } else {
#line 1785
        goto while_break___8;
      }
#line 1787
      if (*(a_height + (min_y - y1___0)) >= *(a_height + (y - y1___0))) {
#line 1788
        min_y = y;
      }
#line 1789
      if (*(a_height + (min_y_start - y1___0)) > *(a_height + (y - y1___0))) {
#line 1790
        min_y_start = y;
      }
#line 1785
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1793
    ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )((min_y_start + min_y) / 2),
                         (int const   )m_out->width);
    }
    {
#line 1795
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1795
      if (y < y2) {
#line 1795
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 1795
          tmp___5 = 1;
        } else {
#line 1795
          tmp___5 = 0;
        }
#line 1795
        if (tmp___5) {
#line 1795
          goto while_break___9;
        }
      } else {
#line 1795
        goto while_break___9;
      }
#line 1795
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1799
  free((void *)a_height);
#line 1800
  ho_bitmap_free(m_temp);
#line 1803
  m_out->x = (int )m_text->x;
#line 1804
  m_out->y = (int )m_text->y;
  }
#line 1806
  return (m_out);
}
}
#line 1809 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_notch_top(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_x ;
  int min_x_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1812
  m_out = (ho_bitmap *)((void *)0);
#line 1813
  m_temp = (ho_bitmap *)((void *)0);
#line 1818
  threshold = 0;
#line 1822
  sum = 0;
#line 1823
  y = 0;
  {
#line 1823
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1823
    if (y < (int )m_mask->height) {
#line 1823
      if (! (sum == 0)) {
#line 1823
        goto while_break;
      }
    } else {
#line 1823
      goto while_break;
    }
#line 1824
    sum = 0;
#line 1824
    x = 0;
    {
#line 1824
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1824
      if (! (x < (int )m_mask->width)) {
#line 1824
        goto while_break___0;
      }
#line 1825
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1825
        tmp = 1;
      } else {
#line 1825
        tmp = 0;
      }
#line 1825
      sum += tmp;
#line 1824
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1823
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1826
  y_start = y - 1;
#line 1827
  sum = 0;
#line 1828
  y = (int )(m_mask->height - 1);
  {
#line 1828
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1828
    if (y > y_start) {
#line 1828
      if (! (sum == 0)) {
#line 1828
        goto while_break___1;
      }
    } else {
#line 1828
      goto while_break___1;
    }
#line 1829
    sum = 0;
#line 1829
    x = 0;
    {
#line 1829
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1829
      if (! (x < (int )m_mask->width)) {
#line 1829
        goto while_break___2;
      }
#line 1830
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1830
        tmp___0 = 1;
      } else {
#line 1830
        tmp___0 = 0;
      }
#line 1830
      sum += tmp___0;
#line 1829
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1828
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1831
  line_height = (y - y_start) + 1;
#line 1833
  if (! line_height) {
#line 1834
    return ((ho_bitmap *)((void *)0));
  } else
#line 1833
  if (m_mask->width < 2) {
#line 1834
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1837
  tmp___1 = calloc((size_t )m_text->width, sizeof(int ));
#line 1837
  a_height = (int *)tmp___1;
  }
#line 1838
  if (! a_height) {
#line 1839
    return ((ho_bitmap *)((void *)0));
  }
#line 1842
  dy = (threshold * line_height) / 100 + 1;
#line 1843
  y1___0 = (y_start - line_height / 6) - 3;
#line 1844
  y2 = (y_start + line_height / 2) + 3;
#line 1845
  if (y1___0 < 0) {
#line 1846
    y1___0 = 0;
  }
#line 1847
  dx = (int )(m_text->width / 30 + 3);
#line 1848
  x1 = dx + 1;
#line 1849
  x2 = (int )(m_text->width - (int const   )x1);
#line 1851
  x = 0;
  {
#line 1851
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1851
    if (! (x < (int )m_text->width)) {
#line 1851
      goto while_break___3;
    }
#line 1853
    y = y1___0;
    {
#line 1853
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1853
      if (y < y2) {
#line 1853
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1853
          tmp___2 = 1;
        } else {
#line 1853
          tmp___2 = 0;
        }
#line 1853
        if (tmp___2) {
#line 1853
          goto while_break___4;
        }
      } else {
#line 1853
        goto while_break___4;
      }
#line 1853
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1854
    *(a_height + x) = y - y1___0;
#line 1851
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1858
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1859
  if (! m_out) {
#line 1860
    return ((ho_bitmap *)((void *)0));
  }
#line 1863
  x = 0;
  {
#line 1863
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1863
    if (! (x < m_out->width)) {
#line 1863
      goto while_break___5;
    }
#line 1865
    if (x > dx) {
#line 1865
      if (*(a_height + (x - dx)) < *(a_height + x) - dy) {
#line 1865
        if (x < m_out->width - dx) {
#line 1865
          if (*(a_height + (x + dx)) < *(a_height + x) - dy) {
            {
#line 1871
            ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
            }
          } else {
#line 1865
            goto _L___0;
          }
        } else {
#line 1865
          goto _L___0;
        }
      } else {
#line 1865
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1865
    if (x > 2 * dx) {
#line 1865
      if (*(a_height + (x - dx * 2)) < *(a_height + x) - dy) {
#line 1865
        if (x < m_out->width - 2 * dx) {
#line 1865
          if (*(a_height + (x + dx * 2)) < *(a_height + x) - dy) {
            {
#line 1871
            ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )y_start);
            }
          }
        }
      }
    }
#line 1863
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1875
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )(dx * 2));
#line 1876
  ho_bitmap_free(m_out);
#line 1879
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1880
  if (! m_out) {
#line 1881
    return ((ho_bitmap *)((void *)0));
  }
#line 1887
  x = 1;
  {
#line 1888
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1888
    if (x < m_temp->width) {
#line 1888
      if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1888
        tmp___3 = 1;
      } else {
#line 1888
        tmp___3 = 0;
      }
#line 1888
      if (tmp___3) {
#line 1888
        goto while_break___6;
      }
    } else {
#line 1888
      goto while_break___6;
    }
#line 1888
    x ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 1889
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1889
    if (! (x < m_temp->width)) {
#line 1889
      goto while_break___7;
    }
#line 1892
    min_x = x - 1;
#line 1893
    min_x_start = min_x;
    {
#line 1894
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1894
      if (x < m_temp->width) {
#line 1894
        if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1894
          tmp___4 = 1;
        } else {
#line 1894
          tmp___4 = 0;
        }
#line 1894
        if (! tmp___4) {
#line 1894
          goto while_break___8;
        }
      } else {
#line 1894
        goto while_break___8;
      }
#line 1896
      if (*(a_height + min_x) <= *(a_height + x)) {
#line 1897
        min_x = x;
      }
#line 1898
      if (*(a_height + min_x_start) < *(a_height + x)) {
#line 1899
        min_x_start = x;
      }
#line 1894
      x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 1902
    ho_bitmap_draw_vline(m_out, (int const   )((min_x_start + min_x) / 2), (int const   )0,
                         (int const   )m_out->height);
    }
    {
#line 1904
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1904
      if (x < m_temp->width) {
#line 1904
        if (((int )*(m_temp->data + (x / 8 + 2 * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1904
          tmp___5 = 1;
        } else {
#line 1904
          tmp___5 = 0;
        }
#line 1904
        if (tmp___5) {
#line 1904
          goto while_break___9;
        }
      } else {
#line 1904
        goto while_break___9;
      }
#line 1904
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 1908
  free((void *)a_height);
#line 1909
  ho_bitmap_free(m_temp);
#line 1912
  m_out->x = (int )m_text->x;
#line 1913
  m_out->y = (int )m_text->y;
  }
#line 1915
  return (m_out);
}
}
#line 1918 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_notch_bottom(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_clean ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_x ;
  int min_x_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 1921
  m_out = (ho_bitmap *)((void *)0);
#line 1922
  m_temp = (ho_bitmap *)((void *)0);
#line 1923
  m_clean = (ho_bitmap *)((void *)0);
#line 1928
  threshold = 2;
#line 1932
  sum = 0;
#line 1933
  y = 0;
  {
#line 1933
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1933
    if (y < (int )m_mask->height) {
#line 1933
      if (! (sum == 0)) {
#line 1933
        goto while_break;
      }
    } else {
#line 1933
      goto while_break;
    }
#line 1934
    sum = 0;
#line 1934
    x = 0;
    {
#line 1934
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1934
      if (! (x < (int )m_mask->width)) {
#line 1934
        goto while_break___0;
      }
#line 1935
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1935
        tmp = 1;
      } else {
#line 1935
        tmp = 0;
      }
#line 1935
      sum += tmp;
#line 1934
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1933
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1936
  y_start = y - 1;
#line 1937
  sum = 0;
#line 1938
  y = (int )(m_mask->height - 1);
  {
#line 1938
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1938
    if (y > y_start) {
#line 1938
      if (! (sum == 0)) {
#line 1938
        goto while_break___1;
      }
    } else {
#line 1938
      goto while_break___1;
    }
#line 1939
    sum = 0;
#line 1939
    x = 0;
    {
#line 1939
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1939
      if (! (x < (int )m_mask->width)) {
#line 1939
        goto while_break___2;
      }
#line 1940
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1940
        tmp___0 = 1;
      } else {
#line 1940
        tmp___0 = 0;
      }
#line 1940
      sum += tmp___0;
#line 1939
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1938
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1941
  line_height = (y - y_start) + 1;
#line 1943
  if (! line_height) {
#line 1944
    return ((ho_bitmap *)((void *)0));
  } else
#line 1943
  if (m_mask->width < 2) {
#line 1944
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 1947
  tmp___1 = calloc((size_t )m_text->width, sizeof(int ));
#line 1947
  a_height = (int *)tmp___1;
  }
#line 1948
  if (! a_height) {
#line 1949
    return ((ho_bitmap *)((void *)0));
  }
#line 1952
  dy = (threshold * line_height) / 100 + 1;
#line 1953
  y1___0 = ((y_start + line_height) - line_height / 2) - 3;
#line 1954
  y2 = ((y_start + line_height) + line_height / 6) + 3;
#line 1955
  if (y2 > (int )(m_text->height - 1)) {
#line 1956
    y2 = (int )(m_text->height - 1);
  }
#line 1958
  dx = (int )(m_text->width / 30 + 3);
#line 1959
  x1 = dx + 1;
#line 1960
  x2 = (int )(m_text->width - (int const   )x1);
#line 1962
  x = 0;
  {
#line 1962
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1962
    if (! (x < (int )m_text->width)) {
#line 1962
      goto while_break___3;
    }
#line 1964
    y = y2;
    {
#line 1964
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1964
      if (y > y1___0) {
#line 1964
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1964
          tmp___2 = 1;
        } else {
#line 1964
          tmp___2 = 0;
        }
#line 1964
        if (tmp___2) {
#line 1964
          goto while_break___4;
        }
      } else {
#line 1964
        goto while_break___4;
      }
#line 1964
      y --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1965
    *(a_height + x) = y2 - y;
#line 1962
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 1969
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 1970
  if (! m_out) {
#line 1971
    return ((ho_bitmap *)((void *)0));
  }
#line 1974
  x = 0;
  {
#line 1974
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1974
    if (! (x < m_out->width)) {
#line 1974
      goto while_break___5;
    }
#line 1976
    if (x > dx) {
#line 1976
      if (*(a_height + (x - dx)) < *(a_height + x) - dy) {
#line 1976
        if (x < m_out->width - dx) {
#line 1976
          if (*(a_height + (x + dx)) < *(a_height + x) - dy) {
            {
#line 1982
            ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
            }
          } else {
#line 1976
            goto _L___0;
          }
        } else {
#line 1976
          goto _L___0;
        }
      } else {
#line 1976
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1976
    if (x > 2 * dx) {
#line 1976
      if (*(a_height + (x - dx * 2)) < *(a_height + x) - dy) {
#line 1976
        if (x < m_out->width - 2 * dx) {
#line 1976
          if (*(a_height + (x + dx * 2)) < *(a_height + x) - dy) {
            {
#line 1982
            ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
            }
          }
        }
      }
    }
#line 1974
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 1986
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )(dx * 2));
#line 1987
  ho_bitmap_free(m_out);
#line 1990
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 1991
  if (! m_out) {
#line 1992
    return ((ho_bitmap *)((void *)0));
  }
#line 1998
  x = 1;
  {
#line 1999
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 1999
    if (x < m_temp->width) {
#line 1999
      if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 1999
        tmp___3 = 1;
      } else {
#line 1999
        tmp___3 = 0;
      }
#line 1999
      if (tmp___3) {
#line 1999
        goto while_break___6;
      }
    } else {
#line 1999
      goto while_break___6;
    }
#line 1999
    x ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2002
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2002
    if (! (x < m_temp->width)) {
#line 2002
      goto while_break___7;
    }
#line 2005
    min_x = x - 1;
#line 2006
    min_x_start = min_x;
    {
#line 2007
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2007
      if (x < m_temp->width) {
#line 2007
        if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 2007
          tmp___4 = 1;
        } else {
#line 2007
          tmp___4 = 0;
        }
#line 2007
        if (! tmp___4) {
#line 2007
          goto while_break___8;
        }
      } else {
#line 2007
        goto while_break___8;
      }
#line 2010
      if (*(a_height + min_x) <= *(a_height + x)) {
#line 2011
        min_x = x;
      }
#line 2012
      if (*(a_height + min_x_start) < *(a_height + x)) {
#line 2013
        min_x_start = x;
      }
#line 2007
      x ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 2016
    ho_bitmap_draw_vline(m_out, (int const   )((min_x_start + min_x) / 2), (int const   )0,
                         (int const   )m_out->height);
    }
    {
#line 2018
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2018
      if (x < m_temp->width) {
#line 2018
        if (((int )*(m_temp->data + (x / 8 + (m_temp->height - 2) * m_temp->rowstride)) & (128 >> x % 8)) > 0) {
#line 2018
          tmp___5 = 1;
        } else {
#line 2018
          tmp___5 = 0;
        }
#line 2018
        if (tmp___5) {
#line 2018
          goto while_break___9;
        }
      } else {
#line 2018
        goto while_break___9;
      }
#line 2018
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 2024
  free((void *)a_height);
#line 2025
  ho_bitmap_free(m_temp);
#line 2028
  m_out->x = (int )m_text->x;
#line 2029
  m_out->y = (int )m_text->y;
  }
#line 2031
  return (m_out);
}
}
#line 2034 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_notch_left(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_y ;
  int min_y_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2037
  m_out = (ho_bitmap *)((void *)0);
#line 2038
  m_temp = (ho_bitmap *)((void *)0);
#line 2043
  threshold = 0;
#line 2047
  sum = 0;
#line 2048
  y = 0;
  {
#line 2048
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2048
    if (y < (int )m_mask->height) {
#line 2048
      if (! (sum == 0)) {
#line 2048
        goto while_break;
      }
    } else {
#line 2048
      goto while_break;
    }
#line 2049
    sum = 0;
#line 2049
    x = 0;
    {
#line 2049
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2049
      if (! (x < (int )m_mask->width)) {
#line 2049
        goto while_break___0;
      }
#line 2050
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 2050
        tmp = 1;
      } else {
#line 2050
        tmp = 0;
      }
#line 2050
      sum += tmp;
#line 2049
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2048
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2051
  y_start = y - 1;
#line 2052
  sum = 0;
#line 2053
  y = (int )(m_mask->height - 1);
  {
#line 2053
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2053
    if (y > y_start) {
#line 2053
      if (! (sum == 0)) {
#line 2053
        goto while_break___1;
      }
    } else {
#line 2053
      goto while_break___1;
    }
#line 2054
    sum = 0;
#line 2054
    x = 0;
    {
#line 2054
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2054
      if (! (x < (int )m_mask->width)) {
#line 2054
        goto while_break___2;
      }
#line 2055
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 2055
        tmp___0 = 1;
      } else {
#line 2055
        tmp___0 = 0;
      }
#line 2055
      sum += tmp___0;
#line 2054
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2053
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2056
  line_height = (y - y_start) + 1;
#line 2058
  if (! line_height) {
#line 2059
    return ((ho_bitmap *)((void *)0));
  } else
#line 2058
  if (m_mask->width < 2) {
#line 2059
    return ((ho_bitmap *)((void *)0));
  }
#line 2062
  dx = (threshold * line_height) / 100 + 1;
#line 2063
  x1 = 0;
#line 2064
  x2 = (3 * (int )m_text->width) / 4 + 1;
#line 2066
  dy = line_height / 10 + 2;
#line 2067
  y1___0 = y_start;
#line 2068
  y2 = (y_start + line_height) + 1;
#line 2069
  if (y2 > (int )m_text->height) {
#line 2070
    y2 = (int )m_text->height;
  }
  {
#line 2073
  tmp___1 = calloc((size_t )(line_height + 1), sizeof(int ));
#line 2073
  a_height = (int *)tmp___1;
  }
#line 2074
  if (! a_height) {
#line 2075
    return ((ho_bitmap *)((void *)0));
  }
#line 2077
  y = y1___0;
  {
#line 2077
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2077
    if (! (y < y2)) {
#line 2077
      goto while_break___3;
    }
#line 2079
    x = x1;
    {
#line 2079
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2079
      if (x < x2) {
#line 2079
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 2079
          tmp___2 = 1;
        } else {
#line 2079
          tmp___2 = 0;
        }
#line 2079
        if (tmp___2) {
#line 2079
          goto while_break___4;
        }
      } else {
#line 2079
        goto while_break___4;
      }
#line 2079
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2080
    *(a_height + (y - y1___0)) = x - x1;
#line 2077
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2084
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 2085
  if (! m_out) {
#line 2086
    return ((ho_bitmap *)((void *)0));
  }
#line 2089
  y = y1___0;
  {
#line 2089
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2089
    if (y < y2) {
#line 2089
      if (! (y < m_out->height)) {
#line 2089
        goto while_break___5;
      }
    } else {
#line 2089
      goto while_break___5;
    }
#line 2091
    if (y > y1___0 + dy) {
#line 2091
      if (*(a_height + ((y - dy) - y1___0)) < *(a_height + (y - y1___0)) - dx) {
#line 2091
        if (y < y2 - dy) {
#line 2091
          if (*(a_height + ((y + dy) - y1___0)) < *(a_height + (y - y1___0)) - dx) {
            {
#line 2101
            ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
            }
          } else {
#line 2091
            goto _L___0;
          }
        } else {
#line 2091
          goto _L___0;
        }
      } else {
#line 2091
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2091
    if (y > y1___0 + 2 * dy) {
#line 2091
      if (*(a_height + ((y - dy * 2) - y1___0)) < *(a_height + (y - y1___0)) - dx) {
#line 2091
        if (y < y2 - 2 * dy) {
#line 2091
          if (*(a_height + ((y + dy * 2) - y1___0)) < *(a_height + (y - y1___0)) - dx) {
            {
#line 2101
            ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
            }
          }
        }
      }
    }
#line 2089
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 2105
  m_temp = ho_bitmap_vlink((ho_bitmap const   *)m_out, (int const   )(dy * 2));
#line 2106
  ho_bitmap_free(m_out);
#line 2109
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 2110
  if (! m_out) {
#line 2111
    return ((ho_bitmap *)((void *)0));
  }
#line 2117
  y = y1___0 + 1;
  {
#line 2118
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2118
    if (y < y2) {
#line 2118
      if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 2118
        tmp___3 = 1;
      } else {
#line 2118
        tmp___3 = 0;
      }
#line 2118
      if (tmp___3) {
#line 2118
        goto while_break___6;
      }
    } else {
#line 2118
      goto while_break___6;
    }
#line 2118
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2119
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2119
    if (! (y < y2)) {
#line 2119
      goto while_break___7;
    }
#line 2122
    min_y = y - 1;
#line 2123
    min_y_start = min_y;
    {
#line 2124
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2124
      if (y < y2) {
#line 2124
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 2124
          tmp___4 = 1;
        } else {
#line 2124
          tmp___4 = 0;
        }
#line 2124
        if (! tmp___4) {
#line 2124
          goto while_break___8;
        }
      } else {
#line 2124
        goto while_break___8;
      }
#line 2126
      if (*(a_height + (min_y - y1___0)) <= *(a_height + (y - y1___0))) {
#line 2127
        min_y = y;
      }
#line 2128
      if (*(a_height + (min_y_start - y1___0)) < *(a_height + (y - y1___0))) {
#line 2129
        min_y_start = y;
      }
#line 2124
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 2132
    ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )((min_y_start + min_y) / 2),
                         (int const   )m_out->width);
    }
    {
#line 2134
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2134
      if (y < y2) {
#line 2134
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 1)) > 0) {
#line 2134
          tmp___5 = 1;
        } else {
#line 2134
          tmp___5 = 0;
        }
#line 2134
        if (tmp___5) {
#line 2134
          goto while_break___9;
        }
      } else {
#line 2134
        goto while_break___9;
      }
#line 2134
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 2138
  free((void *)a_height);
#line 2139
  ho_bitmap_free(m_temp);
#line 2142
  m_out->x = (int )m_text->x;
#line 2143
  m_out->y = (int )m_text->y;
  }
#line 2145
  return (m_out);
}
}
#line 2148 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_notch_right(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_temp ;
  int *a_height ;
  int dx ;
  int dy ;
  int x ;
  int y ;
  int line_height ;
  int y_start ;
  int y1___0 ;
  int y2 ;
  int x1 ;
  int x2 ;
  int threshold ;
  int sum ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int min_y ;
  int min_y_start ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 2151
  m_out = (ho_bitmap *)((void *)0);
#line 2152
  m_temp = (ho_bitmap *)((void *)0);
#line 2157
  threshold = 0;
#line 2161
  sum = 0;
#line 2162
  y = 0;
  {
#line 2162
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2162
    if (y < (int )m_mask->height) {
#line 2162
      if (! (sum == 0)) {
#line 2162
        goto while_break;
      }
    } else {
#line 2162
      goto while_break;
    }
#line 2163
    sum = 0;
#line 2163
    x = 0;
    {
#line 2163
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2163
      if (! (x < (int )m_mask->width)) {
#line 2163
        goto while_break___0;
      }
#line 2164
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 2164
        tmp = 1;
      } else {
#line 2164
        tmp = 0;
      }
#line 2164
      sum += tmp;
#line 2163
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2162
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2165
  y_start = y - 1;
#line 2166
  sum = 0;
#line 2167
  y = (int )(m_mask->height - 1);
  {
#line 2167
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 2167
    if (y > y_start) {
#line 2167
      if (! (sum == 0)) {
#line 2167
        goto while_break___1;
      }
    } else {
#line 2167
      goto while_break___1;
    }
#line 2168
    sum = 0;
#line 2168
    x = 0;
    {
#line 2168
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2168
      if (! (x < (int )m_mask->width)) {
#line 2168
        goto while_break___2;
      }
#line 2169
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 2169
        tmp___0 = 1;
      } else {
#line 2169
        tmp___0 = 0;
      }
#line 2169
      sum += tmp___0;
#line 2168
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 2167
    y --;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 2170
  line_height = (y - y_start) + 1;
#line 2172
  if (! line_height) {
#line 2173
    return ((ho_bitmap *)((void *)0));
  } else
#line 2172
  if (m_mask->width < 2) {
#line 2173
    return ((ho_bitmap *)((void *)0));
  }
#line 2176
  dx = (threshold * (int )m_text->width) / 100 + 1;
#line 2177
  x1 = (int )((m_text->width - (int const   )((3 * (int )m_text->width) / 4)) - 1);
#line 2178
  x2 = (int )m_text->width;
#line 2180
  dy = line_height / 10 + 2;
#line 2181
  y1___0 = y_start;
#line 2182
  y2 = (y_start + line_height) + 1;
#line 2183
  if (y2 > (int )m_text->height) {
#line 2184
    y2 = (int )m_text->height;
  }
  {
#line 2187
  tmp___1 = calloc((size_t )(line_height + 1), sizeof(int ));
#line 2187
  a_height = (int *)tmp___1;
  }
#line 2188
  if (! a_height) {
#line 2189
    return ((ho_bitmap *)((void *)0));
  }
#line 2191
  y = y1___0;
  {
#line 2191
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2191
    if (! (y < y2)) {
#line 2191
      goto while_break___3;
    }
#line 2193
    x = x2 - 1;
    {
#line 2193
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2193
      if (x >= x1) {
#line 2193
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 2193
          tmp___2 = 1;
        } else {
#line 2193
          tmp___2 = 0;
        }
#line 2193
        if (tmp___2) {
#line 2193
          goto while_break___4;
        }
      } else {
#line 2193
        goto while_break___4;
      }
#line 2193
      x --;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 2194
    *(a_height + (y - y1___0)) = x2 - x;
#line 2191
    y ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 2198
  m_out = ho_bitmap_new(m_text->width, m_text->height);
  }
#line 2199
  if (! m_out) {
#line 2200
    return ((ho_bitmap *)((void *)0));
  }
#line 2203
  y = y1___0;
  {
#line 2203
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 2203
    if (y < y2) {
#line 2203
      if (! (y < m_out->height)) {
#line 2203
        goto while_break___5;
      }
    } else {
#line 2203
      goto while_break___5;
    }
#line 2205
    if (y > y1___0 + dy) {
#line 2205
      if (*(a_height + ((y - dy) - y1___0)) < *(a_height + (y - y1___0)) - dx) {
#line 2205
        if (y < y2 - dy) {
#line 2205
          if (*(a_height + ((y + dy) - y1___0)) < *(a_height + (y - y1___0)) - dx) {
            {
#line 2214
            ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
            }
          } else {
#line 2205
            goto _L___0;
          }
        } else {
#line 2205
          goto _L___0;
        }
      } else {
#line 2205
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 2205
    if (y > y1___0 + 2 * dy) {
#line 2205
      if (*(a_height + ((y - dy * 2) - y1___0)) < *(a_height + (y - y1___0)) - dx) {
#line 2205
        if (y < y2 - 2 * dy) {
#line 2205
          if (*(a_height + ((y + dy * 2) - y1___0)) < *(a_height + (y - y1___0)) - dx) {
            {
#line 2214
            ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )y, (int const   )m_out->width);
            }
          }
        }
      }
    }
#line 2203
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 2218
  m_temp = ho_bitmap_vlink((ho_bitmap const   *)m_out, (int const   )(dy * 2));
#line 2219
  ho_bitmap_free(m_out);
#line 2222
  m_out = ho_bitmap_new((int const   )m_temp->width, (int const   )m_temp->height);
  }
#line 2223
  if (! m_out) {
#line 2224
    return ((ho_bitmap *)((void *)0));
  }
#line 2230
  y = y1___0 + 1;
  {
#line 2231
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 2231
    if (y < y2) {
#line 2231
      if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 2231
        tmp___3 = 1;
      } else {
#line 2231
        tmp___3 = 0;
      }
#line 2231
      if (tmp___3) {
#line 2231
        goto while_break___6;
      }
    } else {
#line 2231
      goto while_break___6;
    }
#line 2231
    y ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 2232
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 2232
    if (! (y < y2)) {
#line 2232
      goto while_break___7;
    }
#line 2235
    min_y = y - 2;
#line 2236
    min_y_start = min_y;
    {
#line 2237
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 2237
      if (y < y2) {
#line 2237
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 2237
          tmp___4 = 1;
        } else {
#line 2237
          tmp___4 = 0;
        }
#line 2237
        if (! tmp___4) {
#line 2237
          goto while_break___8;
        }
      } else {
#line 2237
        goto while_break___8;
      }
#line 2239
      if (*(a_height + (min_y - y1___0)) <= *(a_height + (y - y1___0))) {
#line 2240
        min_y = y;
      }
#line 2241
      if (*(a_height + (min_y_start - y1___0)) < *(a_height + (y - y1___0))) {
#line 2242
        min_y_start = y;
      }
#line 2237
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
    {
#line 2245
    ho_bitmap_draw_hline(m_out, (int const   )0, (int const   )((min_y_start + min_y) / 2),
                         (int const   )m_out->width);
    }
    {
#line 2247
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 2247
      if (y < y2) {
#line 2247
        if (((int )*(m_temp->data + y * m_temp->rowstride) & (128 >> 2)) > 0) {
#line 2247
          tmp___5 = 1;
        } else {
#line 2247
          tmp___5 = 0;
        }
#line 2247
        if (tmp___5) {
#line 2247
          goto while_break___9;
        }
      } else {
#line 2247
        goto while_break___9;
      }
#line 2247
      y ++;
    }
    while_break___9: /* CIL Label */ ;
    }
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 2251
  free((void *)a_height);
#line 2252
  ho_bitmap_free(m_temp);
#line 2255
  m_out->x = (int )m_text->x;
#line 2256
  m_out->y = (int )m_text->y;
  }
#line 2258
  return (m_out);
}
}
#line 2261 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
int ho_font_pnm_save(ho_bitmap const   *m_text , ho_bitmap const   *m_nikud , ho_bitmap const   *m_mask ,
                     char const   *filename ) 
{ 
  FILE *file ;
  ho_pixbuf *pix ;
  int x ;
  int y ;
  unsigned char red ;
  unsigned char green ;
  unsigned char blue ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 2265
  file = (FILE *)((void *)0);
#line 2266
  pix = (ho_pixbuf *)((void *)0);
#line 2271
  pix = ho_pixbuf_new((unsigned char const   )3, m_text->width, m_text->height, (int const   )0);
  }
#line 2272
  if (! pix) {
#line 2273
    return (-1);
  }
#line 2276
  x = 0;
  {
#line 2276
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2276
    if (! (x < (int )m_text->width)) {
#line 2276
      goto while_break;
    }
#line 2277
    y = 0;
    {
#line 2277
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2277
      if (! (y < (int )m_text->height)) {
#line 2277
        goto while_break___0;
      }
#line 2279
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 2279
        tmp = 1;
      } else {
#line 2279
        tmp = 0;
      }
#line 2279
      red = (unsigned char )(tmp * 255);
#line 2280
      if (((int )*(m_nikud->data + (x / 8 + y * (int )m_nikud->rowstride)) & (128 >> x % 8)) > 0) {
#line 2280
        tmp___0 = 1;
      } else {
#line 2280
        tmp___0 = 0;
      }
#line 2280
      green = (unsigned char )(tmp___0 * 255);
#line 2281
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 2281
        tmp___1 = 1;
      } else {
#line 2281
        tmp___1 = 0;
      }
#line 2281
      blue = (unsigned char )(tmp___1 * 255);
#line 2283
      *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = red;
#line 2284
      *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 1)) = green;
#line 2285
      *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 2)) = blue;
#line 2277
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2276
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2289
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
  }
#line 2291
  if (! file) {
    {
#line 2293
    ho_pixbuf_free(pix);
    }
#line 2294
    return (-1);
  }
  {
#line 2298
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"P6 %d %d 255\n",
          pix->width, pix->height);
#line 2301
  fwrite((void const   */* __restrict  */)pix->data, (size_t )1, (size_t )(pix->height * pix->rowstride),
         (FILE */* __restrict  */)file);
#line 2302
  fclose(file);
#line 2304
  ho_pixbuf_free(pix);
  }
#line 2306
  return (0);
}
}
#line 2309 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
int ho_font_pnm_load(ho_bitmap **m_text , ho_bitmap **m_nikud , ho_bitmap **m_mask ,
                     char const   *filename ) 
{ 
  ho_pixbuf *pix ;
  int x ;
  int y ;
  unsigned char red ;
  unsigned char green ;
  unsigned char blue ;

  {
  {
#line 2313
  pix = (ho_pixbuf *)((void *)0);
#line 2318
  pix = ho_pixbuf_pnm_load(filename);
  }
#line 2319
  if (! pix) {
#line 2320
    return (-1);
  }
#line 2322
  if ((int )pix->n_channels != 3) {
    {
#line 2324
    ho_pixbuf_free(pix);
    }
#line 2325
    return (-1);
  }
  {
#line 2329
  *m_text = ho_bitmap_new((int const   )pix->width, (int const   )pix->height);
#line 2330
  *m_nikud = ho_bitmap_new((int const   )pix->width, (int const   )pix->height);
#line 2331
  *m_mask = ho_bitmap_new((int const   )pix->width, (int const   )pix->height);
#line 2334
  x = 0;
  }
  {
#line 2334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2334
    if (! (x < (*m_text)->width)) {
#line 2334
      goto while_break;
    }
#line 2335
    y = 0;
    {
#line 2335
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2335
      if (! (y < (*m_text)->height)) {
#line 2335
        goto while_break___0;
      }
#line 2337
      red = *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride));
#line 2338
      green = *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 1));
#line 2339
      blue = *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 2));
#line 2341
      if (red) {
#line 2342
        *((*m_text)->data + (x / 8 + y * (*m_text)->rowstride)) = (unsigned char )((int )*((*m_text)->data + (x / 8 + y * (*m_text)->rowstride)) | (128 >> x % 8));
      }
#line 2343
      if (green) {
#line 2344
        *((*m_nikud)->data + (x / 8 + y * (*m_nikud)->rowstride)) = (unsigned char )((int )*((*m_nikud)->data + (x / 8 + y * (*m_nikud)->rowstride)) | (128 >> x % 8));
      }
#line 2345
      if (blue) {
#line 2346
        *((*m_mask)->data + (x / 8 + y * (*m_mask)->rowstride)) = (unsigned char )((int )*((*m_mask)->data + (x / 8 + y * (*m_mask)->rowstride)) | (128 >> x % 8));
      }
#line 2335
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2334
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2350
  ho_pixbuf_free(pix);
  }
#line 2351
  return (0);
}
}
#line 2354 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_filter(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                          int filter_index ) 
{ 
  ho_bitmap *m_out ;

  {
#line 2358
  m_out = (ho_bitmap *)((void *)0);
  {
#line 2362
  if (filter_index == 1) {
#line 2362
    goto case_1;
  }
#line 2365
  if (filter_index == 2) {
#line 2365
    goto case_2;
  }
#line 2368
  if (filter_index == 3) {
#line 2368
    goto case_3;
  }
#line 2371
  if (filter_index == 4) {
#line 2371
    goto case_4;
  }
#line 2374
  if (filter_index == 5) {
#line 2374
    goto case_5;
  }
#line 2377
  if (filter_index == 6) {
#line 2377
    goto case_6;
  }
#line 2380
  if (filter_index == 7) {
#line 2380
    goto case_7;
  }
#line 2383
  if (filter_index == 8) {
#line 2383
    goto case_8;
  }
#line 2386
  if (filter_index == 9) {
#line 2386
    goto case_9;
  }
#line 2389
  if (filter_index == 10) {
#line 2389
    goto case_10;
  }
#line 2392
  if (filter_index == 11) {
#line 2392
    goto case_11;
  }
#line 2395
  if (filter_index == 12) {
#line 2395
    goto case_12;
  }
#line 2398
  if (filter_index == 13) {
#line 2398
    goto case_13;
  }
#line 2401
  if (filter_index == 14) {
#line 2401
    goto case_14;
  }
#line 2404
  if (filter_index == 15) {
#line 2404
    goto case_15;
  }
#line 2407
  if (filter_index == 16) {
#line 2407
    goto case_16;
  }
#line 2410
  if (filter_index == 17) {
#line 2410
    goto case_17;
  }
#line 2413
  if (filter_index == 18) {
#line 2413
    goto case_18;
  }
#line 2416
  if (filter_index == 19) {
#line 2416
    goto case_19;
  }
#line 2419
  if (filter_index == 20) {
#line 2419
    goto case_20;
  }
#line 2422
  if (filter_index == 21) {
#line 2422
    goto case_21;
  }
#line 2425
  if (filter_index == 22) {
#line 2425
    goto case_22;
  }
#line 2428
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 2363
  m_out = ho_font_main_sign(m_text, m_mask);
  }
#line 2364
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 2366
  m_out = ho_font_second_object(m_text, m_mask);
  }
#line 2367
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 2369
  m_out = ho_font_holes(m_text, m_mask);
  }
#line 2370
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 2372
  m_out = ho_font_hbars(m_text, m_mask);
  }
#line 2373
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 2375
  m_out = ho_font_vbars(m_text, m_mask);
  }
#line 2376
  goto switch_break;
  case_6: /* CIL Label */ 
  {
#line 2378
  m_out = ho_font_diagonal(m_text, m_mask);
  }
#line 2379
  goto switch_break;
  case_7: /* CIL Label */ 
  {
#line 2381
  m_out = ho_font_diagonal_left(m_text, m_mask);
  }
#line 2382
  goto switch_break;
  case_8: /* CIL Label */ 
  {
#line 2384
  m_out = ho_font_thin(m_text, m_mask);
  }
#line 2385
  goto switch_break;
  case_9: /* CIL Label */ 
  {
#line 2387
  m_out = ho_font_cross(m_text, m_mask);
  }
#line 2388
  goto switch_break;
  case_10: /* CIL Label */ 
  {
#line 2390
  m_out = ho_font_ends(m_text, m_mask);
  }
#line 2391
  goto switch_break;
  case_11: /* CIL Label */ 
  {
#line 2393
  m_out = ho_font_edges_top(m_text, m_mask);
  }
#line 2394
  goto switch_break;
  case_12: /* CIL Label */ 
  {
#line 2396
  m_out = ho_font_edges_top_big(m_text, m_mask);
  }
#line 2397
  goto switch_break;
  case_13: /* CIL Label */ 
  {
#line 2399
  m_out = ho_font_edges_bottom(m_text, m_mask);
  }
#line 2400
  goto switch_break;
  case_14: /* CIL Label */ 
  {
#line 2402
  m_out = ho_font_edges_bottom_big(m_text, m_mask);
  }
#line 2403
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 2405
  m_out = ho_font_edges_left(m_text, m_mask);
  }
#line 2406
  goto switch_break;
  case_16: /* CIL Label */ 
  {
#line 2408
  m_out = ho_font_edges_left_big(m_text, m_mask);
  }
#line 2409
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 2411
  m_out = ho_font_edges_right(m_text, m_mask);
  }
#line 2412
  goto switch_break;
  case_18: /* CIL Label */ 
  {
#line 2414
  m_out = ho_font_edges_right_big(m_text, m_mask);
  }
#line 2415
  goto switch_break;
  case_19: /* CIL Label */ 
  {
#line 2417
  m_out = ho_font_notch_top(m_text, m_mask);
  }
#line 2418
  goto switch_break;
  case_20: /* CIL Label */ 
  {
#line 2420
  m_out = ho_font_notch_bottom(m_text, m_mask);
  }
#line 2421
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 2423
  m_out = ho_font_notch_left(m_text, m_mask);
  }
#line 2424
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 2426
  m_out = ho_font_notch_right(m_text, m_mask);
  }
#line 2427
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 2429
  m_out = (ho_bitmap *)((void *)0);
#line 2430
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 2433
  return (m_out);
}
}
#line 2436 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_font.c"
ho_bitmap *ho_font_holes_filter(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                int filter_index ) 
{ 
  ho_bitmap *m_out ;
  ho_bitmap *m_holes ;

  {
  {
#line 2440
  m_out = (ho_bitmap *)((void *)0);
#line 2441
  m_holes = (ho_bitmap *)((void *)0);
#line 2443
  m_holes = ho_font_holes(m_text, m_mask);
  }
#line 2444
  if (! m_holes) {
#line 2445
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 2449
  m_out = ho_font_filter((ho_bitmap const   *)m_holes, m_mask, filter_index);
#line 2451
  ho_bitmap_free(m_holes);
  }
#line 2453
  return (m_out);
}
}
#line 50 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.h"
ho_bitmap *ho_segment_paragraphs_fine(ho_bitmap const   *m , unsigned char const   box ,
                                      double const   font_height_factor_min , double const   font_height_factor_max ,
                                      double const   font_width_factor_min , double const   font_width_factor_max ,
                                      double const   horizontal_link_factor , double const   vertical_link_factor ) ;
#line 79
ho_bitmap *ho_segment_lines_fine(ho_bitmap const   *m , double const   font_height_factor_min ,
                                 double const   font_height_factor_max , double const   font_width_factor_min ,
                                 double const   font_width_factor_max , double const   link_arg ,
                                 double const   link_arg_2 , double const   extend_arg ,
                                 double const   extend_arg_2 , double const   erode_arg ) ;
#line 101
ho_bitmap *ho_segment_words_fine(ho_bitmap const   *m , ho_bitmap const   *m_line_map ,
                                 double const   horizontal_link_factor , double const   top_frame_factor ,
                                 double const   bottom_frame_factor ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.c"
ho_bitmap *ho_segment_paragraphs_fine(ho_bitmap const   *m , unsigned char const   box ,
                                      double const   font_height_factor_min , double const   font_height_factor_max ,
                                      double const   font_width_factor_min , double const   font_width_factor_max ,
                                      double const   horizontal_link_factor , double const   vertical_link_factor ) 
{ 
  ho_bitmap *m_clean ;
  ho_bitmap *m_temp1 ;
  ho_bitmap *m_out ;

  {
  {
#line 57
  m_clean = ho_bitmap_filter_by_size(m, (int )((double )m->font_height * (double )font_height_factor_min),
                                     (int )((double )m->font_height * (double )font_height_factor_max),
                                     (int )((double )m->font_width * (double )font_width_factor_min),
                                     (int )((double )m->font_width * (double )font_width_factor_max));
  }
#line 62
  if (! m_clean) {
#line 63
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 66
  m_temp1 = ho_bitmap_vlink((ho_bitmap const   *)m_clean, (int const   )((double const   )m->line_spacing * vertical_link_factor));
  }
#line 67
  if (! m_temp1) {
#line 68
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 70
  m_out = ho_bitmap_hlink((ho_bitmap const   *)m_temp1, (int const   )((double const   )m->font_width * horizontal_link_factor));
  }
#line 71
  if (! m_out) {
#line 72
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 74
  ho_bitmap_free(m_temp1);
  }
#line 76
  if ((int const   )box > 0) {
#line 76
    if ((int const   )box < 255) {
      {
#line 77
      m_temp1 = ho_bitmap_filter_boxes((ho_bitmap const   *)m_out, (int const   )0,
                                       (int const   )0);
      }
    } else {
#line 76
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 78
  if ((int const   )box == 255) {
    {
#line 79
    m_temp1 = ho_bitmap_filter_fill((ho_bitmap const   *)m_out);
    }
  } else {
    {
#line 81
    m_temp1 = ho_bitmap_filter_fill((ho_bitmap const   *)m_out);
    }
  }
  {
#line 83
  ho_bitmap_free(m_out);
#line 84
  ho_bitmap_free(m_clean);
#line 88
  m_out = ho_bitmap_filter_hlink(m_temp1, (int )(m->font_width * 6), (int )(m->font_height * 2 + m->line_spacing * 2));
#line 91
  ho_bitmap_free(m_temp1);
#line 94
  m_temp1 = ho_bitmap_filter_by_size((ho_bitmap const   *)m_out, (2 * (int )m->font_height) / 3,
                                     (int )m->height, (int )(m->font_width * 3), (int )m->width);
#line 98
  ho_bitmap_free(m_out);
#line 99
  m_out = m_temp1;
  }
#line 101
  return (m_out);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.c"
ho_bitmap *ho_segment_paragraphs(ho_bitmap const   *m , unsigned char const   box ) 
{ 
  ho_bitmap *m_out ;
  double font_height_factor_min ;
  double font_height_factor_max ;
  double font_width_factor_min ;
  double font_width_factor_max ;
  double horizontal_link_factor ;
  double vertical_link_factor ;

  {
#line 108
  font_height_factor_min = 0.25;
#line 109
  font_height_factor_max = 4.0;
#line 110
  font_width_factor_min = 0.25;
#line 111
  font_width_factor_max = 5.0;
#line 112
  horizontal_link_factor = 2.0;
#line 113
  vertical_link_factor = 1.2;
#line 116
  if (m->nikud) {
#line 118
    font_height_factor_min = 0.5;
#line 119
    font_height_factor_max = 4.0;
#line 120
    font_width_factor_min = 1.0 / 3.0;
#line 121
    font_width_factor_max = 5.0;
  }
#line 125
  if ((int const   )box == 1) {
#line 127
    horizontal_link_factor = 6.0;
#line 128
    vertical_link_factor = 1.2;
  }
#line 133
  if ((int const   )box == 255) {
#line 135
    horizontal_link_factor = 1.5;
#line 136
    vertical_link_factor = 0.8;
  }
  {
#line 139
  m_out = ho_segment_paragraphs_fine(m, box, (double const   )font_height_factor_min,
                                     (double const   )font_height_factor_max, (double const   )font_width_factor_min,
                                     (double const   )font_width_factor_max, (double const   )horizontal_link_factor,
                                     (double const   )vertical_link_factor);
  }
#line 144
  return (m_out);
}
}
#line 147 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.c"
ho_bitmap *ho_segment_lines_fine(ho_bitmap const   *m , double const   font_height_factor_min ,
                                 double const   font_height_factor_max , double const   font_width_factor_min ,
                                 double const   font_width_factor_max , double const   link_arg ,
                                 double const   link_arg_2 , double const   extend_arg ,
                                 double const   extend_arg_2 , double const   erode_arg ) 
{ 
  int i ;
  ho_bitmap *m_clean ;
  ho_bitmap *m_temp ;
  ho_bitmap *m_out ;

  {
  {
#line 160
  ho_dimentions_font_width_height_nikud((ho_bitmap *)m, (int const   )12, (int const   )350,
                                        (int const   )12, (int const   )350);
#line 162
  m_clean = ho_bitmap_filter_by_size(m, (int )((double )m->font_height * (double )font_height_factor_min),
                                     (int )((double )m->font_height * (double )font_height_factor_max),
                                     (int )((double )m->font_width * (double )font_width_factor_min),
                                     (int )((double )m->font_width * (double )font_width_factor_max));
  }
#line 167
  if (! m_clean) {
#line 168
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 171
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_clean, (int const   )((double const   )m->font_width * link_arg));
  }
#line 172
  if (! m_temp) {
#line 173
    return ((ho_bitmap *)((void *)0));
  }
#line 174
  m_out = m_temp;
#line 177
  i = 0;
  {
#line 177
  while (1) {
    while_continue: /* CIL Label */ ;
#line 177
    if (! (i < 1)) {
#line 177
      goto while_break;
    }
    {
#line 180
    m_temp = ho_bitmap_filter_obj_extend_lateraly((ho_bitmap const   *)m_out, (int const   )((double const   )m->font_width * extend_arg));
#line 182
    ho_bitmap_free(m_out);
    }
#line 183
    if (! m_temp) {
#line 184
      return ((ho_bitmap *)((void *)0));
    }
    {
#line 185
    m_out = m_temp;
#line 187
    m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )((double const   )m->font_width * link_arg));
#line 188
    ho_bitmap_free(m_out);
    }
#line 189
    if (! m_temp) {
#line 190
      return ((ho_bitmap *)((void *)0));
    }
#line 191
    m_out = m_temp;
#line 177
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 195
  m_temp = ho_bitmap_filter_set_height((ho_bitmap const   *)m_out, m->font_height,
                                       (int const   )0, (int const   )0);
#line 196
  ho_bitmap_free(m_out);
  }
#line 197
  if (! m_temp) {
#line 198
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 199
  m_out = m_temp;
#line 202
  m_temp = ho_bitmap_herode((ho_bitmap const   *)m_out, (int const   )((double const   )m->font_width * erode_arg));
#line 203
  ho_bitmap_free(m_out);
  }
#line 204
  if (! m_temp) {
#line 205
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 206
  m_out = m_temp;
#line 209
  m_temp = ho_bitmap_filter_set_height((ho_bitmap const   *)m_out, m->font_height,
                                       (int const   )0, (int const   )0);
#line 210
  ho_bitmap_free(m_out);
  }
#line 211
  if (! m_temp) {
#line 212
    return ((ho_bitmap *)((void *)0));
  }
#line 213
  m_out = m_temp;
#line 215
  i = 0;
  {
#line 215
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 215
    if (! (i < 6)) {
#line 215
      goto while_break___0;
    }
    {
#line 217
    m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )((double const   )m->font_width * link_arg));
#line 218
    ho_bitmap_free(m_out);
    }
#line 219
    if (! m_temp) {
#line 220
      return ((ho_bitmap *)((void *)0));
    }
    {
#line 221
    m_out = m_temp;
#line 224
    m_temp = ho_bitmap_filter_obj_extend_lateraly((ho_bitmap const   *)m_out, (int const   )((double const   )m->font_width * extend_arg_2));
#line 227
    ho_bitmap_free(m_out);
    }
#line 228
    if (! m_temp) {
#line 229
      return ((ho_bitmap *)((void *)0));
    }
#line 230
    m_out = m_temp;
#line 215
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 234
  m_temp = ho_bitmap_filter_set_height((ho_bitmap const   *)m_out, m->font_height,
                                       (int const   )0, (int const   )0);
#line 235
  ho_bitmap_free(m_out);
  }
#line 236
  if (! m_temp) {
#line 237
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 238
  m_out = m_temp;
#line 241
  ho_bitmap_or(m_out, (ho_bitmap const   *)m_clean);
#line 244
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )((double const   )m->font_width * link_arg));
#line 245
  ho_bitmap_free(m_out);
  }
#line 246
  if (! m_temp) {
#line 247
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 248
  m_out = m_temp;
#line 251
  m_temp = ho_bitmap_filter_obj_extend_lateraly((ho_bitmap const   *)m_out, (int const   )((double const   )m->font_width * extend_arg_2));
#line 253
  ho_bitmap_free(m_out);
  }
#line 254
  if (! m_temp) {
#line 255
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 256
  m_out = m_temp;
#line 259
  m_temp = ho_bitmap_herode((ho_bitmap const   *)m_out, (int const   )((double const   )m->font_width * erode_arg));
#line 260
  ho_bitmap_free(m_out);
  }
#line 261
  if (! m_temp) {
#line 262
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 263
  m_out = m_temp;
#line 266
  m_temp = ho_bitmap_filter_set_height((ho_bitmap const   *)m_out, m->font_height,
                                       (int const   )0, (int const   )0);
#line 267
  ho_bitmap_free(m_out);
  }
#line 268
  if (! m_temp) {
#line 269
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 270
  m_out = m_temp;
#line 272
  ho_bitmap_free(m_clean);
  }
#line 274
  return (m_out);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.c"
ho_bitmap *ho_segment_lines(ho_bitmap const   *m ) 
{ 
  ho_bitmap *m_out ;
  double font_height_factor_min ;
  double font_height_factor_max ;
  double font_width_factor_min ;
  double font_width_factor_max ;
  double link_arg ;
  double link_arg_2 ;
  double extend_arg ;
  double extend_arg_2 ;
  double erode_arg ;

  {
#line 282
  font_height_factor_min = 8.0 / 10.0;
#line 283
  font_height_factor_max = 12.0 / 10.0;
#line 284
  font_width_factor_min = 1.0 / 3.0;
#line 285
  font_width_factor_max = 5.0;
#line 287
  link_arg = 3.0;
#line 288
  link_arg_2 = 6.0;
#line 289
  extend_arg = 1.2;
#line 290
  extend_arg_2 = 3.0;
#line 291
  erode_arg = 5.0;
#line 294
  if ((double )m->width < (double )m->font_width * erode_arg) {
#line 295
    erode_arg = (double )1;
  }
#line 298
  if (! m->nikud) {
#line 300
    font_height_factor_min = 7.0 / 10.0;
#line 301
    font_height_factor_max = 12.0 / 10.0;
#line 302
    font_width_factor_min = 1.0 / 5.0;
#line 303
    font_width_factor_max = 5.0;
  }
  {
#line 306
  m_out = ho_segment_lines_fine(m, (double const   )font_height_factor_min, (double const   )font_height_factor_max,
                                (double const   )font_width_factor_min, (double const   )font_width_factor_max,
                                (double const   )link_arg, (double const   )link_arg_2,
                                (double const   )extend_arg, (double const   )extend_arg_2,
                                (double const   )erode_arg);
  }
#line 311
  return (m_out);
}
}
#line 314 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.c"
ho_bitmap *ho_segment_words_fine(ho_bitmap const   *m , ho_bitmap const   *m_line_map ,
                                 double const   horizontal_link_factor , double const   top_frame_factor ,
                                 double const   bottom_frame_factor ) 
{ 
  ho_bitmap *m_temp ;
  ho_bitmap *m_out ;
  ho_bitmap *m_temp_line_map ;
  int x ;
  int y ;
  int line_height ;
  int font_spacing ;
  int tmp ;
  int tmp___0 ;

  {
#line 319
  m_temp = (ho_bitmap *)((void *)0);
#line 320
  m_out = (ho_bitmap *)((void *)0);
#line 321
  m_temp_line_map = (ho_bitmap *)((void *)0);
#line 332
  if (m->font_spacing == 0) {
#line 333
    font_spacing = (int )(m->font_width / 4 + 1);
  } else
#line 334
  if (m->font_spacing == 255) {
#line 335
    font_spacing = (int )m->font_width;
  } else {
#line 337
    font_spacing = (int )m->font_spacing;
  }
#line 340
  x = (int )(m_line_map->width / 2);
#line 341
  y = 0;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (y < (int )m_line_map->height) {
#line 341
      if (((int )*(m_line_map->data + (x / 8 + y * (int )m_line_map->rowstride)) & (128 >> x % 8)) > 0) {
#line 341
        tmp = 1;
      } else {
#line 341
        tmp = 0;
      }
#line 341
      if (tmp) {
#line 341
        goto while_break;
      }
    } else {
#line 341
      goto while_break;
    }
#line 341
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 343
  line_height = y;
  {
#line 344
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 344
    if (y < (int )m_line_map->height) {
#line 344
      if (((int )*(m_line_map->data + (x / 8 + y * (int )m_line_map->rowstride)) & (128 >> x % 8)) > 0) {
#line 344
        tmp___0 = 1;
      } else {
#line 344
        tmp___0 = 0;
      }
#line 344
      if (! tmp___0) {
#line 344
        goto while_break___0;
      }
    } else {
#line 344
      goto while_break___0;
    }
#line 344
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 345
  line_height = y - line_height;
#line 348
  m_temp = ho_bitmap_clone(m);
  }
#line 349
  if (! m_temp) {
#line 350
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 353
  m_temp_line_map = ho_bitmap_set_height(m_line_map, (int const   )line_height, (int const   )(line_height / 4),
                                         (int const   )(line_height / 4));
  }
#line 356
  if (m_temp_line_map) {
    {
#line 358
    ho_bitmap_and(m_temp, (ho_bitmap const   *)m_temp_line_map);
#line 359
    ho_bitmap_free(m_temp_line_map);
    }
  } else {
    {
#line 363
    ho_bitmap_and(m_temp, m_line_map);
    }
  }
  {
#line 365
  m_out = m_temp;
#line 368
  m_temp = ho_bitmap_set_height((ho_bitmap const   *)m_out, (int const   )(line_height * 2),
                                (int const   )line_height, (int const   )line_height);
#line 370
  ho_bitmap_free(m_out);
  }
#line 371
  if (! m_temp) {
#line 372
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 373
  m_out = m_temp;
#line 374
  ho_bitmap_and(m_out, m_line_map);
#line 377
  m_temp = ho_bitmap_hlink((ho_bitmap const   *)m_out, (int const   )((double )font_spacing * (double )horizontal_link_factor));
#line 379
  ho_bitmap_free(m_out);
  }
#line 380
  if (! m_temp) {
#line 381
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 382
  m_out = m_temp;
#line 385
  m_temp = ho_bitmap_set_height((ho_bitmap const   *)m_out, (int const   )(line_height * 2),
                                (int const   )line_height, (int const   )line_height);
#line 387
  ho_bitmap_free(m_out);
  }
#line 388
  if (! m_temp) {
#line 389
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 390
  m_out = m_temp;
#line 391
  ho_bitmap_and(m_out, m_line_map);
#line 393
  m_temp = ho_bitmap_set_height((ho_bitmap const   *)m_out, (int const   )line_height,
                                (int const   )((double )line_height * (double )top_frame_factor),
                                (int const   )((double )line_height * (double )bottom_frame_factor));
#line 397
  ho_bitmap_free(m_out);
  }
#line 398
  if (! m_temp) {
#line 399
    return ((ho_bitmap *)((void *)0));
  }
#line 400
  m_out = m_temp;
#line 403
  m_out->x = (int )m->x;
#line 404
  m_out->y = (int )m->y;
#line 406
  return (m_out);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.c"
ho_bitmap *ho_segment_words(ho_bitmap const   *m , ho_bitmap const   *m_line_map ,
                            char const   font_spacing_code ) 
{ 
  ho_bitmap *m_out ;
  double horizontal_link_factor ;
  double top_frame_factor ;
  double bottom_frame_factor ;

  {
#line 413
  m_out = (ho_bitmap *)((void *)0);
#line 415
  horizontal_link_factor = 9.0 / 5.0;
#line 416
  top_frame_factor = 0.4;
#line 417
  bottom_frame_factor = 1.1;
#line 420
  if (! m->nikud) {
#line 422
    bottom_frame_factor = 1.0;
  }
  {
#line 428
  if ((int const   )font_spacing_code == -1) {
#line 428
    goto case_neg_1;
  }
#line 431
  if ((int const   )font_spacing_code == -2) {
#line 431
    goto case_neg_2;
  }
#line 434
  if ((int const   )font_spacing_code == -3) {
#line 434
    goto case_neg_3;
  }
#line 437
  if ((int const   )font_spacing_code == 1) {
#line 437
    goto case_1;
  }
#line 440
  if ((int const   )font_spacing_code == 2) {
#line 440
    goto case_2;
  }
#line 443
  if ((int const   )font_spacing_code == 3) {
#line 443
    goto case_3;
  }
#line 446
  goto switch_default;
  case_neg_1: /* CIL Label */ 
#line 429
  horizontal_link_factor = 6.0 / 5.0;
#line 430
  goto switch_break;
  case_neg_2: /* CIL Label */ 
#line 432
  horizontal_link_factor = 4.0 / 5.0;
#line 433
  goto switch_break;
  case_neg_3: /* CIL Label */ 
#line 435
  horizontal_link_factor = 2.0 / 5.0;
#line 436
  goto switch_break;
  case_1: /* CIL Label */ 
#line 438
  horizontal_link_factor = 11.0 / 5.0;
#line 439
  goto switch_break;
  case_2: /* CIL Label */ 
#line 441
  horizontal_link_factor = 16.0 / 5.0;
#line 442
  goto switch_break;
  case_3: /* CIL Label */ 
#line 444
  horizontal_link_factor = 22.0 / 5.0;
#line 445
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 447
  horizontal_link_factor = 8.0 / 5.0;
  switch_break: /* CIL Label */ ;
  }
  {
#line 450
  m_out = ho_segment_words_fine(m, m_line_map, (double const   )horizontal_link_factor,
                                (double const   )top_frame_factor, (double const   )bottom_frame_factor);
  }
#line 453
  return (m_out);
}
}
#line 456 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_segment.c"
ho_bitmap *ho_segment_fonts(ho_bitmap const   *m , ho_bitmap const   *m_line_map ,
                            unsigned char const   slicing_threshold , unsigned char const   slicing_width ,
                            unsigned char const   line_leeway ) 
{ 
  ho_bitmap *m_temp ;
  ho_bitmap *m_font ;
  ho_bitmap *m_font_temp ;
  ho_bitmap *m_out ;
  ho_objmap *o_obj ;
  int i ;
  int x ;
  int y ;
  int line_start ;
  int line_end ;
  int line_height ;
  int lee_way ;
  int s_threshold ;
  int s_width ;
  int *line_fill ;
  int avg_line_fill ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int font_start ;
  int font_end ;
  int tmp___4 ;
  int tmp___5 ;
  int i1 ;
  int i2 ;
  int this_object_end ;
  int next_object_start ;
  int thin_object_width ;
  int overlaping ;
  int x1 ;
  int x2 ;
  int font_start___0 ;
  int font_end___0 ;
  int tmp___6 ;
  int tmp___7 ;
  int min_x ;
  int min_x_start ;
  int width___0 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 477
  avg_line_fill = 0;
#line 480
  if (! m->width) {
#line 481
    return ((ho_bitmap *)((void *)0));
  } else
#line 480
  if (! m->height) {
#line 481
    return ((ho_bitmap *)((void *)0));
  }
#line 484
  if ((int const   )slicing_threshold < 1) {
#line 485
    s_threshold = 85;
  } else {
#line 487
    s_threshold = (int )slicing_threshold;
  }
#line 489
  if ((int const   )slicing_width < 1) {
#line 490
    s_width = 150;
  } else {
#line 492
    s_width = (int )slicing_width;
  }
#line 495
  x = (int )(m_line_map->width / 2);
#line 496
  y = 0;
  {
#line 496
  while (1) {
    while_continue: /* CIL Label */ ;
#line 496
    if (y < (int )m_line_map->height) {
#line 496
      if (((int )*(m_line_map->data + (x / 8 + y * (int )m_line_map->rowstride)) & (128 >> x % 8)) > 0) {
#line 496
        tmp = 1;
      } else {
#line 496
        tmp = 0;
      }
#line 496
      if (tmp) {
#line 496
        goto while_break;
      }
    } else {
#line 496
      goto while_break;
    }
#line 496
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 498
  line_start = y;
  {
#line 499
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 499
    if (y < (int )m_line_map->height) {
#line 499
      if (((int )*(m_line_map->data + (x / 8 + y * (int )m_line_map->rowstride)) & (128 >> x % 8)) > 0) {
#line 499
        tmp___0 = 1;
      } else {
#line 499
        tmp___0 = 0;
      }
#line 499
      if (! tmp___0) {
#line 499
        goto while_break___0;
      }
    } else {
#line 499
      goto while_break___0;
    }
#line 499
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 500
  line_end = y;
#line 502
  line_height = line_end - line_start;
#line 503
  lee_way = (int )(((int const   )line_leeway * (int const   )line_height) / 100);
#line 504
  if (line_start - lee_way < 0) {
#line 505
    lee_way = line_start;
  }
  {
#line 508
  tmp___1 = calloc((size_t )m->width, sizeof(int ));
#line 508
  line_fill = (int *)tmp___1;
  }
#line 509
  if (! line_fill) {
#line 510
    return ((ho_bitmap *)((void *)0));
  }
#line 512
  x = 0;
  {
#line 512
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 512
    if (! (x < (int )m->width)) {
#line 512
      goto while_break___1;
    }
#line 513
    y = line_start - lee_way;
    {
#line 513
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 513
      if (y < line_end + lee_way) {
#line 513
        if (! (y < (int )m->height)) {
#line 513
          goto while_break___2;
        }
      } else {
#line 513
        goto while_break___2;
      }
#line 516
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 516
        tmp___2 = 1;
      } else {
#line 516
        tmp___2 = 0;
      }
#line 516
      *(line_fill + x) += tmp___2;
#line 517
      if (((int )*(m->data + (x / 8 + y * (int )m->rowstride)) & (128 >> x % 8)) > 0) {
#line 517
        tmp___3 = 1;
      } else {
#line 517
        tmp___3 = 0;
      }
#line 517
      avg_line_fill += tmp___3;
#line 513
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 512
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 520
  avg_line_fill /= (int )m->width;
#line 523
  x = 0;
  {
#line 523
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 523
    if (! (x < (int )m->width)) {
#line 523
      goto while_break___3;
    }
#line 524
    *(line_fill + x) = (100 * *(line_fill + x)) / line_height;
#line 523
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 526
  m_out = ho_bitmap_new(m->width, m->height);
  }
#line 527
  if (! m_out) {
#line 528
    return ((ho_bitmap *)((void *)0));
  }
#line 531
  x = 0;
  {
#line 531
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 531
    if (! (x < (int )m->width)) {
#line 531
      goto while_break___4;
    }
#line 533
    if (*(line_fill + x) <= (int )(m->com_line_fill / 15)) {
      {
#line 534
      ho_bitmap_draw_vline(m_out, (int const   )x, (int const   )0, (int const   )m_out->height);
      }
    }
#line 531
    x ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 541
  m_temp = ho_bitmap_clone(m);
  }
#line 542
  if (! m_temp) {
#line 543
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 544
  ho_bitmap_and(m_temp, m_line_map);
#line 550
  x = 0;
  }
  {
#line 551
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 551
    if (! (x < (int )m->width)) {
#line 551
      goto while_break___5;
    }
    {
#line 554
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 554
      if (x < (int )m->width) {
#line 554
        if (((int )*(m_out->data + (x / 8 + m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 554
          tmp___4 = 1;
        } else {
#line 554
          tmp___4 = 0;
        }
#line 554
        if (! tmp___4) {
#line 554
          goto while_break___6;
        }
      } else {
#line 554
        goto while_break___6;
      }
#line 554
      x ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 555
    font_start = x;
    {
#line 556
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 556
      if (x < (int )m->width) {
#line 556
        if (((int )*(m_out->data + (x / 8 + m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 556
          tmp___5 = 1;
        } else {
#line 556
          tmp___5 = 0;
        }
#line 556
        if (tmp___5) {
#line 556
          goto while_break___7;
        }
      } else {
#line 556
        goto while_break___7;
      }
#line 556
      x ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 557
    font_end = x;
#line 561
    m_font = ho_bitmap_clone_window((ho_bitmap const   *)m_temp, (int const   )font_start,
                                    (int const   )0, (int const   )(font_end - font_start),
                                    m->height);
#line 565
    m_font_temp = ho_bitmap_filter_by_size((ho_bitmap const   *)m_font, (int )(m->font_height / 4),
                                           2 * (int )m->font_height, (int )(m->font_width / 5),
                                           3 * (int )m->font_width);
#line 568
    o_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_font_temp);
#line 569
    ho_bitmap_free(m_font_temp);
#line 571
    ho_objmap_sort_by_reading_index(o_obj, (unsigned char const   )255, (unsigned char const   )0);
    }
#line 574
    if ((o_obj->obj_list)->size > 1) {
#line 577
      i = 0;
      {
#line 577
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 577
        if (! (i < (o_obj->obj_list)->size - 1)) {
#line 577
          goto while_break___8;
        }
#line 586
        x1 = ((o_obj->obj_list)->objects + i)->x + ((o_obj->obj_list)->objects + i)->width / 2;
#line 588
        x2 = ((o_obj->obj_list)->objects + (i + 1))->x + ((o_obj->obj_list)->objects + (i + 1))->width / 2;
#line 592
        if (x2 < x1) {
#line 594
          i1 = i;
#line 595
          i2 = i + 1;
        } else {
#line 599
          i2 = i;
#line 600
          i1 = i + 1;
        }
#line 603
        thin_object_width = ((o_obj->obj_list)->objects + i1)->width;
#line 604
        if (thin_object_width > ((o_obj->obj_list)->objects + i2)->width) {
#line 605
          thin_object_width = ((o_obj->obj_list)->objects + i2)->width;
        }
#line 607
        this_object_end = ((o_obj->obj_list)->objects + i1)->x;
#line 608
        next_object_start = ((o_obj->obj_list)->objects + i2)->x + ((o_obj->obj_list)->objects + i2)->width;
#line 611
        overlaping = next_object_start - this_object_end;
#line 614
        if (overlaping >= 0) {
#line 614
          if (overlaping < thin_object_width / 2) {
            {
#line 617
            ho_bitmap_draw_vline(m_out, (int const   )(((o_obj->obj_list)->objects + i1)->x + font_start),
                                 (int const   )0, (int const   )m_out->height);
            }
          }
        }
#line 577
        i ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
    {
#line 623
    ho_objmap_free(o_obj);
#line 624
    ho_bitmap_free(m_font);
    }
  }
  while_break___5: /* CIL Label */ ;
  }
#line 634
  x = 0;
  {
#line 635
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 635
    if (! (x < (int )m->width)) {
#line 635
      goto while_break___9;
    }
    {
#line 638
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 638
      if (x < (int )m->width) {
#line 638
        if (((int )*(m_out->data + (x / 8 + 2 * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 638
          tmp___6 = 1;
        } else {
#line 638
          tmp___6 = 0;
        }
#line 638
        if (! tmp___6) {
#line 638
          goto while_break___10;
        }
      } else {
#line 638
        goto while_break___10;
      }
#line 638
      x ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 639
    font_start___0 = x;
    {
#line 640
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 640
      if (x < (int )m->width) {
#line 640
        if (((int )*(m_out->data + (x / 8 + 2 * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 640
          tmp___7 = 1;
        } else {
#line 640
          tmp___7 = 0;
        }
#line 640
        if (tmp___7) {
#line 640
          goto while_break___11;
        }
      } else {
#line 640
        goto while_break___11;
      }
#line 640
      x ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 641
    font_end___0 = x;
#line 644
    if (font_end___0 - font_start___0 > (s_width * (int )m->font_width) / 100) {
      {
#line 647
      m_font = ho_bitmap_clone_window((ho_bitmap const   *)m_temp, (int const   )font_start___0,
                                      (int const   )0, (int const   )(font_end___0 - font_start___0),
                                      m->height);
#line 650
      o_obj = ho_objmap_new_from_bitmap((ho_bitmap const   *)m_font);
#line 651
      ho_bitmap_free(m_font);
      }
#line 654
      if ((o_obj->obj_list)->size < 1) {
#line 654
        if (! (((o_obj->obj_list)->objects + 0)->height < (int )(m->font_height / 3))) {
#line 654
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 658
      if (font_end___0 - font_start___0 < ((2 * s_width) * (int )m->font_width) / 100) {
#line 660
        i = font_start___0 + 1;
        {
#line 660
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 660
          if (! (i < font_end___0)) {
#line 660
            goto while_break___12;
          }
#line 662
          if (*(line_fill + i) <= (s_threshold * avg_line_fill) / 100) {
            {
#line 664
            ho_bitmap_draw_vline(m_out, (int const   )i, (int const   )0, (int const   )m_out->height);
            }
          }
#line 660
          i ++;
        }
        while_break___12: /* CIL Label */ ;
        }
      } else {
#line 671
        i = font_start___0 + 1;
        {
#line 671
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 671
          if (! (i < font_end___0)) {
#line 671
            goto while_break___13;
          }
#line 673
          if (*(line_fill + i) <= (s_threshold * avg_line_fill) / 70) {
            {
#line 675
            ho_bitmap_draw_vline(m_out, (int const   )i, (int const   )0, (int const   )m_out->height);
            }
          }
#line 671
          i ++;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
      {
#line 681
      ho_objmap_free(o_obj);
      }
    }
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 686
  ho_bitmap_free(m_temp);
#line 689
  m_temp = ho_bitmap_new(m->width, m->height);
  }
#line 690
  if (! m_temp) {
#line 691
    return ((ho_bitmap *)((void *)0));
  }
#line 696
  width___0 = (int )m->width;
#line 698
  x = 1;
  {
#line 699
  while (1) {
    while_continue___14: /* CIL Label */ ;
#line 699
    if (! (x < width___0)) {
#line 699
      goto while_break___14;
    }
#line 702
    min_x = x - 1;
    {
#line 703
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 703
      if (x < width___0) {
#line 703
        if (((int )*(m_out->data + (x / 8 + 2 * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 703
          tmp___8 = 1;
        } else {
#line 703
          tmp___8 = 0;
        }
#line 703
        if (tmp___8) {
#line 703
          goto while_break___15;
        }
      } else {
#line 703
        goto while_break___15;
      }
#line 703
      x ++;
    }
    while_break___15: /* CIL Label */ ;
    }
#line 706
    if ((double )(x - min_x) < (double )m->font_width / 6.0) {
      {
#line 707
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 707
        if (! (min_x <= x)) {
#line 707
          goto while_break___16;
        }
        {
#line 708
        ho_bitmap_draw_vline(m_temp, (int const   )min_x, (int const   )0, (int const   )m_out->height);
#line 707
        min_x ++;
        }
      }
      while_break___16: /* CIL Label */ ;
      }
    }
    {
#line 711
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 711
      if (x < width___0) {
#line 711
        if (((int )*(m_out->data + (x / 8 + 2 * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 711
          tmp___9 = 1;
        } else {
#line 711
          tmp___9 = 0;
        }
#line 711
        if (tmp___9) {
#line 711
          goto while_break___17;
        }
      } else {
#line 711
        goto while_break___17;
      }
#line 711
      x ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 712
    min_x = x - 1;
#line 713
    min_x_start = min_x;
    {
#line 714
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 714
      if (x < width___0) {
#line 714
        if (((int )*(m_out->data + (x / 8 + 2 * m_out->rowstride)) & (128 >> x % 8)) > 0) {
#line 714
          tmp___10 = 1;
        } else {
#line 714
          tmp___10 = 0;
        }
#line 714
        if (! tmp___10) {
#line 714
          goto while_break___18;
        }
      } else {
#line 714
        goto while_break___18;
      }
#line 716
      if (*(line_fill + min_x) >= *(line_fill + x)) {
#line 717
        min_x = x;
      }
#line 718
      if (*(line_fill + min_x_start) > *(line_fill + x)) {
#line 719
        min_x_start = x;
      }
#line 714
      x ++;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 722
    i = min_x_start;
    {
#line 722
    while (1) {
      while_continue___19: /* CIL Label */ ;
#line 722
      if (i <= min_x) {
#line 722
        if (! (i < width___0 - 1)) {
#line 722
          goto while_break___19;
        }
      } else {
#line 722
        goto while_break___19;
      }
      {
#line 723
      ho_bitmap_draw_vline(m_temp, (int const   )i, (int const   )0, (int const   )m_out->height);
#line 722
      i ++;
      }
    }
    while_break___19: /* CIL Label */ ;
    }
  }
  while_break___14: /* CIL Label */ ;
  }
  {
#line 728
  m_temp->x = (int )m->x;
#line 729
  m_temp->y = (int )m->y;
#line 731
  ho_bitmap_free(m_out);
#line 732
  free((void *)line_fill);
  }
#line 734
  return (m_temp);
}
}
#line 61 "./ho_array.h"
ho_array *ho_array_new(int const   width , int const   height ) ;
#line 139
unsigned char ho_array_minmax(ho_array const   *pix , double *min , double *max ) ;
#line 52 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.h"
ho_array_hist *ho_array_hist_new(int const   size ) ;
#line 59
int ho_array_hist_free(ho_array_hist *hist ) ;
#line 67
unsigned char ho_array_hist_init(ho_array_hist *hist , ho_array const   *ar ) ;
#line 75
ho_array_hist *ho_array_hist_new_from_array(int const   size , ho_array const   *ar ) ;
#line 84
double ho_array_hist_get_at(ho_array_hist const   *hist , int i ) ;
#line 92
ho_array *ho_array_hist_to_array(ho_array_hist const   *hist ) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.c"
ho_array_hist *ho_array_hist_new(int const   size ) 
{ 
  int x ;
  ho_array_hist *hist ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 54
  hist = (ho_array_hist *)((void *)0);
#line 59
  tmp = malloc(sizeof(ho_array ));
#line 59
  hist = (ho_array_hist *)tmp;
  }
#line 60
  if (! hist) {
#line 62
    return ((ho_array_hist *)((void *)0));
  }
  {
#line 68
  hist->size = (int )size;
#line 73
  tmp___0 = malloc((unsigned long )hist->size * sizeof(double ));
#line 73
  hist->data = (double *)tmp___0;
  }
#line 74
  if (! hist->data) {
    {
#line 76
    free((void *)hist);
    }
#line 77
    return ((ho_array_hist *)((void *)0));
  }
#line 81
  x = 0;
  {
#line 81
  while (1) {
    while_continue: /* CIL Label */ ;
#line 81
    if (! (x < hist->size)) {
#line 81
      goto while_break;
    }
#line 83
    *(hist->data + x) = 0.0;
#line 81
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 86
  return (hist);
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.c"
int ho_array_hist_free(ho_array_hist *hist ) 
{ 


  {
#line 97
  if (! hist) {
#line 98
    return (-1);
  }
#line 100
  if (hist->data) {
    {
#line 101
    free((void *)hist->data);
    }
  }
  {
#line 103
  free((void *)hist);
  }
#line 105
  return (0);
}
}
#line 114 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.c"
unsigned char ho_array_hist_init(ho_array_hist *hist , ho_array const   *ar ) 
{ 
  int i ;
  int x ;
  int y ;
  double min ;
  double max ;
  double range ;

  {
  {
#line 122
  ho_array_minmax(ar, & min, & max);
#line 123
  range = max - min;
#line 126
  x = 0;
  }
  {
#line 126
  while (1) {
    while_continue: /* CIL Label */ ;
#line 126
    if (! (x < (int )ar->width)) {
#line 126
      goto while_break;
    }
#line 127
    y = 0;
    {
#line 127
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 127
      if (! (y < (int )ar->height)) {
#line 127
        goto while_break___0;
      }
#line 129
      i = (int )(((double )(hist->size - 1) * (*(ar->data + (x + y * (int )ar->width)) - min)) / range);
#line 132
      *(hist->data + i) += (double )1;
#line 127
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 126
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  i = 0;
  {
#line 136
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 136
    if (! (i < hist->size)) {
#line 136
      goto while_break___1;
    }
#line 137
    *(hist->data + i) /= (double )(ar->width * ar->height);
#line 136
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 139
  return ((unsigned char)0);
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.c"
ho_array_hist *ho_array_hist_new_from_array(int const   size , ho_array const   *ar ) 
{ 
  ho_array_hist *hist ;

  {
  {
#line 151
  hist = (ho_array_hist *)((void *)0);
#line 153
  hist = ho_array_hist_new(size);
  }
#line 155
  if (! hist) {
#line 156
    return ((ho_array_hist *)((void *)0));
  }
  {
#line 158
  ho_array_hist_init(hist, ar);
  }
#line 160
  return (hist);
}
}
#line 169 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.c"
double ho_array_hist_get_at(ho_array_hist const   *hist , int i ) 
{ 


  {
#line 172
  return (*(hist->data + i));
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_hist.c"
ho_array *ho_array_hist_to_array(ho_array_hist const   *hist ) 
{ 
  int x ;
  int y ;
  ho_array *m_out ;

  {
  {
#line 185
  m_out = (ho_array *)((void *)0);
#line 188
  m_out = ho_array_new(hist->size, hist->size);
  }
#line 189
  if (! m_out) {
#line 190
    return ((ho_array *)((void *)0));
  }
#line 193
  x = 0;
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! (x < (int )hist->size)) {
#line 193
      goto while_break;
    }
#line 195
    y = (int )((double )hist->size * *(hist->data + x));
#line 196
    *(m_out->data + (x + y * m_out->width)) = 1.0;
#line 193
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  return (m_out);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.h"
double ho_recognize_font_4_zero(double const   *array_in ) ;
#line 36
double ho_recognize_font_4_one(double const   *array_in ) ;
#line 38
double ho_recognize_font_4_two(double const   *array_in ) ;
#line 40
double ho_recognize_font_4_three(double const   *array_in ) ;
#line 42
double ho_recognize_font_4_four(double const   *array_in ) ;
#line 44
double ho_recognize_font_4_five(double const   *array_in ) ;
#line 46
double ho_recognize_font_4_six(double const   *array_in ) ;
#line 48
double ho_recognize_font_4_seven(double const   *array_in ) ;
#line 50
double ho_recognize_font_4_eight(double const   *array_in ) ;
#line 52
double ho_recognize_font_4_nine(double const   *array_in ) ;
#line 54
double ho_recognize_font_4_dot(double const   *array_in ) ;
#line 56
double ho_recognize_font_4_comma(double const   *array_in ) ;
#line 58
double ho_recognize_font_4_open(double const   *array_in ) ;
#line 60
double ho_recognize_font_4_close(double const   *array_in ) ;
#line 62
double ho_recognize_font_4_minus(double const   *array_in ) ;
#line 64
double ho_recognize_font_4_plus(double const   *array_in ) ;
#line 66
double ho_recognize_font_4_div(double const   *array_in ) ;
#line 68
double ho_recognize_font_4_tag(double const   *array_in ) ;
#line 70
double ho_recognize_font_4_two_tags(double const   *array_in ) ;
#line 72
double ho_recognize_font_4_question(double const   *array_in ) ;
#line 74
double ho_recognize_font_4_exclem(double const   *array_in ) ;
#line 76
double ho_recognize_font_4_dot_dot(double const   *array_in ) ;
#line 78
double ho_recognize_font_4_dot_comma(double const   *array_in ) ;
#line 80
double ho_recognize_font_4_alef(double const   *array_in ) ;
#line 82
double ho_recognize_font_4_bet(double const   *array_in ) ;
#line 84
double ho_recognize_font_4_gimal(double const   *array_in ) ;
#line 86
double ho_recognize_font_4_dalet(double const   *array_in ) ;
#line 88
double ho_recognize_font_4_hey(double const   *array_in ) ;
#line 90
double ho_recognize_font_4_vav(double const   *array_in ) ;
#line 92
double ho_recognize_font_4_zayin(double const   *array_in ) ;
#line 94
double ho_recognize_font_4_het(double const   *array_in ) ;
#line 96
double ho_recognize_font_4_tet(double const   *array_in ) ;
#line 98
double ho_recognize_font_4_yud(double const   *array_in ) ;
#line 100
double ho_recognize_font_4_caf(double const   *array_in ) ;
#line 102
double ho_recognize_font_4_caf_sofit(double const   *array_in ) ;
#line 104
double ho_recognize_font_4_lamed(double const   *array_in ) ;
#line 106
double ho_recognize_font_4_mem(double const   *array_in ) ;
#line 108
double ho_recognize_font_4_mem_sofit(double const   *array_in ) ;
#line 110
double ho_recognize_font_4_nun(double const   *array_in ) ;
#line 112
double ho_recognize_font_4_nun_sofit(double const   *array_in ) ;
#line 114
double ho_recognize_font_4_samech(double const   *array_in ) ;
#line 116
double ho_recognize_font_4_ayin(double const   *array_in ) ;
#line 118
double ho_recognize_font_4_pey(double const   *array_in ) ;
#line 120
double ho_recognize_font_4_pey_sofit(double const   *array_in ) ;
#line 122
double ho_recognize_font_4_tzadi(double const   *array_in ) ;
#line 124
double ho_recognize_font_4_tzadi_sofit(double const   *array_in ) ;
#line 126
double ho_recognize_font_4_kuf(double const   *array_in ) ;
#line 128
double ho_recognize_font_4_resh(double const   *array_in ) ;
#line 130
double ho_recognize_font_4_shin(double const   *array_in ) ;
#line 132
double ho_recognize_font_4_tav(double const   *array_in ) ;
#line 53 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_zero(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 56
  return_value = 0.0;
#line 58
  return (return_value);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_one(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 64
  return_value = 0.0;
#line 66
  return (return_value);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_two(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 72
  return_value = 0.0;
#line 74
  return (return_value);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_three(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 80
  return_value = 0.0;
#line 82
  return (return_value);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_four(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 88
  return_value = 0.0;
#line 90
  return (return_value);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_five(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 96
  return_value = 0.0;
#line 98
  return (return_value);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_six(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 104
  return_value = 0.0;
#line 106
  return (return_value);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_seven(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 112
  return_value = 0.0;
#line 114
  return (return_value);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_eight(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 120
  return_value = 0.0;
#line 122
  return (return_value);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_nine(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 128
  return_value = 0.0;
#line 130
  return (return_value);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 136
  return_value = 0.0;
#line 138
  return (return_value);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 144
  return_value = 0.0;
#line 146
  return (return_value);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_minus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 152
  return_value = 0.0;
#line 154
  return (return_value);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_plus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 160
  return_value = 0.0;
#line 162
  return (return_value);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_div(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 168
  return_value = 0.0;
#line 170
  return (return_value);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_open(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 176
  return_value = 0.0;
#line 178
  return (return_value);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_close(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 184
  return_value = 0.0;
#line 186
  return (return_value);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_tag(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 192
  return_value = 0.0;
#line 194
  return (return_value);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_two_tags(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 200
  return_value = 0.0;
#line 202
  return (return_value);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_question(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 208
  return_value = 0.0;
#line 210
  return (return_value);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_exclem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 216
  return_value = 0.0;
#line 218
  return (return_value);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_dot_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 224
  return_value = 0.0;
#line 226
  return (return_value);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_dot_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 232
  return_value = 0.0;
#line 234
  return (return_value);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_alef(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 240
  return_value = 0.0;
#line 242
  return (return_value);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_bet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 248
  return_value = 0.0;
#line 250
  return (return_value);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_gimal(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 256
  return_value = 0.0;
#line 258
  return (return_value);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_dalet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 264
  return_value = 0.0;
#line 266
  return (return_value);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_hey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 272
  return_value = 0.0;
#line 274
  return (return_value);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_vav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 280
  return_value = 0.0;
#line 282
  return (return_value);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_zayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 288
  return_value = 0.0;
#line 290
  return (return_value);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_het(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 296
  return_value = 0.0;
#line 298
  return (return_value);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_tet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 304
  return_value = 0.0;
#line 306
  return (return_value);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_yud(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 312
  return_value = 0.0;
#line 314
  return (return_value);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_caf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 320
  return_value = 0.0;
#line 322
  return (return_value);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_caf_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 328
  return_value = 0.0;
#line 330
  return (return_value);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_lamed(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 336
  return_value = 0.0;
#line 338
  return (return_value);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_mem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 344
  return_value = 0.0;
#line 346
  return (return_value);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_mem_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 352
  return_value = 0.0;
#line 354
  return (return_value);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_nun(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 360
  return_value = 0.0;
#line 362
  return (return_value);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_nun_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 368
  return_value = 0.0;
#line 370
  return (return_value);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_samech(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 376
  return_value = 0.0;
#line 378
  return (return_value);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_ayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 384
  return_value = 0.0;
#line 386
  return (return_value);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_pey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 392
  return_value = 0.0;
#line 394
  return (return_value);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_pey_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 400
  return_value = 0.0;
#line 402
  return (return_value);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_tzadi(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 408
  return_value = 0.0;
#line 410
  return (return_value);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_tzadi_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 416
  return_value = 0.0;
#line 418
  return (return_value);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_kuf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 424
  return_value = 0.0;
#line 426
  return (return_value);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_resh(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 432
  return_value = 0.0;
#line 434
  return (return_value);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_shin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 440
  return_value = 0.0;
#line 442
  return (return_value);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_4.c"
double ho_recognize_font_4_tav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 448
  return_value = 0.0;
#line 450
  return (return_value);
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_linguistics.h"
int ho_linguistics_adjust_array_out(double *array_out , unsigned char word_end , unsigned char word_start ,
                                    int last_char_i ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.h"
double ho_recognize_font_2_zero(double const   *array_in ) ;
#line 36
double ho_recognize_font_2_one(double const   *array_in ) ;
#line 38
double ho_recognize_font_2_two(double const   *array_in ) ;
#line 40
double ho_recognize_font_2_three(double const   *array_in ) ;
#line 42
double ho_recognize_font_2_four(double const   *array_in ) ;
#line 44
double ho_recognize_font_2_five(double const   *array_in ) ;
#line 46
double ho_recognize_font_2_six(double const   *array_in ) ;
#line 48
double ho_recognize_font_2_seven(double const   *array_in ) ;
#line 50
double ho_recognize_font_2_eight(double const   *array_in ) ;
#line 52
double ho_recognize_font_2_nine(double const   *array_in ) ;
#line 54
double ho_recognize_font_2_dot(double const   *array_in ) ;
#line 56
double ho_recognize_font_2_comma(double const   *array_in ) ;
#line 58
double ho_recognize_font_2_open(double const   *array_in ) ;
#line 60
double ho_recognize_font_2_close(double const   *array_in ) ;
#line 62
double ho_recognize_font_2_minus(double const   *array_in ) ;
#line 64
double ho_recognize_font_2_plus(double const   *array_in ) ;
#line 66
double ho_recognize_font_2_div(double const   *array_in ) ;
#line 68
double ho_recognize_font_2_tag(double const   *array_in ) ;
#line 70
double ho_recognize_font_2_two_tags(double const   *array_in ) ;
#line 72
double ho_recognize_font_2_question(double const   *array_in ) ;
#line 74
double ho_recognize_font_2_exclem(double const   *array_in ) ;
#line 76
double ho_recognize_font_2_dot_dot(double const   *array_in ) ;
#line 78
double ho_recognize_font_2_dot_comma(double const   *array_in ) ;
#line 80
double ho_recognize_font_2_alef(double const   *array_in ) ;
#line 82
double ho_recognize_font_2_bet(double const   *array_in ) ;
#line 84
double ho_recognize_font_2_gimal(double const   *array_in ) ;
#line 86
double ho_recognize_font_2_dalet(double const   *array_in ) ;
#line 88
double ho_recognize_font_2_hey(double const   *array_in ) ;
#line 90
double ho_recognize_font_2_vav(double const   *array_in ) ;
#line 92
double ho_recognize_font_2_zayin(double const   *array_in ) ;
#line 94
double ho_recognize_font_2_het(double const   *array_in ) ;
#line 96
double ho_recognize_font_2_tet(double const   *array_in ) ;
#line 98
double ho_recognize_font_2_yud(double const   *array_in ) ;
#line 100
double ho_recognize_font_2_caf(double const   *array_in ) ;
#line 102
double ho_recognize_font_2_caf_sofit(double const   *array_in ) ;
#line 104
double ho_recognize_font_2_lamed(double const   *array_in ) ;
#line 106
double ho_recognize_font_2_mem(double const   *array_in ) ;
#line 108
double ho_recognize_font_2_mem_sofit(double const   *array_in ) ;
#line 110
double ho_recognize_font_2_nun(double const   *array_in ) ;
#line 112
double ho_recognize_font_2_nun_sofit(double const   *array_in ) ;
#line 114
double ho_recognize_font_2_samech(double const   *array_in ) ;
#line 116
double ho_recognize_font_2_ayin(double const   *array_in ) ;
#line 118
double ho_recognize_font_2_pey(double const   *array_in ) ;
#line 120
double ho_recognize_font_2_pey_sofit(double const   *array_in ) ;
#line 122
double ho_recognize_font_2_tzadi(double const   *array_in ) ;
#line 124
double ho_recognize_font_2_tzadi_sofit(double const   *array_in ) ;
#line 126
double ho_recognize_font_2_kuf(double const   *array_in ) ;
#line 128
double ho_recognize_font_2_resh(double const   *array_in ) ;
#line 130
double ho_recognize_font_2_shin(double const   *array_in ) ;
#line 132
double ho_recognize_font_2_tav(double const   *array_in ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.h"
double ho_recognize_font_6_zero(double const   *array_in ) ;
#line 36
double ho_recognize_font_6_one(double const   *array_in ) ;
#line 38
double ho_recognize_font_6_two(double const   *array_in ) ;
#line 40
double ho_recognize_font_6_three(double const   *array_in ) ;
#line 42
double ho_recognize_font_6_four(double const   *array_in ) ;
#line 44
double ho_recognize_font_6_five(double const   *array_in ) ;
#line 46
double ho_recognize_font_6_six(double const   *array_in ) ;
#line 48
double ho_recognize_font_6_seven(double const   *array_in ) ;
#line 50
double ho_recognize_font_6_eight(double const   *array_in ) ;
#line 52
double ho_recognize_font_6_nine(double const   *array_in ) ;
#line 54
double ho_recognize_font_6_dot(double const   *array_in ) ;
#line 56
double ho_recognize_font_6_comma(double const   *array_in ) ;
#line 58
double ho_recognize_font_6_open(double const   *array_in ) ;
#line 60
double ho_recognize_font_6_close(double const   *array_in ) ;
#line 62
double ho_recognize_font_6_minus(double const   *array_in ) ;
#line 64
double ho_recognize_font_6_plus(double const   *array_in ) ;
#line 66
double ho_recognize_font_6_div(double const   *array_in ) ;
#line 68
double ho_recognize_font_6_tag(double const   *array_in ) ;
#line 70
double ho_recognize_font_6_two_tags(double const   *array_in ) ;
#line 72
double ho_recognize_font_6_question(double const   *array_in ) ;
#line 74
double ho_recognize_font_6_exclem(double const   *array_in ) ;
#line 76
double ho_recognize_font_6_dot_dot(double const   *array_in ) ;
#line 78
double ho_recognize_font_6_dot_comma(double const   *array_in ) ;
#line 80
double ho_recognize_font_6_alef(double const   *array_in ) ;
#line 82
double ho_recognize_font_6_bet(double const   *array_in ) ;
#line 84
double ho_recognize_font_6_gimal(double const   *array_in ) ;
#line 86
double ho_recognize_font_6_dalet(double const   *array_in ) ;
#line 88
double ho_recognize_font_6_hey(double const   *array_in ) ;
#line 90
double ho_recognize_font_6_vav(double const   *array_in ) ;
#line 92
double ho_recognize_font_6_zayin(double const   *array_in ) ;
#line 94
double ho_recognize_font_6_het(double const   *array_in ) ;
#line 96
double ho_recognize_font_6_tet(double const   *array_in ) ;
#line 98
double ho_recognize_font_6_yud(double const   *array_in ) ;
#line 100
double ho_recognize_font_6_caf(double const   *array_in ) ;
#line 102
double ho_recognize_font_6_caf_sofit(double const   *array_in ) ;
#line 104
double ho_recognize_font_6_lamed(double const   *array_in ) ;
#line 106
double ho_recognize_font_6_mem(double const   *array_in ) ;
#line 108
double ho_recognize_font_6_mem_sofit(double const   *array_in ) ;
#line 110
double ho_recognize_font_6_nun(double const   *array_in ) ;
#line 112
double ho_recognize_font_6_nun_sofit(double const   *array_in ) ;
#line 114
double ho_recognize_font_6_samech(double const   *array_in ) ;
#line 116
double ho_recognize_font_6_ayin(double const   *array_in ) ;
#line 118
double ho_recognize_font_6_pey(double const   *array_in ) ;
#line 120
double ho_recognize_font_6_pey_sofit(double const   *array_in ) ;
#line 122
double ho_recognize_font_6_tzadi(double const   *array_in ) ;
#line 124
double ho_recognize_font_6_tzadi_sofit(double const   *array_in ) ;
#line 126
double ho_recognize_font_6_kuf(double const   *array_in ) ;
#line 128
double ho_recognize_font_6_resh(double const   *array_in ) ;
#line 130
double ho_recognize_font_6_shin(double const   *array_in ) ;
#line 132
double ho_recognize_font_6_tav(double const   *array_in ) ;
#line 41 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.h"
static char const   *ho_sign_array[51]  = 
#line 41 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.h"
  {      "*",      "\327\220",      "\327\221",      "\327\222", 
        "\327\223",      "\327\224",      "\327\225",      "\327\226", 
        "\327\227",      "\327\230",      "\327\231",      "\327\233", 
        "\327\232",      "\327\234",      "\327\236",      "\327\235", 
        "\327\240",      "\327\237",      "\327\241",      "\327\242", 
        "\327\244",      "\327\243",      "\327\246",      "\327\245", 
        "\327\247",      "\327\250",      "\327\251",      "\327\252", 
        ".",      ",",      "\'",      "\"", 
        "?",      "!",      ":",      ";", 
        ")",      "(",      "-",      "+", 
        "/",      "0",      "1",      "2", 
        "3",      "4",      "5",      "6", 
        "7",      "8",      "9"};
#line 49
int ho_recognize_array_in_size(void) ;
#line 51
int ho_recognize_array_out_size(void) ;
#line 195
int ho_recognize_create_array_in(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                 double *array_in ) ;
#line 199
int ho_recognize_create_array_out(double const   *array_in , double *array_out , int font_code ) ;
#line 202
char const   *ho_recognize_array_out_to_font(double const   *array_out , int *this_char_i ) ;
#line 210
int ho_recognize_dimentions(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                            double *height , double *width , double *top , double *bottom ,
                            double *top_left , double *top_mid , double *top_right ,
                            double *mid_left , double *mid_right , double *bottom_left ,
                            double *bottom_mid , double *bottom_right , double *has_two_hlines_up ,
                            double *has_two_hlines_down , double *has_three_hlines_up ,
                            double *has_three_hlines_down ) ;
#line 221
int ho_recognize_bars(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_top_bar ,
                      double *has_mid_hbar , double *has_bottom_bar , double *has_left_bar ,
                      double *has_mid_vbar , double *has_right_bar , double *has_diagonal_bar ,
                      double *has_diagonal_left_bar ) ;
#line 228
int ho_recognize_edges(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_top_left_edge ,
                       double *has_mid_left_edge , double *has_bottom_left_edge ,
                       double *has_top_right_edge , double *has_mid_right_edge , double *has_bottom_right_edge ,
                       double *has_left_top_edge , double *has_mid_top_edge , double *has_right_top_edge ,
                       double *has_left_bottom_edge , double *has_mid_bottom_edge ,
                       double *has_right_bottom_edge ) ;
#line 243
int ho_recognize_edges_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                           double *has_top_left_edge , double *has_mid_left_edge ,
                           double *has_bottom_left_edge , double *has_top_right_edge ,
                           double *has_mid_right_edge , double *has_bottom_right_edge ,
                           double *has_left_top_edge , double *has_mid_top_edge ,
                           double *has_right_top_edge , double *has_left_bottom_edge ,
                           double *has_mid_bottom_edge , double *has_right_bottom_edge ) ;
#line 258
int ho_recognize_notches(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_top_left_notch ,
                         double *has_mid_left_notch , double *has_bottom_left_notch ,
                         double *has_top_right_notch , double *has_mid_right_notch ,
                         double *has_bottom_right_notch , double *has_left_top_notch ,
                         double *has_mid_top_notch , double *has_right_top_notch ,
                         double *has_left_bottom_notch , double *has_mid_bottom_notch ,
                         double *has_right_bottom_notch ) ;
#line 273
int ho_recognize_parts(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_one_hole ,
                       double *has_two_holes , double *has_hey_part , double *has_dot_part ,
                       double *has_comma_part ) ;
#line 279
int ho_recognize_ends(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_top_left_end ,
                      double *has_top_mid_end , double *has_top_right_end , double *has_mid_left_end ,
                      double *has_mid_mid_end , double *has_mid_right_end , double *has_bottom_left_end ,
                      double *has_bottom_mid_end , double *has_bottom_right_end ,
                      double *has_top_left_cross , double *has_top_mid_cross , double *has_top_right_cross ,
                      double *has_mid_left_cross , double *has_mid_mid_cross , double *has_mid_right_cross ,
                      double *has_bottom_left_cross , double *has_bottom_mid_cross ,
                      double *has_bottom_right_cross ) ;
#line 300
int ho_recognize_holes_dimentions(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                  double *height , double *width , double *top , double *bottom ,
                                  double *top_left , double *top_right , double *bottom_left ,
                                  double *bottom_right ) ;
#line 307
int ho_recognize_holes_edges(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                             double *has_top_left_edge , double *has_mid_left_edge ,
                             double *has_bottom_left_edge , double *has_top_right_edge ,
                             double *has_mid_right_edge , double *has_bottom_right_edge ,
                             double *has_left_top_edge , double *has_mid_top_edge ,
                             double *has_right_top_edge , double *has_left_bottom_edge ,
                             double *has_mid_bottom_edge , double *has_right_bottom_edge ) ;
#line 55 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_array_in_size(void) 
{ 


  {
#line 58
  return (104);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_array_out_size(void) 
{ 


  {
#line 64
  return (51);
}
}
#line 67 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_dimentions(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                            double *height , double *width , double *top , double *bottom ,
                            double *top_left , double *top_mid , double *top_right ,
                            double *mid_left , double *mid_right , double *bottom_left ,
                            double *bottom_mid , double *bottom_right , double *has_two_hlines_up ,
                            double *has_two_hlines_down , double *has_three_hlines_up ,
                            double *has_three_hlines_down ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int line_start ;
  int line_end ;
  int line_height ;
  ho_bitmap *m_clean ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  double tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
#line 93
  m_clean = (ho_bitmap *)((void *)0);
#line 96
  x = (int )(m_mask->width / 2);
#line 97
  y = 0;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (y < (int )m_mask->height) {
#line 97
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 97
        tmp = 1;
      } else {
#line 97
        tmp = 0;
      }
#line 97
      if (tmp) {
#line 97
        goto while_break;
      }
    } else {
#line 97
      goto while_break;
    }
#line 97
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  line_start = y - 1;
  {
#line 99
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 99
    if (y < (int )m_mask->height) {
#line 99
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 99
        tmp___0 = 1;
      } else {
#line 99
        tmp___0 = 0;
      }
#line 99
      if (! tmp___0) {
#line 99
        goto while_break___0;
      }
    } else {
#line 99
      goto while_break___0;
    }
#line 99
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 100
  line_end = y;
#line 101
  line_height = line_end - line_start;
#line 104
  sum = 0;
#line 105
  y = 0;
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 105
    if (y < (int )m_mask->height) {
#line 105
      if (! (sum == 0)) {
#line 105
        goto while_break___1;
      }
    } else {
#line 105
      goto while_break___1;
    }
#line 106
    sum = 0;
#line 106
    x = 0;
    {
#line 106
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 106
      if (! (x < (int )m_text->width)) {
#line 106
        goto while_break___2;
      }
#line 107
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 107
        tmp___1 = 1;
      } else {
#line 107
        tmp___1 = 0;
      }
#line 107
      sum += tmp___1;
#line 106
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 105
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 108
  font_start = y - 1;
#line 109
  sum = 0;
#line 110
  y = (int )(m_mask->height - 4);
  {
#line 110
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 110
    if (y > font_start) {
#line 110
      if (! (sum == 0)) {
#line 110
        goto while_break___3;
      }
    } else {
#line 110
      goto while_break___3;
    }
#line 111
    sum = 0;
#line 111
    x = 0;
    {
#line 111
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 111
      if (! (x < (int )m_text->width)) {
#line 111
        goto while_break___4;
      }
#line 112
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 112
        tmp___2 = 1;
      } else {
#line 112
        tmp___2 = 0;
      }
#line 112
      sum += tmp___2;
#line 111
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 110
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 113
  font_end = y + 1;
#line 114
  font_height = font_end - font_start;
#line 116
  if (! font_height) {
#line 117
    return (-1);
  } else
#line 116
  if (! line_height) {
#line 117
    return (-1);
  }
#line 119
  *height = (double )font_height / (double )line_height;
#line 120
  *width = (double )m_text->width / (double )line_height;
#line 122
  *top = (double )(line_start - font_start) / (double )line_height;
#line 123
  *bottom = (double )(line_end - font_end) / (double )line_height;
#line 126
  if (*top < 0.025) {
#line 126
    if (*top > - 0.025) {
#line 129
      if (*height < 1.025) {
#line 129
        if (*height > 0.975) {
#line 131
          tmp___3 = 0.0;
#line 131
          *bottom = tmp___3;
#line 131
          *top = tmp___3;
        } else {
#line 136
          *bottom -= *top;
#line 137
          *top = 0.0;
        }
      } else {
#line 136
        *bottom -= *top;
#line 137
        *top = 0.0;
      }
    } else {
#line 126
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 140
  if (*bottom < 0.025) {
#line 140
    if (*bottom > - 0.025) {
#line 142
      *top -= *bottom;
#line 143
      *bottom = 0.0;
    }
  }
#line 147
  *height /= 2.0;
#line 148
  if (*height > 1.0) {
#line 149
    *height = 1.0;
  }
#line 151
  *width /= 2.0;
#line 152
  if (*width > 1.0) {
#line 153
    *width = 1.0;
  }
#line 155
  *top = (*top + 1.0) / 2.0;
#line 156
  if (*top > 1.0) {
#line 157
    *top = 1.0;
  }
#line 158
  if (*top < 0.0) {
#line 159
    *top = 0.0;
  }
#line 161
  *bottom = (*bottom + 1.0) / 2.0;
#line 162
  if (*bottom > 1.0) {
#line 163
    *bottom = 1.0;
  }
#line 164
  if (*bottom < 0.0) {
#line 165
    *bottom = 0.0;
  }
#line 168
  y = font_start;
#line 168
  x = 0;
  {
#line 168
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 168
    if (x < (int )(m_mask->width / 2)) {
#line 168
      if (y < font_start + font_height / 2) {
#line 168
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 168
          tmp___4 = 1;
        } else {
#line 168
          tmp___4 = 0;
        }
#line 168
        if (tmp___4) {
#line 168
          goto while_break___5;
        }
      } else {
#line 168
        goto while_break___5;
      }
    } else {
#line 168
      goto while_break___5;
    }
#line 168
    x ++;
#line 168
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 171
  *top_left = (double )x / (double )(m_mask->width / 2);
#line 173
  if (*top_left > 1.0) {
#line 174
    *top_left = 1.0;
  }
#line 176
  y = font_end;
#line 176
  x = 0;
  {
#line 176
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 176
    if (x < (int )(m_mask->width / 2)) {
#line 176
      if (y > font_start + font_height / 2) {
#line 176
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 176
          tmp___5 = 1;
        } else {
#line 176
          tmp___5 = 0;
        }
#line 176
        if (tmp___5) {
#line 176
          goto while_break___6;
        }
      } else {
#line 176
        goto while_break___6;
      }
    } else {
#line 176
      goto while_break___6;
    }
#line 176
    x ++;
#line 176
    y --;
  }
  while_break___6: /* CIL Label */ ;
  }
#line 179
  *bottom_left = (double )x / (double )(m_mask->width / 2);
#line 181
  if (*bottom_left > 1.0) {
#line 182
    *bottom_left = 1.0;
  }
#line 184
  y = font_start;
#line 184
  x = (int )(m_text->width - 1);
  {
#line 184
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 184
    if (x > (int )(m_mask->width / 2)) {
#line 184
      if (y < font_start + font_height / 2) {
#line 184
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 184
          tmp___6 = 1;
        } else {
#line 184
          tmp___6 = 0;
        }
#line 184
        if (tmp___6) {
#line 184
          goto while_break___7;
        }
      } else {
#line 184
        goto while_break___7;
      }
    } else {
#line 184
      goto while_break___7;
    }
#line 184
    x --;
#line 184
    y ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 187
  *top_right = (double )(m_mask->width - (int const   )x) / (double )(m_mask->width / 2);
#line 189
  if (*top_right > 1.0) {
#line 190
    *top_right = 1.0;
  }
#line 192
  y = font_end;
#line 192
  x = (int )(m_text->width - 1);
  {
#line 192
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 192
    if (x > (int )(m_mask->width / 2)) {
#line 192
      if (y > font_start + font_height / 2) {
#line 192
        if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 192
          tmp___7 = 1;
        } else {
#line 192
          tmp___7 = 0;
        }
#line 192
        if (tmp___7) {
#line 192
          goto while_break___8;
        }
      } else {
#line 192
        goto while_break___8;
      }
    } else {
#line 192
      goto while_break___8;
    }
#line 192
    x --;
#line 192
    y --;
  }
  while_break___8: /* CIL Label */ ;
  }
#line 195
  *bottom_right = (double )(m_mask->width - (int const   )x) / (double )(m_mask->width / 2);
#line 197
  if (*bottom_right > 1.0) {
#line 198
    *bottom_right = 1.0;
  }
#line 200
  y = font_start;
#line 200
  x = (int )(m_text->width / 2);
  {
#line 200
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 200
    if (y < font_start + font_height / 2) {
#line 200
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 200
        tmp___8 = 1;
      } else {
#line 200
        tmp___8 = 0;
      }
#line 200
      if (tmp___8) {
#line 200
        goto while_break___9;
      }
    } else {
#line 200
      goto while_break___9;
    }
#line 200
    y ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 202
  *top_mid = (double )(y - font_start) / (double )(font_height / 2);
#line 204
  if (*top_mid > 1.0) {
#line 205
    *top_mid = 1.0;
  }
#line 207
  y = font_end;
#line 207
  x = (int )(m_text->width / 2);
  {
#line 207
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 207
    if (y > font_start + font_height / 2) {
#line 207
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 207
        tmp___9 = 1;
      } else {
#line 207
        tmp___9 = 0;
      }
#line 207
      if (tmp___9) {
#line 207
        goto while_break___10;
      }
    } else {
#line 207
      goto while_break___10;
    }
#line 207
    y --;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 209
  *bottom_mid = (double )(font_end - y) / (double )(font_height / 2);
#line 211
  if (*bottom_mid > 1.0) {
#line 212
    *bottom_mid = 1.0;
  }
#line 214
  y = font_start + font_height / 2;
#line 214
  x = 0;
  {
#line 214
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 214
    if (x < (int )(m_text->width / 2)) {
#line 214
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 214
        tmp___10 = 1;
      } else {
#line 214
        tmp___10 = 0;
      }
#line 214
      if (tmp___10) {
#line 214
        goto while_break___11;
      }
    } else {
#line 214
      goto while_break___11;
    }
#line 214
    x ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 216
  *mid_left = (double )x / (double )(m_text->width / 2);
#line 218
  if (*mid_left > 1.0) {
#line 219
    *mid_left = 1.0;
  }
#line 221
  y = font_start + font_height / 2;
#line 221
  x = (int )(m_text->width - 1);
  {
#line 221
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 221
    if (x > (int )(m_text->width / 2)) {
#line 221
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 221
        tmp___11 = 1;
      } else {
#line 221
        tmp___11 = 0;
      }
#line 221
      if (tmp___11) {
#line 221
        goto while_break___12;
      }
    } else {
#line 221
      goto while_break___12;
    }
#line 221
    x --;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 223
  *mid_right = (double )(m_text->width - (int const   )x) / (double )(m_text->width / 2);
#line 225
  if (*mid_right > 1.0) {
#line 226
    *mid_right = 1.0;
  }
  {
#line 228
  m_clean = ho_bitmap_dilation_n(m_text, (unsigned char const   )6);
#line 230
  *has_two_hlines_up = 0.0;
#line 231
  *has_three_hlines_up = 0.0;
#line 232
  sum = 0;
#line 233
  y = font_start + font_height / 4;
#line 234
  x = 0;
  }
  {
#line 235
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 235
    if (! (x < (int )m_text->width)) {
#line 235
      goto while_break___13;
    }
    {
#line 237
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 237
      if (((int )*(m_clean->data + (x / 8 + y * m_clean->rowstride)) & (128 >> x % 8)) > 0) {
#line 237
        tmp___12 = 1;
      } else {
#line 237
        tmp___12 = 0;
      }
#line 237
      if (tmp___12) {
#line 237
        tmp___13 = 0;
      } else {
#line 237
        tmp___13 = 1;
      }
#line 237
      if (! tmp___13) {
#line 237
        goto while_break___14;
      }
#line 237
      x ++;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 238
    if (((int )*(m_clean->data + (x / 8 + y * m_clean->rowstride)) & (128 >> x % 8)) > 0) {
#line 238
      tmp___14 = 1;
    } else {
#line 238
      tmp___14 = 0;
    }
#line 238
    if (tmp___14) {
#line 238
      if (x < (int )m_text->width) {
#line 239
        sum ++;
      }
    }
    {
#line 240
    while (1) {
      while_continue___15: /* CIL Label */ ;
#line 240
      if (((int )*(m_clean->data + (x / 8 + y * m_clean->rowstride)) & (128 >> x % 8)) > 0) {
#line 240
        tmp___15 = 1;
      } else {
#line 240
        tmp___15 = 0;
      }
#line 240
      if (! tmp___15) {
#line 240
        goto while_break___15;
      }
#line 240
      x ++;
    }
    while_break___15: /* CIL Label */ ;
    }
  }
  while_break___13: /* CIL Label */ ;
  }
#line 243
  if (sum == 2) {
#line 244
    *has_two_hlines_up = 1.0;
  } else
#line 245
  if (sum == 3) {
#line 246
    *has_three_hlines_up = 1.0;
  }
#line 248
  *has_two_hlines_down = 0.0;
#line 249
  *has_three_hlines_down = 0.0;
#line 250
  sum = 0;
#line 251
  y = font_start + (3 * font_height) / 4;
#line 252
  x = 0;
  {
#line 253
  while (1) {
    while_continue___16: /* CIL Label */ ;
#line 253
    if (! (x < (int )m_text->width)) {
#line 253
      goto while_break___16;
    }
    {
#line 255
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 255
      if (((int )*(m_clean->data + (x / 8 + y * m_clean->rowstride)) & (128 >> x % 8)) > 0) {
#line 255
        tmp___16 = 1;
      } else {
#line 255
        tmp___16 = 0;
      }
#line 255
      if (tmp___16) {
#line 255
        tmp___17 = 0;
      } else {
#line 255
        tmp___17 = 1;
      }
#line 255
      if (! tmp___17) {
#line 255
        goto while_break___17;
      }
#line 255
      x ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 256
    if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 256
      tmp___18 = 1;
    } else {
#line 256
      tmp___18 = 0;
    }
#line 256
    if (tmp___18) {
#line 256
      if (x < (int )m_text->width) {
#line 257
        sum ++;
      }
    }
    {
#line 258
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 258
      if (((int )*(m_clean->data + (x / 8 + y * m_clean->rowstride)) & (128 >> x % 8)) > 0) {
#line 258
        tmp___19 = 1;
      } else {
#line 258
        tmp___19 = 0;
      }
#line 258
      if (! tmp___19) {
#line 258
        goto while_break___18;
      }
#line 258
      x ++;
    }
    while_break___18: /* CIL Label */ ;
    }
  }
  while_break___16: /* CIL Label */ ;
  }
#line 261
  if (sum == 2) {
#line 262
    *has_two_hlines_down = 1.0;
  } else
#line 263
  if (sum == 3) {
#line 264
    *has_three_hlines_down = 1.0;
  }
  {
#line 266
  ho_bitmap_free(m_clean);
  }
#line 268
  return (0);
}
}
#line 271 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_bars(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_top_bar ,
                      double *has_mid_hbar , double *has_bottom_bar , double *has_left_bar ,
                      double *has_mid_vbar , double *has_right_bar , double *has_diagonal_bar ,
                      double *has_diagonal_left_bar ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int line_start ;
  int line_end ;
  int line_height ;
  ho_bitmap *m_bars ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 292
  m_bars = (ho_bitmap *)((void *)0);
#line 294
  *has_top_bar = 0.0;
#line 295
  *has_mid_hbar = 0.0;
#line 296
  *has_bottom_bar = 0.0;
#line 297
  *has_left_bar = 0.0;
#line 298
  *has_mid_vbar = 0.0;
#line 299
  *has_right_bar = 0.0;
#line 300
  *has_diagonal_bar = 0.0;
#line 301
  *has_diagonal_left_bar = 0.0;
#line 304
  x = (int )(m_mask->width / 2);
#line 305
  y = 0;
  {
#line 305
  while (1) {
    while_continue: /* CIL Label */ ;
#line 305
    if (y < (int )m_mask->height) {
#line 305
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 305
        tmp = 1;
      } else {
#line 305
        tmp = 0;
      }
#line 305
      if (tmp) {
#line 305
        goto while_break;
      }
    } else {
#line 305
      goto while_break;
    }
#line 305
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 306
  line_start = y - 1;
  {
#line 307
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 307
    if (y < (int )m_mask->height) {
#line 307
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 307
        tmp___0 = 1;
      } else {
#line 307
        tmp___0 = 0;
      }
#line 307
      if (! tmp___0) {
#line 307
        goto while_break___0;
      }
    } else {
#line 307
      goto while_break___0;
    }
#line 307
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 308
  line_end = y;
#line 309
  line_height = line_end - line_start;
#line 312
  sum = 0;
#line 313
  y = 0;
  {
#line 313
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 313
    if (y < (int )m_mask->height) {
#line 313
      if (! (sum == 0)) {
#line 313
        goto while_break___1;
      }
    } else {
#line 313
      goto while_break___1;
    }
#line 314
    sum = 0;
#line 314
    x = 0;
    {
#line 314
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 314
      if (! (x < (int )m_text->width)) {
#line 314
        goto while_break___2;
      }
#line 315
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 315
        tmp___1 = 1;
      } else {
#line 315
        tmp___1 = 0;
      }
#line 315
      sum += tmp___1;
#line 314
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 313
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 316
  font_start = y - 1;
#line 317
  sum = 0;
#line 318
  y = (int )(m_mask->height - 4);
  {
#line 318
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 318
    if (y > font_start) {
#line 318
      if (! (sum == 0)) {
#line 318
        goto while_break___3;
      }
    } else {
#line 318
      goto while_break___3;
    }
#line 319
    sum = 0;
#line 319
    x = 0;
    {
#line 319
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 319
      if (! (x < (int )m_text->width)) {
#line 319
        goto while_break___4;
      }
#line 320
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 320
        tmp___2 = 1;
      } else {
#line 320
        tmp___2 = 0;
      }
#line 320
      sum += tmp___2;
#line 319
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 318
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 321
  font_end = y + 1;
#line 322
  font_height = font_end - font_start;
#line 324
  if (! font_height) {
#line 325
    return (-1);
  } else
#line 324
  if (! line_height) {
#line 325
    return (-1);
  }
  {
#line 328
  m_bars = ho_font_hbars(m_text, m_mask);
  }
#line 329
  if (! m_bars) {
#line 330
    return (-1);
  }
#line 333
  x = m_bars->width / 2;
#line 334
  y = font_start;
  {
#line 334
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 334
    if (! (y < font_end)) {
#line 334
      goto while_break___5;
    }
#line 337
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 337
      tmp___4 = 1;
    } else {
#line 337
      tmp___4 = 0;
    }
#line 337
    if (tmp___4) {
#line 340
      if (y - font_start < font_height / 3) {
#line 341
        *has_top_bar = 1.0;
      } else
#line 342
      if (y - font_start < (2 * font_height) / 3) {
#line 343
        *has_mid_hbar = 1.0;
      } else {
#line 345
        *has_bottom_bar = 1.0;
      }
#line 348
      y ++;
      {
#line 349
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 349
        if (y < font_end) {
#line 349
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 349
            tmp___3 = 1;
          } else {
#line 349
            tmp___3 = 0;
          }
#line 349
          if (! tmp___3) {
#line 349
            goto while_break___6;
          }
        } else {
#line 349
          goto while_break___6;
        }
#line 349
        y ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 334
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 354
  ho_bitmap_free(m_bars);
#line 355
  m_bars = ho_font_vbars(m_text, m_mask);
  }
#line 356
  if (! m_bars) {
#line 357
    return (-1);
  }
#line 360
  y = m_bars->height / 2;
#line 361
  x = 0;
  {
#line 361
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 361
    if (! (x < m_bars->width)) {
#line 361
      goto while_break___7;
    }
#line 364
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 364
      tmp___6 = 1;
    } else {
#line 364
      tmp___6 = 0;
    }
#line 364
    if (tmp___6) {
#line 367
      if (x < m_bars->width / 3) {
#line 368
        *has_left_bar = 1.0;
      } else
#line 369
      if (x < (2 * m_bars->width) / 3) {
#line 370
        *has_mid_vbar = 1.0;
      } else {
#line 372
        *has_right_bar = 1.0;
      }
#line 375
      x ++;
      {
#line 376
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 376
        if (x < m_bars->width) {
#line 376
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 376
            tmp___5 = 1;
          } else {
#line 376
            tmp___5 = 0;
          }
#line 376
          if (! tmp___5) {
#line 376
            goto while_break___8;
          }
        } else {
#line 376
          goto while_break___8;
        }
#line 376
        x ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 361
    x ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 381
  ho_bitmap_free(m_bars);
#line 382
  m_bars = ho_font_diagonal(m_text, m_mask);
  }
#line 383
  if (! m_bars) {
#line 384
    return (-1);
  }
#line 387
  y = m_bars->height / 2;
#line 388
  x = 0;
  {
#line 388
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 388
    if (x < m_bars->width) {
#line 388
      if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 388
        tmp___7 = 1;
      } else {
#line 388
        tmp___7 = 0;
      }
#line 388
      if (tmp___7) {
#line 388
        goto while_break___9;
      }
    } else {
#line 388
      goto while_break___9;
    }
#line 388
    x ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 389
  if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 389
    tmp___8 = 1;
  } else {
#line 389
    tmp___8 = 0;
  }
#line 389
  if (tmp___8) {
#line 389
    if (x < m_bars->width) {
#line 390
      *has_diagonal_bar = 1.0;
    }
  }
  {
#line 393
  ho_bitmap_free(m_bars);
#line 394
  m_bars = ho_font_diagonal_left(m_text, m_mask);
  }
#line 395
  if (! m_bars) {
#line 396
    return (-1);
  }
#line 399
  y = m_bars->height / 2;
#line 400
  x = 0;
  {
#line 400
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 400
    if (x < m_bars->width) {
#line 400
      if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 400
        tmp___9 = 1;
      } else {
#line 400
        tmp___9 = 0;
      }
#line 400
      if (tmp___9) {
#line 400
        goto while_break___10;
      }
    } else {
#line 400
      goto while_break___10;
    }
#line 400
    x ++;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 401
  if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 401
    tmp___10 = 1;
  } else {
#line 401
    tmp___10 = 0;
  }
#line 401
  if (tmp___10) {
#line 401
    if (x < m_bars->width) {
#line 402
      *has_diagonal_left_bar = 1.0;
    }
  }
  {
#line 404
  ho_bitmap_free(m_bars);
  }
#line 406
  return (0);
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_edges(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_top_left_edge ,
                       double *has_mid_left_edge , double *has_bottom_left_edge ,
                       double *has_top_right_edge , double *has_mid_right_edge , double *has_bottom_right_edge ,
                       double *has_left_top_edge , double *has_mid_top_edge , double *has_right_top_edge ,
                       double *has_left_bottom_edge , double *has_mid_bottom_edge ,
                       double *has_right_bottom_edge ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int line_start ;
  int line_end ;
  int line_height ;
  ho_bitmap *m_bars ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 438
  m_bars = (ho_bitmap *)((void *)0);
#line 440
  *has_top_left_edge = 0.0;
#line 441
  *has_mid_left_edge = 0.0;
#line 442
  *has_bottom_left_edge = 0.0;
#line 443
  *has_top_right_edge = 0.0;
#line 444
  *has_mid_right_edge = 0.0;
#line 445
  *has_bottom_right_edge = 0.0;
#line 446
  *has_left_top_edge = 0.0;
#line 447
  *has_mid_top_edge = 0.0;
#line 448
  *has_right_top_edge = 0.0;
#line 449
  *has_left_bottom_edge = 0.0;
#line 450
  *has_mid_bottom_edge = 0.0;
#line 451
  *has_right_bottom_edge = 0.0;
#line 454
  x = (int )(m_mask->width / 2);
#line 455
  y = 0;
  {
#line 455
  while (1) {
    while_continue: /* CIL Label */ ;
#line 455
    if (y < (int )m_mask->height) {
#line 455
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 455
        tmp = 1;
      } else {
#line 455
        tmp = 0;
      }
#line 455
      if (tmp) {
#line 455
        goto while_break;
      }
    } else {
#line 455
      goto while_break;
    }
#line 455
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 456
  line_start = y - 1;
  {
#line 457
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 457
    if (y < (int )m_mask->height) {
#line 457
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 457
        tmp___0 = 1;
      } else {
#line 457
        tmp___0 = 0;
      }
#line 457
      if (! tmp___0) {
#line 457
        goto while_break___0;
      }
    } else {
#line 457
      goto while_break___0;
    }
#line 457
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 458
  line_end = y;
#line 459
  line_height = line_end - line_start;
#line 462
  sum = 0;
#line 463
  y = 0;
  {
#line 463
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 463
    if (y < (int )m_mask->height) {
#line 463
      if (! (sum == 0)) {
#line 463
        goto while_break___1;
      }
    } else {
#line 463
      goto while_break___1;
    }
#line 464
    sum = 0;
#line 464
    x = 0;
    {
#line 464
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 464
      if (! (x < (int )m_text->width)) {
#line 464
        goto while_break___2;
      }
#line 465
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 465
        tmp___1 = 1;
      } else {
#line 465
        tmp___1 = 0;
      }
#line 465
      sum += tmp___1;
#line 464
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 463
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 466
  font_start = y - 1;
#line 467
  sum = 0;
#line 468
  y = (int )(m_mask->height - 4);
  {
#line 468
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 468
    if (y > font_start) {
#line 468
      if (! (sum == 0)) {
#line 468
        goto while_break___3;
      }
    } else {
#line 468
      goto while_break___3;
    }
#line 469
    sum = 0;
#line 469
    x = 0;
    {
#line 469
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 469
      if (! (x < (int )m_text->width)) {
#line 469
        goto while_break___4;
      }
#line 470
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 470
        tmp___2 = 1;
      } else {
#line 470
        tmp___2 = 0;
      }
#line 470
      sum += tmp___2;
#line 469
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 468
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 471
  font_end = y + 1;
#line 472
  font_height = font_end - font_start;
#line 474
  if (! font_height) {
#line 475
    return (-1);
  } else
#line 474
  if (! line_height) {
#line 475
    return (-1);
  }
  {
#line 478
  m_bars = ho_font_edges_left(m_text, m_mask);
  }
#line 479
  if (! m_bars) {
#line 480
    return (-1);
  }
#line 483
  x = m_bars->width / 2;
#line 484
  y = font_start;
  {
#line 484
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 484
    if (! (y < font_end)) {
#line 484
      goto while_break___5;
    }
#line 487
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 487
      tmp___4 = 1;
    } else {
#line 487
      tmp___4 = 0;
    }
#line 487
    if (tmp___4) {
#line 490
      if (y - font_start < font_height / 3) {
#line 491
        *has_top_left_edge += 0.1;
      } else
#line 492
      if (y - font_start < (2 * font_height) / 3) {
#line 493
        *has_mid_left_edge += 0.1;
      } else {
#line 495
        *has_bottom_left_edge += 0.1;
      }
#line 498
      y ++;
      {
#line 499
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 499
        if (y < font_end) {
#line 499
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 499
            tmp___3 = 1;
          } else {
#line 499
            tmp___3 = 0;
          }
#line 499
          if (! tmp___3) {
#line 499
            goto while_break___6;
          }
        } else {
#line 499
          goto while_break___6;
        }
#line 499
        y ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 484
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 504
  ho_bitmap_free(m_bars);
#line 505
  m_bars = ho_font_edges_right(m_text, m_mask);
  }
#line 506
  if (! m_bars) {
#line 507
    return (-1);
  }
#line 510
  x = m_bars->width / 2;
#line 511
  y = font_start;
  {
#line 511
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 511
    if (! (y < font_end)) {
#line 511
      goto while_break___7;
    }
#line 514
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 514
      tmp___6 = 1;
    } else {
#line 514
      tmp___6 = 0;
    }
#line 514
    if (tmp___6) {
#line 517
      if (y - font_start < font_height / 3) {
#line 518
        *has_top_right_edge += 0.1;
      } else
#line 519
      if (y - font_start < (2 * font_height) / 3) {
#line 520
        *has_mid_right_edge += 0.1;
      } else {
#line 522
        *has_bottom_right_edge += 0.1;
      }
#line 525
      y ++;
      {
#line 526
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 526
        if (y < font_end) {
#line 526
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 526
            tmp___5 = 1;
          } else {
#line 526
            tmp___5 = 0;
          }
#line 526
          if (! tmp___5) {
#line 526
            goto while_break___8;
          }
        } else {
#line 526
          goto while_break___8;
        }
#line 526
        y ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 511
    y ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 530
  ho_bitmap_free(m_bars);
#line 531
  m_bars = ho_font_edges_top(m_text, m_mask);
  }
#line 532
  if (! m_bars) {
#line 533
    return (-1);
  }
#line 536
  y = m_bars->height / 2;
#line 537
  x = 0;
  {
#line 537
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 537
    if (! (x < m_bars->width)) {
#line 537
      goto while_break___9;
    }
#line 540
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 540
      tmp___8 = 1;
    } else {
#line 540
      tmp___8 = 0;
    }
#line 540
    if (tmp___8) {
#line 543
      if (x < m_bars->width / 3) {
#line 544
        *has_left_top_edge += 0.1;
      } else
#line 545
      if (x < (2 * m_bars->width) / 3) {
#line 546
        *has_mid_top_edge += 0.1;
      } else {
#line 548
        *has_right_top_edge += 0.1;
      }
#line 551
      x ++;
      {
#line 552
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 552
        if (x < m_bars->width) {
#line 552
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 552
            tmp___7 = 1;
          } else {
#line 552
            tmp___7 = 0;
          }
#line 552
          if (! tmp___7) {
#line 552
            goto while_break___10;
          }
        } else {
#line 552
          goto while_break___10;
        }
#line 552
        x ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 537
    x ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 557
  ho_bitmap_free(m_bars);
#line 558
  m_bars = ho_font_edges_bottom(m_text, m_mask);
  }
#line 559
  if (! m_bars) {
#line 560
    return (-1);
  }
#line 563
  y = m_bars->height / 2;
#line 564
  x = 0;
  {
#line 564
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 564
    if (! (x < m_bars->width)) {
#line 564
      goto while_break___11;
    }
#line 567
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 567
      tmp___10 = 1;
    } else {
#line 567
      tmp___10 = 0;
    }
#line 567
    if (tmp___10) {
#line 570
      if (x < m_bars->width / 3) {
#line 571
        *has_left_bottom_edge += 0.1;
      } else
#line 572
      if (x < (2 * m_bars->width) / 3) {
#line 573
        *has_mid_bottom_edge += 0.1;
      } else {
#line 575
        *has_right_bottom_edge += 0.1;
      }
#line 578
      x ++;
      {
#line 579
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 579
        if (x < m_bars->width) {
#line 579
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 579
            tmp___9 = 1;
          } else {
#line 579
            tmp___9 = 0;
          }
#line 579
          if (! tmp___9) {
#line 579
            goto while_break___12;
          }
        } else {
#line 579
          goto while_break___12;
        }
#line 579
        x ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 564
    x ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 583
  ho_bitmap_free(m_bars);
  }
#line 585
  return (0);
}
}
#line 588 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_edges_big(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                           double *has_top_left_edge , double *has_mid_left_edge ,
                           double *has_bottom_left_edge , double *has_top_right_edge ,
                           double *has_mid_right_edge , double *has_bottom_right_edge ,
                           double *has_left_top_edge , double *has_mid_top_edge ,
                           double *has_right_top_edge , double *has_left_bottom_edge ,
                           double *has_mid_bottom_edge , double *has_right_bottom_edge ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int line_start ;
  int line_end ;
  int line_height ;
  ho_bitmap *m_bars ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 617
  m_bars = (ho_bitmap *)((void *)0);
#line 619
  *has_top_left_edge = 0.0;
#line 620
  *has_mid_left_edge = 0.0;
#line 621
  *has_bottom_left_edge = 0.0;
#line 622
  *has_top_right_edge = 0.0;
#line 623
  *has_mid_right_edge = 0.0;
#line 624
  *has_bottom_right_edge = 0.0;
#line 625
  *has_left_top_edge = 0.0;
#line 626
  *has_mid_top_edge = 0.0;
#line 627
  *has_right_top_edge = 0.0;
#line 628
  *has_left_bottom_edge = 0.0;
#line 629
  *has_mid_bottom_edge = 0.0;
#line 630
  *has_right_bottom_edge = 0.0;
#line 633
  x = (int )(m_mask->width / 2);
#line 634
  y = 0;
  {
#line 634
  while (1) {
    while_continue: /* CIL Label */ ;
#line 634
    if (y < (int )m_mask->height) {
#line 634
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 634
        tmp = 1;
      } else {
#line 634
        tmp = 0;
      }
#line 634
      if (tmp) {
#line 634
        goto while_break;
      }
    } else {
#line 634
      goto while_break;
    }
#line 634
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  line_start = y - 1;
  {
#line 636
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 636
    if (y < (int )m_mask->height) {
#line 636
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 636
        tmp___0 = 1;
      } else {
#line 636
        tmp___0 = 0;
      }
#line 636
      if (! tmp___0) {
#line 636
        goto while_break___0;
      }
    } else {
#line 636
      goto while_break___0;
    }
#line 636
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 637
  line_end = y;
#line 638
  line_height = line_end - line_start;
#line 641
  sum = 0;
#line 642
  y = 0;
  {
#line 642
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 642
    if (y < (int )m_mask->height) {
#line 642
      if (! (sum == 0)) {
#line 642
        goto while_break___1;
      }
    } else {
#line 642
      goto while_break___1;
    }
#line 643
    sum = 0;
#line 643
    x = 0;
    {
#line 643
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 643
      if (! (x < (int )m_text->width)) {
#line 643
        goto while_break___2;
      }
#line 644
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 644
        tmp___1 = 1;
      } else {
#line 644
        tmp___1 = 0;
      }
#line 644
      sum += tmp___1;
#line 643
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 642
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 645
  font_start = y - 1;
#line 646
  sum = 0;
#line 647
  y = (int )(m_mask->height - 4);
  {
#line 647
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 647
    if (y > font_start) {
#line 647
      if (! (sum == 0)) {
#line 647
        goto while_break___3;
      }
    } else {
#line 647
      goto while_break___3;
    }
#line 648
    sum = 0;
#line 648
    x = 0;
    {
#line 648
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 648
      if (! (x < (int )m_text->width)) {
#line 648
        goto while_break___4;
      }
#line 649
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 649
        tmp___2 = 1;
      } else {
#line 649
        tmp___2 = 0;
      }
#line 649
      sum += tmp___2;
#line 648
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 647
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 650
  font_end = y + 1;
#line 651
  font_height = font_end - font_start;
#line 653
  if (! font_height) {
#line 654
    return (-1);
  } else
#line 653
  if (! line_height) {
#line 654
    return (-1);
  }
  {
#line 657
  m_bars = ho_font_edges_left_big(m_text, m_mask);
  }
#line 658
  if (! m_bars) {
#line 659
    return (-1);
  }
#line 662
  x = m_bars->width / 2;
#line 663
  y = font_start;
  {
#line 663
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 663
    if (! (y < font_end)) {
#line 663
      goto while_break___5;
    }
#line 666
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 666
      tmp___4 = 1;
    } else {
#line 666
      tmp___4 = 0;
    }
#line 666
    if (tmp___4) {
#line 669
      if (y - font_start < font_height / 3) {
#line 670
        *has_top_left_edge += 0.1;
      } else
#line 671
      if (y - font_start < (2 * font_height) / 3) {
#line 672
        *has_mid_left_edge += 0.1;
      } else {
#line 674
        *has_bottom_left_edge += 0.1;
      }
#line 677
      y ++;
      {
#line 678
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 678
        if (y < font_end) {
#line 678
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 678
            tmp___3 = 1;
          } else {
#line 678
            tmp___3 = 0;
          }
#line 678
          if (! tmp___3) {
#line 678
            goto while_break___6;
          }
        } else {
#line 678
          goto while_break___6;
        }
#line 678
        y ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 663
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 683
  ho_bitmap_free(m_bars);
#line 684
  m_bars = ho_font_edges_right_big(m_text, m_mask);
  }
#line 685
  if (! m_bars) {
#line 686
    return (-1);
  }
#line 689
  x = m_bars->width / 2;
#line 690
  y = font_start;
  {
#line 690
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 690
    if (! (y < font_end)) {
#line 690
      goto while_break___7;
    }
#line 693
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 693
      tmp___6 = 1;
    } else {
#line 693
      tmp___6 = 0;
    }
#line 693
    if (tmp___6) {
#line 696
      if (y - font_start < font_height / 3) {
#line 697
        *has_top_right_edge += 0.1;
      } else
#line 698
      if (y - font_start < (2 * font_height) / 3) {
#line 699
        *has_mid_right_edge += 0.1;
      } else {
#line 701
        *has_bottom_right_edge += 0.1;
      }
#line 704
      y ++;
      {
#line 705
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 705
        if (y < font_end) {
#line 705
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 705
            tmp___5 = 1;
          } else {
#line 705
            tmp___5 = 0;
          }
#line 705
          if (! tmp___5) {
#line 705
            goto while_break___8;
          }
        } else {
#line 705
          goto while_break___8;
        }
#line 705
        y ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 690
    y ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 709
  ho_bitmap_free(m_bars);
#line 710
  m_bars = ho_font_edges_top_big(m_text, m_mask);
  }
#line 711
  if (! m_bars) {
#line 712
    return (-1);
  }
#line 715
  y = m_bars->height / 2;
#line 716
  x = 0;
  {
#line 716
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 716
    if (! (x < m_bars->width)) {
#line 716
      goto while_break___9;
    }
#line 719
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 719
      tmp___8 = 1;
    } else {
#line 719
      tmp___8 = 0;
    }
#line 719
    if (tmp___8) {
#line 722
      if (x < m_bars->width / 3) {
#line 723
        *has_left_top_edge += 0.1;
      } else
#line 724
      if (x < (2 * m_bars->width) / 3) {
#line 725
        *has_mid_top_edge += 0.1;
      } else {
#line 727
        *has_right_top_edge += 0.1;
      }
#line 730
      x ++;
      {
#line 731
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 731
        if (x < m_bars->width) {
#line 731
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 731
            tmp___7 = 1;
          } else {
#line 731
            tmp___7 = 0;
          }
#line 731
          if (! tmp___7) {
#line 731
            goto while_break___10;
          }
        } else {
#line 731
          goto while_break___10;
        }
#line 731
        x ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 716
    x ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 736
  ho_bitmap_free(m_bars);
#line 737
  m_bars = ho_font_edges_bottom_big(m_text, m_mask);
  }
#line 738
  if (! m_bars) {
#line 739
    return (-1);
  }
#line 742
  y = m_bars->height / 2;
#line 743
  x = 0;
  {
#line 743
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 743
    if (! (x < m_bars->width)) {
#line 743
      goto while_break___11;
    }
#line 746
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 746
      tmp___10 = 1;
    } else {
#line 746
      tmp___10 = 0;
    }
#line 746
    if (tmp___10) {
#line 749
      if (x < m_bars->width / 3) {
#line 750
        *has_left_bottom_edge += 0.1;
      } else
#line 751
      if (x < (2 * m_bars->width) / 3) {
#line 752
        *has_mid_bottom_edge += 0.1;
      } else {
#line 754
        *has_right_bottom_edge += 0.1;
      }
#line 757
      x ++;
      {
#line 758
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 758
        if (x < m_bars->width) {
#line 758
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 758
            tmp___9 = 1;
          } else {
#line 758
            tmp___9 = 0;
          }
#line 758
          if (! tmp___9) {
#line 758
            goto while_break___12;
          }
        } else {
#line 758
          goto while_break___12;
        }
#line 758
        x ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 743
    x ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 762
  ho_bitmap_free(m_bars);
  }
#line 764
  return (0);
}
}
#line 767 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_notches(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_top_left_notch ,
                         double *has_mid_left_notch , double *has_bottom_left_notch ,
                         double *has_top_right_notch , double *has_mid_right_notch ,
                         double *has_bottom_right_notch , double *has_left_top_notch ,
                         double *has_mid_top_notch , double *has_right_top_notch ,
                         double *has_left_bottom_notch , double *has_mid_bottom_notch ,
                         double *has_right_bottom_notch ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int line_start ;
  int line_end ;
  int line_height ;
  ho_bitmap *m_bars ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 796
  m_bars = (ho_bitmap *)((void *)0);
#line 798
  *has_top_left_notch = 0.0;
#line 799
  *has_mid_left_notch = 0.0;
#line 800
  *has_bottom_left_notch = 0.0;
#line 801
  *has_top_right_notch = 0.0;
#line 802
  *has_mid_right_notch = 0.0;
#line 803
  *has_bottom_right_notch = 0.0;
#line 804
  *has_left_top_notch = 0.0;
#line 805
  *has_mid_top_notch = 0.0;
#line 806
  *has_right_top_notch = 0.0;
#line 807
  *has_left_bottom_notch = 0.0;
#line 808
  *has_mid_bottom_notch = 0.0;
#line 809
  *has_right_bottom_notch = 0.0;
#line 812
  x = (int )(m_mask->width / 2);
#line 813
  y = 0;
  {
#line 813
  while (1) {
    while_continue: /* CIL Label */ ;
#line 813
    if (y < (int )m_mask->height) {
#line 813
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 813
        tmp = 1;
      } else {
#line 813
        tmp = 0;
      }
#line 813
      if (tmp) {
#line 813
        goto while_break;
      }
    } else {
#line 813
      goto while_break;
    }
#line 813
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 814
  line_start = y - 1;
  {
#line 815
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 815
    if (y < (int )m_mask->height) {
#line 815
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 815
        tmp___0 = 1;
      } else {
#line 815
        tmp___0 = 0;
      }
#line 815
      if (! tmp___0) {
#line 815
        goto while_break___0;
      }
    } else {
#line 815
      goto while_break___0;
    }
#line 815
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 816
  line_end = y;
#line 817
  line_height = line_end - line_start;
#line 820
  sum = 0;
#line 821
  y = 0;
  {
#line 821
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 821
    if (y < (int )m_mask->height) {
#line 821
      if (! (sum == 0)) {
#line 821
        goto while_break___1;
      }
    } else {
#line 821
      goto while_break___1;
    }
#line 822
    sum = 0;
#line 822
    x = 0;
    {
#line 822
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 822
      if (! (x < (int )m_text->width)) {
#line 822
        goto while_break___2;
      }
#line 823
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 823
        tmp___1 = 1;
      } else {
#line 823
        tmp___1 = 0;
      }
#line 823
      sum += tmp___1;
#line 822
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 821
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 824
  font_start = y - 1;
#line 825
  sum = 0;
#line 826
  y = (int )(m_mask->height - 4);
  {
#line 826
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 826
    if (y > font_start) {
#line 826
      if (! (sum == 0)) {
#line 826
        goto while_break___3;
      }
    } else {
#line 826
      goto while_break___3;
    }
#line 827
    sum = 0;
#line 827
    x = 0;
    {
#line 827
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 827
      if (! (x < (int )m_text->width)) {
#line 827
        goto while_break___4;
      }
#line 828
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 828
        tmp___2 = 1;
      } else {
#line 828
        tmp___2 = 0;
      }
#line 828
      sum += tmp___2;
#line 827
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 826
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 829
  font_end = y + 1;
#line 830
  font_height = font_end - font_start;
#line 832
  if (! font_height) {
#line 833
    return (-1);
  } else
#line 832
  if (! line_height) {
#line 833
    return (-1);
  }
  {
#line 836
  m_bars = ho_font_notch_left(m_text, m_mask);
  }
#line 837
  if (! m_bars) {
#line 838
    return (-1);
  }
#line 840
  x = m_bars->width / 2;
#line 841
  y = font_start;
  {
#line 841
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 841
    if (! (y < font_end)) {
#line 841
      goto while_break___5;
    }
#line 844
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 844
      tmp___4 = 1;
    } else {
#line 844
      tmp___4 = 0;
    }
#line 844
    if (tmp___4) {
#line 847
      if (y - font_start < font_height / 3) {
#line 848
        *has_top_left_notch += 0.1;
      } else
#line 849
      if (y - font_start < (2 * font_height) / 3) {
#line 850
        *has_mid_left_notch += 0.1;
      } else {
#line 852
        *has_bottom_left_notch += 0.1;
      }
#line 855
      y ++;
      {
#line 856
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 856
        if (y < font_end) {
#line 856
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 856
            tmp___3 = 1;
          } else {
#line 856
            tmp___3 = 0;
          }
#line 856
          if (! tmp___3) {
#line 856
            goto while_break___6;
          }
        } else {
#line 856
          goto while_break___6;
        }
#line 856
        y ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 841
    y ++;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 861
  ho_bitmap_free(m_bars);
#line 862
  m_bars = ho_font_notch_right(m_text, m_mask);
  }
#line 863
  if (! m_bars) {
#line 864
    return (-1);
  }
#line 866
  x = m_bars->width / 2;
#line 867
  y = font_start;
  {
#line 867
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 867
    if (! (y < font_end)) {
#line 867
      goto while_break___7;
    }
#line 870
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 870
      tmp___6 = 1;
    } else {
#line 870
      tmp___6 = 0;
    }
#line 870
    if (tmp___6) {
#line 873
      if (y - font_start < font_height / 3) {
#line 874
        *has_top_right_notch += 0.1;
      } else
#line 875
      if (y - font_start < (2 * font_height) / 3) {
#line 876
        *has_mid_right_notch += 0.1;
      } else {
#line 878
        *has_bottom_right_notch += 0.1;
      }
#line 881
      y ++;
      {
#line 882
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 882
        if (y < font_end) {
#line 882
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 882
            tmp___5 = 1;
          } else {
#line 882
            tmp___5 = 0;
          }
#line 882
          if (! tmp___5) {
#line 882
            goto while_break___8;
          }
        } else {
#line 882
          goto while_break___8;
        }
#line 882
        y ++;
      }
      while_break___8: /* CIL Label */ ;
      }
    }
#line 867
    y ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 886
  ho_bitmap_free(m_bars);
#line 887
  m_bars = ho_font_notch_top(m_text, m_mask);
  }
#line 888
  if (! m_bars) {
#line 889
    return (-1);
  }
#line 892
  y = m_bars->height / 2;
#line 893
  x = 0;
  {
#line 893
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 893
    if (! (x < m_bars->width)) {
#line 893
      goto while_break___9;
    }
#line 896
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 896
      tmp___8 = 1;
    } else {
#line 896
      tmp___8 = 0;
    }
#line 896
    if (tmp___8) {
#line 899
      if (x < m_bars->width / 3) {
#line 900
        *has_left_top_notch += 0.1;
      } else
#line 901
      if (x < (2 * m_bars->width) / 3) {
#line 902
        *has_mid_top_notch += 0.1;
      } else {
#line 904
        *has_right_top_notch += 0.1;
      }
#line 907
      x ++;
      {
#line 908
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 908
        if (x < m_bars->width) {
#line 908
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 908
            tmp___7 = 1;
          } else {
#line 908
            tmp___7 = 0;
          }
#line 908
          if (! tmp___7) {
#line 908
            goto while_break___10;
          }
        } else {
#line 908
          goto while_break___10;
        }
#line 908
        x ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 893
    x ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 913
  ho_bitmap_free(m_bars);
#line 914
  m_bars = ho_font_notch_bottom(m_text, m_mask);
  }
#line 915
  if (! m_bars) {
#line 916
    return (-1);
  }
#line 919
  y = m_bars->height / 2;
#line 920
  x = 0;
  {
#line 920
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 920
    if (! (x < m_bars->width)) {
#line 920
      goto while_break___11;
    }
#line 923
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 923
      tmp___10 = 1;
    } else {
#line 923
      tmp___10 = 0;
    }
#line 923
    if (tmp___10) {
#line 926
      if (x < m_bars->width / 3) {
#line 927
        *has_left_bottom_notch += 0.1;
      } else
#line 928
      if (x < (2 * m_bars->width) / 3) {
#line 929
        *has_mid_bottom_notch += 0.1;
      } else {
#line 931
        *has_right_bottom_notch += 0.1;
      }
#line 934
      x ++;
      {
#line 935
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 935
        if (x < m_bars->width) {
#line 935
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 935
            tmp___9 = 1;
          } else {
#line 935
            tmp___9 = 0;
          }
#line 935
          if (! tmp___9) {
#line 935
            goto while_break___12;
          }
        } else {
#line 935
          goto while_break___12;
        }
#line 935
        x ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 920
    x ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 939
  ho_bitmap_free(m_bars);
  }
#line 941
  return (0);
}
}
#line 944 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_parts(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_one_hole ,
                       double *has_two_holes , double *has_hey_part , double *has_dot_part ,
                       double *has_comma_part ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int line_start ;
  int line_end ;
  int line_height ;
  int parts_start ;
  int parts_end ;
  int parts_height ;
  ho_bitmap *m_parts ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 970
  m_parts = (ho_bitmap *)((void *)0);
#line 972
  *has_one_hole = 0.0;
#line 973
  *has_two_holes = 0.0;
#line 974
  *has_hey_part = 0.0;
#line 975
  *has_dot_part = 0.0;
#line 976
  *has_comma_part = 0.0;
#line 979
  x = (int )(m_mask->width / 2);
#line 980
  y = 0;
  {
#line 980
  while (1) {
    while_continue: /* CIL Label */ ;
#line 980
    if (y < (int )m_mask->height) {
#line 980
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 980
        tmp = 1;
      } else {
#line 980
        tmp = 0;
      }
#line 980
      if (tmp) {
#line 980
        goto while_break;
      }
    } else {
#line 980
      goto while_break;
    }
#line 980
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 981
  line_start = y - 1;
  {
#line 982
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 982
    if (y < (int )m_mask->height) {
#line 982
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 982
        tmp___0 = 1;
      } else {
#line 982
        tmp___0 = 0;
      }
#line 982
      if (! tmp___0) {
#line 982
        goto while_break___0;
      }
    } else {
#line 982
      goto while_break___0;
    }
#line 982
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 983
  line_end = y;
#line 984
  line_height = line_end - line_start;
#line 987
  sum = 0;
#line 988
  y = 0;
  {
#line 988
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 988
    if (y < (int )m_mask->height) {
#line 988
      if (! (sum == 0)) {
#line 988
        goto while_break___1;
      }
    } else {
#line 988
      goto while_break___1;
    }
#line 989
    sum = 0;
#line 989
    x = 0;
    {
#line 989
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 989
      if (! (x < (int )m_text->width)) {
#line 989
        goto while_break___2;
      }
#line 990
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 990
        tmp___1 = 1;
      } else {
#line 990
        tmp___1 = 0;
      }
#line 990
      sum += tmp___1;
#line 989
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 988
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 991
  font_start = y - 1;
#line 992
  sum = 0;
#line 993
  y = (int )(m_mask->height - 4);
  {
#line 993
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 993
    if (y > font_start) {
#line 993
      if (! (sum == 0)) {
#line 993
        goto while_break___3;
      }
    } else {
#line 993
      goto while_break___3;
    }
#line 994
    sum = 0;
#line 994
    x = 0;
    {
#line 994
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 994
      if (! (x < (int )m_text->width)) {
#line 994
        goto while_break___4;
      }
#line 995
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 995
        tmp___2 = 1;
      } else {
#line 995
        tmp___2 = 0;
      }
#line 995
      sum += tmp___2;
#line 994
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 993
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 996
  font_end = y + 1;
#line 997
  font_height = font_end - font_start;
#line 999
  if (! font_height) {
#line 1000
    return (-1);
  } else
#line 999
  if (! line_height) {
#line 1000
    return (-1);
  }
  {
#line 1003
  m_parts = ho_font_holes(m_text, m_mask);
  }
#line 1004
  if (m_parts) {
    {
#line 1006
    sum = ho_bitmap_filter_count_objects((ho_bitmap const   *)m_parts);
    }
#line 1007
    if (sum == 1) {
#line 1008
      *has_one_hole = 1.0;
    } else
#line 1009
    if (sum == 2) {
#line 1010
      *has_two_holes = 1.0;
    }
  }
#line 1015
  if (m_parts) {
    {
#line 1016
    ho_bitmap_free(m_parts);
    }
  }
  {
#line 1017
  m_parts = ho_font_second_object(m_text, m_mask);
  }
#line 1018
  if (m_parts) {
#line 1021
    sum = 0;
#line 1022
    y = 0;
    {
#line 1022
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 1022
      if (y < m_parts->height) {
#line 1022
        if (! (sum == 0)) {
#line 1022
          goto while_break___5;
        }
      } else {
#line 1022
        goto while_break___5;
      }
#line 1023
      sum = 0;
#line 1023
      x = 0;
      {
#line 1023
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 1023
        if (! (x < m_parts->width)) {
#line 1023
          goto while_break___6;
        }
#line 1024
        if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1024
          tmp___3 = 1;
        } else {
#line 1024
          tmp___3 = 0;
        }
#line 1024
        sum += tmp___3;
#line 1023
        x ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 1022
      y ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 1025
    parts_start = y - 1;
#line 1026
    sum = 0;
#line 1027
    y = m_parts->height - 4;
    {
#line 1027
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 1027
      if (y > parts_start) {
#line 1027
        if (! (sum == 0)) {
#line 1027
          goto while_break___7;
        }
      } else {
#line 1027
        goto while_break___7;
      }
#line 1028
      sum = 0;
#line 1028
      x = 0;
      {
#line 1028
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 1028
        if (! (x < m_parts->width)) {
#line 1028
          goto while_break___8;
        }
#line 1029
        if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1029
          tmp___4 = 1;
        } else {
#line 1029
          tmp___4 = 0;
        }
#line 1029
        sum += tmp___4;
#line 1028
        x ++;
      }
      while_break___8: /* CIL Label */ ;
      }
#line 1027
      y --;
    }
    while_break___7: /* CIL Label */ ;
    }
#line 1030
    parts_end = y + 1;
#line 1031
    parts_height = parts_end - parts_start;
#line 1034
    y = font_end - font_height / 5;
#line 1036
    x = 0;
    {
#line 1036
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 1036
      if (x < m_parts->width / 2) {
#line 1036
        if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1036
          tmp___5 = 1;
        } else {
#line 1036
          tmp___5 = 0;
        }
#line 1036
        if (tmp___5) {
#line 1036
          goto while_break___9;
        }
      } else {
#line 1036
        goto while_break___9;
      }
#line 1036
      x ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 1038
    if (x < m_parts->width / 2) {
      {
#line 1040
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1040
        if (x < m_parts->width / 2) {
#line 1040
          if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1040
            tmp___6 = 1;
          } else {
#line 1040
            tmp___6 = 0;
          }
#line 1040
          if (! tmp___6) {
#line 1040
            goto while_break___10;
          }
        } else {
#line 1040
          goto while_break___10;
        }
#line 1040
        x ++;
      }
      while_break___10: /* CIL Label */ ;
      }
#line 1042
      if (x < m_parts->width / 2) {
#line 1042
        if (parts_height > font_height / 4) {
#line 1042
          if (parts_start > font_start + font_height / 5) {
#line 1044
            *has_hey_part = 1.0;
          }
        }
      }
    }
#line 1050
    if (parts_start > font_start + font_height / 2) {
#line 1050
      if (parts_height < font_height / 2) {
#line 1050
        if (parts_height > font_height / 6) {
#line 1052
          *has_dot_part = 1.0;
        }
      }
    }
#line 1057
    if (parts_start > font_start + font_height / 2) {
#line 1057
      if (parts_height > font_height / 5) {
#line 1058
        *has_comma_part = 1.0;
      }
    }
  }
#line 1061
  if (m_parts) {
    {
#line 1062
    ho_bitmap_free(m_parts);
    }
  }
#line 1064
  return (0);
}
}
#line 1067 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_ends(ho_bitmap const   *m_text , ho_bitmap const   *m_mask , double *has_top_left_end ,
                      double *has_top_mid_end , double *has_top_right_end , double *has_mid_left_end ,
                      double *has_mid_mid_end , double *has_mid_right_end , double *has_bottom_left_end ,
                      double *has_bottom_mid_end , double *has_bottom_right_end ,
                      double *has_top_left_cross , double *has_top_mid_cross , double *has_top_right_cross ,
                      double *has_mid_left_cross , double *has_mid_mid_cross , double *has_mid_right_cross ,
                      double *has_bottom_left_cross , double *has_bottom_mid_cross ,
                      double *has_bottom_right_cross ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int line_start ;
  int line_end ;
  int line_height ;
  ho_bitmap *m_parts ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;

  {
#line 1102
  m_parts = (ho_bitmap *)((void *)0);
#line 1105
  *has_top_left_end = 0.0;
#line 1106
  *has_top_mid_end = 0.0;
#line 1107
  *has_top_right_end = 0.0;
#line 1109
  *has_mid_left_end = 0.0;
#line 1110
  *has_mid_mid_end = 0.0;
#line 1111
  *has_mid_right_end = 0.0;
#line 1113
  *has_bottom_left_end = 0.0;
#line 1114
  *has_bottom_mid_end = 0.0;
#line 1115
  *has_bottom_right_end = 0.0;
#line 1117
  *has_top_left_cross = 0.0;
#line 1118
  *has_top_mid_cross = 0.0;
#line 1119
  *has_top_right_cross = 0.0;
#line 1121
  *has_mid_left_cross = 0.0;
#line 1122
  *has_mid_mid_cross = 0.0;
#line 1123
  *has_mid_right_cross = 0.0;
#line 1125
  *has_bottom_left_cross = 0.0;
#line 1126
  *has_bottom_mid_cross = 0.0;
#line 1127
  *has_bottom_right_cross = 0.0;
#line 1130
  x = (int )(m_mask->width / 2);
#line 1131
  y = 0;
  {
#line 1131
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1131
    if (y < (int )m_mask->height) {
#line 1131
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 1131
        tmp = 1;
      } else {
#line 1131
        tmp = 0;
      }
#line 1131
      if (tmp) {
#line 1131
        goto while_break;
      }
    } else {
#line 1131
      goto while_break;
    }
#line 1131
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1132
  line_start = y - 1;
  {
#line 1133
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1133
    if (y < (int )m_mask->height) {
#line 1133
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 1133
        tmp___0 = 1;
      } else {
#line 1133
        tmp___0 = 0;
      }
#line 1133
      if (! tmp___0) {
#line 1133
        goto while_break___0;
      }
    } else {
#line 1133
      goto while_break___0;
    }
#line 1133
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1134
  line_end = y;
#line 1135
  line_height = line_end - line_start;
#line 1138
  sum = 0;
#line 1139
  y = 0;
  {
#line 1139
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1139
    if (y < (int )m_mask->height) {
#line 1139
      if (! (sum == 0)) {
#line 1139
        goto while_break___1;
      }
    } else {
#line 1139
      goto while_break___1;
    }
#line 1140
    sum = 0;
#line 1140
    x = 0;
    {
#line 1140
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1140
      if (! (x < (int )m_text->width)) {
#line 1140
        goto while_break___2;
      }
#line 1141
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1141
        tmp___1 = 1;
      } else {
#line 1141
        tmp___1 = 0;
      }
#line 1141
      sum += tmp___1;
#line 1140
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1139
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1142
  font_start = y - 1;
#line 1143
  sum = 0;
#line 1144
  y = (int )(m_mask->height - 4);
  {
#line 1144
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1144
    if (y > font_start) {
#line 1144
      if (! (sum == 0)) {
#line 1144
        goto while_break___3;
      }
    } else {
#line 1144
      goto while_break___3;
    }
#line 1145
    sum = 0;
#line 1145
    x = 0;
    {
#line 1145
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1145
      if (! (x < (int )m_text->width)) {
#line 1145
        goto while_break___4;
      }
#line 1146
      if (((int )*(m_text->data + (x / 8 + y * (int )m_text->rowstride)) & (128 >> x % 8)) > 0) {
#line 1146
        tmp___2 = 1;
      } else {
#line 1146
        tmp___2 = 0;
      }
#line 1146
      sum += tmp___2;
#line 1145
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1144
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1147
  font_end = y + 1;
#line 1148
  if (font_start < 1) {
#line 1149
    font_start = 1;
  }
#line 1151
  font_height = font_end - font_start;
#line 1153
  if (! font_height) {
#line 1154
    return (-1);
  } else
#line 1153
  if (! line_height) {
#line 1154
    return (-1);
  }
  {
#line 1157
  m_parts = ho_font_ends(m_text, m_mask);
  }
#line 1158
  if (! m_parts) {
#line 1159
    return (-1);
  }
#line 1162
  sum = 0;
#line 1163
  x = 0;
  {
#line 1163
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1163
    if (! (x < m_parts->width / 3)) {
#line 1163
      goto while_break___5;
    }
#line 1164
    y = font_start - 1;
    {
#line 1164
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1164
      if (! (y < font_start + font_height / 3)) {
#line 1164
        goto while_break___6;
      }
#line 1164
      y ++;
#line 1164
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1164
        tmp___3 = 1;
      } else {
#line 1164
        tmp___3 = 0;
      }
#line 1164
      sum += tmp___3;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1163
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1167
  *has_top_left_end = (double )sum * 0.1;
#line 1170
  sum = 0;
#line 1171
  x = m_parts->width / 3;
  {
#line 1171
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1171
    if (! (x < (2 * m_parts->width) / 3)) {
#line 1171
      goto while_break___7;
    }
#line 1172
    y = font_start - 1;
    {
#line 1172
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1172
      if (! (y < font_start + font_height / 3)) {
#line 1172
        goto while_break___8;
      }
#line 1172
      y ++;
#line 1172
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1172
        tmp___4 = 1;
      } else {
#line 1172
        tmp___4 = 0;
      }
#line 1172
      sum += tmp___4;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1171
    x ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1175
  *has_top_mid_end = (double )sum * 0.1;
#line 1178
  sum = 0;
#line 1179
  x = (2 * m_parts->width) / 3;
  {
#line 1179
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1179
    if (! (x < m_parts->width)) {
#line 1179
      goto while_break___9;
    }
#line 1180
    y = font_start - 1;
    {
#line 1180
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 1180
      if (! (y < font_start + font_height / 3)) {
#line 1180
        goto while_break___10;
      }
#line 1180
      y ++;
#line 1180
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1180
        tmp___5 = 1;
      } else {
#line 1180
        tmp___5 = 0;
      }
#line 1180
      sum += tmp___5;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 1179
    x ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1183
  *has_top_right_end = (double )sum * 0.1;
#line 1186
  sum = 0;
#line 1187
  x = 0;
  {
#line 1187
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1187
    if (! (x < m_parts->width / 3)) {
#line 1187
      goto while_break___11;
    }
#line 1188
    y = font_start + font_height / 3;
    {
#line 1188
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 1188
      if (! (y < font_start + (2 * font_height) / 3)) {
#line 1188
        goto while_break___12;
      }
#line 1188
      y ++;
#line 1188
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1188
        tmp___6 = 1;
      } else {
#line 1188
        tmp___6 = 0;
      }
#line 1188
      sum += tmp___6;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 1187
    x ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1191
  *has_mid_left_end = (double )sum * 0.1;
#line 1194
  sum = 0;
#line 1195
  x = m_parts->width / 3;
  {
#line 1195
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1195
    if (! (x < (2 * m_parts->width) / 3)) {
#line 1195
      goto while_break___13;
    }
#line 1196
    y = font_start + font_height / 3;
    {
#line 1196
    while (1) {
      while_continue___14: /* CIL Label */ ;
#line 1196
      if (! (y < font_start + (2 * font_height) / 3)) {
#line 1196
        goto while_break___14;
      }
#line 1196
      y ++;
#line 1196
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1196
        tmp___7 = 1;
      } else {
#line 1196
        tmp___7 = 0;
      }
#line 1196
      sum += tmp___7;
    }
    while_break___14: /* CIL Label */ ;
    }
#line 1195
    x ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1199
  *has_mid_mid_end = (double )sum * 0.1;
#line 1202
  sum = 0;
#line 1203
  x = (2 * m_parts->width) / 3;
  {
#line 1203
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 1203
    if (! (x < m_parts->width)) {
#line 1203
      goto while_break___15;
    }
#line 1204
    y = font_start + font_height / 3;
    {
#line 1204
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 1204
      if (! (y < font_start + (2 * font_height) / 3)) {
#line 1204
        goto while_break___16;
      }
#line 1204
      y ++;
#line 1204
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1204
        tmp___8 = 1;
      } else {
#line 1204
        tmp___8 = 0;
      }
#line 1204
      sum += tmp___8;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 1203
    x ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 1207
  *has_mid_right_end = (double )sum * 0.1;
#line 1210
  sum = 0;
#line 1211
  x = 0;
  {
#line 1211
  while (1) {
    while_continue___17: /* CIL Label */ ;
#line 1211
    if (! (x < m_parts->width / 3)) {
#line 1211
      goto while_break___17;
    }
#line 1212
    y = font_start + (2 * font_height) / 3;
    {
#line 1212
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 1212
      if (! (y < font_start + font_height)) {
#line 1212
        goto while_break___18;
      }
#line 1212
      y ++;
#line 1212
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1212
        tmp___9 = 1;
      } else {
#line 1212
        tmp___9 = 0;
      }
#line 1212
      sum += tmp___9;
    }
    while_break___18: /* CIL Label */ ;
    }
#line 1211
    x ++;
  }
  while_break___17: /* CIL Label */ ;
  }
#line 1214
  *has_bottom_left_end = (double )sum * 0.1;
#line 1217
  sum = 0;
#line 1218
  x = m_parts->width / 3;
  {
#line 1218
  while (1) {
    while_continue___19: /* CIL Label */ ;
#line 1218
    if (! (x < (2 * m_parts->width) / 3)) {
#line 1218
      goto while_break___19;
    }
#line 1219
    y = font_start + (2 * font_height) / 3;
    {
#line 1219
    while (1) {
      while_continue___20: /* CIL Label */ ;
#line 1219
      if (! (y < font_start + font_height)) {
#line 1219
        goto while_break___20;
      }
#line 1219
      y ++;
#line 1219
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1219
        tmp___10 = 1;
      } else {
#line 1219
        tmp___10 = 0;
      }
#line 1219
      sum += tmp___10;
    }
    while_break___20: /* CIL Label */ ;
    }
#line 1218
    x ++;
  }
  while_break___19: /* CIL Label */ ;
  }
#line 1221
  *has_bottom_mid_end = (double )sum * 0.1;
#line 1224
  sum = 0;
#line 1225
  x = (2 * m_parts->width) / 3;
  {
#line 1225
  while (1) {
    while_continue___21: /* CIL Label */ ;
#line 1225
    if (! (x < m_parts->width)) {
#line 1225
      goto while_break___21;
    }
#line 1226
    y = font_start + (2 * font_height) / 3;
    {
#line 1226
    while (1) {
      while_continue___22: /* CIL Label */ ;
#line 1226
      if (! (y < font_start + font_height)) {
#line 1226
        goto while_break___22;
      }
#line 1226
      y ++;
#line 1226
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1226
        tmp___11 = 1;
      } else {
#line 1226
        tmp___11 = 0;
      }
#line 1226
      sum += tmp___11;
    }
    while_break___22: /* CIL Label */ ;
    }
#line 1225
    x ++;
  }
  while_break___21: /* CIL Label */ ;
  }
  {
#line 1228
  *has_bottom_right_end = (double )sum * 0.1;
#line 1231
  ho_bitmap_free(m_parts);
#line 1232
  m_parts = ho_font_cross(m_text, m_mask);
  }
#line 1233
  if (! m_parts) {
#line 1234
    return (-1);
  }
#line 1237
  sum = 0;
#line 1238
  x = 0;
  {
#line 1238
  while (1) {
    while_continue___23: /* CIL Label */ ;
#line 1238
    if (! (x < m_parts->width / 3)) {
#line 1238
      goto while_break___23;
    }
#line 1239
    y = font_start - 1;
    {
#line 1239
    while (1) {
      while_continue___24: /* CIL Label */ ;
#line 1239
      if (! (y < font_start + font_height / 3)) {
#line 1239
        goto while_break___24;
      }
#line 1239
      y ++;
#line 1239
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1239
        tmp___12 = 1;
      } else {
#line 1239
        tmp___12 = 0;
      }
#line 1239
      sum += tmp___12;
    }
    while_break___24: /* CIL Label */ ;
    }
#line 1238
    x ++;
  }
  while_break___23: /* CIL Label */ ;
  }
#line 1242
  *has_top_left_cross = (double )sum * 0.1;
#line 1245
  sum = 0;
#line 1246
  x = m_parts->width / 3;
  {
#line 1246
  while (1) {
    while_continue___25: /* CIL Label */ ;
#line 1246
    if (! (x < (2 * m_parts->width) / 3)) {
#line 1246
      goto while_break___25;
    }
#line 1247
    y = font_start - 1;
    {
#line 1247
    while (1) {
      while_continue___26: /* CIL Label */ ;
#line 1247
      if (! (y < font_start + font_height / 3)) {
#line 1247
        goto while_break___26;
      }
#line 1247
      y ++;
#line 1247
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1247
        tmp___13 = 1;
      } else {
#line 1247
        tmp___13 = 0;
      }
#line 1247
      sum += tmp___13;
    }
    while_break___26: /* CIL Label */ ;
    }
#line 1246
    x ++;
  }
  while_break___25: /* CIL Label */ ;
  }
#line 1250
  *has_top_mid_cross = (double )sum * 0.1;
#line 1253
  sum = 0;
#line 1254
  x = (2 * m_parts->width) / 3;
  {
#line 1254
  while (1) {
    while_continue___27: /* CIL Label */ ;
#line 1254
    if (! (x < m_parts->width)) {
#line 1254
      goto while_break___27;
    }
#line 1255
    y = font_start;
    {
#line 1255
    while (1) {
      while_continue___28: /* CIL Label */ ;
#line 1255
      if (! (y < font_start + font_height / 3)) {
#line 1255
        goto while_break___28;
      }
#line 1255
      y ++;
#line 1255
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1255
        tmp___14 = 1;
      } else {
#line 1255
        tmp___14 = 0;
      }
#line 1255
      sum += tmp___14;
    }
    while_break___28: /* CIL Label */ ;
    }
#line 1254
    x ++;
  }
  while_break___27: /* CIL Label */ ;
  }
#line 1258
  *has_top_right_cross = (double )sum * 0.1;
#line 1261
  sum = 0;
#line 1262
  x = 0;
  {
#line 1262
  while (1) {
    while_continue___29: /* CIL Label */ ;
#line 1262
    if (! (x < m_parts->width / 3)) {
#line 1262
      goto while_break___29;
    }
#line 1263
    y = font_start + font_height / 3;
    {
#line 1263
    while (1) {
      while_continue___30: /* CIL Label */ ;
#line 1263
      if (! (y < font_start + (2 * font_height) / 3)) {
#line 1263
        goto while_break___30;
      }
#line 1263
      y ++;
#line 1263
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1263
        tmp___15 = 1;
      } else {
#line 1263
        tmp___15 = 0;
      }
#line 1263
      sum += tmp___15;
    }
    while_break___30: /* CIL Label */ ;
    }
#line 1262
    x ++;
  }
  while_break___29: /* CIL Label */ ;
  }
#line 1266
  *has_mid_left_cross = (double )sum * 0.1;
#line 1269
  sum = 0;
#line 1270
  x = m_parts->width / 3;
  {
#line 1270
  while (1) {
    while_continue___31: /* CIL Label */ ;
#line 1270
    if (! (x < (2 * m_parts->width) / 3)) {
#line 1270
      goto while_break___31;
    }
#line 1271
    y = font_start + font_height / 3;
    {
#line 1271
    while (1) {
      while_continue___32: /* CIL Label */ ;
#line 1271
      if (! (y < font_start + (2 * font_height) / 3)) {
#line 1271
        goto while_break___32;
      }
#line 1271
      y ++;
#line 1271
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1271
        tmp___16 = 1;
      } else {
#line 1271
        tmp___16 = 0;
      }
#line 1271
      sum += tmp___16;
    }
    while_break___32: /* CIL Label */ ;
    }
#line 1270
    x ++;
  }
  while_break___31: /* CIL Label */ ;
  }
#line 1274
  *has_mid_mid_cross = (double )sum * 0.1;
#line 1277
  sum = 0;
#line 1278
  x = (2 * m_parts->width) / 3;
  {
#line 1278
  while (1) {
    while_continue___33: /* CIL Label */ ;
#line 1278
    if (! (x < m_parts->width)) {
#line 1278
      goto while_break___33;
    }
#line 1279
    y = font_start + font_height / 3;
    {
#line 1279
    while (1) {
      while_continue___34: /* CIL Label */ ;
#line 1279
      if (! (y < font_start + (2 * font_height) / 3)) {
#line 1279
        goto while_break___34;
      }
#line 1279
      y ++;
#line 1279
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1279
        tmp___17 = 1;
      } else {
#line 1279
        tmp___17 = 0;
      }
#line 1279
      sum += tmp___17;
    }
    while_break___34: /* CIL Label */ ;
    }
#line 1278
    x ++;
  }
  while_break___33: /* CIL Label */ ;
  }
#line 1282
  *has_mid_right_cross = (double )sum * 0.1;
#line 1285
  sum = 0;
#line 1286
  x = 0;
  {
#line 1286
  while (1) {
    while_continue___35: /* CIL Label */ ;
#line 1286
    if (! (x < m_parts->width / 3)) {
#line 1286
      goto while_break___35;
    }
#line 1287
    y = font_start + (2 * font_height) / 3;
    {
#line 1287
    while (1) {
      while_continue___36: /* CIL Label */ ;
#line 1287
      if (! (y < font_start + font_height)) {
#line 1287
        goto while_break___36;
      }
#line 1287
      y ++;
#line 1287
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1287
        tmp___18 = 1;
      } else {
#line 1287
        tmp___18 = 0;
      }
#line 1287
      sum += tmp___18;
    }
    while_break___36: /* CIL Label */ ;
    }
#line 1286
    x ++;
  }
  while_break___35: /* CIL Label */ ;
  }
#line 1289
  *has_bottom_left_cross = (double )sum * 0.1;
#line 1292
  sum = 0;
#line 1293
  x = m_parts->width / 3;
  {
#line 1293
  while (1) {
    while_continue___37: /* CIL Label */ ;
#line 1293
    if (! (x < (2 * m_parts->width) / 3)) {
#line 1293
      goto while_break___37;
    }
#line 1294
    y = font_start + (2 * font_height) / 3;
    {
#line 1294
    while (1) {
      while_continue___38: /* CIL Label */ ;
#line 1294
      if (! (y < font_start + font_height)) {
#line 1294
        goto while_break___38;
      }
#line 1294
      y ++;
#line 1294
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1294
        tmp___19 = 1;
      } else {
#line 1294
        tmp___19 = 0;
      }
#line 1294
      sum += tmp___19;
    }
    while_break___38: /* CIL Label */ ;
    }
#line 1293
    x ++;
  }
  while_break___37: /* CIL Label */ ;
  }
#line 1296
  *has_bottom_mid_cross = (double )sum * 0.1;
#line 1299
  sum = 0;
#line 1300
  x = (2 * m_parts->width) / 3;
  {
#line 1300
  while (1) {
    while_continue___39: /* CIL Label */ ;
#line 1300
    if (! (x < m_parts->width)) {
#line 1300
      goto while_break___39;
    }
#line 1301
    y = font_start + (2 * font_height) / 3;
    {
#line 1301
    while (1) {
      while_continue___40: /* CIL Label */ ;
#line 1301
      if (! (y < font_start + font_height)) {
#line 1301
        goto while_break___40;
      }
#line 1301
      y ++;
#line 1301
      if (((int )*(m_parts->data + (x / 8 + y * m_parts->rowstride)) & (128 >> x % 8)) > 0) {
#line 1301
        tmp___20 = 1;
      } else {
#line 1301
        tmp___20 = 0;
      }
#line 1301
      sum += tmp___20;
    }
    while_break___40: /* CIL Label */ ;
    }
#line 1300
    x ++;
  }
  while_break___39: /* CIL Label */ ;
  }
  {
#line 1303
  *has_bottom_right_cross = (double )sum * 0.1;
#line 1305
  ho_bitmap_free(m_parts);
  }
#line 1307
  return (0);
}
}
#line 1310 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_holes_dimentions(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                  double *height , double *width , double *top , double *bottom ,
                                  double *top_left , double *top_right , double *bottom_left ,
                                  double *bottom_right ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int font_start_x ;
  int font_end_x ;
  int font_width ;
  int line_start ;
  int line_end ;
  int line_height ;
  ho_bitmap *m_holes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  double tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 1337
  m_holes = (ho_bitmap *)((void *)0);
#line 1339
  *height = 0.0;
#line 1340
  *width = 0.0;
#line 1341
  *top = 0.0;
#line 1342
  *bottom = 0.0;
#line 1343
  *top_left = 0.0;
#line 1344
  *top_right = 0.0;
#line 1345
  *bottom_left = 0.0;
#line 1346
  *bottom_right = 0.0;
#line 1348
  m_holes = ho_font_holes(m_text, m_mask);
  }
#line 1349
  if (! m_holes) {
#line 1350
    return (-1);
  }
  {
#line 1352
  sum = ho_bitmap_filter_count_objects((ho_bitmap const   *)m_holes);
  }
#line 1353
  if (sum > 2) {
#line 1354
    return (-1);
  } else
#line 1353
  if (sum < 1) {
#line 1354
    return (-1);
  }
#line 1357
  x = (int )(m_mask->width / 2);
#line 1358
  y = 0;
  {
#line 1358
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1358
    if (y < (int )m_mask->height) {
#line 1358
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 1358
        tmp = 1;
      } else {
#line 1358
        tmp = 0;
      }
#line 1358
      if (tmp) {
#line 1358
        goto while_break;
      }
    } else {
#line 1358
      goto while_break;
    }
#line 1358
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1359
  line_start = y - 1;
  {
#line 1360
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1360
    if (y < (int )m_mask->height) {
#line 1360
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 1360
        tmp___0 = 1;
      } else {
#line 1360
        tmp___0 = 0;
      }
#line 1360
      if (! tmp___0) {
#line 1360
        goto while_break___0;
      }
    } else {
#line 1360
      goto while_break___0;
    }
#line 1360
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1361
  line_end = y;
#line 1362
  line_height = line_end - line_start;
#line 1365
  sum = 0;
#line 1366
  y = 0;
  {
#line 1366
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1366
    if (y < (int )m_mask->height) {
#line 1366
      if (! (sum == 0)) {
#line 1366
        goto while_break___1;
      }
    } else {
#line 1366
      goto while_break___1;
    }
#line 1367
    sum = 0;
#line 1367
    x = 0;
    {
#line 1367
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1367
      if (! (x < (int )m_text->width)) {
#line 1367
        goto while_break___2;
      }
#line 1368
      if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1368
        tmp___1 = 1;
      } else {
#line 1368
        tmp___1 = 0;
      }
#line 1368
      sum += tmp___1;
#line 1367
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1366
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1369
  font_start = y - 1;
#line 1370
  sum = 0;
#line 1371
  y = (int )(m_mask->height - 4);
  {
#line 1371
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1371
    if (y > font_start) {
#line 1371
      if (! (sum == 0)) {
#line 1371
        goto while_break___3;
      }
    } else {
#line 1371
      goto while_break___3;
    }
#line 1372
    sum = 0;
#line 1372
    x = 0;
    {
#line 1372
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1372
      if (! (x < (int )m_text->width)) {
#line 1372
        goto while_break___4;
      }
#line 1373
      if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1373
        tmp___2 = 1;
      } else {
#line 1373
        tmp___2 = 0;
      }
#line 1373
      sum += tmp___2;
#line 1372
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1371
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1374
  font_end = y + 1;
#line 1375
  font_height = font_end - font_start;
#line 1377
  if (! font_height) {
#line 1378
    return (-1);
  } else
#line 1377
  if (! line_height) {
#line 1378
    return (-1);
  }
#line 1380
  sum = 0;
#line 1381
  x = 0;
  {
#line 1381
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1381
    if (x < (int )m_mask->width) {
#line 1381
      if (! (sum == 0)) {
#line 1381
        goto while_break___5;
      }
    } else {
#line 1381
      goto while_break___5;
    }
#line 1382
    sum = 0;
#line 1382
    y = font_start;
    {
#line 1382
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1382
      if (! (y < font_end)) {
#line 1382
        goto while_break___6;
      }
#line 1383
      if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1383
        tmp___3 = 1;
      } else {
#line 1383
        tmp___3 = 0;
      }
#line 1383
      sum += tmp___3;
#line 1382
      y ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1381
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1384
  font_start_x = x - 1;
#line 1385
  sum = 0;
#line 1386
  x = (int )(m_mask->width - 1);
  {
#line 1386
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1386
    if (x > font_start_x) {
#line 1386
      if (! (sum == 0)) {
#line 1386
        goto while_break___7;
      }
    } else {
#line 1386
      goto while_break___7;
    }
#line 1387
    sum = 0;
#line 1387
    y = font_start;
    {
#line 1387
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1387
      if (! (y < font_end)) {
#line 1387
        goto while_break___8;
      }
#line 1388
      if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1388
        tmp___4 = 1;
      } else {
#line 1388
        tmp___4 = 0;
      }
#line 1388
      sum += tmp___4;
#line 1387
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1386
    x --;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1389
  font_end_x = x + 1;
#line 1390
  font_width = font_end_x - font_start_x;
#line 1392
  if (! font_width) {
#line 1393
    return (-1);
  }
#line 1395
  *height = (double )font_height / (double )line_height;
#line 1396
  *width = (double )font_width / (double )line_height;
#line 1398
  *top = (double )(line_start - font_start) / (double )line_height;
#line 1399
  *bottom = (double )(line_end - font_end) / (double )line_height;
#line 1402
  if (*top < 0.1) {
#line 1402
    if (*top > - 0.1) {
#line 1405
      if (*height < 1.1) {
#line 1405
        if (*height > 0.9) {
#line 1407
          tmp___5 = 0.0;
#line 1407
          *bottom = tmp___5;
#line 1407
          *top = tmp___5;
        } else {
#line 1412
          *bottom -= *top;
#line 1413
          *top = 0.0;
        }
      } else {
#line 1412
        *bottom -= *top;
#line 1413
        *top = 0.0;
      }
    } else {
#line 1402
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1416
  if (*bottom < 0.1) {
#line 1416
    if (*bottom > - 0.1) {
#line 1418
      *top -= *bottom;
#line 1419
      *bottom = 0.0;
    }
  }
#line 1423
  *height /= 2.0;
#line 1424
  if (*height > 1.0) {
#line 1425
    *height = 1.0;
  }
#line 1427
  *width /= 2.0;
#line 1428
  if (*width > 1.0) {
#line 1429
    *width = 1.0;
  }
#line 1431
  *top = (*top + 1.0) / 2.0;
#line 1432
  if (*top > 1.0) {
#line 1433
    *top = 1.0;
  }
#line 1434
  if (*top < 0.0) {
#line 1435
    *top = 0.0;
  }
#line 1437
  *bottom = (*bottom + 1.0) / 2.0;
#line 1438
  if (*bottom > 1.0) {
#line 1439
    *bottom = 1.0;
  }
#line 1440
  if (*bottom < 0.0) {
#line 1441
    *bottom = 0.0;
  }
#line 1444
  y = font_start;
#line 1444
  x = font_start_x;
  {
#line 1444
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1444
    if (x < font_start_x + font_width / 2) {
#line 1444
      if (y < font_start + font_height / 2) {
#line 1444
        if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1444
          tmp___6 = 1;
        } else {
#line 1444
          tmp___6 = 0;
        }
#line 1444
        if (tmp___6) {
#line 1444
          goto while_break___9;
        }
      } else {
#line 1444
        goto while_break___9;
      }
    } else {
#line 1444
      goto while_break___9;
    }
#line 1444
    x ++;
#line 1444
    y ++;
  }
  while_break___9: /* CIL Label */ ;
  }
#line 1448
  *top_left = (double )(x - font_start_x) / (double )(font_width / 2);
#line 1450
  if (*top_left > 1.0) {
#line 1451
    *top_left = 1.0;
  }
#line 1453
  y = font_end;
#line 1453
  x = font_start_x;
  {
#line 1453
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 1453
    if (x < font_start_x + font_width / 2) {
#line 1453
      if (y > font_start + font_height / 2) {
#line 1453
        if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1453
          tmp___7 = 1;
        } else {
#line 1453
          tmp___7 = 0;
        }
#line 1453
        if (tmp___7) {
#line 1453
          goto while_break___10;
        }
      } else {
#line 1453
        goto while_break___10;
      }
    } else {
#line 1453
      goto while_break___10;
    }
#line 1453
    x ++;
#line 1453
    y --;
  }
  while_break___10: /* CIL Label */ ;
  }
#line 1457
  *bottom_left = (double )(x - font_start_x) / (double )(font_width / 2);
#line 1459
  if (*bottom_left > 1.0) {
#line 1460
    *bottom_left = 1.0;
  }
#line 1462
  y = font_start;
#line 1462
  x = font_end_x;
  {
#line 1462
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1462
    if (x > font_start_x + font_width / 2) {
#line 1462
      if (y < font_start + font_height / 2) {
#line 1462
        if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1462
          tmp___8 = 1;
        } else {
#line 1462
          tmp___8 = 0;
        }
#line 1462
        if (tmp___8) {
#line 1462
          goto while_break___11;
        }
      } else {
#line 1462
        goto while_break___11;
      }
    } else {
#line 1462
      goto while_break___11;
    }
#line 1462
    x --;
#line 1462
    y ++;
  }
  while_break___11: /* CIL Label */ ;
  }
#line 1466
  *top_right = (double )(font_end_x - x) / (double )(font_width / 2);
#line 1468
  if (*top_right > 1.0) {
#line 1469
    *top_right = 1.0;
  }
#line 1471
  y = font_end;
#line 1471
  x = font_end_x;
  {
#line 1471
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 1471
    if (x > font_start_x + font_width / 2) {
#line 1471
      if (y > font_start + font_height / 2) {
#line 1471
        if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1471
          tmp___9 = 1;
        } else {
#line 1471
          tmp___9 = 0;
        }
#line 1471
        if (tmp___9) {
#line 1471
          goto while_break___12;
        }
      } else {
#line 1471
        goto while_break___12;
      }
    } else {
#line 1471
      goto while_break___12;
    }
#line 1471
    x --;
#line 1471
    y --;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 1475
  *bottom_right = (double )(font_end_x - x) / (double )(font_width / 2);
#line 1477
  if (*bottom_right > 1.0) {
#line 1478
    *bottom_right = 1.0;
  }
#line 1480
  return (0);
}
}
#line 1483 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_holes_edges(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                             double *has_top_left_edge , double *has_mid_left_edge ,
                             double *has_bottom_left_edge , double *has_top_right_edge ,
                             double *has_mid_right_edge , double *has_bottom_right_edge ,
                             double *has_left_top_edge , double *has_mid_top_edge ,
                             double *has_right_top_edge , double *has_left_bottom_edge ,
                             double *has_mid_bottom_edge , double *has_right_bottom_edge ) 
{ 
  int sum ;
  int x ;
  int y ;
  int font_start ;
  int font_end ;
  int font_height ;
  int font_start_x ;
  int font_end_x ;
  int font_width ;
  int line_start ;
  int line_end ;
  int line_height ;
  ho_bitmap *m_bars ;
  ho_bitmap *m_holes ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;

  {
  {
#line 1518
  m_bars = (ho_bitmap *)((void *)0);
#line 1520
  m_holes = (ho_bitmap *)((void *)0);
#line 1522
  *has_top_left_edge = 0.0;
#line 1523
  *has_mid_left_edge = 0.0;
#line 1524
  *has_bottom_left_edge = 0.0;
#line 1525
  *has_top_right_edge = 0.0;
#line 1526
  *has_mid_right_edge = 0.0;
#line 1527
  *has_bottom_right_edge = 0.0;
#line 1528
  *has_left_top_edge = 0.0;
#line 1529
  *has_mid_top_edge = 0.0;
#line 1530
  *has_right_top_edge = 0.0;
#line 1531
  *has_left_bottom_edge = 0.0;
#line 1532
  *has_mid_bottom_edge = 0.0;
#line 1533
  *has_right_bottom_edge = 0.0;
#line 1535
  m_holes = ho_font_holes(m_text, m_mask);
  }
#line 1536
  if (! m_holes) {
#line 1537
    return (-1);
  }
  {
#line 1539
  sum = ho_bitmap_filter_count_objects((ho_bitmap const   *)m_holes);
  }
#line 1540
  if (sum > 2) {
#line 1541
    return (-1);
  } else
#line 1540
  if (sum < 1) {
#line 1541
    return (-1);
  }
#line 1544
  x = (int )(m_mask->width / 2);
#line 1545
  y = 0;
  {
#line 1545
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1545
    if (y < (int )m_mask->height) {
#line 1545
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 1545
        tmp = 1;
      } else {
#line 1545
        tmp = 0;
      }
#line 1545
      if (tmp) {
#line 1545
        goto while_break;
      }
    } else {
#line 1545
      goto while_break;
    }
#line 1545
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1546
  line_start = y - 1;
  {
#line 1547
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1547
    if (y < (int )m_mask->height) {
#line 1547
      if (((int )*(m_mask->data + (x / 8 + y * (int )m_mask->rowstride)) & (128 >> x % 8)) > 0) {
#line 1547
        tmp___0 = 1;
      } else {
#line 1547
        tmp___0 = 0;
      }
#line 1547
      if (! tmp___0) {
#line 1547
        goto while_break___0;
      }
    } else {
#line 1547
      goto while_break___0;
    }
#line 1547
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1548
  line_end = y;
#line 1549
  line_height = line_end - line_start;
#line 1552
  sum = 0;
#line 1553
  y = 0;
  {
#line 1553
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 1553
    if (y < (int )m_mask->height) {
#line 1553
      if (! (sum == 0)) {
#line 1553
        goto while_break___1;
      }
    } else {
#line 1553
      goto while_break___1;
    }
#line 1554
    sum = 0;
#line 1554
    x = 0;
    {
#line 1554
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1554
      if (! (x < (int )m_text->width)) {
#line 1554
        goto while_break___2;
      }
#line 1555
      if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1555
        tmp___1 = 1;
      } else {
#line 1555
        tmp___1 = 0;
      }
#line 1555
      sum += tmp___1;
#line 1554
      x ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1553
    y ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1556
  font_start = y - 1;
#line 1557
  sum = 0;
#line 1558
  y = (int )(m_mask->height - 4);
  {
#line 1558
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 1558
    if (y > font_start) {
#line 1558
      if (! (sum == 0)) {
#line 1558
        goto while_break___3;
      }
    } else {
#line 1558
      goto while_break___3;
    }
#line 1559
    sum = 0;
#line 1559
    x = 0;
    {
#line 1559
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1559
      if (! (x < (int )m_text->width)) {
#line 1559
        goto while_break___4;
      }
#line 1560
      if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1560
        tmp___2 = 1;
      } else {
#line 1560
        tmp___2 = 0;
      }
#line 1560
      sum += tmp___2;
#line 1559
      x ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1558
    y --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 1561
  font_end = y + 1;
#line 1562
  font_height = font_end - font_start;
#line 1564
  if (! font_height) {
#line 1565
    return (-1);
  } else
#line 1564
  if (! line_height) {
#line 1565
    return (-1);
  }
#line 1567
  sum = 0;
#line 1568
  x = 0;
  {
#line 1568
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 1568
    if (x < (int )m_mask->width) {
#line 1568
      if (! (sum == 0)) {
#line 1568
        goto while_break___5;
      }
    } else {
#line 1568
      goto while_break___5;
    }
#line 1569
    sum = 0;
#line 1569
    y = font_start;
    {
#line 1569
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 1569
      if (! (y < font_end)) {
#line 1569
        goto while_break___6;
      }
#line 1570
      if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1570
        tmp___3 = 1;
      } else {
#line 1570
        tmp___3 = 0;
      }
#line 1570
      sum += tmp___3;
#line 1569
      y ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 1568
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 1571
  font_start_x = x - 1;
#line 1572
  sum = 0;
#line 1573
  x = (int )(m_mask->width - 1);
  {
#line 1573
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 1573
    if (x > font_start_x) {
#line 1573
      if (! (sum == 0)) {
#line 1573
        goto while_break___7;
      }
    } else {
#line 1573
      goto while_break___7;
    }
#line 1574
    sum = 0;
#line 1574
    y = font_start;
    {
#line 1574
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 1574
      if (! (y < font_end)) {
#line 1574
        goto while_break___8;
      }
#line 1575
      if (((int )*(m_holes->data + (x / 8 + y * m_holes->rowstride)) & (128 >> x % 8)) > 0) {
#line 1575
        tmp___4 = 1;
      } else {
#line 1575
        tmp___4 = 0;
      }
#line 1575
      sum += tmp___4;
#line 1574
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 1573
    x --;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 1576
  font_end_x = x + 1;
#line 1577
  font_width = font_end_x - font_start_x;
#line 1579
  if (! font_width) {
#line 1580
    return (-1);
  }
  {
#line 1583
  m_bars = ho_font_edges_left((ho_bitmap const   *)m_holes, m_mask);
  }
#line 1584
  if (! m_bars) {
#line 1585
    return (-1);
  }
#line 1588
  x = m_bars->width / 2;
#line 1589
  y = font_start;
  {
#line 1589
  while (1) {
    while_continue___9: /* CIL Label */ ;
#line 1589
    if (! (y < font_end)) {
#line 1589
      goto while_break___9;
    }
#line 1592
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 1592
      tmp___6 = 1;
    } else {
#line 1592
      tmp___6 = 0;
    }
#line 1592
    if (tmp___6) {
#line 1595
      if (y - font_start < font_height / 3) {
#line 1596
        *has_top_left_edge = 1.0;
      } else
#line 1597
      if (y - font_start < (2 * font_height) / 3) {
#line 1598
        *has_mid_left_edge = 1.0;
      } else {
#line 1600
        *has_bottom_left_edge = 1.0;
      }
#line 1603
      y ++;
      {
#line 1604
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1604
        if (y < font_end) {
#line 1604
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 1604
            tmp___5 = 1;
          } else {
#line 1604
            tmp___5 = 0;
          }
#line 1604
          if (! tmp___5) {
#line 1604
            goto while_break___10;
          }
        } else {
#line 1604
          goto while_break___10;
        }
#line 1604
        y ++;
      }
      while_break___10: /* CIL Label */ ;
      }
    }
#line 1589
    y ++;
  }
  while_break___9: /* CIL Label */ ;
  }
  {
#line 1609
  ho_bitmap_free(m_bars);
#line 1610
  m_bars = ho_font_edges_right((ho_bitmap const   *)m_holes, m_mask);
  }
#line 1611
  if (! m_bars) {
#line 1612
    return (-1);
  }
#line 1615
  x = m_bars->width / 2;
#line 1616
  y = font_start;
  {
#line 1616
  while (1) {
    while_continue___11: /* CIL Label */ ;
#line 1616
    if (! (y < font_end)) {
#line 1616
      goto while_break___11;
    }
#line 1619
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 1619
      tmp___8 = 1;
    } else {
#line 1619
      tmp___8 = 0;
    }
#line 1619
    if (tmp___8) {
#line 1622
      if (y - font_start < font_height / 3) {
#line 1623
        *has_top_right_edge = 1.0;
      } else
#line 1624
      if (y - font_start < (2 * font_height) / 3) {
#line 1625
        *has_mid_right_edge = 1.0;
      } else {
#line 1627
        *has_bottom_right_edge = 1.0;
      }
#line 1630
      y ++;
      {
#line 1631
      while (1) {
        while_continue___12: /* CIL Label */ ;
#line 1631
        if (y < font_end) {
#line 1631
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 1631
            tmp___7 = 1;
          } else {
#line 1631
            tmp___7 = 0;
          }
#line 1631
          if (! tmp___7) {
#line 1631
            goto while_break___12;
          }
        } else {
#line 1631
          goto while_break___12;
        }
#line 1631
        y ++;
      }
      while_break___12: /* CIL Label */ ;
      }
    }
#line 1616
    y ++;
  }
  while_break___11: /* CIL Label */ ;
  }
  {
#line 1635
  ho_bitmap_free(m_bars);
#line 1636
  m_bars = ho_font_edges_top((ho_bitmap const   *)m_holes, m_mask);
  }
#line 1637
  if (! m_bars) {
#line 1638
    return (-1);
  }
#line 1641
  y = m_bars->height / 2;
#line 1642
  x = 0;
  {
#line 1642
  while (1) {
    while_continue___13: /* CIL Label */ ;
#line 1642
    if (! (x < m_bars->width)) {
#line 1642
      goto while_break___13;
    }
#line 1645
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 1645
      tmp___10 = 1;
    } else {
#line 1645
      tmp___10 = 0;
    }
#line 1645
    if (tmp___10) {
#line 1648
      if (x < m_bars->width / 3) {
#line 1649
        *has_left_top_edge = 1.0;
      } else
#line 1650
      if (x < (2 * m_bars->width) / 3) {
#line 1651
        *has_mid_top_edge = 1.0;
      } else {
#line 1653
        *has_right_top_edge = 1.0;
      }
#line 1656
      x ++;
      {
#line 1657
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 1657
        if (x < m_bars->width) {
#line 1657
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 1657
            tmp___9 = 1;
          } else {
#line 1657
            tmp___9 = 0;
          }
#line 1657
          if (! tmp___9) {
#line 1657
            goto while_break___14;
          }
        } else {
#line 1657
          goto while_break___14;
        }
#line 1657
        x ++;
      }
      while_break___14: /* CIL Label */ ;
      }
    }
#line 1642
    x ++;
  }
  while_break___13: /* CIL Label */ ;
  }
  {
#line 1662
  ho_bitmap_free(m_bars);
#line 1663
  m_bars = ho_font_edges_bottom((ho_bitmap const   *)m_holes, m_mask);
  }
#line 1664
  if (! m_bars) {
#line 1665
    return (-1);
  }
#line 1668
  y = m_bars->height / 2;
#line 1669
  x = 0;
  {
#line 1669
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 1669
    if (! (x < m_bars->width)) {
#line 1669
      goto while_break___15;
    }
#line 1672
    if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 1672
      tmp___12 = 1;
    } else {
#line 1672
      tmp___12 = 0;
    }
#line 1672
    if (tmp___12) {
#line 1675
      if (x < m_bars->width / 3) {
#line 1676
        *has_left_bottom_edge = 1.0;
      } else
#line 1677
      if (x < (2 * m_bars->width) / 3) {
#line 1678
        *has_mid_bottom_edge = 1.0;
      } else {
#line 1680
        *has_right_bottom_edge = 1.0;
      }
#line 1683
      x ++;
      {
#line 1684
      while (1) {
        while_continue___16: /* CIL Label */ ;
#line 1684
        if (x < m_bars->width) {
#line 1684
          if (((int )*(m_bars->data + (x / 8 + y * m_bars->rowstride)) & (128 >> x % 8)) > 0) {
#line 1684
            tmp___11 = 1;
          } else {
#line 1684
            tmp___11 = 0;
          }
#line 1684
          if (! tmp___11) {
#line 1684
            goto while_break___16;
          }
        } else {
#line 1684
          goto while_break___16;
        }
#line 1684
        x ++;
      }
      while_break___16: /* CIL Label */ ;
      }
    }
#line 1669
    x ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 1688
  ho_bitmap_free(m_bars);
  }
#line 1690
  return (0);
}
}
#line 1693 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_create_array_in(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                 double *array_in ) 
{ 
  int i ;
  double height ;
  double width ;
  double top ;
  double bottom ;
  double top_left ;
  double top_mid ;
  double top_right ;
  double bottom_left ;
  double bottom_mid ;
  double bottom_right ;
  double mid_left ;
  double mid_right ;
  double has_two_hlines_up ;
  double has_two_hlines_down ;
  double has_three_hlines_up ;
  double has_three_hlines_down ;
  double has_top_bar ;
  double has_mid_hbar ;
  double has_bottom_bar ;
  double has_left_bar ;
  double has_mid_vbar ;
  double has_right_bar ;
  double has_diagonal_bar ;
  double has_diagonal_left_bar ;
  double has_top_left_edge ;
  double has_mid_left_edge ;
  double has_bottom_left_edge ;
  double has_top_right_edge ;
  double has_mid_right_edge ;
  double has_bottom_right_edge ;
  double has_left_top_edge ;
  double has_mid_top_edge ;
  double has_right_top_edge ;
  double has_left_bottom_edge ;
  double has_mid_bottom_edge ;
  double has_right_bottom_edge ;
  double has_top_left_notch ;
  double has_mid_left_notch ;
  double has_bottom_left_notch ;
  double has_top_right_notch ;
  double has_mid_right_notch ;
  double has_bottom_right_notch ;
  double has_left_top_notch ;
  double has_mid_top_notch ;
  double has_right_top_notch ;
  double has_left_bottom_notch ;
  double has_mid_bottom_notch ;
  double has_right_bottom_notch ;
  double has_one_hole ;
  double has_two_holes ;
  double has_hey_part ;
  double has_dot_part ;
  double has_comma_part ;
  double has_top_left_end ;
  double has_top_mid_end ;
  double has_top_right_end ;
  double has_mid_left_end ;
  double has_mid_mid_end ;
  double has_mid_right_end ;
  double has_bottom_left_end ;
  double has_bottom_mid_end ;
  double has_bottom_right_end ;
  double has_top_left_cross ;
  double has_top_mid_cross ;
  double has_top_right_cross ;
  double has_mid_left_cross ;
  double has_mid_mid_cross ;
  double has_mid_right_cross ;
  double has_bottom_left_cross ;
  double has_bottom_mid_cross ;
  double has_bottom_right_cross ;

  {
#line 1842
  i = 0;
  {
#line 1842
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1842
    if (! (i < 104)) {
#line 1842
      goto while_break;
    }
#line 1843
    *(array_in + i) = 0.0;
#line 1842
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1847
  ho_recognize_dimentions(m_text, m_mask, & height, & width, & top, & bottom, & top_left,
                          & top_mid, & top_right, & mid_left, & mid_right, & bottom_left,
                          & bottom_mid, & bottom_right, & has_two_hlines_up, & has_two_hlines_down,
                          & has_three_hlines_up, & has_three_hlines_down);
#line 1855
  *(array_in + 0) = height;
#line 1856
  *(array_in + 1) = width;
#line 1857
  *(array_in + 2) = width / height;
  }
#line 1858
  if (*(array_in + 2) > 1.0) {
#line 1859
    *(array_in + 2) = 1.0;
  }
  {
#line 1860
  *(array_in + 3) = top;
#line 1861
  *(array_in + 4) = bottom;
#line 1862
  *(array_in + 5) = top_left;
#line 1863
  *(array_in + 6) = top_mid;
#line 1864
  *(array_in + 7) = top_right;
#line 1865
  *(array_in + 8) = mid_left;
#line 1866
  *(array_in + 9) = mid_right;
#line 1867
  *(array_in + 10) = bottom_left;
#line 1868
  *(array_in + 11) = bottom_mid;
#line 1869
  *(array_in + 12) = bottom_right;
#line 1871
  *(array_in + 13) = has_two_hlines_up;
#line 1872
  *(array_in + 14) = has_two_hlines_down;
#line 1873
  *(array_in + 15) = has_three_hlines_up;
#line 1874
  *(array_in + 16) = has_three_hlines_down;
#line 1876
  ho_recognize_bars(m_text, m_mask, & has_top_bar, & has_mid_hbar, & has_bottom_bar,
                    & has_left_bar, & has_mid_vbar, & has_right_bar, & has_diagonal_bar,
                    & has_diagonal_left_bar);
#line 1882
  *(array_in + 17) = has_top_bar;
#line 1883
  *(array_in + 18) = has_mid_hbar;
#line 1884
  *(array_in + 19) = has_bottom_bar;
#line 1886
  *(array_in + 20) = has_left_bar;
#line 1887
  *(array_in + 21) = has_mid_vbar;
#line 1888
  *(array_in + 22) = has_right_bar;
#line 1890
  *(array_in + 23) = has_diagonal_bar;
#line 1891
  *(array_in + 24) = has_diagonal_left_bar;
#line 1893
  ho_recognize_edges(m_text, m_mask, & has_top_left_edge, & has_mid_left_edge, & has_bottom_left_edge,
                     & has_top_right_edge, & has_mid_right_edge, & has_bottom_right_edge,
                     & has_left_top_edge, & has_mid_top_edge, & has_right_top_edge,
                     & has_left_bottom_edge, & has_mid_bottom_edge, & has_right_bottom_edge);
#line 1905
  *(array_in + 25) = has_top_left_edge;
#line 1906
  *(array_in + 26) = has_mid_left_edge;
#line 1907
  *(array_in + 27) = has_bottom_left_edge;
#line 1909
  *(array_in + 28) = has_top_right_edge;
#line 1910
  *(array_in + 29) = has_mid_right_edge;
#line 1911
  *(array_in + 30) = has_bottom_right_edge;
#line 1913
  *(array_in + 31) = has_left_top_edge;
#line 1914
  *(array_in + 32) = has_mid_top_edge;
#line 1915
  *(array_in + 33) = has_right_top_edge;
#line 1917
  *(array_in + 34) = has_left_bottom_edge;
#line 1918
  *(array_in + 35) = has_mid_bottom_edge;
#line 1919
  *(array_in + 36) = has_right_bottom_edge;
#line 1921
  ho_recognize_notches(m_text, m_mask, & has_top_left_notch, & has_mid_left_notch,
                       & has_bottom_left_notch, & has_top_right_notch, & has_mid_right_notch,
                       & has_bottom_right_notch, & has_left_top_notch, & has_mid_top_notch,
                       & has_right_top_notch, & has_left_bottom_notch, & has_mid_bottom_notch,
                       & has_right_bottom_notch);
#line 1934
  *(array_in + 37) = has_top_left_notch;
#line 1935
  *(array_in + 38) = has_mid_left_notch;
#line 1936
  *(array_in + 39) = has_bottom_left_notch;
#line 1938
  *(array_in + 40) = has_top_right_notch;
#line 1939
  *(array_in + 41) = has_mid_right_notch;
#line 1940
  *(array_in + 42) = has_bottom_right_notch;
#line 1942
  *(array_in + 43) = has_left_top_notch;
#line 1943
  *(array_in + 44) = has_mid_top_notch;
#line 1944
  *(array_in + 45) = has_right_top_notch;
#line 1946
  *(array_in + 46) = has_left_bottom_notch;
#line 1947
  *(array_in + 47) = has_mid_bottom_notch;
#line 1948
  *(array_in + 48) = has_right_bottom_notch;
#line 1950
  ho_recognize_ends(m_text, m_mask, & has_top_left_end, & has_top_mid_end, & has_top_right_end,
                    & has_mid_left_end, & has_mid_mid_end, & has_mid_right_end, & has_bottom_left_end,
                    & has_bottom_mid_end, & has_bottom_right_end, & has_top_left_cross,
                    & has_top_mid_cross, & has_top_right_cross, & has_mid_left_cross,
                    & has_mid_mid_cross, & has_mid_right_cross, & has_bottom_left_cross,
                    & has_bottom_mid_cross, & has_bottom_right_cross);
#line 1969
  *(array_in + 49) = has_top_left_end;
#line 1970
  *(array_in + 50) = has_top_mid_end;
#line 1971
  *(array_in + 51) = has_top_right_end;
#line 1973
  *(array_in + 52) = has_mid_left_end;
#line 1974
  *(array_in + 53) = has_mid_mid_end;
#line 1975
  *(array_in + 54) = has_mid_right_end;
#line 1977
  *(array_in + 55) = has_bottom_left_end;
#line 1978
  *(array_in + 56) = has_bottom_mid_end;
#line 1979
  *(array_in + 57) = has_bottom_right_end;
#line 1981
  *(array_in + 58) = has_top_left_cross;
#line 1982
  *(array_in + 59) = has_top_mid_cross;
#line 1983
  *(array_in + 60) = has_top_right_cross;
#line 1985
  *(array_in + 61) = has_mid_left_cross;
#line 1986
  *(array_in + 62) = has_mid_mid_cross;
#line 1987
  *(array_in + 63) = has_mid_right_cross;
#line 1989
  *(array_in + 64) = has_bottom_left_cross;
#line 1990
  *(array_in + 65) = has_bottom_mid_cross;
#line 1991
  *(array_in + 66) = has_bottom_right_cross;
#line 1993
  ho_recognize_parts(m_text, m_mask, & has_one_hole, & has_two_holes, & has_hey_part,
                     & has_dot_part, & has_comma_part);
#line 1997
  *(array_in + 67) = has_one_hole;
#line 1998
  *(array_in + 68) = has_two_holes;
#line 1999
  *(array_in + 69) = has_hey_part;
#line 2000
  *(array_in + 70) = has_dot_part;
#line 2001
  *(array_in + 71) = has_comma_part;
#line 2003
  ho_recognize_holes_edges(m_text, m_mask, & has_top_left_edge, & has_mid_left_edge,
                           & has_bottom_left_edge, & has_top_right_edge, & has_mid_right_edge,
                           & has_bottom_right_edge, & has_left_top_edge, & has_mid_top_edge,
                           & has_right_top_edge, & has_left_bottom_edge, & has_mid_bottom_edge,
                           & has_right_bottom_edge);
#line 2015
  *(array_in + 72) = has_top_left_edge;
#line 2016
  *(array_in + 73) = has_mid_left_edge;
#line 2017
  *(array_in + 74) = has_bottom_left_edge;
#line 2019
  *(array_in + 75) = has_top_right_edge;
#line 2020
  *(array_in + 76) = has_mid_right_edge;
#line 2021
  *(array_in + 77) = has_bottom_right_edge;
#line 2023
  *(array_in + 78) = has_left_top_edge;
#line 2024
  *(array_in + 79) = has_mid_top_edge;
#line 2025
  *(array_in + 80) = has_right_top_edge;
#line 2027
  *(array_in + 81) = has_left_bottom_edge;
#line 2028
  *(array_in + 82) = has_mid_bottom_edge;
#line 2029
  *(array_in + 83) = has_right_bottom_edge;
#line 2031
  ho_recognize_holes_dimentions(m_text, m_mask, & height, & width, & top, & bottom,
                                & top_left, & top_right, & bottom_left, & bottom_right);
#line 2035
  *(array_in + 84) = height;
#line 2036
  *(array_in + 85) = width;
#line 2037
  *(array_in + 86) = top;
#line 2038
  *(array_in + 87) = bottom;
#line 2039
  *(array_in + 88) = top_left;
#line 2040
  *(array_in + 89) = top_right;
#line 2041
  *(array_in + 90) = bottom_left;
#line 2042
  *(array_in + 91) = bottom_right;
#line 2044
  ho_recognize_edges_big(m_text, m_mask, & has_top_left_edge, & has_mid_left_edge,
                         & has_bottom_left_edge, & has_top_right_edge, & has_mid_right_edge,
                         & has_bottom_right_edge, & has_left_top_edge, & has_mid_top_edge,
                         & has_right_top_edge, & has_left_bottom_edge, & has_mid_bottom_edge,
                         & has_right_bottom_edge);
#line 2056
  *(array_in + 92) = has_top_left_edge;
#line 2057
  *(array_in + 93) = has_mid_left_edge;
#line 2058
  *(array_in + 94) = has_bottom_left_edge;
#line 2060
  *(array_in + 95) = has_top_right_edge;
#line 2061
  *(array_in + 96) = has_mid_right_edge;
#line 2062
  *(array_in + 97) = has_bottom_right_edge;
#line 2064
  *(array_in + 98) = has_left_top_edge;
#line 2065
  *(array_in + 99) = has_mid_top_edge;
#line 2066
  *(array_in + 100) = has_right_top_edge;
#line 2068
  *(array_in + 101) = has_left_bottom_edge;
#line 2069
  *(array_in + 102) = has_mid_bottom_edge;
#line 2070
  *(array_in + 103) = has_right_bottom_edge;
  }
#line 2072
  return (0);
}
}
#line 2075 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
double ho_recognize_array(double const   *array_in , int const   sign_index , int font_code ) 
{ 
  double return_value ;

  {
#line 2080
  if (font_code == 0) {
    {
#line 2084
    if (sign_index == 1) {
#line 2084
      goto case_1;
    }
#line 2087
    if (sign_index == 2) {
#line 2087
      goto case_2;
    }
#line 2090
    if (sign_index == 3) {
#line 2090
      goto case_3;
    }
#line 2093
    if (sign_index == 4) {
#line 2093
      goto case_4;
    }
#line 2096
    if (sign_index == 5) {
#line 2096
      goto case_5;
    }
#line 2099
    if (sign_index == 6) {
#line 2099
      goto case_6;
    }
#line 2102
    if (sign_index == 7) {
#line 2102
      goto case_7;
    }
#line 2105
    if (sign_index == 8) {
#line 2105
      goto case_8;
    }
#line 2108
    if (sign_index == 9) {
#line 2108
      goto case_9;
    }
#line 2111
    if (sign_index == 10) {
#line 2111
      goto case_10;
    }
#line 2114
    if (sign_index == 11) {
#line 2114
      goto case_11;
    }
#line 2117
    if (sign_index == 12) {
#line 2117
      goto case_12;
    }
#line 2120
    if (sign_index == 13) {
#line 2120
      goto case_13;
    }
#line 2123
    if (sign_index == 14) {
#line 2123
      goto case_14;
    }
#line 2126
    if (sign_index == 15) {
#line 2126
      goto case_15;
    }
#line 2129
    if (sign_index == 16) {
#line 2129
      goto case_16;
    }
#line 2132
    if (sign_index == 17) {
#line 2132
      goto case_17;
    }
#line 2135
    if (sign_index == 18) {
#line 2135
      goto case_18;
    }
#line 2138
    if (sign_index == 19) {
#line 2138
      goto case_19;
    }
#line 2141
    if (sign_index == 20) {
#line 2141
      goto case_20;
    }
#line 2144
    if (sign_index == 21) {
#line 2144
      goto case_21;
    }
#line 2147
    if (sign_index == 22) {
#line 2147
      goto case_22;
    }
#line 2150
    if (sign_index == 23) {
#line 2150
      goto case_23;
    }
#line 2153
    if (sign_index == 24) {
#line 2153
      goto case_24;
    }
#line 2156
    if (sign_index == 25) {
#line 2156
      goto case_25;
    }
#line 2159
    if (sign_index == 26) {
#line 2159
      goto case_26;
    }
#line 2162
    if (sign_index == 27) {
#line 2162
      goto case_27;
    }
#line 2165
    if (sign_index == 28) {
#line 2165
      goto case_28;
    }
#line 2168
    if (sign_index == 29) {
#line 2168
      goto case_29;
    }
#line 2171
    if (sign_index == 30) {
#line 2171
      goto case_30;
    }
#line 2174
    if (sign_index == 31) {
#line 2174
      goto case_31;
    }
#line 2177
    if (sign_index == 32) {
#line 2177
      goto case_32;
    }
#line 2180
    if (sign_index == 33) {
#line 2180
      goto case_33;
    }
#line 2183
    if (sign_index == 34) {
#line 2183
      goto case_34;
    }
#line 2186
    if (sign_index == 35) {
#line 2186
      goto case_35;
    }
#line 2189
    if (sign_index == 36) {
#line 2189
      goto case_36;
    }
#line 2192
    if (sign_index == 37) {
#line 2192
      goto case_37;
    }
#line 2195
    if (sign_index == 38) {
#line 2195
      goto case_38;
    }
#line 2198
    if (sign_index == 39) {
#line 2198
      goto case_39;
    }
#line 2201
    if (sign_index == 40) {
#line 2201
      goto case_40;
    }
#line 2204
    if (sign_index == 41) {
#line 2204
      goto case_41;
    }
#line 2207
    if (sign_index == 42) {
#line 2207
      goto case_42;
    }
#line 2210
    if (sign_index == 43) {
#line 2210
      goto case_43;
    }
#line 2213
    if (sign_index == 44) {
#line 2213
      goto case_44;
    }
#line 2216
    if (sign_index == 45) {
#line 2216
      goto case_45;
    }
#line 2219
    if (sign_index == 46) {
#line 2219
      goto case_46;
    }
#line 2222
    if (sign_index == 47) {
#line 2222
      goto case_47;
    }
#line 2225
    if (sign_index == 48) {
#line 2225
      goto case_48;
    }
#line 2228
    if (sign_index == 49) {
#line 2228
      goto case_49;
    }
#line 2231
    if (sign_index == 50) {
#line 2231
      goto case_50;
    }
#line 2234
    goto switch_default;
    case_1: /* CIL Label */ 
    {
#line 2085
    return_value = ho_recognize_font_1_alef(array_in);
    }
#line 2086
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 2088
    return_value = ho_recognize_font_1_bet(array_in);
    }
#line 2089
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 2091
    return_value = ho_recognize_font_1_gimal(array_in);
    }
#line 2092
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 2094
    return_value = ho_recognize_font_1_dalet(array_in);
    }
#line 2095
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 2097
    return_value = ho_recognize_font_1_hey(array_in);
    }
#line 2098
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 2100
    return_value = ho_recognize_font_1_vav(array_in);
    }
#line 2101
    goto switch_break;
    case_7: /* CIL Label */ 
    {
#line 2103
    return_value = ho_recognize_font_1_zayin(array_in);
    }
#line 2104
    goto switch_break;
    case_8: /* CIL Label */ 
    {
#line 2106
    return_value = ho_recognize_font_1_het(array_in);
    }
#line 2107
    goto switch_break;
    case_9: /* CIL Label */ 
    {
#line 2109
    return_value = ho_recognize_font_1_tet(array_in);
    }
#line 2110
    goto switch_break;
    case_10: /* CIL Label */ 
    {
#line 2112
    return_value = ho_recognize_font_1_yud(array_in);
    }
#line 2113
    goto switch_break;
    case_11: /* CIL Label */ 
    {
#line 2115
    return_value = ho_recognize_font_1_caf(array_in);
    }
#line 2116
    goto switch_break;
    case_12: /* CIL Label */ 
    {
#line 2118
    return_value = ho_recognize_font_1_caf_sofit(array_in);
    }
#line 2119
    goto switch_break;
    case_13: /* CIL Label */ 
    {
#line 2121
    return_value = ho_recognize_font_1_lamed(array_in);
    }
#line 2122
    goto switch_break;
    case_14: /* CIL Label */ 
    {
#line 2124
    return_value = ho_recognize_font_1_mem(array_in);
    }
#line 2125
    goto switch_break;
    case_15: /* CIL Label */ 
    {
#line 2127
    return_value = ho_recognize_font_1_mem_sofit(array_in);
    }
#line 2128
    goto switch_break;
    case_16: /* CIL Label */ 
    {
#line 2130
    return_value = ho_recognize_font_1_nun(array_in);
    }
#line 2131
    goto switch_break;
    case_17: /* CIL Label */ 
    {
#line 2133
    return_value = ho_recognize_font_1_nun_sofit(array_in);
    }
#line 2134
    goto switch_break;
    case_18: /* CIL Label */ 
    {
#line 2136
    return_value = ho_recognize_font_1_samech(array_in);
    }
#line 2137
    goto switch_break;
    case_19: /* CIL Label */ 
    {
#line 2139
    return_value = ho_recognize_font_1_ayin(array_in);
    }
#line 2140
    goto switch_break;
    case_20: /* CIL Label */ 
    {
#line 2142
    return_value = ho_recognize_font_1_pey(array_in);
    }
#line 2143
    goto switch_break;
    case_21: /* CIL Label */ 
    {
#line 2145
    return_value = ho_recognize_font_1_pey_sofit(array_in);
    }
#line 2146
    goto switch_break;
    case_22: /* CIL Label */ 
    {
#line 2148
    return_value = ho_recognize_font_1_tzadi(array_in);
    }
#line 2149
    goto switch_break;
    case_23: /* CIL Label */ 
    {
#line 2151
    return_value = ho_recognize_font_1_tzadi_sofit(array_in);
    }
#line 2152
    goto switch_break;
    case_24: /* CIL Label */ 
    {
#line 2154
    return_value = ho_recognize_font_1_kuf(array_in);
    }
#line 2155
    goto switch_break;
    case_25: /* CIL Label */ 
    {
#line 2157
    return_value = ho_recognize_font_1_resh(array_in);
    }
#line 2158
    goto switch_break;
    case_26: /* CIL Label */ 
    {
#line 2160
    return_value = ho_recognize_font_1_shin(array_in);
    }
#line 2161
    goto switch_break;
    case_27: /* CIL Label */ 
    {
#line 2163
    return_value = ho_recognize_font_1_tav(array_in);
    }
#line 2164
    goto switch_break;
    case_28: /* CIL Label */ 
    {
#line 2166
    return_value = ho_recognize_font_1_dot(array_in);
    }
#line 2167
    goto switch_break;
    case_29: /* CIL Label */ 
    {
#line 2169
    return_value = ho_recognize_font_1_comma(array_in);
    }
#line 2170
    goto switch_break;
    case_30: /* CIL Label */ 
    {
#line 2172
    return_value = ho_recognize_font_1_tag(array_in);
    }
#line 2173
    goto switch_break;
    case_31: /* CIL Label */ 
    {
#line 2175
    return_value = ho_recognize_font_1_two_tags(array_in);
    }
#line 2176
    goto switch_break;
    case_32: /* CIL Label */ 
    {
#line 2178
    return_value = ho_recognize_font_1_question(array_in);
    }
#line 2179
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 2181
    return_value = ho_recognize_font_1_exclem(array_in);
    }
#line 2182
    goto switch_break;
    case_34: /* CIL Label */ 
    {
#line 2184
    return_value = ho_recognize_font_1_dot_dot(array_in);
    }
#line 2185
    goto switch_break;
    case_35: /* CIL Label */ 
    {
#line 2187
    return_value = ho_recognize_font_1_dot_comma(array_in);
    }
#line 2188
    goto switch_break;
    case_36: /* CIL Label */ 
    {
#line 2190
    return_value = ho_recognize_font_1_open(array_in);
    }
#line 2191
    goto switch_break;
    case_37: /* CIL Label */ 
    {
#line 2193
    return_value = ho_recognize_font_1_close(array_in);
    }
#line 2194
    goto switch_break;
    case_38: /* CIL Label */ 
    {
#line 2196
    return_value = ho_recognize_font_1_minus(array_in);
    }
#line 2197
    goto switch_break;
    case_39: /* CIL Label */ 
    {
#line 2199
    return_value = ho_recognize_font_1_plus(array_in);
    }
#line 2200
    goto switch_break;
    case_40: /* CIL Label */ 
    {
#line 2202
    return_value = ho_recognize_font_1_div(array_in);
    }
#line 2203
    goto switch_break;
    case_41: /* CIL Label */ 
    {
#line 2205
    return_value = ho_recognize_font_1_zero(array_in);
    }
#line 2206
    goto switch_break;
    case_42: /* CIL Label */ 
    {
#line 2208
    return_value = ho_recognize_font_1_one(array_in);
    }
#line 2209
    goto switch_break;
    case_43: /* CIL Label */ 
    {
#line 2211
    return_value = ho_recognize_font_1_two(array_in);
    }
#line 2212
    goto switch_break;
    case_44: /* CIL Label */ 
    {
#line 2214
    return_value = ho_recognize_font_1_three(array_in);
    }
#line 2215
    goto switch_break;
    case_45: /* CIL Label */ 
    {
#line 2217
    return_value = ho_recognize_font_1_four(array_in);
    }
#line 2218
    goto switch_break;
    case_46: /* CIL Label */ 
    {
#line 2220
    return_value = ho_recognize_font_1_five(array_in);
    }
#line 2221
    goto switch_break;
    case_47: /* CIL Label */ 
    {
#line 2223
    return_value = ho_recognize_font_1_six(array_in);
    }
#line 2224
    goto switch_break;
    case_48: /* CIL Label */ 
    {
#line 2226
    return_value = ho_recognize_font_1_seven(array_in);
    }
#line 2227
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 2229
    return_value = ho_recognize_font_1_eight(array_in);
    }
#line 2230
    goto switch_break;
    case_50: /* CIL Label */ 
    {
#line 2232
    return_value = ho_recognize_font_1_nine(array_in);
    }
#line 2233
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 2235
    return_value = 0.0;
#line 2236
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  } else
#line 2240
  if (font_code == 1) {
    {
#line 2244
    if (sign_index == 1) {
#line 2244
      goto case_1___0;
    }
#line 2247
    if (sign_index == 2) {
#line 2247
      goto case_2___0;
    }
#line 2250
    if (sign_index == 3) {
#line 2250
      goto case_3___0;
    }
#line 2253
    if (sign_index == 4) {
#line 2253
      goto case_4___0;
    }
#line 2256
    if (sign_index == 5) {
#line 2256
      goto case_5___0;
    }
#line 2259
    if (sign_index == 6) {
#line 2259
      goto case_6___0;
    }
#line 2262
    if (sign_index == 7) {
#line 2262
      goto case_7___0;
    }
#line 2265
    if (sign_index == 8) {
#line 2265
      goto case_8___0;
    }
#line 2268
    if (sign_index == 9) {
#line 2268
      goto case_9___0;
    }
#line 2271
    if (sign_index == 10) {
#line 2271
      goto case_10___0;
    }
#line 2274
    if (sign_index == 11) {
#line 2274
      goto case_11___0;
    }
#line 2277
    if (sign_index == 12) {
#line 2277
      goto case_12___0;
    }
#line 2280
    if (sign_index == 13) {
#line 2280
      goto case_13___0;
    }
#line 2283
    if (sign_index == 14) {
#line 2283
      goto case_14___0;
    }
#line 2286
    if (sign_index == 15) {
#line 2286
      goto case_15___0;
    }
#line 2289
    if (sign_index == 16) {
#line 2289
      goto case_16___0;
    }
#line 2292
    if (sign_index == 17) {
#line 2292
      goto case_17___0;
    }
#line 2295
    if (sign_index == 18) {
#line 2295
      goto case_18___0;
    }
#line 2298
    if (sign_index == 19) {
#line 2298
      goto case_19___0;
    }
#line 2301
    if (sign_index == 20) {
#line 2301
      goto case_20___0;
    }
#line 2304
    if (sign_index == 21) {
#line 2304
      goto case_21___0;
    }
#line 2307
    if (sign_index == 22) {
#line 2307
      goto case_22___0;
    }
#line 2310
    if (sign_index == 23) {
#line 2310
      goto case_23___0;
    }
#line 2313
    if (sign_index == 24) {
#line 2313
      goto case_24___0;
    }
#line 2316
    if (sign_index == 25) {
#line 2316
      goto case_25___0;
    }
#line 2319
    if (sign_index == 26) {
#line 2319
      goto case_26___0;
    }
#line 2322
    if (sign_index == 27) {
#line 2322
      goto case_27___0;
    }
#line 2325
    if (sign_index == 28) {
#line 2325
      goto case_28___0;
    }
#line 2328
    if (sign_index == 29) {
#line 2328
      goto case_29___0;
    }
#line 2331
    if (sign_index == 30) {
#line 2331
      goto case_30___0;
    }
#line 2334
    if (sign_index == 31) {
#line 2334
      goto case_31___0;
    }
#line 2337
    if (sign_index == 32) {
#line 2337
      goto case_32___0;
    }
#line 2340
    if (sign_index == 33) {
#line 2340
      goto case_33___0;
    }
#line 2343
    if (sign_index == 34) {
#line 2343
      goto case_34___0;
    }
#line 2346
    if (sign_index == 35) {
#line 2346
      goto case_35___0;
    }
#line 2349
    if (sign_index == 36) {
#line 2349
      goto case_36___0;
    }
#line 2352
    if (sign_index == 37) {
#line 2352
      goto case_37___0;
    }
#line 2355
    if (sign_index == 38) {
#line 2355
      goto case_38___0;
    }
#line 2358
    if (sign_index == 39) {
#line 2358
      goto case_39___0;
    }
#line 2361
    if (sign_index == 40) {
#line 2361
      goto case_40___0;
    }
#line 2364
    if (sign_index == 41) {
#line 2364
      goto case_41___0;
    }
#line 2367
    if (sign_index == 42) {
#line 2367
      goto case_42___0;
    }
#line 2370
    if (sign_index == 43) {
#line 2370
      goto case_43___0;
    }
#line 2373
    if (sign_index == 44) {
#line 2373
      goto case_44___0;
    }
#line 2376
    if (sign_index == 45) {
#line 2376
      goto case_45___0;
    }
#line 2379
    if (sign_index == 46) {
#line 2379
      goto case_46___0;
    }
#line 2382
    if (sign_index == 47) {
#line 2382
      goto case_47___0;
    }
#line 2385
    if (sign_index == 48) {
#line 2385
      goto case_48___0;
    }
#line 2388
    if (sign_index == 49) {
#line 2388
      goto case_49___0;
    }
#line 2391
    if (sign_index == 50) {
#line 2391
      goto case_50___0;
    }
#line 2394
    goto switch_default___0;
    case_1___0: /* CIL Label */ 
    {
#line 2245
    return_value = ho_recognize_font_2_alef(array_in);
    }
#line 2246
    goto switch_break___0;
    case_2___0: /* CIL Label */ 
    {
#line 2248
    return_value = ho_recognize_font_2_bet(array_in);
    }
#line 2249
    goto switch_break___0;
    case_3___0: /* CIL Label */ 
    {
#line 2251
    return_value = ho_recognize_font_2_gimal(array_in);
    }
#line 2252
    goto switch_break___0;
    case_4___0: /* CIL Label */ 
    {
#line 2254
    return_value = ho_recognize_font_2_dalet(array_in);
    }
#line 2255
    goto switch_break___0;
    case_5___0: /* CIL Label */ 
    {
#line 2257
    return_value = ho_recognize_font_2_hey(array_in);
    }
#line 2258
    goto switch_break___0;
    case_6___0: /* CIL Label */ 
    {
#line 2260
    return_value = ho_recognize_font_2_vav(array_in);
    }
#line 2261
    goto switch_break___0;
    case_7___0: /* CIL Label */ 
    {
#line 2263
    return_value = ho_recognize_font_2_zayin(array_in);
    }
#line 2264
    goto switch_break___0;
    case_8___0: /* CIL Label */ 
    {
#line 2266
    return_value = ho_recognize_font_2_het(array_in);
    }
#line 2267
    goto switch_break___0;
    case_9___0: /* CIL Label */ 
    {
#line 2269
    return_value = ho_recognize_font_2_tet(array_in);
    }
#line 2270
    goto switch_break___0;
    case_10___0: /* CIL Label */ 
    {
#line 2272
    return_value = ho_recognize_font_2_yud(array_in);
    }
#line 2273
    goto switch_break___0;
    case_11___0: /* CIL Label */ 
    {
#line 2275
    return_value = ho_recognize_font_2_caf(array_in);
    }
#line 2276
    goto switch_break___0;
    case_12___0: /* CIL Label */ 
    {
#line 2278
    return_value = ho_recognize_font_2_caf_sofit(array_in);
    }
#line 2279
    goto switch_break___0;
    case_13___0: /* CIL Label */ 
    {
#line 2281
    return_value = ho_recognize_font_2_lamed(array_in);
    }
#line 2282
    goto switch_break___0;
    case_14___0: /* CIL Label */ 
    {
#line 2284
    return_value = ho_recognize_font_2_mem(array_in);
    }
#line 2285
    goto switch_break___0;
    case_15___0: /* CIL Label */ 
    {
#line 2287
    return_value = ho_recognize_font_2_mem_sofit(array_in);
    }
#line 2288
    goto switch_break___0;
    case_16___0: /* CIL Label */ 
    {
#line 2290
    return_value = ho_recognize_font_2_nun(array_in);
    }
#line 2291
    goto switch_break___0;
    case_17___0: /* CIL Label */ 
    {
#line 2293
    return_value = ho_recognize_font_2_nun_sofit(array_in);
    }
#line 2294
    goto switch_break___0;
    case_18___0: /* CIL Label */ 
    {
#line 2296
    return_value = ho_recognize_font_2_samech(array_in);
    }
#line 2297
    goto switch_break___0;
    case_19___0: /* CIL Label */ 
    {
#line 2299
    return_value = ho_recognize_font_2_ayin(array_in);
    }
#line 2300
    goto switch_break___0;
    case_20___0: /* CIL Label */ 
    {
#line 2302
    return_value = ho_recognize_font_2_pey(array_in);
    }
#line 2303
    goto switch_break___0;
    case_21___0: /* CIL Label */ 
    {
#line 2305
    return_value = ho_recognize_font_2_pey_sofit(array_in);
    }
#line 2306
    goto switch_break___0;
    case_22___0: /* CIL Label */ 
    {
#line 2308
    return_value = ho_recognize_font_2_tzadi(array_in);
    }
#line 2309
    goto switch_break___0;
    case_23___0: /* CIL Label */ 
    {
#line 2311
    return_value = ho_recognize_font_2_tzadi_sofit(array_in);
    }
#line 2312
    goto switch_break___0;
    case_24___0: /* CIL Label */ 
    {
#line 2314
    return_value = ho_recognize_font_2_kuf(array_in);
    }
#line 2315
    goto switch_break___0;
    case_25___0: /* CIL Label */ 
    {
#line 2317
    return_value = ho_recognize_font_2_resh(array_in);
    }
#line 2318
    goto switch_break___0;
    case_26___0: /* CIL Label */ 
    {
#line 2320
    return_value = ho_recognize_font_2_shin(array_in);
    }
#line 2321
    goto switch_break___0;
    case_27___0: /* CIL Label */ 
    {
#line 2323
    return_value = ho_recognize_font_2_tav(array_in);
    }
#line 2324
    goto switch_break___0;
    case_28___0: /* CIL Label */ 
    {
#line 2326
    return_value = ho_recognize_font_2_dot(array_in);
    }
#line 2327
    goto switch_break___0;
    case_29___0: /* CIL Label */ 
    {
#line 2329
    return_value = ho_recognize_font_2_comma(array_in);
    }
#line 2330
    goto switch_break___0;
    case_30___0: /* CIL Label */ 
    {
#line 2332
    return_value = ho_recognize_font_2_tag(array_in);
    }
#line 2333
    goto switch_break___0;
    case_31___0: /* CIL Label */ 
    {
#line 2335
    return_value = ho_recognize_font_2_two_tags(array_in);
    }
#line 2336
    goto switch_break___0;
    case_32___0: /* CIL Label */ 
    {
#line 2338
    return_value = ho_recognize_font_2_question(array_in);
    }
#line 2339
    goto switch_break___0;
    case_33___0: /* CIL Label */ 
    {
#line 2341
    return_value = ho_recognize_font_2_exclem(array_in);
    }
#line 2342
    goto switch_break___0;
    case_34___0: /* CIL Label */ 
    {
#line 2344
    return_value = ho_recognize_font_2_dot_dot(array_in);
    }
#line 2345
    goto switch_break___0;
    case_35___0: /* CIL Label */ 
    {
#line 2347
    return_value = ho_recognize_font_2_dot_comma(array_in);
    }
#line 2348
    goto switch_break___0;
    case_36___0: /* CIL Label */ 
    {
#line 2350
    return_value = ho_recognize_font_2_open(array_in);
    }
#line 2351
    goto switch_break___0;
    case_37___0: /* CIL Label */ 
    {
#line 2353
    return_value = ho_recognize_font_2_close(array_in);
    }
#line 2354
    goto switch_break___0;
    case_38___0: /* CIL Label */ 
    {
#line 2356
    return_value = ho_recognize_font_2_minus(array_in);
    }
#line 2357
    goto switch_break___0;
    case_39___0: /* CIL Label */ 
    {
#line 2359
    return_value = ho_recognize_font_2_plus(array_in);
    }
#line 2360
    goto switch_break___0;
    case_40___0: /* CIL Label */ 
    {
#line 2362
    return_value = ho_recognize_font_2_div(array_in);
    }
#line 2363
    goto switch_break___0;
    case_41___0: /* CIL Label */ 
    {
#line 2365
    return_value = ho_recognize_font_2_zero(array_in);
    }
#line 2366
    goto switch_break___0;
    case_42___0: /* CIL Label */ 
    {
#line 2368
    return_value = ho_recognize_font_2_one(array_in);
    }
#line 2369
    goto switch_break___0;
    case_43___0: /* CIL Label */ 
    {
#line 2371
    return_value = ho_recognize_font_2_two(array_in);
    }
#line 2372
    goto switch_break___0;
    case_44___0: /* CIL Label */ 
    {
#line 2374
    return_value = ho_recognize_font_2_three(array_in);
    }
#line 2375
    goto switch_break___0;
    case_45___0: /* CIL Label */ 
    {
#line 2377
    return_value = ho_recognize_font_2_four(array_in);
    }
#line 2378
    goto switch_break___0;
    case_46___0: /* CIL Label */ 
    {
#line 2380
    return_value = ho_recognize_font_2_five(array_in);
    }
#line 2381
    goto switch_break___0;
    case_47___0: /* CIL Label */ 
    {
#line 2383
    return_value = ho_recognize_font_2_six(array_in);
    }
#line 2384
    goto switch_break___0;
    case_48___0: /* CIL Label */ 
    {
#line 2386
    return_value = ho_recognize_font_2_seven(array_in);
    }
#line 2387
    goto switch_break___0;
    case_49___0: /* CIL Label */ 
    {
#line 2389
    return_value = ho_recognize_font_2_eight(array_in);
    }
#line 2390
    goto switch_break___0;
    case_50___0: /* CIL Label */ 
    {
#line 2392
    return_value = ho_recognize_font_2_nine(array_in);
    }
#line 2393
    goto switch_break___0;
    switch_default___0: /* CIL Label */ 
#line 2395
    return_value = 0.0;
#line 2396
    goto switch_break___0;
    switch_break___0: /* CIL Label */ ;
    }
  } else
#line 2400
  if (font_code == 2) {
    {
#line 2404
    if (sign_index == 1) {
#line 2404
      goto case_1___1;
    }
#line 2407
    if (sign_index == 2) {
#line 2407
      goto case_2___1;
    }
#line 2410
    if (sign_index == 3) {
#line 2410
      goto case_3___1;
    }
#line 2413
    if (sign_index == 4) {
#line 2413
      goto case_4___1;
    }
#line 2416
    if (sign_index == 5) {
#line 2416
      goto case_5___1;
    }
#line 2419
    if (sign_index == 6) {
#line 2419
      goto case_6___1;
    }
#line 2422
    if (sign_index == 7) {
#line 2422
      goto case_7___1;
    }
#line 2425
    if (sign_index == 8) {
#line 2425
      goto case_8___1;
    }
#line 2428
    if (sign_index == 9) {
#line 2428
      goto case_9___1;
    }
#line 2431
    if (sign_index == 10) {
#line 2431
      goto case_10___1;
    }
#line 2434
    if (sign_index == 11) {
#line 2434
      goto case_11___1;
    }
#line 2437
    if (sign_index == 12) {
#line 2437
      goto case_12___1;
    }
#line 2440
    if (sign_index == 13) {
#line 2440
      goto case_13___1;
    }
#line 2443
    if (sign_index == 14) {
#line 2443
      goto case_14___1;
    }
#line 2446
    if (sign_index == 15) {
#line 2446
      goto case_15___1;
    }
#line 2449
    if (sign_index == 16) {
#line 2449
      goto case_16___1;
    }
#line 2452
    if (sign_index == 17) {
#line 2452
      goto case_17___1;
    }
#line 2455
    if (sign_index == 18) {
#line 2455
      goto case_18___1;
    }
#line 2458
    if (sign_index == 19) {
#line 2458
      goto case_19___1;
    }
#line 2461
    if (sign_index == 20) {
#line 2461
      goto case_20___1;
    }
#line 2464
    if (sign_index == 21) {
#line 2464
      goto case_21___1;
    }
#line 2467
    if (sign_index == 22) {
#line 2467
      goto case_22___1;
    }
#line 2470
    if (sign_index == 23) {
#line 2470
      goto case_23___1;
    }
#line 2473
    if (sign_index == 24) {
#line 2473
      goto case_24___1;
    }
#line 2476
    if (sign_index == 25) {
#line 2476
      goto case_25___1;
    }
#line 2479
    if (sign_index == 26) {
#line 2479
      goto case_26___1;
    }
#line 2482
    if (sign_index == 27) {
#line 2482
      goto case_27___1;
    }
#line 2485
    if (sign_index == 28) {
#line 2485
      goto case_28___1;
    }
#line 2488
    if (sign_index == 29) {
#line 2488
      goto case_29___1;
    }
#line 2491
    if (sign_index == 30) {
#line 2491
      goto case_30___1;
    }
#line 2494
    if (sign_index == 31) {
#line 2494
      goto case_31___1;
    }
#line 2497
    if (sign_index == 32) {
#line 2497
      goto case_32___1;
    }
#line 2500
    if (sign_index == 33) {
#line 2500
      goto case_33___1;
    }
#line 2503
    if (sign_index == 34) {
#line 2503
      goto case_34___1;
    }
#line 2506
    if (sign_index == 35) {
#line 2506
      goto case_35___1;
    }
#line 2509
    if (sign_index == 36) {
#line 2509
      goto case_36___1;
    }
#line 2512
    if (sign_index == 37) {
#line 2512
      goto case_37___1;
    }
#line 2515
    if (sign_index == 38) {
#line 2515
      goto case_38___1;
    }
#line 2518
    if (sign_index == 39) {
#line 2518
      goto case_39___1;
    }
#line 2521
    if (sign_index == 40) {
#line 2521
      goto case_40___1;
    }
#line 2524
    if (sign_index == 41) {
#line 2524
      goto case_41___1;
    }
#line 2527
    if (sign_index == 42) {
#line 2527
      goto case_42___1;
    }
#line 2530
    if (sign_index == 43) {
#line 2530
      goto case_43___1;
    }
#line 2533
    if (sign_index == 44) {
#line 2533
      goto case_44___1;
    }
#line 2536
    if (sign_index == 45) {
#line 2536
      goto case_45___1;
    }
#line 2539
    if (sign_index == 46) {
#line 2539
      goto case_46___1;
    }
#line 2542
    if (sign_index == 47) {
#line 2542
      goto case_47___1;
    }
#line 2545
    if (sign_index == 48) {
#line 2545
      goto case_48___1;
    }
#line 2548
    if (sign_index == 49) {
#line 2548
      goto case_49___1;
    }
#line 2551
    if (sign_index == 50) {
#line 2551
      goto case_50___1;
    }
#line 2554
    goto switch_default___1;
    case_1___1: /* CIL Label */ 
    {
#line 2405
    return_value = ho_recognize_font_3_alef(array_in);
    }
#line 2406
    goto switch_break___1;
    case_2___1: /* CIL Label */ 
    {
#line 2408
    return_value = ho_recognize_font_3_bet(array_in);
    }
#line 2409
    goto switch_break___1;
    case_3___1: /* CIL Label */ 
    {
#line 2411
    return_value = ho_recognize_font_3_gimal(array_in);
    }
#line 2412
    goto switch_break___1;
    case_4___1: /* CIL Label */ 
    {
#line 2414
    return_value = ho_recognize_font_3_dalet(array_in);
    }
#line 2415
    goto switch_break___1;
    case_5___1: /* CIL Label */ 
    {
#line 2417
    return_value = ho_recognize_font_3_hey(array_in);
    }
#line 2418
    goto switch_break___1;
    case_6___1: /* CIL Label */ 
    {
#line 2420
    return_value = ho_recognize_font_3_vav(array_in);
    }
#line 2421
    goto switch_break___1;
    case_7___1: /* CIL Label */ 
    {
#line 2423
    return_value = ho_recognize_font_3_zayin(array_in);
    }
#line 2424
    goto switch_break___1;
    case_8___1: /* CIL Label */ 
    {
#line 2426
    return_value = ho_recognize_font_3_het(array_in);
    }
#line 2427
    goto switch_break___1;
    case_9___1: /* CIL Label */ 
    {
#line 2429
    return_value = ho_recognize_font_3_tet(array_in);
    }
#line 2430
    goto switch_break___1;
    case_10___1: /* CIL Label */ 
    {
#line 2432
    return_value = ho_recognize_font_3_yud(array_in);
    }
#line 2433
    goto switch_break___1;
    case_11___1: /* CIL Label */ 
    {
#line 2435
    return_value = ho_recognize_font_3_caf(array_in);
    }
#line 2436
    goto switch_break___1;
    case_12___1: /* CIL Label */ 
    {
#line 2438
    return_value = ho_recognize_font_3_caf_sofit(array_in);
    }
#line 2439
    goto switch_break___1;
    case_13___1: /* CIL Label */ 
    {
#line 2441
    return_value = ho_recognize_font_3_lamed(array_in);
    }
#line 2442
    goto switch_break___1;
    case_14___1: /* CIL Label */ 
    {
#line 2444
    return_value = ho_recognize_font_3_mem(array_in);
    }
#line 2445
    goto switch_break___1;
    case_15___1: /* CIL Label */ 
    {
#line 2447
    return_value = ho_recognize_font_3_mem_sofit(array_in);
    }
#line 2448
    goto switch_break___1;
    case_16___1: /* CIL Label */ 
    {
#line 2450
    return_value = ho_recognize_font_3_nun(array_in);
    }
#line 2451
    goto switch_break___1;
    case_17___1: /* CIL Label */ 
    {
#line 2453
    return_value = ho_recognize_font_3_nun_sofit(array_in);
    }
#line 2454
    goto switch_break___1;
    case_18___1: /* CIL Label */ 
    {
#line 2456
    return_value = ho_recognize_font_3_samech(array_in);
    }
#line 2457
    goto switch_break___1;
    case_19___1: /* CIL Label */ 
    {
#line 2459
    return_value = ho_recognize_font_3_ayin(array_in);
    }
#line 2460
    goto switch_break___1;
    case_20___1: /* CIL Label */ 
    {
#line 2462
    return_value = ho_recognize_font_3_pey(array_in);
    }
#line 2463
    goto switch_break___1;
    case_21___1: /* CIL Label */ 
    {
#line 2465
    return_value = ho_recognize_font_3_pey_sofit(array_in);
    }
#line 2466
    goto switch_break___1;
    case_22___1: /* CIL Label */ 
    {
#line 2468
    return_value = ho_recognize_font_3_tzadi(array_in);
    }
#line 2469
    goto switch_break___1;
    case_23___1: /* CIL Label */ 
    {
#line 2471
    return_value = ho_recognize_font_3_tzadi_sofit(array_in);
    }
#line 2472
    goto switch_break___1;
    case_24___1: /* CIL Label */ 
    {
#line 2474
    return_value = ho_recognize_font_3_kuf(array_in);
    }
#line 2475
    goto switch_break___1;
    case_25___1: /* CIL Label */ 
    {
#line 2477
    return_value = ho_recognize_font_3_resh(array_in);
    }
#line 2478
    goto switch_break___1;
    case_26___1: /* CIL Label */ 
    {
#line 2480
    return_value = ho_recognize_font_3_shin(array_in);
    }
#line 2481
    goto switch_break___1;
    case_27___1: /* CIL Label */ 
    {
#line 2483
    return_value = ho_recognize_font_3_tav(array_in);
    }
#line 2484
    goto switch_break___1;
    case_28___1: /* CIL Label */ 
    {
#line 2486
    return_value = ho_recognize_font_3_dot(array_in);
    }
#line 2487
    goto switch_break___1;
    case_29___1: /* CIL Label */ 
    {
#line 2489
    return_value = ho_recognize_font_3_comma(array_in);
    }
#line 2490
    goto switch_break___1;
    case_30___1: /* CIL Label */ 
    {
#line 2492
    return_value = ho_recognize_font_3_tag(array_in);
    }
#line 2493
    goto switch_break___1;
    case_31___1: /* CIL Label */ 
    {
#line 2495
    return_value = ho_recognize_font_3_two_tags(array_in);
    }
#line 2496
    goto switch_break___1;
    case_32___1: /* CIL Label */ 
    {
#line 2498
    return_value = ho_recognize_font_3_question(array_in);
    }
#line 2499
    goto switch_break___1;
    case_33___1: /* CIL Label */ 
    {
#line 2501
    return_value = ho_recognize_font_3_exclem(array_in);
    }
#line 2502
    goto switch_break___1;
    case_34___1: /* CIL Label */ 
    {
#line 2504
    return_value = ho_recognize_font_3_dot_dot(array_in);
    }
#line 2505
    goto switch_break___1;
    case_35___1: /* CIL Label */ 
    {
#line 2507
    return_value = ho_recognize_font_3_dot_comma(array_in);
    }
#line 2508
    goto switch_break___1;
    case_36___1: /* CIL Label */ 
    {
#line 2510
    return_value = ho_recognize_font_3_open(array_in);
    }
#line 2511
    goto switch_break___1;
    case_37___1: /* CIL Label */ 
    {
#line 2513
    return_value = ho_recognize_font_3_close(array_in);
    }
#line 2514
    goto switch_break___1;
    case_38___1: /* CIL Label */ 
    {
#line 2516
    return_value = ho_recognize_font_3_minus(array_in);
    }
#line 2517
    goto switch_break___1;
    case_39___1: /* CIL Label */ 
    {
#line 2519
    return_value = ho_recognize_font_3_plus(array_in);
    }
#line 2520
    goto switch_break___1;
    case_40___1: /* CIL Label */ 
    {
#line 2522
    return_value = ho_recognize_font_3_div(array_in);
    }
#line 2523
    goto switch_break___1;
    case_41___1: /* CIL Label */ 
    {
#line 2525
    return_value = ho_recognize_font_3_zero(array_in);
    }
#line 2526
    goto switch_break___1;
    case_42___1: /* CIL Label */ 
    {
#line 2528
    return_value = ho_recognize_font_3_one(array_in);
    }
#line 2529
    goto switch_break___1;
    case_43___1: /* CIL Label */ 
    {
#line 2531
    return_value = ho_recognize_font_3_two(array_in);
    }
#line 2532
    goto switch_break___1;
    case_44___1: /* CIL Label */ 
    {
#line 2534
    return_value = ho_recognize_font_3_three(array_in);
    }
#line 2535
    goto switch_break___1;
    case_45___1: /* CIL Label */ 
    {
#line 2537
    return_value = ho_recognize_font_3_four(array_in);
    }
#line 2538
    goto switch_break___1;
    case_46___1: /* CIL Label */ 
    {
#line 2540
    return_value = ho_recognize_font_3_five(array_in);
    }
#line 2541
    goto switch_break___1;
    case_47___1: /* CIL Label */ 
    {
#line 2543
    return_value = ho_recognize_font_3_six(array_in);
    }
#line 2544
    goto switch_break___1;
    case_48___1: /* CIL Label */ 
    {
#line 2546
    return_value = ho_recognize_font_3_seven(array_in);
    }
#line 2547
    goto switch_break___1;
    case_49___1: /* CIL Label */ 
    {
#line 2549
    return_value = ho_recognize_font_3_eight(array_in);
    }
#line 2550
    goto switch_break___1;
    case_50___1: /* CIL Label */ 
    {
#line 2552
    return_value = ho_recognize_font_3_nine(array_in);
    }
#line 2553
    goto switch_break___1;
    switch_default___1: /* CIL Label */ 
#line 2555
    return_value = 0.0;
#line 2556
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
  } else
#line 2560
  if (font_code == 3) {
    {
#line 2564
    if (sign_index == 1) {
#line 2564
      goto case_1___2;
    }
#line 2567
    if (sign_index == 2) {
#line 2567
      goto case_2___2;
    }
#line 2570
    if (sign_index == 3) {
#line 2570
      goto case_3___2;
    }
#line 2573
    if (sign_index == 4) {
#line 2573
      goto case_4___2;
    }
#line 2576
    if (sign_index == 5) {
#line 2576
      goto case_5___2;
    }
#line 2579
    if (sign_index == 6) {
#line 2579
      goto case_6___2;
    }
#line 2582
    if (sign_index == 7) {
#line 2582
      goto case_7___2;
    }
#line 2585
    if (sign_index == 8) {
#line 2585
      goto case_8___2;
    }
#line 2588
    if (sign_index == 9) {
#line 2588
      goto case_9___2;
    }
#line 2591
    if (sign_index == 10) {
#line 2591
      goto case_10___2;
    }
#line 2594
    if (sign_index == 11) {
#line 2594
      goto case_11___2;
    }
#line 2597
    if (sign_index == 12) {
#line 2597
      goto case_12___2;
    }
#line 2600
    if (sign_index == 13) {
#line 2600
      goto case_13___2;
    }
#line 2603
    if (sign_index == 14) {
#line 2603
      goto case_14___2;
    }
#line 2606
    if (sign_index == 15) {
#line 2606
      goto case_15___2;
    }
#line 2609
    if (sign_index == 16) {
#line 2609
      goto case_16___2;
    }
#line 2612
    if (sign_index == 17) {
#line 2612
      goto case_17___2;
    }
#line 2615
    if (sign_index == 18) {
#line 2615
      goto case_18___2;
    }
#line 2618
    if (sign_index == 19) {
#line 2618
      goto case_19___2;
    }
#line 2621
    if (sign_index == 20) {
#line 2621
      goto case_20___2;
    }
#line 2624
    if (sign_index == 21) {
#line 2624
      goto case_21___2;
    }
#line 2627
    if (sign_index == 22) {
#line 2627
      goto case_22___2;
    }
#line 2630
    if (sign_index == 23) {
#line 2630
      goto case_23___2;
    }
#line 2633
    if (sign_index == 24) {
#line 2633
      goto case_24___2;
    }
#line 2636
    if (sign_index == 25) {
#line 2636
      goto case_25___2;
    }
#line 2639
    if (sign_index == 26) {
#line 2639
      goto case_26___2;
    }
#line 2642
    if (sign_index == 27) {
#line 2642
      goto case_27___2;
    }
#line 2645
    if (sign_index == 28) {
#line 2645
      goto case_28___2;
    }
#line 2648
    if (sign_index == 29) {
#line 2648
      goto case_29___2;
    }
#line 2651
    if (sign_index == 30) {
#line 2651
      goto case_30___2;
    }
#line 2654
    if (sign_index == 31) {
#line 2654
      goto case_31___2;
    }
#line 2657
    if (sign_index == 32) {
#line 2657
      goto case_32___2;
    }
#line 2660
    if (sign_index == 33) {
#line 2660
      goto case_33___2;
    }
#line 2663
    if (sign_index == 34) {
#line 2663
      goto case_34___2;
    }
#line 2666
    if (sign_index == 35) {
#line 2666
      goto case_35___2;
    }
#line 2669
    if (sign_index == 36) {
#line 2669
      goto case_36___2;
    }
#line 2672
    if (sign_index == 37) {
#line 2672
      goto case_37___2;
    }
#line 2675
    if (sign_index == 38) {
#line 2675
      goto case_38___2;
    }
#line 2678
    if (sign_index == 39) {
#line 2678
      goto case_39___2;
    }
#line 2681
    if (sign_index == 40) {
#line 2681
      goto case_40___2;
    }
#line 2684
    if (sign_index == 41) {
#line 2684
      goto case_41___2;
    }
#line 2687
    if (sign_index == 42) {
#line 2687
      goto case_42___2;
    }
#line 2690
    if (sign_index == 43) {
#line 2690
      goto case_43___2;
    }
#line 2693
    if (sign_index == 44) {
#line 2693
      goto case_44___2;
    }
#line 2696
    if (sign_index == 45) {
#line 2696
      goto case_45___2;
    }
#line 2699
    if (sign_index == 46) {
#line 2699
      goto case_46___2;
    }
#line 2702
    if (sign_index == 47) {
#line 2702
      goto case_47___2;
    }
#line 2705
    if (sign_index == 48) {
#line 2705
      goto case_48___2;
    }
#line 2708
    if (sign_index == 49) {
#line 2708
      goto case_49___2;
    }
#line 2711
    if (sign_index == 50) {
#line 2711
      goto case_50___2;
    }
#line 2714
    goto switch_default___2;
    case_1___2: /* CIL Label */ 
    {
#line 2565
    return_value = ho_recognize_font_4_alef(array_in);
    }
#line 2566
    goto switch_break___2;
    case_2___2: /* CIL Label */ 
    {
#line 2568
    return_value = ho_recognize_font_4_bet(array_in);
    }
#line 2569
    goto switch_break___2;
    case_3___2: /* CIL Label */ 
    {
#line 2571
    return_value = ho_recognize_font_4_gimal(array_in);
    }
#line 2572
    goto switch_break___2;
    case_4___2: /* CIL Label */ 
    {
#line 2574
    return_value = ho_recognize_font_4_dalet(array_in);
    }
#line 2575
    goto switch_break___2;
    case_5___2: /* CIL Label */ 
    {
#line 2577
    return_value = ho_recognize_font_4_hey(array_in);
    }
#line 2578
    goto switch_break___2;
    case_6___2: /* CIL Label */ 
    {
#line 2580
    return_value = ho_recognize_font_4_vav(array_in);
    }
#line 2581
    goto switch_break___2;
    case_7___2: /* CIL Label */ 
    {
#line 2583
    return_value = ho_recognize_font_4_zayin(array_in);
    }
#line 2584
    goto switch_break___2;
    case_8___2: /* CIL Label */ 
    {
#line 2586
    return_value = ho_recognize_font_4_het(array_in);
    }
#line 2587
    goto switch_break___2;
    case_9___2: /* CIL Label */ 
    {
#line 2589
    return_value = ho_recognize_font_4_tet(array_in);
    }
#line 2590
    goto switch_break___2;
    case_10___2: /* CIL Label */ 
    {
#line 2592
    return_value = ho_recognize_font_4_yud(array_in);
    }
#line 2593
    goto switch_break___2;
    case_11___2: /* CIL Label */ 
    {
#line 2595
    return_value = ho_recognize_font_4_caf(array_in);
    }
#line 2596
    goto switch_break___2;
    case_12___2: /* CIL Label */ 
    {
#line 2598
    return_value = ho_recognize_font_4_caf_sofit(array_in);
    }
#line 2599
    goto switch_break___2;
    case_13___2: /* CIL Label */ 
    {
#line 2601
    return_value = ho_recognize_font_4_lamed(array_in);
    }
#line 2602
    goto switch_break___2;
    case_14___2: /* CIL Label */ 
    {
#line 2604
    return_value = ho_recognize_font_4_mem(array_in);
    }
#line 2605
    goto switch_break___2;
    case_15___2: /* CIL Label */ 
    {
#line 2607
    return_value = ho_recognize_font_4_mem_sofit(array_in);
    }
#line 2608
    goto switch_break___2;
    case_16___2: /* CIL Label */ 
    {
#line 2610
    return_value = ho_recognize_font_4_nun(array_in);
    }
#line 2611
    goto switch_break___2;
    case_17___2: /* CIL Label */ 
    {
#line 2613
    return_value = ho_recognize_font_4_nun_sofit(array_in);
    }
#line 2614
    goto switch_break___2;
    case_18___2: /* CIL Label */ 
    {
#line 2616
    return_value = ho_recognize_font_4_samech(array_in);
    }
#line 2617
    goto switch_break___2;
    case_19___2: /* CIL Label */ 
    {
#line 2619
    return_value = ho_recognize_font_4_ayin(array_in);
    }
#line 2620
    goto switch_break___2;
    case_20___2: /* CIL Label */ 
    {
#line 2622
    return_value = ho_recognize_font_4_pey(array_in);
    }
#line 2623
    goto switch_break___2;
    case_21___2: /* CIL Label */ 
    {
#line 2625
    return_value = ho_recognize_font_4_pey_sofit(array_in);
    }
#line 2626
    goto switch_break___2;
    case_22___2: /* CIL Label */ 
    {
#line 2628
    return_value = ho_recognize_font_4_tzadi(array_in);
    }
#line 2629
    goto switch_break___2;
    case_23___2: /* CIL Label */ 
    {
#line 2631
    return_value = ho_recognize_font_4_tzadi_sofit(array_in);
    }
#line 2632
    goto switch_break___2;
    case_24___2: /* CIL Label */ 
    {
#line 2634
    return_value = ho_recognize_font_4_kuf(array_in);
    }
#line 2635
    goto switch_break___2;
    case_25___2: /* CIL Label */ 
    {
#line 2637
    return_value = ho_recognize_font_4_resh(array_in);
    }
#line 2638
    goto switch_break___2;
    case_26___2: /* CIL Label */ 
    {
#line 2640
    return_value = ho_recognize_font_4_shin(array_in);
    }
#line 2641
    goto switch_break___2;
    case_27___2: /* CIL Label */ 
    {
#line 2643
    return_value = ho_recognize_font_4_tav(array_in);
    }
#line 2644
    goto switch_break___2;
    case_28___2: /* CIL Label */ 
    {
#line 2646
    return_value = ho_recognize_font_4_dot(array_in);
    }
#line 2647
    goto switch_break___2;
    case_29___2: /* CIL Label */ 
    {
#line 2649
    return_value = ho_recognize_font_4_comma(array_in);
    }
#line 2650
    goto switch_break___2;
    case_30___2: /* CIL Label */ 
    {
#line 2652
    return_value = ho_recognize_font_4_tag(array_in);
    }
#line 2653
    goto switch_break___2;
    case_31___2: /* CIL Label */ 
    {
#line 2655
    return_value = ho_recognize_font_4_two_tags(array_in);
    }
#line 2656
    goto switch_break___2;
    case_32___2: /* CIL Label */ 
    {
#line 2658
    return_value = ho_recognize_font_4_question(array_in);
    }
#line 2659
    goto switch_break___2;
    case_33___2: /* CIL Label */ 
    {
#line 2661
    return_value = ho_recognize_font_4_exclem(array_in);
    }
#line 2662
    goto switch_break___2;
    case_34___2: /* CIL Label */ 
    {
#line 2664
    return_value = ho_recognize_font_4_dot_dot(array_in);
    }
#line 2665
    goto switch_break___2;
    case_35___2: /* CIL Label */ 
    {
#line 2667
    return_value = ho_recognize_font_4_dot_comma(array_in);
    }
#line 2668
    goto switch_break___2;
    case_36___2: /* CIL Label */ 
    {
#line 2670
    return_value = ho_recognize_font_4_open(array_in);
    }
#line 2671
    goto switch_break___2;
    case_37___2: /* CIL Label */ 
    {
#line 2673
    return_value = ho_recognize_font_4_close(array_in);
    }
#line 2674
    goto switch_break___2;
    case_38___2: /* CIL Label */ 
    {
#line 2676
    return_value = ho_recognize_font_4_minus(array_in);
    }
#line 2677
    goto switch_break___2;
    case_39___2: /* CIL Label */ 
    {
#line 2679
    return_value = ho_recognize_font_4_plus(array_in);
    }
#line 2680
    goto switch_break___2;
    case_40___2: /* CIL Label */ 
    {
#line 2682
    return_value = ho_recognize_font_4_div(array_in);
    }
#line 2683
    goto switch_break___2;
    case_41___2: /* CIL Label */ 
    {
#line 2685
    return_value = ho_recognize_font_4_zero(array_in);
    }
#line 2686
    goto switch_break___2;
    case_42___2: /* CIL Label */ 
    {
#line 2688
    return_value = ho_recognize_font_4_one(array_in);
    }
#line 2689
    goto switch_break___2;
    case_43___2: /* CIL Label */ 
    {
#line 2691
    return_value = ho_recognize_font_4_two(array_in);
    }
#line 2692
    goto switch_break___2;
    case_44___2: /* CIL Label */ 
    {
#line 2694
    return_value = ho_recognize_font_4_three(array_in);
    }
#line 2695
    goto switch_break___2;
    case_45___2: /* CIL Label */ 
    {
#line 2697
    return_value = ho_recognize_font_4_four(array_in);
    }
#line 2698
    goto switch_break___2;
    case_46___2: /* CIL Label */ 
    {
#line 2700
    return_value = ho_recognize_font_4_five(array_in);
    }
#line 2701
    goto switch_break___2;
    case_47___2: /* CIL Label */ 
    {
#line 2703
    return_value = ho_recognize_font_4_six(array_in);
    }
#line 2704
    goto switch_break___2;
    case_48___2: /* CIL Label */ 
    {
#line 2706
    return_value = ho_recognize_font_4_seven(array_in);
    }
#line 2707
    goto switch_break___2;
    case_49___2: /* CIL Label */ 
    {
#line 2709
    return_value = ho_recognize_font_4_eight(array_in);
    }
#line 2710
    goto switch_break___2;
    case_50___2: /* CIL Label */ 
    {
#line 2712
    return_value = ho_recognize_font_4_nine(array_in);
    }
#line 2713
    goto switch_break___2;
    switch_default___2: /* CIL Label */ 
#line 2715
    return_value = 0.0;
#line 2716
    goto switch_break___2;
    switch_break___2: /* CIL Label */ ;
    }
  } else
#line 2720
  if (font_code == 4) {
    {
#line 2724
    if (sign_index == 1) {
#line 2724
      goto case_1___3;
    }
#line 2727
    if (sign_index == 2) {
#line 2727
      goto case_2___3;
    }
#line 2730
    if (sign_index == 3) {
#line 2730
      goto case_3___3;
    }
#line 2733
    if (sign_index == 4) {
#line 2733
      goto case_4___3;
    }
#line 2736
    if (sign_index == 5) {
#line 2736
      goto case_5___3;
    }
#line 2739
    if (sign_index == 6) {
#line 2739
      goto case_6___3;
    }
#line 2742
    if (sign_index == 7) {
#line 2742
      goto case_7___3;
    }
#line 2745
    if (sign_index == 8) {
#line 2745
      goto case_8___3;
    }
#line 2748
    if (sign_index == 9) {
#line 2748
      goto case_9___3;
    }
#line 2751
    if (sign_index == 10) {
#line 2751
      goto case_10___3;
    }
#line 2754
    if (sign_index == 11) {
#line 2754
      goto case_11___3;
    }
#line 2757
    if (sign_index == 12) {
#line 2757
      goto case_12___3;
    }
#line 2760
    if (sign_index == 13) {
#line 2760
      goto case_13___3;
    }
#line 2763
    if (sign_index == 14) {
#line 2763
      goto case_14___3;
    }
#line 2766
    if (sign_index == 15) {
#line 2766
      goto case_15___3;
    }
#line 2769
    if (sign_index == 16) {
#line 2769
      goto case_16___3;
    }
#line 2772
    if (sign_index == 17) {
#line 2772
      goto case_17___3;
    }
#line 2775
    if (sign_index == 18) {
#line 2775
      goto case_18___3;
    }
#line 2778
    if (sign_index == 19) {
#line 2778
      goto case_19___3;
    }
#line 2781
    if (sign_index == 20) {
#line 2781
      goto case_20___3;
    }
#line 2784
    if (sign_index == 21) {
#line 2784
      goto case_21___3;
    }
#line 2787
    if (sign_index == 22) {
#line 2787
      goto case_22___3;
    }
#line 2790
    if (sign_index == 23) {
#line 2790
      goto case_23___3;
    }
#line 2793
    if (sign_index == 24) {
#line 2793
      goto case_24___3;
    }
#line 2796
    if (sign_index == 25) {
#line 2796
      goto case_25___3;
    }
#line 2799
    if (sign_index == 26) {
#line 2799
      goto case_26___3;
    }
#line 2802
    if (sign_index == 27) {
#line 2802
      goto case_27___3;
    }
#line 2805
    if (sign_index == 28) {
#line 2805
      goto case_28___3;
    }
#line 2808
    if (sign_index == 29) {
#line 2808
      goto case_29___3;
    }
#line 2811
    if (sign_index == 30) {
#line 2811
      goto case_30___3;
    }
#line 2814
    if (sign_index == 31) {
#line 2814
      goto case_31___3;
    }
#line 2817
    if (sign_index == 32) {
#line 2817
      goto case_32___3;
    }
#line 2820
    if (sign_index == 33) {
#line 2820
      goto case_33___3;
    }
#line 2823
    if (sign_index == 34) {
#line 2823
      goto case_34___3;
    }
#line 2826
    if (sign_index == 35) {
#line 2826
      goto case_35___3;
    }
#line 2829
    if (sign_index == 36) {
#line 2829
      goto case_36___3;
    }
#line 2832
    if (sign_index == 37) {
#line 2832
      goto case_37___3;
    }
#line 2835
    if (sign_index == 38) {
#line 2835
      goto case_38___3;
    }
#line 2838
    if (sign_index == 39) {
#line 2838
      goto case_39___3;
    }
#line 2841
    if (sign_index == 40) {
#line 2841
      goto case_40___3;
    }
#line 2844
    if (sign_index == 41) {
#line 2844
      goto case_41___3;
    }
#line 2847
    if (sign_index == 42) {
#line 2847
      goto case_42___3;
    }
#line 2850
    if (sign_index == 43) {
#line 2850
      goto case_43___3;
    }
#line 2853
    if (sign_index == 44) {
#line 2853
      goto case_44___3;
    }
#line 2856
    if (sign_index == 45) {
#line 2856
      goto case_45___3;
    }
#line 2859
    if (sign_index == 46) {
#line 2859
      goto case_46___3;
    }
#line 2862
    if (sign_index == 47) {
#line 2862
      goto case_47___3;
    }
#line 2865
    if (sign_index == 48) {
#line 2865
      goto case_48___3;
    }
#line 2868
    if (sign_index == 49) {
#line 2868
      goto case_49___3;
    }
#line 2871
    if (sign_index == 50) {
#line 2871
      goto case_50___3;
    }
#line 2874
    goto switch_default___3;
    case_1___3: /* CIL Label */ 
    {
#line 2725
    return_value = ho_recognize_font_5_alef(array_in);
    }
#line 2726
    goto switch_break___3;
    case_2___3: /* CIL Label */ 
    {
#line 2728
    return_value = ho_recognize_font_5_bet(array_in);
    }
#line 2729
    goto switch_break___3;
    case_3___3: /* CIL Label */ 
    {
#line 2731
    return_value = ho_recognize_font_5_gimal(array_in);
    }
#line 2732
    goto switch_break___3;
    case_4___3: /* CIL Label */ 
    {
#line 2734
    return_value = ho_recognize_font_5_dalet(array_in);
    }
#line 2735
    goto switch_break___3;
    case_5___3: /* CIL Label */ 
    {
#line 2737
    return_value = ho_recognize_font_5_hey(array_in);
    }
#line 2738
    goto switch_break___3;
    case_6___3: /* CIL Label */ 
    {
#line 2740
    return_value = ho_recognize_font_5_vav(array_in);
    }
#line 2741
    goto switch_break___3;
    case_7___3: /* CIL Label */ 
    {
#line 2743
    return_value = ho_recognize_font_5_zayin(array_in);
    }
#line 2744
    goto switch_break___3;
    case_8___3: /* CIL Label */ 
    {
#line 2746
    return_value = ho_recognize_font_5_het(array_in);
    }
#line 2747
    goto switch_break___3;
    case_9___3: /* CIL Label */ 
    {
#line 2749
    return_value = ho_recognize_font_5_tet(array_in);
    }
#line 2750
    goto switch_break___3;
    case_10___3: /* CIL Label */ 
    {
#line 2752
    return_value = ho_recognize_font_5_yud(array_in);
    }
#line 2753
    goto switch_break___3;
    case_11___3: /* CIL Label */ 
    {
#line 2755
    return_value = ho_recognize_font_5_caf(array_in);
    }
#line 2756
    goto switch_break___3;
    case_12___3: /* CIL Label */ 
    {
#line 2758
    return_value = ho_recognize_font_5_caf_sofit(array_in);
    }
#line 2759
    goto switch_break___3;
    case_13___3: /* CIL Label */ 
    {
#line 2761
    return_value = ho_recognize_font_5_lamed(array_in);
    }
#line 2762
    goto switch_break___3;
    case_14___3: /* CIL Label */ 
    {
#line 2764
    return_value = ho_recognize_font_5_mem(array_in);
    }
#line 2765
    goto switch_break___3;
    case_15___3: /* CIL Label */ 
    {
#line 2767
    return_value = ho_recognize_font_5_mem_sofit(array_in);
    }
#line 2768
    goto switch_break___3;
    case_16___3: /* CIL Label */ 
    {
#line 2770
    return_value = ho_recognize_font_5_nun(array_in);
    }
#line 2771
    goto switch_break___3;
    case_17___3: /* CIL Label */ 
    {
#line 2773
    return_value = ho_recognize_font_5_nun_sofit(array_in);
    }
#line 2774
    goto switch_break___3;
    case_18___3: /* CIL Label */ 
    {
#line 2776
    return_value = ho_recognize_font_5_samech(array_in);
    }
#line 2777
    goto switch_break___3;
    case_19___3: /* CIL Label */ 
    {
#line 2779
    return_value = ho_recognize_font_5_ayin(array_in);
    }
#line 2780
    goto switch_break___3;
    case_20___3: /* CIL Label */ 
    {
#line 2782
    return_value = ho_recognize_font_5_pey(array_in);
    }
#line 2783
    goto switch_break___3;
    case_21___3: /* CIL Label */ 
    {
#line 2785
    return_value = ho_recognize_font_5_pey_sofit(array_in);
    }
#line 2786
    goto switch_break___3;
    case_22___3: /* CIL Label */ 
    {
#line 2788
    return_value = ho_recognize_font_5_tzadi(array_in);
    }
#line 2789
    goto switch_break___3;
    case_23___3: /* CIL Label */ 
    {
#line 2791
    return_value = ho_recognize_font_5_tzadi_sofit(array_in);
    }
#line 2792
    goto switch_break___3;
    case_24___3: /* CIL Label */ 
    {
#line 2794
    return_value = ho_recognize_font_5_kuf(array_in);
    }
#line 2795
    goto switch_break___3;
    case_25___3: /* CIL Label */ 
    {
#line 2797
    return_value = ho_recognize_font_5_resh(array_in);
    }
#line 2798
    goto switch_break___3;
    case_26___3: /* CIL Label */ 
    {
#line 2800
    return_value = ho_recognize_font_5_shin(array_in);
    }
#line 2801
    goto switch_break___3;
    case_27___3: /* CIL Label */ 
    {
#line 2803
    return_value = ho_recognize_font_5_tav(array_in);
    }
#line 2804
    goto switch_break___3;
    case_28___3: /* CIL Label */ 
    {
#line 2806
    return_value = ho_recognize_font_5_dot(array_in);
    }
#line 2807
    goto switch_break___3;
    case_29___3: /* CIL Label */ 
    {
#line 2809
    return_value = ho_recognize_font_5_comma(array_in);
    }
#line 2810
    goto switch_break___3;
    case_30___3: /* CIL Label */ 
    {
#line 2812
    return_value = ho_recognize_font_5_tag(array_in);
    }
#line 2813
    goto switch_break___3;
    case_31___3: /* CIL Label */ 
    {
#line 2815
    return_value = ho_recognize_font_5_two_tags(array_in);
    }
#line 2816
    goto switch_break___3;
    case_32___3: /* CIL Label */ 
    {
#line 2818
    return_value = ho_recognize_font_5_question(array_in);
    }
#line 2819
    goto switch_break___3;
    case_33___3: /* CIL Label */ 
    {
#line 2821
    return_value = ho_recognize_font_5_exclem(array_in);
    }
#line 2822
    goto switch_break___3;
    case_34___3: /* CIL Label */ 
    {
#line 2824
    return_value = ho_recognize_font_5_dot_dot(array_in);
    }
#line 2825
    goto switch_break___3;
    case_35___3: /* CIL Label */ 
    {
#line 2827
    return_value = ho_recognize_font_5_dot_comma(array_in);
    }
#line 2828
    goto switch_break___3;
    case_36___3: /* CIL Label */ 
    {
#line 2830
    return_value = ho_recognize_font_5_open(array_in);
    }
#line 2831
    goto switch_break___3;
    case_37___3: /* CIL Label */ 
    {
#line 2833
    return_value = ho_recognize_font_5_close(array_in);
    }
#line 2834
    goto switch_break___3;
    case_38___3: /* CIL Label */ 
    {
#line 2836
    return_value = ho_recognize_font_5_minus(array_in);
    }
#line 2837
    goto switch_break___3;
    case_39___3: /* CIL Label */ 
    {
#line 2839
    return_value = ho_recognize_font_5_plus(array_in);
    }
#line 2840
    goto switch_break___3;
    case_40___3: /* CIL Label */ 
    {
#line 2842
    return_value = ho_recognize_font_5_div(array_in);
    }
#line 2843
    goto switch_break___3;
    case_41___3: /* CIL Label */ 
    {
#line 2845
    return_value = ho_recognize_font_5_zero(array_in);
    }
#line 2846
    goto switch_break___3;
    case_42___3: /* CIL Label */ 
    {
#line 2848
    return_value = ho_recognize_font_5_one(array_in);
    }
#line 2849
    goto switch_break___3;
    case_43___3: /* CIL Label */ 
    {
#line 2851
    return_value = ho_recognize_font_5_two(array_in);
    }
#line 2852
    goto switch_break___3;
    case_44___3: /* CIL Label */ 
    {
#line 2854
    return_value = ho_recognize_font_5_three(array_in);
    }
#line 2855
    goto switch_break___3;
    case_45___3: /* CIL Label */ 
    {
#line 2857
    return_value = ho_recognize_font_5_four(array_in);
    }
#line 2858
    goto switch_break___3;
    case_46___3: /* CIL Label */ 
    {
#line 2860
    return_value = ho_recognize_font_5_five(array_in);
    }
#line 2861
    goto switch_break___3;
    case_47___3: /* CIL Label */ 
    {
#line 2863
    return_value = ho_recognize_font_5_six(array_in);
    }
#line 2864
    goto switch_break___3;
    case_48___3: /* CIL Label */ 
    {
#line 2866
    return_value = ho_recognize_font_5_seven(array_in);
    }
#line 2867
    goto switch_break___3;
    case_49___3: /* CIL Label */ 
    {
#line 2869
    return_value = ho_recognize_font_5_eight(array_in);
    }
#line 2870
    goto switch_break___3;
    case_50___3: /* CIL Label */ 
    {
#line 2872
    return_value = ho_recognize_font_5_nine(array_in);
    }
#line 2873
    goto switch_break___3;
    switch_default___3: /* CIL Label */ 
#line 2875
    return_value = 0.0;
#line 2876
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
  } else
#line 2880
  if (font_code == 5) {
    {
#line 2884
    if (sign_index == 1) {
#line 2884
      goto case_1___4;
    }
#line 2887
    if (sign_index == 2) {
#line 2887
      goto case_2___4;
    }
#line 2890
    if (sign_index == 3) {
#line 2890
      goto case_3___4;
    }
#line 2893
    if (sign_index == 4) {
#line 2893
      goto case_4___4;
    }
#line 2896
    if (sign_index == 5) {
#line 2896
      goto case_5___4;
    }
#line 2899
    if (sign_index == 6) {
#line 2899
      goto case_6___4;
    }
#line 2902
    if (sign_index == 7) {
#line 2902
      goto case_7___4;
    }
#line 2905
    if (sign_index == 8) {
#line 2905
      goto case_8___4;
    }
#line 2908
    if (sign_index == 9) {
#line 2908
      goto case_9___4;
    }
#line 2911
    if (sign_index == 10) {
#line 2911
      goto case_10___4;
    }
#line 2914
    if (sign_index == 11) {
#line 2914
      goto case_11___4;
    }
#line 2917
    if (sign_index == 12) {
#line 2917
      goto case_12___4;
    }
#line 2920
    if (sign_index == 13) {
#line 2920
      goto case_13___4;
    }
#line 2923
    if (sign_index == 14) {
#line 2923
      goto case_14___4;
    }
#line 2926
    if (sign_index == 15) {
#line 2926
      goto case_15___4;
    }
#line 2929
    if (sign_index == 16) {
#line 2929
      goto case_16___4;
    }
#line 2932
    if (sign_index == 17) {
#line 2932
      goto case_17___4;
    }
#line 2935
    if (sign_index == 18) {
#line 2935
      goto case_18___4;
    }
#line 2938
    if (sign_index == 19) {
#line 2938
      goto case_19___4;
    }
#line 2941
    if (sign_index == 20) {
#line 2941
      goto case_20___4;
    }
#line 2944
    if (sign_index == 21) {
#line 2944
      goto case_21___4;
    }
#line 2947
    if (sign_index == 22) {
#line 2947
      goto case_22___4;
    }
#line 2950
    if (sign_index == 23) {
#line 2950
      goto case_23___4;
    }
#line 2953
    if (sign_index == 24) {
#line 2953
      goto case_24___4;
    }
#line 2956
    if (sign_index == 25) {
#line 2956
      goto case_25___4;
    }
#line 2959
    if (sign_index == 26) {
#line 2959
      goto case_26___4;
    }
#line 2962
    if (sign_index == 27) {
#line 2962
      goto case_27___4;
    }
#line 2965
    if (sign_index == 28) {
#line 2965
      goto case_28___4;
    }
#line 2968
    if (sign_index == 29) {
#line 2968
      goto case_29___4;
    }
#line 2971
    if (sign_index == 30) {
#line 2971
      goto case_30___4;
    }
#line 2974
    if (sign_index == 31) {
#line 2974
      goto case_31___4;
    }
#line 2977
    if (sign_index == 32) {
#line 2977
      goto case_32___4;
    }
#line 2980
    if (sign_index == 33) {
#line 2980
      goto case_33___4;
    }
#line 2983
    if (sign_index == 34) {
#line 2983
      goto case_34___4;
    }
#line 2986
    if (sign_index == 35) {
#line 2986
      goto case_35___4;
    }
#line 2989
    if (sign_index == 36) {
#line 2989
      goto case_36___4;
    }
#line 2992
    if (sign_index == 37) {
#line 2992
      goto case_37___4;
    }
#line 2995
    if (sign_index == 38) {
#line 2995
      goto case_38___4;
    }
#line 2998
    if (sign_index == 39) {
#line 2998
      goto case_39___4;
    }
#line 3001
    if (sign_index == 40) {
#line 3001
      goto case_40___4;
    }
#line 3004
    if (sign_index == 41) {
#line 3004
      goto case_41___4;
    }
#line 3007
    if (sign_index == 42) {
#line 3007
      goto case_42___4;
    }
#line 3010
    if (sign_index == 43) {
#line 3010
      goto case_43___4;
    }
#line 3013
    if (sign_index == 44) {
#line 3013
      goto case_44___4;
    }
#line 3016
    if (sign_index == 45) {
#line 3016
      goto case_45___4;
    }
#line 3019
    if (sign_index == 46) {
#line 3019
      goto case_46___4;
    }
#line 3022
    if (sign_index == 47) {
#line 3022
      goto case_47___4;
    }
#line 3025
    if (sign_index == 48) {
#line 3025
      goto case_48___4;
    }
#line 3028
    if (sign_index == 49) {
#line 3028
      goto case_49___4;
    }
#line 3031
    if (sign_index == 50) {
#line 3031
      goto case_50___4;
    }
#line 3034
    goto switch_default___4;
    case_1___4: /* CIL Label */ 
    {
#line 2885
    return_value = ho_recognize_font_6_alef(array_in);
    }
#line 2886
    goto switch_break___4;
    case_2___4: /* CIL Label */ 
    {
#line 2888
    return_value = ho_recognize_font_6_bet(array_in);
    }
#line 2889
    goto switch_break___4;
    case_3___4: /* CIL Label */ 
    {
#line 2891
    return_value = ho_recognize_font_6_gimal(array_in);
    }
#line 2892
    goto switch_break___4;
    case_4___4: /* CIL Label */ 
    {
#line 2894
    return_value = ho_recognize_font_6_dalet(array_in);
    }
#line 2895
    goto switch_break___4;
    case_5___4: /* CIL Label */ 
    {
#line 2897
    return_value = ho_recognize_font_6_hey(array_in);
    }
#line 2898
    goto switch_break___4;
    case_6___4: /* CIL Label */ 
    {
#line 2900
    return_value = ho_recognize_font_6_vav(array_in);
    }
#line 2901
    goto switch_break___4;
    case_7___4: /* CIL Label */ 
    {
#line 2903
    return_value = ho_recognize_font_6_zayin(array_in);
    }
#line 2904
    goto switch_break___4;
    case_8___4: /* CIL Label */ 
    {
#line 2906
    return_value = ho_recognize_font_6_het(array_in);
    }
#line 2907
    goto switch_break___4;
    case_9___4: /* CIL Label */ 
    {
#line 2909
    return_value = ho_recognize_font_6_tet(array_in);
    }
#line 2910
    goto switch_break___4;
    case_10___4: /* CIL Label */ 
    {
#line 2912
    return_value = ho_recognize_font_6_yud(array_in);
    }
#line 2913
    goto switch_break___4;
    case_11___4: /* CIL Label */ 
    {
#line 2915
    return_value = ho_recognize_font_6_caf(array_in);
    }
#line 2916
    goto switch_break___4;
    case_12___4: /* CIL Label */ 
    {
#line 2918
    return_value = ho_recognize_font_6_caf_sofit(array_in);
    }
#line 2919
    goto switch_break___4;
    case_13___4: /* CIL Label */ 
    {
#line 2921
    return_value = ho_recognize_font_6_lamed(array_in);
    }
#line 2922
    goto switch_break___4;
    case_14___4: /* CIL Label */ 
    {
#line 2924
    return_value = ho_recognize_font_6_mem(array_in);
    }
#line 2925
    goto switch_break___4;
    case_15___4: /* CIL Label */ 
    {
#line 2927
    return_value = ho_recognize_font_6_mem_sofit(array_in);
    }
#line 2928
    goto switch_break___4;
    case_16___4: /* CIL Label */ 
    {
#line 2930
    return_value = ho_recognize_font_6_nun(array_in);
    }
#line 2931
    goto switch_break___4;
    case_17___4: /* CIL Label */ 
    {
#line 2933
    return_value = ho_recognize_font_6_nun_sofit(array_in);
    }
#line 2934
    goto switch_break___4;
    case_18___4: /* CIL Label */ 
    {
#line 2936
    return_value = ho_recognize_font_6_samech(array_in);
    }
#line 2937
    goto switch_break___4;
    case_19___4: /* CIL Label */ 
    {
#line 2939
    return_value = ho_recognize_font_6_ayin(array_in);
    }
#line 2940
    goto switch_break___4;
    case_20___4: /* CIL Label */ 
    {
#line 2942
    return_value = ho_recognize_font_6_pey(array_in);
    }
#line 2943
    goto switch_break___4;
    case_21___4: /* CIL Label */ 
    {
#line 2945
    return_value = ho_recognize_font_6_pey_sofit(array_in);
    }
#line 2946
    goto switch_break___4;
    case_22___4: /* CIL Label */ 
    {
#line 2948
    return_value = ho_recognize_font_6_tzadi(array_in);
    }
#line 2949
    goto switch_break___4;
    case_23___4: /* CIL Label */ 
    {
#line 2951
    return_value = ho_recognize_font_6_tzadi_sofit(array_in);
    }
#line 2952
    goto switch_break___4;
    case_24___4: /* CIL Label */ 
    {
#line 2954
    return_value = ho_recognize_font_6_kuf(array_in);
    }
#line 2955
    goto switch_break___4;
    case_25___4: /* CIL Label */ 
    {
#line 2957
    return_value = ho_recognize_font_6_resh(array_in);
    }
#line 2958
    goto switch_break___4;
    case_26___4: /* CIL Label */ 
    {
#line 2960
    return_value = ho_recognize_font_6_shin(array_in);
    }
#line 2961
    goto switch_break___4;
    case_27___4: /* CIL Label */ 
    {
#line 2963
    return_value = ho_recognize_font_6_tav(array_in);
    }
#line 2964
    goto switch_break___4;
    case_28___4: /* CIL Label */ 
    {
#line 2966
    return_value = ho_recognize_font_6_dot(array_in);
    }
#line 2967
    goto switch_break___4;
    case_29___4: /* CIL Label */ 
    {
#line 2969
    return_value = ho_recognize_font_6_comma(array_in);
    }
#line 2970
    goto switch_break___4;
    case_30___4: /* CIL Label */ 
    {
#line 2972
    return_value = ho_recognize_font_6_tag(array_in);
    }
#line 2973
    goto switch_break___4;
    case_31___4: /* CIL Label */ 
    {
#line 2975
    return_value = ho_recognize_font_6_two_tags(array_in);
    }
#line 2976
    goto switch_break___4;
    case_32___4: /* CIL Label */ 
    {
#line 2978
    return_value = ho_recognize_font_6_question(array_in);
    }
#line 2979
    goto switch_break___4;
    case_33___4: /* CIL Label */ 
    {
#line 2981
    return_value = ho_recognize_font_6_exclem(array_in);
    }
#line 2982
    goto switch_break___4;
    case_34___4: /* CIL Label */ 
    {
#line 2984
    return_value = ho_recognize_font_6_dot_dot(array_in);
    }
#line 2985
    goto switch_break___4;
    case_35___4: /* CIL Label */ 
    {
#line 2987
    return_value = ho_recognize_font_6_dot_comma(array_in);
    }
#line 2988
    goto switch_break___4;
    case_36___4: /* CIL Label */ 
    {
#line 2990
    return_value = ho_recognize_font_6_open(array_in);
    }
#line 2991
    goto switch_break___4;
    case_37___4: /* CIL Label */ 
    {
#line 2993
    return_value = ho_recognize_font_6_close(array_in);
    }
#line 2994
    goto switch_break___4;
    case_38___4: /* CIL Label */ 
    {
#line 2996
    return_value = ho_recognize_font_6_minus(array_in);
    }
#line 2997
    goto switch_break___4;
    case_39___4: /* CIL Label */ 
    {
#line 2999
    return_value = ho_recognize_font_6_plus(array_in);
    }
#line 3000
    goto switch_break___4;
    case_40___4: /* CIL Label */ 
    {
#line 3002
    return_value = ho_recognize_font_6_div(array_in);
    }
#line 3003
    goto switch_break___4;
    case_41___4: /* CIL Label */ 
    {
#line 3005
    return_value = ho_recognize_font_6_zero(array_in);
    }
#line 3006
    goto switch_break___4;
    case_42___4: /* CIL Label */ 
    {
#line 3008
    return_value = ho_recognize_font_6_one(array_in);
    }
#line 3009
    goto switch_break___4;
    case_43___4: /* CIL Label */ 
    {
#line 3011
    return_value = ho_recognize_font_6_two(array_in);
    }
#line 3012
    goto switch_break___4;
    case_44___4: /* CIL Label */ 
    {
#line 3014
    return_value = ho_recognize_font_6_three(array_in);
    }
#line 3015
    goto switch_break___4;
    case_45___4: /* CIL Label */ 
    {
#line 3017
    return_value = ho_recognize_font_6_four(array_in);
    }
#line 3018
    goto switch_break___4;
    case_46___4: /* CIL Label */ 
    {
#line 3020
    return_value = ho_recognize_font_6_five(array_in);
    }
#line 3021
    goto switch_break___4;
    case_47___4: /* CIL Label */ 
    {
#line 3023
    return_value = ho_recognize_font_6_six(array_in);
    }
#line 3024
    goto switch_break___4;
    case_48___4: /* CIL Label */ 
    {
#line 3026
    return_value = ho_recognize_font_6_seven(array_in);
    }
#line 3027
    goto switch_break___4;
    case_49___4: /* CIL Label */ 
    {
#line 3029
    return_value = ho_recognize_font_6_eight(array_in);
    }
#line 3030
    goto switch_break___4;
    case_50___4: /* CIL Label */ 
    {
#line 3032
    return_value = ho_recognize_font_6_nine(array_in);
    }
#line 3033
    goto switch_break___4;
    switch_default___4: /* CIL Label */ 
#line 3035
    return_value = 0.0;
#line 3036
    goto switch_break___4;
    switch_break___4: /* CIL Label */ ;
    }
  }
#line 3041
  if (return_value < 0.0) {
#line 3042
    return_value = 0.0;
  }
#line 3043
  if (return_value > 1.0) {
#line 3044
    return_value = 1.0;
  }
#line 3046
  return (return_value);
}
}
#line 3049 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
int ho_recognize_create_array_out(double const   *array_in , double *array_out , int font_code ) 
{ 
  int i ;

  {
#line 3056
  *(array_out + 0) = 0.1;
#line 3059
  i = 1;
  {
#line 3059
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3059
    if (! (i < 51)) {
#line 3059
      goto while_break;
    }
    {
#line 3060
    *(array_out + i) = ho_recognize_array(array_in, (int const   )i, font_code);
#line 3059
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 3062
  return (0);
}
}
#line 3065 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
char const   *ho_recognize_array_out_to_font(double const   *array_out , int *this_char_i ) 
{ 
  int i ;
  int max_i ;

  {
#line 3068
  i = 0;
#line 3070
  max_i = 0;
#line 3073
  i = 1;
  {
#line 3073
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3073
    if (! (i < 51)) {
#line 3073
      goto while_break;
    }
#line 3074
    if (*(array_out + i) > *(array_out + max_i)) {
#line 3075
      max_i = i;
    }
#line 3073
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 3077
  *this_char_i = max_i;
#line 3079
  return (ho_sign_array[max_i]);
}
}
#line 3082 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_recognize.c"
char const   *ho_recognize_font(ho_bitmap const   *m_text , ho_bitmap const   *m_mask ,
                                int font_code , unsigned char do_linguistics , unsigned char word_end ,
                                unsigned char word_start , int *this_char_i , int last_char_i ) 
{ 
  double array_in[104] ;
  double array_out[51] ;
  char const   *font ;

  {
  {
#line 3093
  ho_recognize_create_array_in(m_text, m_mask, array_in);
#line 3094
  ho_recognize_create_array_out((double const   *)(array_in), array_out, font_code);
  }
#line 3097
  if (do_linguistics) {
    {
#line 3099
    ho_linguistics_adjust_array_out(array_out, word_end, word_start, last_char_i);
    }
  }
  {
#line 3103
  font = ho_recognize_array_out_to_font((double const   *)(array_out), this_char_i);
  }
#line 3105
  return (font);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_zero(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 56
  return_value = 0.0;
#line 58
  return (return_value);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_one(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 64
  return_value = 0.0;
#line 66
  return (return_value);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_two(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 72
  return_value = 0.0;
#line 74
  return (return_value);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_three(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 80
  return_value = 0.0;
#line 82
  return (return_value);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_four(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 88
  return_value = 0.0;
#line 90
  return (return_value);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_five(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 96
  return_value = 0.0;
#line 98
  return (return_value);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_six(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 104
  return_value = 0.0;
#line 106
  return (return_value);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_seven(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 112
  return_value = 0.0;
#line 114
  return (return_value);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_eight(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 120
  return_value = 0.0;
#line 122
  return (return_value);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_nine(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 128
  return_value = 0.0;
#line 130
  return (return_value);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 136
  return_value = 0.0;
#line 138
  return (return_value);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 144
  return_value = 0.0;
#line 146
  return (return_value);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_minus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 152
  return_value = 0.0;
#line 154
  return (return_value);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_plus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 160
  return_value = 0.0;
#line 162
  return (return_value);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_div(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 168
  return_value = 0.0;
#line 170
  return (return_value);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_open(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 176
  return_value = 0.0;
#line 178
  return (return_value);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_close(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 184
  return_value = 0.0;
#line 186
  return (return_value);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_tag(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 192
  return_value = 0.0;
#line 194
  return (return_value);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_two_tags(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 200
  return_value = 0.0;
#line 202
  return (return_value);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_question(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 208
  return_value = 0.0;
#line 210
  return (return_value);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_exclem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 216
  return_value = 0.0;
#line 218
  return (return_value);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_dot_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 224
  return_value = 0.0;
#line 226
  return (return_value);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_dot_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 232
  return_value = 0.0;
#line 234
  return (return_value);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_alef(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 240
  return_value = 0.0;
#line 242
  return (return_value);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_bet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 248
  return_value = 0.0;
#line 250
  return (return_value);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_gimal(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 256
  return_value = 0.0;
#line 258
  return (return_value);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_dalet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 264
  return_value = 0.0;
#line 266
  return (return_value);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_hey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 272
  return_value = 0.0;
#line 274
  return (return_value);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_vav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 280
  return_value = 0.0;
#line 282
  return (return_value);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_zayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 288
  return_value = 0.0;
#line 290
  return (return_value);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_het(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 296
  return_value = 0.0;
#line 298
  return (return_value);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_tet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 304
  return_value = 0.0;
#line 306
  return (return_value);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_yud(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 312
  return_value = 0.0;
#line 314
  return (return_value);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_caf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 320
  return_value = 0.0;
#line 322
  return (return_value);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_caf_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 328
  return_value = 0.0;
#line 330
  return (return_value);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_lamed(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 336
  return_value = 0.0;
#line 338
  return (return_value);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_mem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 344
  return_value = 0.0;
#line 346
  return (return_value);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_mem_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 352
  return_value = 0.0;
#line 354
  return (return_value);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_nun(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 360
  return_value = 0.0;
#line 362
  return (return_value);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_nun_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 368
  return_value = 0.0;
#line 370
  return (return_value);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_samech(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 376
  return_value = 0.0;
#line 378
  return (return_value);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_ayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 384
  return_value = 0.0;
#line 386
  return (return_value);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_pey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 392
  return_value = 0.0;
#line 394
  return (return_value);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_pey_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 400
  return_value = 0.0;
#line 402
  return (return_value);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_tzadi(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 408
  return_value = 0.0;
#line 410
  return (return_value);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_tzadi_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 416
  return_value = 0.0;
#line 418
  return (return_value);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_kuf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 424
  return_value = 0.0;
#line 426
  return (return_value);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_resh(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 432
  return_value = 0.0;
#line 434
  return (return_value);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_shin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 440
  return_value = 0.0;
#line 442
  return (return_value);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_6.c"
double ho_recognize_font_6_tav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 448
  return_value = 0.0;
#line 450
  return (return_value);
}
}
#line 53 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_zero(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 56
  return_value = 0.0;
#line 58
  return (return_value);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_one(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 64
  return_value = 0.0;
#line 66
  return (return_value);
}
}
#line 69 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_two(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 72
  return_value = 0.0;
#line 74
  return (return_value);
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_three(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 80
  return_value = 0.0;
#line 82
  return (return_value);
}
}
#line 85 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_four(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 88
  return_value = 0.0;
#line 90
  return (return_value);
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_five(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 96
  return_value = 0.0;
#line 98
  return (return_value);
}
}
#line 101 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_six(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 104
  return_value = 0.0;
#line 106
  return (return_value);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_seven(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 112
  return_value = 0.0;
#line 114
  return (return_value);
}
}
#line 117 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_eight(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 120
  return_value = 0.0;
#line 122
  return (return_value);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_nine(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 128
  return_value = 0.0;
#line 130
  return (return_value);
}
}
#line 133 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 136
  return_value = 0.0;
#line 138
  return (return_value);
}
}
#line 141 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 144
  return_value = 0.0;
#line 146
  return (return_value);
}
}
#line 149 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_minus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 152
  return_value = 0.0;
#line 154
  return (return_value);
}
}
#line 157 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_plus(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 160
  return_value = 0.0;
#line 162
  return (return_value);
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_div(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 168
  return_value = 0.0;
#line 170
  return (return_value);
}
}
#line 173 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_open(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 176
  return_value = 0.0;
#line 178
  return (return_value);
}
}
#line 181 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_close(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 184
  return_value = 0.0;
#line 186
  return (return_value);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_tag(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 192
  return_value = 0.0;
#line 194
  return (return_value);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_two_tags(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 200
  return_value = 0.0;
#line 202
  return (return_value);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_question(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 208
  return_value = 0.0;
#line 210
  return (return_value);
}
}
#line 213 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_exclem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 216
  return_value = 0.0;
#line 218
  return (return_value);
}
}
#line 221 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_dot_dot(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 224
  return_value = 0.0;
#line 226
  return (return_value);
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_dot_comma(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 232
  return_value = 0.0;
#line 234
  return (return_value);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_alef(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 240
  return_value = 0.0;
#line 242
  return (return_value);
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_bet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 248
  return_value = 0.0;
#line 250
  return (return_value);
}
}
#line 253 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_gimal(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 256
  return_value = 0.0;
#line 258
  return (return_value);
}
}
#line 261 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_dalet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 264
  return_value = 0.0;
#line 266
  return (return_value);
}
}
#line 269 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_hey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 272
  return_value = 0.0;
#line 274
  return (return_value);
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_vav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 280
  return_value = 0.0;
#line 282
  return (return_value);
}
}
#line 285 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_zayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 288
  return_value = 0.0;
#line 290
  return (return_value);
}
}
#line 293 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_het(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 296
  return_value = 0.0;
#line 298
  return (return_value);
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_tet(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 304
  return_value = 0.0;
#line 306
  return (return_value);
}
}
#line 309 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_yud(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 312
  return_value = 0.0;
#line 314
  return (return_value);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_caf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 320
  return_value = 0.0;
#line 322
  return (return_value);
}
}
#line 325 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_caf_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 328
  return_value = 0.0;
#line 330
  return (return_value);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_lamed(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 336
  return_value = 0.0;
#line 338
  return (return_value);
}
}
#line 341 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_mem(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 344
  return_value = 0.0;
#line 346
  return (return_value);
}
}
#line 349 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_mem_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 352
  return_value = 0.0;
#line 354
  return (return_value);
}
}
#line 357 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_nun(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 360
  return_value = 0.0;
#line 362
  return (return_value);
}
}
#line 365 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_nun_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 368
  return_value = 0.0;
#line 370
  return (return_value);
}
}
#line 373 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_samech(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 376
  return_value = 0.0;
#line 378
  return (return_value);
}
}
#line 381 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_ayin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 384
  return_value = 0.0;
#line 386
  return (return_value);
}
}
#line 389 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_pey(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 392
  return_value = 0.0;
#line 394
  return (return_value);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_pey_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 400
  return_value = 0.0;
#line 402
  return (return_value);
}
}
#line 405 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_tzadi(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 408
  return_value = 0.0;
#line 410
  return (return_value);
}
}
#line 413 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_tzadi_sofit(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 416
  return_value = 0.0;
#line 418
  return (return_value);
}
}
#line 421 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_kuf(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 424
  return_value = 0.0;
#line 426
  return (return_value);
}
}
#line 429 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_resh(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 432
  return_value = 0.0;
#line 434
  return (return_value);
}
}
#line 437 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_shin(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 440
  return_value = 0.0;
#line 442
  return (return_value);
}
}
#line 445 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/fonts/ho_recognize_font_2.c"
double ho_recognize_font_2_tav(double const   *array_in ) 
{ 
  double return_value ;

  {
#line 448
  return_value = 0.0;
#line 450
  return (return_value);
}
}
#line 42 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_linguistics.c"
int ho_linguistics_adjust_array_out(double *array_out , unsigned char word_end , unsigned char word_start ,
                                    int last_char_i ) 
{ 
  double factor ;

  {
#line 48
  factor = 0.3;
#line 51
  if (word_end) {
#line 55
    *(array_out + 11) -= factor;
#line 57
    *(array_out + 14) -= factor;
#line 59
    *(array_out + 16) -= factor;
#line 61
    *(array_out + 20) -= factor;
#line 63
    *(array_out + 22) -= factor;
  } else {
#line 70
    *(array_out + 12) -= factor;
#line 72
    *(array_out + 15) -= factor;
#line 74
    *(array_out + 17) -= factor;
#line 76
    *(array_out + 21) -= factor;
#line 78
    *(array_out + 23) -= factor;
#line 81
    *(array_out + 28) -= factor;
#line 82
    *(array_out + 29) -= factor;
#line 83
    *(array_out + 32) -= factor;
#line 84
    *(array_out + 23) -= factor;
#line 85
    *(array_out + 34) -= factor;
#line 86
    *(array_out + 35) -= factor;
  }
#line 89
  return (0);
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.h"
ho_array_stat *ho_array_stat_new(int const   width , int const   height , double threshold ) ;
#line 83
int ho_array_stat_free(ho_array_stat *pix ) ;
#line 90
unsigned char ho_array_stat_init(ho_array_stat *ar , ho_array const   *pix ) ;
#line 97
unsigned char ho_array_stat_add(ho_array_stat *ar , ho_array const   *pix ) ;
#line 104
ho_array *ho_array_stat_to_array(ho_array_stat const   *ar_st ) ;
#line 112
ho_array *ho_array_stat_to_array_mask(ho_array_stat const   *ar_st , ho_array const   *ar ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.c"
ho_array_stat *ho_array_stat_new(int const   width , int const   height , double threshold ) 
{ 
  int x ;
  int y ;
  ho_array_stat *pix ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 56
  pix = (ho_array_stat *)((void *)0);
#line 61
  tmp = malloc(sizeof(ho_array ));
#line 61
  pix = (ho_array_stat *)tmp;
  }
#line 62
  if (! pix) {
#line 64
    return ((ho_array_stat *)((void *)0));
  }
  {
#line 70
  pix->width = (int )width;
#line 71
  pix->height = (int )height;
#line 72
  pix->size = 0;
#line 73
  pix->threshold = threshold;
#line 78
  tmp___0 = malloc((unsigned long )(pix->height * pix->width) * sizeof(double ));
#line 78
  pix->data_sums = (double *)tmp___0;
  }
#line 79
  if (! pix->data_sums) {
    {
#line 81
    free((void *)pix);
    }
#line 82
    return ((ho_array_stat *)((void *)0));
  }
  {
#line 85
  tmp___1 = malloc((unsigned long )(pix->height * pix->width) * sizeof(double ));
#line 85
  pix->data_squre_sums = (double *)tmp___1;
  }
#line 86
  if (! pix->data_squre_sums) {
    {
#line 88
    free((void *)pix->data_sums);
#line 89
    free((void *)pix);
    }
#line 90
    return ((ho_array_stat *)((void *)0));
  }
#line 94
  x = 0;
  {
#line 94
  while (1) {
    while_continue: /* CIL Label */ ;
#line 94
    if (! (x < pix->width)) {
#line 94
      goto while_break;
    }
#line 95
    y = 0;
    {
#line 95
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 95
      if (! (y < pix->height)) {
#line 95
        goto while_break___0;
      }
#line 97
      *(pix->data_sums + (x + y * pix->width)) = 0.0;
#line 98
      *(pix->data_squre_sums + (x + y * pix->width)) = 0.0;
#line 95
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 94
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 101
  return (pix);
}
}
#line 109 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.c"
int ho_array_stat_free(ho_array_stat *pix ) 
{ 


  {
#line 112
  if (! pix) {
#line 113
    return (-1);
  }
#line 115
  if (pix->data_sums) {
    {
#line 116
    free((void *)pix->data_sums);
    }
  }
#line 118
  if (pix->data_squre_sums) {
    {
#line 119
    free((void *)pix->data_squre_sums);
    }
  }
  {
#line 121
  free((void *)pix);
  }
#line 123
  return (0);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.c"
unsigned char ho_array_stat_init(ho_array_stat *ar , ho_array const   *pix ) 
{ 
  double value ;
  double value2 ;
  int x ;
  int y ;

  {
#line 141
  x = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (x < (int )pix->width)) {
#line 141
      goto while_break;
    }
#line 142
    y = 0;
    {
#line 142
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 142
      if (! (y < (int )pix->height)) {
#line 142
        goto while_break___0;
      }
#line 144
      value = *(pix->data + (x + y * (int )pix->width));
#line 145
      value2 = value * value;
#line 147
      *(ar->data_sums + (x + y * ar->width)) = value;
#line 148
      *(ar->data_squre_sums + (x + y * ar->width)) = value2;
#line 142
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 141
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 152
  ar->size = 1;
#line 154
  return ((unsigned char)0);
}
}
#line 162 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.c"
unsigned char ho_array_stat_add(ho_array_stat *ar , ho_array const   *pix ) 
{ 
  double value ;
  double value2 ;
  int x ;
  int y ;

  {
#line 172
  x = 0;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! (x < (int )pix->width)) {
#line 172
      goto while_break;
    }
#line 173
    y = 0;
    {
#line 173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 173
      if (! (y < (int )pix->height)) {
#line 173
        goto while_break___0;
      }
#line 175
      value = *(pix->data + (x + y * (int )pix->width));
#line 176
      value2 = value * value;
#line 178
      *(ar->data_sums + (x + y * ar->width)) += value;
#line 179
      *(ar->data_squre_sums + (x + y * ar->width)) += value2;
#line 173
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 172
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 183
  (ar->size) ++;
#line 185
  return ((unsigned char)0);
}
}
#line 193 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.c"
ho_array *ho_array_stat_to_array(ho_array_stat const   *ar_st ) 
{ 
  int x ;
  int y ;
  double value ;
  ho_array *m_out ;

  {
  {
#line 200
  m_out = (ho_array *)((void *)0);
#line 203
  m_out = ho_array_new(ar_st->width, ar_st->height);
  }
#line 204
  if (! m_out) {
#line 205
    return ((ho_array *)((void *)0));
  }
#line 208
  x = 0;
  {
#line 208
  while (1) {
    while_continue: /* CIL Label */ ;
#line 208
    if (! (x < (int )ar_st->width)) {
#line 208
      goto while_break;
    }
#line 209
    y = 0;
    {
#line 209
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 209
      if (! (y < (int )ar_st->height)) {
#line 209
        goto while_break___0;
      }
#line 211
      value = *(ar_st->data_sums + (x + y * (int )ar_st->width)) / (double )ar_st->size;
#line 212
      *(m_out->data + (x + y * m_out->width)) = value;
#line 209
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 208
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 215
  return (m_out);
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array_stat.c"
ho_array *ho_array_stat_to_array_mask(ho_array_stat const   *ar_st , ho_array const   *ar ) 
{ 
  int x ;
  int y ;
  double val ;
  double avg ;
  double avg2 ;
  double sd2 ;
  double threshold ;
  ho_array *m_out ;

  {
#line 235
  m_out = (ho_array *)((void *)0);
#line 238
  if (ar_st->size < 1) {
#line 239
    return ((ho_array *)((void *)0));
  }
  {
#line 242
  m_out = ho_array_new(ar_st->width, ar_st->height);
  }
#line 243
  if (! m_out) {
#line 244
    return ((ho_array *)((void *)0));
  }
#line 247
  x = 0;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    if (! (x < (int )ar_st->width)) {
#line 247
      goto while_break;
    }
#line 248
    y = 0;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      if (! (y < (int )ar_st->height)) {
#line 248
        goto while_break___0;
      }
#line 250
      avg = *(ar_st->data_sums + (x + y * (int )ar_st->width)) / (double )ar_st->size;
#line 251
      avg2 = *(ar_st->data_squre_sums + (x + y * (int )ar_st->width)) / (double )ar_st->size;
#line 252
      sd2 = avg2 - avg * avg;
#line 253
      threshold = (double )((ar_st->threshold * ar_st->threshold) * (double const   )sd2);
#line 255
      val = *(ar->data + (x + y * (int )ar->width));
#line 257
      *(m_out->data + (x + y * m_out->width)) = (val - avg) * (val - avg) - threshold;
#line 248
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 247
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 260
  return (m_out);
}
}
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 89 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.h"
ho_pixbuf *ho_pixbuf_clone(ho_pixbuf const   *m ) ;
#line 100
ho_pixbuf *ho_pixbuf_clone_window(ho_pixbuf const   *m , int const   x , int const   y ,
                                  int const   width , int const   height ) ;
#line 109
int ho_pixbuf_set_data(ho_pixbuf *pix , char const   *data ) ;
#line 116
string_data ho_pixbuf_get_data_string(ho_pixbuf *pix ) ;
#line 123
ho_pixbuf *ho_pixbuf_new_from_bitmap(ho_bitmap const   *bit_in ) ;
#line 132
ho_pixbuf *ho_pixbuf_new_from_objmap(ho_objmap const   *obj_in , unsigned char const   min ,
                                     unsigned char const   max ) ;
#line 162
ho_pixbuf *ho_pixbuf_new_from_layout(ho_layout const   *lay_in , unsigned char const   show_grid ,
                                     ho_bitmap const   *m_text , unsigned char const   text_block_r ,
                                     unsigned char const   text_block_g , unsigned char const   text_block_b ,
                                     unsigned char const   text_block_a , unsigned char const   text_block_frame_width ,
                                     unsigned char const   line_block_r , unsigned char const   line_block_g ,
                                     unsigned char const   line_block_b , unsigned char const   line_block_a ,
                                     unsigned char const   line_block_frame_width ,
                                     unsigned char const   word_block_r , unsigned char const   word_block_g ,
                                     unsigned char const   word_block_b , unsigned char const   word_block_a ,
                                     unsigned char const   word_block_frame_width ,
                                     unsigned char const   font_block_r , unsigned char const   font_block_g ,
                                     unsigned char const   font_block_b , unsigned char const   font_block_a ,
                                     unsigned char const   font_block_frame_width ) ;
#line 182
ho_pixbuf *ho_pixbuf_to_rgb(ho_pixbuf const   *pix_in ) ;
#line 196
ho_pixbuf *ho_pixbuf_color_to_gray(ho_pixbuf const   *pix ) ;
#line 203
ho_pixbuf *ho_pixbuf_color_to_red(ho_pixbuf const   *pix ) ;
#line 210
ho_pixbuf *ho_pixbuf_color_to_green(ho_pixbuf const   *pix ) ;
#line 217
ho_pixbuf *ho_pixbuf_color_to_blue(ho_pixbuf const   *pix ) ;
#line 224
ho_pixbuf *ho_pixbuf_scale2(ho_pixbuf const   *pix ) ;
#line 231
ho_pixbuf *ho_pixbuf_scale3(ho_pixbuf const   *pix ) ;
#line 238
ho_pixbuf *ho_pixbuf_scale4(ho_pixbuf const   *pix ) ;
#line 245
ho_pixbuf *ho_pixbuf_scale8(ho_pixbuf const   *pix ) ;
#line 253
ho_pixbuf *ho_pixbuf_scale(ho_pixbuf const   *pix , unsigned char const   scale ) ;
#line 262
unsigned char ho_pixbuf_minmax(ho_pixbuf const   *pix , unsigned char *min , unsigned char *max ) ;
#line 271
ho_pixbuf *ho_pixbuf_linear_filter(ho_pixbuf const   *pix ) ;
#line 279
ho_bitmap *ho_pixbuf_to_bitmap(ho_pixbuf const   *pix , unsigned char threshold ) ;
#line 292
ho_bitmap *ho_pixbuf_to_bitmap_by_color(ho_pixbuf const   *pix , unsigned char min_red ,
                                        unsigned char max_red , unsigned char min_green ,
                                        unsigned char max_green , unsigned char min_blue ,
                                        unsigned char max_blue ) ;
#line 304
ho_bitmap *ho_pixbuf_to_bitmap_adaptive(ho_pixbuf const   *pix , unsigned char threshold ,
                                        unsigned char size , unsigned char adaptive_threshold ) ;
#line 316
ho_bitmap *ho_pixbuf_to_bitmap_adaptive_fine(ho_pixbuf const   *pix , unsigned char threshold ,
                                             unsigned char size , unsigned char adaptive_threshold ) ;
#line 350
int ho_pixbuf_draw_line(ho_pixbuf *m , int const   x1 , int const   y1___0 , int const   x2 ,
                        int const   y2 , unsigned char const   red , unsigned char const   green ,
                        unsigned char const   blue ) ;
#line 369
int ho_pixbuf_draw_box(ho_pixbuf *m , int const   x , int const   y , int const   width ,
                       int const   height , unsigned char const   red , unsigned char const   green ,
                       unsigned char const   blue , unsigned char const   alpha ) ;
#line 388
int ho_pixbuf_draw_box_empty(ho_pixbuf *m , int const   x , int const   y , int const   width ,
                             int const   height , unsigned char const   red , unsigned char const   green ,
                             unsigned char const   blue ) ;
#line 405
int ho_pixbuf_draw_horizontal_scale(ho_pixbuf *m , int const   x1 , int const   y1___0 ,
                                    int const   length , int const   step , unsigned char const   red ,
                                    unsigned char const   green , unsigned char const   blue ) ;
#line 423
int ho_pixbuf_draw_vertical_scale(ho_pixbuf *m , int const   x1 , int const   y1___0 ,
                                  int const   length , int const   step , unsigned char const   red ,
                                  unsigned char const   green , unsigned char const   blue ) ;
#line 439
int ho_pixbuf_draw_grid(ho_pixbuf *m , int const   size , int const   step , unsigned char const   red ,
                        unsigned char const   green , unsigned char const   blue ) ;
#line 453
int ho_pixbuf_draw_bitmap(ho_pixbuf *m , ho_bitmap const   *bit_in , unsigned char const   red ,
                          unsigned char const   green , unsigned char const   blue ,
                          unsigned char const   alpha ) ;
#line 466
int ho_pixbuf_draw_rgb_bitmap(ho_pixbuf *m , ho_bitmap const   *bit_in_red , ho_bitmap const   *bit_in_green ,
                              ho_bitmap const   *bit_in_blue ) ;
#line 478
int ho_pixbuf_draw_rgb_pixbufs(ho_pixbuf *m , ho_pixbuf const   *bit_in_red , ho_pixbuf const   *bit_in_green ,
                               ho_pixbuf const   *bit_in_blue ) ;
#line 494
int ho_pixbuf_draw_bitmap_at(ho_pixbuf *m , ho_bitmap const   *bit_in , int const   x1 ,
                             int const   y1___0 , unsigned char const   red , unsigned char const   green ,
                             unsigned char const   blue , unsigned char const   alpha ) ;
#line 513
int ho_pixbuf_pnm_save(ho_pixbuf const   *pix , char const   *filename ) ;
#line 47 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_new(unsigned char const   n_channels , int const   width , int const   height ,
                         int const   rowstride ) 
{ 
  ho_pixbuf *pix ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 51
  pix = (ho_pixbuf *)((void *)0);
#line 56
  tmp = malloc(sizeof(ho_pixbuf ));
#line 56
  pix = (ho_pixbuf *)tmp;
  }
#line 57
  if (! pix) {
#line 59
    return ((ho_pixbuf *)((void *)0));
  }
#line 65
  pix->n_channels = (unsigned char )n_channels;
#line 66
  pix->width = (int )width;
#line 67
  pix->height = (int )height;
#line 68
  if (rowstride) {
#line 69
    pix->rowstride = (int )rowstride;
  } else {
#line 71
    pix->rowstride = (int )(width * (int const   )n_channels);
  }
  {
#line 76
  tmp___0 = malloc((size_t )(pix->height * pix->rowstride));
#line 76
  pix->data = (unsigned char *)tmp___0;
  }
#line 77
  if (! pix->data) {
    {
#line 79
    free((void *)pix);
    }
#line 80
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 83
  memset((void *)pix->data, 255, (size_t )(pix->height * pix->rowstride));
  }
#line 85
  return (pix);
}
}
#line 88 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_clone(ho_pixbuf const   *m ) 
{ 
  ho_pixbuf *m_out ;

  {
  {
#line 94
  m_out = ho_pixbuf_new(m->n_channels, m->width, m->height, m->rowstride);
  }
#line 95
  if (! m_out) {
#line 96
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 99
  memcpy((void */* __restrict  */)m_out->data, (void const   */* __restrict  */)m->data,
         (size_t )(m_out->height * m_out->rowstride));
  }
#line 101
  return (m_out);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_clone_window(ho_pixbuf const   *m , int const   x , int const   y ,
                                  int const   width , int const   height ) 
{ 
  ho_pixbuf *m_out ;
  int x1 ;
  int y1___0 ;
  unsigned char val ;

  {
  {
#line 113
  m_out = ho_pixbuf_new(m->n_channels, width, height, (int const   )0);
  }
#line 114
  if (! m_out) {
#line 115
    return ((ho_pixbuf *)((void *)0));
  }
#line 122
  if ((int const   )m->n_channels > 1) {
#line 124
    x1 = 0;
    {
#line 124
    while (1) {
      while_continue: /* CIL Label */ ;
#line 124
      if (x1 < (int )width) {
#line 124
        if (! (x1 < (int )m->width)) {
#line 124
          goto while_break;
        }
      } else {
#line 124
        goto while_break;
      }
#line 125
      y1___0 = 0;
      {
#line 125
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 125
        if (y1___0 < (int )height) {
#line 125
          if (! (y1___0 < (int )m->height)) {
#line 125
            goto while_break___0;
          }
        } else {
#line 125
          goto while_break___0;
        }
#line 128
        val = *(m->data + ((x + (int const   )x1) * (int const   )m->n_channels + (y + (int const   )y1___0) * m->rowstride));
#line 129
        *(m_out->data + (x1 * (int )m_out->n_channels + y1___0 * m_out->rowstride)) = val;
#line 130
        val = *(m->data + (((x + (int const   )x1) * (int const   )m->n_channels + (y + (int const   )y1___0) * m->rowstride) + 1));
#line 131
        *(m_out->data + ((x1 * (int )m_out->n_channels + y1___0 * m_out->rowstride) + 1)) = val;
#line 132
        val = *(m->data + (((x + (int const   )x1) * (int const   )m->n_channels + (y + (int const   )y1___0) * m->rowstride) + 2));
#line 133
        *(m_out->data + ((x1 * (int )m_out->n_channels + y1___0 * m_out->rowstride) + 2)) = val;
#line 125
        y1___0 ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 124
      x1 ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 139
    x1 = 0;
    {
#line 139
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 139
      if (x1 < (int )width) {
#line 139
        if (! (x1 < (int )m->width)) {
#line 139
          goto while_break___1;
        }
      } else {
#line 139
        goto while_break___1;
      }
#line 140
      y1___0 = 0;
      {
#line 140
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 140
        if (y1___0 < (int )height) {
#line 140
          if (! (y1___0 < (int )m->height)) {
#line 140
            goto while_break___2;
          }
        } else {
#line 140
          goto while_break___2;
        }
#line 142
        val = *(m->data + ((x + (int const   )x1) * (int const   )m->n_channels + (y + (int const   )y1___0) * m->rowstride));
#line 143
        *(m_out->data + (x1 * (int )m_out->n_channels + y1___0 * m_out->rowstride)) = val;
#line 140
        y1___0 ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 139
      x1 ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 147
  return (m_out);
}
}
#line 150 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_set_data(ho_pixbuf *pix , char const   *data ) 
{ 


  {
  {
#line 154
  memcpy((void */* __restrict  */)pix->data, (void const   */* __restrict  */)data,
         (size_t )(pix->height * pix->rowstride));
  }
#line 156
  return (0);
}
}
#line 159 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
string_data ho_pixbuf_get_data_string(ho_pixbuf *pix ) 
{ 
  string_data out ;
  void *tmp ;

  {
  {
#line 164
  tmp = malloc((size_t )(pix->height * pix->rowstride));
#line 164
  out.data = (char *)tmp;
  }
#line 166
  if (! out.data) {
#line 168
    out.data = (char *)((void *)0);
#line 169
    out.size = 0;
  } else {
    {
#line 173
    memcpy((void */* __restrict  */)out.data, (void const   */* __restrict  */)pix->data,
           (size_t )(pix->height * pix->rowstride));
#line 175
    out.data = (char *)pix->data;
#line 176
    out.size = pix->height * pix->rowstride;
    }
  }
#line 179
  return (out);
}
}
#line 182 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_new_from_bitmap(ho_bitmap const   *bit_in ) 
{ 
  int x ;
  int y ;
  ho_pixbuf *pix ;
  int tmp ;

  {
  {
#line 186
  pix = (ho_pixbuf *)((void *)0);
#line 188
  pix = ho_pixbuf_new((unsigned char const   )1, bit_in->width, bit_in->height, (int const   )0);
  }
#line 189
  if (! pix) {
#line 190
    return ((ho_pixbuf *)((void *)0));
  }
#line 192
  x = 0;
  {
#line 192
  while (1) {
    while_continue: /* CIL Label */ ;
#line 192
    if (! (x < (int )bit_in->width)) {
#line 192
      goto while_break;
    }
#line 193
    y = 0;
    {
#line 193
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 193
      if (! (y < (int )bit_in->height)) {
#line 193
        goto while_break___0;
      }
#line 194
      if (((int )*(bit_in->data + (x / 8 + y * (int )bit_in->rowstride)) & (128 >> x % 8)) > 0) {
#line 194
        tmp = 1;
      } else {
#line 194
        tmp = 0;
      }
#line 194
      *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = (unsigned char )(255 * (1 - tmp));
#line 193
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 192
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 196
  return (pix);
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_new_from_objmap(ho_objmap const   *obj_in , unsigned char const   min ,
                                     unsigned char const   max ) 
{ 
  int x ;
  int y ;
  ho_pixbuf *pix ;
  int index___0 ;

  {
  {
#line 204
  pix = (ho_pixbuf *)((void *)0);
#line 205
  index___0 = 0;
#line 208
  pix = ho_pixbuf_new((unsigned char const   )3, obj_in->width, obj_in->height, (int const   )0);
  }
#line 209
  if (! pix) {
#line 210
    return ((ho_pixbuf *)((void *)0));
  }
#line 213
  x = 0;
  {
#line 213
  while (1) {
    while_continue: /* CIL Label */ ;
#line 213
    if (! (x < (int )obj_in->width)) {
#line 213
      goto while_break;
    }
#line 214
    y = 0;
    {
#line 214
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 214
      if (! (y < (int )obj_in->height)) {
#line 214
        goto while_break___0;
      }
#line 216
      index___0 = *(obj_in->map + (x + y * (int )obj_in->width));
#line 218
      if (index___0) {
#line 221
        *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = (unsigned char )((int const   )min + (((int const   )max - (int const   )min) * (int const   )(index___0 % 12)) / 12);
#line 222
        *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 1)) = (unsigned char )((int const   )min + (((int const   )max - (int const   )min) * (int const   )(index___0 % 6)) / 6);
#line 223
        *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 2)) = (unsigned char )((int const   )min + (((int const   )max - (int const   )min) * (int const   )(index___0 % 9)) / 9);
      } else {
#line 228
        *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = (unsigned char)255;
#line 229
        *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 1)) = (unsigned char)255;
#line 230
        *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 2)) = (unsigned char)255;
      }
#line 214
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 213
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return (pix);
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_new_from_layout(ho_layout const   *lay_in , unsigned char const   show_grid ,
                                     ho_bitmap const   *m_text , unsigned char const   text_block_r ,
                                     unsigned char const   text_block_g , unsigned char const   text_block_b ,
                                     unsigned char const   text_block_a , unsigned char const   text_block_frame_width ,
                                     unsigned char const   line_block_r , unsigned char const   line_block_g ,
                                     unsigned char const   line_block_b , unsigned char const   line_block_a ,
                                     unsigned char const   line_block_frame_width ,
                                     unsigned char const   word_block_r , unsigned char const   word_block_g ,
                                     unsigned char const   word_block_b , unsigned char const   word_block_a ,
                                     unsigned char const   word_block_frame_width ,
                                     unsigned char const   font_block_r , unsigned char const   font_block_g ,
                                     unsigned char const   font_block_b , unsigned char const   font_block_a ,
                                     unsigned char const   font_block_frame_width ) 
{ 
  ho_pixbuf *pix_out ;
  ho_bitmap *m_block_frame ;
  ho_bitmap *m_word_font_mask ;
  int block_index ;
  int line_index ;
  int word_index ;

  {
  {
#line 253
  pix_out = (ho_pixbuf *)((void *)0);
#line 254
  m_block_frame = (ho_bitmap *)((void *)0);
#line 255
  m_word_font_mask = (ho_bitmap *)((void *)0);
#line 261
  pix_out = ho_pixbuf_new((unsigned char const   )3, (int const   )(lay_in->m_page_blocks_mask)->width,
                          (int const   )(lay_in->m_page_blocks_mask)->height, (int const   )0);
#line 266
  m_block_frame = ho_bitmap_edge((ho_bitmap const   *)lay_in->m_page_blocks_mask,
                                 (int const   )text_block_frame_width);
#line 268
  ho_pixbuf_draw_bitmap(pix_out, (ho_bitmap const   *)m_block_frame, text_block_r,
                        text_block_g, text_block_b, text_block_a);
#line 270
  ho_bitmap_free(m_block_frame);
#line 273
  block_index = 0;
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
#line 273
    if (! (block_index < (int )lay_in->n_blocks)) {
#line 273
      goto while_break;
    }
#line 275
    line_index = 0;
    {
#line 275
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 275
      if (! (line_index < *(lay_in->n_lines + block_index))) {
#line 275
        goto while_break___0;
      }
      {
#line 279
      ho_pixbuf_draw_bitmap(pix_out, (ho_bitmap const   *)*(*(lay_in->m_lines_words_mask + block_index) + line_index),
                            word_block_r, word_block_g, word_block_b, word_block_a);
#line 284
      m_block_frame = ho_bitmap_edge((ho_bitmap const   *)*(*(lay_in->m_lines_line_mask + block_index) + line_index),
                                     (int const   )line_block_frame_width);
#line 288
      ho_pixbuf_draw_bitmap(pix_out, (ho_bitmap const   *)m_block_frame, line_block_r,
                            line_block_g, line_block_b, line_block_a);
#line 291
      ho_bitmap_free(m_block_frame);
#line 294
      word_index = 0;
      }
      {
#line 294
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 294
        if (! (word_index < *(*(lay_in->n_words + block_index) + line_index))) {
#line 294
          goto while_break___1;
        }
        {
#line 297
        m_word_font_mask = *(*(*(lay_in->m_words_font_mask + block_index) + line_index) + word_index);
#line 300
        ho_pixbuf_draw_bitmap(pix_out, (ho_bitmap const   *)m_word_font_mask, font_block_r,
                              font_block_g, font_block_b, font_block_a);
#line 294
        word_index ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 275
      line_index ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 273
    block_index ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 307
  if (show_grid) {
    {
#line 308
    ho_pixbuf_draw_grid(pix_out, (int const   )120, (int const   )30, (unsigned char const   )255,
                        (unsigned char const   )0, (unsigned char const   )0);
    }
  }
#line 311
  if (m_text) {
    {
#line 312
    ho_pixbuf_draw_bitmap(pix_out, m_text, (unsigned char const   )0, (unsigned char const   )0,
                          (unsigned char const   )0, (unsigned char const   )255);
    }
  }
#line 314
  return (pix_out);
}
}
#line 317 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_to_rgb(ho_pixbuf const   *pix_in ) 
{ 
  int x ;
  int y ;
  ho_pixbuf *pix ;
  unsigned char red ;
  unsigned char green ;
  unsigned char blue ;

  {
  {
#line 321
  pix = (ho_pixbuf *)((void *)0);
#line 325
  pix = ho_pixbuf_new((unsigned char const   )3, pix_in->width, pix_in->height, (int const   )0);
  }
#line 326
  if (! pix) {
#line 327
    return ((ho_pixbuf *)((void *)0));
  }
#line 330
  if ((int const   )pix_in->n_channels < 3) {
#line 333
    x = 0;
    {
#line 333
    while (1) {
      while_continue: /* CIL Label */ ;
#line 333
      if (! (x < (int )pix_in->width)) {
#line 333
        goto while_break;
      }
#line 334
      y = 0;
      {
#line 334
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 334
        if (! (y < (int )pix_in->height)) {
#line 334
          goto while_break___0;
        }
#line 336
        red = *(pix_in->data + (x * (int )pix_in->n_channels + y * (int )pix_in->rowstride));
#line 337
        *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = red;
#line 338
        *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 1)) = red;
#line 339
        *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 2)) = red;
#line 334
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 333
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 346
    x = 0;
    {
#line 346
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 346
      if (! (x < (int )pix_in->width)) {
#line 346
        goto while_break___1;
      }
#line 347
      y = 0;
      {
#line 347
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 347
        if (! (y < (int )pix_in->height)) {
#line 347
          goto while_break___2;
        }
#line 349
        red = *(pix_in->data + (x * (int )pix_in->n_channels + y * (int )pix_in->rowstride));
#line 350
        green = *(pix_in->data + ((x * (int )pix_in->n_channels + y * (int )pix_in->rowstride) + 1));
#line 351
        blue = *(pix_in->data + ((x * (int )pix_in->n_channels + y * (int )pix_in->rowstride) + 2));
#line 352
        *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = red;
#line 353
        *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 1)) = green;
#line 354
        *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 2)) = blue;
#line 347
        y ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 346
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 358
  return (pix);
}
}
#line 361 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_free(ho_pixbuf *pix ) 
{ 


  {
#line 364
  if (! pix) {
#line 365
    return (-1);
  }
#line 367
  if (pix->data) {
    {
#line 368
    free((void *)pix->data);
    }
  }
  {
#line 370
  free((void *)pix);
  }
#line 372
  return (0);
}
}
#line 375 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_color_to_gray(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_gray ;
  int x ;
  int y ;
  unsigned char red ;
  unsigned char green ;
  unsigned char blue ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 378
  pix_gray = (ho_pixbuf *)((void *)0);
#line 383
  if ((int const   )pix->n_channels < 3) {
#line 384
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 387
  pix_gray = ho_pixbuf_new((unsigned char const   )1, pix->width, pix->height, (int const   )0);
  }
#line 388
  if (! pix_gray) {
#line 389
    return ((ho_pixbuf *)((void *)0));
  }
#line 391
  x = 0;
  {
#line 391
  while (1) {
    while_continue: /* CIL Label */ ;
#line 391
    if (! (x < (int )pix->width)) {
#line 391
      goto while_break;
    }
#line 392
    y = 0;
    {
#line 392
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 392
      if (! (y < (int )pix->height)) {
#line 392
        goto while_break___0;
      }
#line 394
      red = *(pix->data + (x * (int )pix->n_channels + y * (int )pix->rowstride));
#line 395
      green = *(pix->data + ((x * (int )pix->n_channels + y * (int )pix->rowstride) + 1));
#line 396
      blue = *(pix->data + ((x * (int )pix->n_channels + y * (int )pix->rowstride) + 2));
#line 398
      if ((int )red > (int )green) {
#line 398
        if ((int )red > (int )blue) {
#line 398
          tmp___0 = (int )red;
        } else {
#line 398
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
#line 398
        if ((int )green > (int )blue) {
#line 398
          tmp = (int )green;
        } else {
#line 398
          tmp = (int )blue;
        }
#line 398
        tmp___0 = tmp;
      }
#line 398
      if ((int )red < (int )green) {
#line 398
        if ((int )red < (int )blue) {
#line 398
          tmp___2 = (int )red;
        } else {
#line 398
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
#line 398
        if ((int )green < (int )blue) {
#line 398
          tmp___1 = (int )green;
        } else {
#line 398
          tmp___1 = (int )blue;
        }
#line 398
        tmp___2 = tmp___1;
      }
#line 398
      *(pix_gray->data + (x * (int )pix_gray->n_channels + y * pix_gray->rowstride)) = (unsigned char )((double )(tmp___0 + tmp___2) / 2.0);
#line 392
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 391
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (pix_gray);
}
}
#line 406 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_color_to_red(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_red ;
  int x ;
  int y ;
  unsigned char red ;

  {
#line 409
  pix_red = (ho_pixbuf *)((void *)0);
#line 414
  if ((int const   )pix->n_channels < 3) {
#line 415
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 418
  pix_red = ho_pixbuf_new((unsigned char const   )1, pix->width, pix->height, (int const   )0);
  }
#line 419
  if (! pix_red) {
#line 420
    return ((ho_pixbuf *)((void *)0));
  }
#line 422
  x = 0;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (x < (int )pix->width)) {
#line 422
      goto while_break;
    }
#line 423
    y = 0;
    {
#line 423
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 423
      if (! (y < (int )pix->height)) {
#line 423
        goto while_break___0;
      }
#line 425
      red = *(pix->data + (x * (int )pix->n_channels + y * (int )pix->rowstride));
#line 427
      *(pix_red->data + (x * (int )pix_red->n_channels + y * pix_red->rowstride)) = red;
#line 423
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 422
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 430
  return (pix_red);
}
}
#line 433 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_color_to_green(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_green ;
  int x ;
  int y ;
  unsigned char green ;

  {
#line 436
  pix_green = (ho_pixbuf *)((void *)0);
#line 441
  if ((int const   )pix->n_channels < 3) {
#line 442
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 445
  pix_green = ho_pixbuf_new((unsigned char const   )1, pix->width, pix->height, (int const   )0);
  }
#line 446
  if (! pix_green) {
#line 447
    return ((ho_pixbuf *)((void *)0));
  }
#line 449
  x = 0;
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (x < (int )pix->width)) {
#line 449
      goto while_break;
    }
#line 450
    y = 0;
    {
#line 450
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 450
      if (! (y < (int )pix->height)) {
#line 450
        goto while_break___0;
      }
#line 452
      green = *(pix->data + ((x * (int )pix->n_channels + y * (int )pix->rowstride) + 1));
#line 454
      *(pix_green->data + (x * (int )pix_green->n_channels + y * pix_green->rowstride)) = green;
#line 450
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 449
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  return (pix_green);
}
}
#line 460 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_color_to_blue(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_blue ;
  int x ;
  int y ;
  unsigned char blue ;

  {
#line 463
  pix_blue = (ho_pixbuf *)((void *)0);
#line 468
  if ((int const   )pix->n_channels < 3) {
#line 469
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 472
  pix_blue = ho_pixbuf_new((unsigned char const   )1, pix->width, pix->height, (int const   )0);
  }
#line 473
  if (! pix_blue) {
#line 474
    return ((ho_pixbuf *)((void *)0));
  }
#line 476
  x = 0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (x < (int )pix->width)) {
#line 476
      goto while_break;
    }
#line 477
    y = 0;
    {
#line 477
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 477
      if (! (y < (int )pix->height)) {
#line 477
        goto while_break___0;
      }
#line 479
      blue = *(pix->data + ((x * (int )pix->n_channels + y * (int )pix->rowstride) + 2));
#line 481
      *(pix_blue->data + (x * (int )pix_blue->n_channels + y * pix_blue->rowstride)) = blue;
#line 477
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 476
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 484
  return (pix_blue);
}
}
#line 487 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_scale2(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_scaled ;
  int x ;
  int y ;
  unsigned char neighbors[4] ;

  {
#line 490
  pix_scaled = (ho_pixbuf *)((void *)0);
#line 495
  if ((int const   )pix->n_channels != 1) {
#line 496
    return ((ho_pixbuf *)((void *)0));
  } else
#line 495
  if (pix->width < 3) {
#line 496
    return ((ho_pixbuf *)((void *)0));
  } else
#line 495
  if (pix->height < 3) {
#line 496
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 499
  pix_scaled = ho_pixbuf_new((unsigned char const   )1, pix->width * 2 - 2, pix->height * 2 - 2,
                             (int const   )0);
  }
#line 500
  if (! pix_scaled) {
#line 501
    return ((ho_pixbuf *)((void *)0));
  }
#line 503
  x = 0;
  {
#line 503
  while (1) {
    while_continue: /* CIL Label */ ;
#line 503
    if (! (x < (int )(pix->width - 1))) {
#line 503
      goto while_break;
    }
#line 504
    y = 0;
    {
#line 504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 504
      if (! (y < (int )(pix->height - 1))) {
#line 504
        goto while_break___0;
      }
#line 506
      neighbors[0] = *(pix->data + (x + y * (int )pix->rowstride));
#line 507
      neighbors[1] = *(pix->data + ((x + 1) + y * (int )pix->rowstride));
#line 508
      neighbors[2] = *(pix->data + (x + (y + 1) * (int )pix->rowstride));
#line 509
      neighbors[3] = *(pix->data + ((x + 1) + (y + 1) * (int )pix->rowstride));
#line 511
      *(pix_scaled->data + (x * 2 + (y * 2) * pix_scaled->rowstride)) = neighbors[0];
#line 513
      *(pix_scaled->data + ((x * 2 + 1) + (y * 2) * pix_scaled->rowstride)) = (unsigned char )(((int )neighbors[0] + (int )neighbors[1]) / 2);
#line 515
      *(pix_scaled->data + (x * 2 + (y * 2 + 1) * pix_scaled->rowstride)) = (unsigned char )(((int )neighbors[0] + (int )neighbors[2]) / 2);
#line 517
      *(pix_scaled->data + ((x * 2 + 1) + (y * 2 + 1) * pix_scaled->rowstride)) = (unsigned char )(((((int )neighbors[0] + (int )neighbors[1]) + (int )neighbors[2]) + (int )neighbors[3]) / 4);
#line 504
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 503
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 522
  return (pix_scaled);
}
}
#line 525 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_scale3(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_scaled ;
  int x ;
  int y ;
  unsigned char neighbors[4] ;

  {
#line 528
  pix_scaled = (ho_pixbuf *)((void *)0);
#line 533
  if ((int const   )pix->n_channels != 1) {
#line 534
    return ((ho_pixbuf *)((void *)0));
  } else
#line 533
  if (pix->width < 3) {
#line 534
    return ((ho_pixbuf *)((void *)0));
  } else
#line 533
  if (pix->height < 3) {
#line 534
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 537
  pix_scaled = ho_pixbuf_new((unsigned char const   )1, pix->width * 3 - 3, pix->height * 3 - 3,
                             (int const   )0);
  }
#line 538
  if (! pix_scaled) {
#line 539
    return ((ho_pixbuf *)((void *)0));
  }
#line 541
  x = 0;
  {
#line 541
  while (1) {
    while_continue: /* CIL Label */ ;
#line 541
    if (! (x < (int )(pix->width - 1))) {
#line 541
      goto while_break;
    }
#line 542
    y = 0;
    {
#line 542
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 542
      if (! (y < (int )(pix->height - 1))) {
#line 542
        goto while_break___0;
      }
#line 544
      neighbors[0] = *(pix->data + (x + y * (int )pix->rowstride));
#line 545
      neighbors[1] = *(pix->data + ((x + 1) + y * (int )pix->rowstride));
#line 546
      neighbors[2] = *(pix->data + (x + (y + 1) * (int )pix->rowstride));
#line 547
      neighbors[3] = *(pix->data + ((x + 1) + (y + 1) * (int )pix->rowstride));
#line 549
      *(pix_scaled->data + (x * 3 + (y * 3) * pix_scaled->rowstride)) = neighbors[0];
#line 552
      *(pix_scaled->data + ((x * 3 + 1) + (y * 3) * pix_scaled->rowstride)) = (unsigned char )(((int )neighbors[0] * 2 + (int )neighbors[1]) / 3);
#line 554
      *(pix_scaled->data + ((x * 3 + 2) + (y * 3) * pix_scaled->rowstride)) = (unsigned char )(((int )neighbors[0] + (int )neighbors[1] * 2) / 3);
#line 557
      *(pix_scaled->data + (x * 3 + (y * 3 + 1) * pix_scaled->rowstride)) = (unsigned char )(((int )neighbors[0] * 2 + (int )neighbors[2]) / 3);
#line 559
      *(pix_scaled->data + (x * 3 + (y * 3 + 2) * pix_scaled->rowstride)) = (unsigned char )(((int )neighbors[0] + (int )neighbors[2] * 2) / 3);
#line 562
      *(pix_scaled->data + ((x * 3 + 1) + (y * 3 + 1) * pix_scaled->rowstride)) = (unsigned char )(((((int )neighbors[0] * 3 + (int )neighbors[1]) + (int )neighbors[2]) + (int )neighbors[3]) / 6);
#line 565
      *(pix_scaled->data + ((x * 3 + 2) + (y * 3 + 1) * pix_scaled->rowstride)) = (unsigned char )(((((int )neighbors[0] + (int )neighbors[1] * 3) + (int )neighbors[2]) + (int )neighbors[3]) / 6);
#line 568
      *(pix_scaled->data + ((x * 3 + 1) + (y * 3 + 2) * pix_scaled->rowstride)) = (unsigned char )(((((int )neighbors[0] + (int )neighbors[1]) + (int )neighbors[2] * 3) + (int )neighbors[3]) / 6);
#line 571
      *(pix_scaled->data + ((x * 3 + 2) + (y * 3 + 2) * pix_scaled->rowstride)) = (unsigned char )(((((int )neighbors[0] + (int )neighbors[1]) + (int )neighbors[2]) + (int )neighbors[3] * 3) / 6);
#line 542
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 541
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 576
  return (pix_scaled);
}
}
#line 579 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_scale4(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_scaled2 ;
  ho_pixbuf *pix_scaled4 ;

  {
  {
#line 583
  pix_scaled2 = (ho_pixbuf *)((void *)0);
#line 584
  pix_scaled4 = (ho_pixbuf *)((void *)0);
#line 586
  pix_scaled2 = ho_pixbuf_scale2(pix);
  }
#line 587
  if (! pix_scaled2) {
#line 588
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 590
  pix_scaled4 = ho_pixbuf_scale2((ho_pixbuf const   *)pix_scaled2);
#line 591
  ho_pixbuf_free(pix_scaled2);
  }
#line 593
  return (pix_scaled4);
}
}
#line 596 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_scale8(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_scaled4 ;
  ho_pixbuf *pix_scaled8 ;

  {
  {
#line 599
  pix_scaled4 = (ho_pixbuf *)((void *)0);
#line 600
  pix_scaled8 = (ho_pixbuf *)((void *)0);
#line 602
  pix_scaled4 = ho_pixbuf_scale4(pix);
  }
#line 603
  if (! pix_scaled4) {
#line 604
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 606
  pix_scaled8 = ho_pixbuf_scale2((ho_pixbuf const   *)pix_scaled4);
#line 607
  ho_pixbuf_free(pix_scaled4);
  }
#line 609
  return (pix_scaled8);
}
}
#line 612 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_scale(ho_pixbuf const   *pix , unsigned char const   scale ) 
{ 
  ho_pixbuf *tmp ;
  ho_pixbuf *tmp___0 ;
  ho_pixbuf *tmp___1 ;
  ho_pixbuf *tmp___2 ;

  {
#line 616
  if ((int const   )scale < 2) {
#line 617
    return ((ho_pixbuf *)((void *)0));
  } else
#line 616
  if ((int const   )pix->n_channels != 1) {
#line 617
    return ((ho_pixbuf *)((void *)0));
  } else
#line 616
  if (pix->width < 3) {
#line 617
    return ((ho_pixbuf *)((void *)0));
  } else
#line 616
  if (pix->height < 3) {
#line 617
    return ((ho_pixbuf *)((void *)0));
  }
#line 619
  if ((int const   )scale == 2) {
    {
#line 620
    tmp = ho_pixbuf_scale2(pix);
    }
#line 620
    return (tmp);
  }
#line 622
  if ((int const   )scale == 3) {
    {
#line 623
    tmp___0 = ho_pixbuf_scale3(pix);
    }
#line 623
    return (tmp___0);
  }
#line 625
  if ((int const   )scale == 4) {
    {
#line 626
    tmp___1 = ho_pixbuf_scale4(pix);
    }
#line 626
    return (tmp___1);
  }
#line 629
  if ((int const   )scale > 4) {
    {
#line 630
    tmp___2 = ho_pixbuf_scale8(pix);
    }
#line 630
    return (tmp___2);
  }
#line 632
  return ((ho_pixbuf *)((void *)0));
}
}
#line 635 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
unsigned char ho_pixbuf_minmax(ho_pixbuf const   *pix , unsigned char *min , unsigned char *max ) 
{ 
  int x ;
  int y ;

  {
#line 640
  *min = (unsigned char)0;
#line 641
  *max = (unsigned char)255;
#line 644
  if ((int const   )pix->n_channels != 1) {
#line 645
    return ((unsigned char)255);
  }
#line 647
  x = 0;
  {
#line 647
  while (1) {
    while_continue: /* CIL Label */ ;
#line 647
    if (! (x < (int )pix->width)) {
#line 647
      goto while_break;
    }
#line 648
    y = 0;
    {
#line 648
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 648
      if (! (y < (int )pix->height)) {
#line 648
        goto while_break___0;
      }
#line 650
      if ((int )*min > (int )*(pix->data + (x + y * (int )pix->rowstride))) {
#line 651
        *min = *(pix->data + (x + y * (int )pix->rowstride));
      }
#line 652
      if ((int )*max < (int )*(pix->data + (x + y * (int )pix->rowstride))) {
#line 653
        *max = *(pix->data + (x + y * (int )pix->rowstride));
      }
#line 648
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 647
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 656
  return ((unsigned char)0);
}
}
#line 659 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_linear_filter(ho_pixbuf const   *pix ) 
{ 
  ho_pixbuf *pix_gray ;
  int x ;
  int y ;
  unsigned char min ;
  unsigned char max ;

  {
#line 662
  pix_gray = (ho_pixbuf *)((void *)0);
#line 667
  if ((int const   )pix->n_channels != 1) {
#line 668
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 671
  pix_gray = ho_pixbuf_new((unsigned char const   )1, pix->width, pix->height, (int const   )0);
  }
#line 672
  if (! pix_gray) {
#line 673
    return ((ho_pixbuf *)((void *)0));
  }
  {
#line 675
  ho_pixbuf_minmax(pix, & min, & max);
#line 676
  x = 0;
  }
  {
#line 676
  while (1) {
    while_continue: /* CIL Label */ ;
#line 676
    if (! (x < (int )pix->width)) {
#line 676
      goto while_break;
    }
#line 677
    y = 0;
    {
#line 677
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 677
      if (! (y < (int )pix->height)) {
#line 677
        goto while_break___0;
      }
#line 679
      *(pix_gray->data + (x + y * pix_gray->rowstride)) = (unsigned char )((255 * ((int )*(pix->data + (x + y * (int )pix->rowstride)) - (int )min)) / ((int )max - (int )min));
#line 677
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 676
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 683
  return (pix_gray);
}
}
#line 686 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_bitmap *ho_pixbuf_to_bitmap(ho_pixbuf const   *pix , unsigned char threshold ) 
{ 
  ho_pixbuf *gray_pix ;
  ho_bitmap *m_out ;
  int x ;
  int y ;

  {
#line 689
  gray_pix = (ho_pixbuf *)((void *)0);
#line 690
  m_out = (ho_bitmap *)((void *)0);
#line 694
  threshold = (unsigned char )((255 * (int )threshold) / 100);
#line 697
  if ((int const   )pix->n_channels > 1) {
    {
#line 698
    gray_pix = ho_pixbuf_color_to_gray(pix);
    }
  } else {
    {
#line 700
    gray_pix = ho_pixbuf_clone(pix);
    }
  }
#line 702
  if (! threshold) {
#line 703
    threshold = (unsigned char)153;
  }
  {
#line 706
  m_out = ho_bitmap_new((int const   )gray_pix->width, (int const   )gray_pix->height);
  }
#line 707
  if (! m_out) {
#line 708
    return ((ho_bitmap *)((void *)0));
  }
#line 711
  x = 0;
  {
#line 711
  while (1) {
    while_continue: /* CIL Label */ ;
#line 711
    if (! (x < gray_pix->width)) {
#line 711
      goto while_break;
    }
#line 712
    y = 0;
    {
#line 712
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 712
      if (! (y < gray_pix->height)) {
#line 712
        goto while_break___0;
      }
#line 713
      if ((int )*(gray_pix->data + (x + y * gray_pix->rowstride)) < (int )threshold) {
#line 714
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
#line 712
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 711
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 717
  ho_pixbuf_free(gray_pix);
  }
#line 719
  return (m_out);
}
}
#line 722 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_bitmap *ho_pixbuf_to_bitmap_by_color(ho_pixbuf const   *pix , unsigned char min_red ,
                                        unsigned char max_red , unsigned char min_green ,
                                        unsigned char max_green , unsigned char min_blue ,
                                        unsigned char max_blue ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;

  {
#line 728
  m_out = (ho_bitmap *)((void *)0);
#line 732
  if ((int const   )pix->n_channels < 3) {
#line 733
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 736
  m_out = ho_bitmap_new(pix->width, pix->height);
  }
#line 737
  if (! m_out) {
#line 738
    return ((ho_bitmap *)((void *)0));
  }
#line 741
  x = 0;
  {
#line 741
  while (1) {
    while_continue: /* CIL Label */ ;
#line 741
    if (! (x < (int )pix->width)) {
#line 741
      goto while_break;
    }
#line 742
    y = 0;
    {
#line 742
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 742
      if (! (y < (int )pix->height)) {
#line 742
        goto while_break___0;
      }
#line 744
      if ((int )*(pix->data + (x + y * (int )pix->rowstride)) >= (int )min_red) {
#line 744
        if ((int )*(pix->data + (x + y * (int )pix->rowstride)) < (int )max_red) {
#line 744
          if ((int )*(pix->data + ((x + y * (int )pix->rowstride) + 1)) >= (int )min_green) {
#line 744
            if ((int )*(pix->data + ((x + y * (int )pix->rowstride) + 1)) < (int )max_green) {
#line 744
              if ((int )*(pix->data + ((x + y * (int )pix->rowstride) + 2)) >= (int )min_blue) {
#line 744
                if ((int )*(pix->data + ((x + y * (int )pix->rowstride) + 2)) < (int )max_blue) {
#line 751
                  *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
                }
              }
            }
          }
        }
      }
#line 742
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 741
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 754
  return (m_out);
}
}
#line 757 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_bitmap *ho_pixbuf_to_bitmap_adaptive(ho_pixbuf const   *pix , unsigned char threshold ,
                                        unsigned char size , unsigned char adaptive_threshold ) 
{ 
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int i ;
  int j ;
  unsigned char locale_thereshold ;
  double sum ;
  int hlf_size ;
  double size_aquare ;
  double factor ;

  {
#line 762
  m_out = (ho_bitmap *)((void *)0);
#line 767
  hlf_size = (int )size / 2;
#line 768
  size_aquare = (double )((int )size * (int )size);
#line 769
  factor = (double )adaptive_threshold / 100.0;
#line 772
  threshold = (unsigned char )((255 * (int )threshold) / 100);
#line 775
  if ((int const   )pix->n_channels != 1) {
#line 776
    return ((ho_bitmap *)((void *)0));
  }
#line 779
  if (! threshold) {
#line 780
    threshold = (unsigned char)0;
  }
#line 782
  if (! factor) {
#line 783
    factor = 6.0 / 8.0;
  }
#line 785
  if (! size) {
#line 787
    size = (unsigned char)70;
#line 788
    hlf_size = (int )size / 2;
#line 789
    size_aquare = (double )((int )size * (int )size);
  }
  {
#line 793
  m_out = ho_bitmap_new(pix->width, pix->height);
  }
#line 794
  if (! m_out) {
#line 795
    return ((ho_bitmap *)((void *)0));
  }
#line 798
  x = 0;
  {
#line 798
  while (1) {
    while_continue: /* CIL Label */ ;
#line 798
    if (! (x < hlf_size)) {
#line 798
      goto while_break;
    }
#line 799
    y = 0;
    {
#line 799
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 799
      if (! (y < (int )pix->height)) {
#line 799
        goto while_break___0;
      }
#line 800
      if ((int )*(pix->data + (x * (int )pix->n_channels + y * (int )pix->rowstride)) < 127) {
#line 801
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
#line 799
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 798
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 802
  x = (int )(pix->width - (int const   )size);
  {
#line 802
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 802
    if (! (x < (int )pix->width)) {
#line 802
      goto while_break___1;
    }
#line 803
    y = 0;
    {
#line 803
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 803
      if (! (y < (int )pix->height)) {
#line 803
        goto while_break___2;
      }
#line 804
      if ((int )*(pix->data + (x * (int )pix->n_channels + y * (int )pix->rowstride)) < 127) {
#line 805
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
#line 803
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 802
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 806
  x = 0;
  {
#line 806
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 806
    if (! (x < (int )pix->width)) {
#line 806
      goto while_break___3;
    }
#line 807
    y = 0;
    {
#line 807
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 807
      if (! (y < hlf_size)) {
#line 807
        goto while_break___4;
      }
#line 808
      if ((int )*(pix->data + (x * (int )pix->n_channels + y * (int )pix->rowstride)) < 127) {
#line 809
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
#line 807
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 806
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 810
  x = 0;
  {
#line 810
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 810
    if (! (x < (int )pix->width)) {
#line 810
      goto while_break___5;
    }
#line 811
    y = (int )(pix->height - (int const   )size);
    {
#line 811
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 811
      if (! (y < (int )pix->height)) {
#line 811
        goto while_break___6;
      }
#line 812
      if ((int )*(pix->data + (x * (int )pix->n_channels + y * (int )pix->rowstride)) < 127) {
#line 813
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
#line 811
      y ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 810
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 816
  x = hlf_size;
  {
#line 816
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 816
    if (! (x < (int )(pix->width - (int const   )hlf_size))) {
#line 816
      goto while_break___7;
    }
#line 817
    y = hlf_size;
    {
#line 817
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 817
      if (! (y < (int )(pix->height - (int const   )hlf_size))) {
#line 817
        goto while_break___8;
      }
#line 820
      sum = (double )0;
#line 821
      i = - hlf_size;
      {
#line 821
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 821
        if (! (i < hlf_size)) {
#line 821
          goto while_break___9;
        }
#line 822
        j = - hlf_size;
        {
#line 822
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 822
          if (! (j < hlf_size)) {
#line 822
            goto while_break___10;
          }
#line 823
          sum += (double )*(pix->data + ((x + i) * (int )pix->n_channels + (y + j) * (int )pix->rowstride));
#line 822
          j ++;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 821
        i ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 826
      locale_thereshold = (unsigned char )((factor * sum) / size_aquare);
#line 827
      if ((int )locale_thereshold < (int )threshold) {
#line 828
        locale_thereshold = threshold;
      }
#line 830
      i = - hlf_size;
      {
#line 830
      while (1) {
        while_continue___11: /* CIL Label */ ;
#line 830
        if (! (i < 0)) {
#line 830
          goto while_break___11;
        }
#line 831
        j = - hlf_size;
        {
#line 831
        while (1) {
          while_continue___12: /* CIL Label */ ;
#line 831
          if (! (j < 0)) {
#line 831
            goto while_break___12;
          }
#line 832
          if ((int )*(pix->data + ((x + i) * (int )pix->n_channels + (y + j) * (int )pix->rowstride)) < (int )locale_thereshold) {
#line 833
            *(m_out->data + ((x + i) / 8 + (y + j) * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + ((x + i) / 8 + (y + j) * m_out->rowstride)) | (128 >> (x + i) % 8));
          }
#line 831
          j ++;
        }
        while_break___12: /* CIL Label */ ;
        }
#line 830
        i ++;
      }
      while_break___11: /* CIL Label */ ;
      }
#line 817
      y += hlf_size;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 816
    x += hlf_size;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 837
  return (m_out);
}
}
#line 840 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_bitmap *ho_pixbuf_to_bitmap_adaptive_fine(ho_pixbuf const   *pix , unsigned char threshold ,
                                             unsigned char size , unsigned char adaptive_threshold ) 
{ 
  ho_pixbuf *m_thresholds ;
  ho_bitmap *m_out ;
  int x ;
  int y ;
  int i ;
  int j ;
  unsigned char locale_thereshold ;
  double sum ;
  double first_row ;
  double last_row ;
  double hlf_size ;
  double size_aquare ;
  double factor ;

  {
#line 844
  m_thresholds = (ho_pixbuf *)((void *)0);
#line 845
  m_out = (ho_bitmap *)((void *)0);
#line 850
  hlf_size = (double )size / 2.0;
#line 851
  size_aquare = (double )((int )size * (int )size);
#line 852
  factor = (double )adaptive_threshold / 100.0;
#line 855
  threshold = (unsigned char )((255 * (int )threshold) / 100);
#line 858
  if ((int const   )pix->n_channels != 1) {
#line 859
    return ((ho_bitmap *)((void *)0));
  }
#line 862
  if (! threshold) {
#line 863
    threshold = (unsigned char)0;
  }
#line 865
  if (! factor) {
#line 866
    factor = 80.0 / 100.0;
  }
#line 868
  if (! size) {
#line 870
    size = (unsigned char)70;
#line 871
    hlf_size = (double )size / 2.0;
#line 872
    size_aquare = (double )((int )size * (int )size);
  }
  {
#line 876
  m_out = ho_bitmap_new(pix->width, pix->height);
  }
#line 877
  if (! m_out) {
#line 878
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 880
  m_thresholds = ho_pixbuf_new((unsigned char const   )1, pix->width, pix->height,
                               (int const   )0);
  }
#line 881
  if (! m_thresholds) {
    {
#line 883
    ho_bitmap_free(m_out);
    }
#line 884
    return ((ho_bitmap *)((void *)0));
  }
#line 888
  x = 0;
  {
#line 888
  while (1) {
    while_continue: /* CIL Label */ ;
#line 888
    if (! ((double )x < hlf_size)) {
#line 888
      goto while_break;
    }
#line 889
    y = 0;
    {
#line 889
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 889
      if (! (y < (int )pix->height)) {
#line 889
        goto while_break___0;
      }
#line 890
      *(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride)) = (unsigned char)127;
#line 889
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 888
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 891
  x = (int )((double )pix->width - hlf_size);
  {
#line 891
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 891
    if (! (x < (int )pix->width)) {
#line 891
      goto while_break___1;
    }
#line 892
    y = 0;
    {
#line 892
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 892
      if (! (y < (int )pix->height)) {
#line 892
        goto while_break___2;
      }
#line 893
      *(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride)) = (unsigned char)127;
#line 892
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 891
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 894
  x = 0;
  {
#line 894
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 894
    if (! (x < (int )pix->width)) {
#line 894
      goto while_break___3;
    }
#line 895
    y = 0;
    {
#line 895
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 895
      if (! ((double )y < hlf_size)) {
#line 895
        goto while_break___4;
      }
#line 896
      *(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride)) = (unsigned char)127;
#line 895
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 894
    x ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 897
  x = 0;
  {
#line 897
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 897
    if (! (x < (int )pix->width)) {
#line 897
      goto while_break___5;
    }
#line 898
    y = (int )((double )pix->height - hlf_size);
    {
#line 898
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 898
      if (! (y < (int )pix->height)) {
#line 898
        goto while_break___6;
      }
#line 899
      *(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride)) = (unsigned char)127;
#line 898
      y ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 897
    x ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 902
  x = (int )hlf_size;
  {
#line 902
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 902
    if (! ((double )x < (double )pix->width - hlf_size)) {
#line 902
      goto while_break___7;
    }
#line 905
    y = (int )hlf_size;
#line 906
    sum = (double )0;
#line 907
    i = (int )(- hlf_size);
    {
#line 907
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 907
      if (! ((double )i < hlf_size)) {
#line 907
        goto while_break___8;
      }
#line 908
      j = (int )(- hlf_size);
      {
#line 908
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 908
        if (! ((double )j < hlf_size)) {
#line 908
          goto while_break___9;
        }
#line 910
        sum += (double )*(pix->data + ((x + i) + (y + j) * (int )pix->rowstride));
#line 908
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 907
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 914
    first_row = (double )0;
#line 915
    i = (int )(- hlf_size);
    {
#line 915
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 915
      if (! ((double )i < hlf_size)) {
#line 915
        goto while_break___10;
      }
#line 917
      first_row += (double )*(pix->data + ((x + i) + (y - (int )hlf_size) * (int )pix->rowstride));
#line 915
      i ++;
    }
    while_break___10: /* CIL Label */ ;
    }
#line 919
    last_row = (double )0;
#line 920
    i = (int )(- hlf_size);
    {
#line 920
    while (1) {
      while_continue___11: /* CIL Label */ ;
#line 920
      if (! ((double )i < hlf_size)) {
#line 920
        goto while_break___11;
      }
#line 922
      last_row += (double )*(pix->data + ((x + i) + (y + (int )hlf_size) * (int )pix->rowstride));
#line 920
      i ++;
    }
    while_break___11: /* CIL Label */ ;
    }
#line 926
    locale_thereshold = (unsigned char )((sum / size_aquare) * factor);
#line 927
    if ((int )locale_thereshold < (int )threshold) {
#line 928
      *(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride)) = threshold;
    } else {
#line 930
      *(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride)) = locale_thereshold;
    }
#line 933
    y = (int )(hlf_size + (double )1);
    {
#line 933
    while (1) {
      while_continue___12: /* CIL Label */ ;
#line 933
      if (! (y < (int )(pix->height - (int const   )((int )hlf_size)))) {
#line 933
        goto while_break___12;
      }
#line 936
      sum += last_row - first_row;
#line 937
      first_row = (double )0;
#line 938
      i = (int )(- hlf_size);
      {
#line 938
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 938
        if (! ((double )i < hlf_size)) {
#line 938
          goto while_break___13;
        }
#line 940
        first_row += (double )*(pix->data + ((x + i) + (y - (int )hlf_size) * (int )pix->rowstride));
#line 938
        i ++;
      }
      while_break___13: /* CIL Label */ ;
      }
#line 943
      last_row = (double )0;
#line 944
      i = (int )(- hlf_size);
      {
#line 944
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 944
        if (! ((double )i < hlf_size)) {
#line 944
          goto while_break___14;
        }
#line 946
        last_row += (double )*(pix->data + ((x + i) + (y + (int )hlf_size) * (int )pix->rowstride));
#line 944
        i ++;
      }
      while_break___14: /* CIL Label */ ;
      }
#line 951
      locale_thereshold = (unsigned char )((sum / size_aquare) * factor);
#line 952
      if ((int )locale_thereshold < (int )threshold) {
#line 953
        *(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride)) = threshold;
      } else {
#line 955
        *(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride)) = locale_thereshold;
      }
#line 933
      y ++;
    }
    while_break___12: /* CIL Label */ ;
    }
#line 902
    x ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 960
  x = 0;
  {
#line 960
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 960
    if (! (x < (int )pix->width)) {
#line 960
      goto while_break___15;
    }
#line 961
    y = 0;
    {
#line 961
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 961
      if (! (y < (int )pix->height)) {
#line 961
        goto while_break___16;
      }
#line 962
      if ((int )*(pix->data + (x * (int )pix->n_channels + y * (int )pix->rowstride)) < (int )*(m_thresholds->data + (x * (int )m_thresholds->n_channels + y * m_thresholds->rowstride))) {
#line 963
        *(m_out->data + (x / 8 + y * m_out->rowstride)) = (unsigned char )((int )*(m_out->data + (x / 8 + y * m_out->rowstride)) | (128 >> x % 8));
      }
#line 961
      y ++;
    }
    while_break___16: /* CIL Label */ ;
    }
#line 960
    x ++;
  }
  while_break___15: /* CIL Label */ ;
  }
  {
#line 965
  ho_pixbuf_free(m_thresholds);
  }
#line 967
  return (m_out);
}
}
#line 970 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_bitmap *ho_pixbuf_to_bitmap_wrapper(ho_pixbuf const   *pix_in , unsigned char const   scale ,
                                       unsigned char const   adaptive , unsigned char const   threshold ,
                                       unsigned char const   a_threshold , unsigned char const   size ) 
{ 
  ho_pixbuf *pix ;
  ho_pixbuf *pix_temp ;
  ho_bitmap *m_bw ;

  {
#line 977
  pix = (ho_pixbuf *)((void *)0);
#line 978
  pix_temp = (ho_pixbuf *)((void *)0);
#line 979
  m_bw = (ho_bitmap *)((void *)0);
#line 982
  if ((int const   )pix_in->n_channels > 1) {
    {
#line 983
    pix = ho_pixbuf_color_to_gray(pix_in);
    }
  } else {
    {
#line 985
    pix = ho_pixbuf_clone(pix_in);
    }
  }
#line 987
  if (! pix) {
#line 988
    return ((ho_bitmap *)((void *)0));
  }
  {
#line 991
  pix_temp = ho_pixbuf_linear_filter((ho_pixbuf const   *)pix);
#line 992
  ho_pixbuf_free(pix);
  }
#line 993
  if (! pix_temp) {
#line 994
    return ((ho_bitmap *)((void *)0));
  }
#line 995
  pix = pix_temp;
#line 998
  if ((int const   )scale > 1) {
    {
#line 1000
    pix_temp = ho_pixbuf_scale((ho_pixbuf const   *)pix, scale);
#line 1001
    ho_pixbuf_free(pix);
    }
#line 1002
    if (! pix_temp) {
#line 1003
      return ((ho_bitmap *)((void *)0));
    }
#line 1004
    pix = pix_temp;
  }
  {
#line 1010
  if ((int const   )adaptive == 0) {
#line 1010
    goto case_0;
  }
#line 1013
  if ((int const   )adaptive == 1) {
#line 1013
    goto case_1;
  }
#line 1016
  if ((int const   )adaptive == 2) {
#line 1016
    goto case_2;
  }
#line 1020
  goto switch_default;
  case_0: /* CIL Label */ 
  {
#line 1011
  m_bw = ho_pixbuf_to_bitmap_adaptive((ho_pixbuf const   *)pix, (unsigned char )threshold,
                                      (unsigned char )size, (unsigned char )a_threshold);
  }
#line 1012
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 1014
  m_bw = ho_pixbuf_to_bitmap((ho_pixbuf const   *)pix, (unsigned char )threshold);
  }
#line 1015
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 1017
  m_bw = ho_pixbuf_to_bitmap_adaptive_fine((ho_pixbuf const   *)pix, (unsigned char )threshold,
                                           (unsigned char )size, (unsigned char )a_threshold);
  }
#line 1019
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 1021
  m_bw = ho_pixbuf_to_bitmap_adaptive((ho_pixbuf const   *)pix, (unsigned char )threshold,
                                      (unsigned char )size, (unsigned char )a_threshold);
  }
#line 1022
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 1025
  ho_pixbuf_free(pix);
  }
#line 1027
  return (m_bw);
}
}
#line 1030 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_bitmap(ho_pixbuf *m , ho_bitmap const   *bit_in , unsigned char const   red ,
                          unsigned char const   green , unsigned char const   blue ,
                          unsigned char const   alpha ) 
{ 
  int x ;
  int y ;
  unsigned char new_red ;
  unsigned char new_green ;
  unsigned char new_blue ;
  int tmp ;
  int tmp___0 ;

  {
#line 1041
  if (bit_in->x != 0) {
    {
#line 1043
    ho_pixbuf_draw_bitmap_at(m, bit_in, bit_in->x, bit_in->y, red, green, blue, alpha);
    }
  } else
#line 1041
  if (bit_in->y != 0) {
    {
#line 1043
    ho_pixbuf_draw_bitmap_at(m, bit_in, bit_in->x, bit_in->y, red, green, blue, alpha);
    }
  } else
#line 1041
  if (m->width > (int )bit_in->width) {
    {
#line 1043
    ho_pixbuf_draw_bitmap_at(m, bit_in, bit_in->x, bit_in->y, red, green, blue, alpha);
    }
  } else
#line 1041
  if (m->height > (int )bit_in->height) {
    {
#line 1043
    ho_pixbuf_draw_bitmap_at(m, bit_in, bit_in->x, bit_in->y, red, green, blue, alpha);
    }
  }
#line 1047
  if (m->width != (int )bit_in->width) {
#line 1048
    return (-1);
  } else
#line 1047
  if (m->height != (int )bit_in->height) {
#line 1048
    return (-1);
  }
#line 1051
  if ((int )m->n_channels < 3) {
#line 1053
    x = 0;
    {
#line 1053
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1053
      if (! (x < (int )bit_in->width)) {
#line 1053
        goto while_break;
      }
#line 1054
      y = 0;
      {
#line 1054
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1054
        if (! (y < (int )bit_in->height)) {
#line 1054
          goto while_break___0;
        }
#line 1055
        if (((int )*(bit_in->data + (x / 8 + y * (int )bit_in->rowstride)) & (128 >> x % 8)) > 0) {
#line 1055
          tmp = 1;
        } else {
#line 1055
          tmp = 0;
        }
#line 1055
        if (tmp) {
#line 1057
          new_red = (unsigned char )(((int const   )alpha * (int const   )red) / 255 + (int const   )(((255 - (int )alpha) * (int )*(m->data + (x * (int )m->n_channels + y * m->rowstride))) / 255));
#line 1060
          *(m->data + (x * (int )m->n_channels + y * m->rowstride)) = new_red;
        }
#line 1054
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1053
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1065
    x = 0;
    {
#line 1065
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1065
      if (! (x < (int )bit_in->width)) {
#line 1065
        goto while_break___1;
      }
#line 1066
      y = 0;
      {
#line 1066
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1066
        if (! (y < (int )bit_in->height)) {
#line 1066
          goto while_break___2;
        }
#line 1067
        if (((int )*(bit_in->data + (x / 8 + y * (int )bit_in->rowstride)) & (128 >> x % 8)) > 0) {
#line 1067
          tmp___0 = 1;
        } else {
#line 1067
          tmp___0 = 0;
        }
#line 1067
        if (tmp___0) {
#line 1069
          new_red = (unsigned char )(((int const   )alpha * (int const   )red) / 255 + (int const   )(((255 - (int )alpha) * (int )*(m->data + (x * (int )m->n_channels + y * m->rowstride))) / 255));
#line 1072
          new_green = (unsigned char )(((int const   )alpha * (int const   )green) / 255 + (int const   )(((255 - (int )alpha) * (int )*(m->data + ((x * (int )m->n_channels + y * m->rowstride) + 1))) / 255));
#line 1075
          new_blue = (unsigned char )(((int const   )alpha * (int const   )blue) / 255 + (int const   )(((255 - (int )alpha) * (int )*(m->data + ((x * (int )m->n_channels + y * m->rowstride) + 2))) / 255));
#line 1079
          *(m->data + (x * (int )m->n_channels + y * m->rowstride)) = new_red;
#line 1080
          *(m->data + ((x * (int )m->n_channels + y * m->rowstride) + 1)) = new_green;
#line 1081
          *(m->data + ((x * (int )m->n_channels + y * m->rowstride) + 2)) = new_blue;
        }
#line 1066
        y ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1065
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1085
  return (0);
}
}
#line 1088 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_bitmap_at(ho_pixbuf *m , ho_bitmap const   *bit_in , int const   x1 ,
                             int const   y1___0 , unsigned char const   red , unsigned char const   green ,
                             unsigned char const   blue , unsigned char const   alpha ) 
{ 
  int x ;
  int y ;
  unsigned char new_red ;
  unsigned char new_green ;
  unsigned char new_blue ;
  int tmp ;
  int tmp___0 ;

  {
#line 1100
  if ((int )m->n_channels < 3) {
#line 1102
    x = 0;
    {
#line 1102
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1102
      if (! (x < (int )bit_in->width)) {
#line 1102
        goto while_break;
      }
#line 1103
      y = 0;
      {
#line 1103
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1103
        if (! (y < (int )bit_in->height)) {
#line 1103
          goto while_break___0;
        }
#line 1104
        if (x + (int )x1 >= 0) {
#line 1104
          if (x + (int )x1 < m->width) {
#line 1104
            if (y + (int )y1___0 >= 0) {
#line 1104
              if (y + (int )y1___0 < m->height) {
#line 1106
                if (((int )*(bit_in->data + (x / 8 + y * (int )bit_in->rowstride)) & (128 >> x % 8)) > 0) {
#line 1106
                  tmp = 1;
                } else {
#line 1106
                  tmp = 0;
                }
#line 1106
                if (tmp) {
#line 1108
                  new_red = (unsigned char )(((int const   )alpha * (int const   )red) / 255 + (int const   )(((255 - (int )alpha) * (int )*(m->data + ((x + (int )x1) * (int )m->n_channels + (y + (int )y1___0) * m->rowstride))) / 255));
#line 1111
                  *(m->data + ((x + (int )x1) * (int )m->n_channels + (y + (int )y1___0) * m->rowstride)) = new_red;
                }
              }
            }
          }
        }
#line 1103
        y ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1102
      x ++;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1116
    x = 0;
    {
#line 1116
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1116
      if (! (x < (int )bit_in->width)) {
#line 1116
        goto while_break___1;
      }
#line 1117
      y = 0;
      {
#line 1117
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 1117
        if (! (y < (int )bit_in->height)) {
#line 1117
          goto while_break___2;
        }
#line 1118
        if (x + (int )x1 >= 0) {
#line 1118
          if (x + (int )x1 < m->width) {
#line 1118
            if (y + (int )y1___0 >= 0) {
#line 1118
              if (y + (int )y1___0 < m->height) {
#line 1120
                if (((int )*(bit_in->data + (x / 8 + y * (int )bit_in->rowstride)) & (128 >> x % 8)) > 0) {
#line 1120
                  tmp___0 = 1;
                } else {
#line 1120
                  tmp___0 = 0;
                }
#line 1120
                if (tmp___0) {
#line 1122
                  new_red = (unsigned char )(((int const   )alpha * (int const   )red) / 255 + (int const   )(((255 - (int )alpha) * (int )*(m->data + ((x + (int )x1) * (int )m->n_channels + (y + (int )y1___0) * m->rowstride))) / 255));
#line 1125
                  new_green = (unsigned char )(((int const   )alpha * (int const   )green) / 255 + (int const   )(((255 - (int )alpha) * (int )*(m->data + (((x + (int )x1) * (int )m->n_channels + (y + (int )y1___0) * m->rowstride) + 1))) / 255));
#line 1128
                  new_blue = (unsigned char )(((int const   )alpha * (int const   )blue) / 255 + (int const   )(((255 - (int )alpha) * (int )*(m->data + (((x + (int )x1) * (int )m->n_channels + (y + (int )y1___0) * m->rowstride) + 2))) / 255));
#line 1132
                  *(m->data + ((x + (int )x1) * (int )m->n_channels + (y + (int )y1___0) * m->rowstride)) = new_red;
#line 1133
                  *(m->data + (((x + (int )x1) * (int )m->n_channels + (y + (int )y1___0) * m->rowstride) + 1)) = new_green;
#line 1134
                  *(m->data + (((x + (int )x1) * (int )m->n_channels + (y + (int )y1___0) * m->rowstride) + 2)) = new_blue;
                }
              }
            }
          }
        }
#line 1117
        y ++;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 1116
      x ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 1138
  return (0);
}
}
#line 1141 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_line(ho_pixbuf *m , int const   x1 , int const   y1___0 , int const   x2 ,
                        int const   y2 , unsigned char const   red , unsigned char const   green ,
                        unsigned char const   blue ) 
{ 
  double x ;
  double step_x ;
  double y ;
  double step_y ;
  int x_start ;
  int x_end ;
  int y_start ;
  int y_end ;

  {
#line 1148
  x_start = (int )x1;
#line 1149
  x_end = (int )x2;
#line 1150
  y_start = (int )y1___0;
#line 1151
  y_end = (int )y2;
#line 1153
  step_x = ((double )x2 - (double )x1) * ((double )x2 - (double )x1);
#line 1154
  step_y = ((double )y2 - (double )y1___0) * ((double )y2 - (double )y1___0);
#line 1156
  if (step_y > step_x) {
#line 1159
    if (y1___0 > y2) {
#line 1161
      x_start = (int )x2;
#line 1162
      x_end = (int )x1;
#line 1163
      y_start = (int )y2;
#line 1164
      y_end = (int )y1___0;
    }
#line 1167
    x = (double )x_start;
#line 1168
    step_x = ((double )x_end - (double )x_start) / ((double )y_end - (double )y_start);
#line 1170
    y = (double )y_start;
    {
#line 1170
    while (1) {
      while_continue: /* CIL Label */ ;
#line 1170
      if (! (y <= (double )y_end)) {
#line 1170
        goto while_break;
      }
#line 1172
      *(m->data + ((int )x * (int )m->n_channels + (int )y * m->rowstride)) = (unsigned char )red;
#line 1173
      if ((int )m->n_channels >= 3) {
#line 1175
        *(m->data + (((int )x * (int )m->n_channels + (int )y * m->rowstride) + 1)) = (unsigned char )green;
#line 1176
        *(m->data + (((int )x * (int )m->n_channels + (int )y * m->rowstride) + 2)) = (unsigned char )blue;
      }
#line 1178
      x += step_x;
#line 1170
      y += (double )1;
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 1184
    if (x1 > x2) {
#line 1186
      x_start = (int )x2;
#line 1187
      x_end = (int )x1;
#line 1188
      y_start = (int )y2;
#line 1189
      y_end = (int )y1___0;
    }
#line 1192
    y = (double )y_start;
#line 1193
    step_y = ((double )y_end - (double )y_start) / ((double )x_end - (double )x_start);
#line 1195
    x = (double )x_start;
    {
#line 1195
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1195
      if (! (x <= (double )x_end)) {
#line 1195
        goto while_break___0;
      }
#line 1197
      *(m->data + ((int )x * (int )m->n_channels + (int )y * m->rowstride)) = (unsigned char )red;
#line 1198
      if ((int )m->n_channels >= 3) {
#line 1200
        *(m->data + (((int )x * (int )m->n_channels + (int )y * m->rowstride) + 1)) = (unsigned char )green;
#line 1201
        *(m->data + (((int )x * (int )m->n_channels + (int )y * m->rowstride) + 2)) = (unsigned char )blue;
      }
#line 1203
      y += step_y;
#line 1195
      x += (double )1;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 1207
  return (0);
}
}
#line 1210 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_box(ho_pixbuf *m , int const   x , int const   y , int const   width ,
                       int const   height , unsigned char const   red , unsigned char const   green ,
                       unsigned char const   blue , unsigned char const   alpha ) 
{ 
  int x1 ;
  int y1___0 ;
  int r ;
  int g ;
  int b ;

  {
#line 1220
  x1 = (int )x;
  {
#line 1220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1220
    if (x1 < (int )(x + width)) {
#line 1220
      if (! (x1 < m->width)) {
#line 1220
        goto while_break;
      }
    } else {
#line 1220
      goto while_break;
    }
#line 1221
    y1___0 = (int )y;
    {
#line 1221
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1221
      if (y1___0 < (int )(y + height)) {
#line 1221
        if (! (y1___0 < m->height)) {
#line 1221
          goto while_break___0;
        }
      } else {
#line 1221
        goto while_break___0;
      }
#line 1223
      r = ((int )*(m->data + (x1 * (int )m->n_channels + y1___0 * m->rowstride)) * (255 - (int )alpha) + (int )red * (int )alpha) / 255;
#line 1225
      g = ((int )*(m->data + ((x1 * (int )m->n_channels + y1___0 * m->rowstride) + 1)) * (255 - (int )alpha) + (int )green * (int )alpha) / 255;
#line 1227
      b = ((int )*(m->data + ((x1 * (int )m->n_channels + y1___0 * m->rowstride) + 2)) * (255 - (int )alpha) + (int )blue * (int )alpha) / 255;
#line 1230
      *(m->data + (x1 * (int )m->n_channels + y1___0 * m->rowstride)) = (unsigned char )r;
#line 1231
      *(m->data + ((x1 * (int )m->n_channels + y1___0 * m->rowstride) + 1)) = (unsigned char )g;
#line 1232
      *(m->data + ((x1 * (int )m->n_channels + y1___0 * m->rowstride) + 2)) = (unsigned char )b;
#line 1221
      y1___0 ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1220
    x1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1235
  return (0);
}
}
#line 1238 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_box_empty(ho_pixbuf *m , int const   x , int const   y , int const   width ,
                             int const   height , unsigned char const   red , unsigned char const   green ,
                             unsigned char const   blue ) 
{ 
  int x1 ;
  int y1___0 ;

  {
#line 1247
  x1 = (int )x;
  {
#line 1247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1247
    if (x1 < (int )(x + width)) {
#line 1247
      if (! (x1 < m->width)) {
#line 1247
        goto while_break;
      }
    } else {
#line 1247
      goto while_break;
    }
#line 1249
    *(m->data + (x1 * (int )m->n_channels + (int )(y * (int const   )m->rowstride))) = (unsigned char )red;
#line 1250
    *(m->data + ((x1 * (int )m->n_channels + (int )(y * (int const   )m->rowstride)) + 1)) = (unsigned char )green;
#line 1251
    *(m->data + ((x1 * (int )m->n_channels + (int )(y * (int const   )m->rowstride)) + 2)) = (unsigned char )blue;
#line 1253
    *(m->data + (x1 * (int )m->n_channels + (int )(((y + height) - 1) * (int const   )m->rowstride))) = (unsigned char )red;
#line 1254
    *(m->data + ((x1 * (int )m->n_channels + (int )(((y + height) - 1) * (int const   )m->rowstride)) + 1)) = (unsigned char )green;
#line 1255
    *(m->data + ((x1 * (int )m->n_channels + (int )(((y + height) - 1) * (int const   )m->rowstride)) + 2)) = (unsigned char )blue;
#line 1247
    x1 ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1258
  y1___0 = (int )y;
  {
#line 1258
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1258
    if (y1___0 < (int )(y + height)) {
#line 1258
      if (! (y1___0 < m->height)) {
#line 1258
        goto while_break___0;
      }
    } else {
#line 1258
      goto while_break___0;
    }
#line 1260
    *(m->data + (x * (int const   )m->n_channels + (int const   )(y1___0 * m->rowstride))) = (unsigned char )red;
#line 1261
    *(m->data + ((x * (int const   )m->n_channels + (int const   )(y1___0 * m->rowstride)) + 1)) = (unsigned char )green;
#line 1262
    *(m->data + ((x * (int const   )m->n_channels + (int const   )(y1___0 * m->rowstride)) + 2)) = (unsigned char )blue;
#line 1264
    *(m->data + (((x + width) - 1) * (int const   )m->n_channels + (int const   )(y1___0 * m->rowstride))) = (unsigned char )red;
#line 1265
    *(m->data + ((((x + width) - 1) * (int const   )m->n_channels + (int const   )(y1___0 * m->rowstride)) + 1)) = (unsigned char )green;
#line 1266
    *(m->data + ((((x + width) - 1) * (int const   )m->n_channels + (int const   )(y1___0 * m->rowstride)) + 2)) = (unsigned char )blue;
#line 1258
    y1___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1269
  return (0);
}
}
#line 1272 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_horizontal_scale(ho_pixbuf *m , int const   x1 , int const   y1___0 ,
                                    int const   length , int const   step , unsigned char const   red ,
                                    unsigned char const   green , unsigned char const   blue ) 
{ 
  int x ;

  {
#line 1280
  x = 0;
  {
#line 1280
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1280
    if (! (x <= (int )length)) {
#line 1280
      goto while_break;
    }
#line 1282
    *(m->data + ((x1 + (int const   )x) * (int const   )m->n_channels + y1___0 * (int const   )m->rowstride)) = (unsigned char )red;
#line 1283
    if ((int )m->n_channels >= 3) {
#line 1285
      *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + y1___0 * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1286
      *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + y1___0 * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
    }
#line 1289
    if (! (x % (int )step)) {
#line 1291
      *(m->data + ((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 4) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1292
      *(m->data + ((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 3) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1293
      *(m->data + ((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 2) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1294
      *(m->data + ((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 2) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1295
      *(m->data + ((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 3) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1296
      *(m->data + ((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 4) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1298
      if ((int )m->n_channels >= 3) {
#line 1300
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 4) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1301
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 3) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1302
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 2) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1303
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 2) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1304
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 3) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1305
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 4) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1307
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 4) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1308
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 3) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1309
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 - 2) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1310
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 2) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1311
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 3) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1312
        *(m->data + (((x1 + (int const   )x) * (int const   )m->n_channels + (y1___0 + 4) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
      }
    }
#line 1280
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1317
  return (0);
}
}
#line 1320 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_vertical_scale(ho_pixbuf *m , int const   x1 , int const   y1___0 ,
                                  int const   length , int const   step , unsigned char const   red ,
                                  unsigned char const   green , unsigned char const   blue ) 
{ 
  int y ;

  {
#line 1328
  y = 0;
  {
#line 1328
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1328
    if (! (y <= (int )length)) {
#line 1328
      goto while_break;
    }
#line 1330
    *(m->data + (x1 * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1331
    if ((int )m->n_channels >= 3) {
#line 1333
      *(m->data + ((x1 * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1334
      *(m->data + ((x1 * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
    }
#line 1337
    if (! (y % (int )step)) {
#line 1339
      *(m->data + ((x1 - 4) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1340
      *(m->data + ((x1 - 3) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1341
      *(m->data + ((x1 - 2) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1342
      *(m->data + ((x1 + 2) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1343
      *(m->data + ((x1 + 3) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1344
      *(m->data + ((x1 + 4) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride)) = (unsigned char )red;
#line 1346
      if ((int )m->n_channels >= 3) {
#line 1348
        *(m->data + (((x1 - 4) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1349
        *(m->data + (((x1 - 3) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1350
        *(m->data + (((x1 - 2) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1351
        *(m->data + (((x1 + 2) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1352
        *(m->data + (((x1 + 3) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1353
        *(m->data + (((x1 + 4) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 1)) = (unsigned char )green;
#line 1355
        *(m->data + (((x1 - 4) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1356
        *(m->data + (((x1 - 3) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1357
        *(m->data + (((x1 - 2) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1358
        *(m->data + (((x1 + 2) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1359
        *(m->data + (((x1 + 3) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
#line 1360
        *(m->data + (((x1 + 4) * (int const   )m->n_channels + (y1___0 + (int const   )y) * (int const   )m->rowstride) + 2)) = (unsigned char )blue;
      }
    }
#line 1328
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1365
  return (0);
}
}
#line 1368 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_grid(ho_pixbuf *m , int const   size , int const   step , unsigned char const   red ,
                        unsigned char const   green , unsigned char const   blue ) 
{ 
  int i ;

  {
#line 1375
  if (m->width < 120) {
#line 1376
    return (-1);
  } else
#line 1375
  if (m->height < 120) {
#line 1376
    return (-1);
  }
#line 1379
  i = 60;
  {
#line 1379
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1379
    if (! (i < m->width - 60)) {
#line 1379
      goto while_break;
    }
    {
#line 1381
    ho_pixbuf_draw_vertical_scale(m, (int const   )i, (int const   )30, (int const   )(m->height - 60),
                                  step, red, green, blue);
#line 1379
    i += (int )size;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1385
  i = 60;
  {
#line 1385
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1385
    if (! (i < m->height - 60)) {
#line 1385
      goto while_break___0;
    }
    {
#line 1387
    ho_pixbuf_draw_horizontal_scale(m, (int const   )30, (int const   )i, (int const   )(m->width - 60),
                                    step, red, green, blue);
#line 1385
    i += (int )size;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1391
  return (0);
}
}
#line 1394 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_rgb_bitmap(ho_pixbuf *m , ho_bitmap const   *bit_in_red , ho_bitmap const   *bit_in_green ,
                              ho_bitmap const   *bit_in_blue ) 
{ 
  int x ;
  int y ;
  unsigned char new_red ;
  unsigned char new_green ;
  unsigned char new_blue ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 1404
  if (m->width != (int )bit_in_red->width) {
#line 1405
    return (-1);
  } else
#line 1404
  if (m->height != (int )bit_in_red->height) {
#line 1405
    return (-1);
  }
#line 1408
  if ((int )m->n_channels < 3) {
#line 1409
    return (-1);
  }
#line 1411
  x = 0;
  {
#line 1411
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1411
    if (! (x < (int )bit_in_red->width)) {
#line 1411
      goto while_break;
    }
#line 1412
    y = 0;
    {
#line 1412
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1412
      if (! (y < (int )bit_in_red->height)) {
#line 1412
        goto while_break___0;
      }
#line 1414
      if (((int )*(bit_in_red->data + (x / 8 + y * (int )bit_in_red->rowstride)) & (128 >> x % 8)) > 0) {
#line 1414
        tmp = 1;
      } else {
#line 1414
        tmp = 0;
      }
#line 1414
      new_red = (unsigned char )(255 * tmp);
#line 1415
      if (((int )*(bit_in_green->data + (x / 8 + y * (int )bit_in_green->rowstride)) & (128 >> x % 8)) > 0) {
#line 1415
        tmp___0 = 1;
      } else {
#line 1415
        tmp___0 = 0;
      }
#line 1415
      new_green = (unsigned char )(255 * tmp___0);
#line 1416
      if (((int )*(bit_in_blue->data + (x / 8 + y * (int )bit_in_blue->rowstride)) & (128 >> x % 8)) > 0) {
#line 1416
        tmp___1 = 1;
      } else {
#line 1416
        tmp___1 = 0;
      }
#line 1416
      new_blue = (unsigned char )(255 * tmp___1);
#line 1418
      *(m->data + (x * (int )m->n_channels + y * m->rowstride)) = new_red;
#line 1419
      *(m->data + ((x * (int )m->n_channels + y * m->rowstride) + 1)) = new_green;
#line 1420
      *(m->data + ((x * (int )m->n_channels + y * m->rowstride) + 2)) = new_blue;
#line 1412
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1411
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1423
  return (0);
}
}
#line 1426 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_draw_rgb_pixbufs(ho_pixbuf *m , ho_pixbuf const   *bit_in_red , ho_pixbuf const   *bit_in_green ,
                               ho_pixbuf const   *bit_in_blue ) 
{ 
  int x ;
  int y ;
  unsigned char new_red ;
  unsigned char new_green ;
  unsigned char new_blue ;

  {
#line 1436
  if (m->width != (int )bit_in_red->width) {
#line 1437
    return (-1);
  } else
#line 1436
  if (m->height != (int )bit_in_red->height) {
#line 1437
    return (-1);
  }
#line 1440
  if ((int )m->n_channels < 3) {
#line 1441
    return (-1);
  } else
#line 1440
  if ((int const   )bit_in_red->n_channels > 1) {
#line 1441
    return (-1);
  }
#line 1443
  x = 0;
  {
#line 1443
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1443
    if (! (x < (int )bit_in_red->width)) {
#line 1443
      goto while_break;
    }
#line 1444
    y = 0;
    {
#line 1444
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1444
      if (! (y < (int )bit_in_red->height)) {
#line 1444
        goto while_break___0;
      }
#line 1446
      new_red = *(bit_in_red->data + (x * (int )bit_in_red->n_channels + y * (int )bit_in_red->rowstride));
#line 1447
      new_green = *(bit_in_green->data + (x * (int )bit_in_green->n_channels + y * (int )bit_in_green->rowstride));
#line 1448
      new_blue = *(bit_in_blue->data + (x * (int )bit_in_blue->n_channels + y * (int )bit_in_blue->rowstride));
#line 1450
      *(m->data + (x * (int )m->n_channels + y * m->rowstride)) = new_red;
#line 1451
      *(m->data + ((x * (int )m->n_channels + y * m->rowstride) + 1)) = new_green;
#line 1452
      *(m->data + ((x * (int )m->n_channels + y * m->rowstride) + 2)) = new_blue;
#line 1444
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1443
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1455
  return (0);
}
}
#line 1458 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
unsigned char ho_pbm_getc(FILE *file ) 
{ 
  unsigned char ch ;
  int comment ;
  int tmp ;

  {
#line 1462
  comment = 0;
  {
#line 1464
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1466
    tmp = _IO_getc(file);
#line 1466
    ch = (unsigned char )tmp;
    }
#line 1467
    if ((int )ch == 10) {
#line 1468
      comment = 0;
    } else
#line 1469
    if ((int )ch == 35) {
#line 1470
      comment = -1;
    }
#line 1464
    if (! comment) {
#line 1464
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1474
  return (ch);
}
}
#line 1477 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pbm_getint(FILE *file ) 
{ 
  unsigned char ch ;
  int i ;

  {
#line 1481
  i = 0;
  {
#line 1484
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1486
    ch = ho_pbm_getc(file);
    }
#line 1484
    if (! ((int )ch == 32)) {
#line 1484
      if (! ((int )ch == 10)) {
#line 1484
        if (! ((int )ch == 9)) {
#line 1484
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1491
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1493
    i = i * 10 + ((int )ch - 48);
#line 1494
    ch = ho_pbm_getc(file);
    }
#line 1491
    if ((int )ch >= 48) {
#line 1491
      if (! ((int )ch <= 57)) {
#line 1491
        goto while_break___0;
      }
    } else {
#line 1491
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1498
  return (i);
}
}
#line 1505
int ho_pbm_getbit(FILE *file ) ;
#line 1505 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
static unsigned char byte  =    (unsigned char)0;
#line 1506 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
static unsigned char mask  =    (unsigned char)0;
#line 1501 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pbm_getbit(FILE *file ) 
{ 
  int return_bit ;
  int tmp ;

  {
#line 1510
  if (! file) {
#line 1512
    mask = (unsigned char)0;
#line 1513
    return (0);
  }
#line 1517
  if ((int )mask == 0) {
    {
#line 1519
    mask = (unsigned char)128;
#line 1520
    tmp = _IO_getc(file);
#line 1520
    byte = (unsigned char )tmp;
    }
  }
#line 1524
  if ((int )byte & (int )mask) {
#line 1524
    return_bit = 0;
  } else {
#line 1524
    return_bit = 255;
  }
#line 1527
  mask = (unsigned char )((int )mask >> 1);
#line 1529
  return (return_bit);
}
}
#line 1532 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
ho_pixbuf *ho_pixbuf_pnm_load(char const   *filename ) 
{ 
  char ch1 ;
  char ch2 ;
  ho_pixbuf *pix ;
  FILE *file ;
  unsigned char use_stdin ;
  unsigned char n_channels ;
  unsigned char val ;
  int width ;
  int height ;
  int x ;
  int y ;
  int rowstride ;
  unsigned char tmp ;
  unsigned char tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
#line 1536
  pix = (ho_pixbuf *)((void *)0);
#line 1537
  file = (FILE *)((void *)0);
#line 1538
  use_stdin = (unsigned char)0;
#line 1539
  n_channels = (unsigned char)0;
#line 1540
  val = (unsigned char)0;
#line 1541
  width = 0;
#line 1542
  height = 0;
#line 1546
  if (! filename) {
#line 1550
    file = stdin;
#line 1551
    use_stdin = (unsigned char)1;
  } else
#line 1546
  if ((int const   )*(filename + 0) == 0) {
#line 1550
    file = stdin;
#line 1551
    use_stdin = (unsigned char)1;
  } else
#line 1546
  if ((int const   )*(filename + 0) == 45) {
#line 1546
    if ((int const   )*(filename + 1) == 0) {
#line 1550
      file = stdin;
#line 1551
      use_stdin = (unsigned char)1;
    } else {
#line 1546
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 1556
    file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
    }
#line 1557
    if (! file) {
#line 1558
      return ((ho_pixbuf *)((void *)0));
    }
  }
  {
#line 1562
  tmp = ho_pbm_getc(file);
#line 1562
  ch1 = (char )tmp;
#line 1563
  tmp___0 = ho_pbm_getc(file);
#line 1563
  ch2 = (char )tmp___0;
  }
#line 1564
  if ((int )ch1 != 80) {
#line 1564
    goto _L___0;
  } else
#line 1564
  if ((int )ch2 != 54) {
#line 1564
    if ((int )ch2 != 53) {
#line 1564
      if ((int )ch2 != 52) {
        _L___0: /* CIL Label */ 
#line 1567
        if (! use_stdin) {
          {
#line 1568
          fclose(file);
          }
        }
#line 1569
        return ((ho_pixbuf *)((void *)0));
      }
    }
  }
#line 1573
  if ((int )ch2 == 54) {
#line 1573
    n_channels = (unsigned char)3;
  } else {
#line 1573
    n_channels = (unsigned char)1;
  }
  {
#line 1574
  width = ho_pbm_getint(file);
#line 1575
  height = ho_pbm_getint(file);
  }
#line 1577
  if ((int )ch2 == 52) {
    {
#line 1582
    pix = ho_pixbuf_new((unsigned char const   )n_channels, (int const   )width, (int const   )height,
                        (int const   )0);
#line 1584
    rowstride = 8 * (width / 8 + 1);
    }
#line 1585
    if (pix) {
#line 1586
      y = 0;
      {
#line 1586
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1586
        if (! (y < height)) {
#line 1586
          goto while_break;
        }
        {
#line 1589
        ho_pbm_getbit((FILE *)0);
#line 1592
        x = 0;
        }
        {
#line 1592
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 1592
          if (! (x < rowstride)) {
#line 1592
            goto while_break___0;
          }
          {
#line 1594
          tmp___1 = ho_pbm_getbit(file);
#line 1594
          val = (unsigned char )tmp___1;
          }
#line 1595
          if (x < width) {
#line 1596
            *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = val;
          }
#line 1592
          x ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 1586
        y ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  } else {
    {
#line 1605
    tmp___2 = ho_pbm_getint(file);
    }
#line 1605
    if (tmp___2 > 255) {
#line 1608
      if (! use_stdin) {
        {
#line 1609
        fclose(file);
        }
      }
#line 1611
      return ((ho_pixbuf *)((void *)0));
    }
    {
#line 1615
    pix = ho_pixbuf_new((unsigned char const   )n_channels, (int const   )width, (int const   )height,
                        (int const   )0);
    }
#line 1617
    if (pix) {
      {
#line 1618
      fread((void */* __restrict  */)pix->data, (size_t )1, (size_t )(pix->height * pix->rowstride),
            (FILE */* __restrict  */)file);
      }
    }
  }
#line 1621
  if (! use_stdin) {
    {
#line 1622
    fclose(file);
    }
  }
#line 1625
  return (pix);
}
}
#line 1628 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_pixbuf.c"
int ho_pixbuf_pnm_save(ho_pixbuf const   *pix , char const   *filename ) 
{ 
  FILE *file ;
  int tmp ;

  {
#line 1631
  file = (FILE *)((void *)0);
#line 1633
  if ((int const   )pix->n_channels != 3) {
#line 1633
    if ((int const   )pix->n_channels != 1) {
#line 1636
      return (-1);
    }
  }
  {
#line 1639
  file = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"wb");
  }
#line 1641
  if (! file) {
#line 1642
    return (-1);
  }
#line 1645
  if ((int const   )pix->n_channels == 3) {
#line 1645
    tmp = '6';
  } else {
#line 1645
    tmp = '5';
  }
  {
#line 1645
  fprintf((FILE */* __restrict  */)file, (char const   */* __restrict  */)"P%c %d %d 255\n",
          tmp, pix->width, pix->height);
#line 1649
  fwrite((void const   */* __restrict  */)pix->data, (size_t )1, (size_t )(pix->height * pix->rowstride),
         (FILE */* __restrict  */)file);
#line 1650
  fclose(file);
  }
#line 1652
  return (0);
}
}
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 49 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_string.h"
ho_string *ho_string_new(void) ;
#line 57
int ho_string_free(ho_string *string_buffer ) ;
#line 75
int ho_string_set(ho_string *string_buffer , char const   *new_string ) ;
#line 83
char *ho_string_get(ho_string const   *s_str ) ;
#line 91
ho_string *ho_string_copy(ho_string const   *string_buffer ) ;
#line 51 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_string.c"
ho_string *ho_string_new(void) 
{ 
  ho_string *new_string_buffer ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 57
  tmp = malloc(sizeof(ho_string ));
#line 57
  new_string_buffer = (ho_string *)tmp;
  }
#line 60
  if (! new_string_buffer) {
#line 61
    return ((ho_string *)((void *)0));
  }
  {
#line 64
  new_string_buffer->size = 0;
#line 65
  new_string_buffer->allocated_size = 500;
#line 68
  tmp___0 = malloc(sizeof(char ) * (unsigned long )new_string_buffer->allocated_size);
#line 68
  new_string_buffer->string = (char *)tmp___0;
  }
#line 72
  if (! new_string_buffer->string) {
    {
#line 74
    free((void *)new_string_buffer);
    }
#line 75
    return ((ho_string *)((void *)0));
  }
#line 79
  *(new_string_buffer->string + 0) = (char )'\000';
#line 81
  return (new_string_buffer);
}
}
#line 84 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_string.c"
int ho_string_free(ho_string *string_buffer ) 
{ 


  {
#line 88
  if (string_buffer->string) {
    {
#line 89
    free((void *)string_buffer->string);
    }
  }
#line 92
  if (string_buffer) {
    {
#line 93
    free((void *)string_buffer);
    }
  }
#line 95
  return (0);
}
}
#line 98 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_string.c"
int ho_string_set(ho_string *string_buffer , char const   *new_string ) 
{ 
  int len ;
  char *new_allocated_string ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 102
  new_allocated_string = (char *)((void *)0);
#line 104
  tmp = strlen(new_string);
#line 104
  len = (int )tmp;
#line 107
  tmp___0 = malloc(sizeof(char ) * (unsigned long )(len + 500));
#line 107
  new_allocated_string = (char *)tmp___0;
  }
#line 111
  if (new_allocated_string) {
#line 113
    if (string_buffer->string) {
      {
#line 114
      free((void *)string_buffer->string);
      }
    }
#line 115
    string_buffer->string = new_allocated_string;
#line 116
    string_buffer->allocated_size = len + 500;
  } else {
#line 121
    return (-1);
  }
  {
#line 125
  strcpy((char */* __restrict  */)string_buffer->string, (char const   */* __restrict  */)new_string);
#line 126
  tmp___1 = strlen((char const   *)string_buffer->string);
#line 126
  string_buffer->size = (int )tmp___1;
  }
#line 128
  return (0);
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_string.c"
char *ho_string_get(ho_string const   *s_str ) 
{ 
  int len ;
  char *new_allocated_string ;
  size_t tmp ;
  void *tmp___0 ;

  {
  {
#line 135
  new_allocated_string = (char *)((void *)0);
#line 137
  tmp = strlen((char const   *)s_str->string);
#line 137
  len = (int )tmp;
#line 140
  tmp___0 = malloc(sizeof(char ) * (unsigned long )(len + 1));
#line 140
  new_allocated_string = (char *)tmp___0;
  }
#line 143
  if (! new_allocated_string) {
#line 144
    return ((char *)((void *)0));
  }
  {
#line 147
  strcpy((char */* __restrict  */)new_allocated_string, (char const   */* __restrict  */)s_str->string);
  }
#line 149
  return (new_allocated_string);
}
}
#line 152 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_string.c"
int ho_string_cat(ho_string *string_buffer , char const   *new_string ) 
{ 
  int len ;
  char *new_allocated_string ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;

  {
  {
#line 156
  new_allocated_string = (char *)((void *)0);
#line 158
  tmp = strlen(new_string);
#line 158
  len = (int )tmp;
  }
#line 160
  if (len < 1) {
#line 161
    return (0);
  }
#line 164
  if (string_buffer->size + len >= string_buffer->allocated_size) {
    {
#line 166
    tmp___0 = realloc((void *)string_buffer->string, sizeof(char ) * (unsigned long )((string_buffer->allocated_size + len) + 500));
#line 166
    new_allocated_string = (char *)tmp___0;
    }
#line 171
    if (new_allocated_string) {
#line 173
      string_buffer->string = new_allocated_string;
#line 174
      string_buffer->allocated_size += len + 500;
    } else {
#line 179
      return (-1);
    }
  }
  {
#line 183
  strcat((char */* __restrict  */)string_buffer->string, (char const   */* __restrict  */)new_string);
#line 184
  tmp___1 = strlen((char const   *)string_buffer->string);
#line 184
  string_buffer->size = (int )tmp___1;
  }
#line 186
  return (0);
}
}
#line 189 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_string.c"
ho_string *ho_string_copy(ho_string const   *string_buffer ) 
{ 
  ho_string *new_string ;

  {
  {
#line 192
  new_string = (ho_string *)((void *)0);
#line 194
  new_string = ho_string_new();
#line 195
  ho_string_cat(new_string, (char const   *)string_buffer->string);
  }
#line 196
  return (new_string);
}
}
#line 100 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) exp)(double __x ) ;
#line 109
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) log)(double __x ) ;
#line 156
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 68 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.h"
ho_array *ho_array_clone(ho_array const   *m ) ;
#line 76
int ho_array_set_data(ho_array *pix , double data ) ;
#line 86
int ho_array_set_at(ho_array *pix , int x , int y , double data ) ;
#line 95
double ho_array_get_at(ho_array *pix , int x , int y ) ;
#line 102
ho_array *ho_array_new_from_pixbuf(ho_pixbuf const   *pix ) ;
#line 109
ho_array *ho_array_new_from_bitmap(ho_bitmap const   *pix ) ;
#line 116
ho_pixbuf *ho_array_to_pixbuf(ho_array const   *pix_in ) ;
#line 123
ho_pixbuf *ho_array_to_rgb_pixbuf(ho_array const   *pix_in ) ;
#line 130
int ho_array_free(ho_array *pix ) ;
#line 146
double ho_array_get_mean(ho_array const   *pix ) ;
#line 153
double ho_array_get_min(ho_array const   *ar ) ;
#line 160
double ho_array_get_max(ho_array const   *ar ) ;
#line 168
unsigned char ho_array_add(ho_array *ar1 , ho_array const   *ar2 ) ;
#line 176
unsigned char ho_array_add_const(ho_array *ar , double const   num ) ;
#line 184
unsigned char ho_array_sub(ho_array *ar1 , ho_array const   *ar2 ) ;
#line 192
unsigned char ho_array_mul(ho_array *ar1 , ho_array const   *ar2 ) ;
#line 202
unsigned char ho_array_complex_mul(ho_array *ar1_r , ho_array *ar1_i , ho_array const   *ar2_r ,
                                   ho_array const   *ar2_i ) ;
#line 212
unsigned char ho_array_mul_const(ho_array *ar , double const   num ) ;
#line 220
unsigned char ho_array_div(ho_array *ar1 , ho_array const   *ar2 ) ;
#line 227
unsigned char ho_array_inv(ho_array *ar ) ;
#line 234
unsigned char ho_array_polerize(ho_array *ar , double const   treshold ) ;
#line 241
unsigned char ho_array_log(ho_array *ar ) ;
#line 248
unsigned char ho_array_streach(ho_array *ar ) ;
#line 255
unsigned char ho_array_equl(ho_array *ar ) ;
#line 263
ho_array *ho_array_convolution_filter(ho_array const   *ar , ho_array const   *kernel ) ;
#line 271
ho_array *ho_array_median_filter(ho_array const   *ar ) ;
#line 278
ho_array *ho_array_max_filter(ho_array const   *ar ) ;
#line 285
ho_array *ho_array_min_filter(ho_array const   *ar ) ;
#line 293
ho_array *ho_array_complex_abs(ho_array const   *ar1 , ho_array const   *ar2 ) ;
#line 301
ho_array *ho_array_complex_atan2(ho_array const   *ar1 , ho_array const   *ar2 ) ;
#line 310
unsigned char ho_array_gradient(ho_array const   *ar , ho_array *ar_r , ho_array *ar_theta ) ;
#line 321
ho_array *ho_array_hough_circles(ho_array const   *ar , int const   min_radius , int const   max_radius ,
                                 unsigned char const   t ) ;
#line 330
ho_array *ho_array_hough_lines(ho_array const   *ar , unsigned char const   t ) ;
#line 340
ho_array *ho_array_hough_lines_backwords(ho_array const   *ar , int const   width ,
                                         int const   height , unsigned char const   t ) ;
#line 352
ho_array *ho_array_hough_lines_backwords_by_angle(ho_array const   *ar , int const   width ,
                                                  int const   height , int const   angle1 ,
                                                  int const   angle2 ) ;
#line 364
ho_array *ho_array_hough_lines_backwords_by_angle_v(ho_array const   *ar , int const   width ,
                                                    int const   height , int const   angle1 ,
                                                    int const   angle2 ) ;
#line 440
int ho_array_pnm_save(ho_array const   *ar , char const   *filename ) ;
#line 447
ho_array const   *ho_array_pnm_load(char const   *filename ) ;
#line 471
ho_array *ho_array_new_gaussien(int const   width , int const   height , double const   sigma ) ;
#line 482
ho_array *ho_array_new_box(int const   width , int const   height , int const   box_width ,
                           int const   box_height ) ;
#line 492
ho_array *ho_array_new_circle(int const   width , int const   height , int const   radius ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_new(int const   width , int const   height ) 
{ 
  int x ;
  int y ;
  ho_array *pix ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 61
  pix = (ho_array *)((void *)0);
#line 66
  tmp = malloc(sizeof(ho_array ));
#line 66
  pix = (ho_array *)tmp;
  }
#line 67
  if (! pix) {
#line 69
    return ((ho_array *)((void *)0));
  }
  {
#line 75
  pix->width = (int )width;
#line 76
  pix->height = (int )height;
#line 81
  tmp___0 = malloc((unsigned long )(pix->height * pix->width) * sizeof(double ));
#line 81
  pix->data = (double *)tmp___0;
  }
#line 82
  if (! pix->data) {
    {
#line 84
    free((void *)pix);
    }
#line 85
    return ((ho_array *)((void *)0));
  }
#line 89
  x = 0;
  {
#line 89
  while (1) {
    while_continue: /* CIL Label */ ;
#line 89
    if (! (x < pix->width)) {
#line 89
      goto while_break;
    }
#line 90
    y = 0;
    {
#line 90
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 90
      if (! (y < pix->height)) {
#line 90
        goto while_break___0;
      }
#line 92
      *(pix->data + (x + y * pix->width)) = 0.0;
#line 90
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 89
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (pix);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_clone(ho_array const   *m ) 
{ 
  ho_array *m_out ;

  {
  {
#line 106
  m_out = (ho_array *)((void *)0);
#line 109
  m_out = ho_array_new(m->width, m->height);
  }
#line 110
  if (! m_out) {
#line 111
    return ((ho_array *)((void *)0));
  }
  {
#line 114
  memcpy((void */* __restrict  */)m_out->data, (void const   */* __restrict  */)m->data,
         (unsigned long )(m_out->height * m_out->width) * sizeof(double ));
  }
#line 116
  return (m_out);
}
}
#line 125 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
int ho_array_set_data(ho_array *pix , double data ) 
{ 
  int x ;
  int y ;

  {
#line 130
  x = 0;
  {
#line 130
  while (1) {
    while_continue: /* CIL Label */ ;
#line 130
    if (! (x < pix->width)) {
#line 130
      goto while_break;
    }
#line 131
    y = 0;
    {
#line 131
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 131
      if (! (y < pix->height)) {
#line 131
        goto while_break___0;
      }
#line 132
      *(pix->data + (x + y * pix->width)) = data;
#line 131
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 130
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 134
  return (0);
}
}
#line 145 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
int ho_array_set_at(ho_array *pix , int x , int y , double data ) 
{ 


  {
#line 148
  *(pix->data + (x + y * pix->width)) = data;
#line 150
  return (0);
}
}
#line 160 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
double ho_array_get_at(ho_array *pix , int x , int y ) 
{ 


  {
#line 163
  return (*(pix->data + (x + y * pix->width)));
}
}
#line 171 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_new_from_pixbuf(ho_pixbuf const   *pix ) 
{ 
  int x ;
  int y ;
  double pixel_val ;
  ho_array *m_out ;
  ho_pixbuf *gray_pix ;

  {
#line 178
  m_out = (ho_array *)((void *)0);
#line 180
  gray_pix = (ho_pixbuf *)((void *)0);
#line 183
  if ((int const   )pix->n_channels > 1) {
    {
#line 184
    gray_pix = ho_pixbuf_color_to_gray(pix);
    }
  } else {
    {
#line 186
    gray_pix = ho_pixbuf_clone(pix);
    }
  }
  {
#line 189
  m_out = ho_array_new(pix->width, pix->height);
  }
#line 190
  if (! m_out) {
#line 191
    return ((ho_array *)((void *)0));
  }
#line 194
  x = 0;
  {
#line 194
  while (1) {
    while_continue: /* CIL Label */ ;
#line 194
    if (! (x < (int )pix->width)) {
#line 194
      goto while_break;
    }
#line 195
    y = 0;
    {
#line 195
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 195
      if (! (y < (int )pix->height)) {
#line 195
        goto while_break___0;
      }
#line 197
      pixel_val = (double )*(gray_pix->data + (x * (int )gray_pix->n_channels + y * gray_pix->rowstride)) / 255.0;
#line 198
      *(m_out->data + (x + y * m_out->width)) = pixel_val;
#line 195
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 194
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 202
  ho_pixbuf_free(gray_pix);
  }
#line 204
  return (m_out);
}
}
#line 212 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_new_from_bitmap(ho_bitmap const   *pix ) 
{ 
  int x ;
  int y ;
  double pixel_val ;
  ho_array *m_out ;
  int tmp ;

  {
  {
#line 219
  m_out = (ho_array *)((void *)0);
#line 222
  m_out = ho_array_new(pix->width, pix->height);
  }
#line 223
  if (! m_out) {
#line 224
    return ((ho_array *)((void *)0));
  }
#line 227
  x = 0;
  {
#line 227
  while (1) {
    while_continue: /* CIL Label */ ;
#line 227
    if (! (x < (int )pix->width)) {
#line 227
      goto while_break;
    }
#line 228
    y = 0;
    {
#line 228
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 228
      if (! (y < (int )pix->height)) {
#line 228
        goto while_break___0;
      }
#line 230
      if (((int )*(pix->data + (x / 8 + y * (int )pix->rowstride)) & (128 >> x % 8)) > 0) {
#line 230
        tmp = 1;
      } else {
#line 230
        tmp = 0;
      }
#line 230
      pixel_val = 1.0 - (double )tmp;
#line 231
      *(m_out->data + (x + y * m_out->width)) = pixel_val;
#line 228
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 227
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 234
  return (m_out);
}
}
#line 242 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_pixbuf *ho_array_to_pixbuf(ho_array const   *pix_in ) 
{ 
  int x ;
  int y ;
  unsigned char pixel_val ;
  ho_pixbuf *pix ;
  double min ;
  double max ;
  double range ;

  {
  {
#line 249
  pix = (ho_pixbuf *)((void *)0);
#line 253
  ho_array_minmax(pix_in, & min, & max);
#line 254
  range = max - min;
#line 256
  pix = ho_pixbuf_new((unsigned char const   )1, pix_in->width, pix_in->height, (int const   )0);
  }
#line 257
  if (! pix) {
#line 258
    return ((ho_pixbuf *)((void *)0));
  }
#line 260
  x = 0;
  {
#line 260
  while (1) {
    while_continue: /* CIL Label */ ;
#line 260
    if (! (x < (int )pix_in->width)) {
#line 260
      goto while_break;
    }
#line 261
    y = 0;
    {
#line 261
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 261
      if (! (y < (int )pix_in->height)) {
#line 261
        goto while_break___0;
      }
#line 263
      pixel_val = (unsigned char )((255.0 * (*(pix_in->data + (x + y * (int )pix_in->width)) - min)) / range);
#line 265
      *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = pixel_val;
#line 261
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 260
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  return (pix);
}
}
#line 276 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_pixbuf *ho_array_to_rgb_pixbuf(ho_array const   *pix_in ) 
{ 
  int x ;
  int y ;
  unsigned char pixel_val ;
  ho_pixbuf *pix ;
  double min ;
  double max ;
  double range ;

  {
  {
#line 283
  pix = (ho_pixbuf *)((void *)0);
#line 287
  ho_array_minmax(pix_in, & min, & max);
#line 288
  range = max - min;
#line 290
  pix = ho_pixbuf_new((unsigned char const   )3, pix_in->width, pix_in->height, (int const   )0);
  }
#line 291
  if (! pix) {
#line 292
    return ((ho_pixbuf *)((void *)0));
  }
#line 294
  x = 0;
  {
#line 294
  while (1) {
    while_continue: /* CIL Label */ ;
#line 294
    if (! (x < (int )pix_in->width)) {
#line 294
      goto while_break;
    }
#line 295
    y = 0;
    {
#line 295
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 295
      if (! (y < (int )pix_in->height)) {
#line 295
        goto while_break___0;
      }
#line 297
      pixel_val = (unsigned char )((255.0 * (*(pix_in->data + (x + y * (int )pix_in->width)) - min)) / range);
#line 299
      *(pix->data + (x * (int )pix->n_channels + y * pix->rowstride)) = pixel_val;
#line 300
      *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 1)) = pixel_val;
#line 301
      *(pix->data + ((x * (int )pix->n_channels + y * pix->rowstride) + 2)) = pixel_val;
#line 295
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 294
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  return (pix);
}
}
#line 312 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
int ho_array_free(ho_array *pix ) 
{ 


  {
#line 315
  if (! pix) {
#line 316
    return (-1);
  }
#line 318
  if (pix->data) {
    {
#line 319
    free((void *)pix->data);
    }
  }
  {
#line 321
  free((void *)pix);
  }
#line 323
  return (0);
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_minmax(ho_array const   *pix , double *min , double *max ) 
{ 
  int x ;
  int y ;

  {
#line 338
  *min = *(pix->data + 0);
#line 339
  *max = *(pix->data + 0);
#line 341
  x = 0;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 341
    if (! (x < (int )pix->width)) {
#line 341
      goto while_break;
    }
#line 342
    y = 0;
    {
#line 342
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 342
      if (! (y < (int )pix->height)) {
#line 342
        goto while_break___0;
      }
#line 344
      if (*min > *(pix->data + (x + y * (int )pix->width))) {
#line 345
        *min = *(pix->data + (x + y * (int )pix->width));
      }
#line 346
      if (*max < *(pix->data + (x + y * (int )pix->width))) {
#line 347
        *max = *(pix->data + (x + y * (int )pix->width));
      }
#line 342
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 341
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 350
  return ((unsigned char)0);
}
}
#line 353 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
double ho_array_get_mean(ho_array const   *pix ) 
{ 
  double mean ;
  int x ;
  int y ;

  {
#line 360
  mean = (double )0;
#line 362
  x = 0;
  {
#line 362
  while (1) {
    while_continue: /* CIL Label */ ;
#line 362
    if (! (x < (int )pix->width)) {
#line 362
      goto while_break;
    }
#line 363
    y = 0;
    {
#line 363
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 363
      if (! (y < (int )pix->height)) {
#line 363
        goto while_break___0;
      }
#line 365
      mean += *(pix->data + (x + y * (int )pix->width));
#line 363
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 362
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  mean /= (double )x * (double )y;
#line 370
  return ((double )0);
}
}
#line 378 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
double ho_array_get_min(ho_array const   *ar ) 
{ 
  double min ;
  double max ;

  {
  {
#line 384
  ho_array_minmax(ar, & min, & max);
  }
#line 386
  return (min);
}
}
#line 394 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
double ho_array_get_max(ho_array const   *ar ) 
{ 
  double min ;
  double max ;

  {
  {
#line 400
  ho_array_minmax(ar, & min, & max);
  }
#line 402
  return (max);
}
}
#line 411 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_add(ho_array *ar1 , ho_array const   *ar2 ) 
{ 
  int x ;
  int y ;

  {
#line 416
  x = 0;
  {
#line 416
  while (1) {
    while_continue: /* CIL Label */ ;
#line 416
    if (! (x < ar1->width)) {
#line 416
      goto while_break;
    }
#line 417
    y = 0;
    {
#line 417
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 417
      if (! (y < ar1->height)) {
#line 417
        goto while_break___0;
      }
#line 419
      *(ar1->data + (x + y * ar1->width)) += *(ar2->data + (x + y * (int )ar2->width));
#line 417
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 416
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 422
  return ((unsigned char)0);
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_add_const(ho_array *ar , double const   num ) 
{ 
  int x ;
  int y ;

  {
#line 436
  x = 0;
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! (x < ar->width)) {
#line 436
      goto while_break;
    }
#line 437
    y = 0;
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 437
      if (! (y < ar->height)) {
#line 437
        goto while_break___0;
      }
#line 439
      *(ar->data + (x + y * ar->width)) += (double )num;
#line 437
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 436
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 442
  return ((unsigned char)0);
}
}
#line 451 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_sub(ho_array *ar1 , ho_array const   *ar2 ) 
{ 
  int x ;
  int y ;

  {
#line 456
  x = 0;
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
#line 456
    if (! (x < ar1->width)) {
#line 456
      goto while_break;
    }
#line 457
    y = 0;
    {
#line 457
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 457
      if (! (y < ar1->height)) {
#line 457
        goto while_break___0;
      }
#line 459
      *(ar1->data + (x + y * ar1->width)) -= *(ar2->data + (x + y * (int )ar2->width));
#line 457
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 456
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 462
  return ((unsigned char)0);
}
}
#line 471 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_mul(ho_array *ar1 , ho_array const   *ar2 ) 
{ 
  int x ;
  int y ;

  {
#line 476
  x = 0;
  {
#line 476
  while (1) {
    while_continue: /* CIL Label */ ;
#line 476
    if (! (x < ar1->width)) {
#line 476
      goto while_break;
    }
#line 477
    y = 0;
    {
#line 477
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 477
      if (! (y < ar1->height)) {
#line 477
        goto while_break___0;
      }
#line 479
      *(ar1->data + (x + y * ar1->width)) *= *(ar2->data + (x + y * (int )ar2->width));
#line 477
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 476
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 482
  return ((unsigned char)0);
}
}
#line 493 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_complex_mul(ho_array *ar1_r , ho_array *ar1_i , ho_array const   *ar2_r ,
                                   ho_array const   *ar2_i ) 
{ 
  int x ;
  int y ;
  double a ;
  double b ;
  double c ;
  double d ;

  {
#line 501
  x = 0;
  {
#line 501
  while (1) {
    while_continue: /* CIL Label */ ;
#line 501
    if (! (x < ar1_r->width)) {
#line 501
      goto while_break;
    }
#line 502
    y = 0;
    {
#line 502
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 502
      if (! (y < ar1_r->height)) {
#line 502
        goto while_break___0;
      }
#line 504
      a = *(ar1_r->data + (x + y * ar1_r->width));
#line 505
      b = *(ar1_i->data + (x + y * ar1_i->width));
#line 506
      c = *(ar2_r->data + (x + y * (int )ar2_r->width));
#line 507
      d = *(ar2_i->data + (x + y * (int )ar2_i->width));
#line 509
      *(ar1_r->data + (x + y * ar1_r->width)) = a * c - b * d;
#line 510
      *(ar1_i->data + (x + y * ar1_i->width)) = b * c + a * d;
#line 502
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 501
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 513
  return ((unsigned char)0);
}
}
#line 522 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_mul_const(ho_array *ar , double const   num ) 
{ 
  int x ;
  int y ;

  {
#line 527
  x = 0;
  {
#line 527
  while (1) {
    while_continue: /* CIL Label */ ;
#line 527
    if (! (x < ar->width)) {
#line 527
      goto while_break;
    }
#line 528
    y = 0;
    {
#line 528
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 528
      if (! (y < ar->height)) {
#line 528
        goto while_break___0;
      }
#line 530
      *(ar->data + (x + y * ar->width)) *= (double )num;
#line 528
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 527
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 533
  return ((unsigned char)0);
}
}
#line 542 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_div(ho_array *ar1 , ho_array const   *ar2 ) 
{ 
  int x ;
  int y ;

  {
#line 547
  x = 0;
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (x < ar1->width)) {
#line 547
      goto while_break;
    }
#line 548
    y = 0;
    {
#line 548
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 548
      if (! (y < ar1->height)) {
#line 548
        goto while_break___0;
      }
#line 550
      *(ar1->data + (x + y * ar1->width)) /= *(ar2->data + (x + y * (int )ar2->width));
#line 548
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 547
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 553
  return ((unsigned char)0);
}
}
#line 561 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_inv(ho_array *ar ) 
{ 
  int x ;
  int y ;

  {
#line 566
  x = 0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
#line 566
    if (! (x < ar->width)) {
#line 566
      goto while_break;
    }
#line 567
    y = 0;
    {
#line 567
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 567
      if (! (y < ar->height)) {
#line 567
        goto while_break___0;
      }
#line 569
      *(ar->data + (x + y * ar->width)) = 1.0 / *(ar->data + (x + y * ar->width));
#line 567
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 566
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 572
  return ((unsigned char)0);
}
}
#line 580 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_polerize(ho_array *ar , double const   treshold ) 
{ 
  int x ;
  int y ;
  double min ;
  double max ;
  double real_treshold ;

  {
  {
#line 589
  ho_array_minmax((ho_array const   *)ar, & min, & max);
#line 592
  real_treshold = min + (double )(treshold * (double const   )(max - min));
#line 594
  x = 0;
  }
  {
#line 594
  while (1) {
    while_continue: /* CIL Label */ ;
#line 594
    if (! (x < ar->width)) {
#line 594
      goto while_break;
    }
#line 595
    y = 0;
    {
#line 595
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 595
      if (! (y < ar->height)) {
#line 595
        goto while_break___0;
      }
#line 597
      if (*(ar->data + (x + y * ar->width)) < real_treshold) {
#line 598
        *(ar->data + (x + y * ar->width)) = 0.0;
      } else {
#line 600
        *(ar->data + (x + y * ar->width)) = 1.0;
      }
#line 595
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 594
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 603
  return ((unsigned char)0);
}
}
#line 611 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_log(ho_array *ar ) 
{ 
  int x ;
  int y ;

  {
#line 616
  x = 0;
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! (x < ar->width)) {
#line 616
      goto while_break;
    }
#line 617
    y = 0;
    {
#line 617
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 617
      if (! (y < ar->height)) {
#line 617
        goto while_break___0;
      }
      {
#line 619
      *(ar->data + (x + y * ar->width)) = log(1.0 + *(ar->data + (x + y * ar->width)));
#line 617
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 616
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 622
  return ((unsigned char)0);
}
}
#line 630 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_streach(ho_array *ar ) 
{ 
  int x ;
  int y ;
  double min ;
  double max ;
  double range ;

  {
  {
#line 637
  ho_array_minmax((ho_array const   *)ar, & min, & max);
#line 638
  range = max - min;
#line 640
  x = 0;
  }
  {
#line 640
  while (1) {
    while_continue: /* CIL Label */ ;
#line 640
    if (! (x < ar->width)) {
#line 640
      goto while_break;
    }
#line 641
    y = 0;
    {
#line 641
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 641
      if (! (y < ar->height)) {
#line 641
        goto while_break___0;
      }
#line 643
      *(ar->data + (x + y * ar->width)) = (*(ar->data + (x + y * ar->width)) - min) / range;
#line 641
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 640
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 647
  return ((unsigned char)0);
}
}
#line 655 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_equl(ho_array *ar ) 
{ 
  int i ;
  int x ;
  int y ;
  int l ;
  int k ;
  double min ;
  double max ;
  double range ;
  double acc_hist[256] ;
  double look_up_table[256] ;

  {
#line 669
  i = 0;
  {
#line 669
  while (1) {
    while_continue: /* CIL Label */ ;
#line 669
    if (! (i < 256)) {
#line 669
      goto while_break;
    }
#line 670
    acc_hist[i] = (double )0;
#line 669
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 671
  i = 0;
  {
#line 671
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 671
    if (! (i < 256)) {
#line 671
      goto while_break___0;
    }
#line 672
    look_up_table[i] = (double )0;
#line 671
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 675
  ho_array_minmax((ho_array const   *)ar, & min, & max);
#line 676
  range = max - min;
#line 679
  x = 0;
  }
  {
#line 679
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 679
    if (! (x < ar->width)) {
#line 679
      goto while_break___1;
    }
#line 680
    y = 0;
    {
#line 680
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 680
      if (! (y < ar->height)) {
#line 680
        goto while_break___2;
      }
#line 682
      i = (int )((255.0 * (*(ar->data + (x + y * ar->width)) - min)) / range);
#line 683
      acc_hist[i] += (double )1;
#line 680
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 679
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 685
  i = 1;
  {
#line 685
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 685
    if (! (i < 256)) {
#line 685
      goto while_break___3;
    }
#line 686
    acc_hist[i] += acc_hist[i - 1];
#line 685
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 689
  i = 0;
  {
#line 689
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 689
    if (! (i < 256)) {
#line 689
      goto while_break___4;
    }
#line 690
    acc_hist[i] /= (double )(ar->width * ar->height);
#line 689
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 693
  l = 0;
#line 694
  k = 0;
  {
#line 694
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 694
    if (! (k < 256)) {
#line 694
      goto while_break___5;
    }
    {
#line 696
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 696
      if (255.0 * acc_hist[l] < (double )k) {
#line 696
        if (! (l < 256)) {
#line 696
          goto while_break___6;
        }
      } else {
#line 696
        goto while_break___6;
      }
#line 697
      l ++;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 699
    look_up_table[k] = (double )l / 255.0;
#line 694
    k ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 703
  x = 0;
  {
#line 703
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 703
    if (! (x < ar->width)) {
#line 703
      goto while_break___7;
    }
#line 704
    y = 0;
    {
#line 704
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 704
      if (! (y < ar->height)) {
#line 704
        goto while_break___8;
      }
#line 706
      i = (int )((255.0 * (*(ar->data + (x + y * ar->width)) - min)) / range);
#line 707
      *(ar->data + (x + y * ar->width)) = look_up_table[i];
#line 704
      y ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 703
    x ++;
  }
  while_break___7: /* CIL Label */ ;
  }
#line 710
  return ((unsigned char)0);
}
}
#line 719 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_convolution_filter(ho_array const   *ar , ho_array const   *kernel ) 
{ 
  int x ;
  int y ;
  double sum ;
  double neigbours[9] ;
  ho_array *ar_out ;

  {
  {
#line 728
  ar_out = (ho_array *)((void *)0);
#line 731
  ar_out = ho_array_new(ar->width, ar->height);
  }
#line 732
  if (! ar_out) {
#line 733
    return ((ho_array *)((void *)0));
  }
#line 736
  x = 0;
  {
#line 736
  while (1) {
    while_continue: /* CIL Label */ ;
#line 736
    if (! (x < (int )ar->width)) {
#line 736
      goto while_break;
    }
#line 738
    *(ar_out->data + x) = *(ar->data + x);
#line 739
    *(ar_out->data + (x + (ar_out->height - 1) * ar_out->width)) = *(ar->data + (x + (int )((ar->height - 1) * ar->width)));
#line 736
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 742
  y = 0;
  {
#line 742
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 742
    if (! (y < (int )ar->height)) {
#line 742
      goto while_break___0;
    }
#line 744
    *(ar_out->data + y * ar_out->width) = *(ar->data + y * (int )ar->width);
#line 745
    *(ar_out->data + ((ar_out->width - 1) + y * ar_out->width)) = *(ar->data + ((ar->width - 1) + (int const   )(y * (int )ar->width)));
#line 742
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 750
  x = 1;
  {
#line 750
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 750
    if (! (x < (int )(ar->width - 1))) {
#line 750
      goto while_break___1;
    }
#line 751
    y = 1;
    {
#line 751
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 751
      if (! (y < (int )(ar->height - 1))) {
#line 751
        goto while_break___2;
      }
#line 753
      neigbours[0] = *(ar->data + ((x - 1) + (y - 1) * (int )ar->width));
#line 754
      neigbours[1] = *(ar->data + (x + (y - 1) * (int )ar->width));
#line 755
      neigbours[2] = *(ar->data + ((x + 1) + (y - 1) * (int )ar->width));
#line 757
      neigbours[3] = *(ar->data + ((x - 1) + y * (int )ar->width));
#line 758
      neigbours[4] = *(ar->data + (x + y * (int )ar->width));
#line 759
      neigbours[5] = *(ar->data + ((x + 1) + y * (int )ar->width));
#line 761
      neigbours[6] = *(ar->data + ((x - 1) + (y + 1) * (int )ar->width));
#line 762
      neigbours[7] = *(ar->data + (x + (y + 1) * (int )ar->width));
#line 763
      neigbours[8] = *(ar->data + ((x + 1) + (y + 1) * (int )ar->width));
#line 765
      sum = (((((((neigbours[0] * *(kernel->data + 0) + neigbours[1] * *(kernel->data + 1)) + neigbours[2] * *(kernel->data + 2)) + neigbours[3] * *(kernel->data + 3)) + neigbours[4] * *(kernel->data + 4)) + neigbours[5] * *(kernel->data + 5)) + neigbours[6] * *(kernel->data + 6)) + neigbours[7] * *(kernel->data + 7)) + neigbours[8] * *(kernel->data + 8);
#line 774
      *(ar_out->data + (x + y * ar_out->width)) = sum;
#line 751
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 750
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 777
  return (ar_out);
}
}
#line 785 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_median_filter(ho_array const   *ar ) 
{ 
  int i ;
  int j ;
  int x ;
  int y ;
  int i_min ;
  double median ;
  double max ;
  double neigbours[9] ;
  ho_array *ar_out ;

  {
  {
#line 796
  ar_out = (ho_array *)((void *)0);
#line 799
  ar_out = ho_array_new(ar->width, ar->height);
  }
#line 800
  if (! ar_out) {
#line 801
    return ((ho_array *)((void *)0));
  }
#line 804
  x = 0;
  {
#line 804
  while (1) {
    while_continue: /* CIL Label */ ;
#line 804
    if (! (x < (int )ar->width)) {
#line 804
      goto while_break;
    }
#line 806
    *(ar_out->data + x) = *(ar->data + x);
#line 807
    *(ar_out->data + (x + (ar_out->height - 1) * ar_out->width)) = *(ar->data + (x + (int )((ar->height - 1) * ar->width)));
#line 804
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 810
  y = 0;
  {
#line 810
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 810
    if (! (y < (int )ar->height)) {
#line 810
      goto while_break___0;
    }
#line 812
    *(ar_out->data + y * ar_out->width) = *(ar->data + y * (int )ar->width);
#line 813
    *(ar_out->data + ((ar_out->width - 1) + y * ar_out->width)) = *(ar->data + ((ar->width - 1) + (int const   )(y * (int )ar->width)));
#line 810
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 818
  x = 1;
  {
#line 818
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 818
    if (! (x < (int )(ar->width - 1))) {
#line 818
      goto while_break___1;
    }
#line 819
    y = 1;
    {
#line 819
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 819
      if (! (y < (int )(ar->height - 1))) {
#line 819
        goto while_break___2;
      }
#line 821
      neigbours[0] = *(ar->data + ((x - 1) + (y - 1) * (int )ar->width));
#line 822
      neigbours[1] = *(ar->data + (x + (y - 1) * (int )ar->width));
#line 823
      neigbours[2] = *(ar->data + ((x + 1) + (y - 1) * (int )ar->width));
#line 825
      neigbours[3] = *(ar->data + ((x - 1) + y * (int )ar->width));
#line 826
      neigbours[4] = *(ar->data + (x + y * (int )ar->width));
#line 827
      neigbours[5] = *(ar->data + ((x + 1) + y * (int )ar->width));
#line 829
      neigbours[6] = *(ar->data + ((x - 1) + (y + 1) * (int )ar->width));
#line 830
      neigbours[7] = *(ar->data + (x + (y + 1) * (int )ar->width));
#line 831
      neigbours[8] = *(ar->data + ((x + 1) + (y + 1) * (int )ar->width));
#line 834
      max = neigbours[0];
#line 835
      i = 0;
      {
#line 835
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 835
        if (! (i < 9)) {
#line 835
          goto while_break___3;
        }
#line 836
        if (max < neigbours[i]) {
#line 837
          max = neigbours[i];
        }
#line 835
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 840
      j = 0;
      {
#line 840
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 840
        if (! (j < 4)) {
#line 840
          goto while_break___4;
        }
#line 842
        i_min = 0;
#line 843
        i = 0;
        {
#line 843
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 843
          if (! (i < 9)) {
#line 843
            goto while_break___5;
          }
#line 844
          if (neigbours[i_min] > neigbours[i]) {
#line 845
            i_min = i;
          }
#line 843
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 846
        neigbours[i_min] = max;
#line 840
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
#line 849
      median = max;
#line 850
      i = 0;
      {
#line 850
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 850
        if (! (i < 9)) {
#line 850
          goto while_break___6;
        }
#line 851
        if (median > neigbours[i]) {
#line 852
          median = neigbours[i];
        }
#line 850
        i ++;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 854
      *(ar_out->data + (x + y * ar_out->width)) = median;
#line 819
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 818
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 857
  return (ar_out);
}
}
#line 865 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_max_filter(ho_array const   *ar ) 
{ 
  int i ;
  int x ;
  int y ;
  double max ;
  double neigbours[9] ;
  ho_array *ar_out ;

  {
  {
#line 874
  ar_out = (ho_array *)((void *)0);
#line 877
  ar_out = ho_array_new(ar->width, ar->height);
  }
#line 878
  if (! ar_out) {
#line 879
    return ((ho_array *)((void *)0));
  }
#line 882
  x = 0;
  {
#line 882
  while (1) {
    while_continue: /* CIL Label */ ;
#line 882
    if (! (x < (int )ar->width)) {
#line 882
      goto while_break;
    }
#line 884
    *(ar_out->data + x) = *(ar->data + x);
#line 885
    *(ar_out->data + (x + (ar_out->height - 1) * ar_out->width)) = *(ar->data + (x + (int )((ar->height - 1) * ar->width)));
#line 882
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 888
  y = 0;
  {
#line 888
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 888
    if (! (y < (int )ar->height)) {
#line 888
      goto while_break___0;
    }
#line 890
    *(ar_out->data + y * ar_out->width) = *(ar->data + y * (int )ar->width);
#line 891
    *(ar_out->data + ((ar_out->width - 1) + y * ar_out->width)) = *(ar->data + ((ar->width - 1) + (int const   )(y * (int )ar->width)));
#line 888
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 896
  x = 1;
  {
#line 896
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 896
    if (! (x < (int )(ar->width - 1))) {
#line 896
      goto while_break___1;
    }
#line 897
    y = 1;
    {
#line 897
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 897
      if (! (y < (int )(ar->height - 1))) {
#line 897
        goto while_break___2;
      }
#line 899
      neigbours[0] = *(ar->data + ((x - 1) + (y - 1) * (int )ar->width));
#line 900
      neigbours[1] = *(ar->data + (x + (y - 1) * (int )ar->width));
#line 901
      neigbours[2] = *(ar->data + ((x + 1) + (y - 1) * (int )ar->width));
#line 903
      neigbours[3] = *(ar->data + ((x - 1) + y * (int )ar->width));
#line 904
      neigbours[4] = *(ar->data + (x + y * (int )ar->width));
#line 905
      neigbours[5] = *(ar->data + ((x + 1) + y * (int )ar->width));
#line 907
      neigbours[6] = *(ar->data + ((x - 1) + (y + 1) * (int )ar->width));
#line 908
      neigbours[7] = *(ar->data + (x + (y + 1) * (int )ar->width));
#line 909
      neigbours[8] = *(ar->data + ((x + 1) + (y + 1) * (int )ar->width));
#line 912
      max = neigbours[0];
#line 913
      i = 1;
      {
#line 913
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 913
        if (! (i < 9)) {
#line 913
          goto while_break___3;
        }
#line 914
        if (max < neigbours[i]) {
#line 915
          max = neigbours[i];
        }
#line 913
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 917
      *(ar_out->data + (x + y * ar_out->width)) = max;
#line 897
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 896
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 920
  return (ar_out);
}
}
#line 928 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_min_filter(ho_array const   *ar ) 
{ 
  int i ;
  int x ;
  int y ;
  double min ;
  double neigbours[9] ;
  ho_array *ar_out ;

  {
  {
#line 937
  ar_out = (ho_array *)((void *)0);
#line 940
  ar_out = ho_array_new(ar->width, ar->height);
  }
#line 941
  if (! ar_out) {
#line 942
    return ((ho_array *)((void *)0));
  }
#line 945
  x = 0;
  {
#line 945
  while (1) {
    while_continue: /* CIL Label */ ;
#line 945
    if (! (x < (int )ar->width)) {
#line 945
      goto while_break;
    }
#line 947
    *(ar_out->data + x) = *(ar->data + x);
#line 948
    *(ar_out->data + (x + (ar_out->height - 1) * ar_out->width)) = *(ar->data + (x + (int )((ar->height - 1) * ar->width)));
#line 945
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 951
  y = 0;
  {
#line 951
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 951
    if (! (y < (int )ar->height)) {
#line 951
      goto while_break___0;
    }
#line 953
    *(ar_out->data + y * ar_out->width) = *(ar->data + y * (int )ar->width);
#line 954
    *(ar_out->data + ((ar_out->width - 1) + y * ar_out->width)) = *(ar->data + ((ar->width - 1) + (int const   )(y * (int )ar->width)));
#line 951
    y ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 959
  x = 1;
  {
#line 959
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 959
    if (! (x < (int )(ar->width - 1))) {
#line 959
      goto while_break___1;
    }
#line 960
    y = 1;
    {
#line 960
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 960
      if (! (y < (int )(ar->height - 1))) {
#line 960
        goto while_break___2;
      }
#line 962
      neigbours[0] = *(ar->data + ((x - 1) + (y - 1) * (int )ar->width));
#line 963
      neigbours[1] = *(ar->data + (x + (y - 1) * (int )ar->width));
#line 964
      neigbours[2] = *(ar->data + ((x + 1) + (y - 1) * (int )ar->width));
#line 966
      neigbours[3] = *(ar->data + ((x - 1) + y * (int )ar->width));
#line 967
      neigbours[4] = *(ar->data + (x + y * (int )ar->width));
#line 968
      neigbours[5] = *(ar->data + ((x + 1) + y * (int )ar->width));
#line 970
      neigbours[6] = *(ar->data + ((x - 1) + (y + 1) * (int )ar->width));
#line 971
      neigbours[7] = *(ar->data + (x + (y + 1) * (int )ar->width));
#line 972
      neigbours[8] = *(ar->data + ((x + 1) + (y + 1) * (int )ar->width));
#line 975
      min = neigbours[0];
#line 976
      i = 1;
      {
#line 976
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 976
        if (! (i < 9)) {
#line 976
          goto while_break___3;
        }
#line 977
        if (min > neigbours[i]) {
#line 978
          min = neigbours[i];
        }
#line 976
        i ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 980
      *(ar_out->data + (x + y * ar_out->width)) = min;
#line 960
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 959
    x ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 983
  return (ar_out);
}
}
#line 992 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_complex_abs(ho_array const   *ar1 , ho_array const   *ar2 ) 
{ 
  int x ;
  int y ;
  ho_array *ar_out ;

  {
  {
#line 997
  ar_out = (ho_array *)((void *)0);
#line 1000
  ar_out = ho_array_new(ar1->width, ar1->height);
  }
#line 1001
  if (! ar_out) {
#line 1002
    return ((ho_array *)((void *)0));
  }
#line 1005
  x = 0;
  {
#line 1005
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1005
    if (! (x < (int )ar1->width)) {
#line 1005
      goto while_break;
    }
#line 1006
    y = 0;
    {
#line 1006
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1006
      if (! (y < (int )ar1->height)) {
#line 1006
        goto while_break___0;
      }
      {
#line 1008
      *(ar_out->data + (x + y * ar_out->width)) = sqrt(*(ar1->data + (x + y * (int )ar1->width)) * *(ar1->data + (x + y * (int )ar1->width)) + *(ar2->data + (x + y * (int )ar2->width)) * *(ar2->data + (x + y * (int )ar2->width)));
#line 1006
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1005
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1014
  return (ar_out);
}
}
#line 1023 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_complex_atan2(ho_array const   *ar1 , ho_array const   *ar2 ) 
{ 
  int x ;
  int y ;
  ho_array *ar_out ;

  {
  {
#line 1028
  ar_out = (ho_array *)((void *)0);
#line 1031
  ar_out = ho_array_new(ar1->width, ar1->height);
  }
#line 1032
  if (! ar_out) {
#line 1033
    return ((ho_array *)((void *)0));
  }
#line 1036
  x = 0;
  {
#line 1036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1036
    if (! (x < (int )ar1->width)) {
#line 1036
      goto while_break;
    }
#line 1037
    y = 0;
    {
#line 1037
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1037
      if (! (y < (int )ar1->height)) {
#line 1037
        goto while_break___0;
      }
      {
#line 1039
      *(ar_out->data + (x + y * ar_out->width)) = atan2(*(ar1->data + (x + y * (int )ar1->width)),
                                                        *(ar2->data + (x + y * (int )ar2->width)));
#line 1037
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1036
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1044
  return (ar_out);
}
}
#line 1054 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
unsigned char ho_array_gradient(ho_array const   *ar , ho_array *ar_r , ho_array *ar_theta ) 
{ 
  int x ;
  int y ;
  double sum_x ;
  double sum_y ;
  double neigbours[9] ;
  double sobol_x[9] ;
  double sobol_y[9] ;

  {
#line 1062
  sobol_x[0] = (double )-1;
#line 1062
  sobol_x[1] = (double )0;
#line 1062
  sobol_x[2] = (double )1;
#line 1062
  sobol_x[3] = (double )-2;
#line 1062
  sobol_x[4] = (double )0;
#line 1062
  sobol_x[5] = (double )2;
#line 1062
  sobol_x[6] = (double )-1;
#line 1062
  sobol_x[7] = (double )0;
#line 1062
  sobol_x[8] = (double )1;
#line 1063
  sobol_y[0] = (double )1;
#line 1063
  sobol_y[1] = (double )2;
#line 1063
  sobol_y[2] = (double )1;
#line 1063
  sobol_y[3] = (double )0;
#line 1063
  sobol_y[4] = (double )0;
#line 1063
  sobol_y[5] = (double )0;
#line 1063
  sobol_y[6] = (double )-1;
#line 1063
  sobol_y[7] = (double )-2;
#line 1063
  sobol_y[8] = (double )-1;
#line 1066
  x = 1;
  {
#line 1066
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1066
    if (! (x < (int )(ar->width - 1))) {
#line 1066
      goto while_break;
    }
#line 1067
    y = 1;
    {
#line 1067
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1067
      if (! (y < (int )(ar->height - 1))) {
#line 1067
        goto while_break___0;
      }
      {
#line 1069
      neigbours[0] = *(ar->data + ((x - 1) + (y - 1) * (int )ar->width));
#line 1070
      neigbours[1] = *(ar->data + (x + (y - 1) * (int )ar->width));
#line 1071
      neigbours[2] = *(ar->data + ((x + 1) + (y - 1) * (int )ar->width));
#line 1073
      neigbours[3] = *(ar->data + ((x - 1) + y * (int )ar->width));
#line 1074
      neigbours[4] = *(ar->data + (x + y * (int )ar->width));
#line 1075
      neigbours[5] = *(ar->data + ((x + 1) + y * (int )ar->width));
#line 1077
      neigbours[6] = *(ar->data + ((x - 1) + (y + 1) * (int )ar->width));
#line 1078
      neigbours[7] = *(ar->data + (x + (y + 1) * (int )ar->width));
#line 1079
      neigbours[8] = *(ar->data + ((x + 1) + (y + 1) * (int )ar->width));
#line 1081
      sum_x = (((((((neigbours[0] * sobol_x[0] + neigbours[1] * sobol_x[1]) + neigbours[2] * sobol_x[2]) + neigbours[3] * sobol_x[3]) + neigbours[4] * sobol_x[4]) + neigbours[5] * sobol_x[5]) + neigbours[6] * sobol_x[6]) + neigbours[7] * sobol_x[7]) + neigbours[8] * sobol_x[8];
#line 1090
      sum_y = (((((((neigbours[0] * sobol_y[0] + neigbours[1] * sobol_y[1]) + neigbours[2] * sobol_y[2]) + neigbours[3] * sobol_y[3]) + neigbours[4] * sobol_y[4]) + neigbours[5] * sobol_y[5]) + neigbours[6] * sobol_y[6]) + neigbours[7] * sobol_y[7]) + neigbours[8] * sobol_y[8];
#line 1100
      *(ar_r->data + (x + y * ar_r->width)) = sqrt(sum_x * sum_x + sum_y * sum_y);
#line 1102
      *(ar_theta->data + (x + y * ar_theta->width)) = atan2(sum_y, sum_x);
#line 1067
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1066
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1105
  return ((unsigned char)0);
}
}
#line 1115 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_hough_circles(ho_array const   *ar , int const   min_radius , int const   max_radius ,
                                 unsigned char const   t ) 
{ 
  int radius ;
  double r ;
  double theta ;
  double min ;
  double max ;
  double threshold ;
  double threshold_percent ;
  int x ;
  int y ;
  int xtag ;
  int ytag ;
  ho_array *ar_out ;
  ho_array *ar_r ;
  ho_array *ar_theta ;
  double tmp ;
  double tmp___0 ;

  {
#line 1133
  ar_out = (ho_array *)((void *)0);
#line 1135
  ar_r = (ho_array *)((void *)0);
#line 1137
  ar_theta = (ho_array *)((void *)0);
#line 1139
  if (! t) {
#line 1140
    threshold_percent = 0.1;
  } else {
#line 1142
    threshold_percent = (double )t;
  }
  {
#line 1145
  ar_out = ho_array_new(ar->width, ar->height);
  }
#line 1146
  if (! ar_out) {
#line 1147
    return ((ho_array *)((void *)0));
  }
  {
#line 1149
  ar_r = ho_array_new(ar->width, ar->height);
  }
#line 1150
  if (! ar_r) {
    {
#line 1152
    ho_array_free(ar_out);
    }
#line 1153
    return ((ho_array *)((void *)0));
  }
  {
#line 1156
  ar_theta = ho_array_new(ar->width, ar->height);
  }
#line 1157
  if (! ar_theta) {
    {
#line 1159
    ho_array_free(ar_out);
#line 1160
    ho_array_free(ar_r);
    }
#line 1161
    return ((ho_array *)((void *)0));
  }
  {
#line 1165
  ho_array_gradient(ar, ar_r, ar_theta);
#line 1168
  ho_array_minmax((ho_array const   *)ar_r, & min, & max);
#line 1169
  threshold = min + (threshold_percent * (max - min)) / 100.0;
#line 1172
  x = 0;
  }
  {
#line 1172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1172
    if (! (x < (int )ar->width)) {
#line 1172
      goto while_break;
    }
#line 1173
    y = 0;
    {
#line 1173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1173
      if (! (y < (int )ar->height)) {
#line 1173
        goto while_break___0;
      }
#line 1175
      r = *(ar_r->data + (x + y * ar_r->width));
#line 1176
      theta = *(ar_theta->data + (x + y * ar_theta->width));
#line 1179
      if (r > threshold) {
#line 1180
        radius = (int )min_radius;
        {
#line 1180
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1180
          if (! (radius < (int )max_radius)) {
#line 1180
            goto while_break___1;
          }
          {
#line 1182
          tmp = cos(theta);
#line 1182
          xtag = x - (int )((double )radius * tmp);
#line 1183
          tmp___0 = sin(theta);
#line 1183
          ytag = y + (int )((double )radius * tmp___0);
          }
#line 1186
          if (ytag >= 0) {
#line 1186
            if (ytag < ar_r->height) {
#line 1186
              if (xtag >= 0) {
#line 1186
                if (xtag < ar_r->width) {
#line 1189
                  *(ar_out->data + (xtag + ytag * ar_out->width)) += (double )1;
                }
              }
            }
          }
#line 1180
          radius ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1173
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1172
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1196
  ho_array_free(ar_theta);
#line 1197
  ho_array_free(ar_r);
  }
#line 1199
  return (ar_out);
}
}
#line 1207 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_hough_lines(ho_array const   *ar , unsigned char const   t ) 
{ 
  double r ;
  double theta ;
  double min ;
  double max ;
  double threshold ;
  double threshold_percent ;
  int x ;
  int y ;
  int xtag ;
  int ytag ;
  ho_array *ar_out ;
  ho_array *ar_r ;
  ho_array *ar_theta ;
  double tmp ;
  double tmp___0 ;

  {
#line 1222
  ar_out = (ho_array *)((void *)0);
#line 1224
  ar_r = (ho_array *)((void *)0);
#line 1226
  ar_theta = (ho_array *)((void *)0);
#line 1228
  if (! t) {
#line 1229
    threshold_percent = (double )10;
  } else {
#line 1231
    threshold_percent = (double )t;
  }
  {
#line 1234
  ar_out = ho_array_new(ar->width, (int const   )180);
  }
#line 1235
  if (! ar_out) {
#line 1236
    return ((ho_array *)((void *)0));
  }
  {
#line 1238
  ar_r = ho_array_new(ar->width, ar->height);
  }
#line 1239
  if (! ar_r) {
    {
#line 1241
    ho_array_free(ar_out);
    }
#line 1242
    return ((ho_array *)((void *)0));
  }
  {
#line 1245
  ar_theta = ho_array_new(ar->width, ar->height);
  }
#line 1246
  if (! ar_theta) {
    {
#line 1248
    ho_array_free(ar_out);
#line 1249
    ho_array_free(ar_r);
    }
#line 1250
    return ((ho_array *)((void *)0));
  }
  {
#line 1254
  ho_array_gradient(ar, ar_r, ar_theta);
#line 1257
  ho_array_free(ar_theta);
#line 1260
  ho_array_minmax((ho_array const   *)ar_r, & min, & max);
#line 1261
  threshold = min + (threshold_percent * (max - min)) / 100.0;
#line 1264
  x = 0;
  }
  {
#line 1264
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1264
    if (! (x < (int )ar->width)) {
#line 1264
      goto while_break;
    }
#line 1265
    y = 0;
    {
#line 1265
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1265
      if (! (y < (int )ar->height)) {
#line 1265
        goto while_break___0;
      }
#line 1267
      r = *(ar_r->data + (x + y * ar_r->width));
#line 1270
      if (r > threshold) {
#line 1271
        ytag = 0;
        {
#line 1271
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1271
          if (! (ytag < 180)) {
#line 1271
            goto while_break___1;
          }
          {
#line 1273
          theta = (3.14159265358979323846 * (double )ytag) / 180.0;
#line 1275
          tmp = cos(theta);
#line 1275
          tmp___0 = sin(theta);
#line 1275
          xtag = ar_out->width / 2 + (int )((double )x * tmp + (double )y * tmp___0);
          }
#line 1280
          if (xtag >= 0) {
#line 1280
            if (xtag < ar_out->width) {
#line 1282
              *(ar_out->data + (xtag + ytag * ar_out->width)) += (double )1;
            }
          }
#line 1271
          ytag ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1265
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1264
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1289
  ho_array_free(ar_r);
  }
#line 1291
  return (ar_out);
}
}
#line 1301 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_hough_lines_backwords(ho_array const   *ar , int const   width ,
                                         int const   height , unsigned char const   t ) 
{ 
  int x ;
  int y ;
  double min ;
  double max ;
  double threshold ;
  double threshold_percent ;
  int xtag ;
  int ytag ;
  double theta ;
  double a ;
  double b ;
  ho_array *ar_out ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  double tmp___3 ;
  double tmp___4 ;
  double tmp___5 ;
  double tmp___6 ;
  double tmp___7 ;

  {
#line 1317
  ar_out = (ho_array *)((void *)0);
#line 1319
  if (! t) {
#line 1320
    threshold_percent = (double )40;
  } else {
#line 1322
    threshold_percent = (double )t;
  }
  {
#line 1325
  ar_out = ho_array_new(width, height);
  }
#line 1326
  if (! ar_out) {
#line 1327
    return ((ho_array *)((void *)0));
  }
  {
#line 1330
  ho_array_minmax(ar, & min, & max);
#line 1331
  threshold = min + (threshold_percent * (max - min)) / 100.0;
#line 1334
  x = 0;
  }
  {
#line 1334
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1334
    if (! (x < (int )ar->width)) {
#line 1334
      goto while_break;
    }
#line 1336
    y = 45;
    {
#line 1336
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1336
      if (! (y < 135)) {
#line 1336
        goto while_break___0;
      }
#line 1339
      if (*(ar->data + (x + y * (int )ar->width)) > threshold) {
        {
#line 1341
        theta = (3.14159265358979323846 * (double )y) / 180.0;
#line 1342
        tmp = cos(theta);
#line 1342
        tmp___0 = sin(theta);
#line 1342
        a = - tmp / tmp___0;
#line 1343
        tmp___1 = sin(theta);
#line 1343
        b = (double )(x - (int )(ar->width / 2)) / tmp___1;
#line 1346
        xtag = 0;
        }
        {
#line 1346
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1346
          if (! (xtag < (int )width)) {
#line 1346
            goto while_break___1;
          }
#line 1348
          ytag = (int )(a * (double )xtag + b) + (int )(ar->width / 2);
#line 1351
          if (ytag >= 0) {
#line 1351
            if (ytag < ar_out->height) {
#line 1353
              *(ar_out->data + (xtag + ytag * ar_out->width)) += (double )1;
            }
          }
#line 1346
          xtag ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1336
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1360
    y = 1;
    {
#line 1360
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1360
      if (! (y < 45)) {
#line 1360
        goto while_break___2;
      }
#line 1363
      if (*(ar->data + (x + y * (int )ar->width)) > threshold) {
#line 1363
        if (y != 90) {
          {
#line 1365
          theta = (3.14159265358979323846 * (double )y) / 180.0;
#line 1366
          tmp___2 = sin(theta);
#line 1366
          tmp___3 = cos(theta);
#line 1366
          a = - tmp___2 / tmp___3;
#line 1367
          tmp___4 = cos(theta);
#line 1367
          b = (double )(x - (int )(ar->width / 2)) / tmp___4;
#line 1370
          ytag = 0;
          }
          {
#line 1370
          while (1) {
            while_continue___3: /* CIL Label */ ;
#line 1370
            if (! (ytag < (int )height)) {
#line 1370
              goto while_break___3;
            }
#line 1372
            xtag = (int )(a * (double )ytag + b);
#line 1375
            if (xtag >= 0) {
#line 1375
              if (xtag < ar_out->width) {
#line 1377
                *(ar_out->data + (xtag + ytag * ar_out->width)) += (double )1;
              }
            }
#line 1370
            ytag ++;
          }
          while_break___3: /* CIL Label */ ;
          }
        }
      }
#line 1360
      y ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1384
    y = 135;
    {
#line 1384
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 1384
      if (! (y < 180)) {
#line 1384
        goto while_break___4;
      }
#line 1387
      if (*(ar->data + (x + y * (int )ar->width)) > threshold) {
#line 1387
        if (y != 90) {
          {
#line 1389
          theta = (3.14159265358979323846 * (double )y) / 180.0;
#line 1390
          tmp___5 = sin(theta);
#line 1390
          tmp___6 = cos(theta);
#line 1390
          a = - tmp___5 / tmp___6;
#line 1391
          tmp___7 = cos(theta);
#line 1391
          b = (double )(x - (int )(ar->width / 2)) / tmp___7;
#line 1394
          ytag = 0;
          }
          {
#line 1394
          while (1) {
            while_continue___5: /* CIL Label */ ;
#line 1394
            if (! (ytag < (int )height)) {
#line 1394
              goto while_break___5;
            }
#line 1396
            xtag = (int )(a * (double )ytag + b);
#line 1399
            if (xtag >= 0) {
#line 1399
              if (xtag < ar_out->width) {
#line 1401
                *(ar_out->data + (xtag + ytag * ar_out->width)) += (double )1;
              }
            }
#line 1394
            ytag ++;
          }
          while_break___5: /* CIL Label */ ;
          }
        }
      }
#line 1384
      y ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 1334
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1409
  return (ar_out);
}
}
#line 1421 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_hough_lines_backwords_by_angle(ho_array const   *ar , int const   width ,
                                                  int const   height , int const   angle1 ,
                                                  int const   angle2 ) 
{ 
  int x ;
  int y ;
  int xtag ;
  int ytag ;
  double theta ;
  double a ;
  double b ;
  ho_array *ar_out ;
  ho_array *tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;

  {
#line 1431
  ar_out = (ho_array *)((void *)0);
#line 1434
  if (angle1 > 45) {
#line 1434
    if (angle1 < 135) {
      {
#line 1435
      tmp = ho_array_hough_lines_backwords_by_angle_v(ar, width, height, angle1, angle2);
      }
#line 1435
      return (tmp);
    }
  }
  {
#line 1439
  ar_out = ho_array_new(width, height);
  }
#line 1440
  if (! ar_out) {
#line 1441
    return ((ho_array *)((void *)0));
  }
#line 1444
  x = 0;
  {
#line 1444
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1444
    if (! (x < (int )ar->width)) {
#line 1444
      goto while_break;
    }
#line 1446
    y = (int )angle1;
    {
#line 1446
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1446
      if (! (y < (int )angle2)) {
#line 1446
        goto while_break___0;
      }
#line 1449
      if (*(ar->data + (x + y * (int )ar->width)) > 0.5) {
        {
#line 1452
        theta = (3.14159265358979323846 * (double )y) / 180.0;
#line 1453
        tmp___0 = cos(theta);
#line 1453
        tmp___1 = sin(theta);
#line 1453
        a = - tmp___0 / tmp___1;
#line 1454
        tmp___2 = sin(theta);
#line 1454
        b = (double )(x - (int )(ar->width / 2)) / tmp___2;
#line 1457
        xtag = 0;
        }
        {
#line 1457
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 1457
          if (! (xtag < (int )width)) {
#line 1457
            goto while_break___1;
          }
#line 1459
          ytag = (int )(a * (double )x + b);
#line 1462
          if (ytag >= 0) {
#line 1462
            if (ytag < ar_out->height) {
#line 1464
              *(ar_out->data + (xtag + ytag * ar_out->width)) += (double )1;
            }
          }
#line 1457
          xtag ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 1446
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1444
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1472
  return (ar_out);
}
}
#line 1484 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_hough_lines_backwords_by_angle_v(ho_array const   *ar , int const   width ,
                                                    int const   height , int const   angle1 ,
                                                    int const   angle2 ) 
{ 
  int x ;
  int y ;
  int xtag ;
  int ytag ;
  double theta ;
  double a ;
  double b ;
  ho_array *ar_out ;
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;

  {
  {
#line 1494
  ar_out = (ho_array *)((void *)0);
#line 1497
  ar_out = ho_array_new(width, height);
  }
#line 1498
  if (! ar_out) {
#line 1499
    return ((ho_array *)((void *)0));
  }
#line 1502
  x = 0;
  {
#line 1502
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1502
    if (! (x < (int )ar->width)) {
#line 1502
      goto while_break;
    }
#line 1504
    y = (int )angle1;
    {
#line 1504
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1504
      if (! (y < (int )angle2)) {
#line 1504
        goto while_break___0;
      }
#line 1507
      if (y != 90) {
#line 1507
        if (*(ar->data + (x + y * (int )ar->width)) > 0.5) {
          {
#line 1510
          theta = (3.14159265358979323846 * (double )y) / 180.0;
#line 1511
          tmp = sin(theta);
#line 1511
          tmp___0 = cos(theta);
#line 1511
          a = - tmp / tmp___0;
#line 1512
          tmp___1 = cos(theta);
#line 1512
          b = (double )(x - (int )(ar->width / 2)) / tmp___1;
#line 1515
          ytag = 0;
          }
          {
#line 1515
          while (1) {
            while_continue___1: /* CIL Label */ ;
#line 1515
            if (! (ytag < (int )height)) {
#line 1515
              goto while_break___1;
            }
#line 1517
            xtag = (int )(a * (double )y + b);
#line 1520
            if (xtag >= 0) {
#line 1520
              if (xtag < ar_out->width) {
#line 1522
                *(ar_out->data + (xtag + ytag * ar_out->width)) += (double )1;
              }
            }
#line 1515
            ytag ++;
          }
          while_break___1: /* CIL Label */ ;
          }
        }
      }
#line 1504
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1502
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1530
  return (ar_out);
}
}
#line 1533 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array const   *ho_array_pnm_load(char const   *filename ) 
{ 
  ho_pixbuf *pix ;
  ho_array *ar ;

  {
  {
#line 1540
  pix = ho_pixbuf_pnm_load(filename);
  }
#line 1541
  if (! pix) {
#line 1542
    return ((ho_array const   *)((void *)0));
  }
  {
#line 1544
  ar = ho_array_new_from_pixbuf((ho_pixbuf const   *)pix);
#line 1546
  ho_pixbuf_free(pix);
  }
#line 1548
  return ((ho_array const   *)ar);
}
}
#line 1551 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
int ho_array_pnm_save(ho_array const   *ar , char const   *filename ) 
{ 
  ho_pixbuf *pix ;

  {
  {
#line 1556
  pix = ho_array_to_pixbuf(ar);
  }
#line 1557
  if (! pix) {
#line 1558
    return (-1);
  }
  {
#line 1560
  ho_pixbuf_pnm_save((ho_pixbuf const   *)pix, filename);
#line 1562
  ho_pixbuf_free(pix);
  }
#line 1564
  return (0);
}
}
#line 1898 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_new_gaussien(int const   width , int const   height , double const   sigma ) 
{ 
  int x ;
  int y ;
  ho_array *pix ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 1903
  pix = (ho_array *)((void *)0);
#line 1908
  tmp = malloc(sizeof(ho_array ));
#line 1908
  pix = (ho_array *)tmp;
  }
#line 1909
  if (! pix) {
#line 1911
    return ((ho_array *)((void *)0));
  }
  {
#line 1917
  pix->width = (int )width;
#line 1918
  pix->height = (int )height;
#line 1923
  tmp___0 = malloc((unsigned long )(pix->height * pix->width) * sizeof(double ));
#line 1923
  pix->data = (double *)tmp___0;
  }
#line 1924
  if (! pix->data) {
    {
#line 1926
    free((void *)pix);
    }
#line 1927
    return ((ho_array *)((void *)0));
  }
#line 1931
  x = 0;
  {
#line 1931
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1931
    if (! (x < pix->width)) {
#line 1931
      goto while_break;
    }
#line 1932
    y = 0;
    {
#line 1932
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1932
      if (! (y < pix->height)) {
#line 1932
        goto while_break___0;
      }
      {
#line 1934
      *(pix->data + (x + y * pix->width)) = exp((double )((- (sigma * sigma) * (double const   )(((double )x - (double )width / 2.0) * ((double )x - (double )width / 2.0) + ((double )y - (double )height / 2.0) * ((double )y - (double )height / 2.0))) / (double const   )2.0));
#line 1932
      y ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1931
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1939
  return (pix);
}
}
#line 1950 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_new_box(int const   width , int const   height , int const   box_width ,
                           int const   box_height ) 
{ 
  int x ;
  int y ;
  ho_array *pix ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;

  {
  {
#line 1956
  pix = (ho_array *)((void *)0);
#line 1961
  tmp = malloc(sizeof(ho_array ));
#line 1961
  pix = (ho_array *)tmp;
  }
#line 1962
  if (! pix) {
#line 1964
    return ((ho_array *)((void *)0));
  }
  {
#line 1970
  pix->width = (int )width;
#line 1971
  pix->height = (int )height;
#line 1976
  tmp___0 = malloc((unsigned long )(pix->height * pix->width) * sizeof(double ));
#line 1976
  pix->data = (double *)tmp___0;
  }
#line 1977
  if (! pix->data) {
    {
#line 1979
    free((void *)pix);
    }
#line 1980
    return ((ho_array *)((void *)0));
  }
#line 1984
  x = 0;
  {
#line 1984
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1984
    if (! (x < pix->width)) {
#line 1984
      goto while_break;
    }
#line 1985
    y = 0;
    {
#line 1985
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1985
      if (! (y < pix->height)) {
#line 1985
        goto while_break___0;
      }
#line 1987
      if (x > (int )((width - box_width) / 2)) {
#line 1987
        if (x < (int )((width + box_width) / 2)) {
#line 1987
          if (y > (int )((height - box_height) / 2)) {
#line 1987
            if (y < (int )((height + box_height) / 2)) {
#line 1987
              tmp___1 = 1;
            } else {
#line 1987
              tmp___1 = 0;
            }
          } else {
#line 1987
            tmp___1 = 0;
          }
        } else {
#line 1987
          tmp___1 = 0;
        }
      } else {
#line 1987
        tmp___1 = 0;
      }
#line 1987
      *(pix->data + (x + y * pix->width)) = (double )tmp___1;
#line 1985
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 1984
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1993
  return (pix);
}
}
#line 2003 "/home/june/repo/benchmarks/collector/temp/hocr-0.10.17/src/ho_array.c"
ho_array *ho_array_new_circle(int const   width , int const   height , int const   radius ) 
{ 
  int x ;
  int y ;
  ho_array *pix ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 2008
  pix = (ho_array *)((void *)0);
#line 2013
  tmp = malloc(sizeof(ho_array ));
#line 2013
  pix = (ho_array *)tmp;
  }
#line 2014
  if (! pix) {
#line 2016
    return ((ho_array *)((void *)0));
  }
  {
#line 2022
  pix->width = (int )width;
#line 2023
  pix->height = (int )height;
#line 2028
  tmp___0 = malloc((unsigned long )(pix->height * pix->width) * sizeof(double ));
#line 2028
  pix->data = (double *)tmp___0;
  }
#line 2029
  if (! pix->data) {
    {
#line 2031
    free((void *)pix);
    }
#line 2032
    return ((ho_array *)((void *)0));
  }
#line 2036
  x = 0;
  {
#line 2036
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2036
    if (! (x < pix->width)) {
#line 2036
      goto while_break;
    }
#line 2037
    y = 0;
    {
#line 2037
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2037
      if (! (y < pix->height)) {
#line 2037
        goto while_break___0;
      }
#line 2039
      *(pix->data + (x + y * pix->width)) = (double )(((double )x - (double )width / 2.0) * ((double )x - (double )width / 2.0) + ((double )y - (double )height / 2.0) * ((double )y - (double )height / 2.0) < (double )(radius * radius));
#line 2037
      y ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2036
    x ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2044
  return (pix);
}
}
