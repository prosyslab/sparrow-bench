/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 25 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.h"
struct converter {
   char *ext_from ;
   char *ext_to ;
   char *command ;
   struct converter *next ;
};
#line 51 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
enum opt {
    QUIET = 0,
    CDTEXT = 1,
    CONVERT = 2,
    CONVERTER = 3,
    E_O_F = 4,
    UNKNOWN = 5
} ;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 32 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.h"
enum session_type {
    CD_DA = 1,
    CD_ROM = 2,
    CD_ROM_XA = 3,
    INVALID = 4
} ;
#line 39
enum track_mode {
    AUDIO = 1,
    MODE1 = 2,
    MODE1_RAW = 3,
    MODE2 = 4,
    MODE2_RAW = 5
} ;
#line 47 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.h"
struct trackspec {
   enum track_mode mode ;
   int copy ;
   int pre_emphasis ;
   int four_channel_audio ;
   char isrc[13] ;
   char title[81] ;
   char performer[81] ;
   char songwriter[81] ;
   char filename[1025] ;
   long pregap ;
   int pregap_data_from_file ;
   long start ;
   long postgap ;
   long indexes[98] ;
   struct trackspec *next ;
};
#line 65 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.h"
struct cuesheet {
   char catalog[14] ;
   enum session_type type ;
   char title[81] ;
   char performer[81] ;
   char songwriter[81] ;
   struct trackspec *tracklist ;
};
#line 60 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
enum command {
    REM = 0,
    CATALOG = 1,
    CDTEXTFILE = 2,
    FILECMD = 3,
    PERFORMER = 4,
    SONGWRITER = 5,
    TITLE = 6,
    TRACK = 7,
    FLAGS = 8,
    DCP = 9,
    FOURCH = 10,
    PRE = 11,
    SCMS = 12,
    ISRC = 13,
    PREGAP = 14,
    INDEX = 15,
    POSTGAP = 16,
    BINARY = 17,
    MOTOROLA = 18,
    AIFF = 19,
    WAVE = 20,
    MP3 = 21,
    UNKNOWN___0 = 22,
    END = 23
} ;
#line 77
enum scope {
    CUESHEET = 0,
    GLOBAL = 1,
    ONETRACK = 2
} ;
#line 187 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.c"
union __anonunion_53 {
   int __in ;
   int __i ;
};
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 564
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) getenv)(char const   *__name ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 28 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/error.h"
void err_sys(char const   *s  , ...) ;
#line 31
void err_quit(char const   *s  , ...) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.h"
int cdtext ;
#line 28
int quiet ;
#line 31
int debug ;
#line 34
int convert ;
#line 37
void config(void) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.h"
struct converter *new_converter(void) ;
#line 39
void add_converter(struct converter *converter ) ;
#line 42 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
int convert  =    1;
#line 43 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
int cdtext  =    1;
#line 44 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
int quiet  =    0;
#line 45 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
int debug  =    0;
#line 48 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
static char *conffile  =    (char *)"~/.cue2tocrc";
#line 53 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
static char const   opts[4][10]  = { {        (char const   )'Q',        (char const   )'U',        (char const   )'I',        (char const   )'E', 
            (char const   )'T',        (char const   )'\000'}, 
   {        (char const   )'C',        (char const   )'D',        (char const   )'T',        (char const   )'E', 
            (char const   )'X',        (char const   )'T',        (char const   )'\000'}, 
   {        (char const   )'C',        (char const   )'O',        (char const   )'N',        (char const   )'V', 
            (char const   )'E',        (char const   )'R',        (char const   )'T',        (char const   )'\000'}, 
   {        (char const   )'C',        (char const   )'O',        (char const   )'N',        (char const   )'V', 
            (char const   )'E',        (char const   )'R',        (char const   )'T',        (char const   )'E', 
            (char const   )'R',        (char const   )'\000'}};
#line 57 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
static int line  =    1;
#line 61 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
enum opt get_opt(FILE *f ) 
{ 
  int c ;
  char buf[11] ;
  int i ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 66
  i = 0;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 70
    c = fgetc(f);
    }
#line 71
    if (c == 10) {
#line 71
      line ++;
    }
#line 72
    if (c == 35) {
      {
#line 73
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 73
        if (c != 10) {
#line 73
          if (! (c != -1)) {
#line 73
            goto while_break___0;
          }
        } else {
#line 73
          goto while_break___0;
        }
        {
#line 74
        c = fgetc(f);
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 75
      if (c == 10) {
#line 75
        line ++;
      }
    }
    {
#line 69
    tmp = __ctype_b_loc();
    }
#line 69
    if (! ((int const   )*(*tmp + c) & 8192)) {
#line 69
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 78
  if (c == -1) {
#line 78
    return ((enum opt )4);
  }
  {
#line 80
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 80
    tmp___2 = __ctype_b_loc();
    }
#line 80
    if ((int const   )*(*tmp___2 + c) & 8192) {
#line 80
      goto while_break___1;
    } else
#line 80
    if (c != 61) {
#line 80
      if (c != -1) {
#line 80
        if (! (i < 10)) {
#line 80
          goto while_break___1;
        }
      } else {
#line 80
        goto while_break___1;
      }
    } else {
#line 80
      goto while_break___1;
    }
    {
#line 81
    tmp___0 = i;
#line 81
    i ++;
#line 81
    tmp___1 = toupper(c);
#line 81
    buf[tmp___0] = (char )tmp___1;
#line 82
    c = fgetc(f);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 84
  buf[i] = (char )'\000';
#line 86
  if (c == 10) {
#line 86
    line ++;
  }
#line 88
  if (c == -1) {
    {
#line 89
    err_quit("%s:%d: Premature end of file", conffile, line);
    }
  }
  {
#line 90
  tmp___3 = __ctype_b_loc();
  }
#line 90
  if (! ((int const   )*(*tmp___3 + c) & 8192)) {
#line 90
    if (c != 61) {
#line 91
      return ((enum opt )5);
    }
  }
  {
#line 92
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 92
    tmp___4 = __ctype_b_loc();
    }
#line 92
    if (! ((int const   )*(*tmp___4 + c) & 8192)) {
#line 92
      goto while_break___2;
    }
    {
#line 93
    c = fgetc(f);
    }
#line 93
    if (c == 10) {
#line 94
      line ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 95
  if (c != 61) {
    {
#line 96
    err_quit("%s:%d: Syntax error (epected \'=\')", conffile, line);
    }
  }
  {
#line 98
  tmp___8 = strcmp((char const   *)(buf), opts[0]);
  }
#line 98
  if (tmp___8 == 0) {
#line 98
    return ((enum opt )0);
  } else {
    {
#line 99
    tmp___7 = strcmp((char const   *)(buf), opts[1]);
    }
#line 99
    if (tmp___7 == 0) {
#line 99
      return ((enum opt )1);
    } else {
      {
#line 100
      tmp___6 = strcmp((char const   *)(buf), opts[2]);
      }
#line 100
      if (tmp___6 == 0) {
#line 100
        return ((enum opt )2);
      } else {
        {
#line 101
        tmp___5 = strcmp((char const   *)(buf), opts[3]);
        }
#line 101
        if (tmp___5 == 0) {
#line 101
          return ((enum opt )3);
        } else {
#line 102
          return ((enum opt )5);
        }
      }
    }
  }
}
}
#line 107 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
size_t add_char(char **s , size_t len , size_t pos , char c ) 
{ 
  size_t sz ;
  size_t new_len ;
  char *tmp ;
  void *tmp___0 ;
  char *tmp___1 ;
  void *tmp___2 ;

  {
#line 110
  sz = (size_t )4;
#line 111
  new_len = len;
#line 113
  if (len == 0UL) {
    {
#line 114
    new_len = sz;
#line 114
    tmp___0 = malloc(new_len);
#line 114
    tmp = (char *)tmp___0;
#line 114
    *s = tmp;
    }
#line 114
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 115
      err_quit("Memory allocation error");
      }
    }
  }
  {
#line 116
  while (1) {
    while_continue: /* CIL Label */ ;
#line 116
    if (! (pos > new_len - 2UL)) {
#line 116
      goto while_break;
    }
    {
#line 117
    new_len += sz;
#line 118
    tmp___2 = realloc((void *)*s, new_len);
#line 118
    tmp___1 = (char *)tmp___2;
#line 118
    *s = tmp___1;
    }
#line 118
    if ((unsigned long )tmp___1 == (unsigned long )((void *)0)) {
      {
#line 119
      err_quit("Memory allocation error");
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 121
  *(*s + pos) = c;
#line 122
  *(*s + (pos + 1UL)) = (char )'\000';
#line 124
  return (new_len);
}
}
#line 128 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
static char *get_string(FILE *f ) 
{ 
  char *s ;
  size_t len ;
  size_t pos ;
  int c ;
  int quoted ;
  unsigned short const   **tmp ;
  size_t tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 131
  s = (char *)((void *)0);
#line 132
  len = (size_t )0;
#line 133
  pos = (size_t )0;
#line 135
  quoted = 0;
  {
#line 138
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 139
    c = fgetc(f);
    }
#line 140
    if (c == 10) {
#line 140
      line ++;
    }
    {
#line 138
    tmp = __ctype_b_loc();
    }
#line 138
    if (! ((int const   )*(*tmp + c) & 8192)) {
#line 138
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 143
  if (c == 34) {
    {
#line 144
    quoted = 1;
#line 145
    c = fgetc(f);
    }
#line 146
    if (c == 10) {
#line 146
      line ++;
    }
  }
  {
#line 155
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 156
    if (c == 34) {
#line 156
      if (quoted) {
#line 157
        if (pos > 0UL) {
#line 157
          if ((int )*(s + (pos - 1UL)) == 92) {
            {
#line 158
            len = add_char(& s, len, pos - 1UL, (char )c);
            }
          } else {
            {
#line 160
            len = add_char(& s, len, pos, (char )'\000');
            }
#line 161
            goto while_break___0;
          }
        } else {
          {
#line 160
          len = add_char(& s, len, pos, (char )'\000');
          }
#line 161
          goto while_break___0;
        }
      } else {
#line 156
        goto _L___0;
      }
    } else {
      _L___0: /* CIL Label */ 
      {
#line 163
      tmp___1 = __ctype_b_loc();
      }
#line 163
      if ((int const   )*(*tmp___1 + c) & 8192) {
#line 163
        if (! quoted) {
          {
#line 164
          len = add_char(& s, len, pos, (char )'\000');
          }
#line 165
          goto while_break___0;
        } else {
#line 163
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 166
      if (c == -1) {
#line 167
        if (quoted) {
          {
#line 168
          err_quit("%s:%d: Premature end of file", conffile, line);
          }
        } else {
          {
#line 171
          len = add_char(& s, len, pos, (char )'\000');
          }
#line 172
          goto while_break___0;
        }
      } else {
        {
#line 175
        tmp___0 = pos;
#line 175
        pos ++;
#line 175
        len = add_char(& s, len, tmp___0, (char )c);
        }
      }
    }
    {
#line 177
    c = fgetc(f);
    }
#line 178
    if (c == 10) {
#line 178
      line ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 181
  return (s);
}
}
#line 186 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
static int yes(char *s ) 
{ 
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
#line 189
  tmp = s;
  {
#line 191
  while (1) {
    while_continue: /* CIL Label */ ;
#line 191
    if (! *tmp) {
#line 191
      goto while_break;
    }
    {
#line 192
    tmp___0 = tolower((int )*tmp);
#line 192
    *tmp = (char )tmp___0;
#line 193
    tmp ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 196
  tmp___1 = strcmp((char const   *)s, "yes");
  }
#line 196
  if (tmp___1 == 0) {
#line 198
    return (1);
  } else {
    {
#line 196
    tmp___2 = strcmp((char const   *)s, "y");
    }
#line 196
    if (tmp___2 == 0) {
#line 198
      return (1);
    } else {
      {
#line 196
      tmp___3 = strcmp((char const   *)s, "true");
      }
#line 196
      if (tmp___3 == 0) {
#line 198
        return (1);
      } else {
        {
#line 196
        tmp___4 = strcmp((char const   *)s, "1");
        }
#line 196
        if (tmp___4 == 0) {
#line 198
          return (1);
        }
      }
    }
  }
#line 200
  return (0);
}
}
#line 205 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
static void parse_file(char const   *file ) 
{ 
  FILE *f ;
  enum opt option ;
  char *s ;
  struct converter *converter ;
  size_t tmp ;
  char const   *tmp___0 ;
  size_t tmp___1 ;
  char const   *tmp___2 ;
  size_t tmp___3 ;
  char const   *tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;

  {
  {
#line 213
  f = fopen((char const   */* __restrict  */)file, (char const   */* __restrict  */)"r");
  }
#line 213
  if ((unsigned long )f == (unsigned long )((void *)0)) {
    {
#line 214
    err_sys("Could not open file \"%s\" for reading", file);
    }
  }
  {
#line 216
  option = get_opt(f);
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! ((unsigned int )option != 4U)) {
#line 217
      goto while_break;
    }
    {
#line 219
    if ((unsigned int )option == 0U) {
#line 219
      goto case_0;
    }
#line 231
    if ((unsigned int )option == 1U) {
#line 231
      goto case_1;
    }
#line 243
    if ((unsigned int )option == 2U) {
#line 243
      goto case_2;
    }
#line 255
    if ((unsigned int )option == 3U) {
#line 255
      goto case_3;
    }
#line 286
    if ((unsigned int )option == 5U) {
#line 286
      goto case_5;
    }
#line 289
    goto switch_default;
    case_0: /* CIL Label */ 
#line 220
    if (debug) {
      {
#line 220
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option %s: ",
              opts[0]);
      }
    }
    {
#line 222
    s = get_string(f);
#line 222
    tmp = strlen((char const   *)s);
    }
#line 222
    if (tmp == 0UL) {
      {
#line 223
      err_quit("%s:%d: Option requires argument -- %s\n", conffile, line, opts[0]);
      }
    }
    {
#line 226
    quiet = yes(s);
#line 227
    free((void *)s);
    }
#line 229
    if (debug) {
#line 229
      if (quiet) {
#line 229
        tmp___0 = "yes";
      } else {
#line 229
        tmp___0 = "no";
      }
      {
#line 229
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              tmp___0);
      }
    }
#line 230
    goto switch_break;
    case_1: /* CIL Label */ 
#line 232
    if (debug) {
      {
#line 232
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option %s: ",
              opts[1]);
      }
    }
    {
#line 234
    s = get_string(f);
#line 234
    tmp___1 = strlen((char const   *)s);
    }
#line 234
    if (tmp___1 == 0UL) {
      {
#line 235
      err_quit("%s:%d: Option requires argument -- %s\n", conffile, line, opts[1]);
      }
    }
    {
#line 238
    cdtext = yes(s);
#line 239
    free((void *)s);
    }
#line 241
    if (debug) {
#line 241
      if (cdtext) {
#line 241
        tmp___2 = "yes";
      } else {
#line 241
        tmp___2 = "no";
      }
      {
#line 241
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              tmp___2);
      }
    }
#line 242
    goto switch_break;
    case_2: /* CIL Label */ 
#line 244
    if (debug) {
      {
#line 244
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option %s: ",
              opts[2]);
      }
    }
    {
#line 246
    s = get_string(f);
#line 246
    tmp___3 = strlen((char const   *)s);
    }
#line 246
    if (tmp___3 == 0UL) {
      {
#line 247
      err_quit("%s:%d: Option requires argument -- %s\n", conffile, line, opts[2]);
      }
    }
    {
#line 250
    convert = yes(s);
#line 251
    free((void *)s);
    }
#line 253
    if (debug) {
#line 253
      if (convert) {
#line 253
        tmp___4 = "yes";
      } else {
#line 253
        tmp___4 = "no";
      }
      {
#line 253
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
              tmp___4);
      }
    }
#line 254
    goto switch_break;
    case_3: /* CIL Label */ 
#line 256
    if (debug) {
      {
#line 256
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Option %s: ",
              opts[3]);
      }
    }
    {
#line 259
    converter = new_converter();
#line 261
    s = get_string(f);
#line 261
    tmp___5 = strlen((char const   *)s);
    }
#line 261
    if (tmp___5 == 0UL) {
      {
#line 262
      err_quit("%s:%d: Option requires three arguments -- %s\n", conffile, line, opts[3]);
      }
    }
    {
#line 265
    converter->ext_from = s;
#line 267
    s = get_string(f);
#line 267
    tmp___6 = strlen((char const   *)s);
    }
#line 267
    if (tmp___6 == 0UL) {
      {
#line 268
      err_quit("%s:%d: Option requires three arguments -- %s\n", conffile, line, opts[3]);
      }
    }
    {
#line 271
    converter->ext_to = s;
#line 273
    s = get_string(f);
#line 273
    tmp___7 = strlen((char const   *)s);
    }
#line 273
    if (tmp___7 == 0UL) {
      {
#line 274
      err_quit("%s:%d: Option requires three arguments -- %s\n", conffile, line, opts[3]);
      }
    }
    {
#line 277
    converter->command = s;
#line 279
    add_converter(converter);
    }
#line 281
    if (debug) {
      {
#line 281
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\"%s\" \"%s\" \"%s\"\n",
              converter->ext_from, converter->ext_to, converter->command);
      }
    }
#line 285
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 287
    err_quit("%s:%d: Unknown option", conffile, line);
    }
#line 288
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 290
    err_quit("You found a bug. This get_opt return value cannot be handled.");
    }
    switch_break: /* CIL Label */ ;
    }
    {
#line 293
    option = get_opt(f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 296
  if (debug) {
    {
#line 296
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Done parsing config file\n");
    }
  }
#line 298
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/conf.c"
void config(void) 
{ 
  char *conf ;
  struct stat statbuf ;
  char *tmp ;
  char *tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *tmp___4 ;
  int *tmp___5 ;
  int tmp___6 ;

  {
#line 304
  conf = (char *)((void *)0);
#line 308
  if ((int )*(conffile + 0) == 126) {
    {
#line 309
    tmp = getenv("HOME");
    }
#line 309
    if ((unsigned long )tmp == (unsigned long )((void *)0)) {
      {
#line 310
      err_quit("HOME not defined");
      }
    }
    {
#line 311
    tmp___0 = getenv("HOME");
#line 311
    tmp___1 = strlen((char const   *)tmp___0);
#line 311
    tmp___2 = strlen((char const   *)conffile);
#line 311
    tmp___3 = malloc(tmp___1 + tmp___2);
#line 311
    conf = (char *)tmp___3;
    }
#line 311
    if ((unsigned long )conf == (unsigned long )((void *)0)) {
      {
#line 313
      err_quit("Memory allocation error");
      }
    }
    {
#line 314
    tmp___4 = getenv("HOME");
#line 314
    strcpy((char */* __restrict  */)conf, (char const   */* __restrict  */)tmp___4);
#line 315
    strcat((char */* __restrict  */)conf, (char const   */* __restrict  */)(conffile + 1));
    }
  } else {
#line 317
    conf = conffile;
  }
#line 320
  if (debug) {
    {
#line 320
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Parsing config file %s\n",
            conf);
    }
  }
  {
#line 322
  tmp___6 = stat((char const   */* __restrict  */)conf, (struct stat */* __restrict  */)(& statbuf));
  }
#line 322
  if (tmp___6 != -1) {
    {
#line 323
    parse_file((char const   *)conf);
    }
  } else {
    {
#line 325
    tmp___5 = __errno_location();
    }
#line 325
    if (*tmp___5 != 2) {
      {
#line 326
      err_sys("Error stat\'ing %s", conffile);
      }
    } else
#line 327
    if (debug) {
      {
#line 327
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No config file\n");
      }
    }
  }
#line 328
  return;
}
}
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 169
extern struct _IO_FILE *stdout ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 74 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.h"
struct cuesheet *read_cue(char const   *cuefile ) ;
#line 75
void write_toc(char const   *tocfile , struct cuesheet *cs ) ;
#line 23 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/timecode.h"
long tc2fr(char const   *tc ) ;
#line 24
int fr2tc(char *tc , long fr ) ;
#line 25 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/error.h"
char const   *prog ;
#line 44 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static char const   token_delimiter[4]  = {      (char const   )' ',      (char const   )'\t',      (char const   )'\n',      (char const   )'\r'};
#line 47 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static int isdelim(int c ) 
{ 
  int i ;
  int n ;

  {
#line 51
  n = (int )sizeof(token_delimiter);
#line 53
  i = 0;
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
#line 53
    if (! (i < n)) {
#line 53
      goto while_break;
    }
#line 54
    if (c == (int )token_delimiter[i]) {
#line 55
      return (1);
    }
#line 53
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 56
  return (0);
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
char cmds[24][11]  = 
#line 66
  { {        (char )'R',        (char )'E',        (char )'M',        (char )'\000'}, 
   {        (char )'C',        (char )'A',        (char )'T',        (char )'A', 
            (char )'L',        (char )'O',        (char )'G',        (char )'\000'}, 
   {        (char )'C',        (char )'D',        (char )'T',        (char )'E', 
            (char )'X',        (char )'T',        (char )'F',        (char )'I', 
            (char )'L',        (char )'E',        (char )'\000'}, 
   {        (char )'F',        (char )'I',        (char )'L',        (char )'E', 
            (char )'\000'}, 
   {        (char )'P',        (char )'E',        (char )'R',        (char )'F', 
            (char )'O',        (char )'R',        (char )'M',        (char )'E', 
            (char )'R',        (char )'\000'}, 
   {        (char )'S',        (char )'O',        (char )'N',        (char )'G', 
            (char )'W',        (char )'R',        (char )'I',        (char )'T', 
            (char )'E',        (char )'R',        (char )'\000'}, 
   {        (char )'T',        (char )'I',        (char )'T',        (char )'L', 
            (char )'E',        (char )'\000'}, 
   {        (char )'T',        (char )'R',        (char )'A',        (char )'C', 
            (char )'K',        (char )'\000'}, 
   {        (char )'F',        (char )'L',        (char )'A',        (char )'G', 
            (char )'S',        (char )'\000'}, 
   {        (char )'D',        (char )'C',        (char )'P',        (char )'\000'}, 
   {        (char )'4',        (char )'C',        (char )'H',        (char )'\000'}, 
   {        (char )'P',        (char )'R',        (char )'E',        (char )'\000'}, 
   {        (char )'S',        (char )'C',        (char )'M',        (char )'S', 
            (char )'\000'}, 
   {        (char )'I',        (char )'S',        (char )'R',        (char )'C', 
            (char )'\000'}, 
   {        (char )'P',        (char )'R',        (char )'E',        (char )'G', 
            (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'I',        (char )'N',        (char )'D',        (char )'E', 
            (char )'X',        (char )'\000'}, 
   {        (char )'P',        (char )'O',        (char )'S',        (char )'T', 
            (char )'G',        (char )'A',        (char )'P',        (char )'\000'}, 
   {        (char )'B',        (char )'I',        (char )'N',        (char )'A', 
            (char )'R',        (char )'Y',        (char )'\000'}, 
   {        (char )'M',        (char )'O',        (char )'T',        (char )'O', 
            (char )'R',        (char )'O',        (char )'L',        (char )'A', 
            (char )'\000'}, 
   {        (char )'A',        (char )'I',        (char )'F',        (char )'F', 
            (char )'\000'}, 
   {        (char )'W',        (char )'A',        (char )'V',        (char )'E', 
            (char )'\000'}, 
   {        (char )'M',        (char )'P',        (char )'3',        (char )'\000'}, 
   {        (char )'U',        (char )'N',        (char )'K',        (char )'N', 
            (char )'O',        (char )'W',        (char )'N',        (char )'\000'}, 
   {        (char )'E',        (char )'N',        (char )'D',        (char )'\000'}};
#line 72 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static char const   *fname  =    "stdin";
#line 73 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static long line___0  ;
#line 74 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static long tokenstart  ;
#line 80 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static void err_cue(char const   *s ) 
{ 


  {
  {
#line 83
  err_quit("%s:%ld: %s", fname, tokenstart, s);
  }
#line 84
  return;
}
}
#line 87 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static void err_earlyend(void) 
{ 


  {
  {
#line 90
  err_quit("%s:%ld: Premature end of file", fname, line___0);
  }
#line 91
  return;
}
}
#line 94 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static void err_warn(char const   *s ) 
{ 


  {
#line 97
  if (quiet) {
#line 98
    return;
  }
  {
#line 99
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%s:%ld: Warning, %s\n",
          prog, fname, tokenstart, s);
  }
#line 101
  return;
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static enum command get_command(FILE *f ) 
{ 
  int c ;
  char buf[11] ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;

  {
#line 109
  i = 0;
  {
#line 112
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 113
    c = _IO_getc(f);
    }
#line 114
    if (c == 10) {
#line 115
      line___0 ++;
    }
    {
#line 112
    tmp = isdelim(c);
    }
#line 112
    if (! tmp) {
#line 112
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 118
  if (c == -1) {
#line 119
    return ((enum command )23);
  }
#line 121
  tokenstart = line___0;
  {
#line 124
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 125
    tmp___0 = i;
#line 125
    i ++;
#line 125
    tmp___1 = toupper(c);
#line 125
    buf[tmp___0] = (char )tmp___1;
#line 126
    c = _IO_getc(f);
#line 124
    tmp___2 = isdelim(c);
    }
#line 124
    if (tmp___2) {
#line 124
      goto while_break___0;
    } else
#line 124
    if (c != -1) {
#line 124
      if (! (i < 10)) {
#line 124
        goto while_break___0;
      }
    } else {
#line 124
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 129
  tmp___3 = isdelim(c);
  }
#line 129
  if (! tmp___3) {
#line 129
    return ((enum command )22);
  }
#line 130
  if (c == -1) {
#line 130
    return ((enum command )23);
  }
#line 131
  if (c == 10) {
#line 131
    line___0 ++;
  }
  {
#line 133
  buf[i] = (char )'\000';
#line 135
  tmp___25 = strcmp((char const   *)(buf), (char const   *)(cmds[0]));
  }
#line 135
  if (tmp___25 == 0) {
#line 135
    return ((enum command )0);
  } else {
    {
#line 136
    tmp___24 = strcmp((char const   *)(buf), (char const   *)(cmds[1]));
    }
#line 136
    if (tmp___24 == 0) {
#line 136
      return ((enum command )1);
    } else {
      {
#line 137
      tmp___23 = strcmp((char const   *)(buf), (char const   *)(cmds[2]));
      }
#line 137
      if (tmp___23 == 0) {
#line 137
        return ((enum command )2);
      } else {
        {
#line 138
        tmp___22 = strcmp((char const   *)(buf), (char const   *)(cmds[3]));
        }
#line 138
        if (tmp___22 == 0) {
#line 138
          return ((enum command )3);
        } else {
          {
#line 139
          tmp___21 = strcmp((char const   *)(buf), (char const   *)(cmds[4]));
          }
#line 139
          if (tmp___21 == 0) {
#line 139
            return ((enum command )4);
          } else {
            {
#line 140
            tmp___20 = strcmp((char const   *)(buf), (char const   *)(cmds[5]));
            }
#line 140
            if (tmp___20 == 0) {
#line 140
              return ((enum command )5);
            } else {
              {
#line 141
              tmp___19 = strcmp((char const   *)(buf), (char const   *)(cmds[6]));
              }
#line 141
              if (tmp___19 == 0) {
#line 141
                return ((enum command )6);
              } else {
                {
#line 142
                tmp___18 = strcmp((char const   *)(buf), (char const   *)(cmds[7]));
                }
#line 142
                if (tmp___18 == 0) {
#line 142
                  return ((enum command )7);
                } else {
                  {
#line 143
                  tmp___17 = strcmp((char const   *)(buf), (char const   *)(cmds[8]));
                  }
#line 143
                  if (tmp___17 == 0) {
#line 143
                    return ((enum command )8);
                  } else {
                    {
#line 144
                    tmp___16 = strcmp((char const   *)(buf), (char const   *)(cmds[9]));
                    }
#line 144
                    if (tmp___16 == 0) {
#line 144
                      return ((enum command )9);
                    } else {
                      {
#line 145
                      tmp___15 = strcmp((char const   *)(buf), (char const   *)(cmds[10]));
                      }
#line 145
                      if (tmp___15 == 0) {
#line 145
                        return ((enum command )10);
                      } else {
                        {
#line 146
                        tmp___14 = strcmp((char const   *)(buf), (char const   *)(cmds[11]));
                        }
#line 146
                        if (tmp___14 == 0) {
#line 146
                          return ((enum command )11);
                        } else {
                          {
#line 147
                          tmp___13 = strcmp((char const   *)(buf), (char const   *)(cmds[12]));
                          }
#line 147
                          if (tmp___13 == 0) {
#line 147
                            return ((enum command )12);
                          } else {
                            {
#line 148
                            tmp___12 = strcmp((char const   *)(buf), (char const   *)(cmds[13]));
                            }
#line 148
                            if (tmp___12 == 0) {
#line 148
                              return ((enum command )13);
                            } else {
                              {
#line 149
                              tmp___11 = strcmp((char const   *)(buf), (char const   *)(cmds[14]));
                              }
#line 149
                              if (tmp___11 == 0) {
#line 149
                                return ((enum command )14);
                              } else {
                                {
#line 150
                                tmp___10 = strcmp((char const   *)(buf), (char const   *)(cmds[15]));
                                }
#line 150
                                if (tmp___10 == 0) {
#line 150
                                  return ((enum command )15);
                                } else {
                                  {
#line 151
                                  tmp___9 = strcmp((char const   *)(buf), (char const   *)(cmds[16]));
                                  }
#line 151
                                  if (tmp___9 == 0) {
#line 151
                                    return ((enum command )16);
                                  } else {
                                    {
#line 152
                                    tmp___8 = strcmp((char const   *)(buf), (char const   *)(cmds[17]));
                                    }
#line 152
                                    if (tmp___8 == 0) {
#line 152
                                      return ((enum command )17);
                                    } else {
                                      {
#line 153
                                      tmp___7 = strcmp((char const   *)(buf), (char const   *)(cmds[18]));
                                      }
#line 153
                                      if (tmp___7 == 0) {
#line 153
                                        return ((enum command )18);
                                      } else {
                                        {
#line 154
                                        tmp___6 = strcmp((char const   *)(buf), (char const   *)(cmds[19]));
                                        }
#line 154
                                        if (tmp___6 == 0) {
#line 154
                                          return ((enum command )19);
                                        } else {
                                          {
#line 155
                                          tmp___5 = strcmp((char const   *)(buf),
                                                           (char const   *)(cmds[20]));
                                          }
#line 155
                                          if (tmp___5 == 0) {
#line 155
                                            return ((enum command )20);
                                          } else {
                                            {
#line 156
                                            tmp___4 = strcmp((char const   *)(buf),
                                                             (char const   *)(cmds[21]));
                                            }
#line 156
                                            if (tmp___4 == 0) {
#line 156
                                              return ((enum command )21);
                                            } else {
#line 157
                                              return ((enum command )22);
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
}
#line 165 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static size_t get_string___0(FILE *f , char *s , size_t n ) 
{ 
  int c ;
  size_t i ;
  int tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 169
  i = (size_t )0;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 173
    c = _IO_getc(f);
    }
#line 174
    if (c == 10) {
#line 175
      line___0 ++;
    }
    {
#line 172
    tmp = isdelim(c);
    }
#line 172
    if (! tmp) {
#line 172
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 178
  if (c == -1) {
#line 179
    return ((size_t )0);
  }
#line 181
  tokenstart = line___0;
#line 183
  if (c == 34) {
    {
#line 184
    c = _IO_getc(f);
    }
#line 185
    if (c == 10) {
#line 185
      line___0 ++;
    }
    {
#line 186
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 186
      if (c != 34) {
#line 186
        if (c != -1) {
#line 186
          if (! (i < n)) {
#line 186
            goto while_break___0;
          }
        } else {
#line 186
          goto while_break___0;
        }
      } else {
#line 186
        goto while_break___0;
      }
      {
#line 187
      tmp___0 = i;
#line 187
      i ++;
#line 187
      *(s + tmp___0) = (char )c;
#line 188
      c = _IO_getc(f);
      }
#line 189
      if (c == 10) {
#line 189
        line___0 ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 191
    if (i == n) {
#line 191
      if (c != 34) {
#line 191
        if (c != -1) {
          {
#line 192
          err_cue("String too long");
          }
        }
      }
    }
  } else {
    {
#line 194
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 194
      tmp___2 = isdelim(c);
      }
#line 194
      if (tmp___2) {
#line 194
        goto while_break___1;
      } else
#line 194
      if (c != -1) {
#line 194
        if (! (i < n)) {
#line 194
          goto while_break___1;
        }
      } else {
#line 194
        goto while_break___1;
      }
      {
#line 195
      tmp___1 = i;
#line 195
      i ++;
#line 195
      *(s + tmp___1) = (char )c;
#line 196
      c = _IO_getc(f);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 198
    if (i == n) {
      {
#line 198
      tmp___3 = isdelim(c);
      }
#line 198
      if (! tmp___3) {
#line 198
        if (c != -1) {
          {
#line 199
          err_cue("String too long");
          }
        }
      }
    }
  }
#line 201
  if (i == 0UL) {
    {
#line 201
    err_cue("Empty string");
    }
  }
#line 202
  if (c == 10) {
#line 202
    line___0 ++;
  }
#line 203
  *(s + i) = (char )'\000';
#line 205
  return (i);
}
}
#line 209 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static enum track_mode get_track_mode(FILE *f ) 
{ 
  char buf[11] ;
  char *pbuf ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 212
  buf[0] = (char )'M';
#line 212
  buf[1] = (char )'O';
#line 212
  buf[2] = (char )'D';
#line 212
  buf[3] = (char )'E';
#line 212
  buf[4] = (char )'1';
#line 212
  buf[5] = (char )'/';
#line 212
  buf[6] = (char )'2';
#line 212
  buf[7] = (char )'0';
#line 212
  buf[8] = (char )'4';
#line 212
  buf[9] = (char )'8';
#line 212
  buf[10] = (char )'\000';
#line 213
  pbuf = buf;
#line 215
  tmp = get_string___0(f, buf, sizeof(buf) - 1UL);
  }
#line 215
  if (tmp < 1UL) {
    {
#line 216
    err_cue("Illegal track mode");
    }
  }
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! *pbuf) {
#line 219
      goto while_break;
    }
    {
#line 220
    tmp___0 = toupper((int )*pbuf);
#line 220
    *pbuf = (char )tmp___0;
#line 221
    pbuf ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 224
  tmp___5 = strcmp((char const   *)(buf), "AUDIO");
  }
#line 224
  if (tmp___5 == 0) {
#line 224
    return ((enum track_mode )1);
  } else {
    {
#line 225
    tmp___4 = strcmp((char const   *)(buf), "MODE1/2048");
    }
#line 225
    if (tmp___4 == 0) {
#line 225
      return ((enum track_mode )2);
    } else {
      {
#line 226
      tmp___3 = strcmp((char const   *)(buf), "MODE1/2352");
      }
#line 226
      if (tmp___3 == 0) {
#line 226
        return ((enum track_mode )3);
      } else {
        {
#line 227
        tmp___2 = strcmp((char const   *)(buf), "MODE2/2336");
        }
#line 227
        if (tmp___2 == 0) {
#line 227
          return ((enum track_mode )4);
        } else {
          {
#line 228
          tmp___1 = strcmp((char const   *)(buf), "MODE2/2352");
          }
#line 228
          if (tmp___1 == 0) {
#line 228
            return ((enum track_mode )5);
          } else {
            {
#line 229
            err_cue("Unsupported track mode");
            }
          }
        }
      }
    }
  }
#line 231
  return ((enum track_mode )0);
}
}
#line 234
static void check_once(enum command cmd , char *s , enum scope sc ) ;
#line 237 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static void get_cdtext(FILE *f , enum command cmd , char *s , enum scope sc ) 
{ 
  size_t tmp ;

  {
  {
#line 240
  check_once(cmd, s, sc);
#line 241
  tmp = get_string___0(f, s, (size_t )80);
  }
#line 241
  if (tmp < 1UL) {
    {
#line 242
    err_earlyend();
    }
  }
#line 243
  return;
}
}
#line 249 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static void check_once(enum command cmd , char *s , enum scope sc ) 
{ 


  {
#line 252
  if ((int )*(s + 0) == 0) {
#line 253
    return;
  }
  {
#line 254
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s:%s:%ld: %s allowed only once",
          prog, fname, line___0, cmds[cmd]);
  }
  {
#line 257
  if ((unsigned int )sc == 0U) {
#line 257
    goto case_0;
  }
#line 258
  if ((unsigned int )sc == 1U) {
#line 258
    goto case_1;
  }
#line 259
  if ((unsigned int )sc == 2U) {
#line 259
    goto case_2;
  }
#line 256
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 257
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
  }
#line 257
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 258
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" in global section\n");
  }
#line 258
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 259
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" per track\n");
  }
#line 259
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 261
  exit(1);
  }
}
}
#line 267 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static void check_cutting_binary(struct trackspec *tr ) 
{ 


  {
#line 270
  if ((unsigned int )tr->mode == 1U) {
#line 271
    return;
  }
#line 272
  if (tr->pregap_data_from_file) {
#line 273
    if (tr->pregap < tr->start) {
      {
#line 274
      err_cue("TOC format does not allow cutting binary files. Try burning CUE file directly.\n");
      }
    }
  } else
#line 277
  if (tr->start > 0L) {
    {
#line 278
    err_cue("TOC format does not allow cutting binary files. Try burning CUE file directly.\n");
    }
  }
#line 280
  return;
}
}
#line 283 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static struct trackspec *new_track(void) 
{ 
  struct trackspec *track ;
  int i ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  char tmp___3 ;
  char tmp___4 ;
  char tmp___5 ;
  char tmp___6 ;
  long tmp___7 ;
  long tmp___8 ;

  {
  {
#line 289
  tmp = malloc(sizeof(struct trackspec ));
#line 289
  track = (struct trackspec *)tmp;
  }
#line 289
  if ((unsigned long )track == (unsigned long )((void *)0)) {
    {
#line 291
    err_cue("Memory allocation error in new_track()");
    }
  }
#line 293
  tmp___2 = 0;
#line 293
  track->pregap_data_from_file = tmp___2;
#line 293
  tmp___1 = tmp___2;
#line 293
  track->four_channel_audio = tmp___1;
#line 293
  tmp___0 = tmp___1;
#line 293
  track->pre_emphasis = tmp___0;
#line 293
  track->copy = tmp___0;
#line 295
  tmp___6 = (char )'\000';
#line 295
  track->filename[0] = tmp___6;
#line 295
  tmp___5 = tmp___6;
#line 295
  track->songwriter[0] = tmp___5;
#line 295
  tmp___4 = tmp___5;
#line 295
  track->performer[0] = tmp___4;
#line 295
  tmp___3 = tmp___4;
#line 295
  track->title[0] = tmp___3;
#line 295
  track->isrc[0] = tmp___3;
#line 297
  tmp___8 = -1L;
#line 297
  track->postgap = tmp___8;
#line 297
  tmp___7 = tmp___8;
#line 297
  track->start = tmp___7;
#line 297
  track->pregap = tmp___7;
#line 299
  i = 0;
  {
#line 299
  while (1) {
    while_continue: /* CIL Label */ ;
#line 299
    if (! (i < 98)) {
#line 299
      goto while_break;
    }
#line 300
    track->indexes[i] = -1L;
#line 299
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 301
  track->next = (struct trackspec *)((void *)0);
#line 303
  return (track);
}
}
#line 307 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
struct cuesheet *read_cue(char const   *cuefile ) 
{ 
  FILE *f ;
  enum command cmd ;
  struct cuesheet *cs ;
  struct trackspec *track ;
  size_t n ;
  int c ;
  char file[1025] ;
  enum command filetype ;
  char timecode_buffer[9] ;
  char devnull[1025] ;
  void *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  struct trackspec *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  size_t tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  int tmp___9 ;
  size_t tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;

  {
#line 312
  cs = (struct cuesheet *)((void *)0);
#line 313
  track = (struct trackspec *)((void *)0);
#line 317
  filetype = (enum command )22;
#line 321
  if ((unsigned long )((void *)0) == (unsigned long )cuefile) {
#line 322
    f = stdin;
  } else {
    {
#line 323
    f = fopen((char const   */* __restrict  */)cuefile, (char const   */* __restrict  */)"r");
    }
#line 323
    if ((unsigned long )((void *)0) == (unsigned long )f) {
      {
#line 324
      err_sys("Could not open file \"%s\" for reading", cuefile);
      }
    }
  }
#line 326
  if (cuefile) {
#line 327
    fname = cuefile;
  }
  {
#line 329
  tmp = malloc(sizeof(struct cuesheet ));
#line 329
  cs = (struct cuesheet *)tmp;
  }
#line 329
  if ((unsigned long )cs == (unsigned long )((void *)0)) {
    {
#line 330
    err_cue("Memory allocation error in read_cue()");
    }
  }
#line 332
  cs->catalog[0] = (char )'\000';
#line 333
  cs->type = (enum session_type )0;
#line 334
  cs->title[0] = (char )'\000';
#line 335
  cs->performer[0] = (char )'\000';
#line 336
  cs->songwriter[0] = (char )'\000';
#line 337
  cs->tracklist = (struct trackspec *)((void *)0);
#line 339
  file[0] = (char )'\000';
#line 340
  line___0 = 1L;
  {
#line 343
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 343
    cmd = get_command(f);
    }
#line 343
    if (! ((unsigned int )cmd != 7U)) {
#line 343
      goto while_break;
    }
    {
#line 345
    if ((unsigned int )cmd == 22U) {
#line 345
      goto case_22;
    }
#line 347
    if ((unsigned int )cmd == 23U) {
#line 347
      goto case_23;
    }
#line 349
    if ((unsigned int )cmd == 0U) {
#line 349
      goto case_0;
    }
#line 354
    if ((unsigned int )cmd == 2U) {
#line 354
      goto case_2;
    }
#line 361
    if ((unsigned int )cmd == 1U) {
#line 361
      goto case_1;
    }
#line 368
    if ((unsigned int )cmd == 6U) {
#line 368
      goto case_6;
    }
#line 371
    if ((unsigned int )cmd == 4U) {
#line 371
      goto case_4;
    }
#line 374
    if ((unsigned int )cmd == 5U) {
#line 374
      goto case_5;
    }
#line 377
    if ((unsigned int )cmd == 3U) {
#line 377
      goto case_3;
    }
#line 396
    goto switch_default___0;
    case_22: /* CIL Label */ 
    {
#line 346
    err_cue("Unknown command");
    }
    case_23: /* CIL Label */ 
    {
#line 348
    err_earlyend();
    }
    case_0: /* CIL Label */ 
    {
#line 350
    c = _IO_getc(f);
    }
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 351
      if (c != 10) {
#line 351
        if (! (c != -1)) {
#line 351
          goto while_break___0;
        }
      } else {
#line 351
        goto while_break___0;
      }
      {
#line 352
      c = _IO_getc(f);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 353
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 355
    err_warn("Ignoring CDTEXTFILE");
#line 356
    tmp___0 = get_string___0(f, devnull, (size_t )1024);
    }
#line 356
    if (tmp___0 == 0UL) {
      {
#line 357
      err_warn("Syntactically incorrect CDTEXTFILE command. But who cares...");
      }
    }
#line 360
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 362
    check_once((enum command )1, cs->catalog, (enum scope )0);
#line 363
    n = get_string___0(f, cs->catalog, (size_t )13);
    }
#line 364
    if (n != 13UL) {
      {
#line 365
      err_cue("Catalog number must be 13 characters long");
      }
    }
#line 367
    goto switch_break;
    case_6: /* CIL Label */ 
    {
#line 369
    get_cdtext(f, (enum command )6, cs->title, (enum scope )1);
    }
#line 370
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 372
    get_cdtext(f, (enum command )4, cs->performer, (enum scope )1);
    }
#line 373
    goto switch_break;
    case_5: /* CIL Label */ 
    {
#line 375
    get_cdtext(f, (enum command )5, cs->songwriter, (enum scope )1);
    }
#line 376
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 378
    check_once((enum command )3, file, (enum scope )1);
#line 379
    tmp___1 = get_string___0(f, file, (size_t )1024);
    }
#line 379
    if (tmp___1 < 1UL) {
      {
#line 380
      err_earlyend();
      }
    }
    {
#line 382
    cmd = get_command(f);
    }
    {
#line 383
    if ((unsigned int )cmd == 18U) {
#line 383
      goto case_18;
    }
#line 385
    if ((unsigned int )cmd == 17U) {
#line 385
      goto case_17;
    }
#line 387
    if ((unsigned int )cmd == 19U) {
#line 387
      goto case_19;
    }
#line 390
    if ((unsigned int )cmd == 20U) {
#line 390
      goto case_20;
    }
#line 390
    if ((unsigned int )cmd == 21U) {
#line 390
      goto case_20;
    }
#line 392
    goto switch_default;
    case_18: /* CIL Label */ 
    {
#line 384
    err_warn("Big endian binary file");
    }
    case_17: /* CIL Label */ 
#line 386
    filetype = (enum command )17;
#line 386
    goto switch_break___0;
    case_19: /* CIL Label */ 
    {
#line 388
    err_warn("AIFF not supported by cdrdao");
    }
    case_20: /* CIL Label */ 
    case_21: /* CIL Label */ 
#line 391
    filetype = (enum command )20;
#line 391
    goto switch_break___0;
    switch_default: /* CIL Label */ 
    {
#line 393
    err_cue("Unsupported file type");
    }
    switch_break___0: /* CIL Label */ ;
    }
#line 395
    goto switch_break;
    switch_default___0: /* CIL Label */ 
    {
#line 397
    err_cue("Command not allowed in global section");
    }
#line 398
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  if ((int )file[0] == 0) {
    {
#line 405
    err_cue("TRACK without previous FILE");
    }
  }
  {
#line 407
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 407
    if (! ((unsigned int )cmd != 23U)) {
#line 407
      goto while_break___1;
    }
    {
#line 409
    if ((unsigned int )cmd == 22U) {
#line 409
      goto case_22___0;
    }
#line 411
    if ((unsigned int )cmd == 0U) {
#line 411
      goto case_0___0;
    }
#line 416
    if ((unsigned int )cmd == 7U) {
#line 416
      goto case_7;
    }
#line 442
    if ((unsigned int )cmd == 6U) {
#line 442
      goto case_6___0;
    }
#line 445
    if ((unsigned int )cmd == 4U) {
#line 445
      goto case_4___0;
    }
#line 448
    if ((unsigned int )cmd == 5U) {
#line 448
      goto case_5___0;
    }
#line 451
    if ((unsigned int )cmd == 13U) {
#line 451
      goto case_13;
    }
#line 456
    if ((unsigned int )cmd == 8U) {
#line 456
      goto case_8;
    }
#line 484
    if ((unsigned int )cmd == 14U) {
#line 484
      goto case_14;
    }
#line 494
    if ((unsigned int )cmd == 16U) {
#line 494
      goto case_16;
    }
#line 503
    if ((unsigned int )cmd == 15U) {
#line 503
      goto case_15;
    }
#line 575
    if ((unsigned int )cmd == 3U) {
#line 575
      goto case_3___0;
    }
#line 593
    goto switch_default___4;
    case_22___0: /* CIL Label */ 
    {
#line 410
    err_cue("Unknown command");
    }
    case_0___0: /* CIL Label */ 
    {
#line 412
    c = _IO_getc(f);
    }
    {
#line 413
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 413
      if (c != 10) {
#line 413
        if (! (c != -1)) {
#line 413
          goto while_break___2;
        }
      } else {
#line 413
        goto while_break___2;
      }
      {
#line 414
      c = _IO_getc(f);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
#line 415
    goto switch_break___1;
    case_7: /* CIL Label */ 
#line 417
    if ((unsigned long )track == (unsigned long )((void *)0)) {
      {
#line 418
      track = new_track();
#line 418
      cs->tracklist = track;
      }
    } else {
      {
#line 420
      check_cutting_binary(track);
#line 421
      tmp___2 = new_track();
#line 421
      track->next = tmp___2;
#line 421
      track = tmp___2;
      }
    }
    {
#line 426
    while (1) {
      while_continue___3: /* CIL Label */ ;
      {
#line 426
      c = _IO_getc(f);
#line 426
      tmp___3 = isdelim(c);
      }
#line 426
      if (! tmp___3) {
#line 426
        goto while_break___3;
      }
#line 427
      if (c == 10) {
#line 427
        line___0 ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 428
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 428
      c = _IO_getc(f);
#line 428
      tmp___4 = isdelim(c);
      }
#line 428
      if (tmp___4) {
#line 428
        goto while_break___4;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
#line 429
    if (c == 10) {
#line 429
      line___0 ++;
    }
    {
#line 431
    track->mode = get_track_mode(f);
#line 440
    strcpy((char */* __restrict  */)(track->filename), (char const   */* __restrict  */)(file));
    }
#line 441
    goto switch_break___1;
    case_6___0: /* CIL Label */ 
    {
#line 443
    get_cdtext(f, (enum command )6, track->title, (enum scope )2);
    }
#line 444
    goto switch_break___1;
    case_4___0: /* CIL Label */ 
    {
#line 446
    get_cdtext(f, (enum command )4, track->performer, (enum scope )2);
    }
#line 447
    goto switch_break___1;
    case_5___0: /* CIL Label */ 
    {
#line 449
    get_cdtext(f, (enum command )5, track->songwriter, (enum scope )2);
    }
#line 450
    goto switch_break___1;
    case_13: /* CIL Label */ 
    {
#line 452
    check_once((enum command )13, track->isrc, (enum scope )2);
#line 453
    tmp___5 = get_string___0(f, track->isrc, (size_t )12);
    }
#line 453
    if (tmp___5 != 12UL) {
      {
#line 454
      err_cue("ISRC must be 12 characters long");
      }
    }
#line 455
    goto switch_break___1;
    case_8: /* CIL Label */ 
#line 457
    if (track->copy) {
      {
#line 459
      err_cue("FLAGS allowed only once per track");
      }
    } else
#line 457
    if (track->pre_emphasis) {
      {
#line 459
      err_cue("FLAGS allowed only once per track");
      }
    } else
#line 457
    if (track->four_channel_audio) {
      {
#line 459
      err_cue("FLAGS allowed only once per track");
      }
    }
    {
#line 462
    cmd = get_command(f);
    }
    {
#line 463
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 463
      if (! ((unsigned int )cmd == 9U)) {
#line 463
        if (! ((unsigned int )cmd == 10U)) {
#line 463
          if (! ((unsigned int )cmd == 11U)) {
#line 463
            if (! ((unsigned int )cmd == 12U)) {
#line 463
              goto while_break___5;
            }
          }
        }
      }
      {
#line 466
      if ((unsigned int )cmd == 9U) {
#line 466
        goto case_9;
      }
#line 468
      if ((unsigned int )cmd == 10U) {
#line 468
        goto case_10;
      }
#line 470
      if ((unsigned int )cmd == 11U) {
#line 470
        goto case_11;
      }
#line 472
      if ((unsigned int )cmd == 12U) {
#line 472
        goto case_12;
      }
#line 476
      goto switch_default___1;
      case_9: /* CIL Label */ 
#line 467
      track->copy = 1;
#line 467
      goto switch_break___2;
      case_10: /* CIL Label */ 
#line 469
      track->four_channel_audio = 1;
#line 469
      goto switch_break___2;
      case_11: /* CIL Label */ 
#line 471
      track->pre_emphasis = 1;
#line 471
      goto switch_break___2;
      case_12: /* CIL Label */ 
      {
#line 473
      err_warn("Serial Copy Management System flag not supported by cdrdao");
      }
#line 475
      goto switch_break___2;
      switch_default___1: /* CIL Label */ 
      {
#line 477
      err_cue("Should not get here");
      }
      switch_break___2: /* CIL Label */ ;
      }
      {
#line 479
      cmd = get_command(f);
      }
    }
    while_break___5: /* CIL Label */ ;
    }
#line 483
    goto while_continue___1;
#line 483
    goto switch_break___1;
    case_14: /* CIL Label */ 
#line 485
    if (track->pregap != -1L) {
      {
#line 486
      err_cue("PREGAP allowed only once per track");
      }
    }
    {
#line 487
    tmp___6 = get_string___0(f, timecode_buffer, (size_t )8);
    }
#line 487
    if (tmp___6 < 1UL) {
      {
#line 488
      err_earlyend();
      }
    }
    {
#line 489
    track->pregap = tc2fr((char const   *)(timecode_buffer));
    }
#line 490
    if (track->pregap == -1L) {
      {
#line 491
      err_cue("Timecode out of range");
      }
    }
#line 492
    track->pregap_data_from_file = 0;
#line 493
    goto switch_break___1;
    case_16: /* CIL Label */ 
#line 495
    if (track->postgap != -1L) {
      {
#line 496
      err_cue("POSTGAP allowed only once per track");
      }
    }
    {
#line 497
    tmp___7 = get_string___0(f, timecode_buffer, (size_t )8);
    }
#line 497
    if (tmp___7 < 1UL) {
      {
#line 498
      err_earlyend();
      }
    }
    {
#line 499
    track->postgap = tc2fr((char const   *)(timecode_buffer));
    }
#line 500
    if (track->postgap == -1L) {
      {
#line 501
      err_cue("Timecode out of range");
      }
    }
#line 502
    goto switch_break___1;
    case_15: /* CIL Label */ 
    {
#line 504
    tmp___8 = get_string___0(f, timecode_buffer, (size_t )2);
    }
#line 504
    if (tmp___8 < 1UL) {
      {
#line 505
      err_earlyend();
      }
    }
    {
#line 506
    tmp___9 = atoi((char const   *)(timecode_buffer));
#line 506
    n = (size_t )tmp___9;
    }
#line 507
    if (n < 0UL) {
      {
#line 508
      err_cue("Index out of range");
      }
    } else
#line 507
    if (n > 99UL) {
      {
#line 508
      err_cue("Index out of range");
      }
    }
    {
#line 515
    if (n == 0UL) {
#line 515
      goto case_0___1;
    }
#line 531
    if (n == 1UL) {
#line 531
      goto case_1___0;
    }
#line 546
    if (n == 2UL) {
#line 546
      goto case_2___0;
    }
#line 559
    goto switch_default___2;
    case_0___1: /* CIL Label */ 
#line 516
    if (track->start != -1L) {
      {
#line 517
      err_cue("Indexes must be sequential");
      }
    }
#line 518
    if (track->pregap != -1L) {
      {
#line 519
      err_cue("PREGAP allowed only once per track");
      }
    }
    {
#line 521
    tmp___10 = get_string___0(f, timecode_buffer, (size_t )8);
    }
#line 521
    if (tmp___10 < 1UL) {
      {
#line 523
      err_earlyend();
      }
    }
    {
#line 526
    track->pregap = tc2fr((char const   *)(timecode_buffer));
    }
#line 527
    if (track->pregap == -1L) {
      {
#line 528
      err_cue("Timecode out of range");
      }
    }
#line 529
    track->pregap_data_from_file = 1;
#line 530
    goto switch_break___3;
    case_1___0: /* CIL Label */ 
#line 532
    if (track->start != -1L) {
      {
#line 533
      err_cue("Each index allowed only once per track");
      }
    }
    {
#line 535
    tmp___11 = get_string___0(f, timecode_buffer, (size_t )8);
    }
#line 535
    if (tmp___11 < 1UL) {
      {
#line 537
      err_cue("Missing timecode");
      }
    }
    {
#line 538
    track->start = tc2fr((char const   *)(timecode_buffer));
    }
#line 539
    if (track->start == -1L) {
      {
#line 540
      err_cue("Timecode out of range");
      }
    }
#line 542
    if (track->pregap_data_from_file) {
#line 543
      track->pregap = track->start - track->pregap;
    }
#line 545
    goto switch_break___3;
    case_2___0: /* CIL Label */ 
#line 547
    if (track->start == -1L) {
      {
#line 548
      err_cue("Indexes must be sequential");
      }
    }
#line 549
    if (track->indexes[n - 2UL] != -1L) {
      {
#line 550
      err_cue("Each index allowed only once per track");
      }
    }
    {
#line 552
    tmp___12 = get_string___0(f, timecode_buffer, (size_t )8);
    }
#line 552
    if (tmp___12 < 1UL) {
      {
#line 554
      err_cue("Missing timecode");
      }
    }
    {
#line 555
    track->indexes[n - 2UL] = tc2fr((char const   *)(timecode_buffer));
    }
#line 556
    if (track->indexes[n - 2UL] == -1L) {
      {
#line 557
      err_cue("Timecode out of range");
      }
    }
#line 558
    goto switch_break___3;
    switch_default___2: /* CIL Label */ 
#line 561
    if (track->indexes[n - 3UL] == -1L) {
      {
#line 562
      err_cue("Indexes must be sequential");
      }
    }
#line 563
    if (track->indexes[n - 2UL] != -1L) {
      {
#line 564
      err_cue("Each index allowed only once per track");
      }
    }
    {
#line 566
    tmp___13 = get_string___0(f, timecode_buffer, (size_t )8);
    }
#line 566
    if (tmp___13 < 1UL) {
      {
#line 568
      err_cue("Missing timecode");
      }
    }
    {
#line 569
    track->indexes[n - 2UL] = tc2fr((char const   *)(timecode_buffer));
    }
#line 570
    if (track->indexes[n - 2UL] == -1L) {
      {
#line 571
      err_cue("Timecode out of range");
      }
    }
#line 572
    goto switch_break___3;
    switch_break___3: /* CIL Label */ ;
    }
#line 574
    goto switch_break___1;
    case_3___0: /* CIL Label */ 
    {
#line 576
    tmp___14 = get_string___0(f, file, (size_t )1024);
    }
#line 576
    if (tmp___14 < 1UL) {
      {
#line 577
      err_earlyend();
      }
    }
    {
#line 579
    cmd = get_command(f);
    }
    {
#line 580
    if ((unsigned int )cmd == 18U) {
#line 580
      goto case_18___0;
    }
#line 582
    if ((unsigned int )cmd == 17U) {
#line 582
      goto case_17___0;
    }
#line 584
    if ((unsigned int )cmd == 19U) {
#line 584
      goto case_19___0;
    }
#line 587
    if ((unsigned int )cmd == 20U) {
#line 587
      goto case_20___0;
    }
#line 587
    if ((unsigned int )cmd == 21U) {
#line 587
      goto case_20___0;
    }
#line 589
    goto switch_default___3;
    case_18___0: /* CIL Label */ 
    {
#line 581
    err_warn("Big endian binary file");
    }
    case_17___0: /* CIL Label */ 
#line 583
    filetype = (enum command )17;
#line 583
    goto switch_break___4;
    case_19___0: /* CIL Label */ 
    {
#line 585
    err_warn("AIFF not supported by cdrdao");
    }
    case_20___0: /* CIL Label */ 
    case_21___0: /* CIL Label */ 
#line 588
    filetype = (enum command )20;
#line 588
    goto switch_break___4;
    switch_default___3: /* CIL Label */ 
    {
#line 590
    err_cue("Unsupported file type");
    }
    switch_break___4: /* CIL Label */ ;
    }
#line 592
    goto switch_break___1;
    switch_default___4: /* CIL Label */ 
    {
#line 594
    err_cue("Command not allowed in track spec");
    }
#line 595
    goto switch_break___1;
    switch_break___1: /* CIL Label */ ;
    }
    {
#line 598
    cmd = get_command(f);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 601
  check_cutting_binary(track);
  }
#line 603
  return (cs);
}
}
#line 607 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static enum session_type determine_session_type(struct trackspec *list ) 
{ 
  struct trackspec *track ;
  int audio ;
  int mode1 ;
  int mode2 ;

  {
#line 610
  track = list;
#line 612
  audio = 0;
#line 613
  mode1 = 0;
#line 614
  mode2 = 0;
  {
#line 616
  while (1) {
    while_continue: /* CIL Label */ ;
#line 616
    if (! ((unsigned long )track != (unsigned long )((void *)0))) {
#line 616
      goto while_break;
    }
    {
#line 618
    if ((unsigned int )track->mode == 1U) {
#line 618
      goto case_1;
    }
#line 620
    if ((unsigned int )track->mode == 3U) {
#line 620
      goto case_3;
    }
#line 620
    if ((unsigned int )track->mode == 2U) {
#line 620
      goto case_3;
    }
#line 622
    if ((unsigned int )track->mode == 5U) {
#line 622
      goto case_5;
    }
#line 622
    if ((unsigned int )track->mode == 4U) {
#line 622
      goto case_5;
    }
#line 624
    goto switch_default;
    case_1: /* CIL Label */ 
#line 619
    audio = 1;
#line 619
    goto switch_break;
    case_3: /* CIL Label */ 
    case_2: /* CIL Label */ 
#line 621
    mode1 = 1;
#line 621
    goto switch_break;
    case_5: /* CIL Label */ 
    case_4: /* CIL Label */ 
#line 623
    mode2 = 1;
#line 623
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 625
    err_quit("Dont know how this could happen, but here is a track with an unknown mode :|");
    }
    switch_break: /* CIL Label */ ;
    }
#line 628
    track = track->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 635
  if (audio) {
#line 635
    if (! mode1) {
#line 635
      if (! mode2) {
#line 636
        return ((enum session_type )1);
      } else {
#line 635
        goto _L___6;
      }
    } else {
#line 635
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 637
  if (audio) {
#line 637
    if (mode1) {
#line 637
      if (! mode2) {
#line 638
        return ((enum session_type )2);
      } else {
#line 637
        goto _L___4;
      }
    } else {
#line 637
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 637
  if (! audio) {
#line 637
    if (mode1) {
#line 637
      if (! mode2) {
#line 638
        return ((enum session_type )2);
      } else {
#line 637
        goto _L___2;
      }
    } else {
#line 637
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 639
  if (audio) {
#line 639
    if (! mode1) {
#line 639
      if (mode2) {
#line 640
        return ((enum session_type )3);
      } else {
#line 639
        goto _L___0;
      }
    } else {
#line 639
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 639
  if (! audio) {
#line 639
    if (! mode1) {
#line 639
      if (mode2) {
#line 640
        return ((enum session_type )3);
      } else {
#line 642
        return ((enum session_type )4);
      }
    } else {
#line 642
      return ((enum session_type )4);
    }
  } else {
#line 642
    return ((enum session_type )4);
  }
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static int contains_cdtext(struct cuesheet *cs ) 
{ 
  struct trackspec *track ;

  {
#line 649
  track = cs->tracklist;
#line 651
  if ((int )cs->title[0] != 0) {
#line 653
    return (1);
  } else
#line 651
  if ((int )cs->performer[0] != 0) {
#line 653
    return (1);
  } else
#line 651
  if ((int )cs->songwriter[0] != 0) {
#line 653
    return (1);
  }
  {
#line 655
  while (1) {
    while_continue: /* CIL Label */ ;
#line 655
    if (! track) {
#line 655
      goto while_break;
    }
#line 656
    if ((int )track->title[0] != 0) {
#line 658
      return (1);
    } else
#line 656
    if ((int )track->performer[0] != 0) {
#line 658
      return (1);
    } else
#line 656
    if ((int )track->songwriter[0] != 0) {
#line 658
      return (1);
    }
#line 659
    track = track->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 662
  return (0);
}
}
#line 669 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static int ifprintf(FILE *f , int indent , int level , char const   *format  , ...) 
{ 
  va_list ap ;
  int fprintf_return ;
  int tabs ;
  int spaces ;
  int i ;

  {
#line 673
  fprintf_return = 0;
#line 674
  tabs = (indent * level) / 8;
#line 675
  spaces = (indent * level) % 8;
#line 678
  i = 0;
  {
#line 678
  while (1) {
    while_continue: /* CIL Label */ ;
#line 678
    if (! (i < tabs)) {
#line 678
      goto while_break;
    }
    {
#line 679
    fputc('\t', f);
#line 678
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 680
  i = 0;
  {
#line 680
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 680
    if (! (i < spaces)) {
#line 680
      goto while_break___0;
    }
    {
#line 681
    fputc(' ', f);
#line 680
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 683
  __builtin_va_start(ap, format);
#line 684
  fprintf_return = vfprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)format,
                            ap);
#line 685
  __builtin_va_end(ap);
  }
#line 687
  return (fprintf_return);
}
}
#line 693 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
static void write_track(struct trackspec *tr , FILE *f , int i , int l ) 
{ 
  char timecode_buffer[9] ;
  long start ;
  long len ;
  int j ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;

  {
  {
#line 697
  start = 0L;
#line 697
  len = 0L;
#line 698
  j = 0;
#line 700
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
#line 701
  tmp = l;
#line 701
  l ++;
#line 701
  ifprintf(f, i, tmp, "TRACK ");
  }
  {
#line 703
  if ((unsigned int )tr->mode == 1U) {
#line 703
    goto case_1;
  }
#line 704
  if ((unsigned int )tr->mode == 2U) {
#line 704
    goto case_2;
  }
#line 705
  if ((unsigned int )tr->mode == 3U) {
#line 705
    goto case_3;
  }
#line 706
  if ((unsigned int )tr->mode == 4U) {
#line 706
    goto case_4;
  }
#line 707
  if ((unsigned int )tr->mode == 5U) {
#line 707
    goto case_5;
  }
#line 708
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 703
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"AUDIO\n");
  }
#line 703
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 704
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"MODE1\n");
  }
#line 704
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 705
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"MODE1_RAW\n");
  }
#line 705
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 706
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"MODE2\n");
  }
#line 706
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 707
  fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"MODE2_RAW\n");
  }
#line 707
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 708
  err_quit("Unknown track mode");
  }
  switch_break: /* CIL Label */ ;
  }
#line 712
  if (tr->copy) {
    {
#line 713
    ifprintf(f, i, l, "COPY\n");
    }
  }
#line 714
  if (tr->pre_emphasis) {
    {
#line 715
    ifprintf(f, i, l, "PRE_EMPHASIS\n");
    }
  }
#line 716
  if (tr->four_channel_audio) {
    {
#line 717
    ifprintf(f, i, l, "FOUR_CHANNEL_AUDIO\n");
    }
  }
#line 718
  if ((int )tr->isrc[0] != 0) {
    {
#line 719
    ifprintf(f, i, l, "ISRC \"%s\"\n", tr->isrc);
    }
  }
#line 722
  if (cdtext) {
#line 722
    if ((int )tr->title[0] != 0) {
#line 722
      goto _L;
    } else
#line 722
    if ((int )tr->performer[0] != 0) {
#line 722
      goto _L;
    } else
#line 722
    if ((int )tr->songwriter[0] != 0) {
      _L: /* CIL Label */ 
      {
#line 724
      tmp___0 = l;
#line 724
      l ++;
#line 724
      ifprintf(f, i, tmp___0, "CD_TEXT {\n");
#line 725
      tmp___1 = l;
#line 725
      l ++;
#line 725
      ifprintf(f, i, tmp___1, "LANGUAGE 0 {\n");
      }
#line 726
      if ((int )tr->title[0] != 0) {
        {
#line 727
        ifprintf(f, i, l, "TITLE \"%s\"\n", tr->title);
        }
      }
#line 728
      if ((int )tr->performer[0] != 0) {
        {
#line 729
        ifprintf(f, i, l, "PERFORMER \"%s\"\n", tr->performer);
        }
      }
#line 730
      if ((int )tr->songwriter[0] != 0) {
        {
#line 731
        ifprintf(f, i, l, "SONGWRITER \"%s\"\n", tr->songwriter);
        }
      }
      {
#line 733
      l --;
#line 733
      ifprintf(f, i, l, "}\n");
#line 734
      l --;
#line 734
      ifprintf(f, i, l, "}\n");
      }
    }
  }
#line 738
  if (tr->pregap > 0L) {
#line 738
    if (! tr->pregap_data_from_file) {
      {
#line 739
      tmp___2 = fr2tc(timecode_buffer, tr->pregap);
      }
#line 739
      if (tmp___2 == -1) {
        {
#line 740
        err_quit("Pregap out of range");
        }
      }
      {
#line 741
      ifprintf(f, i, l, "PREGAP %s\n", timecode_buffer);
      }
    }
  }
#line 745
  start = 0L;
#line 746
  if ((unsigned int )tr->mode == 1U) {
    {
#line 747
    ifprintf(f, i, l, "AUDIOFILE \"%s\" ", tr->filename);
    }
#line 748
    if (tr->start != -1L) {
#line 749
      if (tr->pregap_data_from_file) {
#line 750
        start = tr->start - tr->pregap;
      } else {
#line 752
        start = tr->start;
      }
    }
    {
#line 754
    tmp___3 = fr2tc(timecode_buffer, start);
    }
#line 754
    if (tmp___3 == -1) {
      {
#line 755
      err_quit("Track start out of range");
      }
    }
    {
#line 756
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"%s", timecode_buffer);
    }
  } else {
    {
#line 758
    ifprintf(f, i, l, "DATAFILE \"%s\"", tr->filename);
    }
  }
#line 763
  if (tr->next) {
    {
#line 763
    tmp___5 = strcmp((char const   *)(tr->filename), (char const   *)((tr->next)->filename));
    }
#line 763
    if (tmp___5 == 0) {
#line 763
      if ((tr->next)->start != -1L) {
#line 766
        if ((tr->next)->pregap_data_from_file) {
#line 767
          len = ((tr->next)->start - (tr->next)->pregap) - start;
        } else {
#line 770
          len = (tr->next)->start - start;
        }
        {
#line 771
        tmp___4 = fr2tc(timecode_buffer, len);
        }
#line 771
        if (tmp___4 == -1) {
          {
#line 772
          err_quit("Track length out of range");
          }
        }
        {
#line 773
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)" %s\n",
                timecode_buffer);
        }
      } else {
        {
#line 775
        fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
        }
      }
    } else {
      {
#line 775
      fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
      }
    }
  } else {
    {
#line 775
    fprintf((FILE */* __restrict  */)f, (char const   */* __restrict  */)"\n");
    }
  }
#line 778
  if (tr->pregap_data_from_file) {
    {
#line 779
    tmp___6 = fr2tc(timecode_buffer, tr->pregap);
    }
#line 779
    if (tmp___6 == -1) {
      {
#line 780
      err_quit("Pregap out of range");
      }
    }
    {
#line 781
    ifprintf(f, i, l, "START %s\n", timecode_buffer);
    }
  }
#line 785
  if (tr->postgap != -1L) {
    {
#line 786
    tmp___7 = fr2tc(timecode_buffer, tr->postgap);
    }
#line 786
    if (tmp___7 == -1) {
      {
#line 787
      err_quit("Postgap out of range");
      }
    }
#line 788
    if ((unsigned int )tr->mode == 1U) {
      {
#line 789
      ifprintf(f, i, l, "SILENCE %s\n", timecode_buffer);
      }
    } else {
      {
#line 791
      ifprintf(f, i, l, "ZERO %s\n", timecode_buffer);
      }
    }
  }
  {
#line 795
  while (1) {
    while_continue: /* CIL Label */ ;
#line 795
    if (tr->indexes[j] != -1L) {
#line 795
      if (! (i < 98)) {
#line 795
        goto while_break;
      }
    } else {
#line 795
      goto while_break;
    }
    {
#line 796
    tmp___8 = j;
#line 796
    j ++;
#line 796
    tmp___9 = fr2tc(timecode_buffer, tr->indexes[tmp___8]);
    }
#line 796
    if (tmp___9 == -1) {
      {
#line 797
      err_quit("Index out of range");
      }
    }
    {
#line 798
    ifprintf(f, i, l, "INDEX %s\n", timecode_buffer);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 801
  return;
}
}
#line 805 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/cue2toc.c"
void write_toc(char const   *tocfile , struct cuesheet *cs ) 
{ 
  FILE *f ;
  int i ;
  int l ;
  struct trackspec *track ;
  int tmp ;
  int tmp___0 ;
  enum session_type tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 808
  f = stdout;
#line 809
  i = 4;
#line 810
  l = 0;
#line 811
  track = cs->tracklist;
#line 813
  tmp = contains_cdtext(cs);
  }
#line 813
  if (tmp) {
#line 813
    if (cdtext) {
#line 813
      tmp___0 = 1;
    } else {
#line 813
      tmp___0 = 0;
    }
  } else {
#line 813
    tmp___0 = 0;
  }
#line 813
  cdtext = tmp___0;
#line 814
  if ((unsigned long )tocfile != (unsigned long )((void *)0)) {
    {
#line 815
    f = fopen((char const   */* __restrict  */)tocfile, (char const   */* __restrict  */)"w");
    }
#line 815
    if ((unsigned long )f == (unsigned long )((void *)0)) {
      {
#line 816
      err_sys("Could not open file \"%s\" for writing", tocfile);
      }
    }
  }
  {
#line 819
  tmp___1 = determine_session_type(cs->tracklist);
#line 819
  cs->type = tmp___1;
  }
#line 819
  if ((unsigned int )tmp___1 == 4U) {
    {
#line 820
    err_quit("Invalid combination of track modes");
    }
  }
  {
#line 822
  ifprintf(f, i, l, "// Generated by %s\n", "cue2toc 0.4");
#line 823
  ifprintf(f, i, l, "// Report bugs to <%s>\n", "dermatsch@gmx.de");
  }
#line 825
  if ((int )cs->catalog[0] != 0) {
    {
#line 826
    ifprintf(f, i, l, "CATALOG \"%s\"\n", cs->catalog);
    }
  }
  {
#line 829
  if ((unsigned int )cs->type == 1U) {
#line 829
    goto case_1;
  }
#line 830
  if ((unsigned int )cs->type == 2U) {
#line 830
    goto case_2;
  }
#line 831
  if ((unsigned int )cs->type == 3U) {
#line 831
    goto case_3;
  }
#line 832
  goto switch_default;
  case_1: /* CIL Label */ 
  {
#line 829
  ifprintf(f, i, l, "CD_DA\n");
  }
#line 829
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 830
  ifprintf(f, i, l, "CD_ROM\n");
  }
#line 830
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 831
  ifprintf(f, i, l, "CD_ROM_XA\n");
  }
#line 831
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 832
  err_quit("Should never get here");
  }
  switch_break: /* CIL Label */ ;
  }
#line 835
  if (cdtext) {
    {
#line 836
    tmp___2 = l;
#line 836
    l ++;
#line 836
    ifprintf(f, i, tmp___2, "CD_TEXT {\n");
#line 837
    tmp___3 = l;
#line 837
    l ++;
#line 837
    ifprintf(f, i, tmp___3, "LANGUAGE_MAP {\n");
#line 838
    ifprintf(f, i, l, "0 : EN\n");
#line 839
    l --;
#line 839
    ifprintf(f, i, l, "}\n");
#line 840
    tmp___4 = l;
#line 840
    l ++;
#line 840
    ifprintf(f, i, tmp___4, "LANGUAGE 0 {\n");
    }
#line 841
    if ((int )cs->title[0] != 0) {
      {
#line 842
      ifprintf(f, i, l, "TITLE \"%s\"\n", cs->title);
      }
    }
#line 843
    if ((int )cs->performer[0] != 0) {
      {
#line 844
      ifprintf(f, i, l, "PERFORMER \"%s\"\n", cs->performer);
      }
    }
#line 845
    if ((int )cs->songwriter[0] != 0) {
      {
#line 846
      ifprintf(f, i, l, "SONGWRITER \"%s\"\n", cs->songwriter);
      }
    }
    {
#line 848
    l --;
#line 848
    ifprintf(f, i, l, "}\n");
#line 849
    l --;
#line 849
    ifprintf(f, i, l, "}\n");
    }
  }
  {
#line 852
  while (1) {
    while_continue: /* CIL Label */ ;
#line 852
    if (! track) {
#line 852
      goto while_break;
    }
    {
#line 853
    write_track(track, f, i, l);
#line 854
    track = track->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 856
  return;
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/timecode.c"
long tc2fr(char const   *tc ) 
{ 
  int minutes ;
  int seconds ;
  int frames ;
  long totalframes ;
  char tmp[3] ;
  int nums[3] ;
  int n ;
  int i ;
  int last_was_colon ;
  int stop ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
#line 40
  minutes = 0;
#line 41
  seconds = 0;
#line 42
  frames = 0;
#line 43
  totalframes = 0L;
#line 47
  n = 0;
#line 48
  i = 0;
#line 49
  last_was_colon = 0;
#line 50
  stop = 0;
#line 52
  if ((unsigned long )tc == (unsigned long )((void *)0)) {
#line 53
    return (-1L);
  }
#line 55
  i = 0;
  {
#line 55
  while (1) {
    while_continue: /* CIL Label */ ;
#line 55
    if (! (i <= 2)) {
#line 55
      goto while_break;
    }
#line 56
    tmp[i] = (char )'\000';
#line 55
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 58
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 58
    tmp___0 = __ctype_b_loc();
    }
#line 58
    if (! ((int const   )*(*tmp___0 + (int )*tc) & 8192)) {
#line 58
      goto while_break___0;
    }
#line 59
    tc ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 61
  n = 0;
  {
#line 61
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 61
    if (! (n < 3)) {
#line 61
      goto while_break___1;
    }
#line 62
    if (n > 0) {
#line 63
      if ((int const   )*(tc + 0) != 58) {
#line 64
        n --;
#line 65
        goto while_break___1;
      } else {
#line 67
        tc ++;
      }
    }
#line 70
    i = 0;
    {
#line 70
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 70
      if (! (i < 2)) {
#line 70
        goto while_break___2;
      }
      {
#line 72
      tmp___1 = __ctype_b_loc();
      }
#line 72
      if ((int const   )*(*tmp___1 + (int )*(tc + i)) & 2048) {
#line 73
        tmp[i] = (char )*(tc + i);
#line 74
        last_was_colon = 0;
      } else
#line 75
      if ((int const   )*(tc + i) == 58) {
#line 76
        if (i == 0) {
#line 77
          stop = 1;
        }
#line 78
        goto while_break___2;
      } else {
#line 80
        stop = 1;
#line 81
        goto while_break___2;
      }
#line 70
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 85
    if (i != 0) {
      {
#line 86
      tmp[i] = (char )'\000';
#line 87
      nums[n] = atoi((char const   *)(tmp));
#line 88
      tc += i;
      }
    } else {
#line 90
      n --;
    }
#line 92
    if (stop) {
#line 93
      goto while_break___1;
    }
#line 61
    n ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 96
  if (n == 3) {
#line 97
    n --;
  }
#line 99
  minutes = 0;
#line 99
  seconds = minutes;
#line 99
  frames = seconds;
  {
#line 102
  if (n == 0) {
#line 102
    goto case_0;
  }
#line 105
  if (n == 1) {
#line 105
    goto case_1;
  }
#line 109
  if (n == 2) {
#line 109
    goto case_2;
  }
#line 101
  goto switch_break;
  case_0: /* CIL Label */ 
#line 103
  frames = nums[0];
#line 104
  goto switch_break;
  case_1: /* CIL Label */ 
#line 106
  seconds = nums[0];
#line 107
  frames = nums[1];
#line 108
  goto switch_break;
  case_2: /* CIL Label */ 
#line 110
  minutes = nums[0];
#line 111
  seconds = nums[1];
#line 112
  frames = nums[2];
#line 113
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 116
  totalframes = (long )((60 * minutes + seconds) * 75 + frames);
#line 118
  if (seconds > 59) {
#line 119
    return (-1L);
  } else
#line 118
  if (frames > 74) {
#line 119
    return (-1L);
  }
#line 121
  return (totalframes);
}
}
#line 129 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/timecode.c"
int fr2tc(char *tc , long fr ) 
{ 
  int m ;
  int s ;
  int f ;

  {
#line 136
  if (fr > 449999L) {
    {
#line 137
    strcpy((char */* __restrict  */)tc, (char const   */* __restrict  */)"00:00:00");
    }
#line 138
    return (-1);
  } else
#line 136
  if (fr < 0L) {
    {
#line 137
    strcpy((char */* __restrict  */)tc, (char const   */* __restrict  */)"00:00:00");
    }
#line 138
    return (-1);
  }
  {
#line 141
  f = (int )(fr % 75L);
#line 142
  fr -= (long )f;
#line 143
  s = (int )((fr / 75L) % 60L);
#line 144
  fr -= (long )(s * 75);
#line 145
  m = (int )((fr / 75L) / 60L);
#line 147
  sprintf((char */* __restrict  */)tc, (char const   */* __restrict  */)"%02d:%02d:%02d",
          m, s, f);
  }
#line 148
  return (0);
}
}
#line 578 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) putenv)(char *__string ) ;
#line 717
extern int system(char const   *__command ) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 33 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.h"
struct converter *converters ;
#line 42
void convert_files(struct trackspec *tr ) ;
#line 36 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.c"
struct converter *converters  =    (struct converter *)((void *)0);
#line 39 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.c"
static int trackno  =    1;
#line 42 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.c"
struct converter *new_converter(void) 
{ 
  struct converter *converter ;
  void *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 47
  tmp = malloc(sizeof(struct converter ));
#line 47
  converter = (struct converter *)tmp;
  }
#line 47
  if ((unsigned long )converter == (unsigned long )((void *)0)) {
    {
#line 48
    err_quit("Memory allocation error");
    }
  }
#line 50
  tmp___1 = (char *)((void *)0);
#line 50
  converter->command = tmp___1;
#line 50
  tmp___0 = tmp___1;
#line 50
  converter->ext_to = tmp___0;
#line 50
  converter->ext_from = tmp___0;
#line 51
  converter->next = (struct converter *)((void *)0);
#line 53
  return (converter);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.c"
void add_converter(struct converter *converter ) 
{ 
  struct converter *tmp ;

  {
#line 62
  if ((unsigned long )converters == (unsigned long )((void *)0)) {
#line 63
    converters = converter;
#line 64
    return;
  }
#line 67
  tmp = converters;
  {
#line 69
  while (1) {
    while_continue: /* CIL Label */ ;
#line 69
    if (! ((unsigned long )tmp->next != (unsigned long )((void *)0))) {
#line 69
      goto while_break;
    }
#line 70
    tmp = tmp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  tmp->next = converter;
#line 73
  (tmp->next)->next = (struct converter *)((void *)0);
#line 74
  return;
}
}
#line 77 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.c"
struct converter *find_converter(char const   *s ) 
{ 
  char *ext ;
  struct converter *converter ;
  int i ;
  size_t tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;

  {
#line 81
  converter = converters;
  {
#line 85
  while (1) {
    while_continue: /* CIL Label */ ;
#line 85
    if (! ((unsigned long )converter != (unsigned long )((void *)0))) {
#line 85
      goto while_break;
    }
    {
#line 86
    tmp = strlen(s);
#line 86
    tmp___0 = strlen((char const   *)converter->ext_from);
    }
#line 86
    if (tmp <= tmp___0) {
#line 87
      converter = converter->next;
#line 88
      goto while_continue;
    }
    {
#line 91
    tmp___1 = strlen((char const   *)converter->ext_from);
#line 91
    tmp___2 = malloc(tmp___1 + 1UL);
#line 91
    ext = (char *)tmp___2;
    }
#line 91
    if ((unsigned long )ext == (unsigned long )((void *)0)) {
      {
#line 92
      err_quit("Memory allocation error");
      }
    }
    {
#line 94
    tmp___3 = strlen(s);
#line 94
    tmp___4 = strlen((char const   *)converter->ext_from);
#line 94
    strcpy((char */* __restrict  */)ext, (char const   */* __restrict  */)(s + (tmp___3 - tmp___4)));
#line 96
    i = 0;
    }
    {
#line 96
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 96
      tmp___6 = strlen((char const   *)ext);
      }
#line 96
      if (! ((size_t )i < tmp___6)) {
#line 96
        goto while_break___0;
      }
      {
#line 97
      tmp___5 = tolower((int )*(ext + i));
#line 97
      *(ext + i) = (char )tmp___5;
#line 96
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 99
    tmp___7 = strcmp((char const   *)ext, (char const   *)converter->ext_from);
    }
#line 99
    if (tmp___7 == 0) {
      {
#line 100
      free((void *)ext);
      }
#line 101
      return (converter);
    }
    {
#line 104
    free((void *)ext);
#line 105
    converter = converter->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 108
  return ((struct converter *)((void *)0));
}
}
#line 113 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.c"
void do_track(struct trackspec *tr ) 
{ 
  struct converter *converter ;
  char *c2t_from_prefix ;
  char *c2t_to_prefix ;
  char *c2t_from ;
  char *c2t_to ;
  char *c2t_to_filename ;
  struct stat statbuf ;
  int status ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  size_t tmp___2 ;
  size_t tmp___3 ;
  size_t tmp___4 ;
  size_t tmp___5 ;
  void *tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  size_t tmp___9 ;
  void *tmp___10 ;
  size_t tmp___11 ;
  size_t tmp___12 ;
  size_t tmp___13 ;
  size_t tmp___14 ;
  size_t tmp___15 ;
  size_t tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  union __anonunion_53 __constr_expr_0 ;

  {
  {
#line 117
  c2t_from_prefix = (char *)"C2T_FROM=";
#line 118
  c2t_to_prefix = (char *)"C2T_TO=";
#line 125
  converter = find_converter((char const   *)(tr->filename));
  }
#line 125
  if ((unsigned long )converter == (unsigned long )((void *)0)) {
#line 126
    return;
  }
#line 128
  if (debug) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Found a converter for track %d: %s\n",
            trackno, converter->command);
    }
  }
  {
#line 131
  tmp = strlen((char const   *)c2t_from_prefix);
#line 131
  tmp___0 = strlen((char const   *)(tr->filename));
#line 131
  tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 131
  c2t_from = (char *)tmp___1;
  }
#line 131
  if ((unsigned long )c2t_from == (unsigned long )((void *)0)) {
    {
#line 133
    err_quit("Memory allocation error");
    }
  }
  {
#line 134
  tmp___2 = strlen((char const   *)c2t_to_prefix);
#line 134
  tmp___3 = strlen((char const   *)(tr->filename));
#line 134
  tmp___4 = strlen((char const   *)converter->ext_from);
#line 134
  tmp___5 = strlen((char const   *)converter->ext_to);
#line 134
  tmp___6 = malloc((((tmp___2 + tmp___3) - tmp___4) + tmp___5) + 1UL);
#line 134
  c2t_to = (char *)tmp___6;
  }
#line 134
  if ((unsigned long )c2t_to == (unsigned long )((void *)0)) {
    {
#line 137
    err_quit("Memory allocation error");
    }
  }
  {
#line 138
  tmp___7 = strlen((char const   *)(tr->filename));
#line 138
  tmp___8 = strlen((char const   *)converter->ext_from);
#line 138
  tmp___9 = strlen((char const   *)converter->ext_to);
#line 138
  tmp___10 = malloc(((tmp___7 - tmp___8) + tmp___9) + 1UL);
#line 138
  c2t_to_filename = (char *)tmp___10;
  }
#line 138
  if ((unsigned long )c2t_to_filename == (unsigned long )((void *)0)) {
    {
#line 141
    err_quit("Memory allocation error");
    }
  }
  {
#line 144
  strcpy((char */* __restrict  */)c2t_from, (char const   */* __restrict  */)c2t_from_prefix);
#line 145
  strcat((char */* __restrict  */)c2t_from, (char const   */* __restrict  */)(tr->filename));
#line 148
  strcpy((char */* __restrict  */)c2t_to, (char const   */* __restrict  */)c2t_to_prefix);
#line 149
  tmp___11 = strlen((char const   *)(tr->filename));
#line 149
  tmp___12 = strlen((char const   *)converter->ext_from);
#line 149
  strncat((char */* __restrict  */)c2t_to, (char const   */* __restrict  */)(tr->filename),
          tmp___11 - tmp___12);
#line 151
  strcat((char */* __restrict  */)c2t_to, (char const   */* __restrict  */)converter->ext_to);
#line 154
  tmp___13 = strlen((char const   *)(tr->filename));
#line 154
  tmp___14 = strlen((char const   *)converter->ext_from);
#line 154
  strncpy((char */* __restrict  */)c2t_to_filename, (char const   */* __restrict  */)(tr->filename),
          tmp___13 - tmp___14);
#line 156
  tmp___15 = strlen((char const   *)(tr->filename));
#line 156
  tmp___16 = strlen((char const   *)converter->ext_from);
#line 156
  *(c2t_to_filename + (tmp___15 - tmp___16)) = (char )'\000';
#line 158
  strcat((char */* __restrict  */)c2t_to_filename, (char const   */* __restrict  */)converter->ext_to);
#line 160
  tmp___17 = stat((char const   */* __restrict  */)c2t_to_filename, (struct stat */* __restrict  */)(& statbuf));
  }
#line 160
  if (tmp___17 != -1) {
#line 161
    if (debug) {
      {
#line 161
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s already exists\n",
              c2t_to_filename);
      }
    }
    {
#line 163
    free((void *)c2t_from);
#line 164
    free((void *)c2t_to);
#line 165
    strcpy((char */* __restrict  */)(tr->filename), (char const   */* __restrict  */)c2t_to_filename);
#line 166
    free((void *)c2t_to_filename);
    }
#line 168
    return;
  }
#line 171
  if (debug) {
    {
#line 171
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Exporting \"%s\"\n",
            c2t_from);
    }
  }
  {
#line 172
  tmp___18 = putenv(c2t_from);
  }
#line 172
  if (tmp___18 == -1) {
    {
#line 173
    err_sys("putenv error");
    }
  }
#line 175
  if (debug) {
    {
#line 175
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Exporting \"%s\"\n",
            c2t_to);
    }
  }
  {
#line 176
  tmp___19 = putenv(c2t_to);
  }
#line 176
  if (tmp___19 == -1) {
    {
#line 177
    err_sys("putenv error");
    }
  }
#line 180
  if (! quiet) {
    {
#line 181
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Track %d: Converting \"%s\" to \"%s\"\n",
            prog, trackno, tr->filename, c2t_to_filename);
    }
  }
  {
#line 184
  status = system((char const   *)converter->command);
  }
#line 184
  if (status == -1) {
    {
#line 185
    err_sys("system error");
    }
  }
#line 187
  if (debug) {
    {
#line 187
    __constr_expr_0.__in = status;
#line 187
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Conversion command returned with exit status %d\n",
            (__constr_expr_0.__i & 65280) >> 8);
    }
  }
  {
#line 191
  strcpy((char */* __restrict  */)(tr->filename), (char const   */* __restrict  */)c2t_to_filename);
#line 195
  free((void *)c2t_to_filename);
  }
#line 196
  return;
}
}
#line 199 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/convert.c"
void convert_files(struct trackspec *tr ) 
{ 


  {
#line 202
  if (debug) {
    {
#line 202
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Converting files\n");
    }
  }
  {
#line 204
  while (1) {
    while_continue: /* CIL Label */ ;
#line 204
    if (! ((unsigned long )tr != (unsigned long )((void *)0))) {
#line 204
      goto while_break;
    }
    {
#line 205
    do_track(tr);
#line 206
    trackno ++;
#line 207
    tr = tr->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 209
  return;
}
}
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/error.c"
char const   *prog  =    "program";
#line 31 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/error.c"
void err_sys(char const   *s  , ...) 
{ 
  va_list ap ;
  int errno_save ;
  int *tmp ;
  char *tmp___0 ;

  {
  {
#line 35
  tmp = __errno_location();
#line 35
  errno_save = *tmp;
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          prog);
#line 38
  __builtin_va_start(ap, s);
#line 39
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s, ap);
#line 40
  __builtin_va_end(ap);
#line 41
  tmp___0 = strerror(errno_save);
#line 41
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": %s\n",
          tmp___0);
#line 43
  exit(1);
  }
}
}
#line 48 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/error.c"
void err_quit(char const   *s  , ...) 
{ 
  va_list ap ;

  {
  {
#line 53
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
          prog);
#line 54
  __builtin_va_start(ap, s);
#line 55
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s, ap);
#line 56
  __builtin_va_end(ap);
#line 57
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 59
  exit(1);
  }
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 76
extern int opterr ;
#line 80
extern int optopt ;
#line 150
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt)(int ___argc ,
                                                                             char * const  *___argv ,
                                                                             char const   *__shortopts ) ;
#line 32 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/main.c"
void usage(void) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/main.c"
int main(int argc , char **argv ) 
{ 
  char *outfile ;
  char *infile ;
  int c ;
  struct cuesheet *cs ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 37
  outfile = (char *)((void *)0);
#line 38
  infile = (char *)((void *)0);
#line 43
  prog = (char const   *)*(argv + 0);
#line 44
  opterr = 0;
#line 46
  config();
  }
  {
#line 48
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 48
    c = getopt(argc, (char * const  *)argv, ":dhno:qv");
    }
#line 48
    if (! (c != -1)) {
#line 48
      goto while_break;
    }
    {
#line 50
    if (c == 100) {
#line 50
      goto case_100;
    }
#line 51
    if (c == 104) {
#line 51
      goto case_104;
    }
#line 55
    if (c == 110) {
#line 55
      goto case_110;
    }
#line 56
    if (c == 111) {
#line 56
      goto case_111;
    }
#line 62
    if (c == 113) {
#line 62
      goto case_113;
    }
#line 63
    if (c == 118) {
#line 63
      goto case_118;
    }
#line 68
    if (c == 58) {
#line 68
      goto case_58;
    }
#line 69
    if (c == 63) {
#line 69
      goto case_63;
    }
#line 70
    goto switch_default;
    case_100: /* CIL Label */ 
#line 50
    debug = 1;
#line 50
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 52
    usage();
#line 53
    exit(0);
    }
#line 54
    goto switch_break;
    case_110: /* CIL Label */ 
#line 55
    cdtext = 0;
#line 55
    goto switch_break;
    case_111: /* CIL Label */ 
    {
#line 57
    tmp = strcmp((char const   *)optarg, "-");
    }
#line 57
    if (tmp == 0) {
#line 58
      outfile = (char *)((void *)0);
    } else {
#line 60
      outfile = optarg;
    }
#line 61
    goto switch_break;
    case_113: /* CIL Label */ 
#line 62
    quiet = 1;
#line 62
    goto switch_break;
    case_118: /* CIL Label */ 
    {
#line 64
    printf((char const   */* __restrict  */)"%s\n", "cue2toc 0.4");
#line 65
    printf((char const   */* __restrict  */)"Report bugs to <%s>\n", "dermatsch@gmx.de");
#line 66
    exit(0);
    }
#line 67
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 68
    err_quit("Options requires argument -- %c", optopt);
    }
    case_63: /* CIL Label */ 
    {
#line 69
    err_quit("Illegal option -- %c", optopt);
    }
    switch_default: /* CIL Label */ 
    {
#line 70
    err_quit("Unhandled command line option. D\'oh!");
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 75
  if (argc - optind == 0) {
#line 75
    goto case_0;
  }
#line 78
  if (argc - optind == 1) {
#line 78
    goto case_1;
  }
#line 84
  goto switch_default___0;
  case_0: /* CIL Label */ 
#line 76
  infile = (char *)((void *)0);
#line 77
  goto switch_break___0;
  case_1: /* CIL Label */ 
  {
#line 79
  tmp___0 = strcmp((char const   *)*(argv + optind), "-");
  }
#line 79
  if (tmp___0 == 0) {
#line 80
    infile = (char *)((void *)0);
  } else {
#line 82
    infile = *(argv + optind);
  }
#line 83
  goto switch_break___0;
  switch_default___0: /* CIL Label */ 
  {
#line 85
  err_quit("Too many arguments");
  }
  switch_break___0: /* CIL Label */ ;
  }
  {
#line 88
  cs = read_cue((char const   *)infile);
  }
#line 89
  if (convert) {
    {
#line 90
    convert_files(cs->tracklist);
    }
  }
  {
#line 91
  write_toc((char const   *)outfile, cs);
  }
#line 93
  return (0);
}
}
#line 96 "/home/june/repo/benchmarks/collector/temp/cue2toc-0.4/main.c"
void usage(void) 
{ 


  {
  {
#line 99
  printf((char const   */* __restrict  */)"Usage: %s [-dhqv] [-o tocfile] [cuefile]\n",
         prog);
#line 101
  printf((char const   */* __restrict  */)"  -d\t\tprint debugging info\n");
#line 102
  printf((char const   */* __restrict  */)"  -h\t\tdisplay this help message\n");
#line 103
  printf((char const   */* __restrict  */)"  -o tocfile\twrite output to tocfile\n");
#line 104
  printf((char const   */* __restrict  */)"  -q\t\tbe quiet\n");
#line 105
  printf((char const   */* __restrict  */)"  -v\t\tdisplay version information\n");
  }
#line 106
  return;
}
}
