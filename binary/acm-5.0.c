/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 38 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
enum defkind {
    DEF_CONST = 0,
    DEF_STRUCT = 1,
    DEF_UNION = 2,
    DEF_ENUM = 3,
    DEF_TYPEDEF = 4,
    DEF_PROGRAM = 5
} ;
#line 46 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef enum defkind defkind;
#line 48 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef char *const_def;
#line 50
enum relation {
    REL_VECTOR = 0,
    REL_ARRAY = 1,
    REL_ARRAY2 = 2,
    REL_POINTER = 3,
    REL_ALIAS = 4
} ;
#line 57 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef enum relation relation;
#line 59 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct typedef_def {
   char *old_prefix ;
   char *old_type ;
   int old_storage ;
   char old_pstorage[128] ;
   relation rel ;
   char *array_max ;
};
#line 67 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct typedef_def typedef_def;
#line 70 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct enumval_list {
   char *name ;
   char *assignment ;
   struct enumval_list *next ;
};
#line 75 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct enumval_list enumval_list;
#line 77 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct enum_def {
   enumval_list *vals ;
};
#line 80 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct enum_def enum_def;
#line 83 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct declaration {
   char *prefix ;
   char *type ;
   int storage ;
   char pstorage[128] ;
   char *name ;
   relation rel ;
   char *array_max ;
};
#line 92 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct declaration declaration;
#line 95 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct decl_list {
   declaration decl ;
   struct decl_list *next ;
};
#line 99 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct decl_list decl_list;
#line 101 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct struct_def {
   decl_list *decls ;
   int storage ;
   char pstorage[128] ;
};
#line 106 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct struct_def struct_def;
#line 109 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct case_list {
   char *case_name ;
   declaration case_decl ;
   struct case_list *next ;
};
#line 114 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct case_list case_list;
#line 116 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct union_def {
   declaration enum_decl ;
   case_list *cases ;
   declaration *default_decl ;
};
#line 121 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct union_def union_def;
#line 125 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct proc_list {
   char *proc_name ;
   char *proc_num ;
   char *arg_type ;
   char *arg_prefix ;
   char *res_type ;
   char *res_prefix ;
   struct proc_list *next ;
};
#line 134 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct proc_list proc_list;
#line 137 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct version_list {
   char *vers_name ;
   char *vers_num ;
   proc_list *procs ;
   struct version_list *next ;
};
#line 143 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct version_list version_list;
#line 145 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct program_def {
   char *prog_num ;
   version_list *versions ;
};
#line 149 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct program_def program_def;
#line 151 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
union __anonunion_def_6 {
   const_def co ;
   struct_def st ;
   union_def un ;
   enum_def en ;
   typedef_def ty ;
   program_def pr ;
};
#line 151 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
struct definition {
   char *def_name ;
   defkind def_kind ;
   union __anonunion_def_6 def ;
};
#line 163 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
typedef struct definition definition;
#line 45 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
struct list {
   char *val ;
   struct list *next ;
};
#line 49 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
typedef struct list list;
#line 42 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.h"
enum tok_kind {
    TOK_IDENT = 0,
    TOK_STRCONST = 1,
    TOK_LPAREN = 2,
    TOK_RPAREN = 3,
    TOK_LBRACE = 4,
    TOK_RBRACE = 5,
    TOK_LBRACKET = 6,
    TOK_RBRACKET = 7,
    TOK_LANGLE = 8,
    TOK_RANGLE = 9,
    TOK_STAR = 10,
    TOK_COMMA = 11,
    TOK_EQUAL = 12,
    TOK_COLON = 13,
    TOK_SEMICOLON = 14,
    TOK_CONST = 15,
    TOK_STRUCT = 16,
    TOK_UNION = 17,
    TOK_SWITCH = 18,
    TOK_CASE = 19,
    TOK_DEFAULT = 20,
    TOK_ENUM = 21,
    TOK_TYPEDEF = 22,
    TOK_INT = 23,
    TOK_SHORT = 24,
    TOK_LONG = 25,
    TOK_UNSIGNED = 26,
    TOK_FLOAT = 27,
    TOK_DOUBLE = 28,
    TOK_OPAQUE = 29,
    TOK_CHAR = 30,
    TOK_STRING = 31,
    TOK_BOOL = 32,
    TOK_VOID = 33,
    TOK_PROGRAM = 34,
    TOK_VERSION = 35,
    TOK_EOF = 36
} ;
#line 81 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.h"
typedef enum tok_kind tok_kind;
#line 86 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.h"
struct token {
   tok_kind kind ;
   char *str ;
};
#line 90 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.h"
typedef struct token token;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 59 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
struct commandline {
   int cflag ;
   int hflag ;
   int lflag ;
   int sflag ;
   int mflag ;
   char *infile ;
   char *outfile ;
};
#line 45 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.h"
struct __anonstruct_datum_2 {
   char *dptr ;
   int dsize ;
};
#line 45 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.h"
typedef struct __anonstruct_datum_2 datum;
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 15 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.h"
struct __anonstruct_DBM_6 {
   int dirf ;
   int pagf ;
   int flags ;
   long maxbno ;
   long curbit ;
   long hmask ;
   long blkptr ;
   int keyptr ;
   long blkno ;
   long pagbno ;
   char pagbuf[1024] ;
   long dirbno ;
   char dirbuf[4096] ;
};
#line 15 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.h"
typedef struct __anonstruct_DBM_6 DBM;
#line 44 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
struct __anonstruct_cmd_8 {
   char *sname ;
   int scode ;
   int flags ;
};
#line 44 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
typedef struct __anonstruct_cmd_8 cmd;
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 356 "/usr/include/stdio.h"
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 60 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
FILE *fout ;
#line 63
list *defined ;
#line 79
char *stringfix(char *type ) ;
#line 80
void pvname(char *pname , char *vnum ) ;
#line 81
void ptype(char *prefix , char *type , int follow ) ;
#line 83
int streq(char *a , char *b ) ;
#line 105
void write_most(void) ;
#line 106
void write_register(char *transp ) ;
#line 107
void write_rest(void) ;
#line 48 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
static char RQSTP[6]  = {      (char )'r',      (char )'q',      (char )'s',      (char )'t', 
        (char )'p',      (char )'\000'};
#line 49 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
static char TRANSP[7]  = {      (char )'t',      (char )'r',      (char )'a',      (char )'n', 
        (char )'s',      (char )'p',      (char )'\000'};
#line 50 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
static char ARG[9]  = 
#line 50
  {      (char )'a',      (char )'r',      (char )'g',      (char )'u', 
        (char )'m',      (char )'e',      (char )'n',      (char )'t', 
        (char )'\000'};
#line 51 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
static char RESULT[7]  = {      (char )'r',      (char )'e',      (char )'s',      (char )'u', 
        (char )'l',      (char )'t',      (char )'\000'};
#line 52 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
static char ROUTINE[6]  = {      (char )'l',      (char )'o',      (char )'c',      (char )'a', 
        (char )'l',      (char )'\000'};
#line 54
static void write_program(definition *def , char *storage ) ;
#line 54
static void printerr(char *err , char *transp ) ;
#line 54
static void printif(char *proc , char *transp , char *prefix , char *arg ) ;
#line 56
int nullproc(proc_list *proc ) ;
#line 61 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
void write_most(void) 
{ 
  list *l ;
  definition *def ;
  version_list *vp ;

  {
#line 68
  l = defined;
  {
#line 68
  while (1) {
    while_continue: /* CIL Label */ ;
#line 68
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 68
      goto while_break;
    }
#line 69
    def = (definition *)l->val;
#line 70
    if ((unsigned int )def->def_kind == 5U) {
#line 71
      vp = def->def.pr.versions;
      {
#line 71
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 71
        if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 71
          goto while_break___0;
        }
        {
#line 72
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\nstatic void ");
#line 73
        pvname(def->def_name, vp->vers_num);
#line 74
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"();");
#line 71
        vp = vp->next;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
#line 68
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 78
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n");
#line 79
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"main()\n");
#line 80
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"{\n");
#line 81
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tSVCXPRT *%s;\n",
          TRANSP);
#line 82
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 83
  l = defined;
  }
  {
#line 83
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 83
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 83
      goto while_break___1;
    }
#line 84
    def = (definition *)l->val;
#line 85
    if ((unsigned int )def->def_kind != 5U) {
#line 86
      goto __Cont;
    }
#line 88
    vp = def->def.pr.versions;
    {
#line 88
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 88
      if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 88
        goto while_break___2;
      }
      {
#line 89
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t(void)pmap_unset(%s, %s);\n",
              def->def_name, vp->vers_name);
#line 88
      vp = vp->next;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 83
    l = l->next;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 92
  return;
}
}
#line 98 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
void write_register(char *transp ) 
{ 
  list *l ;
  definition *def ;
  version_list *vp ;
  int tmp ;
  char const   *tmp___1 ;
  int tmp___2 ;

  {
  {
#line 106
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 107
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t%s = svc%s_create(RPC_ANYSOCK",
          TRANSP, transp);
#line 108
  tmp = streq(transp, "tcp");
  }
#line 108
  if (tmp) {
    {
#line 109
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)", 0, 0");
    }
  }
  {
#line 111
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)");\n");
#line 112
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tif (%s == NULL) {\n",
          TRANSP);
#line 113
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\t(void)fprintf(stderr, \"cannot create %s service.\\n\");\n",
          transp);
#line 114
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\texit(1);\n");
#line 115
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t}\n");
#line 117
  l = defined;
  }
  {
#line 117
  while (1) {
    while_continue: /* CIL Label */ ;
#line 117
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 117
      goto while_break;
    }
#line 118
    def = (definition *)l->val;
#line 119
    if ((unsigned int )def->def_kind != 5U) {
#line 120
      goto __Cont;
    }
#line 122
    vp = def->def.pr.versions;
    {
#line 122
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 122
      if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 122
        goto while_break___0;
      }
      {
#line 123
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tif (!svc_register(%s, %s, %s, ",
              TRANSP, def->def_name, vp->vers_name);
#line 126
      pvname(def->def_name, vp->vers_num);
#line 127
      tmp___2 = streq(transp, "udp");
      }
#line 127
      if (tmp___2) {
#line 127
        tmp___1 = "UDP";
      } else {
#line 127
        tmp___1 = "TCP";
      }
      {
#line 127
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)", IPPROTO_%s)) {\n",
              tmp___1);
#line 129
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\t(void)fprintf(stderr, \"unable to register (%s, %s, %s).\\n\");\n",
              def->def_name, vp->vers_name, transp);
#line 132
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\texit(1);\n");
#line 133
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t}\n");
#line 122
      vp = vp->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    __Cont: /* CIL Label */ 
#line 117
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 136
  return;
}
}
#line 142 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
void write_rest(void) 
{ 


  {
  {
#line 145
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tsvc_run();\n");
#line 146
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t(void)fprintf(stderr, \"svc_run returned\\n\");\n");
#line 147
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\texit(1);\n");
#line 148
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"}\n");
  }
#line 149
  return;
}
}
#line 151 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
void write_programs(char *storage ) 
{ 
  list *l ;
  definition *def ;

  {
#line 158
  l = defined;
  {
#line 158
  while (1) {
    while_continue: /* CIL Label */ ;
#line 158
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 158
      goto while_break;
    }
#line 159
    def = (definition *)l->val;
#line 160
    if ((unsigned int )def->def_kind == 5U) {
      {
#line 161
      write_program(def, storage);
      }
    }
#line 158
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 164
  return;
}
}
#line 167 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
static void write_program(definition *def , char *storage ) 
{ 
  version_list *vp ;
  proc_list *proc ;
  int filled ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 176
  vp = def->def.pr.versions;
  {
#line 176
  while (1) {
    while_continue: /* CIL Label */ ;
#line 176
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 176
      goto while_break;
    }
    {
#line 177
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
    }
#line 178
    if ((unsigned long )storage != (unsigned long )((void *)0)) {
      {
#line 179
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s ",
              storage);
      }
    }
    {
#line 181
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"void\n");
#line 182
    pvname(def->def_name, vp->vers_num);
#line 183
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"(%s, %s)\n",
            RQSTP, TRANSP);
#line 184
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tstruct svc_req *%s;\n",
            RQSTP);
#line 185
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tSVCXPRT *%s;\n",
            TRANSP);
#line 186
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"{\n");
#line 188
    filled = 0;
#line 189
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tunion {\n");
#line 190
    proc = vp->procs;
    }
    {
#line 190
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 190
      if (! ((unsigned long )proc != (unsigned long )((void *)0))) {
#line 190
        goto while_break___0;
      }
      {
#line 191
      tmp = streq(proc->arg_type, "void");
      }
#line 191
      if (tmp) {
#line 192
        goto __Cont;
      }
      {
#line 194
      filled = 1;
#line 195
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\t");
#line 196
      ptype(proc->arg_prefix, proc->arg_type, 0);
#line 197
      pvname(proc->proc_name, vp->vers_num);
#line 198
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"_arg;\n");
      }
      __Cont: /* CIL Label */ 
#line 190
      proc = proc->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 200
    if (! filled) {
      {
#line 201
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\tint fill;\n");
      }
    }
    {
#line 203
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t} %s;\n",
            ARG);
#line 204
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tchar *%s;\n",
            RESULT);
#line 205
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tbool_t (*xdr_%s)(), (*xdr_%s)();\n",
            ARG, RESULT);
#line 206
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tchar *(*%s)();\n",
            ROUTINE);
#line 207
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 208
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tswitch (%s->rq_proc) {\n",
            RQSTP);
#line 210
    tmp___0 = nullproc(vp->procs);
    }
#line 210
    if (! tmp___0) {
      {
#line 211
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tcase NULLPROC:\n");
#line 212
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\t(void)svc_sendreply(%s, xdr_void, (char *)NULL);\n",
              TRANSP);
#line 213
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\treturn;\n\n");
      }
    }
#line 215
    proc = vp->procs;
    {
#line 215
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 215
      if (! ((unsigned long )proc != (unsigned long )((void *)0))) {
#line 215
        goto while_break___1;
      }
      {
#line 216
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tcase %s:\n",
              proc->proc_name);
#line 217
      tmp___1 = stringfix(proc->arg_type);
#line 217
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\txdr_%s = xdr_%s;\n",
              ARG, tmp___1);
#line 219
      tmp___2 = stringfix(proc->res_type);
#line 219
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\txdr_%s = xdr_%s;\n",
              RESULT, tmp___2);
#line 221
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\t%s = (char *(*)()) ",
              ROUTINE);
#line 222
      pvname(proc->proc_name, vp->vers_num);
#line 223
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)";\n");
#line 224
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\tbreak;\n\n");
#line 215
      proc = proc->next;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 226
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tdefault:\n");
#line 227
    printerr("noproc", TRANSP);
#line 228
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\treturn;\n");
#line 229
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t}\n");
#line 231
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tbzero((char *)&%s, sizeof(%s));\n",
            ARG, ARG);
#line 232
    printif("getargs", TRANSP, "&", ARG);
#line 233
    printerr("decode", TRANSP);
#line 234
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\treturn;\n");
#line 235
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t}\n");
#line 237
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t%s = (*%s)(&%s, %s);\n",
            RESULT, ROUTINE, ARG, RQSTP);
#line 239
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tif (%s != NULL && !svc_sendreply(%s, xdr_%s, %s)) {\n",
            RESULT, TRANSP, RESULT, RESULT);
#line 242
    printerr("systemerr", TRANSP);
#line 243
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t}\n");
#line 245
    printif("freeargs", TRANSP, "&", ARG);
#line 246
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\t(void)fprintf(stderr, \"unable to free arguments\\n\");\n");
#line 247
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\texit(1);\n");
#line 248
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t}\n");
#line 250
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"}\n\n");
#line 176
    vp = vp->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 252
  return;
}
}
#line 254 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
static void printerr(char *err , char *transp ) 
{ 


  {
  {
#line 259
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\tsvcerr_%s(%s);\n",
          err, transp);
  }
#line 260
  return;
}
}
#line 262 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
static void printif(char *proc , char *transp , char *prefix , char *arg ) 
{ 


  {
  {
#line 269
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tif (!svc_%s(%s, xdr_%s, %s%s)) {\n",
          proc, transp, arg, prefix, arg);
  }
#line 271
  return;
}
}
#line 273 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_svcout.c"
int nullproc(proc_list *proc ) 
{ 
  int tmp ;

  {
  {
#line 277
  while (1) {
    while_continue: /* CIL Label */ ;
#line 277
    if (! ((unsigned long )proc != (unsigned long )((void *)0))) {
#line 277
      goto while_break;
    }
    {
#line 278
    tmp = streq(proc->proc_num, "0");
    }
#line 278
    if (tmp) {
#line 279
      return (1);
    }
#line 277
    proc = proc->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 282
  return (0);
}
}
#line 82 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
int isvectordef(char *type , relation rel ) ;
#line 112
void write_stubs(void) ;
#line 50 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_clntout.c"
static int write_program___0(definition *def ) ;
#line 50
static int printbody(proc_list *proc ) ;
#line 53 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_clntout.c"
void write_stubs(void) 
{ 
  list *l ;
  definition *def ;

  {
  {
#line 59
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n/* Default timeout can be changed using clnt_control() */\n");
#line 61
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"static struct timeval TIMEOUT = { %d, 0 };\n",
          25);
#line 63
  l = defined;
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 63
      goto while_break;
    }
#line 64
    def = (definition *)l->val;
#line 65
    if ((unsigned int )def->def_kind == 5U) {
      {
#line 66
      write_program___0(def);
      }
    }
#line 63
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 69
  return;
}
}
#line 72 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_clntout.c"
static int write_program___0(definition *def ) 
{ 
  version_list *vp ;
  proc_list *proc ;

  {
#line 79
  vp = def->def.pr.versions;
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! ((unsigned long )vp != (unsigned long )((void *)0))) {
#line 79
      goto while_break;
    }
#line 80
    proc = vp->procs;
    {
#line 80
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 80
      if (! ((unsigned long )proc != (unsigned long )((void *)0))) {
#line 80
        goto while_break___0;
      }
      {
#line 81
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 82
      ptype(proc->res_prefix, proc->res_type, 1);
#line 83
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"*\n");
#line 84
      pvname(proc->proc_name, vp->vers_num);
#line 85
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"(argp, clnt)\n");
#line 86
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t");
#line 87
      ptype(proc->arg_prefix, proc->arg_type, 1);
#line 88
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"*argp;\n");
#line 89
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tCLIENT *clnt;\n");
#line 90
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"{\n");
#line 91
      printbody(proc);
#line 92
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"}\n\n");
#line 80
      proc = proc->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 79
    vp = vp->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 95
  return (0);
}
}
#line 98 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_clntout.c"
static char *ampr(char *type ) 
{ 
  int tmp ;

  {
  {
#line 102
  tmp = isvectordef(type, 4);
  }
#line 102
  if (tmp) {
#line 103
    return ((char *)"");
  } else {
#line 105
    return ((char *)"&");
  }
}
}
#line 109 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_clntout.c"
static int printbody(proc_list *proc ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;

  {
  {
#line 113
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tstatic ");
#line 114
  tmp = streq(proc->res_type, "void");
  }
#line 114
  if (tmp) {
    {
#line 115
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"char ");
    }
  } else {
    {
#line 117
    ptype(proc->res_prefix, proc->res_type, 0);
    }
  }
  {
#line 119
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"res;\n");
#line 120
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
#line 121
  tmp___0 = ampr(proc->res_type);
#line 121
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tbzero((char *)%sres, sizeof(res));\n",
          tmp___0);
#line 123
  tmp___1 = ampr(proc->res_type);
#line 123
  tmp___2 = stringfix(proc->res_type);
#line 123
  tmp___3 = stringfix(proc->arg_type);
#line 123
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tif (clnt_call(clnt, %s, xdr_%s, argp, xdr_%s, %sres, TIMEOUT) != RPC_SUCCESS) {\n",
          proc->proc_name, tmp___3, tmp___2, tmp___1);
#line 127
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\treturn (NULL);\n");
#line 128
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t}\n");
#line 129
  tmp___6 = streq(proc->res_type, "void");
  }
#line 129
  if (tmp___6) {
    {
#line 130
    tmp___4 = ampr(proc->res_type);
#line 130
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\treturn ((void *)%sres);\n",
            tmp___4);
    }
  } else {
    {
#line 133
    tmp___5 = ampr(proc->res_type);
#line 133
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\treturn (%sres);\n",
            tmp___5);
    }
  }
#line 135
  return (0);
}
}
#line 364 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 466
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 132 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 97 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.h"
void scan(tok_kind expect , token *tokp ) ;
#line 98
void scan2(tok_kind expect1 , tok_kind expect2 , token *tokp ) ;
#line 99
void scan3(tok_kind expect1 , tok_kind expect2 , tok_kind expect3 , token *tokp ) ;
#line 100
void scan_num(token *tokp ) ;
#line 101
void peek(token *tokp ) ;
#line 102
int peekscan(tok_kind expect , token *tokp ) ;
#line 103
void get_token(token *tokp ) ;
#line 55 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
char curline[1024] ;
#line 56
char *where ;
#line 57
int linenum ;
#line 59
char *infilename ;
#line 61
FILE *fin ;
#line 84
void error(char *msg ) ;
#line 85
void expected1(tok_kind exp1 ) ;
#line 86
void expected2(tok_kind exp1 , tok_kind exp2 ) ;
#line 87
void expected3(tok_kind exp1 , tok_kind exp2 , tok_kind exp3 ) ;
#line 50 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static int pushed  =    0;
#line 51 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static token lasttok  ;
#line 53
static void unget_token(token *tokp ) ;
#line 53
static void findstrconst(char **str , char **val ) ;
#line 53
static void findconst(char **str , char **val ) ;
#line 53
static void findkind(char **mark , token *tokp ) ;
#line 53
static void printdirective(char *line ) ;
#line 53
static void docppline(char *line , int *lineno , char **fname ) ;
#line 55
static int cppline(char *line ) ;
#line 55
static int directive(char *line ) ;
#line 60 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
void scan(tok_kind expect , token *tokp ) 
{ 


  {
  {
#line 65
  get_token(tokp);
  }
#line 66
  if ((unsigned int )tokp->kind != (unsigned int )expect) {
    {
#line 67
    expected1((unsigned int )expect);
    }
  }
#line 69
  return;
}
}
#line 74 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
void scan2(tok_kind expect1 , tok_kind expect2 , token *tokp ) 
{ 


  {
  {
#line 80
  get_token(tokp);
  }
#line 81
  if ((unsigned int )tokp->kind != (unsigned int )expect1) {
#line 81
    if ((unsigned int )tokp->kind != (unsigned int )expect2) {
      {
#line 82
      expected2((unsigned int )expect1, (unsigned int )expect2);
      }
    }
  }
#line 84
  return;
}
}
#line 89 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
void scan3(tok_kind expect1 , tok_kind expect2 , tok_kind expect3 , token *tokp ) 
{ 


  {
  {
#line 96
  get_token(tokp);
  }
#line 97
  if ((unsigned int )tokp->kind != (unsigned int )expect1) {
#line 97
    if ((unsigned int )tokp->kind != (unsigned int )expect2) {
#line 97
      if ((unsigned int )tokp->kind != (unsigned int )expect3) {
        {
#line 99
        expected3((unsigned int )expect1, (unsigned int )expect2, (unsigned int )expect3);
        }
      }
    }
  }
#line 101
  return;
}
}
#line 107 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
void scan_num(token *tokp ) 
{ 


  {
  {
#line 111
  get_token(tokp);
  }
  {
#line 113
  if ((unsigned int )tokp->kind == 0U) {
#line 113
    goto case_0;
  }
#line 115
  goto switch_default;
  case_0: /* CIL Label */ 
#line 114
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 116
  error("constant or identifier expected");
  }
  switch_break: /* CIL Label */ ;
  }
#line 118
  return;
}
}
#line 124 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
void peek(token *tokp ) 
{ 


  {
  {
#line 128
  get_token(tokp);
#line 129
  unget_token(tokp);
  }
#line 130
  return;
}
}
#line 136 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
int peekscan(tok_kind expect , token *tokp ) 
{ 


  {
  {
#line 141
  peek(tokp);
  }
#line 142
  if ((unsigned int )tokp->kind == (unsigned int )expect) {
    {
#line 143
    get_token(tokp);
    }
#line 144
    return (1);
  }
#line 146
  return (0);
}
}
#line 154 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
void get_token(token *tokp ) 
{ 
  int commenting ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  char buf___0[100] ;
  char *p ;
  size_t tmp___4 ;
  unsigned short const   **tmp___5 ;
  unsigned short const   **tmp___6 ;

  {
#line 160
  if (pushed) {
#line 161
    pushed = 0;
#line 162
    *tokp = lasttok;
#line 163
    return;
  }
#line 165
  commenting = 0;
  {
#line 166
  while (1) {
    while_continue: /* CIL Label */ ;
#line 167
    if ((int )*where == 0) {
      {
#line 168
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 169
        tmp = fgets((char */* __restrict  */)(curline), 1024, (FILE */* __restrict  */)fin);
        }
#line 169
        if (! tmp) {
#line 170
          tokp->kind = (tok_kind )36;
#line 171
          *where = (char)0;
#line 172
          return;
        }
#line 174
        linenum ++;
#line 175
        if (commenting) {
#line 176
          goto while_break___0;
        } else {
          {
#line 177
          tmp___1 = cppline(curline);
          }
#line 177
          if (tmp___1) {
            {
#line 178
            docppline(curline, & linenum, & infilename);
            }
          } else {
            {
#line 180
            tmp___0 = directive(curline);
            }
#line 180
            if (tmp___0) {
              {
#line 181
              printdirective(curline);
              }
            } else {
#line 183
              goto while_break___0;
            }
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 186
      where = curline;
    } else {
      {
#line 187
      tmp___3 = __ctype_b_loc();
      }
#line 187
      if ((int const   )*(*tmp___3 + (int )*where) & 8192) {
        {
#line 188
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 188
          tmp___2 = __ctype_b_loc();
          }
#line 188
          if (! ((int const   )*(*tmp___2 + (int )*where) & 8192)) {
#line 188
            goto while_break___1;
          }
#line 189
          where ++;
        }
        while_break___1: /* CIL Label */ ;
        }
      } else
#line 191
      if (commenting) {
#line 192
        where ++;
#line 193
        if ((int )*(where + -1) == 42) {
#line 193
          if ((int )*(where + 0) == 47) {
#line 194
            where ++;
#line 195
            commenting --;
          }
        }
      } else
#line 197
      if ((int )*(where + 0) == 47) {
#line 197
        if ((int )*(where + 1) == 42) {
#line 198
          where += 2;
#line 199
          commenting ++;
        } else {
#line 201
          goto while_break;
        }
      } else {
#line 201
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 209
  if ((int )*where == 58) {
#line 209
    goto case_58;
  }
#line 213
  if ((int )*where == 59) {
#line 213
    goto case_59;
  }
#line 217
  if ((int )*where == 44) {
#line 217
    goto case_44;
  }
#line 221
  if ((int )*where == 61) {
#line 221
    goto case_61;
  }
#line 225
  if ((int )*where == 42) {
#line 225
    goto case_42;
  }
#line 229
  if ((int )*where == 91) {
#line 229
    goto case_91;
  }
#line 233
  if ((int )*where == 93) {
#line 233
    goto case_93;
  }
#line 237
  if ((int )*where == 123) {
#line 237
    goto case_123;
  }
#line 241
  if ((int )*where == 125) {
#line 241
    goto case_125;
  }
#line 245
  if ((int )*where == 40) {
#line 245
    goto case_40;
  }
#line 249
  if ((int )*where == 41) {
#line 249
    goto case_41;
  }
#line 253
  if ((int )*where == 60) {
#line 253
    goto case_60;
  }
#line 257
  if ((int )*where == 62) {
#line 257
    goto case_62;
  }
#line 262
  if ((int )*where == 34) {
#line 262
    goto case_34;
  }
#line 277
  if ((int )*where == 57) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 56) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 55) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 54) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 53) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 52) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 51) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 50) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 49) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 48) {
#line 277
    goto case_57;
  }
#line 277
  if ((int )*where == 45) {
#line 277
    goto case_57;
  }
#line 283
  goto switch_default;
  case_58: /* CIL Label */ 
#line 210
  tokp->kind = (tok_kind )13;
#line 211
  where ++;
#line 212
  goto switch_break;
  case_59: /* CIL Label */ 
#line 214
  tokp->kind = (tok_kind )14;
#line 215
  where ++;
#line 216
  goto switch_break;
  case_44: /* CIL Label */ 
#line 218
  tokp->kind = (tok_kind )11;
#line 219
  where ++;
#line 220
  goto switch_break;
  case_61: /* CIL Label */ 
#line 222
  tokp->kind = (tok_kind )12;
#line 223
  where ++;
#line 224
  goto switch_break;
  case_42: /* CIL Label */ 
#line 226
  tokp->kind = (tok_kind )10;
#line 227
  where ++;
#line 228
  goto switch_break;
  case_91: /* CIL Label */ 
#line 230
  tokp->kind = (tok_kind )6;
#line 231
  where ++;
#line 232
  goto switch_break;
  case_93: /* CIL Label */ 
#line 234
  tokp->kind = (tok_kind )7;
#line 235
  where ++;
#line 236
  goto switch_break;
  case_123: /* CIL Label */ 
#line 238
  tokp->kind = (tok_kind )4;
#line 239
  where ++;
#line 240
  goto switch_break;
  case_125: /* CIL Label */ 
#line 242
  tokp->kind = (tok_kind )5;
#line 243
  where ++;
#line 244
  goto switch_break;
  case_40: /* CIL Label */ 
#line 246
  tokp->kind = (tok_kind )2;
#line 247
  where ++;
#line 248
  goto switch_break;
  case_41: /* CIL Label */ 
#line 250
  tokp->kind = (tok_kind )3;
#line 251
  where ++;
#line 252
  goto switch_break;
  case_60: /* CIL Label */ 
#line 254
  tokp->kind = (tok_kind )8;
#line 255
  where ++;
#line 256
  goto switch_break;
  case_62: /* CIL Label */ 
#line 258
  tokp->kind = (tok_kind )9;
#line 259
  where ++;
#line 260
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 263
  tokp->kind = (tok_kind )1;
#line 264
  findstrconst(& where, & tokp->str);
  }
#line 265
  goto switch_break;
  case_57: /* CIL Label */ 
  case_56: /* CIL Label */ 
  case_55: /* CIL Label */ 
  case_54: /* CIL Label */ 
  case_53: /* CIL Label */ 
  case_52: /* CIL Label */ 
  case_51: /* CIL Label */ 
  case_50: /* CIL Label */ 
  case_49: /* CIL Label */ 
  case_48: /* CIL Label */ 
  case_45: /* CIL Label */ 
  {
#line 278
  tokp->kind = (tok_kind )0;
#line 279
  findconst(& where, & tokp->str);
  }
#line 280
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 284
  tmp___6 = __ctype_b_loc();
  }
#line 284
  if (! ((int const   )*(*tmp___6 + (int )*where) & 1024)) {
#line 284
    if (! ((int )*where == 95)) {
      {
#line 288
      sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"illegal character in file: ");
#line 289
      tmp___4 = strlen((char const   *)(buf___0));
#line 289
      p = buf___0 + tmp___4;
#line 290
      tmp___5 = __ctype_b_loc();
      }
#line 290
      if ((int const   )*(*tmp___5 + (int )*where) & 16384) {
        {
#line 291
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%c",
                (int )*where);
        }
      } else {
        {
#line 293
        sprintf((char */* __restrict  */)p, (char const   */* __restrict  */)"%d",
                (int )*where);
        }
      }
      {
#line 295
      error(buf___0);
      }
    }
  }
  {
#line 297
  findkind(& where, tokp);
  }
#line 298
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 300
  return;
}
}
#line 304 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static void unget_token(token *tokp ) 
{ 


  {
#line 308
  lasttok = *tokp;
#line 309
  pushed = 1;
#line 310
  return;
}
}
#line 313 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static void findstrconst(char **str , char **val ) 
{ 
  char *p ;
  int size ;
  char *tmp ;
  void *tmp___0 ;

  {
#line 321
  p = *str;
  {
#line 322
  while (1) {
    while_continue: /* CIL Label */ ;
#line 323
    tmp = p;
#line 323
    p ++;
#line 322
    if (*p) {
#line 322
      if (! ((int )*p != 34)) {
#line 322
        goto while_break;
      }
    } else {
#line 322
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 325
  if ((int )*p == 0) {
    {
#line 326
    error("unterminated string constant");
    }
  }
  {
#line 328
  p ++;
#line 329
  size = (int )(p - *str);
#line 330
  tmp___0 = malloc((size_t )((unsigned int )(size + 1)));
#line 330
  *val = (char *)tmp___0;
#line 331
  strncpy((char */* __restrict  */)*val, (char const   */* __restrict  */)*str, (size_t )size);
#line 332
  *(*val + size) = (char)0;
#line 333
  *str = p;
  }
#line 334
  return;
}
}
#line 336 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static void findconst(char **str , char **val ) 
{ 
  char *p ;
  int size ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  void *tmp___1 ;

  {
#line 344
  p = *str;
#line 345
  if ((int )*p == 48) {
#line 345
    if ((int )*(p + 1) == 120) {
#line 346
      p ++;
      {
#line 347
      while (1) {
        while_continue: /* CIL Label */ ;
        {
#line 348
        p ++;
#line 347
        tmp = __ctype_b_loc();
        }
#line 347
        if (! ((int const   )*(*tmp + (int )*p) & 4096)) {
#line 347
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
    } else {
#line 345
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
    {
#line 351
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 352
      p ++;
#line 351
      tmp___0 = __ctype_b_loc();
      }
#line 351
      if (! ((int const   )*(*tmp___0 + (int )*p) & 2048)) {
#line 351
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 355
  size = (int )(p - *str);
#line 356
  tmp___1 = malloc((size_t )((unsigned int )(size + 1)));
#line 356
  *val = (char *)tmp___1;
#line 357
  strncpy((char */* __restrict  */)*val, (char const   */* __restrict  */)*str, (size_t )size);
#line 358
  *(*val + size) = (char)0;
#line 359
  *str = p;
  }
#line 360
  return;
}
}
#line 364 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static token symbols[22]  = 
#line 364
  {      {(tok_kind )15, (char *)"const"}, 
        {(tok_kind )17, (char *)"union"}, 
        {(tok_kind )18, (char *)"switch"}, 
        {(tok_kind )19, (char *)"case"}, 
        {(tok_kind )20, (char *)"default"}, 
        {(tok_kind )16, (char *)"struct"}, 
        {(tok_kind )22, (char *)"typedef"}, 
        {(tok_kind )21, (char *)"enum"}, 
        {(tok_kind )29, (char *)"opaque"}, 
        {(tok_kind )32, (char *)"bool"}, 
        {(tok_kind )33, (char *)"void"}, 
        {(tok_kind )30, (char *)"char"}, 
        {(tok_kind )23, (char *)"int"}, 
        {(tok_kind )26, (char *)"unsigned"}, 
        {(tok_kind )24, (char *)"short"}, 
        {(tok_kind )25, (char *)"long"}, 
        {(tok_kind )27, (char *)"float"}, 
        {(tok_kind )28, (char *)"double"}, 
        {(tok_kind )31, (char *)"string"}, 
        {(tok_kind )34, (char *)"program"}, 
        {(tok_kind )35, (char *)"version"}, 
        {(tok_kind )36, (char *)"??????"}};
#line 390 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static void findkind(char **mark , token *tokp ) 
{ 
  int len ;
  token *s ;
  char *str ;
  size_t tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  unsigned short const   **tmp___2 ;
  void *tmp___3 ;

  {
#line 400
  str = *mark;
#line 401
  s = symbols;
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
#line 401
    if (! ((unsigned int )s->kind != 36U)) {
#line 401
      goto while_break;
    }
    {
#line 402
    tmp = strlen((char const   *)s->str);
#line 402
    len = (int )tmp;
#line 403
    tmp___1 = strncmp((char const   *)str, (char const   *)s->str, (size_t )len);
    }
#line 403
    if (tmp___1 == 0) {
      {
#line 404
      tmp___0 = __ctype_b_loc();
      }
#line 404
      if (! ((int const   )*(*tmp___0 + (int )*(str + len)) & 8)) {
#line 404
        if ((int )*(str + len) != 95) {
#line 405
          tokp->kind = s->kind;
#line 406
          tokp->str = s->str;
#line 407
          *mark = str + len;
#line 408
          return;
        }
      }
    }
#line 401
    s ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 412
  tokp->kind = (tok_kind )0;
#line 413
  len = 0;
  {
#line 413
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 413
    tmp___2 = __ctype_b_loc();
    }
#line 413
    if (! ((int const   )*(*tmp___2 + (int )*(str + len)) & 8)) {
#line 413
      if (! ((int )*(str + len) == 95)) {
#line 413
        goto while_break___0;
      }
    }
#line 413
    len ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 414
  tmp___3 = malloc((size_t )((unsigned int )(len + 1)));
#line 414
  tokp->str = (char *)tmp___3;
#line 415
  strncpy((char */* __restrict  */)tokp->str, (char const   */* __restrict  */)str,
          (size_t )len);
#line 416
  *(tokp->str + len) = (char)0;
#line 417
  *mark = str + len;
  }
#line 418
  return;
}
}
#line 420 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static int cppline(char *line ) 
{ 
  int tmp ;

  {
#line 424
  if ((unsigned long )line == (unsigned long )(curline)) {
#line 424
    if ((int )*line == 35) {
#line 424
      tmp = 1;
    } else {
#line 424
      tmp = 0;
    }
  } else {
#line 424
    tmp = 0;
  }
#line 424
  return (tmp);
}
}
#line 427 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static int directive(char *line ) 
{ 
  int tmp ;

  {
#line 431
  if ((unsigned long )line == (unsigned long )(curline)) {
#line 431
    if ((int )*line == 37) {
#line 431
      tmp = 1;
    } else {
#line 431
      tmp = 0;
    }
  } else {
#line 431
    tmp = 0;
  }
#line 431
  return (tmp);
}
}
#line 434 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static void printdirective(char *line ) 
{ 


  {
  {
#line 438
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s", line + 1);
  }
#line 439
  return;
}
}
#line 441 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_scan.c"
static void docppline(char *line , int *lineno , char **fname ) 
{ 
  char *file ;
  int num ;
  char *p ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  size_t tmp___3 ;
  void *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
  {
#line 451
  tmp = strncmp((char const   *)line, "#line", (size_t )5);
  }
#line 451
  if (tmp == 0) {
#line 452
    line += 5;
  }
#line 455
  line ++;
  {
#line 456
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 456
    tmp___0 = __ctype_b_loc();
    }
#line 456
    if (! ((int const   )*(*tmp___0 + (int )*line) & 8192)) {
#line 456
      goto while_break;
    }
#line 457
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 459
  num = atoi((char const   *)line);
  }
  {
#line 460
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 460
    tmp___1 = __ctype_b_loc();
    }
#line 460
    if (! ((int const   )*(*tmp___1 + (int )*line) & 2048)) {
#line 460
      goto while_break___0;
    }
#line 461
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 463
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 463
    tmp___2 = __ctype_b_loc();
    }
#line 463
    if (! ((int const   )*(*tmp___2 + (int )*line) & 8192)) {
#line 463
      goto while_break___1;
    }
#line 464
    line ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 466
  if ((int )*line != 34) {
    {
#line 467
    error("preprocessor error");
    }
  }
  {
#line 469
  line ++;
#line 470
  tmp___3 = strlen((char const   *)line);
#line 470
  tmp___4 = malloc((size_t )((unsigned int )(tmp___3 + 1UL)));
#line 470
  file = (char *)tmp___4;
#line 470
  p = file;
  }
  {
#line 471
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 471
    if (*line) {
#line 471
      if (! ((int )*line != 34)) {
#line 471
        goto while_break___2;
      }
    } else {
#line 471
      goto while_break___2;
    }
#line 472
    tmp___5 = p;
#line 472
    p ++;
#line 472
    tmp___6 = line;
#line 472
    line ++;
#line 472
    *tmp___5 = *tmp___6;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 474
  if ((int )*line == 0) {
    {
#line 475
    error("preprocessor error");
    }
  }
#line 477
  *p = (char)0;
#line 478
  if ((int )*file == 0) {
#line 479
    *fname = (char *)((void *)0);
  } else {
#line 481
    *fname = file;
  }
#line 483
  *lineno = num - 1;
#line 484
  return;
}
}
#line 68 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
void storeval(list **lstp , char *val ) ;
#line 166 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.h"
definition *get_definition(void) ;
#line 51 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void isdefined(definition *defp ) ;
#line 52
static void def_struct(definition *defp ) ;
#line 52
static void def_program(definition *defp ) ;
#line 52
static void def_enum(definition *defp ) ;
#line 52
static void def_const(definition *defp ) ;
#line 52
static void def_union(definition *defp ) ;
#line 52
static void def_typedef(definition *defp ) ;
#line 52
static void get_declaration(declaration *dec , defkind dkind ) ;
#line 52
static void get_type(char **prefixp , char **typep , int *stg , defkind dkind ) ;
#line 52
static void unsigned_dec(char **typep , int *stg ) ;
#line 58 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
definition *get_definition(void) 
{ 
  definition *defp ;
  token tok ;
  void *tmp ;

  {
  {
#line 64
  tmp = malloc(sizeof(definition ));
#line 64
  defp = (definition *)tmp;
#line 65
  get_token(& tok);
  }
  {
#line 67
  if ((unsigned int )tok.kind == 16U) {
#line 67
    goto case_16;
  }
#line 70
  if ((unsigned int )tok.kind == 17U) {
#line 70
    goto case_17;
  }
#line 73
  if ((unsigned int )tok.kind == 22U) {
#line 73
    goto case_22;
  }
#line 76
  if ((unsigned int )tok.kind == 21U) {
#line 76
    goto case_21;
  }
#line 79
  if ((unsigned int )tok.kind == 34U) {
#line 79
    goto case_34;
  }
#line 82
  if ((unsigned int )tok.kind == 15U) {
#line 82
    goto case_15;
  }
#line 85
  if ((unsigned int )tok.kind == 36U) {
#line 85
    goto case_36;
  }
#line 88
  goto switch_default;
  case_16: /* CIL Label */ 
  {
#line 68
  def_struct(defp);
  }
#line 69
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 71
  def_union(defp);
  }
#line 72
  goto switch_break;
  case_22: /* CIL Label */ 
  {
#line 74
  def_typedef(defp);
  }
#line 75
  goto switch_break;
  case_21: /* CIL Label */ 
  {
#line 77
  def_enum(defp);
  }
#line 78
  goto switch_break;
  case_34: /* CIL Label */ 
  {
#line 80
  def_program(defp);
  }
#line 81
  goto switch_break;
  case_15: /* CIL Label */ 
  {
#line 83
  def_const(defp);
  }
#line 84
  goto switch_break;
  case_36: /* CIL Label */ 
#line 86
  return ((definition *)((void *)0));
#line 87
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 89
  error("definition keyword expected");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 91
  scan(14, & tok);
#line 92
  isdefined(defp);
  }
#line 93
  return (defp);
}
}
#line 96 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void isdefined(definition *defp ) 
{ 


  {
  {
#line 100
  storeval(& defined, (char *)defp);
  }
#line 101
  return;
}
}
#line 104 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void def_struct(definition *defp ) 
{ 
  token tok ;
  declaration dec ;
  decl_list *decls ;
  decl_list **tailp ;
  void *tmp ;

  {
  {
#line 113
  defp->def_kind = (defkind )1;
#line 115
  scan(0, & tok);
#line 116
  defp->def_name = tok.str;
#line 117
  scan(4, & tok);
#line 118
  tailp = & defp->def.st.decls;
  }
  {
#line 119
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 120
    get_declaration(& dec, 1);
#line 121
    tmp = malloc(sizeof(decl_list ));
#line 121
    decls = (decl_list *)tmp;
#line 122
    decls->decl = dec;
#line 123
    *tailp = decls;
#line 124
    tailp = & decls->next;
#line 125
    scan(14, & tok);
#line 126
    peek(& tok);
    }
#line 119
    if (! ((unsigned int )tok.kind != 5U)) {
#line 119
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 128
  get_token(& tok);
#line 129
  *tailp = (decl_list *)((void *)0);
  }
#line 130
  return;
}
}
#line 132 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void def_program(definition *defp ) 
{ 
  token tok ;
  version_list *vlist ;
  version_list **vtailp ;
  proc_list *plist ;
  proc_list **ptailp ;
  int dummy ;
  void *tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 143
  defp->def_kind = (defkind )5;
#line 144
  scan(0, & tok);
#line 145
  defp->def_name = tok.str;
#line 146
  scan(4, & tok);
#line 147
  vtailp = & defp->def.pr.versions;
#line 148
  scan(35, & tok);
  }
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 150
    scan(0, & tok);
#line 151
    tmp = malloc(sizeof(version_list ));
#line 151
    vlist = (version_list *)tmp;
#line 152
    vlist->vers_name = tok.str;
#line 153
    scan(4, & tok);
#line 154
    ptailp = & vlist->procs;
    }
    {
#line 155
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 156
      tmp___0 = malloc(sizeof(proc_list ));
#line 156
      plist = (proc_list *)tmp___0;
#line 157
      get_type(& plist->res_prefix, & plist->res_type, & dummy, 5);
#line 158
      tmp___1 = streq(plist->res_type, "opaque");
      }
#line 158
      if (tmp___1) {
        {
#line 159
        error("illegal result type");
        }
      }
      {
#line 161
      scan(0, & tok);
#line 162
      plist->proc_name = tok.str;
#line 163
      scan(2, & tok);
#line 164
      get_type(& plist->arg_prefix, & plist->arg_type, & dummy, 5);
#line 165
      tmp___2 = streq(plist->arg_type, "opaque");
      }
#line 165
      if (tmp___2) {
        {
#line 166
        error("illegal argument type");
        }
      }
      {
#line 168
      scan(3, & tok);
#line 169
      scan(12, & tok);
#line 170
      scan_num(& tok);
#line 171
      scan(14, & tok);
#line 172
      plist->proc_num = tok.str;
#line 173
      *ptailp = plist;
#line 174
      ptailp = & plist->next;
#line 175
      peek(& tok);
      }
#line 155
      if (! ((unsigned int )tok.kind != 5U)) {
#line 155
        goto while_break___0;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 177
    *vtailp = vlist;
#line 178
    vtailp = & vlist->next;
#line 179
    scan(5, & tok);
#line 180
    scan(12, & tok);
#line 181
    scan_num(& tok);
#line 182
    vlist->vers_num = tok.str;
#line 183
    scan(14, & tok);
#line 184
    scan2(35, 5, & tok);
    }
#line 149
    if (! ((unsigned int )tok.kind == 35U)) {
#line 149
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 186
  scan(12, & tok);
#line 187
  scan_num(& tok);
#line 188
  defp->def.pr.prog_num = tok.str;
#line 189
  *vtailp = (version_list *)((void *)0);
  }
#line 190
  return;
}
}
#line 192 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void def_enum(definition *defp ) 
{ 
  token tok ;
  enumval_list *elist ;
  enumval_list **tailp ;
  void *tmp ;

  {
  {
#line 200
  defp->def_kind = (defkind )3;
#line 201
  scan(0, & tok);
#line 202
  defp->def_name = tok.str;
#line 203
  scan(4, & tok);
#line 204
  tailp = & defp->def.en.vals;
  }
  {
#line 205
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 206
    scan(0, & tok);
#line 207
    tmp = malloc(sizeof(enumval_list ));
#line 207
    elist = (enumval_list *)tmp;
#line 208
    elist->name = tok.str;
#line 209
    elist->assignment = (char *)((void *)0);
#line 210
    scan3(11, 5, 12, & tok);
    }
#line 211
    if ((unsigned int )tok.kind == 12U) {
      {
#line 212
      scan_num(& tok);
#line 213
      elist->assignment = tok.str;
#line 214
      scan2(11, 5, & tok);
      }
    }
#line 216
    *tailp = elist;
#line 217
    tailp = & elist->next;
#line 205
    if (! ((unsigned int )tok.kind != 5U)) {
#line 205
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 219
  *tailp = (enumval_list *)((void *)0);
#line 220
  return;
}
}
#line 222 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void def_const(definition *defp ) 
{ 
  token tok ;

  {
  {
#line 228
  defp->def_kind = (defkind )0;
#line 229
  scan(0, & tok);
#line 230
  defp->def_name = tok.str;
#line 231
  scan(12, & tok);
#line 232
  scan2(0, 1, & tok);
#line 233
  defp->def.co = tok.str;
  }
#line 234
  return;
}
}
#line 236 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void def_union(definition *defp ) 
{ 
  token tok ;
  declaration dec ;
  case_list *cases ;
  case_list **tailp ;
  void *tmp ;
  void *tmp___0 ;

  {
  {
#line 245
  defp->def_kind = (defkind )2;
#line 246
  scan(0, & tok);
#line 247
  defp->def_name = tok.str;
#line 248
  scan(18, & tok);
#line 249
  scan(2, & tok);
#line 250
  get_declaration(& dec, 2);
#line 251
  defp->def.un.enum_decl = dec;
#line 252
  tailp = & defp->def.un.cases;
#line 253
  scan(3, & tok);
#line 254
  scan(4, & tok);
#line 255
  scan(19, & tok);
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! ((unsigned int )tok.kind == 19U)) {
#line 256
      goto while_break;
    }
    {
#line 257
    scan(0, & tok);
#line 258
    tmp = malloc(sizeof(case_list ));
#line 258
    cases = (case_list *)tmp;
#line 259
    cases->case_name = tok.str;
#line 260
    scan(13, & tok);
#line 261
    get_declaration(& dec, 2);
#line 262
    cases->case_decl = dec;
#line 263
    *tailp = cases;
#line 264
    tailp = & cases->next;
#line 265
    scan(14, & tok);
#line 266
    scan3(19, 20, 5, & tok);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 268
  *tailp = (case_list *)((void *)0);
#line 269
  if ((unsigned int )tok.kind == 20U) {
    {
#line 270
    scan(13, & tok);
#line 271
    get_declaration(& dec, 2);
#line 272
    tmp___0 = malloc(sizeof(declaration ));
#line 272
    defp->def.un.default_decl = (declaration *)tmp___0;
#line 273
    *(defp->def.un.default_decl) = dec;
#line 274
    scan(14, & tok);
#line 275
    scan(5, & tok);
    }
  } else {
#line 277
    defp->def.un.default_decl = (declaration *)((void *)0);
  }
#line 279
  return;
}
}
#line 282 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void def_typedef(definition *defp ) 
{ 
  declaration dec ;

  {
  {
#line 288
  defp->def_kind = (defkind )4;
#line 289
  get_declaration(& dec, 4);
#line 290
  defp->def_name = dec.name;
#line 291
  defp->def.ty.old_prefix = dec.prefix;
#line 292
  defp->def.ty.old_type = dec.type;
#line 293
  defp->def.ty.old_storage = dec.storage;
#line 294
  strncpy(defp->def.ty.old_pstorage, dec.pstorage, 128);
#line 295
  defp->def.ty.rel = dec.rel;
#line 296
  defp->def.ty.array_max = dec.array_max;
  }
#line 297
  return;
}
}
#line 300 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void get_declaration(declaration *dec , defkind dkind ) 
{ 
  token tok ;
  int count ;
  int tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 308
  get_type(& dec->prefix, & dec->type, & dec->storage, (unsigned int )dkind);
#line 309
  dec->rel = (relation )4;
#line 310
  dec->pstorage[0] = (char )'\000';
#line 311
  tmp = streq(dec->type, "void");
  }
#line 311
  if (tmp) {
#line 312
    return;
  }
  {
#line 314
  scan2(10, 0, & tok);
  }
#line 315
  if ((unsigned int )tok.kind == 10U) {
    {
#line 316
    dec->rel = (relation )3;
#line 317
    scan(0, & tok);
    }
  }
  {
#line 319
  dec->name = tok.str;
#line 320
  tmp___3 = peekscan(6, & tok);
  }
#line 320
  if (tmp___3) {
#line 321
    if ((unsigned int )dec->rel == 3U) {
      {
#line 322
      error("no array-of-pointer declarations -- use typedef");
      }
    }
    {
#line 324
    dec->rel = (relation )0;
#line 325
    scan_num(& tok);
#line 326
    tmp___0 = __ctype_b_loc();
    }
#line 326
    if ((int const   )*(*tmp___0 + (int )*(tok.str)) & 2048) {
      {
#line 327
      dec->rel = (relation )0;
#line 328
      count = atoi((char const   *)tok.str);
#line 329
      dec->storage *= count;
      }
    } else {
#line 332
      dec->rel = (relation )2;
    }
    {
#line 334
    dec->array_max = tok.str;
#line 335
    scan(7, & tok);
    }
  } else {
    {
#line 336
    tmp___2 = peekscan(8, & tok);
    }
#line 336
    if (tmp___2) {
#line 337
      if ((unsigned int )dec->rel == 3U) {
        {
#line 338
        error("no array-of-pointer declarations -- use typedef");
        }
      }
      {
#line 340
      dec->rel = (relation )1;
#line 341
      tmp___1 = peekscan(9, & tok);
      }
#line 341
      if (tmp___1) {
#line 342
        dec->array_max = (char *)"~0";
      } else {
        {
#line 344
        scan_num(& tok);
#line 345
        dec->array_max = tok.str;
#line 346
        scan(9, & tok);
        }
      }
    }
  }
  {
#line 349
  tmp___5 = streq(dec->type, "opaque");
  }
#line 349
  if (tmp___5) {
#line 350
    if ((unsigned int )dec->rel != 1U) {
#line 350
      if ((unsigned int )dec->rel != 0U) {
        {
#line 351
        error("array declaration expected");
        }
      }
    }
  } else {
    {
#line 353
    tmp___4 = streq(dec->type, "string");
    }
#line 353
    if (tmp___4) {
#line 354
      if ((unsigned int )dec->rel != 1U) {
        {
#line 355
        error("variable-length array declaration expected");
        }
      }
    }
  }
#line 358
  return;
}
}
#line 361 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void get_type(char **prefixp , char **typep , int *stg , defkind dkind ) 
{ 
  token tok ;

  {
  {
#line 369
  *stg = -1;
#line 371
  *prefixp = (char *)((void *)0);
#line 372
  get_token(& tok);
  }
  {
#line 374
  if ((unsigned int )tok.kind == 0U) {
#line 374
    goto case_0;
  }
#line 379
  if ((unsigned int )tok.kind == 17U) {
#line 379
    goto case_17;
  }
#line 379
  if ((unsigned int )tok.kind == 21U) {
#line 379
    goto case_17;
  }
#line 379
  if ((unsigned int )tok.kind == 16U) {
#line 379
    goto case_17;
  }
#line 384
  if ((unsigned int )tok.kind == 26U) {
#line 384
    goto case_26;
  }
#line 387
  if ((unsigned int )tok.kind == 24U) {
#line 387
    goto case_24;
  }
#line 392
  if ((unsigned int )tok.kind == 25U) {
#line 392
    goto case_25;
  }
#line 397
  if ((unsigned int )tok.kind == 33U) {
#line 397
    goto case_33;
  }
#line 406
  if ((unsigned int )tok.kind == 32U) {
#line 406
    goto case_32;
  }
#line 406
  if ((unsigned int )tok.kind == 30U) {
#line 406
    goto case_32;
  }
#line 406
  if ((unsigned int )tok.kind == 29U) {
#line 406
    goto case_32;
  }
#line 406
  if ((unsigned int )tok.kind == 31U) {
#line 406
    goto case_32;
  }
#line 410
  if ((unsigned int )tok.kind == 27U) {
#line 410
    goto case_27;
  }
#line 414
  if ((unsigned int )tok.kind == 28U) {
#line 414
    goto case_28;
  }
#line 418
  if ((unsigned int )tok.kind == 23U) {
#line 418
    goto case_23;
  }
#line 422
  goto switch_default;
  case_0: /* CIL Label */ 
#line 375
  *typep = tok.str;
#line 376
  goto switch_break;
  case_17: /* CIL Label */ 
  case_21: /* CIL Label */ 
  case_16: /* CIL Label */ 
  {
#line 380
  *prefixp = tok.str;
#line 381
  scan(0, & tok);
#line 382
  *typep = tok.str;
  }
#line 383
  goto switch_break;
  case_26: /* CIL Label */ 
  {
#line 385
  unsigned_dec(typep, stg);
  }
#line 386
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 388
  *typep = (char *)"byte_short";
#line 389
  *stg = 2;
#line 390
  peekscan(23, & tok);
  }
#line 391
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 393
  *typep = (char *)"byte_long";
#line 394
  *stg = 4;
#line 395
  peekscan(23, & tok);
  }
#line 396
  goto switch_break;
  case_33: /* CIL Label */ 
#line 398
  if ((unsigned int )dkind != 2U) {
#line 398
    if ((unsigned int )dkind != 5U) {
      {
#line 399
      error("voids allowed only inside union and program definitions");
      }
    }
  }
#line 401
  *typep = tok.str;
#line 402
  goto switch_break;
  case_32: /* CIL Label */ 
  case_30: /* CIL Label */ 
  case_29: /* CIL Label */ 
  case_31: /* CIL Label */ 
#line 407
  *typep = tok.str;
#line 408
  *stg = 1;
#line 409
  goto switch_break;
  case_27: /* CIL Label */ 
#line 411
  *typep = (char *)"byte_float";
#line 412
  *stg = 4;
#line 413
  goto switch_break;
  case_28: /* CIL Label */ 
#line 415
  *typep = (char *)"byte_double";
#line 416
  *stg = 8;
#line 417
  goto switch_break;
  case_23: /* CIL Label */ 
#line 419
  *typep = (char *)"byte_int";
#line 420
  *stg = 4;
#line 421
  goto switch_break;
  switch_default: /* CIL Label */ 
  {
#line 423
  error("expected type specifier");
  }
  switch_break: /* CIL Label */ ;
  }
#line 425
  return;
}
}
#line 428 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_parse.c"
static void unsigned_dec(char **typep , int *stg ) 
{ 
  token tok ;

  {
  {
#line 435
  peek(& tok);
  }
  {
#line 437
  if ((unsigned int )tok.kind == 30U) {
#line 437
    goto case_30;
  }
#line 442
  if ((unsigned int )tok.kind == 24U) {
#line 442
    goto case_24;
  }
#line 448
  if ((unsigned int )tok.kind == 25U) {
#line 448
    goto case_25;
  }
#line 454
  if ((unsigned int )tok.kind == 23U) {
#line 454
    goto case_23;
  }
#line 459
  goto switch_default;
  case_30: /* CIL Label */ 
  {
#line 438
  get_token(& tok);
#line 439
  *typep = (char *)"byte_u_char";
#line 440
  *stg = 1;
  }
#line 441
  goto switch_break;
  case_24: /* CIL Label */ 
  {
#line 443
  get_token(& tok);
#line 444
  *typep = (char *)"byte_u_short";
#line 445
  *stg = 2;
#line 446
  peekscan(23, & tok);
  }
#line 447
  goto switch_break;
  case_25: /* CIL Label */ 
  {
#line 449
  get_token(& tok);
#line 450
  *typep = (char *)"byte_u_long";
#line 451
  *stg = 4;
#line 452
  peekscan(23, & tok);
  }
#line 453
  goto switch_break;
  case_23: /* CIL Label */ 
  {
#line 455
  get_token(& tok);
#line 456
  *typep = (char *)"byte_u_int";
#line 457
  *stg = 4;
  }
#line 458
  goto switch_break;
  switch_default: /* CIL Label */ 
#line 460
  *typep = (char *)"byte_u_int";
#line 461
  *stg = 4;
#line 462
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 464
  return;
}
}
#line 515 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) abort)(void) ;
#line 40 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void pconstdef(definition *def ) ;
#line 40
static void pstructdef(definition *def ) ;
#line 40
static void puniondef(definition *def ) ;
#line 40
static void pdefine(char *name , char *num ) ;
#line 40
static void pprogramdef(definition *def ) ;
#line 40
static void penumdef(definition *def ) ;
#line 40
static void ptypedef(definition *def ) ;
#line 40
static void pdeclaration(char *name , declaration *dec , int tab ) ;
#line 43
static int undefined2(char *type , char *stop ) ;
#line 45
void pprocdef(proc_list *proc , version_list *vp ) ;
#line 78 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
char *fixtype(char *type ) ;
#line 88
void tabify(FILE *f , int tab ) ;
#line 100
void print_datadef(definition *def ) ;
#line 60 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
void print_datadef(definition *def ) 
{ 


  {
#line 64
  if ((unsigned int )def->def_kind != 0U) {
    {
#line 65
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
    }
  }
  {
#line 68
  if ((unsigned int )def->def_kind == 1U) {
#line 68
    goto case_1;
  }
#line 71
  if ((unsigned int )def->def_kind == 2U) {
#line 71
    goto case_2;
  }
#line 74
  if ((unsigned int )def->def_kind == 3U) {
#line 74
    goto case_3;
  }
#line 77
  if ((unsigned int )def->def_kind == 4U) {
#line 77
    goto case_4;
  }
#line 80
  if ((unsigned int )def->def_kind == 5U) {
#line 80
    goto case_5;
  }
#line 83
  if ((unsigned int )def->def_kind == 0U) {
#line 83
    goto case_0;
  }
#line 67
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 69
  pstructdef(def);
  }
#line 70
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 72
  puniondef(def);
  }
#line 73
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 75
  penumdef(def);
  }
#line 76
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 78
  ptypedef(def);
  }
#line 79
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 81
  pprogramdef(def);
  }
#line 82
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 84
  pconstdef(def);
  }
#line 85
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
#line 87
  if ((unsigned int )def->def_kind != 5U) {
#line 87
    if ((unsigned int )def->def_kind != 0U) {
      {
#line 88
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"bool_t xdr_%s (XDR *, %s *);\n",
              def->def_name, def->def_name);
      }
    }
  }
#line 91
  if ((unsigned int )def->def_kind != 0U) {
    {
#line 92
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n");
    }
  }
#line 94
  return;
}
}
#line 96 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void pconstdef(definition *def ) 
{ 


  {
  {
#line 100
  pdefine(def->def_name, def->def.co);
  }
#line 101
  return;
}
}
#line 103 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void pstructdef(definition *def ) 
{ 
  decl_list *l ;
  char *name ;

  {
  {
#line 108
  name = def->def_name;
#line 110
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"struct %s {\n",
          name);
#line 111
  l = def->def.st.decls;
  }
  {
#line 111
  while (1) {
    while_continue: /* CIL Label */ ;
#line 111
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 111
      goto while_break;
    }
    {
#line 112
    pdeclaration(name, & l->decl, 1);
#line 111
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"};\n");
#line 115
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"typedef struct %s %s;\n",
          name, name);
  }
#line 116
  return;
}
}
#line 118 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void puniondef(definition *def ) 
{ 
  case_list *l ;
  char *name ;
  declaration *decl ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 123
  name = def->def_name;
#line 126
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"struct %s {\n",
          name);
#line 127
  decl = & def->def.un.enum_decl;
#line 128
  tmp = streq(decl->type, "bool");
  }
#line 128
  if (tmp) {
    {
#line 129
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tbool_t %s;\n",
            decl->name);
    }
  } else {
    {
#line 131
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t%s %s;\n",
            decl->type, decl->name);
    }
  }
  {
#line 133
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tunion {\n");
#line 134
  l = def->def.un.cases;
  }
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
#line 134
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 134
      goto while_break;
    }
    {
#line 135
    pdeclaration(name, & l->case_decl, 2);
#line 134
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 137
  decl = def->def.un.default_decl;
#line 138
  if (decl) {
    {
#line 138
    tmp___0 = streq(decl->type, "void");
    }
#line 138
    if (! tmp___0) {
      {
#line 139
      pdeclaration(name, decl, 2);
      }
    }
  }
  {
#line 141
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t} %s_u;\n",
          name);
#line 142
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"};\n");
#line 143
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"typedef struct %s %s;\n",
          name, name);
  }
#line 144
  return;
}
}
#line 148 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void pdefine(char *name , char *num ) 
{ 


  {
  {
#line 153
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#define %s %s\n",
          name, num);
  }
#line 154
  return;
}
}
#line 156 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void puldefine(char *name , char *num ) 
{ 


  {
  {
#line 161
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#define %s ((u_long)%s)\n",
          name, num);
  }
#line 162
  return;
}
}
#line 164 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static int define_printed(proc_list *stop , version_list *start ) 
{ 
  version_list *vers ;
  proc_list *proc ;
  int tmp ;

  {
#line 172
  vers = start;
  {
#line 172
  while (1) {
    while_continue: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )vers != (unsigned long )((void *)0))) {
#line 172
      goto while_break;
    }
#line 173
    proc = vers->procs;
    {
#line 173
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 173
      if (! ((unsigned long )proc != (unsigned long )((void *)0))) {
#line 173
        goto while_break___0;
      }
#line 174
      if ((unsigned long )proc == (unsigned long )stop) {
#line 175
        return (0);
      } else {
        {
#line 176
        tmp = streq(proc->proc_name, stop->proc_name);
        }
#line 176
        if (tmp) {
#line 177
          return (1);
        }
      }
#line 173
      proc = proc->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 172
    vers = vers->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  abort();
  }
}
}
#line 185 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void pprogramdef(definition *def ) 
{ 
  version_list *vers ;
  proc_list *proc ;
  int tmp ;

  {
  {
#line 192
  puldefine(def->def_name, def->def.pr.prog_num);
#line 193
  vers = def->def.pr.versions;
  }
  {
#line 193
  while (1) {
    while_continue: /* CIL Label */ ;
#line 193
    if (! ((unsigned long )vers != (unsigned long )((void *)0))) {
#line 193
      goto while_break;
    }
    {
#line 194
    puldefine(vers->vers_name, vers->vers_num);
#line 195
    proc = vers->procs;
    }
    {
#line 195
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 195
      if (! ((unsigned long )proc != (unsigned long )((void *)0))) {
#line 195
        goto while_break___0;
      }
      {
#line 196
      tmp = define_printed(proc, def->def.pr.versions);
      }
#line 196
      if (! tmp) {
        {
#line 197
        puldefine(proc->proc_name, proc->proc_num);
        }
      }
      {
#line 199
      pprocdef(proc, vers);
#line 195
      proc = proc->next;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 193
    vers = vers->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 202
  return;
}
}
#line 204 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
void pprocdef(proc_list *proc , version_list *vp ) 
{ 
  int tmp ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 209
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"extern ");
  }
#line 210
  if (proc->res_prefix) {
    {
#line 211
    tmp = streq(proc->res_prefix, "enum");
    }
#line 211
    if (tmp) {
      {
#line 212
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"enum ");
      }
    } else {
      {
#line 214
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"struct ");
      }
    }
  }
  {
#line 217
  tmp___2 = streq(proc->res_type, "bool");
  }
#line 217
  if (tmp___2) {
    {
#line 218
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"bool_t *");
    }
  } else {
    {
#line 219
    tmp___1 = streq(proc->res_type, "string");
    }
#line 219
    if (tmp___1) {
      {
#line 220
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"char **");
      }
    } else {
      {
#line 222
      tmp___0 = fixtype(proc->res_type);
#line 222
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s *",
              tmp___0);
      }
    }
  }
  {
#line 224
  pvname(proc->proc_name, vp->vers_num);
#line 225
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"();\n");
  }
#line 226
  return;
}
}
#line 228 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void penumdef(definition *def ) 
{ 
  char *name ;
  enumval_list *l ;
  char *last ;
  int count ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 232
  name = def->def_name;
#line 234
  last = (char *)((void *)0);
#line 235
  count = 0;
#line 237
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"enum %s {\n",
          name);
#line 238
  l = def->def.en.vals;
  }
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 238
      goto while_break;
    }
    {
#line 239
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t%s",
            l->name);
    }
#line 240
    if (l->assignment) {
      {
#line 241
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" = %s",
              l->assignment);
#line 242
      last = l->assignment;
#line 243
      count = 1;
      }
    } else
#line 245
    if ((unsigned long )last == (unsigned long )((void *)0)) {
      {
#line 246
      tmp = count;
#line 246
      count ++;
#line 246
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" = %d",
              tmp);
      }
    } else {
      {
#line 248
      tmp___0 = count;
#line 248
      count ++;
#line 248
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)" = %s + %d",
              last, tmp___0);
      }
    }
    {
#line 251
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)",\n");
#line 238
    l = l->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 253
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"};\n");
#line 254
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"typedef enum %s %s;\n",
          name, name);
  }
#line 255
  return;
}
}
#line 257 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void ptypedef(definition *def ) 
{ 
  char *name ;
  char *old ;
  char prefix[8] ;
  relation rel ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 261
  name = def->def_name;
#line 262
  old = def->def.ty.old_type;
#line 264
  rel = def->def.ty.rel;
#line 266
  tmp = strncmp((char const   *)old, "byte_", (size_t )5);
  }
#line 266
  if (tmp == 0) {
#line 267
    old += 5;
  }
  {
#line 270
  tmp___4 = streq(name, old);
  }
#line 270
  if (! tmp___4) {
    {
#line 271
    tmp___2 = streq(old, "string");
    }
#line 271
    if (tmp___2) {
#line 272
      old = (char *)"char";
#line 273
      rel = (relation )3;
    } else {
      {
#line 274
      tmp___1 = streq(old, "opaque");
      }
#line 274
      if (tmp___1) {
#line 275
        old = (char *)"char";
      } else {
        {
#line 276
        tmp___0 = streq(old, "bool");
        }
#line 276
        if (tmp___0) {
#line 277
          old = (char *)"bool_t";
        }
      }
    }
    {
#line 279
    tmp___3 = undefined2(old, name);
    }
#line 279
    if (tmp___3) {
#line 279
      if (def->def.ty.old_prefix) {
        {
#line 280
        sprintf((char */* __restrict  */)(prefix), (char const   */* __restrict  */)"%s ",
                def->def.ty.old_prefix);
        }
      } else {
#line 282
        prefix[0] = (char)0;
      }
    } else {
#line 282
      prefix[0] = (char)0;
    }
    {
#line 284
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"typedef ");
    }
    {
#line 286
    if ((unsigned int )rel == 1U) {
#line 286
      goto case_1;
    }
#line 292
    if ((unsigned int )rel == 2U) {
#line 292
      goto case_2;
    }
#line 295
    if ((unsigned int )rel == 3U) {
#line 295
      goto case_3;
    }
#line 298
    if ((unsigned int )rel == 0U) {
#line 298
      goto case_0;
    }
#line 302
    if ((unsigned int )rel == 4U) {
#line 302
      goto case_4;
    }
#line 285
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 287
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"struct {\n");
#line 288
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tu_int %s_len;\n",
            name);
#line 289
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t%s%s *%s_val;\n",
            prefix, old, name);
#line 290
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"} %s",
            name);
    }
#line 291
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 293
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s *%s\n",
            prefix, name);
    }
#line 294
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 296
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s%s *%s",
            prefix, old, name);
    }
#line 297
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 299
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s%s %s[%s]",
            prefix, old, name, def->def.ty.array_max);
    }
#line 301
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 303
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s%s %s",
            prefix, old, name);
    }
#line 304
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
    {
#line 306
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)";\n");
    }
  }
#line 308
  return;
}
}
#line 311 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static void pdeclaration(char *name , declaration *dec , int tab ) 
{ 
  char buf___0[8] ;
  char *prefix ;
  char *type ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 321
  tmp = streq(dec->type, "void");
  }
#line 321
  if (tmp) {
#line 322
    return;
  }
  {
#line 324
  tabify(fout, tab);
#line 325
  tmp___0 = streq(dec->type, name);
  }
#line 325
  if (tmp___0) {
#line 325
    if (! dec->prefix) {
      {
#line 326
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"struct ");
      }
    }
  }
  {
#line 328
  tmp___4 = streq(dec->type, "string");
  }
#line 328
  if (tmp___4) {
    {
#line 329
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"char *%s",
            dec->name);
    }
  } else {
    {
#line 331
    prefix = (char *)"";
#line 332
    tmp___3 = streq(dec->type, "bool");
    }
#line 332
    if (tmp___3) {
#line 333
      type = (char *)"bool_t";
    } else {
      {
#line 334
      tmp___2 = streq(dec->type, "opaque");
      }
#line 334
      if (tmp___2) {
#line 335
        type = (char *)"char";
      } else {
#line 337
        if (dec->prefix) {
          {
#line 338
          sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%s ",
                  dec->prefix);
#line 339
          prefix = buf___0;
          }
        }
        {
#line 341
        tmp___1 = strncmp((char const   *)dec->type, "byte_", (size_t )5);
        }
#line 341
        if (tmp___1 == 0) {
#line 342
          type = dec->type + 5;
        } else {
#line 345
          type = dec->type;
        }
      }
    }
    {
#line 349
    if ((unsigned int )dec->rel == 4U) {
#line 349
      goto case_4;
    }
#line 352
    if ((unsigned int )dec->rel == 0U) {
#line 352
      goto case_0;
    }
#line 356
    if ((unsigned int )dec->rel == 3U) {
#line 356
      goto case_3;
    }
#line 359
    if ((unsigned int )dec->rel == 1U) {
#line 359
      goto case_1;
    }
#line 368
    if ((unsigned int )dec->rel == 2U) {
#line 368
      goto case_2;
    }
#line 348
    goto switch_break;
    case_4: /* CIL Label */ 
    {
#line 350
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s%s %s",
            prefix, type, dec->name);
    }
#line 351
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 353
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s%s %s[%s]",
            prefix, type, dec->name, dec->array_max);
    }
#line 355
    goto switch_break;
    case_3: /* CIL Label */ 
    {
#line 357
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s%s *%s",
            prefix, type, dec->name);
    }
#line 358
    goto switch_break;
    case_1: /* CIL Label */ 
    {
#line 360
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"struct {\n");
#line 361
    tabify(fout, tab);
#line 362
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tu_int %s_len;\n",
            dec->name);
#line 363
    tabify(fout, tab);
#line 364
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t%s%s *%s_val;\n",
            prefix, type, dec->name);
#line 365
    tabify(fout, tab);
#line 366
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"} %s",
            dec->name);
    }
#line 367
    goto switch_break;
    case_2: /* CIL Label */ 
    {
#line 369
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s%s *%s",
            prefix, type, dec->name);
    }
#line 370
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
  }
  {
#line 373
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)";\n");
  }
#line 374
  return;
}
}
#line 378 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_hout.c"
static int undefined2(char *type , char *stop ) 
{ 
  list *l ;
  definition *def ;
  int tmp ;
  int tmp___0 ;

  {
#line 386
  l = defined;
  {
#line 386
  while (1) {
    while_continue: /* CIL Label */ ;
#line 386
    if (! ((unsigned long )l != (unsigned long )((void *)0))) {
#line 386
      goto while_break;
    }
#line 387
    def = (definition *)l->val;
#line 388
    if ((unsigned int )def->def_kind != 5U) {
      {
#line 389
      tmp___0 = streq(def->def_name, stop);
      }
#line 389
      if (tmp___0) {
#line 390
        return (1);
      } else {
        {
#line 391
        tmp = streq(def->def_name, type);
        }
#line 391
        if (tmp) {
#line 392
          return (0);
        }
      }
    }
#line 386
    l = l->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 396
  return (1);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 170
extern struct _IO_FILE *stderr ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 846
extern void perror(char const   *__s ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 417
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) pipe)(int *__pipedes ) ;
#line 534
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) dup2)(int __fd ,
                                                                           int __fd2 ) ;
#line 573
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execl)(char const   *__path ,
                                                                                              char const   *__arg 
                                                                                              , ...) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 89 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
void record_open(char *file ) ;
#line 95
void emit(definition *def ) ;
#line 483 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 69 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static char *cmdname  ;
#line 77 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static char CPP[9]  = 
#line 77
  {      (char )'/',      (char )'l',      (char )'i',      (char )'b', 
        (char )'/',      (char )'c',      (char )'p',      (char )'p', 
        (char )'\000'};
#line 81 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static char CPPFLAGS[3]  = {      (char )'-',      (char )'C',      (char )'\000'};
#line 84 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static char *allv[5]  = {      (char *)"rpcgen",      (char *)"-s",      (char *)"udp",      (char *)"-s", 
        (char *)"tcp"};
#line 88 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static int allc  =    (int )(sizeof(allv) / sizeof(allv[0]));
#line 91
static void h_output(char *infile , char *define , int extend , char *outfile ) ;
#line 91
static void c_output(char *infile , char *define , int extend , char *outfile ) ;
#line 91
static void s_output(int argc , char **argv , char *infile , char *define , int extend ,
                     char *outfile , int nomain ) ;
#line 91
static void l_output(char *infile , char *define , int extend , char *outfile ) ;
#line 91
static void do_registers(int argc , char **argv ) ;
#line 92
static int parseargs(int argc , char **argv , struct commandline *cmd ) ;
#line 93
void reinitialize(void) ;
#line 93
void crash(void) ;
#line 94
static void open_output(char *infile , char *outfile ) ;
#line 96 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
int main(int argc , char **argv ) 
{ 
  struct commandline cmd ;
  int tmp ;

  {
  {
#line 103
  tmp = parseargs(argc, argv, & cmd);
  }
#line 103
  if (! tmp) {
    {
#line 104
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"usage: %s infile\n",
            cmdname);
#line 106
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       %s [-c | -h | -l | -m] [-o outfile] [infile]\n",
            cmdname);
#line 109
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"       %s [-s udp|tcp]* [-o outfile] [infile]\n",
            cmdname);
#line 112
    exit(1);
    }
  }
#line 135
  if (cmd.cflag) {
    {
#line 136
    c_output(cmd.infile, "-DRPC_XDR", 0, cmd.outfile);
    }
  } else
#line 137
  if (cmd.hflag) {
    {
#line 138
    h_output(cmd.infile, "-DRPC_HDR", 0, cmd.outfile);
    }
  } else
#line 139
  if (cmd.lflag) {
    {
#line 140
    l_output(cmd.infile, "-DRPC_CLNT", 0, cmd.outfile);
    }
  } else
#line 141
  if (cmd.sflag) {
    {
#line 142
    s_output(argc, argv, cmd.infile, "-DRPC_SVC", 0, cmd.outfile, cmd.mflag);
    }
  } else
#line 141
  if (cmd.mflag) {
    {
#line 142
    s_output(argc, argv, cmd.infile, "-DRPC_SVC", 0, cmd.outfile, cmd.mflag);
    }
  } else {
    {
#line 145
    c_output(cmd.infile, "-DRPC_XDR", 1, "_xdr.c");
#line 146
    reinitialize();
#line 147
    h_output(cmd.infile, "-DRPC_HDR", 1, ".h");
#line 148
    reinitialize();
#line 149
    l_output(cmd.infile, "-DRPC_CLNT", 1, "_clnt.c");
#line 150
    reinitialize();
#line 151
    s_output(allc, allv, cmd.infile, "-DRPC_SVC", 1, "_svc.c", cmd.mflag);
    }
  }
  {
#line 155
  exit(0);
  }
#line 156
  return (0);
}
}
#line 162 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static char *extendfile(char *path , char *ext ) 
{ 
  char *file ;
  char *res ;
  char *p ;
  char *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  size_t tmp___4 ;

  {
  {
#line 171
  tmp = strrchr((char const   *)path, '/');
#line 171
  file = tmp;
  }
#line 171
  if ((unsigned long )file == (unsigned long )((void *)0)) {
#line 172
    file = path;
  } else {
#line 174
    file ++;
  }
  {
#line 176
  tmp___0 = strlen((char const   *)file);
#line 176
  tmp___1 = strlen((char const   *)ext);
#line 176
  tmp___2 = malloc((size_t )((unsigned int )((tmp___0 + tmp___1) + 1UL)));
#line 176
  res = (char *)tmp___2;
  }
#line 177
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 178
    abort();
    }
  }
  {
#line 180
  tmp___3 = strrchr((char const   *)file, '.');
#line 180
  p = tmp___3;
  }
#line 181
  if ((unsigned long )p == (unsigned long )((void *)0)) {
    {
#line 182
    tmp___4 = strlen((char const   *)file);
#line 182
    p = file + tmp___4;
    }
  }
  {
#line 184
  strcpy((char */* __restrict  */)res, (char const   */* __restrict  */)file);
#line 185
  strcpy((char */* __restrict  */)(res + (p - file)), (char const   */* __restrict  */)ext);
  }
#line 186
  return (res);
}
}
#line 192 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static void open_output(char *infile , char *outfile ) 
{ 
  int tmp ;

  {
#line 197
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
#line 198
    fout = stdout;
#line 199
    return;
  }
#line 201
  if ((unsigned long )infile != (unsigned long )((void *)0)) {
    {
#line 201
    tmp = streq(outfile, infile);
    }
#line 201
    if (tmp) {
      {
#line 202
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: output would overwrite %s\n",
              cmdname, infile);
#line 204
      crash();
      }
    }
  }
  {
#line 206
  fout = fopen((char const   */* __restrict  */)outfile, (char const   */* __restrict  */)"w");
  }
#line 207
  if ((unsigned long )fout == (unsigned long )((void *)0)) {
    {
#line 208
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: unable to open ",
            cmdname);
#line 209
    perror((char const   *)outfile);
#line 210
    crash();
    }
  }
  {
#line 212
  record_open(outfile);
  }
#line 213
  return;
}
}
#line 218 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static void open_input(char *infile , char *define ) 
{ 
  int pd[2] ;
  __pid_t tmp ;

  {
#line 228
  if ((unsigned long )infile == (unsigned long )((void *)0)) {
#line 228
    infilename = (char *)"<stdin>";
  } else {
#line 228
    infilename = infile;
  }
  {
#line 247
  pipe((int *)(pd));
#line 248
  tmp = fork();
  }
  {
#line 249
  if (tmp == 0) {
#line 249
    goto case_0;
  }
#line 256
  if (tmp == -1) {
#line 256
    goto case_neg_1;
  }
#line 248
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 250
  close(1);
#line 251
  dup2(pd[1], 1);
#line 252
  close(pd[0]);
#line 253
  execl((char const   *)(CPP), (char const   *)(CPP), CPPFLAGS, define, infile, (void *)0);
#line 254
  perror("execl");
#line 255
  exit(1);
  }
  case_neg_1: /* CIL Label */ 
  {
#line 257
  perror("fork");
#line 258
  exit(1);
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 260
  close(pd[1]);
#line 262
  fin = fdopen(pd[0], "r");
  }
#line 263
  if ((unsigned long )fin == (unsigned long )((void *)0)) {
    {
#line 264
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            cmdname);
#line 265
    perror((char const   *)infilename);
#line 266
    crash();
    }
  }
#line 268
  return;
}
}
#line 273 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static void c_output(char *infile , char *define , int extend , char *outfile ) 
{ 
  definition *def ;
  char *include ;
  char *outfilename ;
  long tell ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 285
  open_input(infile, define);
  }
#line 286
  if (extend) {
    {
#line 286
    tmp = extendfile(infile, outfile);
#line 286
    outfilename = tmp;
    }
  } else {
#line 286
    outfilename = outfile;
  }
  {
#line 287
  open_output(infile, outfilename);
#line 289
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#include <rpc/rpc.h>\n");
  }
#line 291
  if (infile) {
    {
#line 291
    include = extendfile(infile, (char *)".h");
    }
#line 291
    if (include) {
      {
#line 292
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#include \"%s\"\n",
              include);
#line 293
      free((void *)include);
      }
    }
  }
  {
#line 295
  tell = ftell(fout);
  }
  {
#line 296
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 296
    def = get_definition();
    }
#line 296
    if (! def) {
#line 296
      goto while_break;
    }
    {
#line 297
    emit(def);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 299
  if (extend) {
    {
#line 299
    tmp___0 = ftell(fout);
    }
#line 299
    if (tell == tmp___0) {
      {
#line 300
      unlink((char const   *)outfilename);
      }
    }
  }
#line 302
  return;
}
}
#line 307 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static void h_output(char *infile , char *define , int extend , char *outfile ) 
{ 
  definition *def ;
  char *outfilename ;
  long tell ;
  char *tmp ;
  long tmp___0 ;

  {
  {
#line 318
  open_input(infile, define);
  }
#line 319
  if (extend) {
    {
#line 319
    tmp = extendfile(infile, outfile);
#line 319
    outfilename = tmp;
    }
  } else {
#line 319
    outfilename = outfile;
  }
  {
#line 320
  open_output(infile, outfilename);
#line 321
  tell = ftell(fout);
#line 322
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#include <rpc/xdr.h>\n\n");
  }
  {
#line 323
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 323
    def = get_definition();
    }
#line 323
    if (! def) {
#line 323
      goto while_break;
    }
    {
#line 324
    print_datadef(def);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 326
  if (extend) {
    {
#line 326
    tmp___0 = ftell(fout);
    }
#line 326
    if (tell == tmp___0) {
      {
#line 327
      unlink((char const   *)outfilename);
      }
    }
  }
#line 329
  return;
}
}
#line 334 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static void s_output(int argc , char **argv , char *infile , char *define , int extend ,
                     char *outfile , int nomain ) 
{ 
  char *include ;
  definition *def ;
  int foundprogram ;
  char *outfilename ;
  char *tmp ;

  {
  {
#line 349
  open_input(infile, define);
  }
#line 350
  if (extend) {
    {
#line 350
    tmp = extendfile(infile, outfile);
#line 350
    outfilename = tmp;
    }
  } else {
#line 350
    outfilename = outfile;
  }
  {
#line 351
  open_output(infile, outfilename);
#line 352
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#include <stdio.h>\n");
#line 354
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#include <rpc/rpc.h>\n");
  }
#line 356
  if (infile) {
    {
#line 356
    include = extendfile(infile, (char *)".h");
    }
#line 356
    if (include) {
      {
#line 357
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#include \"%s\"\n",
              include);
#line 358
      free((void *)include);
      }
    }
  }
#line 360
  foundprogram = 0;
  {
#line 361
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 361
    def = get_definition();
    }
#line 361
    if (! def) {
#line 361
      goto while_break;
    }
#line 362
    foundprogram |= (unsigned int )def->def_kind == 5U;
  }
  while_break: /* CIL Label */ ;
  }
#line 364
  if (extend) {
#line 364
    if (! foundprogram) {
      {
#line 365
      unlink((char const   *)outfilename);
      }
#line 366
      return;
    }
  }
#line 368
  if (nomain) {
    {
#line 369
    write_programs((char *)((void *)0));
    }
  } else {
    {
#line 371
    write_most();
#line 372
    do_registers(argc, argv);
#line 373
    write_rest();
#line 374
    write_programs("static");
    }
  }
#line 376
  return;
}
}
#line 378 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static void l_output(char *infile , char *define , int extend , char *outfile ) 
{ 
  char *include ;
  definition *def ;
  int foundprogram ;
  char *outfilename ;
  char *tmp ;

  {
  {
#line 390
  open_input(infile, define);
  }
#line 391
  if (extend) {
    {
#line 391
    tmp = extendfile(infile, outfile);
#line 391
    outfilename = tmp;
    }
  } else {
#line 391
    outfilename = outfile;
  }
  {
#line 392
  open_output(infile, outfilename);
#line 394
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#include <rpc/rpc.h>\n");
  }
#line 396
  if (infile) {
    {
#line 396
    include = extendfile(infile, (char *)".h");
    }
#line 396
    if (include) {
      {
#line 397
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"#include \"%s\"\n",
              include);
#line 398
      free((void *)include);
      }
    }
  }
#line 400
  foundprogram = 0;
  {
#line 401
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 401
    def = get_definition();
    }
#line 401
    if (! def) {
#line 401
      goto while_break;
    }
#line 402
    foundprogram |= (unsigned int )def->def_kind == 5U;
  }
  while_break: /* CIL Label */ ;
  }
#line 404
  if (extend) {
#line 404
    if (! foundprogram) {
      {
#line 405
      unlink((char const   *)outfilename);
      }
#line 406
      return;
    }
  }
  {
#line 408
  write_stubs();
  }
#line 409
  return;
}
}
#line 414 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static void do_registers(int argc , char **argv ) 
{ 
  int i ;
  int tmp ;

  {
#line 422
  i = 1;
  {
#line 422
  while (1) {
    while_continue: /* CIL Label */ ;
#line 422
    if (! (i < argc)) {
#line 422
      goto while_break;
    }
    {
#line 423
    tmp = streq(*(argv + i), "-s");
    }
#line 423
    if (tmp) {
      {
#line 424
      write_register(*(argv + (i + 1)));
#line 425
      i ++;
      }
    }
#line 422
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  return;
}
}
#line 433 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_main.c"
static int parseargs(int argc , char **argv , struct commandline *cmd ) 
{ 
  int i ;
  int j ;
  char c ;
  char flag[1 << 8UL * sizeof(char )] ;
  int nflags ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 446
  cmdname = *(argv + 0);
#line 447
  tmp = (char *)((void *)0);
#line 447
  cmd->outfile = tmp;
#line 447
  cmd->infile = tmp;
#line 448
  if (argc < 2) {
#line 449
    return (0);
  }
#line 451
  flag['c'] = (char)0;
#line 452
  flag['h'] = (char)0;
#line 453
  flag['s'] = (char)0;
#line 454
  flag['o'] = (char)0;
#line 455
  flag['l'] = (char)0;
#line 456
  flag['m'] = (char)0;
#line 457
  i = 1;
  {
#line 457
  while (1) {
    while_continue: /* CIL Label */ ;
#line 457
    if (! (i < argc)) {
#line 457
      goto while_break;
    }
#line 458
    if ((int )*(*(argv + i) + 0) != 45) {
#line 459
      if (cmd->infile) {
#line 460
        return (0);
      }
#line 462
      cmd->infile = *(argv + i);
    } else {
#line 464
      j = 1;
      {
#line 464
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 464
        if (! ((int )*(*(argv + i) + j) != 0)) {
#line 464
          goto while_break___0;
        }
#line 465
        c = *(*(argv + i) + j);
        {
#line 470
        if ((int )c == 109) {
#line 470
          goto case_109;
        }
#line 470
        if ((int )c == 108) {
#line 470
          goto case_109;
        }
#line 470
        if ((int )c == 104) {
#line 470
          goto case_109;
        }
#line 470
        if ((int )c == 99) {
#line 470
          goto case_109;
        }
#line 477
        if ((int )c == 115) {
#line 477
          goto case_115;
        }
#line 477
        if ((int )c == 111) {
#line 477
          goto case_115;
        }
#line 499
        goto switch_default;
        case_109: /* CIL Label */ 
        case_108: /* CIL Label */ 
        case_104: /* CIL Label */ 
        case_99: /* CIL Label */ 
#line 471
        if (flag[c]) {
#line 472
          return (0);
        }
#line 474
        flag[c] = (char)1;
#line 475
        goto switch_break;
        case_115: /* CIL Label */ 
        case_111: /* CIL Label */ 
#line 478
        if ((int )*(*(argv + i) + (j - 1)) != 45) {
#line 480
          return (0);
        } else
#line 478
        if ((int )*(*(argv + i) + (j + 1)) != 0) {
#line 480
          return (0);
        }
#line 482
        flag[c] = (char)1;
#line 483
        i ++;
#line 483
        if (i == argc) {
#line 484
          return (0);
        }
#line 486
        if ((int )c == 115) {
          {
#line 487
          tmp___0 = streq(*(argv + i), "udp");
          }
#line 487
          if (! tmp___0) {
            {
#line 487
            tmp___1 = streq(*(argv + i), "tcp");
            }
#line 487
            if (! tmp___1) {
#line 489
              return (0);
            }
          }
        } else
#line 491
        if ((int )c == 111) {
#line 492
          if (cmd->outfile) {
#line 493
            return (0);
          }
#line 495
          cmd->outfile = *(argv + i);
        }
#line 497
        goto nextarg;
        switch_default: /* CIL Label */ 
#line 500
        return (0);
        switch_break: /* CIL Label */ ;
        }
#line 464
        j ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      nextarg: ;
    }
#line 457
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 507
  cmd->cflag = (int )flag['c'];
#line 508
  cmd->hflag = (int )flag['h'];
#line 509
  cmd->sflag = (int )flag['s'];
#line 510
  cmd->lflag = (int )flag['l'];
#line 511
  cmd->mflag = (int )flag['m'];
#line 512
  nflags = (((cmd->cflag + cmd->hflag) + cmd->sflag) + cmd->lflag) + cmd->mflag;
#line 513
  if (nflags == 0) {
#line 514
    if ((unsigned long )cmd->outfile != (unsigned long )((void *)0)) {
#line 515
      return (0);
    } else
#line 514
    if ((unsigned long )cmd->infile == (unsigned long )((void *)0)) {
#line 515
      return (0);
    }
  } else
#line 517
  if (nflags > 1) {
#line 518
    return (0);
  }
#line 520
  return (1);
}
}
#line 73 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
char *findval(list *lst , char *val , int (*cmp)() ) ;
#line 50 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_header(definition *def ) ;
#line 50
static void print_trailer(void) ;
#line 50
static void space(void) ;
#line 50
static void emit_enum(definition *def ) ;
#line 50
static void emit_union(definition *def ) ;
#line 50
static void emit_struct(definition *def ) ;
#line 50
static void emit_typedef(definition *def ) ;
#line 50
static void print_stat(declaration *dec ) ;
#line 57 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
void emit(definition *def ) 
{ 


  {
#line 61
  if ((unsigned int )def->def_kind == 5U) {
#line 62
    return;
  } else
#line 61
  if ((unsigned int )def->def_kind == 0U) {
#line 62
    return;
  }
  {
#line 64
  print_header(def);
  }
  {
#line 66
  if ((unsigned int )def->def_kind == 2U) {
#line 66
    goto case_2;
  }
#line 69
  if ((unsigned int )def->def_kind == 3U) {
#line 69
    goto case_3;
  }
#line 72
  if ((unsigned int )def->def_kind == 1U) {
#line 72
    goto case_1;
  }
#line 75
  if ((unsigned int )def->def_kind == 4U) {
#line 75
    goto case_4;
  }
#line 65
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 67
  emit_union(def);
  }
#line 68
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 70
  emit_enum(def);
  }
#line 71
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 73
  emit_struct(def);
  }
#line 74
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 76
  emit_typedef(def);
  }
#line 77
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 79
  print_trailer();
  }
#line 80
  return;
}
}
#line 82 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static int findtype(definition *def , char *type ) 
{ 
  int tmp ;

  {
#line 87
  if ((unsigned int )def->def_kind == 5U) {
#line 88
    return (0);
  } else
#line 87
  if ((unsigned int )def->def_kind == 0U) {
#line 88
    return (0);
  } else {
    {
#line 90
    tmp = streq(def->def_name, type);
    }
#line 90
    return (tmp);
  }
}
}
#line 94 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static int undefined(char *type ) 
{ 
  definition *def ;
  char *tmp ;

  {
  {
#line 100
  tmp = findval(defined, type, & findtype);
#line 100
  def = (definition *)tmp;
  }
#line 101
  return ((unsigned long )def == (unsigned long )((void *)0));
}
}
#line 105 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_header(definition *def ) 
{ 
  int tmp ;

  {
  {
#line 109
  space();
#line 110
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"bool_t\n");
#line 111
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"xdr_%s(xdrs, objp)\n",
          def->def_name);
#line 112
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tXDR *xdrs;\n");
#line 113
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t%s ",
          def->def_name);
  }
#line 114
  if ((unsigned int )def->def_kind != 4U) {
    {
#line 116
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"*");
    }
  } else {
    {
#line 114
    tmp = isvectordef(def->def.ty.old_type, (unsigned int )def->def.ty.rel);
    }
#line 114
    if (! tmp) {
      {
#line 116
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"*");
      }
    }
  }
  {
#line 118
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"objp;\n");
#line 119
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"{\n");
  }
#line 120
  return;
}
}
#line 122 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_trailer(void) 
{ 


  {
  {
#line 125
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\treturn (TRUE);\n");
#line 126
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"}\n");
#line 127
  space();
  }
#line 128
  return;
}
}
#line 131 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_ifopen(int indent , char *name ) 
{ 


  {
  {
#line 136
  tabify(fout, indent);
#line 137
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"if (!xdr_%s(xdrs",
          name);
  }
#line 138
  return;
}
}
#line 141 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_ifarg(char *arg ) 
{ 


  {
  {
#line 145
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)", %s",
          arg);
  }
#line 146
  return;
}
}
#line 149 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_ifsizeof(char *prefix , char *type ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 154
  tmp___0 = streq(type, "bool");
  }
#line 154
  if (tmp___0) {
    {
#line 155
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)", sizeof(bool_t), xdr_bool");
    }
  } else {
    {
#line 157
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)", sizeof(");
#line 158
    tmp = undefined(type);
    }
#line 158
    if (tmp) {
#line 158
      if (prefix) {
        {
#line 159
        fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s ",
                prefix);
        }
      }
    }
    {
#line 161
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s), xdr_%s",
            type, type);
    }
  }
#line 163
  return;
}
}
#line 165 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_ifclose(int indent ) 
{ 


  {
  {
#line 169
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)")) {\n");
#line 170
  tabify(fout, indent);
#line 171
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\treturn (FALSE);\n");
#line 172
  tabify(fout, indent);
#line 173
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"}\n");
  }
#line 174
  return;
}
}
#line 176 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void space(void) 
{ 


  {
  {
#line 179
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\n\n");
  }
#line 180
  return;
}
}
#line 182 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_ifstat(int indent , char *prefix , char *type , relation rel , char *amax ,
                         char *objname , char *name ) 
{ 
  char *alt ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
#line 192
  alt = (char *)((void *)0);
  {
#line 195
  if ((unsigned int )rel == 3U) {
#line 195
    goto case_3;
  }
#line 201
  if ((unsigned int )rel == 0U) {
#line 201
    goto case_0;
  }
#line 220
  if ((unsigned int )rel == 1U) {
#line 220
    goto case_1;
  }
#line 249
  if ((unsigned int )rel == 2U) {
#line 249
    goto case_2;
  }
#line 277
  if ((unsigned int )rel == 4U) {
#line 277
    goto case_4;
  }
#line 194
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 196
  print_ifopen(indent, (char *)"pointer");
#line 197
  print_ifarg((char *)"(char **)");
#line 198
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s", objname);
#line 199
  print_ifsizeof(prefix, type);
  }
#line 200
  goto switch_break;
  case_0: /* CIL Label */ 
  {
#line 202
  tmp___0 = streq(type, "string");
  }
#line 202
  if (tmp___0) {
#line 203
    alt = (char *)"string";
  } else {
    {
#line 204
    tmp = streq(type, "opaque");
    }
#line 204
    if (tmp) {
#line 205
      alt = (char *)"opaque";
    }
  }
#line 207
  if (alt) {
    {
#line 208
    print_ifopen(indent, alt);
#line 209
    print_ifarg(objname);
    }
  } else {
    {
#line 211
    print_ifopen(indent, (char *)"vector");
#line 212
    print_ifarg((char *)"(char *)");
#line 213
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s",
            objname);
    }
  }
  {
#line 215
  print_ifarg(amax);
  }
#line 216
  if (! alt) {
    {
#line 217
    print_ifsizeof(prefix, type);
    }
  }
#line 219
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 221
  tmp___2 = streq(type, "string");
  }
#line 221
  if (tmp___2) {
#line 222
    alt = (char *)"string";
  } else {
    {
#line 223
    tmp___1 = streq(type, "opaque");
    }
#line 223
    if (tmp___1) {
#line 224
      alt = (char *)"bytes";
    }
  }
  {
#line 226
  tmp___3 = streq(type, "string");
  }
#line 226
  if (tmp___3) {
    {
#line 227
    print_ifopen(indent, alt);
#line 228
    print_ifarg(objname);
    }
  } else {
#line 230
    if (alt) {
      {
#line 231
      print_ifopen(indent, alt);
      }
    } else {
      {
#line 233
      print_ifopen(indent, (char *)"array");
      }
    }
    {
#line 235
    print_ifarg((char *)"(char **)");
    }
#line 236
    if ((int )*objname == 38) {
      {
#line 237
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s.%s_val, (u_int *)%s.%s_len",
              objname, name, objname, name);
      }
    } else {
      {
#line 240
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"&%s->%s_val, (u_int *)&%s->%s_len",
              objname, name, objname, name);
      }
    }
  }
  {
#line 244
  print_ifarg(amax);
  }
#line 245
  if (! alt) {
    {
#line 246
    print_ifsizeof(prefix, type);
    }
  }
#line 248
  goto switch_break;
  case_2: /* CIL Label */ 
  {
#line 250
  tmp___5 = streq(type, "string");
  }
#line 250
  if (tmp___5) {
#line 251
    alt = (char *)"string";
  } else {
    {
#line 252
    tmp___4 = streq(type, "opaque");
    }
#line 252
    if (tmp___4) {
#line 253
      alt = (char *)"bytes";
    }
  }
  {
#line 255
  tmp___6 = streq(type, "string");
  }
#line 255
  if (tmp___6) {
    {
#line 256
    print_ifopen(indent, alt);
#line 257
    print_ifarg(objname);
    }
  } else {
#line 259
    if (alt) {
      {
#line 260
      print_ifopen(indent, alt);
      }
    } else {
      {
#line 262
      print_ifopen(indent, (char *)"var_array");
      }
    }
    {
#line 264
    print_ifarg((char *)"(char **)");
    }
#line 265
    if ((int )*objname == 38) {
      {
#line 266
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s,\n\t\tobjp->%s, objp->%s",
              objname, amax, amax);
      }
    } else {
      {
#line 269
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"&%s,\n\t\tobjp->%s, objp->%s",
              objname, amax, amax);
      }
    }
  }
#line 273
  if (! alt) {
    {
#line 274
    print_ifsizeof(prefix, type);
    }
  }
#line 276
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 278
  print_ifopen(indent, type);
#line 279
  print_ifarg(objname);
  }
#line 280
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 282
  print_ifclose(indent);
  }
#line 283
  return;
}
}
#line 287 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void emit_enum(definition *def ) 
{ 


  {
  {
#line 291
  print_ifopen(1, (char *)"enum");
#line 292
  print_ifarg((char *)"(enum_t *)objp");
#line 293
  print_ifclose(1);
  }
#line 294
  return;
}
}
#line 297 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void emit_union(definition *def ) 
{ 
  declaration *dflt ;
  case_list *cl ;
  declaration *cs ;
  char *object ;
  char *format ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  void *tmp___7 ;
  int tmp___8 ;

  {
  {
#line 305
  format = (char *)"&objp->%s_u.%s";
#line 307
  print_stat(& def->def.un.enum_decl);
#line 308
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tswitch (objp->%s) {\n",
          def->def.un.enum_decl.name);
#line 309
  cl = def->def.un.cases;
  }
  {
#line 309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 309
    if (! ((unsigned long )cl != (unsigned long )((void *)0))) {
#line 309
      goto while_break;
    }
    {
#line 310
    cs = & cl->case_decl;
#line 311
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tcase %s:\n",
            cl->case_name);
#line 312
    tmp___3 = streq(cs->type, "void");
    }
#line 312
    if (! tmp___3) {
      {
#line 313
      tmp = (int )strlen(def->def_name);
#line 313
      tmp___0 = (int )strlen(format);
#line 313
      tmp___1 = (int )strlen(cs->name);
#line 313
      tmp___2 = malloc((size_t )((unsigned int )(((tmp + tmp___0) + tmp___1) + 1)));
#line 313
      object = (char *)tmp___2;
#line 315
      sprintf((char */* __restrict  */)object, (char const   */* __restrict  */)format,
              def->def_name, cs->name);
#line 316
      print_ifstat(2, cs->prefix, cs->type, cs->rel, cs->array_max, object, cs->name);
#line 318
      free((void *)object);
      }
    }
    {
#line 320
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\tbreak;\n");
#line 309
    cl = cl->next;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 322
  dflt = def->def.un.default_decl;
#line 323
  if ((unsigned long )dflt != (unsigned long )((void *)0)) {
    {
#line 324
    tmp___8 = streq(dflt->type, "void");
    }
#line 324
    if (! tmp___8) {
      {
#line 325
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tdefault:\n");
#line 326
      tmp___4 = (int )strlen(def->def_name);
#line 326
      tmp___5 = (int )strlen(format);
#line 326
      tmp___6 = (int )strlen(dflt->name);
#line 326
      tmp___7 = malloc((size_t )((unsigned int )(((tmp___4 + tmp___5) + tmp___6) + 1)));
#line 326
      object = (char *)tmp___7;
#line 328
      sprintf((char */* __restrict  */)object, (char const   */* __restrict  */)format,
              def->def_name, dflt->name);
#line 329
      print_ifstat(2, dflt->prefix, dflt->type, dflt->rel, dflt->array_max, object,
                   dflt->name);
#line 331
      free((void *)object);
#line 332
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\tbreak;\n");
      }
    }
  } else {
    {
#line 335
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\tdefault:\n");
#line 336
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t\treturn (FALSE);\n");
    }
  }
  {
#line 338
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"\t}\n");
  }
#line 339
  return;
}
}
#line 343 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void emit_struct(definition *def ) 
{ 
  decl_list *dl ;
  int size ;
  int szof ;
  definition *d ;
  char buf___0[128] ;
  char *tmp ;

  {
#line 348
  size = 0;
#line 352
  dl = def->def.st.decls;
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    if (! ((unsigned long )dl != (unsigned long )((void *)0))) {
#line 352
      goto while_break;
    }
    {
#line 353
    print_stat(& dl->decl);
    }
#line 354
    if (dl->decl.storage == -1) {
      {
#line 355
      tmp = findval(defined, dl->decl.type, & findtype);
#line 355
      d = (definition *)tmp;
      }
#line 356
      if (d) {
#line 357
        if ((unsigned int )d->def_kind == 4U) {
#line 358
          szof = d->def.ty.old_storage;
        } else {
#line 361
          szof = d->def.st.storage;
        }
#line 363
        if (szof != -1) {
#line 364
          if ((unsigned int )dl->decl.rel == 2U) {
            {
#line 366
            sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"( %s * %d )",
                    dl->decl.array_max, szof);
            }
          } else {
            {
#line 369
            size += szof;
#line 370
            sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)"%d",
                    szof);
            }
          }
          {
#line 372
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s %s\n",
                  dl->decl.type, buf___0);
          }
        }
      } else {
        {
#line 378
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"* could not determine size of \"%s\"\n",
                dl->decl.type);
        }
      }
    } else {
      {
#line 382
      size += dl->decl.storage;
#line 383
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  %s %d\n",
              dl->decl.type, dl->decl.storage);
      }
    }
#line 352
    dl = dl->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 386
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\t%d\n\n",
          def->def_name, size);
#line 387
  def->def.st.storage = size;
  }
#line 388
  return;
}
}
#line 393 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void emit_typedef(definition *def ) 
{ 
  char *prefix ;
  char *type ;
  char *amax ;
  relation rel ;

  {
  {
#line 397
  prefix = def->def.ty.old_prefix;
#line 398
  type = def->def.ty.old_type;
#line 399
  amax = def->def.ty.array_max;
#line 400
  rel = def->def.ty.rel;
#line 402
  print_ifstat(1, prefix, type, rel, amax, (char *)"objp", def->def_name);
  }
#line 403
  return;
}
}
#line 409 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_cout.c"
static void print_stat(declaration *dec ) 
{ 
  char *prefix ;
  char *type ;
  char *amax ;
  relation rel ;
  char name[256] ;
  int tmp ;

  {
  {
#line 413
  prefix = dec->prefix;
#line 414
  type = dec->type;
#line 415
  amax = dec->array_max;
#line 416
  rel = dec->rel;
#line 419
  tmp = isvectordef(type, (unsigned int )rel);
  }
#line 419
  if (tmp) {
    {
#line 420
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"objp->%s",
            dec->name);
    }
  } else {
    {
#line 422
    sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"&objp->%s",
            dec->name);
    }
  }
  {
#line 424
  print_ifstat(1, prefix, type, rel, amax, name, dec->name);
  }
#line 425
  return;
}
}
#line 573 "/usr/include/stdio.h"
extern int fputc(int __c , FILE *__stream ) ;
#line 55 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
char curline[1024]  ;
#line 59 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
char *infilename  ;
#line 60 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
FILE *fout  ;
#line 61 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
FILE *fin  ;
#line 63 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.h"
list *defined  ;
#line 53 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
char *where  =    curline;
#line 54 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
int linenum  =    0;
#line 59 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
char *outfiles[4]  ;
#line 60 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
int nfiles  ;
#line 67
static void printwhere(void) ;
#line 76
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 73 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void reinitialize(void) 
{ 


  {
  {
#line 76
  memset(curline, 0, 1024);
#line 77
  where = curline;
#line 78
  linenum = 0;
#line 79
  defined = (list *)((void *)0);
  }
#line 80
  return;
}
}
#line 89
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 85 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
int streq(char *a , char *b ) 
{ 
  int tmp ;

  {
  {
#line 89
  tmp = strcmp(a, b);
  }
#line 89
  return (tmp == 0);
}
}
#line 95 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
char *findval(list *lst , char *val , int (*cmp)() ) 
{ 
  int tmp ;

  {
  {
#line 102
  while (1) {
    while_continue: /* CIL Label */ ;
#line 102
    if (! ((unsigned long )lst != (unsigned long )((void *)0))) {
#line 102
      goto while_break;
    }
    {
#line 103
    tmp = (*cmp)(lst->val, val);
    }
#line 103
    if (tmp) {
#line 104
      return (lst->val);
    }
#line 102
    lst = lst->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 107
  return ((char *)((void *)0));
}
}
#line 113 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void storeval(list **lstp , char *val ) 
{ 
  list **l ;
  list *lst ;
  void *tmp ;

  {
#line 121
  l = lstp;
  {
#line 121
  while (1) {
    while_continue: /* CIL Label */ ;
#line 121
    if (! ((unsigned long )*l != (unsigned long )((void *)0))) {
#line 121
      goto while_break;
    }
#line 121
    l = & (*l)->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 122
  tmp = malloc(sizeof(list ));
#line 122
  lst = (list *)tmp;
#line 123
  lst->val = val;
#line 124
  lst->next = (struct list *)((void *)0);
#line 125
  *l = lst;
  }
#line 126
  return;
}
}
#line 129 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static int findit(definition *def , char *type ) 
{ 
  int tmp ;

  {
  {
#line 134
  tmp = streq(def->def_name, type);
  }
#line 134
  return (tmp);
}
}
#line 138 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static char *fixit(char *type , char *orig ) 
{ 
  definition *def ;
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 145
  tmp = findval(defined, type, (int (*)())(& findit));
#line 145
  def = (definition *)tmp;
  }
#line 146
  if ((unsigned long )def == (unsigned long )((void *)0)) {
#line 147
    return (orig);
  } else
#line 146
  if ((unsigned int )def->def_kind != 4U) {
#line 147
    return (orig);
  }
  {
#line 150
  if ((unsigned int )def->def.ty.rel == 0U) {
#line 150
    goto case_0;
  }
#line 152
  if ((unsigned int )def->def.ty.rel == 4U) {
#line 152
    goto case_4;
  }
#line 154
  goto switch_default;
  case_0: /* CIL Label */ 
#line 151
  return (def->def.ty.old_type);
  case_4: /* CIL Label */ 
  {
#line 153
  tmp___0 = fixit(def->def.ty.old_type, orig);
  }
#line 153
  return (tmp___0);
  switch_default: /* CIL Label */ 
#line 155
  return (orig);
  switch_break: /* CIL Label */ ;
  }
}
}
#line 159 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
char *fixtype(char *type ) 
{ 
  char *tmp ;

  {
  {
#line 163
  tmp = fixit(type, type);
  }
#line 163
  return (tmp);
}
}
#line 166 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
char *stringfix(char *type ) 
{ 
  int tmp ;

  {
  {
#line 170
  tmp = streq(type, (char *)"string");
  }
#line 170
  if (tmp) {
#line 171
    return ((char *)"wrapstring");
  } else {
#line 173
    return (type);
  }
}
}
#line 177 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void ptype(char *prefix , char *type , int follow ) 
{ 
  int tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 183
  if ((unsigned long )prefix != (unsigned long )((void *)0)) {
    {
#line 184
    tmp = streq(prefix, (char *)"enum");
    }
#line 184
    if (tmp) {
      {
#line 185
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"enum ");
      }
    } else {
      {
#line 187
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"struct ");
      }
    }
  }
  {
#line 190
  tmp___3 = streq(type, (char *)"bool");
  }
#line 190
  if (tmp___3) {
    {
#line 191
    fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"bool_t ");
    }
  } else {
    {
#line 192
    tmp___2 = streq(type, (char *)"string");
    }
#line 192
    if (tmp___2) {
      {
#line 193
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"char *");
      }
    } else {
#line 195
      if (follow) {
        {
#line 195
        tmp___0 = fixtype(type);
#line 195
        tmp___1 = tmp___0;
        }
      } else {
#line 195
        tmp___1 = type;
      }
      {
#line 195
      fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s ",
              tmp___1);
      }
    }
  }
#line 197
  return;
}
}
#line 200 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static int typedefed(definition *def , char *type ) 
{ 
  int tmp ;

  {
#line 205
  if ((unsigned int )def->def_kind != 4U) {
#line 206
    return (0);
  } else
#line 205
  if ((unsigned long )def->def.ty.old_prefix != (unsigned long )((void *)0)) {
#line 206
    return (0);
  } else {
    {
#line 208
    tmp = streq(def->def_name, type);
    }
#line 208
    return (tmp);
  }
}
}
#line 212 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
int isvectordef(char *type , relation rel ) 
{ 
  definition *def ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 218
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 220
    if ((unsigned int )rel == 0U) {
#line 220
      goto case_0;
    }
#line 223
    if ((unsigned int )rel == 2U) {
#line 223
      goto case_2;
    }
#line 223
    if ((unsigned int )rel == 1U) {
#line 223
      goto case_2;
    }
#line 225
    if ((unsigned int )rel == 3U) {
#line 225
      goto case_3;
    }
#line 227
    if ((unsigned int )rel == 4U) {
#line 227
      goto case_4;
    }
#line 219
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 221
    tmp = streq(type, (char *)"string");
    }
#line 221
    if (tmp) {
#line 221
      tmp___0 = 0;
    } else {
#line 221
      tmp___0 = 1;
    }
#line 221
    return (tmp___0);
    case_2: /* CIL Label */ 
    case_1: /* CIL Label */ 
#line 224
    return (0);
    case_3: /* CIL Label */ 
#line 226
    return (0);
    case_4: /* CIL Label */ 
    {
#line 228
    tmp___1 = findval(defined, type, (int (*)())(& typedefed));
#line 228
    def = (definition *)tmp___1;
    }
#line 229
    if ((unsigned long )def == (unsigned long )((void *)0)) {
#line 230
      return (0);
    }
#line 232
    type = def->def.ty.old_type;
#line 233
    rel = def->def.ty.rel;
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 244 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static char buf[100]  ;
#line 239 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static char *locase(char *str ) 
{ 
  char c ;
  char *p ;
  char *tmp ;
  char *tmp___0 ;

  {
#line 245
  p = buf;
  {
#line 247
  while (1) {
    while_continue: /* CIL Label */ ;
#line 247
    tmp___0 = str;
#line 247
    str ++;
#line 247
    c = *tmp___0;
#line 247
    if (! c) {
#line 247
      goto while_break;
    }
#line 248
    tmp = p;
#line 248
    p ++;
#line 248
    if ((int )c >= 65) {
#line 248
      if ((int )c <= 90) {
#line 248
        *tmp = (char )(((int )c - 65) + 97);
      } else {
#line 248
        *tmp = c;
      }
    } else {
#line 248
      *tmp = c;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 250
  *p = (char)0;
#line 251
  return (buf);
}
}
#line 255 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void pvname(char *pname , char *vnum ) 
{ 
  char *tmp ;

  {
  {
#line 260
  tmp = locase(pname);
#line 260
  fprintf((FILE */* __restrict  */)fout, (char const   */* __restrict  */)"%s_%s",
          tmp, vnum);
  }
#line 261
  return;
}
}
#line 267 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void error(char *msg ) 
{ 


  {
  {
#line 271
  printwhere();
#line 272
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s, line %d: ",
          infilename, linenum);
#line 273
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s\n",
          msg);
#line 274
  crash();
  }
#line 275
  return;
}
}
#line 281 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void crash(void) 
{ 
  int i ;

  {
#line 286
  i = 0;
  {
#line 286
  while (1) {
    while_continue: /* CIL Label */ ;
#line 286
    if (! (i < nfiles)) {
#line 286
      goto while_break;
    }
    {
#line 287
    unlink(outfiles[i]);
#line 286
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 289
  exit(1);
  }
}
}
#line 293 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void record_open(char *file ) 
{ 
  int tmp ;

  {
#line 297
  if (nfiles < 4) {
#line 298
    tmp = nfiles;
#line 298
    nfiles ++;
#line 298
    outfiles[tmp] = file;
  } else {
    {
#line 300
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"too many files!\n");
#line 301
    crash();
    }
  }
#line 303
  return;
}
}
#line 305 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static char expectbuf[100]  ;
#line 306
static char *toktostr(tok_kind kind ) ;
#line 311 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void expected1(tok_kind exp1 ) 
{ 
  char *tmp ;

  {
  {
#line 315
  tmp = toktostr((unsigned int )exp1);
#line 315
  sprintf((char */* __restrict  */)(expectbuf), (char const   */* __restrict  */)"expected \'%s\'",
          tmp);
#line 317
  error(expectbuf);
  }
#line 318
  return;
}
}
#line 323 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void expected2(tok_kind exp1 , tok_kind exp2 ) 
{ 
  char *tmp ;
  char *tmp___0 ;

  {
  {
#line 327
  tmp = toktostr((unsigned int )exp2);
#line 327
  tmp___0 = toktostr((unsigned int )exp1);
#line 327
  sprintf((char */* __restrict  */)(expectbuf), (char const   */* __restrict  */)"expected \'%s\' or \'%s\'",
          tmp___0, tmp);
#line 330
  error(expectbuf);
  }
#line 331
  return;
}
}
#line 336 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void expected3(tok_kind exp1 , tok_kind exp2 , tok_kind exp3 ) 
{ 
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 340
  tmp = toktostr((unsigned int )exp3);
#line 340
  tmp___0 = toktostr((unsigned int )exp2);
#line 340
  tmp___1 = toktostr((unsigned int )exp1);
#line 340
  sprintf((char */* __restrict  */)(expectbuf), (char const   */* __restrict  */)"expected \'%s\', \'%s\' or \'%s\'",
          tmp___1, tmp___0, tmp);
#line 344
  error(expectbuf);
  }
#line 345
  return;
}
}
#line 347 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
void tabify(FILE *f , int tab ) 
{ 
  int tmp ;

  {
  {
#line 352
  while (1) {
    while_continue: /* CIL Label */ ;
#line 352
    tmp = tab;
#line 352
    tab --;
#line 352
    if (! tmp) {
#line 352
      goto while_break;
    }
    {
#line 353
    fputc('\t', f);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 355
  return;
}
}
#line 359 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static token tokstrings[34]  = 
#line 359
  {      {(tok_kind )0, (char *)"identifier"}, 
        {(tok_kind )15, (char *)"const"}, 
        {(tok_kind )3, (char *)")"}, 
        {(tok_kind )2, (char *)"("}, 
        {(tok_kind )5, (char *)"}"}, 
        {(tok_kind )4, (char *)"{"}, 
        {(tok_kind )6, (char *)"["}, 
        {(tok_kind )7, (char *)"]"}, 
        {(tok_kind )10, (char *)"*"}, 
        {(tok_kind )11, (char *)","}, 
        {(tok_kind )12, (char *)"="}, 
        {(tok_kind )13, (char *)":"}, 
        {(tok_kind )14, (char *)";"}, 
        {(tok_kind )17, (char *)"union"}, 
        {(tok_kind )16, (char *)"struct"}, 
        {(tok_kind )18, (char *)"switch"}, 
        {(tok_kind )19, (char *)"case"}, 
        {(tok_kind )20, (char *)"default"}, 
        {(tok_kind )21, (char *)"enum"}, 
        {(tok_kind )22, (char *)"typedef"}, 
        {(tok_kind )23, (char *)"int"}, 
        {(tok_kind )24, (char *)"short"}, 
        {(tok_kind )25, (char *)"long"}, 
        {(tok_kind )26, (char *)"unsigned"}, 
        {(tok_kind )28, (char *)"double"}, 
        {(tok_kind )27, (char *)"float"}, 
        {(tok_kind )30, (char *)"char"}, 
        {(tok_kind )31, (char *)"string"}, 
        {(tok_kind )29, (char *)"opaque"}, 
        {(tok_kind )32, (char *)"bool"}, 
        {(tok_kind )33, (char *)"void"}, 
        {(tok_kind )34, (char *)"program"}, 
        {(tok_kind )35, (char *)"version"}, 
        {(tok_kind )36, (char *)"??????"}};
#line 396 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static char *toktostr(tok_kind kind ) 
{ 
  token *sp ;

  {
#line 402
  sp = tokstrings;
  {
#line 402
  while (1) {
    while_continue: /* CIL Label */ ;
#line 402
    if ((unsigned int )sp->kind != 36U) {
#line 402
      if (! ((unsigned int )sp->kind != (unsigned int )kind)) {
#line 402
        goto while_break;
      }
    } else {
#line 402
      goto while_break;
    }
#line 402
    sp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 403
  return (sp->str);
}
}
#line 408 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static void printbuf(void) 
{ 
  char c ;
  int i ;
  int cnt ;
  int tmp ;

  {
#line 417
  i = 0;
  {
#line 417
  while (1) {
    while_continue: /* CIL Label */ ;
#line 417
    c = curline[i];
#line 417
    if (! c) {
#line 417
      goto while_break;
    }
#line 418
    if ((int )c == 9) {
#line 419
      cnt = 8 - i % 4;
#line 420
      c = (char )' ';
    } else {
#line 422
      cnt = 1;
    }
    {
#line 424
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 424
      tmp = cnt;
#line 424
      cnt --;
#line 424
      if (! tmp) {
#line 424
        goto while_break___0;
      }
      {
#line 425
      fputc((int )c, stderr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 417
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 428
  return;
}
}
#line 431 "/home/june/collector/temp/acm-5.0/dis/disgen/rpc_util.c"
static void printwhere(void) 
{ 
  int i ;
  char c ;
  int cnt ;
  int tmp ;

  {
  {
#line 438
  printbuf();
#line 439
  i = 0;
  }
  {
#line 439
  while (1) {
    while_continue: /* CIL Label */ ;
#line 439
    if (! ((long )i < where - curline)) {
#line 439
      goto while_break;
    }
#line 440
    c = curline[i];
#line 441
    if ((int )c == 9) {
#line 442
      cnt = 8 - i % 4;
    } else {
#line 444
      cnt = 1;
    }
    {
#line 446
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 446
      tmp = cnt;
#line 446
      cnt --;
#line 446
      if (! tmp) {
#line 446
        goto while_break___0;
      }
      {
#line 447
      fputc('^', stderr);
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 439
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 450
  fputc('\n', stderr);
  }
#line 451
  return;
}
}
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 16 "/home/june/collector/temp/acm-5.0/dis/sdbm/util.c"
char *progname ;
#line 10 "/home/june/collector/temp/acm-5.0/dis/sdbm/util.c"
void oops(char *s1 , char *s2 ) 
{ 
  int *tmp ;

  {
#line 18
  if (progname) {
    {
#line 19
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
    }
  }
  {
#line 20
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)s1, s2);
#line 21
  tmp = __errno_location();
  }
#line 21
  if (*tmp > 0) {
    {
#line 22
    perror("Error");
    }
  }
  {
#line 23
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 24
  exit(1);
  }
}
}
#line 27 "/home/june/collector/temp/acm-5.0/dis/sdbm/util.c"
int okpage(char *pag ) 
{ 
  register unsigned int n ;
  register int off ;
  register short *ino ;

  {
#line 33
  ino = (short *)pag;
#line 35
  n = (unsigned int )*(ino + 0);
#line 35
  if ((unsigned long )n > 1024UL / sizeof(short )) {
#line 36
    return (0);
  }
#line 38
  if (! n) {
#line 39
    return (1);
  }
#line 41
  off = 1024;
#line 42
  ino ++;
  {
#line 42
  while (1) {
    while_continue: /* CIL Label */ ;
#line 42
    if (! n) {
#line 42
      goto while_break;
    }
#line 43
    if ((int )*(ino + 0) > off) {
#line 45
      return (0);
    } else
#line 43
    if ((int )*(ino + 1) > off) {
#line 45
      return (0);
    } else
#line 43
    if ((int )*(ino + 1) > (int )*(ino + 0)) {
#line 45
      return (0);
    }
#line 46
    off = (int )*(ino + 1);
#line 47
    n -= 2U;
#line 42
    ino += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  return (1);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 9 "/home/june/collector/temp/acm-5.0/dis/sdbm/dba.c"
char *progname  ;
#line 31
int sdump(int pagf ) ;
#line 55
int pagestat(char *pag ) ;
#line 49
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 39 "/home/june/collector/temp/acm-5.0/dis/sdbm/dba.c"
int sdump(int pagf ) 
{ 
  register int b ;
  register int n ;
  register int t ;
  register int o ;
  register int e ;
  char pag[1024] ;
  int tmp ;

  {
#line 43
  n = 0;
#line 44
  t = 0;
#line 45
  o = 0;
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 49
    b = (int )read(pagf, pag, 1024);
    }
#line 49
    if (! (b > 0)) {
#line 49
      goto while_break;
    }
    {
#line 50
    printf((char const   */* __restrict  */)"#%d: ", n);
#line 51
    tmp = okpage(pag);
    }
#line 51
    if (tmp) {
      {
#line 54
      printf((char const   */* __restrict  */)"ok. ");
#line 55
      e = pagestat(pag);
      }
#line 55
      if (e) {
#line 58
        t += e;
      } else {
#line 56
        o ++;
      }
    } else {
      {
#line 52
      printf((char const   */* __restrict  */)"bad\n");
      }
    }
#line 60
    n ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 63
  if (b == 0) {
    {
#line 64
    printf((char const   */* __restrict  */)"%d pages (%d holes):  %d entries\n",
           n, o, t);
    }
  } else {
    {
#line 66
    oops("read failed: block %d", n);
    }
  }
#line 67
  return (0);
}
}
#line 69 "/home/june/collector/temp/acm-5.0/dis/sdbm/dba.c"
int pagestat(char *pag ) 
{ 
  register int n ;
  register int free___0 ;
  register short *ino ;

  {
#line 74
  ino = (short *)pag;
#line 76
  n = (int )*(ino + 0);
#line 76
  if (n) {
    {
#line 79
    free___0 = (int )((unsigned long )*(ino + n) - (unsigned long )(n + 1) * sizeof(short ));
#line 80
    printf((char const   */* __restrict  */)"%3d entries %2d%% used free %d.\n", n / 2,
           ((1024 - free___0) * 100) / 1024, free___0);
    }
  } else {
    {
#line 77
    printf((char const   */* __restrict  */)"no entries.\n");
    }
  }
#line 83
  return (n / 2);
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 55 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbd.c"
int dispage(char *pag ) ;
#line 89 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbd.c"
int dispage(char *pag ) 
{ 
  register int i ;
  register int n ;
  register int off ;
  register short *ino ;

  {
#line 94
  ino = (short *)pag;
#line 96
  off = 1024;
#line 97
  i = 1;
  {
#line 97
  while (1) {
    while_continue: /* CIL Label */ ;
#line 97
    if (! (i < (int )*(ino + 0))) {
#line 97
      goto while_break;
    }
#line 98
    n = (int )*(ino + i);
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! (n < off)) {
#line 98
        goto while_break___0;
      }
#line 99
      if ((int )*(pag + n) != 0) {
        {
#line 100
        putchar((int )*(pag + n));
        }
      }
#line 98
      n ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 101
    putchar('\t');
#line 102
    off = (int )*(ino + i);
#line 103
    n = (int )*(ino + (i + 1));
    }
    {
#line 103
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 103
      if (! (n < off)) {
#line 103
        goto while_break___1;
      }
#line 104
      if ((int )*(pag + n) != 0) {
        {
#line 105
        putchar((int )*(pag + n));
        }
      }
#line 103
      n ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 106
    putchar('\n');
#line 107
    off = (int )*(ino + (i + 1));
#line 97
    i += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 109
  return (0);
}
}
#line 79 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.h"
long dbm_hash(char *str , int len ) ;
#line 18 "/home/june/collector/temp/acm-5.0/dis/sdbm/hash.c"
long dbm_hash(char *str , int len ) 
{ 
  register unsigned long n ;
  register int loop ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;

  {
#line 23
  n = 0UL;
#line 29
  if (len > 0) {
#line 30
    loop = ((len + 8) - 1) >> 3;
    {
#line 33
    if ((len & 7) == 0) {
#line 33
      goto case_0;
    }
#line 34
    if ((len & 7) == 7) {
#line 34
      goto case_7;
    }
#line 35
    if ((len & 7) == 6) {
#line 35
      goto case_6;
    }
#line 35
    if ((len & 7) == 5) {
#line 35
      goto case_5;
    }
#line 36
    if ((len & 7) == 4) {
#line 36
      goto case_4;
    }
#line 36
    if ((len & 7) == 3) {
#line 36
      goto case_3;
    }
#line 37
    if ((len & 7) == 2) {
#line 37
      goto case_2;
    }
#line 37
    if ((len & 7) == 1) {
#line 37
      goto case_1;
    }
#line 32
    goto switch_break;
    case_0: /* CIL Label */ 
    {
#line 33
    while (1) {
      while_continue: /* CIL Label */ ;
#line 34
      tmp = str;
#line 34
      str ++;
#line 34
      n = (unsigned long )*tmp + 65599UL * n;
      case_7: /* CIL Label */ 
#line 34
      tmp___0 = str;
#line 34
      str ++;
#line 34
      n = (unsigned long )*tmp___0 + 65599UL * n;
      case_6: /* CIL Label */ 
#line 35
      tmp___1 = str;
#line 35
      str ++;
#line 35
      n = (unsigned long )*tmp___1 + 65599UL * n;
      case_5: /* CIL Label */ 
#line 35
      tmp___2 = str;
#line 35
      str ++;
#line 35
      n = (unsigned long )*tmp___2 + 65599UL * n;
      case_4: /* CIL Label */ 
#line 36
      tmp___3 = str;
#line 36
      str ++;
#line 36
      n = (unsigned long )*tmp___3 + 65599UL * n;
      case_3: /* CIL Label */ 
#line 36
      tmp___4 = str;
#line 36
      str ++;
#line 36
      n = (unsigned long )*tmp___4 + 65599UL * n;
      case_2: /* CIL Label */ 
#line 37
      tmp___5 = str;
#line 37
      str ++;
#line 37
      n = (unsigned long )*tmp___5 + 65599UL * n;
      case_1: /* CIL Label */ 
#line 37
      tmp___6 = str;
#line 37
      str ++;
#line 37
      n = (unsigned long )*tmp___6 + 65599UL * n;
#line 33
      loop --;
#line 33
      if (! loop) {
#line 33
        goto while_break;
      }
    }
    while_break: /* CIL Label */ ;
    }
    switch_break: /* CIL Label */ ;
    }
  }
#line 46
  return ((long )n);
}
}
#line 50 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.h"
datum nullitem ;
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 69
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) memcmp)(void const   *__s1 ,
                                                                                               void const   *__s2 ,
                                                                                               size_t __n )  __attribute__((__pure__)) ;
#line 1 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.h"
int fitpair(char *pag , int need ) ;
#line 2
void putpair(char *pag , datum key , datum val ) ;
#line 3
datum getpair(char *pag , datum key ) ;
#line 4
int delpair(char *pag , datum key ) ;
#line 5
int chkpage(char *pag ) ;
#line 6
datum getnkey(char *pag , int num ) ;
#line 7
void splpage(char *pag , char *new , long sbit ) ;
#line 9
int duppair(char *pag , datum key ) ;
#line 23 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
static int seepair(char *pag , int n , char *key , int siz ) ;
#line 45 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
int fitpair(char *pag , int need ) 
{ 
  register int n ;
  register int off ;
  register int free___0 ;
  register short *ino ;

  {
#line 53
  ino = (short *)pag;
#line 55
  n = (int )*(ino + 0);
#line 55
  if (n > 0) {
#line 55
    off = (int )*(ino + n);
  } else {
#line 55
    off = 1024;
  }
#line 56
  free___0 = (int )((unsigned long )off - (unsigned long )(n + 1) * sizeof(short ));
#line 57
  need = (int )((unsigned long )need + 2UL * sizeof(short ));
#line 61
  return (need <= free___0);
}
}
#line 64 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
void putpair(char *pag , datum key , datum val ) 
{ 
  register int n ;
  register int off ;
  register short *ino ;

  {
#line 72
  ino = (short *)pag;
#line 74
  n = (int )*(ino + 0);
#line 74
  if (n > 0) {
#line 74
    off = (int )*(ino + n);
  } else {
#line 74
    off = 1024;
  }
  {
#line 78
  off -= key.dsize;
#line 79
  memcpy((void */* __restrict  */)(pag + off), (void const   */* __restrict  */)key.dptr,
         (size_t )key.dsize);
#line 80
  *(ino + (n + 1)) = (short )off;
#line 84
  off -= val.dsize;
#line 85
  memcpy((void */* __restrict  */)(pag + off), (void const   */* __restrict  */)val.dptr,
         (size_t )val.dsize);
#line 86
  *(ino + (n + 2)) = (short )off;
#line 90
  *(ino + 0) = (short )((int )*(ino + 0) + 2);
  }
#line 91
  return;
}
}
#line 93 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
datum getpair(char *pag , datum key ) 
{ 
  register int i ;
  register int n ;
  datum val ;
  register short *ino ;

  {
#line 101
  ino = (short *)pag;
#line 103
  n = (int )*(ino + 0);
#line 103
  if (n == 0) {
#line 104
    return (nullitem);
  }
  {
#line 106
  i = seepair(pag, n, key.dptr, key.dsize);
  }
#line 106
  if (i == 0) {
#line 107
    return (nullitem);
  }
#line 109
  val.dptr = pag + (int )*(ino + (i + 1));
#line 110
  val.dsize = (int )*(ino + i) - (int )*(ino + (i + 1));
#line 111
  return (val);
}
}
#line 115 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
int duppair(char *pag , datum key ) 
{ 
  register short *ino ;
  int tmp ;
  int tmp___0 ;

  {
#line 120
  ino = (short *)pag;
#line 121
  if ((int )*(ino + 0) > 0) {
    {
#line 121
    tmp = seepair(pag, (int )*(ino + 0), key.dptr, key.dsize);
    }
#line 121
    if (tmp > 0) {
#line 121
      tmp___0 = 1;
    } else {
#line 121
      tmp___0 = 0;
    }
  } else {
#line 121
    tmp___0 = 0;
  }
#line 121
  return (tmp___0);
}
}
#line 125 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
datum getnkey(char *pag , int num ) 
{ 
  datum key ;
  register int off ;
  register short *ino ;

  {
#line 132
  ino = (short *)pag;
#line 134
  num = num * 2 - 1;
#line 135
  if ((int )*(ino + 0) == 0) {
#line 136
    return (nullitem);
  } else
#line 135
  if (num > (int )*(ino + 0)) {
#line 136
    return (nullitem);
  }
#line 138
  if (num > 1) {
#line 138
    off = (int )*(ino + (num - 1));
  } else {
#line 138
    off = 1024;
  }
#line 140
  key.dptr = pag + (int )*(ino + num);
#line 141
  key.dsize = off - (int )*(ino + num);
#line 143
  return (key);
}
}
#line 146 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
int delpair(char *pag , datum key ) 
{ 
  register int n ;
  register int i ;
  register short *ino ;
  register int m ;
  register char *dst ;
  int tmp ;
  register char *src ;
  register int zoo ;
  register int loop ;

  {
#line 153
  ino = (short *)pag;
#line 155
  n = (int )*(ino + 0);
#line 155
  if (n == 0) {
#line 156
    return (0);
  }
  {
#line 158
  i = seepair(pag, n, key.dptr, key.dsize);
  }
#line 158
  if (i == 0) {
#line 159
    return (0);
  }
#line 167
  if (i < n - 1) {
#line 169
    if (i == 1) {
#line 169
      tmp = 1024;
    } else {
#line 169
      tmp = (int )*(ino + (i - 1));
    }
#line 169
    dst = pag + tmp;
#line 170
    src = pag + (int )*(ino + (i + 1));
#line 171
    zoo = (int )(dst - src);
#line 177
    m = (int )*(ino + (i + 1)) - (int )*(ino + n);
#line 181
    if (m > 0) {
#line 182
      loop = ((m + 8) - 1) >> 3;
      {
#line 185
      if ((m & 7) == 0) {
#line 185
        goto case_0;
      }
#line 186
      if ((m & 7) == 7) {
#line 186
        goto case_7;
      }
#line 187
      if ((m & 7) == 6) {
#line 187
        goto case_6;
      }
#line 187
      if ((m & 7) == 5) {
#line 187
        goto case_5;
      }
#line 188
      if ((m & 7) == 4) {
#line 188
        goto case_4;
      }
#line 188
      if ((m & 7) == 3) {
#line 188
        goto case_3;
      }
#line 189
      if ((m & 7) == 2) {
#line 189
        goto case_2;
      }
#line 189
      if ((m & 7) == 1) {
#line 189
        goto case_1;
      }
#line 184
      goto switch_break;
      case_0: /* CIL Label */ 
      {
#line 185
      while (1) {
        while_continue: /* CIL Label */ ;
#line 186
        dst --;
#line 186
        src --;
#line 186
        *dst = *src;
        case_7: /* CIL Label */ 
#line 186
        dst --;
#line 186
        src --;
#line 186
        *dst = *src;
        case_6: /* CIL Label */ 
#line 187
        dst --;
#line 187
        src --;
#line 187
        *dst = *src;
        case_5: /* CIL Label */ 
#line 187
        dst --;
#line 187
        src --;
#line 187
        *dst = *src;
        case_4: /* CIL Label */ 
#line 188
        dst --;
#line 188
        src --;
#line 188
        *dst = *src;
        case_3: /* CIL Label */ 
#line 188
        dst --;
#line 188
        src --;
#line 188
        *dst = *src;
        case_2: /* CIL Label */ 
#line 189
        dst --;
#line 189
        src --;
#line 189
        *dst = *src;
        case_1: /* CIL Label */ 
#line 189
        dst --;
#line 189
        src --;
#line 189
        *dst = *src;
#line 185
        loop --;
#line 185
        if (! loop) {
#line 185
          goto while_break;
        }
      }
      while_break: /* CIL Label */ ;
      }
      switch_break: /* CIL Label */ ;
      }
    }
    {
#line 204
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 204
      if (! (i < n - 1)) {
#line 204
        goto while_break___0;
      }
#line 205
      *(ino + i) = (short )((int )*(ino + (i + 2)) + zoo);
#line 206
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 209
  *(ino + 0) = (short )((int )*(ino + 0) - 2);
#line 210
  return (1);
}
}
#line 218 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
static int seepair(char *pag , int n , char *key , int siz ) 
{ 
  register int i ;
  register int off ;
  register short *ino ;
  int tmp ;

  {
#line 226
  off = 1024;
#line 227
  ino = (short *)pag;
#line 229
  i = 1;
  {
#line 229
  while (1) {
    while_continue: /* CIL Label */ ;
#line 229
    if (! (i < n)) {
#line 229
      goto while_break;
    }
#line 230
    if (siz == off - (int )*(ino + i)) {
      {
#line 230
      tmp = memcmp((void const   *)key, (void const   *)(pag + (int )*(ino + i)),
                   (size_t )siz);
      }
#line 230
      if (tmp == 0) {
#line 232
        return (i);
      }
    }
#line 233
    off = (int )*(ino + (i + 1));
#line 229
    i += 2;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return (0);
}
}
#line 238 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
void splpage(char *pag , char *new , long sbit ) 
{ 
  datum key ;
  datum val ;
  register int n ;
  register int off ;
  char cur[1024] ;
  register short *ino ;
  char *tmp___0 ;
  long tmp___1 ;

  {
  {
#line 248
  off = 1024;
#line 250
  ino = (short *)(cur);
#line 252
  memcpy((void */* __restrict  */)(cur), (void const   */* __restrict  */)pag, (size_t )1024);
#line 253
  memset((void *)pag, 0, (size_t )1024);
#line 254
  memset((void *)new, 0, (size_t )1024);
#line 256
  n = (int )*(ino + 0);
#line 257
  ino ++;
  }
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (n > 0)) {
#line 257
      goto while_break;
    }
    {
#line 258
    key.dptr = cur + (int )*(ino + 0);
#line 259
    key.dsize = off - (int )*(ino + 0);
#line 260
    val.dptr = cur + (int )*(ino + 1);
#line 261
    val.dsize = (int )*(ino + 0) - (int )*(ino + 1);
#line 265
    tmp___1 = dbm_hash(key.dptr, key.dsize);
    }
#line 265
    if (tmp___1 & sbit) {
#line 265
      tmp___0 = new;
    } else {
#line 265
      tmp___0 = pag;
    }
    {
#line 265
    putpair(tmp___0, key, val);
#line 267
    off = (int )*(ino + 1);
#line 268
    n -= 2;
#line 257
    ino += 2;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 274
  return;
}
}
#line 282 "/home/june/collector/temp/acm-5.0/dis/sdbm/pair.c"
int chkpage(char *pag ) 
{ 
  register int n ;
  register int off ;
  register short *ino ;

  {
#line 288
  ino = (short *)pag;
#line 290
  n = (int )*(ino + 0);
#line 290
  if (n < 0) {
#line 291
    return (0);
  } else
#line 290
  if ((unsigned long )n > 1024UL / sizeof(short )) {
#line 291
    return (0);
  }
#line 293
  if (n > 0) {
#line 294
    off = 1024;
#line 295
    ino ++;
    {
#line 295
    while (1) {
      while_continue: /* CIL Label */ ;
#line 295
      if (! (n > 0)) {
#line 295
        goto while_break;
      }
#line 296
      if ((int )*(ino + 0) > off) {
#line 298
        return (0);
      } else
#line 296
      if ((int )*(ino + 1) > off) {
#line 298
        return (0);
      } else
#line 296
      if ((int )*(ino + 1) > (int )*(ino + 0)) {
#line 298
        return (0);
      }
#line 299
      off = (int )*(ino + 1);
#line 300
      n -= 2;
#line 295
      ino += 2;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 303
  return (1);
}
}
#line 435 "/usr/include/libio.h"
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 168 "/usr/include/stdio.h"
extern struct _IO_FILE *stdin ;
#line 67 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.h"
DBM *dbm_open(char *file , int flags , int mode ) ;
#line 68
void dbm_close(DBM *db ) ;
#line 69
datum dbm_fetch(DBM *db , datum key ) ;
#line 70
int dbm_delete(DBM *db , datum key ) ;
#line 71
int dbm_store(DBM *db , datum key , datum val , int flags ) ;
#line 72
datum dbm_firstkey(DBM *db ) ;
#line 73
datum dbm_nextkey(DBM *db ) ;
#line 236 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 25 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
extern int getopt() ;
#line 30 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
static int rflag  ;
#line 31 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
static char *usage  =    (char *)"%s [-R] cat | look |... dbmname";
#line 50 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
static cmd cmds[17]  = 
#line 50
  {      {(char *)"fetch", 1, 0}, 
        {(char *)"get", 1, 0}, 
        {(char *)"look", 1, 0}, 
        {(char *)"add", 2, 2}, 
        {(char *)"insert", 2, 2}, 
        {(char *)"store", 2, 2}, 
        {(char *)"delete", 3, 2}, 
        {(char *)"remove", 3, 2}, 
        {(char *)"dump", 4, 0}, 
        {(char *)"list", 4, 0}, 
        {(char *)"cat", 4, 0}, 
        {(char *)"creat", 7, 578}, 
        {(char *)"new", 7, 578}, 
        {(char *)"build", 5, 66}, 
        {(char *)"squash", 6, 2}, 
        {(char *)"compact", 6, 2}, 
        {(char *)"compress", 6, 2}};
#line 73
static cmd *parse(char *str ) ;
#line 74
static void badk(char *word ) ;
#line 74
static void doit(cmd *act , char *file ) ;
#line 74
static void prdatum(FILE *stream , datum d ) ;
#line 83
extern int optind ;
#line 109 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
static void doit(cmd *act , char *file ) 
{ 
  datum key ;
  datum val ;
  register DBM *db ;
  register char *op ;
  register int n ;
  char *line ;
  int tmp ;
  size_t tmp___0 ;
  char *tmp___1 ;
  size_t tmp___2 ;
  int tmp___3 ;
  char *tmp___4 ;
  datum tmp___5 ;
  size_t tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 125
  db = dbm_open(file, act->flags, 420);
  }
#line 125
  if ((unsigned long )db == (unsigned long )((void *)0)) {
    {
#line 126
    oops("cannot open: %s", file);
    }
  }
  {
#line 128
  tmp = (int )malloc(8192);
#line 128
  line = (char *)tmp;
  }
#line 128
  if ((unsigned long )line == (unsigned long )((void *)0)) {
    {
#line 129
    oops("%s: cannot get memory", "line alloc");
    }
  }
  {
#line 133
  if (act->scode == 1) {
#line 133
    goto case_1;
  }
#line 149
  if (act->scode == 2) {
#line 149
    goto case_2;
  }
#line 151
  if (act->scode == 3) {
#line 151
    goto case_3;
  }
#line 163
  if (act->scode == 4) {
#line 163
    goto case_4;
  }
#line 172
  if (act->scode == 5) {
#line 172
    goto case_5;
  }
#line 199
  if (act->scode == 6) {
#line 199
    goto case_6;
  }
#line 201
  if (act->scode == 7) {
#line 201
    goto case_7;
  }
#line 131
  goto switch_break;
  case_1: /* CIL Label */ 
  {
#line 134
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 134
    tmp___1 = fgets((char */* __restrict  */)line, 8192, (FILE */* __restrict  */)stdin);
    }
#line 134
    if (! ((unsigned long )tmp___1 != (unsigned long )((void *)0))) {
#line 134
      goto while_break;
    }
    {
#line 135
    tmp___0 = strlen((char const   *)line);
#line 135
    n = (int )(tmp___0 - 1UL);
#line 136
    *(line + n) = (char)0;
#line 137
    key.dptr = line;
#line 138
    key.dsize = n;
#line 139
    val = dbm_fetch(db, key);
    }
#line 140
    if ((unsigned long )val.dptr != (unsigned long )((void *)0)) {
      {
#line 141
      prdatum(stdout, val);
#line 142
      putchar('\n');
      }
#line 143
      goto while_continue;
    }
    {
#line 145
    prdatum(stderr, key);
#line 146
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": not found.\n");
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 148
  goto switch_break;
  case_2: /* CIL Label */ 
#line 150
  goto switch_break;
  case_3: /* CIL Label */ 
  {
#line 152
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 152
    tmp___4 = fgets((char */* __restrict  */)line, 8192, (FILE */* __restrict  */)stdin);
    }
#line 152
    if (! ((unsigned long )tmp___4 != (unsigned long )((void *)0))) {
#line 152
      goto while_break___0;
    }
    {
#line 153
    tmp___2 = strlen((char const   *)line);
#line 153
    n = (int )(tmp___2 - 1UL);
#line 154
    *(line + n) = (char)0;
#line 155
    key.dptr = line;
#line 156
    key.dsize = n;
#line 157
    tmp___3 = dbm_delete(db, key);
    }
#line 157
    if (tmp___3 == -1) {
      {
#line 158
      prdatum(stderr, key);
#line 159
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": not found.\n");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 162
  goto switch_break;
  case_4: /* CIL Label */ 
  {
#line 164
  key = dbm_firstkey(db);
  }
  {
#line 164
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 164
    if (! ((unsigned long )key.dptr != (unsigned long )((char *)0))) {
#line 164
      goto while_break___1;
    }
    {
#line 166
    prdatum(stdout, key);
#line 167
    putchar('\t');
#line 168
    tmp___5 = dbm_fetch(db, key);
#line 168
    prdatum(stdout, tmp___5);
#line 169
    putchar('\n');
#line 164
    key = dbm_nextkey(db);
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 171
  goto switch_break;
  case_5: /* CIL Label */ 
  {
#line 176
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 176
    tmp___9 = fgets((char */* __restrict  */)line, 8192, (FILE */* __restrict  */)stdin);
    }
#line 176
    if (! ((unsigned long )tmp___9 != (unsigned long )((void *)0))) {
#line 176
      goto while_break___2;
    }
    {
#line 177
    tmp___6 = strlen((char const   *)line);
#line 177
    n = (int )(tmp___6 - 1UL);
#line 178
    *(line + n) = (char)0;
#line 179
    key.dptr = line;
#line 180
    op = strchr((char const   *)line, '\t');
    }
#line 180
    if ((unsigned long )op != (unsigned long )((char *)0)) {
#line 181
      key.dsize = (int )(op - line);
#line 182
      tmp___7 = op;
#line 182
      op ++;
#line 182
      *tmp___7 = (char)0;
#line 183
      val.dptr = op;
#line 184
      val.dsize = (int )((line + n) - op);
    } else {
      {
#line 187
      oops("bad input; %s", line);
      }
    }
    {
#line 189
    tmp___8 = dbm_store(db, key, val, 1);
    }
#line 189
    if (tmp___8 < 0) {
      {
#line 190
      prdatum(stderr, key);
#line 191
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": ");
#line 192
      oops("store: %s", "failed");
      }
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 198
  goto switch_break;
  case_6: /* CIL Label */ 
#line 200
  goto switch_break;
  case_7: /* CIL Label */ 
#line 202
  goto switch_break;
  switch_break: /* CIL Label */ ;
  }
  {
#line 205
  dbm_close(db);
  }
#line 206
  return;
}
}
#line 208 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
static void badk(char *word ) 
{ 
  register int i ;
  int tmp ;

  {
#line 214
  if (progname) {
    {
#line 215
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: ",
            progname);
    }
  }
  {
#line 216
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bad keywd %s. use one of\n",
          word);
#line 217
  i = 0;
  }
  {
#line 217
  while (1) {
    while_continue: /* CIL Label */ ;
#line 217
    if (! (i < (int )(sizeof(cmds) / sizeof(cmd )))) {
#line 217
      goto while_break;
    }
#line 218
    if ((i + 1) % 6 == 0) {
#line 218
      tmp = '\n';
    } else {
#line 218
      tmp = ' ';
    }
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%-8s%c",
            cmds[i].sname, tmp);
#line 217
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 220
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\n");
#line 221
  exit(1);
  }
}
}
#line 225 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
static cmd *parse(char *str ) 
{ 
  register int i ;
  register cmd *p ;
  int tmp ;
  int tmp___0 ;

  {
#line 229
  i = (int )(sizeof(cmds) / sizeof(cmd ));
#line 232
  p = cmds;
  {
#line 232
  while (1) {
    while_continue: /* CIL Label */ ;
#line 232
    tmp___0 = i;
#line 232
    i --;
#line 232
    if (! tmp___0) {
#line 232
      goto while_break;
    }
    {
#line 233
    tmp = strcmp((char const   *)p->sname, (char const   *)str);
    }
#line 233
    if (tmp == 0) {
#line 234
      return (p);
    }
#line 232
    p ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  return ((cmd *)((void *)0));
}
}
#line 238 "/home/june/collector/temp/acm-5.0/dis/sdbm/dbu.c"
static void prdatum(FILE *stream , datum d ) 
{ 
  register int c ;
  register char *p ;
  register int n ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 244
  p = d.dptr;
#line 245
  n = d.dsize;
#line 247
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\"");
  }
  {
#line 248
  while (1) {
    while_continue: /* CIL Label */ ;
#line 248
    tmp___1 = n;
#line 248
    n --;
#line 248
    if (! tmp___1) {
#line 248
      goto while_break;
    }
#line 249
    tmp = p;
#line 249
    p ++;
#line 249
    c = (int )*tmp & 255;
#line 250
    if (c & 128) {
      {
#line 251
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"M-");
#line 252
      c &= 127;
      }
    }
#line 254
    if (c == 127) {
#line 254
      goto _L;
    } else
#line 254
    if (c < 32) {
      _L: /* CIL Label */ 
#line 255
      if (c == 127) {
#line 255
        tmp___0 = '?';
      } else {
#line 255
        tmp___0 = c + 64;
      }
      {
#line 255
      fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"^%c",
              tmp___0);
      }
    } else {
      {
#line 257
      _IO_putc(c, stream);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 259
  fprintf((FILE */* __restrict  */)stream, (char const   */* __restrict  */)"\"");
  }
#line 260
  return;
}
}
#line 78 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.h"
DBM *dbm_prep(char *dirname , char *pagname , int flags , int mode ) ;
#line 334 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) __off_t ( __attribute__((__leaf__)) lseek)(int __fd ,
                                                                                __off_t __offset ,
                                                                                int __whence ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 137 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 214 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(2), __leaf__)) fstat)(int __fd ,
                                                                                            struct stat *__buf ) ;
#line 70 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
static int getdbit(DBM *db , long dbit ) ;
#line 71
static int setdbit(DBM *db , long dbit ) ;
#line 72
static int getpage(DBM *db , long hash ) ;
#line 73
static datum getnext(DBM *db ) ;
#line 74
static int makroom(DBM *db , long hash , int need ) ;
#line 86 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
static long masks[32]  = 
#line 86
  {      0L,      1L,      3L,      7L, 
        15L,      31L,      63L,      127L, 
        255L,      511L,      1023L,      2047L, 
        4095L,      8191L,      16383L,      32767L, 
        65535L,      131071L,      262143L,      524287L, 
        1048575L,      2097151L,      4194303L,      8388607L, 
        16777215L,      33554431L,      67108863L,      134217727L, 
        268435455L,      536870911L,      1073741823L,      2147483647L};
#line 97 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
datum nullitem  =    {(char *)((void *)0), 0};
#line 99 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
DBM *dbm_open(char *file , int flags , int mode ) 
{ 
  register DBM *db ;
  register char *dirname ;
  register char *pagname ;
  register int n ;
  int *tmp ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  int *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  size_t tmp___6 ;

  {
#line 110
  if ((unsigned long )file == (unsigned long )((void *)0)) {
    {
#line 111
    tmp = __errno_location();
#line 111
    *tmp = 22;
    }
#line 111
    return ((DBM *)((void *)0));
  } else
#line 110
  if (! *file) {
    {
#line 111
    tmp = __errno_location();
#line 111
    *tmp = 22;
    }
#line 111
    return ((DBM *)((void *)0));
  }
  {
#line 115
  tmp___0 = strlen((char const   *)file);
#line 115
  tmp___1 = strlen(".dir");
#line 115
  tmp___2 = strlen(".pag");
#line 115
  n = (int )(((tmp___0 * 2UL + tmp___1) + tmp___2) + 2UL);
#line 117
  tmp___4 = (int )malloc((unsigned int )n);
#line 117
  dirname = (char *)tmp___4;
  }
#line 117
  if ((unsigned long )dirname == (unsigned long )((void *)0)) {
    {
#line 118
    tmp___3 = __errno_location();
#line 118
    *tmp___3 = 12;
    }
#line 118
    return ((DBM *)((void *)0));
  }
  {
#line 122
  tmp___5 = strcpy((char */* __restrict  */)dirname, (char const   */* __restrict  */)file);
#line 122
  dirname = strcat((char */* __restrict  */)tmp___5, (char const   */* __restrict  */)".dir");
#line 123
  tmp___6 = strlen((char const   *)dirname);
#line 123
  pagname = strcpy((char */* __restrict  */)((dirname + tmp___6) + 1), (char const   */* __restrict  */)file);
#line 124
  pagname = strcat((char */* __restrict  */)pagname, (char const   */* __restrict  */)".pag");
#line 126
  db = dbm_prep(dirname, pagname, flags, mode);
#line 127
  free((void *)dirname);
  }
#line 128
  return (db);
}
}
#line 131 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
DBM *dbm_prep(char *dirname , char *pagname , int flags , int mode ) 
{ 
  register DBM *db ;
  struct stat dstat ;
  int *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 141
  tmp___0 = (int )malloc(sizeof(DBM ));
#line 141
  db = (DBM *)tmp___0;
  }
#line 141
  if ((unsigned long )db == (unsigned long )((void *)0)) {
    {
#line 142
    tmp = __errno_location();
#line 142
    *tmp = 12;
    }
#line 142
    return ((DBM *)((void *)0));
  }
#line 144
  db->flags = 0;
#line 145
  db->hmask = 0L;
#line 146
  db->blkptr = 0L;
#line 147
  db->keyptr = 0;
#line 153
  if (flags & 1) {
#line 154
    flags = (flags & -2) | 2;
  } else
#line 156
  if ((flags & 3) == 0) {
#line 157
    db->flags = 1;
  }
  {
#line 162
  tmp___3 = open((char const   *)pagname, flags, mode);
#line 162
  db->pagf = tmp___3;
  }
#line 162
  if (tmp___3 > -1) {
    {
#line 163
    tmp___2 = open((char const   *)dirname, flags, mode);
#line 163
    db->dirf = tmp___2;
    }
#line 163
    if (tmp___2 > -1) {
      {
#line 167
      tmp___1 = fstat(db->dirf, & dstat);
      }
#line 167
      if (tmp___1 == 0) {
#line 172
        if (! dstat.st_size) {
#line 172
          db->dirbno = 0L;
        } else {
#line 172
          db->dirbno = -1L;
        }
        {
#line 173
        db->pagbno = -1L;
#line 174
        db->maxbno = dstat.st_size * 8L;
#line 176
        memset((void *)(db->pagbuf), 0, (size_t )1024);
#line 177
        memset((void *)(db->dirbuf), 0, (size_t )4096);
        }
#line 181
        return (db);
      }
      {
#line 183
      close(db->dirf);
      }
    }
    {
#line 185
    close(db->pagf);
    }
  }
  {
#line 187
  free((void *)((char *)db));
  }
#line 188
  return ((DBM *)((void *)0));
}
}
#line 191 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
void dbm_close(DBM *db ) 
{ 
  int *tmp ;

  {
#line 195
  if ((unsigned long )db == (unsigned long )((void *)0)) {
    {
#line 196
    tmp = __errno_location();
#line 196
    *tmp = 22;
    }
  } else {
    {
#line 198
    close(db->dirf);
#line 199
    close(db->pagf);
#line 200
    free((void *)((char *)db));
    }
  }
#line 202
  return;
}
}
#line 204 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
datum dbm_fetch(DBM *db , datum key ) 
{ 
  int *tmp ;
  datum tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;

  {
#line 209
  if ((unsigned long )db == (unsigned long )((void *)0)) {
    {
#line 210
    tmp = __errno_location();
#line 210
    *tmp = 22;
    }
#line 210
    return (nullitem);
  } else
#line 209
  if ((unsigned long )key.dptr == (unsigned long )((void *)0)) {
    {
#line 210
    tmp = __errno_location();
#line 210
    *tmp = 22;
    }
#line 210
    return (nullitem);
  } else
#line 209
  if (key.dsize <= 0) {
    {
#line 210
    tmp = __errno_location();
#line 210
    *tmp = 22;
    }
#line 210
    return (nullitem);
  }
  {
#line 212
  tmp___1 = dbm_hash(key.dptr, key.dsize);
#line 212
  tmp___2 = getpage(db, tmp___1);
  }
#line 212
  if (tmp___2) {
    {
#line 213
    tmp___0 = getpair(db->pagbuf, key);
    }
#line 213
    return (tmp___0);
  }
#line 215
  db->flags |= 2;
#line 215
  return (nullitem);
}
}
#line 218 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
int dbm_delete(DBM *db , datum key ) 
{ 
  int *tmp ;
  int *tmp___0 ;
  int tmp___1 ;
  __off_t tmp___2 ;
  ssize_t tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;

  {
#line 223
  if ((unsigned long )db == (unsigned long )((void *)0)) {
    {
#line 224
    tmp = __errno_location();
#line 224
    *tmp = 22;
    }
#line 224
    return (-1);
  } else
#line 223
  if ((unsigned long )key.dptr == (unsigned long )((void *)0)) {
    {
#line 224
    tmp = __errno_location();
#line 224
    *tmp = 22;
    }
#line 224
    return (-1);
  } else
#line 223
  if (key.dsize <= 0) {
    {
#line 224
    tmp = __errno_location();
#line 224
    *tmp = 22;
    }
#line 224
    return (-1);
  }
#line 225
  if (db->flags & 1) {
    {
#line 226
    tmp___0 = __errno_location();
#line 226
    *tmp___0 = 1;
    }
#line 226
    return (-1);
  }
  {
#line 228
  tmp___4 = dbm_hash(key.dptr, key.dsize);
#line 228
  tmp___5 = getpage(db, tmp___4);
  }
#line 228
  if (tmp___5) {
    {
#line 229
    tmp___1 = delpair(db->pagbuf, key);
    }
#line 229
    if (! tmp___1) {
#line 230
      return (-1);
    }
    {
#line 234
    tmp___2 = lseek(db->pagf, db->pagbno * 1024L, 0);
    }
#line 234
    if (tmp___2 < 0L) {
#line 236
      db->flags |= 2;
#line 236
      return (-1);
    } else {
      {
#line 234
      tmp___3 = write(db->pagf, (void const   *)(db->pagbuf), (size_t )1024);
      }
#line 234
      if (tmp___3 < 0L) {
#line 236
        db->flags |= 2;
#line 236
        return (-1);
      }
    }
#line 238
    return (0);
  }
#line 241
  db->flags |= 2;
#line 241
  return (-1);
}
}
#line 244 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
int dbm_store(DBM *db , datum key , datum val , int flags ) 
{ 
  int need ;
  register long hash ;
  int *tmp ;
  int *tmp___0 ;
  int *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  __off_t tmp___5 ;
  ssize_t tmp___6 ;
  int tmp___7 ;

  {
#line 254
  if ((unsigned long )db == (unsigned long )((void *)0)) {
    {
#line 255
    tmp = __errno_location();
#line 255
    *tmp = 22;
    }
#line 255
    return (-1);
  } else
#line 254
  if ((unsigned long )key.dptr == (unsigned long )((void *)0)) {
    {
#line 255
    tmp = __errno_location();
#line 255
    *tmp = 22;
    }
#line 255
    return (-1);
  } else
#line 254
  if (key.dsize <= 0) {
    {
#line 255
    tmp = __errno_location();
#line 255
    *tmp = 22;
    }
#line 255
    return (-1);
  }
#line 256
  if (db->flags & 1) {
    {
#line 257
    tmp___0 = __errno_location();
#line 257
    *tmp___0 = 1;
    }
#line 257
    return (-1);
  }
#line 259
  need = key.dsize + val.dsize;
#line 263
  if (need < 0) {
    {
#line 264
    tmp___1 = __errno_location();
#line 264
    *tmp___1 = 22;
    }
#line 264
    return (-1);
  } else
#line 263
  if (need > 1008) {
    {
#line 264
    tmp___1 = __errno_location();
#line 264
    *tmp___1 = 22;
    }
#line 264
    return (-1);
  }
  {
#line 266
  hash = dbm_hash(key.dptr, key.dsize);
#line 266
  tmp___7 = getpage(db, hash);
  }
#line 266
  if (tmp___7) {
#line 271
    if (flags == 1) {
      {
#line 272
      delpair(db->pagbuf, key);
      }
    } else {
      {
#line 274
      tmp___2 = duppair(db->pagbuf, key);
      }
#line 274
      if (tmp___2) {
#line 275
        return (1);
      }
    }
    {
#line 280
    tmp___4 = fitpair(db->pagbuf, need);
    }
#line 280
    if (! tmp___4) {
      {
#line 281
      tmp___3 = makroom(db, hash, need);
      }
#line 281
      if (! tmp___3) {
#line 282
        db->flags |= 2;
#line 282
        return (-1);
      }
    }
    {
#line 287
    putpair(db->pagbuf, key, val);
#line 289
    tmp___5 = lseek(db->pagf, db->pagbno * 1024L, 0);
    }
#line 289
    if (tmp___5 < 0L) {
#line 291
      db->flags |= 2;
#line 291
      return (-1);
    } else {
      {
#line 289
      tmp___6 = write(db->pagf, (void const   *)(db->pagbuf), (size_t )1024);
      }
#line 289
      if (tmp___6 < 0L) {
#line 291
        db->flags |= 2;
#line 291
        return (-1);
      }
    }
#line 295
    return (0);
  }
#line 298
  db->flags |= 2;
#line 298
  return (-1);
}
}
#line 306 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
static int makroom(DBM *db , long hash , int need ) 
{ 
  long newp ;
  char twin[1024] ;
  char *pag ;
  char *new ;
  register int smax ;
  __off_t tmp ;
  ssize_t tmp___0 ;
  __off_t tmp___1 ;
  ssize_t tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  __off_t tmp___6 ;
  ssize_t tmp___7 ;

  {
#line 314
  pag = db->pagbuf;
#line 315
  new = twin;
#line 316
  smax = 10;
  {
#line 318
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 322
    splpage(pag, new, db->hmask + 1L);
#line 326
    newp = (hash & db->hmask) | (db->hmask + 1L);
    }
#line 336
    if (hash & (db->hmask + 1L)) {
      {
#line 337
      tmp = lseek(db->pagf, db->pagbno * 1024L, 0);
      }
#line 337
      if (tmp < 0L) {
#line 339
        return (0);
      } else {
        {
#line 337
        tmp___0 = write(db->pagf, (void const   *)(db->pagbuf), (size_t )1024);
        }
#line 337
        if (tmp___0 < 0L) {
#line 339
          return (0);
        }
      }
      {
#line 340
      db->pagbno = newp;
#line 341
      memcpy((void */* __restrict  */)pag, (void const   */* __restrict  */)new, (size_t )1024);
      }
    } else {
      {
#line 343
      tmp___1 = lseek(db->pagf, newp * 1024L, 0);
      }
#line 343
      if (tmp___1 < 0L) {
#line 345
        return (0);
      } else {
        {
#line 343
        tmp___2 = write(db->pagf, (void const   *)new, (size_t )1024);
        }
#line 343
        if (tmp___2 < 0L) {
#line 345
          return (0);
        }
      }
    }
    {
#line 347
    tmp___3 = setdbit(db, db->curbit);
    }
#line 347
    if (! tmp___3) {
#line 348
      return (0);
    }
    {
#line 352
    tmp___4 = fitpair(pag, need);
    }
#line 352
    if (tmp___4) {
#line 353
      return (1);
    }
#line 360
    if (hash & (db->hmask + 1L)) {
#line 360
      tmp___5 = 2;
    } else {
#line 360
      tmp___5 = 1;
    }
    {
#line 360
    db->curbit = 2L * db->curbit + (long )tmp___5;
#line 362
    db->hmask |= db->hmask + 1L;
#line 364
    tmp___6 = lseek(db->pagf, db->pagbno * 1024L, 0);
    }
#line 364
    if (tmp___6 < 0L) {
#line 366
      return (0);
    } else {
      {
#line 364
      tmp___7 = write(db->pagf, (void const   *)(db->pagbuf), (size_t )1024);
      }
#line 364
      if (tmp___7 < 0L) {
#line 366
        return (0);
      }
    }
#line 318
    smax --;
#line 318
    if (! smax) {
#line 318
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 374
  write(2, (void const   *)"sdbm: cannot insert after SPLTMAX attempts.\n", (size_t )44);
  }
#line 376
  return (0);
}
}
#line 384 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
datum dbm_firstkey(DBM *db ) 
{ 
  int *tmp ;
  __off_t tmp___0 ;
  ssize_t tmp___1 ;
  datum tmp___2 ;

  {
#line 388
  if ((unsigned long )db == (unsigned long )((void *)0)) {
    {
#line 389
    tmp = __errno_location();
#line 389
    *tmp = 22;
    }
#line 389
    return (nullitem);
  }
  {
#line 393
  tmp___0 = lseek(db->pagf, 0L, 0);
  }
#line 393
  if (tmp___0 < 0L) {
#line 395
    db->flags |= 2;
#line 395
    return (nullitem);
  } else {
    {
#line 393
    tmp___1 = read(db->pagf, (void *)(db->pagbuf), (size_t )1024);
    }
#line 393
    if (tmp___1 < 0L) {
#line 395
      db->flags |= 2;
#line 395
      return (nullitem);
    }
  }
  {
#line 396
  db->pagbno = 0L;
#line 397
  db->blkptr = 0L;
#line 398
  db->keyptr = 0;
#line 400
  tmp___2 = getnext(db);
  }
#line 400
  return (tmp___2);
}
}
#line 403 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
datum dbm_nextkey(DBM *db ) 
{ 
  int *tmp ;
  datum tmp___0 ;

  {
#line 407
  if ((unsigned long )db == (unsigned long )((void *)0)) {
    {
#line 408
    tmp = __errno_location();
#line 408
    *tmp = 22;
    }
#line 408
    return (nullitem);
  }
  {
#line 409
  tmp___0 = getnext(db);
  }
#line 409
  return (tmp___0);
}
}
#line 415 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
static int getpage(DBM *db , long hash ) 
{ 
  register int hbit ;
  register long dbit ;
  register long pagb ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  __off_t tmp___3 ;
  ssize_t tmp___4 ;
  int tmp___5 ;

  {
#line 424
  dbit = 0L;
#line 425
  hbit = 0;
  {
#line 426
  while (1) {
    while_continue: /* CIL Label */ ;
#line 426
    if (dbit < db->maxbno) {
      {
#line 426
      tmp___2 = getdbit(db, dbit);
      }
#line 426
      if (! tmp___2) {
#line 426
        goto while_break;
      }
    } else {
#line 426
      goto while_break;
    }
#line 427
    tmp___1 = hbit;
#line 427
    hbit ++;
#line 427
    if (hash & (long )(1 << tmp___1)) {
#line 427
      tmp___0 = 2;
    } else {
#line 427
      tmp___0 = 1;
    }
#line 427
    dbit = 2L * dbit + (long )tmp___0;
  }
  while_break: /* CIL Label */ ;
  }
#line 431
  db->curbit = dbit;
#line 432
  db->hmask = masks[hbit];
#line 434
  pagb = hash & db->hmask;
#line 439
  if (pagb != db->pagbno) {
    {
#line 444
    tmp___3 = lseek(db->pagf, pagb * 1024L, 0);
    }
#line 444
    if (tmp___3 < 0L) {
#line 446
      return (0);
    } else {
      {
#line 444
      tmp___4 = read(db->pagf, (void *)(db->pagbuf), (size_t )1024);
      }
#line 444
      if (tmp___4 < 0L) {
#line 446
        return (0);
      }
    }
    {
#line 447
    tmp___5 = chkpage(db->pagbuf);
    }
#line 447
    if (! tmp___5) {
#line 448
      return (0);
    }
#line 449
    db->pagbno = pagb;
  }
#line 453
  return (1);
}
}
#line 456 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
static int getdbit(DBM *db , long dbit ) 
{ 
  register long c ;
  register long dirb ;
  __off_t tmp ;
  ssize_t tmp___0 ;

  {
#line 464
  c = dbit / 8L;
#line 465
  dirb = c / 4096L;
#line 467
  if (dirb != db->dirbno) {
    {
#line 468
    tmp = lseek(db->dirf, dirb * 4096L, 0);
    }
#line 468
    if (tmp < 0L) {
#line 470
      return (0);
    } else {
      {
#line 468
      tmp___0 = read(db->dirf, (void *)(db->dirbuf), (size_t )4096);
      }
#line 468
      if (tmp___0 < 0L) {
#line 470
        return (0);
      }
    }
#line 471
    db->dirbno = dirb;
  }
#line 476
  return ((int )db->dirbuf[c % 4096L] & (1 << dbit % 8L));
}
}
#line 479 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
static int setdbit(DBM *db , long dbit ) 
{ 
  register long c ;
  register long dirb ;
  __off_t tmp ;
  ssize_t tmp___0 ;
  __off_t tmp___1 ;
  ssize_t tmp___2 ;

  {
#line 487
  c = dbit / 8L;
#line 488
  dirb = c / 4096L;
#line 490
  if (dirb != db->dirbno) {
    {
#line 491
    tmp = lseek(db->dirf, dirb * 4096L, 0);
    }
#line 491
    if (tmp < 0L) {
#line 493
      return (0);
    } else {
      {
#line 491
      tmp___0 = read(db->dirf, (void *)(db->dirbuf), (size_t )4096);
      }
#line 491
      if (tmp___0 < 0L) {
#line 493
        return (0);
      }
    }
#line 494
    db->dirbno = dirb;
  }
#line 499
  db->dirbuf[c % 4096L] = (char )((int )db->dirbuf[c % 4096L] | (1 << dbit % 8L));
#line 501
  if (dbit >= db->maxbno) {
#line 502
    db->maxbno += 32768L;
  }
  {
#line 504
  tmp___1 = lseek(db->dirf, dirb * 4096L, 0);
  }
#line 504
  if (tmp___1 < 0L) {
#line 506
    return (0);
  } else {
    {
#line 504
    tmp___2 = write(db->dirf, (void const   *)(db->dirbuf), (size_t )4096);
    }
#line 504
    if (tmp___2 < 0L) {
#line 506
      return (0);
    }
  }
#line 508
  return (1);
}
}
#line 515 "/home/june/collector/temp/acm-5.0/dis/sdbm/sdbm.c"
static datum getnext(DBM *db ) 
{ 
  datum key ;
  __off_t tmp ;
  long tmp___0 ;
  ssize_t tmp___1 ;
  int tmp___2 ;

  {
  {
#line 521
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 522
    (db->keyptr) ++;
#line 523
    key = getnkey(db->pagbuf, db->keyptr);
    }
#line 524
    if ((unsigned long )key.dptr != (unsigned long )((void *)0)) {
#line 525
      return (key);
    }
#line 531
    db->keyptr = 0;
#line 532
    tmp___0 = db->blkptr;
#line 532
    (db->blkptr) ++;
#line 532
    if (db->pagbno != tmp___0) {
      {
#line 533
      tmp = lseek(db->pagf, db->blkptr * 1024L, 0);
      }
#line 533
      if (tmp < 0L) {
#line 534
        goto while_break;
      }
    }
    {
#line 535
    db->pagbno = db->blkptr;
#line 536
    tmp___1 = read(db->pagf, (void *)(db->pagbuf), (size_t )1024);
    }
#line 536
    if (tmp___1 <= 0L) {
#line 537
      goto while_break;
    }
    {
#line 538
    tmp___2 = chkpage(db->pagbuf);
    }
#line 538
    if (! tmp___2) {
#line 539
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 542
  db->flags |= 2;
#line 542
  return (nullitem);
}
}
