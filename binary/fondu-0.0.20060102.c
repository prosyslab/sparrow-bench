/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 315 "/usr/include/libio.h"
typedef struct _IO_FILE _IO_FILE;
#line 35 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
typedef unsigned int uint32;
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
typedef unsigned short uint16;
#line 87
struct resource;
#line 87 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
struct resource_types {
   uint32 tag ;
   struct resource *res ;
   struct resource_types *next ;
   uint32 pos ;
   uint32 resloc ;
   int cnt ;
};
#line 95 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
struct resource {
   uint16 id ;
   uint16 new_id ;
   int flags ;
   FILE *srcf ;
   uint32 src_off ;
   char *name ;
   struct resource *next ;
   uint32 name_off ;
   uint32 merged_off ;
   uint32 nameptloc ;
};
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 49 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
typedef unsigned char uint8;
#line 98 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
struct macbinaryheader {
   char *macfilename ;
   char *binfilename ;
   uint32 type ;
   uint32 creator ;
};
#line 124 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __dev_t;
#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 130 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __nlink_t;
#line 153 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blksize_t;
#line 158 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __blkcnt_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 120 "/usr/include/time.h"
struct timespec {
   __time_t tv_sec ;
   __syscall_slong_t tv_nsec ;
};
#line 46 "/usr/include/x86_64-linux-gnu/bits/stat.h"
struct stat {
   __dev_t st_dev ;
   __ino_t st_ino ;
   __nlink_t st_nlink ;
   __mode_t st_mode ;
   __uid_t st_uid ;
   __gid_t st_gid ;
   int __pad0 ;
   __dev_t st_rdev ;
   __off_t st_size ;
   __blksize_t st_blksize ;
   __blkcnt_t st_blocks ;
   struct timespec st_atim ;
   struct timespec st_mtim ;
   struct timespec st_ctim ;
   __syscall_slong_t __glibc_reserved[3] ;
};
#line 46 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
typedef short int16;
#line 56
enum face_type {
    ft_bdf = 0,
    ft_ps = 1,
    ft_ttf = 2
} ;
#line 56 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
struct face {
   char *filename ;
   enum face_type type ;
   char *fontname ;
   char *family ;
   int16 style ;
   int16 psstyle ;
   int size ;
   int fixed ;
   short metrics[256] ;
   int id ;
   int ascent ;
   int descent ;
   int linegap ;
   struct face *next ;
   int xmin ;
   int ymin ;
   int xmax ;
   int ymax ;
};
#line 56 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
typedef struct face Face;
#line 83 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
struct resource___0 {
   uint32 pos ;
   uint8 flags ;
   uint16 id ;
   char *name ;
   uint32 nameloc ;
   uint32 nameptloc ;
};
#line 105 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
struct macfont {
   short fRectWidth ;
   short fRectHeight ;
   short ascent ;
   short descent ;
   short nDescent ;
   short leading ;
   short kernMax ;
   short firstChar ;
   short lastChar ;
   short fontType ;
   short rowWords ;
   short owTLoc ;
   uint16 widmax ;
   Face *face ;
   unsigned short *widths ;
   short *lbearings ;
   unsigned short *locs ;
   unsigned short **rows ;
   unsigned short *idealwidths ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
struct bdffont {
   char **header ;
   char ***chars ;
   int charmax ;
   char *fontname ;
   int size ;
   Face *face ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
struct family {
   char *familyname ;
   int id ;
   int fixed ;
   int ascent ;
   int descent ;
   int linegap ;
   int maxwidth ;
   Face *faces[96] ;
   Face *ttffaces[96] ;
   Face *psfaces[48] ;
   struct family *next ;
};
#line 72 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
typedef struct family Family;
#line 92 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
struct resourcetype {
   uint32 tag ;
   struct resource___0 *res ;
   uint32 resloc ;
};
#line 82 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
enum output_format {
    of_dfont = 0,
    of_macbin = 1,
    of_res = 2
} ;
#line 39 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondttf.c"
struct ttfinfo {
   long cmap_start ;
   long head_start ;
   long hhea_start ;
   long hmtx_start ;
   long maxp_start ;
   long name_start ;
   long post_start ;
   int max_glyph ;
   int glyphs[256] ;
   int emsize ;
   int macstyle ;
   int longmtx ;
   int isfixed ;
   short metrics[256] ;
   char *fontname ;
   char *familyname ;
};
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
struct assoc {
   short size ;
   short style ;
   short id ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
struct stylewidths {
   short style ;
   short *widthtab ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
struct kerns {
   unsigned char ch1 ;
   unsigned char ch2 ;
   short offset ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
struct stylekerns {
   short style ;
   int kernpairs ;
   struct kerns *kerns ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
struct fond {
   char *fondname ;
   int first ;
   int last ;
   int assoc_cnt ;
   struct assoc *assoc ;
   int stylewidthcnt ;
   struct stylewidths *stylewidths ;
   int stylekerncnt ;
   struct stylekerns *stylekerns ;
   char *psnames[48] ;
   char *family ;
   struct fond *next ;
};
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
typedef struct fond FOND;
#line 66 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
struct bbglyph {
   char *glyphname ;
   int top ;
   int bottom ;
   int left ;
   int right ;
   int hadvance ;
   int isref ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
struct PSFONT {
   char *fontname ;
   char *familyname ;
   char *weight ;
   char *fullname ;
   char *notice ;
   char *version ;
   double italicangle ;
   double em ;
   double fbb[4] ;
   int as ;
   int ds ;
   int ch ;
   int xh ;
   int isadobestd ;
   int glyphcnt ;
   struct bbglyph *glyphs ;
   short encoding[256] ;
   void *temp ;
};
#line 66 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
typedef struct PSFONT PSFONT;
#line 41 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/psfont.h"
struct charprocs {
   int cnt ;
   int next ;
   char **keys ;
   void **values ;
};
#line 47 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/psfont.h"
struct psdict {
   int cnt ;
   int next ;
   char **keys ;
   char **values ;
};
#line 53 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/psfont.h"
struct pschars {
   int cnt ;
   int next ;
   char **keys ;
   unsigned char **values ;
   int *lens ;
   int bias ;
};
#line 61 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/psfont.h"
struct fontinfo {
   char *familyname ;
   char *fullname ;
   char *notice ;
   char *weight ;
   char *version ;
   double italicangle ;
   unsigned int isfixedpitch : 1 ;
   double underlineposition ;
   double underlinethickness ;
   int em ;
   int ascent ;
   int descent ;
   int fstype ;
   char *blenddesignpositions ;
   char *blenddesignmap ;
   char *blendaxistypes ;
};
#line 79 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/psfont.h"
struct private {
   struct psdict *private ;
   struct pschars *subrs ;
   int leniv ;
};
#line 118
struct splinefont;
#line 118 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/psfont.h"
struct fontdict {
   int fonttype ;
   double fontmatrix[6] ;
   char *fontname ;
   struct fontinfo *fontinfo ;
   int languagelevel ;
   int wmode ;
   int isadobestd ;
   char *encoding[256] ;
   double fontbb[4] ;
   int uniqueid ;
   int xuid[20] ;
   int painttype ;
   double strokewidth ;
   struct psdict *metrics ;
   struct psdict *metrics2 ;
   struct pschars *chars ;
   struct charprocs *charprocs ;
   struct private *private ;
   unsigned int wasbinary : 1 ;
   unsigned int wascff : 1 ;
   int fdcnt ;
   struct fontdict **fds ;
   char *cidfontname ;
   int cidfonttype ;
   double cidversion ;
   char *registry ;
   char *ordering ;
   int supplement ;
   int mapoffset ;
   int fdbytes ;
   int gdbytes ;
   int cidcnt ;
   unsigned char **cidstrs ;
   short *cidlens ;
   short *cidfds ;
   struct splinefont *sf ;
   char *blendfunc ;
   char *weightvector ;
   char *cdv ;
   char *ndv ;
   struct psdict *blendprivate ;
   struct psdict *blendfontinfo ;
};
#line 118 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/psfont.h"
typedef struct fontdict FontDict;
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
struct fontparse {
   FontDict *fd ;
   FontDict *mainfd ;
   unsigned int infi : 1 ;
   unsigned int inchars : 1 ;
   unsigned int inprivate : 1 ;
   unsigned int insubs : 1 ;
   unsigned int inmetrics : 1 ;
   unsigned int inmetrics2 : 1 ;
   unsigned int inbb : 1 ;
   unsigned int inencoding : 1 ;
   unsigned int multiline : 1 ;
   unsigned int incidsysteminfo : 1 ;
   unsigned int inblendfi : 1 ;
   unsigned int inblendprivate : 1 ;
   unsigned int skipping_mbf : 1 ;
   unsigned int inblend : 1 ;
   unsigned int iscid : 1 ;
   unsigned int iscff : 1 ;
   unsigned int useshexstrings : 1 ;
   unsigned int doneencoding : 1 ;
   unsigned int ignore : 1 ;
   int instring ;
   int fdindex ;
   char **pending_parse ;
   unsigned int alreadycomplained : 1 ;
   char *vbuf ;
   char *vmax ;
   char *vpt ;
   int depth ;
};
#line 2499 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
struct __anonstruct_current_31 {
   double x ;
   double y ;
};
#line 2502 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
struct substate {
   unsigned char *type1 ;
   int len ;
   int subnum ;
};
#line 109 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
struct MacFontRec {
   short fontType ;
   short firstChar ;
   short lastChar ;
   short widthMax ;
   short kernMax ;
   short Descent ;
   short fRectWidth ;
   short fRectHeight ;
   unsigned short *offsetWidths ;
   short ascent ;
   short descent ;
   short leading ;
   short rowWords ;
   unsigned short *fontImage ;
   unsigned short *locs ;
};
#line 132 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
struct rect {
   short left ;
   short width ;
   short height ;
   short bottom ;
};
#line 132 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
typedef struct rect Rect;
#line 434 "/usr/include/libio.h"
extern int _IO_getc(_IO_FILE *__fp ) ;
#line 435
extern int _IO_putc(int __c , _IO_FILE *__fp ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 195
extern FILE *tmpfile(void) ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 689
extern int fputs(char const   * __restrict  __s , FILE * __restrict  __stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 754
extern long ftell(FILE *__stream ) ;
#line 759
extern void rewind(FILE *__stream ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 483
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) free)(void *__ptr ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 129 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 137
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcat)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 176
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 236
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strchr)(char const   *__s ,
                                                                                               int __c )  __attribute__((__pure__)) ;
#line 263
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strrchr)(char const   *__s ,
                                                                                                int __c )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 124
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tolower)(int __c ) ;
#line 88 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
int getushort(FILE *f ) ;
#line 89
long getlong(FILE *f ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
int getushort(FILE *f ) 
{ 
  int ch1 ;
  int tmp ;
  int ch2 ;
  int tmp___0 ;

  {
  {
#line 39
  tmp = _IO_getc(f);
#line 39
  ch1 = tmp;
#line 40
  tmp___0 = _IO_getc(f);
#line 40
  ch2 = tmp___0;
  }
#line 41
  if (ch2 == -1) {
#line 42
    return (-1);
  }
#line 43
  return ((ch1 << 8) | ch2);
}
}
#line 46 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
long getlong(FILE *f ) 
{ 
  int ch1 ;
  int tmp ;
  int ch2 ;
  int tmp___0 ;
  int ch3 ;
  int tmp___1 ;
  int ch4 ;
  int tmp___2 ;

  {
  {
#line 47
  tmp = _IO_getc(f);
#line 47
  ch1 = tmp;
#line 48
  tmp___0 = _IO_getc(f);
#line 48
  ch2 = tmp___0;
#line 49
  tmp___1 = _IO_getc(f);
#line 49
  ch3 = tmp___1;
#line 50
  tmp___2 = _IO_getc(f);
#line 50
  ch4 = tmp___2;
  }
#line 51
  if (ch4 == -1) {
#line 52
    return (-1L);
  }
#line 53
  return ((long )((((ch1 << 24) | (ch2 << 16)) | (ch3 << 8)) | ch4));
}
}
#line 56 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static void putshort___0(int val , FILE *f ) 
{ 


  {
  {
#line 57
  _IO_putc(val >> 8, f);
#line 58
  _IO_putc(val & 255, f);
  }
#line 59
  return;
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static void dousage(void) 
{ 


  {
  {
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: setfondname -name=newname font.dfont\n");
#line 63
  exit(1);
  }
}
}
#line 66 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static char *newname  ;
#line 68 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static void NewName(char *name ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
#line 69
  if ((int )*(name + 1) == 45) {
#line 70
    name ++;
  }
  {
#line 71
  tmp___0 = strcmp((char const   *)name, "-usage");
  }
#line 71
  if (tmp___0 == 0) {
    {
#line 72
    dousage();
    }
  } else {
    {
#line 73
    tmp = strncmp((char const   *)name, "-name=", (size_t )6);
    }
#line 73
    if (tmp == 0) {
      {
#line 74
      newname = strdup((char const   *)(name + 6));
      }
    } else {
      {
#line 76
      dousage();
      }
    }
  }
#line 77
  return;
}
}
#line 79 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static void ClearNames(void) 
{ 


  {
#line 80
  newname = (char *)((void *)0);
#line 81
  return;
}
}
#line 86 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static void CheckFondList(FILE *f , long rlistpos , int subcnt , long rdata_pos ,
                          long name_list ) 
{ 
  long start ;
  long tmp ;
  int i ;
  int tmp___0 ;
  unsigned int namepos ;
  long tmp___1 ;
  unsigned int nameloc ;
  long tmp___2 ;
  size_t tmp___3 ;

  {
  {
#line 88
  tmp = ftell(f);
#line 88
  start = tmp;
#line 91
  fseek(f, rlistpos, 0);
#line 92
  i = 0;
  }
  {
#line 92
  while (1) {
    while_continue: /* CIL Label */ ;
#line 92
    if (! (i < subcnt)) {
#line 92
      goto while_break;
    }
    {
#line 93
    getushort(f);
#line 94
    tmp___0 = feof(f);
    }
#line 94
    if (tmp___0) {
      {
#line 95
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF found in FOND list after reading %d resources of %d.\n",
              i, subcnt);
      }
#line 96
      goto while_break;
    }
#line 98
    if ((unsigned long )newname != (unsigned long )((void *)0)) {
      {
#line 99
      tmp___1 = ftell(f);
#line 99
      namepos = (unsigned int )tmp___1;
#line 100
      fseek(f, 0L, 2);
#line 101
      tmp___2 = ftell(f);
#line 101
      nameloc = (unsigned int )tmp___2;
#line 102
      tmp___3 = strlen((char const   *)newname);
#line 102
      _IO_putc((int )tmp___3, f);
#line 103
      fputs((char const   */* __restrict  */)newname, (FILE */* __restrict  */)f);
#line 104
      fseek(f, (long )namepos, 0);
#line 105
      putshort___0((int )((long )nameloc - name_list), f);
#line 106
      newname = (char *)((void *)0);
#line 107
      fseek(f, (long )namepos, 0);
      }
#line 108
      goto while_break;
    }
    {
#line 110
    getushort(f);
#line 111
    _IO_getc(f);
#line 111
    _IO_getc(f);
#line 111
    _IO_getc(f);
#line 112
    getlong(f);
#line 92
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 114
  fseek(f, start, 0);
  }
#line 115
  return;
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static int IsResourceFork(FILE *f , long offset ) 
{ 
  unsigned char buffer___0[16] ;
  unsigned char buffer2[16] ;
  long rdata_pos ;
  long map_pos ;
  long type_list ;
  long name_list ;
  long rpos ;
  unsigned long tag ;
  int i ;
  int cnt ;
  int subcnt ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 129
  fseek(f, offset, 0);
#line 130
  tmp = fread((void */* __restrict  */)(buffer___0), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
#line 130
  if (tmp != 16UL) {
#line 131
    return (0);
  }
  {
#line 132
  rdata_pos = offset + (long )(((((int )buffer___0[0] << 24) | ((int )buffer___0[1] << 16)) | ((int )buffer___0[2] << 8)) | (int )buffer___0[3]);
#line 133
  map_pos = offset + (long )(((((int )buffer___0[4] << 24) | ((int )buffer___0[5] << 16)) | ((int )buffer___0[6] << 8)) | (int )buffer___0[7]);
#line 134
  fseek(f, map_pos, 0);
#line 135
  buffer2[15] = (unsigned char )((int )buffer___0[15] + 1);
#line 136
  tmp___0 = fread((void */* __restrict  */)(buffer2), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
#line 136
  if (tmp___0 != 16UL) {
#line 137
    return (0);
  }
#line 141
  i = 0;
  {
#line 141
  while (1) {
    while_continue: /* CIL Label */ ;
#line 141
    if (! (i < 16)) {
#line 141
      goto while_break;
    }
#line 142
    if ((int )buffer2[i] != 0) {
#line 143
      goto while_break;
    }
#line 141
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 144
  if (i != 16) {
#line 145
    i = 0;
    {
#line 145
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 145
      if (! (i < 16)) {
#line 145
        goto while_break___0;
      }
#line 146
      if ((int )buffer___0[i] != (int )buffer2[i]) {
#line 147
        return (0);
      }
#line 145
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 148
  getlong(f);
#line 149
  getushort(f);
#line 150
  getushort(f);
#line 151
  tmp___1 = getushort(f);
#line 151
  type_list = map_pos + (long )tmp___1;
#line 152
  tmp___2 = getushort(f);
#line 152
  name_list = map_pos + (long )tmp___2;
#line 154
  fseek(f, type_list, 0);
#line 155
  tmp___3 = getushort(f);
#line 155
  cnt = tmp___3 + 1;
#line 156
  i = 0;
  }
  {
#line 156
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 156
    if (! (i < cnt)) {
#line 156
      goto while_break___1;
    }
    {
#line 157
    tmp___4 = getlong(f);
#line 157
    tag = (unsigned long )tmp___4;
#line 158
    tmp___5 = getushort(f);
#line 158
    subcnt = tmp___5 + 1;
#line 159
    tmp___6 = getushort(f);
#line 159
    rpos = type_list + (long )tmp___6;
    }
#line 160
    if (tag == (unsigned long )((((70 << 24) | (79 << 16)) | (78 << 8)) | 68)) {
      {
#line 161
      CheckFondList(f, rpos, subcnt, rdata_pos, name_list);
      }
    }
#line 156
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 163
  return (1);
}
}
#line 166 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static int HasResourceFork(char *filename ) 
{ 
  char *respath ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  FILE *temp ;
  int ret ;

  {
  {
#line 170
  tmp = strlen((char const   *)filename);
#line 170
  tmp___0 = strlen("/rsrc");
#line 170
  tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 170
  respath = (char *)tmp___1;
#line 172
  ret = 0;
#line 174
  strcpy((char */* __restrict  */)respath, (char const   */* __restrict  */)filename);
#line 175
  strcat((char */* __restrict  */)respath, (char const   */* __restrict  */)"/rsrc");
#line 176
  temp = fopen((char const   */* __restrict  */)respath, (char const   */* __restrict  */)"r+");
#line 177
  free((void *)respath);
  }
#line 178
  if ((unsigned long )temp != (unsigned long )((void *)0)) {
    {
#line 179
    ret = IsResourceFork(temp, 0L);
#line 180
    fclose(temp);
    }
  }
#line 182
  return (ret);
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static int IsResourceInBinary(FILE *f ) 
{ 
  unsigned char header[128] ;
  unsigned long offset ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 189
  tmp = fread((void */* __restrict  */)(header), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
  }
#line 189
  if (tmp != 128UL) {
#line 190
    return (0);
  }
#line 191
  if ((int )header[0] != 0) {
#line 193
    return (0);
  } else
#line 191
  if ((int )header[74] != 0) {
#line 193
    return (0);
  } else
#line 191
  if ((int )header[82] != 0) {
#line 193
    return (0);
  } else
#line 191
  if ((int )header[1] <= 0) {
#line 193
    return (0);
  } else
#line 191
  if ((int )header[1] > 33) {
#line 193
    return (0);
  } else
#line 191
  if ((int )header[63] != 0) {
#line 193
    return (0);
  } else
#line 191
  if ((int )header[2 + (int )header[1]] != 0) {
#line 193
    return (0);
  }
  {
#line 194
  offset = (unsigned long )(128 + (((((int )header[83] << 24) | ((int )header[84] << 16)) | ((int )header[85] << 8)) | (int )header[86]));
#line 195
  tmp___0 = IsResourceFork(f, (long )offset);
  }
#line 195
  return (tmp___0);
}
}
#line 198 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static int lastch  =    0;
#line 198 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static int repeat  =    0;
#line 199 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static void outchr(FILE *binary , int ch ) 
{ 
  int i ;

  {
#line 202
  if (repeat) {
#line 203
    if (ch == 0) {
      {
#line 205
      lastch = 144;
#line 206
      _IO_putc(lastch, binary);
      }
    } else {
#line 208
      i = 1;
      {
#line 208
      while (1) {
        while_continue: /* CIL Label */ ;
#line 208
        if (! (i < ch)) {
#line 208
          goto while_break;
        }
        {
#line 209
        _IO_putc(lastch, binary);
#line 208
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 211
    repeat = 0;
  } else
#line 212
  if (ch == 144) {
#line 213
    repeat = 1;
  } else {
    {
#line 215
    _IO_putc(ch, binary);
#line 216
    lastch = ch;
    }
  }
#line 218
  return;
}
}
#line 220 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static int IsResourceInHex(FILE *f ) 
{ 
  FILE *binary ;
  FILE *tmp ;
  char *sixbit ;
  int ch ;
  int val ;
  int cnt ;
  int i ;
  int dlen ;
  int rlen ;
  int ret ;
  char header[20] ;
  char *pt ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 223
  tmp = tmpfile();
#line 223
  binary = tmp;
#line 224
  sixbit = (char *)"!\"#$%&\'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr";
  }
#line 228
  if ((unsigned long )binary == (unsigned long )((void *)0)) {
    {
#line 229
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t create temporary file\n");
    }
#line 230
    return (0);
  }
#line 233
  repeat = 0;
#line 233
  lastch = repeat;
  {
#line 234
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 234
    ch = _IO_getc(f);
    }
#line 234
    if (! (ch != 58)) {
#line 234
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 235
  val = 0;
#line 235
  cnt = val;
  {
#line 236
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 236
    ch = _IO_getc(f);
    }
#line 236
    if (! (ch != 58)) {
#line 236
      goto while_break___0;
    }
    {
#line 237
    tmp___0 = __ctype_b_loc();
    }
#line 237
    if ((int const   )*(*tmp___0 + ch) & 8192) {
#line 238
      goto while_continue___0;
    }
#line 239
    pt = sixbit;
    {
#line 239
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 239
      if ((int )*pt != ch) {
#line 239
        if (! ((int )*pt != 0)) {
#line 239
          goto while_break___1;
        }
      } else {
#line 239
        goto while_break___1;
      }
#line 239
      pt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 240
    if ((int )*pt == 0) {
      {
#line 241
      fclose(binary);
      }
#line 242
      return (0);
    }
#line 244
    val = (int )((long )(val << 6) | (pt - sixbit));
#line 245
    cnt ++;
#line 245
    if (cnt == 4) {
      {
#line 246
      outchr(binary, (val >> 16) & 255);
#line 247
      outchr(binary, (val >> 8) & 255);
#line 248
      outchr(binary, val & 255);
#line 249
      cnt = 0;
#line 249
      val = cnt;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 252
  if (cnt != 0) {
#line 253
    if (cnt == 1) {
      {
#line 254
      outchr(binary, val << 2);
      }
    } else
#line 255
    if (cnt == 2) {
      {
#line 256
      val <<= 4;
#line 257
      outchr(binary, (val >> 8) & 255);
#line 258
      outchr(binary, val & 255);
      }
    } else
#line 259
    if (cnt == 3) {
      {
#line 260
      val <<= 6;
#line 261
      outchr(binary, (val >> 16) & 255);
#line 262
      outchr(binary, (val >> 8) & 255);
#line 263
      outchr(binary, val & 255);
      }
    }
  }
  {
#line 267
  rewind(binary);
#line 268
  ch = _IO_getc(binary);
#line 270
  i = 0;
  }
  {
#line 270
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 270
    if (! (i < ch)) {
#line 270
      goto while_break___2;
    }
    {
#line 271
    _IO_getc(binary);
#line 270
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 272
  tmp___1 = _IO_getc(binary);
  }
#line 272
  if (tmp___1 != 0) {
    {
#line 273
    fclose(binary);
    }
#line 274
    return (0);
  }
  {
#line 276
  fread((void */* __restrict  */)(header), (size_t )1, (size_t )20, (FILE */* __restrict  */)binary);
#line 277
  dlen = ((((int )header[10] << 24) | ((int )header[11] << 16)) | ((int )header[12] << 8)) | (int )header[13];
#line 278
  rlen = ((((int )header[14] << 24) | ((int )header[15] << 16)) | ((int )header[16] << 8)) | (int )header[17];
  }
#line 279
  if (rlen == 0) {
    {
#line 280
    fclose(binary);
    }
#line 281
    return (0);
  }
  {
#line 284
  tmp___2 = ftell(binary);
#line 284
  ret = IsResourceFork(binary, (tmp___2 + (long )dlen) + 2L);
#line 285
  fclose(binary);
  }
#line 286
  return (ret);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static int IsResourceInFile(char *filename ) 
{ 
  FILE *f ;
  char *spt ;
  char *pt ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 294
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r+");
  }
#line 295
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 296
    return (0);
  }
  {
#line 297
  spt = strrchr((char const   *)filename, '/');
  }
#line 298
  if ((unsigned long )spt == (unsigned long )((void *)0)) {
#line 298
    spt = filename;
  }
  {
#line 299
  pt = strrchr((char const   *)spt, '.');
  }
#line 300
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 300
    if ((int )*(pt + 1) == 98) {
#line 300
      goto _L___8;
    } else
#line 300
    if ((int )*(pt + 1) == 66) {
      _L___8: /* CIL Label */ 
#line 300
      if ((int )*(pt + 2) == 105) {
#line 300
        goto _L___6;
      } else
#line 300
      if ((int )*(pt + 2) == 73) {
        _L___6: /* CIL Label */ 
#line 300
        if ((int )*(pt + 3) == 110) {
#line 300
          goto _L___4;
        } else
#line 300
        if ((int )*(pt + 3) == 78) {
          _L___4: /* CIL Label */ 
#line 300
          if ((int )*(pt + 4) == 0) {
            {
#line 302
            tmp = IsResourceInBinary(f);
            }
#line 302
            if (tmp) {
              {
#line 303
              fclose(f);
              }
#line 304
              return (1);
            }
          } else {
#line 300
            goto _L___7;
          }
        } else {
#line 300
          goto _L___7;
        }
      } else {
#line 300
        goto _L___7;
      }
    } else {
#line 300
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 306
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 306
    if ((int )*(pt + 1) == 104) {
#line 306
      goto _L___1;
    } else
#line 306
    if ((int )*(pt + 1) == 72) {
      _L___1: /* CIL Label */ 
#line 306
      if ((int )*(pt + 2) == 113) {
#line 306
        goto _L___0;
      } else
#line 306
      if ((int )*(pt + 2) == 81) {
        _L___0: /* CIL Label */ 
#line 306
        if ((int )*(pt + 3) == 120) {
#line 306
          goto _L;
        } else
#line 306
        if ((int )*(pt + 3) == 88) {
          _L: /* CIL Label */ 
#line 306
          if ((int )*(pt + 4) == 0) {
            {
#line 308
            tmp___0 = IsResourceInHex(f);
            }
#line 308
            if (tmp___0) {
              {
#line 309
              fclose(f);
              }
#line 310
              return (1);
            }
          }
        }
      }
    }
  }
  {
#line 314
  ret = IsResourceFork(f, 0L);
#line 315
  fclose(f);
  }
#line 316
  if (! ret) {
    {
#line 317
    ret = HasResourceFork(filename);
    }
  }
#line 318
  return (ret);
}
}
#line 321 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
static int FindResourceFile(char *filename ) 
{ 
  char *spt ;
  char *pt ;
  char *dpt ;
  char buffer___0[1400] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  char exten[8] ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 325
  tmp = IsResourceInFile(filename);
  }
#line 325
  if (tmp) {
#line 326
    return (1);
  }
  {
#line 330
  strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)filename);
#line 331
  spt = strrchr((char const   *)(buffer___0), '/');
  }
#line 332
  if ((unsigned long )spt == (unsigned long )((void *)0)) {
#line 332
    spt = buffer___0;
#line 332
    pt = filename;
  } else {
#line 333
    spt ++;
#line 333
    pt = filename + (spt - buffer___0);
  }
  {
#line 334
  strcpy((char */* __restrict  */)spt, (char const   */* __restrict  */)"resource.frk/");
#line 335
  strcat((char */* __restrict  */)spt, (char const   */* __restrict  */)pt);
#line 336
  tmp___0 = IsResourceInFile(buffer___0);
  }
#line 336
  if (tmp___0) {
#line 337
    return (1);
  }
  {
#line 341
  tmp___1 = strrchr((char const   *)(buffer___0), '/');
#line 341
  spt = tmp___1 + 1;
#line 342
  pt = spt;
  }
  {
#line 342
  while (1) {
    while_continue: /* CIL Label */ ;
#line 342
    if (! *pt) {
#line 342
      goto while_break;
    }
    {
#line 343
    tmp___3 = __ctype_b_loc();
    }
#line 343
    if ((int const   )*(*tmp___3 + (int )*pt) & 256) {
      {
#line 344
      tmp___2 = tolower((int )*pt);
#line 344
      *pt = (char )tmp___2;
      }
    }
#line 342
    pt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 345
  dpt = strchr((char const   *)spt, '.');
  }
#line 346
  if ((unsigned long )dpt == (unsigned long )((void *)0)) {
    {
#line 346
    tmp___4 = strlen((char const   *)spt);
#line 346
    dpt = spt + tmp___4;
    }
  }
#line 347
  if (dpt - spt > 8L) {
#line 347
    goto _L;
  } else {
    {
#line 347
    tmp___7 = strlen((char const   *)dpt);
    }
#line 347
    if (tmp___7 > 4UL) {
      _L: /* CIL Label */ 
      {
#line 349
      strncpy((char */* __restrict  */)(exten), (char const   */* __restrict  */)dpt,
              (size_t )7);
#line 350
      exten[4] = (char )'\000';
      }
#line 351
      if (dpt - spt > 6L) {
#line 352
        dpt = spt + 6;
      }
      {
#line 353
      tmp___5 = dpt;
#line 353
      dpt ++;
#line 353
      *tmp___5 = (char )'~';
#line 354
      tmp___6 = dpt;
#line 354
      dpt ++;
#line 354
      *tmp___6 = (char )'1';
#line 355
      strcpy((char */* __restrict  */)dpt, (char const   */* __restrict  */)(exten));
      }
    }
  }
  {
#line 357
  tmp___8 = IsResourceInFile(buffer___0);
  }
#line 357
  return (tmp___8);
}
}
#line 360 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/setfondname.c"
int main(int argc , char **argv ) 
{ 
  int i ;
  int ret ;
  int tmp ;

  {
#line 361
  ret = 0;
#line 363
  if (argc == 1) {
    {
#line 364
    dousage();
    }
  }
#line 366
  i = 1;
  {
#line 366
  while (1) {
    while_continue: /* CIL Label */ ;
#line 366
    if (! (i < argc)) {
#line 366
      goto while_break;
    }
#line 367
    if ((int )*(*(argv + i)) == 45) {
      {
#line 368
      NewName(*(argv + i));
      }
    } else {
      {
#line 369
      tmp = FindResourceFile(*(argv + i));
      }
#line 369
      if (tmp) {
        {
#line 370
        ClearNames();
        }
      } else {
        {
#line 372
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t find an appropriate resource fork in %s\n",
                *(argv + i));
#line 373
        ret = 1;
        }
      }
    }
#line 366
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 376
  return (ret);
}
}
#line 715 "/usr/include/stdio.h"
extern size_t fwrite(void const   * __restrict  __ptr , size_t __size , size_t __n ,
                     FILE * __restrict  __s ) ;
#line 468 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 107 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static struct resource_types *global_types  ;
#line 108 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int do_fond_fixup  =    0;
#line 109 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int only_fonts  =    1;
#line 116 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int getushort___0(FILE *f ) 
{ 
  int ch1 ;
  int tmp ;
  int ch2 ;
  int tmp___0 ;

  {
  {
#line 117
  tmp = _IO_getc(f);
#line 117
  ch1 = tmp;
#line 118
  tmp___0 = _IO_getc(f);
#line 118
  ch2 = tmp___0;
  }
#line 119
  if (ch2 == -1) {
#line 120
    return (-1);
  }
#line 121
  return ((ch1 << 8) | ch2);
}
}
#line 124 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static long getlong___0(FILE *f ) 
{ 
  int ch1 ;
  int tmp ;
  int ch2 ;
  int tmp___0 ;
  int ch3 ;
  int tmp___1 ;
  int ch4 ;
  int tmp___2 ;

  {
  {
#line 125
  tmp = _IO_getc(f);
#line 125
  ch1 = tmp;
#line 126
  tmp___0 = _IO_getc(f);
#line 126
  ch2 = tmp___0;
#line 127
  tmp___1 = _IO_getc(f);
#line 127
  ch3 = tmp___1;
#line 128
  tmp___2 = _IO_getc(f);
#line 128
  ch4 = tmp___2;
  }
#line 129
  if (ch4 == -1) {
#line 130
    return (-1L);
  }
#line 131
  return ((long )((((ch1 << 24) | (ch2 << 16)) | (ch3 << 8)) | ch4));
}
}
#line 134 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void putshort___1(int val , FILE *f ) 
{ 


  {
  {
#line 135
  _IO_putc(val >> 8, f);
#line 136
  _IO_putc(val & 255, f);
  }
#line 137
  return;
}
}
#line 139 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void putlong___0(long val , FILE *f ) 
{ 


  {
  {
#line 140
  _IO_putc((int )((val >> 24) & 255L), f);
#line 141
  _IO_putc((int )((val >> 16) & 255L), f);
#line 142
  _IO_putc((int )((val >> 8) & 255L), f);
#line 143
  _IO_putc((int )(val & 255L), f);
  }
#line 144
  return;
}
}
#line 148 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void DumpResourceMap(FILE *res , struct resource_types *rtypes ) 
{ 
  uint32 rfork_base ;
  uint32 resource_base ;
  uint32 rend ;
  uint32 rtypesstart ;
  uint32 mend ;
  uint32 namestart ;
  struct resource_types *cur ;
  struct resource *rcur ;
  int i ;
  int j ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  size_t tmp___6 ;
  size_t tmp___7 ;
  long tmp___8 ;
  long tmp___9 ;

  {
  {
#line 149
  rfork_base = (uint32 )0;
#line 150
  resource_base = rfork_base + 256U;
#line 156
  fseek(res, 0L, 2);
#line 157
  tmp = ftell(res);
#line 157
  rend = (uint32 )tmp;
#line 159
  i = 0;
  }
  {
#line 159
  while (1) {
    while_continue: /* CIL Label */ ;
#line 159
    if (! (i < 16)) {
#line 159
      goto while_break;
    }
    {
#line 160
    _IO_putc(0, res);
#line 159
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 162
  putlong___0(0L, res);
#line 163
  putshort___1(0, res);
#line 164
  putshort___1(0, res);
#line 166
  tmp___0 = ftell(res);
#line 166
  putshort___1((int )((4L + tmp___0) - (long )rend), res);
#line 167
  putshort___1(0, res);
#line 169
  tmp___1 = ftell(res);
#line 169
  rtypesstart = (uint32 )tmp___1;
#line 170
  i = 0;
#line 170
  cur = rtypes;
  }
  {
#line 170
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 170
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 170
      goto while_break___0;
    }
#line 170
    cur = cur->next;
#line 170
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 171
  putshort___1(i - 1, res);
#line 172
  cur = rtypes;
  }
  {
#line 172
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 172
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 172
      goto while_break___1;
    }
    {
#line 173
    putlong___0((long )cur->tag, res);
#line 174
    putshort___1(0, res);
#line 175
    putshort___1(0, res);
#line 172
    cur = cur->next;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 179
  cur = rtypes;
  {
#line 179
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 179
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 179
      goto while_break___2;
    }
    {
#line 180
    tmp___2 = ftell(res);
#line 180
    cur->pos = (uint32 )tmp___2;
#line 181
    rcur = cur->res;
    }
    {
#line 181
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 181
      if (! ((unsigned long )rcur != (unsigned long )((void *)0))) {
#line 181
        goto while_break___3;
      }
      {
#line 182
      putshort___1((int )rcur->new_id, res);
#line 183
      tmp___3 = ftell(res);
#line 183
      rcur->nameptloc = (uint32 )tmp___3;
#line 184
      putshort___1(65535, res);
#line 185
      _IO_putc(rcur->flags, res);
#line 187
      _IO_putc((int )(((rcur->merged_off - resource_base) >> 16) & 255U), res);
#line 188
      _IO_putc((int )(((rcur->merged_off - resource_base) >> 8) & 255U), res);
#line 189
      _IO_putc((int )((rcur->merged_off - resource_base) & 255U), res);
#line 190
      putlong___0(0L, res);
#line 181
      rcur = rcur->next;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 179
    cur = cur->next;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 193
  tmp___4 = ftell(res);
#line 193
  namestart = (uint32 )tmp___4;
#line 195
  cur = rtypes;
  }
  {
#line 195
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 195
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 195
      goto while_break___4;
    }
#line 196
    rcur = cur->res;
    {
#line 196
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 196
      if (! ((unsigned long )rcur != (unsigned long )((void *)0))) {
#line 196
        goto while_break___5;
      }
#line 197
      if ((unsigned long )rcur->name != (unsigned long )((void *)0)) {
        {
#line 198
        tmp___5 = ftell(res);
#line 198
        rcur->name_off = (uint32 )tmp___5;
#line 199
        tmp___6 = strlen((char const   *)rcur->name);
#line 199
        _IO_putc((int )tmp___6, res);
#line 200
        tmp___7 = strlen((char const   *)rcur->name);
#line 200
        fwrite((void const   */* __restrict  */)rcur->name, (size_t )1, tmp___7, (FILE */* __restrict  */)res);
        }
      }
#line 196
      rcur = rcur->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 195
    cur = cur->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 204
  tmp___8 = ftell(res);
#line 204
  mend = (uint32 )tmp___8;
#line 207
  fseek(res, (long )(rtypesstart + 2U), 0);
#line 208
  cur = rtypes;
  }
  {
#line 208
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 208
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 208
      goto while_break___6;
    }
    {
#line 209
    putlong___0((long )cur->tag, res);
#line 210
    j = 0;
#line 210
    rcur = cur->res;
    }
    {
#line 210
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 210
      if (! ((unsigned long )rcur != (unsigned long )((void *)0))) {
#line 210
        goto while_break___7;
      }
#line 210
      rcur = rcur->next;
#line 210
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 211
    putshort___1(j - 1, res);
#line 212
    putshort___1((int )(cur->pos - rtypesstart), res);
#line 208
    cur = cur->next;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 215
  cur = rtypes;
  {
#line 215
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 215
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 215
      goto while_break___8;
    }
#line 216
    rcur = cur->res;
    {
#line 216
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 216
      if (! ((unsigned long )rcur != (unsigned long )((void *)0))) {
#line 216
        goto while_break___9;
      }
#line 217
      if ((unsigned long )rcur->name != (unsigned long )((void *)0)) {
        {
#line 218
        fseek(res, (long )rcur->nameptloc, 0);
#line 219
        putshort___1((int )(rcur->name_off - namestart), res);
        }
      }
#line 216
      rcur = rcur->next;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 215
    cur = cur->next;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 224
  fseek(res, (long )rend, 0);
#line 226
  i = 0;
  }
  {
#line 226
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 226
    if (! (i < 16)) {
#line 226
      goto while_break___10;
    }
    {
#line 227
    _IO_putc(0, res);
#line 226
    i ++;
    }
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 229
  putlong___0(0L, res);
#line 230
  putshort___1(0, res);
#line 231
  putshort___1(0, res);
#line 233
  tmp___9 = ftell(res);
#line 233
  putshort___1((int )((4L + tmp___9) - (long )rend), res);
#line 234
  putshort___1((int )(namestart - rend), res);
#line 236
  fseek(res, (long )rfork_base, 0);
#line 238
  putlong___0(256L, res);
#line 239
  putlong___0((long )(rend - rfork_base), res);
#line 240
  putlong___0((long )((rend - rfork_base) - 256U), res);
#line 241
  putlong___0((long )(mend - rend), res);
  }
#line 242
  return;
}
}
#line 244 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void DumpResource(FILE *to , struct resource *rcur ) 
{ 
  uint32 len ;
  int ch ;
  long tmp ;
  long tmp___0 ;

  {
  {
#line 248
  tmp = ftell(to);
#line 248
  rcur->merged_off = (uint32 )tmp;
#line 249
  fseek(rcur->srcf, (long )rcur->src_off, 0);
#line 250
  tmp___0 = getlong___0(rcur->srcf);
#line 250
  len = (uint32 )tmp___0;
  }
#line 251
  if (len == 4294967295U) {
    {
#line 252
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Bad resource length at offset %d\n",
            rcur->src_off);
#line 253
    exit(1);
    }
  }
  {
#line 255
  putlong___0((long )len, to);
  }
  {
#line 256
  while (1) {
    while_continue: /* CIL Label */ ;
#line 256
    if (! (len > 0U)) {
#line 256
      goto while_break;
    }
    {
#line 257
    ch = _IO_getc(rcur->srcf);
#line 258
    _IO_putc(ch, to);
#line 259
    len --;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 261
  return;
}
}
#line 263 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int FindNewId(uint32 tag , FILE *origf , int id ) 
{ 
  struct resource_types *cur ;
  struct resource *res ;

  {
#line 267
  cur = global_types;
  {
#line 267
  while (1) {
    while_continue: /* CIL Label */ ;
#line 267
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 267
      goto while_break;
    }
#line 268
    if (cur->tag == tag) {
#line 269
      res = cur->res;
      {
#line 269
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 269
        if (! ((unsigned long )res != (unsigned long )((void *)0))) {
#line 269
          goto while_break___0;
        }
#line 270
        if ((int )res->id == id) {
#line 270
          if ((unsigned long )res->srcf == (unsigned long )origf) {
#line 271
            return ((int )res->new_id);
          }
        }
#line 269
        res = res->next;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 273
      return (id);
    }
#line 267
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 276
  return (id);
}
}
#line 279 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void DumpFond(FILE *to , struct resource *rcur ) 
{ 
  int i ;
  int assoc_cnt ;
  int size ;
  int style ;
  int id ;
  int newid ;
  int tmp ;

  {
  {
#line 283
  DumpResource(to, rcur);
#line 285
  fseek(to, (long )((rcur->merged_off + 4U) + 52U), 0);
#line 286
  tmp = getushort___0(to);
#line 286
  assoc_cnt = tmp + 1;
#line 287
  i = 0;
  }
  {
#line 287
  while (1) {
    while_continue: /* CIL Label */ ;
#line 287
    if (! (i < assoc_cnt)) {
#line 287
      goto while_break;
    }
    {
#line 288
    size = getushort___0(to);
#line 289
    style = getushort___0(to);
#line 290
    id = getushort___0(to);
    }
#line 291
    if (size == 0) {
      {
#line 292
      newid = FindNewId((uint32 )((((115 << 24) | (102 << 16)) | (110 << 8)) | 116),
                        rcur->srcf, id);
      }
    } else {
      {
#line 294
      newid = FindNewId((uint32 )((((78 << 24) | (70 << 16)) | (78 << 8)) | 84), rcur->srcf,
                        id);
      }
    }
#line 295
    if (newid != id) {
      {
#line 296
      fseek(to, -2L, 1);
#line 297
      putshort___1(newid, to);
#line 298
      fseek(to, 0L, 1);
      }
    }
#line 287
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 301
  fseek(to, 0L, 2);
  }
#line 302
  return;
}
}
#line 304 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void ResCopy(FILE *to ) 
{ 
  struct resource_types *cur ;
  struct resource *rcur ;
  int fixupfond ;
  int tmp ;

  {
#line 310
  cur = global_types;
  {
#line 310
  while (1) {
    while_continue: /* CIL Label */ ;
#line 310
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 310
      goto while_break;
    }
#line 311
    if (do_fond_fixup) {
#line 311
      if (cur->tag == (uint32 )((((70 << 24) | (79 << 16)) | (78 << 8)) | 68)) {
#line 311
        tmp = 1;
      } else {
#line 311
        tmp = 0;
      }
    } else {
#line 311
      tmp = 0;
    }
#line 311
    fixupfond = tmp;
#line 312
    rcur = cur->res;
    {
#line 312
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 312
      if (! ((unsigned long )rcur != (unsigned long )((void *)0))) {
#line 312
        goto while_break___0;
      }
#line 313
      if (fixupfond) {
        {
#line 314
        DumpFond(to, rcur);
        }
      } else {
        {
#line 316
        DumpResource(to, rcur);
        }
      }
#line 312
      rcur = rcur->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 310
    cur = cur->next;
  }
  while_break: /* CIL Label */ ;
  }
#line 318
  return;
}
}
#line 320 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int ResIdUsed(int id , struct resource *list1 , struct resource *list2 ) 
{ 


  {
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )list1 != (unsigned long )((void *)0))) {
#line 321
      goto while_break;
    }
#line 322
    if (id == (int )list1->new_id) {
#line 323
      return (1);
    }
#line 324
    list1 = list1->next;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 326
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 326
    if (! ((unsigned long )list2 != (unsigned long )((void *)0))) {
#line 326
      goto while_break___0;
    }
#line 327
    if (id == (int )list2->new_id) {
#line 328
      return (1);
    }
#line 329
    list2 = list2->next;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 331
  return (0);
}
}
#line 334 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void MergeResLists(struct resource_types *into , struct resource_types *from ) 
{ 
  struct resource *res ;
  struct resource *rtest ;
  struct resource *rnext ;
  struct resource *p ;
  int tmp ;

  {
#line 337
  res = from->res;
  {
#line 337
  while (1) {
    while_continue: /* CIL Label */ ;
#line 337
    if (! ((unsigned long )res != (unsigned long )((void *)0))) {
#line 337
      goto while_break;
    }
#line 338
    rnext = res->next;
    {
#line 339
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 339
      tmp = ResIdUsed((int )res->new_id, into->res, rnext);
      }
#line 339
      if (! tmp) {
#line 339
        goto while_break___0;
      }
#line 340
      res->new_id = (uint16 )(((int )res->new_id + 1) & 65535);
    }
    while_break___0: /* CIL Label */ ;
    }
#line 341
    if ((int )res->new_id != (int )res->id) {
#line 342
      if (into->tag == (uint32 )((((115 << 24) | (102 << 16)) | (110 << 8)) | 116)) {
#line 343
        do_fond_fixup = 1;
      } else
#line 342
      if (into->tag == (uint32 )((((78 << 24) | (70 << 16)) | (78 << 8)) | 84)) {
#line 343
        do_fond_fixup = 1;
      }
      {
#line 344
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Warning: Renumbering resource \'%c%c%c%c\' %d -> %d\n",
              into->tag >> 24, (into->tag >> 16) & 255U, (into->tag >> 8) & 255U,
              into->tag & 255U, (int )res->id, (int )res->new_id);
      }
    }
#line 348
    rtest = into->res;
#line 348
    p = (struct resource *)((void *)0);
    {
#line 348
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 348
      if (! ((unsigned long )rtest != (unsigned long )((void *)0))) {
#line 348
        goto while_break___1;
      }
#line 349
      if ((int )rtest->new_id > (int )res->new_id) {
#line 350
        goto while_break___1;
      }
#line 348
      p = rtest;
#line 348
      rtest = rtest->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 352
    if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 353
      res->next = into->res;
#line 354
      into->res = res;
    } else {
#line 356
      res->next = p->next;
#line 357
      p->next = res;
    }
#line 337
    res = rnext;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 360
  free((void *)from);
  }
#line 361
  return;
}
}
#line 363 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void MergeToGlobalResources(struct resource_types *head ) 
{ 
  struct resource_types *test ;
  struct resource_types *p ;
  struct resource_types *hnext ;

  {
#line 366
  if ((unsigned long )global_types == (unsigned long )((void *)0)) {
#line 367
    global_types = head;
#line 368
    return;
  }
  {
#line 370
  while (1) {
    while_continue: /* CIL Label */ ;
#line 370
    if (! ((unsigned long )head != (unsigned long )((void *)0))) {
#line 370
      goto while_break;
    }
#line 371
    hnext = head->next;
#line 372
    if (only_fonts) {
#line 372
      if (head->tag != (uint32 )((((115 << 24) | (102 << 16)) | (110 << 8)) | 116)) {
#line 372
        if (head->tag != (uint32 )((((78 << 24) | (70 << 16)) | (78 << 8)) | 84)) {
#line 372
          if (head->tag != (uint32 )((((70 << 24) | (79 << 16)) | (78 << 8)) | 68)) {
#line 377
            head = hnext;
#line 378
            goto while_continue;
          }
        }
      }
    }
#line 380
    test = global_types;
    {
#line 380
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 380
      if (! ((unsigned long )test != (unsigned long )((void *)0))) {
#line 380
        goto while_break___0;
      }
#line 381
      if (test->tag == head->tag) {
        {
#line 382
        MergeResLists(test, head);
        }
#line 383
        goto while_break___0;
      }
#line 380
      test = test->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 386
    if ((unsigned long )test == (unsigned long )((void *)0)) {
#line 388
      test = global_types;
#line 388
      p = (struct resource_types *)((void *)0);
      {
#line 388
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 388
        if (! ((unsigned long )test != (unsigned long )((void *)0))) {
#line 388
          goto while_break___1;
        }
#line 389
        if (test->tag > head->tag) {
#line 390
          goto while_break___1;
        }
#line 388
        p = test;
#line 388
        test = test->next;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 392
      if ((unsigned long )p == (unsigned long )((void *)0)) {
#line 393
        head->next = global_types;
#line 394
        global_types = head;
      } else {
#line 396
        head->next = p->next;
#line 397
        p->next = head;
      }
    }
#line 400
    head = hnext;
  }
  while_break: /* CIL Label */ ;
  }
#line 402
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int IsResourceFork___0(FILE *f , long offset ) 
{ 
  unsigned char buffer___0[16] ;
  unsigned char buffer2[16] ;
  long rdata_pos ;
  long map_pos ;
  long type_list ;
  long name_list ;
  int i ;
  int cnt ;
  int ch1 ;
  int ch2 ;
  int namepos ;
  struct resource_types *head ;
  struct resource_types *last ;
  struct resource_types *cur ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  struct resource *rlast ;
  struct resource *rcur ;
  void *tmp___8 ;
  uint16 tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  struct resource *rcur___0 ;
  void *tmp___12 ;

  {
  {
#line 416
  head = (struct resource_types *)((void *)0);
#line 416
  last = (struct resource_types *)((void *)0);
#line 418
  fseek(f, offset, 0);
#line 419
  tmp = fread((void */* __restrict  */)(buffer___0), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
#line 419
  if (tmp != 16UL) {
#line 420
    return (0);
  }
  {
#line 421
  rdata_pos = offset + (long )(((((int )buffer___0[0] << 24) | ((int )buffer___0[1] << 16)) | ((int )buffer___0[2] << 8)) | (int )buffer___0[3]);
#line 422
  map_pos = offset + (long )(((((int )buffer___0[4] << 24) | ((int )buffer___0[5] << 16)) | ((int )buffer___0[6] << 8)) | (int )buffer___0[7]);
#line 423
  fseek(f, map_pos, 0);
#line 424
  buffer2[15] = (unsigned char )((int )buffer___0[15] + 1);
#line 425
  tmp___0 = fread((void */* __restrict  */)(buffer2), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
#line 425
  if (tmp___0 != 16UL) {
#line 426
    return (0);
  }
#line 430
  i = 0;
  {
#line 430
  while (1) {
    while_continue: /* CIL Label */ ;
#line 430
    if (! (i < 16)) {
#line 430
      goto while_break;
    }
#line 431
    if ((int )buffer2[i] != 0) {
#line 432
      goto while_break;
    }
#line 430
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 433
  if (i != 16) {
#line 434
    i = 0;
    {
#line 434
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 434
      if (! (i < 16)) {
#line 434
        goto while_break___0;
      }
#line 435
      if ((int )buffer___0[i] != (int )buffer2[i]) {
#line 436
        return (0);
      }
#line 434
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 437
  getlong___0(f);
#line 438
  getushort___0(f);
#line 439
  getushort___0(f);
#line 440
  tmp___1 = getushort___0(f);
#line 440
  type_list = map_pos + (long )tmp___1;
#line 441
  tmp___2 = getushort___0(f);
#line 441
  name_list = map_pos + (long )tmp___2;
#line 443
  fseek(f, type_list, 0);
#line 444
  tmp___3 = getushort___0(f);
#line 444
  cnt = tmp___3 + 1;
#line 445
  i = 0;
  }
  {
#line 445
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 445
    if (! (i < cnt)) {
#line 445
      goto while_break___1;
    }
    {
#line 446
    tmp___4 = calloc((size_t )1, sizeof(struct resource_types ));
#line 446
    cur = (struct resource_types *)tmp___4;
#line 447
    tmp___5 = getlong___0(f);
#line 447
    cur->tag = (uint32 )tmp___5;
#line 448
    tmp___6 = getushort___0(f);
#line 448
    cur->cnt = tmp___6 + 1;
#line 449
    tmp___7 = getushort___0(f);
#line 449
    cur->pos = (uint32 )(type_list + (long )tmp___7);
    }
#line 450
    if ((unsigned long )last == (unsigned long )((void *)0)) {
#line 451
      head = cur;
    } else {
#line 453
      last->next = cur;
    }
#line 454
    last = cur;
#line 445
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 457
  cur = head;
  {
#line 457
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 457
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 457
      goto while_break___2;
    }
    {
#line 458
    rlast = (struct resource *)((void *)0);
#line 459
    fseek(f, (long )cur->pos, 0);
#line 460
    i = 0;
    }
    {
#line 460
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 460
      if (! (i < cur->cnt)) {
#line 460
        goto while_break___3;
      }
      {
#line 461
      tmp___8 = calloc((size_t )1, sizeof(struct resource ));
#line 461
      rcur = (struct resource *)tmp___8;
#line 462
      tmp___10 = getushort___0(f);
#line 462
      tmp___9 = (uint16 )tmp___10;
#line 462
      rcur->id = tmp___9;
#line 462
      rcur->new_id = tmp___9;
#line 463
      namepos = getushort___0(f);
      }
#line 464
      if (namepos == 65535) {
#line 465
        rcur->name_off = (uint32 )0;
      } else {
#line 467
        rcur->name_off = (uint32 )(name_list + (long )namepos);
      }
      {
#line 468
      rcur->flags = _IO_getc(f);
#line 469
      ch1 = _IO_getc(f);
#line 469
      ch2 = _IO_getc(f);
#line 470
      tmp___11 = _IO_getc(f);
#line 470
      rcur->src_off = (uint32 )(rdata_pos + (long )(((ch1 << 16) | (ch2 << 8)) | tmp___11));
#line 471
      rcur->srcf = f;
#line 472
      getlong___0(f);
      }
#line 473
      if ((unsigned long )rlast == (unsigned long )((void *)0)) {
#line 474
        cur->res = rcur;
      } else {
#line 476
        rlast->next = rcur;
      }
#line 477
      rlast = rcur;
#line 460
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 457
    cur = cur->next;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 481
  cur = head;
  {
#line 481
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 481
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 481
      goto while_break___4;
    }
#line 483
    rcur___0 = cur->res;
    {
#line 483
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 483
      if (! ((unsigned long )rcur___0 != (unsigned long )((void *)0))) {
#line 483
        goto while_break___5;
      }
#line 484
      if (rcur___0->name_off != 0U) {
        {
#line 485
        fseek(f, (long )rcur___0->name_off, 0);
#line 486
        ch1 = _IO_getc(f);
        }
#line 487
        if (ch1 != -1) {
          {
#line 488
          tmp___12 = malloc((size_t )(ch1 + 1));
#line 488
          rcur___0->name = (char *)tmp___12;
#line 489
          fread((void */* __restrict  */)rcur___0->name, (size_t )1, (size_t )ch1,
                (FILE */* __restrict  */)f);
#line 490
          *(rcur___0->name + ch1) = (char )'\000';
          }
        }
      }
#line 483
      rcur___0 = rcur___0->next;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 481
    cur = cur->next;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 496
  MergeToGlobalResources(head);
  }
#line 497
  return (1);
}
}
#line 500 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int HasResourceFork___0(char *filename ) 
{ 
  char *respath ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  FILE *temp ;
  int ret ;

  {
  {
#line 504
  tmp = strlen((char const   *)filename);
#line 504
  tmp___0 = strlen("/rsrc");
#line 504
  tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 504
  respath = (char *)tmp___1;
#line 506
  ret = 0;
#line 508
  strcpy((char */* __restrict  */)respath, (char const   */* __restrict  */)filename);
#line 509
  strcat((char */* __restrict  */)respath, (char const   */* __restrict  */)"/rsrc");
#line 510
  temp = fopen((char const   */* __restrict  */)respath, (char const   */* __restrict  */)"r");
#line 511
  free((void *)respath);
  }
#line 512
  if ((unsigned long )temp != (unsigned long )((void *)0)) {
    {
#line 513
    ret = IsResourceFork___0(temp, 0L);
    }
  }
#line 514
  return (ret);
}
}
#line 517 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int IsResourceInBinary___0(FILE *f ) 
{ 
  unsigned char header[128] ;
  unsigned long offset ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 521
  tmp = fread((void */* __restrict  */)(header), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
  }
#line 521
  if (tmp != 128UL) {
#line 522
    return (0);
  }
#line 523
  if ((int )header[0] != 0) {
#line 525
    return (0);
  } else
#line 523
  if ((int )header[74] != 0) {
#line 525
    return (0);
  } else
#line 523
  if ((int )header[82] != 0) {
#line 525
    return (0);
  } else
#line 523
  if ((int )header[1] <= 0) {
#line 525
    return (0);
  } else
#line 523
  if ((int )header[1] > 33) {
#line 525
    return (0);
  } else
#line 523
  if ((int )header[63] != 0) {
#line 525
    return (0);
  } else
#line 523
  if ((int )header[2 + (int )header[1]] != 0) {
#line 525
    return (0);
  }
  {
#line 526
  offset = (unsigned long )(128 + (((((int )header[83] << 24) | ((int )header[84] << 16)) | ((int )header[85] << 8)) | (int )header[86]));
#line 527
  tmp___0 = IsResourceFork___0(f, (long )offset);
  }
#line 527
  return (tmp___0);
}
}
#line 530 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int lastch___0  =    0;
#line 530 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int repeat___0  =    0;
#line 531 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void outchr___0(FILE *binary , int ch ) 
{ 
  int i ;

  {
#line 534
  if (repeat___0) {
#line 535
    if (ch == 0) {
      {
#line 537
      lastch___0 = 144;
#line 538
      _IO_putc(lastch___0, binary);
      }
    } else {
#line 540
      i = 1;
      {
#line 540
      while (1) {
        while_continue: /* CIL Label */ ;
#line 540
        if (! (i < ch)) {
#line 540
          goto while_break;
        }
        {
#line 541
        _IO_putc(lastch___0, binary);
#line 540
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 543
    repeat___0 = 0;
  } else
#line 544
  if (ch == 144) {
#line 545
    repeat___0 = 1;
  } else {
    {
#line 547
    _IO_putc(ch, binary);
#line 548
    lastch___0 = ch;
    }
  }
#line 550
  return;
}
}
#line 552 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int IsResourceInHex___0(FILE *f ) 
{ 
  FILE *binary ;
  FILE *tmp ;
  char *sixbit ;
  int ch ;
  int val ;
  int cnt ;
  int i ;
  int dlen ;
  int rlen ;
  int ret ;
  char header[20] ;
  char *pt ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 555
  tmp = tmpfile();
#line 555
  binary = tmp;
#line 556
  sixbit = (char *)"!\"#$%&\'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr";
  }
#line 560
  if ((unsigned long )binary == (unsigned long )((void *)0)) {
    {
#line 561
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t create temporary file\n");
    }
#line 562
    return (0);
  }
#line 565
  repeat___0 = 0;
#line 565
  lastch___0 = repeat___0;
  {
#line 566
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 566
    ch = _IO_getc(f);
    }
#line 566
    if (! (ch != 58)) {
#line 566
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 567
  val = 0;
#line 567
  cnt = val;
  {
#line 568
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 568
    ch = _IO_getc(f);
    }
#line 568
    if (! (ch != 58)) {
#line 568
      goto while_break___0;
    }
    {
#line 569
    tmp___0 = __ctype_b_loc();
    }
#line 569
    if ((int const   )*(*tmp___0 + ch) & 8192) {
#line 570
      goto while_continue___0;
    }
#line 571
    pt = sixbit;
    {
#line 571
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 571
      if ((int )*pt != ch) {
#line 571
        if (! ((int )*pt != 0)) {
#line 571
          goto while_break___1;
        }
      } else {
#line 571
        goto while_break___1;
      }
#line 571
      pt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 572
    if ((int )*pt == 0) {
      {
#line 573
      fclose(binary);
      }
#line 574
      return (0);
    }
#line 576
    val = (int )((long )(val << 6) | (pt - sixbit));
#line 577
    cnt ++;
#line 577
    if (cnt == 4) {
      {
#line 578
      outchr___0(binary, (val >> 16) & 255);
#line 579
      outchr___0(binary, (val >> 8) & 255);
#line 580
      outchr___0(binary, val & 255);
#line 581
      cnt = 0;
#line 581
      val = cnt;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 584
  if (cnt != 0) {
#line 585
    if (cnt == 1) {
      {
#line 586
      outchr___0(binary, val << 2);
      }
    } else
#line 587
    if (cnt == 2) {
      {
#line 588
      val <<= 4;
#line 589
      outchr___0(binary, (val >> 8) & 255);
#line 590
      outchr___0(binary, val & 255);
      }
    } else
#line 591
    if (cnt == 3) {
      {
#line 592
      val <<= 6;
#line 593
      outchr___0(binary, (val >> 16) & 255);
#line 594
      outchr___0(binary, (val >> 8) & 255);
#line 595
      outchr___0(binary, val & 255);
      }
    }
  }
  {
#line 599
  rewind(binary);
#line 600
  ch = _IO_getc(binary);
#line 602
  i = 0;
  }
  {
#line 602
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 602
    if (! (i < ch)) {
#line 602
      goto while_break___2;
    }
    {
#line 603
    _IO_getc(binary);
#line 602
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 604
  tmp___1 = _IO_getc(binary);
  }
#line 604
  if (tmp___1 != 0) {
    {
#line 605
    fclose(binary);
    }
#line 606
    return (0);
  }
  {
#line 608
  fread((void */* __restrict  */)(header), (size_t )1, (size_t )20, (FILE */* __restrict  */)binary);
#line 609
  dlen = ((((int )header[10] << 24) | ((int )header[11] << 16)) | ((int )header[12] << 8)) | (int )header[13];
#line 610
  rlen = ((((int )header[14] << 24) | ((int )header[15] << 16)) | ((int )header[16] << 8)) | (int )header[17];
  }
#line 611
  if (rlen == 0) {
    {
#line 612
    fclose(binary);
    }
#line 613
    return (0);
  }
  {
#line 616
  tmp___2 = ftell(binary);
#line 616
  ret = IsResourceFork___0(binary, (tmp___2 + (long )dlen) + 2L);
  }
#line 617
  return (ret);
}
}
#line 620 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int IsResourceInFile___0(char *filename ) 
{ 
  FILE *f ;
  char *spt ;
  char *pt ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 625
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 626
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 627
    return (0);
  }
  {
#line 628
  spt = strrchr((char const   *)filename, '/');
  }
#line 629
  if ((unsigned long )spt == (unsigned long )((void *)0)) {
#line 629
    spt = filename;
  }
  {
#line 630
  pt = strrchr((char const   *)spt, '.');
  }
#line 631
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 631
    if ((int )*(pt + 1) == 98) {
#line 631
      goto _L___8;
    } else
#line 631
    if ((int )*(pt + 1) == 66) {
      _L___8: /* CIL Label */ 
#line 631
      if ((int )*(pt + 2) == 105) {
#line 631
        goto _L___6;
      } else
#line 631
      if ((int )*(pt + 2) == 73) {
        _L___6: /* CIL Label */ 
#line 631
        if ((int )*(pt + 3) == 110) {
#line 631
          goto _L___4;
        } else
#line 631
        if ((int )*(pt + 3) == 78) {
          _L___4: /* CIL Label */ 
#line 631
          if ((int )*(pt + 4) == 0) {
            {
#line 633
            tmp = IsResourceInBinary___0(f);
            }
#line 633
            if (tmp) {
#line 634
              return (1);
            }
          } else {
#line 631
            goto _L___7;
          }
        } else {
#line 631
          goto _L___7;
        }
      } else {
#line 631
        goto _L___7;
      }
    } else {
#line 631
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 636
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 636
    if ((int )*(pt + 1) == 104) {
#line 636
      goto _L___1;
    } else
#line 636
    if ((int )*(pt + 1) == 72) {
      _L___1: /* CIL Label */ 
#line 636
      if ((int )*(pt + 2) == 113) {
#line 636
        goto _L___0;
      } else
#line 636
      if ((int )*(pt + 2) == 81) {
        _L___0: /* CIL Label */ 
#line 636
        if ((int )*(pt + 3) == 120) {
#line 636
          goto _L;
        } else
#line 636
        if ((int )*(pt + 3) == 88) {
          _L: /* CIL Label */ 
#line 636
          if ((int )*(pt + 4) == 0) {
            {
#line 638
            tmp___0 = IsResourceInHex___0(f);
            }
#line 638
            if (tmp___0) {
#line 639
              return (1);
            }
          }
        }
      }
    }
  }
  {
#line 643
  ret = IsResourceFork___0(f, 0L);
  }
#line 644
  if (! ret) {
    {
#line 645
    fclose(f);
#line 646
    ret = HasResourceFork___0(filename);
    }
  }
#line 648
  return (ret);
}
}
#line 651 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static int LoadResourceMap(char *filename ) 
{ 
  char *spt ;
  char *pt ;
  char *dpt ;
  char buffer___0[1400] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  char exten[8] ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 655
  tmp = IsResourceInFile___0(filename);
  }
#line 655
  if (tmp) {
#line 656
    return (1);
  }
  {
#line 660
  strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)filename);
#line 661
  spt = strrchr((char const   *)(buffer___0), '/');
  }
#line 662
  if ((unsigned long )spt == (unsigned long )((void *)0)) {
#line 662
    spt = buffer___0;
#line 662
    pt = filename;
  } else {
#line 663
    spt ++;
#line 663
    pt = filename + (spt - buffer___0);
  }
  {
#line 664
  strcpy((char */* __restrict  */)spt, (char const   */* __restrict  */)"resource.frk/");
#line 665
  strcat((char */* __restrict  */)spt, (char const   */* __restrict  */)pt);
#line 666
  tmp___0 = IsResourceInFile___0(buffer___0);
  }
#line 666
  if (tmp___0) {
#line 667
    return (1);
  }
  {
#line 671
  tmp___1 = strrchr((char const   *)(buffer___0), '/');
#line 671
  spt = tmp___1 + 1;
#line 672
  pt = spt;
  }
  {
#line 672
  while (1) {
    while_continue: /* CIL Label */ ;
#line 672
    if (! *pt) {
#line 672
      goto while_break;
    }
    {
#line 673
    tmp___3 = __ctype_b_loc();
    }
#line 673
    if ((int const   )*(*tmp___3 + (int )*pt) & 256) {
      {
#line 674
      tmp___2 = tolower((int )*pt);
#line 674
      *pt = (char )tmp___2;
      }
    }
#line 672
    pt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 675
  dpt = strchr((char const   *)spt, '.');
  }
#line 676
  if ((unsigned long )dpt == (unsigned long )((void *)0)) {
    {
#line 676
    tmp___4 = strlen((char const   *)spt);
#line 676
    dpt = spt + tmp___4;
    }
  }
#line 677
  if (dpt - spt > 8L) {
#line 677
    goto _L;
  } else {
    {
#line 677
    tmp___7 = strlen((char const   *)dpt);
    }
#line 677
    if (tmp___7 > 4UL) {
      _L: /* CIL Label */ 
      {
#line 679
      strncpy((char */* __restrict  */)(exten), (char const   */* __restrict  */)dpt,
              (size_t )7);
#line 680
      exten[4] = (char )'\000';
      }
#line 681
      if (dpt - spt > 6L) {
#line 682
        dpt = spt + 6;
      }
      {
#line 683
      tmp___5 = dpt;
#line 683
      dpt ++;
#line 683
      *tmp___5 = (char )'~';
#line 684
      tmp___6 = dpt;
#line 684
      dpt ++;
#line 684
      *tmp___6 = (char )'1';
#line 685
      strcpy((char */* __restrict  */)dpt, (char const   */* __restrict  */)(exten));
      }
    }
  }
  {
#line 687
  tmp___8 = IsResourceInFile___0(buffer___0);
  }
#line 687
  return (tmp___8);
}
}
#line 690 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void CopyFile(FILE *to , FILE *from ) 
{ 
  int ch ;

  {
  {
#line 693
  rewind(from);
  }
  {
#line 694
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 694
    ch = _IO_getc(from);
    }
#line 694
    if (! (ch != -1)) {
#line 694
      goto while_break;
    }
    {
#line 695
    _IO_putc(ch, to);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 696
  return;
}
}
#line 698 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/lumper.c"
static void DumpResourceMaps(char *filename ) 
{ 
  FILE *restemp ;
  FILE *tmp ;
  FILE *real ;
  int i ;
  char *pt ;
  char *dot ;
  char *new ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 699
  tmp = tmpfile();
#line 699
  restemp = tmp;
#line 704
  i = 0;
  }
  {
#line 704
  while (1) {
    while_continue: /* CIL Label */ ;
#line 704
    if (! (i < 256)) {
#line 704
      goto while_break;
    }
    {
#line 705
    _IO_putc('\000', restemp);
#line 704
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 708
  ResCopy(restemp);
#line 711
  DumpResourceMap(restemp, global_types);
#line 713
  pt = strrchr((char const   *)filename, '/');
  }
#line 714
  if ((unsigned long )pt == (unsigned long )((void *)0)) {
#line 714
    pt = filename;
  }
  {
#line 715
  dot = strrchr((char const   *)pt, '.');
  }
#line 716
  if ((unsigned long )dot == (unsigned long )((void *)0)) {
    {
#line 716
    tmp___0 = strlen((char const   *)pt);
#line 716
    dot = pt + tmp___0;
    }
  }
  {
#line 717
  tmp___1 = strlen((char const   *)pt);
#line 717
  tmp___2 = strlen(".dfont");
#line 717
  tmp___3 = malloc((tmp___1 + tmp___2) + 2UL);
#line 717
  new = (char *)tmp___3;
#line 718
  strcpy((char */* __restrict  */)new, (char const   */* __restrict  */)pt);
#line 719
  strcpy((char */* __restrict  */)(new + (dot - pt)), (char const   */* __restrict  */)".dfont");
#line 721
  real = fopen((char const   */* __restrict  */)new, (char const   */* __restrict  */)"w");
  }
#line 722
  if ((unsigned long )real == (unsigned long )((void *)0)) {
    {
#line 723
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for output\n",
            new);
#line 724
    exit(1);
    }
  }
  {
#line 726
  CopyFile(real, restemp);
#line 727
  fclose(restemp);
#line 728
  fclose(real);
  }
#line 729
  return;
}
}
#line 46 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memcpy)(void * __restrict  __dest ,
                                                                                                 void const   * __restrict  __src ,
                                                                                                 size_t __n ) ;
#line 66
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 342
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strstr)(char const   *__haystack ,
                                                                                                 char const   *__needle )  __attribute__((__pure__)) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 34 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/dfont2res.c"
static void Usage(char *prog ) 
{ 


  {
  {
#line 35
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s mac-dfont {mac-dfonts}\n",
          prog);
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tTakes a list of mac-dfont files and generates corresponding resource\n");
#line 37
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\tfork files (in a macbinary wrapper)\n");
#line 38
  exit(0);
  }
}
}
#line 54
unsigned long binhex_crc(unsigned char *buffer___0 , int size ) ;
#line 56 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/dfont2res.c"
static void DumpMacBinaryHeader(FILE *res , struct macbinaryheader *mb ) 
{ 
  uint8 header[128] ;
  uint8 *hpt ;
  char buffer___0[256] ;
  char *pt ;
  char *dpt ;
  uint32 len ;
  time_t now ;
  int i ;
  int crc ;
  char *pt___0 ;
  char *tmp ;
  uint8 *tmp___0 ;
  uint8 *tmp___1 ;
  size_t tmp___2 ;
  uint8 *tmp___3 ;
  char *tmp___4 ;
  uint8 *tmp___5 ;
  uint8 *tmp___6 ;
  uint8 *tmp___7 ;
  uint8 *tmp___8 ;
  uint8 *tmp___9 ;
  uint8 *tmp___10 ;
  uint8 *tmp___11 ;
  uint8 *tmp___12 ;
  uint8 *tmp___13 ;
  uint8 *tmp___14 ;
  uint8 *tmp___15 ;
  uint8 *tmp___16 ;
  uint8 *tmp___17 ;
  uint8 *tmp___18 ;
  uint8 *tmp___19 ;
  uint8 *tmp___20 ;
  uint8 *tmp___21 ;
  uint8 *tmp___22 ;
  uint8 *tmp___23 ;
  uint8 *tmp___24 ;
  uint8 *tmp___25 ;
  uint8 *tmp___26 ;
  uint8 *tmp___27 ;
  long tmp___28 ;
  uint8 *tmp___29 ;
  uint8 *tmp___30 ;
  uint8 *tmp___31 ;
  uint8 *tmp___32 ;
  uint8 *tmp___33 ;
  uint8 *tmp___34 ;
  uint8 *tmp___35 ;
  uint8 *tmp___36 ;
  uint8 *tmp___37 ;
  uint8 *tmp___38 ;
  uint8 *tmp___39 ;
  uint8 *tmp___40 ;
  uint8 *tmp___41 ;
  uint8 *tmp___42 ;
  uint8 *tmp___43 ;
  unsigned long tmp___44 ;

  {
#line 62
  if ((unsigned long )mb->macfilename == (unsigned long )((void *)0)) {
    {
#line 63
    tmp = strrchr((char const   *)mb->binfilename, '/');
#line 63
    pt___0 = tmp;
    }
#line 64
    if ((unsigned long )pt___0 == (unsigned long )((void *)0)) {
#line 64
      pt___0 = mb->binfilename;
    } else {
#line 65
      pt___0 ++;
    }
    {
#line 66
    strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)pt___0);
#line 67
    dpt = strrchr((char const   *)(buffer___0), '.');
    }
#line 68
    if ((unsigned long )dpt == (unsigned long )((void *)0)) {
      {
#line 69
      buffer___0[0] = (char )'_';
#line 70
      strcpy((char */* __restrict  */)(buffer___0 + 1), (char const   */* __restrict  */)pt___0);
      }
    } else {
#line 72
      *dpt = (char )'\000';
    }
#line 73
    mb->macfilename = buffer___0;
#line 74
    buffer___0[63] = (char )'\000';
  }
  {
#line 77
  memset((void *)(header), '\000', sizeof(header));
#line 78
  hpt = header;
#line 79
  tmp___0 = hpt;
#line 79
  hpt ++;
#line 79
  *tmp___0 = (uint8 )'\000';
#line 81
  pt = mb->macfilename;
#line 82
  tmp___1 = hpt;
#line 82
  hpt ++;
#line 82
  tmp___2 = strlen((char const   *)pt);
#line 82
  *tmp___1 = (uint8 )tmp___2;
  }
  {
#line 83
  while (1) {
    while_continue: /* CIL Label */ ;
#line 83
    if (! *pt) {
#line 83
      goto while_break;
    }
#line 84
    tmp___3 = hpt;
#line 84
    hpt ++;
#line 84
    tmp___4 = pt;
#line 84
    pt ++;
#line 84
    *tmp___3 = (uint8 )*tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 85
    if (! ((unsigned long )hpt < (unsigned long )(header + 65))) {
#line 85
      goto while_break___0;
    }
#line 86
    tmp___5 = hpt;
#line 86
    hpt ++;
#line 86
    *tmp___5 = (uint8 )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 88
  tmp___6 = hpt;
#line 88
  hpt ++;
#line 88
  *tmp___6 = (uint8 )(mb->type >> 24);
#line 88
  tmp___7 = hpt;
#line 88
  hpt ++;
#line 88
  *tmp___7 = (uint8 )(mb->type >> 16);
#line 88
  tmp___8 = hpt;
#line 88
  hpt ++;
#line 88
  *tmp___8 = (uint8 )(mb->type >> 8);
#line 88
  tmp___9 = hpt;
#line 88
  hpt ++;
#line 88
  *tmp___9 = (uint8 )mb->type;
#line 90
  tmp___10 = hpt;
#line 90
  hpt ++;
#line 90
  *tmp___10 = (uint8 )(mb->creator >> 24);
#line 90
  tmp___11 = hpt;
#line 90
  hpt ++;
#line 90
  *tmp___11 = (uint8 )(mb->creator >> 16);
#line 90
  tmp___12 = hpt;
#line 90
  hpt ++;
#line 90
  *tmp___12 = (uint8 )(mb->creator >> 8);
#line 90
  tmp___13 = hpt;
#line 90
  hpt ++;
#line 90
  *tmp___13 = (uint8 )mb->creator;
#line 91
  tmp___14 = hpt;
#line 91
  hpt ++;
#line 91
  *tmp___14 = (uint8 )'\000';
#line 92
  tmp___15 = hpt;
#line 92
  hpt ++;
#line 92
  *tmp___15 = (uint8 )'\000';
#line 93
  tmp___16 = hpt;
#line 93
  hpt ++;
#line 93
  *tmp___16 = (uint8 )'\000';
#line 93
  tmp___17 = hpt;
#line 93
  hpt ++;
#line 93
  *tmp___17 = (uint8 )'\000';
#line 94
  tmp___18 = hpt;
#line 94
  hpt ++;
#line 94
  *tmp___18 = (uint8 )'\000';
#line 94
  tmp___19 = hpt;
#line 94
  hpt ++;
#line 94
  *tmp___19 = (uint8 )'\000';
#line 95
  tmp___20 = hpt;
#line 95
  hpt ++;
#line 95
  *tmp___20 = (uint8 )'\000';
#line 95
  tmp___21 = hpt;
#line 95
  hpt ++;
#line 95
  *tmp___21 = (uint8 )'\000';
#line 96
  tmp___22 = hpt;
#line 96
  hpt ++;
#line 96
  *tmp___22 = (uint8 )'\000';
#line 97
  tmp___23 = hpt;
#line 97
  hpt ++;
#line 97
  *tmp___23 = (uint8 )'\000';
#line 99
  tmp___24 = hpt;
#line 99
  hpt ++;
#line 99
  *tmp___24 = (uint8 )'\000';
#line 99
  tmp___25 = hpt;
#line 99
  hpt ++;
#line 99
  *tmp___25 = (uint8 )'\000';
#line 99
  tmp___26 = hpt;
#line 99
  hpt ++;
#line 99
  *tmp___26 = (uint8 )'\000';
#line 99
  tmp___27 = hpt;
#line 99
  hpt ++;
#line 99
  *tmp___27 = (uint8 )'\000';
#line 101
  fseek(res, 0L, 2);
#line 102
  tmp___28 = ftell(res);
#line 102
  len = (uint32 )((unsigned long )tmp___28 - sizeof(header));
#line 103
  tmp___29 = hpt;
#line 103
  hpt ++;
#line 103
  *tmp___29 = (uint8 )(len >> 24);
#line 103
  tmp___30 = hpt;
#line 103
  hpt ++;
#line 103
  *tmp___30 = (uint8 )(len >> 16);
#line 103
  tmp___31 = hpt;
#line 103
  hpt ++;
#line 103
  *tmp___31 = (uint8 )(len >> 8);
#line 103
  tmp___32 = hpt;
#line 103
  hpt ++;
#line 103
  *tmp___32 = (uint8 )len;
  }
  {
#line 105
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 105
    if (! ((len & 127U) != 0U)) {
#line 105
      goto while_break___1;
    }
    {
#line 106
    _IO_putc('\000', res);
#line 106
    len ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 109
  time(& now);
#line 111
  now += 2081376000L;
#line 112
  i = 1904;
  }
  {
#line 112
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 112
    if (! (i < 1970)) {
#line 112
      goto while_break___2;
    }
#line 113
    now += 86400L;
#line 112
    i += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 115
  tmp___33 = hpt;
#line 115
  hpt ++;
#line 115
  *tmp___33 = (uint8 )(now >> 24);
#line 115
  tmp___34 = hpt;
#line 115
  hpt ++;
#line 115
  *tmp___34 = (uint8 )(now >> 16);
#line 115
  tmp___35 = hpt;
#line 115
  hpt ++;
#line 115
  *tmp___35 = (uint8 )(now >> 8);
#line 115
  tmp___36 = hpt;
#line 115
  hpt ++;
#line 115
  *tmp___36 = (uint8 )now;
#line 117
  tmp___37 = hpt;
#line 117
  hpt ++;
#line 117
  *tmp___37 = (uint8 )(now >> 24);
#line 117
  tmp___38 = hpt;
#line 117
  hpt ++;
#line 117
  *tmp___38 = (uint8 )(now >> 16);
#line 117
  tmp___39 = hpt;
#line 117
  hpt ++;
#line 117
  *tmp___39 = (uint8 )(now >> 8);
#line 117
  tmp___40 = hpt;
#line 117
  hpt ++;
#line 117
  *tmp___40 = (uint8 )now;
#line 119
  tmp___41 = hpt;
#line 119
  hpt ++;
#line 119
  *tmp___41 = (uint8 )'\000';
#line 119
  tmp___42 = hpt;
#line 119
  hpt ++;
#line 119
  *tmp___42 = (uint8 )'\000';
#line 120
  tmp___43 = hpt;
#line 120
  hpt ++;
#line 120
  *tmp___43 = (uint8 )0;
#line 123
  memcpy((void */* __restrict  */)(header + 102), (void const   */* __restrict  */)"mBIN",
         (size_t )4);
#line 124
  header[106] = (uint8 )0;
#line 125
  header[107] = (uint8 )0;
#line 127
  header[122] = (uint8 )130;
#line 128
  header[123] = (uint8 )129;
#line 130
  tmp___44 = binhex_crc(header, 124);
#line 130
  crc = (int )tmp___44;
#line 131
  header[124] = (uint8 )(crc >> 8);
#line 132
  header[125] = (uint8 )crc;
#line 134
  fseek(res, 0L, 0);
#line 135
  fwrite((void const   */* __restrict  */)(header), (size_t )1, sizeof(header), (FILE */* __restrict  */)res);
  }
#line 136
  return;
}
}
#line 138 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/dfont2res.c"
static void CopyFile___0(FILE *out , FILE *in , char *filename ) 
{ 
  struct macbinaryheader header ;
  char buffer___0[1024] ;
  char *pt ;
  unsigned char ubuf[16] ;
  int len ;
  int map_pos ;
  size_t tmp ;

  {
  {
#line 144
  memset((void *)(buffer___0), 0, (size_t )128);
#line 145
  fwrite((void const   */* __restrict  */)(buffer___0), (size_t )1, (size_t )128,
         (FILE */* __restrict  */)out);
  }
  {
#line 148
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 148
    tmp = fread((void */* __restrict  */)(buffer___0), (size_t )1, (size_t )1024,
                (FILE */* __restrict  */)in);
#line 148
    len = (int )tmp;
    }
#line 148
    if (! (len > 0)) {
#line 148
      goto while_break;
    }
    {
#line 149
    fwrite((void const   */* __restrict  */)(buffer___0), (size_t )1, (size_t )len,
           (FILE */* __restrict  */)out);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 152
  rewind(in);
#line 153
  fread((void */* __restrict  */)(ubuf), (size_t )1, (size_t )16, (FILE */* __restrict  */)in);
#line 154
  map_pos = 128 + (((((int )ubuf[4] << 24) | ((int )ubuf[5] << 16)) | ((int )ubuf[6] << 8)) | (int )ubuf[7]);
#line 155
  fseek(out, (long )map_pos, 0);
#line 156
  fwrite((void const   */* __restrict  */)(buffer___0), (size_t )1, (size_t )16, (FILE */* __restrict  */)out);
#line 159
  pt = strrchr((char const   *)filename, '/');
  }
#line 160
  if ((unsigned long )pt == (unsigned long )((void *)0)) {
    {
#line 161
    strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)filename);
    }
  } else {
    {
#line 163
    strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)(pt + 1));
    }
  }
  {
#line 164
  pt = strstr((char const   *)(buffer___0), ".dfont");
  }
#line 165
  if ((unsigned long )pt == (unsigned long )((void *)0)) {
    {
#line 166
    pt = strrchr((char const   *)(buffer___0), '.');
    }
  }
#line 167
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 167
    *pt = (char )'\000';
  }
  {
#line 169
  header.type = (uint32 )((((70 << 24) | (70 << 16)) | (73 << 8)) | 76);
#line 170
  header.creator = (uint32 )((((68 << 24) | (77 << 16)) | (79 << 8)) | 86);
#line 171
  header.macfilename = buffer___0;
#line 172
  DumpMacBinaryHeader(out, & header);
  }
#line 173
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned long const   binhex_crcinit  =    (unsigned long const   )0;
#line 8 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned short crctab[256]  = 
#line 8
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 43 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned long binhex_updcrc(unsigned long icrc , unsigned char *icp , int icnt ) 
{ 
  register unsigned long crc ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 50
  crc = icrc;
#line 51
  cp = icp;
#line 52
  cnt = icnt;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    tmp___0 = cnt;
#line 54
    cnt --;
#line 54
    if (! tmp___0) {
#line 54
      goto while_break;
    }
#line 55
    tmp = cp;
#line 55
    cp ++;
#line 55
    crc = ((crc << 8) & 65280UL) ^ (unsigned long )crctab[((crc >> 8) & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return (crc);
}
}
#line 61 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
unsigned long binhex_crc(unsigned char *buffer___0 , int size ) 
{ 
  unsigned long tmp ;

  {
  {
#line 62
  tmp = binhex_updcrc((unsigned long )binhex_crcinit, buffer___0, size);
  }
#line 62
  return (tmp);
}
}
#line 622 "/usr/include/stdio.h"
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 702
extern int ungetc(int __c , FILE *__stream ) ;
#line 209 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) stat)(char const   * __restrict  __file ,
                                                                                             struct stat * __restrict  __buf ) ;
#line 130 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
void putlong(long val , FILE *f ) ;
#line 133
int PSGetNames(Face *face ) ;
#line 134
struct resource___0 *PSToResources(FILE *res , Face *face ) ;
#line 37 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondpfb.c"
static long getpfblong(FILE *f ) 
{ 
  int ch1 ;
  int tmp ;
  int ch2 ;
  int tmp___0 ;
  int ch3 ;
  int tmp___1 ;
  int ch4 ;
  int tmp___2 ;

  {
  {
#line 38
  tmp = _IO_getc(f);
#line 38
  ch1 = tmp;
#line 39
  tmp___0 = _IO_getc(f);
#line 39
  ch2 = tmp___0;
#line 40
  tmp___1 = _IO_getc(f);
#line 40
  ch3 = tmp___1;
#line 41
  tmp___2 = _IO_getc(f);
#line 41
  ch4 = tmp___2;
  }
#line 42
  if (ch4 == -1) {
#line 43
    return (-1L);
  }
#line 44
  return ((long )(((ch4 | (ch3 << 8)) | (ch2 << 16)) | (ch1 << 24)));
}
}
#line 47 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondpfb.c"
int PSGetNames(Face *face ) 
{ 
  FILE *pf ;
  FILE *tmp ;
  char buffer___0[512] ;
  int ch ;
  char *pt ;
  char *npt ;
  size_t tmp___0 ;
  size_t tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;

  {
  {
#line 49
  tmp = fopen((char const   */* __restrict  */)face->filename, (char const   */* __restrict  */)"r");
#line 49
  pf = tmp;
  }
#line 54
  if ((unsigned long )pf == (unsigned long )((void *)0)) {
    {
#line 55
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for reading\n",
            face->filename);
    }
#line 56
    return (0);
  }
  {
#line 58
  ch = _IO_getc(pf);
  }
#line 59
  if (ch == 128) {
    {
#line 60
    _IO_getc(pf);
#line 60
    _IO_getc(pf);
#line 60
    _IO_getc(pf);
#line 60
    _IO_getc(pf);
#line 60
    _IO_getc(pf);
    }
  } else {
    {
#line 62
    ungetc(ch, pf);
#line 63
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s doesn\'t look like a pfb font,\nif it\'s a pfa just convert it to pfb and try again.\n",
            face->filename);
#line 64
    fclose(pf);
    }
#line 65
    return (0);
  }
  {
#line 67
  buffer___0[0] = (char )'\000';
#line 68
  fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0), (FILE */* __restrict  */)pf);
  }
#line 69
  if ((int )buffer___0[0] != 37) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a postscript font\n",
            face->fontname);
#line 71
    fclose(pf);
    }
#line 72
    return (0);
  } else
#line 69
  if ((int )buffer___0[1] != 33) {
    {
#line 70
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a postscript font\n",
            face->fontname);
#line 71
    fclose(pf);
    }
#line 72
    return (0);
  }
  {
#line 75
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 75
    tmp___2 = fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0),
                    (FILE */* __restrict  */)pf);
    }
#line 75
    if (! ((unsigned long )tmp___2 != (unsigned long )((void *)0))) {
#line 75
      goto while_break;
    }
    {
#line 76
    pt = strstr((char const   *)(buffer___0), "/FamilyName");
    }
#line 76
    if ((unsigned long )pt != (unsigned long )((void *)0)) {
      {
#line 77
      tmp___0 = strlen("/FamilyName");
#line 77
      pt += tmp___0;
      }
      {
#line 78
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 78
        if (! ((int )*pt == 32)) {
#line 78
          goto while_break___0;
        }
#line 78
        pt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
#line 79
      if ((int )*pt == 40) {
#line 79
        pt ++;
      }
#line 82
      npt = pt;
      {
#line 82
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 82
        if ((int )*npt != 41) {
#line 82
          if (! ((int )*npt != 0)) {
#line 82
            goto while_break___1;
          }
        } else {
#line 82
          goto while_break___1;
        }
#line 82
        npt ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 83
      *npt = (char )'\000';
#line 84
      face->family = strdup((char const   *)pt);
      }
#line 85
      if ((unsigned long )face->fontname != (unsigned long )((void *)0)) {
#line 86
        goto while_break;
      }
    } else {
      {
#line 87
      pt = strstr((char const   *)(buffer___0), "/FontName");
      }
#line 87
      if ((unsigned long )pt != (unsigned long )((void *)0)) {
        {
#line 88
        tmp___1 = strlen("/FontName");
#line 88
        pt += tmp___1;
        }
        {
#line 89
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 89
          if (! ((int )*pt == 32)) {
#line 89
            goto while_break___2;
          }
#line 89
          pt ++;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 90
        if ((int )*pt == 47) {
#line 90
          pt ++;
        }
#line 91
        npt = pt;
        {
#line 91
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 91
          if ((int )*npt != 32) {
#line 91
            if (! ((int )*npt != 0)) {
#line 91
              goto while_break___3;
            }
          } else {
#line 91
            goto while_break___3;
          }
#line 91
          npt ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 92
        *npt = (char )'\000';
#line 93
        face->fontname = strdup((char const   *)pt);
        }
#line 94
        if ((unsigned long )face->family != (unsigned long )((void *)0)) {
#line 95
          goto while_break;
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 98
  fclose(pf);
  }
#line 99
  if ((unsigned long )face->fontname == (unsigned long )((void *)0)) {
#line 99
    if ((unsigned long )face->family != (unsigned long )((void *)0)) {
      {
#line 100
      face->fontname = strdup((char const   *)face->family);
      }
    }
  }
#line 101
  if ((unsigned long )face->fontname != (unsigned long )((void *)0)) {
    {
#line 102
    tmp___3 = strstr((char const   *)face->fontname, "Bold");
    }
#line 102
    if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
#line 103
      face->style = (int16 )((int )face->style | 1);
#line 104
      face->psstyle = (int16 )((int )face->psstyle | 1);
    }
    {
#line 106
    tmp___4 = strstr((char const   *)face->fontname, "Italic");
    }
#line 106
    if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
#line 107
      face->style = (int16 )((int )face->style | 2);
#line 108
      face->psstyle = (int16 )((int )face->psstyle | 2);
    } else {
      {
#line 106
      tmp___5 = strstr((char const   *)face->fontname, "Oblique");
      }
#line 106
      if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
#line 107
        face->style = (int16 )((int )face->style | 2);
#line 108
        face->psstyle = (int16 )((int )face->psstyle | 2);
      }
    }
    {
#line 110
    tmp___6 = strstr((char const   *)face->fontname, "Outline");
    }
#line 110
    if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
#line 111
      face->style = (int16 )((int )face->style | 8);
#line 112
      face->psstyle = (int16 )((int )face->psstyle | 4);
    }
    {
#line 114
    tmp___7 = strstr((char const   *)face->fontname, "Shadow");
    }
#line 114
    if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 115
      face->style = (int16 )((int )face->style | 16);
#line 116
      face->psstyle = (int16 )((int )face->psstyle | 8);
    }
    {
#line 118
    tmp___8 = strstr((char const   *)face->fontname, "Condense");
    }
#line 118
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 119
      face->style = (int16 )((int )face->style | 32);
#line 120
      face->psstyle = (int16 )((int )face->psstyle | 16);
    }
    {
#line 122
    tmp___9 = strstr((char const   *)face->fontname, "Extend");
    }
#line 122
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 123
      face->style = (int16 )((int )face->style | 64);
#line 124
      face->psstyle = (int16 )((int )face->psstyle | 32);
    }
  }
#line 127
  return ((unsigned long )face->fontname != (unsigned long )((void *)0));
}
}
#line 130 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondpfb.c"
struct resource___0 *PSToResources(FILE *res , Face *face ) 
{ 
  struct stat statb ;
  int cnt ;
  int type ;
  int len ;
  int i ;
  struct resource___0 *resstarts ;
  FILE *pf ;
  void *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  int ilen ;
  int tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;

  {
  {
#line 138
  stat((char const   */* __restrict  */)face->filename, (struct stat */* __restrict  */)(& statb));
#line 139
  cnt = (int )((3L * (statb.st_size + 2048L)) / 2046L + 1L);
#line 140
  tmp = calloc((size_t )(cnt + 1), sizeof(struct resource___0 ));
#line 140
  resstarts = (struct resource___0 *)tmp;
#line 142
  pf = fopen((char const   */* __restrict  */)face->filename, (char const   */* __restrict  */)"r");
#line 143
  cnt = 0;
  }
  {
#line 144
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 145
    tmp___0 = _IO_getc(pf);
    }
#line 145
    if (tmp___0 != 128) {
      {
#line 146
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Missing pfb section head in %s\n",
              face->fontname);
#line 147
      fclose(pf);
      }
#line 148
      return ((struct resource___0 *)((void *)0));
    }
    {
#line 150
    type = _IO_getc(pf);
    }
#line 151
    if (type == 3) {
      {
#line 152
      (resstarts + cnt)->id = (uint16 )(501 + cnt);
#line 153
      tmp___1 = cnt;
#line 153
      cnt ++;
#line 153
      tmp___2 = ftell(res);
#line 153
      (resstarts + tmp___1)->pos = (uint32 )tmp___2;
#line 154
      putlong(2L, res);
#line 155
      _IO_putc(5, res);
#line 156
      _IO_putc(0, res);
      }
#line 157
      goto while_break;
    }
    {
#line 159
    tmp___3 = getpfblong(pf);
#line 159
    len = (int )tmp___3;
    }
    {
#line 160
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 160
      if (! (len > 0)) {
#line 160
        goto while_break___0;
      }
#line 161
      ilen = len;
#line 162
      if (ilen > 2046) {
#line 163
        ilen = 2046;
      }
      {
#line 164
      len -= ilen;
#line 165
      (resstarts + cnt)->id = (uint16 )(501 + cnt);
#line 166
      tmp___4 = cnt;
#line 166
      cnt ++;
#line 166
      tmp___5 = ftell(res);
#line 166
      (resstarts + tmp___4)->pos = (uint32 )tmp___5;
#line 167
      putlong((long )(ilen + 2), res);
#line 168
      _IO_putc(type, res);
#line 169
      _IO_putc(0, res);
#line 170
      i = 0;
      }
      {
#line 170
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 170
        if (! (i < ilen)) {
#line 170
          goto while_break___1;
        }
        {
#line 171
        tmp___6 = _IO_getc(pf);
#line 171
        _IO_putc(tmp___6, res);
#line 170
        i ++;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 174
  fclose(pf);
#line 175
  (resstarts + cnt)->pos = (uint32 )0;
  }
#line 176
  return (resstarts);
}
}
#line 362 "/usr/include/stdio.h"
extern int printf(char const   * __restrict  __format  , ...) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 480
extern  __attribute__((__nothrow__)) void *( __attribute__((__warn_unused_result__,
__leaf__)) realloc)(void *__ptr , size_t __size ) ;
#line 129 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
void putshort(int val , FILE *f ) ;
#line 139
int BDFGetNames(Face *face ) ;
#line 140
long BDFToResource(FILE *res , Face *face ) ;
#line 46 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
int BDFGetNames(Face *face ) 
{ 
  FILE *bdf ;
  FILE *tmp ;
  char buffer___0[512] ;
  char *pt ;
  char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  long tmp___3 ;
  int w ;
  int h ;
  int lb ;
  int ds ;
  int tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;
  char *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  char *tmp___25 ;

  {
  {
#line 48
  tmp = fopen((char const   */* __restrict  */)face->filename, (char const   */* __restrict  */)"r");
#line 48
  bdf = tmp;
  }
#line 52
  if ((unsigned long )bdf == (unsigned long )((void *)0)) {
    {
#line 53
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for reading\n",
            face->filename);
    }
#line 54
    return (0);
  }
  {
#line 56
  tmp___0 = fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0),
                  (FILE */* __restrict  */)bdf);
  }
#line 56
  if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
    {
#line 57
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s doesn\'t look like a bdf font",
            face->filename);
#line 58
    fclose(bdf);
    }
#line 59
    return (0);
  } else {
    {
#line 56
    tmp___1 = strncmp((char const   *)(buffer___0), "STARTFONT ", (size_t )10);
    }
#line 56
    if (tmp___1 != 0) {
      {
#line 57
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s doesn\'t look like a bdf font",
              face->filename);
#line 58
      fclose(bdf);
      }
#line 59
      return (0);
    }
  }
#line 61
  buffer___0[0] = (char )'\000';
  {
#line 62
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 62
    tmp___25 = fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0),
                     (FILE */* __restrict  */)bdf);
    }
#line 62
    if (! ((unsigned long )tmp___25 != (unsigned long )((void *)0))) {
#line 62
      goto while_break;
    }
    {
#line 63
    tmp___2 = strncmp((char const   *)(buffer___0), "CHARS ", (size_t )6);
    }
#line 63
    if (tmp___2 == 0) {
#line 65
      goto while_break;
    }
    {
#line 66
    tmp___24 = strncmp((char const   *)(buffer___0), "FAMILY_NAME \"", (size_t )13);
    }
#line 66
    if (tmp___24 == 0) {
      {
#line 67
      pt = strchr((char const   *)(buffer___0 + 13), '\"');
      }
#line 68
      if ((unsigned long )pt != (unsigned long )((void *)0)) {
        {
#line 69
        *pt = (char )'\000';
#line 70
        face->family = strdup((char const   *)(buffer___0 + 13));
        }
      }
    } else {
      {
#line 72
      tmp___23 = strncmp((char const   *)(buffer___0), "PIXEL_SIZE ", (size_t )11);
      }
#line 72
      if (tmp___23 == 0) {
        {
#line 73
        tmp___3 = strtol((char const   */* __restrict  */)(buffer___0 + 11), (char **/* __restrict  */)((void *)0),
                         10);
#line 73
        face->size = (int )tmp___3;
        }
      } else {
        {
#line 77
        tmp___22 = strncmp((char const   *)(buffer___0), "FONTBOUNDINGBOX ", (size_t )16);
        }
#line 77
        if (tmp___22 == 0) {
          {
#line 79
          tmp___4 = sscanf((char const   */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"FONTBOUNDINGBOX %d %d %d %d",
                           & w, & h, & lb, & ds);
          }
#line 79
          if (tmp___4 == 4) {
#line 80
            face->xmin = lb;
#line 81
            face->ymin = ds;
#line 82
            face->xmax = lb + w;
#line 83
            face->ymax = ds + h;
          }
        } else {
          {
#line 85
          tmp___21 = strncmp((char const   *)(buffer___0), "FONT_ASCENT ", (size_t )12);
          }
#line 85
          if (tmp___21 == 0) {
            {
#line 86
            tmp___5 = strtol((char const   */* __restrict  */)(buffer___0 + 12), (char **/* __restrict  */)((void *)0),
                             10);
#line 86
            face->ascent = (int )tmp___5;
            }
          } else {
            {
#line 87
            tmp___20 = strncmp((char const   *)(buffer___0), "FONT_DESCENT ", (size_t )13);
            }
#line 87
            if (tmp___20 == 0) {
              {
#line 88
              tmp___6 = strtol((char const   */* __restrict  */)(buffer___0 + 13),
                               (char **/* __restrict  */)((void *)0), 10);
#line 88
              face->descent = (int )tmp___6;
              }
            } else {
              {
#line 89
              tmp___19 = strncmp((char const   *)(buffer___0), "SLANT \"", (size_t )7);
              }
#line 89
              if (tmp___19 == 0) {
#line 90
                if ((int )buffer___0[7] == 73) {
#line 91
                  face->style = (int16 )((int )face->style | 2);
                } else
#line 90
                if ((int )buffer___0[7] == 79) {
#line 91
                  face->style = (int16 )((int )face->style | 2);
                }
              } else {
                {
#line 92
                tmp___18 = strncmp((char const   *)(buffer___0), "WEIGHT_NAME \"",
                                   (size_t )13);
                }
#line 92
                if (tmp___18 == 0) {
                  {
#line 93
                  tmp___7 = strstr((char const   *)(buffer___0 + 13), "Bold");
                  }
#line 93
                  if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
#line 96
                    face->style = (int16 )((int )face->style | 1);
                  } else {
                    {
#line 93
                    tmp___8 = strstr((char const   *)(buffer___0 + 13), "BOLD");
                    }
#line 93
                    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 96
                      face->style = (int16 )((int )face->style | 1);
                    } else {
                      {
#line 93
                      tmp___9 = strstr((char const   *)(buffer___0 + 13), "Gras");
                      }
#line 93
                      if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 96
                        face->style = (int16 )((int )face->style | 1);
                      } else {
                        {
#line 93
                        tmp___10 = strstr((char const   *)(buffer___0 + 13), "Fett");
                        }
#line 93
                        if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 96
                          face->style = (int16 )((int )face->style | 1);
                        } else {
                          {
#line 93
                          tmp___11 = strstr((char const   *)(buffer___0 + 13), "Black");
                          }
#line 93
                          if ((unsigned long )tmp___11 != (unsigned long )((void *)0)) {
#line 96
                            face->style = (int16 )((int )face->style | 1);
                          } else {
                            {
#line 93
                            tmp___12 = strstr((char const   *)(buffer___0 + 13), "Heavy");
                            }
#line 93
                            if ((unsigned long )tmp___12 != (unsigned long )((void *)0)) {
#line 96
                              face->style = (int16 )((int )face->style | 1);
                            }
                          }
                        }
                      }
                    }
                  }
                } else {
                  {
#line 97
                  tmp___17 = strncmp((char const   *)(buffer___0), "SETWIDTH_NAME \"",
                                     (size_t )15);
                  }
#line 97
                  if (tmp___17 == 0) {
                    {
#line 98
                    tmp___15 = strstr((char const   *)(buffer___0 + 15), "Condense");
                    }
#line 98
                    if ((unsigned long )tmp___15 != (unsigned long )((void *)0)) {
#line 99
                      face->style = (int16 )((int )face->style | 32);
                    } else {
                      {
#line 100
                      tmp___13 = strstr((char const   *)(buffer___0 + 15), "Extend");
                      }
#line 100
                      if ((unsigned long )tmp___13 != (unsigned long )((void *)0)) {
#line 101
                        face->style = (int16 )((int )face->style | 64);
                      } else {
                        {
#line 100
                        tmp___14 = strstr((char const   *)(buffer___0 + 15), "Expand");
                        }
#line 100
                        if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
#line 101
                          face->style = (int16 )((int )face->style | 64);
                        }
                      }
                    }
                  } else {
                    {
#line 102
                    tmp___16 = strncmp((char const   *)(buffer___0), "SPACING \"",
                                       (size_t )9);
                    }
#line 102
                    if (tmp___16 == 0) {
#line 103
                      if ((int )buffer___0[9] == 77) {
#line 104
                        face->fixed = 1;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 107
  fclose(bdf);
  }
#line 108
  if (face->size == 0) {
#line 108
    face->size = face->ascent + face->descent;
  }
#line 109
  if ((unsigned long )face->family == (unsigned long )((void *)0)) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s does not contain all the needed meta data\n",
            face->filename);
    }
#line 111
    return (0);
  } else
#line 109
  if (face->size == 0) {
    {
#line 110
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s does not contain all the needed meta data\n",
            face->filename);
    }
#line 111
    return (0);
  }
#line 113
  if (face->ascent == 0) {
#line 114
    if (face->descent != 0) {
#line 114
      face->ascent = face->size - face->descent;
    } else {
#line 115
      face->ascent = (8 * face->size + 5) / 10;
    }
  }
#line 117
  if (face->descent == 0) {
#line 117
    face->descent = face->size - face->ascent;
  }
#line 118
  return (1);
}
}
#line 121 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static void FreeBdfFont(struct bdffont *font ) 
{ 
  char **l ;
  int i ;
  char **tmp ;
  char **tmp___0 ;

  {
#line 125
  if ((unsigned long )font != (unsigned long )((void *)0)) {
#line 126
    i = 0;
    {
#line 126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 126
      if (! (i < font->charmax)) {
#line 126
        goto while_break;
      }
#line 126
      if ((unsigned long )*(font->chars + i) != (unsigned long )((void *)0)) {
#line 127
        l = *(font->chars + i);
        {
#line 128
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 128
          if (! *l) {
#line 128
            goto while_break___0;
          }
          {
#line 128
          tmp = l;
#line 128
          l ++;
#line 128
          free((void *)*tmp);
          }
        }
        while_break___0: /* CIL Label */ ;
        }
        {
#line 129
        free((void *)*(font->chars + i));
        }
      }
#line 126
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 131
    free((void *)font->chars);
#line 132
    l = font->header;
    }
    {
#line 133
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 133
      if (! *l) {
#line 133
        goto while_break___1;
      }
      {
#line 133
      tmp___0 = l;
#line 133
      l ++;
#line 133
      free((void *)*tmp___0);
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 134
    free((void *)font->header);
    }
#line 135
    if (font->fontname) {
      {
#line 136
      free((void *)font->fontname);
      }
    }
    {
#line 137
    free((void *)font);
    }
  }
#line 139
  return;
}
}
#line 144
static char **SlurpChar(FILE *bdffile , char *buffer___0 , int size , char *terminator ,
                        int *val ) ;
#line 144 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static char **list  =    (char **)((void *)0);
#line 145 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static int tot  =    0;
#line 143 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static char **SlurpChar(FILE *bdffile , char *buffer___0 , int size , char *terminator ,
                        int *val ) 
{ 
  int i ;
  int j ;
  int enc ;
  char **ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;

  {
#line 146
  i = 0;
#line 146
  enc = -1;
  {
#line 149
  while (1) {
    while_continue: /* CIL Label */ ;
#line 150
    if (i >= tot) {
#line 151
      if ((unsigned long )list == (unsigned long )((void *)0)) {
        {
#line 151
        tot = 60;
#line 151
        tmp = malloc((unsigned long )tot * sizeof(char *));
#line 151
        list = (char **)tmp;
        }
      } else {
        {
#line 152
        tot *= 2;
#line 152
        tmp___0 = realloc((void *)list, (unsigned long )tot * sizeof(char *));
#line 152
        list = (char **)tmp___0;
        }
      }
#line 153
      j = i;
      {
#line 153
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 153
        if (! (j < tot)) {
#line 153
          goto while_break___0;
        }
        {
#line 154
        tmp___1 = malloc((size_t )201);
#line 154
        *(list + j) = (char *)tmp___1;
#line 153
        j ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 156
    tmp___2 = i;
#line 156
    i ++;
#line 156
    strcpy((char */* __restrict  */)*(list + tmp___2), (char const   */* __restrict  */)buffer___0);
#line 157
    tmp___3 = strstr((char const   *)buffer___0, "ENCODING");
    }
#line 157
    if ((unsigned long )tmp___3 == (unsigned long )buffer___0) {
      {
#line 158
      sscanf((char const   */* __restrict  */)buffer___0, (char const   */* __restrict  */)"ENCODING %d",
             & enc);
      }
    }
    {
#line 159
    tmp___4 = strstr((char const   *)buffer___0, (char const   *)terminator);
    }
#line 159
    if ((unsigned long )tmp___4 == (unsigned long )buffer___0) {
#line 160
      goto while_break;
    }
    {
#line 161
    tmp___5 = fgets((char */* __restrict  */)buffer___0, size, (FILE */* __restrict  */)bdffile);
    }
#line 161
    if ((unsigned long )tmp___5 == (unsigned long )((void *)0)) {
#line 162
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 165
  j = i;
#line 166
  if (j < 7) {
#line 166
    j = 7;
  }
  {
#line 167
  tmp___6 = malloc((unsigned long )(j + 1) * sizeof(char *));
#line 167
  ret = (char **)tmp___6;
#line 168
  j = 0;
  }
  {
#line 168
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 168
    if (! (j < i)) {
#line 168
      goto while_break___1;
    }
    {
#line 169
    *(ret + j) = strdup((char const   *)*(list + j));
#line 168
    j ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 170
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 170
    if (! (j < 7)) {
#line 170
      goto while_break___2;
    }
    {
#line 171
    tmp___7 = j;
#line 171
    j ++;
#line 171
    *(ret + tmp___7) = strdup("");
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 172
  *(ret + i) = (char *)((void *)0);
#line 173
  *val = enc;
#line 174
  return (ret);
}
}
#line 177 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static struct bdffont *SlurpFont(Face *face ) 
{ 
  FILE *bdffile ;
  FILE *tmp ;
  struct bdffont *bdffont ;
  char buffer___0[201] ;
  char **chr ;
  int i ;
  int enc ;
  int last_enc ;
  void *tmp___0 ;
  int new ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;

  {
  {
#line 178
  tmp = fopen((char const   */* __restrict  */)face->filename, (char const   */* __restrict  */)"r");
#line 178
  bdffile = tmp;
#line 182
  last_enc = -1;
  }
#line 184
  if ((unsigned long )bdffile == (unsigned long )((void *)0)) {
    {
#line 185
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s\n",
            face->filename);
    }
#line 186
    return ((struct bdffont *)((void *)0));
  }
  {
#line 188
  tmp___0 = calloc((size_t )1, sizeof(*bdffont));
#line 188
  bdffont = (struct bdffont *)tmp___0;
#line 189
  bdffont->face = face;
#line 191
  fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0), (FILE */* __restrict  */)bdffile);
#line 192
  bdffont->header = SlurpChar(bdffile, buffer___0, (int )sizeof(buffer___0), (char *)"ENDPROPERTIES",
                              & enc);
#line 193
  fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0), (FILE */* __restrict  */)bdffile);
#line 195
  fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0), (FILE */* __restrict  */)bdffile);
  }
  {
#line 196
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 196
    tmp___4 = strcmp((char const   *)(buffer___0), "ENDFONT\n");
    }
#line 196
    if (! (tmp___4 != 0)) {
#line 196
      goto while_break;
    }
    {
#line 197
    chr = SlurpChar(bdffile, buffer___0, (int )sizeof(buffer___0), (char *)"ENDCHAR",
                    & enc);
    }
#line 198
    if (enc != -1) {
#line 199
      if (enc >= bdffont->charmax) {
#line 200
        new = enc + 256;
#line 201
        if (bdffont->charmax == 0) {
          {
#line 201
          tmp___1 = malloc((unsigned long )new * sizeof(char **));
#line 201
          bdffont->chars = (char ***)tmp___1;
          }
        } else {
          {
#line 202
          tmp___2 = realloc((void *)bdffont->chars, (unsigned long )new * sizeof(char **));
#line 202
          bdffont->chars = (char ***)tmp___2;
          }
        }
#line 203
        i = bdffont->charmax;
        {
#line 203
        while (1) {
          while_continue___0: /* CIL Label */ ;
#line 203
          if (! (i < new)) {
#line 203
            goto while_break___0;
          }
#line 204
          *(bdffont->chars + i) = (char **)((void *)0);
#line 203
          i ++;
        }
        while_break___0: /* CIL Label */ ;
        }
#line 205
        bdffont->charmax = new;
      }
#line 207
      *(bdffont->chars + enc) = chr;
#line 208
      last_enc = enc;
    }
    {
#line 210
    tmp___3 = fgets((char */* __restrict  */)(buffer___0), (int )sizeof(buffer___0),
                    (FILE */* __restrict  */)bdffile);
    }
#line 210
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 211
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 213
  return (bdffont);
}
}
#line 216 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static void ParseBdfHeader(struct macfont *macfont , struct bdffont *bdf ) 
{ 
  int h ;
  int w ;
  int lb ;
  int ds ;
  int i ;
  int tmp ;

  {
#line 217
  h = 10;
#line 217
  w = 10;
#line 217
  lb = 0;
#line 217
  ds = 0;
#line 219
  i = 0;
  {
#line 219
  while (1) {
    while_continue: /* CIL Label */ ;
#line 219
    if (! ((unsigned long )*(bdf->header + i) != (unsigned long )((void *)0))) {
#line 219
      goto while_break;
    }
    {
#line 220
    tmp = sscanf((char const   */* __restrict  */)*(bdf->header + i), (char const   */* __restrict  */)"FONTBOUNDINGBOX %d %d %d %d",
                 & w, & h, & lb, & ds);
    }
#line 220
    if (tmp == 4) {
#line 221
      goto while_break;
    }
#line 219
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 222
  macfont->fRectWidth = (short )w;
#line 223
  macfont->fRectHeight = (short )(macfont->face)->size;
#line 224
  macfont->ascent = (short )(macfont->face)->ascent;
#line 225
  macfont->descent = (short )(macfont->face)->descent;
#line 226
  macfont->nDescent = (short )(- (macfont->face)->descent);
#line 227
  macfont->leading = (short)0;
#line 228
  macfont->kernMax = (short )lb;
#line 229
  macfont->firstChar = (short)0;
#line 230
  macfont->lastChar = (short)255;
#line 231
  if ((macfont->face)->fixed) {
#line 231
    macfont->fontType = (short)-20480;
  } else {
#line 231
    macfont->fontType = (short)-28672;
  }
#line 232
  return;
}
}
#line 234 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static int ParseCharWidths(struct macfont *macfont , int ch , char **chlist , int loc ) 
{ 
  int pwidth ;
  int swidth ;
  int gwidth ;
  int lb ;
  int i ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
#line 235
  pwidth = 0;
#line 235
  swidth = 0;
#line 235
  gwidth = 0;
#line 235
  lb = 0;
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! ((unsigned long )*(chlist + i) != (unsigned long )((void *)0))) {
#line 238
      goto while_break;
    }
    {
#line 239
    tmp___1 = strncmp((char const   *)*(chlist + i), "SWIDTH", (size_t )6);
    }
#line 239
    if (tmp___1 == 0) {
      {
#line 240
      sscanf((char const   */* __restrict  */)*(chlist + i), (char const   */* __restrict  */)"SWIDTH %d",
             & swidth);
      }
    } else {
      {
#line 241
      tmp___0 = strncmp((char const   *)*(chlist + i), "DWIDTH", (size_t )6);
      }
#line 241
      if (tmp___0 == 0) {
        {
#line 242
        sscanf((char const   */* __restrict  */)*(chlist + i), (char const   */* __restrict  */)"DWIDTH %d",
               & pwidth);
        }
      } else {
        {
#line 243
        tmp = strncmp((char const   *)*(chlist + i), "BBX", (size_t )3);
        }
#line 243
        if (tmp == 0) {
          {
#line 244
          sscanf((char const   */* __restrict  */)*(chlist + i), (char const   */* __restrict  */)"BBX %d %*d %d",
                 & gwidth, & lb);
          }
        }
      }
    }
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 247
  *(macfont->widths + ch) = (unsigned short )pwidth;
#line 248
  *(macfont->lbearings + ch) = (short )lb;
#line 249
  (macfont->face)->metrics[ch] = (short )((((long )swidth << 12) + 500L) / 1000L);
#line 250
  *(macfont->locs + ch) = (unsigned short )loc;
#line 251
  return (loc + gwidth);
}
}
#line 254 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static void ProcessLBearings(struct macfont *macfont ) 
{ 
  int i ;
  int lb ;
  int wmax ;

  {
#line 255
  lb = 256;
#line 255
  wmax = 0;
#line 257
  i = 0;
  {
#line 257
  while (1) {
    while_continue: /* CIL Label */ ;
#line 257
    if (! (i < 255)) {
#line 257
      goto while_break;
    }
#line 258
    if ((int )*(macfont->widths + i) != 65535) {
#line 258
      if ((int )*(macfont->lbearings + i) < lb) {
#line 259
        lb = (int )*(macfont->lbearings + i);
      }
    }
#line 260
    if ((int )*(macfont->widths + i) != 65535) {
#line 260
      if ((int )*(macfont->widths + i) > wmax) {
#line 261
        wmax = (int )*(macfont->widths + i);
      }
    }
#line 257
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 263
  macfont->kernMax = (short )lb;
#line 264
  macfont->widmax = (uint16 )wmax;
#line 266
  i = 0;
  {
#line 266
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 266
    if (! (i < 255)) {
#line 266
      goto while_break___0;
    }
#line 267
    if ((int )*(macfont->widths + i) != 65535) {
#line 268
      *(macfont->widths + i) = (unsigned short )((int )*(macfont->widths + i) | (((int )*(macfont->lbearings + i) - lb) << 8));
    }
#line 266
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 272
  *(macfont->widths + 0) = (unsigned short)0;
#line 273
  *(macfont->widths + '\t') = (unsigned short)6;
#line 274
  *(macfont->widths + '\r') = (unsigned short)0;
#line 275
  return;
}
}
#line 277 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static void ParseRow(struct macfont *macfont , int ch , int row , char *hexbits ) 
{ 
  int loc ;
  int bits ;
  unsigned short word ;
  unsigned short const   **tmp ;
  unsigned short const   **tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
#line 278
  loc = (int )*(macfont->locs + ch);
#line 278
  bits = (int )*(macfont->locs + (ch + 1)) - loc;
#line 281
  if (row >= (int )macfont->fRectHeight) {
#line 282
    return;
  } else
#line 281
  if (row < 0) {
#line 282
    return;
  }
  {
#line 284
  while (1) {
    while_continue: /* CIL Label */ ;
#line 284
    if ((int )*hexbits != 0) {
#line 284
      if (! (bits > 0)) {
#line 284
        goto while_break;
      }
    } else {
#line 284
      goto while_break;
    }
    {
#line 285
    tmp = __ctype_b_loc();
    }
#line 285
    if ((int const   )*(*tmp + (int )*hexbits) & 2048) {
#line 285
      word = (unsigned short )(((int )*hexbits - 48) << 12);
    } else
#line 286
    if ((int )*hexbits >= 97) {
#line 286
      if ((int )*hexbits <= 102) {
#line 286
        word = (unsigned short )((((int )*hexbits - 97) + 10) << 12);
      } else {
#line 286
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 287
    if ((int )*hexbits >= 65) {
#line 287
      if ((int )*hexbits <= 70) {
#line 287
        word = (unsigned short )((((int )*hexbits - 65) + 10) << 12);
      } else {
#line 288
        word = (unsigned short)0;
      }
    } else {
#line 288
      word = (unsigned short)0;
    }
    {
#line 289
    hexbits ++;
#line 290
    tmp___0 = __ctype_b_loc();
    }
#line 290
    if ((int const   )*(*tmp___0 + (int )*hexbits) & 2048) {
#line 290
      word = (unsigned short )((int )word | (((int )*hexbits - 48) << 8));
    } else
#line 291
    if ((int )*hexbits >= 97) {
#line 291
      if ((int )*hexbits <= 102) {
#line 291
        word = (unsigned short )((int )word | ((((int )*hexbits - 97) + 10) << 8));
      } else {
#line 291
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 292
    if ((int )*hexbits >= 65) {
#line 292
      if ((int )*hexbits <= 70) {
#line 292
        word = (unsigned short )((int )word | ((((int )*hexbits - 65) + 10) << 8));
      } else {
#line 293
        hexbits --;
      }
    } else {
#line 293
      hexbits --;
    }
    {
#line 294
    hexbits ++;
#line 295
    tmp___1 = __ctype_b_loc();
    }
#line 295
    if ((int const   )*(*tmp___1 + (int )*hexbits) & 2048) {
#line 295
      word = (unsigned short )((int )word | (((int )*hexbits - 48) << 4));
    } else
#line 296
    if ((int )*hexbits >= 97) {
#line 296
      if ((int )*hexbits <= 102) {
#line 296
        word = (unsigned short )((int )word | ((((int )*hexbits - 97) + 10) << 4));
      } else {
#line 296
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 297
    if ((int )*hexbits >= 65) {
#line 297
      if ((int )*hexbits <= 70) {
#line 297
        word = (unsigned short )((int )word | ((((int )*hexbits - 65) + 10) << 4));
      } else {
#line 298
        hexbits --;
      }
    } else {
#line 298
      hexbits --;
    }
    {
#line 299
    hexbits ++;
#line 300
    tmp___2 = __ctype_b_loc();
    }
#line 300
    if ((int const   )*(*tmp___2 + (int )*hexbits) & 2048) {
#line 300
      word = (unsigned short )((int )word | ((int )*hexbits - 48));
    } else
#line 301
    if ((int )*hexbits >= 97) {
#line 301
      if ((int )*hexbits <= 102) {
#line 301
        word = (unsigned short )((int )word | (((int )*hexbits - 97) + 10));
      } else {
#line 301
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 302
    if ((int )*hexbits >= 65) {
#line 302
      if ((int )*hexbits <= 70) {
#line 302
        word = (unsigned short )((int )word | (((int )*hexbits - 65) + 10));
      } else {
#line 303
        hexbits --;
      }
    } else {
#line 303
      hexbits --;
    }
#line 304
    hexbits ++;
#line 305
    if ((loc & 15) == 0) {
#line 306
      *(*(macfont->rows + row) + (loc >> 4)) = word;
    } else {
#line 308
      *(*(macfont->rows + row) + (loc >> 4)) = (unsigned short )((int )*(*(macfont->rows + row) + (loc >> 4)) | ((int )word >> (loc & 15)));
#line 309
      if (bits - (16 - (loc & 15)) <= 0) {
#line 310
        goto while_break;
      }
#line 311
      *(*(macfont->rows + row) + ((loc >> 4) + 1)) = (unsigned short )((int )word << (16 - (loc & 15)));
    }
#line 313
    loc += 16;
#line 314
    bits -= 16;
  }
  while_break: /* CIL Label */ ;
  }
#line 316
  return;
}
}
#line 318 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static void ParseBitmap(struct macfont *macfont , int ch , char **chlist ) 
{ 
  int height ;
  int descent ;
  int ascent ;
  int off ;
  int i ;
  int base ;
  int tmp ;
  int tmp___0 ;

  {
#line 321
  base = 0;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! ((unsigned long )*(chlist + base) != (unsigned long )((void *)0))) {
#line 321
      goto while_break;
    }
    {
#line 322
    tmp___0 = strncmp((char const   *)*(chlist + base), "BBX", (size_t )3);
    }
#line 322
    if (tmp___0 == 0) {
      {
#line 323
      sscanf((char const   */* __restrict  */)*(chlist + base), (char const   */* __restrict  */)"BBX %*d %d %*d %d",
             & height, & descent);
      }
    } else {
      {
#line 324
      tmp = strncmp((char const   *)*(chlist + base), "BITMAP", (size_t )6);
      }
#line 324
      if (tmp == 0) {
#line 325
        goto while_break;
      }
    }
#line 321
    base ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  if ((unsigned long )*(chlist + base) != (unsigned long )((void *)0)) {
#line 328
    ascent = height + descent;
#line 329
    off = (int )macfont->ascent - ascent;
#line 330
    i = 0;
    {
#line 330
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 330
      if (! (i < height)) {
#line 330
        goto while_break___0;
      }
      {
#line 331
      ParseRow(macfont, ch, i + off, *(chlist + ((i + base) + 1)));
#line 330
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 333
  return;
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static void DummyUpFakeBitmap(struct macfont *macfont , int ch ) 
{ 
  int loc ;
  int lw ;
  int lb ;
  int i ;

  {
#line 337
  loc = (int )*(macfont->locs + ch);
#line 337
  lw = loc >> 4;
#line 337
  lb = 1 << (15 - (loc & 15));
#line 340
  i = 0;
  {
#line 340
  while (1) {
    while_continue: /* CIL Label */ ;
#line 340
    if (! (i < (int )macfont->fRectHeight)) {
#line 340
      goto while_break;
    }
#line 341
    *(*(macfont->rows + i) + lw) = (unsigned short )((int )*(*(macfont->rows + i) + lw) | lb);
#line 340
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 342
  return;
}
}
#line 344 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static struct macfont *CvtBdfToNfnt(struct bdffont *bdf , Face *face ) 
{ 
  struct macfont *macfont ;
  int i ;
  int loc ;
  int ch ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
#line 348
  if ((unsigned long )bdf == (unsigned long )((void *)0)) {
#line 349
    return ((struct macfont *)((void *)0));
  }
  {
#line 350
  tmp = calloc(sizeof(struct macfont ), sizeof(char ));
#line 350
  macfont = (struct macfont *)tmp;
#line 351
  macfont->face = face;
#line 352
  tmp___0 = calloc((size_t )258, sizeof(short ));
#line 352
  macfont->widths = (unsigned short *)tmp___0;
#line 353
  tmp___1 = calloc((size_t )258, sizeof(short ));
#line 353
  macfont->lbearings = (short *)tmp___1;
#line 354
  tmp___2 = calloc((size_t )258, sizeof(short ));
#line 354
  macfont->locs = (unsigned short *)tmp___2;
#line 355
  ParseBdfHeader(macfont, bdf);
#line 356
  tmp___3 = malloc((unsigned long )macfont->fRectHeight * sizeof(char *));
#line 356
  macfont->rows = (unsigned short **)tmp___3;
#line 358
  loc = 0;
#line 359
  i = 0;
  }
  {
#line 359
  while (1) {
    while_continue: /* CIL Label */ ;
#line 359
    if (! (i < 256)) {
#line 359
      goto while_break;
    }
#line 360
    ch = i;
#line 361
    if (ch < bdf->charmax) {
#line 361
      if ((unsigned long )*(bdf->chars + ch) != (unsigned long )((void *)0)) {
        {
#line 362
        loc = ParseCharWidths(macfont, i, *(bdf->chars + ch), loc);
        }
      } else {
#line 364
        *(macfont->widths + i) = (unsigned short)65535;
#line 365
        *(macfont->locs + i) = (unsigned short )loc;
      }
    } else {
#line 364
      *(macfont->widths + i) = (unsigned short)65535;
#line 365
      *(macfont->locs + i) = (unsigned short )loc;
    }
#line 359
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 368
  *(macfont->locs + i) = (unsigned short )loc;
#line 369
  *(macfont->widths + i) = (unsigned short)3;
#line 370
  (macfont->face)->metrics[i] = (short )((3 << 12) / (int )macfont->fRectHeight);
#line 371
  *(macfont->lbearings + i) = (short)1;
#line 372
  loc ++;
#line 372
  *(macfont->locs + (i + 1)) = (unsigned short )loc;
#line 373
  *(macfont->widths + (i + 1)) = (unsigned short)65535;
#line 375
  macfont->rowWords = (short )((loc + 15) / 16);
#line 376
  i = 0;
  {
#line 376
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 376
    if (! (i < (int )macfont->fRectHeight)) {
#line 376
      goto while_break___0;
    }
    {
#line 377
    tmp___4 = calloc((size_t )macfont->rowWords, sizeof(short ));
#line 377
    *(macfont->rows + i) = (unsigned short *)tmp___4;
#line 376
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 379
  i = 0;
  {
#line 379
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 379
    if (! (i < 256)) {
#line 379
      goto while_break___1;
    }
#line 380
    ch = i;
#line 381
    if (ch < bdf->charmax) {
#line 381
      if ((unsigned long )*(bdf->chars + ch) != (unsigned long )((void *)0)) {
        {
#line 382
        ParseBitmap(macfont, i, *(bdf->chars + ch));
        }
      }
    }
#line 379
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 384
  DummyUpFakeBitmap(macfont, i);
#line 386
  ProcessLBearings(macfont);
  }
#line 387
  return (macfont);
}
}
#line 390 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static struct macfont *ProcessBdfFile(Face *face ) 
{ 
  struct bdffont *bdf ;
  struct bdffont *tmp ;
  struct macfont *macfont ;
  struct macfont *tmp___0 ;

  {
  {
#line 391
  tmp = SlurpFont(face);
#line 391
  bdf = tmp;
#line 392
  tmp___0 = CvtBdfToNfnt(bdf, face);
#line 392
  macfont = tmp___0;
#line 393
  FreeBdfFont(bdf);
  }
#line 394
  return (macfont);
}
}
#line 397 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static void FreeMacFont(struct macfont *macfont ) 
{ 
  int i ;

  {
#line 400
  i = 0;
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (i < (int )macfont->fRectHeight)) {
#line 400
      goto while_break;
    }
    {
#line 401
    free((void *)*(macfont->rows + i));
#line 400
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 402
  free((void *)macfont->rows);
#line 403
  free((void *)macfont->lbearings);
#line 404
  free((void *)macfont->widths);
#line 405
  free((void *)macfont->locs);
#line 406
  free((void *)macfont);
  }
#line 407
  return;
}
}
#line 409 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
static long DumpMacFont(FILE *resfile , struct macfont *macfont ) 
{ 
  int size ;
  int i ;
  int j ;
  long here ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;

  {
  {
#line 413
  size = (int )(((13UL * sizeof(short ) + (unsigned long )((int )macfont->fRectHeight * (int )macfont->rowWords) * sizeof(short )) + 258UL * sizeof(short )) + 258UL * sizeof(short ));
#line 417
  macfont->owTLoc = (short )((((unsigned long )size - 258UL * sizeof(short )) - 8UL * sizeof(short )) / sizeof(short ));
#line 421
  here = ftell(resfile);
#line 422
  putlong(0L, resfile);
#line 423
  putshort((int )macfont->fontType, resfile);
#line 424
  putshort((int )macfont->firstChar, resfile);
#line 425
  putshort((int )macfont->lastChar, resfile);
#line 426
  putshort((int )macfont->widmax, resfile);
#line 427
  putshort((int )macfont->kernMax, resfile);
#line 428
  putshort((int )macfont->nDescent, resfile);
#line 429
  putshort((int )macfont->fRectWidth, resfile);
#line 430
  putshort((int )macfont->fRectHeight, resfile);
#line 431
  putshort((int )macfont->owTLoc, resfile);
#line 432
  putshort((int )macfont->ascent, resfile);
#line 433
  putshort((int )macfont->descent, resfile);
#line 434
  putshort((int )macfont->leading, resfile);
#line 435
  putshort((int )macfont->rowWords, resfile);
#line 436
  i = 0;
  }
  {
#line 436
  while (1) {
    while_continue: /* CIL Label */ ;
#line 436
    if (! (i < (int )macfont->fRectHeight)) {
#line 436
      goto while_break;
    }
#line 437
    j = 0;
    {
#line 437
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 437
      if (! (j < (int )macfont->rowWords)) {
#line 437
        goto while_break___0;
      }
      {
#line 438
      putshort((int )*(*(macfont->rows + i) + j), resfile);
#line 437
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 436
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 440
  i = 0;
  {
#line 440
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 440
    if (! (i < 258)) {
#line 440
      goto while_break___1;
    }
    {
#line 441
    putshort((int )*(macfont->locs + i), resfile);
#line 440
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 442
  i = 0;
  {
#line 442
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 442
    if (! (i < 258)) {
#line 442
      goto while_break___2;
    }
    {
#line 443
    putshort((int )*(macfont->widths + i), resfile);
#line 442
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 445
  tmp___0 = ftell(resfile);
  }
#line 445
  if ((long )size != (tmp___0 - here) - 4L) {
    {
#line 446
    tmp = ftell(resfile);
#line 446
    printf((char const   */* __restrict  */)"IE: expected %d found %d\n", size, (tmp - here) - 4L);
    }
  }
  {
#line 447
  tmp___1 = ftell(resfile);
#line 447
  size = (int )((tmp___1 - here) - 4L);
#line 448
  fseek(resfile, here, 0);
#line 449
  putlong((long )size, resfile);
#line 450
  fseek(resfile, 0L, 2);
  }
#line 451
  return (here);
}
}
#line 454 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondbdf.c"
long BDFToResource(FILE *res , Face *face ) 
{ 
  struct macfont *macfont ;
  struct macfont *tmp ;
  long ret ;

  {
  {
#line 455
  tmp = ProcessBdfFile(face);
#line 455
  macfont = tmp;
  }
#line 457
  if ((unsigned long )macfont == (unsigned long )((void *)0)) {
#line 458
    return (0L);
  }
  {
#line 459
  ret = DumpMacFont(res, macfont);
#line 460
  FreeMacFont(macfont);
  }
#line 461
  return (ret);
}
}
#line 830 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ferror)(FILE *__stream ) ;
#line 534 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcasecmp)(char const   *__s1 ,
                                                                                                   char const   *__s2 )  __attribute__((__pure__)) ;
#line 127 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 826 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 136 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.h"
int TTFGetNames(Face *face ) ;
#line 137
long TTFToResource(FILE *res , Face *face ) ;
#line 70 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
void putshort(int val , FILE *f ) 
{ 


  {
  {
#line 71
  _IO_putc(val >> 8, f);
#line 72
  _IO_putc(val & 255, f);
  }
#line 73
  return;
}
}
#line 75 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
void putlong(long val , FILE *f ) 
{ 


  {
  {
#line 76
  _IO_putc((int )((val >> 24) & 255L), f);
#line 77
  _IO_putc((int )((val >> 16) & 255L), f);
#line 78
  _IO_putc((int )((val >> 8) & 255L), f);
#line 79
  _IO_putc((int )(val & 255L), f);
  }
#line 80
  return;
}
}
#line 82 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
enum output_format output_format  =    (enum output_format )1;
#line 83 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static int script  =    0;
#line 85 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static uint16 HashToId(char *fontname ) 
{ 
  int low ;
  int high ;
  uint32 hash ;
  int temp ;
  char *tmp ;

  {
#line 86
  low = 128;
#line 86
  high = 16384;
#line 87
  hash = (uint32 )0;
#line 89
  if (script != 0) {
#line 90
    low = 16384 + (script - 1) * 512;
#line 91
    high = low + 512;
  }
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! *fontname) {
#line 93
      goto while_break;
    }
#line 94
    temp = (int )((hash >> 28) & 15U);
#line 95
    hash = (hash << 4) | (unsigned int )temp;
#line 96
    tmp = fontname;
#line 96
    fontname ++;
#line 96
    hash ^= (unsigned int )((int )*tmp - 32);
  }
  while_break: /* CIL Label */ ;
  }
#line 98
  hash %= (unsigned int )(high - low);
#line 99
  hash += (uint32 )low;
#line 100
  return ((uint16 )hash);
}
}
#line 103 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static void Usage___0(char *prog ) 
{ 


  {
  {
#line 104
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-dfont] [-macbin] [-res] [-script name] fontfile {fontfiles}\n",
          prog);
#line 105
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -dfont\t\tPuts the output into a Mac OS/X dfont file.\n");
#line 106
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -macbin\tPuts the output into a resource fork inside a mac binary file.\n");
#line 107
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -res\tPuts the output into a data file containing a resource fork\n\t\t(you have to figure out how to get it into a real resource fork)");
#line 108
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -script [name|code]\tThe name should be the name of a mac script\n\t\tlike Roman or Cyrillic (not all names are recognized)\n\t\tthe code can be a number representing a script\n");
#line 109
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A list of bdf/ttf files all with the same family name will be merged into\n");
#line 110
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"one FOND and all stored in one output files. Any pfb files will be refered\n");
#line 111
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"to in the FOND but will live in a separate file.\n");
#line 112
  exit(1);
  }
}
}
#line 115 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static Face *ParseArgs(int argc , char **argv ) 
{ 
  Face *head ;
  Face *last ;
  Face *cur ;
  int i ;
  int bad ;
  int val ;
  char *pt ;
  char *end___0 ;
  char *pt___0 ;
  int bad___0 ;
  long tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  void *tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;

  {
#line 116
  head = (Face *)((void *)0);
#line 116
  last = (Face *)((void *)0);
#line 120
  i = 1;
  {
#line 120
  while (1) {
    while_continue: /* CIL Label */ ;
#line 120
    if (! (i < argc)) {
#line 120
      goto while_break;
    }
#line 121
    if ((int )*(*(argv + i)) == 45) {
#line 122
      pt___0 = *(argv + i) + 1;
#line 123
      if ((int )*pt___0 == 45) {
#line 123
        pt___0 ++;
      }
      {
#line 124
      tmp___19 = strcmp((char const   *)pt___0, "dfont");
      }
#line 124
      if (tmp___19 == 0) {
#line 125
        output_format = (enum output_format )0;
      } else {
        {
#line 126
        tmp___17 = strcmp((char const   *)pt___0, "bin");
        }
#line 126
        if (tmp___17 == 0) {
#line 127
          output_format = (enum output_format )1;
        } else {
          {
#line 126
          tmp___18 = strcmp((char const   *)pt___0, "macbin");
          }
#line 126
          if (tmp___18 == 0) {
#line 127
            output_format = (enum output_format )1;
          } else {
            {
#line 128
            tmp___15 = strcmp((char const   *)pt___0, "res");
            }
#line 128
            if (tmp___15 == 0) {
#line 129
              output_format = (enum output_format )2;
            } else {
              {
#line 128
              tmp___16 = strcmp((char const   *)pt___0, "resource");
              }
#line 128
              if (tmp___16 == 0) {
#line 129
                output_format = (enum output_format )2;
              } else {
                {
#line 130
                tmp___14 = strcmp((char const   *)pt___0, "script");
                }
#line 130
                if (tmp___14 == 0) {
#line 131
                  bad___0 = 0;
#line 132
                  i ++;
#line 132
                  if (i >= argc) {
#line 133
                    bad___0 = 1;
                  } else {
                    {
#line 134
                    tmp___13 = strcasecmp((char const   *)*(argv + i), "roman");
                    }
#line 134
                    if (tmp___13 == 0) {
#line 135
                      script = 0;
                    } else {
                      {
#line 136
                      tmp___12 = strcasecmp((char const   *)*(argv + i), "japanese");
                      }
#line 136
                      if (tmp___12 == 0) {
#line 137
                        script = 1;
                      } else {
                        {
#line 138
                        tmp___8 = strcasecmp((char const   *)*(argv + i), "traditionalchinese");
                        }
#line 138
                        if (tmp___8 == 0) {
#line 142
                          script = 2;
                        } else {
                          {
#line 138
                          tmp___9 = strcasecmp((char const   *)*(argv + i), "tradchinese");
                          }
#line 138
                          if (tmp___9 == 0) {
#line 142
                            script = 2;
                          } else {
                            {
#line 138
                            tmp___10 = strcasecmp((char const   *)*(argv + i), "big5");
                            }
#line 138
                            if (tmp___10 == 0) {
#line 142
                              script = 2;
                            } else {
                              {
#line 138
                              tmp___11 = strcasecmp((char const   *)*(argv + i), "taiwan");
                              }
#line 138
                              if (tmp___11 == 0) {
#line 142
                                script = 2;
                              } else {
                                {
#line 143
                                tmp___6 = strcasecmp((char const   *)*(argv + i),
                                                     "simplifiedchinese");
                                }
#line 143
                                if (tmp___6 == 0) {
#line 145
                                  script = 25;
                                } else {
                                  {
#line 143
                                  tmp___7 = strcasecmp((char const   *)*(argv + i),
                                                       "simpchinese");
                                  }
#line 143
                                  if (tmp___7 == 0) {
#line 145
                                    script = 25;
                                  } else {
                                    {
#line 146
                                    tmp___5 = strcasecmp((char const   *)*(argv + i),
                                                         "korean");
                                    }
#line 146
                                    if (tmp___5 == 0) {
#line 147
                                      script = 3;
                                    } else {
                                      {
#line 148
                                      tmp___4 = strcasecmp((char const   *)*(argv + i),
                                                           "arabic");
                                      }
#line 148
                                      if (tmp___4 == 0) {
#line 149
                                        script = 4;
                                      } else {
                                        {
#line 150
                                        tmp___3 = strcasecmp((char const   *)*(argv + i),
                                                             "hebrew");
                                        }
#line 150
                                        if (tmp___3 == 0) {
#line 151
                                          script = 5;
                                        } else {
                                          {
#line 152
                                          tmp___2 = strcasecmp((char const   *)*(argv + i),
                                                               "greek");
                                          }
#line 152
                                          if (tmp___2 == 0) {
#line 153
                                            script = 6;
                                          } else {
                                            {
#line 154
                                            tmp___0 = strcasecmp((char const   *)*(argv + i),
                                                                 "cyrillic");
                                            }
#line 154
                                            if (tmp___0 == 0) {
#line 156
                                              script = 7;
                                            } else {
                                              {
#line 154
                                              tmp___1 = strcasecmp((char const   *)*(argv + i),
                                                                   "russian");
                                              }
#line 154
                                              if (tmp___1 == 0) {
#line 156
                                                script = 7;
                                              } else {
                                                {
#line 157
                                                tmp = strtol((char const   */* __restrict  */)*(argv + i),
                                                             (char **/* __restrict  */)(& end___0),
                                                             10);
#line 157
                                                val = (int )tmp;
                                                }
#line 157
                                                if ((int )*end___0 != 0) {
#line 158
                                                  bad___0 = 1;
                                                } else
#line 157
                                                if (val < 0) {
#line 158
                                                  bad___0 = 1;
                                                } else
#line 157
                                                if (val > 128) {
#line 158
                                                  bad___0 = 1;
                                                } else {
#line 160
                                                  script = val;
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
#line 161
                  if (bad___0) {
                    {
#line 162
                    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The script argument must be followed by a script name or number\n(Roman=0, Japanese=1, Big5=2, Korean=3, Arabic=4, Hebrew=5, Greek=6, Cyrillic=7)\n");
#line 163
                    exit(1);
                    }
                  }
                } else {
                  {
#line 166
                  Usage___0(*(argv + 0));
                  }
                }
              }
            }
          }
        }
      }
    } else {
      {
#line 168
      tmp___20 = calloc((size_t )1, sizeof(Face ));
#line 168
      cur = (Face *)tmp___20;
#line 169
      cur->filename = *(argv + i);
#line 170
      pt = strrchr((char const   *)*(argv + i), '.');
#line 171
      cur->type = (enum face_type )-1;
#line 172
      bad = 0;
      }
#line 173
      if (! ((unsigned long )pt == (unsigned long )((void *)0))) {
        {
#line 175
        tmp___30 = strcasecmp((char const   *)pt, ".bdf");
        }
#line 175
        if (tmp___30 == 0) {
          {
#line 176
          cur->type = (enum face_type )0;
#line 177
          tmp___21 = BDFGetNames(cur);
          }
#line 177
          if (tmp___21) {
#line 177
            tmp___22 = 0;
          } else {
#line 177
            tmp___22 = 1;
          }
#line 177
          bad = tmp___22;
        } else {
          {
#line 178
          tmp___28 = strcasecmp((char const   *)pt, ".ttf");
          }
#line 178
          if (tmp___28 == 0) {
#line 178
            goto _L;
          } else {
            {
#line 178
            tmp___29 = strcasecmp((char const   *)pt, ".otf");
            }
#line 178
            if (tmp___29 == 0) {
              _L: /* CIL Label */ 
              {
#line 179
              cur->type = (enum face_type )2;
#line 180
              tmp___23 = TTFGetNames(cur);
              }
#line 180
              if (tmp___23) {
#line 180
                tmp___24 = 0;
              } else {
#line 180
                tmp___24 = 1;
              }
#line 180
              bad = tmp___24;
            } else {
              {
#line 181
              tmp___27 = strcasecmp((char const   *)pt, ".pfb");
              }
#line 181
              if (tmp___27 == 0) {
                {
#line 182
                cur->type = (enum face_type )1;
#line 183
                tmp___25 = PSGetNames(cur);
                }
#line 183
                if (tmp___25) {
#line 183
                  tmp___26 = 0;
                } else {
#line 183
                  tmp___26 = 1;
                }
#line 183
                bad = tmp___26;
              }
            }
          }
        }
      }
#line 187
      if ((unsigned int )cur->type == 4294967295U) {
        {
#line 188
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Unknown file type for %s\n Must be one of .bdf, .pfb, .ttf or .otf\n",
                *(argv + i));
#line 189
        Usage___0(*(argv + 0));
        }
      } else
#line 190
      if (bad) {
        {
#line 191
        Usage___0(*(argv + 0));
        }
      }
#line 192
      if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 193
        head = cur;
      } else {
#line 195
        last->next = cur;
      }
#line 196
      last = cur;
    }
#line 120
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 199
  if ((unsigned long )head == (unsigned long )((void *)0)) {
    {
#line 200
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No files\n");
#line 201
    Usage___0(*(argv + 0));
    }
  }
#line 203
  return (head);
}
}
#line 206 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static Family *SortByFamily(Face *faces ) 
{ 
  Family *head ;
  Family *last ;
  Family *cur ;
  Face *next ;
  int index___0 ;
  int i ;
  int cnt ;
  int one ;
  int tmp ;
  int tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  Face *tmp___3 ;
  Face *tmp___4 ;
  uint16 tmp___5 ;

  {
#line 207
  head = (Family *)((void *)0);
#line 207
  last = (Family *)((void *)0);
  {
#line 212
  while (1) {
    while_continue: /* CIL Label */ ;
#line 212
    if (! ((unsigned long )faces != (unsigned long )((void *)0))) {
#line 212
      goto while_break;
    }
#line 213
    next = faces->next;
#line 217
    if ((int )faces->style < 48) {
#line 218
      cur = head;
      {
#line 218
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 218
        if ((unsigned long )cur != (unsigned long )((void *)0)) {
          {
#line 218
          tmp = strcmp((char const   *)cur->familyname, (char const   *)faces->family);
          }
#line 218
          if (! (tmp != 0)) {
#line 218
            goto while_break___0;
          }
        } else {
#line 218
          goto while_break___0;
        }
#line 218
        cur = cur->next;
      }
      while_break___0: /* CIL Label */ ;
      }
    } else {
#line 220
      cur = head;
      {
#line 220
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 220
        if ((unsigned long )cur != (unsigned long )((void *)0)) {
          {
#line 220
          tmp___0 = strcmp((char const   *)cur->familyname, (char const   *)faces->fontname);
          }
#line 220
          if (! (tmp___0 != 0)) {
#line 220
            goto while_break___1;
          }
        } else {
#line 220
          goto while_break___1;
        }
#line 220
        cur = cur->next;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 221
    if ((unsigned long )cur == (unsigned long )((void *)0)) {
      {
#line 222
      tmp___1 = calloc((size_t )1, sizeof(Family ));
#line 222
      cur = (Family *)tmp___1;
      }
#line 223
      if ((unsigned long )head == (unsigned long )((void *)0)) {
#line 224
        head = cur;
      } else {
#line 226
        last->next = cur;
      }
#line 227
      last = cur;
#line 228
      if ((int )faces->style < 48) {
#line 228
        cur->familyname = faces->family;
      } else {
#line 228
        cur->familyname = faces->fontname;
      }
    }
#line 230
    if ((unsigned int )faces->type != 1U) {
#line 230
      cur->fixed = faces->fixed;
    }
#line 231
    index___0 = (int )faces->style;
#line 232
    if (index___0 >= 96) {
      {
#line 233
      index___0 = 0;
#line 234
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has a style which doesn\'t fit in a normal FOND, so we\'re\ngiving it its own FOND where it can pretend to be plain\n",
              faces->filename);
      }
    }
#line 236
    if ((unsigned int )faces->type == 0U) {
#line 237
      faces->next = cur->faces[index___0];
#line 238
      cur->faces[index___0] = faces;
    } else
#line 239
    if ((unsigned int )faces->type == 2U) {
#line 240
      if ((unsigned long )cur->ttffaces[index___0] != (unsigned long )((void *)0)) {
        {
#line 241
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to add two scalable fonts for the same style in a FOND\n%s and %s\n",
                faces->filename, (cur->ttffaces[index___0])->filename);
        }
      }
#line 242
      cur->ttffaces[index___0] = faces;
#line 243
      faces->next = (struct face *)((void *)0);
    } else {
#line 245
      index___0 = (int )faces->psstyle;
#line 246
      if (index___0 >= 48) {
        {
#line 247
        index___0 = 0;
#line 248
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has a style which doesn\'t fit in a normal FOND, so we\'re\ngiving it its own FOND where it can pretend to be plain\n",
                faces->filename);
        }
      }
#line 250
      if ((unsigned long )cur->psfaces[index___0] != (unsigned long )((void *)0)) {
        {
#line 251
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Attempt to add two postscript fonts for the same style in a FOND\n%s and %s\n",
                faces->filename, (cur->psfaces[index___0])->filename);
        }
      }
#line 252
      cur->psfaces[index___0] = faces;
#line 253
      faces->next = (struct face *)((void *)0);
    }
#line 212
    faces = next;
  }
  while_break: /* CIL Label */ ;
  }
#line 257
  cur = head;
  {
#line 257
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 257
    if (! ((unsigned long )cur != (unsigned long )((void *)0))) {
#line 257
      goto while_break___2;
    }
#line 258
    i = 0;
    {
#line 258
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 258
      if (! (i < 48)) {
#line 258
        goto while_break___3;
      }
#line 260
      if ((unsigned long )cur->psfaces[i] != (unsigned long )((void *)0)) {
#line 260
        if ((unsigned long )cur->faces[(cur->psfaces[i])->style] == (unsigned long )((void *)0)) {
          {
#line 261
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"A postscript font was found without a bitmap font of the same style\n %s\n",
                  (cur->psfaces[i])->filename);
#line 262
          exit(1);
          }
        }
      }
#line 258
      i ++;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 265
    cnt = 0;
#line 265
    i = cnt;
    {
#line 265
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 265
      if (! (i < 96)) {
#line 265
        goto while_break___4;
      }
#line 266
      if ((unsigned long )cur->faces[i] != (unsigned long )((void *)0)) {
#line 267
        one = i;
#line 268
        cnt ++;
      } else
#line 266
      if ((unsigned long )cur->ttffaces[i] != (unsigned long )((void *)0)) {
#line 267
        one = i;
#line 268
        cnt ++;
      }
#line 265
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 270
    if (one != 0) {
#line 270
      if (cnt == 1) {
#line 271
        if ((unsigned long )cur->faces[one] != (unsigned long )((void *)0)) {
#line 271
          tmp___2 = (cur->faces[one])->filename;
        } else {
#line 271
          tmp___2 = (cur->ttffaces[one])->filename;
        }
        {
#line 271
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not have a corresponding plain style font.\nWe will claim it is plain when we build the FOND\n",
                tmp___2);
#line 274
        cur->faces[0] = cur->faces[one];
#line 275
        cur->ttffaces[0] = cur->ttffaces[one];
#line 276
        cur->psfaces[0] = cur->psfaces[one];
#line 277
        tmp___4 = (Face *)((void *)0);
#line 277
        cur->psfaces[one] = tmp___4;
#line 277
        tmp___3 = tmp___4;
#line 277
        cur->ttffaces[one] = tmp___3;
#line 277
        cur->faces[one] = tmp___3;
        }
#line 278
        if ((unsigned long )cur->faces[one] != (unsigned long )((void *)0)) {
#line 278
          cur->familyname = (cur->faces[one])->fontname;
        } else {
#line 278
          cur->familyname = (cur->ttffaces[one])->fontname;
        }
      } else {
#line 270
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 280
    if ((unsigned long )cur->faces[0] == (unsigned long )((void *)0)) {
#line 280
      if ((unsigned long )cur->ttffaces[0] == (unsigned long )((void *)0)) {
        {
#line 281
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The family, %s, does not have a plain style. That would lead to\nconfusion, so I\'m giving up.\n",
                cur->familyname);
#line 282
        exit(1);
        }
      }
    }
    {
#line 284
    tmp___5 = HashToId(cur->familyname);
#line 284
    cur->id = (int )tmp___5;
#line 257
    cur = cur->next;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
#line 286
  return (head);
}
}
#line 289 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static void putpsstring(FILE *res , char *fontname ) 
{ 
  size_t tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;

  {
  {
#line 290
  tmp = strlen((char const   *)fontname);
#line 290
  _IO_putc((int )tmp, res);
  }
#line 291
  if (*fontname) {
    {
#line 292
    tmp___1 = __ctype_b_loc();
    }
#line 292
    if ((int const   )*(*tmp___1 + (int )*fontname) & 512) {
      {
#line 293
      tmp___0 = toupper((int )*fontname);
#line 293
      _IO_putc(tmp___0, res);
      }
    } else {
      {
#line 295
      _IO_putc((int )*fontname, res);
      }
    }
#line 296
    fontname ++;
    {
#line 296
    while (1) {
      while_continue: /* CIL Label */ ;
#line 296
      if (! *fontname) {
#line 296
        goto while_break;
      }
      {
#line 297
      _IO_putc((int )*fontname, res);
#line 296
      fontname ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 299
  return;
}
}
#line 301 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static uint32 FamilyToFOND(FILE *res , Family *fam ) 
{ 
  uint32 rlenpos ;
  long tmp ;
  uint32 widoffpos ;
  uint32 widoffloc ;
  uint32 kernloc ;
  uint32 styleloc ;
  uint32 glyphloc ;
  uint32 end___0 ;
  int i ;
  int j ;
  int cnt ;
  int scnt ;
  int strcnt ;
  int pscnt ;
  int maxw ;
  int size ;
  Face *face ;
  Face *test ;
  int exact ;
  int badmatch ;
  int tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  char *family ;
  char const   *tmp___8 ;
  int fontclass ;
  long tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  size_t tmp___14 ;
  int tmp___15 ;
  long tmp___16 ;
  long tmp___17 ;
  uint32 tmp___18 ;
  uint32 tmp___19 ;

  {
  {
#line 302
  tmp = ftell(res);
#line 302
  rlenpos = (uint32 )tmp;
#line 310
  face = fam->ttffaces[0];
  }
#line 311
  if ((unsigned long )face == (unsigned long )((void *)0)) {
#line 312
    face = fam->faces[0];
#line 313
    test = face;
    {
#line 313
    while (1) {
      while_continue: /* CIL Label */ ;
#line 313
      if (! ((unsigned long )test != (unsigned long )((void *)0))) {
#line 313
        goto while_break;
      }
#line 314
      if (test->size > face->size) {
#line 314
        face = test;
      }
#line 313
      test = test->next;
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 316
  maxw = 0;
#line 317
  i = 0;
  {
#line 317
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 317
    if (! (i < 256)) {
#line 317
      goto while_break___0;
    }
#line 318
    if ((int )face->metrics[i] > maxw) {
#line 318
      maxw = (int )face->metrics[i];
    }
#line 317
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 320
  putlong(0L, res);
  }
#line 321
  if (fam->fixed) {
#line 321
    tmp___0 = 36864;
  } else {
#line 321
    tmp___0 = 4096;
  }
  {
#line 321
  putshort(tmp___0, res);
#line 322
  putshort(fam->id, res);
#line 323
  putshort(0, res);
#line 324
  putshort(255, res);
#line 325
  putshort((int )((short )((face->ascent * (1 << 12)) / (face->ascent + face->descent))),
           res);
#line 326
  putshort(- ((int )((short )((face->descent * (1 << 12)) / (face->ascent + face->descent)))),
           res);
#line 327
  putshort((int )((short )((face->linegap * (1 << 12)) / (face->ascent + face->descent))),
           res);
#line 328
  putshort((int )((short )maxw), res);
#line 329
  tmp___1 = ftell(res);
#line 329
  widoffpos = (uint32 )tmp___1;
#line 330
  putlong(0L, res);
#line 331
  putlong(0L, res);
#line 332
  putlong(0L, res);
#line 333
  i = 0;
  }
  {
#line 333
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 333
    if (! (i < 9)) {
#line 333
      goto while_break___1;
    }
    {
#line 334
    putshort(0, res);
#line 333
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 335
  putlong(0L, res);
#line 336
  putshort(2, res);
#line 339
  scnt = 0;
#line 339
  cnt = scnt;
#line 339
  i = cnt;
  }
  {
#line 339
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 339
    if (! (i < 96)) {
#line 339
      goto while_break___2;
    }
#line 340
    face = fam->faces[i];
    {
#line 340
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 340
      if (! ((unsigned long )face != (unsigned long )((void *)0))) {
#line 340
        goto while_break___3;
      }
#line 341
      cnt ++;
#line 340
      face = face->next;
    }
    while_break___3: /* CIL Label */ ;
    }
#line 342
    if (fam->ttffaces[i]) {
#line 343
      cnt ++;
    }
#line 344
    if ((unsigned long )fam->faces[i] != (unsigned long )((void *)0)) {
#line 345
      scnt ++;
    } else
#line 344
    if ((unsigned long )fam->ttffaces[i] != (unsigned long )((void *)0)) {
#line 345
      scnt ++;
    }
#line 339
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 347
  putshort(cnt - 1, res);
#line 349
  cnt = 0;
#line 349
  i = cnt;
  }
  {
#line 349
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 349
    if (! (i < 96)) {
#line 349
      goto while_break___4;
    }
#line 349
    if ((unsigned long )fam->ttffaces[i] != (unsigned long )((void *)0)) {
      {
#line 350
      putshort(0, res);
#line 351
      putshort(i, res);
#line 352
      tmp___2 = cnt;
#line 352
      cnt ++;
#line 352
      (fam->ttffaces[i])->id = fam->id + tmp___2;
#line 353
      putshort((fam->ttffaces[i])->id, res);
      }
    }
#line 349
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 355
  i = 0;
  {
#line 355
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 355
    if (! (i < 96)) {
#line 355
      goto while_break___5;
    }
#line 356
    face = fam->faces[i];
    {
#line 356
    while (1) {
      while_continue___6: /* CIL Label */ ;
#line 356
      if (! ((unsigned long )face != (unsigned long )((void *)0))) {
#line 356
        goto while_break___6;
      }
#line 357
      tmp___3 = cnt;
#line 357
      cnt ++;
#line 357
      face->id = fam->id + tmp___3;
#line 356
      face = face->next;
    }
    while_break___6: /* CIL Label */ ;
    }
#line 355
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 358
  size = 1;
  {
#line 358
  while (1) {
    while_continue___7: /* CIL Label */ ;
#line 358
    if (! (size < 256)) {
#line 358
      goto while_break___7;
    }
#line 359
    i = 0;
    {
#line 359
    while (1) {
      while_continue___8: /* CIL Label */ ;
#line 359
      if (! (i < 96)) {
#line 359
        goto while_break___8;
      }
#line 360
      face = fam->faces[i];
      {
#line 360
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 360
        if (! ((unsigned long )face != (unsigned long )((void *)0))) {
#line 360
          goto while_break___9;
        }
#line 360
        if (face->size == size) {
          {
#line 361
          putshort(face->size, res);
#line 362
          putshort(i, res);
#line 363
          putshort(face->id, res);
          }
        }
#line 360
        face = face->next;
      }
      while_break___9: /* CIL Label */ ;
      }
#line 359
      i ++;
    }
    while_break___8: /* CIL Label */ ;
    }
#line 358
    size ++;
  }
  while_break___7: /* CIL Label */ ;
  }
  {
#line 369
  putshort(0, res);
#line 370
  putlong(6L, res);
#line 373
  putshort(scnt - 1, res);
#line 374
  i = 0;
  }
  {
#line 374
  while (1) {
    while_continue___10: /* CIL Label */ ;
#line 374
    if (! (i < 96)) {
#line 374
      goto while_break___10;
    }
#line 374
    if ((unsigned long )fam->faces[i] != (unsigned long )((void *)0)) {
#line 374
      goto _L;
    } else
#line 374
    if ((unsigned long )fam->ttffaces[i] != (unsigned long )((void *)0)) {
      _L: /* CIL Label */ 
#line 377
      face = fam->ttffaces[i];
#line 378
      if ((unsigned long )face == (unsigned long )((void *)0)) {
#line 379
        face = fam->faces[i];
#line 380
        test = face;
        {
#line 380
        while (1) {
          while_continue___11: /* CIL Label */ ;
#line 380
          if (! ((unsigned long )test != (unsigned long )((void *)0))) {
#line 380
            goto while_break___11;
          }
#line 381
          if (test->size > face->size) {
#line 381
            face = test;
          }
#line 380
          test = test->next;
        }
        while_break___11: /* CIL Label */ ;
        }
      }
      {
#line 383
      putshort(i, res);
#line 384
      putshort(face->xmin, res);
#line 385
      putshort(face->ymin, res);
#line 386
      putshort(face->xmax, res);
#line 387
      putshort(face->ymax, res);
      }
    }
#line 374
    i ++;
  }
  while_break___10: /* CIL Label */ ;
  }
  {
#line 390
  tmp___4 = ftell(res);
#line 390
  widoffloc = (uint32 )tmp___4;
#line 391
  putshort(scnt - 1, res);
#line 392
  i = 0;
  }
  {
#line 392
  while (1) {
    while_continue___12: /* CIL Label */ ;
#line 392
    if (! (i < 96)) {
#line 392
      goto while_break___12;
    }
#line 392
    if ((unsigned long )fam->faces[i] != (unsigned long )((void *)0)) {
#line 392
      goto _L___0;
    } else
#line 392
    if ((unsigned long )fam->ttffaces[i] != (unsigned long )((void *)0)) {
      _L___0: /* CIL Label */ 
#line 393
      face = fam->ttffaces[i];
#line 394
      if ((unsigned long )face == (unsigned long )((void *)0)) {
#line 395
        face = fam->faces[i];
#line 396
        test = face;
        {
#line 396
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 396
          if (! ((unsigned long )test != (unsigned long )((void *)0))) {
#line 396
            goto while_break___13;
          }
#line 397
          if (test->size > face->size) {
#line 397
            face = test;
          }
#line 396
          test = test->next;
        }
        while_break___13: /* CIL Label */ ;
        }
      }
      {
#line 399
      putshort(i, res);
#line 400
      j = 0;
      }
      {
#line 400
      while (1) {
        while_continue___14: /* CIL Label */ ;
#line 400
        if (! (j < 256)) {
#line 400
          goto while_break___14;
        }
        {
#line 401
        putshort((int )face->metrics[j], res);
#line 400
        j ++;
        }
      }
      while_break___14: /* CIL Label */ ;
      }
      {
#line 402
      putshort(1 << 12, res);
#line 403
      putshort(1 << 12, res);
      }
    }
#line 392
    i ++;
  }
  while_break___12: /* CIL Label */ ;
  }
#line 406
  kernloc = (uint32 )0;
#line 408
  badmatch = 0;
#line 408
  exact = badmatch;
#line 409
  pscnt = 0;
#line 409
  i = pscnt;
  {
#line 409
  while (1) {
    while_continue___15: /* CIL Label */ ;
#line 409
    if (! (i < 48)) {
#line 409
      goto while_break___15;
    }
#line 409
    if ((unsigned long )fam->psfaces[i] != (unsigned long )((void *)0)) {
      {
#line 410
      pscnt ++;
#line 411
      tmp___5 = strcmp((char const   *)fam->familyname, (char const   *)(fam->psfaces[i])->fontname);
      }
#line 411
      if (tmp___5 == 0) {
#line 412
        exact = 1;
      }
      {
#line 413
      tmp___6 = strlen((char const   *)fam->familyname);
#line 413
      tmp___7 = strncmp((char const   *)(fam->psfaces[i])->fontname, (char const   *)fam->familyname,
                        tmp___6);
      }
#line 413
      if (tmp___7 != 0) {
#line 414
        badmatch = 1;
      }
    }
#line 409
    i ++;
  }
  while_break___15: /* CIL Label */ ;
  }
#line 416
  styleloc = (uint32 )0;
#line 417
  if (pscnt != 0) {
#line 418
    if (badmatch) {
#line 418
      tmp___8 = "";
    } else {
#line 418
      tmp___8 = (char const   *)fam->familyname;
    }
#line 418
    family = (char *)tmp___8;
#line 420
    if (badmatch) {
#line 420
      exact = 0;
    }
    {
#line 421
    tmp___9 = ftell(res);
#line 421
    styleloc = (uint32 )tmp___9;
#line 422
    fontclass = 1;
    }
#line 423
    if ((unsigned long )fam->psfaces[4] == (unsigned long )((void *)0)) {
#line 423
      fontclass |= 4;
    }
#line 424
    if ((unsigned long )fam->psfaces[1] != (unsigned long )((void *)0)) {
#line 424
      fontclass |= 24;
    }
#line 425
    if ((unsigned long )fam->psfaces[2] != (unsigned long )((void *)0)) {
#line 425
      fontclass |= 64;
    }
#line 426
    if ((unsigned long )fam->psfaces[16] != (unsigned long )((void *)0)) {
#line 426
      fontclass |= 128;
    }
#line 427
    if ((unsigned long )fam->psfaces[32] != (unsigned long )((void *)0)) {
#line 427
      fontclass |= 256;
    }
    {
#line 428
    putshort(fontclass, res);
#line 429
    putlong(0L, res);
#line 430
    putlong(0L, res);
#line 431
    strcnt = (((1 + pscnt) - exact) + pscnt) - exact;
#line 434
    i = 0;
#line 434
    pscnt = 2;
    }
    {
#line 434
    while (1) {
      while_continue___16: /* CIL Label */ ;
#line 434
      if (! (i < 48)) {
#line 434
        goto while_break___16;
      }
#line 435
      if ((unsigned long )fam->psfaces[i] == (unsigned long )((void *)0)) {
        {
#line 436
        _IO_putc(1, res);
        }
      } else {
        {
#line 435
        tmp___11 = strcmp((char const   *)family, (char const   *)(fam->psfaces[i])->fontname);
        }
#line 435
        if (tmp___11 == 0) {
          {
#line 436
          _IO_putc(1, res);
          }
        } else {
          {
#line 438
          tmp___10 = pscnt;
#line 438
          pscnt ++;
#line 438
          _IO_putc(tmp___10, res);
          }
        }
      }
#line 434
      i ++;
    }
    while_break___16: /* CIL Label */ ;
    }
    {
#line 439
    putshort(strcnt, res);
#line 440
    putpsstring(res, family);
#line 442
    i = 0;
    }
    {
#line 442
    while (1) {
      while_continue___17: /* CIL Label */ ;
#line 442
      if (! (i < 48)) {
#line 442
        goto while_break___17;
      }
#line 442
      if ((unsigned long )fam->psfaces[i] != (unsigned long )((void *)0)) {
        {
#line 443
        tmp___13 = strcmp((char const   *)family, (char const   *)(fam->psfaces[i])->fontname);
        }
#line 443
        if (tmp___13 != 0) {
          {
#line 444
          _IO_putc(1, res);
#line 445
          tmp___12 = pscnt;
#line 445
          pscnt ++;
#line 445
          _IO_putc(tmp___12, res);
          }
        }
      }
#line 442
      i ++;
    }
    while_break___17: /* CIL Label */ ;
    }
#line 449
    i = 0;
    {
#line 449
    while (1) {
      while_continue___18: /* CIL Label */ ;
#line 449
      if (! (i < 48)) {
#line 449
        goto while_break___18;
      }
#line 449
      if ((unsigned long )fam->psfaces[i] != (unsigned long )((void *)0)) {
        {
#line 450
        tmp___15 = strcmp((char const   *)family, (char const   *)(fam->psfaces[i])->fontname);
        }
#line 450
        if (tmp___15 != 0) {
          {
#line 451
          tmp___14 = strlen((char const   *)family);
#line 451
          putpsstring(res, (fam->psfaces[i])->fontname + tmp___14);
          }
        }
      }
#line 449
      i ++;
    }
    while_break___18: /* CIL Label */ ;
    }
    {
#line 456
    tmp___16 = ftell(res);
#line 456
    glyphloc = (uint32 )tmp___16;
#line 457
    putshort(0, res);
    }
  }
  {
#line 460
  tmp___17 = ftell(res);
#line 460
  end___0 = (uint32 )tmp___17;
#line 461
  fseek(res, (long )widoffpos, 0);
#line 462
  putlong((long )((widoffloc - rlenpos) - 4U), res);
  }
#line 463
  if (kernloc != 0U) {
#line 463
    tmp___18 = (kernloc - rlenpos) - 4U;
  } else {
#line 463
    tmp___18 = (uint32 )0;
  }
  {
#line 463
  putlong((long )tmp___18, res);
  }
#line 464
  if (styleloc != 0U) {
#line 464
    tmp___19 = (styleloc - rlenpos) - 4U;
  } else {
#line 464
    tmp___19 = (uint32 )0;
  }
  {
#line 464
  putlong((long )tmp___19, res);
  }
#line 467
  if (styleloc) {
#line 467
    if (glyphloc) {
      {
#line 468
      fseek(res, (long )(styleloc + 2U), 0);
#line 469
      putlong((long )(glyphloc - styleloc), res);
      }
    }
  }
  {
#line 472
  fseek(res, (long )rlenpos, 0);
#line 473
  putlong((long )((end___0 - rlenpos) - 4U), res);
#line 474
  fseek(res, (long )end___0, 0);
  }
#line 475
  return (rlenpos);
}
}
#line 479 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static void DumpResourceMap___0(FILE *res , struct resourcetype *rtypes ) 
{ 
  uint32 rfork_base ;
  int tmp ;
  uint32 resource_base ;
  uint32 rend ;
  uint32 rtypesstart ;
  uint32 mend ;
  uint32 namestart ;
  int i ;
  int j ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  long tmp___3 ;
  long tmp___4 ;
  long tmp___5 ;
  long tmp___6 ;
  size_t tmp___7 ;
  size_t tmp___8 ;
  long tmp___9 ;
  long tmp___10 ;

  {
#line 480
  if ((unsigned int )output_format != 1U) {
#line 480
    tmp = 0;
  } else {
#line 480
    tmp = 128;
  }
  {
#line 480
  rfork_base = (uint32 )tmp;
#line 481
  resource_base = rfork_base + 256U;
#line 485
  fseek(res, 0L, 2);
#line 486
  tmp___0 = ftell(res);
#line 486
  rend = (uint32 )tmp___0;
  }
#line 488
  if ((unsigned int )output_format != 0U) {
    {
#line 490
    putlong(256L, res);
#line 491
    putlong((long )(rend - rfork_base), res);
#line 492
    putlong((long )((rend - rfork_base) - 256U), res);
#line 493
    putlong(0L, res);
    }
  } else {
#line 495
    i = 0;
    {
#line 495
    while (1) {
      while_continue: /* CIL Label */ ;
#line 495
      if (! (i < 16)) {
#line 495
        goto while_break;
      }
      {
#line 496
      _IO_putc(0, res);
#line 495
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 499
  putlong(0L, res);
#line 500
  putshort(0, res);
#line 501
  putshort(0, res);
#line 503
  tmp___1 = ftell(res);
#line 503
  putshort((int )((4L + tmp___1) - (long )rend), res);
#line 504
  putshort(0, res);
#line 506
  tmp___2 = ftell(res);
#line 506
  rtypesstart = (uint32 )tmp___2;
#line 507
  i = 0;
  }
  {
#line 507
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 507
    if (! ((rtypes + i)->tag != 0U)) {
#line 507
      goto while_break___0;
    }
#line 507
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 508
  putshort(i - 1, res);
#line 509
  i = 0;
  }
  {
#line 509
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 509
    if (! ((rtypes + i)->tag != 0U)) {
#line 509
      goto while_break___1;
    }
    {
#line 510
    putlong((long )(rtypes + i)->tag, res);
#line 511
    putshort(0, res);
#line 512
    putshort(0, res);
#line 509
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 516
  i = 0;
  {
#line 516
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 516
    if (! ((rtypes + i)->tag != 0U)) {
#line 516
      goto while_break___2;
    }
    {
#line 517
    tmp___3 = ftell(res);
#line 517
    (rtypes + i)->resloc = (uint32 )tmp___3;
#line 518
    j = 0;
    }
    {
#line 518
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 518
      if (! (((rtypes + i)->res + j)->pos != 0U)) {
#line 518
        goto while_break___3;
      }
      {
#line 519
      putshort((int )((rtypes + i)->res + j)->id, res);
#line 520
      tmp___4 = ftell(res);
#line 520
      ((rtypes + i)->res + j)->nameptloc = (uint32 )tmp___4;
#line 521
      putshort(65535, res);
#line 522
      _IO_putc((int )((rtypes + i)->res + j)->flags, res);
#line 524
      _IO_putc((int )(((((rtypes + i)->res + j)->pos - resource_base) >> 16) & 255U),
               res);
#line 525
      _IO_putc((int )(((((rtypes + i)->res + j)->pos - resource_base) >> 8) & 255U),
               res);
#line 526
      _IO_putc((int )((((rtypes + i)->res + j)->pos - resource_base) & 255U), res);
#line 527
      putlong(0L, res);
#line 518
      j ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
#line 516
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 530
  tmp___5 = ftell(res);
#line 530
  namestart = (uint32 )tmp___5;
#line 532
  i = 0;
  }
  {
#line 532
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 532
    if (! ((rtypes + i)->tag != 0U)) {
#line 532
      goto while_break___4;
    }
#line 533
    j = 0;
    {
#line 533
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 533
      if (! (((rtypes + i)->res + j)->pos != 0U)) {
#line 533
        goto while_break___5;
      }
#line 534
      if ((unsigned long )((rtypes + i)->res + j)->name != (unsigned long )((void *)0)) {
        {
#line 535
        tmp___6 = ftell(res);
#line 535
        ((rtypes + i)->res + j)->nameloc = (uint32 )tmp___6;
#line 536
        tmp___7 = strlen((char const   *)((rtypes + i)->res + j)->name);
#line 536
        _IO_putc((int )tmp___7, res);
#line 537
        tmp___8 = strlen((char const   *)((rtypes + i)->res + j)->name);
#line 537
        fwrite((void const   */* __restrict  */)((rtypes + i)->res + j)->name, (size_t )1,
               tmp___8, (FILE */* __restrict  */)res);
        }
      }
#line 533
      j ++;
    }
    while_break___5: /* CIL Label */ ;
    }
#line 532
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
  {
#line 541
  tmp___9 = ftell(res);
#line 541
  mend = (uint32 )tmp___9;
#line 544
  fseek(res, (long )(rtypesstart + 2U), 0);
#line 545
  i = 0;
  }
  {
#line 545
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 545
    if (! ((rtypes + i)->tag != 0U)) {
#line 545
      goto while_break___6;
    }
    {
#line 546
    putlong((long )(rtypes + i)->tag, res);
#line 547
    j = 0;
    }
    {
#line 547
    while (1) {
      while_continue___7: /* CIL Label */ ;
#line 547
      if (! (((rtypes + i)->res + j)->pos != 0U)) {
#line 547
        goto while_break___7;
      }
#line 547
      j ++;
    }
    while_break___7: /* CIL Label */ ;
    }
    {
#line 548
    putshort(j - 1, res);
#line 549
    putshort((int )((rtypes + i)->resloc - rtypesstart), res);
#line 545
    i ++;
    }
  }
  while_break___6: /* CIL Label */ ;
  }
#line 552
  i = 0;
  {
#line 552
  while (1) {
    while_continue___8: /* CIL Label */ ;
#line 552
    if (! ((rtypes + i)->tag != 0U)) {
#line 552
      goto while_break___8;
    }
#line 553
    j = 0;
    {
#line 553
    while (1) {
      while_continue___9: /* CIL Label */ ;
#line 553
      if (! (((rtypes + i)->res + j)->pos != 0U)) {
#line 553
        goto while_break___9;
      }
#line 554
      if ((unsigned long )((rtypes + i)->res + j)->name != (unsigned long )((void *)0)) {
        {
#line 555
        fseek(res, (long )((rtypes + i)->res + j)->nameptloc, 0);
#line 556
        putshort((int )(((rtypes + i)->res + j)->nameloc - namestart), res);
        }
      }
#line 553
      j ++;
    }
    while_break___9: /* CIL Label */ ;
    }
#line 552
    i ++;
  }
  while_break___8: /* CIL Label */ ;
  }
  {
#line 561
  fseek(res, (long )rend, 0);
  }
#line 563
  if ((unsigned int )output_format != 0U) {
    {
#line 564
    putlong(256L, res);
#line 565
    putlong((long )(rend - rfork_base), res);
#line 566
    putlong((long )((rend - rfork_base) - 256U), res);
#line 567
    putlong((long )(mend - rend), res);
    }
  } else {
#line 569
    i = 0;
    {
#line 569
    while (1) {
      while_continue___10: /* CIL Label */ ;
#line 569
      if (! (i < 16)) {
#line 569
        goto while_break___10;
      }
      {
#line 570
      _IO_putc(0, res);
#line 569
      i ++;
      }
    }
    while_break___10: /* CIL Label */ ;
    }
  }
  {
#line 573
  putlong(0L, res);
#line 574
  putshort(0, res);
#line 575
  putshort(0, res);
#line 577
  tmp___10 = ftell(res);
#line 577
  putshort((int )((4L + tmp___10) - (long )rend), res);
#line 578
  putshort((int )(namestart - rend), res);
#line 580
  fseek(res, (long )rfork_base, 0);
#line 582
  putlong(256L, res);
#line 583
  putlong((long )(rend - rfork_base), res);
#line 584
  putlong((long )((rend - rfork_base) - 256U), res);
#line 585
  putlong((long )(mend - rend), res);
  }
#line 586
  return;
}
}
#line 603 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static void DumpMacBinaryHeader___0(FILE *res , struct macbinaryheader *mb ) 
{ 
  uint8 header[128] ;
  uint8 *hpt ;
  char buffer___0[256] ;
  char *pt ;
  char *dpt ;
  uint32 len ;
  time_t now ;
  int i ;
  int crc ;
  char *pt___0 ;
  char *tmp ;
  uint8 *tmp___0 ;
  uint8 *tmp___1 ;
  size_t tmp___2 ;
  uint8 *tmp___3 ;
  char *tmp___4 ;
  uint8 *tmp___5 ;
  uint8 *tmp___6 ;
  uint8 *tmp___7 ;
  uint8 *tmp___8 ;
  uint8 *tmp___9 ;
  uint8 *tmp___10 ;
  uint8 *tmp___11 ;
  uint8 *tmp___12 ;
  uint8 *tmp___13 ;
  uint8 *tmp___14 ;
  uint8 *tmp___15 ;
  uint8 *tmp___16 ;
  uint8 *tmp___17 ;
  uint8 *tmp___18 ;
  uint8 *tmp___19 ;
  uint8 *tmp___20 ;
  uint8 *tmp___21 ;
  uint8 *tmp___22 ;
  uint8 *tmp___23 ;
  uint8 *tmp___24 ;
  uint8 *tmp___25 ;
  uint8 *tmp___26 ;
  uint8 *tmp___27 ;
  long tmp___28 ;
  uint8 *tmp___29 ;
  uint8 *tmp___30 ;
  uint8 *tmp___31 ;
  uint8 *tmp___32 ;
  uint8 *tmp___33 ;
  uint8 *tmp___34 ;
  uint8 *tmp___35 ;
  uint8 *tmp___36 ;
  uint8 *tmp___37 ;
  uint8 *tmp___38 ;
  uint8 *tmp___39 ;
  uint8 *tmp___40 ;
  uint8 *tmp___41 ;
  uint8 *tmp___42 ;
  uint8 *tmp___43 ;
  unsigned long tmp___44 ;

  {
#line 609
  if ((unsigned long )mb->macfilename == (unsigned long )((void *)0)) {
    {
#line 610
    tmp = strrchr((char const   *)mb->binfilename, '/');
#line 610
    pt___0 = tmp;
    }
#line 611
    if ((unsigned long )pt___0 == (unsigned long )((void *)0)) {
#line 611
      pt___0 = mb->binfilename;
    } else {
#line 612
      pt___0 ++;
    }
    {
#line 613
    strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)pt___0);
#line 614
    dpt = strrchr((char const   *)(buffer___0), '.');
    }
#line 615
    if ((unsigned long )dpt == (unsigned long )((void *)0)) {
      {
#line 616
      buffer___0[0] = (char )'_';
#line 617
      strcpy((char */* __restrict  */)(buffer___0 + 1), (char const   */* __restrict  */)pt___0);
      }
    } else {
#line 619
      *dpt = (char )'\000';
    }
#line 620
    mb->macfilename = buffer___0;
#line 621
    buffer___0[63] = (char )'\000';
  }
  {
#line 624
  memset((void *)(header), '\000', sizeof(header));
#line 625
  hpt = header;
#line 626
  tmp___0 = hpt;
#line 626
  hpt ++;
#line 626
  *tmp___0 = (uint8 )'\000';
#line 628
  pt = mb->macfilename;
#line 629
  tmp___1 = hpt;
#line 629
  hpt ++;
#line 629
  tmp___2 = strlen((char const   *)pt);
#line 629
  *tmp___1 = (uint8 )tmp___2;
  }
  {
#line 630
  while (1) {
    while_continue: /* CIL Label */ ;
#line 630
    if (! *pt) {
#line 630
      goto while_break;
    }
#line 631
    tmp___3 = hpt;
#line 631
    hpt ++;
#line 631
    tmp___4 = pt;
#line 631
    pt ++;
#line 631
    *tmp___3 = (uint8 )*tmp___4;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 632
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 632
    if (! ((unsigned long )hpt < (unsigned long )(header + 65))) {
#line 632
      goto while_break___0;
    }
#line 633
    tmp___5 = hpt;
#line 633
    hpt ++;
#line 633
    *tmp___5 = (uint8 )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 635
  tmp___6 = hpt;
#line 635
  hpt ++;
#line 635
  *tmp___6 = (uint8 )(mb->type >> 24);
#line 635
  tmp___7 = hpt;
#line 635
  hpt ++;
#line 635
  *tmp___7 = (uint8 )(mb->type >> 16);
#line 635
  tmp___8 = hpt;
#line 635
  hpt ++;
#line 635
  *tmp___8 = (uint8 )(mb->type >> 8);
#line 635
  tmp___9 = hpt;
#line 635
  hpt ++;
#line 635
  *tmp___9 = (uint8 )mb->type;
#line 637
  tmp___10 = hpt;
#line 637
  hpt ++;
#line 637
  *tmp___10 = (uint8 )(mb->creator >> 24);
#line 637
  tmp___11 = hpt;
#line 637
  hpt ++;
#line 637
  *tmp___11 = (uint8 )(mb->creator >> 16);
#line 637
  tmp___12 = hpt;
#line 637
  hpt ++;
#line 637
  *tmp___12 = (uint8 )(mb->creator >> 8);
#line 637
  tmp___13 = hpt;
#line 637
  hpt ++;
#line 637
  *tmp___13 = (uint8 )mb->creator;
#line 638
  tmp___14 = hpt;
#line 638
  hpt ++;
#line 638
  *tmp___14 = (uint8 )'\000';
#line 639
  tmp___15 = hpt;
#line 639
  hpt ++;
#line 639
  *tmp___15 = (uint8 )'\000';
#line 640
  tmp___16 = hpt;
#line 640
  hpt ++;
#line 640
  *tmp___16 = (uint8 )'\000';
#line 640
  tmp___17 = hpt;
#line 640
  hpt ++;
#line 640
  *tmp___17 = (uint8 )'\000';
#line 641
  tmp___18 = hpt;
#line 641
  hpt ++;
#line 641
  *tmp___18 = (uint8 )'\000';
#line 641
  tmp___19 = hpt;
#line 641
  hpt ++;
#line 641
  *tmp___19 = (uint8 )'\000';
#line 642
  tmp___20 = hpt;
#line 642
  hpt ++;
#line 642
  *tmp___20 = (uint8 )'\000';
#line 642
  tmp___21 = hpt;
#line 642
  hpt ++;
#line 642
  *tmp___21 = (uint8 )'\000';
#line 643
  tmp___22 = hpt;
#line 643
  hpt ++;
#line 643
  *tmp___22 = (uint8 )'\000';
#line 644
  tmp___23 = hpt;
#line 644
  hpt ++;
#line 644
  *tmp___23 = (uint8 )'\000';
#line 646
  tmp___24 = hpt;
#line 646
  hpt ++;
#line 646
  *tmp___24 = (uint8 )'\000';
#line 646
  tmp___25 = hpt;
#line 646
  hpt ++;
#line 646
  *tmp___25 = (uint8 )'\000';
#line 646
  tmp___26 = hpt;
#line 646
  hpt ++;
#line 646
  *tmp___26 = (uint8 )'\000';
#line 646
  tmp___27 = hpt;
#line 646
  hpt ++;
#line 646
  *tmp___27 = (uint8 )'\000';
#line 648
  fseek(res, 0L, 2);
#line 649
  tmp___28 = ftell(res);
#line 649
  len = (uint32 )((unsigned long )tmp___28 - sizeof(header));
#line 650
  tmp___29 = hpt;
#line 650
  hpt ++;
#line 650
  *tmp___29 = (uint8 )(len >> 24);
#line 650
  tmp___30 = hpt;
#line 650
  hpt ++;
#line 650
  *tmp___30 = (uint8 )(len >> 16);
#line 650
  tmp___31 = hpt;
#line 650
  hpt ++;
#line 650
  *tmp___31 = (uint8 )(len >> 8);
#line 650
  tmp___32 = hpt;
#line 650
  hpt ++;
#line 650
  *tmp___32 = (uint8 )len;
  }
  {
#line 652
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 652
    if (! ((len & 127U) != 0U)) {
#line 652
      goto while_break___1;
    }
    {
#line 653
    _IO_putc('\000', res);
#line 653
    len ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 656
  time(& now);
#line 658
  now += 2081376000L;
#line 659
  i = 1904;
  }
  {
#line 659
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 659
    if (! (i < 1970)) {
#line 659
      goto while_break___2;
    }
#line 660
    now += 86400L;
#line 659
    i += 4;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 662
  tmp___33 = hpt;
#line 662
  hpt ++;
#line 662
  *tmp___33 = (uint8 )(now >> 24);
#line 662
  tmp___34 = hpt;
#line 662
  hpt ++;
#line 662
  *tmp___34 = (uint8 )(now >> 16);
#line 662
  tmp___35 = hpt;
#line 662
  hpt ++;
#line 662
  *tmp___35 = (uint8 )(now >> 8);
#line 662
  tmp___36 = hpt;
#line 662
  hpt ++;
#line 662
  *tmp___36 = (uint8 )now;
#line 664
  tmp___37 = hpt;
#line 664
  hpt ++;
#line 664
  *tmp___37 = (uint8 )(now >> 24);
#line 664
  tmp___38 = hpt;
#line 664
  hpt ++;
#line 664
  *tmp___38 = (uint8 )(now >> 16);
#line 664
  tmp___39 = hpt;
#line 664
  hpt ++;
#line 664
  *tmp___39 = (uint8 )(now >> 8);
#line 664
  tmp___40 = hpt;
#line 664
  hpt ++;
#line 664
  *tmp___40 = (uint8 )now;
#line 666
  tmp___41 = hpt;
#line 666
  hpt ++;
#line 666
  *tmp___41 = (uint8 )'\000';
#line 666
  tmp___42 = hpt;
#line 666
  hpt ++;
#line 666
  *tmp___42 = (uint8 )'\000';
#line 667
  tmp___43 = hpt;
#line 667
  hpt ++;
#line 667
  *tmp___43 = (uint8 )0;
#line 670
  memcpy((void */* __restrict  */)(header + 102), (void const   */* __restrict  */)"mBIN",
         (size_t )4);
#line 671
  header[106] = (uint8 )0;
#line 672
  header[107] = (uint8 )0;
#line 674
  header[122] = (uint8 )130;
#line 675
  header[123] = (uint8 )129;
#line 677
  tmp___44 = binhex_crc(header, 124);
#line 677
  crc = (int )tmp___44;
#line 678
  header[124] = (uint8 )(crc >> 8);
#line 679
  header[125] = (uint8 )crc;
#line 681
  fseek(res, 0L, 0);
#line 682
  fwrite((void const   */* __restrict  */)(header), (size_t )1, sizeof(header), (FILE */* __restrict  */)res);
  }
#line 683
  return;
}
}
#line 685 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static void WriteDummyHeaders(FILE *res ) 
{ 
  int i ;

  {
#line 689
  if ((unsigned int )output_format == 1U) {
#line 690
    i = 0;
    {
#line 690
    while (1) {
      while_continue: /* CIL Label */ ;
#line 690
      if (! (i < 128)) {
#line 690
        goto while_break;
      }
      {
#line 691
      _IO_putc(0, res);
#line 690
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
#line 693
  i = 0;
  {
#line 693
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 693
    if (! (i < 256)) {
#line 693
      goto while_break___0;
    }
    {
#line 694
    _IO_putc(0, res);
#line 693
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 695
  return;
}
}
#line 697 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static int DumpPostscriptFont(Face *face ) 
{ 
  FILE *res ;
  int ret ;
  struct resourcetype resources[2] ;
  struct macbinaryheader header ;
  char buffer___0[63] ;
  char *pt ;
  char *spt ;
  char *lcpt ;
  char filename[63] ;
  char *fpt ;
  char *tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;

  {
#line 699
  ret = 1;
#line 702
  lcpt = (char *)((void *)0);
#line 705
  fpt = filename;
#line 706
  pt = buffer___0;
#line 706
  spt = face->fontname;
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
#line 706
    if (*spt) {
#line 706
      if (! ((unsigned long )pt < (unsigned long )((buffer___0 + sizeof(buffer___0)) - 1))) {
#line 706
        goto while_break;
      }
    } else {
#line 706
      goto while_break;
    }
    {
#line 707
    tmp___2 = __ctype_b_loc();
    }
#line 707
    if ((int const   )*(*tmp___2 + (int )*spt) & 256) {
#line 708
      tmp = pt;
#line 708
      pt ++;
#line 708
      *tmp = *spt;
#line 709
      if ((unsigned long )spt == (unsigned long )face->fontname) {
#line 709
        lcpt = spt + 5;
      } else {
#line 709
        lcpt = spt + 3;
      }
    } else {
      {
#line 710
      tmp___1 = __ctype_b_loc();
      }
#line 710
      if ((int const   )*(*tmp___1 + (int )*spt) & 512) {
#line 710
        if ((unsigned long )spt < (unsigned long )lcpt) {
#line 711
          tmp___0 = pt;
#line 711
          pt ++;
#line 711
          *tmp___0 = *spt;
        }
      }
    }
    {
#line 712
    tmp___4 = __ctype_b_loc();
    }
#line 712
    if ((int const   )*(*tmp___4 + (int )*spt) & 8) {
#line 712
      if ((unsigned long )fpt < (unsigned long )((filename + sizeof(filename)) - 6)) {
#line 713
        tmp___3 = fpt;
#line 713
        fpt ++;
#line 713
        *tmp___3 = *spt;
      }
    }
#line 706
    spt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 715
  *pt = (char )'\000';
#line 715
  *fpt = (char )'\000';
#line 717
  if ((unsigned int )output_format != 1U) {
    {
#line 718
    strcpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)(buffer___0));
    }
  } else {
    {
#line 720
    strcat((char */* __restrict  */)(filename), (char const   */* __restrict  */)".bin");
    }
  }
  {
#line 721
  res = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"w+");
  }
#line 722
  if ((unsigned long )res == (unsigned long )((void *)0)) {
#line 723
    return (0);
  }
  {
#line 725
  WriteDummyHeaders(res);
#line 726
  memset((void *)(resources), '\000', sizeof(resources));
#line 728
  resources[0].tag = (uint32 )((((80 << 24) | (79 << 16)) | (83 << 8)) | 84);
#line 729
  resources[0].res = PSToResources(res, face);
  }
#line 730
  if ((unsigned long )resources[0].res == (unsigned long )((void *)0)) {
    {
#line 731
    fclose(res);
#line 732
    unlink((char const   *)(filename));
    }
#line 733
    return (0);
  }
  {
#line 735
  DumpResourceMap___0(res, resources);
#line 736
  free((void *)resources[0].res);
  }
#line 738
  if ((unsigned int )output_format == 1U) {
    {
#line 739
    header.macfilename = buffer___0;
#line 744
    header.type = (uint32 )((((76 << 24) | (87 << 16)) | (70 << 8)) | 78);
#line 745
    header.creator = (uint32 )((((71 << 24) | (87 << 16)) | (112 << 8)) | 49);
#line 746
    DumpMacBinaryHeader___0(res, & header);
    }
  }
  {
#line 748
  tmp___5 = ferror(res);
  }
#line 748
  if (tmp___5) {
#line 748
    tmp___6 = 0;
  } else {
#line 748
    tmp___6 = 1;
  }
  {
#line 748
  ret = tmp___6;
#line 749
  tmp___7 = fclose(res);
  }
#line 749
  if (tmp___7 == -1) {
#line 749
    ret = 0;
  }
#line 750
  return (ret);
}
}
#line 753 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufond.c"
static void DumpFamily(Family *fam ) 
{ 
  int i ;
  int ncnt ;
  int tcnt ;
  int ret ;
  int npos ;
  int tpos ;
  int fpos ;
  Face *face ;
  struct resourcetype resources[4] ;
  struct resource___0 fonds[2] ;
  FILE *res ;
  struct macbinaryheader header ;
  char filename[256] ;
  int tmp ;
  char const   *tmp___0 ;
  char const   *tmp___1 ;
  void *tmp___2 ;
  long tmp___3 ;
  void *tmp___4 ;
  long tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;

  {
#line 763
  i = 0;
  {
#line 763
  while (1) {
    while_continue: /* CIL Label */ ;
#line 763
    if (! (i < 48)) {
#line 763
      goto while_break;
    }
#line 764
    if ((unsigned long )fam->psfaces[i] != (unsigned long )((void *)0)) {
      {
#line 765
      tmp = DumpPostscriptFont(fam->psfaces[i]);
      }
#line 765
      if (! tmp) {
        {
#line 766
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to write resource file for PostScript %s\n",
                face->fontname);
        }
      }
    }
#line 763
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 768
  tcnt = 0;
#line 768
  ncnt = tcnt;
#line 768
  i = ncnt;
  {
#line 768
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 768
    if (! (i < 96)) {
#line 768
      goto while_break___0;
    }
#line 769
    face = fam->faces[i];
    {
#line 769
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 769
      if (! ((unsigned long )face != (unsigned long )((void *)0))) {
#line 769
        goto while_break___1;
      }
#line 770
      ncnt ++;
#line 769
      face = face->next;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 771
    if ((unsigned long )fam->ttffaces[i] != (unsigned long )((void *)0)) {
#line 772
      tcnt ++;
    }
#line 768
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 775
  if (ncnt == 0) {
#line 775
    if (tcnt == 0) {
#line 776
      return;
    }
  }
  {
#line 778
  strcpy((char */* __restrict  */)(filename), (char const   */* __restrict  */)fam->familyname);
#line 779
  strcat((char */* __restrict  */)(filename), (char const   */* __restrict  */)".fam");
  }
#line 780
  if ((unsigned int )output_format == 0U) {
#line 780
    tmp___1 = ".dfont";
  } else {
#line 780
    if ((unsigned int )output_format == 1U) {
#line 780
      tmp___0 = ".bin";
    } else {
#line 780
      tmp___0 = ".rsrc";
    }
#line 780
    tmp___1 = tmp___0;
  }
  {
#line 780
  strcat((char */* __restrict  */)(filename), (char const   */* __restrict  */)tmp___1);
#line 783
  res = fopen((char const   */* __restrict  */)(filename), (char const   */* __restrict  */)"w");
  }
#line 784
  if ((unsigned long )res == (unsigned long )((void *)0)) {
    {
#line 785
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to open output file %s\n",
            filename);
    }
#line 786
    return;
  }
  {
#line 788
  WriteDummyHeaders(res);
#line 790
  memset((void *)(resources), 0, sizeof(resources));
#line 791
  memset((void *)(fonds), 0, sizeof(fonds));
#line 792
  fpos = 0;
#line 792
  tpos = fpos;
#line 792
  npos = tpos;
  }
#line 793
  if (ncnt != 0) {
    {
#line 794
    resources[0].tag = (uint32 )((((78 << 24) | (70 << 16)) | (78 << 8)) | 84);
#line 795
    tmp___2 = calloc((size_t )(ncnt + 1), sizeof(struct resource___0 ));
#line 795
    resources[0].res = (struct resource___0 *)tmp___2;
#line 796
    tcnt = 0;
#line 796
    ncnt = tcnt;
#line 796
    i = ncnt;
    }
    {
#line 796
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 796
      if (! (i < 96)) {
#line 796
        goto while_break___2;
      }
#line 797
      face = fam->faces[i];
      {
#line 797
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 797
        if (! ((unsigned long )face != (unsigned long )((void *)0))) {
#line 797
          goto while_break___3;
        }
        {
#line 798
        tmp___3 = BDFToResource(res, face);
#line 798
        (resources[0].res + ncnt)->pos = (uint32 )tmp___3;
#line 799
        (resources[0].res + ncnt)->flags = (uint8 )0;
#line 800
        (resources[0].res + ncnt)->id = (uint16 )(fam->id + ncnt);
#line 801
        ncnt ++;
#line 797
        face = face->next;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 796
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 804
    fpos = 1;
#line 804
    tpos = fpos;
  }
#line 806
  if (tcnt != 0) {
    {
#line 807
    resources[tpos].tag = (uint32 )((((115 << 24) | (102 << 16)) | (110 << 8)) | 116);
#line 808
    tmp___4 = calloc((size_t )(tcnt + 1), sizeof(struct resource___0 ));
#line 808
    resources[tpos].res = (struct resource___0 *)tmp___4;
#line 809
    tcnt = 0;
#line 809
    i = tcnt;
    }
    {
#line 809
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 809
      if (! (i < 96)) {
#line 809
        goto while_break___4;
      }
#line 810
      if ((unsigned long )fam->ttffaces[i] != (unsigned long )((void *)0)) {
        {
#line 811
        tmp___5 = TTFToResource(res, fam->ttffaces[i]);
#line 811
        (resources[tpos].res + tcnt)->pos = (uint32 )tmp___5;
#line 812
        (resources[tpos].res + tcnt)->flags = (uint8 )0;
#line 813
        (resources[tpos].res + tcnt)->id = (uint16 )(fam->id + tcnt);
#line 814
        tcnt ++;
        }
      }
#line 809
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 817
    fpos ++;
  }
  {
#line 820
  resources[fpos].tag = (uint32 )((((70 << 24) | (79 << 16)) | (78 << 8)) | 68);
#line 821
  resources[fpos].res = fonds;
#line 822
  fonds[0].pos = FamilyToFOND(res, fam);
#line 823
  fonds[0].flags = (uint8 )0;
#line 824
  fonds[0].id = (uint16 )fam->id;
#line 825
  fonds[0].name = fam->familyname;
#line 827
  DumpResourceMap___0(res, resources);
  }
#line 829
  if ((unsigned int )output_format == 1U) {
    {
#line 830
    header.macfilename = (char *)((void *)0);
#line 831
    header.binfilename = filename;
#line 833
    header.type = (uint32 )((((70 << 24) | (70 << 16)) | (73 << 8)) | 76);
#line 834
    header.creator = (uint32 )((((68 << 24) | (77 << 16)) | (79 << 8)) | 86);
#line 835
    DumpMacBinaryHeader___0(res, & header);
    }
  }
  {
#line 837
  tmp___6 = ferror(res);
  }
#line 837
  if (tmp___6) {
#line 837
    tmp___7 = 0;
  } else {
#line 837
    tmp___7 = 1;
  }
  {
#line 837
  ret = tmp___7;
#line 838
  tmp___8 = fclose(res);
  }
#line 838
  if (tmp___8 == -1) {
    {
#line 839
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to write resource file for family %s\n",
            fam->familyname);
    }
  } else
#line 838
  if (ret == 0) {
    {
#line 839
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to write resource file for family %s\n",
            fam->familyname);
    }
  }
#line 840
  return;
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned long const   binhex_crcinit___0  =    (unsigned long const   )0;
#line 8 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned short crctab___0[256]  = 
#line 8
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 43 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned long binhex_updcrc___0(unsigned long icrc , unsigned char *icp , int icnt ) 
{ 
  register unsigned long crc ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 50
  crc = icrc;
#line 51
  cp = icp;
#line 52
  cnt = icnt;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    tmp___0 = cnt;
#line 54
    cnt --;
#line 54
    if (! tmp___0) {
#line 54
      goto while_break;
    }
#line 55
    tmp = cp;
#line 55
    cp ++;
#line 55
    crc = ((crc << 8) & 65280UL) ^ (unsigned long )crctab___0[((crc >> 8) & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return (crc);
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondttf.c"
static char *ReadUnicode(FILE *ttf , long pos , int len ) 
{ 
  char *str ;
  void *tmp ;
  char *pt ;
  int ch ;
  long here ;
  long tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 59
  tmp = malloc((size_t )(len / 2 + 1));
#line 59
  str = (char *)tmp;
#line 59
  pt = str;
#line 61
  tmp___0 = ftell(ttf);
#line 61
  here = tmp___0;
#line 62
  fseek(ttf, pos, 0);
  }
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (len > 0)) {
#line 63
      goto while_break;
    }
    {
#line 64
    ch = getushort(ttf);
    }
#line 65
    if (ch >= 32) {
#line 65
      if (ch < 127) {
#line 66
        tmp___1 = pt;
#line 66
        pt ++;
#line 66
        *tmp___1 = (char )ch;
      }
    }
#line 67
    len -= 2;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 69
  *pt = (char )'\000';
#line 70
  fseek(ttf, here, 0);
  }
#line 71
  return (str);
}
}
#line 74 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondttf.c"
static char *Read1Byte(FILE *ttf , long pos , int len ) 
{ 
  char *str ;
  void *tmp ;
  char *pt ;
  int ch ;
  long here ;
  long tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 75
  tmp = malloc((size_t )(len + 1));
#line 75
  str = (char *)tmp;
#line 75
  pt = str;
#line 77
  tmp___0 = ftell(ttf);
#line 77
  here = tmp___0;
#line 78
  fseek(ttf, pos, 0);
  }
  {
#line 79
  while (1) {
    while_continue: /* CIL Label */ ;
#line 79
    if (! (len > 0)) {
#line 79
      goto while_break;
    }
    {
#line 80
    ch = _IO_getc(ttf);
    }
#line 81
    if (ch >= 32) {
#line 81
      if (ch < 127) {
#line 82
        tmp___1 = pt;
#line 82
        pt ++;
#line 82
        *tmp___1 = (char )ch;
      }
    }
#line 83
    len --;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 85
  *pt = (char )'\000';
#line 86
  fseek(ttf, here, 0);
  }
#line 87
  return (str);
}
}
#line 90 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondttf.c"
int TTFGetNames(Face *face ) 
{ 
  FILE *ttf ;
  FILE *tmp ;
  int ch1 ;
  int ch2 ;
  int ch3 ;
  int ch4 ;
  struct ttfinfo info ;
  int i ;
  int cnt ;
  int tag ;
  int platform ;
  int specific ;
  int offset ;
  int format ;
  int len ;
  int lang ;
  int name ;
  int stroff ;
  long strbase ;
  char *str ;
  long tmp___0 ;
  long tmp___1 ;
  long tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int k ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 92
  tmp = fopen((char const   */* __restrict  */)face->filename, (char const   */* __restrict  */)"r");
#line 92
  ttf = tmp;
  }
#line 100
  if ((unsigned long )ttf == (unsigned long )((void *)0)) {
    {
#line 101
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for reading\n",
            face->filename);
    }
#line 102
    return (0);
  }
  {
#line 104
  ch1 = _IO_getc(ttf);
#line 105
  ch2 = _IO_getc(ttf);
#line 106
  ch3 = _IO_getc(ttf);
#line 107
  ch4 = _IO_getc(ttf);
  }
#line 108
  if (ch1 == 0) {
#line 108
    if (ch2 == 1) {
#line 108
      if (ch3 == 0) {
#line 108
        if (! (ch4 == 0)) {
#line 108
          goto _L___4;
        }
      } else {
#line 108
        goto _L___4;
      }
    } else {
#line 108
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 108
  if (ch1 == 79) {
#line 108
    if (ch2 == 84) {
#line 108
      if (ch3 == 84) {
#line 108
        if (! (ch4 == 79)) {
#line 108
          goto _L___1;
        }
      } else {
#line 108
        goto _L___1;
      }
    } else {
#line 108
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 108
  if (ch1 == 116) {
#line 108
    if (ch2 == 114) {
#line 108
      if (ch3 == 117) {
#line 108
        if (! (ch4 == 101)) {
          {
#line 111
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s doesn\'t look like a true or open type font.\n",
                  face->filename);
#line 112
          fclose(ttf);
          }
#line 113
          return (0);
        }
      } else {
        {
#line 111
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s doesn\'t look like a true or open type font.\n",
                face->filename);
#line 112
        fclose(ttf);
        }
#line 113
        return (0);
      }
    } else {
      {
#line 111
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s doesn\'t look like a true or open type font.\n",
              face->filename);
#line 112
      fclose(ttf);
      }
#line 113
      return (0);
    }
  } else {
    {
#line 111
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s doesn\'t look like a true or open type font.\n",
            face->filename);
#line 112
    fclose(ttf);
    }
#line 113
    return (0);
  }
  {
#line 115
  memset((void *)(& info), 0, sizeof(info));
#line 117
  cnt = getushort(ttf);
#line 118
  getushort(ttf);
#line 119
  getushort(ttf);
#line 120
  getushort(ttf);
#line 122
  i = 0;
  }
  {
#line 122
  while (1) {
    while_continue: /* CIL Label */ ;
#line 122
    if (! (i < cnt)) {
#line 122
      goto while_break;
    }
    {
#line 123
    tmp___0 = getlong(ttf);
#line 123
    tag = (int )tmp___0;
#line 124
    getlong(ttf);
#line 125
    tmp___1 = getlong(ttf);
#line 125
    offset = (int )tmp___1;
#line 126
    getlong(ttf);
    }
    {
#line 131
    if (tag == ((((99 << 24) | (109 << 16)) | (97 << 8)) | 112)) {
#line 131
      goto case_exp;
    }
#line 135
    if (tag == ((((104 << 24) | (101 << 16)) | (97 << 8)) | 100)) {
#line 135
      goto case_exp___0;
    }
#line 135
    if (tag == ((((98 << 24) | (104 << 16)) | (101 << 8)) | 100)) {
#line 135
      goto case_exp___0;
    }
#line 138
    if (tag == ((((104 << 24) | (104 << 16)) | (101 << 8)) | 97)) {
#line 138
      goto case_exp___2;
    }
#line 141
    if (tag == ((((104 << 24) | (109 << 16)) | (116 << 8)) | 120)) {
#line 141
      goto case_exp___3;
    }
#line 144
    if (tag == ((((109 << 24) | (97 << 16)) | (120 << 8)) | 112)) {
#line 144
      goto case_exp___4;
    }
#line 147
    if (tag == ((((110 << 24) | (97 << 16)) | (109 << 8)) | 101)) {
#line 147
      goto case_exp___5;
    }
#line 150
    if (tag == ((((112 << 24) | (111 << 16)) | (115 << 8)) | 116)) {
#line 150
      goto case_exp___6;
    }
#line 130
    goto switch_break;
    case_exp: /* CIL Label */ 
#line 132
    info.cmap_start = (long )offset;
#line 133
    goto switch_break;
    case_exp___0: /* CIL Label */ 
    case_exp___1: /* CIL Label */ 
#line 136
    info.head_start = (long )offset;
#line 137
    goto switch_break;
    case_exp___2: /* CIL Label */ 
#line 139
    info.hhea_start = (long )offset;
#line 140
    goto switch_break;
    case_exp___3: /* CIL Label */ 
#line 142
    info.hmtx_start = (long )offset;
#line 143
    goto switch_break;
    case_exp___4: /* CIL Label */ 
#line 145
    info.maxp_start = (long )offset;
#line 146
    goto switch_break;
    case_exp___5: /* CIL Label */ 
#line 148
    info.name_start = (long )offset;
#line 149
    goto switch_break;
    case_exp___6: /* CIL Label */ 
#line 151
    info.post_start = (long )offset;
#line 152
    goto switch_break;
    switch_break: /* CIL Label */ ;
    }
#line 122
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 155
  if (info.cmap_start == 0L) {
    {
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s is missing some required tables. I can\'t deal with it.\n",
            face->filename);
#line 158
    fclose(ttf);
    }
#line 159
    return (0);
  } else
#line 155
  if (info.head_start == 0L) {
    {
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s is missing some required tables. I can\'t deal with it.\n",
            face->filename);
#line 158
    fclose(ttf);
    }
#line 159
    return (0);
  } else
#line 155
  if (info.hhea_start == 0L) {
    {
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s is missing some required tables. I can\'t deal with it.\n",
            face->filename);
#line 158
    fclose(ttf);
    }
#line 159
    return (0);
  } else
#line 155
  if (info.hmtx_start == 0L) {
    {
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s is missing some required tables. I can\'t deal with it.\n",
            face->filename);
#line 158
    fclose(ttf);
    }
#line 159
    return (0);
  } else
#line 155
  if (info.maxp_start == 0L) {
    {
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s is missing some required tables. I can\'t deal with it.\n",
            face->filename);
#line 158
    fclose(ttf);
    }
#line 159
    return (0);
  } else
#line 155
  if (info.name_start == 0L) {
    {
#line 157
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Hmm, %s is missing some required tables. I can\'t deal with it.\n",
            face->filename);
#line 158
    fclose(ttf);
    }
#line 159
    return (0);
  }
#line 162
  if (info.post_start) {
    {
#line 163
    fseek(ttf, info.post_start + 12L, 0);
#line 164
    tmp___2 = getlong(ttf);
#line 164
    info.isfixed = (int )tmp___2;
    }
  }
  {
#line 166
  fseek(ttf, info.maxp_start + 4L, 0);
#line 167
  info.max_glyph = getushort(ttf);
#line 168
  fseek(ttf, info.head_start + 18L, 0);
#line 169
  info.emsize = getushort(ttf);
#line 170
  fseek(ttf, info.head_start + 36L, 0);
#line 171
  face->xmin = getushort(ttf);
#line 172
  face->ymin = getushort(ttf);
#line 173
  face->xmax = getushort(ttf);
#line 174
  face->ymax = getushort(ttf);
#line 175
  info.macstyle = getushort(ttf);
#line 176
  fseek(ttf, info.hhea_start + 4L, 0);
#line 177
  face->ascent = getushort(ttf);
#line 178
  tmp___3 = getushort(ttf);
#line 178
  face->descent = - tmp___3;
#line 179
  face->linegap = getushort(ttf);
#line 180
  fseek(ttf, info.hhea_start + 34L, 0);
#line 181
  info.longmtx = getushort(ttf);
  }
#line 183
  if (face->ascent + face->descent != info.emsize) {
#line 184
    face->ascent = (int )(.8 * (double )info.emsize);
#line 185
    face->descent = info.emsize - face->ascent;
  }
  {
#line 191
  fseek(ttf, info.cmap_start + 2L, 0);
#line 192
  cnt = getushort(ttf);
#line 193
  i = 0;
  }
  {
#line 193
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 193
    if (! (i < cnt)) {
#line 193
      goto while_break___0;
    }
    {
#line 194
    platform = getushort(ttf);
#line 195
    specific = getushort(ttf);
#line 196
    tmp___4 = getlong(ttf);
#line 196
    offset = (int )tmp___4;
    }
#line 197
    if (platform == 1) {
#line 197
      if (specific != 1) {
#line 197
        if (specific != 2) {
#line 197
          if (specific != 3) {
#line 197
            if (specific != 25) {
#line 198
              goto while_break___0;
            }
          }
        }
      }
    }
#line 193
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 200
  fseek(ttf, info.cmap_start + (long )offset, 0);
#line 201
  format = getushort(ttf);
#line 202
  len = getushort(ttf);
  }
#line 203
  if (i == cnt) {
    {
#line 204
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has a more complicated encoding vector than I am prepared to deal with\n",
            face->filename);
#line 205
    fclose(ttf);
    }
#line 206
    return (0);
  } else
#line 203
  if (format != 0) {
    {
#line 204
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has a more complicated encoding vector than I am prepared to deal with\n",
            face->filename);
#line 205
    fclose(ttf);
    }
#line 206
    return (0);
  }
  {
#line 208
  getushort(ttf);
#line 209
  i = 0;
  }
  {
#line 209
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 209
    if (! (i < 256)) {
#line 209
      goto while_break___1;
    }
    {
#line 210
    info.glyphs[i] = _IO_getc(ttf);
#line 209
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 212
  i = 0;
  {
#line 212
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 212
    if (! (i < 256)) {
#line 212
      goto while_break___2;
    }
#line 213
    k = info.glyphs[i];
#line 214
    if (k >= info.longmtx) {
#line 215
      k = info.longmtx - 1;
    }
    {
#line 216
    fseek(ttf, info.hmtx_start + (long )(k * 4), 0);
#line 217
    tmp___5 = getushort(ttf);
#line 217
    info.metrics[i] = (short )tmp___5;
#line 212
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 220
  fseek(ttf, info.name_start + 2L, 0);
#line 221
  cnt = getushort(ttf);
#line 222
  tmp___6 = getushort(ttf);
#line 222
  strbase = (long )tmp___6 + info.name_start;
#line 223
  i = 0;
  }
  {
#line 223
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 223
    if (! (i < cnt)) {
#line 223
      goto while_break___3;
    }
    {
#line 224
    platform = getushort(ttf);
#line 225
    specific = getushort(ttf);
#line 226
    lang = getushort(ttf);
#line 227
    name = getushort(ttf);
#line 228
    len = getushort(ttf);
#line 229
    stroff = getushort(ttf);
    }
#line 230
    if (name == 1) {
#line 230
      goto _L___7;
    } else
#line 230
    if (name == 6) {
      _L___7: /* CIL Label */ 
#line 231
      if (platform == 3) {
#line 231
        if (specific == 1) {
#line 231
          if ((lang & 255) == 9) {
            {
#line 233
            str = ReadUnicode(ttf, strbase + (long )stroff, len);
            }
          } else {
#line 231
            goto _L___6;
          }
        } else {
#line 231
          goto _L___6;
        }
      } else
      _L___6: /* CIL Label */ 
#line 231
      if (platform == 0) {
        {
#line 233
        str = ReadUnicode(ttf, strbase + (long )stroff, len);
        }
      } else
#line 234
      if (platform == 1) {
#line 234
        if (specific == 0) {
#line 234
          if (lang == 0) {
            {
#line 235
            str = Read1Byte(ttf, strbase + (long )stroff, len);
            }
          }
        }
      }
#line 236
      if (name == 1) {
#line 237
        info.familyname = str;
      } else {
#line 239
        info.fontname = str;
      }
    }
#line 223
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 243
  fclose(ttf);
  }
#line 245
  if ((unsigned long )info.fontname == (unsigned long )((void *)0)) {
#line 245
    if ((unsigned long )info.familyname != (unsigned long )((void *)0)) {
      {
#line 246
      info.fontname = strdup((char const   *)info.familyname);
      }
    } else {
#line 245
      goto _L___8;
    }
  } else
  _L___8: /* CIL Label */ 
#line 247
  if ((unsigned long )info.fontname == (unsigned long )((void *)0)) {
    {
#line 248
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s has no font name.\n",
            face->filename);
    }
#line 249
    return (0);
  }
#line 252
  face->fontname = info.fontname;
#line 253
  face->family = info.familyname;
#line 254
  face->style = (int16 )info.macstyle;
#line 255
  face->size = 0;
#line 256
  face->fixed = info.isfixed;
#line 257
  i = 0;
  {
#line 257
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 257
    if (! (i < 256)) {
#line 257
      goto while_break___4;
    }
#line 258
    face->metrics[i] = (short )(((int )info.metrics[i] << 12) / info.emsize);
#line 257
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 259
  return (1);
}
}
#line 262 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/ufondttf.c"
long TTFToResource(FILE *res , Face *face ) 
{ 
  struct stat statb ;
  int ch ;
  FILE *ttf ;
  long here ;
  long tmp ;

  {
  {
#line 267
  tmp = ftell(res);
#line 267
  here = tmp;
#line 269
  stat((char const   */* __restrict  */)face->filename, (struct stat */* __restrict  */)(& statb));
#line 270
  putlong(statb.st_size, res);
#line 272
  ttf = fopen((char const   */* __restrict  */)face->filename, (char const   */* __restrict  */)"r");
  }
  {
#line 273
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 273
    ch = _IO_getc(ttf);
    }
#line 273
    if (! (ch != -1)) {
#line 273
      goto while_break;
    }
    {
#line 274
    _IO_putc(ch, res);
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 275
  fclose(ttf);
  }
#line 276
  return (here);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned long const   binhex_crcinit___1  =    (unsigned long const   )0;
#line 8 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned short crctab___1[256]  = 
#line 8
  {      (unsigned short)0,      (unsigned short)4129,      (unsigned short)8258,      (unsigned short)12387, 
        (unsigned short)16516,      (unsigned short)20645,      (unsigned short)24774,      (unsigned short)28903, 
        (unsigned short)33032,      (unsigned short)37161,      (unsigned short)41290,      (unsigned short)45419, 
        (unsigned short)49548,      (unsigned short)53677,      (unsigned short)57806,      (unsigned short)61935, 
        (unsigned short)4657,      (unsigned short)528,      (unsigned short)12915,      (unsigned short)8786, 
        (unsigned short)21173,      (unsigned short)17044,      (unsigned short)29431,      (unsigned short)25302, 
        (unsigned short)37689,      (unsigned short)33560,      (unsigned short)45947,      (unsigned short)41818, 
        (unsigned short)54205,      (unsigned short)50076,      (unsigned short)62463,      (unsigned short)58334, 
        (unsigned short)9314,      (unsigned short)13379,      (unsigned short)1056,      (unsigned short)5121, 
        (unsigned short)25830,      (unsigned short)29895,      (unsigned short)17572,      (unsigned short)21637, 
        (unsigned short)42346,      (unsigned short)46411,      (unsigned short)34088,      (unsigned short)38153, 
        (unsigned short)58862,      (unsigned short)62927,      (unsigned short)50604,      (unsigned short)54669, 
        (unsigned short)13907,      (unsigned short)9842,      (unsigned short)5649,      (unsigned short)1584, 
        (unsigned short)30423,      (unsigned short)26358,      (unsigned short)22165,      (unsigned short)18100, 
        (unsigned short)46939,      (unsigned short)42874,      (unsigned short)38681,      (unsigned short)34616, 
        (unsigned short)63455,      (unsigned short)59390,      (unsigned short)55197,      (unsigned short)51132, 
        (unsigned short)18628,      (unsigned short)22757,      (unsigned short)26758,      (unsigned short)30887, 
        (unsigned short)2112,      (unsigned short)6241,      (unsigned short)10242,      (unsigned short)14371, 
        (unsigned short)51660,      (unsigned short)55789,      (unsigned short)59790,      (unsigned short)63919, 
        (unsigned short)35144,      (unsigned short)39273,      (unsigned short)43274,      (unsigned short)47403, 
        (unsigned short)23285,      (unsigned short)19156,      (unsigned short)31415,      (unsigned short)27286, 
        (unsigned short)6769,      (unsigned short)2640,      (unsigned short)14899,      (unsigned short)10770, 
        (unsigned short)56317,      (unsigned short)52188,      (unsigned short)64447,      (unsigned short)60318, 
        (unsigned short)39801,      (unsigned short)35672,      (unsigned short)47931,      (unsigned short)43802, 
        (unsigned short)27814,      (unsigned short)31879,      (unsigned short)19684,      (unsigned short)23749, 
        (unsigned short)11298,      (unsigned short)15363,      (unsigned short)3168,      (unsigned short)7233, 
        (unsigned short)60846,      (unsigned short)64911,      (unsigned short)52716,      (unsigned short)56781, 
        (unsigned short)44330,      (unsigned short)48395,      (unsigned short)36200,      (unsigned short)40265, 
        (unsigned short)32407,      (unsigned short)28342,      (unsigned short)24277,      (unsigned short)20212, 
        (unsigned short)15891,      (unsigned short)11826,      (unsigned short)7761,      (unsigned short)3696, 
        (unsigned short)65439,      (unsigned short)61374,      (unsigned short)57309,      (unsigned short)53244, 
        (unsigned short)48923,      (unsigned short)44858,      (unsigned short)40793,      (unsigned short)36728, 
        (unsigned short)37256,      (unsigned short)33193,      (unsigned short)45514,      (unsigned short)41451, 
        (unsigned short)53516,      (unsigned short)49453,      (unsigned short)61774,      (unsigned short)57711, 
        (unsigned short)4224,      (unsigned short)161,      (unsigned short)12482,      (unsigned short)8419, 
        (unsigned short)20484,      (unsigned short)16421,      (unsigned short)28742,      (unsigned short)24679, 
        (unsigned short)33721,      (unsigned short)37784,      (unsigned short)41979,      (unsigned short)46042, 
        (unsigned short)49981,      (unsigned short)54044,      (unsigned short)58239,      (unsigned short)62302, 
        (unsigned short)689,      (unsigned short)4752,      (unsigned short)8947,      (unsigned short)13010, 
        (unsigned short)16949,      (unsigned short)21012,      (unsigned short)25207,      (unsigned short)29270, 
        (unsigned short)46570,      (unsigned short)42443,      (unsigned short)38312,      (unsigned short)34185, 
        (unsigned short)62830,      (unsigned short)58703,      (unsigned short)54572,      (unsigned short)50445, 
        (unsigned short)13538,      (unsigned short)9411,      (unsigned short)5280,      (unsigned short)1153, 
        (unsigned short)29798,      (unsigned short)25671,      (unsigned short)21540,      (unsigned short)17413, 
        (unsigned short)42971,      (unsigned short)47098,      (unsigned short)34713,      (unsigned short)38840, 
        (unsigned short)59231,      (unsigned short)63358,      (unsigned short)50973,      (unsigned short)55100, 
        (unsigned short)9939,      (unsigned short)14066,      (unsigned short)1681,      (unsigned short)5808, 
        (unsigned short)26199,      (unsigned short)30326,      (unsigned short)17941,      (unsigned short)22068, 
        (unsigned short)55628,      (unsigned short)51565,      (unsigned short)63758,      (unsigned short)59695, 
        (unsigned short)39368,      (unsigned short)35305,      (unsigned short)47498,      (unsigned short)43435, 
        (unsigned short)22596,      (unsigned short)18533,      (unsigned short)30726,      (unsigned short)26663, 
        (unsigned short)6336,      (unsigned short)2273,      (unsigned short)14466,      (unsigned short)10403, 
        (unsigned short)52093,      (unsigned short)56156,      (unsigned short)60223,      (unsigned short)64286, 
        (unsigned short)35833,      (unsigned short)39896,      (unsigned short)43963,      (unsigned short)48026, 
        (unsigned short)19061,      (unsigned short)23124,      (unsigned short)27191,      (unsigned short)31254, 
        (unsigned short)2801,      (unsigned short)6864,      (unsigned short)10931,      (unsigned short)14994, 
        (unsigned short)64814,      (unsigned short)60687,      (unsigned short)56684,      (unsigned short)52557, 
        (unsigned short)48554,      (unsigned short)44427,      (unsigned short)40424,      (unsigned short)36297, 
        (unsigned short)31782,      (unsigned short)27655,      (unsigned short)23652,      (unsigned short)19525, 
        (unsigned short)15522,      (unsigned short)11395,      (unsigned short)7392,      (unsigned short)3265, 
        (unsigned short)61215,      (unsigned short)65342,      (unsigned short)53085,      (unsigned short)57212, 
        (unsigned short)44955,      (unsigned short)49082,      (unsigned short)36825,      (unsigned short)40952, 
        (unsigned short)28183,      (unsigned short)32310,      (unsigned short)20053,      (unsigned short)24180, 
        (unsigned short)11923,      (unsigned short)16050,      (unsigned short)3793,      (unsigned short)7920};
#line 43 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/crctab.c"
static unsigned long binhex_updcrc___1(unsigned long icrc , unsigned char *icp , int icnt ) 
{ 
  register unsigned long crc ;
  register unsigned char *cp ;
  register int cnt ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 50
  crc = icrc;
#line 51
  cp = icp;
#line 52
  cnt = icnt;
  {
#line 54
  while (1) {
    while_continue: /* CIL Label */ ;
#line 54
    tmp___0 = cnt;
#line 54
    cnt --;
#line 54
    if (! tmp___0) {
#line 54
      goto while_break;
    }
#line 55
    tmp = cp;
#line 55
    cp ++;
#line 55
    crc = ((crc << 8) & 65280UL) ^ (unsigned long )crctab___1[((crc >> 8) & 255UL) ^ (unsigned long )*tmp];
  }
  while_break: /* CIL Label */ ;
  }
#line 58
  return (crc);
}
}
#line 60 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/tomacbinary.c"
static void Usage___1(char *prog ) 
{ 


  {
  {
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s {[-res filename] [-create creat] [-type type] [filename]}\n",
          prog);
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -res filename\tProvides the name of a file whose data fork is to\n");
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tplaced in a resource fork\n");
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -create creat\tProvides a four character creator (if omitted on the\n");
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tmac this will be read from the datafile.\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -type type\tProvides a four character type (if omitted on the\n");
#line 67
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\t\t\tmac this will be read from the datafile.\n");
#line 68
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Takes a list of filenames and perhaps a list of resource forks\n");
#line 69
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"and puts the result into a list of macbinary files.\n");
#line 70
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"On the mac, if no resource fork file is specified and the datafork\n");
#line 71
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"file contains a resource fork, then it will be used as the resource\n");
#line 72
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"fork.\n");
#line 73
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"If no data filename is specified then the resource file will be\n");
#line 74
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"placed in the macbinary file without a data fork.\n");
#line 75
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The output filename will be the name of the data fork file with .bin\n");
#line 76
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"appended, or if there is no data fork file, then the resource fork file\n");
#line 77
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"with .bin appended.\n");
#line 78
  exit(1);
  }
}
}
#line 81 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/tomacbinary.c"
static FILE *ResForkOfDataFile(char *dataname ) 
{ 
  char *respath ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  FILE *temp ;

  {
  {
#line 84
  tmp = strlen((char const   *)dataname);
#line 84
  tmp___0 = strlen("/rsrc");
#line 84
  tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 84
  respath = (char *)tmp___1;
#line 87
  strcpy((char */* __restrict  */)respath, (char const   */* __restrict  */)dataname);
#line 88
  strcat((char */* __restrict  */)respath, (char const   */* __restrict  */)"/rsrc");
#line 89
  temp = fopen((char const   */* __restrict  */)respath, (char const   */* __restrict  */)"r");
#line 90
  free((void *)respath);
  }
#line 91
  return (temp);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/tomacbinary.c"
static char tbuf[5]  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/tomacbinary.c"
static void FindTypeCreater(char *dataname , char **create , char **type ) 
{ 
  int len ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
  {
#line 188
  tmp = strlen((char const   *)dataname);
#line 188
  len = (int )tmp;
  }
#line 189
  if ((unsigned long )*type == (unsigned long )((void *)0)) {
#line 190
    if (len > 4) {
      {
#line 190
      tmp___0 = strcmp((char const   *)((dataname + len) - 4), ".txt");
      }
#line 190
      if (tmp___0 == 0) {
        {
#line 194
        strcpy((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"TEXT");
#line 195
        *type = tbuf;
        }
      } else {
#line 190
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 190
    if (len > 4) {
      {
#line 190
      tmp___1 = strcmp((char const   *)((dataname + len) - 4), ".TXT");
      }
#line 190
      if (tmp___1 == 0) {
        {
#line 194
        strcpy((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"TEXT");
#line 195
        *type = tbuf;
        }
      } else {
#line 190
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 190
    if (len > 5) {
      {
#line 190
      tmp___2 = strcmp((char const   *)((dataname + len) - 5), ".text");
      }
#line 190
      if (tmp___2 == 0) {
        {
#line 194
        strcpy((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"TEXT");
#line 195
        *type = tbuf;
        }
      } else {
#line 190
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 190
    if (len > 5) {
      {
#line 190
      tmp___3 = strcmp((char const   *)((dataname + len) - 5), ".TEXT");
      }
#line 190
      if (tmp___3 == 0) {
        {
#line 194
        strcpy((char */* __restrict  */)(tbuf), (char const   */* __restrict  */)"TEXT");
#line 195
        *type = tbuf;
        }
      }
    }
  }
#line 199
  return;
}
}
#line 201 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/tomacbinary.c"
static void Dump(char *dataname , char *resname , char *create , char *type ) 
{ 
  FILE *datafile ;
  FILE *resfile ;
  FILE *outfile ;
  char *outname ;
  unsigned char header[128] ;
  unsigned char *hpt ;
  char *pt ;
  char *ept ;
  time_t now ;
  unsigned long dlen ;
  unsigned long rlen ;
  int i ;
  int crc ;
  int ch ;
  size_t tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  void *tmp___2 ;
  unsigned char *tmp___3 ;
  size_t tmp___4 ;
  unsigned char *tmp___5 ;
  unsigned char *tmp___6 ;
  char *tmp___7 ;
  unsigned char *tmp___8 ;
  unsigned char *tmp___9 ;
  unsigned char *tmp___10 ;
  unsigned char *tmp___11 ;
  unsigned char *tmp___12 ;
  unsigned char *tmp___13 ;
  unsigned char *tmp___14 ;
  unsigned char *tmp___15 ;
  unsigned char *tmp___16 ;
  unsigned char *tmp___17 ;
  unsigned char *tmp___18 ;
  unsigned char *tmp___19 ;
  unsigned char *tmp___20 ;
  unsigned char *tmp___21 ;
  unsigned char *tmp___22 ;
  unsigned char *tmp___23 ;
  unsigned char *tmp___24 ;
  unsigned char *tmp___25 ;
  unsigned char *tmp___26 ;
  long tmp___27 ;
  long tmp___28 ;
  unsigned char *tmp___29 ;
  unsigned char *tmp___30 ;
  unsigned char *tmp___31 ;
  unsigned char *tmp___32 ;
  unsigned char *tmp___33 ;
  unsigned char *tmp___34 ;
  unsigned char *tmp___35 ;
  unsigned char *tmp___36 ;
  unsigned char *tmp___37 ;
  unsigned char *tmp___38 ;
  unsigned char *tmp___39 ;
  unsigned char *tmp___40 ;
  unsigned char *tmp___41 ;
  unsigned char *tmp___42 ;
  unsigned char *tmp___43 ;
  unsigned char *tmp___44 ;
  unsigned char *tmp___45 ;
  unsigned char *tmp___46 ;
  unsigned char *tmp___47 ;
  unsigned long tmp___48 ;

  {
#line 202
  datafile = (FILE *)((void *)0);
#line 202
  resfile = (FILE *)((void *)0);
#line 209
  if ((unsigned long )dataname == (unsigned long )((void *)0)) {
#line 209
    if ((unsigned long )resname == (unsigned long )((void *)0)) {
#line 210
      return;
    }
  }
#line 211
  if ((unsigned long )dataname != (unsigned long )((void *)0)) {
    {
#line 212
    datafile = fopen((char const   */* __restrict  */)dataname, (char const   */* __restrict  */)"r");
    }
#line 213
    if ((unsigned long )datafile == (unsigned long )((void *)0)) {
      {
#line 214
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for reading\n",
              dataname);
#line 215
      exit(1);
      }
    }
    {
#line 217
    FindTypeCreater(dataname, & create, & type);
    }
  }
#line 219
  if ((unsigned long )resname != (unsigned long )((void *)0)) {
    {
#line 220
    resfile = fopen((char const   */* __restrict  */)resname, (char const   */* __restrict  */)"r");
    }
#line 221
    if ((unsigned long )resfile == (unsigned long )((void *)0)) {
      {
#line 222
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for reading\n",
              resname);
#line 223
      exit(1);
      }
    }
  } else {
    {
#line 226
    resfile = ResForkOfDataFile(dataname);
    }
  }
#line 228
  if ((unsigned long )dataname != (unsigned long )((void *)0)) {
    {
#line 229
    tmp = strlen((char const   *)dataname);
#line 229
    tmp___0 = malloc(tmp + 30UL);
#line 229
    outname = (char *)tmp___0;
#line 230
    strcpy((char */* __restrict  */)outname, (char const   */* __restrict  */)dataname);
#line 231
    strcat((char */* __restrict  */)outname, (char const   */* __restrict  */)".bin");
    }
  } else {
    {
#line 233
    tmp___1 = strlen((char const   *)resname);
#line 233
    tmp___2 = malloc(tmp___1 + 30UL);
#line 233
    outname = (char *)tmp___2;
#line 234
    strcpy((char */* __restrict  */)outname, (char const   */* __restrict  */)resname);
#line 235
    strcat((char */* __restrict  */)outname, (char const   */* __restrict  */)".bin");
    }
  }
  {
#line 237
  outfile = fopen((char const   */* __restrict  */)outname, (char const   */* __restrict  */)"w");
  }
#line 238
  if ((unsigned long )outfile == (unsigned long )((void *)0)) {
    {
#line 239
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s for writing\n",
            outname);
#line 240
    free((void *)outname);
    }
#line 241
    if (datafile) {
      {
#line 241
      fclose(datafile);
      }
    }
#line 242
    if (resfile) {
      {
#line 242
      fclose(resfile);
      }
    }
  }
  {
#line 245
  memset((void *)(header), '\000', sizeof(header));
#line 246
  hpt = header;
#line 247
  tmp___3 = hpt;
#line 247
  hpt ++;
#line 247
  *tmp___3 = (unsigned char )'\000';
  }
#line 249
  if (dataname) {
#line 249
    pt = dataname;
  } else {
#line 249
    pt = resname;
  }
  {
#line 250
  ept = strrchr((char const   *)pt, '/');
  }
#line 251
  if ((unsigned long )ept != (unsigned long )((void *)0)) {
#line 251
    pt = ept + 1;
  }
  {
#line 252
  tmp___4 = strlen((char const   *)pt);
#line 252
  ept = pt + tmp___4;
  }
#line 253
  if (ept - pt > 63L) {
#line 253
    ept = pt + 63;
  }
#line 254
  tmp___5 = hpt;
#line 254
  hpt ++;
#line 254
  *tmp___5 = (unsigned char )(ept - pt);
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! ((unsigned long )pt < (unsigned long )ept)) {
#line 255
      goto while_break;
    }
#line 256
    tmp___6 = hpt;
#line 256
    hpt ++;
#line 256
    tmp___7 = pt;
#line 256
    pt ++;
#line 256
    *tmp___6 = (unsigned char )*tmp___7;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 257
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 257
    if (! ((unsigned long )hpt < (unsigned long )(header + 65))) {
#line 257
      goto while_break___0;
    }
#line 258
    tmp___8 = hpt;
#line 258
    hpt ++;
#line 258
    *tmp___8 = (unsigned char )'\000';
  }
  while_break___0: /* CIL Label */ ;
  }
#line 260
  if ((unsigned long )type == (unsigned long )((void *)0)) {
#line 260
    type = (char *)"\000\000\000\000";
  }
#line 261
  if ((unsigned long )create == (unsigned long )((void *)0)) {
#line 261
    create = (char *)"\000\000\000\000";
  }
#line 263
  tmp___9 = hpt;
#line 263
  hpt ++;
#line 263
  *tmp___9 = (unsigned char )*(type + 0);
#line 263
  tmp___10 = hpt;
#line 263
  hpt ++;
#line 263
  *tmp___10 = (unsigned char )*(type + 1);
#line 263
  tmp___11 = hpt;
#line 263
  hpt ++;
#line 263
  *tmp___11 = (unsigned char )*(type + 2);
#line 263
  tmp___12 = hpt;
#line 263
  hpt ++;
#line 263
  *tmp___12 = (unsigned char )*(type + 3);
#line 265
  tmp___13 = hpt;
#line 265
  hpt ++;
#line 265
  *tmp___13 = (unsigned char )*(create + 0);
#line 265
  tmp___14 = hpt;
#line 265
  hpt ++;
#line 265
  *tmp___14 = (unsigned char )*(create + 1);
#line 265
  tmp___15 = hpt;
#line 265
  hpt ++;
#line 265
  *tmp___15 = (unsigned char )*(create + 2);
#line 265
  tmp___16 = hpt;
#line 265
  hpt ++;
#line 265
  *tmp___16 = (unsigned char )*(create + 3);
#line 266
  tmp___17 = hpt;
#line 266
  hpt ++;
#line 266
  *tmp___17 = (unsigned char )'\000';
#line 267
  tmp___18 = hpt;
#line 267
  hpt ++;
#line 267
  *tmp___18 = (unsigned char )'\000';
#line 268
  tmp___19 = hpt;
#line 268
  hpt ++;
#line 268
  *tmp___19 = (unsigned char )'\000';
#line 268
  tmp___20 = hpt;
#line 268
  hpt ++;
#line 268
  *tmp___20 = (unsigned char )'\000';
#line 269
  tmp___21 = hpt;
#line 269
  hpt ++;
#line 269
  *tmp___21 = (unsigned char )'\000';
#line 269
  tmp___22 = hpt;
#line 269
  hpt ++;
#line 269
  *tmp___22 = (unsigned char )'\000';
#line 270
  tmp___23 = hpt;
#line 270
  hpt ++;
#line 270
  *tmp___23 = (unsigned char )'\000';
#line 270
  tmp___24 = hpt;
#line 270
  hpt ++;
#line 270
  *tmp___24 = (unsigned char )'\000';
#line 271
  tmp___25 = hpt;
#line 271
  hpt ++;
#line 271
  *tmp___25 = (unsigned char )'\000';
#line 272
  tmp___26 = hpt;
#line 272
  hpt ++;
#line 272
  *tmp___26 = (unsigned char )'\000';
#line 274
  rlen = 0UL;
#line 274
  dlen = rlen;
#line 275
  if ((unsigned long )datafile != (unsigned long )((void *)0)) {
    {
#line 276
    fseek(datafile, 0L, 2);
#line 277
    tmp___27 = ftell(datafile);
#line 277
    dlen = (unsigned long )tmp___27;
#line 278
    fseek(datafile, 0L, 0);
    }
  }
#line 280
  if ((unsigned long )resfile != (unsigned long )((void *)0)) {
    {
#line 281
    fseek(resfile, 0L, 2);
#line 282
    tmp___28 = ftell(resfile);
#line 282
    rlen = (unsigned long )tmp___28;
#line 283
    fseek(resfile, 0L, 0);
    }
  }
  {
#line 286
  tmp___29 = hpt;
#line 286
  hpt ++;
#line 286
  *tmp___29 = (unsigned char )(dlen >> 24);
#line 286
  tmp___30 = hpt;
#line 286
  hpt ++;
#line 286
  *tmp___30 = (unsigned char )(dlen >> 16);
#line 286
  tmp___31 = hpt;
#line 286
  hpt ++;
#line 286
  *tmp___31 = (unsigned char )(dlen >> 8);
#line 286
  tmp___32 = hpt;
#line 286
  hpt ++;
#line 286
  *tmp___32 = (unsigned char )dlen;
#line 288
  tmp___33 = hpt;
#line 288
  hpt ++;
#line 288
  *tmp___33 = (unsigned char )(rlen >> 24);
#line 288
  tmp___34 = hpt;
#line 288
  hpt ++;
#line 288
  *tmp___34 = (unsigned char )(rlen >> 16);
#line 288
  tmp___35 = hpt;
#line 288
  hpt ++;
#line 288
  *tmp___35 = (unsigned char )(rlen >> 8);
#line 288
  tmp___36 = hpt;
#line 288
  hpt ++;
#line 288
  *tmp___36 = (unsigned char )rlen;
#line 291
  time(& now);
#line 293
  now += 2081376000L;
#line 294
  i = 1904;
  }
  {
#line 294
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 294
    if (! (i < 1970)) {
#line 294
      goto while_break___1;
    }
#line 295
    now += 86400L;
#line 294
    i += 4;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 297
  tmp___37 = hpt;
#line 297
  hpt ++;
#line 297
  *tmp___37 = (unsigned char )(now >> 24);
#line 297
  tmp___38 = hpt;
#line 297
  hpt ++;
#line 297
  *tmp___38 = (unsigned char )(now >> 16);
#line 297
  tmp___39 = hpt;
#line 297
  hpt ++;
#line 297
  *tmp___39 = (unsigned char )(now >> 8);
#line 297
  tmp___40 = hpt;
#line 297
  hpt ++;
#line 297
  *tmp___40 = (unsigned char )now;
#line 299
  tmp___41 = hpt;
#line 299
  hpt ++;
#line 299
  *tmp___41 = (unsigned char )(now >> 24);
#line 299
  tmp___42 = hpt;
#line 299
  hpt ++;
#line 299
  *tmp___42 = (unsigned char )(now >> 16);
#line 299
  tmp___43 = hpt;
#line 299
  hpt ++;
#line 299
  *tmp___43 = (unsigned char )(now >> 8);
#line 299
  tmp___44 = hpt;
#line 299
  hpt ++;
#line 299
  *tmp___44 = (unsigned char )now;
#line 301
  tmp___45 = hpt;
#line 301
  hpt ++;
#line 301
  *tmp___45 = (unsigned char )'\000';
#line 301
  tmp___46 = hpt;
#line 301
  hpt ++;
#line 301
  *tmp___46 = (unsigned char )'\000';
#line 302
  tmp___47 = hpt;
#line 302
  hpt ++;
#line 302
  *tmp___47 = (unsigned char)0;
#line 305
  memcpy((void */* __restrict  */)(header + 102), (void const   */* __restrict  */)"mBIN",
         (size_t )4);
#line 306
  header[106] = (unsigned char)0;
#line 307
  header[107] = (unsigned char)0;
#line 309
  header[122] = (unsigned char)130;
#line 310
  header[123] = (unsigned char)129;
#line 312
  tmp___48 = binhex_crc(header, 124);
#line 312
  crc = (int )tmp___48;
#line 313
  header[124] = (unsigned char )(crc >> 8);
#line 314
  header[125] = (unsigned char )crc;
#line 316
  fwrite((void const   */* __restrict  */)(header), (size_t )1, sizeof(header), (FILE */* __restrict  */)outfile);
  }
#line 317
  if (datafile) {
    {
#line 318
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 318
      ch = _IO_getc(datafile);
      }
#line 318
      if (! (ch != -1)) {
#line 318
        goto while_break___2;
      }
      {
#line 319
      _IO_putc(ch, outfile);
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 320
    while (1) {
      while_continue___3: /* CIL Label */ ;
#line 320
      if (! ((dlen & 127UL) != 0UL)) {
#line 320
        goto while_break___3;
      }
      {
#line 321
      _IO_putc('\000', outfile);
#line 321
      dlen ++;
      }
    }
    while_break___3: /* CIL Label */ ;
    }
    {
#line 322
    fclose(datafile);
    }
  }
#line 324
  if (resfile) {
    {
#line 325
    while (1) {
      while_continue___4: /* CIL Label */ ;
      {
#line 325
      ch = _IO_getc(resfile);
      }
#line 325
      if (! (ch != -1)) {
#line 325
        goto while_break___4;
      }
      {
#line 326
      _IO_putc(ch, outfile);
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 327
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 327
      if (! ((rlen & 127UL) != 0UL)) {
#line 327
        goto while_break___5;
      }
      {
#line 328
      _IO_putc('\000', outfile);
#line 328
      rlen ++;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 329
    fclose(resfile);
    }
  }
#line 331
  return;
}
}
#line 180 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rename)(char const   *__old ,
                                                                             char const   *__new ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 538
extern int getchar(void) ;
#line 287 "/usr/include/unistd.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) access)(char const   *__name ,
                                                                                             int __type ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 264 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) ctime)(time_t const   *__timer ) ;
#line 178 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) ceil)(double __x )  __attribute__((__const__)) ;
#line 184
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) floor)(double __x )  __attribute__((__const__)) ;
#line 84 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/macfonts.h"
int tolatin1 ;
#line 85
char const   *macnames[257] ;
#line 86
char const   *styles[8] ;
#line 90
int cleanfilename(char *filename ) ;
#line 92
void SearchNFNTResources(FILE *f , long rlistpos , int subcnt , long rdata_pos , long name_list ,
                         FOND *fonds ) ;
#line 95
void ParsePfb(FILE *pfb , PSFONT *psfont ) ;
#line 38 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
int tolatin1  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int force  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int inquire  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int doafm  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int trackps  =    0;
#line 39 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int show  =    0;
#line 59 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int _cleanfilename(char *filename ) 
{ 
  char *pt ;
  char *npt ;
  int ch ;
  int exists ;
  int ch2 ;
  char *tmp ;
  int tmp___0 ;
  int tmp___1 ;
  char *tmp___2 ;

  {
#line 63
  npt = filename;
#line 63
  pt = npt;
#line 63
  ch = (int )*pt;
  {
#line 63
  while (1) {
    while_continue: /* CIL Label */ ;
#line 63
    if (! (ch != 0)) {
#line 63
      goto while_break;
    }
#line 64
    if (ch > 33) {
#line 64
      if (ch != 42) {
#line 64
        if (ch != 63) {
#line 64
          if (ch != 47) {
#line 64
            if (ch != 92) {
#line 64
              if (ch != 91) {
#line 64
                if (ch < 127) {
#line 65
                  tmp = npt;
#line 65
                  npt ++;
#line 65
                  *tmp = (char )ch;
                }
              }
            }
          }
        }
      }
    }
#line 63
    pt ++;
#line 63
    ch = (int )*pt;
  }
  while_break: /* CIL Label */ ;
  }
#line 67
  *npt = (char )'\000';
#line 68
  if (force) {
#line 68
    if (! inquire) {
#line 69
      return (1);
    }
  }
  {
#line 71
  tmp___0 = access((char const   *)filename, 0);
#line 71
  exists = tmp___0 == 0;
  }
  {
#line 73
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 74
    if (exists) {
      {
#line 75
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s exists, do you want to overwrite it? (n) ",
              filename);
      }
    } else
#line 76
    if (inquire) {
      {
#line 77
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Write %s? (y) ",
              filename);
      }
    } else {
#line 79
      return (1);
    }
    {
#line 80
    ch = getchar();
    }
#line 81
    if (ch == 113) {
      {
#line 82
      exit(0);
      }
    } else
#line 81
    if (ch == 81) {
      {
#line 82
      exit(0);
      }
    }
#line 83
    if (ch == 97) {
#line 84
      force = 1;
#line 85
      inquire = 0;
#line 86
      return (1);
    } else
#line 83
    if (ch == 65) {
#line 84
      force = 1;
#line 85
      inquire = 0;
#line 86
      return (1);
    }
#line 88
    if (ch == 121) {
#line 88
      goto _L___0;
    } else
#line 88
    if (ch == 89) {
#line 88
      goto _L___0;
    } else
#line 88
    if (ch == 110) {
#line 88
      goto _L___0;
    } else
#line 88
    if (ch == 78) {
#line 88
      goto _L___0;
    } else
#line 88
    if (ch == -1) {
#line 88
      goto _L___0;
    } else
#line 88
    if (ch == 10) {
      _L___0: /* CIL Label */ 
#line 89
      if (ch == 10) {
#line 89
        goto _L;
      } else
#line 89
      if (ch == -1) {
        _L: /* CIL Label */ 
#line 90
        if (exists) {
#line 90
          ch = 'n';
        } else {
#line 90
          ch = 'y';
        }
      } else {
        {
#line 92
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 92
          ch2 = getchar();
          }
#line 92
          if (ch2 != 10) {
#line 92
            if (! (ch2 != -1)) {
#line 92
              goto while_break___1;
            }
          } else {
#line 92
            goto while_break___1;
          }
        }
        while_break___1: /* CIL Label */ ;
        }
      }
#line 93
      if (ch == 121) {
#line 93
        tmp___1 = 1;
      } else
#line 93
      if (ch == 89) {
#line 93
        tmp___1 = 1;
      } else {
#line 93
        tmp___1 = 0;
      }
#line 93
      return (tmp___1);
    } else
#line 94
    if (ch == 61) {
#line 95
      pt = filename;
      {
#line 95
      while (1) {
        while_continue___2: /* CIL Label */ ;
        {
#line 95
        ch = getchar();
        }
#line 95
        if (ch != -1) {
#line 95
          if (! (ch != 10)) {
#line 95
            goto while_break___2;
          }
        } else {
#line 95
          goto while_break___2;
        }
#line 96
        tmp___2 = pt;
#line 96
        pt ++;
#line 96
        *tmp___2 = (char )ch;
      }
      while_break___2: /* CIL Label */ ;
      }
#line 97
      return (1);
    } else {
      {
#line 99
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Please answer with \'y\'(es), \'n\'(o), \'q\'(uit), \'a\'(ll), or \'=new-filename\'.\n");
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
int cleanfilename(char *filename ) 
{ 
  int ret ;
  int tmp ;

  {
  {
#line 105
  tmp = _cleanfilename(filename);
#line 105
  ret = tmp;
  }
#line 106
  if (ret) {
#line 106
    if (show) {
      {
#line 107
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Creating %s\n",
              filename);
      }
    }
  }
#line 108
  return (ret);
}
}
#line 112 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int upos  ;
#line 111 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static void mytmpname(char *temp ) 
{ 
  __pid_t tmp ;
  int tmp___0 ;

  {
  {
#line 115
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 116
    upos ++;
#line 116
    tmp = getpid();
#line 116
    sprintf((char */* __restrict  */)temp, (char const   */* __restrict  */)"fondu%04X-%d",
            tmp, upos);
#line 117
    tmp___0 = access((char const   *)temp, 0);
    }
#line 117
    if (tmp___0 == -1) {
#line 118
      return;
    }
  }
  while_break: /* CIL Label */ ;
  }
}
}
#line 131 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static char *FileNameFromPSFontName(char *fontname ) 
{ 
  char *filename ;
  char *tmp ;
  char *pt ;
  char *spt ;
  char *lcpt ;
  char *tmp___0 ;
  char *tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;

  {
  {
#line 132
  tmp = strdup((char const   *)fontname);
#line 132
  filename = tmp;
#line 135
  pt = filename;
#line 135
  spt = fontname;
  }
  {
#line 135
  while (1) {
    while_continue: /* CIL Label */ ;
#line 135
    if (! *spt) {
#line 135
      goto while_break;
    }
    {
#line 136
    tmp___4 = __ctype_b_loc();
    }
#line 136
    if ((int const   )*(*tmp___4 + (int )*spt) & 256) {
#line 136
      goto _L___0;
    } else
#line 136
    if ((unsigned long )spt == (unsigned long )fontname) {
      _L___0: /* CIL Label */ 
#line 137
      tmp___0 = pt;
#line 137
      pt ++;
#line 137
      *tmp___0 = *spt;
#line 138
      if ((unsigned long )spt == (unsigned long )fontname) {
#line 138
        lcpt = spt + 5;
      } else {
#line 138
        lcpt = spt + 3;
      }
    } else {
      {
#line 139
      tmp___2 = __ctype_b_loc();
      }
#line 139
      if ((int const   )*(*tmp___2 + (int )*spt) & 512) {
#line 139
        goto _L;
      } else {
        {
#line 139
        tmp___3 = __ctype_b_loc();
        }
#line 139
        if ((int const   )*(*tmp___3 + (int )*spt) & 2048) {
          _L: /* CIL Label */ 
#line 139
          if ((unsigned long )spt < (unsigned long )lcpt) {
#line 140
            tmp___1 = pt;
#line 140
            pt ++;
#line 140
            *tmp___1 = *spt;
          }
        }
      }
    }
#line 135
    spt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 142
  *pt = (char )'\000';
#line 143
  return (filename);
}
}
#line 146
static int IsResourceInFile___1(char *filename , PSFONT *psfont ) ;
#line 148 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static void ProcessNestedPS(char *fontname , char *origfilename , PSFONT *psfont ) 
{ 
  char *filename ;
  char *tmp ;
  char *dirend ;
  char *tmp___0 ;
  char *newfn ;
  size_t tmp___1 ;
  size_t tmp___2 ;
  void *tmp___3 ;
  char *end___0 ;
  size_t tmp___4 ;
  void *tmp___5 ;
  size_t tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *pt ;
  char *tmp___10 ;
  char *ept ;
  char *tmp___11 ;

  {
  {
#line 149
  tmp = FileNameFromPSFontName(fontname);
#line 149
  filename = tmp;
  }
#line 151
  if ((unsigned long )filename != (unsigned long )((void *)0)) {
#line 151
    if ((int )*filename != 0) {
      {
#line 152
      tmp___0 = strrchr((char const   *)origfilename, '/');
#line 152
      dirend = tmp___0;
      }
#line 153
      if ((unsigned long )dirend != (unsigned long )((void *)0)) {
        {
#line 154
        tmp___1 = strlen((char const   *)filename);
#line 154
        tmp___2 = strlen((char const   *)origfilename);
#line 154
        tmp___3 = malloc((tmp___1 + tmp___2) + 1UL);
#line 154
        newfn = (char *)tmp___3;
#line 155
        strcpy((char */* __restrict  */)newfn, (char const   */* __restrict  */)origfilename);
#line 156
        strcpy((char */* __restrict  */)((newfn + (dirend - origfilename)) + 1), (char const   */* __restrict  */)filename);
#line 157
        free((void *)filename);
#line 158
        filename = newfn;
        }
      }
      {
#line 160
      tmp___9 = access((char const   *)filename, 4);
      }
#line 160
      if (tmp___9 == 0) {
        {
#line 161
        IsResourceInFile___1(filename, psfont);
        }
      } else {
        {
#line 164
        tmp___4 = strlen((char const   *)filename);
#line 164
        tmp___5 = realloc((void *)filename, tmp___4 + 10UL);
#line 164
        filename = (char *)tmp___5;
#line 165
        tmp___6 = strlen((char const   *)filename);
#line 165
        end___0 = filename + tmp___6;
#line 166
        strcpy((char */* __restrict  */)end___0, (char const   */* __restrict  */)".bin");
#line 167
        tmp___8 = access((char const   *)filename, 4);
        }
#line 167
        if (tmp___8 == 0) {
          {
#line 168
          IsResourceInFile___1(filename, psfont);
          }
        } else {
          {
#line 170
          strcpy((char */* __restrict  */)end___0, (char const   */* __restrict  */)".hqx");
#line 171
          tmp___7 = access((char const   *)filename, 4);
          }
#line 171
          if (tmp___7 == 0) {
            {
#line 172
            IsResourceInFile___1(filename, psfont);
            }
          }
        }
      }
    }
  }
#line 176
  if ((unsigned long )psfont != (unsigned long )((void *)0)) {
#line 176
    if ((unsigned long )psfont->fontname == (unsigned long )((void *)0)) {
      {
#line 177
      tmp___10 = strrchr((char const   *)filename, '.');
#line 177
      pt = tmp___10;
#line 178
      tmp___11 = strrchr((char const   *)filename, '/');
#line 178
      ept = tmp___11;
      }
#line 179
      if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 179
        if ((unsigned long )pt > (unsigned long )ept) {
#line 179
          *pt = (char )'\000';
        }
      }
      {
#line 180
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to find file %s when searching for a postscript resource\n",
              filename);
      }
    }
  }
  {
#line 182
  free((void *)filename);
  }
#line 183
  return;
}
}
#line 185 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static FILE *CreateAfmFile(FILE *f , FOND *fond , int style , char *fontname , char *familyname ,
                           PSFONT *psfont , char *origfilename ) 
{ 
  char namebuf[300] ;
  int i ;
  FILE *afm ;
  char *fn ;
  int tmp ;

  {
  {
#line 191
  memset((void *)psfont, 0, sizeof(PSFONT ));
  }
#line 192
  if (! (style & 4)) {
#line 192
    if ((unsigned long )fond->psnames[(style & 3) | ((style & -8) >> 1)] != (unsigned long )((void *)0)) {
      {
#line 194
      fn = fond->psnames[(style & 3) | ((style & -8) >> 1)];
#line 195
      strcpy((char */* __restrict  */)familyname, (char const   */* __restrict  */)fond->family);
#line 196
      strcpy((char */* __restrict  */)fontname, (char const   */* __restrict  */)fn);
#line 197
      ProcessNestedPS(fn, origfilename, psfont);
      }
#line 198
      if ((unsigned long )psfont->familyname != (unsigned long )((void *)0)) {
        {
#line 199
        strcpy((char */* __restrict  */)familyname, (char const   */* __restrict  */)psfont->familyname);
        }
      }
    } else {
#line 192
      goto _L;
    }
  } else {
    _L: /* CIL Label */ 
#line 201
    if ((unsigned long )fond->family != (unsigned long )((void *)0)) {
      {
#line 202
      strcpy((char */* __restrict  */)familyname, (char const   */* __restrict  */)fond->family);
      }
    } else
#line 203
    if ((unsigned long )fond->fondname != (unsigned long )((void *)0)) {
      {
#line 204
      strcpy((char */* __restrict  */)familyname, (char const   */* __restrict  */)fond->fondname);
      }
    } else {
      {
#line 206
      strcpy((char */* __restrict  */)familyname, (char const   */* __restrict  */)"Nameless");
      }
    }
    {
#line 207
    strcpy((char */* __restrict  */)fontname, (char const   */* __restrict  */)familyname);
#line 208
    i = 0;
    }
    {
#line 208
    while (1) {
      while_continue: /* CIL Label */ ;
#line 208
      if (! ((unsigned long )styles[i] != (unsigned long )((void *)0))) {
#line 208
        goto while_break;
      }
#line 209
      if (style & (1 << i)) {
        {
#line 210
        strcat((char */* __restrict  */)fontname, (char const   */* __restrict  */)styles[i]);
        }
      }
#line 208
      i ++;
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 212
  strcpy((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)fontname);
#line 213
  strcat((char */* __restrict  */)(namebuf), (char const   */* __restrict  */)".afm");
#line 214
  tmp = cleanfilename(namebuf);
  }
#line 214
  if (! tmp) {
#line 215
    return ((FILE *)((void *)0));
  }
  {
#line 216
  afm = fopen((char const   */* __restrict  */)(namebuf), (char const   */* __restrict  */)"w");
  }
#line 217
  if ((unsigned long )afm == (unsigned long )((void *)0)) {
    {
#line 218
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s\n",
            namebuf);
    }
  }
#line 219
  return (afm);
}
}
#line 222 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static void AfmBB(FILE *afm , struct bbglyph *bb , int enc , double em ) 
{ 
  double tmp ;
  double tmp___0 ;
  double tmp___1 ;
  double tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 223
  fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"C %d ; WX %d ; ",
          enc, (int )((double )(bb->hadvance * 1000) / em));
#line 224
  tmp = ceil((double )(bb->top * 1000) / em);
#line 224
  tmp___0 = ceil((double )(bb->right * 1000) / em);
#line 224
  tmp___1 = floor((double )(bb->bottom * 1000) / em);
#line 224
  tmp___2 = floor((double )(bb->left * 1000) / em);
#line 224
  fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"N %s ; B %d %d %d %d ;",
          bb->glyphname, (int )tmp___2, (int )tmp___1, (int )tmp___0, (int )tmp);
#line 228
  tmp___5 = strcmp((char const   *)bb->glyphname, "fi");
  }
#line 228
  if (tmp___5 == 0) {
    {
#line 229
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)" L f i ;");
    }
  } else {
    {
#line 230
    tmp___4 = strcmp((char const   *)bb->glyphname, "fl");
    }
#line 230
    if (tmp___4 == 0) {
      {
#line 231
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)" L f l ;");
      }
    } else {
      {
#line 232
      tmp___3 = strcmp((char const   *)bb->glyphname, "ff");
      }
#line 232
      if (tmp___3 == 0) {
        {
#line 233
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)" L f f ;");
        }
      }
    }
  }
  {
#line 234
  _IO_putc('\n', afm);
  }
#line 235
  return;
}
}
#line 237 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static void MakeAfmFiles(FOND *fond , FILE *f , int isfixed , char *origfilename ) 
{ 
  long start ;
  long tmp ;
  int ii ;
  int i ;
  int j ;
  int k ;
  int l ;
  int dups ;
  FILE *afm ;
  time_t now ;
  char fontname[256] ;
  char familyname[256] ;
  char buffer___0[32] ;
  PSFONT psfont ;
  int style ;
  char *tmp___0 ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  char const   *tmp___7 ;
  char const   *name ;
  int tmp___8 ;
  char const   *name1 ;
  char const   *name2 ;
  struct kerns *kp ;

  {
  {
#line 238
  tmp = ftell(f);
#line 238
  start = tmp;
#line 246
  ii = 0;
  }
  {
#line 246
  while (1) {
    while_continue: /* CIL Label */ ;
#line 246
    if (! (ii < 48)) {
#line 246
      goto while_break;
    }
#line 247
    style = (ii & 3) | ((ii & -4) << 1);
#line 248
    i = fond->stylekerncnt - 1;
    {
#line 248
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 248
      if (! (i >= 0)) {
#line 248
        goto while_break___0;
      }
#line 249
      if ((int )(fond->stylekerns + i)->style == style) {
#line 250
        goto while_break___0;
      }
#line 248
      i --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 251
    if (i == -1) {
#line 251
      if ((unsigned long )fond->psnames[ii] == (unsigned long )((void *)0)) {
#line 252
        goto __Cont;
      }
    }
    {
#line 253
    afm = CreateAfmFile(f, fond, style, fontname, familyname, & psfont, origfilename);
    }
#line 255
    if ((unsigned long )afm == (unsigned long )((void *)0)) {
#line 256
      goto __Cont;
    }
    {
#line 257
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"StartFontMetrics 2.0\n");
    }
#line 258
    if ((unsigned long )psfont.fontname == (unsigned long )((void *)0)) {
      {
#line 259
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Comment Caveat: This does not contain all the information generally found in an AFM file\n");
      }
    }
    {
#line 260
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Comment Generated by Fondu from a mac FOND resource\n");
#line 261
    time(& now);
#line 262
    tmp___0 = ctime((time_t const   *)(& now));
#line 262
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Comment Creation Date: %s",
            tmp___0);
#line 263
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"FontName %s\n",
            fontname);
#line 264
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"FamilyName %s\n",
            familyname);
    }
#line 265
    if (isfixed) {
#line 265
      tmp___1 = "true";
    } else {
#line 265
      tmp___1 = "false";
    }
    {
#line 265
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"IsFixedPitch %s\n",
            tmp___1);
    }
#line 266
    if ((unsigned long )psfont.fontname != (unsigned long )((void *)0)) {
#line 267
      if (psfont.fullname) {
        {
#line 268
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"FullName %s\n",
                psfont.fullname);
        }
      }
#line 269
      if (psfont.weight) {
        {
#line 270
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Weight %s\n",
                psfont.weight);
        }
      }
#line 271
      if (psfont.notice) {
        {
#line 272
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Notice (%s)\n",
                psfont.notice);
        }
      }
#line 273
      if (psfont.version) {
        {
#line 274
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Version (%s)\n",
                psfont.version);
        }
      }
      {
#line 275
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"ItalicAngle %g\n",
              psfont.italicangle);
      }
#line 276
      if (psfont.isadobestd) {
#line 276
        tmp___2 = "AdobeStandardEncoding";
      } else {
#line 276
        tmp___2 = "FontSpecific";
      }
      {
#line 276
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"EncodingScheme %s\n",
              tmp___2);
#line 278
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"FontBBox %g %g %g %g\n",
              psfont.fbb[0], psfont.fbb[1], psfont.fbb[2], psfont.fbb[3]);
      }
#line 280
      if (psfont.xh != 0) {
        {
#line 281
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"XHeight %d\n",
                psfont.xh);
        }
      }
#line 282
      if (psfont.ch != 0) {
        {
#line 283
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"CapHeight %d\n",
                psfont.ch);
        }
      }
#line 284
      if (psfont.as != 0) {
        {
#line 285
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Ascender %d\n",
                psfont.as);
        }
      }
#line 286
      if (psfont.ds != 0) {
        {
#line 287
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Descender %d\n",
                psfont.ds);
        }
      }
#line 288
      dups = 0;
#line 289
      k = 0;
      {
#line 289
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 289
        if (! (k < 256)) {
#line 289
          goto while_break___1;
        }
        {
#line 290
        tmp___3 = strcmp((char const   *)(psfont.glyphs + psfont.encoding[k])->glyphname,
                         ".notdef");
        }
#line 290
        if (tmp___3 == 0) {
#line 290
          if ((psfont.glyphs + 0)->isref) {
#line 291
            goto __Cont___0;
          }
        }
#line 292
        l = psfont.glyphcnt - 1;
        {
#line 292
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 292
          if (! (l >= 0)) {
#line 292
            goto while_break___2;
          }
          {
#line 293
          tmp___4 = strcmp((char const   *)(psfont.glyphs + psfont.encoding[k])->glyphname,
                           (char const   *)(psfont.glyphs + l)->glyphname);
          }
#line 293
          if (tmp___4 == 0) {
#line 294
            goto while_break___2;
          }
#line 292
          l --;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 295
        if (! (l == -1)) {
#line 297
          if (! (psfont.glyphs + l)->isref) {
#line 298
            (psfont.glyphs + l)->isref = 1;
          } else {
#line 300
            dups ++;
          }
        }
        __Cont___0: /* CIL Label */ 
#line 289
        k ++;
      }
      while_break___1: /* CIL Label */ ;
      }
      {
#line 302
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"StartCharMetrics %d\n",
              psfont.glyphcnt + dups);
#line 303
      (psfont.glyphs + 0)->isref = 0;
#line 304
      k = 0;
      }
      {
#line 304
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 304
        if (! (k < 256)) {
#line 304
          goto while_break___3;
        }
        {
#line 305
        tmp___5 = strcmp((char const   *)(psfont.glyphs + psfont.encoding[k])->glyphname,
                         ".notdef");
        }
#line 305
        if (tmp___5 == 0) {
#line 305
          if ((psfont.glyphs + 0)->isref) {
#line 306
            goto __Cont___1;
          }
        }
#line 307
        l = psfont.glyphcnt - 1;
        {
#line 307
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 307
          if (! (l >= 0)) {
#line 307
            goto while_break___4;
          }
          {
#line 308
          tmp___6 = strcmp((char const   *)(psfont.glyphs + psfont.encoding[k])->glyphname,
                           (char const   *)(psfont.glyphs + l)->glyphname);
          }
#line 308
          if (tmp___6 == 0) {
#line 309
            goto while_break___4;
          }
#line 307
          l --;
        }
        while_break___4: /* CIL Label */ ;
        }
#line 310
        if (l == -1) {
#line 311
          goto __Cont___1;
        }
        {
#line 312
        AfmBB(afm, psfont.glyphs + l, k, psfont.em);
#line 313
        (psfont.glyphs + l)->isref = 1;
        }
        __Cont___1: /* CIL Label */ 
#line 304
        k ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 315
      l = 0;
      {
#line 315
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 315
        if (! (l < psfont.glyphcnt)) {
#line 315
          goto while_break___5;
        }
#line 315
        if (! (psfont.glyphs + l)->isref) {
          {
#line 316
          AfmBB(afm, psfont.glyphs + l, -1, psfont.em);
          }
        }
#line 315
        l ++;
      }
      while_break___5: /* CIL Label */ ;
      }
    } else {
#line 318
      if (style & 1) {
#line 318
        tmp___7 = "Bold";
      } else {
#line 318
        tmp___7 = "Medium";
      }
      {
#line 318
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"Weight %s\n",
              tmp___7);
      }
#line 319
      if (! (style & 2)) {
        {
#line 320
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"ItalicAngle 0\n");
        }
      }
      {
#line 321
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"EncodingScheme FontSpecific\n");
#line 326
      j = fond->stylewidthcnt - 1;
      }
      {
#line 326
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 326
        if (! (j >= 0)) {
#line 326
          goto while_break___6;
        }
#line 327
        if (style == (int )(fond->stylewidths + j)->style) {
#line 328
          goto while_break___6;
        }
#line 326
        j --;
      }
      while_break___6: /* CIL Label */ ;
      }
#line 329
      if (j != -1) {
        {
#line 330
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"StartCharMetrics %d\n",
                (fond->last - fond->first) + 1);
#line 331
        k = fond->first;
        }
        {
#line 331
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 331
          if (! (k <= fond->last)) {
#line 331
            goto while_break___7;
          }
#line 333
          if (k <= 256) {
#line 333
            if ((unsigned long )macnames[k] != (unsigned long )((void *)0)) {
#line 334
              name = macnames[k];
            } else {
              {
#line 336
              sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"char%04x",
                      k);
#line 337
              name = (char const   *)(buffer___0);
              }
            }
          } else {
            {
#line 336
            sprintf((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)"char%04x",
                    k);
#line 337
            name = (char const   *)(buffer___0);
            }
          }
#line 339
          if (k >= 256) {
#line 339
            tmp___8 = -1;
          } else {
#line 339
            tmp___8 = k;
          }
          {
#line 339
          fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"C %d ; WX %d ; N %s ;\n",
                  tmp___8, ((int )*((fond->stylewidths + j)->widthtab + (k - fond->first)) * 1000 + (1 << 11)) >> 12,
                  name);
#line 331
          k ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
      } else {
        {
#line 345
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"StartCharMetrics 0\n");
        }
      }
    }
    {
#line 347
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"EndCharMetrics\n");
    }
#line 348
    if (i != -1) {
      {
#line 351
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"StartKernData\nStartKernPairs %d\n",
              (fond->stylekerns + i)->kernpairs);
#line 353
      k = 0;
      }
      {
#line 353
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 353
        if (! (k < (fond->stylekerns + i)->kernpairs)) {
#line 353
          goto while_break___8;
        }
#line 355
        kp = (fond->stylekerns + i)->kerns + k;
#line 357
        name1 = macnames[kp->ch1];
#line 362
        if ((unsigned long )name1 == (unsigned long )((void *)0)) {
#line 362
          name1 = ".notdef";
        }
#line 364
        name2 = macnames[kp->ch2];
#line 369
        if ((unsigned long )name2 == (unsigned long )((void *)0)) {
#line 369
          name2 = ".notdef";
        }
        {
#line 370
        fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"KPX %s %s %d\n",
                name1, name2, ((int )kp->offset * 1000 + (1 << 11)) >> 12);
#line 353
        k ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 372
      fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"EndKernPairs\nEndKernData\n");
      }
    }
    {
#line 374
    fprintf((FILE */* __restrict  */)afm, (char const   */* __restrict  */)"EndFontMetrics\n");
#line 375
    fclose(afm);
    }
    __Cont: /* CIL Label */ 
#line 246
    ii ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 377
  fseek(f, start, 0);
  }
#line 378
  return;
}
}
#line 388 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static FOND *BuildFondList(FILE *f , long rlistpos , int subcnt , long rdata_pos ,
                           long name_list , char *origfilename ) 
{ 
  long here ;
  long start ;
  long tmp ;
  long offset ;
  int rname ;
  char name[300] ;
  int ch1 ;
  int ch2 ;
  int i ;
  int j ;
  int k ;
  int cnt ;
  int isfixed ;
  FOND *head ;
  FOND *cur ;
  long widoff ;
  long kernoff ;
  long styleoff ;
  int tmp___0 ;
  int tmp___1 ;
  void *tmp___2 ;
  int tmp___4 ;
  int tmp___5 ;
  void *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  void *tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  void *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  unsigned char stringoffsets[48] ;
  int strcnt ;
  int strlength ;
  int format ;
  char **strings ;
  char *pt ;
  int tmp___22 ;
  void *tmp___23 ;
  void *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  void *tmp___27 ;

  {
  {
#line 390
  tmp = ftell(f);
#line 390
  start = tmp;
#line 392
  rname = -1;
#line 396
  head = (FOND *)((void *)0);
#line 399
  fseek(f, rlistpos, 0);
#line 400
  i = 0;
  }
  {
#line 400
  while (1) {
    while_continue: /* CIL Label */ ;
#line 400
    if (! (i < subcnt)) {
#line 400
      goto while_break;
    }
    {
#line 401
    getushort(f);
#line 402
    tmp___0 = getushort(f);
#line 402
    rname = (int )((short )tmp___0);
#line 403
    _IO_getc(f);
#line 404
    ch1 = _IO_getc(f);
#line 404
    ch2 = _IO_getc(f);
#line 405
    tmp___1 = _IO_getc(f);
#line 405
    offset = rdata_pos + (long )(((ch1 << 16) | (ch2 << 8)) | tmp___1);
#line 406
    getlong(f);
#line 407
    here = ftell(f);
#line 409
    tmp___2 = calloc((size_t )1, sizeof(FOND ));
#line 409
    cur = (FOND *)tmp___2;
#line 410
    cur->next = head;
#line 411
    head = cur;
    }
#line 413
    if (rname != -1) {
      {
#line 414
      fseek(f, name_list + (long )rname, 0);
#line 415
      ch1 = _IO_getc(f);
#line 416
      fread((void */* __restrict  */)(name), (size_t )1, (size_t )ch1, (FILE */* __restrict  */)f);
#line 417
      name[ch1] = (char )'\000';
#line 418
      cur->fondname = strdup((char const   *)(name));
      }
    }
    {
#line 421
    offset += 4L;
#line 422
    fseek(f, offset, 0);
#line 423
    tmp___4 = getushort(f);
    }
#line 423
    if (tmp___4 & 32768) {
#line 423
      isfixed = 1;
    } else {
#line 423
      isfixed = 0;
    }
    {
#line 424
    getushort(f);
#line 425
    cur->first = getushort(f);
#line 426
    cur->last = getushort(f);
#line 428
    getushort(f);
#line 429
    getushort(f);
#line 430
    getushort(f);
#line 431
    getushort(f);
#line 432
    widoff = getlong(f);
    }
#line 432
    if (widoff != 0L) {
#line 432
      widoff += offset;
    }
    {
#line 433
    kernoff = getlong(f);
    }
#line 433
    if (kernoff != 0L) {
#line 433
      kernoff += offset;
    }
    {
#line 434
    styleoff = getlong(f);
    }
#line 434
    if (styleoff != 0L) {
#line 434
      styleoff += offset;
    }
#line 435
    j = 0;
    {
#line 435
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 435
      if (! (j < 9)) {
#line 435
        goto while_break___0;
      }
      {
#line 436
      getushort(f);
#line 435
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 437
    getlong(f);
#line 438
    getushort(f);
#line 439
    tmp___5 = getushort(f);
#line 439
    cur->assoc_cnt = tmp___5 + 1;
#line 440
    tmp___6 = calloc((size_t )cur->assoc_cnt, sizeof(struct assoc ));
#line 440
    cur->assoc = (struct assoc *)tmp___6;
#line 441
    j = 0;
    }
    {
#line 441
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 441
      if (! (j < cur->assoc_cnt)) {
#line 441
        goto while_break___1;
      }
      {
#line 442
      tmp___7 = getushort(f);
#line 442
      (cur->assoc + j)->size = (short )tmp___7;
#line 443
      tmp___8 = getushort(f);
#line 443
      (cur->assoc + j)->style = (short )tmp___8;
#line 444
      tmp___9 = getushort(f);
#line 444
      (cur->assoc + j)->id = (short )tmp___9;
#line 441
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 446
    if (widoff != 0L) {
      {
#line 447
      fseek(f, widoff, 0);
#line 448
      tmp___10 = getushort(f);
#line 448
      cnt = tmp___10 + 1;
#line 449
      cur->stylewidthcnt = cnt;
#line 450
      tmp___11 = calloc((size_t )cnt, sizeof(struct stylewidths ));
#line 450
      cur->stylewidths = (struct stylewidths *)tmp___11;
#line 451
      j = 0;
      }
      {
#line 451
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 451
        if (! (j < cnt)) {
#line 451
          goto while_break___2;
        }
        {
#line 452
        tmp___12 = getushort(f);
#line 452
        (cur->stylewidths + j)->style = (short )tmp___12;
#line 453
        tmp___13 = malloc((unsigned long )((cur->last - cur->first) + 3) * sizeof(short ));
#line 453
        (cur->stylewidths + j)->widthtab = (short *)tmp___13;
#line 454
        k = cur->first;
        }
        {
#line 454
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 454
          if (! (k <= cur->last + 2)) {
#line 454
            goto while_break___3;
          }
          {
#line 455
          tmp___14 = getushort(f);
#line 455
          *((cur->stylewidths + j)->widthtab + k) = (short )tmp___14;
#line 454
          k ++;
          }
        }
        while_break___3: /* CIL Label */ ;
        }
#line 451
        j ++;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
#line 458
    if (kernoff != 0L) {
      {
#line 459
      fseek(f, kernoff, 0);
#line 460
      tmp___15 = getushort(f);
#line 460
      cnt = tmp___15 + 1;
#line 461
      cur->stylekerncnt = cnt;
#line 462
      tmp___16 = calloc((size_t )cnt, sizeof(struct stylekerns ));
#line 462
      cur->stylekerns = (struct stylekerns *)tmp___16;
#line 463
      j = 0;
      }
      {
#line 463
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 463
        if (! (j < cnt)) {
#line 463
          goto while_break___4;
        }
        {
#line 464
        tmp___17 = getushort(f);
#line 464
        (cur->stylekerns + j)->style = (short )tmp___17;
#line 465
        (cur->stylekerns + j)->kernpairs = getushort(f);
#line 466
        tmp___18 = malloc((unsigned long )(cur->stylekerns + j)->kernpairs * sizeof(struct kerns ));
#line 466
        (cur->stylekerns + j)->kerns = (struct kerns *)tmp___18;
#line 467
        k = 0;
        }
        {
#line 467
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 467
          if (! (k < (cur->stylekerns + j)->kernpairs)) {
#line 467
            goto while_break___5;
          }
          {
#line 468
          tmp___19 = _IO_getc(f);
#line 468
          ((cur->stylekerns + j)->kerns + k)->ch1 = (unsigned char )tmp___19;
#line 469
          tmp___20 = _IO_getc(f);
#line 469
          ((cur->stylekerns + j)->kerns + k)->ch2 = (unsigned char )tmp___20;
#line 470
          tmp___21 = getushort(f);
#line 470
          ((cur->stylekerns + j)->kerns + k)->offset = (short )tmp___21;
#line 467
          k ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
#line 463
        j ++;
      }
      while_break___4: /* CIL Label */ ;
      }
    }
#line 474
    if (styleoff != 0L) {
      {
#line 478
      fseek(f, styleoff, 0);
#line 479
      getushort(f);
#line 480
      getlong(f);
#line 481
      getlong(f);
#line 482
      j = 0;
      }
      {
#line 482
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 482
        if (! (j < 48)) {
#line 482
          goto while_break___6;
        }
        {
#line 483
        tmp___22 = _IO_getc(f);
#line 483
        stringoffsets[j] = (unsigned char )tmp___22;
#line 482
        j ++;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 484
      strcnt = getushort(f);
#line 485
      tmp___23 = malloc((unsigned long )strcnt * sizeof(char *));
#line 485
      strings = (char **)tmp___23;
#line 486
      j = 0;
      }
      {
#line 486
      while (1) {
        while_continue___7: /* CIL Label */ ;
#line 486
        if (! (j < strcnt)) {
#line 486
          goto while_break___7;
        }
        {
#line 487
        strlength = _IO_getc(f);
#line 488
        tmp___24 = malloc((size_t )(strlength + 2));
#line 488
        *(strings + j) = (char *)tmp___24;
#line 489
        *(*(strings + j) + 0) = (char )strlength;
#line 490
        *(*(strings + j) + (strlength + 1)) = (char )'\000';
#line 491
        k = 0;
        }
        {
#line 491
        while (1) {
          while_continue___8: /* CIL Label */ ;
#line 491
          if (! (k < strlength)) {
#line 491
            goto while_break___8;
          }
          {
#line 492
          tmp___25 = _IO_getc(f);
#line 492
          *(*(strings + j) + (k + 1)) = (char )tmp___25;
#line 491
          k ++;
          }
        }
        while_break___8: /* CIL Label */ ;
        }
#line 486
        j ++;
      }
      while_break___7: /* CIL Label */ ;
      }
#line 494
      j = 0;
      {
#line 494
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 494
        if (! (j < 48)) {
#line 494
          goto while_break___9;
        }
#line 495
        k = j - 1;
        {
#line 495
        while (1) {
          while_continue___10: /* CIL Label */ ;
#line 495
          if (! (k >= 0)) {
#line 495
            goto while_break___10;
          }
#line 496
          if ((int )stringoffsets[j] == (int )stringoffsets[k]) {
#line 497
            goto while_break___10;
          }
#line 495
          k --;
        }
        while_break___10: /* CIL Label */ ;
        }
#line 498
        if (k != -1) {
#line 499
          goto __Cont;
        } else
#line 498
        if ((int )stringoffsets[j] == 0) {
#line 499
          goto __Cont;
        }
#line 500
        format = (int )stringoffsets[j] - 1;
#line 501
        strlength = (int )*(*(strings + 0) + 0);
#line 502
        if (format != 0) {
#line 502
          if (format != -1) {
#line 503
            k = 0;
            {
#line 503
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 503
              if (! (k < (int )*(*(strings + format) + 0))) {
#line 503
                goto while_break___11;
              }
#line 504
              strlength += (int )*(*(strings + ((int )*(*(strings + format) + (k + 1)) - 1)) + 0);
#line 503
              k ++;
            }
            while_break___11: /* CIL Label */ ;
            }
          }
        }
        {
#line 505
        tmp___27 = malloc((size_t )(strlength + 1));
#line 505
        tmp___26 = (char *)tmp___27;
#line 505
        cur->psnames[j] = tmp___26;
#line 505
        pt = tmp___26;
#line 506
        strcpy((char */* __restrict  */)pt, (char const   */* __restrict  */)(*(strings + 0) + 1));
#line 507
        pt += (int )*(*(strings + 0) + 0);
        }
#line 508
        if (format != 0) {
#line 508
          if (format != -1) {
#line 509
            k = 0;
            {
#line 509
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 509
              if (! (k < (int )*(*(strings + format) + 0))) {
#line 509
                goto while_break___12;
              }
              {
#line 510
              strcpy((char */* __restrict  */)pt, (char const   */* __restrict  */)(*(strings + ((int )*(*(strings + format) + (k + 1)) - 1)) + 1));
#line 511
              pt += (int )*(*(strings + ((int )*(*(strings + format) + (k + 1)) - 1)) + 0);
#line 509
              k ++;
              }
            }
            while_break___12: /* CIL Label */ ;
            }
          }
        }
#line 513
        *pt = (char )'\000';
        __Cont: /* CIL Label */ 
#line 494
        j ++;
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 515
      cur->family = strdup((char const   *)*(strings + 0));
#line 516
      j = 0;
      }
      {
#line 516
      while (1) {
        while_continue___13: /* CIL Label */ ;
#line 516
        if (! (j < strcnt)) {
#line 516
          goto while_break___13;
        }
        {
#line 517
        free((void *)*(strings + j));
#line 516
        j ++;
        }
      }
      while_break___13: /* CIL Label */ ;
      }
      {
#line 518
      free((void *)strings);
      }
    }
#line 520
    if (doafm) {
      {
#line 521
      MakeAfmFiles(cur, f, isfixed, origfilename);
      }
    }
    {
#line 522
    fseek(f, here, 0);
#line 400
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 524
  fseek(f, start, 0);
  }
#line 525
  return (head);
}
}
#line 535 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int ucnt  ;
#line 528 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static void SearchPostscriptResources(FILE *f , long rlistpos , int subcnt , long rdata_pos ,
                                      long name_list , PSFONT *psfont ) 
{ 
  long here ;
  long tmp ;
  long *offsets ;
  long lenpos ;
  int rname ;
  int tmp___0 ;
  char name[300] ;
  char newname___0[300] ;
  int ch1 ;
  int ch2 ;
  int len ;
  int type ;
  int i ;
  int rlen ;
  char *buffer___0 ;
  int max ;
  FILE *pfb ;
  void *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  FILE *tmp___4 ;
  FILE *tmp___5 ;
  long tmp___6 ;
  long hold ;
  long tmp___7 ;
  void *tmp___8 ;
  int j ;
  char *pt ;
  size_t tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *end___0 ;
  char *tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;

  {
  {
#line 530
  tmp = ftell(f);
#line 530
  here = tmp;
#line 532
  rname = -1;
#line 541
  buffer___0 = (char *)((void *)0);
#line 542
  max = 0;
#line 545
  fseek(f, rlistpos, 0);
#line 546
  tmp___1 = calloc((size_t )subcnt, sizeof(long ));
#line 546
  offsets = (long *)tmp___1;
#line 547
  i = 0;
  }
  {
#line 547
  while (1) {
    while_continue: /* CIL Label */ ;
#line 547
    if (! (i < subcnt)) {
#line 547
      goto while_break;
    }
    {
#line 548
    getushort(f);
#line 549
    tmp___2 = getushort(f);
#line 549
    tmp___0 = (int )((short )tmp___2);
    }
#line 550
    if (rname == -1) {
#line 550
      rname = tmp___0;
    }
    {
#line 551
    _IO_getc(f);
#line 552
    ch1 = _IO_getc(f);
#line 552
    ch2 = _IO_getc(f);
#line 553
    tmp___3 = _IO_getc(f);
#line 553
    *(offsets + i) = rdata_pos + (long )(((ch1 << 16) | (ch2 << 8)) | tmp___3);
#line 554
    getlong(f);
#line 547
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 556
  mytmpname(name);
  }
#line 558
  if (rname != -1) {
    {
#line 559
    fseek(f, name_list + (long )rname, 0);
#line 560
    ch1 = _IO_getc(f);
#line 561
    fread((void */* __restrict  */)(newname___0), (size_t )1, (size_t )ch1, (FILE */* __restrict  */)f);
#line 562
    strcpy((char */* __restrict  */)(newname___0 + ch1), (char const   */* __restrict  */)".pfb");
    }
  } else {
    {
#line 564
    ucnt ++;
#line 564
    sprintf((char */* __restrict  */)(newname___0), (char const   */* __restrict  */)"Untitled-%d.pfb",
            ucnt);
    }
  }
#line 566
  if ((unsigned long )psfont != (unsigned long )((void *)0)) {
    {
#line 566
    tmp___4 = tmpfile();
#line 566
    pfb = tmp___4;
    }
  } else {
    {
#line 566
    tmp___5 = fopen((char const   */* __restrict  */)(name), (char const   */* __restrict  */)"w");
#line 566
    pfb = tmp___5;
    }
  }
#line 567
  if ((unsigned long )pfb == (unsigned long )((void *)0)) {
    {
#line 568
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open temporary file for postscript output\n");
#line 569
    fseek(f, here, 0);
#line 570
    free((void *)offsets);
    }
#line 571
    return;
  }
  {
#line 574
  _IO_putc(128, pfb);
#line 575
  _IO_putc(1, pfb);
#line 576
  lenpos = ftell(pfb);
#line 577
  _IO_putc(0, pfb);
#line 578
  _IO_putc(0, pfb);
#line 579
  _IO_putc(0, pfb);
#line 580
  _IO_putc(0, pfb);
#line 581
  len = 0;
#line 581
  type = 1;
#line 582
  i = 0;
  }
  {
#line 582
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 582
    if (! (i < subcnt)) {
#line 582
      goto while_break___0;
    }
    {
#line 583
    fseek(f, *(offsets + i), 0);
#line 584
    tmp___6 = getlong(f);
#line 584
    rlen = (int )tmp___6;
#line 585
    ch1 = _IO_getc(f);
#line 585
    ch2 = _IO_getc(f);
#line 586
    rlen -= 2;
    }
#line 587
    if (ch1 == type) {
#line 588
      len += rlen;
    } else {
      {
#line 590
      tmp___7 = ftell(pfb);
#line 590
      hold = tmp___7;
#line 591
      fseek(pfb, lenpos, 0);
#line 592
      _IO_putc(len & 255, pfb);
#line 593
      _IO_putc((len >> 8) & 255, pfb);
#line 594
      _IO_putc((len >> 16) & 255, pfb);
#line 595
      _IO_putc(len >> 24, pfb);
#line 596
      fseek(pfb, hold, 0);
      }
#line 597
      if (ch1 == 5) {
#line 598
        goto while_break___0;
      }
      {
#line 599
      _IO_putc(128, pfb);
#line 600
      _IO_putc(ch1, pfb);
#line 601
      lenpos = ftell(pfb);
#line 602
      _IO_putc(0, pfb);
#line 603
      _IO_putc(0, pfb);
#line 604
      _IO_putc(0, pfb);
#line 605
      _IO_putc(0, pfb);
#line 606
      type = ch1;
#line 607
      len = rlen;
      }
    }
#line 609
    if (rlen > max) {
      {
#line 610
      free((void *)buffer___0);
#line 611
      max = rlen;
      }
#line 612
      if (max < 2048) {
#line 612
        max = 2048;
      }
      {
#line 613
      tmp___8 = malloc((size_t )max);
#line 613
      buffer___0 = (char *)tmp___8;
      }
#line 614
      if ((unsigned long )buffer___0 == (unsigned long )((void *)0)) {
        {
#line 615
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Out of memory\n");
#line 616
        exit(1);
        }
      }
    }
    {
#line 619
    fread((void */* __restrict  */)buffer___0, (size_t )1, (size_t )rlen, (FILE */* __restrict  */)f);
    }
#line 620
    if (type == 1) {
#line 623
      j = 0;
      {
#line 623
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 623
        if (! (j < rlen)) {
#line 623
          goto while_break___1;
        }
#line 623
        if ((int )*(buffer___0 + j) == 13) {
#line 623
          *(buffer___0 + j) = (char )'\n';
        }
#line 623
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 624
      if (i == 0) {
#line 624
        if (rname == -1) {
          {
#line 624
          pt = strstr((char const   *)buffer___0, "/FontName");
          }
#line 624
          if ((unsigned long )pt != (unsigned long )((void *)0)) {
            {
#line 625
            tmp___9 = strlen("/FontName");
#line 625
            pt += tmp___9;
            }
            {
#line 626
            while (1) {
              while_continue___2: /* CIL Label */ ;
              {
#line 626
              tmp___10 = __ctype_b_loc();
              }
#line 626
              if (! ((int const   )*(*tmp___10 + (int )*pt) & 8192)) {
#line 626
                goto while_break___2;
              }
#line 626
              pt ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 627
            if ((int )*pt == 47) {
              {
#line 628
              tmp___11 = strchr((char const   *)pt, ' ');
#line 628
              end___0 = tmp___11;
#line 629
              ch1 = (int )*end___0;
#line 629
              *end___0 = (char )'\000';
#line 630
              sprintf((char */* __restrict  */)(newname___0), (char const   */* __restrict  */)"%s.pfb",
                      pt + 1);
#line 631
              *end___0 = (char )ch1;
              }
            }
          }
        }
      }
    }
    {
#line 635
    fwrite((void const   */* __restrict  */)buffer___0, (size_t )1, (size_t )rlen,
           (FILE */* __restrict  */)pfb);
#line 582
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 637
  free((void *)buffer___0);
#line 638
  free((void *)offsets);
#line 639
  _IO_putc(128, pfb);
#line 640
  _IO_putc(3, pfb);
#line 641
  fseek(pfb, lenpos, 0);
#line 642
  _IO_putc(len & 255, pfb);
#line 643
  _IO_putc((len >> 8) & 255, pfb);
#line 644
  _IO_putc((len >> 16) & 255, pfb);
#line 645
  _IO_putc(len >> 24, pfb);
  }
#line 646
  if ((unsigned long )psfont != (unsigned long )((void *)0)) {
    {
#line 647
    rewind(pfb);
#line 648
    ParsePfb(pfb, psfont);
    }
  }
  {
#line 650
  fclose(pfb);
  }
#line 651
  if ((unsigned long )psfont == (unsigned long )((void *)0)) {
    {
#line 652
    tmp___13 = cleanfilename(newname___0);
    }
#line 652
    if (tmp___13) {
      {
#line 653
      tmp___12 = rename((char const   *)(name), (char const   *)(newname___0));
      }
#line 653
      if (tmp___12 == -1) {
        {
#line 654
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not create %s\n",
                newname___0);
#line 655
        unlink((char const   *)(name));
        }
      }
    } else {
      {
#line 658
      unlink((char const   *)(name));
      }
    }
  }
  {
#line 660
  fseek(f, here, 0);
  }
#line 661
  return;
}
}
#line 663 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int ttfnamefixup(FILE *ttf , char *buffer___0 ) 
{ 
  int version ;
  int isotf ;
  int i ;
  int num ;
  int nameoffset ;
  int stringoffset ;
  int fullval ;
  int famval ;
  int fullstr ;
  int famstr ;
  int fulllen ;
  int famlen ;
  int val ;
  int tag ;
  int plat ;
  int spec ;
  int lang ;
  int name ;
  int len ;
  int off ;
  int ch ;
  char *pt ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char const   *tmp___5 ;

  {
  {
#line 664
  isotf = 0;
#line 670
  rewind(ttf);
#line 671
  tmp = getlong(ttf);
#line 671
  version = (int )tmp;
  }
#line 671
  if (version == ((((79 << 24) | (84 << 16)) | (84 << 8)) | 79)) {
#line 672
    isotf = 1;
  } else
#line 673
  if (version != 65536) {
#line 673
    if (version != ((((116 << 24) | (114 << 16)) | (117 << 8)) | 101)) {
#line 674
      return (0);
    }
  }
  {
#line 676
  num = getushort(ttf);
#line 677
  getushort(ttf);
#line 678
  getushort(ttf);
#line 679
  getushort(ttf);
#line 680
  i = 0;
  }
  {
#line 680
  while (1) {
    while_continue: /* CIL Label */ ;
#line 680
    if (! (i < num)) {
#line 680
      goto while_break;
    }
    {
#line 681
    tmp___0 = getlong(ttf);
#line 681
    tag = (int )tmp___0;
#line 682
    getlong(ttf);
#line 683
    tmp___1 = getlong(ttf);
#line 683
    nameoffset = (int )tmp___1;
#line 684
    getlong(ttf);
    }
#line 685
    if (tag == ((((110 << 24) | (97 << 16)) | (109 << 8)) | 101)) {
#line 686
      goto while_break;
    }
#line 680
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 688
  if (i == num) {
#line 689
    return (0);
  }
  {
#line 691
  fseek(ttf, (long )nameoffset, 0);
#line 692
  getushort(ttf);
#line 693
  num = getushort(ttf);
#line 694
  tmp___2 = getushort(ttf);
#line 694
  stringoffset = nameoffset + tmp___2;
#line 695
  famval = 0;
#line 695
  fullval = famval;
#line 696
  i = 0;
  }
  {
#line 696
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 696
    if (! (i < num)) {
#line 696
      goto while_break___0;
    }
    {
#line 697
    plat = getushort(ttf);
#line 698
    spec = getushort(ttf);
#line 699
    lang = getushort(ttf);
#line 700
    name = getushort(ttf);
#line 701
    len = getushort(ttf);
#line 702
    off = getushort(ttf);
#line 703
    val = 0;
    }
#line 704
    if (plat == 0) {
#line 704
      if (lang == 0) {
#line 705
        val = 1;
      } else {
#line 704
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 706
    if (plat == 3) {
#line 706
      if (spec == 1) {
#line 706
        if (lang == 1033) {
#line 707
          val = 2;
        } else {
#line 706
          goto _L___0;
        }
      } else {
#line 706
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 708
    if (plat == 1) {
#line 708
      if (spec == 0) {
#line 709
        val = 3;
      }
    }
#line 710
    if (name == 4) {
#line 710
      if (val > fullval) {
#line 711
        fullval = val;
#line 712
        fullstr = off;
#line 713
        fulllen = len;
#line 714
        if (val == 2) {
#line 715
          goto while_break___0;
        } else
#line 714
        if (val == 3) {
#line 715
          goto while_break___0;
        }
      } else {
#line 710
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 716
    if (name == 1) {
#line 716
      if (val > famval) {
#line 717
        famval = val;
#line 718
        famstr = off;
#line 719
        famlen = len;
      }
    }
#line 696
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 722
  if (fullval == 0) {
#line 723
    if (famval == 0) {
#line 724
      return (0);
    }
#line 725
    fullstr = famstr;
#line 726
    fulllen = famlen;
  }
  {
#line 729
  fseek(ttf, (long )(stringoffset + fullstr), 0);
#line 730
  pt = buffer___0;
  }
#line 731
  if (val == 3) {
#line 732
    i = 0;
    {
#line 732
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 732
      if (! (i < len)) {
#line 732
        goto while_break___1;
      }
      {
#line 733
      ch = _IO_getc(ttf);
      }
#line 735
      if (ch > 33) {
#line 735
        if (ch != 42) {
#line 735
          if (ch != 63) {
#line 735
            if (ch != 47) {
#line 735
              if (ch != 92) {
#line 735
                if (ch < 127) {
#line 736
                  tmp___3 = pt;
#line 736
                  pt ++;
#line 736
                  *tmp___3 = (char )ch;
                }
              }
            }
          }
        }
      }
#line 732
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 739
    i = 0;
    {
#line 739
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 739
      if (! (i < len / 2)) {
#line 739
        goto while_break___2;
      }
      {
#line 740
      _IO_getc(ttf);
#line 741
      ch = _IO_getc(ttf);
      }
#line 743
      if (ch > 33) {
#line 743
        if (ch != 42) {
#line 743
          if (ch != 63) {
#line 743
            if (ch != 47) {
#line 743
              if (ch != 92) {
#line 743
                if (ch < 127) {
#line 744
                  tmp___4 = pt;
#line 744
                  pt ++;
#line 744
                  *tmp___4 = (char )ch;
                }
              }
            }
          }
        }
      }
#line 739
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 747
  if (isotf) {
#line 747
    tmp___5 = ".otf";
  } else {
#line 747
    tmp___5 = ".ttf";
  }
  {
#line 747
  strcpy((char */* __restrict  */)pt, (char const   */* __restrict  */)tmp___5);
  }
#line 748
  return (1);
}
}
#line 751 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static void ttfnameset(FILE *ttf , char *curname , char *patheticattempt ) 
{ 
  char buffer___0[1024] ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 754
  tmp = ttfnamefixup(ttf, buffer___0);
  }
#line 754
  if (! tmp) {
    {
#line 755
    strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)patheticattempt);
    }
  }
  {
#line 756
  tmp___1 = cleanfilename(buffer___0);
  }
#line 756
  if (tmp___1) {
    {
#line 758
    tmp___0 = rename((char const   *)curname, (char const   *)(buffer___0));
    }
#line 758
    if (tmp___0 == -1) {
      {
#line 759
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not create %s\n",
              buffer___0);
#line 760
      unlink((char const   *)curname);
      }
    }
  } else {
    {
#line 757
    unlink((char const   *)curname);
    }
  }
#line 762
  return;
}
}
#line 771 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int ucnt___0  ;
#line 764 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static void SearchTtfResources(FILE *f , long rlistpos , int subcnt , long rdata_pos ,
                               long name_list , FOND *fonds ) 
{ 
  long here ;
  long start ;
  long tmp ;
  long roff ;
  int rname ;
  char name[300] ;
  char newname___0[300] ;
  int ch1 ;
  int ch2 ;
  int len ;
  int i ;
  int rlen ;
  int ilen ;
  char *buffer___0 ;
  int max ;
  FILE *ttf ;
  int tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;
  void *tmp___3 ;
  int temp ;
  size_t tmp___4 ;

  {
  {
#line 766
  tmp = ftell(f);
#line 766
  start = tmp;
#line 768
  rname = -1;
#line 774
  buffer___0 = (char *)((void *)0);
#line 775
  max = 0;
#line 778
  fseek(f, rlistpos, 0);
#line 779
  i = 0;
  }
  {
#line 779
  while (1) {
    while_continue: /* CIL Label */ ;
#line 779
    if (! (i < subcnt)) {
#line 779
      goto while_break;
    }
    {
#line 780
    getushort(f);
#line 781
    tmp___0 = getushort(f);
#line 781
    rname = (int )((short )tmp___0);
#line 782
    _IO_getc(f);
#line 783
    ch1 = _IO_getc(f);
#line 783
    ch2 = _IO_getc(f);
#line 784
    tmp___1 = _IO_getc(f);
#line 784
    roff = rdata_pos + (long )(((ch1 << 16) | (ch2 << 8)) | tmp___1);
#line 785
    getlong(f);
#line 786
    here = ftell(f);
    }
#line 787
    if (rname != -1) {
      {
#line 788
      fseek(f, name_list + (long )rname, 0);
#line 789
      ch1 = _IO_getc(f);
#line 790
      fread((void */* __restrict  */)(newname___0), (size_t )1, (size_t )ch1, (FILE */* __restrict  */)f);
#line 791
      strcpy((char */* __restrict  */)(newname___0 + ch1), (char const   */* __restrict  */)".ttf");
      }
    } else {
      {
#line 793
      ucnt___0 ++;
#line 793
      sprintf((char */* __restrict  */)(newname___0), (char const   */* __restrict  */)"Untitled-%d.ttf",
              ucnt___0);
      }
    }
    {
#line 795
    mytmpname(name);
#line 796
    ttf = fopen((char const   */* __restrict  */)(name), (char const   */* __restrict  */)"w+");
    }
#line 797
    if ((unsigned long )ttf == (unsigned long )((void *)0)) {
      {
#line 798
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open temporary file for truetype output.\n");
#line 799
      fseek(f, here, 0);
      }
#line 800
      goto __Cont;
    }
    {
#line 803
    fseek(f, roff, 0);
#line 804
    tmp___2 = getlong(f);
#line 804
    rlen = (int )tmp___2;
#line 804
    ilen = rlen;
    }
#line 805
    if (rlen > 16384) {
#line 806
      ilen = 16384;
    }
#line 807
    if (ilen > max) {
      {
#line 808
      free((void *)buffer___0);
#line 809
      max = ilen;
      }
#line 810
      if (max < 2048) {
#line 810
        max = 2048;
      }
      {
#line 811
      tmp___3 = malloc((size_t )max);
#line 811
      buffer___0 = (char *)tmp___3;
      }
    }
#line 813
    len = 0;
    {
#line 813
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 813
      if (! (len < rlen)) {
#line 813
        goto while_break___0;
      }
#line 814
      temp = ilen;
#line 815
      if (rlen - len < ilen) {
#line 815
        temp = rlen - len;
      }
      {
#line 816
      tmp___4 = fread((void */* __restrict  */)buffer___0, (size_t )1, (size_t )temp,
                      (FILE */* __restrict  */)f);
#line 816
      temp = (int )tmp___4;
      }
#line 817
      if (temp == -1) {
#line 818
        goto while_break___0;
      }
      {
#line 819
      fwrite((void const   */* __restrict  */)buffer___0, (size_t )1, (size_t )temp,
             (FILE */* __restrict  */)ttf);
#line 820
      len += temp;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 822
    ttfnameset(ttf, name, newname___0);
#line 823
    fclose(ttf);
#line 824
    fseek(f, here, 0);
    }
    __Cont: /* CIL Label */ 
#line 779
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 826
  fseek(f, start, 0);
  }
#line 827
  return;
}
}
#line 830 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int MightBeTrueType(FILE *binary , int pos , int dlen , char *filename ) 
{ 
  FILE *out ;
  FILE *tmp ;
  char *buffer___0 ;
  void *tmp___0 ;
  int len ;
  int tmp___1 ;
  size_t tmp___2 ;

  {
  {
#line 831
  tmp = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"w");
#line 831
  out = tmp;
#line 832
  tmp___0 = malloc((size_t )8192);
#line 832
  buffer___0 = (char *)tmp___0;
  }
#line 835
  if ((unsigned long )out == (unsigned long )((void *)0)) {
    {
#line 836
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Could not open %s for writing\n",
            filename);
#line 837
    exit(1);
    }
  }
  {
#line 840
  fseek(binary, (long )pos, 0);
  }
  {
#line 841
  while (1) {
    while_continue: /* CIL Label */ ;
#line 841
    if (! (dlen > 0)) {
#line 841
      goto while_break;
    }
#line 842
    if (dlen > 8192) {
#line 842
      len = 8192;
    } else {
#line 842
      len = dlen;
    }
#line 843
    if (dlen > 8192) {
#line 843
      tmp___1 = 8192;
    } else {
#line 843
      tmp___1 = dlen;
    }
    {
#line 843
    tmp___2 = fread((void */* __restrict  */)buffer___0, (size_t )1, (size_t )tmp___1,
                    (FILE */* __restrict  */)binary);
#line 843
    len = (int )tmp___2;
    }
#line 844
    if (len == 0) {
#line 845
      goto while_break;
    }
    {
#line 846
    fwrite((void const   */* __restrict  */)buffer___0, (size_t )1, (size_t )len,
           (FILE */* __restrict  */)out);
#line 847
    dlen -= len;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 849
  fclose(out);
#line 850
  free((void *)buffer___0);
  }
#line 851
  return (1);
}
}
#line 854 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int IsResourceFork___1(FILE *f , long offset , char *filename , PSFONT *psfont ) 
{ 
  unsigned char buffer___0[16] ;
  unsigned char buffer2[16] ;
  long rdata_pos ;
  long map_pos ;
  long type_list ;
  long name_list ;
  long rpos ;
  long rdata_len ;
  long map_len ;
  unsigned long tag ;
  int i ;
  int cnt ;
  int subcnt ;
  FOND *fondlist ;
  FOND *fl ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 865
  fondlist = (FOND *)((void *)0);
#line 867
  fseek(f, offset, 0);
#line 868
  tmp = fread((void */* __restrict  */)(buffer___0), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
#line 868
  if (tmp != 16UL) {
#line 869
    return (0);
  }
#line 870
  rdata_pos = offset + (long )(((((int )buffer___0[0] << 24) | ((int )buffer___0[1] << 16)) | ((int )buffer___0[2] << 8)) | (int )buffer___0[3]);
#line 871
  map_pos = offset + (long )(((((int )buffer___0[4] << 24) | ((int )buffer___0[5] << 16)) | ((int )buffer___0[6] << 8)) | (int )buffer___0[7]);
#line 872
  rdata_len = (long )(((((int )buffer___0[8] << 24) | ((int )buffer___0[9] << 16)) | ((int )buffer___0[10] << 8)) | (int )buffer___0[11]);
#line 873
  map_len = (long )(((((int )buffer___0[12] << 24) | ((int )buffer___0[13] << 16)) | ((int )buffer___0[14] << 8)) | (int )buffer___0[15]);
#line 874
  if (rdata_pos + rdata_len != map_pos) {
#line 875
    return (0);
  }
  {
#line 876
  fseek(f, map_pos, 0);
#line 877
  buffer2[15] = (unsigned char )((int )buffer___0[15] + 1);
#line 878
  tmp___0 = fread((void */* __restrict  */)(buffer2), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
#line 878
  if (tmp___0 != 16UL) {
#line 879
    return (0);
  }
#line 883
  i = 0;
  {
#line 883
  while (1) {
    while_continue: /* CIL Label */ ;
#line 883
    if (! (i < 16)) {
#line 883
      goto while_break;
    }
#line 884
    if ((int )buffer2[i] != 0) {
#line 885
      goto while_break;
    }
#line 883
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 886
  if (i != 16) {
#line 887
    i = 0;
    {
#line 887
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 887
      if (! (i < 16)) {
#line 887
        goto while_break___0;
      }
#line 888
      if ((int )buffer___0[i] != (int )buffer2[i]) {
#line 889
        return (0);
      }
#line 887
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 891
  getlong(f);
#line 892
  getushort(f);
#line 893
  getushort(f);
#line 894
  tmp___1 = getushort(f);
#line 894
  type_list = map_pos + (long )tmp___1;
#line 895
  tmp___2 = getushort(f);
#line 895
  name_list = map_pos + (long )tmp___2;
  }
#line 897
  if ((unsigned long )psfont == (unsigned long )((void *)0)) {
    {
#line 898
    fseek(f, type_list, 0);
#line 899
    tmp___3 = getushort(f);
#line 899
    cnt = tmp___3 + 1;
#line 900
    i = 0;
    }
    {
#line 900
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 900
      if (! (i < cnt)) {
#line 900
        goto while_break___1;
      }
      {
#line 901
      tmp___4 = getlong(f);
#line 901
      tag = (unsigned long )tmp___4;
#line 902
      tmp___5 = getushort(f);
#line 902
      subcnt = tmp___5 + 1;
#line 903
      tmp___6 = getushort(f);
#line 903
      rpos = type_list + (long )tmp___6;
      }
#line 904
      if (tag == (unsigned long )((((70 << 24) | (79 << 16)) | (78 << 8)) | 68)) {
        {
#line 905
        fondlist = BuildFondList(f, rpos, subcnt, rdata_pos, name_list, filename);
        }
      }
#line 900
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 908
    if (trackps) {
#line 909
      fl = fondlist;
      {
#line 909
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 909
        if (! ((unsigned long )fl != (unsigned long )((void *)0))) {
#line 909
          goto while_break___2;
        }
#line 910
        i = 0;
        {
#line 910
        while (1) {
          while_continue___3: /* CIL Label */ ;
#line 910
          if (! (i < 48)) {
#line 910
            goto while_break___3;
          }
#line 910
          if ((unsigned long )fl->psnames[i] != (unsigned long )((void *)0)) {
            {
#line 911
            ProcessNestedPS(fl->psnames[i], filename, (PSFONT *)((void *)0));
            }
          }
#line 910
          i ++;
        }
        while_break___3: /* CIL Label */ ;
        }
#line 909
        fl = fl->next;
      }
      while_break___2: /* CIL Label */ ;
      }
    }
  }
  {
#line 915
  fseek(f, type_list, 0);
#line 916
  tmp___7 = getushort(f);
#line 916
  cnt = tmp___7 + 1;
#line 917
  i = 0;
  }
  {
#line 917
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 917
    if (! (i < cnt)) {
#line 917
      goto while_break___4;
    }
    {
#line 918
    tmp___8 = getlong(f);
#line 918
    tag = (unsigned long )tmp___8;
#line 920
    tmp___9 = getushort(f);
#line 920
    subcnt = tmp___9 + 1;
#line 921
    tmp___10 = getushort(f);
#line 921
    rpos = type_list + (long )tmp___10;
    }
#line 922
    if (tag == (unsigned long )((((80 << 24) | (79 << 16)) | (83 << 8)) | 84)) {
      {
#line 923
      SearchPostscriptResources(f, rpos, subcnt, rdata_pos, name_list, psfont);
      }
    } else
#line 924
    if (! ((unsigned long )psfont != (unsigned long )((void *)0))) {
#line 926
      if (tag == (unsigned long )((((70 << 24) | (79 << 16)) | (78 << 8)) | 84)) {
        {
#line 927
        SearchNFNTResources(f, rpos, subcnt, rdata_pos, name_list, fondlist);
        }
      } else
#line 928
      if (tag == (unsigned long )((((78 << 24) | (70 << 16)) | (78 << 8)) | 84)) {
        {
#line 929
        SearchNFNTResources(f, rpos, subcnt, rdata_pos, name_list, fondlist);
        }
      } else
#line 930
      if (tag == (unsigned long )((((115 << 24) | (102 << 16)) | (110 << 8)) | 116)) {
        {
#line 931
        SearchTtfResources(f, rpos, subcnt, rdata_pos, name_list, fondlist);
        }
      }
    }
#line 917
    i ++;
  }
  while_break___4: /* CIL Label */ ;
  }
#line 937
  return (1);
}
}
#line 942 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int HasResourceFork___1(char *filename , PSFONT *psfont ) 
{ 
  char *respath ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  FILE *temp ;
  int ret ;

  {
  {
#line 943
  tmp = strlen((char const   *)filename);
#line 943
  tmp___0 = strlen("/rsrc");
#line 943
  tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 943
  respath = (char *)tmp___1;
#line 945
  ret = 0;
#line 947
  strcpy((char */* __restrict  */)respath, (char const   */* __restrict  */)filename);
#line 948
  strcat((char */* __restrict  */)respath, (char const   */* __restrict  */)"/rsrc");
#line 949
  temp = fopen((char const   */* __restrict  */)respath, (char const   */* __restrict  */)"r");
#line 950
  free((void *)respath);
  }
#line 951
  if ((unsigned long )temp != (unsigned long )((void *)0)) {
    {
#line 952
    ret = IsResourceFork___1(temp, 0L, filename, psfont);
#line 953
    fclose(temp);
    }
  }
#line 955
  return (ret);
}
}
#line 995 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int IsResourceInBinary___1(FILE *f , char *filename , PSFONT *psfont ) 
{ 
  unsigned char header[128] ;
  unsigned char first[8] ;
  unsigned long offset ;
  unsigned long dlen ;
  unsigned long rlen ;
  size_t tmp ;
  int pos ;
  long tmp___0 ;
  int len ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 999
  tmp = fread((void */* __restrict  */)(header), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
  }
#line 999
  if (tmp != 128UL) {
#line 1000
    return (0);
  }
#line 1001
  if ((int )header[0] != 0) {
#line 1003
    return (0);
  } else
#line 1001
  if ((int )header[74] != 0) {
#line 1003
    return (0);
  } else
#line 1001
  if ((int )header[82] != 0) {
#line 1003
    return (0);
  } else
#line 1001
  if ((int )header[1] <= 0) {
#line 1003
    return (0);
  } else
#line 1001
  if ((int )header[1] > 33) {
#line 1003
    return (0);
  } else
#line 1001
  if ((int )header[63] != 0) {
#line 1003
    return (0);
  } else
#line 1001
  if ((int )header[2 + (int )header[1]] != 0) {
#line 1003
    return (0);
  }
#line 1004
  dlen = (unsigned long )(((((int )header[83] << 24) | ((int )header[84] << 16)) | ((int )header[85] << 8)) | (int )header[86]);
#line 1005
  rlen = (unsigned long )(((((int )header[87] << 24) | ((int )header[88] << 16)) | ((int )header[89] << 8)) | (int )header[90]);
#line 1007
  if (dlen != 0UL) {
#line 1007
    if (rlen <= dlen) {
      {
#line 1008
      tmp___0 = ftell(f);
#line 1008
      pos = (int )tmp___0;
#line 1009
      fread((void */* __restrict  */)(first), (size_t )1, (size_t )4, (FILE */* __restrict  */)f);
#line 1010
      first[5] = (unsigned char )'\000';
#line 1011
      tmp___2 = strcmp((char const   *)((char *)(first)), "OTTO");
      }
#line 1011
      if (tmp___2 == 0) {
        {
#line 1014
        len = (int )header[1];
#line 1015
        header[2 + len] = (unsigned char )'\000';
#line 1016
        tmp___1 = MightBeTrueType(f, pos, (int )dlen, (char *)(header) + 2);
        }
#line 1016
        return (tmp___1);
      } else {
        {
#line 1011
        tmp___3 = strcmp((char const   *)((char *)(first)), "true");
        }
#line 1011
        if (tmp___3 == 0) {
          {
#line 1014
          len = (int )header[1];
#line 1015
          header[2 + len] = (unsigned char )'\000';
#line 1016
          tmp___1 = MightBeTrueType(f, pos, (int )dlen, (char *)(header) + 2);
          }
#line 1016
          return (tmp___1);
        } else {
          {
#line 1011
          tmp___4 = strcmp((char const   *)((char *)(first)), "ttcf");
          }
#line 1011
          if (tmp___4 == 0) {
            {
#line 1014
            len = (int )header[1];
#line 1015
            header[2 + len] = (unsigned char )'\000';
#line 1016
            tmp___1 = MightBeTrueType(f, pos, (int )dlen, (char *)(header) + 2);
            }
#line 1016
            return (tmp___1);
          } else
#line 1011
          if ((int )first[0] == 0) {
#line 1011
            if ((int )first[1] == 1) {
#line 1011
              if ((int )first[2] == 0) {
#line 1011
                if ((int )first[3] == 0) {
                  {
#line 1014
                  len = (int )header[1];
#line 1015
                  header[2 + len] = (unsigned char )'\000';
#line 1016
                  tmp___1 = MightBeTrueType(f, pos, (int )dlen, (char *)(header) + 2);
                  }
#line 1016
                  return (tmp___1);
                }
              }
            }
          }
        }
      }
    }
  }
  {
#line 1020
  offset = 128UL + ((dlen + 127UL) & 0xffffffffffffff80UL);
#line 1021
  tmp___5 = IsResourceFork___1(f, (long )offset, filename, psfont);
  }
#line 1021
  return (tmp___5);
}
}
#line 1024 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int lastch___1  =    0;
#line 1024 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int repeat___1  =    0;
#line 1025 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static void outchr___1(FILE *binary , int ch ) 
{ 
  int i ;

  {
#line 1028
  if (repeat___1) {
#line 1029
    if (ch == 0) {
      {
#line 1031
      lastch___1 = 144;
#line 1032
      _IO_putc(lastch___1, binary);
      }
    } else {
#line 1034
      i = 1;
      {
#line 1034
      while (1) {
        while_continue: /* CIL Label */ ;
#line 1034
        if (! (i < ch)) {
#line 1034
          goto while_break;
        }
        {
#line 1035
        _IO_putc(lastch___1, binary);
#line 1034
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 1037
    repeat___1 = 0;
  } else
#line 1038
  if (ch == 144) {
#line 1039
    repeat___1 = 1;
  } else {
    {
#line 1041
    _IO_putc(ch, binary);
#line 1042
    lastch___1 = ch;
    }
  }
#line 1044
  return;
}
}
#line 1046 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int IsResourceInHex___1(FILE *f , char *filename , PSFONT *psfont ) 
{ 
  FILE *binary ;
  FILE *tmp ;
  char *sixbit ;
  int ch ;
  int val ;
  int cnt ;
  int i ;
  int dlen ;
  int rlen ;
  int ret ;
  char header[20] ;
  char *pt ;
  char wrappedfilename[128] ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int pos ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;

  {
  {
#line 1049
  tmp = tmpfile();
#line 1049
  binary = tmp;
#line 1050
  sixbit = (char *)"!\"#$%&\'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr";
  }
#line 1055
  if ((unsigned long )binary == (unsigned long )((void *)0)) {
    {
#line 1056
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t create temporary file\n");
    }
#line 1057
    return (0);
  }
#line 1060
  repeat___1 = 0;
#line 1060
  lastch___1 = repeat___1;
  {
#line 1061
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1061
    ch = _IO_getc(f);
    }
#line 1061
    if (! (ch != 58)) {
#line 1061
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1062
  val = 0;
#line 1062
  cnt = val;
  {
#line 1063
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1063
    ch = _IO_getc(f);
    }
#line 1063
    if (! (ch != 58)) {
#line 1063
      goto while_break___0;
    }
    {
#line 1064
    tmp___0 = __ctype_b_loc();
    }
#line 1064
    if ((int const   )*(*tmp___0 + ch) & 8192) {
#line 1065
      goto while_continue___0;
    }
#line 1066
    pt = sixbit;
    {
#line 1066
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1066
      if ((int )*pt != ch) {
#line 1066
        if (! ((int )*pt != 0)) {
#line 1066
          goto while_break___1;
        }
      } else {
#line 1066
        goto while_break___1;
      }
#line 1066
      pt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1067
    if ((int )*pt == 0) {
      {
#line 1068
      fclose(binary);
      }
#line 1069
      return (0);
    }
#line 1071
    val = (int )((long )(val << 6) | (pt - sixbit));
#line 1072
    cnt ++;
#line 1072
    if (cnt == 4) {
      {
#line 1073
      outchr___1(binary, (val >> 16) & 255);
#line 1074
      outchr___1(binary, (val >> 8) & 255);
#line 1075
      outchr___1(binary, val & 255);
#line 1076
      cnt = 0;
#line 1076
      val = cnt;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1079
  if (cnt != 0) {
#line 1080
    if (cnt == 1) {
      {
#line 1081
      outchr___1(binary, val << 2);
      }
    } else
#line 1082
    if (cnt == 2) {
      {
#line 1083
      val <<= 4;
#line 1084
      outchr___1(binary, (val >> 8) & 255);
#line 1085
      outchr___1(binary, val & 255);
      }
    } else
#line 1086
    if (cnt == 3) {
      {
#line 1087
      val <<= 6;
#line 1088
      outchr___1(binary, (val >> 16) & 255);
#line 1089
      outchr___1(binary, (val >> 8) & 255);
#line 1090
      outchr___1(binary, val & 255);
      }
    }
  }
  {
#line 1094
  rewind(binary);
#line 1095
  ch = _IO_getc(binary);
#line 1097
  i = 0;
#line 1097
  pt = wrappedfilename;
  }
  {
#line 1097
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 1097
    if (! (i < ch)) {
#line 1097
      goto while_break___2;
    }
    {
#line 1098
    tmp___1 = pt;
#line 1098
    pt ++;
#line 1098
    tmp___2 = _IO_getc(binary);
#line 1098
    *tmp___1 = (char )tmp___2;
#line 1097
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 1099
  *pt = (char )'\000';
#line 1100
  tmp___3 = _IO_getc(binary);
  }
#line 1100
  if (tmp___3 != 0) {
    {
#line 1101
    fclose(binary);
    }
#line 1102
    return (0);
  }
  {
#line 1104
  fread((void */* __restrict  */)(header), (size_t )1, (size_t )20, (FILE */* __restrict  */)binary);
#line 1105
  dlen = ((((int )header[10] << 24) | ((int )header[11] << 16)) | ((int )header[12] << 8)) | (int )header[13];
#line 1106
  rlen = ((((int )header[14] << 24) | ((int )header[15] << 16)) | ((int )header[16] << 8)) | (int )header[17];
  }
#line 1108
  if (dlen != 0) {
#line 1108
    if (rlen < dlen) {
      {
#line 1109
      tmp___4 = ftell(binary);
#line 1109
      pos = (int )tmp___4;
#line 1110
      fread((void */* __restrict  */)(header), (size_t )1, (size_t )4, (FILE */* __restrict  */)binary);
#line 1111
      header[5] = (char )'\000';
#line 1112
      tmp___5 = strcmp((char const   *)(header), "OTTO");
      }
#line 1112
      if (tmp___5 == 0) {
        {
#line 1115
        ret = MightBeTrueType(binary, pos, dlen, wrappedfilename);
#line 1116
        fclose(binary);
        }
#line 1117
        return (ret);
      } else {
        {
#line 1112
        tmp___6 = strcmp((char const   *)(header), "true");
        }
#line 1112
        if (tmp___6 == 0) {
          {
#line 1115
          ret = MightBeTrueType(binary, pos, dlen, wrappedfilename);
#line 1116
          fclose(binary);
          }
#line 1117
          return (ret);
        } else {
          {
#line 1112
          tmp___7 = strcmp((char const   *)(header), "ttcf");
          }
#line 1112
          if (tmp___7 == 0) {
            {
#line 1115
            ret = MightBeTrueType(binary, pos, dlen, wrappedfilename);
#line 1116
            fclose(binary);
            }
#line 1117
            return (ret);
          } else
#line 1112
          if ((int )header[0] == 0) {
#line 1112
            if ((int )header[1] == 1) {
#line 1112
              if ((int )header[2] == 0) {
#line 1112
                if ((int )header[3] == 0) {
                  {
#line 1115
                  ret = MightBeTrueType(binary, pos, dlen, wrappedfilename);
#line 1116
                  fclose(binary);
                  }
#line 1117
                  return (ret);
                }
              }
            }
          }
        }
      }
    }
  }
#line 1120
  if (rlen == 0) {
    {
#line 1121
    fclose(binary);
    }
#line 1122
    return (0);
  }
  {
#line 1125
  tmp___8 = ftell(binary);
#line 1125
  ret = IsResourceFork___1(binary, (tmp___8 + (long )dlen) + 2L, filename, psfont);
#line 1127
  fclose(binary);
  }
#line 1128
  return (ret);
}
}
#line 1131 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int IsResourceInFile___1(char *filename , PSFONT *psfont ) 
{ 
  FILE *f ;
  char *spt ;
  char *pt ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 1136
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 1137
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 1138
    return (0);
  }
  {
#line 1139
  spt = strrchr((char const   *)filename, '/');
  }
#line 1140
  if ((unsigned long )spt == (unsigned long )((void *)0)) {
#line 1140
    spt = filename;
  }
  {
#line 1141
  pt = strrchr((char const   *)spt, '.');
  }
#line 1142
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 1142
    if ((int )*(pt + 1) == 98) {
#line 1142
      goto _L___8;
    } else
#line 1142
    if ((int )*(pt + 1) == 66) {
      _L___8: /* CIL Label */ 
#line 1142
      if ((int )*(pt + 2) == 105) {
#line 1142
        goto _L___6;
      } else
#line 1142
      if ((int )*(pt + 2) == 73) {
        _L___6: /* CIL Label */ 
#line 1142
        if ((int )*(pt + 3) == 110) {
#line 1142
          goto _L___4;
        } else
#line 1142
        if ((int )*(pt + 3) == 78) {
          _L___4: /* CIL Label */ 
#line 1142
          if ((int )*(pt + 4) == 0) {
            {
#line 1144
            tmp = IsResourceInBinary___1(f, filename, psfont);
            }
#line 1144
            if (tmp) {
              {
#line 1145
              fclose(f);
              }
#line 1146
              return (1);
            }
          } else {
#line 1142
            goto _L___7;
          }
        } else {
#line 1142
          goto _L___7;
        }
      } else {
#line 1142
        goto _L___7;
      }
    } else {
#line 1142
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 1148
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 1148
    if ((int )*(pt + 1) == 104) {
#line 1148
      goto _L___1;
    } else
#line 1148
    if ((int )*(pt + 1) == 72) {
      _L___1: /* CIL Label */ 
#line 1148
      if ((int )*(pt + 2) == 113) {
#line 1148
        goto _L___0;
      } else
#line 1148
      if ((int )*(pt + 2) == 81) {
        _L___0: /* CIL Label */ 
#line 1148
        if ((int )*(pt + 3) == 120) {
#line 1148
          goto _L;
        } else
#line 1148
        if ((int )*(pt + 3) == 88) {
          _L: /* CIL Label */ 
#line 1148
          if ((int )*(pt + 4) == 0) {
            {
#line 1150
            tmp___0 = IsResourceInHex___1(f, filename, psfont);
            }
#line 1150
            if (tmp___0) {
              {
#line 1151
              fclose(f);
              }
#line 1152
              return (1);
            }
          }
        }
      }
    }
  }
  {
#line 1156
  ret = IsResourceFork___1(f, 0L, filename, psfont);
#line 1157
  fclose(f);
  }
#line 1158
  if (! ret) {
    {
#line 1159
    ret = HasResourceFork___1(filename, psfont);
    }
  }
#line 1160
  return (ret);
}
}
#line 1163 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondu.c"
static int FindResourceFile___0(char *filename ) 
{ 
  char *spt ;
  char *pt ;
  char *dpt ;
  char buffer___0[1400] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  char exten[8] ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 1167
  tmp = IsResourceInFile___1(filename, (PSFONT *)((void *)0));
  }
#line 1167
  if (tmp) {
#line 1168
    return (1);
  }
  {
#line 1172
  strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)filename);
#line 1173
  spt = strrchr((char const   *)(buffer___0), '/');
  }
#line 1174
  if ((unsigned long )spt == (unsigned long )((void *)0)) {
#line 1174
    spt = buffer___0;
#line 1174
    pt = filename;
  } else {
#line 1175
    spt ++;
#line 1175
    pt = filename + (spt - buffer___0);
  }
  {
#line 1176
  strcpy((char */* __restrict  */)spt, (char const   */* __restrict  */)"resource.frk/");
#line 1177
  strcat((char */* __restrict  */)spt, (char const   */* __restrict  */)pt);
#line 1178
  tmp___0 = IsResourceInFile___1(buffer___0, (PSFONT *)((void *)0));
  }
#line 1178
  if (tmp___0) {
#line 1179
    return (1);
  }
  {
#line 1183
  tmp___1 = strrchr((char const   *)(buffer___0), '/');
#line 1183
  spt = tmp___1 + 1;
#line 1184
  pt = spt;
  }
  {
#line 1184
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1184
    if (! *pt) {
#line 1184
      goto while_break;
    }
    {
#line 1185
    tmp___3 = __ctype_b_loc();
    }
#line 1185
    if ((int const   )*(*tmp___3 + (int )*pt) & 256) {
      {
#line 1186
      tmp___2 = tolower((int )*pt);
#line 1186
      *pt = (char )tmp___2;
      }
    }
#line 1184
    pt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1187
  dpt = strchr((char const   *)spt, '.');
  }
#line 1188
  if ((unsigned long )dpt == (unsigned long )((void *)0)) {
    {
#line 1188
    tmp___4 = strlen((char const   *)spt);
#line 1188
    dpt = spt + tmp___4;
    }
  }
#line 1189
  if (dpt - spt > 8L) {
#line 1189
    goto _L;
  } else {
    {
#line 1189
    tmp___7 = strlen((char const   *)dpt);
    }
#line 1189
    if (tmp___7 > 4UL) {
      _L: /* CIL Label */ 
      {
#line 1191
      strncpy((char */* __restrict  */)(exten), (char const   */* __restrict  */)dpt,
              (size_t )7);
#line 1192
      exten[4] = (char )'\000';
      }
#line 1193
      if (dpt - spt > 6L) {
#line 1194
        dpt = spt + 6;
      }
      {
#line 1195
      tmp___5 = dpt;
#line 1195
      dpt ++;
#line 1195
      *tmp___5 = (char )'~';
#line 1196
      tmp___6 = dpt;
#line 1196
      dpt ++;
#line 1196
      *tmp___6 = (char )'1';
#line 1197
      strcpy((char */* __restrict  */)dpt, (char const   */* __restrict  */)(exten));
      }
    }
  }
  {
#line 1199
  tmp___8 = IsResourceInFile___1(buffer___0, (PSFONT *)((void *)0));
  }
#line 1199
  return (tmp___8);
}
}
#line 425 "/usr/include/stdio.h"
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 164 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__nonnull__(1), __leaf__)) strtod)(char const   * __restrict  __nptr ,
                                                                                                char ** __restrict  __endptr ) ;
#line 374
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) rand)(void) ;
#line 191 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/psfont.h"
char *AdobeStandardEncoding[256] ;
#line 124 "/usr/include/locale.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) setlocale)(int __category ,
                                                                                  char const   *__locale ) ;
#line 156 "/usr/include/x86_64-linux-gnu/bits/mathcalls.h"
extern  __attribute__((__nothrow__)) double ( __attribute__((__leaf__)) sqrt)(double __x ) ;
#line 69 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *copyn(char const   *str , long n ) 
{ 
  char *ret ;
  void *tmp ;

  {
#line 72
  if ((unsigned long )str == (unsigned long )((void *)0)) {
#line 73
    return ((char *)((void *)0));
  }
  {
#line 74
  tmp = malloc((size_t )(n + 1L));
#line 74
  ret = (char *)tmp;
#line 75
  memcpy((void */* __restrict  */)ret, (void const   */* __restrict  */)str, (size_t )n);
#line 76
  *(ret + n) = (char )'\000';
  }
#line 77
  return (ret);
}
}
#line 80 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *PSDictHasEntry(struct psdict *dict , char *key ) 
{ 
  int i ;
  int tmp ;

  {
#line 83
  if ((unsigned long )dict == (unsigned long )((void *)0)) {
#line 84
    return ((char *)((void *)0));
  }
#line 86
  i = 0;
  {
#line 86
  while (1) {
    while_continue: /* CIL Label */ ;
#line 86
    if (! (i < dict->next)) {
#line 86
      goto while_break;
    }
    {
#line 87
    tmp = strcmp((char const   *)*(dict->keys + i), (char const   *)key);
    }
#line 87
    if (tmp == 0) {
#line 88
      return (*(dict->values + i));
    }
#line 86
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 90
  return ((char *)((void *)0));
}
}
#line 93 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static int PSDictRemoveEntry(struct psdict *dict , char *key ) 
{ 
  int i ;
  int tmp ;

  {
#line 96
  if ((unsigned long )dict == (unsigned long )((void *)0)) {
#line 97
    return (0);
  }
#line 99
  i = 0;
  {
#line 99
  while (1) {
    while_continue: /* CIL Label */ ;
#line 99
    if (! (i < dict->next)) {
#line 99
      goto while_break;
    }
    {
#line 100
    tmp = strcmp((char const   *)*(dict->keys + i), (char const   *)key);
    }
#line 100
    if (tmp == 0) {
#line 101
      goto while_break;
    }
#line 99
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 102
  if (i == dict->next) {
#line 103
    return (0);
  }
  {
#line 104
  free((void *)*(dict->keys + i));
#line 105
  free((void *)*(dict->values + i));
#line 106
  (dict->next) --;
  }
  {
#line 107
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 107
    if (! (i < dict->next)) {
#line 107
      goto while_break___0;
    }
#line 108
    *(dict->keys + i) = *(dict->keys + (i + 1));
#line 109
    *(dict->values + i) = *(dict->values + (i + 1));
#line 110
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 113
  return (1);
}
}
#line 116 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void copyenc(char **encoding , char **std ) 
{ 
  int i ;

  {
#line 118
  i = 0;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
#line 118
    if (! (i < 256)) {
#line 118
      goto while_break;
    }
    {
#line 119
    *(encoding + i) = strdup((char const   *)*(std + i));
#line 118
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 120
  return;
}
}
#line 122 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
char *AdobeStandardEncoding[256]  = 
#line 122
  {      (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)"space",      (char *)"exclam",      (char *)"quotedbl",      (char *)"numbersign", 
        (char *)"dollar",      (char *)"percent",      (char *)"ampersand",      (char *)"quoteright", 
        (char *)"parenleft",      (char *)"parenright",      (char *)"asterisk",      (char *)"plus", 
        (char *)"comma",      (char *)"hyphen",      (char *)"period",      (char *)"slash", 
        (char *)"zero",      (char *)"one",      (char *)"two",      (char *)"three", 
        (char *)"four",      (char *)"five",      (char *)"six",      (char *)"seven", 
        (char *)"eight",      (char *)"nine",      (char *)"colon",      (char *)"semicolon", 
        (char *)"less",      (char *)"equal",      (char *)"greater",      (char *)"question", 
        (char *)"at",      (char *)"A",      (char *)"B",      (char *)"C", 
        (char *)"D",      (char *)"E",      (char *)"F",      (char *)"G", 
        (char *)"H",      (char *)"I",      (char *)"J",      (char *)"K", 
        (char *)"L",      (char *)"M",      (char *)"N",      (char *)"O", 
        (char *)"P",      (char *)"Q",      (char *)"R",      (char *)"S", 
        (char *)"T",      (char *)"U",      (char *)"V",      (char *)"W", 
        (char *)"X",      (char *)"Y",      (char *)"Z",      (char *)"bracketleft", 
        (char *)"backslash",      (char *)"bracketright",      (char *)"asciicircum",      (char *)"underscore", 
        (char *)"quoteleft",      (char *)"a",      (char *)"b",      (char *)"c", 
        (char *)"d",      (char *)"e",      (char *)"f",      (char *)"g", 
        (char *)"h",      (char *)"i",      (char *)"j",      (char *)"k", 
        (char *)"l",      (char *)"m",      (char *)"n",      (char *)"o", 
        (char *)"p",      (char *)"q",      (char *)"r",      (char *)"s", 
        (char *)"t",      (char *)"u",      (char *)"v",      (char *)"w", 
        (char *)"x",      (char *)"y",      (char *)"z",      (char *)"braceleft", 
        (char *)"bar",      (char *)"braceright",      (char *)"asciitilde",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)"exclamdown",      (char *)"cent",      (char *)"sterling", 
        (char *)"fraction",      (char *)"yen",      (char *)"florin",      (char *)"section", 
        (char *)"currency",      (char *)"quotesingle",      (char *)"quotedblleft",      (char *)"guillemotleft", 
        (char *)"guilsinglleft",      (char *)"guilsinglright",      (char *)"fi",      (char *)"fl", 
        (char *)".notdef",      (char *)"endash",      (char *)"dagger",      (char *)"daggerdbl", 
        (char *)"periodcentered",      (char *)".notdef",      (char *)"paragraph",      (char *)"bullet", 
        (char *)"quotesinglbase",      (char *)"quotedblbase",      (char *)"quotedblright",      (char *)"guillemotright", 
        (char *)"ellipsis",      (char *)"perthousand",      (char *)".notdef",      (char *)"questiondown", 
        (char *)".notdef",      (char *)"grave",      (char *)"acute",      (char *)"circumflex", 
        (char *)"tilde",      (char *)"macron",      (char *)"breve",      (char *)"dotaccent", 
        (char *)"dieresis",      (char *)".notdef",      (char *)"ring",      (char *)"cedilla", 
        (char *)".notdef",      (char *)"hungarumlaut",      (char *)"ogonek",      (char *)"caron", 
        (char *)"emdash",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)"AE",      (char *)".notdef",      (char *)"ordfeminine", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)"Lslash",      (char *)"Oslash",      (char *)"OE",      (char *)"ordmasculine", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)"ae",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)"dotlessi",      (char *)".notdef",      (char *)".notdef", 
        (char *)"lslash",      (char *)"oslash",      (char *)"oe",      (char *)"germandbls", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef"};
#line 380 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void setStdEnc(char **encoding ) 
{ 


  {
  {
#line 381
  copyenc(encoding, (char **)(AdobeStandardEncoding));
  }
#line 382
  return;
}
}
#line 385
static void setLatin1Enc(char **encoding ) ;
#line 385 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *latin1enc[256]  = 
#line 385
  {      (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)"space",      (char *)"exclam",      (char *)"quotedbl",      (char *)"numbersign", 
        (char *)"dollar",      (char *)"percent",      (char *)"ampersand",      (char *)"quoteright", 
        (char *)"parenleft",      (char *)"parenright",      (char *)"asterisk",      (char *)"plus", 
        (char *)"comma",      (char *)"hyphen",      (char *)"period",      (char *)"slash", 
        (char *)"zero",      (char *)"one",      (char *)"two",      (char *)"three", 
        (char *)"four",      (char *)"five",      (char *)"six",      (char *)"seven", 
        (char *)"eight",      (char *)"nine",      (char *)"colon",      (char *)"semicolon", 
        (char *)"less",      (char *)"equal",      (char *)"greater",      (char *)"question", 
        (char *)"at",      (char *)"A",      (char *)"B",      (char *)"C", 
        (char *)"D",      (char *)"E",      (char *)"F",      (char *)"G", 
        (char *)"H",      (char *)"I",      (char *)"J",      (char *)"K", 
        (char *)"L",      (char *)"M",      (char *)"N",      (char *)"O", 
        (char *)"P",      (char *)"Q",      (char *)"R",      (char *)"S", 
        (char *)"T",      (char *)"U",      (char *)"V",      (char *)"W", 
        (char *)"X",      (char *)"Y",      (char *)"Z",      (char *)"bracketleft", 
        (char *)"backslash",      (char *)"bracketright",      (char *)"asciicircum",      (char *)"underscore", 
        (char *)"grave",      (char *)"a",      (char *)"b",      (char *)"c", 
        (char *)"d",      (char *)"e",      (char *)"f",      (char *)"g", 
        (char *)"h",      (char *)"i",      (char *)"j",      (char *)"k", 
        (char *)"l",      (char *)"m",      (char *)"n",      (char *)"o", 
        (char *)"p",      (char *)"q",      (char *)"r",      (char *)"s", 
        (char *)"t",      (char *)"u",      (char *)"v",      (char *)"w", 
        (char *)"x",      (char *)"y",      (char *)"z",      (char *)"braceleft", 
        (char *)"bar",      (char *)"braceright",      (char *)"asciitilde",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)"dotlessi",      (char *)"grave",      (char *)"accute",      (char *)"circumflex", 
        (char *)"tilde",      (char *)"macron",      (char *)"breve",      (char *)"dotaccent", 
        (char *)"dieresis",      (char *)".notdef",      (char *)"ring",      (char *)"cedilla", 
        (char *)".notdef",      (char *)"hungarumlaut",      (char *)"ogonek",      (char *)"caron", 
        (char *)"space",      (char *)"exclamdown",      (char *)"cent",      (char *)"sterling", 
        (char *)"currency",      (char *)"yen",      (char *)"brokenbar",      (char *)"section", 
        (char *)"dieresis",      (char *)"copyright",      (char *)"ordfeminine",      (char *)"guillemotleft", 
        (char *)"logicalnot",      (char *)"hyphen",      (char *)"registered",      (char *)"macron", 
        (char *)"degree",      (char *)"plusminus",      (char *)"twosuperior",      (char *)"threesuperior", 
        (char *)"acute",      (char *)"mu",      (char *)"paragraph",      (char *)"periodcentered", 
        (char *)"cedilla",      (char *)"onesuperior",      (char *)"ordmasculine",      (char *)"guillemotright", 
        (char *)"onequarter",      (char *)"onehalf",      (char *)"threequarters",      (char *)"questiondown", 
        (char *)"Agrave",      (char *)"Aacute",      (char *)"Acircumflex",      (char *)"Atilde", 
        (char *)"Adieresis",      (char *)"Aring",      (char *)"AE",      (char *)"Ccedilla", 
        (char *)"Egrave",      (char *)"Eacute",      (char *)"Ecircumflex",      (char *)"Edieresis", 
        (char *)"Igrave",      (char *)"Iacute",      (char *)"Icircumflex",      (char *)"Idieresis", 
        (char *)"Eth",      (char *)"Ntilde",      (char *)"Ograve",      (char *)"Oacute", 
        (char *)"Ocircumflex",      (char *)"Otilde",      (char *)"Odieresis",      (char *)"multiply", 
        (char *)"Oslash",      (char *)"Ugrave",      (char *)"Uacute",      (char *)"Ucircumflex", 
        (char *)"Udieresis",      (char *)"Yacute",      (char *)"Thorn",      (char *)"germandbls", 
        (char *)"agrave",      (char *)"aacute",      (char *)"acircumflex",      (char *)"atilde", 
        (char *)"adieresis",      (char *)"aring",      (char *)"ae",      (char *)"ccedilla", 
        (char *)"egrave",      (char *)"eacute",      (char *)"ecircumflex",      (char *)"edieresis", 
        (char *)"igrave",      (char *)"iacute",      (char *)"icircumflex",      (char *)"idieresis", 
        (char *)"eth",      (char *)"ntilde",      (char *)"ograve",      (char *)"oacute", 
        (char *)"ocircumflex",      (char *)"otilde",      (char *)"odieresis",      (char *)"divide", 
        (char *)"oslash",      (char *)"ugrave",      (char *)"uacute",      (char *)"ucircumflex", 
        (char *)"udieresis",      (char *)"yacute",      (char *)"thorn",      (char *)"ydieresis"};
#line 384 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void setLatin1Enc(char **encoding ) 
{ 


  {
  {
#line 643
  copyenc(encoding, (char **)(latin1enc));
  }
#line 644
  return;
}
}
#line 646 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
char *AdobeExpertEncoding[256]  = 
#line 646
  {      (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)"space",      (char *)"exclamsmall",      (char *)"Hungarumlautsmal",      (char *)".notdef", 
        (char *)"dollaroldstyle",      (char *)"dollarsuperior",      (char *)"ampersandsmall",      (char *)"Acutesmall", 
        (char *)"parenleftsuperior",      (char *)"parenrightsuperior",      (char *)"twodotenleader",      (char *)"onedotenleader", 
        (char *)"comma",      (char *)"hyphen",      (char *)"period",      (char *)"fraction", 
        (char *)"zerooldstyle",      (char *)"oneoldstyle",      (char *)"twooldstyle",      (char *)"threeoldstyle", 
        (char *)"fouroldstyle",      (char *)"fiveoldstyle",      (char *)"sixoldstyle",      (char *)"sevenoldstyle", 
        (char *)"eightoldstyle",      (char *)"nineoldstyle",      (char *)"colon",      (char *)"semicolon", 
        (char *)"commasuperior",      (char *)"threequartersemdash",      (char *)"periodsuperior",      (char *)"questionsmall", 
        (char *)".notdef",      (char *)"asuperior",      (char *)"bsuperior",      (char *)"centsuperior", 
        (char *)"dsuperior",      (char *)"esuperior",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)"isuperior",      (char *)".notdef",      (char *)".notdef", 
        (char *)"lsuperior",      (char *)"msuperior",      (char *)"nsuperior",      (char *)"osuperior", 
        (char *)".notdef",      (char *)".notdef",      (char *)"rsuperior",      (char *)"ssuperior", 
        (char *)"tsuperior",      (char *)".notdef",      (char *)"ff",      (char *)"fi", 
        (char *)"fl",      (char *)"ffi",      (char *)"ffl",      (char *)"parenleftinferior", 
        (char *)".notdef",      (char *)"parenrightinferior",      (char *)"Circumflexsmall",      (char *)"hyphensuperior", 
        (char *)"Gravesmall",      (char *)"Asmall",      (char *)"Bsmall",      (char *)"Csmall", 
        (char *)"Dsmall",      (char *)"Esmall",      (char *)"Fsmall",      (char *)"Gsmall", 
        (char *)"Hsmall",      (char *)"Ismall",      (char *)"Jsmall",      (char *)"Ksmall", 
        (char *)"Lsmall",      (char *)"Msmall",      (char *)"Nsmall",      (char *)"Osmall", 
        (char *)"Psmall",      (char *)"Qsmall",      (char *)"Rsmall",      (char *)"Ssmall", 
        (char *)"Tsmall",      (char *)"Usmall",      (char *)"Vsmall",      (char *)"Wsmall", 
        (char *)"Xsmall",      (char *)"Ysmall",      (char *)"Zsmall",      (char *)"colonmonetary", 
        (char *)"onefitted",      (char *)"rupiah",      (char *)"Tildesmall",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)".notdef",      (char *)"exclamdownsmall",      (char *)"centoldstyle",      (char *)"Lslashsmall", 
        (char *)".notdef",      (char *)".notdef",      (char *)"Scaronsmall",      (char *)"Zcaronsmall", 
        (char *)"Dieresissmall",      (char *)"Brevesmall",      (char *)"Caronsmall",      (char *)".notdef", 
        (char *)"Dotaccentsmall",      (char *)".notdef",      (char *)".notdef",      (char *)"Macronsmall", 
        (char *)".notdef",      (char *)".notdef",      (char *)"figuredash",      (char *)"hypheninferior", 
        (char *)".notdef",      (char *)".notdef",      (char *)"Ogoneksmall",      (char *)"Ringsmall", 
        (char *)"Cedillasmall",      (char *)".notdef",      (char *)".notdef",      (char *)".notdef", 
        (char *)"onequarter",      (char *)"onehalf",      (char *)"threequarters",      (char *)"questiondownsmall", 
        (char *)"oneeighth",      (char *)"threeeighths",      (char *)"fiveeighths",      (char *)"seveneighths", 
        (char *)"onethird",      (char *)"twothirds",      (char *)".notdef",      (char *)".notdef", 
        (char *)"zerosuperior",      (char *)"onesuperior",      (char *)"twosuperior",      (char *)"threesuperior", 
        (char *)"foursuperior",      (char *)"fivesuperior",      (char *)"sixsuperior",      (char *)"sevensuperior", 
        (char *)"eightsuperior",      (char *)"ninesuperior",      (char *)"zeroinferior",      (char *)"oneinferior", 
        (char *)"twoinferior",      (char *)"threeinferior",      (char *)"fourinferior",      (char *)"fiveinferior", 
        (char *)"sixinferior",      (char *)"seveninferior",      (char *)"eightinferior",      (char *)"nineinferior", 
        (char *)"centinferior",      (char *)"dollarinferior",      (char *)"periodinferior",      (char *)"commainferior", 
        (char *)"Agravesmall",      (char *)"Aacutesmall",      (char *)"Acircumflexsmall",      (char *)"Atildesmall", 
        (char *)"Adieresissmall",      (char *)"Aringsmall",      (char *)"AEsmall",      (char *)"Ccedillasmall", 
        (char *)"Egravesmall",      (char *)"Eacutesmall",      (char *)"Ecircumflexsmall",      (char *)"Edieresissmall", 
        (char *)"Igravesmall",      (char *)"Iacutesmall",      (char *)"Icircumflexsmall",      (char *)"Idieresissmall", 
        (char *)"Ethsmall",      (char *)"Ntildesmall",      (char *)"Ogravesmall",      (char *)"Oacutesmall", 
        (char *)"Ocircumflexsmall",      (char *)"Otildesmall",      (char *)"Odieresissmall",      (char *)"OEsmall", 
        (char *)"Oslashsmall",      (char *)"Ugravesmall",      (char *)"Uacutesmall",      (char *)"Ucircumflexsmall", 
        (char *)"Udieresissmall",      (char *)"Yacutesmall",      (char *)"Thornsmall",      (char *)"Ydieresissmall"};
#line 905 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static struct fontdict *MakeEmptyFont(void) 
{ 
  struct fontdict *ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 908
  tmp = calloc((size_t )1, sizeof(struct fontdict ));
#line 908
  ret = (struct fontdict *)tmp;
#line 909
  tmp___0 = calloc((size_t )1, sizeof(struct fontinfo ));
#line 909
  ret->fontinfo = (struct fontinfo *)tmp___0;
#line 910
  tmp___1 = calloc((size_t )1, sizeof(struct pschars ));
#line 910
  ret->chars = (struct pschars *)tmp___1;
#line 911
  tmp___2 = calloc((size_t )1, sizeof(struct private ));
#line 911
  ret->private = (struct private *)tmp___2;
#line 912
  tmp___3 = calloc((size_t )1, sizeof(struct pschars ));
#line 912
  (ret->private)->subrs = (struct pschars *)tmp___3;
#line 913
  tmp___4 = calloc((size_t )1, sizeof(struct psdict ));
#line 913
  (ret->private)->private = (struct psdict *)tmp___4;
#line 914
  (ret->private)->leniv = 4;
#line 915
  (ret->fontinfo)->fstype = -1;
  }
#line 916
  return (ret);
}
}
#line 919 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static struct fontdict *PSMakeEmptyFont(void) 
{ 
  struct fontdict *ret ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;
  void *tmp___5 ;

  {
  {
#line 922
  tmp = calloc((size_t )1, sizeof(struct fontdict ));
#line 922
  ret = (struct fontdict *)tmp;
#line 923
  tmp___0 = calloc((size_t )1, sizeof(struct fontinfo ));
#line 923
  ret->fontinfo = (struct fontinfo *)tmp___0;
#line 924
  tmp___1 = calloc((size_t )1, sizeof(struct pschars ));
#line 924
  ret->chars = (struct pschars *)tmp___1;
#line 925
  tmp___2 = calloc((size_t )1, sizeof(struct private ));
#line 925
  ret->private = (struct private *)tmp___2;
#line 926
  tmp___3 = calloc((size_t )1, sizeof(struct pschars ));
#line 926
  (ret->private)->subrs = (struct pschars *)tmp___3;
#line 927
  tmp___4 = calloc((size_t )1, sizeof(struct psdict ));
#line 927
  (ret->private)->private = (struct psdict *)tmp___4;
#line 928
  (ret->private)->leniv = 4;
#line 929
  tmp___5 = calloc((size_t )1, sizeof(struct charprocs ));
#line 929
  ret->charprocs = (struct charprocs *)tmp___5;
#line 930
  (ret->fontinfo)->fstype = -1;
  }
#line 931
  return (ret);
}
}
#line 934 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *myfgets(char *str , int len , FILE *file ) 
{ 
  char *pt ;
  char *end___0 ;
  int ch ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
#line 936
  ch = 0;
#line 938
  pt = str;
#line 938
  end___0 = (str + len) - 1;
  {
#line 938
  while (1) {
    while_continue: /* CIL Label */ ;
#line 938
    if ((unsigned long )pt < (unsigned long )end___0) {
      {
#line 938
      ch = _IO_getc(file);
      }
#line 938
      if (ch != -1) {
#line 938
        if (ch != 13) {
#line 938
          if (! (ch != 10)) {
#line 938
            goto while_break;
          }
        } else {
#line 938
          goto while_break;
        }
      } else {
#line 938
        goto while_break;
      }
    } else {
#line 938
      goto while_break;
    }
#line 938
    tmp = pt;
#line 938
    pt ++;
#line 938
    *tmp = (char )ch;
  }
  while_break: /* CIL Label */ ;
  }
#line 940
  if (ch == 10) {
#line 941
    tmp___0 = pt;
#line 941
    pt ++;
#line 941
    *tmp___0 = (char )'\n';
  } else
#line 942
  if (ch == 13) {
    {
#line 943
    tmp___1 = pt;
#line 943
    pt ++;
#line 943
    *tmp___1 = (char )'\r';
#line 944
    ch = _IO_getc(file);
    }
#line 944
    if (ch != 10) {
      {
#line 945
      ungetc(ch, file);
      }
    } else {
#line 947
      tmp___2 = pt;
#line 947
      pt ++;
#line 947
      *tmp___2 = (char )'\n';
    }
  }
#line 949
  if ((unsigned long )pt == (unsigned long )str) {
#line 950
    return ((char *)((void *)0));
  }
#line 951
  *pt = (char )'\000';
#line 952
  return (str);
}
}
#line 955 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *getstring(char *start , FILE *in ) 
{ 
  char *end___0 ;
  char *ret ;
  int parencnt ;
  int len ;
  char buffer___0[512] ;
  char *tmp ;
  char *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  char *tmp___3 ;

  {
#line 957
  parencnt = 0;
#line 957
  len = 0;
  {
#line 960
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 961
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 961
      if ((int )*start != 0) {
#line 961
        if (! ((int )*start != 40)) {
#line 961
          goto while_break___0;
        }
      } else {
#line 961
        goto while_break___0;
      }
#line 961
      start ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 962
    if ((int )*start == 0) {
      {
#line 963
      tmp___0 = myfgets(buffer___0, (int )sizeof(buffer___0), in);
      }
#line 963
      if ((unsigned long )tmp___0 == (unsigned long )((void *)0)) {
        {
#line 964
        tmp = strdup("");
        }
#line 964
        return (tmp);
      }
#line 965
      start = buffer___0;
    } else {
#line 967
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 969
  start ++;
#line 970
  ret = (char *)((void *)0);
#line 970
  len = 1;
  {
#line 971
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 972
    end___0 = start;
    {
#line 972
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 972
      if ((int )*end___0 != 0) {
#line 972
        if (! ((int )*end___0 != 41)) {
#line 972
          if (! (parencnt > 0)) {
#line 972
            goto while_break___2;
          }
        }
      } else {
#line 972
        goto while_break___2;
      }
#line 973
      if ((int )*end___0 == 92) {
#line 973
        if ((int )*(end___0 + 1) == 40) {
#line 974
          end___0 ++;
        } else
#line 973
        if ((int )*(end___0 + 1) == 41) {
#line 974
          end___0 ++;
        } else {
#line 973
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 975
      if ((int )*end___0 == 40) {
#line 975
        parencnt ++;
      } else
#line 976
      if ((int )*end___0 == 41) {
#line 976
        parencnt --;
      }
#line 972
      end___0 ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 978
    if ((unsigned long )end___0 > (unsigned long )start) {
#line 979
      if ((unsigned long )ret == (unsigned long )((void *)0)) {
        {
#line 980
        tmp___1 = malloc((size_t )((end___0 - start) + 1L));
#line 980
        ret = (char *)tmp___1;
        }
      } else {
        {
#line 982
        tmp___2 = realloc((void *)ret, (size_t )((end___0 + len) - start));
#line 982
        ret = (char *)tmp___2;
        }
      }
      {
#line 983
      strncpy((char */* __restrict  */)((ret + len) - 1), (char const   */* __restrict  */)start,
              (size_t )(end___0 - start));
#line 984
      len = (int )((long )len + (end___0 - start));
#line 985
      *(ret + (len - 1)) = (char )'\000';
      }
    }
#line 987
    if ((int )*end___0 != 0) {
#line 988
      goto while_break___1;
    }
    {
#line 989
    tmp___3 = myfgets(buffer___0, (int )sizeof(buffer___0), in);
    }
#line 989
    if ((unsigned long )tmp___3 == (unsigned long )((void *)0)) {
#line 990
      return (ret);
    }
#line 991
    start = buffer___0;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 993
  return (ret);
}
}
#line 996 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *gettoken(char *start ) 
{ 
  char *end___0 ;
  char *ret ;
  unsigned short const   **tmp ;
  void *tmp___0 ;

  {
  {
#line 999
  while (1) {
    while_continue: /* CIL Label */ ;
#line 999
    if ((int )*start != 0) {
#line 999
      if (! ((int )*start != 47)) {
#line 999
        goto while_break;
      }
    } else {
#line 999
      goto while_break;
    }
#line 999
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1000
  if ((int )*start == 47) {
#line 1000
    start ++;
  }
#line 1001
  end___0 = start;
  {
#line 1001
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1001
    if ((int )*end___0 != 0) {
      {
#line 1001
      tmp = __ctype_b_loc();
      }
#line 1001
      if ((int const   )*(*tmp + (int )*end___0) & 8192) {
#line 1001
        goto while_break___0;
      } else
#line 1001
      if ((int )*end___0 != 91) {
#line 1001
        if ((int )*end___0 != 47) {
#line 1001
          if ((int )*end___0 != 123) {
#line 1001
            if (! ((int )*end___0 != 40)) {
#line 1001
              goto while_break___0;
            }
          } else {
#line 1001
            goto while_break___0;
          }
        } else {
#line 1001
          goto while_break___0;
        }
      } else {
#line 1001
        goto while_break___0;
      }
    } else {
#line 1001
      goto while_break___0;
    }
#line 1001
    end___0 ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1002
  tmp___0 = malloc((size_t )((end___0 - start) + 1L));
#line 1002
  ret = (char *)tmp___0;
  }
#line 1003
  if ((unsigned long )end___0 > (unsigned long )start) {
    {
#line 1004
    strncpy((char */* __restrict  */)ret, (char const   */* __restrict  */)start,
            (size_t )(end___0 - start));
    }
  }
#line 1005
  *(ret + (end___0 - start)) = (char )'\000';
#line 1006
  return (ret);
}
}
#line 1009 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static int getbool(char *start ) 
{ 
  unsigned short const   **tmp ;

  {
  {
#line 1011
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1011
    tmp = __ctype_b_loc();
    }
#line 1011
    if (! ((int const   )*(*tmp + (int )*start) & 8192)) {
#line 1011
      goto while_break;
    }
#line 1011
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1012
  if ((int )*start == 84) {
#line 1013
    return (1);
  } else
#line 1012
  if ((int )*start == 116) {
#line 1013
    return (1);
  }
#line 1015
  return (0);
}
}
#line 1018 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void fillintarray(int *array , char *start , int maxentries ) 
{ 
  int i ;
  char *end___0 ;
  double tmp ;
  unsigned short const   **tmp___0 ;

  {
  {
#line 1022
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1022
    if ((int )*start != 0) {
#line 1022
      if ((int )*start != 91) {
#line 1022
        if (! ((int )*start != 123)) {
#line 1022
          goto while_break;
        }
      } else {
#line 1022
        goto while_break;
      }
    } else {
#line 1022
      goto while_break;
    }
#line 1022
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1023
  if ((int )*start == 91) {
#line 1023
    start ++;
  } else
#line 1023
  if ((int )*start == 123) {
#line 1023
    start ++;
  }
#line 1024
  i = 0;
  {
#line 1024
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1024
    if (i < maxentries) {
#line 1024
      if ((int )*start != 93) {
#line 1024
        if (! ((int )*start != 125)) {
#line 1024
          goto while_break___0;
        }
      } else {
#line 1024
        goto while_break___0;
      }
    } else {
#line 1024
      goto while_break___0;
    }
    {
#line 1025
    tmp = strtod((char const   */* __restrict  */)start, (char **/* __restrict  */)(& end___0));
#line 1025
    *(array + i) = (int )tmp;
    }
#line 1026
    if ((unsigned long )start == (unsigned long )end___0) {
#line 1027
      return;
    }
#line 1028
    start = end___0;
    {
#line 1029
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1029
      tmp___0 = __ctype_b_loc();
      }
#line 1029
      if (! ((int const   )*(*tmp___0 + (int )*start) & 8192)) {
#line 1029
        goto while_break___1;
      }
#line 1029
      start ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 1024
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1031
  return;
}
}
#line 1033 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void filldoublearray(double *array , char *start , int maxentries ) 
{ 
  int i ;
  char *end___0 ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;

  {
  {
#line 1037
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1037
    if ((int )*start != 0) {
#line 1037
      if ((int )*start != 91) {
#line 1037
        if (! ((int )*start != 123)) {
#line 1037
          goto while_break;
        }
      } else {
#line 1037
        goto while_break;
      }
    } else {
#line 1037
      goto while_break;
    }
#line 1037
    start ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1038
  if ((int )*start == 91) {
#line 1038
    start ++;
  } else
#line 1038
  if ((int )*start == 123) {
#line 1038
    start ++;
  }
#line 1039
  i = 0;
  {
#line 1039
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1039
    if (i < maxentries) {
#line 1039
      if ((int )*start != 93) {
#line 1039
        if (! ((int )*start != 125)) {
#line 1039
          goto while_break___0;
        }
      } else {
#line 1039
        goto while_break___0;
      }
    } else {
#line 1039
      goto while_break___0;
    }
    {
#line 1040
    while (1) {
      while_continue___1: /* CIL Label */ ;
      {
#line 1040
      tmp = __ctype_b_loc();
      }
#line 1040
      if (! ((int const   )*(*tmp + (int )*start) & 8192)) {
#line 1040
        goto while_break___1;
      }
#line 1040
      start ++;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 1041
    tmp___1 = __ctype_b_loc();
    }
#line 1041
    if ((int const   )*(*tmp___1 + (int )*start) & 2048) {
      {
#line 1042
      *(array + i) = strtod((char const   */* __restrict  */)start, (char **/* __restrict  */)(& end___0));
      }
    } else
#line 1041
    if ((int )*start == 45) {
      {
#line 1042
      *(array + i) = strtod((char const   */* __restrict  */)start, (char **/* __restrict  */)(& end___0));
      }
    } else
#line 1041
    if ((int )*start == 46) {
      {
#line 1042
      *(array + i) = strtod((char const   */* __restrict  */)start, (char **/* __restrict  */)(& end___0));
      }
    } else {
      {
#line 1043
      tmp___0 = strncmp((char const   *)start, "div", (size_t )3);
      }
#line 1043
      if (tmp___0 == 0) {
#line 1043
        if (i >= 2) {
#line 1045
          *(array + (i - 2)) /= *(array + (i - 1));
#line 1046
          i -= 2;
#line 1047
          end___0 = start + 3;
        } else {
#line 1049
          return;
        }
      } else {
#line 1049
        return;
      }
    }
#line 1050
    if ((unsigned long )start == (unsigned long )end___0) {
#line 1051
      return;
    }
#line 1052
    start = end___0;
    {
#line 1053
    while (1) {
      while_continue___2: /* CIL Label */ ;
      {
#line 1053
      tmp___2 = __ctype_b_loc();
      }
#line 1053
      if (! ((int const   )*(*tmp___2 + (int )*start) & 8192)) {
#line 1053
        goto while_break___2;
      }
#line 1053
      start ++;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1039
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 1055
  return;
}
}
#line 1057 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void InitDict(struct psdict *dict , char *line ) 
{ 
  unsigned short const   **tmp ;
  long tmp___0 ;
  int i ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;
  void *tmp___4 ;

  {
  {
#line 1058
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1058
    if ((int )*line != 47) {
#line 1058
      if (! ((int )*line != 0)) {
#line 1058
        goto while_break;
      }
    } else {
#line 1058
      goto while_break;
    }
#line 1058
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1059
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1059
    tmp = __ctype_b_loc();
    }
#line 1059
    if ((int const   )*(*tmp + (int )*line) & 8192) {
#line 1059
      goto while_break___0;
    } else
#line 1059
    if (! ((int )*line != 0)) {
#line 1059
      goto while_break___0;
    }
#line 1059
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1060
  tmp___0 = strtol((char const   */* __restrict  */)line, (char **/* __restrict  */)((void *)0),
                   10);
#line 1060
  dict->cnt = (int )((long )dict->cnt + tmp___0);
  }
#line 1061
  if (dict->next > 0) {
    {
#line 1062
    tmp___1 = realloc((void *)dict->keys, (unsigned long )dict->cnt * sizeof(char *));
#line 1062
    dict->keys = (char **)tmp___1;
#line 1063
    tmp___2 = realloc((void *)dict->values, (unsigned long )dict->cnt * sizeof(char *));
#line 1063
    dict->values = (char **)tmp___2;
#line 1064
    i = dict->next;
    }
    {
#line 1064
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 1064
      if (! (i < dict->cnt)) {
#line 1064
        goto while_break___1;
      }
#line 1065
      *(dict->keys + i) = (char *)((void *)0);
#line 1065
      *(dict->values + i) = (char *)((void *)0);
#line 1064
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
    {
#line 1068
    tmp___3 = calloc((size_t )dict->cnt, sizeof(char *));
#line 1068
    dict->keys = (char **)tmp___3;
#line 1069
    tmp___4 = calloc((size_t )dict->cnt, sizeof(char *));
#line 1069
    dict->values = (char **)tmp___4;
    }
  }
#line 1071
  return;
}
}
#line 1073 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void InitChars(struct pschars *chars , char *line ) 
{ 
  unsigned short const   **tmp ;
  long tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  void *tmp___3 ;

  {
  {
#line 1074
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1074
    if ((int )*line != 47) {
#line 1074
      if (! ((int )*line != 0)) {
#line 1074
        goto while_break;
      }
    } else {
#line 1074
      goto while_break;
    }
#line 1074
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1075
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1075
    tmp = __ctype_b_loc();
    }
#line 1075
    if ((int const   )*(*tmp + (int )*line) & 8192) {
#line 1075
      goto while_break___0;
    } else
#line 1075
    if (! ((int )*line != 0)) {
#line 1075
      goto while_break___0;
    }
#line 1075
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1076
  tmp___0 = strtol((char const   */* __restrict  */)line, (char **/* __restrict  */)((void *)0),
                   10);
#line 1076
  chars->cnt = (int )tmp___0;
  }
#line 1077
  if (chars->cnt > 0) {
    {
#line 1078
    tmp___1 = calloc((size_t )chars->cnt, sizeof(char *));
#line 1078
    chars->keys = (char **)tmp___1;
#line 1079
    tmp___2 = calloc((size_t )chars->cnt, sizeof(char *));
#line 1079
    chars->values = (unsigned char **)tmp___2;
#line 1080
    tmp___3 = calloc((size_t )chars->cnt, sizeof(int ));
#line 1080
    chars->lens = (int *)tmp___3;
    }
  }
#line 1082
  return;
}
}
#line 1084 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void InitCharProcs(struct charprocs *cp , char *line ) 
{ 
  unsigned short const   **tmp ;
  long tmp___0 ;
  void *tmp___1 ;

  {
  {
#line 1085
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1085
    if ((int )*line != 47) {
#line 1085
      if (! ((int )*line != 0)) {
#line 1085
        goto while_break;
      }
    } else {
#line 1085
      goto while_break;
    }
#line 1085
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1086
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 1086
    tmp = __ctype_b_loc();
    }
#line 1086
    if ((int const   )*(*tmp + (int )*line) & 8192) {
#line 1086
      goto while_break___0;
    } else
#line 1086
    if (! ((int )*line != 0)) {
#line 1086
      goto while_break___0;
    }
#line 1086
    line ++;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1087
  tmp___0 = strtol((char const   */* __restrict  */)line, (char **/* __restrict  */)((void *)0),
                   10);
#line 1087
  cp->cnt = (int )tmp___0;
  }
#line 1088
  if (cp->cnt > 0) {
    {
#line 1089
    tmp___1 = calloc((size_t )cp->cnt, sizeof(char *));
#line 1089
    cp->keys = (char **)tmp___1;
#line 1090
    cp->values = (void **)((void *)0);
    }
  }
#line 1092
  return;
}
}
#line 1094 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static int mycmp(char *str , char *within , char *end___0 ) 
{ 
  int tmp ;

  {
  {
#line 1095
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1095
    if (! ((unsigned long )within < (unsigned long )end___0)) {
#line 1095
      goto while_break;
    }
#line 1096
    if ((int )*str != (int )*within) {
#line 1097
      return ((int )*str - (int )*within);
    }
#line 1098
    str ++;
#line 1098
    within ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1100
  if ((int )*str == 0) {
#line 1100
    tmp = 0;
  } else {
#line 1100
    tmp = 1;
  }
#line 1100
  return (tmp);
}
}
#line 1103 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void ContinueValue(struct fontparse *fp , struct psdict *dict , char *line ) 
{ 
  int incomment ;
  unsigned short const   **tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int len ;
  int off ;
  void *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;

  {
#line 1104
  incomment = 0;
  {
#line 1106
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1106
    if (! *line) {
#line 1106
      goto while_break;
    }
#line 1107
    if (! fp->instring) {
#line 1107
      if (fp->depth == 0) {
        {
#line 1107
        tmp___3 = strncmp((char const   *)line, "def", (size_t )3);
        }
#line 1107
        if (tmp___3 == 0) {
#line 1107
          goto _L___1;
        } else {
          {
#line 1107
          tmp___4 = strncmp((char const   *)line, "|-", (size_t )2);
          }
#line 1107
          if (tmp___4 == 0) {
#line 1107
            goto _L___1;
          } else {
            {
#line 1107
            tmp___5 = strncmp((char const   *)line, "ND", (size_t )2);
            }
#line 1107
            if (tmp___5 == 0) {
              _L___1: /* CIL Label */ 
              {
#line 1110
              while (1) {
                while_continue___0: /* CIL Label */ ;
                {
#line 1111
                while (1) {
                  while_continue___1: /* CIL Label */ ;
#line 1111
                  if ((unsigned long )fp->vpt > (unsigned long )(fp->vbuf + 1)) {
                    {
#line 1111
                    tmp = __ctype_b_loc();
                    }
#line 1111
                    if (! ((int const   )*(*tmp + (int )*(fp->vpt + -1)) & 8192)) {
#line 1111
                      goto while_break___1;
                    }
                  } else {
#line 1111
                    goto while_break___1;
                  }
#line 1112
                  (fp->vpt) --;
                }
                while_break___1: /* CIL Label */ ;
                }
#line 1113
                if ((unsigned long )fp->vpt > (unsigned long )(fp->vbuf + 8)) {
                  {
#line 1113
                  tmp___2 = strncmp((char const   *)(fp->vpt - 8), "noaccess", (size_t )8);
                  }
#line 1113
                  if (tmp___2 == 0) {
#line 1114
                    fp->vpt -= 8;
                  } else {
#line 1113
                    goto _L___0;
                  }
                } else
                _L___0: /* CIL Label */ 
#line 1115
                if ((unsigned long )fp->vpt > (unsigned long )(fp->vbuf + 8)) {
                  {
#line 1115
                  tmp___1 = strncmp((char const   *)(fp->vpt - 8), "readonly", (size_t )8);
                  }
#line 1115
                  if (tmp___1 == 0) {
#line 1116
                    fp->vpt -= 8;
                  } else {
#line 1115
                    goto _L;
                  }
                } else
                _L: /* CIL Label */ 
#line 1117
                if ((unsigned long )fp->vpt > (unsigned long )(fp->vbuf + 4)) {
                  {
#line 1117
                  tmp___0 = strncmp((char const   *)(fp->vpt - 4), "bind", (size_t )4);
                  }
#line 1117
                  if (tmp___0 == 0) {
#line 1118
                    fp->vpt -= 4;
                  } else {
#line 1120
                    goto while_break___0;
                  }
                } else {
#line 1120
                  goto while_break___0;
                }
              }
              while_break___0: /* CIL Label */ ;
              }
#line 1126
              if ((unsigned long )fp->pending_parse != (unsigned long )((void *)0)) {
                {
#line 1127
                *(fp->pending_parse) = copyn((char const   *)fp->vbuf, fp->vpt - fp->vbuf);
#line 1128
                fp->pending_parse = (char **)((void *)0);
                }
              } else {
                {
#line 1130
                *(dict->values + dict->next) = copyn((char const   *)fp->vbuf, fp->vpt - fp->vbuf);
#line 1131
                (dict->next) ++;
                }
              }
#line 1133
              fp->vpt = fp->vbuf;
#line 1134
              fp->multiline = 0U;
#line 1135
              return;
            }
          }
        }
      }
    }
#line 1137
    if ((unsigned long )fp->vpt >= (unsigned long )fp->vmax) {
      {
#line 1138
      len = (int )((fp->vmax - fp->vbuf) + 1000L);
#line 1138
      off = (int )(fp->vpt - fp->vbuf);
#line 1139
      tmp___6 = realloc((void *)fp->vbuf, (size_t )len);
#line 1139
      fp->vbuf = (char *)tmp___6;
#line 1140
      fp->vpt = fp->vbuf + off;
#line 1141
      fp->vmax = fp->vbuf + len;
      }
    }
#line 1143
    if (fp->instring) {
#line 1144
      if ((int )*line == 41) {
#line 1144
        (fp->instring) --;
      }
    } else
#line 1145
    if (! incomment) {
#line 1147
      if ((int )*line == 40) {
#line 1148
        (fp->instring) ++;
      } else
#line 1149
      if ((int )*line == 37) {
#line 1150
        incomment = 1;
      } else
#line 1151
      if ((int )*line == 91) {
#line 1152
        (fp->depth) ++;
      } else
#line 1151
      if ((int )*line == 123) {
#line 1152
        (fp->depth) ++;
      } else
#line 1153
      if ((int )*line == 125) {
#line 1154
        (fp->depth) --;
      } else
#line 1153
      if ((int )*line == 93) {
#line 1154
        (fp->depth) --;
      }
    }
#line 1155
    tmp___7 = fp->vpt;
#line 1155
    (fp->vpt) ++;
#line 1155
    tmp___8 = line;
#line 1155
    line ++;
#line 1155
    *tmp___7 = *tmp___8;
  }
  while_break: /* CIL Label */ ;
  }
#line 1157
  return;
}
}
#line 1159 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void AddValue(struct fontparse *fp , struct psdict *dict , char *line , char *endtok ) 
{ 
  char *pt ;
  void *tmp ;
  void *tmp___0 ;
  size_t tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  unsigned short const   **tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
#line 1162
  if ((unsigned long )dict != (unsigned long )((void *)0)) {
#line 1163
    if (dict->next >= dict->cnt) {
      {
#line 1164
      dict->cnt += 10;
#line 1165
      tmp = realloc((void *)dict->keys, (unsigned long )dict->cnt * sizeof(char *));
#line 1165
      dict->keys = (char **)tmp;
#line 1166
      tmp___0 = realloc((void *)dict->values, (unsigned long )dict->cnt * sizeof(char *));
#line 1166
      dict->values = (char **)tmp___0;
      }
    }
    {
#line 1168
    *(dict->keys + dict->next) = copyn((char const   *)(line + 1), endtok - (line + 1));
    }
  }
  {
#line 1170
  tmp___1 = strlen((char const   *)line);
#line 1170
  pt = (line + tmp___1) - 1;
  }
  {
#line 1171
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1171
    tmp___2 = __ctype_b_loc();
    }
#line 1171
    if (! ((int const   )*(*tmp___2 + (int )*endtok) & 8192)) {
#line 1171
      goto while_break;
    }
#line 1171
    endtok ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 1172
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 1172
    if ((unsigned long )pt > (unsigned long )endtok) {
      {
#line 1172
      tmp___3 = __ctype_b_loc();
      }
#line 1172
      if (! ((int const   )*(*tmp___3 + (int )*pt) & 8192)) {
#line 1172
        goto while_break___0;
      }
    } else {
#line 1172
      goto while_break___0;
    }
#line 1172
    pt --;
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 1173
  pt ++;
#line 1174
  tmp___6 = strncmp((char const   *)(pt - 3), "def", (size_t )3);
  }
#line 1174
  if (tmp___6 == 0) {
#line 1175
    pt -= 3;
  } else {
    {
#line 1176
    tmp___4 = strncmp((char const   *)(pt - 2), "|-", (size_t )2);
    }
#line 1176
    if (tmp___4 == 0) {
#line 1177
      pt -= 2;
    } else {
      {
#line 1176
      tmp___5 = strncmp((char const   *)(pt - 2), "ND", (size_t )2);
      }
#line 1176
      if (tmp___5 == 0) {
#line 1177
        pt -= 2;
      } else {
        {
#line 1179
        fp->multiline = 1U;
#line 1180
        ContinueValue(fp, dict, endtok);
        }
#line 1181
        return;
      }
    }
  }
  {
#line 1183
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 1184
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 1184
      if ((unsigned long )(pt - 1) > (unsigned long )endtok) {
        {
#line 1184
        tmp___7 = __ctype_b_loc();
        }
#line 1184
        if (! ((int const   )*(*tmp___7 + (int )*(pt + -1)) & 8192)) {
#line 1184
          goto while_break___2;
        }
      } else {
#line 1184
        goto while_break___2;
      }
#line 1184
      pt --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 1185
    if ((unsigned long )(pt - 8) > (unsigned long )endtok) {
      {
#line 1185
      tmp___10 = strncmp((char const   *)(pt - 8), "noaccess", (size_t )8);
      }
#line 1185
      if (tmp___10 == 0) {
#line 1186
        pt -= 8;
      } else {
#line 1185
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 1187
    if ((unsigned long )(pt - 8) > (unsigned long )endtok) {
      {
#line 1187
      tmp___9 = strncmp((char const   *)(pt - 8), "readonly", (size_t )8);
      }
#line 1187
      if (tmp___9 == 0) {
#line 1188
        pt -= 8;
      } else {
#line 1187
        goto _L;
      }
    } else
    _L: /* CIL Label */ 
#line 1189
    if ((unsigned long )(pt - 4) > (unsigned long )endtok) {
      {
#line 1189
      tmp___8 = strncmp((char const   *)(pt - 4), "bind", (size_t )4);
      }
#line 1189
      if (tmp___8 == 0) {
#line 1190
        pt -= 4;
      } else {
#line 1192
        goto while_break___1;
      }
    } else {
#line 1192
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
#line 1194
  if ((unsigned long )dict != (unsigned long )((void *)0)) {
    {
#line 1195
    *(dict->values + dict->next) = copyn((char const   *)endtok, pt - endtok);
#line 1196
    (dict->next) ++;
    }
  } else {
    {
#line 1198
    *(fp->pending_parse) = copyn((char const   *)endtok, pt - endtok);
#line 1199
    fp->pending_parse = (char **)((void *)0);
    }
  }
#line 1201
  return;
}
}
#line 1203 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static int hex(int ch1 , int ch2 ) 
{ 


  {
#line 1204
  if (ch1 >= 48) {
#line 1204
    if (ch1 <= 57) {
#line 1205
      ch1 -= 48;
    } else {
#line 1204
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 1206
  if (ch1 >= 97) {
#line 1207
    ch1 -= 87;
  } else {
#line 1209
    ch1 -= 55;
  }
#line 1210
  if (ch2 >= 48) {
#line 1210
    if (ch2 <= 57) {
#line 1211
      ch2 -= 48;
    } else {
#line 1210
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 1212
  if (ch2 >= 97) {
#line 1213
    ch2 -= 87;
  } else {
#line 1215
    ch2 -= 55;
  }
#line 1216
  return ((ch1 << 4) | ch2);
}
}
#line 1219 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
unsigned short r  ;
#line 1223 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void initcode(void) 
{ 


  {
#line 1224
  r = (unsigned short)55665;
#line 1225
  return;
}
}
#line 1227 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static int decode(unsigned char cypher ) 
{ 
  unsigned char plain ;

  {
#line 1228
  plain = (unsigned char )((int )cypher ^ ((int )r >> 8));
#line 1229
  r = (unsigned short )(((int )cypher + (int )r) * 52845 + 22719);
#line 1230
  return ((int )plain);
}
}
#line 1233 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void dumpzeros(FILE *out , unsigned char *zeros , int zcnt ) 
{ 
  unsigned char *tmp ;

  {
  {
#line 1234
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1234
    zcnt --;
#line 1234
    if (! (zcnt >= 0)) {
#line 1234
      goto while_break;
    }
    {
#line 1235
    tmp = zeros;
#line 1235
    zeros ++;
#line 1235
    fputc((int )*tmp, out);
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 1236
  return;
}
}
#line 1238 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void decodestr(unsigned char *str , int len ) 
{ 
  unsigned short r___0 ;
  unsigned char plain ;
  unsigned char cypher ;
  unsigned char *tmp ;
  int tmp___0 ;

  {
#line 1239
  r___0 = (unsigned short)4330;
  {
#line 1242
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1242
    tmp___0 = len;
#line 1242
    len --;
#line 1242
    if (! (tmp___0 > 0)) {
#line 1242
      goto while_break;
    }
#line 1243
    cypher = *str;
#line 1244
    plain = (unsigned char )((int )cypher ^ ((int )r___0 >> 8));
#line 1245
    r___0 = (unsigned short )(((int )cypher + (int )r___0) * 52845 + 22719);
#line 1246
    tmp = str;
#line 1246
    str ++;
#line 1246
    *tmp = plain;
  }
  while_break: /* CIL Label */ ;
  }
#line 1248
  return;
}
}
#line 1250 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void findstring(struct fontparse *fp , struct pschars *subrs , int index___0 ,
                       char *nametok , char *str ) 
{ 
  char buffer___0[1024] ;
  char *bpt ;
  char *bs ;
  char *end___0 ;
  int val ;
  unsigned short const   **tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  unsigned short const   **tmp___4 ;
  unsigned short const   **tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  void *tmp___9 ;

  {
#line 1251
  end___0 = (buffer___0 + sizeof(buffer___0)) - 1;
  {
#line 1254
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1254
    tmp = __ctype_b_loc();
    }
#line 1254
    if (! ((int const   )*(*tmp + (int )*str) & 8192)) {
#line 1254
      goto while_break;
    }
#line 1254
    str ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1255
  if ((int )*str == 40) {
#line 1256
    str ++;
#line 1257
    bpt = buffer___0;
    {
#line 1258
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 1258
      if (! ((int )*str != 41)) {
#line 1258
        goto while_break___0;
      }
#line 1259
      if ((int )*str != 92) {
#line 1260
        tmp___0 = str;
#line 1260
        str ++;
#line 1260
        val = (int )*tmp___0;
      } else {
        {
#line 1262
        tmp___7 = __ctype_b_loc();
#line 1262
        str ++;
        }
#line 1262
        if ((int const   )*(*tmp___7 + (int )*str) & 2048) {
          {
#line 1263
          tmp___1 = str;
#line 1263
          str ++;
#line 1263
          val = (int )*tmp___1 - 48;
#line 1264
          tmp___5 = __ctype_b_loc();
          }
#line 1264
          if ((int const   )*(*tmp___5 + (int )*str) & 2048) {
            {
#line 1265
            tmp___2 = str;
#line 1265
            str ++;
#line 1265
            val = (val << 3) | ((int )*tmp___2 - 48);
#line 1266
            tmp___4 = __ctype_b_loc();
            }
#line 1266
            if ((int const   )*(*tmp___4 + (int )*str) & 2048) {
#line 1267
              tmp___3 = str;
#line 1267
              str ++;
#line 1267
              val = (val << 3) | ((int )*tmp___3 - 48);
            }
          }
        } else {
#line 1270
          tmp___6 = str;
#line 1270
          str ++;
#line 1270
          val = (int )*tmp___6;
        }
      }
#line 1272
      if ((unsigned long )bpt < (unsigned long )end___0) {
#line 1273
        tmp___8 = bpt;
#line 1273
        bpt ++;
#line 1273
        *tmp___8 = (char )val;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 1275
    decodestr((unsigned char *)(buffer___0), (int )(bpt - buffer___0));
#line 1276
    bs = buffer___0 + ((fp->fd)->private)->leniv;
#line 1277
    *(subrs->lens + index___0) = (int )(bpt - bs);
#line 1278
    *(subrs->keys + index___0) = strdup((char const   *)nametok);
#line 1279
    tmp___9 = malloc((size_t )(bpt - bs));
#line 1279
    *(subrs->values + index___0) = (unsigned char *)tmp___9;
#line 1280
    memcpy((void */* __restrict  */)*(subrs->values + index___0), (void const   */* __restrict  */)bs,
           (size_t )(bpt - bs));
    }
#line 1281
    if (index___0 >= subrs->next) {
#line 1281
      subrs->next = index___0 + 1;
    }
  }
#line 1283
  return;
}
}
#line 1285 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *rmbinary(char *line ) 
{ 
  char *pt ;
  size_t tmp ;

  {
#line 1288
  pt = line;
  {
#line 1288
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1288
    if (! *pt) {
#line 1288
      goto while_break;
    }
#line 1289
    if ((int )*pt < 32) {
#line 1289
      goto _L;
    } else
#line 1289
    if ((int )*pt >= 127) {
      _L: /* CIL Label */ 
#line 1289
      if ((int )*pt != 10) {
        {
#line 1290
        tmp = strlen((char const   *)pt);
        }
#line 1290
        if (tmp > 5UL) {
#line 1291
          *(pt + 0) = (char )'.';
#line 1292
          *(pt + 1) = (char )'.';
#line 1293
          *(pt + 2) = (char )'.';
#line 1294
          *(pt + 3) = (char )'\n';
#line 1295
          *(pt + 4) = (char )'\000';
        } else {
#line 1297
          *(pt + 0) = (char )'\n';
#line 1298
          *(pt + 1) = (char )'\000';
        }
#line 1300
        goto while_break;
      }
    }
#line 1288
    pt ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1303
  return (line);
}
}
#line 1306 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void parseline(struct fontparse *fp , char *line , FILE *in ) 
{ 
  char buffer___0[200] ;
  char *pt ;
  char *endtok ;
  char *end___0 ;
  int pos ;
  long tmp ;
  unsigned short const   **tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  int tmp___5 ;
  unsigned short const   **tmp___6 ;
  int tmp___7 ;
  int i ;
  char *end___1 ;
  int pos___0 ;
  unsigned short const   **tmp___8 ;
  long tmp___9 ;
  unsigned short const   **tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  unsigned short const   **tmp___13 ;
  int tmp___14 ;
  struct pschars *subrs ;
  unsigned short const   **tmp___15 ;
  int i___0 ;
  char *ept ;
  long tmp___16 ;
  char *tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  struct pschars *chars ;
  unsigned short const   **tmp___23 ;
  unsigned int tmp___24 ;
  char *tmp___25 ;
  char *tmp___26 ;
  int i___1 ;
  char *namestrt ;
  unsigned short const   **tmp___27 ;
  unsigned short const   **tmp___28 ;
  int tmp___29 ;
  char *tmp___30 ;
  char *tmp___31 ;
  char *tmp___32 ;
  char *tmp___33 ;
  int tmp___34 ;
  unsigned short const   **tmp___35 ;
  unsigned short const   **tmp___36 ;
  unsigned int tmp___37 ;
  unsigned int tmp___38 ;
  unsigned int tmp___39 ;
  unsigned int tmp___40 ;
  unsigned int tmp___41 ;
  char *tmp___42 ;
  char *tmp___43 ;
  char *tmp___44 ;
  char *tmp___45 ;
  unsigned int tmp___46 ;
  unsigned int tmp___47 ;
  unsigned int tmp___48 ;
  unsigned int tmp___49 ;
  unsigned int tmp___50 ;
  unsigned int tmp___51 ;
  unsigned int tmp___52 ;
  unsigned int tmp___53 ;
  unsigned int tmp___54 ;
  unsigned int tmp___55 ;
  unsigned int tmp___56 ;
  unsigned int tmp___57 ;
  void *tmp___58 ;
  long tmp___59 ;
  void *tmp___60 ;
  void *tmp___61 ;
  unsigned int tmp___62 ;
  unsigned int tmp___63 ;
  unsigned int tmp___64 ;
  unsigned int tmp___65 ;
  unsigned int tmp___66 ;
  void *tmp___67 ;
  unsigned int tmp___68 ;
  unsigned int tmp___69 ;
  unsigned int tmp___70 ;
  unsigned int tmp___71 ;
  unsigned int tmp___72 ;
  void *tmp___73 ;
  int tmp___74 ;
  int tmp___75 ;
  long tmp___76 ;
  long tmp___77 ;
  long tmp___78 ;
  long tmp___79 ;
  char *tmp___80 ;
  int tmp___81 ;
  int tmp___82 ;
  int tmp___83 ;
  int tmp___84 ;
  int tmp___85 ;
  int tmp___86 ;
  int tmp___87 ;
  int tmp___88 ;
  int tmp___89 ;
  int tmp___90 ;
  int tmp___91 ;
  int tmp___92 ;
  int tmp___93 ;
  int tmp___94 ;
  int tmp___95 ;
  int tmp___96 ;
  int tmp___97 ;
  char *tmp___98 ;
  struct psdict *subdict ;
  struct psdict *tmp___99 ;
  unsigned int tmp___100 ;
  char *tmp___101 ;
  char *tmp___102 ;
  char *tmp___103 ;
  char *tmp___104 ;
  char *pt___0 ;
  long tmp___105 ;
  long tmp___106 ;
  int tmp___107 ;
  int tmp___108 ;
  int tmp___109 ;
  int tmp___110 ;
  int tmp___111 ;
  int tmp___112 ;
  int tmp___113 ;
  int tmp___114 ;
  int tmp___115 ;
  int tmp___116 ;
  int tmp___117 ;
  long tmp___118 ;
  int tmp___119 ;
  int tmp___120 ;
  int tmp___121 ;
  unsigned int tmp___122 ;
  unsigned int tmp___123 ;
  unsigned int tmp___124 ;
  unsigned int tmp___125 ;
  unsigned int tmp___126 ;
  void *tmp___127 ;
  char *tmp___128 ;
  unsigned int tmp___129 ;
  unsigned int tmp___130 ;
  unsigned int tmp___131 ;
  unsigned int tmp___132 ;
  unsigned int tmp___133 ;
  void *tmp___134 ;
  char *tmp___135 ;
  unsigned int tmp___136 ;
  unsigned int tmp___137 ;
  unsigned int tmp___138 ;
  unsigned int tmp___139 ;
  unsigned int tmp___140 ;
  unsigned int tmp___141 ;
  unsigned int tmp___142 ;
  unsigned int tmp___143 ;
  unsigned int tmp___144 ;
  unsigned int tmp___145 ;
  unsigned int tmp___146 ;
  unsigned int tmp___147 ;
  unsigned int tmp___148 ;
  unsigned int tmp___149 ;
  char *tmp___150 ;
  int tmp___151 ;
  char *tmp___152 ;
  char *tmp___153 ;
  char *tmp___154 ;
  char *tmp___155 ;
  char *tmp___156 ;
  char *tmp___157 ;
  char *tmp___158 ;
  char *tmp___159 ;
  char *tmp___160 ;
  long tmp___161 ;
  long tmp___162 ;
  double temp[6] ;
  long tmp___163 ;
  long tmp___164 ;
  long tmp___165 ;
  long tmp___166 ;
  long tmp___167 ;
  long tmp___168 ;
  long tmp___169 ;
  long tmp___170 ;
  long tmp___171 ;
  long tmp___172 ;
  int i___2 ;
  long tmp___173 ;
  void *tmp___174 ;
  char *tmp___175 ;
  int tmp___176 ;
  int tmp___177 ;
  int tmp___178 ;
  int tmp___179 ;
  int tmp___180 ;
  int tmp___181 ;
  int tmp___182 ;
  int tmp___183 ;
  int tmp___184 ;
  int tmp___185 ;
  int tmp___186 ;
  int tmp___187 ;
  int tmp___188 ;
  char *tmp___189 ;
  char *tmp___190 ;
  int tmp___191 ;
  int tmp___192 ;
  int tmp___193 ;
  int tmp___194 ;
  int tmp___195 ;
  int tmp___196 ;
  int tmp___197 ;
  int tmp___198 ;
  int tmp___199 ;
  int tmp___200 ;
  int tmp___201 ;
  int tmp___202 ;
  int tmp___203 ;
  char *tmp___204 ;
  char *tmp___205 ;
  char *tmp___206 ;
  char *tmp___207 ;
  int tmp___208 ;
  int tmp___209 ;
  int tmp___210 ;

  {
  {
#line 1309
  while (1) {
    while_continue: /* CIL Label */ ;
#line 1309
    if (! ((int )*line == 32)) {
#line 1309
      if (! ((int )*line == 9)) {
#line 1309
        goto while_break;
      }
    }
#line 1309
    line ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 1310
  if ((int )*(line + 0) == 37) {
#line 1310
    if (! fp->multiline) {
#line 1311
      return;
    }
  }
#line 1313
  if (fp->inencoding) {
    {
#line 1313
    tmp___34 = strncmp((char const   *)line, "dup", (size_t )3);
    }
#line 1313
    if (tmp___34 == 0) {
      {
#line 1315
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 1315
        tmp___7 = strncmp((char const   *)line, "dup", (size_t )3);
        }
#line 1315
        if (! (tmp___7 == 0)) {
#line 1315
          goto while_break___0;
        }
        {
#line 1317
        tmp = strtol((char const   */* __restrict  */)(line + 3), (char **/* __restrict  */)(& end___0),
                     10);
#line 1317
        pos = (int )tmp;
#line 1318
        line = end___0;
        }
        {
#line 1319
        while (1) {
          while_continue___1: /* CIL Label */ ;
          {
#line 1319
          tmp___0 = __ctype_b_loc();
          }
#line 1319
          if (! ((int const   )*(*tmp___0 + (int )*line) & 8192)) {
#line 1319
            goto while_break___1;
          }
#line 1319
          line ++;
        }
        while_break___1: /* CIL Label */ ;
        }
#line 1320
        if ((int )*line == 47) {
#line 1320
          line ++;
        }
#line 1321
        pt = buffer___0;
        {
#line 1321
        while (1) {
          while_continue___2: /* CIL Label */ ;
          {
#line 1321
          tmp___3 = __ctype_b_loc();
          }
#line 1321
          if ((int const   )*(*tmp___3 + (int )*line) & 8192) {
#line 1321
            goto while_break___2;
          }
#line 1321
          tmp___1 = pt;
#line 1321
          pt ++;
#line 1321
          tmp___2 = line;
#line 1321
          line ++;
#line 1321
          *tmp___1 = *tmp___2;
        }
        while_break___2: /* CIL Label */ ;
        }
#line 1322
        *pt = (char )'\000';
#line 1323
        if (pos >= 0) {
#line 1323
          if (pos < 256) {
            {
#line 1324
            (fp->fd)->encoding[pos] = strdup((char const   *)(buffer___0));
            }
          }
        }
        {
#line 1325
        while (1) {
          while_continue___3: /* CIL Label */ ;
          {
#line 1325
          tmp___4 = __ctype_b_loc();
          }
#line 1325
          if (! ((int const   )*(*tmp___4 + (int )*line) & 8192)) {
#line 1325
            goto while_break___3;
          }
#line 1325
          line ++;
        }
        while_break___3: /* CIL Label */ ;
        }
        {
#line 1326
        tmp___5 = strncmp((char const   *)line, "put", (size_t )3);
        }
#line 1326
        if (tmp___5 == 0) {
#line 1326
          line += 3;
        }
        {
#line 1327
        while (1) {
          while_continue___4: /* CIL Label */ ;
          {
#line 1327
          tmp___6 = __ctype_b_loc();
          }
#line 1327
          if (! ((int const   )*(*tmp___6 + (int )*line) & 8192)) {
#line 1327
            goto while_break___4;
          }
#line 1327
          line ++;
        }
        while_break___4: /* CIL Label */ ;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 1329
      return;
    } else {
#line 1313
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 1330
  if (fp->inencoding) {
    {
#line 1330
    tmp___32 = strstr((char const   *)line, "for");
    }
#line 1330
    if ((unsigned long )tmp___32 != (unsigned long )((void *)0)) {
      {
#line 1330
      tmp___33 = strstr((char const   *)line, "/.notdef");
      }
#line 1330
      if ((unsigned long )tmp___33 != (unsigned long )((void *)0)) {
#line 1335
        i = 0;
        {
#line 1335
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 1335
          if (! (i < 256)) {
#line 1335
            goto while_break___5;
          }
#line 1336
          if ((unsigned long )(fp->fd)->encoding[i] == (unsigned long )((void *)0)) {
            {
#line 1337
            (fp->fd)->encoding[i] = strdup(".notdef");
            }
          }
#line 1335
          i ++;
        }
        while_break___5: /* CIL Label */ ;
        }
#line 1338
        return;
      } else {
#line 1330
        goto _L___3;
      }
    } else {
#line 1330
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 1339
  if (fp->inencoding) {
    {
#line 1339
    tmp___30 = strstr((char const   *)line, "Encoding");
    }
#line 1339
    if ((unsigned long )tmp___30 != (unsigned long )((void *)0)) {
      {
#line 1339
      tmp___31 = strstr((char const   *)line, "put");
      }
#line 1339
      if ((unsigned long )tmp___31 != (unsigned long )((void *)0)) {
        {
#line 1343
        while (1) {
          while_continue___6: /* CIL Label */ ;
          {
#line 1343
          tmp___8 = __ctype_b_loc();
          }
#line 1343
          if (! ((int const   )*(*tmp___8 + (int )*line) & 8192)) {
#line 1343
            goto while_break___6;
          }
#line 1343
          line ++;
        }
        while_break___6: /* CIL Label */ ;
        }
        {
#line 1344
        tmp___14 = strncmp((char const   *)line, "Encoding ", (size_t )9);
        }
#line 1344
        if (tmp___14 == 0) {
          {
#line 1345
          line += 9;
#line 1346
          tmp___9 = strtol((char const   */* __restrict  */)line, (char **/* __restrict  */)(& end___1),
                           10);
#line 1346
          pos___0 = (int )tmp___9;
#line 1347
          line = end___1;
          }
          {
#line 1348
          while (1) {
            while_continue___7: /* CIL Label */ ;
            {
#line 1348
            tmp___10 = __ctype_b_loc();
            }
#line 1348
            if (! ((int const   )*(*tmp___10 + (int )*line) & 8192)) {
#line 1348
              goto while_break___7;
            }
#line 1348
            line ++;
          }
          while_break___7: /* CIL Label */ ;
          }
#line 1349
          if ((int )*line == 47) {
#line 1350
            line ++;
#line 1351
            pt = buffer___0;
            {
#line 1351
            while (1) {
              while_continue___8: /* CIL Label */ ;
              {
#line 1351
              tmp___13 = __ctype_b_loc();
              }
#line 1351
              if ((int const   )*(*tmp___13 + (int )*line) & 8192) {
#line 1351
                goto while_break___8;
              }
#line 1351
              tmp___11 = pt;
#line 1351
              pt ++;
#line 1351
              tmp___12 = line;
#line 1351
              line ++;
#line 1351
              *tmp___11 = *tmp___12;
            }
            while_break___8: /* CIL Label */ ;
            }
#line 1352
            *pt = (char )'\000';
#line 1353
            if (pos___0 >= 0) {
#line 1353
              if (pos___0 < 256) {
                {
#line 1354
                (fp->fd)->encoding[pos___0] = strdup((char const   *)(buffer___0));
                }
              }
            }
          }
        }
#line 1357
        return;
      } else {
#line 1339
        goto _L___1;
      }
    } else {
#line 1339
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 1358
  if (fp->insubs) {
#line 1359
    subrs = ((fp->fd)->private)->subrs;
    {
#line 1360
    while (1) {
      while_continue___9: /* CIL Label */ ;
      {
#line 1360
      tmp___15 = __ctype_b_loc();
      }
#line 1360
      if (! ((int const   )*(*tmp___15 + (int )*line) & 8192)) {
#line 1360
        goto while_break___9;
      }
#line 1360
      line ++;
    }
    while_break___9: /* CIL Label */ ;
    }
    {
#line 1361
    tmp___22 = strncmp((char const   *)line, "dup ", (size_t )4);
    }
#line 1361
    if (tmp___22 == 0) {
#line 1364
      line += 4;
      {
#line 1364
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 1364
        if (! ((int )*line == 32)) {
#line 1364
          goto while_break___10;
        }
#line 1364
        line ++;
      }
      while_break___10: /* CIL Label */ ;
      }
      {
#line 1365
      tmp___16 = strtol((char const   */* __restrict  */)line, (char **/* __restrict  */)(& ept),
                        10);
#line 1365
      i___0 = (int )tmp___16;
      }
#line 1366
      if (! fp->ignore) {
#line 1368
        if (i___0 < subrs->cnt) {
          {
#line 1369
          findstring(fp, subrs, i___0, (char *)((void *)0), ept);
          }
        } else
#line 1370
        if (! fp->alreadycomplained) {
          {
#line 1371
          tmp___17 = rmbinary(line);
#line 1371
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index too big (must be <%d) |%s",
                  subrs->cnt, tmp___17);
#line 1372
          fp->alreadycomplained = 1U;
          }
        }
      }
    } else {
      {
#line 1374
      tmp___19 = strncmp((char const   *)line, "readonly put", (size_t )12);
      }
#line 1374
      if (tmp___19 == 0) {
#line 1375
        fp->insubs = 0U;
#line 1376
        fp->ignore = 0U;
      } else {
        {
#line 1374
        tmp___20 = strncmp((char const   *)line, "ND", (size_t )2);
        }
#line 1374
        if (tmp___20 == 0) {
#line 1375
          fp->insubs = 0U;
#line 1376
          fp->ignore = 0U;
        } else {
          {
#line 1374
          tmp___21 = strncmp((char const   *)line, "|-", (size_t )2);
          }
#line 1374
          if (tmp___21 == 0) {
#line 1375
            fp->insubs = 0U;
#line 1376
            fp->ignore = 0U;
          } else
#line 1377
          if (! ((int )*line == 10)) {
#line 1377
            if (! ((int )*line == 0)) {
#line 1379
              if (! fp->alreadycomplained) {
                {
#line 1380
                tmp___18 = rmbinary(line);
#line 1380
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Didn\'t understand |%s",
                        tmp___18);
#line 1381
                fp->alreadycomplained = 1U;
                }
              }
            }
          }
        }
      }
    }
  } else
#line 1383
  if (fp->inchars) {
#line 1384
    chars = (fp->fd)->chars;
    {
#line 1385
    while (1) {
      while_continue___11: /* CIL Label */ ;
      {
#line 1385
      tmp___23 = __ctype_b_loc();
      }
#line 1385
      if (! ((int const   )*(*tmp___23 + (int )*line) & 8192)) {
#line 1385
        goto while_break___11;
      }
#line 1385
      line ++;
    }
    while_break___11: /* CIL Label */ ;
    }
    {
#line 1386
    tmp___29 = strncmp((char const   *)line, "end", (size_t )3);
    }
#line 1386
    if (tmp___29 == 0) {
#line 1387
      tmp___24 = 0U;
#line 1387
      fp->inchars = tmp___24;
#line 1387
      fp->ignore = tmp___24;
    } else
#line 1388
    if (! ((int )*line != 10)) {
#line 1388
      if (! ((int )*line == 0)) {
#line 1390
        if ((int )*line != 47) {
          {
#line 1391
          tmp___25 = rmbinary(line);
#line 1391
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No name for CharStrings dictionary |%s",
                  tmp___25);
#line 1392
          fp->alreadycomplained = 1U;
          }
        } else {
          {
#line 1390
          tmp___28 = __ctype_b_loc();
          }
#line 1390
          if ((int const   )*(*tmp___28 + (int )*(line + 1)) & 1024) {
#line 1390
            goto _L;
          } else
#line 1390
          if ((int )*(line + 1) == 46) {
            _L: /* CIL Label */ 
#line 1393
            if (! fp->ignore) {
#line 1395
              if (chars->next >= chars->cnt) {
                {
#line 1396
                tmp___26 = rmbinary(line);
#line 1396
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many entries in CharStrings dictionary |%s",
                        tmp___26);
                }
              } else {
#line 1398
                i___1 = chars->next;
#line 1399
                line ++;
#line 1399
                namestrt = line;
                {
#line 1400
                while (1) {
                  while_continue___12: /* CIL Label */ ;
                  {
#line 1400
                  tmp___27 = __ctype_b_loc();
                  }
#line 1400
                  if (! ((int const   )*(*tmp___27 + (int )*line) & 8)) {
#line 1400
                    if (! ((int )*line == 46)) {
#line 1400
                      goto while_break___12;
                    }
                  }
#line 1400
                  line ++;
                }
                while_break___12: /* CIL Label */ ;
                }
                {
#line 1401
                *line = (char )'\000';
#line 1402
                findstring(fp, chars, i___1, namestrt, line + 1);
                }
              }
            }
          } else {
            {
#line 1391
            tmp___25 = rmbinary(line);
#line 1391
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No name for CharStrings dictionary |%s",
                    tmp___25);
#line 1392
            fp->alreadycomplained = 1U;
            }
          }
        }
      }
    }
  }
#line 1405
  fp->inencoding = 0U;
  {
#line 1407
  while (1) {
    while_continue___13: /* CIL Label */ ;
    {
#line 1407
    tmp___35 = __ctype_b_loc();
    }
#line 1407
    if (! ((int const   )*(*tmp___35 + (int )*line) & 8192)) {
#line 1407
      goto while_break___13;
    }
#line 1407
    line ++;
  }
  while_break___13: /* CIL Label */ ;
  }
#line 1408
  endtok = (char *)((void *)0);
#line 1409
  if ((int )*line == 47) {
#line 1410
    endtok = line + 1;
    {
#line 1410
    while (1) {
      while_continue___14: /* CIL Label */ ;
      {
#line 1410
      tmp___36 = __ctype_b_loc();
      }
#line 1410
      if ((int const   )*(*tmp___36 + (int )*endtok) & 8192) {
#line 1410
        goto while_break___14;
      } else
#line 1410
      if ((int )*endtok != 40) {
#line 1410
        if ((int )*endtok != 123) {
#line 1410
          if ((int )*endtok != 91) {
#line 1410
            if (! ((int )*endtok != 0)) {
#line 1410
              goto while_break___14;
            }
          } else {
#line 1410
            goto while_break___14;
          }
        } else {
#line 1410
          goto while_break___14;
        }
      } else {
#line 1410
        goto while_break___14;
      }
#line 1410
      endtok ++;
    }
    while_break___14: /* CIL Label */ ;
    }
  }
  {
#line 1413
  tmp___42 = strstr((char const   *)line, "/shareddict");
  }
#line 1413
  if ((unsigned long )tmp___42 != (unsigned long )((void *)0)) {
    {
#line 1413
    tmp___43 = strstr((char const   *)line, "where");
    }
#line 1413
    if ((unsigned long )tmp___43 != (unsigned long )((void *)0)) {
#line 1414
      tmp___39 = 0U;
#line 1414
      fp->inmetrics2 = tmp___39;
#line 1414
      tmp___38 = tmp___39;
#line 1414
      fp->inmetrics = tmp___38;
#line 1414
      tmp___37 = tmp___38;
#line 1414
      fp->inbb = tmp___37;
#line 1414
      fp->infi = tmp___37;
#line 1415
      tmp___41 = 0U;
#line 1415
      fp->inblendfi = tmp___41;
#line 1415
      tmp___40 = tmp___41;
#line 1415
      fp->inblendprivate = tmp___40;
#line 1415
      fp->inprivate = tmp___40;
#line 1416
      fp->skipping_mbf = 1U;
#line 1417
      return;
    }
  }
  {
#line 1420
  tmp___210 = mycmp((char *)"Encoding", line + 1, endtok);
  }
#line 1420
  if (tmp___210 == 0) {
#line 1420
    if (! fp->doneencoding) {
      {
#line 1421
      tmp___45 = strstr((char const   *)endtok, "StandardEncoding");
      }
#line 1421
      if ((unsigned long )tmp___45 != (unsigned long )((void *)0)) {
        {
#line 1422
        setStdEnc((char **)((fp->fd)->encoding));
#line 1423
        (fp->fd)->isadobestd = 1;
        }
      } else {
        {
#line 1424
        tmp___44 = strstr((char const   *)endtok, "ISOLatin1Encoding");
        }
#line 1424
        if ((unsigned long )tmp___44 != (unsigned long )((void *)0)) {
          {
#line 1425
          setLatin1Enc((char **)((fp->fd)->encoding));
          }
        } else {
#line 1427
          fp->inencoding = 1U;
        }
      }
#line 1429
      tmp___49 = 0U;
#line 1429
      fp->inmetrics2 = tmp___49;
#line 1429
      tmp___48 = tmp___49;
#line 1429
      fp->inmetrics = tmp___48;
#line 1429
      tmp___47 = tmp___48;
#line 1429
      fp->inbb = tmp___47;
#line 1429
      tmp___46 = tmp___47;
#line 1429
      fp->inprivate = tmp___46;
#line 1429
      fp->infi = tmp___46;
#line 1430
      fp->doneencoding = 1U;
    } else {
#line 1420
      goto _L___15;
    }
  } else {
    _L___15: /* CIL Label */ 
    {
#line 1431
    tmp___209 = mycmp((char *)"BoundingBoxes", line + 1, endtok);
    }
#line 1431
    if (tmp___209 == 0) {
#line 1432
      tmp___53 = 0U;
#line 1432
      fp->inmetrics2 = tmp___53;
#line 1432
      tmp___52 = tmp___53;
#line 1432
      fp->inmetrics = tmp___52;
#line 1432
      tmp___51 = tmp___52;
#line 1432
      fp->inencoding = tmp___51;
#line 1432
      tmp___50 = tmp___51;
#line 1432
      fp->inprivate = tmp___50;
#line 1432
      fp->infi = tmp___50;
#line 1433
      fp->inbb = 1U;
    } else {
      {
#line 1434
      tmp___208 = mycmp((char *)"Metrics", line + 1, endtok);
      }
#line 1434
      if (tmp___208 == 0) {
        {
#line 1435
        tmp___57 = 0U;
#line 1435
        fp->inmetrics2 = tmp___57;
#line 1435
        tmp___56 = tmp___57;
#line 1435
        fp->inencoding = tmp___56;
#line 1435
        tmp___55 = tmp___56;
#line 1435
        fp->inbb = tmp___55;
#line 1435
        tmp___54 = tmp___55;
#line 1435
        fp->inprivate = tmp___54;
#line 1435
        fp->infi = tmp___54;
#line 1436
        fp->inmetrics = 1U;
#line 1437
        tmp___58 = calloc((size_t )1, sizeof(struct psdict ));
#line 1437
        (fp->fd)->metrics = (struct psdict *)tmp___58;
#line 1438
        tmp___59 = strtol((char const   */* __restrict  */)endtok, (char **/* __restrict  */)((void *)0),
                          10);
#line 1438
        ((fp->fd)->metrics)->cnt = (int )tmp___59;
#line 1439
        tmp___60 = malloc((unsigned long )((fp->fd)->metrics)->cnt * sizeof(char *));
#line 1439
        ((fp->fd)->metrics)->keys = (char **)tmp___60;
#line 1440
        tmp___61 = malloc((unsigned long )((fp->fd)->metrics)->cnt * sizeof(char *));
#line 1440
        ((fp->fd)->metrics)->values = (char **)tmp___61;
        }
      } else {
        {
#line 1441
        tmp___206 = strstr((char const   *)line, "/Private");
        }
#line 1441
        if ((unsigned long )tmp___206 != (unsigned long )((void *)0)) {
          {
#line 1441
          tmp___207 = strstr((char const   *)line, "/Blend");
          }
#line 1441
          if ((unsigned long )tmp___207 != (unsigned long )((void *)0)) {
            {
#line 1442
            tmp___64 = 0U;
#line 1442
            fp->inmetrics2 = tmp___64;
#line 1442
            tmp___63 = tmp___64;
#line 1442
            fp->inmetrics = tmp___63;
#line 1442
            tmp___62 = tmp___63;
#line 1442
            fp->inbb = tmp___62;
#line 1442
            fp->infi = tmp___62;
#line 1443
            tmp___66 = 0U;
#line 1443
            fp->inblendfi = tmp___66;
#line 1443
            tmp___65 = tmp___66;
#line 1443
            fp->inblendprivate = tmp___65;
#line 1443
            fp->inprivate = tmp___65;
#line 1444
            fp->inblendprivate = 1U;
#line 1445
            tmp___67 = calloc((size_t )1, sizeof(struct psdict ));
#line 1445
            (fp->fd)->blendprivate = (struct psdict *)tmp___67;
#line 1446
            InitDict((fp->fd)->blendprivate, line);
            }
#line 1447
            return;
          } else {
#line 1441
            goto _L___14;
          }
        } else {
          _L___14: /* CIL Label */ 
          {
#line 1448
          tmp___204 = strstr((char const   *)line, "/FontInfo");
          }
#line 1448
          if ((unsigned long )tmp___204 != (unsigned long )((void *)0)) {
            {
#line 1448
            tmp___205 = strstr((char const   *)line, "/Blend");
            }
#line 1448
            if ((unsigned long )tmp___205 != (unsigned long )((void *)0)) {
              {
#line 1449
              tmp___70 = 0U;
#line 1449
              fp->inmetrics2 = tmp___70;
#line 1449
              tmp___69 = tmp___70;
#line 1449
              fp->inmetrics = tmp___69;
#line 1449
              tmp___68 = tmp___69;
#line 1449
              fp->inbb = tmp___68;
#line 1449
              fp->infi = tmp___68;
#line 1450
              tmp___72 = 0U;
#line 1450
              fp->inblendfi = tmp___72;
#line 1450
              tmp___71 = tmp___72;
#line 1450
              fp->inblendprivate = tmp___71;
#line 1450
              fp->inprivate = tmp___71;
#line 1451
              fp->inblendfi = 1U;
#line 1452
              tmp___73 = calloc((size_t )1, sizeof(struct psdict ));
#line 1452
              (fp->fd)->blendfontinfo = (struct psdict *)tmp___73;
#line 1453
              InitDict((fp->fd)->blendfontinfo, line);
              }
#line 1454
              return;
            } else {
#line 1448
              goto _L___13;
            }
          } else
          _L___13: /* CIL Label */ 
#line 1455
          if (fp->infi) {
#line 1456
            if (fp->multiline) {
              {
#line 1457
              ContinueValue(fp, (struct psdict *)((void *)0), line);
              }
#line 1458
              return;
            }
#line 1460
            if ((unsigned long )endtok == (unsigned long )((void *)0)) {
              {
#line 1460
              tmp___74 = strncmp((char const   *)line, "end", (size_t )3);
              }
#line 1460
              if (tmp___74 == 0) {
#line 1461
                fp->infi = 0U;
#line 1462
                return;
              } else {
#line 1460
                goto _L___5;
              }
            } else
            _L___5: /* CIL Label */ 
#line 1463
            if ((unsigned long )endtok == (unsigned long )((void *)0)) {
#line 1464
              return;
            }
            {
#line 1465
            tmp___97 = mycmp((char *)"version", line + 1, endtok);
            }
#line 1465
            if (tmp___97 == 0) {
              {
#line 1466
              ((fp->fd)->fontinfo)->version = getstring(endtok, in);
              }
            } else {
              {
#line 1467
              tmp___96 = mycmp((char *)"Notice", line + 1, endtok);
              }
#line 1467
              if (tmp___96 == 0) {
#line 1468
                if ((unsigned long )((fp->fd)->fontinfo)->notice != (unsigned long )((void *)0)) {
                  {
#line 1469
                  free((void *)((fp->fd)->fontinfo)->notice);
                  }
                }
                {
#line 1470
                ((fp->fd)->fontinfo)->notice = getstring(endtok, in);
                }
              } else {
                {
#line 1471
                tmp___95 = mycmp((char *)"Copyright", line + 1, endtok);
                }
#line 1471
                if (tmp___95 == 0) {
#line 1472
                  if ((unsigned long )((fp->fd)->fontinfo)->notice != (unsigned long )((void *)0)) {
                    {
#line 1473
                    free((void *)((fp->fd)->fontinfo)->notice);
                    }
                  }
                  {
#line 1474
                  ((fp->fd)->fontinfo)->notice = getstring(endtok, in);
                  }
                } else {
                  {
#line 1475
                  tmp___94 = mycmp((char *)"FullName", line + 1, endtok);
                  }
#line 1475
                  if (tmp___94 == 0) {
#line 1476
                    if ((unsigned long )((fp->fd)->fontinfo)->fullname == (unsigned long )((void *)0)) {
                      {
#line 1477
                      ((fp->fd)->fontinfo)->fullname = getstring(endtok, in);
                      }
                    } else {
                      {
#line 1479
                      getstring(endtok, in);
                      }
                    }
                  } else {
                    {
#line 1480
                    tmp___93 = mycmp((char *)"FamilyName", line + 1, endtok);
                    }
#line 1480
                    if (tmp___93 == 0) {
                      {
#line 1481
                      ((fp->fd)->fontinfo)->familyname = getstring(endtok, in);
                      }
                    } else {
                      {
#line 1482
                      tmp___92 = mycmp((char *)"Weight", line + 1, endtok);
                      }
#line 1482
                      if (tmp___92 == 0) {
                        {
#line 1483
                        ((fp->fd)->fontinfo)->weight = getstring(endtok, in);
                        }
                      } else {
                        {
#line 1484
                        tmp___91 = mycmp((char *)"ItalicAngle", line + 1, endtok);
                        }
#line 1484
                        if (tmp___91 == 0) {
                          {
#line 1485
                          ((fp->fd)->fontinfo)->italicangle = strtod((char const   */* __restrict  */)endtok,
                                                                     (char **/* __restrict  */)((void *)0));
                          }
                        } else {
                          {
#line 1486
                          tmp___90 = mycmp((char *)"UnderlinePosition", line + 1,
                                           endtok);
                          }
#line 1486
                          if (tmp___90 == 0) {
                            {
#line 1487
                            ((fp->fd)->fontinfo)->underlineposition = strtod((char const   */* __restrict  */)endtok,
                                                                             (char **/* __restrict  */)((void *)0));
                            }
                          } else {
                            {
#line 1488
                            tmp___89 = mycmp((char *)"UnderlineThickness", line + 1,
                                             endtok);
                            }
#line 1488
                            if (tmp___89 == 0) {
                              {
#line 1489
                              ((fp->fd)->fontinfo)->underlinethickness = strtod((char const   */* __restrict  */)endtok,
                                                                                (char **/* __restrict  */)((void *)0));
                              }
                            } else {
                              {
#line 1490
                              tmp___88 = mycmp((char *)"isFixedPitch", line + 1, endtok);
                              }
#line 1490
                              if (tmp___88 == 0) {
                                {
#line 1491
                                tmp___75 = getbool(endtok);
#line 1491
                                ((fp->fd)->fontinfo)->isfixedpitch = (unsigned int )tmp___75;
                                }
                              } else {
                                {
#line 1492
                                tmp___87 = mycmp((char *)"em", line + 1, endtok);
                                }
#line 1492
                                if (tmp___87 == 0) {
                                  {
#line 1493
                                  tmp___76 = strtol((char const   */* __restrict  */)endtok,
                                                    (char **/* __restrict  */)((void *)0),
                                                    10);
#line 1493
                                  ((fp->fd)->fontinfo)->em = (int )tmp___76;
                                  }
                                } else {
                                  {
#line 1494
                                  tmp___86 = mycmp((char *)"ascent", line + 1, endtok);
                                  }
#line 1494
                                  if (tmp___86 == 0) {
                                    {
#line 1495
                                    tmp___77 = strtol((char const   */* __restrict  */)endtok,
                                                      (char **/* __restrict  */)((void *)0),
                                                      10);
#line 1495
                                    ((fp->fd)->fontinfo)->ascent = (int )tmp___77;
                                    }
                                  } else {
                                    {
#line 1496
                                    tmp___85 = mycmp((char *)"descent", line + 1,
                                                     endtok);
                                    }
#line 1496
                                    if (tmp___85 == 0) {
                                      {
#line 1497
                                      tmp___78 = strtol((char const   */* __restrict  */)endtok,
                                                        (char **/* __restrict  */)((void *)0),
                                                        10);
#line 1497
                                      ((fp->fd)->fontinfo)->descent = (int )tmp___78;
                                      }
                                    } else {
                                      {
#line 1498
                                      tmp___84 = mycmp((char *)"FSType", line + 1,
                                                       endtok);
                                      }
#line 1498
                                      if (tmp___84 == 0) {
                                        {
#line 1499
                                        tmp___79 = strtol((char const   */* __restrict  */)endtok,
                                                          (char **/* __restrict  */)((void *)0),
                                                          10);
#line 1499
                                        ((fp->fd)->fontinfo)->fstype = (int )tmp___79;
                                        }
                                      } else {
                                        {
#line 1500
                                        tmp___83 = mycmp((char *)"BlendDesignPositions",
                                                         line + 1, endtok);
                                        }
#line 1500
                                        if (tmp___83 == 0) {
                                          {
#line 1501
                                          fp->pending_parse = & ((fp->fd)->fontinfo)->blenddesignpositions;
#line 1502
                                          AddValue(fp, (struct psdict *)((void *)0),
                                                   line, endtok);
                                          }
                                        } else {
                                          {
#line 1503
                                          tmp___82 = mycmp((char *)"BlendDesignMap",
                                                           line + 1, endtok);
                                          }
#line 1503
                                          if (tmp___82 == 0) {
                                            {
#line 1504
                                            fp->pending_parse = & ((fp->fd)->fontinfo)->blenddesignmap;
#line 1505
                                            AddValue(fp, (struct psdict *)((void *)0),
                                                     line, endtok);
                                            }
                                          } else {
                                            {
#line 1506
                                            tmp___81 = mycmp((char *)"BlendAxisTypes",
                                                             line + 1, endtok);
                                            }
#line 1506
                                            if (tmp___81 == 0) {
                                              {
#line 1507
                                              fp->pending_parse = & ((fp->fd)->fontinfo)->blendaxistypes;
#line 1508
                                              AddValue(fp, (struct psdict *)((void *)0),
                                                       line, endtok);
                                              }
                                            } else
#line 1509
                                            if (! fp->alreadycomplained) {
                                              {
#line 1510
                                              tmp___80 = rmbinary(line);
#line 1510
                                              fprintf((FILE */* __restrict  */)stderr,
                                                      (char const   */* __restrict  */)"Didn\'t understand |%s",
                                                      tmp___80);
#line 1511
                                              fp->alreadycomplained = 1U;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else
#line 1513
          if (fp->inblend) {
#line 1514
            if ((unsigned long )endtok == (unsigned long )((void *)0)) {
#line 1515
              if ((int )*line != 47) {
                {
#line 1515
                tmp___98 = strstr((char const   *)line, "end");
                }
#line 1515
                if ((unsigned long )tmp___98 != (unsigned long )((void *)0)) {
#line 1516
                  fp->inblend = 0U;
                }
              }
#line 1517
              return;
            }
          } else
#line 1520
          if (fp->inblendprivate) {
#line 1520
            goto _L___12;
          } else
#line 1520
          if (fp->inblendfi) {
            _L___12: /* CIL Label */ 
#line 1521
            if (fp->inblendfi) {
#line 1521
              tmp___99 = (fp->fd)->blendfontinfo;
            } else {
#line 1521
              tmp___99 = (fp->fd)->blendprivate;
            }
#line 1521
            subdict = tmp___99;
#line 1522
            if (fp->multiline) {
              {
#line 1523
              ContinueValue(fp, subdict, line);
              }
#line 1524
              return;
            } else
#line 1525
            if ((unsigned long )endtok == (unsigned long )((void *)0)) {
#line 1526
              if ((int )*line != 47) {
                {
#line 1526
                tmp___101 = strstr((char const   *)line, "end");
                }
#line 1526
                if ((unsigned long )tmp___101 != (unsigned long )((void *)0)) {
#line 1527
                  tmp___100 = 0U;
#line 1527
                  fp->inblendfi = tmp___100;
#line 1527
                  fp->inblendprivate = tmp___100;
#line 1528
                  fp->inprivate = 1U;
                }
              }
#line 1530
              return;
            } else {
              {
#line 1532
              AddValue(fp, subdict, line, endtok);
              }
            }
          } else
#line 1533
          if (fp->inprivate) {
            {
#line 1534
            tmp___103 = strstr((char const   *)line, "/CharStrings");
            }
#line 1534
            if ((unsigned long )tmp___103 != (unsigned long )((void *)0)) {
              {
#line 1534
              tmp___104 = strstr((char const   *)line, "dict");
              }
#line 1534
              if ((unsigned long )tmp___104 != (unsigned long )((void *)0)) {
#line 1535
                if (((fp->fd)->chars)->next == 0) {
                  {
#line 1536
                  InitChars((fp->fd)->chars, line);
#line 1537
                  fp->ignore = 0U;
                  }
                } else {
                  {
#line 1539
                  fp->ignore = 1U;
#line 1540
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring duplicate /CharStrings entry\n");
                  }
                }
#line 1542
                fp->inchars = 1U;
#line 1543
                fp->insubs = 0U;
#line 1544
                return;
              } else {
#line 1534
                goto _L___6;
              }
            } else {
              _L___6: /* CIL Label */ 
              {
#line 1545
              tmp___102 = strstr((char const   *)line, "/Subrs");
              }
#line 1545
              if ((unsigned long )tmp___102 != (unsigned long )((void *)0)) {
#line 1546
                if ((((fp->fd)->private)->subrs)->next > 0) {
                  {
#line 1547
                  fp->ignore = 1U;
#line 1548
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring duplicate /Subrs entry\n");
                  }
                } else {
                  {
#line 1550
                  InitChars(((fp->fd)->private)->subrs, line);
#line 1551
                  fp->ignore = 0U;
                  }
                }
#line 1553
                fp->insubs = 1U;
#line 1554
                fp->inchars = 0U;
#line 1555
                return;
              } else
#line 1556
              if (fp->multiline) {
                {
#line 1557
                ContinueValue(fp, ((fp->fd)->private)->private, line);
                }
#line 1558
                return;
              }
            }
#line 1560
            if ((unsigned long )endtok == (unsigned long )((void *)0)) {
#line 1561
              pt___0 = line;
#line 1562
              if ((int )*pt___0 != 47) {
                {
#line 1562
                while (1) {
                  while_continue___15: /* CIL Label */ ;
                  {
#line 1562
                  pt___0 = strstr((char const   *)pt___0, "end");
                  }
#line 1562
                  if (! ((unsigned long )pt___0 != (unsigned long )((void *)0))) {
#line 1562
                    goto while_break___15;
                  }
#line 1563
                  if (fp->inchars) {
#line 1563
                    fp->inchars = 0U;
                  } else {
#line 1564
                    fp->inprivate = 0U;
                  }
#line 1565
                  pt___0 += 3;
                }
                while_break___15: /* CIL Label */ ;
                }
              }
#line 1567
              return;
            }
            {
#line 1569
            tmp___109 = mycmp((char *)"ND", line + 1, endtok);
            }
#line 1569
            if (! (tmp___109 == 0)) {
              {
#line 1569
              tmp___110 = mycmp((char *)"|-", line + 1, endtok);
              }
#line 1569
              if (! (tmp___110 == 0)) {
                {
#line 1569
                tmp___111 = mycmp((char *)"NP", line + 1, endtok);
                }
#line 1569
                if (! (tmp___111 == 0)) {
                  {
#line 1569
                  tmp___112 = mycmp((char *)"|", line + 1, endtok);
                  }
#line 1569
                  if (! (tmp___112 == 0)) {
                    {
#line 1569
                    tmp___113 = mycmp((char *)"RD", line + 1, endtok);
                    }
#line 1569
                    if (! (tmp___113 == 0)) {
                      {
#line 1569
                      tmp___114 = mycmp((char *)"-|", line + 1, endtok);
                      }
#line 1569
                      if (! (tmp___114 == 0)) {
                        {
#line 1569
                        tmp___115 = mycmp((char *)"password", line + 1, endtok);
                        }
#line 1569
                        if (! (tmp___115 == 0)) {
                          {
#line 1569
                          tmp___116 = mycmp((char *)"MinFeature", line + 1, endtok);
                          }
#line 1569
                          if (! (tmp___116 == 0)) {
                            {
#line 1575
                            tmp___108 = mycmp((char *)"UniqueID", line + 1, endtok);
                            }
#line 1575
                            if (tmp___108 == 0) {
#line 1576
                              if ((fp->fd)->uniqueid == 0) {
                                {
#line 1577
                                tmp___105 = strtol((char const   */* __restrict  */)endtok,
                                                   (char **/* __restrict  */)((void *)0),
                                                   10);
#line 1577
                                (fp->fd)->uniqueid = (int )tmp___105;
                                }
                              }
                            } else {
                              {
#line 1579
                              tmp___107 = mycmp((char *)"lenIV", line + 1, endtok);
                              }
#line 1579
                              if (tmp___107 == 0) {
                                {
#line 1580
                                tmp___106 = strtol((char const   */* __restrict  */)endtok,
                                                   (char **/* __restrict  */)((void *)0),
                                                   10);
#line 1580
                                ((fp->fd)->private)->leniv = (int )tmp___106;
                                }
                              }
                              {
#line 1581
                              AddValue(fp, ((fp->fd)->private)->private, line, endtok);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else
#line 1583
          if (fp->incidsysteminfo) {
#line 1584
            if ((unsigned long )endtok == (unsigned long )((void *)0)) {
              {
#line 1584
              tmp___117 = strncmp((char const   *)line, "end", (size_t )3);
              }
#line 1584
              if (tmp___117 == 0) {
#line 1585
                fp->incidsysteminfo = 0U;
#line 1586
                return;
              } else {
#line 1584
                goto _L___7;
              }
            } else
            _L___7: /* CIL Label */ 
#line 1587
            if ((unsigned long )endtok == (unsigned long )((void *)0)) {
#line 1588
              return;
            }
            {
#line 1589
            tmp___121 = mycmp((char *)"Registry", line + 1, endtok);
            }
#line 1589
            if (tmp___121 == 0) {
              {
#line 1590
              (fp->fd)->registry = getstring(endtok, in);
              }
            } else {
              {
#line 1591
              tmp___120 = mycmp((char *)"Ordering", line + 1, endtok);
              }
#line 1591
              if (tmp___120 == 0) {
                {
#line 1592
                (fp->fd)->ordering = getstring(endtok, in);
                }
              } else {
                {
#line 1593
                tmp___119 = mycmp((char *)"Supplement", line + 1, endtok);
                }
#line 1593
                if (tmp___119 == 0) {
                  {
#line 1594
                  tmp___118 = strtol((char const   */* __restrict  */)endtok, (char **/* __restrict  */)((void *)0),
                                     0);
#line 1594
                  (fp->fd)->supplement = (int )tmp___118;
                  }
                }
              }
            }
          } else {
            {
#line 1596
            tmp___158 = strstr((char const   *)line, "/Private");
            }
#line 1596
            if ((unsigned long )tmp___158 != (unsigned long )((void *)0)) {
              {
#line 1596
              tmp___159 = strstr((char const   *)line, "dict");
              }
#line 1596
              if ((unsigned long )tmp___159 != (unsigned long )((void *)0)) {
                {
#line 1597
                tmp___124 = 0U;
#line 1597
                fp->inmetrics2 = tmp___124;
#line 1597
                tmp___123 = tmp___124;
#line 1597
                fp->inmetrics = tmp___123;
#line 1597
                tmp___122 = tmp___123;
#line 1597
                fp->inbb = tmp___122;
#line 1597
                fp->infi = tmp___122;
#line 1598
                tmp___126 = 0U;
#line 1598
                fp->inblendfi = tmp___126;
#line 1598
                tmp___125 = tmp___126;
#line 1598
                fp->inblendprivate = tmp___125;
#line 1598
                fp->inprivate = tmp___125;
#line 1599
                tmp___128 = strstr((char const   *)line, "/Blend");
                }
#line 1599
                if ((unsigned long )tmp___128 != (unsigned long )((void *)0)) {
                  {
#line 1600
                  fp->inblendprivate = 1U;
#line 1601
                  tmp___127 = calloc((size_t )1, sizeof(struct psdict ));
#line 1601
                  (fp->fd)->blendprivate = (struct psdict *)tmp___127;
#line 1602
                  InitDict((fp->fd)->blendprivate, line);
                  }
                } else {
                  {
#line 1604
                  fp->inprivate = 1U;
#line 1605
                  InitDict(((fp->fd)->private)->private, line);
                  }
                }
#line 1607
                return;
              } else {
#line 1596
                goto _L___11;
              }
            } else {
              _L___11: /* CIL Label */ 
              {
#line 1608
              tmp___156 = strstr((char const   *)line, "/FontInfo");
              }
#line 1608
              if ((unsigned long )tmp___156 != (unsigned long )((void *)0)) {
                {
#line 1608
                tmp___157 = strstr((char const   *)line, "dict");
                }
#line 1608
                if ((unsigned long )tmp___157 != (unsigned long )((void *)0)) {
                  {
#line 1609
                  tmp___131 = 0U;
#line 1609
                  fp->inmetrics2 = tmp___131;
#line 1609
                  tmp___130 = tmp___131;
#line 1609
                  fp->inmetrics = tmp___130;
#line 1609
                  tmp___129 = tmp___130;
#line 1609
                  fp->inbb = tmp___129;
#line 1609
                  fp->inprivate = tmp___129;
#line 1610
                  tmp___133 = 0U;
#line 1610
                  fp->inblendfi = tmp___133;
#line 1610
                  tmp___132 = tmp___133;
#line 1610
                  fp->inblendprivate = tmp___132;
#line 1610
                  fp->infi = tmp___132;
#line 1611
                  tmp___135 = strstr((char const   *)line, "/Blend");
                  }
#line 1611
                  if ((unsigned long )tmp___135 != (unsigned long )((void *)0)) {
                    {
#line 1612
                    fp->inblendfi = 1U;
#line 1613
                    tmp___134 = calloc((size_t )1, sizeof(struct psdict ));
#line 1613
                    (fp->fd)->blendfontinfo = (struct psdict *)tmp___134;
#line 1614
                    InitDict((fp->fd)->blendfontinfo, line);
                    }
                  } else {
#line 1616
                    fp->infi = 1U;
                  }
#line 1618
                  return;
                } else {
#line 1608
                  goto _L___10;
                }
              } else {
                _L___10: /* CIL Label */ 
                {
#line 1619
                tmp___154 = strstr((char const   *)line, "/Blend");
                }
#line 1619
                if ((unsigned long )tmp___154 != (unsigned long )((void *)0)) {
                  {
#line 1619
                  tmp___155 = strstr((char const   *)line, "dict");
                  }
#line 1619
                  if ((unsigned long )tmp___155 != (unsigned long )((void *)0)) {
#line 1620
                    tmp___138 = 0U;
#line 1620
                    fp->inmetrics2 = tmp___138;
#line 1620
                    tmp___137 = tmp___138;
#line 1620
                    fp->inmetrics = tmp___137;
#line 1620
                    tmp___136 = tmp___137;
#line 1620
                    fp->inbb = tmp___136;
#line 1620
                    fp->inprivate = tmp___136;
#line 1621
                    tmp___140 = 0U;
#line 1621
                    fp->inblendfi = tmp___140;
#line 1621
                    tmp___139 = tmp___140;
#line 1621
                    fp->inblendprivate = tmp___139;
#line 1621
                    fp->infi = tmp___139;
#line 1622
                    fp->inblend = 1U;
#line 1623
                    return;
                  } else {
#line 1619
                    goto _L___9;
                  }
                } else {
                  _L___9: /* CIL Label */ 
                  {
#line 1624
                  tmp___152 = strstr((char const   *)line, "/CharStrings");
                  }
#line 1624
                  if ((unsigned long )tmp___152 != (unsigned long )((void *)0)) {
                    {
#line 1624
                    tmp___153 = strstr((char const   *)line, "dict");
                    }
#line 1624
                    if ((unsigned long )tmp___153 != (unsigned long )((void *)0)) {
#line 1625
                      if (((fp->fd)->chars)->next == 0) {
                        {
#line 1626
                        InitChars((fp->fd)->chars, line);
#line 1627
                        fp->ignore = 0U;
                        }
                      } else {
                        {
#line 1629
                        fp->ignore = 1U;
#line 1630
                        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Ignoring duplicate /CharStrings entry\n");
                        }
                      }
#line 1632
                      fp->inchars = 1U;
#line 1633
                      fp->insubs = 0U;
#line 1634
                      tmp___144 = 0U;
#line 1634
                      fp->inmetrics2 = tmp___144;
#line 1634
                      tmp___143 = tmp___144;
#line 1634
                      fp->inmetrics = tmp___143;
#line 1634
                      tmp___142 = tmp___143;
#line 1634
                      fp->inbb = tmp___142;
#line 1634
                      tmp___141 = tmp___142;
#line 1634
                      fp->inprivate = tmp___141;
#line 1634
                      fp->infi = tmp___141;
#line 1635
                      tmp___145 = 0U;
#line 1635
                      fp->inblendfi = tmp___145;
#line 1635
                      fp->inblendprivate = tmp___145;
#line 1636
                      return;
                    } else {
#line 1624
                      goto _L___8;
                    }
                  } else {
                    _L___8: /* CIL Label */ 
                    {
#line 1637
                    tmp___151 = mycmp((char *)"/CharProcs", line, endtok);
                    }
#line 1637
                    if (tmp___151 == 0) {
                      {
#line 1638
                      InitCharProcs((fp->fd)->charprocs, line);
#line 1639
                      tmp___149 = 0U;
#line 1639
                      fp->inmetrics2 = tmp___149;
#line 1639
                      tmp___148 = tmp___149;
#line 1639
                      fp->inmetrics = tmp___148;
#line 1639
                      tmp___147 = tmp___148;
#line 1639
                      fp->inbb = tmp___147;
#line 1639
                      tmp___146 = tmp___147;
#line 1639
                      fp->inprivate = tmp___146;
#line 1639
                      fp->infi = tmp___146;
#line 1640
                      fp->insubs = 0U;
                      }
#line 1641
                      return;
                    } else {
                      {
#line 1642
                      tmp___150 = strstr((char const   *)line, "/CIDSystemInfo");
                      }
#line 1642
                      if ((unsigned long )tmp___150 != (unsigned long )((void *)0)) {
#line 1643
                        fp->incidsysteminfo = 1U;
#line 1644
                        return;
                      } else
#line 1645
                      if (fp->inmetrics) {
#line 1646
                        if ((unsigned long )endtok != (unsigned long )((void *)0)) {
                          {
#line 1647
                          AddValue(fp, (fp->fd)->metrics, line, endtok);
                          }
                        }
#line 1648
                        return;
                      } else
#line 1649
                      if (fp->inbb) {
#line 1651
                        return;
                      }
                    }
                  }
                }
              }
            }
#line 1654
            if (fp->multiline) {
              {
#line 1655
              ContinueValue(fp, (struct psdict *)((void *)0), line);
              }
#line 1656
              return;
            }
#line 1659
            if ((unsigned long )endtok == (unsigned long )((void *)0)) {
#line 1660
              if (! fp->skipping_mbf) {
#line 1662
                if (fp->fdindex != -1) {
                  {
#line 1662
                  tmp___160 = strstr((char const   *)line, "end");
                  }
#line 1662
                  if ((unsigned long )tmp___160 != (unsigned long )((void *)0)) {
#line 1663
                    (fp->fdindex) ++;
#line 1663
                    if (fp->fdindex >= (fp->mainfd)->fdcnt) {
#line 1664
                      fp->fd = fp->mainfd;
                    } else {
#line 1666
                      fp->fd = *((fp->mainfd)->fds + fp->fdindex);
                    }
                  }
                }
              }
#line 1668
              return;
            }
            {
#line 1670
            tmp___203 = mycmp((char *)"FontName", line + 1, endtok);
            }
#line 1670
            if (tmp___203 == 0) {
#line 1671
              if ((unsigned long )(fp->fd)->fontname == (unsigned long )((void *)0)) {
                {
#line 1672
                (fp->fd)->fontname = gettoken(endtok);
                }
              } else {
                {
#line 1674
                gettoken(endtok);
                }
              }
            } else {
              {
#line 1675
              tmp___202 = mycmp((char *)"PaintType", line + 1, endtok);
              }
#line 1675
              if (tmp___202 == 0) {
                {
#line 1676
                tmp___161 = strtol((char const   */* __restrict  */)endtok, (char **/* __restrict  */)((void *)0),
                                   10);
#line 1676
                (fp->fd)->painttype = (int )tmp___161;
                }
              } else {
                {
#line 1677
                tmp___201 = mycmp((char *)"FontType", line + 1, endtok);
                }
#line 1677
                if (tmp___201 == 0) {
                  {
#line 1678
                  tmp___162 = strtol((char const   */* __restrict  */)endtok, (char **/* __restrict  */)((void *)0),
                                     10);
#line 1678
                  (fp->fd)->fonttype = (int )tmp___162;
                  }
                } else {
                  {
#line 1679
                  tmp___200 = mycmp((char *)"FontMatrix", line + 1, endtok);
                  }
#line 1679
                  if (tmp___200 == 0) {
#line 1680
                    if ((fp->fd)->fontmatrix[0] == (double )0) {
                      {
#line 1681
                      filldoublearray((fp->fd)->fontmatrix, endtok, 6);
                      }
                    } else {
                      {
#line 1684
                      filldoublearray(temp, endtok, 6);
                      }
                    }
                  } else {
                    {
#line 1686
                    tmp___199 = mycmp((char *)"LanguageLevel", line + 1, endtok);
                    }
#line 1686
                    if (tmp___199 == 0) {
                      {
#line 1687
                      tmp___163 = strtol((char const   */* __restrict  */)endtok,
                                         (char **/* __restrict  */)((void *)0), 10);
#line 1687
                      (fp->fd)->languagelevel = (int )tmp___163;
                      }
                    } else {
                      {
#line 1688
                      tmp___198 = mycmp((char *)"WMode", line + 1, endtok);
                      }
#line 1688
                      if (tmp___198 == 0) {
                        {
#line 1689
                        tmp___164 = strtol((char const   */* __restrict  */)endtok,
                                           (char **/* __restrict  */)((void *)0),
                                           10);
#line 1689
                        (fp->fd)->wmode = (int )tmp___164;
                        }
                      } else {
                        {
#line 1690
                        tmp___197 = mycmp((char *)"FontBBox", line + 1, endtok);
                        }
#line 1690
                        if (tmp___197 == 0) {
                          {
#line 1691
                          filldoublearray((fp->fd)->fontbb, endtok, 4);
                          }
                        } else {
                          {
#line 1692
                          tmp___196 = mycmp((char *)"UniqueID", line + 1, endtok);
                          }
#line 1692
                          if (tmp___196 == 0) {
#line 1693
                            if ((fp->fd)->uniqueid == 0) {
                              {
#line 1694
                              tmp___165 = strtol((char const   */* __restrict  */)endtok,
                                                 (char **/* __restrict  */)((void *)0),
                                                 10);
#line 1694
                              (fp->fd)->uniqueid = (int )tmp___165;
                              }
                            }
                          } else {
                            {
#line 1695
                            tmp___195 = mycmp((char *)"UniqueId", line + 1, endtok);
                            }
#line 1695
                            if (tmp___195 == 0) {
                              {
#line 1696
                              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"This font contains a \"UniqueId\" variable, but the correct name for it is\n\t\"UniqueID\" (postscript is case concious)\n");
                              }
#line 1697
                              if ((fp->fd)->uniqueid == 0) {
                                {
#line 1698
                                tmp___166 = strtol((char const   */* __restrict  */)endtok,
                                                   (char **/* __restrict  */)((void *)0),
                                                   10);
#line 1698
                                (fp->fd)->uniqueid = (int )tmp___166;
                                }
                              }
                            } else {
                              {
#line 1699
                              tmp___194 = mycmp((char *)"XUID", line + 1, endtok);
                              }
#line 1699
                              if (tmp___194 == 0) {
#line 1700
                                if ((fp->fd)->xuid[0] == 0) {
                                  {
#line 1701
                                  fillintarray((fp->fd)->xuid, endtok, 20);
                                  }
                                }
                              } else {
                                {
#line 1702
                                tmp___193 = mycmp((char *)"StrokeWidth", line + 1,
                                                  endtok);
                                }
#line 1702
                                if (tmp___193 == 0) {
                                  {
#line 1703
                                  (fp->fd)->strokewidth = strtod((char const   */* __restrict  */)endtok,
                                                                 (char **/* __restrict  */)((void *)0));
                                  }
                                } else {
                                  {
#line 1704
                                  tmp___192 = mycmp((char *)"WeightVector", line + 1,
                                                    endtok);
                                  }
#line 1704
                                  if (tmp___192 == 0) {
                                    {
#line 1705
                                    fp->pending_parse = & (fp->fd)->weightvector;
#line 1706
                                    AddValue(fp, (struct psdict *)((void *)0), line,
                                             endtok);
                                    }
                                  } else {
                                    {
#line 1707
                                    tmp___191 = mycmp((char *)"$Blend", line + 1,
                                                      endtok);
                                    }
#line 1707
                                    if (tmp___191 == 0) {
                                      {
#line 1708
                                      fp->pending_parse = & (fp->fd)->blendfunc;
#line 1709
                                      AddValue(fp, (struct psdict *)((void *)0), line,
                                               endtok);
                                      }
                                    } else {
                                      {
#line 1710
                                      tmp___190 = strstr((char const   *)line, "/NormalizeDesignVector");
                                      }
#line 1710
                                      if ((unsigned long )tmp___190 != (unsigned long )((void *)0)) {
                                        {
#line 1711
                                        fp->pending_parse = & (fp->fd)->ndv;
#line 1712
                                        AddValue(fp, (struct psdict *)((void *)0),
                                                 line, endtok);
                                        }
                                      } else {
                                        {
#line 1713
                                        tmp___189 = strstr((char const   *)line, "/ConvertDesignVector");
                                        }
#line 1713
                                        if ((unsigned long )tmp___189 != (unsigned long )((void *)0)) {
                                          {
#line 1714
                                          fp->pending_parse = & (fp->fd)->cdv;
#line 1715
                                          AddValue(fp, (struct psdict *)((void *)0),
                                                   line, endtok);
                                          }
                                        } else {
                                          {
#line 1716
                                          tmp___188 = mycmp((char *)"BuildChar", line + 1,
                                                            endtok);
                                          }
#line 1716
                                          if (! (tmp___188 == 0)) {
                                            {
#line 1718
                                            tmp___187 = mycmp((char *)"BuildGlyph",
                                                              line + 1, endtok);
                                            }
#line 1718
                                            if (! (tmp___187 == 0)) {
                                              {
#line 1720
                                              tmp___186 = mycmp((char *)"CIDFontName",
                                                                line + 1, endtok);
                                              }
#line 1720
                                              if (tmp___186 == 0) {
                                                {
#line 1721
                                                (fp->fd)->cidfontname = gettoken(endtok);
                                                }
                                              } else {
                                                {
#line 1722
                                                tmp___185 = mycmp((char *)"CIDFontVersion",
                                                                  line + 1, endtok);
                                                }
#line 1722
                                                if (tmp___185 == 0) {
                                                  {
#line 1723
                                                  (fp->fd)->cidversion = strtod((char const   */* __restrict  */)endtok,
                                                                                (char **/* __restrict  */)((void *)0));
                                                  }
                                                } else {
                                                  {
#line 1731
                                                  tmp___184 = mycmp((char *)"CIDFontType",
                                                                    line + 1, endtok);
                                                  }
#line 1731
                                                  if (tmp___184 == 0) {
                                                    {
#line 1732
                                                    tmp___167 = strtol((char const   */* __restrict  */)endtok,
                                                                       (char **/* __restrict  */)((void *)0),
                                                                       10);
#line 1732
                                                    (fp->fd)->cidfonttype = (int )tmp___167;
                                                    }
                                                  } else {
                                                    {
#line 1733
                                                    tmp___183 = mycmp((char *)"UIDBase",
                                                                      line + 1, endtok);
                                                    }
#line 1733
                                                    if (tmp___183 == 0) {
                                                      {
#line 1734
                                                      tmp___168 = strtol((char const   */* __restrict  */)endtok,
                                                                         (char **/* __restrict  */)((void *)0),
                                                                         10);
#line 1734
                                                      (fp->fd)->uniqueid = (int )tmp___168;
                                                      }
                                                    } else {
                                                      {
#line 1735
                                                      tmp___182 = mycmp((char *)"CIDMapOffset",
                                                                        line + 1,
                                                                        endtok);
                                                      }
#line 1735
                                                      if (tmp___182 == 0) {
                                                        {
#line 1736
                                                        tmp___169 = strtol((char const   */* __restrict  */)endtok,
                                                                           (char **/* __restrict  */)((void *)0),
                                                                           10);
#line 1736
                                                        (fp->fd)->mapoffset = (int )tmp___169;
                                                        }
                                                      } else {
                                                        {
#line 1737
                                                        tmp___181 = mycmp((char *)"FDBytes",
                                                                          line + 1,
                                                                          endtok);
                                                        }
#line 1737
                                                        if (tmp___181 == 0) {
                                                          {
#line 1738
                                                          tmp___170 = strtol((char const   */* __restrict  */)endtok,
                                                                             (char **/* __restrict  */)((void *)0),
                                                                             10);
#line 1738
                                                          (fp->fd)->fdbytes = (int )tmp___170;
                                                          }
                                                        } else {
                                                          {
#line 1739
                                                          tmp___180 = mycmp((char *)"GDBytes",
                                                                            line + 1,
                                                                            endtok);
                                                          }
#line 1739
                                                          if (tmp___180 == 0) {
                                                            {
#line 1740
                                                            tmp___171 = strtol((char const   */* __restrict  */)endtok,
                                                                               (char **/* __restrict  */)((void *)0),
                                                                               10);
#line 1740
                                                            (fp->fd)->gdbytes = (int )tmp___171;
                                                            }
                                                          } else {
                                                            {
#line 1741
                                                            tmp___179 = mycmp((char *)"CIDCount",
                                                                              line + 1,
                                                                              endtok);
                                                            }
#line 1741
                                                            if (tmp___179 == 0) {
                                                              {
#line 1742
                                                              tmp___172 = strtol((char const   */* __restrict  */)endtok,
                                                                                 (char **/* __restrict  */)((void *)0),
                                                                                 10);
#line 1742
                                                              (fp->fd)->cidcnt = (int )tmp___172;
                                                              }
                                                            } else {
                                                              {
#line 1743
                                                              tmp___178 = mycmp((char *)"FDArray",
                                                                                line + 1,
                                                                                endtok);
                                                              }
#line 1743
                                                              if (tmp___178 == 0) {
                                                                {
#line 1744
                                                                fp->mainfd = fp->fd;
#line 1745
                                                                tmp___173 = strtol((char const   */* __restrict  */)endtok,
                                                                                   (char **/* __restrict  */)((void *)0),
                                                                                   10);
#line 1745
                                                                (fp->fd)->fdcnt = (int )tmp___173;
#line 1746
                                                                tmp___174 = calloc((size_t )(fp->fd)->fdcnt,
                                                                                   sizeof(struct fontdict *));
#line 1746
                                                                (fp->fd)->fds = (struct fontdict **)tmp___174;
#line 1747
                                                                i___2 = 0;
                                                                }
                                                                {
#line 1747
                                                                while (1) {
                                                                  while_continue___16: /* CIL Label */ ;
#line 1747
                                                                  if (! (i___2 < (fp->fd)->fdcnt)) {
#line 1747
                                                                    goto while_break___16;
                                                                  }
                                                                  {
#line 1748
                                                                  *((fp->fd)->fds + i___2) = MakeEmptyFont();
#line 1747
                                                                  i___2 ++;
                                                                  }
                                                                }
                                                                while_break___16: /* CIL Label */ ;
                                                                }
#line 1749
                                                                fp->fdindex = 0;
#line 1750
                                                                fp->fd = *((fp->fd)->fds + 0);
                                                              } else {
                                                                {
#line 1751
                                                                tmp___177 = mycmp((char *)"FontSetInit",
                                                                                  line + 1,
                                                                                  endtok);
                                                                }
#line 1751
                                                                if (tmp___177 == 0) {
#line 1752
                                                                  fp->iscff = 1U;
#line 1753
                                                                  fp->iscid = 0U;
                                                                } else {
                                                                  {
#line 1754
                                                                  tmp___176 = mycmp((char *)"CIDInit",
                                                                                    line + 1,
                                                                                    endtok);
                                                                  }
#line 1754
                                                                  if (tmp___176 == 0) {
#line 1755
                                                                    fp->iscid = 1U;
#line 1756
                                                                    fp->iscff = 0U;
                                                                  } else
#line 1757
                                                                  if (! fp->skipping_mbf) {
#line 1759
                                                                    if (! fp->alreadycomplained) {
                                                                      {
#line 1760
                                                                      tmp___175 = rmbinary(line);
#line 1760
                                                                      fprintf((FILE */* __restrict  */)stderr,
                                                                              (char const   */* __restrict  */)"Didn\'t understand |%s",
                                                                              tmp___175);
#line 1761
                                                                      fp->alreadycomplained = 1U;
                                                                      }
                                                                    }
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
#line 1764
  return;
}
}
#line 1766 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void addinfo(struct fontparse *fp , char *line , char *tok , char *binstart ,
                    int binlen , FILE *in ) 
{ 
  char *pt ;
  struct pschars *chars ;
  unsigned short const   **tmp ;
  int i ;
  long tmp___0 ;
  void *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  struct pschars *chars___0 ;
  char *tmp___5 ;
  char *tmp___6 ;
  int i___0 ;
  void *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;

  {
  {
#line 1769
  decodestr((unsigned char *)binstart, binlen);
#line 1770
  binstart += ((fp->fd)->private)->leniv;
#line 1771
  binlen -= ((fp->fd)->private)->leniv;
  }
  retry: 
#line 1774
  if (fp->insubs) {
#line 1775
    chars = ((fp->fd)->private)->subrs;
    {
#line 1776
    while (1) {
      while_continue: /* CIL Label */ ;
      {
#line 1776
      tmp = __ctype_b_loc();
      }
#line 1776
      if (! ((int const   )*(*tmp + (int )*line) & 8192)) {
#line 1776
        goto while_break;
      }
#line 1776
      line ++;
    }
    while_break: /* CIL Label */ ;
    }
    {
#line 1777
    tmp___4 = strncmp((char const   *)line, "dup ", (size_t )4);
    }
#line 1777
    if (tmp___4 == 0) {
      {
#line 1778
      tmp___0 = strtol((char const   */* __restrict  */)(line + 4), (char **/* __restrict  */)((void *)0),
                       10);
#line 1778
      i = (int )tmp___0;
      }
#line 1779
      if (! fp->ignore) {
#line 1781
        if (i < chars->cnt) {
#line 1782
          if ((unsigned long )*(chars->values + i) != (unsigned long )((void *)0)) {
            {
#line 1783
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Duplicate definition of subroutine %d\n",
                    i);
            }
          }
          {
#line 1784
          *(chars->lens + i) = binlen;
#line 1785
          tmp___1 = malloc((size_t )binlen);
#line 1785
          *(chars->values + i) = (unsigned char *)tmp___1;
#line 1786
          memcpy((void */* __restrict  */)*(chars->values + i), (void const   */* __restrict  */)binstart,
                 (size_t )binlen);
          }
#line 1787
          if (i >= chars->next) {
#line 1787
            chars->next = i + 1;
          }
        } else
#line 1788
        if (! fp->alreadycomplained) {
          {
#line 1789
          tmp___2 = rmbinary(line);
#line 1789
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index too big (must be <%d) |%s",
                  chars->cnt, tmp___2);
#line 1790
          fp->alreadycomplained = 1U;
          }
        }
      }
    } else
#line 1792
    if (! fp->alreadycomplained) {
      {
#line 1793
      tmp___3 = rmbinary(line);
#line 1793
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Didn\'t understand |%s",
              tmp___3);
#line 1794
      fp->alreadycomplained = 1U;
      }
    }
  } else
#line 1796
  if (fp->inchars) {
#line 1797
    chars___0 = (fp->fd)->chars;
#line 1798
    if ((int )*tok == 0) {
      {
#line 1799
      tmp___5 = rmbinary(line);
#line 1799
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"No name for CharStrings dictionary |%s",
              tmp___5);
      }
    } else
#line 1800
    if (! fp->ignore) {
#line 1802
      if (chars___0->next >= chars___0->cnt) {
        {
#line 1803
        tmp___6 = rmbinary(line);
#line 1803
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many entries in CharStrings dictionary |%s",
                tmp___6);
        }
      } else {
        {
#line 1805
        i___0 = chars___0->next;
#line 1806
        *(chars___0->lens + i___0) = binlen;
#line 1807
        *(chars___0->keys + i___0) = strdup((char const   *)tok);
#line 1808
        tmp___7 = malloc((size_t )binlen);
#line 1808
        *(chars___0->values + i___0) = (unsigned char *)tmp___7;
#line 1809
        memcpy((void */* __restrict  */)*(chars___0->values + i___0), (void const   */* __restrict  */)binstart,
               (size_t )binlen);
#line 1810
        (chars___0->next) ++;
        }
      }
    }
  } else
#line 1812
  if (! fp->alreadycomplained) {
    {
#line 1814
    tmp___9 = strstr((char const   *)line, "/CharStrings");
    }
#line 1814
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
#line 1815
      pt = line;
      {
#line 1815
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 1815
        if (! ((int )*pt != 47)) {
#line 1815
          goto while_break___0;
        }
#line 1815
        pt ++;
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 1816
      pt = strchr((char const   *)(pt + 1), '/');
      }
#line 1817
      if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 1818
        *pt = (char )'\000';
      }
      {
#line 1819
      parseline(fp, line, in);
      }
#line 1820
      if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 1821
        *pt = (char )'/';
#line 1822
        line = pt;
#line 1823
        goto retry;
      }
#line 1825
      return;
    } else {
      {
#line 1826
      tmp___8 = strstr((char const   *)line, "/Subrs");
      }
#line 1826
      if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
        {
#line 1827
        pt = strstr((char const   *)line, "dup");
        }
#line 1828
        if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 1829
          *pt = (char )'\000';
        }
        {
#line 1830
        parseline(fp, line, in);
        }
#line 1831
        if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 1832
          *pt = (char )'d';
#line 1833
          line = pt;
#line 1834
          goto retry;
        }
#line 1836
        return;
      }
    }
    {
#line 1838
    tmp___10 = rmbinary(line);
#line 1838
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Shouldn\'t be in addinfo |%s",
            tmp___10);
#line 1839
    fp->alreadycomplained = 1U;
    }
  }
#line 1841
  return;
}
}
#line 1854
static int glorpline(struct fontparse *fp , FILE *temp , char *rdtok ) ;
#line 1854 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *buffer  =    (char *)((void *)0);
#line 1854 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static char *end  ;
#line 1853 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static int glorpline(struct fontparse *fp , FILE *temp , char *rdtok ) 
{ 
  char *pt ;
  char *binstart ;
  int binlen ;
  int ch ;
  int innum ;
  int val ;
  int inbinary ;
  int cnt ;
  int inr ;
  int wasspace ;
  int nownum ;
  int nowr ;
  int nowspace ;
  int sptok ;
  char *rdline ;
  char *rpt ;
  char *rdline2 ;
  char *tokpt ;
  char *rdpt ;
  char temptok[255] ;
  int intok ;
  int first ;
  int wasminus ;
  int isminus ;
  int nibble ;
  int firstnibble ;
  int inhex ;
  int willbehex ;
  void *tmp ;
  char *old ;
  int len ;
  void *tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  int h ;
  unsigned short const   **tmp___3 ;
  unsigned short const   **tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  unsigned short const   **tmp___7 ;
  char *tmp___8 ;
  unsigned short const   **tmp___9 ;
  unsigned short const   **tmp___10 ;
  unsigned short const   **tmp___11 ;
  unsigned short const   **tmp___12 ;
  unsigned short const   **tmp___13 ;
  unsigned short const   **tmp___14 ;

  {
  {
#line 1858
  val = 0;
#line 1858
  cnt = 0;
#line 1859
  rdline = (char *)"{string currentfile exch readstring pop}";
#line 1860
  rdline2 = (char *)"{string currentfile exch readhexstring pop}";
#line 1861
  tokpt = (char *)((void *)0);
#line 1864
  wasminus = 0;
#line 1865
  willbehex = 0;
#line 1867
  ch = _IO_getc(temp);
  }
#line 1868
  if (ch == -1) {
#line 1869
    return (0);
  }
  {
#line 1870
  ungetc(ch, temp);
  }
#line 1872
  if ((unsigned long )buffer == (unsigned long )((void *)0)) {
    {
#line 1873
    tmp = malloc((size_t )3000);
#line 1873
    buffer = (char *)tmp;
#line 1874
    end = buffer + 3000;
    }
  }
#line 1876
  inr = 0;
#line 1876
  innum = inr;
#line 1876
  wasspace = 0;
#line 1876
  inbinary = 0;
#line 1876
  rpt = (char *)((void *)0);
#line 1876
  rdpt = (char *)((void *)0);
#line 1877
  inhex = 0;
#line 1878
  pt = buffer;
#line 1878
  binstart = (char *)((void *)0);
#line 1878
  binlen = 0;
#line 1878
  intok = 0;
#line 1878
  sptok = 0;
#line 1878
  first = 1;
#line 1879
  temptok[0] = (char )'\000';
  {
#line 1880
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 1880
    ch = _IO_getc(temp);
    }
#line 1880
    if (! (ch != -1)) {
#line 1880
      goto while_break;
    }
#line 1881
    if ((unsigned long )pt >= (unsigned long )end) {
      {
#line 1882
      old = buffer;
#line 1883
      len = (int )((end - buffer) + 2000L);
#line 1884
      tmp___0 = realloc((void *)buffer, (size_t )len);
#line 1884
      buffer = (char *)tmp___0;
#line 1885
      end = buffer + len;
#line 1886
      pt = buffer + (pt - old);
      }
#line 1887
      if ((unsigned long )binstart != (unsigned long )((void *)0)) {
#line 1888
        binstart = buffer + (binstart - old);
      }
    }
#line 1890
    tmp___1 = pt;
#line 1890
    pt ++;
#line 1890
    *tmp___1 = (char )ch;
#line 1891
    if (ch == 45) {
#line 1891
      if (wasspace) {
#line 1891
        tmp___2 = 1;
      } else {
#line 1891
        tmp___2 = 0;
      }
    } else {
#line 1891
      tmp___2 = 0;
    }
#line 1891
    isminus = tmp___2;
#line 1892
    nowr = 0;
#line 1892
    nowspace = nowr;
#line 1892
    nownum = nowspace;
#line 1893
    if ((unsigned long )rpt != (unsigned long )((void *)0)) {
#line 1893
      if (ch != (int )*rpt) {
#line 1893
        if (ch == 104) {
#line 1893
          if (rpt - rdline > 25L) {
#line 1893
            if (rpt - rdline < 30L) {
#line 1893
              if ((int )*(rdline2 + (rpt - rdline)) == 104) {
#line 1895
                rpt = rdline2 + (rpt - rdline);
#line 1896
                willbehex = 1;
              }
            }
          }
        }
      }
    }
#line 1898
    if (inbinary) {
#line 1899
      cnt --;
#line 1899
      if (cnt == 0) {
#line 1900
        inbinary = 0;
      }
    } else
#line 1901
    if (inhex) {
      {
#line 1902
      tmp___4 = __ctype_b_loc();
      }
#line 1902
      if ((int const   )*(*tmp___4 + ch) & 4096) {
        {
#line 1904
        tmp___3 = __ctype_b_loc();
        }
#line 1904
        if ((int const   )*(*tmp___3 + ch) & 2048) {
#line 1904
          h = ch - 48;
        } else
#line 1905
        if (ch >= 97) {
#line 1905
          if (ch <= 102) {
#line 1905
            h = (ch - 97) + 10;
          } else {
#line 1906
            h = (ch - 65) + 10;
          }
        } else {
#line 1906
          h = (ch - 65) + 10;
        }
#line 1907
        if (firstnibble) {
#line 1908
          nibble = h;
#line 1909
          pt --;
        } else {
#line 1911
          *(pt + -1) = (char )((nibble << 4) | h);
#line 1912
          cnt --;
#line 1912
          if (cnt == 0) {
#line 1913
            inhex = 0;
#line 1913
            inbinary = inhex;
          }
        }
#line 1915
        firstnibble = ! firstnibble;
      } else {
#line 1917
        pt --;
      }
    } else
#line 1920
    if (ch == 47) {
#line 1921
      intok = 1;
#line 1922
      tokpt = temptok;
    } else
#line 1923
    if (intok) {
      {
#line 1923
      tmp___14 = __ctype_b_loc();
      }
#line 1923
      if ((int const   )*(*tmp___14 + ch) & 8192) {
#line 1923
        goto _L___11;
      } else
#line 1923
      if (ch != 123) {
#line 1923
        if (ch != 91) {
#line 1924
          tmp___5 = tokpt;
#line 1924
          tokpt ++;
#line 1924
          *tmp___5 = (char )ch;
        } else {
#line 1923
          goto _L___11;
        }
      } else {
#line 1923
        goto _L___11;
      }
    } else
    _L___11: /* CIL Label */ 
#line 1925
    if (intok) {
#line 1925
      goto _L___8;
    } else
#line 1925
    if (sptok) {
      _L___8: /* CIL Label */ 
#line 1925
      if (ch == 123) {
#line 1926
        *tokpt = (char )'\000';
#line 1927
        rpt = rdline + 1;
#line 1928
        sptok = 0;
#line 1928
        intok = sptok;
      } else
#line 1925
      if (ch == 91) {
#line 1926
        *tokpt = (char )'\000';
#line 1927
        rpt = rdline + 1;
#line 1928
        sptok = 0;
#line 1928
        intok = sptok;
      } else {
#line 1925
        goto _L___7;
      }
    } else
    _L___7: /* CIL Label */ 
#line 1929
    if (intok) {
#line 1930
      *tokpt = (char )'\000';
#line 1931
      intok = 0;
#line 1932
      sptok = 1;
    } else
#line 1933
    if (sptok) {
      {
#line 1933
      tmp___13 = __ctype_b_loc();
      }
#line 1933
      if ((int const   )*(*tmp___13 + ch) & 8192) {
#line 1934
        nowspace = 1;
#line 1935
        if (ch == 10) {
#line 1936
          goto while_break;
        } else
#line 1935
        if (ch == 13) {
#line 1936
          goto while_break;
        }
      } else {
#line 1933
        goto _L___6;
      }
    } else
    _L___6: /* CIL Label */ 
#line 1937
    if (sptok) {
      {
#line 1937
      tmp___12 = __ctype_b_loc();
      }
#line 1937
      if ((int const   )*(*tmp___12 + ch) & 2048) {
#line 1937
        goto _L___5;
      } else {
#line 1938
        sptok = 0;
      }
    } else
    _L___5: /* CIL Label */ 
#line 1939
    if ((unsigned long )rpt != (unsigned long )((void *)0)) {
#line 1939
      if (ch == (int )*rpt) {
#line 1940
        rpt ++;
#line 1940
        if ((int )*rpt == 0) {
          {
#line 1943
          strcpy((char */* __restrict  */)rdtok, (char const   */* __restrict  */)(temptok));
#line 1944
          fp->useshexstrings = (unsigned int )willbehex;
#line 1945
          rpt = (char *)((void *)0);
          }
        }
      } else {
#line 1939
        goto _L___4;
      }
    } else
    _L___4: /* CIL Label */ 
#line 1947
    if ((unsigned long )rpt != (unsigned long )((void *)0)) {
#line 1947
      if (! (ch == 32)) {
#line 1947
        goto _L___3;
      }
    } else
    _L___3: /* CIL Label */ 
#line 1949
    if ((unsigned long )rpt != (unsigned long )((void *)0)) {
#line 1950
      rpt = (char *)((void *)0);
#line 1951
      willbehex = 0;
    } else {
      {
#line 1952
      tmp___11 = __ctype_b_loc();
      }
#line 1952
      if ((int const   )*(*tmp___11 + ch) & 2048) {
#line 1953
        sptok = 0;
#line 1954
        nownum = 1;
#line 1955
        if (innum) {
#line 1956
          val = (10 * val + ch) - 48;
        } else {
#line 1958
          val = ch - 48;
        }
      } else {
        {
#line 1959
        tmp___10 = __ctype_b_loc();
        }
#line 1959
        if ((int const   )*(*tmp___10 + ch) & 8192) {
#line 1960
          nowspace = 1;
#line 1961
          if (ch == 10) {
#line 1962
            goto while_break;
          } else
#line 1961
          if (ch == 13) {
#line 1962
            goto while_break;
          }
        } else
#line 1963
        if (wasspace) {
#line 1963
          if (ch == (int )*rdtok) {
#line 1964
            nowr = 1;
#line 1965
            fp->useshexstrings = (unsigned int )willbehex;
#line 1966
            rdpt = rdtok + 1;
          } else {
#line 1963
            goto _L___2;
          }
        } else
        _L___2: /* CIL Label */ 
#line 1967
        if (wasspace) {
#line 1967
          if (ch == 45) {
#line 1968
            nowr = 1;
#line 1969
            fp->useshexstrings = 0U;
#line 1970
            rdpt = (char *)"|";
          } else {
#line 1967
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 1971
        if (wasspace) {
#line 1971
          if (ch == 82) {
#line 1972
            nowr = 1;
#line 1973
            fp->useshexstrings = 0U;
#line 1974
            rdpt = (char *)"D";
          } else {
#line 1971
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 1975
        if (inr) {
#line 1975
          if (ch == (int )*rdpt) {
#line 1976
            rdpt ++;
#line 1976
            if ((int )*rdpt == 0) {
              {
#line 1977
              ch = _IO_getc(temp);
#line 1978
              tmp___6 = pt;
#line 1978
              pt ++;
#line 1978
              *tmp___6 = (char )ch;
#line 1979
              tmp___7 = __ctype_b_loc();
              }
#line 1979
              if ((int const   )*(*tmp___7 + ch) & 8192) {
#line 1979
                if (val != 0) {
#line 1980
                  inhex = (int )fp->useshexstrings;
#line 1981
                  inbinary = ! fp->useshexstrings;
#line 1982
                  firstnibble = 1;
#line 1983
                  cnt = val;
#line 1984
                  binstart = pt;
#line 1985
                  binlen = val;
                }
              }
            } else {
#line 1988
              nowr = 1;
            }
          } else {
#line 1975
            goto _L;
          }
        } else
        _L: /* CIL Label */ 
#line 1989
        if (wasminus) {
#line 1989
          if (ch == 33) {
            {
#line 1990
            ch = _IO_getc(temp);
#line 1991
            tmp___8 = pt;
#line 1991
            pt ++;
#line 1991
            *tmp___8 = (char )ch;
#line 1992
            tmp___9 = __ctype_b_loc();
            }
#line 1992
            if ((int const   )*(*tmp___9 + ch) & 8192) {
#line 1992
              if (val != 0) {
#line 1993
                inhex = 1;
#line 1994
                cnt = val;
#line 1995
                binstart = pt;
#line 1996
                binlen = val;
#line 1997
                firstnibble = 1;
              }
            }
          }
        }
      }
    }
#line 2000
    innum = nownum;
#line 2000
    wasspace = nowspace;
#line 2000
    inr = nowr;
#line 2001
    wasminus = isminus;
#line 2002
    first = 0;
  }
  while_break: /* CIL Label */ ;
  }
#line 2004
  *pt = (char )'\000';
#line 2005
  if ((unsigned long )binstart == (unsigned long )((void *)0)) {
    {
#line 2006
    parseline(fp, buffer, temp);
    }
  } else {
    {
#line 2008
    addinfo(fp, buffer, temptok, binstart, binlen, temp);
    }
  }
#line 2010
  return (1);
}
}
#line 2013 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static int nrandombytes[4]  ;
#line 2018 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void decrypteexec(FILE *in , FILE *temp , int hassectionheads , char *extra ) 
{ 
  int ch1 ;
  int ch2 ;
  int ch3 ;
  int ch4 ;
  int binary ;
  int zcnt ;
  unsigned char zeros[23] ;
  int sect_len ;
  int tmp ;
  char *tmp___0 ;
  unsigned short const   **tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  int tmp___4 ;
  char *tmp___5 ;
  int tmp___6 ;
  char *tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  char *tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  char *tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  char *tmp___16 ;
  int tmp___17 ;
  char *tmp___18 ;
  int tmp___19 ;
  char *tmp___20 ;
  int tmp___21 ;
  char *tmp___22 ;
  int tmp___23 ;
  char *tmp___24 ;
  int tmp___25 ;
  char *tmp___26 ;
  int tmp___27 ;
  char *tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  char *tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  char *tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  char *tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  char *tmp___44 ;
  int tmp___45 ;
  char *tmp___46 ;
  int tmp___47 ;
  char *tmp___48 ;
  int tmp___49 ;
  char *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  char *tmp___54 ;
  unsigned short const   **tmp___55 ;
  int tmp___56 ;
  char *tmp___57 ;
  unsigned short const   **tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;
  int tmp___62 ;
  int tmp___63 ;
  char *tmp___64 ;
  int tmp___65 ;
  char *tmp___66 ;
  unsigned short const   **tmp___67 ;

  {
#line 2024
  if ((unsigned long )extra == (unsigned long )((void *)5)) {
#line 2024
    extra = (char *)"";
  }
  {
#line 2026
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2026
    if ((int )*extra == 0) {
      {
#line 2026
      tmp = _IO_getc(in);
#line 2026
      ch1 = tmp;
      }
    } else {
#line 2026
      tmp___0 = extra;
#line 2026
      extra ++;
#line 2026
      ch1 = (int )((unsigned char )*tmp___0);
    }
#line 2026
    if (ch1 != -1) {
      {
#line 2026
      tmp___1 = __ctype_b_loc();
      }
#line 2026
      if (! ((int const   )*(*tmp___1 + ch1) & 8192)) {
#line 2026
        goto while_break;
      }
    } else {
#line 2026
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2027
  if (ch1 == 128) {
#line 2027
    if (hassectionheads) {
#line 2029
      if ((int )*extra == 0) {
        {
#line 2029
        tmp___2 = _IO_getc(in);
#line 2029
        ch1 = tmp___2;
        }
      } else {
#line 2029
        tmp___3 = extra;
#line 2029
        extra ++;
#line 2029
        ch1 = (int )((unsigned char )*tmp___3);
      }
#line 2030
      if ((int )*extra == 0) {
        {
#line 2030
        tmp___4 = _IO_getc(in);
#line 2030
        sect_len = tmp___4;
        }
      } else {
#line 2030
        tmp___5 = extra;
#line 2030
        extra ++;
#line 2030
        sect_len = (int )((unsigned char )*tmp___5);
      }
#line 2031
      if ((int )*extra == 0) {
        {
#line 2031
        tmp___6 = _IO_getc(in);
#line 2031
        tmp___8 = tmp___6;
        }
      } else {
#line 2031
        tmp___7 = extra;
#line 2031
        extra ++;
#line 2031
        tmp___8 = (int )((unsigned char )*tmp___7);
      }
#line 2031
      sect_len |= tmp___8 << 8;
#line 2032
      if ((int )*extra == 0) {
        {
#line 2032
        tmp___9 = _IO_getc(in);
#line 2032
        tmp___11 = tmp___9;
        }
      } else {
#line 2032
        tmp___10 = extra;
#line 2032
        extra ++;
#line 2032
        tmp___11 = (int )((unsigned char )*tmp___10);
      }
#line 2032
      sect_len |= tmp___11 << 16;
#line 2033
      if ((int )*extra == 0) {
        {
#line 2033
        tmp___12 = _IO_getc(in);
#line 2033
        tmp___14 = tmp___12;
        }
      } else {
#line 2033
        tmp___13 = extra;
#line 2033
        extra ++;
#line 2033
        tmp___14 = (int )((unsigned char )*tmp___13);
      }
#line 2033
      sect_len |= tmp___14 << 24;
#line 2034
      sect_len -= 3;
#line 2035
      if ((int )*extra == 0) {
        {
#line 2035
        tmp___15 = _IO_getc(in);
#line 2035
        ch1 = tmp___15;
        }
      } else {
#line 2035
        tmp___16 = extra;
#line 2035
        extra ++;
#line 2035
        ch1 = (int )((unsigned char )*tmp___16);
      }
    }
  }
#line 2037
  if ((int )*extra == 0) {
    {
#line 2037
    tmp___17 = _IO_getc(in);
#line 2037
    ch2 = tmp___17;
    }
  } else {
#line 2037
    tmp___18 = extra;
#line 2037
    extra ++;
#line 2037
    ch2 = (int )((unsigned char )*tmp___18);
  }
#line 2037
  if ((int )*extra == 0) {
    {
#line 2037
    tmp___19 = _IO_getc(in);
#line 2037
    ch3 = tmp___19;
    }
  } else {
#line 2037
    tmp___20 = extra;
#line 2037
    extra ++;
#line 2037
    ch3 = (int )((unsigned char )*tmp___20);
  }
#line 2037
  if ((int )*extra == 0) {
    {
#line 2037
    tmp___21 = _IO_getc(in);
#line 2037
    ch4 = tmp___21;
    }
  } else {
#line 2037
    tmp___22 = extra;
#line 2037
    extra ++;
#line 2037
    ch4 = (int )((unsigned char )*tmp___22);
  }
#line 2038
  binary = 0;
#line 2039
  if (ch1 < 48) {
#line 2043
    binary = 1;
  } else
#line 2039
  if (ch1 > 57) {
#line 2039
    if (ch1 < 65) {
#line 2043
      binary = 1;
    } else {
#line 2039
      goto _L___6;
    }
  } else
  _L___6: /* CIL Label */ 
#line 2039
  if (ch1 > 70) {
#line 2039
    if (ch1 < 97) {
#line 2043
      binary = 1;
    } else {
#line 2039
      goto _L___5;
    }
  } else
  _L___5: /* CIL Label */ 
#line 2039
  if (ch1 > 102) {
#line 2043
    binary = 1;
  } else
#line 2039
  if (ch2 < 48) {
#line 2043
    binary = 1;
  } else
#line 2039
  if (ch2 > 57) {
#line 2039
    if (ch2 < 65) {
#line 2043
      binary = 1;
    } else {
#line 2039
      goto _L___4;
    }
  } else
  _L___4: /* CIL Label */ 
#line 2039
  if (ch2 > 70) {
#line 2039
    if (ch2 < 97) {
#line 2043
      binary = 1;
    } else {
#line 2039
      goto _L___3;
    }
  } else
  _L___3: /* CIL Label */ 
#line 2039
  if (ch2 > 102) {
#line 2043
    binary = 1;
  } else
#line 2039
  if (ch3 < 48) {
#line 2043
    binary = 1;
  } else
#line 2039
  if (ch3 > 57) {
#line 2039
    if (ch3 < 65) {
#line 2043
      binary = 1;
    } else {
#line 2039
      goto _L___2;
    }
  } else
  _L___2: /* CIL Label */ 
#line 2039
  if (ch3 > 70) {
#line 2039
    if (ch3 < 97) {
#line 2043
      binary = 1;
    } else {
#line 2039
      goto _L___1;
    }
  } else
  _L___1: /* CIL Label */ 
#line 2039
  if (ch3 > 102) {
#line 2043
    binary = 1;
  } else
#line 2039
  if (ch4 < 48) {
#line 2043
    binary = 1;
  } else
#line 2039
  if (ch4 > 57) {
#line 2039
    if (ch4 < 65) {
#line 2043
      binary = 1;
    } else {
#line 2039
      goto _L___0;
    }
  } else
  _L___0: /* CIL Label */ 
#line 2039
  if (ch4 > 70) {
#line 2039
    if (ch4 < 97) {
#line 2043
      binary = 1;
    } else {
#line 2039
      goto _L;
    }
  } else
  _L: /* CIL Label */ 
#line 2039
  if (ch4 > 102) {
#line 2043
    binary = 1;
  }
#line 2044
  if (ch1 == -1) {
#line 2045
    return;
  } else
#line 2044
  if (ch2 == -1) {
#line 2045
    return;
  } else
#line 2044
  if (ch3 == -1) {
#line 2045
    return;
  } else
#line 2044
  if (ch4 == -1) {
#line 2045
    return;
  }
  {
#line 2048
  initcode();
  }
#line 2049
  if (binary) {
    {
#line 2050
    nrandombytes[0] = decode((unsigned char )ch1);
#line 2051
    nrandombytes[1] = decode((unsigned char )ch2);
#line 2052
    nrandombytes[2] = decode((unsigned char )ch3);
#line 2053
    nrandombytes[3] = decode((unsigned char )ch4);
#line 2054
    zcnt = 0;
    }
    {
#line 2055
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2055
      if ((int )*extra == 0) {
        {
#line 2055
        tmp___39 = _IO_getc(in);
#line 2055
        ch1 = tmp___39;
        }
      } else {
#line 2055
        tmp___40 = extra;
#line 2055
        extra ++;
#line 2055
        ch1 = (int )((unsigned char )*tmp___40);
      }
#line 2055
      if (! (ch1 != -1)) {
#line 2055
        goto while_break___0;
      }
#line 2056
      sect_len --;
#line 2057
      if (hassectionheads) {
#line 2058
        if (sect_len == 0) {
#line 2058
          if (ch1 == 128) {
#line 2059
            if ((int )*extra == 0) {
              {
#line 2059
              tmp___23 = _IO_getc(in);
#line 2059
              ch1 = tmp___23;
              }
            } else {
#line 2059
              tmp___24 = extra;
#line 2059
              extra ++;
#line 2059
              ch1 = (int )((unsigned char )*tmp___24);
            }
#line 2060
            if ((int )*extra == 0) {
              {
#line 2060
              tmp___25 = _IO_getc(in);
#line 2060
              sect_len = tmp___25;
              }
            } else {
#line 2060
              tmp___26 = extra;
#line 2060
              extra ++;
#line 2060
              sect_len = (int )((unsigned char )*tmp___26);
            }
#line 2061
            if ((int )*extra == 0) {
              {
#line 2061
              tmp___27 = _IO_getc(in);
#line 2061
              tmp___29 = tmp___27;
              }
            } else {
#line 2061
              tmp___28 = extra;
#line 2061
              extra ++;
#line 2061
              tmp___29 = (int )((unsigned char )*tmp___28);
            }
#line 2061
            sect_len |= tmp___29 << 8;
#line 2062
            if ((int )*extra == 0) {
              {
#line 2062
              tmp___30 = _IO_getc(in);
#line 2062
              tmp___32 = tmp___30;
              }
            } else {
#line 2062
              tmp___31 = extra;
#line 2062
              extra ++;
#line 2062
              tmp___32 = (int )((unsigned char )*tmp___31);
            }
#line 2062
            sect_len |= tmp___32 << 16;
#line 2063
            if ((int )*extra == 0) {
              {
#line 2063
              tmp___33 = _IO_getc(in);
#line 2063
              tmp___35 = tmp___33;
              }
            } else {
#line 2063
              tmp___34 = extra;
#line 2063
              extra ++;
#line 2063
              tmp___35 = (int )((unsigned char )*tmp___34);
            }
#line 2063
            sect_len |= tmp___35 << 24;
#line 2064
            sect_len ++;
#line 2065
            if (ch1 == 1) {
#line 2066
              goto while_break___0;
            }
          } else {
            {
#line 2068
            dumpzeros(temp, zeros, zcnt);
#line 2069
            zcnt = 0;
#line 2070
            tmp___36 = decode((unsigned char )ch1);
#line 2070
            _IO_putc(tmp___36, temp);
            }
          }
        } else {
          {
#line 2068
          dumpzeros(temp, zeros, zcnt);
#line 2069
          zcnt = 0;
#line 2070
          tmp___36 = decode((unsigned char )ch1);
#line 2070
          _IO_putc(tmp___36, temp);
          }
        }
      } else {
#line 2073
        if (ch1 == 48) {
#line 2073
          zcnt ++;
        } else {
          {
#line 2073
          dumpzeros(temp, zeros, zcnt);
#line 2073
          zcnt = 0;
          }
        }
#line 2074
        if (zcnt > 16) {
#line 2075
          goto while_break___0;
        }
#line 2076
        if (zcnt == 0) {
          {
#line 2077
          tmp___37 = decode((unsigned char )ch1);
#line 2077
          _IO_putc(tmp___37, temp);
          }
        } else {
          {
#line 2079
          tmp___38 = decode((unsigned char )ch1);
#line 2079
          zeros[zcnt - 1] = (unsigned char )tmp___38;
          }
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  } else {
    {
#line 2083
    tmp___41 = hex(ch1, ch2);
#line 2083
    nrandombytes[0] = decode((unsigned char )tmp___41);
#line 2084
    tmp___42 = hex(ch3, ch4);
#line 2084
    nrandombytes[1] = decode((unsigned char )tmp___42);
    }
#line 2085
    if ((int )*extra == 0) {
      {
#line 2085
      tmp___43 = _IO_getc(in);
#line 2085
      ch1 = tmp___43;
      }
    } else {
#line 2085
      tmp___44 = extra;
#line 2085
      extra ++;
#line 2085
      ch1 = (int )((unsigned char )*tmp___44);
    }
#line 2085
    if ((int )*extra == 0) {
      {
#line 2085
      tmp___45 = _IO_getc(in);
#line 2085
      ch2 = tmp___45;
      }
    } else {
#line 2085
      tmp___46 = extra;
#line 2085
      extra ++;
#line 2085
      ch2 = (int )((unsigned char )*tmp___46);
    }
#line 2085
    if ((int )*extra == 0) {
      {
#line 2085
      tmp___47 = _IO_getc(in);
#line 2085
      ch3 = tmp___47;
      }
    } else {
#line 2085
      tmp___48 = extra;
#line 2085
      extra ++;
#line 2085
      ch3 = (int )((unsigned char )*tmp___48);
    }
#line 2085
    if ((int )*extra == 0) {
      {
#line 2085
      tmp___49 = _IO_getc(in);
#line 2085
      ch4 = tmp___49;
      }
    } else {
#line 2085
      tmp___50 = extra;
#line 2085
      extra ++;
#line 2085
      ch4 = (int )((unsigned char )*tmp___50);
    }
    {
#line 2086
    tmp___51 = hex(ch1, ch2);
#line 2086
    nrandombytes[2] = decode((unsigned char )tmp___51);
#line 2087
    tmp___52 = hex(ch3, ch4);
#line 2087
    nrandombytes[3] = decode((unsigned char )tmp___52);
#line 2088
    zcnt = 0;
    }
    {
#line 2089
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2089
      if ((int )*extra == 0) {
        {
#line 2089
        tmp___63 = _IO_getc(in);
#line 2089
        ch1 = tmp___63;
        }
      } else {
#line 2089
        tmp___64 = extra;
#line 2089
        extra ++;
#line 2089
        ch1 = (int )((unsigned char )*tmp___64);
      }
#line 2089
      if (! (ch1 != -1)) {
#line 2089
        goto while_break___1;
      }
      {
#line 2090
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 2090
        if (ch1 != -1) {
          {
#line 2090
          tmp___55 = __ctype_b_loc();
          }
#line 2090
          if (! ((int const   )*(*tmp___55 + ch1) & 8192)) {
#line 2090
            goto while_break___2;
          }
        } else {
#line 2090
          goto while_break___2;
        }
#line 2090
        if ((int )*extra == 0) {
          {
#line 2090
          tmp___53 = _IO_getc(in);
#line 2090
          ch1 = tmp___53;
          }
        } else {
#line 2090
          tmp___54 = extra;
#line 2090
          extra ++;
#line 2090
          ch1 = (int )((unsigned char )*tmp___54);
        }
      }
      while_break___2: /* CIL Label */ ;
      }
      {
#line 2091
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 2091
        if ((int )*extra == 0) {
          {
#line 2091
          tmp___56 = _IO_getc(in);
#line 2091
          ch2 = tmp___56;
          }
        } else {
#line 2091
          tmp___57 = extra;
#line 2091
          extra ++;
#line 2091
          ch2 = (int )((unsigned char )*tmp___57);
        }
#line 2091
        if (ch2 != -1) {
          {
#line 2091
          tmp___58 = __ctype_b_loc();
          }
#line 2091
          if (! ((int const   )*(*tmp___58 + ch2) & 8192)) {
#line 2091
            goto while_break___3;
          }
        } else {
#line 2091
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 2092
      if (ch1 == 48) {
#line 2092
        if (ch2 == 48) {
#line 2092
          zcnt ++;
        } else {
          {
#line 2092
          dumpzeros(temp, zeros, zcnt);
#line 2092
          zcnt = 0;
          }
        }
      } else {
        {
#line 2092
        dumpzeros(temp, zeros, zcnt);
#line 2092
        zcnt = 0;
        }
      }
#line 2093
      if (zcnt > 16) {
#line 2094
        goto while_break___1;
      }
#line 2095
      if (zcnt == 0) {
        {
#line 2096
        tmp___59 = hex(ch1, ch2);
#line 2096
        tmp___60 = decode((unsigned char )tmp___59);
#line 2096
        _IO_putc(tmp___60, temp);
        }
      } else {
        {
#line 2098
        tmp___61 = hex(ch1, ch2);
#line 2098
        tmp___62 = decode((unsigned char )tmp___61);
#line 2098
        zeros[zcnt - 1] = (unsigned char )tmp___62;
        }
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 2101
  while (1) {
    while_continue___4: /* CIL Label */ ;
#line 2101
    if ((int )*extra == 0) {
      {
#line 2101
      tmp___65 = _IO_getc(in);
#line 2101
      ch1 = tmp___65;
      }
    } else {
#line 2101
      tmp___66 = extra;
#line 2101
      extra ++;
#line 2101
      ch1 = (int )((unsigned char )*tmp___66);
    }
#line 2101
    if (! (ch1 == 48)) {
      {
#line 2101
      tmp___67 = __ctype_b_loc();
      }
#line 2101
      if (! ((int const   )*(*tmp___67 + ch1) & 8192)) {
#line 2101
        goto while_break___4;
      }
    }
  }
  while_break___4: /* CIL Label */ ;
  }
#line 2102
  if (ch1 != -1) {
    {
#line 2102
    ungetc(ch1, in);
    }
  }
#line 2103
  return;
}
}
#line 2105 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void decryptagain(struct fontparse *fp , FILE *temp , char *rdtok ) 
{ 
  int tmp ;

  {
  {
#line 2106
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2106
    tmp = glorpline(fp, temp, rdtok);
    }
#line 2106
    if (! tmp) {
#line 2106
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2107
  return;
}
}
#line 2109 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void parsetype3(struct fontparse *fp , FILE *in ) 
{ 


  {
#line 2111
  return;
}
}
#line 2113 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static unsigned char *readt1str(FILE *temp , int offset , int len , int leniv ) 
{ 
  int i ;
  unsigned char *str ;
  unsigned char *pt ;
  unsigned short r___0 ;
  unsigned char plain ;
  unsigned char cypher ;
  void *tmp ;
  unsigned char *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  void *tmp___3 ;
  int tmp___4 ;
  unsigned char *tmp___5 ;

  {
  {
#line 2116
  r___0 = (unsigned short)4330;
#line 2123
  fseek(temp, (long )offset, 0);
  }
#line 2124
  if (leniv < 0) {
    {
#line 2125
    tmp = malloc((size_t )(len + 1));
#line 2125
    pt = (unsigned char *)tmp;
#line 2125
    str = pt;
    }
    {
#line 2126
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2126
      if (! (i < len)) {
#line 2126
        goto while_break;
      }
      {
#line 2127
      tmp___0 = pt;
#line 2127
      pt ++;
#line 2127
      tmp___1 = _IO_getc(temp);
#line 2127
      *tmp___0 = (unsigned char )tmp___1;
#line 2126
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  } else {
#line 2129
    i = 0;
    {
#line 2129
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2129
      if (! (i < leniv)) {
#line 2129
        goto while_break___0;
      }
      {
#line 2130
      tmp___2 = _IO_getc(temp);
#line 2130
      cypher = (unsigned char )tmp___2;
#line 2131
      plain = (unsigned char )((int )cypher ^ ((int )r___0 >> 8));
#line 2132
      r___0 = (unsigned short )(((int )cypher + (int )r___0) * 52845 + 22719);
#line 2129
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2134
    tmp___3 = malloc((size_t )((len - leniv) + 1));
#line 2134
    pt = (unsigned char *)tmp___3;
#line 2134
    str = pt;
    }
    {
#line 2135
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2135
      if (! (i < len)) {
#line 2135
        goto while_break___1;
      }
      {
#line 2136
      tmp___4 = _IO_getc(temp);
#line 2136
      cypher = (unsigned char )tmp___4;
#line 2137
      plain = (unsigned char )((int )cypher ^ ((int )r___0 >> 8));
#line 2138
      r___0 = (unsigned short )(((int )cypher + (int )r___0) * 52845 + 22719);
#line 2139
      tmp___5 = pt;
#line 2139
      pt ++;
#line 2139
      *tmp___5 = plain;
#line 2135
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
#line 2142
  *pt = (unsigned char )'\000';
#line 2143
  return (str);
}
}
#line 2146 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void figurecids(struct fontparse *fp , FILE *temp ) 
{ 
  struct fontdict *fd ;
  int i ;
  int j ;
  int k ;
  int val ;
  int *offsets ;
  int cidcnt ;
  int leniv ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;
  void *tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  struct private *private ;
  char *ssubroff ;
  char *tmp___5 ;
  char *ssdbytes ;
  char *tmp___6 ;
  char *ssubrcnt ;
  char *tmp___7 ;
  int subroff ;
  int sdbytes ;
  int subrcnt ;
  void *tmp___8 ;
  void *tmp___9 ;
  void *tmp___10 ;
  int tmp___11 ;
  long tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;

  {
  {
#line 2147
  fd = fp->mainfd;
#line 2150
  cidcnt = fd->cidcnt;
#line 2154
  tmp = malloc((unsigned long )cidcnt * sizeof(unsigned char *));
#line 2154
  fd->cidstrs = (unsigned char **)tmp;
#line 2155
  tmp___0 = malloc((unsigned long )cidcnt * sizeof(short ));
#line 2155
  fd->cidlens = (short *)tmp___0;
#line 2156
  tmp___1 = malloc((unsigned long )(cidcnt + 1) * sizeof(short ));
#line 2156
  fd->cidfds = (short *)tmp___1;
#line 2157
  tmp___2 = malloc((unsigned long )(cidcnt + 1) * sizeof(int ));
#line 2157
  offsets = (int *)tmp___2;
#line 2159
  fseek(temp, (long )fd->mapoffset, 0);
#line 2160
  i = 0;
  }
  {
#line 2160
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2160
    if (! (i <= fd->cidcnt)) {
#line 2160
      goto while_break;
    }
#line 2161
    val = 0;
#line 2161
    j = val;
    {
#line 2161
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2161
      if (! (j < fd->fdbytes)) {
#line 2161
        goto while_break___0;
      }
      {
#line 2162
      tmp___3 = _IO_getc(temp);
#line 2162
      val = (val << 8) + tmp___3;
#line 2161
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2163
    *(fd->cidfds + i) = (short )val;
#line 2164
    val = 0;
#line 2164
    j = val;
    {
#line 2164
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2164
      if (! (j < fd->gdbytes)) {
#line 2164
        goto while_break___1;
      }
      {
#line 2165
      tmp___4 = _IO_getc(temp);
#line 2165
      val = (val << 8) + tmp___4;
#line 2164
      j ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 2166
    *(offsets + i) = val;
#line 2167
    if (i != 0) {
#line 2168
      *(fd->cidlens + (i - 1)) = (short )(*(offsets + i) - *(offsets + (i - 1)));
    }
#line 2160
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2171
  i = 0;
  {
#line 2171
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 2171
    if (! (i < fd->cidcnt)) {
#line 2171
      goto while_break___2;
    }
#line 2172
    if ((int )*(fd->cidlens + i) == 0) {
#line 2173
      *(fd->cidstrs + i) = (unsigned char *)((void *)0);
    } else {
      {
#line 2175
      *(fd->cidstrs + i) = readt1str(temp, *(offsets + i), (int )*(fd->cidlens + i),
                                     ((*(fd->fds + *(fd->cidfds + i)))->private)->leniv);
#line 2177
      *(fd->cidlens + i) = (short )((int )*(fd->cidlens + i) - ((*(fd->fds + *(fd->cidfds + i)))->private)->leniv);
      }
    }
#line 2171
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2180
  free((void *)offsets);
#line 2182
  k = 0;
  }
  {
#line 2182
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2182
    if (! (k < fd->fdcnt)) {
#line 2182
      goto while_break___3;
    }
    {
#line 2183
    private = (*(fd->fds + k))->private;
#line 2184
    tmp___5 = PSDictHasEntry(private->private, (char *)"SubrMapOffset");
#line 2184
    ssubroff = tmp___5;
#line 2185
    tmp___6 = PSDictHasEntry(private->private, (char *)"SDBytes");
#line 2185
    ssdbytes = tmp___6;
#line 2186
    tmp___7 = PSDictHasEntry(private->private, (char *)"SubrCount");
#line 2186
    ssubrcnt = tmp___7;
    }
#line 2189
    if ((unsigned long )ssubroff != (unsigned long )((void *)0)) {
#line 2189
      if ((unsigned long )ssdbytes != (unsigned long )((void *)0)) {
#line 2189
        if ((unsigned long )ssubrcnt != (unsigned long )((void *)0)) {
          {
#line 2189
          tmp___12 = strtol((char const   */* __restrict  */)ssubroff, (char **/* __restrict  */)((void *)0),
                            10);
#line 2189
          subroff = (int )tmp___12;
          }
#line 2189
          if (subroff >= 0) {
            {
#line 2189
            tmp___13 = strtol((char const   */* __restrict  */)ssdbytes, (char **/* __restrict  */)((void *)0),
                              10);
#line 2189
            sdbytes = (int )tmp___13;
            }
#line 2189
            if (sdbytes > 0) {
              {
#line 2189
              tmp___14 = strtol((char const   */* __restrict  */)ssubrcnt, (char **/* __restrict  */)((void *)0),
                                10);
#line 2189
              subrcnt = (int )tmp___14;
              }
#line 2189
              if (subrcnt > 0) {
                {
#line 2193
                (private->subrs)->cnt = subrcnt;
#line 2194
                tmp___8 = calloc((size_t )subrcnt, sizeof(char *));
#line 2194
                (private->subrs)->values = (unsigned char **)tmp___8;
#line 2195
                tmp___9 = calloc((size_t )subrcnt, sizeof(int ));
#line 2195
                (private->subrs)->lens = (int *)tmp___9;
#line 2196
                leniv = private->leniv;
#line 2197
                tmp___10 = malloc((unsigned long )(subrcnt + 1) * sizeof(int ));
#line 2197
                offsets = (int *)tmp___10;
#line 2198
                fseek(temp, (long )subroff, 0);
#line 2199
                i = 0;
                }
                {
#line 2199
                while (1) {
                  while_continue___4: /* CIL Label */ ;
#line 2199
                  if (! (i <= subrcnt)) {
#line 2199
                    goto while_break___4;
                  }
#line 2200
                  val = 0;
#line 2200
                  j = val;
                  {
#line 2200
                  while (1) {
                    while_continue___5: /* CIL Label */ ;
#line 2200
                    if (! (j < sdbytes)) {
#line 2200
                      goto while_break___5;
                    }
                    {
#line 2201
                    tmp___11 = _IO_getc(temp);
#line 2201
                    val = (val << 8) + tmp___11;
#line 2200
                    j ++;
                    }
                  }
                  while_break___5: /* CIL Label */ ;
                  }
#line 2202
                  *(offsets + i) = val;
#line 2203
                  if (i != 0) {
#line 2204
                    *((private->subrs)->lens + (i - 1)) = *(offsets + i) - *(offsets + (i - 1));
                  }
#line 2199
                  i ++;
                }
                while_break___4: /* CIL Label */ ;
                }
#line 2206
                i = 0;
                {
#line 2206
                while (1) {
                  while_continue___6: /* CIL Label */ ;
#line 2206
                  if (! (i < subrcnt)) {
#line 2206
                    goto while_break___6;
                  }
                  {
#line 2207
                  *((private->subrs)->values + i) = readt1str(temp, *(offsets + i),
                                                              *((private->subrs)->lens + i),
                                                              leniv);
#line 2206
                  i ++;
                  }
                }
                while_break___6: /* CIL Label */ ;
                }
                {
#line 2210
                (private->subrs)->next = i;
#line 2211
                free((void *)offsets);
                }
              }
            }
          }
        }
      }
    }
    {
#line 2213
    PSDictRemoveEntry(private->private, (char *)"SubrMapOffset");
#line 2214
    PSDictRemoveEntry(private->private, (char *)"SDBytes");
#line 2215
    PSDictRemoveEntry(private->private, (char *)"SubrCount");
#line 2182
    k ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2217
  return;
}
}
#line 2219 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void dodata(struct fontparse *fp , FILE *in , FILE *temp ) 
{ 
  int binary ;
  int cnt ;
  int len ;
  int ch ;
  int ch2 ;
  char *pt ;
  char fontsetname[256] ;
  char *tmp ;
  int tmp___0 ;
  unsigned short const   **tmp___1 ;
  unsigned short const   **tmp___2 ;
  unsigned short const   **tmp___3 ;

  {
  {
#line 2225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2225
    ch = _IO_getc(in);
    }
#line 2225
    if (ch != 40) {
#line 2225
      if (ch != 47) {
#line 2225
        if (! (ch != -1)) {
#line 2225
          goto while_break;
        }
      } else {
#line 2225
        goto while_break;
      }
    } else {
#line 2225
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 2226
  if (ch == 47) {
#line 2229
    binary = 1;
#line 2230
    pt = fontsetname;
    {
#line 2230
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2230
      ch = _IO_getc(in);
      }
#line 2230
      if (ch != 32) {
#line 2230
        if (! (ch != -1)) {
#line 2230
          goto while_break___0;
        }
      } else {
#line 2230
        goto while_break___0;
      }
#line 2231
      if ((unsigned long )pt < (unsigned long )((fontsetname + sizeof(fontsetname)) - 1)) {
#line 2232
        tmp = pt;
#line 2232
        pt ++;
#line 2232
        *tmp = (char )ch;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
#line 2233
    *pt = (char )'\000';
  } else {
    {
#line 2235
    ch = _IO_getc(in);
    }
#line 2235
    if (ch == 66) {
#line 2235
      binary = 1;
    } else
#line 2235
    if (ch == 98) {
#line 2235
      binary = 1;
    } else
#line 2236
    if (ch == 72) {
#line 2236
      binary = 0;
    } else
#line 2236
    if (ch == 104) {
#line 2236
      binary = 0;
    } else {
      {
#line 2238
      binary = 1;
#line 2239
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to parse the StartData command properly\n");
      }
    }
#line 2241
    fontsetname[0] = (char )'\000';
  }
  {
#line 2243
  while (1) {
    while_continue___1: /* CIL Label */ ;
    {
#line 2243
    ch = _IO_getc(in);
    }
#line 2243
    if (ch != 41) {
#line 2243
      if (! (ch != -1)) {
#line 2243
        goto while_break___1;
      }
    } else {
#line 2243
      goto while_break___1;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 2244
  tmp___0 = fscanf((FILE */* __restrict  */)in, (char const   */* __restrict  */)"%d",
                   & len);
  }
#line 2244
  if (tmp___0 != 1) {
    {
#line 2245
    len = 0;
#line 2246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to parse the StartData command properly, bad cnt\n");
    }
  } else
#line 2244
  if (len <= 0) {
    {
#line 2245
    len = 0;
#line 2246
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Failed to parse the StartData command properly, bad cnt\n");
    }
  }
#line 2248
  cnt = len;
  {
#line 2249
  while (1) {
    while_continue___2: /* CIL Label */ ;
    {
#line 2249
    tmp___1 = __ctype_b_loc();
#line 2249
    ch = _IO_getc(in);
    }
#line 2249
    if (! ((int const   )*(*tmp___1 + ch) & 8192)) {
#line 2249
      goto while_break___2;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 2250
  ungetc(ch, in);
#line 2251
  pt = (char *)"StartData ";
  }
  {
#line 2251
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 2251
    if (! *pt) {
#line 2251
      goto while_break___3;
    }
    {
#line 2252
    _IO_getc(in);
#line 2251
    pt ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
#line 2253
  if (binary) {
    {
#line 2254
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 2254
      if (! (cnt > 0)) {
#line 2254
        goto while_break___4;
      }
      {
#line 2255
      ch = _IO_getc(in);
#line 2256
      _IO_putc(ch, temp);
#line 2257
      cnt --;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
  } else {
    {
#line 2260
    while (1) {
      while_continue___5: /* CIL Label */ ;
#line 2260
      if (! (cnt > 0)) {
#line 2260
        goto while_break___5;
      }
      {
#line 2262
      while (1) {
        while_continue___6: /* CIL Label */ ;
        {
#line 2262
        tmp___2 = __ctype_b_loc();
#line 2262
        ch = _IO_getc(in);
        }
#line 2262
        if (! ((int const   )*(*tmp___2 + ch) & 8192)) {
#line 2262
          goto while_break___6;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
      {
#line 2263
      while (1) {
        while_continue___7: /* CIL Label */ ;
        {
#line 2263
        tmp___3 = __ctype_b_loc();
#line 2263
        ch2 = _IO_getc(in);
        }
#line 2263
        if (! ((int const   )*(*tmp___3 + ch2) & 8192)) {
#line 2263
          goto while_break___7;
        }
      }
      while_break___7: /* CIL Label */ ;
      }
      {
#line 2264
      ch = hex(ch, ch2);
#line 2265
      _IO_putc(ch, temp);
#line 2266
      cnt --;
      }
    }
    while_break___5: /* CIL Label */ ;
    }
    {
#line 2268
    ch = _IO_getc(in);
    }
#line 2268
    if (ch != 62) {
      {
#line 2268
      ungetc(ch, in);
      }
    }
  }
  {
#line 2270
  rewind(temp);
  }
#line 2271
  if (fp->iscid) {
    {
#line 2272
    figurecids(fp, temp);
    }
  } else {
#line 2275
    (fp->fd)->wascff = 1U;
  }
#line 2277
  return;
}
}
#line 2279 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void doubledecrypt(struct fontparse *fp , FILE *in , FILE *temp ) 
{ 
  char buffer___0[256] ;
  int first ;
  int hassectionheads ;
  char rdtok[20] ;
  int saw_blend ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;
  char *tmp___5 ;
  char *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char *tmp___9 ;
  char *tmp___10 ;
  char *tmp___11 ;
  char *tmp___12 ;
  char *tmp___13 ;
  char *tmp___14 ;

  {
  {
#line 2283
  saw_blend = 0;
#line 2285
  strcpy((char */* __restrict  */)(rdtok), (char const   */* __restrict  */)"RD");
#line 2287
  first = 1;
#line 2287
  hassectionheads = 0;
  }
  {
#line 2288
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 2288
    tmp___11 = myfgets(buffer___0, (int )sizeof(buffer___0), in);
    }
#line 2288
    if (! ((unsigned long )tmp___11 != (unsigned long )((void *)0))) {
#line 2288
      goto while_break;
    }
    {
#line 2289
    tmp = strstr((char const   *)(buffer___0), "Blend");
    }
#line 2289
    if ((unsigned long )tmp != (unsigned long )((void *)0)) {
#line 2290
      saw_blend = 1;
    }
#line 2291
    if (first) {
#line 2291
      if ((int )buffer___0[0] == -128) {
        {
#line 2292
        hassectionheads = 1;
#line 2293
        (fp->fd)->wasbinary = 1U;
#line 2294
        parseline(fp, buffer___0 + 6, in);
        }
      } else {
#line 2291
        goto _L___2;
      }
    } else {
      _L___2: /* CIL Label */ 
      {
#line 2295
      tmp___6 = strstr((char const   *)(buffer___0), "CharProcs");
      }
#line 2295
      if ((unsigned long )tmp___6 != (unsigned long )((void *)0)) {
        {
#line 2295
        tmp___7 = strstr((char const   *)(buffer___0), "begin");
        }
#line 2295
        if ((unsigned long )tmp___7 != (unsigned long )((void *)0)) {
          {
#line 2296
          parsetype3(fp, in);
          }
#line 2297
          return;
        } else {
#line 2295
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 2298
      if (! fp->iscid) {
#line 2299
        if (saw_blend) {
          {
#line 2300
          parseline(fp, buffer___0, in);
          }
        } else {
          {
#line 2302
          tmp___4 = strstr((char const   *)(buffer___0), "/CharStrings");
          }
#line 2302
          if ((unsigned long )tmp___4 != (unsigned long )((void *)0)) {
            {
#line 2302
            tmp___5 = strstr((char const   *)(buffer___0), "begin");
            }
#line 2302
            if ((unsigned long )tmp___5 != (unsigned long )((void *)0)) {
              {
#line 2304
              InitChars((fp->fd)->chars, buffer___0);
#line 2305
              fp->inchars = 1U;
#line 2306
              decryptagain(fp, in, rdtok);
              }
#line 2307
              return;
            } else {
#line 2302
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
            {
#line 2308
            tmp___2 = strstr((char const   *)(buffer___0), "/Subrs");
            }
#line 2308
            if ((unsigned long )tmp___2 != (unsigned long )((void *)0)) {
              {
#line 2308
              tmp___3 = strstr((char const   *)(buffer___0), "array");
              }
#line 2308
              if ((unsigned long )tmp___3 != (unsigned long )((void *)0)) {
                {
#line 2310
                InitChars(((fp->fd)->private)->subrs, buffer___0);
#line 2311
                fp->insubs = 1U;
#line 2312
                decryptagain(fp, in, rdtok);
                }
#line 2313
                return;
              } else {
#line 2308
                goto _L;
              }
            } else {
              _L: /* CIL Label */ 
              {
#line 2314
              tmp___0 = strstr((char const   *)(buffer___0), "/Private");
              }
#line 2314
              if ((unsigned long )tmp___0 != (unsigned long )((void *)0)) {
                {
#line 2314
                tmp___1 = strstr((char const   *)(buffer___0), "dict");
                }
#line 2314
                if ((unsigned long )tmp___1 != (unsigned long )((void *)0)) {
                  {
#line 2316
                  fp->inprivate = 1U;
#line 2317
                  fp->infi = 0U;
#line 2318
                  decryptagain(fp, in, rdtok);
                  }
#line 2319
                  return;
                } else {
                  {
#line 2321
                  parseline(fp, buffer___0, in);
                  }
                }
              } else {
                {
#line 2321
                parseline(fp, buffer___0, in);
                }
              }
            }
          }
        }
      } else {
        {
#line 2323
        parseline(fp, buffer___0, in);
        }
      }
    }
    {
#line 2324
    first = 0;
#line 2325
    tmp___8 = strstr((char const   *)(buffer___0), "%%BeginData: ");
    }
#line 2325
    if ((unsigned long )tmp___8 != (unsigned long )((void *)0)) {
#line 2326
      goto while_break;
    }
    {
#line 2327
    tmp___9 = strstr((char const   *)(buffer___0), "currentfile");
    }
#line 2327
    if ((unsigned long )tmp___9 != (unsigned long )((void *)0)) {
      {
#line 2327
      tmp___10 = strstr((char const   *)(buffer___0), "eexec");
      }
#line 2327
      if ((unsigned long )tmp___10 != (unsigned long )((void *)0)) {
#line 2328
        fp->skipping_mbf = 0U;
#line 2329
        goto while_break;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2333
  tmp___14 = strstr((char const   *)(buffer___0), "%%BeginData: ");
  }
#line 2333
  if ((unsigned long )tmp___14 != (unsigned long )((void *)0)) {
    {
#line 2335
    dodata(fp, in, temp);
    }
  } else {
    {
#line 2337
    tmp___12 = strstr((char const   *)(buffer___0), "eexec");
#line 2337
    decrypteexec(in, temp, hassectionheads, tmp___12 + 5);
#line 2338
    rewind(temp);
#line 2339
    decryptagain(fp, temp, rdtok);
    }
    {
#line 2340
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 2340
      tmp___13 = myfgets(buffer___0, (int )sizeof(buffer___0), in);
      }
#line 2340
      if (! ((unsigned long )tmp___13 != (unsigned long )((void *)0))) {
#line 2340
        goto while_break___0;
      }
#line 2341
      if ((int )buffer___0[0] != -128) {
        {
#line 2342
        parseline(fp, buffer___0, in);
        }
      } else
#line 2341
      if (! hassectionheads) {
        {
#line 2342
        parseline(fp, buffer___0, in);
        }
      }
    }
    while_break___0: /* CIL Label */ ;
    }
  }
#line 2345
  return;
}
}
#line 2347 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static FontDict *_ReadPSFont(FILE *in ) 
{ 
  FILE *temp ;
  struct fontparse fp ;
  char *oldloc ;

  {
  {
#line 2352
  temp = tmpfile();
  }
#line 2353
  if ((unsigned long )temp == (unsigned long )((void *)0)) {
    {
#line 2354
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open a temporary file\n");
#line 2355
    fclose(in);
    }
#line 2356
    return ((FontDict *)((void *)0));
  }
  {
#line 2359
  oldloc = setlocale(1, "C");
#line 2360
  memset((void *)(& fp), '\000', sizeof(fp));
#line 2361
  fp.mainfd = PSMakeEmptyFont();
#line 2361
  fp.fd = fp.mainfd;
#line 2362
  fp.fdindex = -1;
#line 2363
  doubledecrypt(& fp, in, temp);
#line 2364
  free((void *)fp.vbuf);
#line 2365
  setlocale(1, (char const   *)oldloc);
#line 2367
  fclose(temp);
  }
#line 2368
  return (fp.fd);
}
}
#line 2372 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void PSCharsFree(struct pschars *chrs ) 
{ 
  int i ;

  {
#line 2375
  if ((unsigned long )chrs == (unsigned long )((void *)0)) {
#line 2376
    return;
  }
#line 2377
  i = 0;
  {
#line 2377
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2377
    if (! (i < chrs->next)) {
#line 2377
      goto while_break;
    }
#line 2378
    if ((unsigned long )chrs->keys != (unsigned long )((void *)0)) {
      {
#line 2378
      free((void *)*(chrs->keys + i));
      }
    }
    {
#line 2379
    free((void *)*(chrs->values + i));
#line 2377
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2381
  free((void *)chrs->lens);
#line 2382
  free((void *)chrs->keys);
#line 2383
  free((void *)chrs->values);
#line 2384
  free((void *)chrs);
  }
#line 2385
  return;
}
}
#line 2387 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void PSDictFree(struct psdict *dict ) 
{ 
  int i ;

  {
#line 2390
  if ((unsigned long )dict == (unsigned long )((void *)0)) {
#line 2391
    return;
  }
#line 2392
  i = 0;
  {
#line 2392
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2392
    if (! (i < dict->next)) {
#line 2392
      goto while_break;
    }
#line 2393
    if ((unsigned long )dict->keys != (unsigned long )((void *)0)) {
      {
#line 2393
      free((void *)*(dict->keys + i));
      }
    }
    {
#line 2394
    free((void *)*(dict->values + i));
#line 2392
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 2396
  free((void *)dict->keys);
#line 2397
  free((void *)dict->values);
#line 2398
  free((void *)dict);
  }
#line 2399
  return;
}
}
#line 2401 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void PrivateFree(struct private *prv ) 
{ 


  {
  {
#line 2402
  PSCharsFree(prv->subrs);
#line 2404
  PSDictFree(prv->private);
#line 2412
  free((void *)prv);
  }
#line 2413
  return;
}
}
#line 2415 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void FontInfoFree(struct fontinfo *fi ) 
{ 


  {
  {
#line 2416
  free((void *)fi->familyname);
#line 2417
  free((void *)fi->fullname);
#line 2418
  free((void *)fi->notice);
#line 2419
  free((void *)fi->weight);
#line 2420
  free((void *)fi->version);
#line 2421
  free((void *)fi->blenddesignpositions);
#line 2422
  free((void *)fi->blenddesignmap);
#line 2423
  free((void *)fi->blendaxistypes);
#line 2424
  free((void *)fi);
  }
#line 2425
  return;
}
}
#line 2427 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void PSFontFree(FontDict *fd ) 
{ 
  int i ;

  {
#line 2430
  if ((unsigned long )(fd->encoding) != (unsigned long )((void *)0)) {
#line 2431
    i = 0;
    {
#line 2431
    while (1) {
      while_continue: /* CIL Label */ ;
#line 2431
      if (! (i < 256)) {
#line 2431
        goto while_break;
      }
      {
#line 2432
      free((void *)fd->encoding[i]);
#line 2431
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
  }
  {
#line 2433
  free((void *)fd->fontname);
#line 2434
  free((void *)fd->cidfontname);
#line 2435
  free((void *)fd->registry);
#line 2436
  free((void *)fd->ordering);
#line 2437
  FontInfoFree(fd->fontinfo);
#line 2438
  PSCharsFree(fd->chars);
#line 2439
  PrivateFree(fd->private);
  }
#line 2440
  if ((unsigned long )fd->charprocs != (unsigned long )((void *)0)) {
#line 2441
    i = 0;
    {
#line 2441
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 2441
      if (! (i < (fd->charprocs)->cnt)) {
#line 2441
        goto while_break___0;
      }
      {
#line 2442
      free((void *)*((fd->charprocs)->keys + i));
#line 2441
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 2443
    free((void *)(fd->charprocs)->keys);
#line 2444
    free((void *)(fd->charprocs)->values);
#line 2445
    free((void *)fd->charprocs);
    }
  }
#line 2447
  if ((unsigned long )fd->cidstrs != (unsigned long )((void *)0)) {
#line 2448
    i = 0;
    {
#line 2448
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 2448
      if (! (i < fd->cidcnt)) {
#line 2448
        goto while_break___1;
      }
      {
#line 2449
      free((void *)*(fd->cidstrs + i));
#line 2448
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 2450
    free((void *)fd->cidstrs);
    }
  }
  {
#line 2452
  free((void *)fd->cidlens);
#line 2453
  free((void *)fd->cidfds);
  }
#line 2454
  if ((unsigned long )fd->fds != (unsigned long )((void *)0)) {
#line 2455
    i = 0;
    {
#line 2455
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 2455
      if (! (i < fd->fdcnt)) {
#line 2455
        goto while_break___2;
      }
      {
#line 2456
      PSFontFree(*(fd->fds + i));
#line 2455
      i ++;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 2457
    free((void *)fd->fds);
    }
  }
  {
#line 2459
  free((void *)fd->blendfunc);
#line 2460
  free((void *)fd->weightvector);
#line 2461
  free((void *)fd->cdv);
#line 2462
  free((void *)fd->ndv);
#line 2464
  PSDictFree(fd->blendprivate);
#line 2465
  PSDictFree(fd->blendfontinfo);
#line 2467
  free((void *)fd);
  }
#line 2468
  return;
}
}
#line 2470 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static struct bbglyph *FindAdobeGlyph(PSFONT *psfont , int adobe_enc ) 
{ 
  char *search_name ;
  struct pschars *chars ;
  int i ;
  int tmp ;
  int tmp___0 ;

  {
#line 2472
  chars = (struct pschars *)psfont->temp;
#line 2475
  if (adobe_enc >= 256) {
#line 2476
    return (psfont->glyphs + 0);
  } else
#line 2475
  if (adobe_enc < 0) {
#line 2476
    return (psfont->glyphs + 0);
  }
#line 2477
  search_name = AdobeStandardEncoding[adobe_enc];
#line 2478
  i = 0;
  {
#line 2478
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2478
    if (! (i < chars->cnt)) {
#line 2478
      goto while_break;
    }
    {
#line 2479
    tmp = strcmp((char const   *)search_name, (char const   *)*(chars->keys + i));
    }
#line 2479
    if (tmp == 0) {
#line 2480
      if ((psfont->glyphs + i)->isref) {
#line 2481
        return ((struct bbglyph *)((void *)0));
      }
#line 2483
      return (psfont->glyphs + i);
    }
#line 2478
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 2487
  i = 0;
  {
#line 2487
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 2487
    if (! (i < chars->cnt)) {
#line 2487
      goto while_break___0;
    }
    {
#line 2488
    tmp___0 = strcmp(".notdef", (char const   *)*(chars->keys + i));
    }
#line 2488
    if (tmp___0 == 0) {
#line 2489
      return (psfont->glyphs + i);
    }
#line 2487
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 2492
  return (psfont->glyphs + 0);
}
}
#line 2495 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
static void FindBB(PSFONT *psfont , struct bbglyph *bb , unsigned char *type1 , int len ,
                   struct pschars *subrs , char *name ) 
{ 
  double stack[50] ;
  int sp ;
  int v ;
  double transient[32] ;
  struct __anonstruct_current_31 current ;
  double dx ;
  double dy ;
  double dx2 ;
  double dy2 ;
  double dx3 ;
  double dy3 ;
  struct substate pcstack[11] ;
  int pcsp ;
  double pops[30] ;
  int popsp ;
  int base ;
  int polarity ;
  struct pschars *s ;
  int first ;
  int lsidebearing ;
  struct bbglyph *bb1 ;
  struct bbglyph *bb2 ;
  int offx ;
  int offy ;
  int tmp ;
  int tmp___0 ;
  unsigned char *tmp___1 ;
  int tmp___2 ;
  unsigned char *tmp___3 ;
  int val ;
  int tmp___4 ;
  int tmp___5 ;
  unsigned char *tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tot___0 ;
  int k ;
  int tmp___10 ;
  int tmp___11 ;
  double temp ;
  int index___0 ;
  int j ;
  int N ;
  double *temp___0 ;
  void *tmp___12 ;
  int i ;
  int tmp___13 ;
  int tmp___14 ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  int tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int tmp___31 ;
  int tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  int tmp___40 ;
  int tmp___41 ;
  int tmp___42 ;
  int tmp___43 ;
  int tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  int tmp___48 ;
  unsigned char *tmp___49 ;

  {
#line 2497
  sp = 0;
#line 2503
  pcsp = 0;
#line 2505
  popsp = 0;
#line 2508
  first = 1;
#line 2513
  current.y = (double )0;
#line 2513
  current.x = current.y;
  {
#line 2514
  while (1) {
    while_continue: /* CIL Label */ ;
#line 2514
    if (! (len > 0)) {
#line 2514
      goto while_break;
    }
#line 2515
    if (sp > 48) {
      {
#line 2516
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack got too big in %s\n",
              name);
#line 2517
      sp = 48;
      }
    }
#line 2519
    base = 0;
#line 2520
    len --;
#line 2521
    tmp___49 = type1;
#line 2521
    type1 ++;
#line 2521
    v = (int )*tmp___49;
#line 2521
    if (v >= 32) {
#line 2522
      if (v <= 246) {
#line 2523
        tmp = sp;
#line 2523
        sp ++;
#line 2523
        stack[tmp] = (double )(v - 139);
      } else
#line 2524
      if (v <= 250) {
#line 2525
        tmp___0 = sp;
#line 2525
        sp ++;
#line 2525
        tmp___1 = type1;
#line 2525
        type1 ++;
#line 2525
        stack[tmp___0] = (double )(((v - 247) * 256 + (int )*tmp___1) + 108);
#line 2526
        len --;
      } else
#line 2527
      if (v <= 254) {
#line 2528
        tmp___2 = sp;
#line 2528
        sp ++;
#line 2528
        tmp___3 = type1;
#line 2528
        type1 ++;
#line 2528
        stack[tmp___2] = (double )((- (v - 251) * 256 - (int )*tmp___3) - 108);
#line 2529
        len --;
      } else {
#line 2531
        val = ((((int )*type1 << 24) | ((int )*(type1 + 1) << 16)) | ((int )*(type1 + 2) << 8)) | (int )*(type1 + 3);
#line 2532
        tmp___4 = sp;
#line 2532
        sp ++;
#line 2532
        stack[tmp___4] = (double )val;
#line 2533
        type1 += 4;
#line 2534
        len -= 4;
      }
    } else
#line 2536
    if (v == 28) {
#line 2537
      tmp___5 = sp;
#line 2537
      sp ++;
#line 2537
      stack[tmp___5] = (double )((short )(((int )*(type1 + 0) << 8) | (int )*(type1 + 1)));
#line 2538
      type1 += 2;
#line 2539
      len -= 2;
    } else
#line 2542
    if (v == 12) {
#line 2543
      tmp___6 = type1;
#line 2543
      type1 ++;
#line 2543
      v = (int )*tmp___6;
#line 2544
      len --;
      {
#line 2546
      if (v == 0) {
#line 2546
        goto case_0;
      }
#line 2549
      if (v == 1) {
#line 2549
        goto case_1;
      }
#line 2556
      if (v == 2) {
#line 2556
        goto case_2;
      }
#line 2560
      if (v == 6) {
#line 2560
        goto seac;
      }
#line 2578
      if (v == 7) {
#line 2578
        goto case_7;
      }
#line 2586
      if (v == 26) {
#line 2586
        goto case_26;
      }
#line 2586
      if (v == 14) {
#line 2586
        goto case_26;
      }
#line 2586
      if (v == 9) {
#line 2586
        goto case_26;
      }
#line 2586
      if (v == 5) {
#line 2586
        goto case_26;
      }
#line 2595
      if (v == 24) {
#line 2595
        goto case_24;
      }
#line 2595
      if (v == 15) {
#line 2595
        goto case_24;
      }
#line 2595
      if (v == 12) {
#line 2595
        goto case_24;
      }
#line 2595
      if (v == 11) {
#line 2595
        goto case_24;
      }
#line 2595
      if (v == 10) {
#line 2595
        goto case_24;
      }
#line 2595
      if (v == 4) {
#line 2595
        goto case_24;
      }
#line 2595
      if (v == 3) {
#line 2595
        goto case_24;
      }
#line 2622
      if (v == 22) {
#line 2622
        goto case_22;
      }
#line 2630
      if (v == 23) {
#line 2630
        goto case_23;
      }
#line 2639
      if (v == 16) {
#line 2639
        goto case_16;
      }
#line 2674
      if (v == 20) {
#line 2674
        goto case_20;
      }
#line 2682
      if (v == 21) {
#line 2682
        goto case_21;
      }
#line 2688
      if (v == 17) {
#line 2688
        goto case_17;
      }
#line 2698
      if (v == 18) {
#line 2698
        goto case_18;
      }
#line 2701
      if (v == 27) {
#line 2701
        goto case_27;
      }
#line 2707
      if (v == 28) {
#line 2707
        goto case_28;
      }
#line 2713
      if (v == 29) {
#line 2713
        goto case_29;
      }
#line 2724
      if (v == 30) {
#line 2724
        goto case_30;
      }
#line 2742
      if (v == 33) {
#line 2742
        goto case_33;
      }
#line 2757
      if (v == 37) {
#line 2757
        goto case_37;
      }
#line 2757
      if (v == 36) {
#line 2757
        goto case_37;
      }
#line 2757
      if (v == 35) {
#line 2757
        goto case_37;
      }
#line 2757
      if (v == 34) {
#line 2757
        goto case_37;
      }
#line 2760
      goto switch_default;
      case_0: /* CIL Label */ 
#line 2547
      sp = 0;
#line 2548
      goto switch_break;
      case_1: /* CIL Label */ 
#line 2550
      if (sp < 6) {
        {
#line 2550
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on vstem3 in %s\n",
                name);
        }
      }
#line 2554
      sp = 0;
#line 2555
      goto switch_break;
      case_2: /* CIL Label */ 
#line 2557
      if (sp < 6) {
        {
#line 2557
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on hstem3 in %s\n",
                name);
        }
      }
#line 2558
      sp = 0;
#line 2559
      goto switch_break;
      seac: 
      case_6: /* CIL Label */ 
#line 2562
      if (sp < 5) {
        {
#line 2562
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on seac in %s\n",
                name);
        }
      }
      {
#line 2564
      bb1 = FindAdobeGlyph(psfont, (int )stack[3]);
#line 2565
      bb2 = FindAdobeGlyph(psfont, (int )stack[4]);
#line 2566
      offx = (int )(stack[1] - (stack[0] - (double )lsidebearing));
#line 2567
      offy = (int )stack[2];
      }
#line 2568
      if ((unsigned long )bb1 == (unsigned long )((void *)0)) {
#line 2569
        bb->isref = 1;
      } else
#line 2568
      if ((unsigned long )bb2 == (unsigned long )((void *)0)) {
#line 2569
        bb->isref = 1;
      } else {
#line 2571
        if (bb1->top > bb2->top + offy) {
#line 2571
          bb->top = bb1->top;
        } else {
#line 2571
          bb->top = bb2->top + offy;
        }
#line 2572
        if (bb1->bottom < bb2->bottom + offy) {
#line 2572
          bb->bottom = bb1->bottom;
        } else {
#line 2572
          bb->bottom = bb2->bottom + offy;
        }
#line 2573
        if (bb1->right > bb2->right + offx) {
#line 2573
          bb->right = bb1->right;
        } else {
#line 2573
          bb->right = bb2->right + offx;
        }
#line 2574
        if (bb1->left < bb2->left + offx) {
#line 2574
          bb->left = bb1->left;
        } else {
#line 2574
          bb->left = bb2->left + offx;
        }
      }
#line 2576
      sp = 0;
#line 2577
      goto switch_break;
      case_7: /* CIL Label */ 
#line 2579
      if (sp < 4) {
        {
#line 2579
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on sbw in %s\n",
                name);
        }
      }
#line 2580
      lsidebearing = (int )stack[0];
#line 2582
      bb->hadvance = (int )stack[2];
#line 2584
      sp = 0;
#line 2585
      goto switch_break;
      case_26: /* CIL Label */ 
      case_14: /* CIL Label */ 
      case_9: /* CIL Label */ 
      case_5: /* CIL Label */ 
#line 2587
      if (sp < 1) {
        {
#line 2587
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on unary operator in %s\n",
                name);
        }
      }
      {
#line 2589
      if (v == 5) {
#line 2589
        goto case_5___0;
      }
#line 2590
      if (v == 9) {
#line 2590
        goto case_9___0;
      }
#line 2591
      if (v == 14) {
#line 2591
        goto case_14___0;
      }
#line 2592
      if (v == 26) {
#line 2592
        goto case_26___0;
      }
#line 2588
      goto switch_break___0;
      case_5___0: /* CIL Label */ 
#line 2589
      stack[sp - 1] = (double )(stack[sp - 1] == (double )0);
#line 2589
      goto switch_break___0;
      case_9___0: /* CIL Label */ 
#line 2590
      if (stack[sp - 1] < (double )0) {
#line 2590
        stack[sp - 1] = - stack[sp - 1];
      }
#line 2590
      goto switch_break___0;
      case_14___0: /* CIL Label */ 
#line 2591
      stack[sp - 1] = - stack[sp - 1];
#line 2591
      goto switch_break___0;
      case_26___0: /* CIL Label */ 
      {
#line 2592
      stack[sp - 1] = sqrt(stack[sp - 1]);
      }
#line 2592
      goto switch_break___0;
      switch_break___0: /* CIL Label */ ;
      }
#line 2594
      goto switch_break;
      case_24: /* CIL Label */ 
      case_15: /* CIL Label */ 
      case_12: /* CIL Label */ 
      case_11: /* CIL Label */ 
      case_10: /* CIL Label */ 
      case_4: /* CIL Label */ 
      case_3: /* CIL Label */ 
#line 2596
      if (sp < 2) {
        {
#line 2596
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on binary operator in %s\n",
                name);
        }
      } else {
        {
#line 2598
        if (v == 3) {
#line 2598
          goto case_3___0;
        }
#line 2601
        if (v == 4) {
#line 2601
          goto case_4___0;
        }
#line 2604
        if (v == 10) {
#line 2604
          goto case_10___0;
        }
#line 2607
        if (v == 11) {
#line 2607
          goto case_11___0;
        }
#line 2610
        if (v == 12) {
#line 2610
          goto case_12___0;
        }
#line 2613
        if (v == 24) {
#line 2613
          goto case_24___0;
        }
#line 2616
        if (v == 15) {
#line 2616
          goto case_15___0;
        }
#line 2597
        goto switch_break___1;
        case_3___0: /* CIL Label */ 
#line 2599
        if (stack[sp - 1] != (double )0) {
#line 2599
          if (stack[sp - 2] != (double )0) {
#line 2599
            tmp___7 = 1;
          } else {
#line 2599
            tmp___7 = 0;
          }
        } else {
#line 2599
          tmp___7 = 0;
        }
#line 2599
        stack[sp - 2] = (double )tmp___7;
#line 2600
        goto switch_break___1;
        case_4___0: /* CIL Label */ 
#line 2602
        if (stack[sp - 1] != (double )0) {
#line 2602
          tmp___8 = 1;
        } else
#line 2602
        if (stack[sp - 2] != (double )0) {
#line 2602
          tmp___8 = 1;
        } else {
#line 2602
          tmp___8 = 0;
        }
#line 2602
        stack[sp - 2] = (double )tmp___8;
#line 2603
        goto switch_break___1;
        case_10___0: /* CIL Label */ 
#line 2605
        stack[sp - 2] += stack[sp - 1];
#line 2606
        goto switch_break___1;
        case_11___0: /* CIL Label */ 
#line 2608
        stack[sp - 2] -= stack[sp - 1];
#line 2609
        goto switch_break___1;
        case_12___0: /* CIL Label */ 
#line 2611
        stack[sp - 2] /= stack[sp - 1];
#line 2612
        goto switch_break___1;
        case_24___0: /* CIL Label */ 
#line 2614
        stack[sp - 2] *= stack[sp - 1];
#line 2615
        goto switch_break___1;
        case_15___0: /* CIL Label */ 
#line 2617
        stack[sp - 2] = (double )(stack[sp - 1] == stack[sp - 2]);
#line 2618
        goto switch_break___1;
        switch_break___1: /* CIL Label */ ;
        }
      }
#line 2620
      sp --;
#line 2621
      goto switch_break;
      case_22: /* CIL Label */ 
#line 2623
      if (sp < 4) {
        {
#line 2623
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on ifelse in %s\n",
                name);
        }
      } else {
#line 2625
        if (stack[sp - 2] > stack[sp - 1]) {
#line 2626
          stack[sp - 4] = stack[sp - 3];
        }
#line 2627
        sp -= 3;
      }
#line 2629
      goto switch_break;
      case_23: /* CIL Label */ 
      {
#line 2634
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 2635
        tmp___9 = rand();
#line 2635
        stack[sp] = (double )(tmp___9 / 2147483646);
        }
#line 2634
        if (! (stack[sp] == (double )0)) {
#line 2634
          if (! (stack[sp] > (double )1)) {
#line 2634
            goto while_break___0;
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
#line 2637
      sp ++;
#line 2638
      goto switch_break;
      case_16: /* CIL Label */ 
#line 2643
      if (sp < 2) {
        {
#line 2644
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on callothersubr in %s\n",
                name);
#line 2645
        sp = 0;
        }
      } else
#line 2643
      if ((double )sp < (double )2 + stack[sp - 2]) {
        {
#line 2644
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on callothersubr in %s\n",
                name);
#line 2645
        sp = 0;
        }
      } else {
#line 2647
        tot___0 = (int )stack[sp - 2];
#line 2648
        popsp = 0;
#line 2649
        k = sp - 3;
        {
#line 2649
        while (1) {
          while_continue___1: /* CIL Label */ ;
#line 2649
          if (! (k >= (sp - 2) - tot___0)) {
#line 2649
            goto while_break___1;
          }
#line 2650
          tmp___10 = popsp;
#line 2650
          popsp ++;
#line 2650
          pops[tmp___10] = stack[k];
#line 2649
          k --;
        }
        while_break___1: /* CIL Label */ ;
        }
        {
#line 2657
        if ((int )stack[sp - 1] == 3) {
#line 2657
          goto case_3___1;
        }
#line 2663
        if ((int )stack[sp - 1] == 1) {
#line 2663
          goto case_1___0;
        }
#line 2665
        if ((int )stack[sp - 1] == 2) {
#line 2665
          goto case_2___0;
        }
#line 2668
        if ((int )stack[sp - 1] == 0) {
#line 2668
          goto case_0___0;
        }
#line 2656
        goto switch_break___2;
        case_3___1: /* CIL Label */ 
#line 2661
        pops[popsp - 1] = (double )3;
#line 2662
        goto switch_break___2;
        case_1___0: /* CIL Label */ ;
#line 2664
        goto switch_break___2;
        case_2___0: /* CIL Label */ ;
#line 2667
        goto switch_break___2;
        case_0___0: /* CIL Label */ 
#line 2669
        goto switch_break___2;
        switch_break___2: /* CIL Label */ ;
        }
#line 2671
        sp = k + 1;
      }
#line 2673
      goto switch_break;
      case_20: /* CIL Label */ 
#line 2675
      if (sp < 2) {
        {
#line 2675
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too few items on stack for put in %s\n",
                name);
        }
      } else
#line 2676
      if (stack[sp - 1] < (double )0) {
        {
#line 2676
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reference to transient memory out of bounds in put in %s\n",
                name);
        }
      } else
#line 2676
      if (stack[sp - 1] >= (double )32) {
        {
#line 2676
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reference to transient memory out of bounds in put in %s\n",
                name);
        }
      } else {
#line 2678
        transient[(int )stack[sp - 1]] = stack[sp - 2];
#line 2679
        sp -= 2;
      }
#line 2681
      goto switch_break;
      case_21: /* CIL Label */ 
#line 2683
      if (sp < 1) {
        {
#line 2683
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too few items on stack for get in %s\n",
                name);
        }
      } else
#line 2684
      if (stack[sp - 1] < (double )0) {
        {
#line 2684
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reference to transient memory out of bounds in put in %s\n",
                name);
        }
      } else
#line 2684
      if (stack[sp - 1] >= (double )32) {
        {
#line 2684
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Reference to transient memory out of bounds in put in %s\n",
                name);
        }
      } else {
#line 2686
        stack[sp - 1] = transient[(int )stack[sp - 1]];
      }
#line 2687
      goto switch_break;
      case_17: /* CIL Label */ 
#line 2693
      if (popsp <= 0) {
        {
#line 2694
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Pop stack underflow on pop in %s\n",
                name);
        }
      } else {
#line 2696
        tmp___11 = sp;
#line 2696
        sp ++;
#line 2696
        popsp --;
#line 2696
        stack[tmp___11] = pops[popsp];
      }
#line 2697
      goto switch_break;
      case_18: /* CIL Label */ 
#line 2699
      if (sp > 0) {
#line 2699
        sp --;
      }
#line 2700
      goto switch_break;
      case_27: /* CIL Label */ 
#line 2702
      if (sp >= 1) {
#line 2703
        stack[sp] = stack[sp - 1];
#line 2704
        sp ++;
      }
#line 2706
      goto switch_break;
      case_28: /* CIL Label */ 
#line 2708
      if (sp >= 2) {
#line 2709
        temp = stack[sp - 1];
#line 2710
        stack[sp - 1] = stack[sp - 2];
#line 2710
        stack[sp - 2] = temp;
      }
#line 2712
      goto switch_break;
      case_29: /* CIL Label */ 
#line 2714
      if (sp >= 1) {
#line 2715
        sp --;
#line 2715
        index___0 = (int )stack[sp];
#line 2716
        if (index___0 < 0) {
          {
#line 2717
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index out of range in %s\n",
                  name);
          }
        } else
#line 2716
        if (sp < index___0 + 1) {
          {
#line 2717
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Index out of range in %s\n",
                  name);
          }
        } else {
#line 2719
          stack[sp] = stack[(sp - index___0) - 1];
#line 2720
          sp ++;
        }
      }
#line 2723
      goto switch_break;
      case_30: /* CIL Label */ 
#line 2725
      if (sp >= 2) {
#line 2726
        j = (int )stack[sp - 1];
#line 2726
        N = (int )stack[sp - 2];
#line 2727
        if (N > sp) {
          {
#line 2728
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"roll out of range in %s\n",
                  name);
          }
        } else
#line 2727
        if (j >= N) {
          {
#line 2728
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"roll out of range in %s\n",
                  name);
          }
        } else
#line 2727
        if (j < 0) {
          {
#line 2728
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"roll out of range in %s\n",
                  name);
          }
        } else
#line 2727
        if (N < 0) {
          {
#line 2728
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"roll out of range in %s\n",
                  name);
          }
        } else
#line 2729
        if (! (j == 0)) {
#line 2729
          if (! (N == 0)) {
            {
#line 2732
            tmp___12 = malloc((unsigned long )N * sizeof(double ));
#line 2732
            temp___0 = (double *)tmp___12;
#line 2734
            i = 0;
            }
            {
#line 2734
            while (1) {
              while_continue___2: /* CIL Label */ ;
#line 2734
              if (! (i < N)) {
#line 2734
                goto while_break___2;
              }
#line 2735
              *(temp___0 + i) = stack[(sp - N) + i];
#line 2734
              i ++;
            }
            while_break___2: /* CIL Label */ ;
            }
#line 2736
            i = 0;
            {
#line 2736
            while (1) {
              while_continue___3: /* CIL Label */ ;
#line 2736
              if (! (i < N)) {
#line 2736
                goto while_break___3;
              }
#line 2737
              stack[(sp - N) + i] = *(temp___0 + (i + j) % N);
#line 2736
              i ++;
            }
            while_break___3: /* CIL Label */ ;
            }
            {
#line 2738
            free((void *)temp___0);
            }
          }
        }
      }
#line 2741
      goto switch_break;
      case_33: /* CIL Label */ 
#line 2743
      if (sp < 2) {
        {
#line 2743
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on setcurrentpoint in %s\n",
                name);
        }
      } else {
#line 2745
        current.x = stack[0];
#line 2746
        current.y = stack[1];
#line 2747
        if (current.y > (double )bb->top) {
#line 2747
          bb->top = (int )current.y;
        }
#line 2748
        if (current.y < (double )bb->bottom) {
#line 2748
          bb->bottom = (int )current.y;
        }
#line 2749
        if (current.x > (double )bb->right) {
#line 2749
          bb->right = (int )current.x;
        }
#line 2750
        if (current.x < (double )bb->left) {
#line 2750
          bb->left = (int )current.x;
        }
      }
#line 2752
      sp = 0;
#line 2753
      goto switch_break;
      case_37: /* CIL Label */ 
      case_36: /* CIL Label */ 
      case_35: /* CIL Label */ 
      case_34: /* CIL Label */ 
#line 2758
      sp = 0;
#line 2759
      goto switch_break;
      switch_default: /* CIL Label */ 
      {
#line 2761
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Uninterpreted opcode 12,%d in %s\n",
              v, name);
      }
#line 2762
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    } else {
      {
#line 2766
      if (v == 18) {
#line 2766
        goto case_18___0;
      }
#line 2766
      if (v == 1) {
#line 2766
        goto case_18___0;
      }
#line 2780
      if (v == 20) {
#line 2780
        goto case_20___0;
      }
#line 2780
      if (v == 19) {
#line 2780
        goto case_20___0;
      }
#line 2784
      if (v == 23) {
#line 2784
        goto case_23___0;
      }
#line 2784
      if (v == 3) {
#line 2784
        goto case_23___0;
      }
#line 2786
      if (v == 14) {
#line 2786
        goto case_14___1;
      }
#line 2808
      if (v == 13) {
#line 2808
        goto case_13;
      }
#line 2815
      if (v == 9) {
#line 2815
        goto case_9___1;
      }
#line 2823
      if (v == 7) {
#line 2823
        goto case_7___0;
      }
#line 2823
      if (v == 6) {
#line 2823
        goto case_7___0;
      }
#line 2823
      if (v == 5) {
#line 2823
        goto case_7___0;
      }
#line 2823
      if (v == 4) {
#line 2823
        goto case_7___0;
      }
#line 2823
      if (v == 22) {
#line 2823
        goto case_7___0;
      }
#line 2823
      if (v == 21) {
#line 2823
        goto case_7___0;
      }
#line 2854
      if (v == 25) {
#line 2854
        goto case_25;
      }
#line 2868
      if (v == 26) {
#line 2868
        goto case_26___1;
      }
#line 2868
      if (v == 27) {
#line 2868
        goto case_26___1;
      }
#line 2868
      if (v == 30) {
#line 2868
        goto case_26___1;
      }
#line 2868
      if (v == 31) {
#line 2868
        goto case_26___1;
      }
#line 2868
      if (v == 8) {
#line 2868
        goto case_26___1;
      }
#line 2868
      if (v == 24) {
#line 2868
        goto case_26___1;
      }
#line 2958
      if (v == 10) {
#line 2958
        goto case_10___1;
      }
#line 2958
      if (v == 29) {
#line 2958
        goto case_10___1;
      }
#line 2981
      if (v == 11) {
#line 2981
        goto case_11___1;
      }
#line 2990
      goto switch_default___0;
      case_18___0: /* CIL Label */ 
      case_1___1: /* CIL Label */ 
#line 2767
      base = 0;
#line 2768
      if (sp & 1) {
#line 2769
        bb->hadvance = (int )stack[0];
#line 2770
        base = 1;
      }
#line 2772
      if (sp - base < 2) {
        {
#line 2773
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on hstem in %s\n",
                name);
        }
      }
#line 2777
      sp = 0;
#line 2778
      goto switch_break___3;
      case_20___0: /* CIL Label */ 
      case_19: /* CIL Label */ 
#line 2782
      base = 0;
      case_23___0: /* CIL Label */ 
      case_3___2: /* CIL Label */ 
#line 2785
      goto switch_break___3;
      case_14___1: /* CIL Label */ 
#line 2788
      pcsp = 0;
#line 2789
      if (sp == 4) {
#line 2793
        stack[4] = stack[3];
#line 2793
        stack[3] = stack[2];
#line 2793
        stack[2] = stack[1];
#line 2793
        stack[1] = stack[0];
#line 2794
        stack[0] = (double )0;
#line 2795
        sp = 5;
#line 2796
        goto seac;
      }
#line 2806
      goto done;
#line 2807
      goto switch_break___3;
      case_13: /* CIL Label */ 
#line 2809
      if (sp < 2) {
        {
#line 2809
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on hsbw in %s\n",
                name);
        }
      }
#line 2810
      lsidebearing = (int )stack[0];
#line 2811
      current.x = stack[0];
#line 2812
      bb->hadvance = (int )stack[1];
#line 2813
      sp = 0;
#line 2814
      goto switch_break___3;
      case_9___1: /* CIL Label */ 
#line 2816
      sp = 0;
#line 2817
      goto switch_break___3;
      case_7___0: /* CIL Label */ 
      case_6___0: /* CIL Label */ 
      case_5___1: /* CIL Label */ 
      case_4___1: /* CIL Label */ 
      case_22___0: /* CIL Label */ 
      case_21___0: /* CIL Label */ 
#line 2824
      polarity = 0;
#line 2825
      base = 0;
      {
#line 2826
      while (1) {
        while_continue___4: /* CIL Label */ ;
#line 2826
        if (! (base < sp)) {
#line 2826
          goto while_break___4;
        }
#line 2827
        dy = (double )0;
#line 2827
        dx = dy;
#line 2828
        if (v == 5) {
#line 2828
          goto _L___2;
        } else
#line 2828
        if (v == 21) {
          _L___2: /* CIL Label */ 
#line 2829
          if (sp < 2) {
            {
#line 2829
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on rlineto/rmoveto in %s\n",
                    name);
            }
          }
#line 2830
          tmp___13 = base;
#line 2830
          base ++;
#line 2830
          dx = stack[tmp___13];
#line 2831
          tmp___14 = base;
#line 2831
          base ++;
#line 2831
          dy = stack[tmp___14];
        } else
#line 2832
        if (v == 6) {
#line 2832
          if (! (polarity & 1)) {
#line 2832
            goto _L;
          } else {
#line 2832
            goto _L___1;
          }
        } else
        _L___1: /* CIL Label */ 
#line 2832
        if (v == 7) {
#line 2832
          if (polarity & 1) {
#line 2832
            goto _L;
          } else {
#line 2832
            goto _L___0;
          }
        } else
        _L___0: /* CIL Label */ 
#line 2832
        if (v == 22) {
          _L: /* CIL Label */ 
#line 2833
          if (sp < 1) {
            {
#line 2833
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on hlineto/hmoveto in %s\n",
                    name);
            }
          }
#line 2834
          tmp___15 = base;
#line 2834
          base ++;
#line 2834
          dx = stack[tmp___15];
        } else {
#line 2836
          if (sp < 1) {
            {
#line 2836
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on vlineto/vmoveto in %s\n",
                    name);
            }
          }
#line 2837
          tmp___16 = base;
#line 2837
          base ++;
#line 2837
          dy = stack[tmp___16];
        }
#line 2839
        polarity ++;
#line 2840
        current.x += dx;
#line 2840
        current.y += dy;
#line 2841
        if (first) {
#line 2842
          tmp___17 = (int )current.y;
#line 2842
          bb->bottom = tmp___17;
#line 2842
          bb->top = tmp___17;
#line 2843
          tmp___18 = (int )current.x;
#line 2843
          bb->right = tmp___18;
#line 2843
          bb->left = tmp___18;
#line 2844
          first = 0;
        } else {
#line 2846
          if (current.y > (double )bb->top) {
#line 2846
            bb->top = (int )current.y;
          }
#line 2847
          if (current.y < (double )bb->bottom) {
#line 2847
            bb->bottom = (int )current.y;
          }
#line 2848
          if (current.x > (double )bb->right) {
#line 2848
            bb->right = (int )current.x;
          }
#line 2849
          if (current.x < (double )bb->left) {
#line 2849
            bb->left = (int )current.x;
          }
        }
      }
      while_break___4: /* CIL Label */ ;
      }
#line 2852
      sp = 0;
#line 2853
      goto switch_break___3;
      case_25: /* CIL Label */ 
#line 2855
      base = 0;
      {
#line 2856
      while (1) {
        while_continue___5: /* CIL Label */ ;
#line 2856
        if (! (sp > base + 6)) {
#line 2856
          goto while_break___5;
        }
#line 2857
        tmp___19 = base;
#line 2857
        base ++;
#line 2857
        current.x += stack[tmp___19];
#line 2857
        tmp___20 = base;
#line 2857
        base ++;
#line 2857
        current.y += stack[tmp___20];
#line 2858
        if (current.y > (double )bb->top) {
#line 2858
          bb->top = (int )current.y;
        }
#line 2859
        if (current.y < (double )bb->bottom) {
#line 2859
          bb->bottom = (int )current.y;
        }
#line 2860
        if (current.x > (double )bb->right) {
#line 2860
          bb->right = (int )current.x;
        }
#line 2861
        if (current.x < (double )bb->left) {
#line 2861
          bb->left = (int )current.x;
        }
      }
      while_break___5: /* CIL Label */ ;
      }
      case_26___1: /* CIL Label */ 
      case_27___0: /* CIL Label */ 
      case_30___0: /* CIL Label */ 
      case_31: /* CIL Label */ 
      case_8: /* CIL Label */ 
      case_24___1: /* CIL Label */ 
#line 2869
      polarity = 0;
      {
#line 2870
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 2870
        if (! (sp > base + 2)) {
#line 2870
          goto while_break___6;
        }
#line 2871
        dy3 = (double )0;
#line 2871
        dx3 = dy3;
#line 2871
        dy2 = dx3;
#line 2871
        dx2 = dy2;
#line 2871
        dy = dx2;
#line 2871
        dx = dy;
#line 2872
        if (v == 8) {
#line 2872
          goto _L___6;
        } else
#line 2872
        if (v == 25) {
#line 2872
          goto _L___6;
        } else
#line 2872
        if (v == 24) {
          _L___6: /* CIL Label */ 
#line 2873
          if (sp < 6 + base) {
            {
#line 2874
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on rrcurveto in %s\n",
                    name);
#line 2875
            base = sp;
            }
          } else {
#line 2877
            tmp___21 = base;
#line 2877
            base ++;
#line 2877
            dx = stack[tmp___21];
#line 2878
            tmp___22 = base;
#line 2878
            base ++;
#line 2878
            dy = stack[tmp___22];
#line 2879
            tmp___23 = base;
#line 2879
            base ++;
#line 2879
            dx2 = stack[tmp___23];
#line 2880
            tmp___24 = base;
#line 2880
            base ++;
#line 2880
            dy2 = stack[tmp___24];
#line 2881
            tmp___25 = base;
#line 2881
            base ++;
#line 2881
            dx3 = stack[tmp___25];
#line 2882
            tmp___26 = base;
#line 2882
            base ++;
#line 2882
            dy3 = stack[tmp___26];
          }
        } else
#line 2884
        if (v == 27) {
#line 2885
          if (sp < 4 + base) {
            {
#line 2886
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on hhcurveto in %s\n",
                    name);
#line 2887
            base = sp;
            }
          } else {
#line 2889
            if ((sp - base) & 1) {
#line 2889
              tmp___27 = base;
#line 2889
              base ++;
#line 2889
              dy = stack[tmp___27];
            }
#line 2890
            tmp___28 = base;
#line 2890
            base ++;
#line 2890
            dx = stack[tmp___28];
#line 2891
            tmp___29 = base;
#line 2891
            base ++;
#line 2891
            dx2 = stack[tmp___29];
#line 2892
            tmp___30 = base;
#line 2892
            base ++;
#line 2892
            dy2 = stack[tmp___30];
#line 2893
            tmp___31 = base;
#line 2893
            base ++;
#line 2893
            dx3 = stack[tmp___31];
          }
        } else
#line 2895
        if (v == 26) {
#line 2896
          if (sp < 4 + base) {
            {
#line 2897
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on hhcurveto in %s\n",
                    name);
#line 2898
            base = sp;
            }
          } else {
#line 2900
            if ((sp - base) & 1) {
#line 2900
              tmp___32 = base;
#line 2900
              base ++;
#line 2900
              dx = stack[tmp___32];
            }
#line 2901
            tmp___33 = base;
#line 2901
            base ++;
#line 2901
            dy = stack[tmp___33];
#line 2902
            tmp___34 = base;
#line 2902
            base ++;
#line 2902
            dx2 = stack[tmp___34];
#line 2903
            tmp___35 = base;
#line 2903
            base ++;
#line 2903
            dy2 = stack[tmp___35];
#line 2904
            tmp___36 = base;
#line 2904
            base ++;
#line 2904
            dy3 = stack[tmp___36];
          }
        } else
#line 2906
        if (v == 31) {
#line 2906
          if (! (polarity & 1)) {
#line 2906
            goto _L___3;
          } else {
#line 2906
            goto _L___5;
          }
        } else
        _L___5: /* CIL Label */ 
#line 2906
        if (v == 30) {
#line 2906
          if (polarity & 1) {
            _L___3: /* CIL Label */ 
#line 2907
            if (sp < 4 + base) {
              {
#line 2908
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on hvcurveto in %s\n",
                      name);
#line 2909
              base = sp;
              }
            } else {
#line 2911
              tmp___37 = base;
#line 2911
              base ++;
#line 2911
              dx = stack[tmp___37];
#line 2912
              tmp___38 = base;
#line 2912
              base ++;
#line 2912
              dx2 = stack[tmp___38];
#line 2913
              tmp___39 = base;
#line 2913
              base ++;
#line 2913
              dy2 = stack[tmp___39];
#line 2914
              tmp___40 = base;
#line 2914
              base ++;
#line 2914
              dy3 = stack[tmp___40];
#line 2915
              if (sp == base + 1) {
#line 2916
                tmp___41 = base;
#line 2916
                base ++;
#line 2916
                dx3 = stack[tmp___41];
              }
            }
          } else {
#line 2906
            goto _L___4;
          }
        } else
        _L___4: /* CIL Label */ 
#line 2919
        if (sp < 4 + base) {
          {
#line 2920
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on vhcurveto in %s\n",
                  name);
#line 2921
          base = sp;
          }
        } else {
#line 2923
          tmp___42 = base;
#line 2923
          base ++;
#line 2923
          dy = stack[tmp___42];
#line 2924
          tmp___43 = base;
#line 2924
          base ++;
#line 2924
          dx2 = stack[tmp___43];
#line 2925
          tmp___44 = base;
#line 2925
          base ++;
#line 2925
          dy2 = stack[tmp___44];
#line 2926
          tmp___45 = base;
#line 2926
          base ++;
#line 2926
          dx3 = stack[tmp___45];
#line 2927
          if (sp == base + 1) {
#line 2928
            tmp___46 = base;
#line 2928
            base ++;
#line 2928
            dy3 = stack[tmp___46];
          }
        }
#line 2931
        polarity ++;
#line 2932
        current.x += dx;
#line 2932
        current.y += dy;
#line 2933
        if (current.y > (double )bb->top) {
#line 2933
          bb->top = (int )current.y;
        }
#line 2934
        if (current.y < (double )bb->bottom) {
#line 2934
          bb->bottom = (int )current.y;
        }
#line 2935
        if (current.x > (double )bb->right) {
#line 2935
          bb->right = (int )current.x;
        }
#line 2936
        if (current.x < (double )bb->left) {
#line 2936
          bb->left = (int )current.x;
        }
#line 2937
        current.x += dx2;
#line 2937
        current.y += dy2;
#line 2938
        if (current.y > (double )bb->top) {
#line 2938
          bb->top = (int )current.y;
        }
#line 2939
        if (current.y < (double )bb->bottom) {
#line 2939
          bb->bottom = (int )current.y;
        }
#line 2940
        if (current.x > (double )bb->right) {
#line 2940
          bb->right = (int )current.x;
        }
#line 2941
        if (current.x < (double )bb->left) {
#line 2941
          bb->left = (int )current.x;
        }
#line 2942
        current.x += dx3;
#line 2942
        current.y += dy3;
#line 2943
        if (current.y > (double )bb->top) {
#line 2943
          bb->top = (int )current.y;
        }
#line 2944
        if (current.y < (double )bb->bottom) {
#line 2944
          bb->bottom = (int )current.y;
        }
#line 2945
        if (current.x > (double )bb->right) {
#line 2945
          bb->right = (int )current.x;
        }
#line 2946
        if (current.x < (double )bb->left) {
#line 2946
          bb->left = (int )current.x;
        }
      }
      while_break___6: /* CIL Label */ ;
      }
#line 2948
      if (v == 24) {
#line 2949
        tmp___47 = base;
#line 2949
        base ++;
#line 2949
        current.x += stack[tmp___47];
#line 2949
        tmp___48 = base;
#line 2949
        base ++;
#line 2949
        current.y += stack[tmp___48];
#line 2950
        if (current.y > (double )bb->top) {
#line 2950
          bb->top = (int )current.y;
        }
#line 2951
        if (current.y < (double )bb->bottom) {
#line 2951
          bb->bottom = (int )current.y;
        }
#line 2952
        if (current.x > (double )bb->right) {
#line 2952
          bb->right = (int )current.x;
        }
#line 2953
        if (current.x < (double )bb->left) {
#line 2953
          bb->left = (int )current.x;
        }
      }
#line 2955
      sp = 0;
#line 2956
      goto switch_break___3;
      case_10___1: /* CIL Label */ 
      case_29___0: /* CIL Label */ 
#line 2960
      if (sp < 1) {
        {
#line 2961
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Stack underflow on callsubr in %s\n",
                name);
        }
#line 2962
        goto switch_break___3;
      } else
#line 2963
      if (pcsp > 10) {
        {
#line 2964
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Too many subroutine calls in %s\n",
                name);
        }
#line 2965
        goto switch_break___3;
      }
#line 2967
      s = subrs;
#line 2968
      if ((unsigned long )s == (unsigned long )((void *)0)) {
        {
#line 2970
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Subroutine number out of bounds in %s\n",
                name);
        }
      } else
#line 2968
      if (stack[sp - 1] >= (double )s->cnt) {
        {
#line 2970
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Subroutine number out of bounds in %s\n",
                name);
        }
      } else
#line 2968
      if (stack[sp - 1] < (double )0) {
        {
#line 2970
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Subroutine number out of bounds in %s\n",
                name);
        }
      } else
#line 2968
      if ((unsigned long )*(s->values + (int )stack[sp - 1]) == (unsigned long )((void *)0)) {
        {
#line 2970
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Subroutine number out of bounds in %s\n",
                name);
        }
      } else {
#line 2972
        pcstack[pcsp].type1 = type1;
#line 2973
        pcstack[pcsp].len = len;
#line 2974
        pcstack[pcsp].subnum = (int )stack[sp - 1];
#line 2975
        pcsp ++;
#line 2976
        type1 = *(s->values + (int )stack[sp - 1]);
#line 2977
        len = *(s->lens + (int )stack[sp - 1]);
      }
#line 2979
      sp --;
#line 2979
      if (sp < 0) {
#line 2979
        sp = 0;
      }
#line 2980
      goto switch_break___3;
      case_11___1: /* CIL Label */ 
#line 2983
      if (pcsp < 1) {
        {
#line 2983
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"return when not in subroutine in %s\n",
                name);
        }
      } else {
#line 2985
        pcsp --;
#line 2986
        type1 = pcstack[pcsp].type1;
#line 2987
        len = pcstack[pcsp].len;
      }
#line 2989
      goto switch_break___3;
      switch_default___0: /* CIL Label */ 
      {
#line 2991
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Uninterpreted opcode %d in %s\n",
              v, name);
      }
#line 2992
      goto switch_break___3;
      switch_break___3: /* CIL Label */ ;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  done: 
#line 2996
  if (pcsp != 0) {
    {
#line 2997
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"end of subroutine reached with no return in %s\n",
            name);
    }
  }
#line 2998
  return;
}
}
#line 3001 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/fondups.c"
void ParsePfb(FILE *pfb , PSFONT *psfont ) 
{ 
  FontDict *fd ;
  FontDict *tmp ;
  char *pt ;
  int i ;
  int j ;
  int anyrefs ;
  int attempts ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;

  {
  {
#line 3002
  tmp = _ReadPSFont(pfb);
#line 3002
  fd = tmp;
#line 3006
  memset((void *)psfont, 0, sizeof(PSFONT ));
  }
#line 3007
  if ((unsigned long )fd == (unsigned long )((void *)0)) {
#line 3008
    return;
  } else
#line 3007
  if ((unsigned long )fd->fontname == (unsigned long )((void *)0)) {
#line 3008
    return;
  }
  {
#line 3009
  psfont->glyphcnt = (fd->chars)->next;
#line 3010
  tmp___0 = calloc((size_t )psfont->glyphcnt, sizeof(struct bbglyph ));
#line 3010
  psfont->glyphs = (struct bbglyph *)tmp___0;
#line 3011
  psfont->temp = (void *)fd->chars;
#line 3012
  i = 0;
  }
  {
#line 3012
  while (1) {
    while_continue: /* CIL Label */ ;
#line 3012
    if (! (i < 256)) {
#line 3012
      goto while_break;
    }
#line 3013
    j = (fd->chars)->next - 1;
    {
#line 3013
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 3013
      if (! (j >= 0)) {
#line 3013
        goto while_break___0;
      }
      {
#line 3014
      tmp___1 = strcmp((char const   *)fd->encoding[i], (char const   *)*((fd->chars)->keys + j));
      }
#line 3014
      if (tmp___1 == 0) {
#line 3015
        goto while_break___0;
      }
#line 3013
      j --;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 3016
    if (j == -1) {
#line 3017
      j = (fd->chars)->next - 1;
      {
#line 3017
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 3017
        if (! (j > 0)) {
#line 3017
          goto while_break___1;
        }
        {
#line 3018
        tmp___2 = strcmp(".notdef", (char const   *)*((fd->chars)->keys + j));
        }
#line 3018
        if (tmp___2 == 0) {
#line 3019
          goto while_break___1;
        }
#line 3017
        j --;
      }
      while_break___1: /* CIL Label */ ;
      }
    }
#line 3020
    psfont->encoding[i] = (short )j;
#line 3012
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 3022
  psfont->fontname = strdup((char const   *)fd->fontname);
  }
#line 3023
  if ((unsigned long )fd->fontinfo != (unsigned long )((void *)0)) {
    {
#line 3024
    psfont->familyname = strdup((char const   *)(fd->fontinfo)->familyname);
#line 3025
    psfont->fullname = strdup((char const   *)(fd->fontinfo)->fullname);
#line 3026
    psfont->weight = strdup((char const   *)(fd->fontinfo)->weight);
#line 3027
    psfont->notice = strdup((char const   *)(fd->fontinfo)->notice);
#line 3028
    psfont->version = strdup((char const   *)(fd->fontinfo)->version);
#line 3029
    psfont->italicangle = (fd->fontinfo)->italicangle;
    }
  } else {
    {
#line 3031
    psfont->familyname = strdup((char const   *)fd->fontname);
#line 3032
    pt = strchr((char const   *)psfont->familyname, '-');
    }
#line 3032
    if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 3033
      *pt = (char )'\000';
    }
    {
#line 3034
    psfont->fullname = strdup((char const   *)fd->fontname);
#line 3035
    psfont->weight = strdup("Regular");
    }
  }
#line 3037
  psfont->isadobestd = fd->isadobestd;
#line 3038
  psfont->em = (double )1000;
#line 3039
  if (fd->fontmatrix[0] != (double )0) {
#line 3040
    psfont->em = 1.0 / fd->fontmatrix[0];
  }
  {
#line 3041
  memcpy((void */* __restrict  */)(psfont->fbb), (void const   */* __restrict  */)(fd->fontbb),
         sizeof(psfont->fbb));
#line 3043
  anyrefs = 1;
#line 3044
  i = 0;
  }
  {
#line 3044
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 3044
    if (! (i < psfont->glyphcnt)) {
#line 3044
      goto while_break___2;
    }
#line 3045
    (psfont->glyphs + i)->isref = 1;
#line 3044
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 3046
  attempts = 0;
  {
#line 3047
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 3047
    if (anyrefs) {
#line 3047
      if (! (attempts < psfont->glyphcnt)) {
#line 3047
        goto while_break___3;
      }
    } else {
#line 3047
      goto while_break___3;
    }
#line 3048
    anyrefs = 0;
#line 3049
    i = 0;
    {
#line 3049
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 3049
      if (! (i < psfont->glyphcnt)) {
#line 3049
        goto while_break___4;
      }
#line 3049
      if ((psfont->glyphs + i)->isref) {
        {
#line 3050
        (psfont->glyphs + i)->isref = 0;
#line 3051
        FindBB(psfont, psfont->glyphs + i, *((fd->chars)->values + i), *((fd->chars)->lens + i),
               (fd->private)->subrs, *((fd->chars)->keys + i));
        }
#line 3053
        if ((psfont->glyphs + i)->isref) {
#line 3054
          anyrefs = 1;
        } else {
          {
#line 3056
          (psfont->glyphs + i)->glyphname = strdup((char const   *)*((fd->chars)->keys + i));
          }
        }
      }
#line 3049
      i ++;
    }
    while_break___4: /* CIL Label */ ;
    }
#line 3058
    attempts ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 3060
  i = 0;
  {
#line 3060
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 3060
    if (! (i < psfont->glyphcnt)) {
#line 3060
      goto while_break___5;
    }
#line 3060
    if (! (psfont->glyphs + i)->isref) {
      {
#line 3061
      tmp___6 = strcmp((char const   *)(psfont->glyphs + i)->glyphname, "X");
      }
#line 3061
      if (tmp___6 == 0) {
#line 3062
        psfont->ch = (psfont->glyphs + i)->top;
      } else {
        {
#line 3063
        tmp___5 = strcmp((char const   *)(psfont->glyphs + i)->glyphname, "x");
        }
#line 3063
        if (tmp___5 == 0) {
#line 3064
          psfont->xh = (psfont->glyphs + i)->top;
        } else {
          {
#line 3065
          tmp___4 = strcmp((char const   *)(psfont->glyphs + i)->glyphname, "l");
          }
#line 3065
          if (tmp___4 == 0) {
#line 3066
            psfont->as = (psfont->glyphs + i)->top;
          } else {
            {
#line 3067
            tmp___3 = strcmp((char const   *)(psfont->glyphs + i)->glyphname, "p");
            }
#line 3067
            if (tmp___3 == 0) {
#line 3068
              psfont->ds = (psfont->glyphs + i)->bottom;
            }
          }
        }
      }
    }
#line 3060
    i ++;
  }
  while_break___5: /* CIL Label */ ;
  }
#line 3070
  i = 0;
  {
#line 3070
  while (1) {
    while_continue___6: /* CIL Label */ ;
#line 3070
    if (! (i < psfont->glyphcnt)) {
#line 3070
      goto while_break___6;
    }
#line 3070
    if ((psfont->glyphs + i)->isref) {
      {
#line 3071
      (psfont->glyphcnt) --;
#line 3072
      memcpy((void */* __restrict  */)(psfont->glyphs + i), (void const   */* __restrict  */)(psfont->glyphs + (i + 1)),
             (unsigned long )(psfont->glyphcnt - i) * sizeof(struct bbglyph ));
      }
    }
#line 3070
    i ++;
  }
  while_break___6: /* CIL Label */ ;
  }
  {
#line 3074
  PSFontFree(fd);
  }
#line 3075
  return;
}
}
#line 34 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
char const   *macnames[257]  = 
#line 34 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
  {      (char const   *)((void *)0),      "Eth",      "eth",      "Lslash", 
        "lslash",      "Scaron",      "scaron",      "Yacute", 
        "yacute",      (char const   *)((void *)0),      (char const   *)((void *)0),      "Thorn", 
        "thorn",      (char const   *)((void *)0),      "Zcaron",      "zcaron", 
        (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0),      (char const   *)((void *)0), 
        (char const   *)((void *)0),      "onehalf",      "onequarter",      "onesuperior", 
        "threequarters",      "threesuperior",      "twosuperior",      "brokenbar", 
        "minus",      "multiply",      (char const   *)((void *)0),      (char const   *)((void *)0), 
        "space",      "exclam",      "quotedbl",      "numbersign", 
        "dollar",      "percent",      "ampersand",      "quotesingle", 
        "parenleft",      "parenright",      "asterisk",      "plus", 
        "comma",      "hyphen",      "period",      "slash", 
        "zero",      "one",      "two",      "three", 
        "four",      "five",      "six",      "seven", 
        "eight",      "nine",      "colon",      "semicolon", 
        "less",      "equal",      "greater",      "question", 
        "at",      "A",      "B",      "C", 
        "D",      "E",      "F",      "G", 
        "H",      "I",      "J",      "K", 
        "L",      "M",      "N",      "O", 
        "P",      "Q",      "R",      "S", 
        "T",      "U",      "V",      "W", 
        "X",      "Y",      "Z",      "bracketleft", 
        "backslash",      "bracketright",      "asciicircum",      "underscore", 
        "grave",      "a",      "b",      "c", 
        "d",      "e",      "f",      "g", 
        "h",      "i",      "j",      "k", 
        "l",      "m",      "n",      "o", 
        "p",      "q",      "r",      "s", 
        "t",      "u",      "v",      "w", 
        "x",      "y",      "z",      "braceleft", 
        "bar",      "braceright",      "asciitilde",      (char const   *)((void *)0), 
        "Adieresis",      "Aring",      "Ccedilla",      "Eacute", 
        "Ntilde",      "Odieresis",      "Udieresis",      "aacute", 
        "agrave",      "acircumflex",      "adieresis",      "atilde", 
        "aring",      "ccedilla",      "eacute",      "egrave", 
        "ecircumflex",      "edieresis",      "iacute",      "igrave", 
        "icircumflex",      "idieresis",      "ntilde",      "oacute", 
        "ograve",      "ocircumflex",      "odieresis",      "otilde", 
        "uacute",      "ugrave",      "ucircumflex",      "udieresis", 
        "dagger",      "degree",      "cent",      "sterling", 
        "section",      "bullet",      "paragraph",      "germandbls", 
        "registered",      "copyright",      "trademark",      "acute", 
        "dieresis",      "notequal",      "AE",      "Oslash", 
        "infinity",      "plusminus",      "lessequal",      "greaterequal", 
        "yen",      "mu",      "partialdiff",      "summation", 
        "product",      "pi",      "integral",      "ordfeminine", 
        "ordmasculine",      "Omega",      "ae",      "oslash", 
        "questiondown",      "exclamdown",      "logicalnot",      "radical", 
        "florin",      "approxequal",      "Delta",      "guillemotleft", 
        "guillemotright",      "ellipsis",      "nbspace",      "Agrave", 
        "Atilde",      "Otilde",      "OE",      "oe", 
        "endash",      "emdash",      "quotedblleft",      "quotedblright", 
        "quoteleft",      "quoteright",      "divide",      "lozenge", 
        "ydieresis",      "Ydieresis",      "fraction",      "currency", 
        "guilsinglleft",      "guilsinglright",      "fi",      "fl", 
        "daggerdbl",      "periodcentered",      "quotesinglbase",      "quotedblbase", 
        "perthousand",      "Acircumflex",      "Ecircumflex",      "Aacute", 
        "Edieresis",      "Egrave",      "Iacute",      "Icircumflex", 
        "Idieresis",      "Igrave",      "Oacute",      "Ocircumflex", 
        "apple",      "Ograve",      "Uacute",      "Ucircumflex", 
        "Ugrave",      "dotlessi",      "circumflex",      "tilde", 
        "macron",      "breve",      "dotaccent",      "ring", 
        "cedilla",      "hungarumlaut",      "ogonek",      "caron", 
        (char const   *)((void *)0)};
#line 69 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static unsigned char mac2iso[256]  = 
#line 69
  {      (unsigned char)0,      (unsigned char)208,      (unsigned char)240,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)221, 
        (unsigned char)253,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43, 
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63, 
        (unsigned char)64,      (unsigned char)65,      (unsigned char)66,      (unsigned char)67, 
        (unsigned char)68,      (unsigned char)69,      (unsigned char)70,      (unsigned char)71, 
        (unsigned char)72,      (unsigned char)73,      (unsigned char)74,      (unsigned char)75, 
        (unsigned char)76,      (unsigned char)77,      (unsigned char)78,      (unsigned char)79, 
        (unsigned char)80,      (unsigned char)81,      (unsigned char)82,      (unsigned char)83, 
        (unsigned char)84,      (unsigned char)85,      (unsigned char)86,      (unsigned char)87, 
        (unsigned char)88,      (unsigned char)89,      (unsigned char)90,      (unsigned char)91, 
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95, 
        (unsigned char)96,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99, 
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103, 
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107, 
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111, 
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115, 
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119, 
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)123, 
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)0, 
        (unsigned char)196,      (unsigned char)197,      (unsigned char)199,      (unsigned char)201, 
        (unsigned char)209,      (unsigned char)214,      (unsigned char)220,      (unsigned char)225, 
        (unsigned char)224,      (unsigned char)226,      (unsigned char)228,      (unsigned char)227, 
        (unsigned char)229,      (unsigned char)231,      (unsigned char)233,      (unsigned char)232, 
        (unsigned char)234,      (unsigned char)235,      (unsigned char)237,      (unsigned char)236, 
        (unsigned char)238,      (unsigned char)239,      (unsigned char)241,      (unsigned char)243, 
        (unsigned char)242,      (unsigned char)244,      (unsigned char)246,      (unsigned char)245, 
        (unsigned char)250,      (unsigned char)249,      (unsigned char)251,      (unsigned char)252, 
        (unsigned char)0,      (unsigned char)176,      (unsigned char)162,      (unsigned char)163, 
        (unsigned char)167,      (unsigned char)0,      (unsigned char)182,      (unsigned char)223, 
        (unsigned char)174,      (unsigned char)169,      (unsigned char)0,      (unsigned char)180, 
        (unsigned char)168,      (unsigned char)0,      (unsigned char)198,      (unsigned char)216, 
        (unsigned char)0,      (unsigned char)177,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)165,      (unsigned char)181,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)170, 
        (unsigned char)186,      (unsigned char)0,      (unsigned char)230,      (unsigned char)248, 
        (unsigned char)191,      (unsigned char)161,      (unsigned char)172,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)171, 
        (unsigned char)187,      (unsigned char)0,      (unsigned char)32,      (unsigned char)192, 
        (unsigned char)195,      (unsigned char)213,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)247,      (unsigned char)0, 
        (unsigned char)255,      (unsigned char)0,      (unsigned char)0,      (unsigned char)164, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)183,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)194,      (unsigned char)202,      (unsigned char)193, 
        (unsigned char)203,      (unsigned char)200,      (unsigned char)205,      (unsigned char)206, 
        (unsigned char)207,      (unsigned char)204,      (unsigned char)211,      (unsigned char)212, 
        (unsigned char)0,      (unsigned char)210,      (unsigned char)218,      (unsigned char)219, 
        (unsigned char)217,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)175,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)184,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0};
#line 88 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static unsigned char iso2mac[256]  = 
#line 88
  {      (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)32,      (unsigned char)33,      (unsigned char)34,      (unsigned char)35, 
        (unsigned char)36,      (unsigned char)37,      (unsigned char)38,      (unsigned char)39, 
        (unsigned char)40,      (unsigned char)41,      (unsigned char)42,      (unsigned char)43, 
        (unsigned char)44,      (unsigned char)45,      (unsigned char)46,      (unsigned char)47, 
        (unsigned char)48,      (unsigned char)49,      (unsigned char)50,      (unsigned char)51, 
        (unsigned char)52,      (unsigned char)53,      (unsigned char)54,      (unsigned char)55, 
        (unsigned char)56,      (unsigned char)57,      (unsigned char)58,      (unsigned char)59, 
        (unsigned char)60,      (unsigned char)61,      (unsigned char)62,      (unsigned char)63, 
        (unsigned char)64,      (unsigned char)65,      (unsigned char)66,      (unsigned char)67, 
        (unsigned char)68,      (unsigned char)69,      (unsigned char)70,      (unsigned char)71, 
        (unsigned char)72,      (unsigned char)73,      (unsigned char)74,      (unsigned char)75, 
        (unsigned char)76,      (unsigned char)77,      (unsigned char)78,      (unsigned char)79, 
        (unsigned char)80,      (unsigned char)81,      (unsigned char)82,      (unsigned char)83, 
        (unsigned char)84,      (unsigned char)85,      (unsigned char)86,      (unsigned char)87, 
        (unsigned char)88,      (unsigned char)89,      (unsigned char)90,      (unsigned char)91, 
        (unsigned char)92,      (unsigned char)93,      (unsigned char)94,      (unsigned char)95, 
        (unsigned char)96,      (unsigned char)97,      (unsigned char)98,      (unsigned char)99, 
        (unsigned char)100,      (unsigned char)101,      (unsigned char)102,      (unsigned char)103, 
        (unsigned char)104,      (unsigned char)105,      (unsigned char)106,      (unsigned char)107, 
        (unsigned char)108,      (unsigned char)109,      (unsigned char)110,      (unsigned char)111, 
        (unsigned char)112,      (unsigned char)113,      (unsigned char)114,      (unsigned char)115, 
        (unsigned char)116,      (unsigned char)117,      (unsigned char)118,      (unsigned char)119, 
        (unsigned char)120,      (unsigned char)121,      (unsigned char)122,      (unsigned char)123, 
        (unsigned char)124,      (unsigned char)125,      (unsigned char)126,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)32,      (unsigned char)193,      (unsigned char)162,      (unsigned char)163, 
        (unsigned char)219,      (unsigned char)180,      (unsigned char)0,      (unsigned char)164, 
        (unsigned char)172,      (unsigned char)169,      (unsigned char)187,      (unsigned char)199, 
        (unsigned char)194,      (unsigned char)0,      (unsigned char)168,      (unsigned char)248, 
        (unsigned char)161,      (unsigned char)177,      (unsigned char)0,      (unsigned char)0, 
        (unsigned char)171,      (unsigned char)181,      (unsigned char)166,      (unsigned char)225, 
        (unsigned char)252,      (unsigned char)0,      (unsigned char)188,      (unsigned char)200, 
        (unsigned char)0,      (unsigned char)0,      (unsigned char)0,      (unsigned char)192, 
        (unsigned char)203,      (unsigned char)231,      (unsigned char)229,      (unsigned char)204, 
        (unsigned char)128,      (unsigned char)129,      (unsigned char)174,      (unsigned char)130, 
        (unsigned char)233,      (unsigned char)131,      (unsigned char)230,      (unsigned char)232, 
        (unsigned char)237,      (unsigned char)234,      (unsigned char)235,      (unsigned char)236, 
        (unsigned char)1,      (unsigned char)132,      (unsigned char)241,      (unsigned char)238, 
        (unsigned char)239,      (unsigned char)205,      (unsigned char)133,      (unsigned char)0, 
        (unsigned char)175,      (unsigned char)244,      (unsigned char)242,      (unsigned char)243, 
        (unsigned char)134,      (unsigned char)0,      (unsigned char)0,      (unsigned char)167, 
        (unsigned char)136,      (unsigned char)135,      (unsigned char)137,      (unsigned char)139, 
        (unsigned char)138,      (unsigned char)140,      (unsigned char)190,      (unsigned char)141, 
        (unsigned char)143,      (unsigned char)142,      (unsigned char)144,      (unsigned char)145, 
        (unsigned char)147,      (unsigned char)146,      (unsigned char)148,      (unsigned char)149, 
        (unsigned char)2,      (unsigned char)150,      (unsigned char)152,      (unsigned char)151, 
        (unsigned char)153,      (unsigned char)155,      (unsigned char)154,      (unsigned char)214, 
        (unsigned char)191,      (unsigned char)157,      (unsigned char)156,      (unsigned char)158, 
        (unsigned char)159,      (unsigned char)0,      (unsigned char)0,      (unsigned char)216};
#line 106 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
char const   *styles[8]  = 
#line 106
  {      "Bold",      "Italic",      "Underline",      "Outline", 
        "Shadow",      "Condensed",      "Extended",      (char const   *)((void *)0)};
#line 136 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static void LoadNFNT(FILE *f , struct MacFontRec *font , long offset ) 
{ 
  long here ;
  long tmp ;
  long baseow ;
  long ow ;
  int i ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  void *tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;

  {
  {
#line 137
  tmp = ftell(f);
#line 137
  here = tmp;
#line 142
  offset += 4L;
#line 143
  fseek(f, offset, 0);
#line 144
  memset((void *)font, '\000', sizeof(struct MacFontRec ));
#line 145
  tmp___0 = getushort(f);
#line 145
  font->fontType = (short )tmp___0;
#line 146
  tmp___1 = getushort(f);
#line 146
  font->firstChar = (short )tmp___1;
#line 147
  tmp___2 = getushort(f);
#line 147
  font->lastChar = (short )tmp___2;
#line 148
  tmp___3 = getushort(f);
#line 148
  font->widthMax = (short )tmp___3;
#line 149
  tmp___4 = getushort(f);
#line 149
  font->kernMax = (short )tmp___4;
#line 150
  tmp___5 = getushort(f);
#line 150
  font->Descent = (short )tmp___5;
#line 151
  tmp___6 = getushort(f);
#line 151
  font->fRectWidth = (short )tmp___6;
#line 152
  tmp___7 = getushort(f);
#line 152
  font->fRectHeight = (short )tmp___7;
#line 153
  baseow = ftell(f);
#line 154
  tmp___8 = getushort(f);
#line 154
  ow = (long )tmp___8;
#line 155
  tmp___9 = getushort(f);
#line 155
  font->ascent = (short )tmp___9;
#line 156
  tmp___10 = getushort(f);
#line 156
  font->descent = (short )tmp___10;
  }
#line 157
  if ((int )font->Descent >= 0) {
#line 158
    ow |= (long )((int )font->Descent << 16);
#line 159
    font->Descent = (short )(- ((int )font->descent));
  }
  {
#line 161
  tmp___11 = getushort(f);
#line 161
  font->leading = (short )tmp___11;
#line 162
  tmp___12 = getushort(f);
#line 162
  font->rowWords = (short )tmp___12;
  }
#line 163
  if ((int )font->rowWords != 0) {
#line 164
    font->fontImage = (unsigned short *)((void *)0);
#line 165
    if ((int )font->rowWords != 0) {
      {
#line 166
      tmp___13 = calloc((size_t )((int )font->rowWords * (int )font->fRectHeight),
                        sizeof(short ));
#line 166
      font->fontImage = (unsigned short *)tmp___13;
      }
    }
    {
#line 167
    tmp___14 = calloc((size_t )(((int )font->lastChar - (int )font->firstChar) + 3),
                      sizeof(short ));
#line 167
    font->locs = (unsigned short *)tmp___14;
#line 168
    tmp___15 = calloc((size_t )(((int )font->lastChar - (int )font->firstChar) + 3),
                      sizeof(short ));
#line 168
    font->offsetWidths = (unsigned short *)tmp___15;
#line 169
    i = 0;
    }
    {
#line 169
    while (1) {
      while_continue: /* CIL Label */ ;
#line 169
      if (! (i < (int )font->rowWords * (int )font->fRectHeight)) {
#line 169
        goto while_break;
      }
      {
#line 170
      tmp___16 = getushort(f);
#line 170
      *(font->fontImage + i) = (unsigned short )tmp___16;
#line 169
      i ++;
      }
    }
    while_break: /* CIL Label */ ;
    }
#line 171
    i = 0;
    {
#line 171
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 171
      if (! (i < ((int )font->lastChar - (int )font->firstChar) + 3)) {
#line 171
        goto while_break___0;
      }
      {
#line 172
      tmp___17 = getushort(f);
#line 172
      *(font->locs + i) = (unsigned short )tmp___17;
#line 171
      i ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 173
    fseek(f, baseow + 2L * ow, 0);
#line 174
    i = 0;
    }
    {
#line 174
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 174
      if (! (i < ((int )font->lastChar - (int )font->firstChar) + 3)) {
#line 174
        goto while_break___1;
      }
      {
#line 175
      tmp___18 = getushort(f);
#line 175
      *(font->offsetWidths + i) = (unsigned short )tmp___18;
#line 174
      i ++;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
  }
  {
#line 177
  fseek(f, here, 0);
  }
#line 178
  return;
}
}
#line 180 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static int FontHasChar(struct MacFontRec *font , int ch ) 
{ 


  {
#line 181
  if (ch < (int )font->firstChar) {
#line 182
    return (0);
  } else
#line 181
  if (ch > (int )font->lastChar) {
#line 182
    return (0);
  } else
#line 181
  if (ch == 0) {
#line 182
    return (0);
  } else
#line 181
  if (ch == 9) {
#line 182
    return (0);
  } else
#line 181
  if (ch == 13) {
#line 182
    return (0);
  }
#line 184
  return ((int )*(font->offsetWidths + (ch - (int )font->firstChar)) != 65535);
}
}
#line 187 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static int GetFontCount(struct MacFontRec *font ) 
{ 
  int cnt ;
  int i ;
  int tmp ;

  {
#line 188
  cnt = 0;
#line 190
  i = (int )font->firstChar;
  {
#line 190
  while (1) {
    while_continue: /* CIL Label */ ;
#line 190
    if (! (i <= (int )font->lastChar)) {
#line 190
      goto while_break;
    }
    {
#line 191
    tmp = FontHasChar(font, i);
    }
#line 191
    if (tmp) {
#line 192
      cnt ++;
    }
#line 190
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 194
  return (cnt);
}
}
#line 197 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static int GetFontAvgWidth(struct MacFontRec *font ) 
{ 
  int cnt ;
  int i ;
  int wid ;
  int ch ;
  int tmp ;
  int tmp___0 ;

  {
#line 198
  cnt = 0;
#line 198
  wid = 0;
#line 201
  i = (int )font->firstChar;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 201
    if (! (i <= (int )font->lastChar)) {
#line 201
      goto while_break;
    }
#line 202
    if (tolatin1) {
#line 203
      if (i < 256) {
#line 203
        if ((int )mac2iso[i] != 0) {
#line 204
          ch = (int )mac2iso[i];
        } else {
#line 206
          goto __Cont;
        }
      } else {
#line 206
        goto __Cont;
      }
    } else {
#line 208
      ch = i;
    }
    {
#line 209
    tmp = FontHasChar(font, ch);
    }
#line 209
    if (tmp) {
#line 210
      cnt ++;
#line 211
      wid += (int )*(font->offsetWidths + (ch - (int )font->firstChar)) & 255;
    }
    __Cont: /* CIL Label */ 
#line 201
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 214
  if (cnt > 0) {
#line 214
    tmp___0 = (wid * 10) / cnt;
  } else {
#line 214
    tmp___0 = 0;
  }
#line 214
  return (tmp___0);
}
}
#line 217 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static int AnyBitsSet(unsigned short *pt , int bits , int bite ) 
{ 
  int i ;

  {
#line 220
  i = bits;
  {
#line 220
  while (1) {
    while_continue: /* CIL Label */ ;
#line 220
    if (! (i < bite)) {
#line 220
      goto while_break;
    }
#line 221
    if ((int )*(pt + (i >> 4)) & (1 << (15 - (i & 15)))) {
#line 222
      return (1);
    }
#line 220
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 224
  return (0);
}
}
#line 227 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static int GetCharBBox(struct MacFontRec *font , int ch , Rect *bbox ) 
{ 
  unsigned short *widths ;
  unsigned short *locs ;
  unsigned short *rows ;
  int i ;
  int ow ;
  int tmp ;
  int tmp___0 ;

  {
#line 228
  widths = font->offsetWidths;
#line 229
  locs = font->locs;
#line 230
  rows = font->fontImage;
#line 234
  ch -= (int )font->firstChar;
#line 235
  ow = (int )*(widths + ch);
#line 236
  bbox->left = (short )((ow >> 8) + (int )font->kernMax);
#line 236
  bbox->width = (short )((int )*(locs + (ch + 1)) - (int )*(locs + ch));
#line 237
  bbox->height = font->fRectHeight;
#line 237
  bbox->bottom = (short )(- ((int )font->descent));
#line 238
  i = 0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (i < (int )font->fRectHeight)) {
#line 238
      goto while_break;
    }
    {
#line 239
    tmp = AnyBitsSet(rows + i * (int )font->rowWords, (int )*(locs + ch), (int )*(locs + (ch + 1)));
    }
#line 239
    if (tmp) {
#line 240
      goto while_break;
    }
#line 238
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 241
  bbox->height = (short )((int )bbox->height - i);
#line 242
  i = 0;
  {
#line 242
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 242
    if (! (i < (int )bbox->height)) {
#line 242
      goto while_break___0;
    }
    {
#line 243
    tmp___0 = AnyBitsSet(rows + (((int )font->fRectHeight - i) - 1) * (int )font->rowWords,
                         (int )*(locs + ch), (int )*(locs + (ch + 1)));
    }
#line 243
    if (tmp___0) {
#line 244
      goto while_break___0;
    }
#line 242
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 245
  bbox->bottom = (short )((int )bbox->bottom + i);
#line 245
  bbox->height = (short )((int )bbox->height - i);
#line 246
  if ((int )bbox->height < 0) {
#line 246
    bbox->height = (short)0;
  }
#line 247
  return (ow & 255);
}
}
#line 250 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static void WriteRow(FILE *bdf , unsigned short *test , int bits , int bite ) 
{ 
  int i ;
  int cnt ;
  int nibble ;
  char buffer___0[80] ;
  char *pt ;
  char *tmp ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
#line 252
  cnt = 8;
#line 252
  nibble = 0;
#line 253
  pt = buffer___0;
#line 255
  i = bits;
  {
#line 255
  while (1) {
    while_continue: /* CIL Label */ ;
#line 255
    if (! (i < bite)) {
#line 255
      goto while_break;
    }
#line 256
    if ((int )*(test + (i >> 4)) & (1 << (15 - (i & 15)))) {
#line 257
      nibble |= cnt;
    }
#line 258
    cnt >>= 1;
#line 258
    if (cnt == 0) {
#line 259
      if (nibble >= 10) {
#line 260
        tmp = pt;
#line 260
        pt ++;
#line 260
        *tmp = (char )((65 + nibble) - 10);
      } else {
#line 262
        tmp___0 = pt;
#line 262
        pt ++;
#line 262
        *tmp___0 = (char )(48 + nibble);
      }
#line 263
      cnt = 8;
#line 264
      nibble = 0;
    }
#line 255
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 267
  if (cnt != 8) {
#line 268
    if (nibble >= 10) {
#line 269
      tmp___1 = pt;
#line 269
      pt ++;
#line 269
      *tmp___1 = (char )((65 + nibble) - 10);
    } else {
#line 271
      tmp___2 = pt;
#line 271
      pt ++;
#line 271
      *tmp___2 = (char )(48 + nibble);
    }
  }
#line 273
  if ((pt - buffer___0) & 1L) {
#line 274
    tmp___3 = pt;
#line 274
    pt ++;
#line 274
    *tmp___3 = (char )'0';
  }
  {
#line 275
  tmp___4 = pt;
#line 275
  pt ++;
#line 275
  *tmp___4 = (char )'\n';
#line 276
  *pt = (char )'\000';
#line 277
  fputs((char const   */* __restrict  */)(buffer___0), (FILE */* __restrict  */)bdf);
  }
#line 278
  return;
}
}
#line 280 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static void WriteBitmap(FILE *bdf , struct MacFontRec *font , int ch , Rect *rct ) 
{ 
  unsigned short *locs ;
  unsigned short *rows ;
  int i ;
  int bits ;
  int bite ;
  int rowf ;
  int rowe ;

  {
#line 281
  locs = font->locs;
#line 282
  rows = font->fontImage;
#line 287
  ch -= (int )font->firstChar;
#line 288
  bits = (int )*(locs + ch);
#line 288
  bite = (int )*(locs + (ch + 1));
#line 289
  rowf = (int )font->fRectHeight - (((int )rct->height + (int )font->descent) + (int )rct->bottom);
#line 290
  rowe = (int )font->fRectHeight - ((int )rct->bottom + (int )font->descent);
#line 291
  i = rowf;
  {
#line 291
  while (1) {
    while_continue: /* CIL Label */ ;
#line 291
    if (! (i < rowe)) {
#line 291
      goto while_break;
    }
    {
#line 292
    WriteRow(bdf, rows + i * (int )font->rowWords, bits, bite);
#line 291
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 293
  return;
}
}
#line 295 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static void WriteChar(FILE *bdf , struct MacFontRec *font , int enc , int index___0 ,
                      int size , FOND *mine , struct assoc *ass ) 
{ 
  Rect rct ;
  int width ;
  short *widths ;
  int i ;
  long tmp ;

  {
#line 299
  widths = (short *)((void *)0);
#line 301
  if ((unsigned long )mine != (unsigned long )((void *)0)) {
#line 301
    if ((unsigned long )ass != (unsigned long )((void *)0)) {
#line 305
      i = 0;
      {
#line 305
      while (1) {
        while_continue: /* CIL Label */ ;
#line 305
        if (! (i < mine->stylewidthcnt)) {
#line 305
          goto while_break;
        }
#line 306
        if ((int )(mine->stylewidths + i)->style == (int )ass->style) {
#line 307
          widths = (mine->stylewidths + i)->widthtab;
#line 308
          goto while_break;
        }
#line 305
        i ++;
      }
      while_break: /* CIL Label */ ;
      }
    }
  }
#line 312
  if (index___0 == 0) {
    {
#line 313
    fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"STARTCHAR .notdef\n");
    }
  } else
#line 314
  if (index___0 < 256) {
#line 314
    if ((unsigned long )macnames[index___0] != (unsigned long )((void *)0)) {
      {
#line 315
      fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"STARTCHAR %s\n",
              macnames[index___0]);
      }
    } else {
      {
#line 317
      fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"STARTCHAR char%04x\n",
              index___0);
      }
    }
  } else {
    {
#line 317
    fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"STARTCHAR char%04x\n",
            index___0);
    }
  }
  {
#line 318
  width = GetCharBBox(font, index___0, & rct);
#line 319
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"ENCODING %d\n",
          enc);
  }
#line 320
  if ((unsigned long )widths == (unsigned long )((void *)0)) {
#line 320
    tmp = ((long )width * 1000L) / (long )size;
  } else {
#line 320
    tmp = ((long )*(widths + index___0) * 1000L + (long )(1 << 11)) >> 12;
  }
  {
#line 320
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"SWIDTH %ld 0\n",
          tmp);
#line 322
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"DWIDTH %d 0\n",
          width);
#line 323
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"BBX %d %d %d %d\n",
          (int )rct.width, (int )rct.height, (int )rct.left, (int )rct.bottom);
#line 324
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"BITMAP\n");
#line 325
  WriteBitmap(bdf, font, index___0, & rct);
#line 326
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"ENDCHAR\n");
  }
#line 327
  return;
}
}
#line 329 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static void DumpNFNT2BDF(FILE *bdf , struct MacFontRec *font , char *resname , FOND *mine ,
                         struct assoc *ass ) 
{ 
  int cnt ;
  int avg ;
  int style ;
  int tmp ;
  int size ;
  int tmp___0 ;
  int i ;
  int dpi ;
  char const   *tmp___1 ;
  char const   *tmp___2 ;
  char const   *tmp___3 ;
  char const   *tmp___4 ;
  char const   *tmp___5 ;
  char const   *tmp___6 ;
  char *tmp___7 ;
  char *tmp___8 ;
  char const   *tmp___9 ;
  char const   *tmp___10 ;
  char const   *tmp___11 ;
  char const   *tmp___12 ;
  char const   *tmp___13 ;
  char const   *tmp___14 ;
  int ch ;
  int tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;

  {
#line 332
  if ((unsigned long )ass != (unsigned long )((void *)0)) {
#line 332
    tmp = (int )ass->style;
  } else {
#line 332
    tmp = 0;
  }
#line 332
  style = tmp;
#line 333
  if ((unsigned long )ass != (unsigned long )((void *)0)) {
#line 333
    tmp___0 = (int )ass->size;
  } else {
#line 333
    tmp___0 = (int )font->fRectHeight;
  }
#line 333
  size = tmp___0;
#line 335
  dpi = 75;
#line 337
  if (size == 17) {
#line 338
    dpi = 100;
  } else
#line 337
  if (size == 33) {
#line 338
    dpi = 100;
  }
  {
#line 340
  cnt = GetFontCount(font);
#line 341
  avg = GetFontAvgWidth(font);
#line 342
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"STARTFONT 2.1\n");
  }
#line 343
  if (tolatin1) {
#line 343
    tmp___1 = "ISO8859";
  } else {
#line 343
    tmp___1 = "MacRoman";
  }
#line 343
  if (((int )font->fontType & 61440) == 45056) {
#line 343
    tmp___2 = "M";
  } else {
#line 343
    tmp___2 = "P";
  }
#line 343
  if (style & 32) {
#line 343
    tmp___4 = "Condensed";
  } else {
#line 343
    if (style & 64) {
#line 343
      tmp___3 = "Extended";
    } else {
#line 343
      tmp___3 = "Normal";
    }
#line 343
    tmp___4 = tmp___3;
  }
#line 343
  if (style & 2) {
#line 343
    tmp___5 = "I";
  } else {
#line 343
    tmp___5 = "R";
  }
#line 343
  if (style & 1) {
#line 343
    tmp___6 = "Bold";
  } else {
#line 343
    tmp___6 = "Medium";
  }
#line 343
  if ((unsigned long )mine != (unsigned long )((void *)0)) {
#line 343
    if ((unsigned long )mine->fondname != (unsigned long )((void *)0)) {
#line 343
      tmp___7 = mine->fondname;
    } else {
#line 343
      tmp___7 = resname;
    }
  } else {
#line 343
    tmp___7 = resname;
  }
  {
#line 343
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"FONT -Fondu-%s-%s-%s-%s--%d-%d0-%d-%d-%s-%d-%s-1\n",
          tmp___7, tmp___6, tmp___5, tmp___4, size, (size * 72 + dpi / 2) / dpi, dpi,
          dpi, tmp___2, avg, tmp___1);
#line 353
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"SIZE %d %d %d\n",
          (size * 72 + dpi / 2) / dpi, dpi, dpi);
#line 354
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"FONTBOUNDINGBOX %d %d %d %d\n",
          (int )font->fRectWidth, (int )font->fRectHeight, (int )font->kernMax, - ((int )font->descent));
#line 355
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"COMMENT Created by Fondu from a mac NFNT/FONT resource\n");
#line 356
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"STARTPROPERTIES 17\n");
#line 357
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"FOUNDRY \"Fondu\"\n");
  }
#line 358
  if ((unsigned long )mine != (unsigned long )((void *)0)) {
#line 358
    if ((unsigned long )mine->fondname != (unsigned long )((void *)0)) {
#line 358
      tmp___8 = mine->fondname;
    } else {
#line 358
      tmp___8 = resname;
    }
  } else {
#line 358
    tmp___8 = resname;
  }
  {
#line 358
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"FAMILY_NAME \"%s\"\n",
          tmp___8);
  }
#line 359
  if (style & 1) {
#line 359
    tmp___9 = "Bold";
  } else {
#line 359
    tmp___9 = "Medium";
  }
  {
#line 359
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"WEIGHT_NAME \"%s\"\n",
          tmp___9);
  }
#line 360
  if (style & 2) {
#line 360
    tmp___10 = "I";
  } else {
#line 360
    tmp___10 = "R";
  }
  {
#line 360
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"SLANT \"%s\"\n",
          tmp___10);
  }
#line 361
  if (style & 32) {
#line 361
    tmp___12 = "Condensed";
  } else {
#line 361
    if (style & 64) {
#line 361
      tmp___11 = "Extended";
    } else {
#line 361
      tmp___11 = "Normal";
    }
#line 361
    tmp___12 = tmp___11;
  }
  {
#line 361
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"SETWIDTH_NAME \"%s\"\n",
          tmp___12);
#line 362
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"ADD_STYLE_NAME \"\"\n");
#line 363
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"PIXEL_SIZE %d\n",
          size);
#line 364
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"POINT_SIZE %d0\n",
          (size * 72 + dpi / 2) / dpi);
#line 365
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"RESOLUTION_X %d\n",
          dpi);
#line 366
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"RESOLUTION_Y %d\n",
          dpi);
  }
#line 367
  if (((int )font->fontType & 61440) == 45056) {
#line 367
    tmp___13 = "M";
  } else {
#line 367
    tmp___13 = "P";
  }
  {
#line 367
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"SPACING \"%s\"\n",
          tmp___13);
#line 368
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"AVERAGE_WIDTH %d\n",
          avg);
  }
#line 369
  if (tolatin1) {
#line 369
    tmp___14 = "ISO8859";
  } else {
#line 369
    tmp___14 = "MacRoman";
  }
  {
#line 369
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"CHARSET_REGISTRY \"%s\"\n",
          tmp___14);
#line 370
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"CHARSET_ENCODING \"1\"\n");
#line 371
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"FONT_ASCENT %d\n",
          (int )font->ascent);
#line 372
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"FONT_DESCENT %d\n",
          (int )font->descent);
#line 373
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"FACE_NAME \"");
  }
#line 374
  if ((int )*resname != 0) {
    {
#line 375
    fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"%s\"\n",
            resname);
    }
  } else
#line 376
  if ((unsigned long )mine != (unsigned long )((void *)0)) {
#line 376
    if ((unsigned long )mine->fondname != (unsigned long )((void *)0)) {
      {
#line 377
      fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"%s",
              mine->fondname);
      }
#line 378
      if ((unsigned long )ass != (unsigned long )((void *)0)) {
#line 379
        i = 0;
        {
#line 379
        while (1) {
          while_continue: /* CIL Label */ ;
#line 379
          if (! ((unsigned long )styles[i] != (unsigned long )((void *)0))) {
#line 379
            goto while_break;
          }
#line 380
          if ((int )ass->style & (1 << i)) {
            {
#line 381
            fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"%s",
                    styles[i]);
            }
          }
#line 379
          i ++;
        }
        while_break: /* CIL Label */ ;
        }
      }
      {
#line 383
      fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"\"\n");
      }
    } else {
      {
#line 385
      fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"nameless\"\n");
      }
    }
  } else {
    {
#line 385
    fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"nameless\"\n");
    }
  }
  {
#line 386
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"ENDPROPERTIES\n");
#line 387
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"CHARS %d\n",
          cnt);
  }
#line 388
  if (tolatin1) {
#line 389
    i = 0;
    {
#line 389
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 389
      if (! (i <= 255)) {
#line 389
        goto while_break___0;
      }
      {
#line 390
      ch = (int )iso2mac[i];
#line 391
      tmp___15 = FontHasChar(font, ch);
      }
#line 391
      if (tmp___15) {
        {
#line 392
        WriteChar(bdf, font, i, ch, size, mine, ass);
        }
      }
#line 389
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 394
    i = (int )font->firstChar;
    {
#line 394
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 394
      if (! (i <= (int )font->lastChar)) {
#line 394
        goto while_break___1;
      }
#line 395
      if (i >= 256) {
#line 395
        goto _L;
      } else
#line 395
      if ((int )mac2iso[i] == 0) {
        _L: /* CIL Label */ 
        {
#line 395
        tmp___16 = FontHasChar(font, i);
        }
#line 395
        if (tmp___16) {
          {
#line 396
          WriteChar(bdf, font, -1, i, size, mine, ass);
          }
        }
      }
#line 394
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 398
    i = (int )font->firstChar;
    {
#line 398
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 398
      if (! (i <= (int )font->lastChar)) {
#line 398
        goto while_break___2;
      }
      {
#line 399
      tmp___17 = FontHasChar(font, i);
      }
#line 399
      if (tmp___17) {
        {
#line 400
        WriteChar(bdf, font, i, i, size, mine, ass);
        }
      }
#line 398
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
  {
#line 402
  fprintf((FILE */* __restrict  */)bdf, (char const   */* __restrict  */)"ENDFONT\n");
  }
#line 403
  return;
}
}
#line 412 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
static int ucnt___1  ;
#line 405 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/readnfnt.c"
void SearchNFNTResources(FILE *f , long rlistpos , int subcnt , long rdata_pos , long name_list ,
                         FOND *fonds ) 
{ 
  long here ;
  long start ;
  long tmp ;
  long roff ;
  int rname ;
  char resname[256] ;
  char name[300] ;
  int ch1 ;
  int ch2 ;
  int i ;
  int j ;
  int res_id ;
  FILE *bdf ;
  FOND *mine ;
  struct assoc *ass ;
  struct MacFontRec font ;
  int tmp___0 ;
  int tmp___1 ;
  int i___0 ;
  int tmp___2 ;
  size_t tmp___3 ;
  int tmp___4 ;

  {
  {
#line 407
  tmp = ftell(f);
#line 407
  start = tmp;
#line 409
  rname = -1;
#line 420
  fseek(f, rlistpos, 0);
#line 421
  i = 0;
  }
  {
#line 421
  while (1) {
    while_continue: /* CIL Label */ ;
#line 421
    if (! (i < subcnt)) {
#line 421
      goto while_break;
    }
    {
#line 422
    res_id = getushort(f);
#line 423
    tmp___0 = getushort(f);
#line 423
    rname = (int )((short )tmp___0);
#line 424
    _IO_getc(f);
#line 425
    ch1 = _IO_getc(f);
#line 425
    ch2 = _IO_getc(f);
#line 426
    tmp___1 = _IO_getc(f);
#line 426
    roff = rdata_pos + (long )(((ch1 << 16) | (ch2 << 8)) | tmp___1);
#line 427
    getlong(f);
#line 428
    here = ftell(f);
#line 429
    LoadNFNT(f, & font, roff);
    }
#line 430
    if ((int )font.rowWords == 0) {
#line 433
      goto __Cont;
    }
#line 435
    ass = (struct assoc *)((void *)0);
#line 438
    mine = fonds;
    {
#line 438
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 438
      if (! ((unsigned long )mine != (unsigned long )((void *)0))) {
#line 438
        goto while_break___0;
      }
#line 440
      i___0 = 0;
      {
#line 440
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 440
        if (! (i___0 < mine->assoc_cnt)) {
#line 440
          goto while_break___1;
        }
#line 441
        if (res_id == (int )(mine->assoc + i___0)->id) {
#line 441
          if ((int )(mine->assoc + i___0)->size != 0) {
#line 442
            ass = mine->assoc + i___0;
#line 443
            goto while_break___1;
          }
        }
#line 440
        i___0 ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 445
      if ((unsigned long )ass != (unsigned long )((void *)0)) {
#line 446
        goto while_break___0;
      }
#line 438
      mine = mine->next;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 448
    resname[0] = (char )'\000';
#line 449
    if (rname != -1) {
      {
#line 450
      fseek(f, name_list + (long )rname, 0);
#line 451
      ch1 = _IO_getc(f);
#line 452
      fread((void */* __restrict  */)(resname), (size_t )1, (size_t )ch1, (FILE */* __restrict  */)f);
#line 453
      resname[ch1] = (char )'\000';
      }
#line 454
      if ((unsigned long )ass != (unsigned long )((void *)0)) {
#line 454
        tmp___2 = (int )ass->size;
      } else {
#line 454
        tmp___2 = (int )font.fRectHeight;
      }
      {
#line 454
      sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"%s-%d.bdf",
              resname, tmp___2);
      }
    } else
#line 455
    if ((unsigned long )ass != (unsigned long )((void *)0)) {
#line 456
      if ((unsigned long )mine->fondname == (unsigned long )((void *)0)) {
        {
#line 457
        ucnt___1 ++;
#line 457
        sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"Untitled%d-%d.bdf",
                ucnt___1, (int )ass->size);
        }
      } else {
        {
#line 459
        strcpy((char */* __restrict  */)(name), (char const   */* __restrict  */)mine->fondname);
#line 460
        j = 0;
        }
        {
#line 460
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 460
          if (! ((unsigned long )styles[j] != (unsigned long )((void *)0))) {
#line 460
            goto while_break___2;
          }
#line 461
          if ((int )ass->style & (1 << j)) {
            {
#line 462
            strcat((char */* __restrict  */)(name), (char const   */* __restrict  */)styles[j]);
            }
          }
#line 460
          j ++;
        }
        while_break___2: /* CIL Label */ ;
        }
        {
#line 463
        tmp___3 = strlen((char const   *)(name));
#line 463
        sprintf((char */* __restrict  */)(name + tmp___3), (char const   */* __restrict  */)"-%d.bdf",
                (int )ass->size);
        }
      }
    } else {
      {
#line 466
      ucnt___1 ++;
#line 466
      sprintf((char */* __restrict  */)(name), (char const   */* __restrict  */)"Untitled%d-%d.bdf",
              ucnt___1, (int )font.fRectHeight);
      }
    }
    {
#line 467
    fseek(f, here, 0);
#line 468
    tmp___4 = cleanfilename(name);
    }
#line 468
    if (tmp___4) {
#line 470
      if (((int )font.fontType & 12) != 0) {
        {
#line 471
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"The bitmap font %s a depth greater than 1 and is ignored\n",
                name);
        }
      } else {
        {
#line 473
        bdf = fopen((char const   */* __restrict  */)(name), (char const   */* __restrict  */)"w+");
        }
#line 474
        if ((unsigned long )bdf == (unsigned long )((void *)0)) {
          {
#line 475
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Can\'t open %s for output\n",
                  name);
          }
        } else {
          {
#line 477
          DumpNFNT2BDF(bdf, & font, resname, mine, ass);
          }
        }
      }
    }
    {
#line 479
    free((void *)font.offsetWidths);
#line 480
    free((void *)font.fontImage);
#line 481
    free((void *)font.locs);
    }
    __Cont: /* CIL Label */ 
#line 421
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 483
  fseek(f, start, 0);
  }
#line 484
  return;
}
}
#line 57 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/frommacbinary.c"
static void Usage___2(char *prog ) 
{ 


  {
  {
#line 58
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Usage: %s [-usage] [-help] [-version] filenames\n",
          prog);
#line 59
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -usage\t\tPrints this message\n");
#line 60
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -help\t\tPrints this message\n");
#line 61
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" -version\t\tPrints the version of the program\n");
#line 62
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Takes a list of macbinary filenames and extracts the contents\n");
#line 63
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" on the mac it creates the obvious file.\n");
#line 64
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" on non-mac systems it will create up to three files for each input file\n");
#line 65
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  *.info contains some mac specific data\n");
#line 66
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  *.data contains the data fork (if present)\n");
#line 67
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"  *.rsrc contains the resource fork (if present)\n");
#line 68
  exit(1);
  }
}
}
#line 71 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/frommacbinary.c"
static void ProcessFile(char *filename ) 
{ 
  FILE *binfile ;
  unsigned char header[128] ;
  char name[80] ;
  int dlen ;
  int rlen ;
  int i ;
  int ch ;
  FILE *datafile ;
  FILE *resfile ;
  FILE *infofile ;

  {
  {
#line 78
  binfile = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 79
  if ((unsigned long )binfile == (unsigned long )((void *)0)) {
    {
#line 80
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open %s\n",
            filename);
    }
#line 81
    return;
  }
  {
#line 83
  fread((void */* __restrict  */)(header), (size_t )1, sizeof(header), (FILE */* __restrict  */)binfile);
  }
#line 84
  if ((int )header[0] != 0) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a macbinary file\n",
            filename);
#line 87
    fclose(binfile);
    }
#line 88
    return;
  } else
#line 84
  if ((int )header[74] != 0) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a macbinary file\n",
            filename);
#line 87
    fclose(binfile);
    }
#line 88
    return;
  } else
#line 84
  if ((int )header[82] != 0) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a macbinary file\n",
            filename);
#line 87
    fclose(binfile);
    }
#line 88
    return;
  } else
#line 84
  if ((int )header[1] <= 0) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a macbinary file\n",
            filename);
#line 87
    fclose(binfile);
    }
#line 88
    return;
  } else
#line 84
  if ((int )header[1] > 33) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a macbinary file\n",
            filename);
#line 87
    fclose(binfile);
    }
#line 88
    return;
  } else
#line 84
  if ((int )header[63] != 0) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a macbinary file\n",
            filename);
#line 87
    fclose(binfile);
    }
#line 88
    return;
  } else
#line 84
  if ((int )header[2 + (int )header[1]] != 0) {
    {
#line 86
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s does not look like a macbinary file\n",
            filename);
#line 87
    fclose(binfile);
    }
#line 88
    return;
  }
  {
#line 90
  strncpy((char */* __restrict  */)(name), (char const   */* __restrict  */)((char *)(header) + 2),
          (size_t )header[1]);
#line 91
  name[header[1]] = (char )'\000';
#line 92
  dlen = ((((int )header[83] << 24) | ((int )header[84] << 16)) | ((int )header[85] << 8)) | (int )header[86];
#line 93
  rlen = ((((int )header[87] << 24) | ((int )header[88] << 16)) | ((int )header[89] << 8)) | (int )header[90];
#line 94
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)" %s => %s, dfork len=%d rfork len=%d\n",
          filename, name, dlen, rlen);
  }
#line 99
  if (dlen > 0) {
    {
#line 100
    fseek(binfile, 128L, 0);
#line 101
    strcpy((char */* __restrict  */)(name + (int )header[1]), (char const   */* __restrict  */)".data");
#line 102
    datafile = fopen((char const   */* __restrict  */)(name), (char const   */* __restrict  */)"w");
    }
#line 103
    if ((unsigned long )datafile == (unsigned long )((void *)0)) {
      {
#line 104
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file: %s\n",
              name);
      }
    } else {
#line 106
      i = 0;
      {
#line 106
      while (1) {
        while_continue: /* CIL Label */ ;
#line 106
        if (i < dlen) {
          {
#line 106
          ch = _IO_getc(binfile);
          }
#line 106
          if (! (ch != -1)) {
#line 106
            goto while_break;
          }
        } else {
#line 106
          goto while_break;
        }
        {
#line 107
        _IO_putc(ch, datafile);
#line 106
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
      {
#line 108
      fclose(datafile);
      }
    }
  }
#line 112
  if (rlen > 0) {
    {
#line 113
    fseek(binfile, (long )(128 + ((dlen + 127) & -128)), 0);
#line 114
    strcpy((char */* __restrict  */)(name + (int )header[1]), (char const   */* __restrict  */)".rsrc");
#line 115
    resfile = fopen((char const   */* __restrict  */)(name), (char const   */* __restrict  */)"w");
    }
#line 116
    if ((unsigned long )resfile == (unsigned long )((void *)0)) {
      {
#line 117
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file: %s\n",
              name);
      }
    } else {
#line 119
      i = 0;
      {
#line 119
      while (1) {
        while_continue___0: /* CIL Label */ ;
#line 119
        if (i < rlen) {
          {
#line 119
          ch = _IO_getc(binfile);
          }
#line 119
          if (! (ch != -1)) {
#line 119
            goto while_break___0;
          }
        } else {
#line 119
          goto while_break___0;
        }
        {
#line 120
        _IO_putc(ch, resfile);
#line 119
        i ++;
        }
      }
      while_break___0: /* CIL Label */ ;
      }
      {
#line 121
      fclose(resfile);
      }
    }
  }
  {
#line 125
  strcpy((char */* __restrict  */)(name + (int )header[1]), (char const   */* __restrict  */)".info");
#line 126
  infofile = fopen((char const   */* __restrict  */)(name), (char const   */* __restrict  */)"w");
  }
#line 127
  if ((unsigned long )infofile == (unsigned long )((void *)0)) {
    {
#line 128
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Cannot open output file: %s\n",
            name);
    }
  } else {
    {
#line 130
    name[header[1]] = (char )'\000';
#line 131
    fprintf((FILE */* __restrict  */)infofile, (char const   */* __restrict  */)"Mac filename = %s\n",
            name);
#line 132
    fprintf((FILE */* __restrict  */)infofile, (char const   */* __restrict  */)"Data fork length = %d\n",
            dlen);
#line 133
    fprintf((FILE */* __restrict  */)infofile, (char const   */* __restrict  */)"Resource fork length = %d\n",
            rlen);
#line 134
    fprintf((FILE */* __restrict  */)infofile, (char const   */* __restrict  */)"File Type = %c%c%c%c\n",
            (int )header[65], (int )header[66], (int )header[67], (int )header[68]);
#line 136
    fprintf((FILE */* __restrict  */)infofile, (char const   */* __restrict  */)"File Creator = %c%c%c%c\n",
            (int )header[69], (int )header[70], (int )header[71], (int )header[72]);
#line 138
    fprintf((FILE */* __restrict  */)infofile, (char const   */* __restrict  */)"Finder Flags = %08x\n",
            (int )header[73]);
#line 140
    fclose(infofile);
    }
  }
  {
#line 230
  fclose(binfile);
  }
#line 231
  return;
}
}
#line 580 "/usr/include/stdio.h"
extern int putchar(int __c ) ;
#line 64 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static FOND *BuildFondList___0(FILE *f , long rlistpos , int subcnt , long rdata_pos ,
                               long name_list ) 
{ 
  long here ;
  long start ;
  long tmp ;
  long offset ;
  long end___0 ;
  int rname ;
  char name[300] ;
  int ch1 ;
  int ch2 ;
  int i ;
  int j ;
  int k ;
  int l ;
  int ch ;
  int rlen ;
  int cnt ;
  FOND *head ;
  FOND *cur ;
  long widoff ;
  long kernoff ;
  long styleoff ;
  long bboff ;
  long offsetstart ;
  long glyphenc ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  void *tmp___5 ;
  long tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  long tmp___13 ;
  long tmp___14 ;
  long tmp___15 ;
  int tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;
  int tmp___20 ;
  int tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int tmp___25 ;
  int tmp___26 ;
  void *tmp___27 ;
  int tmp___28 ;
  int tmp___29 ;
  int tmp___30 ;
  int test ;
  int tmp___31 ;
  long tmp___32 ;
  int tmp___33 ;
  int tmp___34 ;
  int tmp___35 ;
  int tmp___36 ;
  int tmp___37 ;
  int tmp___38 ;
  int tmp___39 ;
  void *tmp___40 ;
  int tmp___41 ;
  void *tmp___42 ;
  int tmp___43 ;
  char const   *tmp___44 ;
  int tmp___45 ;
  int tmp___46 ;
  int tmp___47 ;
  void *tmp___48 ;
  int tmp___49 ;
  void *tmp___50 ;
  int tmp___51 ;
  int tmp___52 ;
  int tmp___53 ;
  int class ;
  int tmp___54 ;
  int tmp___55 ;
  int tmp___56 ;
  int tmp___57 ;
  int tmp___58 ;
  int tmp___59 ;
  int tmp___60 ;
  int tmp___61 ;

  {
  {
#line 66
  tmp = ftell(f);
#line 66
  start = tmp;
#line 68
  rname = -1;
#line 72
  head = (FOND *)((void *)0);
#line 75
  fseek(f, rlistpos, 0);
#line 76
  i = 0;
  }
  {
#line 76
  while (1) {
    while_continue: /* CIL Label */ ;
#line 76
    if (! (i < subcnt)) {
#line 76
      goto while_break;
    }
    {
#line 77
    tmp___0 = getushort(f);
#line 77
    printf((char const   */* __restrict  */)"\nFOND ResId=%d\n", tmp___0);
#line 78
    tmp___1 = feof(f);
    }
#line 78
    if (tmp___1) {
      {
#line 79
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF found in FOND list after reading %d resources of %d.\n",
              i, subcnt);
      }
#line 80
      goto while_break;
    }
    {
#line 82
    tmp___2 = getushort(f);
#line 82
    rname = (int )((short )tmp___2);
#line 83
    tmp___3 = _IO_getc(f);
#line 83
    printf((char const   */* __restrict  */)" resource flags=%x\n", tmp___3);
#line 84
    ch1 = _IO_getc(f);
#line 84
    ch2 = _IO_getc(f);
#line 85
    tmp___4 = _IO_getc(f);
#line 85
    offset = rdata_pos + (long )(((ch1 << 16) | (ch2 << 8)) | tmp___4);
#line 86
    getlong(f);
#line 87
    here = ftell(f);
#line 89
    tmp___5 = calloc((size_t )1, sizeof(FOND ));
#line 89
    cur = (FOND *)tmp___5;
    }
#line 90
    if (rname != -1) {
      {
#line 91
      fseek(f, name_list + (long )rname, 0);
#line 92
      ch1 = _IO_getc(f);
#line 93
      fread((void */* __restrict  */)(name), (size_t )1, (size_t )ch1, (FILE */* __restrict  */)f);
#line 94
      name[ch1] = (char )'\000';
#line 95
      cur->fondname = strdup((char const   *)(name));
#line 96
      printf((char const   */* __restrict  */)"\nFOND %s\n", name);
      }
    } else {
      {
#line 98
      printf((char const   */* __restrict  */)"\nFOND nameless\n");
      }
    }
    {
#line 100
    offset += 4L;
#line 101
    fseek(f, offset - 4L, 0);
#line 102
    tmp___6 = getlong(f);
#line 102
    rlen = (int )tmp___6;
#line 102
    printf((char const   */* __restrict  */)"Resource len=%d\n", rlen);
#line 103
    tmp___7 = getushort(f);
#line 103
    printf((char const   */* __restrict  */)"flags = %x\n", tmp___7);
#line 110
    tmp___8 = getushort(f);
#line 110
    printf((char const   */* __restrict  */)"famid = %d\n", tmp___8);
#line 111
    cur->first = getushort(f);
#line 112
    cur->last = getushort(f);
#line 113
    printf((char const   */* __restrict  */)"first=%d, last=%d\n", cur->first, cur->last);
#line 115
    tmp___9 = getushort(f);
#line 115
    printf((char const   */* __restrict  */)"ascent = %g\n", (double )tmp___9 / (double )(1 << 12));
#line 116
    tmp___10 = getushort(f);
#line 116
    printf((char const   */* __restrict  */)"descent = %g\n", (double )((short )tmp___10) / (double )(1 << 12));
#line 117
    tmp___11 = getushort(f);
#line 117
    printf((char const   */* __restrict  */)"leading = %g\n", (double )tmp___11 / (double )(1 << 12));
#line 118
    tmp___12 = getushort(f);
#line 118
    printf((char const   */* __restrict  */)"widmax = %g\n", (double )tmp___12 / (double )(1 << 12));
#line 119
    widoff = getlong(f);
    }
#line 119
    if (widoff != 0L) {
#line 119
      widoff += offset;
    }
    {
#line 120
    kernoff = getlong(f);
    }
#line 120
    if (kernoff != 0L) {
#line 120
      kernoff += offset;
    }
    {
#line 121
    styleoff = getlong(f);
    }
#line 121
    if (styleoff != 0L) {
#line 121
      styleoff += offset;
    }
#line 122
    if (widoff == 0L) {
#line 122
      tmp___13 = 0L;
    } else {
#line 122
      tmp___13 = widoff - offset;
    }
    {
#line 122
    printf((char const   */* __restrict  */)"width table offset = %d\n", tmp___13);
    }
#line 123
    if (kernoff == 0L) {
#line 123
      tmp___14 = 0L;
    } else {
#line 123
      tmp___14 = kernoff - offset;
    }
    {
#line 123
    printf((char const   */* __restrict  */)"kern table offset = %d\n", tmp___14);
    }
#line 124
    if (styleoff == 0L) {
#line 124
      tmp___15 = 0L;
    } else {
#line 124
      tmp___15 = styleoff - offset;
    }
    {
#line 124
    printf((char const   */* __restrict  */)"style table offset = %d\n", tmp___15);
#line 125
    printf((char const   */* __restrict  */)"extra width values:\n");
#line 126
    tmp___16 = getushort(f);
#line 126
    printf((char const   */* __restrict  */)" plain: %d\n", tmp___16);
#line 127
    tmp___17 = getushort(f);
#line 127
    printf((char const   */* __restrict  */)" bold: %d\n", tmp___17);
#line 128
    tmp___18 = getushort(f);
#line 128
    printf((char const   */* __restrict  */)" italic: %d\n", tmp___18);
#line 129
    tmp___19 = getushort(f);
#line 129
    printf((char const   */* __restrict  */)" underline: %d\n", tmp___19);
#line 130
    tmp___20 = getushort(f);
#line 130
    printf((char const   */* __restrict  */)" outline: %d\n", tmp___20);
#line 131
    tmp___21 = getushort(f);
#line 131
    printf((char const   */* __restrict  */)" shadow: %d\n", tmp___21);
#line 132
    tmp___22 = getushort(f);
#line 132
    printf((char const   */* __restrict  */)" condensed: %d\n", tmp___22);
#line 133
    tmp___23 = getushort(f);
#line 133
    printf((char const   */* __restrict  */)" extended: %d\n", tmp___23);
#line 134
    tmp___24 = getushort(f);
#line 134
    printf((char const   */* __restrict  */)" not used: %d\n", tmp___24);
#line 135
    getlong(f);
#line 136
    tmp___25 = getushort(f);
#line 136
    printf((char const   */* __restrict  */)"version=%d\n", tmp___25);
#line 138
    tmp___26 = getushort(f);
#line 138
    cur->assoc_cnt = tmp___26 + 1;
#line 139
    printf((char const   */* __restrict  */)"Association cnt=%d\n", cur->assoc_cnt);
#line 140
    tmp___27 = calloc((size_t )cur->assoc_cnt, sizeof(struct assoc ));
#line 140
    cur->assoc = (struct assoc *)tmp___27;
#line 141
    j = 0;
    }
    {
#line 141
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 141
      if (! (j < cur->assoc_cnt)) {
#line 141
        goto while_break___0;
      }
      {
#line 142
      tmp___28 = getushort(f);
#line 142
      (cur->assoc + j)->size = (short )tmp___28;
#line 143
      tmp___29 = getushort(f);
#line 143
      (cur->assoc + j)->style = (short )tmp___29;
#line 144
      tmp___30 = getushort(f);
#line 144
      (cur->assoc + j)->id = (short )tmp___30;
#line 145
      printf((char const   */* __restrict  */)" size=%d style=%x id=%d\n", (int )(cur->assoc + j)->size,
             (int )(cur->assoc + j)->style, (int )(cur->assoc + j)->id);
#line 141
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 147
    end___0 = offset + (long )rlen;
#line 148
    offsetstart = ftell(f);
#line 149
    bboff = 0L;
    }
#line 150
    if (widoff != 0L) {
#line 150
      goto _L;
    } else
#line 150
    if (kernoff != 0L) {
#line 150
      goto _L;
    } else
#line 150
    if (styleoff != 0L) {
      _L: /* CIL Label */ 
      {
#line 153
      tmp___31 = getushort(f);
#line 153
      cnt = tmp___31 + 1;
#line 153
      printf((char const   */* __restrict  */)"Offset table cnt=%d\n", cnt);
#line 154
      j = 0;
      }
      {
#line 154
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 154
        if (! (j < cnt)) {
#line 154
          goto while_break___1;
        }
        {
#line 155
        tmp___32 = getlong(f);
#line 155
        test = (int )tmp___32;
#line 155
        printf((char const   */* __restrict  */)" Offset to=%d\n", test);
        }
#line 156
        if (bboff == 0L) {
#line 156
          bboff = offsetstart + (long )test;
        }
#line 154
        j ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 160
      if (bboff != 0L) {
        {
#line 161
        fseek(f, bboff, 0);
#line 162
        tmp___33 = getushort(f);
#line 162
        cnt = tmp___33 + 1;
#line 162
        printf((char const   */* __restrict  */)"Number of font bounding boxes: %d\n",
               cnt);
#line 163
        j = 0;
        }
        {
#line 163
        while (1) {
          while_continue___2: /* CIL Label */ ;
#line 163
          if (! (j < cnt)) {
#line 163
            goto while_break___2;
          }
          {
#line 164
          tmp___34 = getushort(f);
#line 164
          printf((char const   */* __restrict  */)"Style = %x\n", tmp___34);
#line 165
          tmp___35 = getushort(f);
#line 165
          printf((char const   */* __restrict  */)" bb left = %g\n", (double )((short )tmp___35) / (double )(1 << 12));
#line 166
          tmp___36 = getushort(f);
#line 166
          printf((char const   */* __restrict  */)" bb bottom = %g\n", (double )((short )tmp___36) / (double )(1 << 12));
#line 167
          tmp___37 = getushort(f);
#line 167
          printf((char const   */* __restrict  */)" bb right = %g\n", (double )((short )tmp___37) / (double )(1 << 12));
#line 168
          tmp___38 = getushort(f);
#line 168
          printf((char const   */* __restrict  */)" bb top = %g\n", (double )((short )tmp___38) / (double )(1 << 12));
#line 163
          j ++;
          }
        }
        while_break___2: /* CIL Label */ ;
        }
      }
    }
#line 172
    if (widoff != 0L) {
      {
#line 173
      fseek(f, widoff, 0);
#line 174
      tmp___39 = getushort(f);
#line 174
      cnt = tmp___39 + 1;
#line 174
      printf((char const   */* __restrict  */)"Style widths entries: %d\n", cnt);
#line 175
      cur->stylewidthcnt = cnt;
#line 176
      tmp___40 = calloc((size_t )cnt, sizeof(struct stylewidths ));
#line 176
      cur->stylewidths = (struct stylewidths *)tmp___40;
#line 177
      j = 0;
      }
      {
#line 177
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 177
        if (! (j < cnt)) {
#line 177
          goto while_break___3;
        }
        {
#line 178
        tmp___41 = getushort(f);
#line 178
        (cur->stylewidths + j)->style = (short )tmp___41;
#line 179
        tmp___42 = malloc((unsigned long )((cur->last - cur->first) + 3) * sizeof(short ));
#line 179
        (cur->stylewidths + j)->widthtab = (short *)tmp___42;
#line 180
        printf((char const   */* __restrict  */)" Style=%x\n", (int )(cur->stylewidths + j)->style);
#line 181
        k = cur->first;
        }
        {
#line 181
        while (1) {
          while_continue___4: /* CIL Label */ ;
#line 181
          if (! (k <= cur->last + 2)) {
#line 181
            goto while_break___4;
          }
          {
#line 182
          tmp___43 = getushort(f);
#line 182
          *((cur->stylewidths + j)->widthtab + k) = (short )tmp___43;
#line 181
          k ++;
          }
        }
        while_break___4: /* CIL Label */ ;
        }
#line 177
        j ++;
      }
      while_break___3: /* CIL Label */ ;
      }
#line 184
      if (cnt > 0) {
#line 185
        if (cnt > 1) {
#line 185
          tmp___44 = " (I\'m not printing out the others)";
        } else {
#line 185
          tmp___44 = "";
        }
        {
#line 185
        printf((char const   */* __restrict  */)"Widths for style %x%s\n", (int )(cur->stylewidths + 0)->style,
               tmp___44);
#line 187
        k = cur->first;
        }
        {
#line 187
        while (1) {
          while_continue___5: /* CIL Label */ ;
#line 187
          if (! (k <= cur->last)) {
#line 187
            goto while_break___5;
          }
#line 188
          if (k >= 32) {
#line 188
            if (k < 127) {
#line 188
              tmp___46 = k;
            } else {
#line 188
              goto _L___0;
            }
          } else {
            _L___0: /* CIL Label */ 
#line 188
            if (k >= 160) {
#line 188
              tmp___45 = k;
            } else {
#line 188
              tmp___45 = ' ';
            }
#line 188
            tmp___46 = tmp___45;
          }
          {
#line 188
          printf((char const   */* __restrict  */)"Width %d (%c): %g\n", k, tmp___46,
                 (double )*((cur->stylewidths + 0)->widthtab + k) / (double )(1 << 12));
#line 187
          k ++;
          }
        }
        while_break___5: /* CIL Label */ ;
        }
      }
    }
#line 192
    if (kernoff != 0L) {
      {
#line 193
      fseek(f, kernoff, 0);
#line 194
      tmp___47 = getushort(f);
#line 194
      cnt = tmp___47 + 1;
#line 194
      printf((char const   */* __restrict  */)"Style kern entries: %d\n", cnt);
#line 195
      cur->stylekerncnt = cnt;
#line 196
      tmp___48 = calloc((size_t )cnt, sizeof(struct stylekerns ));
#line 196
      cur->stylekerns = (struct stylekerns *)tmp___48;
#line 197
      j = 0;
      }
      {
#line 197
      while (1) {
        while_continue___6: /* CIL Label */ ;
#line 197
        if (! (j < cnt)) {
#line 197
          goto while_break___6;
        }
        {
#line 198
        tmp___49 = getushort(f);
#line 198
        (cur->stylekerns + j)->style = (short )tmp___49;
#line 199
        (cur->stylekerns + j)->kernpairs = getushort(f);
#line 200
        tmp___50 = malloc((unsigned long )(cur->stylekerns + j)->kernpairs * sizeof(struct kerns ));
#line 200
        (cur->stylekerns + j)->kerns = (struct kerns *)tmp___50;
#line 201
        printf((char const   */* __restrict  */)" Style=%x kernpairs=%d\n", (int )(cur->stylekerns + j)->style,
               (cur->stylekerns + j)->kernpairs);
#line 202
        k = 0;
        }
        {
#line 202
        while (1) {
          while_continue___7: /* CIL Label */ ;
#line 202
          if (! (k < (cur->stylekerns + j)->kernpairs)) {
#line 202
            goto while_break___7;
          }
          {
#line 203
          tmp___51 = _IO_getc(f);
#line 203
          ((cur->stylekerns + j)->kerns + k)->ch1 = (unsigned char )tmp___51;
#line 204
          tmp___52 = _IO_getc(f);
#line 204
          ((cur->stylekerns + j)->kerns + k)->ch2 = (unsigned char )tmp___52;
#line 205
          tmp___53 = getushort(f);
#line 205
          ((cur->stylekerns + j)->kerns + k)->offset = (short )tmp___53;
#line 202
          k ++;
          }
        }
        while_break___7: /* CIL Label */ ;
        }
#line 197
        j ++;
      }
      while_break___6: /* CIL Label */ ;
      }
    }
#line 209
    if (styleoff != 0L) {
      {
#line 211
      fseek(f, styleoff, 0);
#line 212
      class = getushort(f);
#line 212
      printf((char const   */* __restrict  */)"PS Font Class Flags: %x\n", class);
      }
#line 213
      if (class & 1) {
        {
#line 213
        printf((char const   */* __restrict  */)"  0x1  Font name needs coordinating\n");
        }
      }
#line 214
      if (class & 2) {
        {
#line 214
        printf((char const   */* __restrict  */)"  0x2  Needs MacVector reencoding\n");
        }
      }
#line 215
      if (class & 4) {
        {
#line 215
        printf((char const   */* __restrict  */)"  0x4  Can be outlined with PaintType==2\n");
        }
      }
#line 216
      if (class & 8) {
        {
#line 216
        printf((char const   */* __restrict  */)"  0x8  Do not embolded by smear & white out\n");
        }
      }
#line 217
      if (class & 16) {
        {
#line 217
        printf((char const   */* __restrict  */)"  0x10 Do not embolded by smearing\n");
        }
      }
#line 218
      if (class & 32) {
        {
#line 218
        printf((char const   */* __restrict  */)"  0x20 Embolden by increasing size\n");
        }
      }
#line 219
      if (class & 64) {
        {
#line 219
        printf((char const   */* __restrict  */)"  0x40 Do not oblique font to italicize\n");
        }
      }
#line 220
      if (class & 128) {
        {
#line 220
        printf((char const   */* __restrict  */)"  0x80 No auto-condense\n");
        }
      }
#line 221
      if (class & 256) {
        {
#line 221
        printf((char const   */* __restrict  */)"  0x100 No auto-expand\n");
        }
      }
#line 222
      if (class & 512) {
        {
#line 222
        printf((char const   */* __restrict  */)"  0x200 Needs some other encoding scheme\n");
        }
      }
      {
#line 223
      glyphenc = getlong(f);
#line 223
      printf((char const   */* __restrict  */)" Glyph encoding offset: %d\n", glyphenc);
#line 224
      getlong(f);
#line 226
      tmp___54 = _IO_getc(f);
#line 226
      printf((char const   */* __restrict  */)"Plain index is: %d\n", tmp___54);
#line 227
      tmp___55 = _IO_getc(f);
#line 227
      printf((char const   */* __restrict  */)"Bold index is: %d\n", tmp___55);
#line 228
      tmp___56 = _IO_getc(f);
#line 228
      printf((char const   */* __restrict  */)"Italic index is: %d\n", tmp___56);
#line 229
      j = 3;
      }
      {
#line 229
      while (1) {
        while_continue___8: /* CIL Label */ ;
#line 229
        if (! (j < 48)) {
#line 229
          goto while_break___8;
        }
        {
#line 230
        _IO_getc(f);
#line 229
        j ++;
        }
      }
      while_break___8: /* CIL Label */ ;
      }
      {
#line 231
      cnt = getushort(f);
#line 231
      printf((char const   */* __restrict  */)" String count: %d\n", cnt);
#line 232
      k = _IO_getc(f);
#line 233
      printf((char const   */* __restrict  */)" BaseFontName: \"");
#line 234
      j = 0;
      }
      {
#line 234
      while (1) {
        while_continue___9: /* CIL Label */ ;
#line 234
        if (! (j < k)) {
#line 234
          goto while_break___9;
        }
        {
#line 235
        tmp___57 = _IO_getc(f);
#line 235
        putchar(tmp___57);
#line 234
        j ++;
        }
      }
      while_break___9: /* CIL Label */ ;
      }
      {
#line 236
      printf((char const   */* __restrict  */)"\"\n");
#line 237
      l = 2;
      }
      {
#line 237
      while (1) {
        while_continue___10: /* CIL Label */ ;
#line 237
        if (! (l <= cnt)) {
#line 237
          goto while_break___10;
        }
        {
#line 238
        k = _IO_getc(f);
#line 239
        printf((char const   */* __restrict  */)"String %d, length=%d: ", l, k);
        }
#line 240
        if (k != 0) {
          {
#line 241
          ch = _IO_getc(f);
          }
#line 242
          if (ch < 32) {
            {
#line 243
            printf((char const   */* __restrict  */)"%d,", ch);
#line 244
            j = 1;
            }
            {
#line 244
            while (1) {
              while_continue___11: /* CIL Label */ ;
#line 244
              if (! (j < k)) {
#line 244
                goto while_break___11;
              }
              {
#line 245
              tmp___58 = _IO_getc(f);
#line 245
              printf((char const   */* __restrict  */)"%d,", tmp___58);
#line 244
              j ++;
              }
            }
            while_break___11: /* CIL Label */ ;
            }
          } else {
            {
#line 247
            putchar(ch);
#line 248
            j = 1;
            }
            {
#line 248
            while (1) {
              while_continue___12: /* CIL Label */ ;
#line 248
              if (! (j < k)) {
#line 248
                goto while_break___12;
              }
              {
#line 249
              tmp___59 = _IO_getc(f);
#line 249
              putchar(tmp___59);
#line 248
              j ++;
              }
            }
            while_break___12: /* CIL Label */ ;
            }
          }
        }
        {
#line 252
        putchar('\n');
#line 237
        l ++;
        }
      }
      while_break___10: /* CIL Label */ ;
      }
#line 261
      if (glyphenc != 0L) {
        {
#line 262
        fseek(f, styleoff + glyphenc, 0);
#line 263
        cnt = getushort(f);
#line 263
        printf((char const   */* __restrict  */)"Postscript glyph-name cnt: %d\n",
               cnt);
#line 264
        l = 1;
        }
        {
#line 264
        while (1) {
          while_continue___13: /* CIL Label */ ;
#line 264
          if (! (l <= cnt)) {
#line 264
            goto while_break___13;
          }
          {
#line 265
          tmp___60 = _IO_getc(f);
#line 265
          printf((char const   */* __restrict  */)"  Map encoding 0x%02x to \'", tmp___60);
#line 266
          k = _IO_getc(f);
#line 267
          j = 0;
          }
          {
#line 267
          while (1) {
            while_continue___14: /* CIL Label */ ;
#line 267
            if (! (j < k)) {
#line 267
              goto while_break___14;
            }
            {
#line 268
            tmp___61 = _IO_getc(f);
#line 268
            putchar(tmp___61);
#line 267
            j ++;
            }
          }
          while_break___14: /* CIL Label */ ;
          }
          {
#line 269
          putchar('\'');
#line 270
          putchar('\n');
#line 264
          l ++;
          }
        }
        while_break___13: /* CIL Label */ ;
        }
      }
    }
    {
#line 274
    fseek(f, here, 0);
#line 76
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 276
  fseek(f, start, 0);
  }
#line 277
  return (head);
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static void LoadNFNT___0(FILE *f , struct MacFontRec *font , long offset ) 
{ 
  long here ;
  long tmp ;
  long baseow ;
  long ow ;
  int i ;
  long tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  int tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;
  int tmp___11 ;
  int tmp___12 ;
  int tmp___13 ;
  void *tmp___14 ;
  void *tmp___15 ;
  void *tmp___16 ;
  int tmp___17 ;
  int tmp___18 ;
  int tmp___19 ;

  {
  {
#line 304
  tmp = ftell(f);
#line 304
  here = tmp;
#line 309
  fseek(f, offset, 0);
#line 310
  tmp___0 = getlong(f);
#line 310
  printf((char const   */* __restrict  */)"NFNT length = %d\n", tmp___0);
#line 311
  memset((void *)font, '\000', sizeof(struct MacFontRec ));
#line 312
  tmp___1 = getushort(f);
#line 312
  font->fontType = (short )tmp___1;
#line 313
  tmp___2 = getushort(f);
#line 313
  font->firstChar = (short )tmp___2;
#line 314
  tmp___3 = getushort(f);
#line 314
  font->lastChar = (short )tmp___3;
#line 315
  tmp___4 = getushort(f);
#line 315
  font->widthMax = (short )tmp___4;
#line 316
  tmp___5 = getushort(f);
#line 316
  font->kernMax = (short )tmp___5;
#line 317
  tmp___6 = getushort(f);
#line 317
  font->Descent = (short )tmp___6;
#line 318
  tmp___7 = getushort(f);
#line 318
  font->fRectWidth = (short )tmp___7;
#line 319
  tmp___8 = getushort(f);
#line 319
  font->fRectHeight = (short )tmp___8;
#line 320
  baseow = ftell(f);
#line 321
  tmp___9 = getushort(f);
#line 321
  ow = (long )tmp___9;
#line 322
  tmp___10 = getushort(f);
#line 322
  font->ascent = (short )tmp___10;
#line 323
  tmp___11 = getushort(f);
#line 323
  font->descent = (short )tmp___11;
  }
#line 324
  if ((int )font->Descent >= 0) {
#line 325
    ow |= (long )((int )font->Descent << 16);
#line 326
    font->Descent = (short )(- ((int )font->descent));
  }
  {
#line 328
  tmp___12 = getushort(f);
#line 328
  font->leading = (short )tmp___12;
#line 329
  tmp___13 = getushort(f);
#line 329
  font->rowWords = (short )tmp___13;
#line 330
  tmp___14 = calloc((size_t )((int )font->rowWords * (int )font->fRectHeight), sizeof(short ));
#line 330
  font->fontImage = (unsigned short *)tmp___14;
#line 331
  tmp___15 = calloc((size_t )(((int )font->lastChar - (int )font->firstChar) + 3),
                    sizeof(short ));
#line 331
  font->locs = (unsigned short *)tmp___15;
#line 332
  tmp___16 = calloc((size_t )(((int )font->lastChar - (int )font->firstChar) + 3),
                    sizeof(short ));
#line 332
  font->offsetWidths = (unsigned short *)tmp___16;
#line 333
  i = 0;
  }
  {
#line 333
  while (1) {
    while_continue: /* CIL Label */ ;
#line 333
    if (! (i < (int )font->rowWords * (int )font->fRectHeight)) {
#line 333
      goto while_break;
    }
    {
#line 334
    tmp___17 = getushort(f);
#line 334
    *(font->fontImage + i) = (unsigned short )tmp___17;
#line 333
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 335
  i = 0;
  {
#line 335
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 335
    if (! (i < ((int )font->lastChar - (int )font->firstChar) + 3)) {
#line 335
      goto while_break___0;
    }
    {
#line 336
    tmp___18 = getushort(f);
#line 336
    *(font->locs + i) = (unsigned short )tmp___18;
#line 335
    i ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
  {
#line 337
  fseek(f, baseow + 2L * ow, 0);
#line 338
  i = 0;
  }
  {
#line 338
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 338
    if (! (i < ((int )font->lastChar - (int )font->firstChar) + 3)) {
#line 338
      goto while_break___1;
    }
    {
#line 339
    tmp___19 = getushort(f);
#line 339
    *(font->offsetWidths + i) = (unsigned short )tmp___19;
#line 338
    i ++;
    }
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 340
  fseek(f, here, 0);
  }
#line 341
  return;
}
}
#line 404 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static void SearchPostscriptResources___0(FILE *f , long rlistpos , int subcnt , long rdata_pos ,
                                          long name_list , FOND *fonds ) 
{ 
  long here ;
  long tmp ;
  int rname ;
  int tmp___0 ;
  int ch1 ;
  int ch2 ;
  int i ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 406
  tmp = ftell(f);
#line 406
  here = tmp;
#line 407
  rname = -1;
#line 414
  fseek(f, rlistpos, 0);
#line 415
  i = 0;
  }
  {
#line 415
  while (1) {
    while_continue: /* CIL Label */ ;
#line 415
    if (! (i < subcnt)) {
#line 415
      goto while_break;
    }
    {
#line 416
    tmp___1 = getushort(f);
#line 416
    printf((char const   */* __restrict  */)"post ResId=%d\n", tmp___1);
#line 417
    tmp___2 = feof(f);
    }
#line 417
    if (tmp___2) {
      {
#line 418
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF found in POST list after reading %d resources of %d.\n",
              i, subcnt);
      }
#line 419
      goto while_break;
    }
    {
#line 421
    tmp___3 = getushort(f);
#line 421
    tmp___0 = (int )((short )tmp___3);
    }
#line 422
    if (rname == -1) {
#line 422
      rname = tmp___0;
    }
    {
#line 423
    tmp___4 = _IO_getc(f);
#line 423
    printf((char const   */* __restrict  */)" resource flags=%x\n", tmp___4);
#line 424
    ch1 = _IO_getc(f);
#line 424
    ch2 = _IO_getc(f);
#line 425
    _IO_getc(f);
#line 426
    getlong(f);
#line 415
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 428
  fseek(f, here, 0);
  }
#line 429
  return;
}
}
#line 431 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int getttfname(FILE *ttf , char *buffer___0 , long offset ) 
{ 
  int version ;
  int isotf ;
  int i ;
  int num ;
  int nameoffset ;
  int stringoffset ;
  int fullval ;
  int famval ;
  int fullstr ;
  int famstr ;
  int fulllen ;
  int famlen ;
  int val ;
  int tag ;
  int plat ;
  int spec ;
  int lang ;
  int name ;
  int len ;
  int off ;
  int ch ;
  char *pt ;
  long tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  char *tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 432
  isotf = 0;
#line 438
  offset += 4L;
#line 439
  fseek(ttf, offset, 0);
#line 440
  tmp = getlong(ttf);
#line 440
  version = (int )tmp;
  }
#line 440
  if (version == ((((79 << 24) | (84 << 16)) | (84 << 8)) | 79)) {
#line 441
    isotf = 1;
  } else
#line 442
  if (version != 65536) {
#line 442
    if (version != ((((116 << 24) | (114 << 16)) | (117 << 8)) | 101)) {
#line 443
      return (0);
    }
  }
  {
#line 445
  num = getushort(ttf);
#line 446
  getushort(ttf);
#line 447
  getushort(ttf);
#line 448
  getushort(ttf);
#line 449
  i = 0;
  }
  {
#line 449
  while (1) {
    while_continue: /* CIL Label */ ;
#line 449
    if (! (i < num)) {
#line 449
      goto while_break;
    }
    {
#line 450
    tmp___0 = getlong(ttf);
#line 450
    tag = (int )tmp___0;
#line 451
    getlong(ttf);
#line 452
    tmp___1 = getlong(ttf);
#line 452
    nameoffset = (int )(tmp___1 + offset);
#line 453
    getlong(ttf);
    }
#line 454
    if (tag == ((((110 << 24) | (97 << 16)) | (109 << 8)) | 101)) {
#line 455
      goto while_break;
    }
#line 449
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 457
  if (i == num) {
#line 458
    return (0);
  }
  {
#line 460
  fseek(ttf, (long )nameoffset, 0);
#line 461
  getushort(ttf);
#line 462
  num = getushort(ttf);
#line 463
  tmp___2 = getushort(ttf);
#line 463
  stringoffset = nameoffset + tmp___2;
#line 464
  famval = 0;
#line 464
  fullval = famval;
#line 465
  i = 0;
  }
  {
#line 465
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 465
    if (! (i < num)) {
#line 465
      goto while_break___0;
    }
    {
#line 466
    plat = getushort(ttf);
#line 467
    spec = getushort(ttf);
#line 468
    lang = getushort(ttf);
#line 469
    name = getushort(ttf);
#line 470
    len = getushort(ttf);
#line 471
    off = getushort(ttf);
#line 472
    val = 0;
    }
#line 473
    if (plat == 0) {
#line 473
      if (lang == 0) {
#line 474
        val = 1;
      } else {
#line 473
        goto _L___1;
      }
    } else
    _L___1: /* CIL Label */ 
#line 475
    if (plat == 3) {
#line 475
      if (spec == 1) {
#line 475
        if (lang == 1033) {
#line 476
          val = 2;
        } else {
#line 475
          goto _L___0;
        }
      } else {
#line 475
        goto _L___0;
      }
    } else
    _L___0: /* CIL Label */ 
#line 477
    if (plat == 1) {
#line 477
      if (spec == 0) {
#line 478
        val = 3;
      }
    }
#line 479
    if (name == 4) {
#line 479
      if (val > fullval) {
#line 480
        fullval = val;
#line 481
        fullstr = off;
#line 482
        fulllen = len;
#line 483
        if (val == 2) {
#line 484
          goto while_break___0;
        } else
#line 483
        if (val == 3) {
#line 484
          goto while_break___0;
        }
      } else {
#line 479
        goto _L___2;
      }
    } else
    _L___2: /* CIL Label */ 
#line 485
    if (name == 1) {
#line 485
      if (val > famval) {
#line 486
        famval = val;
#line 487
        famstr = off;
#line 488
        famlen = len;
      }
    }
#line 465
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 491
  if (fullval == 0) {
#line 492
    if (famval == 0) {
#line 493
      return (0);
    }
#line 494
    fullstr = famstr;
#line 495
    fulllen = famlen;
  }
  {
#line 498
  fseek(ttf, (long )(stringoffset + fullstr), 0);
#line 499
  pt = buffer___0;
  }
#line 500
  if (val == 3) {
#line 501
    i = 0;
    {
#line 501
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 501
      if (! (i < len)) {
#line 501
        goto while_break___1;
      }
      {
#line 502
      ch = _IO_getc(ttf);
      }
#line 504
      if (ch > 33) {
#line 504
        if (ch != 42) {
#line 504
          if (ch != 63) {
#line 504
            if (ch != 47) {
#line 504
              if (ch != 92) {
#line 504
                if (ch < 127) {
#line 505
                  tmp___3 = pt;
#line 505
                  pt ++;
#line 505
                  *tmp___3 = (char )ch;
                }
              }
            }
          }
        }
      }
#line 501
      i ++;
    }
    while_break___1: /* CIL Label */ ;
    }
  } else {
#line 508
    i = 0;
    {
#line 508
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 508
      if (! (i < len / 2)) {
#line 508
        goto while_break___2;
      }
      {
#line 509
      _IO_getc(ttf);
#line 510
      ch = _IO_getc(ttf);
      }
#line 512
      if (ch > 33) {
#line 512
        if (ch != 42) {
#line 512
          if (ch != 63) {
#line 512
            if (ch != 47) {
#line 512
              if (ch != 92) {
#line 512
                if (ch < 127) {
#line 513
                  tmp___4 = pt;
#line 513
                  pt ++;
#line 513
                  *tmp___4 = (char )ch;
                }
              }
            }
          }
        }
      }
#line 508
      i ++;
    }
    while_break___2: /* CIL Label */ ;
    }
  }
#line 516
  *pt = (char )'\000';
#line 518
  return (1);
}
}
#line 521 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static void SearchTtfResources___0(FILE *f , long rlistpos , int subcnt , long rdata_pos ,
                                   long name_list , FOND *fonds ) 
{ 
  long start ;
  long tmp ;
  long here ;
  long roff ;
  int rname ;
  int ch1 ;
  int ch2 ;
  int i ;
  char buffer___0[200] ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
  {
#line 523
  tmp = ftell(f);
#line 523
  start = tmp;
#line 525
  rname = -1;
#line 530
  fseek(f, rlistpos, 0);
#line 531
  i = 0;
  }
  {
#line 531
  while (1) {
    while_continue: /* CIL Label */ ;
#line 531
    if (! (i < subcnt)) {
#line 531
      goto while_break;
    }
    {
#line 532
    tmp___0 = getushort(f);
#line 532
    printf((char const   */* __restrict  */)"sfnt res=%d\n", tmp___0);
#line 533
    tmp___1 = feof(f);
    }
#line 533
    if (tmp___1) {
      {
#line 534
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"EOF found in sfnt list after reading %d resources of %d.\n",
              i, subcnt);
      }
#line 535
      goto while_break;
    }
    {
#line 537
    tmp___2 = getushort(f);
#line 537
    rname = (int )((short )tmp___2);
#line 538
    tmp___3 = _IO_getc(f);
#line 538
    printf((char const   */* __restrict  */)" resource flags=%x\n", tmp___3);
#line 539
    ch1 = _IO_getc(f);
#line 539
    ch2 = _IO_getc(f);
#line 540
    tmp___4 = _IO_getc(f);
#line 540
    roff = rdata_pos + (long )(((ch1 << 16) | (ch2 << 8)) | tmp___4);
#line 541
    getlong(f);
#line 542
    here = ftell(f);
#line 543
    tmp___5 = getttfname(f, buffer___0, roff);
    }
#line 543
    if (tmp___5) {
      {
#line 544
      printf((char const   */* __restrict  */)"\tFontName=%s\n", buffer___0);
      }
    }
    {
#line 545
    fseek(f, here, 0);
#line 531
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 547
  fseek(f, start, 0);
  }
#line 548
  return;
}
}
#line 550 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int IsResourceFork___2(FILE *f , long offset ) 
{ 
  unsigned char buffer___0[16] ;
  unsigned char buffer2[16] ;
  long rdata_pos ;
  long map_pos ;
  long type_list ;
  long name_list ;
  long rpos ;
  unsigned long tag ;
  int i ;
  int cnt ;
  int subcnt ;
  FOND *fondlist ;
  size_t tmp ;
  size_t tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  long tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  long tmp___8 ;
  int tmp___9 ;
  int tmp___10 ;

  {
  {
#line 560
  fondlist = (FOND *)((void *)0);
#line 562
  fseek(f, offset, 0);
#line 563
  tmp = fread((void */* __restrict  */)(buffer___0), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
#line 563
  if (tmp != 16UL) {
#line 564
    return (0);
  }
  {
#line 565
  rdata_pos = offset + (long )(((((int )buffer___0[0] << 24) | ((int )buffer___0[1] << 16)) | ((int )buffer___0[2] << 8)) | (int )buffer___0[3]);
#line 566
  map_pos = offset + (long )(((((int )buffer___0[4] << 24) | ((int )buffer___0[5] << 16)) | ((int )buffer___0[6] << 8)) | (int )buffer___0[7]);
#line 567
  fseek(f, map_pos, 0);
#line 568
  buffer2[15] = (unsigned char )((int )buffer___0[15] + 1);
#line 569
  tmp___0 = fread((void */* __restrict  */)(buffer2), (size_t )1, (size_t )16, (FILE */* __restrict  */)f);
  }
#line 569
  if (tmp___0 != 16UL) {
#line 570
    return (0);
  }
#line 574
  i = 0;
  {
#line 574
  while (1) {
    while_continue: /* CIL Label */ ;
#line 574
    if (! (i < 16)) {
#line 574
      goto while_break;
    }
#line 575
    if ((int )buffer2[i] != 0) {
#line 576
      goto while_break;
    }
#line 574
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 577
  if (i != 16) {
#line 578
    i = 0;
    {
#line 578
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 578
      if (! (i < 16)) {
#line 578
        goto while_break___0;
      }
#line 579
      if ((int )buffer___0[i] != (int )buffer2[i]) {
#line 580
        return (0);
      }
#line 578
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
  }
  {
#line 581
  getlong(f);
#line 582
  getushort(f);
#line 583
  getushort(f);
#line 584
  tmp___1 = getushort(f);
#line 584
  type_list = map_pos + (long )tmp___1;
#line 585
  tmp___2 = getushort(f);
#line 585
  name_list = map_pos + (long )tmp___2;
#line 587
  fseek(f, type_list, 0);
#line 588
  tmp___3 = getushort(f);
#line 588
  cnt = tmp___3 + 1;
#line 589
  i = 0;
  }
  {
#line 589
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 589
    if (! (i < cnt)) {
#line 589
      goto while_break___1;
    }
    {
#line 590
    tmp___4 = getlong(f);
#line 590
    tag = (unsigned long )tmp___4;
#line 591
    tmp___5 = getushort(f);
#line 591
    subcnt = tmp___5 + 1;
#line 592
    tmp___6 = getushort(f);
#line 592
    rpos = type_list + (long )tmp___6;
    }
#line 593
    if (tag == (unsigned long )((((70 << 24) | (79 << 16)) | (78 << 8)) | 68)) {
      {
#line 594
      fondlist = BuildFondList___0(f, rpos, subcnt, rdata_pos, name_list);
      }
    }
#line 589
    i ++;
  }
  while_break___1: /* CIL Label */ ;
  }
  {
#line 597
  fseek(f, type_list, 0);
#line 598
  tmp___7 = getushort(f);
#line 598
  cnt = tmp___7 + 1;
#line 599
  i = 0;
  }
  {
#line 599
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 599
    if (! (i < cnt)) {
#line 599
      goto while_break___2;
    }
    {
#line 600
    tmp___8 = getlong(f);
#line 600
    tag = (unsigned long )tmp___8;
#line 601
    printf((char const   */* __restrict  */)"%c%c%c%c\n", tag >> 24, (tag >> 16) & 255UL,
           (tag >> 8) & 255UL, tag & 255UL);
#line 602
    tmp___9 = getushort(f);
#line 602
    subcnt = tmp___9 + 1;
#line 603
    tmp___10 = getushort(f);
#line 603
    rpos = type_list + (long )tmp___10;
    }
#line 604
    if (tag == (unsigned long )((((80 << 24) | (79 << 16)) | (83 << 8)) | 84)) {
      {
#line 605
      SearchPostscriptResources___0(f, rpos, subcnt, rdata_pos, name_list, fondlist);
      }
    } else
#line 606
    if (! (tag == (unsigned long )((((70 << 24) | (79 << 16)) | (78 << 8)) | 84))) {
#line 608
      if (tag == (unsigned long )((((78 << 24) | (70 << 16)) | (78 << 8)) | 84)) {
        {
#line 609
        SearchNFNTResources(f, rpos, subcnt, rdata_pos, name_list, fondlist);
        }
      } else
#line 610
      if (tag == (unsigned long )((((115 << 24) | (102 << 16)) | (110 << 8)) | 116)) {
        {
#line 611
        SearchTtfResources___0(f, rpos, subcnt, rdata_pos, name_list, fondlist);
        }
      }
    }
#line 599
    i ++;
  }
  while_break___2: /* CIL Label */ ;
  }
#line 615
  return (1);
}
}
#line 618 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int HasResourceFork___2(char *filename ) 
{ 
  char *respath ;
  size_t tmp ;
  size_t tmp___0 ;
  void *tmp___1 ;
  FILE *temp ;
  int ret ;

  {
  {
#line 622
  tmp = strlen((char const   *)filename);
#line 622
  tmp___0 = strlen("/rsrc");
#line 622
  tmp___1 = malloc((tmp + tmp___0) + 1UL);
#line 622
  respath = (char *)tmp___1;
#line 624
  ret = 0;
#line 626
  strcpy((char */* __restrict  */)respath, (char const   */* __restrict  */)filename);
#line 627
  strcat((char */* __restrict  */)respath, (char const   */* __restrict  */)"/rsrc");
#line 628
  temp = fopen((char const   */* __restrict  */)respath, (char const   */* __restrict  */)"r");
#line 629
  free((void *)respath);
  }
#line 630
  if ((unsigned long )temp != (unsigned long )((void *)0)) {
    {
#line 631
    ret = IsResourceFork___2(temp, 0L);
#line 632
    fclose(temp);
    }
  }
#line 634
  return (ret);
}
}
#line 637 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int IsResourceInBinary___2(FILE *f ) 
{ 
  unsigned char header[128] ;
  unsigned long offset ;
  size_t tmp ;
  int tmp___0 ;

  {
  {
#line 641
  tmp = fread((void */* __restrict  */)(header), (size_t )1, (size_t )128, (FILE */* __restrict  */)f);
  }
#line 641
  if (tmp != 128UL) {
#line 642
    return (0);
  }
#line 643
  if ((int )header[0] != 0) {
#line 645
    return (0);
  } else
#line 643
  if ((int )header[74] != 0) {
#line 645
    return (0);
  } else
#line 643
  if ((int )header[82] != 0) {
#line 645
    return (0);
  } else
#line 643
  if ((int )header[1] <= 0) {
#line 645
    return (0);
  } else
#line 643
  if ((int )header[1] > 33) {
#line 645
    return (0);
  } else
#line 643
  if ((int )header[63] != 0) {
#line 645
    return (0);
  } else
#line 643
  if ((int )header[2 + (int )header[1]] != 0) {
#line 645
    return (0);
  }
  {
#line 646
  offset = (unsigned long )(128 + (((((int )header[83] << 24) | ((int )header[84] << 16)) | ((int )header[85] << 8)) | (int )header[86]));
#line 647
  tmp___0 = IsResourceFork___2(f, (long )offset);
  }
#line 647
  return (tmp___0);
}
}
#line 650 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int lastch___2  =    0;
#line 650 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int repeat___2  =    0;
#line 651 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static void outchr___2(FILE *binary , int ch ) 
{ 
  int i ;

  {
#line 654
  if (repeat___2) {
#line 655
    if (ch == 0) {
      {
#line 657
      lastch___2 = 144;
#line 658
      _IO_putc(lastch___2, binary);
      }
    } else {
#line 660
      i = 1;
      {
#line 660
      while (1) {
        while_continue: /* CIL Label */ ;
#line 660
        if (! (i < ch)) {
#line 660
          goto while_break;
        }
        {
#line 661
        _IO_putc(lastch___2, binary);
#line 660
        i ++;
        }
      }
      while_break: /* CIL Label */ ;
      }
    }
#line 663
    repeat___2 = 0;
  } else
#line 664
  if (ch == 144) {
#line 665
    repeat___2 = 1;
  } else {
    {
#line 667
    _IO_putc(ch, binary);
#line 668
    lastch___2 = ch;
    }
  }
#line 670
  return;
}
}
#line 672 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int IsResourceInHex___2(FILE *f ) 
{ 
  FILE *binary ;
  FILE *tmp ;
  char *sixbit ;
  int ch ;
  int val ;
  int cnt ;
  int i ;
  int dlen ;
  int rlen ;
  int ret ;
  char header[20] ;
  char *pt ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  long tmp___2 ;

  {
  {
#line 675
  tmp = tmpfile();
#line 675
  binary = tmp;
#line 676
  sixbit = (char *)"!\"#$%&\'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr";
  }
#line 680
  if ((unsigned long )binary == (unsigned long )((void *)0)) {
    {
#line 681
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"can\'t create temporary file\n");
    }
#line 682
    return (0);
  }
#line 685
  repeat___2 = 0;
#line 685
  lastch___2 = repeat___2;
  {
#line 686
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 686
    ch = _IO_getc(f);
    }
#line 686
    if (! (ch != 58)) {
#line 686
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 687
  val = 0;
#line 687
  cnt = val;
  {
#line 688
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 688
    ch = _IO_getc(f);
    }
#line 688
    if (! (ch != 58)) {
#line 688
      goto while_break___0;
    }
    {
#line 689
    tmp___0 = __ctype_b_loc();
    }
#line 689
    if ((int const   )*(*tmp___0 + ch) & 8192) {
#line 690
      goto while_continue___0;
    }
#line 691
    pt = sixbit;
    {
#line 691
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 691
      if ((int )*pt != ch) {
#line 691
        if (! ((int )*pt != 0)) {
#line 691
          goto while_break___1;
        }
      } else {
#line 691
        goto while_break___1;
      }
#line 691
      pt ++;
    }
    while_break___1: /* CIL Label */ ;
    }
#line 692
    if ((int )*pt == 0) {
      {
#line 693
      fclose(binary);
      }
#line 694
      return (0);
    }
#line 696
    val = (int )((long )(val << 6) | (pt - sixbit));
#line 697
    cnt ++;
#line 697
    if (cnt == 4) {
      {
#line 698
      outchr___2(binary, (val >> 16) & 255);
#line 699
      outchr___2(binary, (val >> 8) & 255);
#line 700
      outchr___2(binary, val & 255);
#line 701
      cnt = 0;
#line 701
      val = cnt;
      }
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 704
  if (cnt != 0) {
#line 705
    if (cnt == 1) {
      {
#line 706
      outchr___2(binary, val << 2);
      }
    } else
#line 707
    if (cnt == 2) {
      {
#line 708
      val <<= 4;
#line 709
      outchr___2(binary, (val >> 8) & 255);
#line 710
      outchr___2(binary, val & 255);
      }
    } else
#line 711
    if (cnt == 3) {
      {
#line 712
      val <<= 6;
#line 713
      outchr___2(binary, (val >> 16) & 255);
#line 714
      outchr___2(binary, (val >> 8) & 255);
#line 715
      outchr___2(binary, val & 255);
      }
    }
  }
  {
#line 719
  rewind(binary);
#line 720
  ch = _IO_getc(binary);
#line 722
  i = 0;
  }
  {
#line 722
  while (1) {
    while_continue___2: /* CIL Label */ ;
#line 722
    if (! (i < ch)) {
#line 722
      goto while_break___2;
    }
    {
#line 723
    _IO_getc(binary);
#line 722
    i ++;
    }
  }
  while_break___2: /* CIL Label */ ;
  }
  {
#line 724
  tmp___1 = _IO_getc(binary);
  }
#line 724
  if (tmp___1 != 0) {
    {
#line 725
    fclose(binary);
    }
#line 726
    return (0);
  }
  {
#line 728
  fread((void */* __restrict  */)(header), (size_t )1, (size_t )20, (FILE */* __restrict  */)binary);
#line 729
  dlen = ((((int )header[10] << 24) | ((int )header[11] << 16)) | ((int )header[12] << 8)) | (int )header[13];
#line 730
  rlen = ((((int )header[14] << 24) | ((int )header[15] << 16)) | ((int )header[16] << 8)) | (int )header[17];
  }
#line 731
  if (rlen == 0) {
    {
#line 732
    fclose(binary);
    }
#line 733
    return (0);
  }
  {
#line 736
  tmp___2 = ftell(binary);
#line 736
  ret = IsResourceFork___2(binary, (tmp___2 + (long )dlen) + 2L);
#line 737
  fclose(binary);
  }
#line 738
  return (ret);
}
}
#line 741 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int IsResourceInFile___2(char *filename ) 
{ 
  FILE *f ;
  char *spt ;
  char *pt ;
  int ret ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 746
  f = fopen((char const   */* __restrict  */)filename, (char const   */* __restrict  */)"r");
  }
#line 747
  if ((unsigned long )f == (unsigned long )((void *)0)) {
#line 748
    return (0);
  }
  {
#line 749
  spt = strrchr((char const   *)filename, '/');
  }
#line 750
  if ((unsigned long )spt == (unsigned long )((void *)0)) {
#line 750
    spt = filename;
  }
  {
#line 751
  pt = strrchr((char const   *)spt, '.');
  }
#line 752
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 752
    if ((int )*(pt + 1) == 98) {
#line 752
      goto _L___8;
    } else
#line 752
    if ((int )*(pt + 1) == 66) {
      _L___8: /* CIL Label */ 
#line 752
      if ((int )*(pt + 2) == 105) {
#line 752
        goto _L___6;
      } else
#line 752
      if ((int )*(pt + 2) == 73) {
        _L___6: /* CIL Label */ 
#line 752
        if ((int )*(pt + 3) == 110) {
#line 752
          goto _L___4;
        } else
#line 752
        if ((int )*(pt + 3) == 78) {
          _L___4: /* CIL Label */ 
#line 752
          if ((int )*(pt + 4) == 0) {
            {
#line 754
            tmp = IsResourceInBinary___2(f);
            }
#line 754
            if (tmp) {
              {
#line 755
              fclose(f);
              }
#line 756
              return (1);
            }
          } else {
#line 752
            goto _L___7;
          }
        } else {
#line 752
          goto _L___7;
        }
      } else {
#line 752
        goto _L___7;
      }
    } else {
#line 752
      goto _L___7;
    }
  } else
  _L___7: /* CIL Label */ 
#line 758
  if ((unsigned long )pt != (unsigned long )((void *)0)) {
#line 758
    if ((int )*(pt + 1) == 104) {
#line 758
      goto _L___1;
    } else
#line 758
    if ((int )*(pt + 1) == 72) {
      _L___1: /* CIL Label */ 
#line 758
      if ((int )*(pt + 2) == 113) {
#line 758
        goto _L___0;
      } else
#line 758
      if ((int )*(pt + 2) == 81) {
        _L___0: /* CIL Label */ 
#line 758
        if ((int )*(pt + 3) == 120) {
#line 758
          goto _L;
        } else
#line 758
        if ((int )*(pt + 3) == 88) {
          _L: /* CIL Label */ 
#line 758
          if ((int )*(pt + 4) == 0) {
            {
#line 760
            tmp___0 = IsResourceInHex___2(f);
            }
#line 760
            if (tmp___0) {
              {
#line 761
              fclose(f);
              }
#line 762
              return (1);
            }
          }
        }
      }
    }
  }
  {
#line 766
  ret = IsResourceFork___2(f, 0L);
#line 767
  fclose(f);
  }
#line 768
  if (! ret) {
    {
#line 769
    ret = HasResourceFork___2(filename);
    }
  }
#line 770
  return (ret);
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/fondu-0.0.20060102/showfond.c"
static int FindResourceFile___1(char *filename ) 
{ 
  char *spt ;
  char *pt ;
  char *dpt ;
  char buffer___0[1400] ;
  int tmp ;
  int tmp___0 ;
  char *tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  size_t tmp___4 ;
  char exten[8] ;
  char *tmp___5 ;
  char *tmp___6 ;
  size_t tmp___7 ;
  int tmp___8 ;

  {
  {
#line 777
  tmp = IsResourceInFile___2(filename);
  }
#line 777
  if (tmp) {
#line 778
    return (1);
  }
  {
#line 782
  strcpy((char */* __restrict  */)(buffer___0), (char const   */* __restrict  */)filename);
#line 783
  spt = strrchr((char const   *)(buffer___0), '/');
  }
#line 784
  if ((unsigned long )spt == (unsigned long )((void *)0)) {
#line 784
    spt = buffer___0;
#line 784
    pt = filename;
  } else {
#line 785
    spt ++;
#line 785
    pt = filename + (spt - buffer___0);
  }
  {
#line 786
  strcpy((char */* __restrict  */)spt, (char const   */* __restrict  */)"resource.frk/");
#line 787
  strcat((char */* __restrict  */)spt, (char const   */* __restrict  */)pt);
#line 788
  tmp___0 = IsResourceInFile___2(buffer___0);
  }
#line 788
  if (tmp___0) {
#line 789
    return (1);
  }
  {
#line 793
  tmp___1 = strrchr((char const   *)(buffer___0), '/');
#line 793
  spt = tmp___1 + 1;
#line 794
  pt = spt;
  }
  {
#line 794
  while (1) {
    while_continue: /* CIL Label */ ;
#line 794
    if (! *pt) {
#line 794
      goto while_break;
    }
    {
#line 795
    tmp___3 = __ctype_b_loc();
    }
#line 795
    if ((int const   )*(*tmp___3 + (int )*pt) & 256) {
      {
#line 796
      tmp___2 = tolower((int )*pt);
#line 796
      *pt = (char )tmp___2;
      }
    }
#line 794
    pt ++;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 797
  dpt = strchr((char const   *)spt, '.');
  }
#line 798
  if ((unsigned long )dpt == (unsigned long )((void *)0)) {
    {
#line 798
    tmp___4 = strlen((char const   *)spt);
#line 798
    dpt = spt + tmp___4;
    }
  }
#line 799
  if (dpt - spt > 8L) {
#line 799
    goto _L;
  } else {
    {
#line 799
    tmp___7 = strlen((char const   *)dpt);
    }
#line 799
    if (tmp___7 > 4UL) {
      _L: /* CIL Label */ 
      {
#line 801
      strncpy((char */* __restrict  */)(exten), (char const   */* __restrict  */)dpt,
              (size_t )7);
#line 802
      exten[4] = (char )'\000';
      }
#line 803
      if (dpt - spt > 6L) {
#line 804
        dpt = spt + 6;
      }
      {
#line 805
      tmp___5 = dpt;
#line 805
      dpt ++;
#line 805
      *tmp___5 = (char )'~';
#line 806
      tmp___6 = dpt;
#line 806
      dpt ++;
#line 806
      *tmp___6 = (char )'1';
#line 807
      strcpy((char */* __restrict  */)dpt, (char const   */* __restrict  */)(exten));
      }
    }
  }
  {
#line 809
  tmp___8 = IsResourceInFile___2(buffer___0);
  }
#line 809
  return (tmp___8);
}
}
