/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 125 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __uid_t;
#line 126 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __gid_t;
#line 127 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __ino_t;
#line 129 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned int __mode_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 133 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __pid_t;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 144 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef int __key_t;
#line 172 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __ssize_t;
#line 175 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __syscall_slong_t;
#line 177 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef unsigned long __syscall_ulong_t;
#line 104 "/usr/include/getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 220 "/usr/include/unistd.h"
typedef __ssize_t ssize_t;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 260 "/usr/include/unistd.h"
typedef __pid_t pid_t;
#line 122 "/usr/include/x86_64-linux-gnu/sys/types.h"
typedef __key_t key_t;
#line 75 "/usr/include/time.h"
typedef __time_t time_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 54 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef long __fd_mask;
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
struct __anonstruct_fd_set_7 {
   __fd_mask fds_bits[1024 / (8 * (int )sizeof(__fd_mask ))] ;
};
#line 64 "/usr/include/x86_64-linux-gnu/sys/select.h"
typedef struct __anonstruct_fd_set_7 fd_set;
#line 27 "/usr/include/x86_64-linux-gnu/bits/ioctl-types.h"
struct winsize {
   unsigned short ws_row ;
   unsigned short ws_col ;
   unsigned short ws_xpixel ;
   unsigned short ws_ypixel ;
};
#line 23 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned char cc_t;
#line 24 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int speed_t;
#line 25 "/usr/include/x86_64-linux-gnu/bits/termios.h"
typedef unsigned int tcflag_t;
#line 28 "/usr/include/x86_64-linux-gnu/bits/termios.h"
struct termios {
   tcflag_t c_iflag ;
   tcflag_t c_oflag ;
   tcflag_t c_cflag ;
   tcflag_t c_lflag ;
   cc_t c_line ;
   cc_t c_cc[32] ;
   speed_t c_ispeed ;
   speed_t c_ospeed ;
};
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 22 "/usr/include/x86_64-linux-gnu/bits/dirent.h"
struct dirent {
   __ino_t d_ino ;
   __off_t d_off ;
   unsigned short d_reclen ;
   unsigned char d_type ;
   char d_name[256] ;
};
#line 127 "/usr/include/dirent.h"
struct __dirstream;
#line 127 "/usr/include/dirent.h"
typedef struct __dirstream DIR;
#line 85 "/usr/include/signal.h"
typedef void (*__sighandler_t)(int  );
#line 60 "/usr/include/x86_64-linux-gnu/sys/wait.h"
union wait;
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_terminated_47 {
   unsigned int __w_termsig : 7 ;
   unsigned int __w_coredump : 1 ;
   unsigned int __w_retcode : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
struct __anonstruct___wait_stopped_48 {
   unsigned int __w_stopval : 8 ;
   unsigned int __w_stopsig : 8 ;
   unsigned int  : 16 ;
};
#line 66 "/usr/include/x86_64-linux-gnu/bits/waitstatus.h"
union wait {
   int w_status ;
   struct __anonstruct___wait_terminated_47 __wait_terminated ;
   struct __anonstruct___wait_stopped_48 __wait_stopped ;
};
#line 155 "/usr/include/x86_64-linux-gnu/sys/wait.h"
struct rusage;
#line 155
struct rusage;
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_49 {
   long ru_maxrss ;
   __syscall_slong_t __ru_maxrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_50 {
   long ru_ixrss ;
   __syscall_slong_t __ru_ixrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_51 {
   long ru_idrss ;
   __syscall_slong_t __ru_idrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_52 {
   long ru_isrss ;
   __syscall_slong_t __ru_isrss_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_53 {
   long ru_minflt ;
   __syscall_slong_t __ru_minflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_54 {
   long ru_majflt ;
   __syscall_slong_t __ru_majflt_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_55 {
   long ru_nswap ;
   __syscall_slong_t __ru_nswap_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_56 {
   long ru_inblock ;
   __syscall_slong_t __ru_inblock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_57 {
   long ru_oublock ;
   __syscall_slong_t __ru_oublock_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_58 {
   long ru_msgsnd ;
   __syscall_slong_t __ru_msgsnd_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_59 {
   long ru_msgrcv ;
   __syscall_slong_t __ru_msgrcv_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_60 {
   long ru_nsignals ;
   __syscall_slong_t __ru_nsignals_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_61 {
   long ru_nvcsw ;
   __syscall_slong_t __ru_nvcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
union __anonunion____missing_field_name_62 {
   long ru_nivcsw ;
   __syscall_slong_t __ru_nivcsw_word ;
};
#line 187 "/usr/include/x86_64-linux-gnu/bits/resource.h"
struct rusage {
   struct timeval ru_utime ;
   struct timeval ru_stime ;
   union __anonunion____missing_field_name_49 __annonCompField2 ;
   union __anonunion____missing_field_name_50 __annonCompField3 ;
   union __anonunion____missing_field_name_51 __annonCompField4 ;
   union __anonunion____missing_field_name_52 __annonCompField5 ;
   union __anonunion____missing_field_name_53 __annonCompField6 ;
   union __anonunion____missing_field_name_54 __annonCompField7 ;
   union __anonunion____missing_field_name_55 __annonCompField8 ;
   union __anonunion____missing_field_name_56 __annonCompField9 ;
   union __anonunion____missing_field_name_57 __annonCompField10 ;
   union __anonunion____missing_field_name_58 __annonCompField11 ;
   union __anonunion____missing_field_name_59 __annonCompField12 ;
   union __anonunion____missing_field_name_60 __annonCompField13 ;
   union __anonunion____missing_field_name_61 __annonCompField14 ;
   union __anonunion____missing_field_name_62 __annonCompField15 ;
};
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
#line 42 "/usr/include/x86_64-linux-gnu/bits/ipc.h"
struct ipc_perm {
   __key_t __key ;
   __uid_t uid ;
   __gid_t gid ;
   __uid_t cuid ;
   __gid_t cgid ;
   unsigned short mode ;
   unsigned short __pad1 ;
   unsigned short __seq ;
   unsigned short __pad2 ;
   __syscall_ulong_t __glibc_reserved1 ;
   __syscall_ulong_t __glibc_reserved2 ;
};
#line 38 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct semid_ds {
   struct ipc_perm sem_perm ;
   __time_t sem_otime ;
   __syscall_ulong_t __glibc_reserved1 ;
   __time_t sem_ctime ;
   __syscall_ulong_t __glibc_reserved2 ;
   __syscall_ulong_t sem_nsems ;
   __syscall_ulong_t __glibc_reserved3 ;
   __syscall_ulong_t __glibc_reserved4 ;
};
#line 72 "/usr/include/x86_64-linux-gnu/bits/sem.h"
struct seminfo {
   int semmap ;
   int semmni ;
   int semmns ;
   int semmnu ;
   int semmsl ;
   int semopm ;
   int semume ;
   int semusz ;
   int semvmx ;
   int semaem ;
};
#line 41 "/usr/include/x86_64-linux-gnu/sys/sem.h"
struct sembuf {
   unsigned short sem_num ;
   short sem_op ;
   short sem_flg ;
};
#line 43 "/usr/include/regex.h"
typedef unsigned long reg_syntax_t;
#line 368 "/usr/include/regex.h"
struct re_pattern_buffer {
   unsigned char *buffer ;
   unsigned long allocated ;
   unsigned long used ;
   reg_syntax_t syntax ;
   char *fastmap ;
   unsigned char *translate ;
   size_t re_nsub ;
   unsigned int can_be_null : 1 ;
   unsigned int regs_allocated : 2 ;
   unsigned int fastmap_accurate : 1 ;
   unsigned int no_sub : 1 ;
   unsigned int not_bol : 1 ;
   unsigned int not_eol : 1 ;
   unsigned int newline_anchor : 1 ;
};
#line 434 "/usr/include/regex.h"
typedef struct re_pattern_buffer regex_t;
#line 437 "/usr/include/regex.h"
typedef int regoff_t;
#line 463 "/usr/include/regex.h"
struct __anonstruct_regmatch_t_72 {
   regoff_t rm_so ;
   regoff_t rm_eo ;
};
#line 463 "/usr/include/regex.h"
typedef struct __anonstruct_regmatch_t_72 regmatch_t;
#line 189 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
union semun {
   int val ;
   struct semid_ds *buf ;
   unsigned short *array ;
   struct seminfo *__buf ;
};
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
/* compiler builtin: 
   void __builtin_va_end(__builtin_va_list  ) ;  */
#line 57 "/usr/include/getopt.h"
extern char *optarg ;
#line 71
extern int optind ;
#line 173
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) getopt_long)(int ___argc ,
                                                                                  char * const  *___argv ,
                                                                                  char const   *__shortopts ,
                                                                                  struct option  const  *__longopts ,
                                                                                  int *__longind ) ;
#line 353 "/usr/include/unistd.h"
extern int close(int __fd ) ;
#line 360
extern ssize_t read(int __fd , void *__buf , size_t __nbytes ) ;
#line 366
extern ssize_t write(int __fd , void const   *__buf , size_t __n ) ;
#line 578
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) execvp)(char const   *__file ,
                                                                                               char * const  *__argv ) ;
#line 628
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getpid)(void) ;
#line 631
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) getppid)(void) ;
#line 667
extern  __attribute__((__nothrow__)) __pid_t ( __attribute__((__leaf__)) setsid)(void) ;
#line 756
extern  __attribute__((__nothrow__)) __pid_t fork(void) ;
#line 826
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) unlink)(char const   *__name ) ;
#line 106 "/usr/include/x86_64-linux-gnu/sys/select.h"
extern int select(int __nfds , fd_set * __restrict  __readfds , fd_set * __restrict  __writefds ,
                  fd_set * __restrict  __exceptfds , struct timeval * __restrict  __timeout ) ;
#line 41 "/usr/include/x86_64-linux-gnu/sys/ioctl.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) ioctl)(int __fd ,
                                                                            unsigned long __request 
                                                                            , ...) ;
#line 350 "/usr/include/x86_64-linux-gnu/sys/stat.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) mkfifo)(char const   *__path ,
                                                                                             __mode_t __mode ) ;
#line 66 "/usr/include/termios.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcgetattr)(int __fd ,
                                                                                struct termios *__termios_p ) ;
#line 70
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) tcsetattr)(int __fd ,
                                                                                int __optional_actions ,
                                                                                struct termios  const  *__termios_p ) ;
#line 76
extern  __attribute__((__nothrow__)) void ( __attribute__((__leaf__)) cfmakeraw)(struct termios *__termios_p ) ;
#line 33 "/usr/include/pty.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) openpty)(int *__amaster ,
                                                                              int *__aslave ,
                                                                              char *__name ,
                                                                              struct termios  const  *__termp ,
                                                                              struct winsize  const  *__winp ) ;
#line 41 "/usr/include/utmp.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) login_tty)(int __fd ) ;
#line 192 "/usr/include/time.h"
extern  __attribute__((__nothrow__)) time_t ( __attribute__((__leaf__)) time)(time_t *__timer ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 134 "/usr/include/dirent.h"
extern DIR *( __attribute__((__nonnull__(1))) opendir)(char const   *__name ) ;
#line 149
extern int ( __attribute__((__nonnull__(1))) closedir)(DIR *__dirp ) ;
#line 162
extern struct dirent *( __attribute__((__nonnull__(1))) readdir)(DIR *__dirp ) ;
#line 102 "/usr/include/signal.h"
extern  __attribute__((__nothrow__)) __sighandler_t ( __attribute__((__leaf__)) signal)(int __sig ,
                                                                                        void (*__handler)(int  ) ) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) kill)(__pid_t __pid ,
                                                                           int __sig ) ;
#line 162 "/usr/include/x86_64-linux-gnu/sys/wait.h"
extern  __attribute__((__nothrow__)) __pid_t wait3(union wait *__stat_loc , int __options ,
                                                   struct rusage *__usage ) ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 306
extern  __attribute__((__nothrow__)) FILE *( __attribute__((__leaf__)) fdopen)(int __fd ,
                                                                               char const   *__modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 386
extern  __attribute__((__nothrow__)) int ( /* format attribute */  snprintf)(char * __restrict  __s ,
                                                                             size_t __maxlen ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 390
extern  __attribute__((__nothrow__)) int ( /* format attribute */  vsnprintf)(char * __restrict  __s ,
                                                                              size_t __maxlen ,
                                                                              char const   * __restrict  __format ,
                                                                              __gnuc_va_list __arg ) ;
#line 433
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...) ;
#line 846
extern void perror(char const   *__s ) ;
#line 50 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1,2), __leaf__)) memmove)(void *__dest ,
                                                                                                  void const   *__src ,
                                                                                                  size_t __n ) ;
#line 132
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncpy)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 140
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strncat)(char * __restrict  __dest ,
                                                                                                  char const   * __restrict  __src ,
                                                                                                  size_t __n ) ;
#line 144
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 348
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(2), __leaf__)) strtok)(char * __restrict  __s ,
                                                                                               char const   * __restrict  __delim ) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 146 "/usr/include/fcntl.h"
extern int ( __attribute__((__nonnull__(1))) open)(char const   *__file , int __oflag 
                                                   , ...) ;
#line 175 "/usr/include/x86_64-linux-gnu/sys/syslog.h"
extern void closelog(void) ;
#line 181
extern void openlog(char const   *__ident , int __option , int __facility ) ;
#line 190
extern void ( /* format attribute */  syslog)(int __pri , char const   *__fmt  , ...) ;
#line 200
extern void ( /* format attribute */  vsyslog)(int __pri , char const   *__fmt , __gnuc_va_list __ap ) ;
#line 183 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) long ( __attribute__((__nonnull__(1), __leaf__)) strtol)(char const   * __restrict  __nptr ,
                                                                                              char ** __restrict  __endptr ,
                                                                                              int __base ) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 54 "/usr/include/x86_64-linux-gnu/sys/ipc.h"
extern  __attribute__((__nothrow__)) key_t ( __attribute__((__leaf__)) ftok)(char const   *__pathname ,
                                                                             int __proj_id ) ;
#line 52 "/usr/include/x86_64-linux-gnu/sys/sem.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semctl)(int __semid ,
                                                                             int __semnum ,
                                                                             int __cmd 
                                                                             , ...) ;
#line 55
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semget)(key_t __key ,
                                                                             int __nsems ,
                                                                             int __semflg ) ;
#line 58
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) semop)(int __semid ,
                                                                            struct sembuf *__sops ,
                                                                            size_t __nsops ) ;
#line 573 "/usr/include/regex.h"
extern int regcomp(regex_t * __restrict  __preg , char const   * __restrict  __pattern ,
                   int __cflags ) ;
#line 577
extern int regexec(regex_t const   * __restrict  __preg , char const   * __restrict  __string ,
                   size_t __nmatch , regmatch_t * __restrict  __pmatch , int __eflags ) ;
#line 585
extern void regfree(regex_t *__preg ) ;
#line 114 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
static void usage(void) ;
#line 115
long toint(char *intstr ) ;
#line 116
void wait4child(int child___0 , char *argv0___0 ) ;
#line 117
int mfifo(char *fname , int mode ) ;
#line 118
void perrx(int ex_code , char const   *err_text  , ...) ;
#line 119
void perrxslog(int ex_code , char const   *err_text  , ...) ;
#line 120
long pidbyppid(pid_t ppid , int lflg ) ;
#line 121
void clean(void) ;
#line 122
void fsignal(int sig ) ;
#line 123
int longargv(int argc , char **argv ) ;
#line 124
int checkgr(int argc , char **argv , char *buf___0 , int chkonly ) ;
#line 125
int regmatch(char const   *string , char *pattern , regex_t *re ) ;
#line 126
int watch4str(int ifd___0 , int ofd___0 , int argc , char **argv , int Sflg , int vflg ,
              int cflg , int timeout ) ;
#line 128
int parsestr(char *dst , char *src , int len , int Sflg ) ;
#line 131 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int master  ;
#line 131 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int slave  ;
#line 132 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int child  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
long pid  =    -1L;
#line 134 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
char *in  =    (char *)((void *)0);
#line 134 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
char *out  =    (char *)((void *)0);
#line 134 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
char *sl  =    (char *)((void *)0);
#line 134 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
char *pfile  =    (char *)((void *)0);
#line 135 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int ifd  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int ofd  ;
#line 135 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int lfd  =    0;
#line 135 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int pfd  =    0;
#line 136 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
FILE *pf  ;
#line 137 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int status  ;
#line 138 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
char buf[8192]  ;
#line 139 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
fd_set rfd  ;
#line 140 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
char *argv0  =    (char *)((void *)0);
#line 141 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int sem  =    -1;
#line 142 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
struct sembuf free_sem  =    {(unsigned short)0, (short)1, (short)0};
#line 214
int main(int argc , char **argv ) ;
#line 214 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
static struct option long_options[2]  = {      {"logfile-mode", 1, (int *)0, 0}, 
        {(char const   *)((void *)0), 0, (int *)0, 0}};
#line 145 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int main(int argc , char **argv ) 
{ 
  struct winsize win ;
  struct termios tt ;
  int i ;
  int bl ;
  int cc ;
  int n ;
  int ch ;
  int fflg ;
  int wflg ;
  int sflg ;
  int kflg ;
  int lflg ;
  int iflg ;
  int oflg ;
  int Sflg ;
  int cflg ;
  int vflg ;
  int timeout ;
  int Lflg ;
  int rflg ;
  int bflg ;
  int tflg ;
  int pflg ;
  long bs ;
  int ksig ;
  pid_t ppid ;
  char infifo[4096] ;
  char outfifo[4096] ;
  struct sembuf check_sem ;
  key_t sem_key ;
  char const   *sem_file ;
  time_t stime___0 ;
  time_t ntime ;
  struct timeval tv ;
  int fl_state ;
  union semun semu ;
  unsigned int logfile_mode ;
  int option_index ;
  int tmp ;
  long tmp___0 ;
  long tmp___1 ;
  int tmp___2 ;
  size_t tmp___3 ;
  ssize_t tmp___4 ;
  ssize_t tmp___5 ;
  ssize_t tmp___6 ;
  int __d0 ;
  int __d1 ;
  int *tmp___7 ;
  ssize_t tmp___8 ;
  ssize_t tmp___9 ;
  int tmp___10 ;
  __pid_t tmp___11 ;
  int tmp___12 ;
  __pid_t tmp___13 ;
  int tmp___14 ;
  int *tmp___15 ;
  int *tmp___16 ;
  __pid_t tmp___17 ;
  __pid_t tmp___18 ;
  __pid_t tmp___19 ;
  int *tmp___20 ;
  int *tmp___21 ;
  int tmp___22 ;
  int tmp___23 ;
  int tmp___24 ;
  int __d0___0 ;
  int __d1___0 ;
  ssize_t tmp___25 ;
  ssize_t tmp___26 ;
  int *tmp___27 ;

  {
#line 149
  fflg = 0;
#line 150
  wflg = 0;
#line 151
  sflg = 0;
#line 152
  kflg = 0;
#line 153
  lflg = 0;
#line 154
  iflg = 0;
#line 155
  oflg = 0;
#line 156
  Sflg = 0;
#line 157
  cflg = 0;
#line 158
  vflg = 0;
#line 159
  timeout = 10;
#line 160
  Lflg = 0;
#line 161
  rflg = 0;
#line 162
  bflg = 0;
#line 163
  tflg = 0;
#line 164
  pflg = 0;
#line 165
  bs = 1L;
#line 167
  ksig = 15;
#line 173
  check_sem.sem_num = (unsigned short)0;
#line 173
  check_sem.sem_op = (short)-1;
#line 173
  check_sem.sem_flg = (short)0;
#line 175
  sem_file = "/";
#line 180
  fl_state = 2;
#line 212
  logfile_mode = 384U;
#line 220
  option_index = -1;
  {
#line 225
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 225
    ch = getopt_long(argc, (char * const  *)argv, "+Scvhfrb:kwslp:i:o:t:L:", (struct option  const  *)(long_options),
                     & option_index);
    }
#line 225
    if (! (ch != -1)) {
#line 225
      goto while_break;
    }
    {
#line 228
    if (ch == 0) {
#line 228
      goto case_0;
    }
#line 234
    if (ch == 102) {
#line 234
      goto case_102;
    }
#line 237
    if (ch == 107) {
#line 237
      goto case_107;
    }
#line 241
    if (ch == 119) {
#line 241
      goto case_119;
    }
#line 244
    if (ch == 115) {
#line 244
      goto case_115;
    }
#line 247
    if (ch == 108) {
#line 247
      goto case_108;
    }
#line 250
    if (ch == 105) {
#line 250
      goto case_105;
    }
#line 254
    if (ch == 111) {
#line 254
      goto case_111;
    }
#line 258
    if (ch == 112) {
#line 258
      goto case_112;
    }
#line 262
    if (ch == 114) {
#line 262
      goto case_114;
    }
#line 266
    if (ch == 98) {
#line 266
      goto case_98;
    }
#line 274
    if (ch == 116) {
#line 274
      goto case_116;
    }
#line 283
    if (ch == 76) {
#line 283
      goto case_76;
    }
#line 288
    if (ch == 99) {
#line 288
      goto case_99;
    }
#line 293
    if (ch == 83) {
#line 293
      goto case_83;
    }
#line 297
    if (ch == 118) {
#line 297
      goto case_118;
    }
#line 301
    goto switch_default;
    case_0: /* CIL Label */ 
#line 229
    if (option_index >= 0) {
      {
#line 229
      tmp = strcmp(long_options[option_index].name, "logfile-mode");
      }
#line 229
      if (tmp == 0) {
#line 229
        if (optarg) {
          {
#line 232
          sscanf((char const   */* __restrict  */)optarg, (char const   */* __restrict  */)"%o",
                 & logfile_mode);
          }
        }
      }
    }
#line 233
    goto switch_break;
    case_102: /* CIL Label */ 
#line 235
    fflg = 1;
#line 236
    goto switch_break;
    case_107: /* CIL Label */ 
#line 239
    kflg = 1;
#line 240
    goto switch_break;
    case_119: /* CIL Label */ 
#line 242
    wflg = 1;
#line 243
    goto switch_break;
    case_115: /* CIL Label */ 
#line 245
    sflg = 1;
#line 246
    goto switch_break;
    case_108: /* CIL Label */ 
#line 248
    lflg = 1;
#line 249
    goto switch_break;
    case_105: /* CIL Label */ 
#line 251
    in = optarg;
#line 252
    iflg = 1;
#line 253
    goto switch_break;
    case_111: /* CIL Label */ 
#line 255
    out = optarg;
#line 256
    oflg = 1;
#line 257
    goto switch_break;
    case_112: /* CIL Label */ 
#line 259
    pfile = optarg;
#line 260
    pflg = 1;
#line 261
    goto switch_break;
    case_114: /* CIL Label */ 
#line 263
    rflg = 1;
#line 264
    in = optarg;
#line 265
    goto switch_break;
    case_98: /* CIL Label */ 
    {
#line 267
    bflg = 1;
#line 268
    bs = toint(optarg);
    }
#line 268
    if (bs < 1L) {
      {
#line 269
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fatal: wrong -b value\n");
#line 271
      usage();
      }
    }
#line 273
    goto switch_break;
    case_116: /* CIL Label */ 
    {
#line 276
    tflg = 1;
#line 277
    tmp___0 = toint(optarg);
#line 277
    timeout = (int )tmp___0;
    }
#line 277
    if (timeout < 1) {
      {
#line 278
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fatal: wrong -t value\n");
#line 280
      usage();
      }
    }
#line 282
    goto switch_break;
    case_76: /* CIL Label */ 
#line 285
    sl = optarg;
#line 286
    Lflg = 1;
#line 287
    goto switch_break;
    case_99: /* CIL Label */ 
#line 290
    cflg = 1;
#line 291
    goto switch_break;
    case_83: /* CIL Label */ 
#line 295
    Sflg = 1;
#line 296
    goto switch_break;
    case_118: /* CIL Label */ 
#line 298
    vflg = 1;
#line 299
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 302
    usage();
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 304
  argc -= optind;
#line 305
  argv += optind;
#line 308
  if (((((fflg + kflg) + wflg) + sflg) + lflg) + rflg != 1) {
    {
#line 309
    usage();
    }
  }
  {
#line 311
  ppid = getppid();
  }
#line 313
  if (kflg) {
#line 315
    if (*(argv + 0)) {
      {
#line 316
      pid = toint(*(argv + 0));
      }
#line 316
      if (pid < 0L) {
        {
#line 317
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Fatal: wrong PID value\n");
#line 318
        usage();
        }
      }
#line 322
      if (*(argv + 1)) {
        {
#line 323
        tmp___1 = toint(*(argv + 1));
#line 323
        ksig = (int )tmp___1;
        }
      }
    } else {
      {
#line 325
      pid = pidbyppid(ppid, lflg);
      }
#line 325
      if (pid < 1L) {
        {
#line 326
        perrx(255, "Can\'t find desired process");
        }
      }
    }
#line 328
    if (pid > 0L) {
      {
#line 328
      tmp___2 = kill((__pid_t )pid, ksig);
      }
#line 328
      if (tmp___2 == -1) {
        {
#line 329
        perrx(255, "Can\'t kill PID: %d", pid);
        }
      }
    }
    {
#line 331
    exit(0);
    }
  }
#line 334
  if (lflg) {
    {
#line 335
    pidbyppid(ppid, lflg);
#line 336
    exit(0);
    }
  }
#line 339
  if (sflg) {
#line 340
    if (! oflg) {
      {
#line 341
      pid = pidbyppid(ppid, lflg);
      }
#line 341
      if (pid > 0L) {
        {
#line 342
        snprintf((char */* __restrict  */)(outfifo), sizeof(outfifo), (char const   */* __restrict  */)"%s/%s.%ld.%ld.in",
                 "/tmp", "empty", (long )ppid, pid);
#line 344
        out = outfifo;
        }
      } else {
        {
#line 346
        perrx(255, "Fatal can\'t find IN FIFO file by PPID:PID pair");
        }
      }
    }
    {
#line 349
    ofd = open((char const   *)out, 1);
    }
#line 349
    if (ofd == -1) {
      {
#line 350
      perrx(255, "Fatal open FIFO for writing: %s", out);
      }
    }
#line 352
    if (! cflg) {
#line 352
      if ((unsigned long )*(argv + 0) != (unsigned long )((void *)0)) {
        {
#line 353
        tmp___3 = strlen((char const   *)*(argv + 0));
#line 353
        bl = parsestr(buf, *(argv + 0), (int )tmp___3, Sflg);
#line 354
        tmp___4 = write(ofd, (void const   *)(buf), (size_t )bl);
        }
#line 354
        if (tmp___4 == -1L) {
          {
#line 355
          perrx(255, "Fatal write data to FIFO: %s", out);
          }
        }
      } else {
#line 352
        goto _L;
      }
    } else {
      _L: /* CIL Label */ 
      {
#line 357
      while (1) {
        while_continue___0: /* CIL Label */ ;
        {
#line 357
        tmp___6 = read(0, (void *)(buf), sizeof(buf));
#line 357
        cc = (int )tmp___6;
        }
#line 357
        if (! (cc > 0)) {
#line 357
          goto while_break___0;
        }
#line 358
        if (cc == -1) {
          {
#line 359
          perrx(255, "Fatal read from STDIN to buffer");
          }
        }
        {
#line 360
        bl = parsestr(buf, buf, cc, Sflg);
#line 361
        tmp___5 = write(ofd, (void const   *)(buf), (size_t )bl);
        }
#line 361
        if (tmp___5 == -1L) {
          {
#line 362
          perrx(255, "Fatal write STDIN data to FIFO: %s", out);
          }
        }
      }
      while_break___0: /* CIL Label */ ;
      }
    }
    {
#line 365
    exit(0);
    }
  }
#line 368
  if (rflg) {
#line 369
    if (! iflg) {
      {
#line 370
      pid = pidbyppid(ppid, lflg);
      }
#line 370
      if (pid > 0L) {
        {
#line 371
        snprintf((char */* __restrict  */)(infifo), sizeof(infifo), (char const   */* __restrict  */)"%s/%s.%ld.%ld.out",
                 "/tmp", "empty", (long )ppid, pid);
#line 373
        in = infifo;
        }
      } else {
        {
#line 375
        perrx(255, "Fatal can\'t find OUT FIFO file by PPID:PID pair");
        }
      }
    }
    {
#line 378
    ifd = open((char const   *)in, 0);
    }
#line 378
    if (ifd == -1) {
      {
#line 379
      perrx(255, "Fatal open FIFO for reading: %s", in);
      }
    }
    {
#line 382
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 382
      __asm__  volatile   ("cld; rep; "
                           "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                           "1" (& rfd.fds_bits[0]): "memory");
#line 382
      goto while_break___1;
    }
    while_break___1: /* CIL Label */ ;
    }
    {
#line 384
    stime___0 = time((time_t *)0);
#line 385
    tv.tv_sec = (__time_t )timeout;
#line 386
    tv.tv_usec = (__suseconds_t )0;
#line 388
    cc = -1;
    }
    {
#line 388
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 388
      if (! (cc != 0)) {
#line 388
        goto while_break___2;
      }
      {
#line 389
      rfd.fds_bits[ifd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ifd % (8 * (int )sizeof(__fd_mask ));
#line 390
      n = select(ifd + 1, (fd_set */* __restrict  */)(& rfd), (fd_set */* __restrict  */)0,
                 (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
#line 392
      tv.tv_sec = (__time_t )timeout;
      }
#line 394
      if (n < 0) {
        {
#line 394
        tmp___7 = __errno_location();
        }
#line 394
        if (*tmp___7 != 4) {
          {
#line 395
          perrx(255, "Fatal select()");
          }
        }
      }
#line 397
      if (n > 0) {
#line 397
        if ((rfd.fds_bits[ifd / (8 * (int )sizeof(__fd_mask ))] & (1L << ifd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 398
          tmp___8 = read(ifd, (void *)(buf), (size_t )bs);
#line 398
          cc = (int )tmp___8;
          }
#line 398
          if (cc == -1) {
            {
#line 399
            perrx(255, "Fatal read from IN FIFO");
            }
          }
          {
#line 400
          tmp___9 = write(1, (void const   *)(buf), (size_t )cc);
          }
#line 400
          if (tmp___9 == -1L) {
            {
#line 401
            perrx(255, "Fatal write to STDOUT");
            }
          }
#line 402
          if (! bflg) {
#line 402
            if ((int )buf[0] == 10) {
#line 403
              goto while_break___2;
            } else {
#line 402
              goto _L___0;
            }
          } else
          _L___0: /* CIL Label */ 
#line 402
          if (bflg) {
#line 403
            goto while_break___2;
          }
        } else {
#line 397
          goto _L___1;
        }
      } else
      _L___1: /* CIL Label */ 
#line 405
      if (tflg) {
        {
#line 406
        ntime = time((time_t *)0);
        }
#line 407
        if (ntime - stime___0 >= (time_t )timeout) {
          {
#line 408
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Buffer is empty. Exit on timeout\n",
                  "empty");
#line 412
          close(ifd);
#line 413
          exit(255);
          }
        }
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 418
    close(ifd);
#line 419
    exit(0);
    }
  }
#line 422
  if (argc == 0) {
    {
#line 423
    usage();
    }
  }
#line 426
  if (wflg) {
#line 427
    if (! iflg) {
#line 427
      if (! oflg) {
        {
#line 428
        pid = pidbyppid(ppid, lflg);
        }
#line 428
        if (pid > 0L) {
          {
#line 429
          sprintf((char */* __restrict  */)(infifo), (char const   */* __restrict  */)"%s/%s.%ld.%ld.out",
                  "/tmp", "empty", (long )ppid, pid);
#line 431
          sprintf((char */* __restrict  */)(outfifo), (char const   */* __restrict  */)"%s/%s.%ld.%ld.in",
                  "/tmp", "empty", (long )ppid, pid);
#line 433
          in = infifo;
#line 434
          out = outfifo;
          }
        } else {
          {
#line 436
          perrx(255, "Fatal can\'t find FIFO files by PPID:PID pair");
          }
        }
      }
    }
    {
#line 440
    ifd = open((char const   *)in, 0);
    }
#line 440
    if (ifd == -1) {
      {
#line 441
      perrx(255, "Fatal open FIFO for reading: %s", in);
      }
    }
    {
#line 443
    ofd = open((char const   *)out, 1);
    }
#line 443
    if (ofd == -1) {
      {
#line 444
      perrx(255, "Fatal open FIFO for writing: %s", out);
      }
    }
    {
#line 446
    checkgr(argc, argv, (char *)((void *)0), 1);
#line 447
    tmp___10 = watch4str(ifd, ofd, argc, argv, Sflg, vflg, cflg, timeout);
#line 447
    exit(tmp___10);
    }
  }
  {
#line 451
  openlog("empty", 0, 0);
#line 452
  syslog(5, "version %s started", "0.6.19b");
#line 453
  argv0 = *(argv + 0);
#line 455
  tcgetattr(0, & tt);
#line 456
  ioctl(0, 21523UL, & win);
#line 458
  tmp___11 = getpid();
#line 458
  sem_key = ftok(sem_file, tmp___11);
  }
#line 458
  if (sem_key == -1) {
    {
#line 459
    perrxslog(255, "Can\'t generate semaphore key from file %s %m", sem_file);
    }
  }
  {
#line 461
  sem = semget(sem_key, 1, 896);
  }
#line 461
  if (sem == -1) {
    {
#line 462
    perrxslog(255, "Can\'t get semaphore %m");
    }
  }
  {
#line 464
  semu.val = 0;
#line 465
  tmp___12 = semctl(sem, 0, 16, semu);
  }
#line 465
  if (tmp___12 == -1) {
    {
#line 466
    perrxslog(255, "Can\'t set semaphore %d to lock: %m", sem);
    }
  }
  {
#line 468
  tmp___13 = fork();
#line 468
  pid = (long )tmp___13;
  }
#line 468
  if (pid == -1L) {
    {
#line 469
    perrxslog(255, "Daemonizing failed. Fatal first fork");
    }
  }
#line 470
  if (pid > 0L) {
    {
#line 471
    tmp___14 = semop(sem, & check_sem, (size_t )1);
    }
#line 471
    if (tmp___14 == -1) {
      {
#line 471
      tmp___15 = __errno_location();
      }
#line 471
      if (*tmp___15 != 22) {
        {
#line 471
        tmp___16 = __errno_location();
        }
#line 471
        if (*tmp___16 != 43) {
          {
#line 473
          perrxslog(255, "Can\'t get semaphore %d status: %m", sem);
          }
        }
      }
    }
    {
#line 475
    exit(0);
    }
  }
  {
#line 478
  tmp___17 = setsid();
  }
#line 478
  if (tmp___17 < 0) {
    {
#line 479
    perrxslog(255, "Daemonizing failed. Fatal setsid");
    }
  }
  {
#line 481
  tmp___18 = fork();
#line 481
  pid = (long )tmp___18;
  }
#line 481
  if (pid == -1L) {
    {
#line 482
    perrxslog(255, "Daemonizing failed. Fatal second fork");
    }
  }
#line 484
  if (pid > 0L) {
    {
#line 485
    exit(0);
    }
  }
  {
#line 486
  tmp___19 = getpid();
#line 486
  pid = (long )tmp___19;
  }
#line 488
  if (pflg) {
    {
#line 489
    pfd = open((char const   *)pfile, 65, 448);
    }
#line 489
    if (pfd == -1) {
      {
#line 490
      syslog(5, "Warning: Can\'t write pid-file %s %m", pfile);
      }
    }
    {
#line 493
    pf = fdopen(pfd, "w");
#line 494
    fprintf((FILE */* __restrict  */)pf, (char const   */* __restrict  */)"%ld\n",
            pid);
#line 495
    fclose(pf);
    }
  }
#line 498
  if (iflg) {
#line 498
    if (! oflg) {
      {
#line 499
      sprintf((char */* __restrict  */)(infifo), (char const   */* __restrict  */)"%s/%s.%ld.%ld.in",
              "/tmp", "empty", (long )ppid, pid);
#line 500
      sprintf((char */* __restrict  */)(outfifo), (char const   */* __restrict  */)"%s/%s.%ld.%ld.out",
              "/tmp", "empty", (long )ppid, pid);
#line 501
      in = infifo;
#line 502
      out = outfifo;
      }
    }
  } else {
    {
#line 499
    sprintf((char */* __restrict  */)(infifo), (char const   */* __restrict  */)"%s/%s.%ld.%ld.in",
            "/tmp", "empty", (long )ppid, pid);
#line 500
    sprintf((char */* __restrict  */)(outfifo), (char const   */* __restrict  */)"%s/%s.%ld.%ld.out",
            "/tmp", "empty", (long )ppid, pid);
#line 501
    in = infifo;
#line 502
    out = outfifo;
    }
  }
#line 505
  if (Lflg) {
    {
#line 506
    lfd = open((char const   *)sl, 1089, logfile_mode);
    }
#line 506
    if (lfd == -1) {
      {
#line 507
      syslog(5, "Warning: Can\'t open %s for session-log %m", sl);
      }
    }
  }
  {
#line 510
  ifd = mfifo(in, 2);
  }
#line 510
  if (ifd == -1) {
    {
#line 510
    tmp___20 = __errno_location();
    }
#line 510
    if (*tmp___20 != 6) {
      {
#line 511
      perrxslog(255, "Fatal creating FIFO: %s", in);
      }
    }
  }
  {
#line 512
  ofd = mfifo(out, 2);
  }
#line 512
  if (ofd == -1) {
    {
#line 512
    tmp___21 = __errno_location();
    }
#line 512
    if (*tmp___21 != 6) {
      {
#line 513
      perrxslog(255, "Fatal creating FIFO: %s", out);
      }
    }
  }
  {
#line 515
  tmp___22 = semop(sem, & free_sem, (size_t )1);
  }
#line 515
  if (tmp___22 == -1) {
    {
#line 516
    perrxslog(255, "Can\'t release semaphore: %d from lock %m", sem);
    }
  }
  {
#line 517
  tmp___23 = semctl(sem, 0, 0);
  }
#line 517
  if (tmp___23 == -1) {
    {
#line 518
    syslog(5, "Warning: Can\'t remove semaphore: %d  %m", sem);
    }
  }
  {
#line 521
  tmp___24 = openpty(& master, & slave, (char *)((void *)0), (struct termios  const  *)(& tt),
                     (struct winsize  const  *)(& win));
  }
#line 521
  if (tmp___24 == -1) {
    {
#line 522
    perrxslog(255, "PTY routine failed. Fatal openpty()");
    }
  }
#line 550
  i = 1;
  {
#line 550
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 550
    if (! (i < 32)) {
#line 550
      goto while_break___3;
    }
    {
#line 551
    signal(i, & fsignal);
#line 550
    i ++;
    }
  }
  while_break___3: /* CIL Label */ ;
  }
  {
#line 553
  child = fork();
  }
#line 553
  if (child < 0) {
    {
#line 554
    clean();
#line 555
    perrxslog(255, "Fatal fork at creating desired process");
    }
  }
#line 559
  if (child == 0) {
    {
#line 560
    close(master);
#line 563
    login_tty(slave);
#line 565
    cfmakeraw(& tt);
#line 599
    tt.c_lflag &= 4294967287U;
#line 600
    tcsetattr(0, 2, (struct termios  const  *)(& tt));
#line 602
    strncpy((char */* __restrict  */)(buf), (char const   */* __restrict  */)*(argv + 0),
            sizeof(buf) - 1UL);
#line 603
    buf[sizeof(buf) - 1UL] = (char )'\000';
#line 605
    i = 1;
    }
    {
#line 605
    while (1) {
      while_continue___4: /* CIL Label */ ;
#line 605
      if (! (i < argc)) {
#line 605
        goto while_break___4;
      }
      {
#line 606
      strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)" ",
              (size_t )1);
#line 607
      strncat((char */* __restrict  */)(buf), (char const   */* __restrict  */)*(argv + i),
              sizeof(buf));
#line 605
      i ++;
      }
    }
    while_break___4: /* CIL Label */ ;
    }
    {
#line 610
    syslog(5, "forked %s", buf);
#line 613
    execvp((char const   *)*(argv + 0), (char * const  *)argv);
#line 615
    syslog(5, "Failed loading %s: %m", buf);
#line 617
    clean();
#line 618
    kill(0, 15);
#line 619
    exit(0);
    }
  }
  {
#line 623
  while (1) {
    while_continue___5: /* CIL Label */ ;
#line 623
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0___0), "=D" (__d1___0): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfd.fds_bits[0]): "memory");
#line 623
    goto while_break___5;
  }
  while_break___5: /* CIL Label */ ;
  }
  {
#line 624
  while (1) {
    while_continue___6: /* CIL Label */ ;
    {
#line 625
    rfd.fds_bits[master / (8 * (int )sizeof(__fd_mask ))] |= 1L << master % (8 * (int )sizeof(__fd_mask ));
#line 626
    rfd.fds_bits[ifd / (8 * (int )sizeof(__fd_mask ))] |= 1L << ifd % (8 * (int )sizeof(__fd_mask ));
#line 628
    n = select(master + 1, (fd_set */* __restrict  */)(& rfd), (fd_set */* __restrict  */)0,
               (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)((void *)0));
    }
#line 629
    if (n > 0) {
#line 629
      goto _L___2;
    } else {
      {
#line 629
      tmp___27 = __errno_location();
      }
#line 629
      if (*tmp___27 == 4) {
        _L___2: /* CIL Label */ 
#line 630
        if ((rfd.fds_bits[ifd / (8 * (int )sizeof(__fd_mask ))] & (1L << ifd % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 631
          tmp___25 = read(ifd, (void *)(buf), sizeof(buf));
#line 631
          cc = (int )tmp___25;
          }
#line 631
          if (cc > 0) {
            {
#line 633
            write(master, (void const   *)(buf), (size_t )cc);
            }
#line 634
            if (lfd) {
#line 635
              if (fl_state != 1) {
                {
#line 636
                write(lfd, (void const   *)">>>", (size_t )3);
#line 637
                fl_state = 1;
                }
              }
              {
#line 639
              write(lfd, (void const   *)(buf), (size_t )cc);
              }
            }
          }
        }
#line 643
        if ((rfd.fds_bits[master / (8 * (int )sizeof(__fd_mask ))] & (1L << master % (8 * (int )sizeof(__fd_mask )))) != 0L) {
          {
#line 644
          tmp___26 = read(master, (void *)(buf), sizeof(buf));
#line 644
          cc = (int )tmp___26;
          }
#line 644
          if (cc > 0) {
            {
#line 646
            write(ofd, (void const   *)(buf), (size_t )cc);
            }
#line 647
            if (lfd) {
#line 648
              if (fl_state != 0) {
                {
#line 649
                write(lfd, (void const   *)"<<<", (size_t )3);
#line 650
                fl_state = 0;
                }
              }
              {
#line 652
              write(lfd, (void const   *)(buf), (size_t )cc);
              }
            }
          }
        }
      }
    }
  }
  while_break___6: /* CIL Label */ ;
  }
}
}
#line 662 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
static void usage(void) 
{ 


  {
  {
#line 663
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s-%s usage:\nempty -f [-i fifo1 -o fifo2] [-p file.pid] [-L file] command [command args]\nempty -w [-Sv] [-t n] [-i fifo2 -o fifo1] key1 [answer1] ... [keyX answerX]\nempty -s [-Sc] [-o fifo1] [request]\nempty -r [-b size] [-t n] [-i fifo1]\nempty -l\nempty -k [pid] [signal]\nempty -h\n",
          "empty", "0.6.19b");
#line 672
  exit(255);
  }
}
}
#line 676 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
long toint(char *intstr ) 
{ 
  int in___0 ;
  long tmp ;
  int *tmp___0 ;

  {
  {
#line 679
  tmp = strtol((char const   */* __restrict  */)intstr, (char **/* __restrict  */)((char **)((void *)0)),
               10);
#line 679
  in___0 = (int )tmp;
  }
#line 680
  if (in___0 == 0) {
    {
#line 680
    tmp___0 = __errno_location();
    }
#line 680
    if (*tmp___0 == 22) {
      {
#line 681
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"Wrong long value: %s\n",
              intstr);
#line 682
      usage();
      }
    }
  }
#line 684
  return ((long )in___0);
}
}
#line 688 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
long pidbyppid(pid_t ppid , int lflg ) 
{ 
  char fmask[4096] ;
  char fname[4096] ;
  char const   *sep ;
  DIR *dir ;
  struct dirent *dent ;
  int len ;
  char *chpid ;
  char *tail ;
  long pid___0 ;
  long maxpid ;
  int header ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 691
  sep = ".";
#line 696
  pid___0 = -1L;
#line 696
  maxpid = -1L;
#line 697
  header = 1;
#line 700
  sprintf((char */* __restrict  */)(fmask), (char const   */* __restrict  */)"%s%s%d",
          "empty", sep, ppid);
#line 701
  tmp = strlen((char const   *)(fmask));
#line 701
  len = (int )tmp;
#line 703
  dir = opendir("/tmp");
  }
#line 703
  if ((unsigned long )dir == (unsigned long )((void *)0)) {
    {
#line 704
    perrx(255, "Can\'t open directory: %s", "/tmp");
    }
  }
  {
#line 706
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 706
    dent = readdir(dir);
    }
#line 706
    if (! ((unsigned long )dent != (unsigned long )((void *)0))) {
#line 706
      goto while_break;
    }
    {
#line 707
    tmp___0 = strncmp((char const   *)(fmask), (char const   *)(dent->d_name), (size_t )len);
    }
#line 707
    if (! tmp___0) {
      {
#line 708
      strncpy((char */* __restrict  */)(fname), (char const   */* __restrict  */)(dent->d_name),
              sizeof(fname) - 1UL);
#line 709
      fname[sizeof(fname) - 1UL] = (char )'\000';
#line 711
      strtok((char */* __restrict  */)(fname), (char const   */* __restrict  */)sep);
#line 712
      strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)sep);
#line 713
      chpid = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)sep);
#line 714
      tail = strtok((char */* __restrict  */)((void *)0), (char const   */* __restrict  */)sep);
      }
#line 716
      if ((unsigned long )chpid != (unsigned long )((void *)0)) {
        {
#line 717
        pid___0 = toint(chpid);
        }
#line 718
        if (pid___0 > maxpid) {
#line 718
          maxpid = pid___0;
        }
      }
#line 721
      if (lflg) {
#line 722
        if (header) {
          {
#line 723
          printf((char const   */* __restrict  */)"PPID\tPID\tTYPE\tFILENAME\n");
#line 724
          header --;
          }
        }
        {
#line 727
        printf((char const   */* __restrict  */)"%ld\t%ld\t%s\t%s/%s\n", (long )ppid,
               pid___0, tail, "/tmp", dent->d_name);
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 734
  tmp___1 = closedir(dir);
  }
#line 734
  if (tmp___1 == -1) {
    {
#line 735
    perror("Warning closing directory");
    }
  }
#line 738
  if (lflg) {
#line 738
    if (pid___0 > 0L) {
      {
#line 739
      printf((char const   */* __restrict  */)"\n%ld\t%ld\tcurrent\n", (long )ppid,
             maxpid);
      }
    }
  }
#line 741
  return (maxpid);
}
}
#line 745 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
void wait4child(int child___0 , char *argv0___0 ) 
{ 
  __pid_t tmp ;

  {
  {
#line 746
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 746
    tmp = wait3((union wait *)(& status), 1, (struct rusage *)0);
#line 746
    pid = (long )tmp;
    }
#line 746
    if (! (pid > 0L)) {
#line 746
      goto while_break;
    }
#line 747
    if (pid == (long )child___0) {
      {
#line 748
      syslog(5, "%s exited", argv0___0);
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 749
  return;
}
}
#line 752 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int mfifo(char *fname , int mode ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 754
  tmp = mkfifo((char const   *)fname, (__mode_t )4544);
  }
#line 754
  if (tmp == -1) {
#line 755
    return (-1);
  }
  {
#line 757
  tmp___0 = open((char const   *)fname, mode);
  }
#line 757
  return (tmp___0);
}
}
#line 762 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
void clean(void) 
{ 


  {
  {
#line 763
  close(master);
#line 764
  close(ifd);
#line 765
  close(ofd);
#line 766
  close(lfd);
#line 767
  unlink((char const   *)in);
#line 768
  unlink((char const   *)out);
#line 769
  unlink((char const   *)pfile);
  }
#line 770
  return;
}
}
#line 773 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
void perrx(int ex_code , char const   *err_text  , ...) 
{ 
  char err_buf[8192] ;
  va_list va ;

  {
  {
#line 777
  __builtin_va_start(va, err_text);
#line 778
  vsnprintf((char */* __restrict  */)(err_buf), sizeof(err_buf), (char const   */* __restrict  */)err_text,
            va);
#line 779
  __builtin_va_end(va);
#line 781
  perror((char const   *)(err_buf));
#line 782
  exit(ex_code);
  }
}
}
#line 786 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
void perrxslog(int ex_code , char const   *err_text  , ...) 
{ 
  va_list va ;

  {
  {
#line 789
  __builtin_va_start(va, err_text);
#line 791
  vsyslog(5, err_text, va);
#line 799
  __builtin_va_end(va);
  }
#line 801
  if (sem != -1) {
    {
#line 802
    semctl(sem, 0, 0);
    }
  }
  {
#line 804
  closelog();
#line 805
  exit(ex_code);
  }
}
}
#line 809 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
void fsignal(int sig ) 
{ 


  {
  {
#line 814
  if (sig == 11) {
#line 814
    goto case_11;
  }
#line 814
  if (sig == 3) {
#line 814
    goto case_11;
  }
#line 814
  if (sig == 2) {
#line 814
    goto case_11;
  }
#line 814
  if (sig == 15) {
#line 814
    goto case_11;
  }
#line 816
  if (sig == 17) {
#line 816
    goto case_17;
  }
#line 810
  goto switch_break;
  case_11: /* CIL Label */ 
  case_3: /* CIL Label */ 
  case_2: /* CIL Label */ 
  case_15: /* CIL Label */ 
#line 815
  goto switch_break;
  case_17: /* CIL Label */ 
  {
#line 817
  wait4child(child, argv0);
#line 818
  syslog(5, "version %s finished", "0.6.19b");
  }
  switch_break: /* CIL Label */ ;
  }
  {
#line 822
  clean();
#line 823
  semop(sem, & free_sem, (size_t )1);
#line 824
  closelog();
#line 825
  exit(0);
  }
}
}
#line 829 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int longargv(int argc , char **argv ) 
{ 
  int i ;
  int len ;
  int maxlen ;
  size_t tmp ;

  {
#line 830
  i = 0;
#line 830
  len = 0;
#line 830
  maxlen = 0;
  {
#line 833
  while (1) {
    while_continue: /* CIL Label */ ;
#line 833
    if (! ((unsigned long )*(argv + i) != (unsigned long )((void *)0))) {
#line 833
      goto while_break;
    }
    {
#line 834
    tmp = strlen((char const   *)*(argv + i));
#line 834
    len = (int )tmp;
    }
#line 835
    if (len > maxlen) {
#line 836
      maxlen = len;
    }
#line 837
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 840
  return (maxlen);
}
}
#line 844 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int checkgr(int argc , char **argv , char *buf___0 , int chkonly ) 
{ 
  int i ;
  regex_t re ;
  int tmp ;
  int tmp___0 ;

  {
#line 848
  i = 1;
  {
#line 848
  while (1) {
    while_continue: /* CIL Label */ ;
#line 848
    if (! (i <= argc)) {
#line 848
      goto while_break;
    }
    {
#line 849
    tmp = regcomp((regex_t */* __restrict  */)(& re), (char const   */* __restrict  */)*(argv + (i - 1)),
                  1 | (((1 << 1) << 1) << 1));
    }
#line 849
    if (tmp != 0) {
      {
#line 850
      perrx(255, "Regex compilation failed");
      }
    }
#line 852
    if (chkonly != 1) {
      {
#line 853
      tmp___0 = regmatch((char const   *)buf___0, *(argv + (i - 1)), & re);
      }
      {
#line 854
      if (tmp___0 == 1) {
#line 854
        goto case_1;
      }
#line 856
      if (tmp___0 == 0) {
#line 856
        goto case_0;
      }
#line 853
      goto switch_break;
      case_1: /* CIL Label */ 
#line 855
      return (i);
      case_0: /* CIL Label */ 
#line 857
      if (i + 1 <= argc) {
#line 858
        i ++;
      }
#line 859
      goto switch_break;
      switch_break: /* CIL Label */ ;
      }
    }
#line 848
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 863
  return (0);
}
}
#line 867 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int regmatch(char const   *string , char *pattern , regex_t *re ) 
{ 
  int status___0 ;

  {
  {
#line 871
  status___0 = regexec((regex_t const   */* __restrict  */)re, (char const   */* __restrict  */)string,
                       (size_t )0, (regmatch_t */* __restrict  */)((void *)0), 0);
#line 872
  regfree(re);
  }
  {
#line 875
  if (status___0 == 0) {
#line 875
    goto case_0;
  }
#line 878
  if (status___0 == 1) {
#line 878
    goto case_1;
  }
#line 881
  goto switch_default;
  case_0: /* CIL Label */ 
#line 876
  return (1);
  case_1: /* CIL Label */ 
#line 879
  return (0);
  switch_default: /* CIL Label */ 
  {
#line 882
  perrx(255, "Regex execution failed");
  }
  switch_break: /* CIL Label */ ;
  }
#line 885
  return (255);
}
}
#line 889 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int watch4str(int ifd___0 , int ofd___0 , int argc , char **argv , int Sflg , int vflg ,
              int cflg , int timeout ) 
{ 
  int n ;
  int cc ;
  int bl ;
  time_t stime___0 ;
  time_t ntime ;
  struct timeval tv ;
  int argt ;
  int largv ;
  char *resp ;
  int __d0 ;
  int __d1 ;
  int *tmp ;
  size_t tmp___0 ;
  ssize_t tmp___1 ;
  ssize_t tmp___2 ;

  {
  {
#line 896
  argt = 0;
#line 897
  largv = 0;
#line 898
  resp = (char *)((void *)0);
#line 901
  stime___0 = time((time_t *)0);
#line 902
  tv.tv_sec = (__time_t )timeout;
#line 903
  tv.tv_usec = (__suseconds_t )0;
  }
  {
#line 905
  while (1) {
    while_continue: /* CIL Label */ ;
#line 905
    __asm__  volatile   ("cld; rep; "
                         "stosq": "=c" (__d0), "=D" (__d1): "a" (0), "0" (sizeof(fd_set ) / sizeof(__fd_mask )),
                         "1" (& rfd.fds_bits[0]): "memory");
#line 905
    goto while_break;
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 906
  while (1) {
    while_continue___0: /* CIL Label */ ;
    {
#line 907
    rfd.fds_bits[ifd___0 / (8 * (int )sizeof(__fd_mask ))] |= 1L << ifd___0 % (8 * (int )sizeof(__fd_mask ));
#line 908
    n = select(ifd___0 + 1, (fd_set */* __restrict  */)(& rfd), (fd_set */* __restrict  */)0,
               (fd_set */* __restrict  */)0, (struct timeval */* __restrict  */)(& tv));
#line 910
    tv.tv_sec = (__time_t )timeout;
    }
#line 912
    if (n < 0) {
      {
#line 912
      tmp = __errno_location();
      }
#line 912
      if (*tmp != 4) {
        {
#line 913
        perrx(255, "Fatal select()");
        }
      }
    }
#line 915
    if (n > 0) {
#line 915
      if ((rfd.fds_bits[ifd___0 / (8 * (int )sizeof(__fd_mask ))] & (1L << ifd___0 % (8 * (int )sizeof(__fd_mask )))) != 0L) {
        {
#line 916
        largv = 0;
#line 917
        tmp___2 = read(ifd___0, (void *)(buf + largv), sizeof(buf) - (unsigned long )largv);
#line 917
        cc = (int )tmp___2;
        }
#line 917
        if (cc > 0) {
          {
#line 918
          stime___0 = time((time_t *)0);
#line 920
          buf[cc + largv] = (char )'\000';
          }
#line 922
          if (vflg) {
            {
#line 923
            printf((char const   */* __restrict  */)"%s", buf);
            }
          }
          {
#line 925
          argt = checkgr(argc, argv, buf, 0);
          }
#line 925
          if (argt > 0) {
#line 926
            resp = *(argv + argt);
#line 926
            if (resp) {
              {
#line 928
              tmp___0 = strlen((char const   *)resp);
#line 928
              bl = parsestr(buf, resp, (int )tmp___0, Sflg);
#line 930
              tmp___1 = write(ofd___0, (void const   *)(buf), (size_t )bl);
              }
#line 930
              if (tmp___1 == -1L) {
                {
#line 931
                perrx(255, "Fatal write data to output");
                }
              }
            }
#line 934
            return ((argt + 1) / 2);
          }
#line 937
          if (largv == 0) {
            {
#line 938
            largv = longargv(argc, argv);
            }
          }
          {
#line 940
          memmove((void *)(buf), (void const   *)((buf + cc) - largv), (size_t )largv);
          }
        }
#line 943
        if (cc <= 0) {
#line 945
          if (vflg) {
            {
#line 946
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Got nothing in output\n",
                    "empty");
            }
          }
#line 948
          return (255);
        }
      }
    }
    {
#line 952
    ntime = time((time_t *)0);
    }
#line 953
    if (ntime - stime___0 >= (time_t )timeout) {
      {
#line 954
      fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"%s: Data stream is empty. Keyphrase wasn\'t found. Exit on timeout\n",
              "empty");
      }
#line 957
      return (255);
    }
  }
  while_break___0: /* CIL Label */ ;
  }
}
}
#line 963 "/home/june/repo/benchmarks/collector/temp/empty-expect-0.6.19b/empty.c"
int parsestr(char *dst , char *src , int len , int Sflg ) 
{ 
  int i ;
  int bi ;

  {
#line 967
  if (Sflg == 1) {
#line 967
    len --;
  }
#line 968
  i = 0;
#line 968
  bi = 0;
  {
#line 968
  while (1) {
    while_continue: /* CIL Label */ ;
#line 968
    if (! (i < len)) {
#line 968
      goto while_break;
    }
#line 969
    if ((int )*(src + i) == 92) {
      {
#line 971
      if ((int )*(src + (i + 1)) == 92) {
#line 971
        goto case_92;
      }
#line 975
      if ((int )*(src + (i + 1)) == 110) {
#line 975
        goto case_110;
      }
#line 979
      if ((int )*(src + (i + 1)) == 114) {
#line 979
        goto case_114;
      }
#line 983
      goto switch_default;
      case_92: /* CIL Label */ 
#line 972
      *(dst + bi) = (char )'\\';
#line 973
      i ++;
#line 974
      goto switch_break;
      case_110: /* CIL Label */ 
#line 976
      *(dst + bi) = (char )'\n';
#line 977
      i ++;
#line 978
      goto switch_break;
      case_114: /* CIL Label */ 
#line 980
      *(dst + bi) = (char )'\r';
#line 981
      i ++;
#line 982
      goto switch_break;
      switch_default: /* CIL Label */ 
#line 984
      *(dst + bi) = *(src + i);
      switch_break: /* CIL Label */ ;
      }
    } else {
#line 987
      *(dst + bi) = *(src + i);
    }
#line 968
    i ++;
#line 968
    bi ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 990
  return (bi);
}
}
