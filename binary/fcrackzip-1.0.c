/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 98 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/config.h"
typedef unsigned char u8;
#line 101 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/config.h"
typedef unsigned short u16;
#line 109 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/config.h"
typedef unsigned int u32;
#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 81 "./getopt.h"
struct option {
   char const   *name ;
   int has_arg ;
   int *flag ;
   int val ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
struct __anonstruct_method_6 {
   char *desc ;
   void (*init_crack_pw)(void) ;
   int (*crack_pw)(int (*)(void) , int (*)(char const   * , char const   * ) ) ;
   void (*load_file)(char const   * ) ;
};
#line 39 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
typedef struct __anonstruct_method_6 method;
#line 17 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
typedef unsigned int UI;
#line 26 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
struct __anonstruct_cp_cell_26 {
   UI dst_x ;
   UI dst_y ;
   int mirror ;
};
#line 26 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
typedef struct __anonstruct_cp_cell_26 cp_cell;
#line 139 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __time_t;
#line 141 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __suseconds_t;
#line 30 "/usr/include/x86_64-linux-gnu/bits/time.h"
struct timeval {
   __time_t tv_sec ;
   __suseconds_t tv_usec ;
};
#line 55 "/usr/include/x86_64-linux-gnu/sys/time.h"
struct timezone {
   int tz_minuteswest ;
   int tz_dsttime ;
};
#line 61 "/usr/include/x86_64-linux-gnu/sys/time.h"
typedef struct timezone * __restrict  __timezone_ptr_t;
#line 463 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
enum __anonenum_mode_29 {
    m_benchmark = 0,
    m_brute_force = 1,
    m_dictionary = 2
} ;
#line 170 "/usr/include/stdio.h"
extern struct _IO_FILE *stderr ;
#line 237
extern int fclose(FILE *__stream ) ;
#line 272
extern FILE *fopen(char const   * __restrict  __filename , char const   * __restrict  __modes ) ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 531
extern int fgetc(FILE *__stream ) ;
#line 709
extern size_t fread(void * __restrict  __ptr , size_t __size , size_t __n , FILE * __restrict  __stream ) ;
#line 749
extern int fseek(FILE *__stream , long __off , int __whence ) ;
#line 828
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) feof)(FILE *__stream ) ;
#line 543 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 49 "./getopt.h"
extern int optind ;
#line 110
extern int getopt_long(int argc , char * const  *argv , char const   *shortopts ,
                       struct option  const  *longopts , int *longind ) ;
#line 413 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__leaf__)) strerror)(int __errnum ) ;
#line 50 "/usr/include/x86_64-linux-gnu/bits/errno.h"
extern  __attribute__((__nothrow__)) int *( __attribute__((__leaf__)) __errno_location)(void)  __attribute__((__const__)) ;
#line 21 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipinfo.c"
static u32 fgetu32(FILE *f ) 
{ 
  register u32 r ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 25
  tmp = fgetc(f);
#line 25
  r = (u32 )tmp;
#line 26
  tmp___0 = fgetc(f);
#line 26
  r |= (unsigned int )(tmp___0 << 8);
#line 27
  tmp___1 = fgetc(f);
#line 27
  r |= (unsigned int )(tmp___1 << 16);
#line 28
  tmp___2 = fgetc(f);
#line 28
  r |= (unsigned int )(tmp___2 << 24);
  }
#line 30
  return (r);
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipinfo.c"
static u32 fgetu16(FILE *f ) 
{ 
  register u32 r ;
  int tmp ;
  int tmp___0 ;

  {
  {
#line 37
  tmp = fgetc(f);
#line 37
  r = (u32 )tmp;
#line 38
  tmp___0 = fgetc(f);
#line 38
  r |= (unsigned int )(tmp___0 << 8);
  }
#line 40
  return (r);
}
}
#line 43 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipinfo.c"
static void parse_zip(char *path ) 
{ 
  FILE *f ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  u32 id ;
  u32 tmp___2 ;
  u16 version ;
  u32 tmp___3 ;
  u16 flags ;
  u32 tmp___4 ;
  u16 compression_method ;
  u32 tmp___5 ;
  u16 lastmodtime ;
  u32 tmp___6 ;
  u16 lastmoddate ;
  u32 tmp___7 ;
  u32 crc32 ;
  u32 tmp___8 ;
  u32 compr_size ;
  u32 tmp___9 ;
  u32 uncompr_size ;
  u32 tmp___10 ;
  u16 name_len ;
  u32 tmp___11 ;
  u16 extra_field_len ;
  u32 tmp___12 ;
  char zip_path[1024] ;
  u8 file[24] ;
  int tmp___13 ;

  {
  {
#line 45
  tmp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"rb");
#line 45
  f = tmp;
  }
#line 47
  if (! f) {
    {
#line 49
    tmp___0 = __errno_location();
#line 49
    tmp___1 = strerror(*tmp___0);
#line 49
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipping \'%s\': %s\n",
            path, tmp___1);
    }
#line 50
    goto out;
  }
  {
#line 53
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 53
    tmp___13 = feof(f);
    }
#line 53
    if (tmp___13) {
#line 53
      goto while_break;
    }
    {
#line 55
    tmp___2 = fgetu32(f);
#line 55
    id = tmp___2;
    }
#line 57
    if ((unsigned long )id == 67324752UL) {
      {
#line 59
      tmp___3 = fgetu16(f);
#line 59
      version = (u16 )tmp___3;
#line 60
      tmp___4 = fgetu16(f);
#line 60
      flags = (u16 )tmp___4;
#line 61
      tmp___5 = fgetu16(f);
#line 61
      compression_method = (u16 )tmp___5;
#line 62
      tmp___6 = fgetu16(f);
#line 62
      lastmodtime = (u16 )tmp___6;
#line 63
      tmp___7 = fgetu16(f);
#line 63
      lastmoddate = (u16 )tmp___7;
#line 64
      tmp___8 = fgetu32(f);
#line 64
      crc32 = tmp___8;
#line 65
      tmp___9 = fgetu32(f);
#line 65
      compr_size = tmp___9;
#line 66
      tmp___10 = fgetu32(f);
#line 66
      uncompr_size = tmp___10;
#line 67
      tmp___11 = fgetu16(f);
#line 67
      name_len = (u16 )tmp___11;
#line 68
      tmp___12 = fgetu16(f);
#line 68
      extra_field_len = (u16 )tmp___12;
      }
#line 80
      if ((int )name_len < 1024) {
        {
#line 82
        fread((void */* __restrict  */)(zip_path), (size_t )name_len, (size_t )1,
              (FILE */* __restrict  */)f);
#line 83
        zip_path[name_len] = (char)0;
        }
      } else {
        {
#line 87
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filename too long (>1023 bytes), skipping zipfile\n");
        }
#line 88
        goto out;
      }
      {
#line 91
      fseek(f, (long )extra_field_len, 1);
#line 93
      printf((char const   */* __restrict  */)"found file \'%s\', size %ld (%ld)",
             zip_path, (long )uncompr_size, (long )compr_size);
      }
#line 95
      if ((int )flags & 1) {
        {
#line 96
        printf((char const   */* __restrict  */)", encrypted");
        }
      }
#line 98
      if (compr_size >= 23U) {
        {
#line 101
        fread((void */* __restrict  */)(file), (size_t )24, (size_t )1, (FILE */* __restrict  */)f);
#line 103
        printf((char const   */* __restrict  */)"\n%02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
               (int )file[0], (int )file[1], (int )file[2], (int )file[3], (int )file[4],
               (int )file[5], (int )file[6], (int )file[7], (int )file[8], (int )file[9],
               (int )file[10], (int )file[11]);
#line 108
        printf((char const   */* __restrict  */)" : %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x",
               (int )file[12], (int )file[13], (int )file[14], (int )file[15], (int )file[16],
               (int )file[17], (int )file[18], (int )file[19], (int )file[20], (int )file[21],
               (int )file[22], (int )file[23]);
#line 113
        compr_size -= 24U;
        }
      }
      {
#line 116
      printf((char const   */* __restrict  */)"\n");
#line 118
      fseek(f, (long )compr_size, 1);
      }
    } else
#line 120
    if ((unsigned long )id == 134695760UL) {
      {
#line 122
      fseek(f, 12L, 1);
      }
    } else
#line 124
    if (! ((unsigned long )id == 808471376UL)) {
#line 128
      if ((unsigned long )id == 33639248UL) {
#line 130
        goto out;
      } else
#line 128
      if ((unsigned long )id == 101010256UL) {
#line 130
        goto out;
      } else {
        {
#line 134
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found id %08lx, \'%s\' is not a zipfile ver 2.xx, skipping\n",
                (unsigned long )id, path);
        }
#line 136
        goto out;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 141
  fclose(f);
  }
#line 142
  return;
}
}
#line 144 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipinfo.c"
static void usage(int ec ) 
{ 


  {
  {
#line 146
  printf((char const   */* __restrict  */)"\nfcrackzip version 1.0, zipinfo - tell me about a zip file\nwritten by Marc Lehmann <pcg@goof.com> You can find more info on\nhttp://www.goof.com/pcg/marc/\n\nUSAGE: zipinfo file...                the zipfiles to parse\n\n");
#line 155
  exit(ec);
  }
}
}
#line 158 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipinfo.c"
static struct option options[3]  = {      {"help", 0, (int *)0, 'h'}, 
        {"version", 0, (int *)0, 'R'}, 
        {(char const   *)0, 0, (int *)0, 0}};
#line 164 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipinfo.c"
int main(int argc , char **argv ) 
{ 
  int option_index ;
  int c ;

  {
#line 166
  option_index = 0;
  {
#line 169
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 169
    c = getopt_long(argc, (char * const  *)argv, "", (struct option  const  *)(options),
                    & option_index);
    }
#line 169
    if (! (c != -1)) {
#line 169
      goto while_break;
    }
    {
#line 172
    if (c == 104) {
#line 172
      goto case_104;
    }
#line 175
    if (c == 82) {
#line 175
      goto case_82;
    }
#line 170
    goto switch_break;
    case_104: /* CIL Label */ 
    {
#line 173
    usage(0);
    }
#line 174
    goto switch_break;
    case_82: /* CIL Label */ 
    {
#line 176
    printf((char const   */* __restrict  */)"zipinfo version 1.0\n");
#line 177
    exit(0);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 180
  if (optind >= argc) {
    {
#line 182
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"you have to specify one or more zip files (try --help)\n");
#line 183
    exit(1);
    }
  }
  {
#line 186
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 186
    if (! (optind < argc)) {
#line 186
      goto while_break___0;
    }
    {
#line 187
    parse_zip(*(argv + optind));
#line 186
    optind ++;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 189
  return (0);
}
}
#line 169 "/usr/include/stdio.h"
extern struct _IO_FILE *stdout ;
#line 242
extern int fflush(FILE *__stream ) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 425
extern int fscanf(FILE * __restrict  __stream , char const   * __restrict  __format 
                  , ...)  __asm__("__isoc99_fscanf")  ;
#line 846
extern void perror(char const   *__s ) ;
#line 176 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1), __leaf__)) strdup)(char const   *__s )  __attribute__((__malloc__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 7 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
u8 pw[41] ;
#line 8 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
u8 *pw_end  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
u8 bf_next[256]  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
u8 bf_last  ;
#line 26 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
int verbosity  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
u8 files[112]  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
char const   *file_path[8]  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
int file_count  ;
#line 46
method methods[4] ;
#line 47
int default_method ;
#line 10 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.c"
u8 pw[41]  = {      (u8 )'a',      (u8 )'a',      (u8 )'a',      (u8 )'a', 
        (u8 )'a',      (u8 )'a',      (u8 )'\000'};
#line 22 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.c"
static u8 mult_tab[16384]  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.c"
static u32 fgetu32___0(FILE *f ) 
{ 
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;

  {
  {
#line 27
  tmp = fgetc(f);
#line 27
  tmp___0 = fgetc(f);
#line 27
  tmp___1 = fgetc(f);
#line 27
  tmp___2 = fgetc(f);
  }
#line 27
  return ((u32 )(((tmp | (tmp___0 << 8)) | (tmp___1 << 16)) | (tmp___2 << 24)));
}
}
#line 33 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.c"
static u32 fgetu16___0(FILE *f ) 
{ 
  int tmp ;
  int tmp___0 ;

  {
  {
#line 36
  tmp = fgetc(f);
#line 36
  tmp___0 = fgetc(f);
  }
#line 36
  return ((u32 )(tmp | (tmp___0 << 8)));
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.c"
static void load_zip(char const   *path ) 
{ 
  FILE *f ;
  FILE *tmp ;
  int *tmp___0 ;
  char *tmp___1 ;
  u32 id ;
  u32 tmp___2 ;
  u16 version ;
  u32 tmp___3 ;
  u16 flags ;
  u32 tmp___4 ;
  u16 compression_method ;
  u32 tmp___5 ;
  u16 lastmodtime ;
  u32 tmp___6 ;
  u16 lastmoddate ;
  u32 tmp___7 ;
  u32 crc32 ;
  u32 tmp___8 ;
  u32 compr_size ;
  u32 tmp___9 ;
  u32 uncompr_size ;
  u32 tmp___10 ;
  u16 name_len ;
  u32 tmp___11 ;
  u16 extra_field_len ;
  u32 tmp___12 ;
  char zip_path[1024] ;
  u8 *file ;
  char *tmp___13 ;
  int tmp___14 ;

  {
  {
#line 43
  tmp = fopen((char const   */* __restrict  */)path, (char const   */* __restrict  */)"rb");
#line 43
  f = tmp;
  }
#line 45
  if (! f) {
    {
#line 47
    tmp___0 = __errno_location();
#line 47
    tmp___1 = strerror(*tmp___0);
#line 47
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"skipping \'%s\': %s\n",
            path, tmp___1);
    }
#line 48
    return;
  }
  {
#line 51
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    tmp___14 = feof(f);
    }
#line 51
    if (tmp___14) {
#line 51
      goto while_break;
    }
    {
#line 53
    tmp___2 = fgetu32___0(f);
#line 53
    id = tmp___2;
    }
#line 55
    if ((unsigned long )id == 67324752UL) {
      {
#line 57
      tmp___3 = fgetu16___0(f);
#line 57
      version = (u16 )tmp___3;
#line 58
      tmp___4 = fgetu16___0(f);
#line 58
      flags = (u16 )tmp___4;
#line 59
      tmp___5 = fgetu16___0(f);
#line 59
      compression_method = (u16 )tmp___5;
#line 60
      tmp___6 = fgetu16___0(f);
#line 60
      lastmodtime = (u16 )tmp___6;
#line 61
      tmp___7 = fgetu16___0(f);
#line 61
      lastmoddate = (u16 )tmp___7;
#line 62
      tmp___8 = fgetu32___0(f);
#line 62
      crc32 = tmp___8;
#line 63
      tmp___9 = fgetu32___0(f);
#line 63
      compr_size = tmp___9;
#line 64
      tmp___10 = fgetu32___0(f);
#line 64
      uncompr_size = tmp___10;
#line 65
      tmp___11 = fgetu16___0(f);
#line 65
      name_len = (u16 )tmp___11;
#line 66
      tmp___12 = fgetu16___0(f);
#line 66
      extra_field_len = (u16 )tmp___12;
      }
#line 76
      if ((int )name_len < 1024) {
        {
#line 78
        fread((void */* __restrict  */)(zip_path), (size_t )name_len, (size_t )1,
              (FILE */* __restrict  */)f);
#line 79
        zip_path[name_len] = (char)0;
        }
      } else {
        {
#line 83
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"filename too long (>1023 bytes), skipping zipfile\n");
        }
#line 84
        goto out;
      }
      {
#line 87
      fseek(f, (long )extra_field_len, 1);
      }
#line 89
      if ((int )flags & 1) {
#line 91
        if (compr_size >= 12U) {
          {
#line 93
          file = files + 14 * file_count;
#line 94
          fread((void */* __restrict  */)file, (size_t )12, (size_t )1, (FILE */* __restrict  */)f);
          }
#line 96
          if ((int )flags & 8) {
#line 99
            *(file + 12) = (u8 )((int )lastmodtime >> 8);
#line 100
            *(file + 13) = (u8 )lastmodtime;
          } else {
#line 104
            *(file + 12) = (u8 )(crc32 >> 24);
#line 105
            *(file + 13) = (u8 )(crc32 >> 16);
          }
          {
#line 108
          tmp___13 = strdup(path);
#line 108
          file_path[file_count] = (char const   *)tmp___13;
          }
#line 110
          if (verbosity) {
            {
#line 111
            printf((char const   */* __restrict  */)"found file \'%s\', (size cp/uc %6lu/%6lu, flags %lx, chk %02x%02x)\n",
                   zip_path, (unsigned long )compr_size, (unsigned long )uncompr_size,
                   (unsigned long )flags, (int )*(file + 12), (int )*(file + 13));
            }
          }
#line 115
          file_count ++;
#line 115
          if (file_count >= 8) {
#line 117
            if (verbosity) {
              {
#line 118
              printf((char const   */* __restrict  */)"%d file maximum reached, skipping further files\n",
                     8);
              }
            }
#line 120
            goto out;
          }
#line 123
          compr_size -= 12U;
        } else {
          {
#line 127
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"\'%s\' is corrupted, skipping zipfile\n",
                  zip_path);
          }
#line 128
          goto out;
        }
      } else
#line 131
      if (verbosity) {
        {
#line 132
        printf((char const   */* __restrict  */)"\'%s\' is not encrypted, skipping\n",
               zip_path);
        }
      }
      {
#line 134
      fseek(f, (long )compr_size, 1);
      }
    } else
#line 136
    if ((unsigned long )id == 134695760UL) {
      {
#line 138
      fseek(f, 12L, 1);
      }
    } else
#line 140
    if (! ((unsigned long )id == 808471376UL)) {
#line 144
      if ((unsigned long )id == 33639248UL) {
#line 146
        goto out;
      } else
#line 144
      if ((unsigned long )id == 101010256UL) {
#line 146
        goto out;
      } else {
        {
#line 150
        fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"found id %08lx, \'%s\' is not a zipfile ver 2.xx, skipping\n",
                (unsigned long )id, path);
        }
#line 152
        goto out;
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  out: 
  {
#line 157
  fclose(f);
  }
#line 158
  return;
}
}
#line 466 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) malloc)(size_t __size )  __attribute__((__malloc__)) ;
#line 775
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) abs)(int __x )  __attribute__((__const__)) ;
#line 69 "/usr/include/assert.h"
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) __assert_fail)(char const   *__assertion ,
                                                                                                   char const   *__file ,
                                                                                                   unsigned int __line ,
                                                                                                   char const   *__function ) ;
#line 19 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static UI image_width  ;
#line 20 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static UI image_height  ;
#line 21 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static u8 *image_data  ;
#line 22 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static UI transform_width  ;
#line 23 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static UI transform_height  ;
#line 24 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static u8 *transform_data  ;
#line 33 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static UI cp_cells  ;
#line 34 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static cp_cell *cp_trans  ;
#line 35 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static int *cp_table  ;
#line 36 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static UI cp_width  ;
#line 37 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static UI cp_height  ;
#line 54 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static void load_img(char const   *name ) 
{ 
  FILE *img ;
  UI image_depth ;
  void *tmp ;
  int tmp___0 ;
  size_t tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;

  {
#line 60
  if (image_data) {
    {
#line 61
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"cannot load more than one image\n");
    }
  } else {
    {
#line 64
    img = fopen((char const   */* __restrict  */)name, (char const   */* __restrict  */)"rb");
    }
#line 65
    if (img) {
      {
#line 67
      tmp___5 = fscanf((FILE */* __restrict  */)img, (char const   */* __restrict  */)"P6 ");
      }
#line 67
      if (tmp___5 == -1) {
        {
#line 68
        perror("no BINARY PPM header detected");
        }
      } else {
        {
#line 71
        fscanf((FILE */* __restrict  */)img, (char const   */* __restrict  */)"#%*[^\n\r] ");
#line 72
        tmp___4 = fscanf((FILE */* __restrict  */)img, (char const   */* __restrict  */)"%u ",
                         & image_width);
        }
#line 72
        if (tmp___4 != 1) {
          {
#line 73
          fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to read image width\n");
          }
        } else {
          {
#line 76
          fscanf((FILE */* __restrict  */)img, (char const   */* __restrict  */)"#%*[^\n\r] ");
#line 77
          tmp___3 = fscanf((FILE */* __restrict  */)img, (char const   */* __restrict  */)"%u ",
                           & image_height);
          }
#line 77
          if (tmp___3 != 1) {
            {
#line 78
            fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to read image height\n");
            }
          } else {
            {
#line 81
            fscanf((FILE */* __restrict  */)img, (char const   */* __restrict  */)"#%*[^\n\r] ");
#line 82
            tmp___2 = fscanf((FILE */* __restrict  */)img, (char const   */* __restrict  */)"%u%*[ \n\r] ",
                             & image_depth);
            }
#line 82
            if (tmp___2 != 1) {
              {
#line 83
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to read image depth\n");
              }
            } else
#line 86
            if (image_depth != 255U) {
              {
#line 87
              fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"pixel maxval %d (!= 255) is not supported\n",
                      image_depth);
              }
            } else {
              {
#line 90
              tmp = malloc((size_t )((image_width * image_height) * 3U));
#line 90
              image_data = (u8 *)tmp;
              }
#line 91
              if (! image_data) {
                {
#line 92
                fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to allocate memory for image\n");
                }
              } else {
                {
#line 95
                tmp___1 = fread((void */* __restrict  */)image_data, (size_t )((image_width * image_height) * 3U),
                                (size_t )1, (FILE */* __restrict  */)img);
                }
#line 95
                if (tmp___1 != 1UL) {
                  {
#line 96
                  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unable to read image data\n");
                  }
                } else {
#line 100
                  tmp___0 = file_count;
#line 100
                  file_count ++;
#line 100
                  file_path[tmp___0] = name;
                }
              }
            }
          }
        }
        {
#line 107
        fclose(img);
        }
      }
    }
  }
#line 111
  return;
}
}
#line 123 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static u8 cp_key[26]  = 
#line 123
  {      (u8 )16,      (u8 )23,      (u8 )19,      (u8 )21, 
        (u8 )9,      (u8 )8,      (u8 )10,      (u8 )20, 
        (u8 )6,      (u8 )5,      (u8 )22,      (u8 )2, 
        (u8 )13,      (u8 )3,      (u8 )1,      (u8 )4, 
        (u8 )25,      (u8 )12,      (u8 )15,      (u8 )14, 
        (u8 )18,      (u8 )7,      (u8 )11,      (u8 )24, 
        (u8 )17,      (u8 )26};
#line 129 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static int cp_table_lu1[2048]  ;
#line 130 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static int cp_table_lu2[2048]  ;
#line 133 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static void cp_set_pw(u8 *pw___0 , u8 *pw_end___0 ) 
{ 
  u8 *cursor ;
  int i ;
  int j ;
  int x ;
  int y ;
  int len ;
  int *table ;
  cp_cell *trans ;
  int *tmp ;

  {
#line 141
  len = (int )(pw_end___0 - pw___0);
#line 143
  y = 0;
#line 143
  x = y;
#line 143
  i = x;
#line 143
  table = cp_table;
#line 143
  trans = cp_trans;
  {
#line 143
  while (1) {
    while_continue: /* CIL Label */ ;
#line 143
    if (! ((UI )i < cp_cells)) {
#line 143
      goto while_break;
    }
#line 147
    tmp = table;
#line 147
    table ++;
#line 147
    *tmp = -1;
#line 148
    trans->dst_x = (UI )x;
#line 149
    trans->dst_y = (UI )y;
#line 150
    trans->mirror = 0;
#line 151
    trans ++;
#line 153
    x ++;
#line 153
    if ((UI )x == cp_width) {
#line 155
      x = 0;
#line 156
      y ++;
    }
#line 143
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 160
  x = (int )(cp_cells - 1U);
#line 161
  y = (int )((unsigned int )len + cp_cells % (unsigned int )len);
#line 163
  i = 0;
#line 163
  cursor = pw___0;
  {
#line 163
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 163
    if (! ((UI )i < cp_cells)) {
#line 163
      goto while_break___0;
    }
#line 165
    x = ((int )cp_key[(int )*cursor - 65] + x) + y;
#line 167
    cursor ++;
#line 167
    if ((unsigned long )cursor == (unsigned long )pw_end___0) {
#line 168
      cursor = pw___0;
    }
#line 170
    if ((UI )x >= cp_cells) {
#line 171
      x = (int )((UI )x - cp_cells);
    }
#line 173
    if ((UI )x >= cp_cells) {
#line 174
      x = (int )((UI )x - cp_cells);
    }
    {
#line 176
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 176
      if (! (*(cp_table + x) != -1)) {
#line 176
        goto while_break___1;
      }
#line 178
      x ++;
#line 179
      if ((UI )x >= cp_cells) {
#line 180
        x = 0;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 183
    *(cp_table + x) = i;
#line 184
    y ++;
#line 186
    i ++;
#line 186
    if ((UI )i >= cp_cells) {
#line 187
      goto while_break___0;
    }
#line 189
    x = ((int )cp_key[(int )*cursor - 65] + x) + y;
#line 191
    cursor ++;
#line 191
    if ((unsigned long )cursor == (unsigned long )pw_end___0) {
#line 192
      cursor = pw___0;
    }
#line 194
    if ((UI )x >= cp_cells) {
#line 195
      x = (int )((UI )x - cp_cells);
    }
#line 197
    if ((UI )x >= cp_cells) {
#line 198
      x = (int )((UI )x - cp_cells);
    }
    {
#line 200
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 200
      if (! (*(cp_table + x) != -1)) {
#line 200
        goto while_break___2;
      }
#line 202
      if (x == 0) {
#line 203
        x = (int )cp_cells;
      }
#line 205
      x --;
    }
    while_break___2: /* CIL Label */ ;
    }
#line 208
    *(cp_table + x) = i;
#line 209
    y ++;
#line 163
    i ++;
  }
  while_break___0: /* CIL Label */ ;
  }
#line 212
  i = 0;
#line 212
  j = (int )(cp_cells - 1U);
  {
#line 212
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 212
    if (! (i < j)) {
#line 212
      goto while_break___3;
    }
#line 214
    (cp_trans + *(cp_table + i))->dst_x = (UI )cp_table_lu1[j];
#line 215
    (cp_trans + *(cp_table + i))->dst_y = (UI )cp_table_lu2[j];
#line 216
    (cp_trans + *(cp_table + j))->dst_x = (UI )cp_table_lu1[i];
#line 217
    (cp_trans + *(cp_table + j))->dst_y = (UI )cp_table_lu2[i];
#line 219
    if ((*(cp_table + i) ^ *(cp_table + j)) & 1) {
#line 221
      (cp_trans + *(cp_table + i))->mirror = 1;
#line 222
      (cp_trans + *(cp_table + j))->mirror = 1;
    }
#line 212
    i ++;
#line 212
    j --;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 225
  return;
}
}
#line 229 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static void cp_do_mask(void) 
{ 
  UI x ;
  UI y ;
  UI src_x ;
  UI src_y ;
  UI u ;
  UI v ;
  UI dst_x ;
  UI dst_y ;
  UI xx ;
  int rot ;
  cp_cell *cell ;
  u8 *s ;
  u8 *d ;
  u8 *tmp ;
  u8 *tmp___0 ;
  u8 *tmp___1 ;
  u8 *tmp___2 ;
  u8 *tmp___3 ;
  u8 *tmp___4 ;
  u8 *s___0 ;
  u8 *d___0 ;
  u8 *tmp___5 ;
  u8 *tmp___6 ;
  u8 *tmp___7 ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  u8 *s___1 ;
  u8 *d___1 ;
  u8 *tmp___11 ;
  u8 *tmp___12 ;
  u8 *tmp___13 ;
  u8 *tmp___14 ;
  u8 *tmp___15 ;
  u8 *tmp___16 ;
  u8 *s___2 ;
  u8 *d___2 ;
  u8 *tmp___17 ;
  u8 *tmp___18 ;
  u8 *tmp___19 ;
  u8 *tmp___20 ;
  u8 *tmp___21 ;
  u8 *tmp___22 ;
  UI tmp___23 ;
  u8 *s___3 ;
  u8 *d___3 ;
  u8 *tmp___24 ;
  u8 *tmp___25 ;
  u8 *tmp___26 ;
  u8 *tmp___27 ;
  u8 *tmp___28 ;
  u8 *tmp___29 ;
  u8 *s___4 ;
  u8 *d___4 ;
  u8 *tmp___30 ;
  u8 *tmp___31 ;
  u8 *tmp___32 ;
  u8 *tmp___33 ;
  u8 *tmp___34 ;
  u8 *tmp___35 ;
  u8 *s___5 ;
  u8 *d___5 ;
  u8 *tmp___36 ;
  u8 *tmp___37 ;
  u8 *tmp___38 ;
  u8 *tmp___39 ;
  u8 *tmp___40 ;
  u8 *tmp___41 ;
  u8 *s___6 ;
  u8 *d___6 ;
  u8 *tmp___42 ;
  u8 *tmp___43 ;
  u8 *tmp___44 ;
  u8 *tmp___45 ;
  u8 *tmp___46 ;
  u8 *tmp___47 ;
  UI tmp___48 ;

  {
#line 236
  cell = cp_trans;
#line 238
  y = (UI )0;
  {
#line 238
  while (1) {
    while_continue: /* CIL Label */ ;
#line 238
    if (! (y < cp_height)) {
#line 238
      goto while_break;
    }
#line 240
    x = (UI )0;
    {
#line 240
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 240
      if (! (x < cp_width)) {
#line 240
        goto while_break___0;
      }
#line 243
      u = cell->dst_x;
#line 244
      v = cell->dst_y;
#line 245
      rot = cell->mirror;
#line 246
      cell ++;
#line 247
      dst_x = x * 8U;
#line 248
      dst_y = y * 8U;
#line 249
      src_x = u * 8U;
#line 250
      src_y = v * 8U;
#line 261
      if (dst_x + 8U <= transform_width) {
#line 261
        if (dst_y + 8U <= transform_height) {
#line 264
          if (rot) {
#line 267
            xx = (UI )7;
            {
#line 267
            while (1) {
              while_continue___1: /* CIL Label */ ;
#line 267
              tmp___23 = xx;
#line 267
              xx --;
#line 267
              if (! tmp___23) {
#line 267
                goto while_break___1;
              }
              {
#line 269
              while (1) {
                while_continue___2: /* CIL Label */ ;
#line 269
                s = image_data + (src_y * image_width + (src_x + (xx + 1U))) * 3U;
#line 269
                d = transform_data + ((dst_y + (xx + 1U)) * transform_width + dst_x) * 3U;
#line 269
                tmp = d;
#line 269
                d ++;
#line 269
                tmp___0 = s;
#line 269
                s ++;
#line 269
                *tmp = *tmp___0;
#line 269
                tmp___1 = d;
#line 269
                d ++;
#line 269
                tmp___2 = s;
#line 269
                s ++;
#line 269
                *tmp___1 = *tmp___2;
#line 269
                tmp___3 = d;
#line 269
                d ++;
#line 269
                tmp___4 = s;
#line 269
                s ++;
#line 269
                *tmp___3 = *tmp___4;
#line 269
                goto while_break___2;
              }
              while_break___2: /* CIL Label */ ;
              }
              {
#line 270
              while (1) {
                while_continue___3: /* CIL Label */ ;
#line 270
                s___0 = image_data + ((src_y + xx) * image_width + src_x) * 3U;
#line 270
                d___0 = transform_data + (dst_y * transform_width + (dst_x + xx)) * 3U;
#line 270
                tmp___5 = d___0;
#line 270
                d___0 ++;
#line 270
                tmp___6 = s___0;
#line 270
                s___0 ++;
#line 270
                *tmp___5 = *tmp___6;
#line 270
                tmp___7 = d___0;
#line 270
                d___0 ++;
#line 270
                tmp___8 = s___0;
#line 270
                s___0 ++;
#line 270
                *tmp___7 = *tmp___8;
#line 270
                tmp___9 = d___0;
#line 270
                d___0 ++;
#line 270
                tmp___10 = s___0;
#line 270
                s___0 ++;
#line 270
                *tmp___9 = *tmp___10;
#line 270
                goto while_break___3;
              }
              while_break___3: /* CIL Label */ ;
              }
              {
#line 271
              while (1) {
                while_continue___4: /* CIL Label */ ;
#line 271
                s___1 = image_data + ((src_y + 7U) * image_width + (src_x + xx)) * 3U;
#line 271
                d___1 = transform_data + ((dst_y + xx) * transform_width + (dst_x + 7U)) * 3U;
#line 271
                tmp___11 = d___1;
#line 271
                d___1 ++;
#line 271
                tmp___12 = s___1;
#line 271
                s___1 ++;
#line 271
                *tmp___11 = *tmp___12;
#line 271
                tmp___13 = d___1;
#line 271
                d___1 ++;
#line 271
                tmp___14 = s___1;
#line 271
                s___1 ++;
#line 271
                *tmp___13 = *tmp___14;
#line 271
                tmp___15 = d___1;
#line 271
                d___1 ++;
#line 271
                tmp___16 = s___1;
#line 271
                s___1 ++;
#line 271
                *tmp___15 = *tmp___16;
#line 271
                goto while_break___4;
              }
              while_break___4: /* CIL Label */ ;
              }
              {
#line 272
              while (1) {
                while_continue___5: /* CIL Label */ ;
#line 272
                s___2 = image_data + ((src_y + (xx + 1U)) * image_width + (src_x + 7U)) * 3U;
#line 272
                d___2 = transform_data + ((dst_y + 7U) * transform_width + (dst_x + (xx + 1U))) * 3U;
#line 272
                tmp___17 = d___2;
#line 272
                d___2 ++;
#line 272
                tmp___18 = s___2;
#line 272
                s___2 ++;
#line 272
                *tmp___17 = *tmp___18;
#line 272
                tmp___19 = d___2;
#line 272
                d___2 ++;
#line 272
                tmp___20 = s___2;
#line 272
                s___2 ++;
#line 272
                *tmp___19 = *tmp___20;
#line 272
                tmp___21 = d___2;
#line 272
                d___2 ++;
#line 272
                tmp___22 = s___2;
#line 272
                s___2 ++;
#line 272
                *tmp___21 = *tmp___22;
#line 272
                goto while_break___5;
              }
              while_break___5: /* CIL Label */ ;
              }
            }
            while_break___1: /* CIL Label */ ;
            }
          } else {
#line 277
            xx = (UI )8;
            {
#line 277
            while (1) {
              while_continue___6: /* CIL Label */ ;
#line 277
              tmp___48 = xx;
#line 277
              xx --;
#line 277
              if (! tmp___48) {
#line 277
                goto while_break___6;
              }
              {
#line 279
              while (1) {
                while_continue___7: /* CIL Label */ ;
#line 279
                s___3 = image_data + (src_y * image_width + (src_x + (xx + 1U))) * 3U;
#line 279
                d___3 = transform_data + (dst_y * transform_width + (dst_x + (xx + 1U))) * 3U;
#line 279
                tmp___24 = d___3;
#line 279
                d___3 ++;
#line 279
                tmp___25 = s___3;
#line 279
                s___3 ++;
#line 279
                *tmp___24 = *tmp___25;
#line 279
                tmp___26 = d___3;
#line 279
                d___3 ++;
#line 279
                tmp___27 = s___3;
#line 279
                s___3 ++;
#line 279
                *tmp___26 = *tmp___27;
#line 279
                tmp___28 = d___3;
#line 279
                d___3 ++;
#line 279
                tmp___29 = s___3;
#line 279
                s___3 ++;
#line 279
                *tmp___28 = *tmp___29;
#line 279
                goto while_break___7;
              }
              while_break___7: /* CIL Label */ ;
              }
              {
#line 280
              while (1) {
                while_continue___8: /* CIL Label */ ;
#line 280
                s___4 = image_data + ((src_y + xx) * image_width + src_x) * 3U;
#line 280
                d___4 = transform_data + ((dst_y + xx) * transform_width + dst_x) * 3U;
#line 280
                tmp___30 = d___4;
#line 280
                d___4 ++;
#line 280
                tmp___31 = s___4;
#line 280
                s___4 ++;
#line 280
                *tmp___30 = *tmp___31;
#line 280
                tmp___32 = d___4;
#line 280
                d___4 ++;
#line 280
                tmp___33 = s___4;
#line 280
                s___4 ++;
#line 280
                *tmp___32 = *tmp___33;
#line 280
                tmp___34 = d___4;
#line 280
                d___4 ++;
#line 280
                tmp___35 = s___4;
#line 280
                s___4 ++;
#line 280
                *tmp___34 = *tmp___35;
#line 280
                goto while_break___8;
              }
              while_break___8: /* CIL Label */ ;
              }
              {
#line 281
              while (1) {
                while_continue___9: /* CIL Label */ ;
#line 281
                s___5 = image_data + ((src_y + 7U) * image_width + (src_x + xx)) * 3U;
#line 281
                d___5 = transform_data + ((dst_y + 7U) * transform_width + (dst_x + xx)) * 3U;
#line 281
                tmp___36 = d___5;
#line 281
                d___5 ++;
#line 281
                tmp___37 = s___5;
#line 281
                s___5 ++;
#line 281
                *tmp___36 = *tmp___37;
#line 281
                tmp___38 = d___5;
#line 281
                d___5 ++;
#line 281
                tmp___39 = s___5;
#line 281
                s___5 ++;
#line 281
                *tmp___38 = *tmp___39;
#line 281
                tmp___40 = d___5;
#line 281
                d___5 ++;
#line 281
                tmp___41 = s___5;
#line 281
                s___5 ++;
#line 281
                *tmp___40 = *tmp___41;
#line 281
                goto while_break___9;
              }
              while_break___9: /* CIL Label */ ;
              }
              {
#line 282
              while (1) {
                while_continue___10: /* CIL Label */ ;
#line 282
                s___6 = image_data + ((src_y + (xx + 1U)) * image_width + (src_x + 7U)) * 3U;
#line 282
                d___6 = transform_data + ((dst_y + (xx + 1U)) * transform_width + (dst_x + 7U)) * 3U;
#line 282
                tmp___42 = d___6;
#line 282
                d___6 ++;
#line 282
                tmp___43 = s___6;
#line 282
                s___6 ++;
#line 282
                *tmp___42 = *tmp___43;
#line 282
                tmp___44 = d___6;
#line 282
                d___6 ++;
#line 282
                tmp___45 = s___6;
#line 282
                s___6 ++;
#line 282
                *tmp___44 = *tmp___45;
#line 282
                tmp___46 = d___6;
#line 282
                d___6 ++;
#line 282
                tmp___47 = s___6;
#line 282
                s___6 ++;
#line 282
                *tmp___46 = *tmp___47;
#line 282
                goto while_break___10;
              }
              while_break___10: /* CIL Label */ ;
              }
            }
            while_break___6: /* CIL Label */ ;
            }
          }
        }
      }
#line 240
      x ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 238
    y ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 291
  return;
}
}
#line 303 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static void init_cpmask(void) 
{ 
  UI i ;
  void *tmp ;
  void *tmp___0 ;
  void *tmp___1 ;

  {
#line 308
  if (! image_data) {
    {
#line 308
    __assert_fail("image_data", "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c",
                  308U, "init_cpmask");
    }
  }
  {
#line 309
  cp_width = image_width / 8U;
#line 310
  cp_height = image_height / 8U;
#line 311
  cp_cells = cp_width * cp_height;
#line 312
  tmp = malloc(sizeof(int ) * (unsigned long )cp_cells);
#line 312
  cp_table = (int *)tmp;
#line 313
  tmp___0 = malloc(sizeof(cp_cell ) * (unsigned long )cp_cells);
#line 313
  cp_trans = (cp_cell *)tmp___0;
  }
#line 315
  if (cp_width > 2048U) {
    {
#line 317
    printf((char const   */* __restrict  */)"maximum image width in this version is %d\n",
           16384);
#line 318
    exit(1);
    }
  }
#line 321
  i = (UI )0;
  {
#line 321
  while (1) {
    while_continue: /* CIL Label */ ;
#line 321
    if (! (i < 2048U)) {
#line 321
      goto while_break;
    }
#line 323
    cp_table_lu1[i] = (int )(i % cp_width);
#line 324
    cp_table_lu2[i] = (int )(i / cp_width);
#line 321
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 327
  if (image_width < 32U) {
#line 327
    transform_width = image_width;
  } else {
#line 327
    transform_width = (UI )32;
  }
#line 328
  if (image_height < 32U) {
#line 328
    transform_height = image_height;
  } else {
#line 328
    transform_height = (UI )32;
  }
  {
#line 330
  tmp___1 = malloc((size_t )((transform_width * transform_height) * 3U));
#line 330
  transform_data = (u8 *)tmp___1;
  }
#line 331
  return;
}
}
#line 333 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/cpmask.c"
static int crack_cpmask(int (*genfunc)(void) , int (*cbfunc)(char const   * , char const   * ) ) 
{ 
  unsigned long minimum ;
  unsigned long current ;
  int changed ;
  int x ;
  int y ;
  size_t tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;
  int tmp___5 ;
  int tmp___6 ;
  int tmp___7 ;
  char info[80] ;

  {
#line 336
  minimum = (unsigned long )(1 << 31);
#line 338
  changed = -1;
  {
#line 341
  while (1) {
    while_continue: /* CIL Label */ ;
#line 343
    if (changed >= 4) {
#line 343
      if (verbosity) {
        {
#line 344
        printf((char const   */* __restrict  */)"checking pw %s\r", pw);
#line 344
        fflush(stdout);
        }
      }
    }
#line 346
    if (changed < 0) {
      {
#line 347
      tmp = strlen((char const   *)(pw));
#line 347
      pw_end = pw + tmp;
      }
    }
    {
#line 349
    cp_set_pw(pw, pw_end);
#line 350
    cp_do_mask();
#line 353
    current = 0UL;
#line 355
    x = 8;
    }
    {
#line 355
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 355
      if (! ((UI )x < transform_width)) {
#line 355
        goto while_break___0;
      }
#line 356
      y = (int )transform_height;
      {
#line 356
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 356
        tmp___3 = y;
#line 356
        y --;
#line 356
        if (! tmp___3) {
#line 356
          goto while_break___1;
        }
        {
#line 358
        tmp___0 = abs((int )((UI )*(transform_data + ((UI )y * transform_width + (UI )(x - 1)) * 3U) - (UI )*(transform_data + ((UI )y * transform_width + (UI )x) * 3U)));
#line 358
        current += (unsigned long )tmp___0;
#line 359
        tmp___1 = abs((int )((UI )*(transform_data + (((UI )y * transform_width + (UI )(x - 1)) * 3U + 1U)) - (UI )*(transform_data + (((UI )y * transform_width + (UI )x) * 3U + 1U))));
#line 359
        current += (unsigned long )tmp___1;
#line 360
        tmp___2 = abs((int )((UI )*(transform_data + (((UI )y * transform_width + (UI )(x - 1)) * 3U + 2U)) - (UI )*(transform_data + (((UI )y * transform_width + (UI )x) * 3U + 2U))));
#line 360
        current += (unsigned long )tmp___2;
        }
#line 362
        if (current > minimum) {
#line 363
          goto overflow;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
#line 355
      x += 8;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 366
    y = 8;
    {
#line 366
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 366
      if ((UI )y < transform_height) {
#line 366
        if (! (current < minimum)) {
#line 366
          goto while_break___2;
        }
      } else {
#line 366
        goto while_break___2;
      }
#line 367
      x = (int )transform_width;
      {
#line 367
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 367
        tmp___7 = x;
#line 367
        x --;
#line 367
        if (tmp___7) {
#line 367
          if (! (current < minimum)) {
#line 367
            goto while_break___3;
          }
        } else {
#line 367
          goto while_break___3;
        }
        {
#line 369
        tmp___4 = abs((int )((UI )*(transform_data + ((UI )(y - 1) * transform_width + (UI )x) * 3U) - (UI )*(transform_data + ((UI )y * transform_width + (UI )x) * 3U)));
#line 369
        current += (unsigned long )tmp___4;
#line 370
        tmp___5 = abs((int )((UI )*(transform_data + (((UI )(y - 1) * transform_width + (UI )x) * 3U + 1U)) - (UI )*(transform_data + (((UI )y * transform_width + (UI )x) * 3U + 1U))));
#line 370
        current += (unsigned long )tmp___5;
#line 371
        tmp___6 = abs((int )((UI )*(transform_data + (((UI )(y - 1) * transform_width + (UI )x) * 3U + 2U)) - (UI )*(transform_data + (((UI )y * transform_width + (UI )x) * 3U + 2U))));
#line 371
        current += (unsigned long )tmp___6;
        }
#line 373
        if (current > minimum) {
#line 374
          goto overflow;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 366
      y += 8;
    }
    while_break___2: /* CIL Label */ ;
    }
    overflow: 
#line 379
    if (current < minimum) {
      {
#line 383
      minimum = current + 99UL;
#line 385
      sprintf((char */* __restrict  */)(info), (char const   */* __restrict  */)"badness %ld",
              current);
#line 387
      changed = (*cbfunc)((char const   *)(pw), (char const   *)(info));
      }
#line 387
      if (changed) {
#line 388
        return (changed);
      }
    }
    {
#line 341
    changed = (*genfunc)();
    }
#line 341
    if (! changed) {
#line 341
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 394
  return (0);
}
}
#line 6 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crc32.h"
static u32 const   crc_32_tab[256]  = 
#line 6 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crc32.h"
  {      (u32 const   )0UL,      (u32 const   )1996959894UL,      (u32 const   )3993919788UL,      (u32 const   )2567524794UL, 
        (u32 const   )124634137UL,      (u32 const   )1886057615UL,      (u32 const   )3915621685UL,      (u32 const   )2657392035UL, 
        (u32 const   )249268274UL,      (u32 const   )2044508324UL,      (u32 const   )3772115230UL,      (u32 const   )2547177864UL, 
        (u32 const   )162941995UL,      (u32 const   )2125561021UL,      (u32 const   )3887607047UL,      (u32 const   )2428444049UL, 
        (u32 const   )498536548UL,      (u32 const   )1789927666UL,      (u32 const   )4089016648UL,      (u32 const   )2227061214UL, 
        (u32 const   )450548861UL,      (u32 const   )1843258603UL,      (u32 const   )4107580753UL,      (u32 const   )2211677639UL, 
        (u32 const   )325883990UL,      (u32 const   )1684777152UL,      (u32 const   )4251122042UL,      (u32 const   )2321926636UL, 
        (u32 const   )335633487UL,      (u32 const   )1661365465UL,      (u32 const   )4195302755UL,      (u32 const   )2366115317UL, 
        (u32 const   )997073096UL,      (u32 const   )1281953886UL,      (u32 const   )3579855332UL,      (u32 const   )2724688242UL, 
        (u32 const   )1006888145UL,      (u32 const   )1258607687UL,      (u32 const   )3524101629UL,      (u32 const   )2768942443UL, 
        (u32 const   )901097722UL,      (u32 const   )1119000684UL,      (u32 const   )3686517206UL,      (u32 const   )2898065728UL, 
        (u32 const   )853044451UL,      (u32 const   )1172266101UL,      (u32 const   )3705015759UL,      (u32 const   )2882616665UL, 
        (u32 const   )651767980UL,      (u32 const   )1373503546UL,      (u32 const   )3369554304UL,      (u32 const   )3218104598UL, 
        (u32 const   )565507253UL,      (u32 const   )1454621731UL,      (u32 const   )3485111705UL,      (u32 const   )3099436303UL, 
        (u32 const   )671266974UL,      (u32 const   )1594198024UL,      (u32 const   )3322730930UL,      (u32 const   )2970347812UL, 
        (u32 const   )795835527UL,      (u32 const   )1483230225UL,      (u32 const   )3244367275UL,      (u32 const   )3060149565UL, 
        (u32 const   )1994146192UL,      (u32 const   )31158534UL,      (u32 const   )2563907772UL,      (u32 const   )4023717930UL, 
        (u32 const   )1907459465UL,      (u32 const   )112637215UL,      (u32 const   )2680153253UL,      (u32 const   )3904427059UL, 
        (u32 const   )2013776290UL,      (u32 const   )251722036UL,      (u32 const   )2517215374UL,      (u32 const   )3775830040UL, 
        (u32 const   )2137656763UL,      (u32 const   )141376813UL,      (u32 const   )2439277719UL,      (u32 const   )3865271297UL, 
        (u32 const   )1802195444UL,      (u32 const   )476864866UL,      (u32 const   )2238001368UL,      (u32 const   )4066508878UL, 
        (u32 const   )1812370925UL,      (u32 const   )453092731UL,      (u32 const   )2181625025UL,      (u32 const   )4111451223UL, 
        (u32 const   )1706088902UL,      (u32 const   )314042704UL,      (u32 const   )2344532202UL,      (u32 const   )4240017532UL, 
        (u32 const   )1658658271UL,      (u32 const   )366619977UL,      (u32 const   )2362670323UL,      (u32 const   )4224994405UL, 
        (u32 const   )1303535960UL,      (u32 const   )984961486UL,      (u32 const   )2747007092UL,      (u32 const   )3569037538UL, 
        (u32 const   )1256170817UL,      (u32 const   )1037604311UL,      (u32 const   )2765210733UL,      (u32 const   )3554079995UL, 
        (u32 const   )1131014506UL,      (u32 const   )879679996UL,      (u32 const   )2909243462UL,      (u32 const   )3663771856UL, 
        (u32 const   )1141124467UL,      (u32 const   )855842277UL,      (u32 const   )2852801631UL,      (u32 const   )3708648649UL, 
        (u32 const   )1342533948UL,      (u32 const   )654459306UL,      (u32 const   )3188396048UL,      (u32 const   )3373015174UL, 
        (u32 const   )1466479909UL,      (u32 const   )544179635UL,      (u32 const   )3110523913UL,      (u32 const   )3462522015UL, 
        (u32 const   )1591671054UL,      (u32 const   )702138776UL,      (u32 const   )2966460450UL,      (u32 const   )3352799412UL, 
        (u32 const   )1504918807UL,      (u32 const   )783551873UL,      (u32 const   )3082640443UL,      (u32 const   )3233442989UL, 
        (u32 const   )3988292384UL,      (u32 const   )2596254646UL,      (u32 const   )62317068UL,      (u32 const   )1957810842UL, 
        (u32 const   )3939845945UL,      (u32 const   )2647816111UL,      (u32 const   )81470997UL,      (u32 const   )1943803523UL, 
        (u32 const   )3814918930UL,      (u32 const   )2489596804UL,      (u32 const   )225274430UL,      (u32 const   )2053790376UL, 
        (u32 const   )3826175755UL,      (u32 const   )2466906013UL,      (u32 const   )167816743UL,      (u32 const   )2097651377UL, 
        (u32 const   )4027552580UL,      (u32 const   )2265490386UL,      (u32 const   )503444072UL,      (u32 const   )1762050814UL, 
        (u32 const   )4150417245UL,      (u32 const   )2154129355UL,      (u32 const   )426522225UL,      (u32 const   )1852507879UL, 
        (u32 const   )4275313526UL,      (u32 const   )2312317920UL,      (u32 const   )282753626UL,      (u32 const   )1742555852UL, 
        (u32 const   )4189708143UL,      (u32 const   )2394877945UL,      (u32 const   )397917763UL,      (u32 const   )1622183637UL, 
        (u32 const   )3604390888UL,      (u32 const   )2714866558UL,      (u32 const   )953729732UL,      (u32 const   )1340076626UL, 
        (u32 const   )3518719985UL,      (u32 const   )2797360999UL,      (u32 const   )1068828381UL,      (u32 const   )1219638859UL, 
        (u32 const   )3624741850UL,      (u32 const   )2936675148UL,      (u32 const   )906185462UL,      (u32 const   )1090812512UL, 
        (u32 const   )3747672003UL,      (u32 const   )2825379669UL,      (u32 const   )829329135UL,      (u32 const   )1181335161UL, 
        (u32 const   )3412177804UL,      (u32 const   )3160834842UL,      (u32 const   )628085408UL,      (u32 const   )1382605366UL, 
        (u32 const   )3423369109UL,      (u32 const   )3138078467UL,      (u32 const   )570562233UL,      (u32 const   )1426400815UL, 
        (u32 const   )3317316542UL,      (u32 const   )2998733608UL,      (u32 const   )733239954UL,      (u32 const   )1555261956UL, 
        (u32 const   )3268935591UL,      (u32 const   )3050360625UL,      (u32 const   )752459403UL,      (u32 const   )1541320221UL, 
        (u32 const   )2607071920UL,      (u32 const   )3965973030UL,      (u32 const   )1969922972UL,      (u32 const   )40735498UL, 
        (u32 const   )2617837225UL,      (u32 const   )3943577151UL,      (u32 const   )1913087877UL,      (u32 const   )83908371UL, 
        (u32 const   )2512341634UL,      (u32 const   )3803740692UL,      (u32 const   )2075208622UL,      (u32 const   )213261112UL, 
        (u32 const   )2463272603UL,      (u32 const   )3855990285UL,      (u32 const   )2094854071UL,      (u32 const   )198958881UL, 
        (u32 const   )2262029012UL,      (u32 const   )4057260610UL,      (u32 const   )1759359992UL,      (u32 const   )534414190UL, 
        (u32 const   )2176718541UL,      (u32 const   )4139329115UL,      (u32 const   )1873836001UL,      (u32 const   )414664567UL, 
        (u32 const   )2282248934UL,      (u32 const   )4279200368UL,      (u32 const   )1711684554UL,      (u32 const   )285281116UL, 
        (u32 const   )2405801727UL,      (u32 const   )4167216745UL,      (u32 const   )1634467795UL,      (u32 const   )376229701UL, 
        (u32 const   )2685067896UL,      (u32 const   )3608007406UL,      (u32 const   )1308918612UL,      (u32 const   )956543938UL, 
        (u32 const   )2808555105UL,      (u32 const   )3495958263UL,      (u32 const   )1231636301UL,      (u32 const   )1047427035UL, 
        (u32 const   )2932959818UL,      (u32 const   )3654703836UL,      (u32 const   )1088359270UL,      (u32 const   )936918000UL, 
        (u32 const   )2847714899UL,      (u32 const   )3736837829UL,      (u32 const   )1202900863UL,      (u32 const   )817233897UL, 
        (u32 const   )3183342108UL,      (u32 const   )3401237130UL,      (u32 const   )1404277552UL,      (u32 const   )615818150UL, 
        (u32 const   )3134207493UL,      (u32 const   )3453421203UL,      (u32 const   )1423857449UL,      (u32 const   )601450431UL, 
        (u32 const   )3009837614UL,      (u32 const   )3294710456UL,      (u32 const   )1567103746UL,      (u32 const   )711928724UL, 
        (u32 const   )3020668471UL,      (u32 const   )3272380065UL,      (u32 const   )1510334235UL,      (u32 const   )755167117L};
#line 31 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipcrack.c"
static void METHOD1_init_crack_pw(void) 
{ 


  {
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipcrack.c"
static int METHOD1_crack_pw(int (*genfunc)(void) , int (*cbfunc)(char const   * ,
                                                                 char const   * ) ) 
{ 
  int changed ;
  int crack_count ;
  u32 key_stack[123] ;
  unsigned int tmp ;
  u32 *sp ;
  int count ;
  int count2 ;
  u32 key0 ;
  u32 key1 ;
  u32 key2 ;
  u8 *p ;
  u8 *b ;
  size_t tmp___0 ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;
  u32 *tmp___3 ;
  u32 *tmp___4 ;
  u8 *tmp___5 ;
  u32 *tmp___6 ;
  u32 *tmp___7 ;
  u8 target ;
  u8 pre_target ;
  u16 t ;
  u32 kez0 ;
  u32 kez1 ;
  u32 kez2 ;
  u8 *e ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  u8 *tmp___11 ;

  {
#line 42
  changed = -1;
#line 43
  crack_count = 0;
#line 44
  key_stack[0] = (u32 )305419896UL;
#line 44
  key_stack[1] = (u32 )591751049UL;
#line 44
  key_stack[2] = (u32 )878082192UL;
#line 44
  tmp = 3U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (tmp >= 123U) {
#line 44
      goto while_break;
    }
#line 44
    key_stack[tmp] = 0U;
#line 44
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  sp = (u32 *)0;
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    count = file_count;
#line 55
    count2 = 0;
#line 58
    b = files;
#line 60
    if (changed < 0) {
      {
#line 62
      tmp___0 = strlen((char const   *)(pw));
#line 62
      changed = (int )tmp___0;
#line 63
      pw_end = pw + changed;
#line 64
      sp = key_stack + changed * 3;
      }
    }
#line 67
    sp -= changed * 3;
#line 68
    p = pw_end - changed;
#line 70
    crack_count ++;
#line 70
    if (crack_count >= 1000000) {
#line 70
      if (verbosity) {
        {
#line 72
        printf((char const   */* __restrict  */)"checking pw %-40.40s\r", pw);
#line 72
        fflush(stdout);
#line 73
        crack_count = 0;
        }
      }
    }
#line 106
    tmp___1 = sp;
#line 106
    sp ++;
#line 106
    key0 = *tmp___1;
#line 107
    tmp___2 = sp;
#line 107
    sp ++;
#line 107
    key1 = *tmp___2;
#line 108
    tmp___3 = sp;
#line 108
    sp ++;
#line 108
    key2 = *tmp___3;
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 110
      tmp___4 = sp;
#line 110
      sp ++;
#line 110
      tmp___5 = p;
#line 110
      p ++;
#line 110
      key0 = (u32 )(crc_32_tab[(int )((u8 )key0) ^ (int )*tmp___5] ^ (unsigned int const   )(key0 >> 8));
#line 110
      *tmp___4 = key0;
#line 111
      tmp___6 = sp;
#line 111
      sp ++;
#line 111
      key1 = (key1 + (u32 )((u8 )key0)) * 134775813U + 1U;
#line 111
      *tmp___6 = key1;
#line 112
      tmp___7 = sp;
#line 112
      sp ++;
#line 112
      key2 = (u32 )(crc_32_tab[(int )((u8 )key2) ^ (int )((u8 )(key1 >> 24))] ^ (unsigned int const   )(key2 >> 8));
#line 112
      *tmp___7 = key2;
#line 109
      if (! *p) {
#line 109
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 115
    sp -= 3;
    {
#line 118
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 234
      e = (b + 12) - 1;
#line 236
      kez0 = key0;
#line 236
      kez1 = key1;
#line 236
      kez2 = key2;
      {
#line 237
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 242
        t = (u16 )(kez2 | 2U);
#line 243
        tmp___8 = b;
#line 243
        b ++;
#line 243
        pre_target = (u8 )((int )*tmp___8 ^ (int )((u8 )((int )((u16 )((int )t * ((int )t ^ 1))) >> 8)));
#line 245
        kez0 = (u32 )(crc_32_tab[(int )((u8 )kez0) ^ (int )pre_target] ^ (unsigned int const   )(kez0 >> 8));
#line 246
        kez1 = (kez1 + (u32 )((u8 )kez0)) * 134775813U + 1U;
#line 247
        kez2 = (u32 )(crc_32_tab[(int )((u8 )kez2) ^ (int )((u8 )(kez1 >> 24))] ^ (unsigned int const   )(kez2 >> 8));
#line 237
        if (! ((unsigned long )b < (unsigned long )e)) {
#line 237
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 254
      t = (u16 )(kez2 | 2U);
#line 255
      tmp___9 = b;
#line 255
      b ++;
#line 255
      target = (u8 )((int )*tmp___9 ^ (int )((u8 )((int )((u16 )((int )t * ((int )t ^ 1))) >> 8)));
#line 261
      tmp___10 = b;
#line 261
      b ++;
#line 261
      if ((int )target != (int )*tmp___10) {
#line 262
        goto out;
      }
#line 264
      tmp___11 = b;
#line 264
      b ++;
#line 264
      if ((int )pre_target == (int )*tmp___11) {
#line 265
        count2 ++;
      }
#line 118
      count --;
#line 118
      if (! count) {
#line 118
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 269
    changed = (*cbfunc)((char const   *)(pw), (char const   *)0);
    }
#line 269
    if (changed) {
#line 270
      return (changed);
    }
    out: 
    {
#line 52
    changed = (*genfunc)();
    }
#line 52
    if (! changed) {
#line 52
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 276
  return (0);
}
}
#line 31 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipcrack.c"
static void METHOD2_init_crack_pw(void) 
{ 
  u16 t ;

  {
#line 35
  t = (u16 )0;
  {
#line 35
  while (1) {
    while_continue: /* CIL Label */ ;
#line 35
    if (! ((int )t < 16384)) {
#line 35
      goto while_break;
    }
#line 36
    mult_tab[t] = (u8 )((((int )t * 4 + 3) * ((int )t * 4 + 2) >> 8) & 255);
#line 35
    t = (u16 )((int )t + 1);
  }
  while_break: /* CIL Label */ ;
  }
#line 38
  return;
}
}
#line 40 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/zipcrack.c"
static int METHOD2_crack_pw(int (*genfunc)(void) , int (*cbfunc)(char const   * ,
                                                                 char const   * ) ) 
{ 
  int changed ;
  int crack_count ;
  u32 key_stack[123] ;
  unsigned int tmp ;
  u32 *sp ;
  int count ;
  int count2 ;
  u32 key0 ;
  u32 key1 ;
  u32 key2 ;
  u8 *p ;
  u8 *b ;
  size_t tmp___0 ;
  u32 *tmp___1 ;
  u32 *tmp___2 ;
  u32 *tmp___3 ;
  u32 *tmp___4 ;
  u8 *tmp___5 ;
  u32 *tmp___6 ;
  u32 *tmp___7 ;
  u8 target ;
  u8 pre_target ;
  u32 kez0 ;
  u32 kez1 ;
  u32 kez2 ;
  u8 *e ;
  u8 *tmp___8 ;
  u8 *tmp___9 ;
  u8 *tmp___10 ;
  u8 *tmp___11 ;

  {
#line 42
  changed = -1;
#line 43
  crack_count = 0;
#line 44
  key_stack[0] = (u32 )305419896UL;
#line 44
  key_stack[1] = (u32 )591751049UL;
#line 44
  key_stack[2] = (u32 )878082192UL;
#line 44
  tmp = 3U;
  {
#line 44
  while (1) {
    while_continue: /* CIL Label */ ;
#line 44
    if (tmp >= 123U) {
#line 44
      goto while_break;
    }
#line 44
    key_stack[tmp] = 0U;
#line 44
    tmp ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 50
  sp = (u32 *)0;
  {
#line 52
  while (1) {
    while_continue___0: /* CIL Label */ ;
#line 54
    count = file_count;
#line 55
    count2 = 0;
#line 58
    b = files;
#line 60
    if (changed < 0) {
      {
#line 62
      tmp___0 = strlen((char const   *)(pw));
#line 62
      changed = (int )tmp___0;
#line 63
      pw_end = pw + changed;
#line 64
      sp = key_stack + changed * 3;
      }
    }
#line 67
    sp -= changed * 3;
#line 68
    p = pw_end - changed;
#line 70
    crack_count ++;
#line 70
    if (crack_count >= 1000000) {
#line 70
      if (verbosity) {
        {
#line 72
        printf((char const   */* __restrict  */)"checking pw %-40.40s\r", pw);
#line 72
        fflush(stdout);
#line 73
        crack_count = 0;
        }
      }
    }
#line 106
    tmp___1 = sp;
#line 106
    sp ++;
#line 106
    key0 = *tmp___1;
#line 107
    tmp___2 = sp;
#line 107
    sp ++;
#line 107
    key1 = *tmp___2;
#line 108
    tmp___3 = sp;
#line 108
    sp ++;
#line 108
    key2 = *tmp___3;
    {
#line 109
    while (1) {
      while_continue___1: /* CIL Label */ ;
#line 110
      tmp___4 = sp;
#line 110
      sp ++;
#line 110
      tmp___5 = p;
#line 110
      p ++;
#line 110
      key0 = (u32 )(crc_32_tab[(int )((u8 )key0) ^ (int )*tmp___5] ^ (unsigned int const   )(key0 >> 8));
#line 110
      *tmp___4 = key0;
#line 111
      tmp___6 = sp;
#line 111
      sp ++;
#line 111
      key1 = (key1 + (u32 )((u8 )key0)) * 134775813U + 1U;
#line 111
      *tmp___6 = key1;
#line 112
      tmp___7 = sp;
#line 112
      sp ++;
#line 112
      key2 = (u32 )(crc_32_tab[(int )((u8 )key2) ^ (int )((u8 )(key1 >> 24))] ^ (unsigned int const   )(key2 >> 8));
#line 112
      *tmp___7 = key2;
#line 109
      if (! *p) {
#line 109
        goto while_break___1;
      }
    }
    while_break___1: /* CIL Label */ ;
    }
#line 115
    sp -= 3;
    {
#line 118
    while (1) {
      while_continue___2: /* CIL Label */ ;
#line 234
      e = (b + 12) - 1;
#line 236
      kez0 = key0;
#line 236
      kez1 = key1;
#line 236
      kez2 = key2;
      {
#line 237
      while (1) {
        while_continue___3: /* CIL Label */ ;
#line 240
        tmp___8 = b;
#line 240
        b ++;
#line 240
        pre_target = (u8 )((int )*tmp___8 ^ (int )mult_tab[(int )((u16 )kez2) >> 2]);
#line 245
        kez0 = (u32 )(crc_32_tab[(int )((u8 )kez0) ^ (int )pre_target] ^ (unsigned int const   )(kez0 >> 8));
#line 246
        kez1 = (kez1 + (u32 )((u8 )kez0)) * 134775813U + 1U;
#line 247
        kez2 = (u32 )(crc_32_tab[(int )((u8 )kez2) ^ (int )((u8 )(kez1 >> 24))] ^ (unsigned int const   )(kez2 >> 8));
#line 237
        if (! ((unsigned long )b < (unsigned long )e)) {
#line 237
          goto while_break___3;
        }
      }
      while_break___3: /* CIL Label */ ;
      }
#line 252
      tmp___9 = b;
#line 252
      b ++;
#line 252
      target = (u8 )((int )*tmp___9 ^ (int )mult_tab[(int )((u16 )kez2) >> 2]);
#line 261
      tmp___10 = b;
#line 261
      b ++;
#line 261
      if ((int )target != (int )*tmp___10) {
#line 262
        goto out;
      }
#line 264
      tmp___11 = b;
#line 264
      b ++;
#line 264
      if ((int )pre_target == (int )*tmp___11) {
#line 265
        count2 ++;
      }
#line 118
      count --;
#line 118
      if (! count) {
#line 118
        goto while_break___2;
      }
    }
    while_break___2: /* CIL Label */ ;
    }
    {
#line 269
    changed = (*cbfunc)((char const   *)(pw), (char const   *)0);
    }
#line 269
    if (changed) {
#line 270
      return (changed);
    }
    out: 
    {
#line 52
    changed = (*genfunc)();
    }
#line 52
    if (! changed) {
#line 52
      goto while_break___0;
    }
  }
  while_break___0: /* CIL Label */ ;
  }
#line 276
  return (0);
}
}
#line 118 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crackdef.c"
int default_method  =    2;
#line 120 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crackdef.c"
method methods[4]  = {      {(char *)"cpmask", & init_cpmask, & crack_cpmask, & load_img}, 
        {(char *)"zip1", & METHOD1_init_crack_pw, & METHOD1_crack_pw, & load_zip}, 
        {(char *)"zip2, USE_MULT_TAB", & METHOD2_init_crack_pw, & METHOD2_crack_pw, & load_zip}, 
        {(char *)0,
      (void (*)(void))0, (int (*)(int (*)(void) , int (*)(char const   * , char const   * ) ))0,
      (void (*)(char const   * ))0}};
#line 433 "/usr/include/stdio.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) sscanf)(char const   * __restrict  __s ,
                                                                             char const   * __restrict  __format 
                                                                             , ...)  __asm__("__isoc99_sscanf")  ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 717
extern int system(char const   *__command ) ;
#line 35 "./getopt.h"
extern char *optarg ;
#line 71 "/usr/include/x86_64-linux-gnu/sys/time.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) gettimeofday)(struct timeval * __restrict  __tv ,
                                                                                                   __timezone_ptr_t __tz ) ;
#line 66 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) void *( __attribute__((__nonnull__(1), __leaf__)) memset)(void *__s ,
                                                                                               int __c ,
                                                                                               size_t __n ) ;
#line 129
extern  __attribute__((__nothrow__)) char *( __attribute__((__nonnull__(1,2), __leaf__)) strcpy)(char * __restrict  __dest ,
                                                                                                 char const   * __restrict  __src ) ;
#line 147
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strncmp)(char const   *__s1 ,
                                                                                                char const   *__s2 ,
                                                                                                size_t __n )  __attribute__((__pure__)) ;
#line 27 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/crack.h"
int use_unzip  ;
#line 38 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static method *crack_method  =    methods;
#line 39 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int method_number  =    -1;
#line 40 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int min_length  =    -1;
#line 41 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int max_length  =    -1;
#line 42 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int residuent  =    0;
#line 43 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int modul  =    1;
#line 45 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static FILE *dict_file  ;
#line 47 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
char *path_for_shell(char *dest , char const   *str ) 
{ 
  char ch ;
  char *p ;
  size_t len ;
  size_t tmp ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 52
  p = dest;
#line 53
  tmp = strlen(str);
#line 53
  len = tmp;
#line 56
  i = 0;
  }
  {
#line 56
  while (1) {
    while_continue: /* CIL Label */ ;
#line 56
    if (! ((size_t )i < len)) {
#line 56
      goto while_break;
    }
#line 58
    ch = (char )*(str + i);
    {
#line 88
    if ((int )ch == 126) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 125) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 124) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 123) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 96) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 94) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 93) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 92) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 91) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 63) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 62) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 60) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 59) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 58) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 44) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 43) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 42) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 41) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 40) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 39) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 38) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 36) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 35) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 34) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 33) {
#line 88
      goto case_126;
    }
#line 88
    if ((int )ch == 32) {
#line 88
      goto case_126;
    }
#line 93
    goto switch_default;
    case_126: /* CIL Label */ 
    case_125: /* CIL Label */ 
    case_124: /* CIL Label */ 
    case_123: /* CIL Label */ 
    case_96: /* CIL Label */ 
    case_94: /* CIL Label */ 
    case_93: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_91: /* CIL Label */ 
    case_63: /* CIL Label */ 
    case_62: /* CIL Label */ 
    case_60: /* CIL Label */ 
    case_59: /* CIL Label */ 
    case_58: /* CIL Label */ 
    case_44: /* CIL Label */ 
    case_43: /* CIL Label */ 
    case_42: /* CIL Label */ 
    case_41: /* CIL Label */ 
    case_40: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_38: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_35: /* CIL Label */ 
    case_34: /* CIL Label */ 
    case_33: /* CIL Label */ 
    case_32: /* CIL Label */ 
#line 90
    tmp___0 = p;
#line 90
    p ++;
#line 90
    *tmp___0 = (char )'\\';
#line 91
    tmp___1 = p;
#line 91
    p ++;
#line 91
    *tmp___1 = ch;
#line 92
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 94
    tmp___2 = p;
#line 94
    p ++;
#line 94
    *tmp___2 = ch;
    switch_break: /* CIL Label */ ;
    }
#line 56
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 99
  *p = (char )'\000';
#line 101
  return (dest);
}
}
#line 104 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
char *escape_pw(char *dest , char const   *str ) 
{ 
  char ch ;
  char *p ;
  size_t len ;
  size_t tmp ;
  int i ;
  char *tmp___0 ;
  char *tmp___1 ;
  char *tmp___2 ;

  {
  {
#line 109
  p = dest;
#line 110
  tmp = strlen(str);
#line 110
  len = tmp;
#line 113
  i = 0;
  }
  {
#line 113
  while (1) {
    while_continue: /* CIL Label */ ;
#line 113
    if (! ((size_t )i < len)) {
#line 113
      goto while_break;
    }
#line 115
    ch = (char )*(str + i);
    {
#line 124
    if ((int )ch == 96) {
#line 124
      goto case_96;
    }
#line 124
    if ((int )ch == 92) {
#line 124
      goto case_96;
    }
#line 124
    if ((int )ch == 39) {
#line 124
      goto case_96;
    }
#line 124
    if ((int )ch == 36) {
#line 124
      goto case_96;
    }
#line 124
    if ((int )ch == 34) {
#line 124
      goto case_96;
    }
#line 129
    goto switch_default;
    case_96: /* CIL Label */ 
    case_92: /* CIL Label */ 
    case_39: /* CIL Label */ 
    case_36: /* CIL Label */ 
    case_34: /* CIL Label */ 
#line 126
    tmp___0 = p;
#line 126
    p ++;
#line 126
    *tmp___0 = (char )'\\';
#line 127
    tmp___1 = p;
#line 127
    p ++;
#line 127
    *tmp___1 = ch;
#line 128
    goto switch_break;
    switch_default: /* CIL Label */ 
#line 130
    tmp___2 = p;
#line 130
    p ++;
#line 130
    *tmp___2 = ch;
    switch_break: /* CIL Label */ ;
    }
#line 113
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 135
  *p = (char )'\000';
#line 137
  return (dest);
}
}
#line 140 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
int check_unzip(char const   *pw___0 ) 
{ 
  char buff[1024] ;
  char path[1024] ;
  char escpw[256] ;
  int status ;

  {
  {
#line 148
  escape_pw(escpw, pw___0);
#line 149
  path_for_shell(path, file_path[0]);
#line 151
  sprintf((char */* __restrict  */)(buff), (char const   */* __restrict  */)"unzip -qqtP \"%s\" %s >/dev/null 2>&1",
          escpw, path);
#line 153
  status = system((char const   *)(buff));
  }
#line 157
  if (status == 0) {
    {
#line 159
    printf((char const   */* __restrict  */)"\n\nPASSWORD FOUND!!!!: pw == %s\n",
           pw___0);
#line 160
    exit(0);
    }
  }
#line 163
  return (! status);
}
}
#line 168 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int false_callback(char const   *pw___0 , char const   *info ) 
{ 


  {
#line 173
  return (0);
}
}
#line 176 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int true_callback(char const   *pw___0 , char const   *info ) 
{ 


  {
#line 181
  return (1);
}
}
#line 184 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int print_callback(char const   *pw___0 , char const   *info ) 
{ 
  char const   *tmp ;
  int tmp___0 ;

  {
#line 187
  if (! use_unzip) {
#line 187
    goto _L;
  } else {
    {
#line 187
    tmp___0 = check_unzip(pw___0);
    }
#line 187
    if (tmp___0) {
      _L: /* CIL Label */ 
#line 189
      if (info) {
#line 189
        tmp = info;
      } else {
#line 189
        tmp = "";
      }
      {
#line 189
      printf((char const   */* __restrict  */)"possible pw found: %s (%s)\n", pw___0,
             tmp);
      }
    }
  }
#line 193
  return (0);
}
}
#line 196 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int brute_force_gen(void) 
{ 
  u8 *p ;
  u8 o ;

  {
#line 199
  p = pw_end;
  {
#line 201
  while (1) {
    while_continue: /* CIL Label */ ;
#line 203
    p --;
#line 203
    o = *p;
#line 204
    *p = bf_next[o];
#line 205
    if ((int )o != (int )bf_last) {
#line 206
      return ((int )(pw_end - p));
    }
#line 201
    if (! ((unsigned long )p > (unsigned long )(pw))) {
#line 201
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 210
  if (pw_end - pw < (long )max_length) {
#line 212
    pw_end ++;
#line 212
    p = pw_end;
#line 213
    *p = (u8 )0;
    {
#line 215
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 215
      if (! ((unsigned long )p > (unsigned long )(pw))) {
#line 215
        goto while_break___0;
      }
#line 216
      p --;
#line 216
      *p = bf_next[255];
    }
    while_break___0: /* CIL Label */ ;
    }
#line 218
    return (-1);
  } else {
#line 221
    return (0);
  }
}
}
#line 224 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int dictionary_gen(void) 
{ 
  size_t tmp ;
  int tmp___0 ;
  char *tmp___1 ;

  {
  {
#line 231
  tmp___1 = fgets((char */* __restrict  */)(pw), 41, (FILE */* __restrict  */)dict_file);
  }
#line 231
  if (tmp___1) {
    {
#line 233
    tmp = strlen((char const   *)(pw));
#line 233
    pw[tmp - 1UL] = (u8 )0;
    }
#line 234
    return (-1);
  } else {
    {
#line 238
    tmp___0 = feof(dict_file);
    }
#line 238
    if (! tmp___0) {
      {
#line 239
      perror("dictionary_read_next_password");
      }
    }
#line 241
    return (0);
  }
}
}
#line 245 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int validate_gen(void) 
{ 


  {
#line 248
  return (0);
}
}
#line 251 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static void validate(void) 
{ 
  u8 header[15] ;
  int tmp ;

  {
  {
#line 254
  header[0] = (u8 )244;
#line 254
  header[1] = (u8 )40;
#line 254
  header[2] = (u8 )214;
#line 254
  header[3] = (u8 )238;
#line 254
  header[4] = (u8 )215;
#line 254
  header[5] = (u8 )210;
#line 254
  header[6] = (u8 )60;
#line 254
  header[7] = (u8 )26;
#line 254
  header[8] = (u8 )32;
#line 254
  header[9] = (u8 )171;
#line 254
  header[10] = (u8 )223;
#line 254
  header[11] = (u8 )115;
#line 254
  header[12] = (u8 )214;
#line 254
  header[13] = (u8 )186;
#line 254
  header[14] = (u8 )0;
#line 258
  strcpy((char */* __restrict  */)((char *)(files)), (char const   */* __restrict  */)((char *)(header)));
#line 259
  file_count = 1;
  }
#line 261
  if ((int )*(crack_method->desc + 0) == 122) {
    {
#line 263
    (*(crack_method->init_crack_pw))();
#line 265
    strcpy((char */* __restrict  */)(pw), (char const   */* __restrict  */)"Martha");
#line 266
    tmp = (*(crack_method->crack_pw))(& validate_gen, & true_callback);
    }
#line 266
    if (tmp) {
      {
#line 267
      printf((char const   */* __restrict  */)"validate ok (%s == Martha)\n", pw);
      }
    } else {
      {
#line 269
      printf((char const   */* __restrict  */)"validation error (%s != Martha)\n",
             pw);
      }
    }
  } else {
    {
#line 272
    printf((char const   */* __restrict  */)"validate only works for zip methods, use --method to select one.\n");
    }
  }
#line 273
  return;
}
}
#line 275 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static void parse_charset(char *cs ) 
{ 
  u8 chars[800] ;
  u8 map[256] ;
  u8 *p ;
  char *tmp ;
  u8 *tmp___0 ;
  char *tmp___1 ;
  u8 *tmp___2 ;

  {
#line 280
  p = chars;
  {
#line 282
  while (1) {
    while_continue: /* CIL Label */ ;
#line 282
    if (! *cs) {
#line 282
      goto while_break;
    }
#line 283
    tmp = cs;
#line 283
    cs ++;
    {
#line 285
    if ((int )*tmp == 97) {
#line 285
      goto case_97;
    }
#line 290
    if ((int )*tmp == 65) {
#line 290
      goto case_65;
    }
#line 295
    if ((int )*tmp == 49) {
#line 295
      goto case_49;
    }
#line 300
    if ((int )*tmp == 33) {
#line 300
      goto case_33;
    }
#line 305
    if ((int )*tmp == 58) {
#line 305
      goto case_58;
    }
#line 310
    goto switch_default;
    case_97: /* CIL Label */ 
    {
#line 286
    strcpy((char */* __restrict  */)((char *)p), (char const   */* __restrict  */)"abcdefghijklmnopqrstuvwxyz");
#line 287
    p += 26;
    }
#line 288
    goto switch_break;
    case_65: /* CIL Label */ 
    {
#line 291
    strcpy((char */* __restrict  */)((char *)p), (char const   */* __restrict  */)"ABCDEFGHIJKLMNOPQRSTUVWXYZ");
#line 292
    p += 26;
    }
#line 293
    goto switch_break;
    case_49: /* CIL Label */ 
    {
#line 296
    strcpy((char */* __restrict  */)((char *)p), (char const   */* __restrict  */)"0123456789");
#line 297
    p += 10;
    }
#line 298
    goto switch_break;
    case_33: /* CIL Label */ 
    {
#line 301
    strcpy((char */* __restrict  */)((char *)p), (char const   */* __restrict  */)"!:$%&/()=?{[]}+-*~#");
#line 302
    p += 18;
    }
#line 303
    goto switch_break;
    case_58: /* CIL Label */ 
    {
#line 306
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 306
      if (! *cs) {
#line 306
        goto while_break___0;
      }
#line 307
      tmp___0 = p;
#line 307
      p ++;
#line 307
      tmp___1 = cs;
#line 307
      cs ++;
#line 307
      *tmp___0 = (u8 )*tmp___1;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 308
    goto switch_break;
    switch_default: /* CIL Label */ 
    {
#line 311
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"unknown charset specifier, only \'aA1!:\' recognized\n");
#line 312
    exit(1);
    }
    switch_break: /* CIL Label */ ;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 315
  *p = (u8 )0;
#line 317
  p = chars;
#line 318
  tmp___2 = p;
#line 318
  p ++;
#line 318
  bf_last = *tmp___2;
#line 319
  memset((void *)(bf_next), (int )bf_last, sizeof(bf_next));
#line 320
  memset((void *)(map), 0, (size_t )256);
  }
  {
#line 322
  while (1) {
    while_continue___1: /* CIL Label */ ;
#line 322
    if (! *p) {
#line 322
      goto while_break___1;
    }
#line 323
    if (! map[*p]) {
#line 325
      map[*p] = (u8 )1;
#line 326
      bf_next[bf_last] = *p;
#line 327
      bf_last = *p;
    }
#line 322
    p ++;
  }
  while_break___1: /* CIL Label */ ;
  }
#line 330
  bf_next[bf_last] = chars[0];
#line 333
  return;
}
}
#line 335 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int benchmark_count  ;
#line 337 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static int benchmark_gen(void) 
{ 
  int tmp ;

  {
#line 340
  benchmark_count --;
#line 340
  if (! benchmark_count) {
#line 341
    return (0);
  }
  {
#line 343
  tmp = brute_force_gen();
  }
#line 343
  return (tmp);
}
}
#line 346 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static void benchmark(void) 
{ 
  int i ;
  long j ;
  long k ;
  struct timeval tv1 ;
  struct timeval tv2 ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;

  {
  {
#line 354
  while (1) {
    while_continue: /* CIL Label */ ;
#line 356
    i = 0;
    {
#line 356
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 356
      if (! (i < 42)) {
#line 356
        goto while_break___0;
      }
#line 357
      files[i] = (u8 )(i ^ i * 3);
#line 356
      i ++;
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 359
    file_count = 3;
#line 360
    strcpy((char */* __restrict  */)(pw), (char const   */* __restrict  */)"abcdefghij");
#line 361
    parse_charset((char *)"a");
#line 362
    benchmark_count = 5000000;
#line 364
    verbosity = 0;
    }
#line 366
    if (crack_method - methods == (long )default_method) {
#line 366
      tmp = '*';
    } else {
#line 366
      tmp = ' ';
    }
    {
#line 366
    printf((char const   */* __restrict  */)"%c%s: ", tmp, crack_method->desc);
#line 370
    tmp___1 = strncmp("zip", (char const   *)crack_method->desc, (size_t )3);
    }
#line 370
    if (tmp___1) {
      {
#line 371
      printf((char const   */* __restrict  */)"(skipped)");
      }
    } else {
      {
#line 374
      fflush(stdout);
#line 376
      (*(crack_method->init_crack_pw))();
#line 377
      gettimeofday((struct timeval */* __restrict  */)(& tv1), (__timezone_ptr_t )0);
#line 378
      (*(crack_method->crack_pw))(& benchmark_gen, & false_callback);
#line 379
      gettimeofday((struct timeval */* __restrict  */)(& tv2), (__timezone_ptr_t )0);
#line 380
      tv2.tv_sec -= tv1.tv_sec;
#line 381
      tv2.tv_usec -= tv1.tv_usec;
#line 383
      j = tv2.tv_sec * 1000000L + tv2.tv_usec;
#line 384
      k = 5000000L;
#line 386
      printf((char const   */* __restrict  */)"cracks/s = ");
#line 388
      i = 7;
      }
      {
#line 388
      while (1) {
        while_continue___1: /* CIL Label */ ;
#line 388
        tmp___0 = i;
#line 388
        i --;
#line 388
        if (! tmp___0) {
#line 388
          goto while_break___1;
        }
        {
#line 389
        printf((char const   */* __restrict  */)"%ld", k / j);
#line 389
        k = (k - (k / j) * j) * 10L;
        }
      }
      while_break___1: /* CIL Label */ ;
      }
    }
    {
#line 392
    printf((char const   */* __restrict  */)"\n");
#line 393
    crack_method ++;
    }
#line 354
    if (method_number < 0) {
#line 354
      if (! crack_method->desc) {
#line 354
        goto while_break;
      }
    } else {
#line 354
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 400
  return;
}
}
#line 402 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static void usage___0(int ec ) 
{ 
  int tmp ;

  {
  {
#line 405
  printf((char const   */* __restrict  */)"\nfcrackzip version 1.0, a fast/free zip password cracker\nwritten by Marc Lehmann <pcg@goof.com> You can find more info on\nhttp://www.goof.com/pcg/marc/\n\nUSAGE: fcrackzip\n          [-b|--brute-force]            use brute force algorithm\n          [-D|--dictionary]             use a dictionary\n          [-B|--benchmark]              execute a small benchmark\n          [-c|--charset characterset]   use characters from charset\n          [-h|--help]                   show this message\n          [--version]                   show the version of this program\n          [-V|--validate]               sanity-check the algortihm\n          [-v|--verbose]                be more verbose\n          [-p|--init-password string]   use string as initial password/file\n          [-l|--length min-max]         check password with length min to max\n          [-u|--use-unzip]              use unzip to weed out wrong passwords\n          [-m|--method num]             use method number \"num\" (see below)\n          [-2|--modulo r/m]             only calculcate 1/m of the password\n          file...                    the zipfiles to crack\n\n");
#line 428
  printf((char const   */* __restrict  */)"methods compiled in (* = default):\n\n");
#line 429
  crack_method = methods;
  }
  {
#line 429
  while (1) {
    while_continue: /* CIL Label */ ;
#line 429
    if (! crack_method->desc) {
#line 429
      goto while_break;
    }
#line 430
    if (crack_method - methods == (long )default_method) {
#line 430
      tmp = '*';
    } else {
#line 430
      tmp = ' ';
    }
    {
#line 430
    printf((char const   */* __restrict  */)"%c%d: %s\n", tmp, crack_method - methods,
           crack_method->desc);
#line 429
    crack_method ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 435
  printf((char const   */* __restrict  */)"\n");
#line 436
  exit(ec);
  }
}
}
#line 439 "/home/june/repo/benchmarks/collector/temp/fcrackzip-1.0/main.c"
static struct option options___0[14]  = 
#line 439
  {      {"version", 0, (int *)0, 'R'}, 
        {"brute-force", 0, (int *)0, 'b'}, 
        {"dictionary", 0, (int *)0, 'D'}, 
        {"benchmark", 0, (int *)0, 'B'}, 
        {"charset", 1, (int *)0, 'c'}, 
        {"help", 0, (int *)0, 'h'}, 
        {"validate", 0, (int *)0, 'V'}, 
        {"verbose", 0, (int *)0, 'v'}, 
        {"init-password", 1, (int *)0, 'p'}, 
        {"length", 1, (int *)0, 'l'}, 
        {"use-unzip", 0, (int *)0, 'u'}, 
        {"method", 1, (int *)0, 'm'}, 
        {"modulo", 1, (int *)0, 2}, 
        {(char const   *)0, 0, (int *)0, 0}};
