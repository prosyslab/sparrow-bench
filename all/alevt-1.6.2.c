/* Generated by CIL v. 1.7.3 */
/* print_CIL_Input is false */

#line 212 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stddef.h"
typedef unsigned long size_t;
#line 131 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off_t;
#line 132 "/usr/include/x86_64-linux-gnu/bits/types.h"
typedef long __off64_t;
#line 44 "/usr/include/stdio.h"
struct _IO_FILE;
#line 44
struct _IO_FILE;
#line 48 "/usr/include/stdio.h"
typedef struct _IO_FILE FILE;
#line 40 "/usr/lib/gcc/x86_64-linux-gnu/4.8/include/stdarg.h"
typedef __builtin_va_list __gnuc_va_list;
#line 144 "/usr/include/libio.h"
struct _IO_FILE;
#line 154 "/usr/include/libio.h"
typedef void _IO_lock_t;
#line 160 "/usr/include/libio.h"
struct _IO_marker {
   struct _IO_marker *_next ;
   struct _IO_FILE *_sbuf ;
   int _pos ;
};
#line 245 "/usr/include/libio.h"
struct _IO_FILE {
   int _flags ;
   char *_IO_read_ptr ;
   char *_IO_read_end ;
   char *_IO_read_base ;
   char *_IO_write_base ;
   char *_IO_write_ptr ;
   char *_IO_write_end ;
   char *_IO_buf_base ;
   char *_IO_buf_end ;
   char *_IO_save_base ;
   char *_IO_backup_base ;
   char *_IO_save_end ;
   struct _IO_marker *_markers ;
   struct _IO_FILE *_chain ;
   int _fileno ;
   int _flags2 ;
   __off_t _old_offset ;
   unsigned short _cur_column ;
   signed char _vtable_offset ;
   char _shortbuf[1] ;
   _IO_lock_t *_lock ;
   __off64_t _offset ;
   void *__pad1 ;
   void *__pad2 ;
   void *__pad3 ;
   void *__pad4 ;
   size_t __pad5 ;
   int _mode ;
   char _unused2[(15UL * sizeof(int ) - 4UL * sizeof(void *)) - sizeof(size_t )] ;
};
#line 79 "/usr/include/stdio.h"
typedef __gnuc_va_list va_list;
/* compiler builtin: 
   void __builtin_va_start(__builtin_va_list  ) ;  */
#line 168
extern struct _IO_FILE *stdin ;
#line 170
extern struct _IO_FILE *stderr ;
#line 356
extern int fprintf(FILE * __restrict  __stream , char const   * __restrict  __format 
                   , ...) ;
#line 362
extern int printf(char const   * __restrict  __format  , ...) ;
#line 364
extern  __attribute__((__nothrow__)) int sprintf(char * __restrict  __s , char const   * __restrict  __format 
                                                 , ...) ;
#line 371
extern int vfprintf(FILE * __restrict  __s , char const   * __restrict  __format ,
                    __gnuc_va_list __arg ) ;
#line 573
extern int fputc(int __c , FILE *__stream ) ;
#line 622
extern char *fgets(char * __restrict  __s , int __n , FILE * __restrict  __stream ) ;
#line 144 "/usr/include/string.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1,2), __leaf__)) strcmp)(char const   *__s1 ,
                                                                                               char const   *__s2 )  __attribute__((__pure__)) ;
#line 399
extern  __attribute__((__nothrow__)) size_t ( __attribute__((__nonnull__(1), __leaf__)) strlen)(char const   *__s )  __attribute__((__pure__)) ;
#line 147 "/usr/include/stdlib.h"
extern  __attribute__((__nothrow__)) int ( __attribute__((__nonnull__(1), __leaf__)) atoi)(char const   *__nptr )  __attribute__((__pure__)) ;
#line 468
extern  __attribute__((__nothrow__)) void *( __attribute__((__leaf__)) calloc)(size_t __nmemb ,
                                                                               size_t __size )  __attribute__((__malloc__)) ;
#line 543
extern  __attribute__((__nothrow__, __noreturn__)) void ( __attribute__((__leaf__)) exit)(int __status ) ;
#line 79 "/usr/include/ctype.h"
extern  __attribute__((__nothrow__)) unsigned short const   **( __attribute__((__leaf__)) __ctype_b_loc)(void)  __attribute__((__const__)) ;
#line 127
extern  __attribute__((__nothrow__)) int ( __attribute__((__leaf__)) toupper)(int __c ) ;
#line 19 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
int lineno  ;
#line 20 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
char *word[64]  ;
#line 21 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
int nword  ;
#line 23 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
char *font  =    (char *)"font%dx%d";
#line 24 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
int w  ;
#line 24 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
int h  ;
#line 24 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
int bpl  ;
#line 25 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
unsigned char *bmap  ;
#line 27 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
static void error(char *fmt  , ...) 
{ 
  va_list args ;

  {
  {
#line 32
  __builtin_va_start(args, fmt);
#line 33
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)"bdf2xbm");
  }
#line 34
  if (lineno) {
    {
#line 35
    fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)":%d",
            lineno);
    }
  }
  {
#line 36
  fprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)": ");
#line 37
  vfprintf((FILE */* __restrict  */)stderr, (char const   */* __restrict  */)fmt,
           args);
#line 38
  fputc('\n', stderr);
#line 39
  exit(1);
  }
}
}
#line 45 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
static char buf[256]  ;
#line 42 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
static int nextline(void) 
{ 
  char *p ;
  int i ;
  char *tmp ;
  unsigned short const   **tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  unsigned short const   **tmp___3 ;
  char *tmp___4 ;

  {
  {
#line 49
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 51
    nword = 0;
#line 52
    tmp = fgets((char */* __restrict  */)(buf), (int )sizeof(buf), (FILE */* __restrict  */)stdin);
    }
#line 52
    if ((unsigned long )tmp == (unsigned long )((char *)0)) {
#line 53
      return (nword);
    }
#line 54
    lineno ++;
#line 56
    p = buf;
    {
#line 57
    while (1) {
      while_continue___0: /* CIL Label */ ;
      {
#line 59
      while (1) {
        while_continue___1: /* CIL Label */ ;
        {
#line 59
        tmp___0 = __ctype_b_loc();
        }
#line 59
        if (! ((int const   )*(*tmp___0 + (int )*p) & 8192)) {
#line 59
          goto while_break___1;
        }
#line 60
        p ++;
      }
      while_break___1: /* CIL Label */ ;
      }
#line 61
      if ((int )*p == 0) {
#line 62
        goto while_break___0;
      }
#line 63
      tmp___1 = nword;
#line 63
      nword ++;
#line 63
      word[tmp___1] = p;
      {
#line 64
      while (1) {
        while_continue___2: /* CIL Label */ ;
#line 64
        if (*p) {
          {
#line 64
          tmp___3 = __ctype_b_loc();
          }
#line 64
          if ((int const   )*(*tmp___3 + (int )*p) & 8192) {
#line 64
            goto while_break___2;
          }
        } else {
#line 64
          goto while_break___2;
        }
        {
#line 65
        tmp___2 = toupper((int )*p);
#line 65
        *p = (char )tmp___2;
#line 65
        p ++;
        }
      }
      while_break___2: /* CIL Label */ ;
      }
#line 66
      if ((int )*p == 0) {
#line 67
        goto while_break___0;
      }
#line 68
      tmp___4 = p;
#line 68
      p ++;
#line 68
      *tmp___4 = (char)0;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 49
    if (! (nword == 0)) {
#line 49
      goto while_break;
    }
  }
  while_break: /* CIL Label */ ;
  }
#line 72
  i = nword;
  {
#line 72
  while (1) {
    while_continue___3: /* CIL Label */ ;
#line 72
    if (! (i < 64)) {
#line 72
      goto while_break___3;
    }
#line 73
    word[i] = (char *)"";
#line 72
    i ++;
  }
  while_break___3: /* CIL Label */ ;
  }
#line 75
  return (nword);
}
}
#line 78 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
__inline static void setbit(int ch , int x , int y ) 
{ 
  int yo ;
  int xo ;

  {
#line 82
  yo = (ch / 32) * h + y;
#line 83
  xo = (ch % 32) * w + x;
#line 85
  *(bmap + (yo * bpl + xo / 8)) = (unsigned char )((int )*(bmap + (yo * bpl + xo / 8)) | (1 << xo % 8));
#line 86
  return;
}
}
#line 88 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
static void dobitmap(int ch , int x , int y ) 
{ 
  int i ;
  int j ;
  size_t tmp ;
  int c ;

  {
#line 93
  i = 0;
  {
#line 93
  while (1) {
    while_continue: /* CIL Label */ ;
#line 93
    if (! (i < y)) {
#line 93
      goto while_break;
    }
    {
#line 95
    nextline();
    }
#line 96
    if (nword > 1) {
      {
#line 97
      error((char *)"bad BITMAP");
      }
    } else {
      {
#line 96
      tmp = strlen((char const   *)word[0]);
      }
#line 96
      if (tmp != (size_t )(((x + 7) / 8) * 2)) {
        {
#line 97
        error((char *)"bad BITMAP");
        }
      }
    }
#line 98
    j = 0;
    {
#line 98
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 98
      if (! (j < x)) {
#line 98
        goto while_break___0;
      }
#line 100
      c = (int )*(word[0] + j / 4);
#line 101
      if (c >= 48) {
#line 101
        if (c <= 57) {
#line 102
          c -= 48;
        } else {
#line 101
          goto _L;
        }
      } else
      _L: /* CIL Label */ 
#line 103
      if (c >= 65) {
#line 103
        if (c <= 70) {
#line 104
          c -= 55;
        } else {
          {
#line 106
          error((char *)"bad hexchar in BITMAP");
          }
        }
      } else {
        {
#line 106
        error((char *)"bad hexchar in BITMAP");
        }
      }
#line 107
      if (c & (8 >> j % 4)) {
        {
#line 108
        setbit(ch, j, i);
        }
      }
#line 98
      j ++;
    }
    while_break___0: /* CIL Label */ ;
    }
#line 93
    i ++;
  }
  while_break: /* CIL Label */ ;
  }
#line 111
  return;
}
}
#line 113 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
static void dochar(void) 
{ 
  int ch ;
  int x ;
  int y ;
  int tmp ;
  int tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;

  {
#line 116
  ch = -1;
#line 116
  x = -1;
#line 116
  y = -1;
  {
#line 118
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 118
    tmp___3 = nextline();
    }
#line 118
    if (! tmp___3) {
#line 118
      goto while_break;
    }
    {
#line 120
    tmp___2 = strcmp((char const   *)word[0], "ENDCHAR");
    }
#line 120
    if (tmp___2 == 0) {
#line 121
      return;
    } else {
      {
#line 122
      tmp___1 = strcmp((char const   *)word[0], "ENCODING");
      }
#line 122
      if (tmp___1 == 0) {
#line 122
        if (nword == 2) {
          {
#line 124
          ch = atoi((char const   *)word[1]);
          }
#line 125
          if (ch < 0) {
            {
#line 126
            error((char *)"bad character code %d", ch);
            }
          } else
#line 125
          if (ch > 255) {
            {
#line 126
            error((char *)"bad character code %d", ch);
            }
          }
        } else {
#line 122
          goto _L___0;
        }
      } else {
        _L___0: /* CIL Label */ 
        {
#line 128
        tmp___0 = strcmp((char const   *)word[0], "BBX");
        }
#line 128
        if (tmp___0 == 0) {
#line 128
          if (nword == 5) {
            {
#line 130
            x = atoi((char const   *)word[1]);
#line 130
            y = atoi((char const   *)word[2]);
            }
#line 131
            if (x < 1) {
              {
#line 132
              error((char *)"bad BBX (%dx%d)", x, y);
              }
            } else
#line 131
            if (x > 64) {
              {
#line 132
              error((char *)"bad BBX (%dx%d)", x, y);
              }
            } else
#line 131
            if (y < 1) {
              {
#line 132
              error((char *)"bad BBX (%dx%d)", x, y);
              }
            } else
#line 131
            if (y > 64) {
              {
#line 132
              error((char *)"bad BBX (%dx%d)", x, y);
              }
            }
          } else {
#line 128
            goto _L;
          }
        } else {
          _L: /* CIL Label */ 
          {
#line 134
          tmp = strcmp((char const   *)word[0], "BITMAP");
          }
#line 134
          if (tmp == 0) {
#line 136
            if (x < 0) {
              {
#line 137
              error((char *)"missing BBX");
              }
            }
#line 138
            if (ch < 0) {
              {
#line 139
              error((char *)"missing ENDCODING");
              }
            }
            {
#line 140
            dobitmap(ch, x, y);
            }
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 143
  error((char *)"unexpected EOF (missing ENDCHAR)");
  }
#line 144
  return;
}
}
#line 146 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
static void dofile(void) 
{ 
  int tmp ;
  void *tmp___0 ;
  int tmp___1 ;
  int tmp___2 ;
  int tmp___3 ;
  int tmp___4 ;

  {
  {
#line 149
  lineno = 0;
#line 150
  h = 0;
#line 150
  w = h;
#line 151
  bmap = (unsigned char *)0;
#line 153
  nextline();
  }
#line 154
  if (nword != 2) {
    {
#line 155
    error((char *)"not a bdf-file");
    }
  } else {
    {
#line 154
    tmp = strcmp((char const   *)word[0], "STARTFONT");
    }
#line 154
    if (! (tmp == 0)) {
      {
#line 155
      error((char *)"not a bdf-file");
      }
    }
  }
  {
#line 157
  while (1) {
    while_continue: /* CIL Label */ ;
    {
#line 157
    tmp___4 = nextline();
    }
#line 157
    if (! tmp___4) {
#line 157
      goto while_break;
    }
    {
#line 159
    tmp___3 = strcmp((char const   *)word[0], "ENDFONT");
    }
#line 159
    if (tmp___3 == 0) {
#line 160
      return;
    } else {
      {
#line 161
      tmp___2 = strcmp((char const   *)word[0], "FONTBOUNDINGBOX");
      }
#line 161
      if (tmp___2 == 0) {
#line 161
        if (nword == 5) {
#line 163
          if (bmap) {
            {
#line 164
            error((char *)"multiple FONTBOUNDINGBOXes!?!");
            }
          }
          {
#line 165
          w = atoi((char const   *)word[1]);
#line 165
          h = atoi((char const   *)word[2]);
          }
#line 166
          if (w < 1) {
            {
#line 167
            error((char *)"bad bounding box %dx%d\n", w, h);
            }
          } else
#line 166
          if (w > 64) {
            {
#line 167
            error((char *)"bad bounding box %dx%d\n", w, h);
            }
          } else
#line 166
          if (h < 1) {
            {
#line 167
            error((char *)"bad bounding box %dx%d\n", w, h);
            }
          } else
#line 166
          if (h > 64) {
            {
#line 167
            error((char *)"bad bounding box %dx%d\n", w, h);
            }
          }
          {
#line 168
          bpl = (w * 32 + 7) / 8;
#line 169
          tmp___0 = calloc((size_t )1, (size_t )((bpl * h) * 8));
#line 169
          bmap = (unsigned char *)tmp___0;
          }
#line 170
          if ((unsigned long )bmap == (unsigned long )((unsigned char *)0)) {
            {
#line 171
            error((char *)"out of memory");
            }
          }
        } else {
#line 161
          goto _L;
        }
      } else {
        _L: /* CIL Label */ 
        {
#line 174
        tmp___1 = strcmp((char const   *)word[0], "STARTCHAR");
        }
#line 174
        if (tmp___1 == 0) {
#line 176
          if (! bmap) {
            {
#line 177
            error((char *)"no FONTBOUNDINGBOX");
            }
          }
          {
#line 178
          dochar();
          }
        }
      }
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 181
  error((char *)"unexpected EOF (missing ENDFONT)");
  }
#line 182
  return;
}
}
#line 184 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
static void writexbm(void) 
{ 
  char buf___0[256] ;
  int i ;
  int j ;
  unsigned char *p ;
  unsigned char *tmp ;

  {
#line 189
  p = bmap;
#line 191
  if (! bmap) {
#line 192
    return;
  }
  {
#line 194
  sprintf((char */* __restrict  */)(buf___0), (char const   */* __restrict  */)font,
          w, h);
#line 196
  printf((char const   */* __restrict  */)"#define %s_width %d\n", buf___0, 32 * w);
#line 197
  printf((char const   */* __restrict  */)"#define %s_height %d\n", buf___0, 8 * h);
#line 198
  printf((char const   */* __restrict  */)"static unsigned char %s_bits[] = {\n",
         buf___0);
#line 199
  i = 0;
  }
  {
#line 199
  while (1) {
    while_continue: /* CIL Label */ ;
#line 199
    if (! (i < ((16 * h) * w) / 8)) {
#line 199
      goto while_break;
    }
#line 202
    j = 0;
    {
#line 202
    while (1) {
      while_continue___0: /* CIL Label */ ;
#line 202
      if (! (j < 16)) {
#line 202
        goto while_break___0;
      }
      {
#line 203
      tmp = p;
#line 203
      p ++;
#line 203
      printf((char const   */* __restrict  */)"0x%02x,", (int )*tmp);
#line 202
      j ++;
      }
    }
    while_break___0: /* CIL Label */ ;
    }
    {
#line 204
    printf((char const   */* __restrict  */)"\n");
#line 199
    i ++;
    }
  }
  while_break: /* CIL Label */ ;
  }
  {
#line 206
  printf((char const   */* __restrict  */)"};\n");
  }
#line 207
  return;
}
}
#line 209 "/home/june/collector/temp/alevt-1.6.2/bdf2xbm.c"
int main(int argc , char **argv ) 
{ 


  {
#line 212
  if (argc > 1) {
#line 213
    font = *(argv + 1);
  }
  {
#line 214
  dofile();
#line 215
  writexbm();
#line 216
  exit(0);
  }
}
}
